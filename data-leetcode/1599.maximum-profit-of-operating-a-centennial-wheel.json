[
    {
        "title": "The Most Frequently Ordered Products for Each Customer",
        "question_content": null,
        "solutions": [],
        "discussions": [
            {
                "id": 1570447,
                "content": [
                    {
                        "username": "aodish",
                        "content": "with order_counts as (\\nSELECT\\no.customer_id,\\np.product_name,\\np.product_id,\\ncount(o.order_id) as order_count\\nFROM\\norders o\\nINNER JOIN products p ON p.product_id = o.product_id\\nGROUP BY 1,2,3)\\n\\nselect \\noc.customer_id,\\noc.product_id,\\noc.product_name\\nfrom order_counts oc\\nWHERE\\noc.order_count = (select MAX(order_count) from order_counts x where x.customer_id = oc.customer_id)\\n"
                    },
                    {
                        "username": "divy3003",
                        "content": "with ct as (select customer_id, product_id, rank()over(partition by customer_id order by count(product_id) desc) as rnk from orders group by customer_id, product_id)\\nselect c.customer_id, c.product_id, p.product_name\\nfrom ct c left join products p on c.product_id = p.product_id\\nwhere c.rnk = 1;"
                    },
                    {
                        "username": "MelodieHe",
                        "content": "WITH t1 AS (SELECT customer_id, product_id, RANK() OVER (PARTITION BY customer_id ORDER BY COUNT(order_date) DESC) AS rk FROM Orders GROUP BY customer_id, product_id)\\n\\nSELECT t1.customer_id, t1.product_id, P.product_name\\nFROM t1, Products P\\nWHERE rk = 1\\nAND t1.product_id = P.product_id\\nORDER BY t1.customer_id, t1.product_id \\n"
                    },
                    {
                        "username": "vdhyasagr",
                        "content": "A good case where you need to read the question properly. I could swear I read \"most recently\" and not \"most frequently\". That changed the whole dynamic. Straightforward solution otherwise"
                    }
                ]
            },
            {
                "id": 1570376,
                "content": [
                    {
                        "username": "aodish",
                        "content": "with order_counts as (\\nSELECT\\no.customer_id,\\np.product_name,\\np.product_id,\\ncount(o.order_id) as order_count\\nFROM\\norders o\\nINNER JOIN products p ON p.product_id = o.product_id\\nGROUP BY 1,2,3)\\n\\nselect \\noc.customer_id,\\noc.product_id,\\noc.product_name\\nfrom order_counts oc\\nWHERE\\noc.order_count = (select MAX(order_count) from order_counts x where x.customer_id = oc.customer_id)\\n"
                    },
                    {
                        "username": "divy3003",
                        "content": "with ct as (select customer_id, product_id, rank()over(partition by customer_id order by count(product_id) desc) as rnk from orders group by customer_id, product_id)\\nselect c.customer_id, c.product_id, p.product_name\\nfrom ct c left join products p on c.product_id = p.product_id\\nwhere c.rnk = 1;"
                    },
                    {
                        "username": "MelodieHe",
                        "content": "WITH t1 AS (SELECT customer_id, product_id, RANK() OVER (PARTITION BY customer_id ORDER BY COUNT(order_date) DESC) AS rk FROM Orders GROUP BY customer_id, product_id)\\n\\nSELECT t1.customer_id, t1.product_id, P.product_name\\nFROM t1, Products P\\nWHERE rk = 1\\nAND t1.product_id = P.product_id\\nORDER BY t1.customer_id, t1.product_id \\n"
                    },
                    {
                        "username": "vdhyasagr",
                        "content": "A good case where you need to read the question properly. I could swear I read \"most recently\" and not \"most frequently\". That changed the whole dynamic. Straightforward solution otherwise"
                    }
                ]
            },
            {
                "id": 1574582,
                "content": [
                    {
                        "username": "aodish",
                        "content": "with order_counts as (\\nSELECT\\no.customer_id,\\np.product_name,\\np.product_id,\\ncount(o.order_id) as order_count\\nFROM\\norders o\\nINNER JOIN products p ON p.product_id = o.product_id\\nGROUP BY 1,2,3)\\n\\nselect \\noc.customer_id,\\noc.product_id,\\noc.product_name\\nfrom order_counts oc\\nWHERE\\noc.order_count = (select MAX(order_count) from order_counts x where x.customer_id = oc.customer_id)\\n"
                    },
                    {
                        "username": "divy3003",
                        "content": "with ct as (select customer_id, product_id, rank()over(partition by customer_id order by count(product_id) desc) as rnk from orders group by customer_id, product_id)\\nselect c.customer_id, c.product_id, p.product_name\\nfrom ct c left join products p on c.product_id = p.product_id\\nwhere c.rnk = 1;"
                    },
                    {
                        "username": "MelodieHe",
                        "content": "WITH t1 AS (SELECT customer_id, product_id, RANK() OVER (PARTITION BY customer_id ORDER BY COUNT(order_date) DESC) AS rk FROM Orders GROUP BY customer_id, product_id)\\n\\nSELECT t1.customer_id, t1.product_id, P.product_name\\nFROM t1, Products P\\nWHERE rk = 1\\nAND t1.product_id = P.product_id\\nORDER BY t1.customer_id, t1.product_id \\n"
                    },
                    {
                        "username": "vdhyasagr",
                        "content": "A good case where you need to read the question properly. I could swear I read \"most recently\" and not \"most frequently\". That changed the whole dynamic. Straightforward solution otherwise"
                    }
                ]
            },
            {
                "id": 1901712,
                "content": [
                    {
                        "username": "aodish",
                        "content": "with order_counts as (\\nSELECT\\no.customer_id,\\np.product_name,\\np.product_id,\\ncount(o.order_id) as order_count\\nFROM\\norders o\\nINNER JOIN products p ON p.product_id = o.product_id\\nGROUP BY 1,2,3)\\n\\nselect \\noc.customer_id,\\noc.product_id,\\noc.product_name\\nfrom order_counts oc\\nWHERE\\noc.order_count = (select MAX(order_count) from order_counts x where x.customer_id = oc.customer_id)\\n"
                    },
                    {
                        "username": "divy3003",
                        "content": "with ct as (select customer_id, product_id, rank()over(partition by customer_id order by count(product_id) desc) as rnk from orders group by customer_id, product_id)\\nselect c.customer_id, c.product_id, p.product_name\\nfrom ct c left join products p on c.product_id = p.product_id\\nwhere c.rnk = 1;"
                    },
                    {
                        "username": "MelodieHe",
                        "content": "WITH t1 AS (SELECT customer_id, product_id, RANK() OVER (PARTITION BY customer_id ORDER BY COUNT(order_date) DESC) AS rk FROM Orders GROUP BY customer_id, product_id)\\n\\nSELECT t1.customer_id, t1.product_id, P.product_name\\nFROM t1, Products P\\nWHERE rk = 1\\nAND t1.product_id = P.product_id\\nORDER BY t1.customer_id, t1.product_id \\n"
                    },
                    {
                        "username": "vdhyasagr",
                        "content": "A good case where you need to read the question properly. I could swear I read \"most recently\" and not \"most frequently\". That changed the whole dynamic. Straightforward solution otherwise"
                    }
                ]
            }
        ]
    },
    {
        "title": "Build Binary Expression Tree From Infix Expression",
        "question_content": null,
        "solutions": [],
        "discussions": [
            {
                "id": 1837823,
                "content": [
                    {
                        "username": "coderinterview",
                        "content": "For the test case : \"(1/2/3)\"\\nExpected output is : [/,/,3,1,2]\\nMy output is : [/,1,/,null,null,2,3]\\nWhen my output is traversed in-order, same string is generated with operands in same order.\\nSo, why is it considered wrong ans?\\nMy Code:\\n```\\n/**\\n * Definition for a binary tree node.\\n * struct Node {\\n *     char val;\\n *     Node *left;\\n *     Node *right;\\n *     Node() : val(\\' \\'), left(nullptr), right(nullptr) {}\\n *     Node(char x) : val(x), left(nullptr), right(nullptr) {}\\n *     Node(char x, Node *left, Node *right) : val(x), left(left), right(right) {}\\n * };\\n */\\nclass Solution {\\npublic:\\n    int rank(char c){\\n        if(c == \\'+\\') return 1;\\n        else if(c == \\'-\\') return 2;\\n        else if(c == \\'/\\') return 3;\\n        else if (c == \\'*\\') return 4;\\n        return 5;\\n    }\\n    Node* solve(string &s,int l,int r){\\n        if(l>r) return nullptr;\\n        int mino=l;      \\n        int ob=0;\\n        for(int i=l;i<=r;i++){\\n            if(s[i] == \\'(\\') ob++;\\n            else if(s[i] == \\')\\') ob--;\\n            else if(rank(s[i]) < rank(s[mino]) && ob == 0) mino=i;\\n            \\n        }\\n        if(mino == l && r-l != 0){\\n            ob=-1;\\n            for(int i=l;i<=r;i++){\\n                if(s[i] == \\'(\\') ob++;\\n                else if(s[i] == \\')\\') ob--;\\n                else if(rank(s[i]) < rank(s[mino]) && ob == 0) mino=i;    \\n            }\\n            l++;\\n            r--;\\n        }\\n        Node *t = new Node(s[mino]);\\n        t->left = solve(s,l,mino-1);\\n        t->right = solve(s,mino+1,r);\\n        return t;\\n    }\\n    Node* expTree(string s) {\\n        Node *ans = solve(s,0,s.length()-1);\\n        return ans;\\n    }\\n};\\n```"
                    },
                    {
                        "username": "ndrwknsh",
                        "content": "I had the same problem in my code.\\n\\nThe output [/,1,/,null,null,2,3] is actually equivalent to \"1/(2/3)\"."
                    }
                ]
            }
        ]
    },
    {
        "title": "Crawler Log Folder",
        "question_content": "<p>The Leetcode file system keeps a log each time some user performs a <em>change folder</em> operation.</p>\n\n<p>The operations are described below:</p>\n\n<ul>\n\t<li><code>&quot;../&quot;</code> : Move to the parent folder of the current folder. (If you are already in the main folder, <strong>remain in the same folder</strong>).</li>\n\t<li><code>&quot;./&quot;</code> : Remain in the same folder.</li>\n\t<li><code>&quot;x/&quot;</code> : Move to the child folder named <code>x</code> (This folder is <strong>guaranteed to always exist</strong>).</li>\n</ul>\n\n<p>You are given a list of strings <code>logs</code> where <code>logs[i]</code> is the operation performed by the user at the <code>i<sup>th</sup></code> step.</p>\n\n<p>The file system starts in the main folder, then the operations in <code>logs</code> are performed.</p>\n\n<p>Return <em>the minimum number of operations needed to go back to the main folder after the change folder operations.</em></p>\n\n<p>&nbsp;</p>\n<p><strong class=\"example\">Example 1:</strong></p>\n\n<p><img alt=\"\" src=\"https://assets.leetcode.com/uploads/2020/09/09/sample_11_1957.png\" style=\"width: 775px; height: 151px;\" /></p>\n\n<pre>\n<strong>Input:</strong> logs = [&quot;d1/&quot;,&quot;d2/&quot;,&quot;../&quot;,&quot;d21/&quot;,&quot;./&quot;]\n<strong>Output:</strong> 2\n<strong>Explanation: </strong>Use this change folder operation &quot;../&quot; 2 times and go back to the main folder.\n</pre>\n\n<p><strong class=\"example\">Example 2:</strong></p>\n\n<p><img alt=\"\" src=\"https://assets.leetcode.com/uploads/2020/09/09/sample_22_1957.png\" style=\"width: 600px; height: 270px;\" /></p>\n\n<pre>\n<strong>Input:</strong> logs = [&quot;d1/&quot;,&quot;d2/&quot;,&quot;./&quot;,&quot;d3/&quot;,&quot;../&quot;,&quot;d31/&quot;]\n<strong>Output:</strong> 3\n</pre>\n\n<p><strong class=\"example\">Example 3:</strong></p>\n\n<pre>\n<strong>Input:</strong> logs = [&quot;d1/&quot;,&quot;../&quot;,&quot;../&quot;,&quot;../&quot;]\n<strong>Output:</strong> 0\n</pre>\n\n<p>&nbsp;</p>\n<p><strong>Constraints:</strong></p>\n\n<ul>\n\t<li><code>1 &lt;= logs.length &lt;= 10<sup>3</sup></code></li>\n\t<li><code>2 &lt;= logs[i].length &lt;= 10</code></li>\n\t<li><code>logs[i]</code> contains lowercase English letters, digits, <code>&#39;.&#39;</code>, and <code>&#39;/&#39;</code>.</li>\n\t<li><code>logs[i]</code> follows the format described in the statement.</li>\n\t<li>Folder names consist of lowercase English letters and digits.</li>\n</ul>\n",
        "solutions": [
            {
                "id": 866374,
                "title": "java-simple-o-n-loop",
                "content": "```\\n    public int minOperations(String[] logs) {\\n        int res = 0;\\n        for (String s : logs) {\\n            if (s.equals(\"../\")) res = Math.max(0, --res);\\n            else if (s.equals(\"./\")) continue;\\n            else res++;\\n        }\\n        return res;\\n    }\\n```",
                "solutionTags": [],
                "code": "```\\n    public int minOperations(String[] logs) {\\n        int res = 0;\\n        for (String s : logs) {\\n            if (s.equals(\"../\")) res = Math.max(0, --res);\\n            else if (s.equals(\"./\")) continue;\\n            else res++;\\n        }\\n        return res;\\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 868439,
                "title": "c-check-for-and",
                "content": "Check whether we go back (`\"../\"`), stay (`\"./\"`) or deeper (otherwise), and update the number of `steps`.\\n```cpp\\nint minOperations(vector<string>& logs, int steps = 0) {\\n    for (auto log : logs)\\n        if (log == \"../\")\\n            steps = max(0, steps - 1);\\n        else if (log != \"./\")\\n            ++steps;\\n    return steps;\\n}\\n```",
                "solutionTags": [],
                "code": "```cpp\\nint minOperations(vector<string>& logs, int steps = 0) {\\n    for (auto log : logs)\\n        if (log == \"../\")\\n            steps = max(0, steps - 1);\\n        else if (log != \"./\")\\n            ++steps;\\n    return steps;\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 866622,
                "title": "java-python-3-count-the-depth-of-the-folders",
                "content": "```java\\n    public int minOperations(String[] logs) {\\n        int depth = 0;\\n        for (String log : logs) {\\n            if (log.equals(\"../\")) {\\n                depth = Math.max(0, --depth);\\n            }else if (!log.equals(\"./\")) {\\n                ++depth;\\n            }\\n        }\\n        return depth;\\n    }\\n```\\n```python\\n    def minOperations(self, logs: List[str]) -> int:\\n        depth = 0\\n        for log in logs:\\n            if log == \\'../\\':\\n                depth = max(0, depth - 1)\\n            elif log != \\'./\\':\\n                depth += 1\\n        return depth\\n```\\n1 liner - credit to **@blue_sky5**\\n```python\\n    def minOperations(self, logs: List[str]) -> int:\\n        return functools.reduce(lambda depth, folder: max(0, depth - 1) if folder == \\'../\\' else depth + (folder != \\'./\\'), logs, 0)\\n```\\nImproved by **@StefanPochmann**:\\nRefer to the [hint](https://leetcode.com/problems/crawler-log-folder/discuss/866374/Java-Simple-O(N)-loop/779657).\\n```java\\n    public int minOperations(String[] logs) {\\n        return Arrays.stream(logs)\\n                     .mapToInt(log -> log.lastIndexOf(\".\"))\\n                     .reduce(0, (depth, index) -> Math.max(0, depth - index));  \\n    }\\n```\\n```python\\n    def minOperations(self, logs: List[str]) -> int:\\n        return functools.reduce(lambda depth, folder: max(0, depth - folder.rfind(\\'.\\')), logs, 0)\\n```",
                "solutionTags": [],
                "code": "```java\\n    public int minOperations(String[] logs) {\\n        int depth = 0;\\n        for (String log : logs) {\\n            if (log.equals(\"../\")) {\\n                depth = Math.max(0, --depth);\\n            }else if (!log.equals(\"./\")) {\\n                ++depth;\\n            }\\n        }\\n        return depth;\\n    }\\n```\n```python\\n    def minOperations(self, logs: List[str]) -> int:\\n        depth = 0\\n        for log in logs:\\n            if log == \\'../\\':\\n                depth = max(0, depth - 1)\\n            elif log != \\'./\\':\\n                depth += 1\\n        return depth\\n```\n```python\\n    def minOperations(self, logs: List[str]) -> int:\\n        return functools.reduce(lambda depth, folder: max(0, depth - 1) if folder == \\'../\\' else depth + (folder != \\'./\\'), logs, 0)\\n```\n```java\\n    public int minOperations(String[] logs) {\\n        return Arrays.stream(logs)\\n                     .mapToInt(log -> log.lastIndexOf(\".\"))\\n                     .reduce(0, (depth, index) -> Math.max(0, depth - index));  \\n    }\\n```\n```python\\n    def minOperations(self, logs: List[str]) -> int:\\n        return functools.reduce(lambda depth, folder: max(0, depth - folder.rfind(\\'.\\')), logs, 0)\\n```",
                "codeTag": "Python3"
            },
            {
                "id": 1239366,
                "title": "shortest-c-stack-solution-100-faster",
                "content": "```\\nclass Solution\\n{\\npublic:\\n    int minOperations(vector<string> &logs)\\n    {\\n        stack<string> st;\\n        for (string &s : logs)\\n        {\\n            if (s == \"../\")\\n            {\\n                if(!st.empty())\\n                    st.pop();\\n            }\\n            else if (s == \"./\")\\n                continue;\\n            else\\n                st.push(s);\\n        }\\n        return st.size();\\n    }\\n};\\n```\\n\\n\\nIf this solution helped you in any way, then please hit the upvote button.\\nAlso, let me know if you face trouble understanding it.",
                "solutionTags": [
                    "C",
                    "Stack"
                ],
                "code": "```\\nclass Solution\\n{\\npublic:\\n    int minOperations(vector<string> &logs)\\n    {\\n        stack<string> st;\\n        for (string &s : logs)\\n        {\\n            if (s == \"../\")\\n            {\\n                if(!st.empty())\\n                    st.pop();\\n            }\\n            else if (s == \"./\")\\n                continue;\\n            else\\n                st.push(s);\\n        }\\n        return st.size();\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1046552,
                "title": "java-o-n-stack",
                "content": "```\\nclass Solution {\\n    public int minOperations(String[] logs) {\\n         var stack = new Stack<String>();\\n        for(var log : logs){\\n            if(log.equals(\"../\")){\\n                if(!stack.empty())\\n                    stack.pop();\\n            }else if(log.equals(\"./\")){\\n\\n            }else{\\n                stack.push(log);\\n            }\\n        }\\n        return stack.size();\\n    }\\n}",
                "solutionTags": [
                    "Java",
                    "Stack"
                ],
                "code": "class Solution {\\n    public int minOperations(String[] logs) {\\n         var stack = new Stack<String>();\\n        for(var log : logs){\\n            if(log.equals(\"../\")){\\n                if(!stack.empty())\\n                    stack.pop();\\n            }",
                "codeTag": "Java"
            },
            {
                "id": 866343,
                "title": "python3-straightforward",
                "content": "\\n```\\nclass Solution:\\n    def minOperations(self, logs: List[str]) -> int:\\n        ans = 0\\n        for log in logs: \\n            if log == \"./\": continue\\n            elif log == \"../\": ans = max(0, ans-1) # parent directory\\n            else: ans += 1 # child directory \\n        return ans \\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def minOperations(self, logs: List[str]) -> int:\\n        ans = 0\\n        for log in logs: \\n            if log == \"./\": continue\\n            elif log == \"../\": ans = max(0, ans-1) # parent directory\\n            else: ans += 1 # child directory \\n        return ans \\n```",
                "codeTag": "Java"
            },
            {
                "id": 866722,
                "title": "faster-than-100-00-using-stack-and-without-stack-2-ways",
                "content": "```\\n//1.using stack\\nclass Solution {\\npublic:\\n    int minOperations(vector<string>& logs) {\\n\\t\\n        if(logs.size()==0) return 0;\\n\\t\\t\\n        stack<string> st;\\n        for(auto x: logs){\\n            if (x[0] != \\'.\\')  //Move to the child folder so add children\\n                st.push(x);\\n            else if(x==\"../\"){ // Move to the parent folder of the current folder so pop\\n                 if(!st.empty())  st.pop(); \\n                 else continue; //don\\u2019t move the pointer beyond the main folder.\\n            }\\n        }\\n        return st.size();\\n    }\\n};\\n//2.\\nclass Solution {\\npublic:\\n    int minOperations(vector<string>& logs) {\\n         int ans = 0;\\n        for (string log : logs) {\\n            if (log == \"../\") { // go deeper\\n                ans--; \\n                ans = max(ans, 0);\\n            } else if (log != \"./\") // one level up\\n\\t\\t\\t   ans++; \\n        }\\n        return ans;\\n    }\\n};\\n//3.\\nclass Solution {\\npublic:\\n    int minOperations(vector<string>& logs) {\\n        int res = 0;\\n        for (string s : logs) {\\n            if (s==\"../\") res = max(0, --res);\\n            else if (s==\"./\") continue;\\n            else res++;\\n        }\\n        return res;\\n    }\\n};\\n```\\n**Feel free to ask any question in the comment section.**\\nI hope that you\\'ve found the solution useful.\\nIn that case, **please do upvote and encourage me** to on my quest to document all leetcode problems\\uD83D\\uDE03\\nHappy Coding :)\\n",
                "solutionTags": [
                    "C++",
                    "C"
                ],
                "code": "```\\n//1.using stack\\nclass Solution {\\npublic:\\n    int minOperations(vector<string>& logs) {\\n\\t\\n        if(logs.size()==0) return 0;\\n\\t\\t\\n        stack<string> st;\\n        for(auto x: logs){\\n            if (x[0] != \\'.\\')  //Move to the child folder so add children\\n                st.push(x);\\n            else if(x==\"../\"){ // Move to the parent folder of the current folder so pop\\n                 if(!st.empty())  st.pop(); \\n                 else continue; //don\\u2019t move the pointer beyond the main folder.\\n            }\\n        }\\n        return st.size();\\n    }\\n};\\n//2.\\nclass Solution {\\npublic:\\n    int minOperations(vector<string>& logs) {\\n         int ans = 0;\\n        for (string log : logs) {\\n            if (log == \"../\") { // go deeper\\n                ans--; \\n                ans = max(ans, 0);\\n            } else if (log != \"./\") // one level up\\n\\t\\t\\t   ans++; \\n        }\\n        return ans;\\n    }\\n};\\n//3.\\nclass Solution {\\npublic:\\n    int minOperations(vector<string>& logs) {\\n        int res = 0;\\n        for (string s : logs) {\\n            if (s==\"../\") res = max(0, --res);\\n            else if (s==\"./\") continue;\\n            else res++;\\n        }\\n        return res;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 871751,
                "title": "java-100-0ms-no-string-compares-explanation",
                "content": "Start at ```level = 0``` in the folder structure.  Move up or down levels in the folder structure, using 3 cases:\\n\\n1. \\t```\"../\"```  Move down a level toward the root:  Level-1, but not below zero.\\n2. \\t```\"./\"```  Do nothing.\\n3. \\t```\"text/\"```  Move upward in the folder structure:  Level+1\\n\\nTo decide on which case, for case 1. if the second character is a ```\\'.\\'``` then move down a level.  Else to decide between case 2. and case 3., if the first character is not a ```\\'.\\'``` then move up a level.  This method uses character comparisons instead of string comparisons, because usually ```char``` operations are faster than ```String``` operations.\\n\\nWhen done with all the folder strings, the resultant ```level``` number is the *number of operations needed to go back to the main folder* which was requested in the problem description.\\n```\\nclass Solution {\\n    public int minOperations(String[] logs) {\\n        int level = 0;\\n        for (String s : logs) {\\n            if (s.charAt(1) == \\'.\\')\\n                level = Math.max(0, level - 1);\\n            else if (s.charAt(0) != \\'.\\')\\n                level++;\\n        }\\n        return level;\\n    }\\n}\\n```\\n\\n**Or using ternary comparisons:**\\n```\\nclass Solution {\\n    public int minOperations(String[] logs) {\\n        int level = 0;\\n        for (String s : logs)\\n            level = (s.charAt(1) == \\'.\\') ? Math.max(0, level-1) : (s.charAt(0) != \\'.\\') ? level+1 : level;\\n        return level;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```level = 0```\n```\"../\"```\n```\"./\"```\n```\"text/\"```\n```\\'.\\'```\n```\\'.\\'```\n```char```\n```String```\n```level```\n```\\nclass Solution {\\n    public int minOperations(String[] logs) {\\n        int level = 0;\\n        for (String s : logs) {\\n            if (s.charAt(1) == \\'.\\')\\n                level = Math.max(0, level - 1);\\n            else if (s.charAt(0) != \\'.\\')\\n                level++;\\n        }\\n        return level;\\n    }\\n}\\n```\n```\\nclass Solution {\\n    public int minOperations(String[] logs) {\\n        int level = 0;\\n        for (String s : logs)\\n            level = (s.charAt(1) == \\'.\\') ? Math.max(0, level-1) : (s.charAt(0) != \\'.\\') ? level+1 : level;\\n        return level;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2102858,
                "title": "python-super-easy-python-solution",
                "content": "```\\nclass Solution:\\n    def minOperations(self, logs: List[str]) -> int:\\n        res = 0\\n        \\n        for i in logs:\\n            if i == \\'../\\' and res > 0:\\n                res -= 1\\n            elif i != \\'./\\' and i != \\'../\\':\\n                res += 1\\n                \\n        return res\\n```",
                "solutionTags": [
                    "Python",
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def minOperations(self, logs: List[str]) -> int:\\n        res = 0\\n        \\n        for i in logs:\\n            if i == \\'../\\' and res > 0:\\n                res -= 1\\n            elif i != \\'./\\' and i != \\'../\\':\\n                res += 1\\n                \\n        return res\\n```",
                "codeTag": "Java"
            },
            {
                "id": 866491,
                "title": "without-using-stack-o-1-space-complexity",
                "content": "```\\n    public int MinOperations(string[] logs) {\\n        int count = 0;\\n        \\n        foreach(string log in logs){\\n            if(log == \"../\"){\\n                if(count != 0){\\n                    count--;\\n                }\\n            }\\n            else if(log != \"./\"){\\n                count++;\\n            }\\n        }\\n        \\n        return count;\\n    }\\n```",
                "solutionTags": [],
                "code": "```\\n    public int MinOperations(string[] logs) {\\n        int count = 0;\\n        \\n        foreach(string log in logs){\\n            if(log == \"../\"){\\n                if(count != 0){\\n                    count--;\\n                }\\n            }\\n            else if(log != \"./\"){\\n                count++;\\n            }\\n        }\\n        \\n        return count;\\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 866446,
                "title": "python-easy-using-stack",
                "content": "```\\n        if not logs:\\n            return 0\\n        \\n        stk = []\\n        \\n        for log in logs:\\n            if log == \\'../\\':\\n                if stk:\\n                    stk.pop()\\n            elif log == \\'./\\':\\n                continue\\n            else:\\n                stk.append(log)\\n        \\n        return len(stk)\\n```",
                "solutionTags": [
                    "Python",
                    "Python3"
                ],
                "code": "```\\n        if not logs:\\n            return 0\\n        \\n        stk = []\\n        \\n        for log in logs:\\n            if log == \\'../\\':\\n                if stk:\\n                    stk.pop()\\n            elif log == \\'./\\':\\n                continue\\n            else:\\n                stk.append(log)\\n        \\n        return len(stk)\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3403932,
                "title": "c-implementation",
                "content": "# Complexity\\n- Time complexity: $$O(n)$$\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: $$O(1)$$\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int minOperations(vector<string>& logs) {\\n        int cnt=0;\\n        for (int i=0; i<logs.size(); i++){\\n            if (logs[i]==\"../\"){\\n                if (cnt>0)cnt--;\\n            }\\n            else if (logs[i]==\"./\"){\\n                // do nothing\\n            }\\n            else{\\n                cnt++;\\n            }\\n        }\\n        return cnt;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int minOperations(vector<string>& logs) {\\n        int cnt=0;\\n        for (int i=0; i<logs.size(); i++){\\n            if (logs[i]==\"../\"){\\n                if (cnt>0)cnt--;\\n            }\\n            else if (logs[i]==\"./\"){\\n                // do nothing\\n            }\\n            else{\\n                cnt++;\\n            }\\n        }\\n        return cnt;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3193850,
                "title": "easy-python-solution-using-stacks",
                "content": "# Code\\n```\\nclass Solution:\\n    def minOperations(self, logs: List[str]) -> int:\\n        stack=[]\\n        for i in logs:\\n            if i==\"./\":\\n                continue\\n            elif stack and i==\"../\":\\n                stack.pop()\\n            elif i!=\\'../\\':\\n                stack.append(i)\\n        return len(stack)\\n```",
                "solutionTags": [
                    "Python3",
                    "Array",
                    "Stack"
                ],
                "code": "```\\nclass Solution:\\n    def minOperations(self, logs: List[str]) -> int:\\n        stack=[]\\n        for i in logs:\\n            if i==\"./\":\\n                continue\\n            elif stack and i==\"../\":\\n                stack.pop()\\n            elif i!=\\'../\\':\\n                stack.append(i)\\n        return len(stack)\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2507874,
                "title": "intuitive-code-and-easily-understandable-in-python",
                "content": "```\\nclass Solution:\\n    def minOperations(self, logs: List[str]) -> int:\\n        res = 0\\n        for i in logs:\\n            if i == \\'./\\':\\n                continue\\n            elif i == \\'../\\':\\n                if res > 0:\\n                    res -= 1\\n            else:\\n                res += 1\\n        return res\\n```",
                "solutionTags": [
                    "Python",
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def minOperations(self, logs: List[str]) -> int:\\n        res = 0\\n        for i in logs:\\n            if i == \\'./\\':\\n                continue\\n            elif i == \\'../\\':\\n                if res > 0:\\n                    res -= 1\\n            else:\\n                res += 1\\n        return res\\n```",
                "codeTag": "Java"
            },
            {
                "id": 866466,
                "title": "javascript-stack",
                "content": "```\\n/**\\n * @param {string[]} logs\\n * @return {number}\\n */\\nvar minOperations = function(logs) {\\n    let stack = []\\n    for (const log of logs){\\n        if (log === \"../\"){\\n            stack.pop();\\n        } else if (log !== \"./\"){\\n            stack.push(log);\\n        }\\n    }\\n    return stack.length;\\n};\\n```",
                "solutionTags": [],
                "code": "```\\n/**\\n * @param {string[]} logs\\n * @return {number}\\n */\\nvar minOperations = function(logs) {\\n    let stack = []\\n    for (const log of logs){\\n        if (log === \"../\"){\\n            stack.pop();\\n        } else if (log !== \"./\"){\\n            stack.push(log);\\n        }\\n    }\\n    return stack.length;\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2453034,
                "title": "js-runtime-92-91-memory-100-00",
                "content": "```\\nvar minOperations = function(logs) {\\n\\tlet level = 0;\\n\\tfor (let i = 0; i < logs.length; i++) {\\n\\t\\tif (logs[i] === \\'./\\') continue;\\n\\t\\tif (logs[i] !== \\'../\\') level++;\\n\\t\\telse level = Math.max(0, level-1);\\n\\t}\\n\\treturn level\\n};\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\nvar minOperations = function(logs) {\\n\\tlet level = 0;\\n\\tfor (let i = 0; i < logs.length; i++) {\\n\\t\\tif (logs[i] === \\'./\\') continue;\\n\\t\\tif (logs[i] !== \\'../\\') level++;\\n\\t\\telse level = Math.max(0, level-1);\\n\\t}\\n\\treturn level\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1903453,
                "title": "python3-solution-using-stacks",
                "content": "```\\nclass Solution:\\n    def minOperations(self, logs: List[str]) -> int:\\n        m=\\'../\\'\\n        r=\\'./\\'\\n\\t\\t#create an empty stack\\n        stk=[]\\n\\t\\t#iterate through the list\\n        for i in logs:\\n\\t\\t\\t#if Move to the parent folder (../) operator occurs and stack is not empty, pop element from stack\\n            if(i==m):\\n                if(len(stk)>0):\\n                    stk.pop()\\n\\t\\t\\t#else if Remain in the same folder (./) operator occurs, do nothing and move to next element in list\\n            elif(i==r):\\n                continue\\n\\t\\t\\t#else add element to the stack\\n            else:\\n                stk.append(i)\\n\\t\\t#now return the size of the stack which would be the minimum number of operations needed to go back to the main folder\\n        return(len(stk))\\n\\t\\t```",
                "solutionTags": [
                    "Python",
                    "Stack"
                ],
                "code": "```\\nclass Solution:\\n    def minOperations(self, logs: List[str]) -> int:\\n        m=\\'../\\'\\n        r=\\'./\\'\\n\\t\\t#create an empty stack\\n        stk=[]\\n\\t\\t#iterate through the list\\n        for i in logs:\\n\\t\\t\\t#if Move to the parent folder (../) operator occurs and stack is not empty, pop element from stack\\n            if(i==m):\\n                if(len(stk)>0):\\n                    stk.pop()\\n\\t\\t\\t#else if Remain in the same folder (./) operator occurs, do nothing and move to next element in list\\n            elif(i==r):\\n                continue\\n\\t\\t\\t#else add element to the stack\\n            else:\\n                stk.append(i)\\n\\t\\t#now return the size of the stack which would be the minimum number of operations needed to go back to the main folder\\n        return(len(stk))\\n\\t\\t```",
                "codeTag": "Java"
            },
            {
                "id": 1529675,
                "title": "c-2-approach-1-with-extra-space-2-without-extra-space",
                "content": "#### WITH EXTRA SPACE \\n```\\nclass Solution {\\npublic:\\n    int minOperations(vector<string>& logs) \\n    {\\n         stack<string> st;\\n        \\n        for(int i=0;i<logs.size();i++)\\n        {\\n            if(!st.empty() && logs[i] == \"../\")\\n            {\\n                st.pop();\\n            }\\n            else if(st.empty() && logs[i] == \"../\")\\n            {\\n                continue;\\n            }\\n            else if(logs[i] == \"./\")\\n            {\\n                continue;\\n            }\\n            else \\n            {\\n                st.push(logs[i]);\\n            }\\n        }\\n        return st.size();\\n       \\n    }\\n};\\n```\\n**WITHOUT USING EXTRA SPACE** \\n```\\nclass Solution {\\npublic:\\n    int minOperations(vector<string>& logs) \\n    {\\n        int count = 0;\\n        for(int i=0;i<logs.size();i++)\\n        {\\n            if(logs[i] != \"./\")\\n            {\\n                if(logs[i] == \"../\")\\n                {\\n                    if(count > 0)\\n                    {\\n                        count--;\\n                    }\\n                    \\n                }\\n                else\\n                {\\n                    count++;\\n                }\\n            }\\n            \\n        }\\n        return count;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int minOperations(vector<string>& logs) \\n    {\\n         stack<string> st;\\n        \\n        for(int i=0;i<logs.size();i++)\\n        {\\n            if(!st.empty() && logs[i] == \"../\")\\n            {\\n                st.pop();\\n            }\\n            else if(st.empty() && logs[i] == \"../\")\\n            {\\n                continue;\\n            }\\n            else if(logs[i] == \"./\")\\n            {\\n                continue;\\n            }\\n            else \\n            {\\n                st.push(logs[i]);\\n            }\\n        }\\n        return st.size();\\n       \\n    }\\n};\\n```\n```\\nclass Solution {\\npublic:\\n    int minOperations(vector<string>& logs) \\n    {\\n        int count = 0;\\n        for(int i=0;i<logs.size();i++)\\n        {\\n            if(logs[i] != \"./\")\\n            {\\n                if(logs[i] == \"../\")\\n                {\\n                    if(count > 0)\\n                    {\\n                        count--;\\n                    }\\n                    \\n                }\\n                else\\n                {\\n                    count++;\\n                }\\n            }\\n            \\n        }\\n        return count;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1359182,
                "title": "two-simple-java-solutions",
                "content": "Intuition:\\nThere can be three kind of strings possible in logs:\\n\"./\", \"../\", \"d/\"\\nFirst Type  \"./\" :  In this type we don\\'t need to move anywhere so don\\'t do anything.\\nSecond Type \"../\": In this type we need to go back to previous directory so remove last entry from stack(if stack contains any entry).\\nThird Type \"d/\":  In this type we need to move to next directory so push new entry into stack.\\nIn the end return the position of final directory from root directory which is the size of stack.\\n\\nSolution 1 using stack:\\n\\n```\\nclass Solution {\\n    public int minOperations(String[] logs) {\\n        Stack<String> s= new Stack<>();\\n        for(String log : logs) {\\n            if(log.charAt(1)==\\'.\\' && !s.isEmpty())  // pop only when \"../\" log is there and there should be some entry in stack.\\n                s.pop();\\n            else if(log.charAt(0)!=\\'/\\' && log.charAt(0)!=\\'.\\') //directory name can be anything so check for two conditions\\n                s.push(log);\\n        }\\n        return s.size();\\n    }\\n}\\n```\\n\\n\\n\\n\\nSolution 2: using single variable \\n\\nYou can replace stack with simple variable. When you need to push new directory then just increment variable and when you need to pop then just decrement that variable. finally return the final directory position from root directory.\\n\\n```\\nclass Solution {\\n    public int minOperations(String[] logs) {\\n        int res=0;\\n        for(String log : logs) {\\n            if(log.charAt(1)==\\'.\\' && res>0)\\n                res--;\\n            else if(log.charAt(0)!=\\'/\\' && log.charAt(0)!=\\'.\\')\\n                res++;\\n        }\\n        return res;\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    public int minOperations(String[] logs) {\\n        Stack<String> s= new Stack<>();\\n        for(String log : logs) {\\n            if(log.charAt(1)==\\'.\\' && !s.isEmpty())  // pop only when \"../\" log is there and there should be some entry in stack.\\n                s.pop();\\n            else if(log.charAt(0)!=\\'/\\' && log.charAt(0)!=\\'.\\') //directory name can be anything so check for two conditions\\n                s.push(log);\\n        }\\n        return s.size();\\n    }\\n}\\n```\n```\\nclass Solution {\\n    public int minOperations(String[] logs) {\\n        int res=0;\\n        for(String log : logs) {\\n            if(log.charAt(1)==\\'.\\' && res>0)\\n                res--;\\n            else if(log.charAt(0)!=\\'/\\' && log.charAt(0)!=\\'.\\')\\n                res++;\\n        }\\n        return res;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1346322,
                "title": "java-0ms-100-fast-and-easy-to-understand-solution",
                "content": "Basic idea is to maintain depth of the current folder w.r.t. main folder.\\nAs there are only 3 types of command then interpret and manipulate(+1, -1, 0) depth accordingly.\\n**Type 1** \"./\" : Depth will be same \\n**Type 2** \"../\" : Decrease depth value by 1\\n**Type 3** \"x/\" : Increase depth value by 1\\n\\n```\\npublic int minOperations(String[] logs) {\\n        int depth = 0;\\n        for (String cmd : logs) {\\n            depth += interpretCurrentCMD(cmd);\\n            depth = depth < 0 ? 0 : depth;\\n            //Above condition will keep pointer in \\n            //same folder if already in the main folder\\n        }\\n        return depth;\\n    }\\n\\n    private int interpretCurrentCMD(String cmd) {\\n        // CMD Type \"./\"\\n        if (cmd.equals(\"./\")) {\\n            return 0;\\n        }\\n\\n        // CMD Type \"../\"\\n        if (cmd.equals(\"../\")) {\\n            return -1;\\n        }\\n\\n        // CMD Type \"x/\"\\n        return 1;\\n    }\\n```\\nPlease do upvote if you liked the solution or comment incase any doubt :)",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\npublic int minOperations(String[] logs) {\\n        int depth = 0;\\n        for (String cmd : logs) {\\n            depth += interpretCurrentCMD(cmd);\\n            depth = depth < 0 ? 0 : depth;\\n            //Above condition will keep pointer in \\n            //same folder if already in the main folder\\n        }\\n        return depth;\\n    }\\n\\n    private int interpretCurrentCMD(String cmd) {\\n        // CMD Type \"./\"\\n        if (cmd.equals(\"./\")) {\\n            return 0;\\n        }\\n\\n        // CMD Type \"../\"\\n        if (cmd.equals(\"../\")) {\\n            return -1;\\n        }\\n\\n        // CMD Type \"x/\"\\n        return 1;\\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1331526,
                "title": "easy-python-solution",
                "content": "```\\nclass Solution:\\n    def minOperations(self, logs: List[str]) -> int:\\n        s = []\\n        for i in range(len(logs)):\\n            if logs[i] == \"../\":\\n                if len(s) == 0:\\n                    continue\\n                else:\\n                    s.pop(-1)\\n            elif logs[i] == \"./\":\\n                continue\\n            else:\\n                s.append(1)\\n        return len(s)\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution:\\n    def minOperations(self, logs: List[str]) -> int:\\n        s = []\\n        for i in range(len(logs)):\\n            if logs[i] == \"../\":\\n                if len(s) == 0:\\n                    continue\\n                else:\\n                    s.pop(-1)\\n            elif logs[i] == \"./\":\\n                continue\\n            else:\\n                s.append(1)\\n        return len(s)\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3536067,
                "title": "java-simple-approach",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n**O(n)**\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\n    public int minOperations(String[] logs) {\\n\\n      \\n\\t\\tList<String> folder = new ArrayList<>();\\n\\n        for(int i=0;i<logs.length;i++)\\n        {\\n            if(logs[i].equals(\"./\"))\\n            {\\n                continue;\\n            }\\n            else if(logs[i].equals(\"../\"))\\n            {\\n            \\tif(folder.size()>1)\\n                folder.remove(folder.size()-1);\\n            \\telse\\n            \\t\\tfolder.clear();\\n            }\\n            else\\n            folder.add(logs[i]);\\n        }\\n\\n        return folder.size();\\n\\t}\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int minOperations(String[] logs) {\\n\\n      \\n\\t\\tList<String> folder = new ArrayList<>();\\n\\n        for(int i=0;i<logs.length;i++)\\n        {\\n            if(logs[i].equals(\"./\"))\\n            {\\n                continue;\\n            }\\n            else if(logs[i].equals(\"../\"))\\n            {\\n            \\tif(folder.size()>1)\\n                folder.remove(folder.size()-1);\\n            \\telse\\n            \\t\\tfolder.clear();\\n            }\\n            else\\n            folder.add(logs[i]);\\n        }\\n\\n        return folder.size();\\n\\t}\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3361090,
                "title": "crawler-log-folder-solution-in-c",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\nO(n)\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\nO(1)\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int minOperations(vector<string>& logs) {\\n        int i, count=0;\\n        for(i=0 ; i<logs.size() ; i++)\\n        {\\n            if(logs[i]==\"../\" && count>0)\\n                count--;\\n            else if(logs[i]!=\"./\" && logs[i]!=\"../\")\\n                count++;\\n        }\\n        return count;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int minOperations(vector<string>& logs) {\\n        int i, count=0;\\n        for(i=0 ; i<logs.size() ; i++)\\n        {\\n            if(logs[i]==\"../\" && count>0)\\n                count--;\\n            else if(logs[i]!=\"./\" && logs[i]!=\"../\")\\n                count++;\\n        }\\n        return count;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3194915,
                "title": "reduce-switch-case-solution",
                "content": "# Code\\n```\\n/**\\n * @param {string[]} logs\\n * @return {number}\\n */\\nvar minOperations = function(logs) {\\n    return logs.reduce((acc, log) => {\\n        switch (log) {\\n            case \\'../\\':\\n                return Math.max(acc - 1, 0);\\n            case \\'./\\':\\n                return acc;\\n            default:\\n                return acc + 1;\\n        }\\n    }, 0);\\n};\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\n/**\\n * @param {string[]} logs\\n * @return {number}\\n */\\nvar minOperations = function(logs) {\\n    return logs.reduce((acc, log) => {\\n        switch (log) {\\n            case \\'../\\':\\n                return Math.max(acc - 1, 0);\\n            case \\'./\\':\\n                return acc;\\n            default:\\n                return acc + 1;\\n        }\\n    }, 0);\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3037519,
                "title": "python-solution-with-one-pass",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nIterate through the logs, \\n- if there are two dots and the steps is greater than zero, then step decreases by 1\\n- if there is only one dot, steps doesn\\' change\\n- if it\\'s a folder, steps increase by 1\\n\\n\\n\\n# Complexity\\n- Time complexity: `O(n)`\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: `O(1)`\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```python\\nclass Solution:\\n    def minOperations(self, logs: List[str]) -> int:\\n        steps = 0\\n        for log in logs:\\n            if \"..\" in log:\\n                steps -= steps > 0\\n            elif \".\" in log:\\n                continue\\n            else:\\n                steps += 1\\n        return steps if steps > 0 else 0\\n```\\n\\nOr using `match`\\n\\n```python\\nclass Solution:\\n    def minOperations(self, logs: List[str]) -> int:\\n        steps = 0\\n        for log in logs:\\n            match log.split(\"/\")[0]:\\n                case \"..\":\\n                    steps -= steps > 0\\n                case \".\":\\n                    continue\\n                case d:\\n                    steps += 1\\n        return steps if steps > 0 else 0\\n```\\n\\n**Please upvote if you found if helpful.**",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```python\\nclass Solution:\\n    def minOperations(self, logs: List[str]) -> int:\\n        steps = 0\\n        for log in logs:\\n            if \"..\" in log:\\n                steps -= steps > 0\\n            elif \".\" in log:\\n                continue\\n            else:\\n                steps += 1\\n        return steps if steps > 0 else 0\\n```\n```python\\nclass Solution:\\n    def minOperations(self, logs: List[str]) -> int:\\n        steps = 0\\n        for log in logs:\\n            match log.split(\"/\")[0]:\\n                case \"..\":\\n                    steps -= steps > 0\\n                case \".\":\\n                    continue\\n                case d:\\n                    steps += 1\\n        return steps if steps > 0 else 0\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2961942,
                "title": "100-faster-java-solution-easy-and-simple",
                "content": "\\n\\n# Code\\n```\\nclass Solution {\\n    public int minOperations(String[] logs) {\\n        int count=0;\\n        for(int i=0;i<logs.length;i++){\\n            if(logs[i].startsWith(\"..\")) count--;\\n            else if(logs[i].startsWith(\"./\")) continue;\\n            else count++;\\n\\n            if(count < 0) count =0;\\n        }\\n\\n        return count<0? 0 : count;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int minOperations(String[] logs) {\\n        int count=0;\\n        for(int i=0;i<logs.length;i++){\\n            if(logs[i].startsWith(\"..\")) count--;\\n            else if(logs[i].startsWith(\"./\")) continue;\\n            else count++;\\n\\n            if(count < 0) count =0;\\n        }\\n\\n        return count<0? 0 : count;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2838141,
                "title": "java-easy-peasy-lemon-squeezy-solution",
                "content": "# Code\\n```\\nclass Solution {\\n    public int minOperations(String[] logs) {\\n        int count = 0;\\n        for (String move : logs) {\\n            switch (move) {\\n                case \"../\": {\\n                    if (count > 0)\\n                        count--;\\n                    break;\\n                }\\n                case \"./\": {\\n                    break;\\n                }\\n                default: {\\n                    count++;\\n                }\\n            }\\n        }\\n        return count;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int minOperations(String[] logs) {\\n        int count = 0;\\n        for (String move : logs) {\\n            switch (move) {\\n                case \"../\": {\\n                    if (count > 0)\\n                        count--;\\n                    break;\\n                }\\n                case \"./\": {\\n                    break;\\n                }\\n                default: {\\n                    count++;\\n                }\\n            }\\n        }\\n        return count;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2641602,
                "title": "c-code",
                "content": "![image](https://assets.leetcode.com/users/images/9270a1fb-5c9f-4344-8eea-6e862ae6e403_1664524709.758991.png)\\n// creating stack then simple checking for two conditions , at the last return the size of stack . \\n\\n        stack<string>stk;\\n        for(int i = 0 ; i <logs.size();i++)\\n        {\\n            string str = logs[i];\\n            if(str == \"../\")\\n            {\\n                if(!stk.empty())\\n                {\\n                    stk.pop();\\n                }\\n            }\\n            else if(str != \"./\")\\n            {\\n                stk.push(str);\\n            }\\n        }\\n        return stk.size();\\n\\n",
                "solutionTags": [
                    "Stack"
                ],
                "code": "![image](https://assets.leetcode.com/users/images/9270a1fb-5c9f-4344-8eea-6e862ae6e403_1664524709.758991.png)\\n// creating stack then simple checking for two conditions , at the last return the size of stack . \\n\\n        stack<string>stk;\\n        for(int i = 0 ; i <logs.size();i++)\\n        {\\n            string str = logs[i];\\n            if(str == \"../\")\\n            {\\n                if(!stk.empty())\\n                {\\n                    stk.pop();\\n                }\\n            }\\n            else if(str != \"./\")\\n            {\\n                stk.push(str);\\n            }\\n        }\\n        return stk.size();\\n\\n",
                "codeTag": "Unknown"
            },
            {
                "id": 2387765,
                "title": "two-solutions-stack-solution-iterative-solution",
                "content": "**Stack solution**\\n```\\nclass Solution {\\npublic:\\n    int minOperations(vector<string>& logs) {\\n        stack<int> s;\\n        for(int i = 0; i < logs.size(); i++){\\n            if(isalpha(logs[i][0]) || isdigit(logs[i][0]))\\n                s.push(1);\\n            \\n            if(logs[i] ==\"../\" && !s.empty())\\n                s.pop();\\n            \\n            if(logs[i] == \"./\")\\n                continue;\\n            \\n        }\\n        return s.size();\\n    }\\n};\\n```\\n\\n**Iterative solution**\\n```\\nclass Solution {\\npublic:\\n    int minOperations(vector<string>& logs) {\\n        int count = 0;\\n        for(int i = 0; i < logs.size(); i++){\\n            if(isalpha(logs[i][0]) || isdigit(logs[i][0]))\\n                count++;\\n            \\n            if(logs[i] ==\"../\" && count != 0)\\n                count--;\\n            \\n            if(logs[i] == \"./\")\\n                continue;\\n        }\\n        \\n        return count;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "C",
                    "Stack"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int minOperations(vector<string>& logs) {\\n        stack<int> s;\\n        for(int i = 0; i < logs.size(); i++){\\n            if(isalpha(logs[i][0]) || isdigit(logs[i][0]))\\n                s.push(1);\\n            \\n            if(logs[i] ==\"../\" && !s.empty())\\n                s.pop();\\n            \\n            if(logs[i] == \"./\")\\n                continue;\\n            \\n        }\\n        return s.size();\\n    }\\n};\\n```\n```\\nclass Solution {\\npublic:\\n    int minOperations(vector<string>& logs) {\\n        int count = 0;\\n        for(int i = 0; i < logs.size(); i++){\\n            if(isalpha(logs[i][0]) || isdigit(logs[i][0]))\\n                count++;\\n            \\n            if(logs[i] ==\"../\" && count != 0)\\n                count--;\\n            \\n            if(logs[i] == \"./\")\\n                continue;\\n        }\\n        \\n        return count;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2007281,
                "title": "java-modified-stack-approach-beats-96-submissions",
                "content": "```\\nclass Solution {\\n    public int minOperations(String[] logs) {\\n        int c=0;\\n        \\n        for(int i=0; i<logs.length; i++){\\n            if(!logs[i].equals(\"./\") && !logs[i].equals(\"../\")){\\n                c++;\\n            }\\n            else if(c>0 && logs[i].equals(\"../\")){\\n                c--;\\n            }\\n        }\\n        \\n        return c;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int minOperations(String[] logs) {\\n        int c=0;\\n        \\n        for(int i=0; i<logs.length; i++){\\n            if(!logs[i].equals(\"./\") && !logs[i].equals(\"../\")){\\n                c++;\\n            }\\n            else if(c>0 && logs[i].equals(\"../\")){\\n                c--;\\n            }\\n        }\\n        \\n        return c;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1490100,
                "title": "java-using-stack-do-checkout",
                "content": "**//Do vote up if you like it :)**\\n```\\nclass Solution {\\n    public int minOperations(String[] logs) {\\n        int len = logs.length;\\n        Stack<String> stack = new Stack<>();\\n        stack.push(\"Main\");\\n        for(int i = 0; i < len; i++) {\\n            if(logs[i].equals(\"./\")) continue; //Remain in same folder\\n            else if(logs[i].equals(\"../\")) {\\n                if(stack.peek().equals(\"Main\")) continue; //Already at parent\\n                else stack.pop(); //Go to one level back of the heirarchy\\n            }\\n            else stack.push(logs[i]); //Go to one level up of the heirarchy\\n        }\\n        int count = 0;\\n        while(!stack.peek().equals(\"Main\")) { //Pop until you reach to Main\\n            stack.pop();\\n            count++;\\n        }\\n        return count;\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    public int minOperations(String[] logs) {\\n        int len = logs.length;\\n        Stack<String> stack = new Stack<>();\\n        stack.push(\"Main\");\\n        for(int i = 0; i < len; i++) {\\n            if(logs[i].equals(\"./\")) continue; //Remain in same folder\\n            else if(logs[i].equals(\"../\")) {\\n                if(stack.peek().equals(\"Main\")) continue; //Already at parent\\n                else stack.pop(); //Go to one level back of the heirarchy\\n            }\\n            else stack.push(logs[i]); //Go to one level up of the heirarchy\\n        }\\n        int count = 0;\\n        while(!stack.peek().equals(\"Main\")) { //Pop until you reach to Main\\n            stack.pop();\\n            count++;\\n        }\\n        return count;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1315038,
                "title": "easy-fast-python-solution-faster-than-95-00",
                "content": "# Easy, Fast Python Solution (faster than 95.00%)\\nRuntime: 40 ms, faster than 95.00% of Python3 online submissions for Crawler Log Folder.\\nMemory Usage: 14.5 MB\\n\\n```\\ndef minOperations(self, logs: List[str]) -> int:\\n        length = len(logs)\\n        i = 0\\n\\n        while i < length:\\n            if logs[i] == \\'./\\':\\n                del logs[i]\\n                length -= 1\\n            elif logs[i] == \\'../\\':\\n                if i < 1:\\n                    del logs[i]\\n                    length -= 1\\n                else:\\n                    del logs[i]\\n                    del logs[i-1]\\n                    i -= 1\\n                    length -= 2\\n            else:\\n                i += 1\\n\\n        return len(logs)\\n```",
                "solutionTags": [
                    "Python",
                    "Python3"
                ],
                "code": "```\\ndef minOperations(self, logs: List[str]) -> int:\\n        length = len(logs)\\n        i = 0\\n\\n        while i < length:\\n            if logs[i] == \\'./\\':\\n                del logs[i]\\n                length -= 1\\n            elif logs[i] == \\'../\\':\\n                if i < 1:\\n                    del logs[i]\\n                    length -= 1\\n                else:\\n                    del logs[i]\\n                    del logs[i-1]\\n                    i -= 1\\n                    length -= 2\\n            else:\\n                i += 1\\n\\n        return len(logs)\\n```",
                "codeTag": "Python3"
            },
            {
                "id": 1098198,
                "title": "4-ms-faster-than-95-55-of-c-using-simple-stack-implementation",
                "content": "```\\nclass Solution {\\npublic:\\n    int minOperations(vector<string>& logs) {\\n        stack<string>s;\\n        int count=0;\\n        for(int i=0;i<logs.size();i++){\\n            string str=logs[i];\\n            if(str==\"../\"){\\n                if(!s.empty()) s.pop();\\n            }\\n            else if(str!=\"./\"){\\n              s.push(str);   \\n            }\\n        }\\n        while(!s.empty()){\\n            s.pop();\\n            count++;\\n        }\\n        return count;\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    int minOperations(vector<string>& logs) {\\n        stack<string>s;\\n        int count=0;\\n        for(int i=0;i<logs.size();i++){\\n            string str=logs[i];\\n            if(str==\"../\"){\\n                if(!s.empty()) s.pop();\\n            }\\n            else if(str!=\"./\"){\\n              s.push(str);   \\n            }\\n        }\\n        while(!s.empty()){\\n            s.pop();\\n            count++;\\n        }\\n        return count;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1065177,
                "title": "java-regex-solution-unique-in-this-discussion",
                "content": "I don\\'t know why these dicuss solutions are so repetitive I felt that this question can also be done using regex, and I am not so good at this, so I though let\\'s look up in the dicuss, sadly all the solutions in Java discuss were a repetitive code. So I had to come up with this code\\n\\n```\\npublic int minOperations(String[] logs) {\\n        int ans=0;\\n        for(String s : logs){\\n            if(s.equals(\"../\")) ans = Math.max(--ans,0);\\n            else if(s.matches(\"[0-9a-z]+/\")) ans++;\\n        }\\n        return ans;\\n    }\\n```",
                "solutionTags": [],
                "code": "```\\npublic int minOperations(String[] logs) {\\n        int ans=0;\\n        for(String s : logs){\\n            if(s.equals(\"../\")) ans = Math.max(--ans,0);\\n            else if(s.matches(\"[0-9a-z]+/\")) ans++;\\n        }\\n        return ans;\\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1045008,
                "title": "beats-97-using-stack-o-n",
                "content": "```\\nclass Solution {\\npublic:\\n    int minOperations(vector<string> &logs) {\\n            \\n        stack <int> st;    \\n            \\n        for(string &s : logs){\\n                if(s == \"../\" && !st.empty())\\n                    st.pop();\\n                else if(s != \"./\" && s != \"../\")\\n                    st.push(1);    \\n        }\\n        \\n       return st.size();\\n    }\\n};\\n```\\n**Pls upvote my solution if you like it**",
                "solutionTags": [
                    "C",
                    "Stack"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int minOperations(vector<string> &logs) {\\n            \\n        stack <int> st;    \\n            \\n        for(string &s : logs){\\n                if(s == \"../\" && !st.empty())\\n                    st.pop();\\n                else if(s != \"./\" && s != \"../\")\\n                    st.push(1);    \\n        }\\n        \\n       return st.size();\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 944864,
                "title": "c-99-faster-code-easy-to-understand-code",
                "content": "\\tclass Solution {\\n\\tpublic:\\n\\t\\tint minOperations(vector<string>& logs) {\\n\\n\\t\\t\\tint ans = 0; //this will keep track of our position\\n\\t\\t\\t\\t\\t\\t // i.e, how far we are from main folder \\n\\n\\t\\t\\tfor(int i=0;i<logs.size();i++){\\n\\n\\t\\t\\t\\tstring curr = logs[i];\\n\\n\\t\\t\\t\\tif(curr == \"../\")\\n\\t\\t\\t\\t\\tans--; \\n\\t\\t\\t\\telse if(curr == \"./\")\\n\\t\\t\\t\\t\\tans = ans;\\n\\t\\t\\t\\telse\\n\\t\\t\\t\\t\\tans++;\\n\\n\\t\\t\\t\\tif(ans < 0) ans  = 0;\\n\\n\\t\\t\\t}\\n\\n\\t\\t\\tif(ans < 0) ans = 0;\\n\\n\\t\\t\\treturn ans;\\n\\t\\t}\\n\\t};",
                "solutionTags": [
                    "C++",
                    "C"
                ],
                "code": "class Solution {\\n\\tpublic:\\n\\t\\tint minOperations(vector<string>& logs) {\\n\\n\\t\\t\\tint ans = 0; //this will keep track of our position\\n\\t\\t\\t\\t\\t\\t // i.e, how far we are from main folder \\n\\n\\t\\t\\tfor(int i=0;i<logs.size();i++){\\n\\n\\t\\t\\t\\tstring curr = logs[i];\\n\\n\\t\\t\\t\\tif(curr == \"../\")\\n\\t\\t\\t\\t\\tans--; \\n\\t\\t\\t\\telse if(curr == \"./\")\\n\\t\\t\\t\\t\\tans = ans;\\n\\t\\t\\t\\telse\\n\\t\\t\\t\\t\\tans++;\\n\\n\\t\\t\\t\\tif(ans < 0) ans  = 0;\\n\\n\\t\\t\\t}",
                "codeTag": "Java"
            },
            {
                "id": 886987,
                "title": "faster-than-53-36-of-c-memory-usage-10-8-mb-less-than-99-86",
                "content": "```\\nclass Solution {\\npublic:\\n    int minOperations(vector<string>& logs) {\\n        \\n        int ops=0;\\n        \\n        for(auto c:logs){\\n            \\n            if(c==\"../\") {\\n                \\n                if(ops>0)\\n                ops--;\\n            }\\n            else {\\n                \\n                if(c==\"./\") continue;\\n                else {\\n                    ops++;\\n                }\\n                \\n            }\\n            \\n        }\\n        \\n        return ops;     \\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    int minOperations(vector<string>& logs) {\\n        \\n        int ops=0;\\n        \\n        for(auto c:logs){\\n            \\n            if(c==\"../\") {\\n                \\n                if(ops>0)\\n                ops--;\\n            }\\n            else {\\n                \\n                if(c==\"./\") continue;\\n                else {\\n                    ops++;\\n                }\\n                \\n            }\\n            \\n        }\\n        \\n        return ops;     \\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 866489,
                "title": "python-and-c-simple-python-code-o-n",
                "content": "**PYTHON**\\n```\\ndef minOperations(self, logs: List[str]) -> int:\\n        res = 0\\n        for val in logs:\\n            if(val  ==  \"../\"):\\n                if res: res-=1\\n            elif(val != \"./\" ) :  # to count for operations such as d1/ , d21/ \\n                res+=1\\n        return res\\n```\\n\\n**C++**\\n```\\nclass Solution {\\npublic:\\n    int minOperations(vector<string>& logs) {\\n        int res = 0;\\n        for(string val :logs){\\n            if(val==\"../\"){\\n                if(res!=0) res--;\\n            }\\n            else  if(val != \"./\") res+=1;  \\n\\t\\t}\\n        return res;\\n};\\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\ndef minOperations(self, logs: List[str]) -> int:\\n        res = 0\\n        for val in logs:\\n            if(val  ==  \"../\"):\\n                if res: res-=1\\n            elif(val != \"./\" ) :  # to count for operations such as d1/ , d21/ \\n                res+=1\\n        return res\\n```\n```\\nclass Solution {\\npublic:\\n    int minOperations(vector<string>& logs) {\\n        int res = 0;\\n        for(string val :logs){\\n            if(val==\"../\"){\\n                if(res!=0) res--;\\n            }\\n            else  if(val != \"./\") res+=1;  \\n\\t\\t}\\n        return res;\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 866437,
                "title": "python-o-n-solution",
                "content": "```\\nclass Solution:\\n    def minOperations(self, logs: List[str]) -> int:\\n        \\n        # ans will hold minimum number of operations required\\n        ans = 0\\n        for i in logs:\\n            # when we go up by one directory the operation will decrease by 1\\n            if i==\"../\":\\n                ans-=1\\n            # nothing to do we neither go one directory up or down\\n            elif i==\\'./\\':\\n                pass\\n            # we have gone down by one directory so required operations will increase\\n            else:\\n                ans+=1\\n            # ans<0 means we were in the main directory and we perform ../ which means nothing\\n            if ans<0:\\n                ans = 0\\n        if ans<0:\\n            return 0\\n        return ans\\n\\n\\n\\n\\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def minOperations(self, logs: List[str]) -> int:\\n        \\n        # ans will hold minimum number of operations required\\n        ans = 0\\n        for i in logs:\\n            # when we go up by one directory the operation will decrease by 1\\n            if i==\"../\":\\n                ans-=1\\n            # nothing to do we neither go one directory up or down\\n            elif i==\\'./\\':\\n                pass\\n            # we have gone down by one directory so required operations will increase\\n            else:\\n                ans+=1\\n            # ans<0 means we were in the main directory and we perform ../ which means nothing\\n            if ans<0:\\n                ans = 0\\n        if ans<0:\\n            return 0\\n        return ans\\n\\n\\n\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 866397,
                "title": "c-simple-few-lines-solution-clean-code",
                "content": "```\\n int minOperations(vector<string>& logs) {\\n        int ans = 0;\\n        for (string log : logs) {\\n            if (log == \"../\") {\\n                ans--;\\n                ans = max(ans, 0);\\n            } else if (log != \"./\") ans++;\\n        }\\n        return ans;\\n    }",
                "solutionTags": [],
                "code": "```\\n int minOperations(vector<string>& logs) {\\n        int ans = 0;\\n        for (string log : logs) {\\n            if (log == \"../\") {\\n                ans--;\\n                ans = max(ans, 0);\\n            } else if (log != \"./\") ans++;\\n        }\\n        return ans;\\n    }",
                "codeTag": "Unknown"
            },
            {
                "id": 3972434,
                "title": "simple-implementing-with-using-stack-ds",
                "content": "# Intuition\\nThe descriptions is leading us to use the **stack**, that follows LIFO-schema.\\n\\n---\\n\\nIf you don\\'t familiar with **stack**, lets have a look at [wiki page about stack description](https://en.wikipedia.org/wiki/Stack_(abstract_data_type)).\\n\\n# Approach\\n1. create `stack` variable, that\\'ll be store all of the elelement, that aren\\'t in this list `folders = [\\'./\\', \\'../\\']`\\n2. iterate over all `logs` and check, if log contains `../`, it\\'s time to **back to the parent folder**, if it\\'s `./`, than do **NOTHING**, otherwise save this dir inside of a stack.\\n3. be sure NOT to **pop from an empty stack, that causes an IndexError**\\n4. **finally check HOW** many dirs are in the stack\\n\\n# Complexity\\n- Time complexity: **O(n)** because of iterating `logs`\\n\\n- Space complexity: **O(n)**, in the worst case, if the folders aren\\'t that list of `folders`\\n\\n# Code\\n```\\nclass Solution:\\n    def minOperations(self, logs: List[str]) -> int:\\n        stack = []\\n\\n        for log in logs:\\n            if log.startswith(\\'../\\'):\\n                if stack:\\n                    stack.pop()\\n            elif log.startswith(\\'./\\'):\\n                continue\\n            else:\\n                stack.append(log)\\n\\n        return len(stack)\\n```",
                "solutionTags": [
                    "Python3",
                    "Stack"
                ],
                "code": "```\\nclass Solution:\\n    def minOperations(self, logs: List[str]) -> int:\\n        stack = []\\n\\n        for log in logs:\\n            if log.startswith(\\'../\\'):\\n                if stack:\\n                    stack.pop()\\n            elif log.startswith(\\'./\\'):\\n                continue\\n            else:\\n                stack.append(log)\\n\\n        return len(stack)\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3882917,
                "title": "no-stack-c-only-5-lines-o-n-beast-95",
                "content": "# Approach\\n<!-- Describe your approach to solving the problem. -->\\nApproach is Very Simple Just **Count** the Number of **Folders** after all the **Operations**.\\n\\n# Complexity\\n- Time complexity: O(N)\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: O(1)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int minOperations(vector<string>& logs) {\\n        int ans = 0;\\n        for(int i = 0;i<logs.size();i++)\\n        {\\n            if(logs[i]==\"../\" && ans>0) ans-=1;\\n            else if(logs[i]!=\"../\" && logs[i]!=\"./\") ans+=1;\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int minOperations(vector<string>& logs) {\\n        int ans = 0;\\n        for(int i = 0;i<logs.size();i++)\\n        {\\n            if(logs[i]==\"../\" && ans>0) ans-=1;\\n            else if(logs[i]!=\"../\" && logs[i]!=\"./\") ans+=1;\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3585614,
                "title": "easy-shit-solution-with-comments-beats-92",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\npublic class Solution {\\n    public int MinOperations(string[] logs)\\n    {\\n        List<string> result = new List<string>();\\n        foreach (var item in logs)\\n        {\\n            if (item.Contains(\\'.\\'))\\n            {\\n                if(item.Length - item.Replace(\".\", \"\").Length == 2) \\n                    if(result.Count != 0)\\n                        result.RemoveAt(result.Count - 1);\\n            }\\n            else\\n            {\\n                result.Add(item);\\n            }\\n        }\\n        return result.Count;\\n    }\\n}\\n```",
                "solutionTags": [
                    "C#"
                ],
                "code": "```\\npublic class Solution {\\n    public int MinOperations(string[] logs)\\n    {\\n        List<string> result = new List<string>();\\n        foreach (var item in logs)\\n        {\\n            if (item.Contains(\\'.\\'))\\n            {\\n                if(item.Length - item.Replace(\".\", \"\").Length == 2) \\n                    if(result.Count != 0)\\n                        result.RemoveAt(result.Count - 1);\\n            }\\n            else\\n            {\\n                result.Add(item);\\n            }\\n        }\\n        return result.Count;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3447741,
                "title": "c-solution-stack",
                "content": "```\\nint minOperations(vector<string>& logs) {\\n\\tstack<string> st;\\n\\tfor (const string& s : logs) {\\n\\t\\tif (s == \"../\") {\\n\\t\\t\\tif (!st.empty())\\n\\t\\t\\t\\tst.pop();\\n\\t\\t}\\n\\t\\telse if (s != \"./\")\\n\\t\\t\\tst.push(s);\\n\\t}\\n\\treturn st.size();\\n}\\n```",
                "solutionTags": [
                    "C++",
                    "C",
                    "Stack"
                ],
                "code": "```\\nint minOperations(vector<string>& logs) {\\n\\tstack<string> st;\\n\\tfor (const string& s : logs) {\\n\\t\\tif (s == \"../\") {\\n\\t\\t\\tif (!st.empty())\\n\\t\\t\\t\\tst.pop();\\n\\t\\t}\\n\\t\\telse if (s != \"./\")\\n\\t\\t\\tst.push(s);\\n\\t}\\n\\treturn st.size();\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3364041,
                "title": "js-very-easy-solution",
                "content": "# Code\\n```\\n/**\\n * @param {string[]} logs\\n * @return {number}\\n */\\nvar minOperations = function(logs) {\\n    let step = 0;\\n\\n    for (let i = 0; i < logs.length; i++) {\\n        const log = logs[i];\\n        if (log === \\'../\\') {\\n            if (step > 0) step--;\\n        } else if (log !== \\'./\\') {\\n            step++;\\n        }\\n    }\\n\\n    return step;\\n};\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\n/**\\n * @param {string[]} logs\\n * @return {number}\\n */\\nvar minOperations = function(logs) {\\n    let step = 0;\\n\\n    for (let i = 0; i < logs.length; i++) {\\n        const log = logs[i];\\n        if (log === \\'../\\') {\\n            if (step > 0) step--;\\n        } else if (log !== \\'./\\') {\\n            step++;\\n        }\\n    }\\n\\n    return step;\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3328986,
                "title": "php-solution",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n    O(n)\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\n\\n    /**\\n     * @param String[] $logs\\n     * @return Integer\\n     */\\n    function minOperations($logs) {\\n        $count = 0;\\n        foreach($logs as $log) {\\n            if ($log == \\'../\\'){\\n                if ($count == 0) {\\n                    $count;\\n                } else {\\n                    $count -= 1;\\n                }\\n            } else if($log == \\'./\\'){\\n                $count;\\n            } else {\\n                $count += 1;\\n            }\\n        }\\n\\n        return $count;\\n    }\\n}\\n```",
                "solutionTags": [
                    "PHP"
                ],
                "code": "```\\nclass Solution {\\n\\n    /**\\n     * @param String[] $logs\\n     * @return Integer\\n     */\\n    function minOperations($logs) {\\n        $count = 0;\\n        foreach($logs as $log) {\\n            if ($log == \\'../\\'){\\n                if ($count == 0) {\\n                    $count;\\n                } else {\\n                    $count -= 1;\\n                }\\n            } else if($log == \\'./\\'){\\n                $count;\\n            } else {\\n                $count += 1;\\n            }\\n        }\\n\\n        return $count;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3289154,
                "title": "very-simple-self-explanatory-stack-based-solution",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n$$O(n)$$\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n$$O(n)$$\\n# Code\\n```\\nclass Solution:\\n    def minOperations(self, logs: List[str]) -> int:\\n        stack = [] \\n        for lg in logs:\\n            if lg != \\'./\\':\\n                if lg != \\'../\\':\\n                    stack.append(lg)\\n                else:\\n                    if stack:\\n                        stack.pop()\\n        return len(stack)\\n\\n\\n\\n\\n```",
                "solutionTags": [
                    "Python",
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def minOperations(self, logs: List[str]) -> int:\\n        stack = [] \\n        for lg in logs:\\n            if lg != \\'./\\':\\n                if lg != \\'../\\':\\n                    stack.append(lg)\\n                else:\\n                    if stack:\\n                        stack.pop()\\n        return len(stack)\\n\\n\\n\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3240762,
                "title": "simple-python-code",
                "content": "# Complexity\\n- Time complexity: O(n)\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: O(n)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution:\\n    def minOperations(self, logs: List[str]) -> int:\\n        stack = []\\n        for log in logs:\\n            if log == \"./\":\\n                continue\\n            elif log == \"../\":\\n                if stack:\\n                    stack.pop()\\n            else:\\n                stack.append(log)\\n        return len(stack)\\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def minOperations(self, logs: List[str]) -> int:\\n        stack = []\\n        for log in logs:\\n            if log == \"./\":\\n                continue\\n            elif log == \"../\":\\n                if stack:\\n                    stack.pop()\\n            else:\\n                stack.append(log)\\n        return len(stack)\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3227317,
                "title": "solved-using-stacks-with-o-n",
                "content": "# Intuition\\nI see I need to store past elements.So stack can do it\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n If else condition is used rather than while Because I just need to pop only 1 thing after comparision. \\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:O(n)\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:O(1)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\n/**\\n * @param {string[]} logs\\n * @return {number}\\n */\\nvar minOperations = function(logs) {\\n    let stack=[]\\n    for(let i=0;i<logs.length;i++){\\n        if(stack.length!==0 && logs[i]===\\'../\\'){\\n            stack.pop()\\n        }else if(logs[i]===\\'./\\'){\\n            continue;\\n        }else if(logs[i]!==\\'../\\'){\\n            stack.push(logs[i])\\n        }\\n    }\\n    return stack.length\\n       \\n};\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\n/**\\n * @param {string[]} logs\\n * @return {number}\\n */\\nvar minOperations = function(logs) {\\n    let stack=[]\\n    for(let i=0;i<logs.length;i++){\\n        if(stack.length!==0 && logs[i]===\\'../\\'){\\n            stack.pop()\\n        }else if(logs[i]===\\'./\\'){\\n            continue;\\n        }else if(logs[i]!==\\'../\\'){\\n            stack.push(logs[i])\\n        }\\n    }\\n    return stack.length\\n       \\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3012115,
                "title": "easy-to-understand-beat-100-and-runtime-is-1ms-using-java",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\n    public int minOperations(String[] log) {\\n      int count=0;\\n        for(int i=0; i<log.length; i++)\\n        {\\n            \\n            if(!log[i].equals(\"./\") && !log[i].equals(\"../\"))\\n            {\\n                count++;\\n            }\\n            else if(log[i].equals(\"./\"))\\n            {\\n                continue;\\n            }\\n            else\\n            {\\n                if(count!=0)\\n                {\\n                count--;\\n                }\\n            }\\n        }\\n        if(count<=0)\\n        {\\n            return 0;\\n        }\\n        return count;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Array",
                    "String"
                ],
                "code": "```\\nclass Solution {\\n    public int minOperations(String[] log) {\\n      int count=0;\\n        for(int i=0; i<log.length; i++)\\n        {\\n            \\n            if(!log[i].equals(\"./\") && !log[i].equals(\"../\"))\\n            {\\n                count++;\\n            }\\n            else if(log[i].equals(\"./\"))\\n            {\\n                continue;\\n            }\\n            else\\n            {\\n                if(count!=0)\\n                {\\n                count--;\\n                }\\n            }\\n        }\\n        if(count<=0)\\n        {\\n            return 0;\\n        }\\n        return count;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2965693,
                "title": "easiest-c-approach-1ms-time",
                "content": "# Intuition\\nEasy c++ approach\\n\\n# Approach\\ncount the number of directoires else return back\\n\\n# Complexity\\n- Time complexity: O(n)\\n\\n- Space complexity: O(1)\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int minOperations(vector<string>& logs) {\\n        int n=logs.size();\\n        int c=0;\\n        for(int i=0;i<n;i++){\\n            if(logs[i] == \"./\")\\n                continue;\\n            if(logs[i] == \"../\")\\n                    c--;\\n            else\\n                c++;\\n            if(c<0)\\n                c=0;\\n        }\\n        return c;\\n        \\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int minOperations(vector<string>& logs) {\\n        int n=logs.size();\\n        int c=0;\\n        for(int i=0;i<n;i++){\\n            if(logs[i] == \"./\")\\n                continue;\\n            if(logs[i] == \"../\")\\n                    c--;\\n            else\\n                c++;\\n            if(c<0)\\n                c=0;\\n        }\\n        return c;\\n        \\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2925804,
                "title": "3-ms-no-stack-c",
                "content": "\\n\\n## Approach 1 : O(1) Space\\n<!-- Describe your approach to solving the problem. -->\\n\\n```\\nclass Solution \\n{\\npublic:\\n    int minOperations(vector<string>& logs) \\n    {\\n        int ans=0;\\n        for(string &it:logs)\\n        {\\n            if(it[it.size()-2]!=\\'.\\')\\n               ans++;\\n            else if(it==\"../\")\\n               ans=(ans==0)?0:ans-1;\\n        }\\n        return ans;\\n    }\\n};\\n```\\n## Approach 2 : Stack\\n``` \\nclass Solution \\n{\\npublic:\\n    int minOperations(vector<string>& logs) \\n    {\\n        stack<string>st;\\n        for(string &it:logs)\\n        {\\n            if(!st.empty() && it==\"../\")\\n                st.pop();\\n            else if(it[it.size()-2]!=\\'.\\')\\n                st.push(it);\\n        }\\n        return st.size();\\n    }\\n};\\n```       \\n",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution \\n{\\npublic:\\n    int minOperations(vector<string>& logs) \\n    {\\n        int ans=0;\\n        for(string &it:logs)\\n        {\\n            if(it[it.size()-2]!=\\'.\\')\\n               ans++;\\n            else if(it==\"../\")\\n               ans=(ans==0)?0:ans-1;\\n        }\\n        return ans;\\n    }\\n};\\n```\n``` \\nclass Solution \\n{\\npublic:\\n    int minOperations(vector<string>& logs) \\n    {\\n        stack<string>st;\\n        for(string &it:logs)\\n        {\\n            if(!st.empty() && it==\"../\")\\n                st.pop();\\n            else if(it[it.size()-2]!=\\'.\\')\\n                st.push(it);\\n        }\\n        return st.size();\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2707580,
                "title": "rust-fold-0ms",
                "content": "```\\nimpl Solution {\\n    pub fn min_operations(logs: Vec<String>) -> i32 {\\n        logs.iter()\\n            .fold(0, |dep, op| {\\n                match op.as_str() {\\n                    // decrease depth (stop at zero)\\n                    \"../\" => {\\n                        match dep {\\n                            0 => dep,\\n                            _ => dep - 1,\\n                        }\\n                    }\\n                    \"./\" => dep, // no change\\n                    _ => dep + 1,  // increase depth\\n                }\\n             })\\n    }\\n}\\n```",
                "solutionTags": [
                    "Rust"
                ],
                "code": "```\\nimpl Solution {\\n    pub fn min_operations(logs: Vec<String>) -> i32 {\\n        logs.iter()\\n            .fold(0, |dep, op| {\\n                match op.as_str() {\\n                    // decrease depth (stop at zero)\\n                    \"../\" => {\\n                        match dep {\\n                            0 => dep,\\n                            _ => dep - 1,\\n                        }\\n                    }\\n                    \"./\" => dep, // no change\\n                    _ => dep + 1,  // increase depth\\n                }\\n             })\\n    }\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2688322,
                "title": "python-super-easy-no-stack",
                "content": "```py\\nclass Solution:\\n    def minOperations(self, logs: List[str]) -> int:\\n        ans = 0\\n        \\n        for i in logs:\\n            if i[0] == \".\" and i[1] == \".\":\\n                ans -=1\\n                if ans < 0:\\n                    ans = 0\\n            elif i[0] == \".\" and i[1] == \"/\":\\n                continue\\n            else:\\n                ans +=1\\n        return ans```",
                "solutionTags": [],
                "code": "```py\\nclass Solution:\\n    def minOperations(self, logs: List[str]) -> int:\\n        ans = 0\\n        \\n        for i in logs:\\n            if i[0] == \".\" and i[1] == \".\":\\n                ans -=1\\n                if ans < 0:\\n                    ans = 0\\n            elif i[0] == \".\" and i[1] == \"/\":\\n                continue\\n            else:\\n                ans +=1\\n        return ans```",
                "codeTag": "Java"
            },
            {
                "id": 2545524,
                "title": "java-easy-solution-99-75-fast",
                "content": "```\\nclass Solution {\\n    public int minOperations(String[] logs) {\\n        int c=0;\\n        for(int i=0;i<logs.length;i++)\\n        {\\n            \\n            if(logs[i].equals(\"../\")==true)c-=1;\\n            else if(logs[i].equals(\"./\")==true)continue;\\n            else c+=1;\\n            if(c<=0)c=0;\\n        }\\n        if(c<=0)return 0;\\n        else return c;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int minOperations(String[] logs) {\\n        int c=0;\\n        for(int i=0;i<logs.length;i++)\\n        {\\n            \\n            if(logs[i].equals(\"../\")==true)c-=1;\\n            else if(logs[i].equals(\"./\")==true)continue;\\n            else c+=1;\\n            if(c<=0)c=0;\\n        }\\n        if(c<=0)return 0;\\n        else return c;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2504472,
                "title": "java-easy-solution-by-count-variable",
                "content": "```\\nclass Solution {\\n    public int minOperations(String[] logs) {\\n        int count=0;\\n        for(int i=0;i<logs.length;i++){\\n            if(logs[i].equals(\"../\") && count>0)\\n                count--;\\n            else if(logs[i].equals(\"../\"))\\n                continue;\\n            else if(!logs[i].equals(\"./\"))\\n                count++;\\n        }\\n        return count;\\n    }\\n}",
                "solutionTags": [
                    "Java"
                ],
                "code": "class Solution {\\n    public int minOperations(String[] logs) {\\n        int count=0;\\n        for(int i=0;i<logs.length;i++){\\n            if(logs[i].equals(\"../\") && count>0)\\n                count--;\\n            else if(logs[i].equals(\"../\"))\\n                continue;\\n            else if(!logs[i].equals(\"./\"))\\n                count++;\\n        }",
                "codeTag": "Java"
            },
            {
                "id": 2464513,
                "title": "stack-java-simple-solution-2ms",
                "content": "```\\nclass Solution {\\n    public int minOperations(String[] logs) {\\n      Stack<String> stack=new Stack<>();\\n      int max=Integer.MIN_VALUE;\\n      for(int i=0;i<logs.length;i++)\\n      {\\n        if(!stack.isEmpty() && logs[i].equals(\"../\"))\\n          stack.pop();\\n        else if(!logs[i].equals(\"./\") && !logs[i].equals(\"../\"))\\n          stack.push(logs[i]); \\n      } \\n      return stack.size();\\n        \\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Stack"
                ],
                "code": "```\\nclass Solution {\\n    public int minOperations(String[] logs) {\\n      Stack<String> stack=new Stack<>();\\n      int max=Integer.MIN_VALUE;\\n      for(int i=0;i<logs.length;i++)\\n      {\\n        if(!stack.isEmpty() && logs[i].equals(\"../\"))\\n          stack.pop();\\n        else if(!logs[i].equals(\"./\") && !logs[i].equals(\"../\"))\\n          stack.push(logs[i]); \\n      } \\n      return stack.size();\\n        \\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2407966,
                "title": "c",
                "content": "```\\nclass Solution {\\npublic:\\n    int minOperations(vector<string>& logs) {\\n        int count=0;\\n        for(auto x:logs){\\n            if(x==\"../\") count==0?0:count--;\\n            else if(x==\"./\") continue;\\n            else count++;\\n        }\\n        return count;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int minOperations(vector<string>& logs) {\\n        int count=0;\\n        for(auto x:logs){\\n            if(x==\"../\") count==0?0:count--;\\n            else if(x==\"./\") continue;\\n            else count++;\\n        }\\n        return count;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2312308,
                "title": "very-easy-c-solution",
                "content": "```\\nclass Solution {\\npublic:\\n    int minOperations(vector<string>& logs) {\\n        stack<string> str;\\n        for(int i=0;i<logs.size();i++){\\n            if(logs[i] == \"./\"){\\n                continue;\\n            }\\n            else if(logs[i] == \"../\"){\\n                if(str.empty()){\\n                    continue;\\n                }\\n                str.pop();\\n            }\\n            else{\\n                str.push(logs[i]);\\n            }\\n        }\\n        return str.size();\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    int minOperations(vector<string>& logs) {\\n        stack<string> str;\\n        for(int i=0;i<logs.size();i++){\\n            if(logs[i] == \"./\"){\\n                continue;\\n            }\\n            else if(logs[i] == \"../\"){\\n                if(str.empty()){\\n                    continue;\\n                }\\n                str.pop();\\n            }\\n            else{\\n                str.push(logs[i]);\\n            }\\n        }\\n        return str.size();\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2284266,
                "title": "java-2-methods-explained",
                "content": "**Method 1:** Stack\\n* Let there be a stack indicating current state of directory. Moving inside a directory will be a push, and moving out will be push\\n* If log is alphanumeric, then push the log \\n* Else if log is `../` and stack is not empty, pop from stack, since you\\'re moving out from the current directory\\n* Else log is `./` and nothing needs to be done\\n* At the end, the size of stack will indicate how deep we are in the directory\\n>**T/S:** O(n)/O(n), where n = size(logs)\\n```\\npublic int minOperations(String[] logs) {\\n\\tvar stack = new ArrayDeque<String>();\\n\\t\\n\\tfor (var log : logs)\\n\\t\\tif (Character.isAlphabetic(log.charAt(0)) || Character.isDigit(log.charAt(0)))\\n\\t\\t\\tstack.push(log);\\n\\t\\telse if (!stack.isEmpty() && log.charAt(1) == \\'.\\')\\n\\t\\t\\tstack.pop();\\n\\treturn stack.size();\\n}\\n```\\n**Method 2:** Space optimized version of method 1\\n* Notice that stack\\'s elements aren\\'t being used themselves, only push/pop/size are being used. \\n* This means we can replace the stack with a count variable and return that at the end\\n>**T/S:** O(n)/O(1)\\n```\\npublic int minOperations(String[] logs) {\\n\\tvar ops = 0;\\n\\t\\n\\tfor (var log : logs) \\n\\t\\tif (Character.isAlphabetic(log.charAt(0)) || Character.isDigit(log.charAt(0)))\\n\\t\\t\\tops++;\\n\\t\\telse if (ops > 0 && log.charAt(1) == \\'.\\')\\n\\t\\t\\tops--;\\n\\treturn ops;\\n}\\n```\\n***Please upvote if this helps***",
                "solutionTags": [
                    "Java",
                    "Stack"
                ],
                "code": "```\\npublic int minOperations(String[] logs) {\\n\\tvar stack = new ArrayDeque<String>();\\n\\t\\n\\tfor (var log : logs)\\n\\t\\tif (Character.isAlphabetic(log.charAt(0)) || Character.isDigit(log.charAt(0)))\\n\\t\\t\\tstack.push(log);\\n\\t\\telse if (!stack.isEmpty() && log.charAt(1) == \\'.\\')\\n\\t\\t\\tstack.pop();\\n\\treturn stack.size();\\n}\\n```\n```\\npublic int minOperations(String[] logs) {\\n\\tvar ops = 0;\\n\\t\\n\\tfor (var log : logs) \\n\\t\\tif (Character.isAlphabetic(log.charAt(0)) || Character.isDigit(log.charAt(0)))\\n\\t\\t\\tops++;\\n\\t\\telse if (ops > 0 && log.charAt(1) == \\'.\\')\\n\\t\\t\\tops--;\\n\\treturn ops;\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2273108,
                "title": "c-stack-easy-code",
                "content": "Please Upvote :)\\n\\n```\\nclass Solution {\\npublic:\\n    int minOperations(vector<string>& logs) {\\n        stack<string> s;\\n        \\n        for(auto x:logs)\\n        {\\n            if(x==\"../\")\\n            {\\n                if(!s.empty())\\n                    s.pop();// child removed if exist\\n            }\\n            else if(x!=\"./\")\\n                s.push(\"+\");// new child added.\\n        }\\n        return s.size();\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "C",
                    "Stack"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int minOperations(vector<string>& logs) {\\n        stack<string> s;\\n        \\n        for(auto x:logs)\\n        {\\n            if(x==\"../\")\\n            {\\n                if(!s.empty())\\n                    s.pop();// child removed if exist\\n            }\\n            else if(x!=\"./\")\\n                s.push(\"+\");// new child added.\\n        }\\n        return s.size();\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2189303,
                "title": "java",
                "content": "```\\nclass Solution {\\n    public int minOperations(String[] logs) {\\n        int count = 0;\\n        \\n        for(int i = 0; i < logs.length; i++){\\n            if(logs[i].equals(\"./\")){\\n                continue;\\n            }\\n            else if(logs[i].equals(\"../\") ){\\n                if(count > 0){\\n                    count--;\\n                }\\n                \\n            }\\n            else{\\n                count++;\\n            }\\n        }\\n        \\n        return count;\\n    }\\n}\\n```\\n",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int minOperations(String[] logs) {\\n        int count = 0;\\n        \\n        for(int i = 0; i < logs.length; i++){\\n            if(logs[i].equals(\"./\")){\\n                continue;\\n            }\\n            else if(logs[i].equals(\"../\") ){\\n                if(count > 0){\\n                    count--;\\n                }\\n                \\n            }\\n            else{\\n                count++;\\n            }\\n        }\\n        \\n        return count;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2186704,
                "title": "java-easy-solution-100",
                "content": "```\\nclass Solution {\\n    public int minOperations(String[] logs) {\\n        int count=0;\\n        for(int i=0;i<logs.length;i++){\\n            \\n            if(logs[i].equals(\"../\")){\\n                count--;\\n            }else if(logs[i].equals(\"./\")){\\n                count=count;\\n            }else{\\n                count++;\\n            }\\n            if(count<0) count=0;\\n        }\\n       \\n        return count;\\n    }\\n}\\n```\\n**Please UPVOTE  you understand my code and comment your best approach**",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int minOperations(String[] logs) {\\n        int count=0;\\n        for(int i=0;i<logs.length;i++){\\n            \\n            if(logs[i].equals(\"../\")){\\n                count--;\\n            }else if(logs[i].equals(\"./\")){\\n                count=count;\\n            }else{\\n                count++;\\n            }\\n            if(count<0) count=0;\\n        }\\n       \\n        return count;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2137723,
                "title": "python3",
                "content": "```\\nclass Solution:\\n    def minOperations(self, logs: List[str]) -> int:\\n        c=0\\n        for i in range(len(logs)):\\n            if  logs[i]==\\'../\\' and c>0:\\n                c-=1\\n            elif logs[i]!=\\'../\\' and logs[i]!=\\'./\\' :\\n                c+=1\\n        return c\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution:\\n    def minOperations(self, logs: List[str]) -> int:\\n        c=0\\n        for i in range(len(logs)):\\n            if  logs[i]==\\'../\\' and c>0:\\n                c-=1\\n            elif logs[i]!=\\'../\\' and logs[i]!=\\'./\\' :\\n                c+=1\\n        return c\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2107090,
                "title": "java-easy-faster-than-97",
                "content": "```\\npublic int minOperations(String[] s) {\\n        int res=0;\\n        for(String c:s){\\n            if(c.equals(\"../\")){\\n                res=Math.max(0,--res);\\n                \\n            }\\n            else if(c.equals(\"./\")){\\n                continue;\\n            }\\n            else{\\n                res++;\\n            }\\n        }\\n        return res;\\n        \\n    }\\n```",
                "solutionTags": [],
                "code": "```\\npublic int minOperations(String[] s) {\\n        int res=0;\\n        for(String c:s){\\n            if(c.equals(\"../\")){\\n                res=Math.max(0,--res);\\n                \\n            }\\n            else if(c.equals(\"./\")){\\n                continue;\\n            }\\n            else{\\n                res++;\\n            }\\n        }\\n        return res;\\n        \\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2022176,
                "title": "crawler-log-folder-python3-solution",
                "content": "```\\ndef minOperations(self, logs: List[str]) -> int:\\n\\tstack =[]\\n\\tfor i in range(len(logs)):\\n\\t\\tif logs[i] ==\"../\":\\n\\t\\t\\tif stack !=[]:\\n\\t\\t\\t\\tstack.pop()\\n\\t\\telif logs[i] ==\"./\":\\n\\t\\t\\tcontinue\\n\\t\\telse:\\n\\t\\t\\tstack.append(logs[i])\\n\\treturn len(stack)",
                "solutionTags": [
                    "Python",
                    "Python3",
                    "Stack"
                ],
                "code": "```\\ndef minOperations(self, logs: List[str]) -> int:\\n\\tstack =[]\\n\\tfor i in range(len(logs)):\\n\\t\\tif logs[i] ==\"../\":\\n\\t\\t\\tif stack !=[]:\\n\\t\\t\\t\\tstack.pop()\\n\\t\\telif logs[i] ==\"./\":\\n\\t\\t\\tcontinue\\n\\t\\telse:\\n\\t\\t\\tstack.append(logs[i])\\n\\treturn len(stack)",
                "codeTag": "Python3"
            },
            {
                "id": 2003637,
                "title": "python-easy-and-smart-solution-o-1-space-72ms",
                "content": "```\\n# var for counting directories or depth \\ndirs = 0\\nfor i in logs:\\n\\tif i == \"../\":\\n\\t    # if there is any folder present then remove it and \\n\\t\\t# if no folder present i.e. dirs = 0 then no need to do anything, \\n\\t\\t# you are already in root directory\\n\\t\\tif dirs != 0:\\n\\t\\t\\tdirs -= 1\\n\\t# you have to remain in same directory hence no increment in dirs ..i.e. depth remains same\\n\\telif i == \"./\":\\n\\t\\tcontinue\\n\\telse:\\n\\t# increase the dirs count with 1. because a new directory is encountered and \\n\\t# depth of dirs is increased\\n\\t#   root / a / b / c / d     --- > depth = 4\\n\\t# so if you see everytime we encounter a new directory our depth increases.\\n\\t\\tdirs += 1\\n\\t\\t\\n# if directories left then return count of them \\nif dirs > 0:\\n\\treturn dirs\\n# else if there are 0 directories then return 0\\nelse:\\n\\treturn 0\\n```\\nPlease **UPVOTE** if you liked the solution and do consider a follow.",
                "solutionTags": [
                    "Python"
                ],
                "code": "```\\n# var for counting directories or depth \\ndirs = 0\\nfor i in logs:\\n\\tif i == \"../\":\\n\\t    # if there is any folder present then remove it and \\n\\t\\t# if no folder present i.e. dirs = 0 then no need to do anything, \\n\\t\\t# you are already in root directory\\n\\t\\tif dirs != 0:\\n\\t\\t\\tdirs -= 1\\n\\t# you have to remain in same directory hence no increment in dirs ..i.e. depth remains same\\n\\telif i == \"./\":\\n\\t\\tcontinue\\n\\telse:\\n\\t# increase the dirs count with 1. because a new directory is encountered and \\n\\t# depth of dirs is increased\\n\\t#   root / a / b / c / d     --- > depth = 4\\n\\t# so if you see everytime we encounter a new directory our depth increases.\\n\\t\\tdirs += 1\\n\\t\\t\\n# if directories left then return count of them \\nif dirs > 0:\\n\\treturn dirs\\n# else if there are 0 directories then return 0\\nelse:\\n\\treturn 0\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1997483,
                "title": "c-simple-o-n",
                "content": "Just check for ../ and ./ and rest will be in else block.\\n\\n```\\nclass Solution {\\npublic:\\n    int minOperations(vector<string>& logs) {\\n        int len = logs.size();\\n        int ans = 0;\\n        \\n        for(int i=0; i<len; i++) {\\n            if(logs[i]==\"../\")\\n            {\\n                ans--;\\n                ans<0?ans=0:ans=ans;\\n            }\\n            else if(logs[i]==\"./\") continue;\\n            else{\\n                ans++;\\n            }\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    int minOperations(vector<string>& logs) {\\n        int len = logs.size();\\n        int ans = 0;\\n        \\n        for(int i=0; i<len; i++) {\\n            if(logs[i]==\"../\")\\n            {\\n                ans--;\\n                ans<0?ans=0:ans=ans;\\n            }\\n            else if(logs[i]==\"./\") continue;\\n            else{\\n                ans++;\\n            }\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1997356,
                "title": "python-and-c-o-1-space",
                "content": "We are guaranteed that every folder will exist when called, so we don\\'t need to worry at all about that.\\n* If `log` is `\"../\"` we\\'ll go back up once (if we can)\\n* If `log` is not `\"../\"` we\\'ll go down once only if we are seeing a folder name, i.e. `log` is not `\"./\"`\\n\\n<hr>\\n\\n# Python solution\\n```\\nclass Solution:\\n    def minOperations(self, logs: List[str]) -> int:\\n        depth = 0\\n        \\n        for log in logs:\\n            if log == \"../\":\\n                if depth > 0:\\n                    depth -= 1\\n            elif log != \"./\":\\n                depth += 1\\n                \\n        return depth\\n```\\n\\n# C++ solution\\n```\\nclass Solution {\\npublic:\\n    int minOperations(vector<string>& logs) {\\n        \\n        int depth = 0;\\n        \\n        for(auto log: logs){\\n            if(log == \"../\"){\\n                if(depth > 0){\\n                    depth--;\\n                }\\n            }\\n            else if(log != \"./\"){\\n                depth++;\\n            }\\n        }\\n        \\n        return depth;\\n    }\\n};\\n```",
                "solutionTags": [
                    "Python",
                    "C"
                ],
                "code": "```\\nclass Solution:\\n    def minOperations(self, logs: List[str]) -> int:\\n        depth = 0\\n        \\n        for log in logs:\\n            if log == \"../\":\\n                if depth > 0:\\n                    depth -= 1\\n            elif log != \"./\":\\n                depth += 1\\n                \\n        return depth\\n```\n```\\nclass Solution {\\npublic:\\n    int minOperations(vector<string>& logs) {\\n        \\n        int depth = 0;\\n        \\n        for(auto log: logs){\\n            if(log == \"../\"){\\n                if(depth > 0){\\n                    depth--;\\n                }\\n            }\\n            else if(log != \"./\"){\\n                depth++;\\n            }\\n        }\\n        \\n        return depth;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1997227,
                "title": "easy-stack-solution-simple-stack",
                "content": "```\\nclass Solution {\\npublic:\\n    int minOperations(vector<string>& l) {\\n     stack<string> st;\\n     for(int i=0;i<l.size();i++){\\n         if(l[i]==\"./\"){\\n             continue;\\n         }else if(l[i]==\"../\"){\\n             if(st.size())\\n             st.pop();\\n         }else{\\n             st.push(l[i]);\\n         }\\n     }\\n            return st.size();\\n     \\n    }\\n};\\n```",
                "solutionTags": [
                    "C",
                    "Stack"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int minOperations(vector<string>& l) {\\n     stack<string> st;\\n     for(int i=0;i<l.size();i++){\\n         if(l[i]==\"./\"){\\n             continue;\\n         }else if(l[i]==\"../\"){\\n             if(st.size())\\n             st.pop();\\n         }else{\\n             st.push(l[i]);\\n         }\\n     }\\n            return st.size();\\n     \\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1965420,
                "title": "javascript",
                "content": "```\\nvar minOperations = function(logs) {\\n    let count = 0;\\n    for(i=0;i<logs.length;i++){\\n        if(logs[i] === \\'../\\') {\\n            if(count > 0)  count = count - 1;\\n            continue\\n        }\\n        if(logs[i] === \\'./\\') continue;\\n        else count = count + 1;\\n    }\\n    return count\\n};\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\nvar minOperations = function(logs) {\\n    let count = 0;\\n    for(i=0;i<logs.length;i++){\\n        if(logs[i] === \\'../\\') {\\n            if(count > 0)  count = count - 1;\\n            continue\\n        }\\n        if(logs[i] === \\'./\\') continue;\\n        else count = count + 1;\\n    }\\n    return count\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1943551,
                "title": "easiest-solution-without-using-stack",
                "content": "```\\n/**\\n * @param {string[]} logs\\n * @return {number}\\n */\\nvar minOperations = function(logs) {\\n    let s = 0;\\n    \\n    logs.forEach(step => {\\n        if(step === \\'../\\') s = Math.max(0, --s);\\n        else if(step !== \\'./\\') s++;\\n    });\\n    \\n    return s;\\n};\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\n/**\\n * @param {string[]} logs\\n * @return {number}\\n */\\nvar minOperations = function(logs) {\\n    let s = 0;\\n    \\n    logs.forEach(step => {\\n        if(step === \\'../\\') s = Math.max(0, --s);\\n        else if(step !== \\'./\\') s++;\\n    });\\n    \\n    return s;\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1933398,
                "title": "java-easy-1ms-solution",
                "content": "```\\nclass Solution {\\n    public int minOperations(String[] logs) {\\n        List<String> l = new ArrayList();\\n        \\n        for(int i=0;i<=logs.length-1;i++){\\n            if(logs[i].equals(\"../\")){\\n                if(l.size()-1>0)\\n                l.remove(l.size()-1);\\n                else l.clear();\\n            }else if (logs[i].equals(\"./\")){\\n                continue;\\n            }else{\\n                l.add(logs[i]);\\n            }\\n        }\\n        return l.size();\\n    }\\n}",
                "solutionTags": [],
                "code": "class Solution {\\n    public int minOperations(String[] logs) {\\n        List<String> l = new ArrayList();\\n        \\n        for(int i=0;i<=logs.length-1;i++){\\n            if(logs[i].equals(\"../\")){\\n                if(l.size()-1>0)\\n                l.remove(l.size()-1);\\n                else l.clear();\\n            }",
                "codeTag": "Java"
            },
            {
                "id": 1933326,
                "title": "c-two-approach-with-stack-without-stack-simple-clean-code",
                "content": "**C++ Approach :**\\n\\n**Approach 1 : Space - O(N)**\\n```\\n        stack<int> s;\\n        \\n        for(auto p:logs)\\n        {\\n            if(p==\"../\")\\n            {\\n                if(!s.empty())\\n                {\\n                    s.pop();\\n                }\\n            }\\n            else if(p==\"./\")\\n            {\\n                continue;\\n            }\\n            else\\n            {\\n                s.push(1);\\n            }\\n        }\\n        \\n        return s.size();\\n```\\n**Approach 2 : Space - O(1)**\\n```\\n\\t\\tint count=0;\\n        for(auto p:logs)\\n        {\\n            if(p==\"../\")\\n            {\\n                if(count>0)\\n                {\\n                    count--;\\n                }\\n            }\\n            else if(p==\"./\")\\n            {\\n                continue;\\n            }\\n            else\\n            {\\n                count++;\\n            }\\n        }\\n        \\n        return count;\\n```",
                "solutionTags": [
                    "C",
                    "Stack"
                ],
                "code": "```\\n        stack<int> s;\\n        \\n        for(auto p:logs)\\n        {\\n            if(p==\"../\")\\n            {\\n                if(!s.empty())\\n                {\\n                    s.pop();\\n                }\\n            }\\n            else if(p==\"./\")\\n            {\\n                continue;\\n            }\\n            else\\n            {\\n                s.push(1);\\n            }\\n        }\\n        \\n        return s.size();\\n```\n```\\n\\t\\tint count=0;\\n        for(auto p:logs)\\n        {\\n            if(p==\"../\")\\n            {\\n                if(count>0)\\n                {\\n                    count--;\\n                }\\n            }\\n            else if(p==\"./\")\\n            {\\n                continue;\\n            }\\n            else\\n            {\\n                count++;\\n            }\\n        }\\n        \\n        return count;\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1932810,
                "title": "java-very-simple-solution-with-100-tc-and-97-space-complexity-solution",
                "content": "If \"../\" encountered return to the parent folder of that child\\nif \"./\" encountered then simply ignore and continue\\nif any other string encountered then simply goes to that file or increment the count\\n\\nAs easy as you thinks buddies ;)\\n\\n```\\nclass Solution {\\n    public int minOperations(String[] logs) {\\n        int res=0;\\n        for(int i=0;i<logs.length;i++){\\n            if(logs[i].equals(\"./\"))continue;\\n            else if(logs[i].equals(\"../\")){\\n                if(res>0)res--;\\n                continue;\\n            }\\n            else{\\n                res++;\\n            }\\n        }\\n        return res;\\n    }\\n}",
                "solutionTags": [
                    "Java"
                ],
                "code": "class Solution {\\n    public int minOperations(String[] logs) {\\n        int res=0;\\n        for(int i=0;i<logs.length;i++){\\n            if(logs[i].equals(\"./\"))continue;\\n            else if(logs[i].equals(\"../\")){\\n                if(res>0)res--;\\n                continue;\\n            }",
                "codeTag": "Java"
            },
            {
                "id": 1930803,
                "title": "java-solution-using-stack-faster-than-96-26",
                "content": "class Solution {\\n    public int minOperations(String[] logs) {\\n\\t\\n        Stack<String> stack = new Stack();\\n        \\n        for (String log: logs){\\n            \\n            if (log.equals(\"./\")){\\n                continue;\\n            }\\n           else if (log.equals(\"../\")){\\n                if (!stack.empty()){\\n                    stack.pop();\\n                }\\n            }\\n            else {\\n                 stack.push(\"a\");\\n            }\\n            \\n        }\\n        return stack.size();\\n    }\\n}\\n",
                "solutionTags": [
                    "Java",
                    "Stack"
                ],
                "code": "class Solution {\\n    public int minOperations(String[] logs) {\\n\\t\\n        Stack<String> stack = new Stack();\\n        \\n        for (String log: logs){\\n            \\n            if (log.equals(\"./\")){\\n                continue;\\n            }",
                "codeTag": "Java"
            },
            {
                "id": 1903464,
                "title": "java-solution-using-stack-simplest-you-can-find",
                "content": "```\\nclass Solution {\\n    public int minOperations(String[] logs) {\\n       Stack<String> stack = new Stack<>();\\n       for(int i=0;i<logs.length;i++){\\n           if(stack.empty()&&(logs[i].contains(\"../\")||logs[i].contains(\"./\")))\\n               continue;\\n         if(logs[i].contains(\"../\"))\\n         {\\n             stack.pop();\\n         }\\n          else if(logs[i].contains(\"./\"))\\n          { \\n              stack.peek();\\n          }\\n           else stack.add(\"d\");\\n      }  \\n        return stack.size();\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Stack"
                ],
                "code": "```\\nclass Solution {\\n    public int minOperations(String[] logs) {\\n       Stack<String> stack = new Stack<>();\\n       for(int i=0;i<logs.length;i++){\\n           if(stack.empty()&&(logs[i].contains(\"../\")||logs[i].contains(\"./\")))\\n               continue;\\n         if(logs[i].contains(\"../\"))\\n         {\\n             stack.pop();\\n         }\\n          else if(logs[i].contains(\"./\"))\\n          { \\n              stack.peek();\\n          }\\n           else stack.add(\"d\");\\n      }  \\n        return stack.size();\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1556542,
                "title": "short-code-0-n-and-0-1-c-easy-to-understand-100-faster-solution",
                "content": "int minOperations(vector<string>& logs) {\\n        \\n        int count=0;\\n        \\n        for(int i=0;i<logs.size();i++){\\n            if(logs[i]!=\"../\" and logs[i]!=\"./\")\\n                count++;\\n            \\n            else if(logs[i]==\"../\"){\\n                if(count>=2) count--;\\n                else count=0;\\n            }\\n            else\\n                continue;\\n            \\n        }\\n        \\n        \\n        \\n        return count;\\n    }",
                "solutionTags": [],
                "code": "int minOperations(vector<string>& logs) {\\n        \\n        int count=0;\\n        \\n        for(int i=0;i<logs.size();i++){\\n            if(logs[i]!=\"../\" and logs[i]!=\"./\")\\n                count++;\\n            \\n            else if(logs[i]==\"../\"){\\n                if(count>=2) count--;\\n                else count=0;\\n            }\\n            else\\n                continue;\\n            \\n        }\\n        \\n        \\n        \\n        return count;\\n    }",
                "codeTag": "Unknown"
            },
            {
                "id": 1540186,
                "title": "easy-c-solution",
                "content": "```\\nclass Solution \\n{\\npublic:\\n    int minOperations(vector<string>& logs) \\n    {\\n        stack<string>stk;\\n        for(int i=0;i<logs.size();i++)\\n        {\\n            if(logs[i]!=\"../\" && logs[i]!=\"./\")\\n            {\\n                stk.push(logs[i]);\\n            }\\n            else if(logs[i]==\"../\" && !stk.empty())\\n            {\\n                stk.pop();\\n            }\\n        }\\n        return stk.size();\\n    }\\n};\\n```\\n***Please upvote if you have got any help from my code. Thank you.***",
                "solutionTags": [
                    "C",
                    "Stack"
                ],
                "code": "```\\nclass Solution \\n{\\npublic:\\n    int minOperations(vector<string>& logs) \\n    {\\n        stack<string>stk;\\n        for(int i=0;i<logs.size();i++)\\n        {\\n            if(logs[i]!=\"../\" && logs[i]!=\"./\")\\n            {\\n                stk.push(logs[i]);\\n            }\\n            else if(logs[i]==\"../\" && !stk.empty())\\n            {\\n                stk.pop();\\n            }\\n        }\\n        return stk.size();\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1534807,
                "title": "c-90-fast-without-extra-space",
                "content": "```\\nclass Solution {\\npublic:\\n    int minOperations(vector<string>& logs) {\\n        int ans=0;\\n        for(int i=0; i<logs.size(); i++){\\n            string s=logs[i];\\n            if(s==\"../\") ans--;\\n            else if(s==\"./\") continue;\\n            else ans++;\\n            if(ans<0) ans=0;\\n        }\\n           return ans;\\n    }\\n};",
                "solutionTags": [],
                "code": "class Solution {\\npublic:\\n    int minOperations(vector<string>& logs) {\\n        int ans=0;\\n        for(int i=0; i<logs.size(); i++){\\n            string s=logs[i];\\n            if(s==\"../\") ans--;\\n            else if(s==\"./\") continue;\\n            else ans++;\\n            if(ans<0) ans=0;\\n        }",
                "codeTag": "Java"
            },
            {
                "id": 1534633,
                "title": "java-easy-solution",
                "content": "```\\nclass Solution {\\n    public int minOperations(String[] logs) {\\n        int count=0;\\n        for(String temp:logs){\\n            if(temp.substring(0,2).equals(\"..\"))\\n                count=(count-1)<0?0:(count-1);\\n            else if(!temp.substring(0,2).equals(\"./\"))\\n                count++;\\n        }\\n        return count;\\n        \\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    public int minOperations(String[] logs) {\\n        int count=0;\\n        for(String temp:logs){\\n            if(temp.substring(0,2).equals(\"..\"))\\n                count=(count-1)<0?0:(count-1);\\n            else if(!temp.substring(0,2).equals(\"./\"))\\n                count++;\\n        }\\n        return count;\\n        \\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1373644,
                "title": "c-simpe-string",
                "content": "```\\nclass Solution {\\npublic:\\n    int minOperations(vector<string>& logs) {\\n        int count=0;\\n        for(int i=0;i<logs.size();i++){\\n            if(logs[i]==\"./\"){\\n                count=count;\\n            }else if(logs[i]==\"../\"){\\n                if(count>0){\\n                    count--;\\n                }\\n            }else{\\n                count++;\\n            }\\n        }\\n        return count;\\n    }\\n};",
                "solutionTags": [
                    "C"
                ],
                "code": "class Solution {\\npublic:\\n    int minOperations(vector<string>& logs) {\\n        int count=0;\\n        for(int i=0;i<logs.size();i++){\\n            if(logs[i]==\"./\"){\\n                count=count;\\n            }",
                "codeTag": "Java"
            },
            {
                "id": 1366348,
                "title": "simple-java-100",
                "content": "```\\npublic int minOperations(String[] logs) {\\n        int depth = 0;\\n        for (String s : logs) {\\n            depth -= s.charAt(0) == \\'.\\' ? depth == 0 || s.charAt(1) == \\'/\\' ? 0 : 1 : -1;\\n        }\\n        return depth;\\n    }\\n```\\n",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\npublic int minOperations(String[] logs) {\\n        int depth = 0;\\n        for (String s : logs) {\\n            depth -= s.charAt(0) == \\'.\\' ? depth == 0 || s.charAt(1) == \\'/\\' ? 0 : 1 : -1;\\n        }\\n        return depth;\\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1291927,
                "title": "easy-python-solution-93-94",
                "content": "Runtime: 40 ms, faster than 93.94% of Python3 online submissions for Crawler Log Folder.\\nMemory Usage: 14.5 MB, less than 22.91% of Python3 online submissions for Crawler Log Folder.\\n```\\nclass Solution:\\n    def minOperations(self, logs: List[str]) -> int:\\n        stack=[]\\n        for i in logs:\\n            if(i==\\'../\\' and stack):\\n                stack.pop()\\n            elif(i==\\'./\\'):\\n                continue\\n            elif(i!=\\'../\\' ):\\n                stack.append(i)\\n        return len(stack)",
                "solutionTags": [
                    "Python",
                    "Python3"
                ],
                "code": "Runtime: 40 ms, faster than 93.94% of Python3 online submissions for Crawler Log Folder.\\nMemory Usage: 14.5 MB, less than 22.91% of Python3 online submissions for Crawler Log Folder.\\n```\\nclass Solution:\\n    def minOperations(self, logs: List[str]) -> int:\\n        stack=[]\\n        for i in logs:\\n            if(i==\\'../\\' and stack):\\n                stack.pop()\\n            elif(i==\\'./\\'):\\n                continue\\n            elif(i!=\\'../\\' ):\\n                stack.append(i)\\n        return len(stack)",
                "codeTag": "Java"
            },
            {
                "id": 1247348,
                "title": "c-iterative-solution",
                "content": "If logs[i] == \"../\" dercrease the count variable but we can\\'t move beyond main folder so check if (count != 0) than only decrement the count, and we don\\'t have to do anything if we found \"./\" so check if (logs[i] != \"./\") it means logs[i] must be equal to \"x/\" so increment the count variable.\\n\\n```\\nclass Solution {\\npublic:\\n    int minOperations(vector<string>& logs) {\\n\\n        int count = 0;\\n        \\n        for (int i =0; i< logs.size(); i++){\\n            if (logs[i] == \"../\") {\\n                if (count != 0) count--;\\n            }\\n            else if (logs[i] != \"./\") count++;\\n        }\\n        return count;\\n    }\\n};",
                "solutionTags": [
                    "C++"
                ],
                "code": "class Solution {\\npublic:\\n    int minOperations(vector<string>& logs) {\\n\\n        int count = 0;\\n        \\n        for (int i =0; i< logs.size(); i++){\\n            if (logs[i] == \"../\") {\\n                if (count != 0) count--;\\n            }",
                "codeTag": "Java"
            },
            {
                "id": 1229983,
                "title": "c-0ms-stack-easy-to-understand-with-explanation",
                "content": "```\\n//You can understand easily by understanding that pop is basically one step back, so that \\n//means \"../\" and \"./\" means we are in the same folder so it\\'s obvious continue there (i.e no \\n//pushing in stack) and the reamaining action is getting inside a folder, so pushing in the stack. \\n//So at the end if we simply return the size of stack that means we have to go that much back \\n//to reach the root folder. There are just few edge cases that you need to see carefully, rest it\\'s \\n//pretty easy.\\n\\nclass Solution {\\npublic:\\n    int minOperations(vector<string>& logs) {\\n        int n = logs.size();\\n        stack<string> s;\\n        for(int i=0; i<n; i++) {\\n            if(logs[i]==\"../\" && !s.empty()) s.pop();\\n            else if(logs[i]==\"./\") continue;\\n            else if(logs[i]==\"../\" && s.empty()) continue;  //special case\\n            else s.push(logs[i]);\\n        }\\n        \\n        return s.empty() ? 0 : s.size();\\n    }\\n};\\n```\\n",
                "solutionTags": [],
                "code": "```\\n//You can understand easily by understanding that pop is basically one step back, so that \\n//means \"../\" and \"./\" means we are in the same folder so it\\'s obvious continue there (i.e no \\n//pushing in stack) and the reamaining action is getting inside a folder, so pushing in the stack. \\n//So at the end if we simply return the size of stack that means we have to go that much back \\n//to reach the root folder. There are just few edge cases that you need to see carefully, rest it\\'s \\n//pretty easy.\\n\\nclass Solution {\\npublic:\\n    int minOperations(vector<string>& logs) {\\n        int n = logs.size();\\n        stack<string> s;\\n        for(int i=0; i<n; i++) {\\n            if(logs[i]==\"../\" && !s.empty()) s.pop();\\n            else if(logs[i]==\"./\") continue;\\n            else if(logs[i]==\"../\" && s.empty()) continue;  //special case\\n            else s.push(logs[i]);\\n        }\\n        \\n        return s.empty() ? 0 : s.size();\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1221698,
                "title": "java-100-fast-easy-to-understand",
                "content": "```\\npublic int minOperations(String[] logs) {\\n\\tint ops = 0;\\n\\tfor (String log : logs) {\\n\\t\\tif (log.equals(\"../\")) {\\n\\t\\t\\tif (ops != 0)\\n\\t\\t\\t\\tops--;\\n\\t\\t} else if (log.equals(\"./\")) {\\n\\t\\t\\tcontinue;\\n\\t\\t} else {\\n\\t\\t\\tops++;\\n\\t\\t}\\n\\t}\\n\\treturn ops;\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\npublic int minOperations(String[] logs) {\\n\\tint ops = 0;\\n\\tfor (String log : logs) {\\n\\t\\tif (log.equals(\"../\")) {\\n\\t\\t\\tif (ops != 0)\\n\\t\\t\\t\\tops--;\\n\\t\\t} else if (log.equals(\"./\")) {\\n\\t\\t\\tcontinue;\\n\\t\\t} else {\\n\\t\\t\\tops++;\\n\\t\\t}\\n\\t}\\n\\treturn ops;\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1220046,
                "title": "python-a-single-pass-solution",
                "content": "```\\nclass Solution:\\n    def minOperations(self, logs: List[str]) -> int:\\n        counter = 0\\n        for log in logs:\\n            if log == \"../\":\\n                counter = max(0, counter - 1)\\n            elif log != \"./\":\\n                counter += 1\\n        return  counter\\n```",
                "solutionTags": [
                    "Python"
                ],
                "code": "```\\nclass Solution:\\n    def minOperations(self, logs: List[str]) -> int:\\n        counter = 0\\n        for log in logs:\\n            if log == \"../\":\\n                counter = max(0, counter - 1)\\n            elif log != \"./\":\\n                counter += 1\\n        return  counter\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1208698,
                "title": "python-3-one-line",
                "content": "Use `reduce` to keep track of the depth as we iterate through the folders.\\nUse `dict.get` with a default value to calculate the depth change:\\n  * `../` -> depth - 1 (but no lower than 0)\\n  * `./` -> depth\\n  * anything else -> depth + 1 \\n\\n```python\\nclass Solution:\\n  def minOperations(self, L: List[str]) -> int:\\n    return reduce(lambda d,l: {\"../\":max(d-1,0), \"./\":d}.get(l, d+1), L, 0)\\n```",
                "solutionTags": [],
                "code": "```python\\nclass Solution:\\n  def minOperations(self, L: List[str]) -> int:\\n    return reduce(lambda d,l: {\"../\":max(d-1,0), \"./\":d}.get(l, d+1), L, 0)\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1175717,
                "title": "js-straightforward-solution-with-stack-68ms",
                "content": "```\\nvar minOperations = function(logs) {\\n    const stack = [];\\n\\n    for(let log of logs){\\n        if(log === \"../\") stack.pop();\\n        else if(log === \"./\") continue;\\n        else stack.push(log)\\n    }  \\n\\n    return stack.length;\\n};\\n```\\nI\\'d love to hear your suggestions, thanks!",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\nvar minOperations = function(logs) {\\n    const stack = [];\\n\\n    for(let log of logs){\\n        if(log === \"../\") stack.pop();\\n        else if(log === \"./\") continue;\\n        else stack.push(log)\\n    }  \\n\\n    return stack.length;\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1155639,
                "title": "java-ez-stack",
                "content": "class Solution {\\n    public int minOperations(String[] logs) {\\n\\t\\n        Stack<String> stk=new Stack<>();\\n        for(String log:logs)\\n        {\\n            if(log.equals(\"../\"))\\n            {\\n                if(stk.size()>0)\\n                    stk.pop();\\n            }\\n            else if(!log.equals(\"./\"))\\n                stk.push(log);\\n        }\\n        return stk.size();\\n        \\n    }\\n}",
                "solutionTags": [],
                "code": "class Solution {\\n    public int minOperations(String[] logs) {\\n\\t\\n        Stack<String> stk=new Stack<>();\\n        for(String log:logs)\\n        {\\n            if(log.equals(\"../\"))\\n            {\\n                if(stk.size()>0)\\n                    stk.pop();\\n            }",
                "codeTag": "Java"
            },
            {
                "id": 1154304,
                "title": "swift-100-no-stack",
                "content": "```\\nclass Solution {\\n    func minOperations(_ logs: [String]) -> Int {\\n        var steps = 0\\n        for log in logs {\\n            switch log {\\n                case \"../\":\\n                    steps -= 1\\n                    steps = max(steps, 0)\\n                case \"./\":\\n                    break\\n                default:\\n                    steps += 1\\n            }\\n        }\\n        return steps\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    func minOperations(_ logs: [String]) -> Int {\\n        var steps = 0\\n        for log in logs {\\n            switch log {\\n                case \"../\":\\n                    steps -= 1\\n                    steps = max(steps, 0)\\n                case \"./\":\\n                    break\\n                default:\\n                    steps += 1\\n            }\\n        }\\n        return steps\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1131355,
                "title": "rust-clean-match",
                "content": "```rust\\nimpl Solution {\\n    pub fn min_operations(logs: Vec<String>) -> i32 {\\n        logs.iter().fold(0, |acc, log| match log.as_str() {\\n            \"../\" if acc > 0 => acc - 1,\\n            \"../\" | \"./\" => acc,\\n            _ => acc + 1,\\n        })\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```rust\\nimpl Solution {\\n    pub fn min_operations(logs: Vec<String>) -> i32 {\\n        logs.iter().fold(0, |acc, log| match log.as_str() {\\n            \"../\" if acc > 0 => acc - 1,\\n            \"../\" | \"./\" => acc,\\n            _ => acc + 1,\\n        })\\n    }\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1110092,
                "title": "java-simple-solution-0ms-beats-100",
                "content": "If you think of the directory hierarchy as a tree structure, this question is simply to figure out where you stand in the tree (the depth from the root or the main folder in this case) after performing all the operations in the logs array.\\n\\nHaving said that, we start from the main folder, where depth is 0. \\n\\nWhen encounter  \"../\", depth decrease by 1,  unless depth is at 0, then stay at 0; \\n\\nWhen encounter \"./\", do nothing. \\n\\nOtherwise, when encounter any other String, depth increase by one. \\n\\nAt the end, the final depth value will be what it takes to return back to the main folder.\\n\\n```\\nclass Solution {\\n    public int minOperations(String[] logs) {\\n        \\n        int depth = 0;\\n        for (String s : logs)\\n        {\\n           if (\"../\".equals(s))\\n           {\\n              depth = depth == 0 ? 0 : depth - 1;\\n           }\\n           else if (\"./\".equals(s));\\n           else\\n           {\\n               depth++;\\n           }\\n        }\\n        return depth;\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    public int minOperations(String[] logs) {\\n        \\n        int depth = 0;\\n        for (String s : logs)\\n        {\\n           if (\"../\".equals(s))\\n           {\\n              depth = depth == 0 ? 0 : depth - 1;\\n           }\\n           else if (\"./\".equals(s));\\n           else\\n           {\\n               depth++;\\n           }\\n        }\\n        return depth;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1095666,
                "title": "simple-java-solution-no-stack",
                "content": "```\\nclass Solution {\\n    public int minOperations(String[] logs) {\\n        int counter = 0;\\n        for(int i =0 ;i<logs.length;i++){\\n            \\n            if(logs[i].equals(\"./\"))\\n                continue;\\n            else if(logs[i].equals(\"../\")){\\n                counter -=1;\\n            }else{\\n                counter++;\\n            }\\n            if(counter <0){\\n                counter = 0;\\n            }\\n        }\\n        return counter;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int minOperations(String[] logs) {\\n        int counter = 0;\\n        for(int i =0 ;i<logs.length;i++){\\n            \\n            if(logs[i].equals(\"./\"))\\n                continue;\\n            else if(logs[i].equals(\"../\")){\\n                counter -=1;\\n            }else{\\n                counter++;\\n            }\\n            if(counter <0){\\n                counter = 0;\\n            }\\n        }\\n        return counter;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1048167,
                "title": "go-solution-faster-than-100",
                "content": "The else if with `long != \"../\"` is here because in the first if it says if `len(stack) > 0 && log == \"../\"` which means that if `log == \"../\"` and `len(stack)` is smaller than `0` the code will just append `\"../\"`\\n\\n```\\nfunc minOperations(logs []string) int {\\n\\tstack := []string{}\\n\\n\\tfor _, log := range logs {\\n\\t\\tif len(stack) > 0 && log == \"../\" {\\n\\t\\t\\tstack = stack[:len(stack)-1]\\n\\t\\t} else if log == \"./\" {\\n\\t\\t\\tcontinue\\n\\t\\t} else if log != \"../\" { \\n\\t\\t\\tstack = append(stack, log)\\n\\t\\t}\\n\\t}\\n\\tfmt.Println(stack)\\n\\treturn len(stack)\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nfunc minOperations(logs []string) int {\\n\\tstack := []string{}\\n\\n\\tfor _, log := range logs {\\n\\t\\tif len(stack) > 0 && log == \"../\" {\\n\\t\\t\\tstack = stack[:len(stack)-1]\\n\\t\\t} else if log == \"./\" {\\n\\t\\t\\tcontinue\\n\\t\\t} else if log != \"../\" { \\n\\t\\t\\tstack = append(stack, log)\\n\\t\\t}\\n\\t}\\n\\tfmt.Println(stack)\\n\\treturn len(stack)\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 896197,
                "title": "c-simple-and-understandable-approach",
                "content": "```\\nclass Solution {\\npublic:\\n    int minOperations(vector<string>& logs) {\\n        int count=0;\\n        for(int i=0;i<logs.size();i++)\\n        {\\n            if(logs[i]==\"./\")continue;\\n            if(logs[i]==\"../\" && count==0)continue;\\n            if(logs[i]==\"../\" && count!=0)count--;\\n            else count++;\\n            \\n        }\\n        return count;\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    int minOperations(vector<string>& logs) {\\n        int count=0;\\n        for(int i=0;i<logs.size();i++)\\n        {\\n            if(logs[i]==\"./\")continue;\\n            if(logs[i]==\"../\" && count==0)continue;\\n            if(logs[i]==\"../\" && count!=0)count--;\\n            else count++;\\n            \\n        }\\n        return count;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 883835,
                "title": "stack-based-solution-o-n-c",
                "content": "```\\nclass Solution {\\npublic:\\n    int minOperations(vector<string>& A) {\\n        stack<int> st;\\n        for(int i = 0 ; i < A.size() ; i++){\\n            if(A[i].size() == 3 and A[i][0] == \\'.\\'){\\n                if(st.size() > 0 )  // move up the folder means u can remove it  only if there is an element\\n                    st.pop(); // left in stack\\n            }else if(A[i].size() == 2 and A[i][0] == \\'.\\'){ // do nothing\\n                \\n            }else{\\n                st.push(1);  // increase stack size \\n            }\\n        }\\n        return st.size();  // return size of stack\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Stack"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int minOperations(vector<string>& A) {\\n        stack<int> st;\\n        for(int i = 0 ; i < A.size() ; i++){\\n            if(A[i].size() == 3 and A[i][0] == \\'.\\'){\\n                if(st.size() > 0 )  // move up the folder means u can remove it  only if there is an element\\n                    st.pop(); // left in stack\\n            }else if(A[i].size() == 2 and A[i][0] == \\'.\\'){ // do nothing\\n                \\n            }else{\\n                st.push(1);  // increase stack size \\n            }\\n        }\\n        return st.size();  // return size of stack\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 883234,
                "title": "easy-python-solution-time-better-than-70-space-better-than-90",
                "content": "```\\nclass Solution:\\n    def minOperations(self, logs: List[str]) -> int:\\n        stack = []\\n        stack_top = -1\\n        pointer = 0\\n        while pointer < len(logs):\\n            if logs[pointer] == \"../\":\\n                if stack_top != -1:\\n                    stack.pop(-1)\\n                    stack_top-=1\\n                pointer+=1\\n            elif logs[pointer] == \"./\":\\n                pointer+=1\\n            else:\\n                stack.append(logs[pointer])\\n                stack_top+=1\\n                pointer+=1\\n        return len(stack)\\n    \\n```\\nGITHUB for more solutions: https://github.com/Kushagrabainsla/Leetcode_DSA",
                "solutionTags": [],
                "code": "```\\nclass Solution:\\n    def minOperations(self, logs: List[str]) -> int:\\n        stack = []\\n        stack_top = -1\\n        pointer = 0\\n        while pointer < len(logs):\\n            if logs[pointer] == \"../\":\\n                if stack_top != -1:\\n                    stack.pop(-1)\\n                    stack_top-=1\\n                pointer+=1\\n            elif logs[pointer] == \"./\":\\n                pointer+=1\\n            else:\\n                stack.append(logs[pointer])\\n                stack_top+=1\\n                pointer+=1\\n        return len(stack)\\n    \\n```",
                "codeTag": "Java"
            },
            {
                "id": 882024,
                "title": "c-4-ms-and-8-ms-solutions-stack-approach-o-1-space",
                "content": "***Runtime: 4 ms, faster than 99.25% of C++ online submissions for Crawler Log Folder.\\nMemory Usage: 11 MB, less than 12.36% of C++ online submissions for Crawler Log Folder.***\\n```\\nclass Solution {\\npublic:\\n    int minOperations(vector<string>& logs) {\\n        stack<string> path;\\n        for(auto log:logs){\\n            if(log == \"../\" && !path.empty()){\\n                path.pop();\\n            }\\n            if(log != \"../\" && log != \"./\"){\\n                path.push(log);\\n            }\\n        }\\n        return path.size();\\n    }\\n};\\n```\\n\\n***Runtime: 8 ms, faster than 89.41% of C++ online submissions for Crawler Log Folder.\\nMemory Usage: 10.7 MB, less than 71.34% of C++ online submissions for Crawler Log Folder.***\\n```\\nclass Solution {\\npublic:\\n    int minOperations(vector<string>& logs) {\\n        int result = 0;\\n        for(auto log:logs){\\n            if(log == \"../\"){\\n                result = max(0, result-1);\\n            }else if(log != \"./\"){\\n                result++;\\n            }\\n        }\\n        return result;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "C"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int minOperations(vector<string>& logs) {\\n        stack<string> path;\\n        for(auto log:logs){\\n            if(log == \"../\" && !path.empty()){\\n                path.pop();\\n            }\\n            if(log != \"../\" && log != \"./\"){\\n                path.push(log);\\n            }\\n        }\\n        return path.size();\\n    }\\n};\\n```\n```\\nclass Solution {\\npublic:\\n    int minOperations(vector<string>& logs) {\\n        int result = 0;\\n        for(auto log:logs){\\n            if(log == \"../\"){\\n                result = max(0, result-1);\\n            }else if(log != \"./\"){\\n                result++;\\n            }\\n        }\\n        return result;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 878901,
                "title": "simple-java-o-n-solution",
                "content": "```\\nclass Solution {\\n    public int minOperations(String[] logs) {\\n        int level = 0;\\n        for (String log : logs) {\\n            if (log.equals(\"../\")) {\\n                if (level > 0) level--;\\n            } else if (log.equals(\"./\")) {\\n                \\n            } else {\\n                level++;\\n            }\\n        }\\n        return level;\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    public int minOperations(String[] logs) {\\n        int level = 0;\\n        for (String log : logs) {\\n            if (log.equals(\"../\")) {\\n                if (level > 0) level--;\\n            } else if (log.equals(\"./\")) {\\n                \\n            } else {\\n                level++;\\n            }\\n        }\\n        return level;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 876216,
                "title": "c-solution",
                "content": "```\\nclass Solution {\\npublic:\\n    int minOperations(vector<string>& logs,int cnt=0) {\\n        for(auto str:logs){\\n            if(str==\"../\")  cnt = max(0,--cnt);\\n            else if(str!=\"./\") cnt++;\\n        }\\n        return cnt;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int minOperations(vector<string>& logs,int cnt=0) {\\n        for(auto str:logs){\\n            if(str==\"../\")  cnt = max(0,--cnt);\\n            else if(str!=\"./\") cnt++;\\n        }\\n        return cnt;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 872459,
                "title": "a-c-python-3-solution-stack-time-complexity-o-n-easy-to-understand",
                "content": "```\\nclass Solution:\\n    def minOperations(self, logs: List[str]) -> int:\\n        stack = []\\n        n = len(logs)\\n        for i in range(n):\\n            a = logs[i]\\n            print (\"i  = \", i, \" a = \", a)\\n            if (a == \"../\"):\\n                if (len(stack) > 0):\\n                    stack.pop()\\n            elif (a == \"./\"):\\n                continue\\n            else:\\n                stack.append(a)\\n                \\n        print (\"end stack = \", stack)\\n        return len(stack)\\n            \\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution:\\n    def minOperations(self, logs: List[str]) -> int:\\n        stack = []\\n        n = len(logs)\\n        for i in range(n):\\n            a = logs[i]\\n            print (\"i  = \", i, \" a = \", a)\\n            if (a == \"../\"):\\n                if (len(stack) > 0):\\n                    stack.pop()\\n            elif (a == \"./\"):\\n                continue\\n            else:\\n                stack.append(a)\\n                \\n        print (\"end stack = \", stack)\\n        return len(stack)\\n            \\n```",
                "codeTag": "Java"
            },
            {
                "id": 867307,
                "title": "c-easy-solution-o-n",
                "content": "```\\nint minOperations(vector<string>& logs) {\\n\\tint res = 0;\\n\\tfor (string s : logs) {\\n\\t\\tif (s == \"./\")\\n\\t\\t\\tcontinue;\\n\\t\\telse if (s != \"../\")\\n\\t\\t\\tres++;\\n\\t\\telse if (res)\\n\\t\\t\\tres--;\\n\\t}\\n\\treturn res;\\n}\\n```\\n",
                "solutionTags": [
                    "C++",
                    "C"
                ],
                "code": "```\\nint minOperations(vector<string>& logs) {\\n\\tint res = 0;\\n\\tfor (string s : logs) {\\n\\t\\tif (s == \"./\")\\n\\t\\t\\tcontinue;\\n\\t\\telse if (s != \"../\")\\n\\t\\t\\tres++;\\n\\t\\telse if (res)\\n\\t\\t\\tres--;\\n\\t}\\n\\treturn res;\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 867016,
                "title": "swift-beats-100-simple-solution",
                "content": "```\\nfunc minOperations(_ logs: [String]) -> Int {\\n      var count = 0\\n      for log in logs where log != \"./\" {\\n        count += log == \"../\" ? -1 : 1\\n        count = count < 0 ? 0 : count\\n      }\\n      return count\\n    }\\n```",
                "solutionTags": [
                    "Swift"
                ],
                "code": "```\\nfunc minOperations(_ logs: [String]) -> Int {\\n      var count = 0\\n      for log in logs where log != \"./\" {\\n        count += log == \"../\" ? -1 : 1\\n        count = count < 0 ? 0 : count\\n      }\\n      return count\\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 866969,
                "title": "100-faster-100-memory-c-c-javascript-java",
                "content": "C\\n```\\nint minOperations(char ** logs, int logsSize){\\n    int res = 0;\\n        for(int i =0;i<logsSize;i++){\\n            if(strcmp(logs[i],\"./\") == 0)continue;\\n            else if(strcmp(logs[i],\"../\") == 0){\\n                if(res !=0)res--;\\n            }\\n            else res++;\\n        }\\n        \\n        return res;\\n}\\n```\\n\\nC++\\n\\n```\\nclass Solution {\\npublic:\\n    int minOperations(vector<string>& logs) {\\n        int res = 0;\\n        for(int i =0;i<logs.size();i++){\\n            if(logs[i].compare(\"./\") == 0)continue;\\n            else if(logs[i].compare(\"../\") == 0){\\n                if(res !=0)res--;\\n            }\\n            else res++;\\n        }\\n        \\n        return res;\\n    }\\n};\\n```\\nJava\\n```\\nclass Solution {\\n    public int minOperations(String[] logs) {\\n        int res = 0;\\n        for(int i =0;i<logs.length;i++){\\n            if(logs[i].equals(\"./\"))continue;\\n            else if(logs[i].equals(\"../\")){\\n                if(res !=0)res--;\\n            }\\n            else res++;\\n        }\\n        \\n        return res;\\n        \\n    }\\n}\\n```\\nJavaScript\\n```\\nvar minOperations = function(logs) {\\n    var res = 0;\\n        for(var i =0;i<logs.length;i++){\\n            if(logs[i] == (\"./\")){}\\n            else if(logs[i] == (\"../\")){\\n                if(res !=0)res--;\\n            }\\n            else res++;\\n        }\\n        \\n        return res;\\n};\\n```",
                "solutionTags": [
                    "Java",
                    "C",
                    "JavaScript"
                ],
                "code": "```\\nint minOperations(char ** logs, int logsSize){\\n    int res = 0;\\n        for(int i =0;i<logsSize;i++){\\n            if(strcmp(logs[i],\"./\") == 0)continue;\\n            else if(strcmp(logs[i],\"../\") == 0){\\n                if(res !=0)res--;\\n            }\\n            else res++;\\n        }\\n        \\n        return res;\\n}\\n```\n```\\nclass Solution {\\npublic:\\n    int minOperations(vector<string>& logs) {\\n        int res = 0;\\n        for(int i =0;i<logs.size();i++){\\n            if(logs[i].compare(\"./\") == 0)continue;\\n            else if(logs[i].compare(\"../\") == 0){\\n                if(res !=0)res--;\\n            }\\n            else res++;\\n        }\\n        \\n        return res;\\n    }\\n};\\n```\n```\\nclass Solution {\\n    public int minOperations(String[] logs) {\\n        int res = 0;\\n        for(int i =0;i<logs.length;i++){\\n            if(logs[i].equals(\"./\"))continue;\\n            else if(logs[i].equals(\"../\")){\\n                if(res !=0)res--;\\n            }\\n            else res++;\\n        }\\n        \\n        return res;\\n        \\n    }\\n}\\n```\n```\\nvar minOperations = function(logs) {\\n    var res = 0;\\n        for(var i =0;i<logs.length;i++){\\n            if(logs[i] == (\"./\")){}\\n            else if(logs[i] == (\"../\")){\\n                if(res !=0)res--;\\n            }\\n            else res++;\\n        }\\n        \\n        return res;\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 866794,
                "title": "beginner-friendly-solution-with-clean-explanation",
                "content": "Number of operations to get back to main folder is equal to the number of levels we are away from main folder.\\nTo keep track of number of levels (depth) we are in, let us use `res` variable.\\n`res = 0` for main folder.\\n\\n```\\nclass Solution {\\n    public int minOperations(String[] logs) {\\n        int res = 0;\\n        for(int i=0;i<logs.length;i++){\\n            String currOperation = logs[i];\\n\\t\\t\\t//If not home and back operation - We go back one level.\\n            if(res>0 && \"../\".equals(currOperation)) res--; \\n\\t\\t\\t//If ./ or if (main folder and ../) we do nothing.\\n            else if(currOperation.startsWith(\".\")) continue;\\n\\t\\t\\t//If forward operation - We add one level.\\n            else res++;\\n        }\\n        return res;\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    public int minOperations(String[] logs) {\\n        int res = 0;\\n        for(int i=0;i<logs.length;i++){\\n            String currOperation = logs[i];\\n\\t\\t\\t//If not home and back operation - We go back one level.\\n            if(res>0 && \"../\".equals(currOperation)) res--; \\n\\t\\t\\t//If ./ or if (main folder and ../) we do nothing.\\n            else if(currOperation.startsWith(\".\")) continue;\\n\\t\\t\\t//If forward operation - We add one level.\\n            else res++;\\n        }\\n        return res;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 866691,
                "title": "c-straightforward-single-pass-with-brief-explanation-o-1-space",
                "content": "**Brief Explanation**\\nIncrement minimum operations required for every move to child folder. Decrement minimum operations required **iff** currently the minimum operations required are greater than **0** (*i.e. we are not at the main folder already*) and current operation is move to parent folder.\\n\\n```\\nclass Solution {\\npublic:\\n    int minOperations(vector<string>& logs) {\\n        int min_ops = 0;\\n        for (const auto& log: logs) {\\n            if (log[0] != \\'.\\') {\\n                min_ops++;\\n            }\\n            else if (log == \"../\" && min_ops > 0) {\\n                min_ops--;\\n            }\\n        }\\n        return min_ops;\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    int minOperations(vector<string>& logs) {\\n        int min_ops = 0;\\n        for (const auto& log: logs) {\\n            if (log[0] != \\'.\\') {\\n                min_ops++;\\n            }\\n            else if (log == \"../\" && min_ops > 0) {\\n                min_ops--;\\n            }\\n        }\\n        return min_ops;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 866604,
                "title": "python-easy-short-obvious",
                "content": "```\\nclass Solution:\\n    def minOperations(self, logs: List[str]) -> int:\\n        \\n        depth=0\\n        for operation in logs:\\n            if operation==\"../\": depth = max(0, depth -1)\\n            if (operation != \"../\") and (operation !=\"./\"): depth += 1\\n                \\n        return depth\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution:\\n    def minOperations(self, logs: List[str]) -> int:\\n        \\n        depth=0\\n        for operation in logs:\\n            if operation==\"../\": depth = max(0, depth -1)\\n            if (operation != \"../\") and (operation !=\"./\"): depth += 1\\n                \\n        return depth\\n```",
                "codeTag": "Java"
            },
            {
                "id": 866552,
                "title": "c-1-liner",
                "content": "```cpp\\nint minOperations(vector<string>& logs) {\\n    return accumulate(logs.begin(), logs.end(), 0, [](int n, const string &s) { return s == \"../\" ? max(0, n - 1) : (s == \"./\" ? n : n + 1); });\\n}\\n```\\nNormal version:\\n```cpp\\nint minOperations(vector<string>& logs) {\\n    int ans = 0;\\n    for (auto & s : logs) {\\n        if (s == \"../\")\\n            ans = max(0, ans - 1);\\n        else if (s != \"./\")\\n            ++ans;\\n    }\\n    return ans;\\n}\\n```\\nT: O(n)\\nS: O(1)\\n",
                "solutionTags": [
                    "C"
                ],
                "code": "```cpp\\nint minOperations(vector<string>& logs) {\\n    return accumulate(logs.begin(), logs.end(), 0, [](int n, const string &s) { return s == \"../\" ? max(0, n - 1) : (s == \"./\" ? n : n + 1); });\\n}\\n```\n```cpp\\nint minOperations(vector<string>& logs) {\\n    int ans = 0;\\n    for (auto & s : logs) {\\n        if (s == \"../\")\\n            ans = max(0, ans - 1);\\n        else if (s != \"./\")\\n            ++ans;\\n    }\\n    return ans;\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 866537,
                "title": "java-very-simple-o-n-solution",
                "content": "```\\nclass Solution {\\n    public int minOperations(String[] logs) {\\n        int depth=0;\\n        for (String l : logs) {\\n            if (l.charAt(1)==\\'.\\') {\\n                if (depth > 0) {\\n                    depth--;\\n                }\\n            } else if (l.charAt(0)!=\\'.\\') depth++;\\n        }\\n        return depth;\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    public int minOperations(String[] logs) {\\n        int depth=0;\\n        for (String l : logs) {\\n            if (l.charAt(1)==\\'.\\') {\\n                if (depth > 0) {\\n                    depth--;\\n                }\\n            } else if (l.charAt(0)!=\\'.\\') depth++;\\n        }\\n        return depth;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 866405,
                "title": "c-simple-solution-with-comments",
                "content": "```\\nclass Solution {\\npublic:\\n    int minOperations(vector<string>& logs) {\\n        int op = 0;\\n        \\n        for(int i = 0 ; i < logs.size() ; i++)\\n        {\\n            if(logs[i][0] != \\'.\\') // go inside folder\\n            {\\n                op++;\\n            }\\n            else if(logs[i][1] != \\'/\\') // ../\\n            {\\n                op = max(op-1 , 0); \\n            }\\n            else\\n            {\\n                // do nothing\\n            }\\n        }\\n        return max(0,op);\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    int minOperations(vector<string>& logs) {\\n        int op = 0;\\n        \\n        for(int i = 0 ; i < logs.size() ; i++)\\n        {\\n            if(logs[i][0] != \\'.\\') // go inside folder\\n            {\\n                op++;\\n            }\\n            else if(logs[i][1] != \\'/\\') // ../\\n            {\\n                op = max(op-1 , 0); \\n            }\\n            else\\n            {\\n                // do nothing\\n            }\\n        }\\n        return max(0,op);\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 866401,
                "title": "simple-python3-solution-o-n",
                "content": "The approach is very simple. Whenever **\"../\"** is encountered **decrement** ops by one ( only if ops is not zero), if **\"./\"** is encountered do **nothing** ( i.e don\\'t update ops ).\\n\\nFinally if we encounter any other **string** in the list just **increment** the value of ops by one because no matter what it is ( for eg. it can be **\"d1/\"**,**d2/** etc )we are supposed to enter into new child file\\n```\\nclass Solution:\\n    def minOperations(self, logs: List[str]) -> int:\\n        ops=0\\n        for i in range(len(logs)):\\n            if logs[i]==\\'../\\':\\n                if ops==0:\\n                    continue\\n                ops-=1\\n            elif logs[i]==\\'./\\':\\n                continue\\n            else:\\n                ops+=1\\n        return ops\\n```\\n",
                "solutionTags": [
                    "Python3",
                    "Iterator"
                ],
                "code": "```\\nclass Solution:\\n    def minOperations(self, logs: List[str]) -> int:\\n        ops=0\\n        for i in range(len(logs)):\\n            if logs[i]==\\'../\\':\\n                if ops==0:\\n                    continue\\n                ops-=1\\n            elif logs[i]==\\'./\\':\\n                continue\\n            else:\\n                ops+=1\\n        return ops\\n```",
                "codeTag": "Java"
            },
            {
                "id": 866395,
                "title": "c-o-n-time-o-1-space",
                "content": "Runtime: 132 ms\\nMemory Usage: 25.3 MB\\n```\\n    public int MinOperations(string[] logs) {\\n        \\n        int depth = 0;\\n        \\n        foreach(string k in logs)\\n        {\\n            if (k == \"./\") { continue; }\\n            if (k == \"../\") { if (depth > 0) { depth--; } }\\n            else { depth++; }\\n        }\\n        \\n        return depth;\\n    }",
                "solutionTags": [],
                "code": "Runtime: 132 ms\\nMemory Usage: 25.3 MB\\n```\\n    public int MinOperations(string[] logs) {\\n        \\n        int depth = 0;\\n        \\n        foreach(string k in logs)\\n        {\\n            if (k == \"./\") { continue; }\\n            if (k == \"../\") { if (depth > 0) { depth--; } }\\n            else { depth++; }\\n        }\\n        \\n        return depth;\\n    }",
                "codeTag": "Unknown"
            },
            {
                "id": 866394,
                "title": "java-efficient-solution-using-map",
                "content": "```\\npublic int minOperations(String[] logs) {\\n        Map<String, Integer> map = new HashMap<>();\\n        map.put(\"./\", 0);\\n        map.put(\"../\", -1);\\n        \\n        int ans = 0;\\n        for(int i=0;i<logs.length;i++) {\\n            if(map.containsKey(logs[i])) {\\n                ans += map.get(logs[i]);\\n                if(ans < 0) ans = 0;\\n            } else {\\n                ans += 1;\\n            }\\n        }\\n        \\n        return ans;\\n    }",
                "solutionTags": [],
                "code": "```\\npublic int minOperations(String[] logs) {\\n        Map<String, Integer> map = new HashMap<>();\\n        map.put(\"./\", 0);\\n        map.put(\"../\", -1);\\n        \\n        int ans = 0;\\n        for(int i=0;i<logs.length;i++) {\\n            if(map.containsKey(logs[i])) {\\n                ans += map.get(logs[i]);\\n                if(ans < 0) ans = 0;\\n            } else {\\n                ans += 1;\\n            }\\n        }\\n        \\n        return ans;\\n    }",
                "codeTag": "Unknown"
            },
            {
                "id": 866385,
                "title": "go",
                "content": "func minOperations(logs []string) int {\\n    var level int \\n    \\n    for i := range logs {\\n        if logs[i] == \"./\" {\\n            continue\\n        } else if logs[i] == \"../\" {\\n            level = max(level -1 , 0)\\n        } else {\\n            level++\\n        }\\n    }\\n    return level\\n    \\n}\\nfunc max(i,j int) int {\\n    if i >= j {\\n        return i\\n    }\\n     \\n    return j\\n}",
                "solutionTags": [],
                "code": "func minOperations(logs []string) int {\\n    var level int \\n    \\n    for i := range logs {\\n        if logs[i] == \"./\" {\\n            continue\\n        } else if logs[i] == \"../\" {\\n            level = max(level -1 , 0)\\n        } else {\\n            level++\\n        }\\n    }\\n    return level\\n    \\n}\\nfunc max(i,j int) int {\\n    if i >= j {\\n        return i\\n    }\\n     \\n    return j\\n}",
                "codeTag": "Unknown"
            },
            {
                "id": 866381,
                "title": "javascript-solution",
                "content": "```\\n/**\\n * @param {string[]} logs\\n * @return {number}\\n */\\nvar minOperations = function(logs) {\\n    let level = 0;\\n    for(let i=0; i<logs.length; i++){\\n        if(logs[i]===\"../\"){\\n            if(level!==0){\\n                level--;\\n            }\\n        }else if(logs[i]===\"./\"){\\n            continue;\\n        }else{\\n            level++;\\n        }\\n    }\\n    return level;\\n};\\n```",
                "solutionTags": [],
                "code": "```\\n/**\\n * @param {string[]} logs\\n * @return {number}\\n */\\nvar minOperations = function(logs) {\\n    let level = 0;\\n    for(let i=0; i<logs.length; i++){\\n        if(logs[i]===\"../\"){\\n            if(level!==0){\\n                level--;\\n            }\\n        }else if(logs[i]===\"./\"){\\n            continue;\\n        }else{\\n            level++;\\n        }\\n    }\\n    return level;\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 866355,
                "title": "python-easy-sol-o-n-time-o-1-space",
                "content": "```\\nclass Solution:\\n    def minOperations(self, logs: List[str]) -> int:\\n        count = 0\\n        \\n        for item in logs:\\n            if item == \\'../\\':\\n                if count > 0:\\n                    count -= 1\\n            \\n            elif item == \\'./\\':\\n                pass\\n            \\n            else:\\n                count += 1\\n            \\n            \\n        return count if count > 0 else 0\\n        \\n```",
                "solutionTags": [
                    "Python",
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def minOperations(self, logs: List[str]) -> int:\\n        count = 0\\n        \\n        for item in logs:\\n            if item == \\'../\\':\\n                if count > 0:\\n                    count -= 1\\n            \\n            elif item == \\'./\\':\\n                pass\\n            \\n            else:\\n                count += 1\\n            \\n            \\n        return count if count > 0 else 0\\n        \\n```",
                "codeTag": "Java"
            },
            {
                "id": 866353,
                "title": "kotlin-o-n",
                "content": "```\\nfun minOperations(logs: Array<String>): Int {\\n        var counter = 0\\n        \\n        logs.forEach { log ->\\n            when (log) {\\n                \"../\" -> counter = maxOf(0, counter - 1)\\n                \"./\" -> Unit // Do nothing\\n                else -> counter++\\n            }\\n        }\\n        \\n        return counter\\n    }\\n```",
                "solutionTags": [],
                "code": "```\\nfun minOperations(logs: Array<String>): Int {\\n        var counter = 0\\n        \\n        logs.forEach { log ->\\n            when (log) {\\n                \"../\" -> counter = maxOf(0, counter - 1)\\n                \"./\" -> Unit // Do nothing\\n                else -> counter++\\n            }\\n        }\\n        \\n        return counter\\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 866352,
                "title": "stack-python",
                "content": "```\\nclass Solution:\\n    def minOperations(self, logs: List[str]) -> int:\\n        \\n        stack=[]\\n        stack.append(\".\")\\n        for operation in logs:\\n            \\n            if operation==\"./\":\\n                continue\\n            elif operation==\"../\":\\n                if len(stack)>1:\\n                    stack.pop()\\n            else:\\n                stack.append(operation)\\n        return len(stack)-1\\n            \\n            \\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution:\\n    def minOperations(self, logs: List[str]) -> int:\\n        \\n        stack=[]\\n        stack.append(\".\")\\n        for operation in logs:\\n            \\n            if operation==\"./\":\\n                continue\\n            elif operation==\"../\":\\n                if len(stack)>1:\\n                    stack.pop()\\n            else:\\n                stack.append(operation)\\n        return len(stack)-1\\n            \\n            \\n```",
                "codeTag": "Java"
            },
            {
                "id": 866348,
                "title": "easy-solution-in-cpp",
                "content": "```\\nclass Solution {\\npublic:\\n    int minOperations(vector<string>& logs) {\\n        vector<string> v;\\n        for(string s : logs){\\n            if(s == \"../\"){\\n                if(v.empty()) continue;\\n                v.pop_back();\\n            }\\n            \\n            else if(s == \"./\"){\\n                continue;\\n            }\\n        \\n            else{\\n                v.push_back(s);\\n            }\\n            \\n        }\\n        return (int)v.size();\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "C"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int minOperations(vector<string>& logs) {\\n        vector<string> v;\\n        for(string s : logs){\\n            if(s == \"../\"){\\n                if(v.empty()) continue;\\n                v.pop_back();\\n            }\\n            \\n            else if(s == \"./\"){\\n                continue;\\n            }\\n        \\n            else{\\n                v.push_back(s);\\n            }\\n            \\n        }\\n        return (int)v.size();\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 866341,
                "title": "java-o-n",
                "content": "```\\nclass Solution {\\n    public int minOperations(String[] logs) {\\n        int ans = 0;\\n        for(String s: logs){\\n            ans = s.charAt(0) != \\'.\\' ? ans + 1 : s.charAt(1) == \\'.\\' ? Math.max(0, ans-1) : ans;\\n        }\\n        return ans;\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    public int minOperations(String[] logs) {\\n        int ans = 0;\\n        for(String s: logs){\\n            ans = s.charAt(0) != \\'.\\' ? ans + 1 : s.charAt(1) == \\'.\\' ? Math.max(0, ans-1) : ans;\\n        }\\n        return ans;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 4087660,
                "title": "1ms-simple-4-line-approach",
                "content": "\\n\\n# Approach\\n1. Initialize a variable count to keep track of the current directory level.\\n2. Iterate through each string log in the logs array.\\n3. For each log entry:\\n- If it is \"../\" (representing moving up one level in the directory hierarchy), decrement count by 1, but only if count is greater than 0 (to avoid going below the root level).\\n- If it is \"./\" (representing staying in the current directory), skip this log entry and continue to the next one.\\n- For any other log entry, increment count by 1, representing moving into a subdirectory.\\n4. After processing all log entries, count will represent the minimum number of operations required to reach the final directory.\\n5. Return the count as the result.\\n\\n# Complexity\\n- Time complexity:\\nThe code iterates through each log entry in the logs array, so the time complexity is O(n), where n is the number of log entries.\\n\\n- Space complexity:\\nThe code uses a single integer variable count, so the space complexity is O(1), as it doesn\\'t depend on the size of the input.\\n# Code\\n```\\nclass Solution {\\n    public int minOperations(String[] logs) {\\n        int count=0;\\n        for(String log: logs){\\n            if(log.equals(\"../\")) count=count==0?0:count-1;\\n            else if(log.equals(\"./\")) continue;\\n            else count++;\\n        }\\n        return count;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "String"
                ],
                "code": "```\\nclass Solution {\\n    public int minOperations(String[] logs) {\\n        int count=0;\\n        for(String log: logs){\\n            if(log.equals(\"../\")) count=count==0?0:count-1;\\n            else if(log.equals(\"./\")) continue;\\n            else count++;\\n        }\\n        return count;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 4083989,
                "title": "96-89-javascript",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\n/**\\n * @param {string[]} logs\\n * @return {number}\\n */\\nvar minOperations = function(logs) {\\n    const stack = []\\n    logs.forEach((each)=>{\\n        if(each === \"../\"){\\n            stack.pop()\\n        }else if( each == \\'./\\'){}\\n        else{\\n            stack.push(each)\\n        }\\n    })\\n\\n    return stack.length\\n};\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\n/**\\n * @param {string[]} logs\\n * @return {number}\\n */\\nvar minOperations = function(logs) {\\n    const stack = []\\n    logs.forEach((each)=>{\\n        if(each === \"../\"){\\n            stack.pop()\\n        }else if( each == \\'./\\'){}\\n        else{\\n            stack.push(each)\\n        }\\n    })\\n\\n    return stack.length\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 4072573,
                "title": "no-stack-no-problem",
                "content": "# Code\\n```\\nclass Solution:\\n    def minOperations(self, logs: List[str]) -> int:\\n        level = 0\\n        for log in logs:\\n            if log == \\'../\\':\\n                level -= 1 if level > 0 else 0\\n            elif log == \\'./\\':\\n                continue\\n            else:\\n                level += 1\\n        return level\\n\\n\\n            \\n\\n        \\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def minOperations(self, logs: List[str]) -> int:\\n        level = 0\\n        for log in logs:\\n            if log == \\'../\\':\\n                level -= 1 if level > 0 else 0\\n            elif log == \\'./\\':\\n                continue\\n            else:\\n                level += 1\\n        return level\\n\\n\\n            \\n\\n        \\n```",
                "codeTag": "Java"
            },
            {
                "id": 4064511,
                "title": "c-solution",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity: O(n)\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: O(1)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int minOperations(vector<string>& logs) {\\n        int ans=0;\\n        for(int i=0;i<logs.size();i++){\\n            if(logs[i]==\"../\"){\\n                if(ans>0){\\n                    ans--;\\n                }\\n            }else{\\n                    if(logs[i]!=\"./\"){\\n                        ans++;\\n                    }\\n            }\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int minOperations(vector<string>& logs) {\\n        int ans=0;\\n        for(int i=0;i<logs.size();i++){\\n            if(logs[i]==\"../\"){\\n                if(ans>0){\\n                    ans--;\\n                }\\n            }else{\\n                    if(logs[i]!=\"./\"){\\n                        ans++;\\n                    }\\n            }\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 4062491,
                "title": "simple-js",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\n/**\\n * @param {string[]} logs\\n * @return {number}\\n */\\nvar minOperations = function (logs) {\\n    console.log(logs);\\n    var ct = 0;\\n    for (var i = 0; i < logs.length; i++) {\\n        if (logs[i] == \"../\" ) {\\n            if( ct != 0)\\n            {\\n                ct--;\\n            }\\n        }\\n        if (logs[i] != \"./\" && logs[i] != \"../\") {\\n            ct++;\\n        }\\n    }\\n    if (ct <= 0) {\\n        return 0;\\n    }\\n    return ct;\\n};\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\n/**\\n * @param {string[]} logs\\n * @return {number}\\n */\\nvar minOperations = function (logs) {\\n    console.log(logs);\\n    var ct = 0;\\n    for (var i = 0; i < logs.length; i++) {\\n        if (logs[i] == \"../\" ) {\\n            if( ct != 0)\\n            {\\n                ct--;\\n            }\\n        }\\n        if (logs[i] != \"./\" && logs[i] != \"../\") {\\n            ct++;\\n        }\\n    }\\n    if (ct <= 0) {\\n        return 0;\\n    }\\n    return ct;\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 4058241,
                "title": "beginner-friendly-just-a-linear-traversal-optimize-solution-100-beats-2ms",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:O(n)\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:O(1)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\n    public int minOperations(String[] logs) {\\n        int depth=0;\\n        for(String log : logs){\\n            if(log.equals(\"./\")) continue;\\n            else if(log.equals(\"../\")){\\n                depth--;\\n                if(depth < 0) depth = 0;\\n            }\\n            else depth++;\\n        }\\n\\n        return depth;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Array",
                    "String",
                    "Stack"
                ],
                "code": "```\\nclass Solution {\\n    public int minOperations(String[] logs) {\\n        int depth=0;\\n        for(String log : logs){\\n            if(log.equals(\"./\")) continue;\\n            else if(log.equals(\"../\")){\\n                depth--;\\n                if(depth < 0) depth = 0;\\n            }\\n            else depth++;\\n        }\\n\\n        return depth;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 4052451,
                "title": "java-solution-easy-approach",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\n    public int minOperations(String[] logs) {\\n        Stack<String> stack = new Stack<>();\\n        for(String c: logs){\\n            if(c.equals(\"../\")){\\n                if(!stack.isEmpty()){\\n                    stack.pop();\\n                }\\n            }\\n            else if (c.equals(\"./\")){\\n                  continue;\\n            }\\n            else{\\n                stack.push(c);\\n            }\\n        }\\n        return stack.size();\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int minOperations(String[] logs) {\\n        Stack<String> stack = new Stack<>();\\n        for(String c: logs){\\n            if(c.equals(\"../\")){\\n                if(!stack.isEmpty()){\\n                    stack.pop();\\n                }\\n            }\\n            else if (c.equals(\"./\")){\\n                  continue;\\n            }\\n            else{\\n                stack.push(c);\\n            }\\n        }\\n        return stack.size();\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 4050431,
                "title": "easy-java",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\n    public int minOperations(String[] logs) {\\n        Stack<String> st = new Stack<>();\\n        for(int i=0;i<logs.length;i++){\\n            if(st.size()== 0 && logs[i].equals(\"../\")){\\n                continue;\\n            }\\n            if(st.size()>0 && logs[i].equals(\"../\")){\\n                st.pop();\\n            }\\n            else if(logs[i].equals(\"./\")){\\n                continue;\\n            }else{\\n                st.push(logs[i]);\\n            }\\n        }\\n      \\n        return st.size();\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int minOperations(String[] logs) {\\n        Stack<String> st = new Stack<>();\\n        for(int i=0;i<logs.length;i++){\\n            if(st.size()== 0 && logs[i].equals(\"../\")){\\n                continue;\\n            }\\n            if(st.size()>0 && logs[i].equals(\"../\")){\\n                st.pop();\\n            }\\n            else if(logs[i].equals(\"./\")){\\n                continue;\\n            }else{\\n                st.push(logs[i]);\\n            }\\n        }\\n      \\n        return st.size();\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 4043161,
                "title": "java-simple-approach-using-stack",
                "content": "# Intuition\\nStack used\\n\\n# Approach\\npush :- For the folder\\npop :- \"../\" \\n\\n# Complexity\\n- Time complexity:\\nO(n)\\n\\n- Space complexity:\\nO(n)\\n\\n# Code\\n```\\nclass Solution {\\n    public int minOperations(String[] logs) {\\n        Stack<String> stack = new Stack<>();\\n        int ans = 0;\\n        for (String log : logs) {\\n            if (!stack.isEmpty() && log.equals(\"../\")) {\\n                stack.pop();\\n            } else if (log.equals(\"./\")) {\\n                continue;\\n            } else if (!log.equals(\"../\")) {\\n                stack.push(log);\\n            }\\n        }\\n        ans = stack.size();\\n        return ans;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int minOperations(String[] logs) {\\n        Stack<String> stack = new Stack<>();\\n        int ans = 0;\\n        for (String log : logs) {\\n            if (!stack.isEmpty() && log.equals(\"../\")) {\\n                stack.pop();\\n            } else if (log.equals(\"./\")) {\\n                continue;\\n            } else if (!log.equals(\"../\")) {\\n                stack.push(log);\\n            }\\n        }\\n        ans = stack.size();\\n        return ans;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 4032650,
                "title": "simple-solution",
                "content": "```\\nclass Solution:\\n    def minOperations(self, logs: List[str]) -> int:\\n        depth = 0\\n        for log in logs:\\n            if \"..\" in log:\\n                if depth:\\n                    depth -= 1\\n            elif \".\" not in log:\\n                depth += 1\\n        return depth\\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def minOperations(self, logs: List[str]) -> int:\\n        depth = 0\\n        for log in logs:\\n            if \"..\" in log:\\n                if depth:\\n                    depth -= 1\\n            elif \".\" not in log:\\n                depth += 1\\n        return depth\\n```",
                "codeTag": "Java"
            },
            {
                "id": 4029933,
                "title": "fastest-response-time-say-hii-amit-flutter",
                "content": "# Intuition\\n1. Remove \"./\" from list becase there is no effect of it so it will save loop time and memory\\n2. if i found \"../\" then minStep counter will decrese it means back to main but if we are alredy on main then do notheing (if minStep == 0 no need --)\\n3. if there are any folder name then we will increse steps\\n\\n# Code\\n```\\nclass Solution {\\n  int minOperations(List<String> logs) {\\n    int minStep = 0;\\n    logs.removeWhere((item) => item == \"./\");\\n    \\n    for (int i = 0; i < logs.length; i++) {\\n      if (logs[i] == \"../\") {\\n        if (minStep > 0) minStep--;\\n      } else\\n        minStep++;\\n    }\\n    return minStep;\\n  }\\n}\\n```\\n\\n*need **memory usage is still 50%** need help to improve it drop your comment below\\n\\n## Connect with me here : \\nhttps://linktr.ee/amit.flutter",
                "solutionTags": [
                    "Dart",
                    "String"
                ],
                "code": "```\\nclass Solution {\\n  int minOperations(List<String> logs) {\\n    int minStep = 0;\\n    logs.removeWhere((item) => item == \"./\");\\n    \\n    for (int i = 0; i < logs.length; i++) {\\n      if (logs[i] == \"../\") {\\n        if (minStep > 0) minStep--;\\n      } else\\n        minStep++;\\n    }\\n    return minStep;\\n  }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 4024271,
                "title": "c-solution",
                "content": "# Complexity\\n- Time complexity: $$O(n)$$\\n- Space complexity: $$O(1)$$\\n\\n# Code\\n```\\npublic class Solution\\n{\\n    public int MinOperations(string[] logs)\\n    {\\n        var depth = 0;\\n        foreach (var log in logs)\\n        {\\n            if (log == \"../\")\\n            {\\n                if (depth > 0)\\n                {\\n                    depth--;\\n                }\\n            }\\n            else if (log != \"./\")\\n            {\\n                depth++;\\n            }\\n        }\\n\\n        return depth;\\n    }\\n}\\n```",
                "solutionTags": [
                    "C#"
                ],
                "code": "```\\npublic class Solution\\n{\\n    public int MinOperations(string[] logs)\\n    {\\n        var depth = 0;\\n        foreach (var log in logs)\\n        {\\n            if (log == \"../\")\\n            {\\n                if (depth > 0)\\n                {\\n                    depth--;\\n                }\\n            }\\n            else if (log != \"./\")\\n            {\\n                depth++;\\n            }\\n        }\\n\\n        return depth;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 4014791,
                "title": "typescript-javascript-solution",
                "content": "```ts\\nfunction minOperations(logs: string[]): number {\\n    let count: number = 0;\\n    for(let dir of logs){\\n        if(dir === \\'./\\') continue;\\n        if(dir === \\'../\\') {\\n            count = count == 0 ? 0 : --count;\\n             continue;\\n        }\\n        ++count;\\n    }\\n    return count;\\n};\\n```",
                "solutionTags": [
                    "JavaScript",
                    "TypeScript"
                ],
                "code": "```ts\\nfunction minOperations(logs: string[]): number {\\n    let count: number = 0;\\n    for(let dir of logs){\\n        if(dir === \\'./\\') continue;\\n        if(dir === \\'../\\') {\\n            count = count == 0 ? 0 : --count;\\n             continue;\\n        }\\n        ++count;\\n    }\\n    return count;\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 4013882,
                "title": "c-stack-implementation",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nvoid push(int stack[],int *t,int val,int l)\\n{\\n    if(*t==l-1) return;\\n    else\\n    stack[++(*t)];\\n}\\nvoid pop(int *t)\\n{\\n    if(*t==-1) return;\\n    else\\n    (*t)--;\\n}\\nint minOperations(char ** logs, int logsSize){\\n  char stack[logsSize];\\n  int top=-1;\\n  for(int i=0;i<logsSize;i++)\\n  {\\n      if(strcmp(logs[i],\"../\")==0) pop(&top);\\n      else if(strcmp(logs[i],\"./\")==0) continue;\\n      else push(stack,&top,i+1,logsSize);\\n  }\\n  int m=0;\\n  while(top>=0)\\n  {\\n      m++;\\n      top--;\\n  }\\n  return m;\\n}\\n```",
                "solutionTags": [
                    "C"
                ],
                "code": "```\\nvoid push(int stack[],int *t,int val,int l)\\n{\\n    if(*t==l-1) return;\\n    else\\n    stack[++(*t)];\\n}\\nvoid pop(int *t)\\n{\\n    if(*t==-1) return;\\n    else\\n    (*t)--;\\n}\\nint minOperations(char ** logs, int logsSize){\\n  char stack[logsSize];\\n  int top=-1;\\n  for(int i=0;i<logsSize;i++)\\n  {\\n      if(strcmp(logs[i],\"../\")==0) pop(&top);\\n      else if(strcmp(logs[i],\"./\")==0) continue;\\n      else push(stack,&top,i+1,logsSize);\\n  }\\n  int m=0;\\n  while(top>=0)\\n  {\\n      m++;\\n      top--;\\n  }\\n  return m;\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 4008572,
                "title": "easy-cpp-solution-beats-90-70-in-runtime-beginner-friendly",
                "content": "![image.png](https://assets.leetcode.com/users/images/682a1150-642f-40f6-8880-81f5d4c4b631_1693982120.7181227.png)\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int minOperations(vector<string>& logs) {\\n        stack<string> st;\\n        int sz = logs.size();\\n        \\n        for(int i=0; i<sz; i++){\\n            if(logs[i] == \"../\"){\\n                if(st.size()) st.pop();\\n            }\\n            else if(logs[i] != \"./\"){\\n                st.push(logs[i]);\\n            }\\n        }\\n\\n        return st.size();\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int minOperations(vector<string>& logs) {\\n        stack<string> st;\\n        int sz = logs.size();\\n        \\n        for(int i=0; i<sz; i++){\\n            if(logs[i] == \"../\"){\\n                if(st.size()) st.pop();\\n            }\\n            else if(logs[i] != \"./\"){\\n                st.push(logs[i]);\\n            }\\n        }\\n\\n        return st.size();\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 4003760,
                "title": "using-if-else",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\nsimply by using if else\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution:\\n    def minOperations(self, logs: List[str]) -> int:\\n        count = 0\\n        for i in range(0,len(logs)):\\n            if logs[i] == \"./\":\\n                count+=0\\n            elif logs[i] == \"../\":\\n                if count>0:\\n                    count-=1\\n                else:\\n                    count\\n            else:\\n                count+=1\\n        if count>0:\\n            return count\\n        else:\\n            return 0\\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def minOperations(self, logs: List[str]) -> int:\\n        count = 0\\n        for i in range(0,len(logs)):\\n            if logs[i] == \"./\":\\n                count+=0\\n            elif logs[i] == \"../\":\\n                if count>0:\\n                    count-=1\\n                else:\\n                    count\\n            else:\\n                count+=1\\n        if count>0:\\n            return count\\n        else:\\n            return 0\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3996617,
                "title": "c-solution-using-iterative-approach",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nI have used iterative approach here. But if you want, you can also use stack to solve it.\\n\\n# Approach\\nIterative approach\\n\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int minOperations(vector<string>& logs) {\\n        int count = 0;\\n\\n        for (int i = 0; i < logs.size(); i++) {\\n            if (logs[i] == \"./\") {\\n                // Do nothing, stay in the same folder\\n            } else if (logs[i] == \"../\") {\\n                // Go up to the parent folder\\n                if (count > 0) {\\n                    count--;\\n                }\\n            } else {\\n                // Move to a child folder\\n                count++;\\n            }\\n        }\\n\\n        return max(0, count);\\n    }\\n};\\n\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int minOperations(vector<string>& logs) {\\n        int count = 0;\\n\\n        for (int i = 0; i < logs.size(); i++) {\\n            if (logs[i] == \"./\") {\\n                // Do nothing, stay in the same folder\\n            } else if (logs[i] == \"../\") {\\n                // Go up to the parent folder\\n                if (count > 0) {\\n                    count--;\\n                }\\n            } else {\\n                // Move to a child folder\\n                count++;\\n            }\\n        }\\n\\n        return max(0, count);\\n    }\\n};\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3988567,
                "title": "easy-to-understand-better-c",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\nUsing Stack\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int minOperations(vector<string>& logs) {\\n        stack<string>s1;\\n        for(string s : logs){\\n            if(s == \"./\"){\\n                continue;\\n            }\\n            else if(s == \"../\"){\\n                if(s1.size() != 0){\\n                   s1.pop();\\n                }   \\n            }\\n            else{\\n                s1.push(s);\\n            }\\n        }\\n        return s1.size();\\n    }\\n}; // please upvote if you like\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int minOperations(vector<string>& logs) {\\n        stack<string>s1;\\n        for(string s : logs){\\n            if(s == \"./\"){\\n                continue;\\n            }\\n            else if(s == \"../\"){\\n                if(s1.size() != 0){\\n                   s1.pop();\\n                }   \\n            }\\n            else{\\n                s1.push(s);\\n            }\\n        }\\n        return s1.size();\\n    }\\n}; // please upvote if you like\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3988503,
                "title": "php-simple-o-n",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity: O(n)\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: O(n)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\n\\n    /**\\n     * @param String[] $logs\\n     * @return Integer\\n     */\\n    function minOperations($logs) {\\n        $steps = 0;\\n        foreach ($logs as $log) {\\n            if ($log === \\'./\\') {\\n                continue;\\n            }\\n\\n            if ($log === \\'../\\') {\\n                $steps = $steps > 0 ? $steps - 1 : $steps;\\n            } else {\\n                $steps++;\\n            }\\n        }\\n        return $steps;\\n    }\\n}\\n```",
                "solutionTags": [
                    "PHP"
                ],
                "code": "```\\nclass Solution {\\n\\n    /**\\n     * @param String[] $logs\\n     * @return Integer\\n     */\\n    function minOperations($logs) {\\n        $steps = 0;\\n        foreach ($logs as $log) {\\n            if ($log === \\'./\\') {\\n                continue;\\n            }\\n\\n            if ($log === \\'../\\') {\\n                $steps = $steps > 0 ? $steps - 1 : $steps;\\n            } else {\\n                $steps++;\\n            }\\n        }\\n        return $steps;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3984841,
                "title": "java-and-python-solution",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\nO(n)\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\nO(1)\\n\\n# Java\\n```\\nclass Solution {\\n    public int minOperations(String[] logs) {\\n        int main = 0;\\n        for(String log: logs){\\n            if(log.endsWith(\"../\") && main > 0){\\n                main -= 1;\\n            }else if(log.endsWith(\"./\")){\\n                main += 0;\\n            }else{\\n                main += 1;\\n            }\\n        }\\n        return main;\\n    }\\n}\\n```\\n\\n# Python\\n```\\n def minOperations(self, logs: List[str]) -> int:\\n        step = 0\\n        for log in logs:\\n            print(log)\\n            if log.endswith(\"../\") and step > 0:\\n                step -= 1\\n            elif log.endswith(\"./\"):\\n                step += 0\\n            elif log.endswith(\"/\"):\\n                step += 1\\n        return step\\n```",
                "solutionTags": [
                    "Java",
                    "Python",
                    "Python3"
                ],
                "code": "```\\nclass Solution {\\n    public int minOperations(String[] logs) {\\n        int main = 0;\\n        for(String log: logs){\\n            if(log.endsWith(\"../\") && main > 0){\\n                main -= 1;\\n            }else if(log.endsWith(\"./\")){\\n                main += 0;\\n            }else{\\n                main += 1;\\n            }\\n        }\\n        return main;\\n    }\\n}\\n```\n```\\n def minOperations(self, logs: List[str]) -> int:\\n        step = 0\\n        for log in logs:\\n            print(log)\\n            if log.endswith(\"../\") and step > 0:\\n                step -= 1\\n            elif log.endswith(\"./\"):\\n                step += 0\\n            elif log.endswith(\"/\"):\\n                step += 1\\n        return step\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3984665,
                "title": "c-easy-constant-memory-solution",
                "content": "# Intuition\\nNo need to record the events/directories in a stack.\\n\\n# Approach\\nMaintain a counter which tracks how far we are from the main folder at any point\\n\\n# Complexity\\n- Time complexity: O(N)\\n\\n- Space complexity: O(1)\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n\\n    // Time: O(N)\\n    // Space: O(1)\\n    int minOperations(vector<string>& A) {\\n        int op_count = 0;\\n        for (string& s : A) {\\n            if (s == \"../\") {\\n                if (op_count != 0)\\n                    op_count--;\\n            }\\n            else if (s == \"./\") continue;\\n            else op_count++;\\n        }\\n\\n        return op_count;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n\\n    // Time: O(N)\\n    // Space: O(1)\\n    int minOperations(vector<string>& A) {\\n        int op_count = 0;\\n        for (string& s : A) {\\n            if (s == \"../\") {\\n                if (op_count != 0)\\n                    op_count--;\\n            }\\n            else if (s == \"./\") continue;\\n            else op_count++;\\n        }\\n\\n        return op_count;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3984278,
                "title": "python-stack-easy-beginner-friendly",
                "content": "# Please upvote if you find it useful\\n\\n# Complexity\\n- Time complexity: O(n)\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: O(n)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution:\\n    def minOperations(self, logs: List[str]) -> int:\\n        stk = []\\n        for operation in logs:\\n            if operation == \"../\":\\n                if stk:\\n                    stk.pop()\\n            elif operation != \"./\":\\n                stk.append(operation)\\n        return len(stk)\\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def minOperations(self, logs: List[str]) -> int:\\n        stk = []\\n        for operation in logs:\\n            if operation == \"../\":\\n                if stk:\\n                    stk.pop()\\n            elif operation != \"./\":\\n                stk.append(operation)\\n        return len(stk)\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3982099,
                "title": "simple-solution-using-stack-in-java",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. --> We can use a stack to record the number of files away from main we are.\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. --> We will pop from the stack when we need to go back and we can push to the stack when we move forwards.\\n\\n# Code\\n```\\nimport java.util.*;\\n\\nclass Solution {\\n    public int minOperations(String[] logs) {\\n        \\n        // we will use a stack to keep track of our distance from the main file\\n        Stack<Integer> stack = new Stack<>();\\n\\n        // we will check each operation and convert it to an \"action\"\\n        for(String op: logs) {\\n            \\n            // if operation is \"go back\" then we will pop a value of the stack\\n            if(op.equals(\"../\")) {\\n                if(!stack.isEmpty()) {\\n                    stack.pop();\\n                }\\n                \\n            // if the operation is not \"stay in place\" and not \"go back\" then we will add to the top of the stack    \\n            } else if(!op.equals(\"./\")) {\\n                stack.push(1);\\n            }\\n        }\\n        \\n        // we will return the size of the stack as that is the number of operations away from main we are.\\n        return stack.size();\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nimport java.util.*;\\n\\nclass Solution {\\n    public int minOperations(String[] logs) {\\n        \\n        // we will use a stack to keep track of our distance from the main file\\n        Stack<Integer> stack = new Stack<>();\\n\\n        // we will check each operation and convert it to an \"action\"\\n        for(String op: logs) {\\n            \\n            // if operation is \"go back\" then we will pop a value of the stack\\n            if(op.equals(\"../\")) {\\n                if(!stack.isEmpty()) {\\n                    stack.pop();\\n                }\\n                \\n            // if the operation is not \"stay in place\" and not \"go back\" then we will add to the top of the stack    \\n            } else if(!op.equals(\"./\")) {\\n                stack.push(1);\\n            }\\n        }\\n        \\n        // we will return the size of the stack as that is the number of operations away from main we are.\\n        return stack.size();\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3981476,
                "title": "simple-js-solution",
                "content": "```\\n/**\\n * @param {string[]} logs\\n * @return {number}\\n */\\nconst minOperations = function(logs) {\\n\\n    let result = 0\\n\\n    for (let i = 0; i < logs.length; i++) {\\n\\n        let curr = logs[i]\\n\\n        if (curr === \\'./\\') {\\n            result = result\\n        } else if (curr === \\'../\\' && result > 0) {\\n            result--\\n        } else if (curr === \\'../\\' && result === 0) {\\n            result = result\\n        } else {\\n            result++\\n        }\\n\\n    }\\n\\n    return result\\n\\n}\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\n/**\\n * @param {string[]} logs\\n * @return {number}\\n */\\nconst minOperations = function(logs) {\\n\\n    let result = 0\\n\\n    for (let i = 0; i < logs.length; i++) {\\n\\n        let curr = logs[i]\\n\\n        if (curr === \\'./\\') {\\n            result = result\\n        } else if (curr === \\'../\\' && result > 0) {\\n            result--\\n        } else if (curr === \\'../\\' && result === 0) {\\n            result = result\\n        } else {\\n            result++\\n        }\\n\\n    }\\n\\n    return result\\n\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3979514,
                "title": "easy-and-fast-solution",
                "content": "# Approach\\n<!-- Describe your approach to solving the problem. -->\\n - to check if the file vistited and this movement is into the child of this file do `if(a[0]==act[o]&&a[length-2]==act[length-3]`\\n - for example d12 and d121  \\n# Complexity\\n- Time complexity:$$O(n)$$\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:$$O(n)$$\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int minOperations(vector<string>& logs) {\\n     stack<string>st;\\n     for(string act:logs){\\n         if(act==\"../\"){\\n             if(!st.empty())\\n              st.pop();\\n         }\\n        else if(act==\"./\")\\n           continue;\\n        else{\\n          if(!st.empty()){\\n           string a=st.top();\\n            if(a[0]==act[0]&&a[a.length()-2]==act[act.length()-3])\\n               continue;\\n          }\\n          st.push(act);\\n        }\\n     }\\n     int op=0;\\n     while(!st.empty()){ \\n      op++;\\n     st.pop();\\n     }\\n     return op;   \\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "String",
                    "Stack"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int minOperations(vector<string>& logs) {\\n     stack<string>st;\\n     for(string act:logs){\\n         if(act==\"../\"){\\n             if(!st.empty())\\n              st.pop();\\n         }\\n        else if(act==\"./\")\\n           continue;\\n        else{\\n          if(!st.empty()){\\n           string a=st.top();\\n            if(a[0]==act[0]&&a[a.length()-2]==act[act.length()-3])\\n               continue;\\n          }\\n          st.push(act);\\n        }\\n     }\\n     int op=0;\\n     while(!st.empty()){ \\n      op++;\\n     st.pop();\\n     }\\n     return op;   \\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3978876,
                "title": "clean-concise-readable-and-easy-to-understand-code",
                "content": "# Intuition\\n  Simple approach dude : If we encounter \"x/\" folder then simply we have to push it into the stack and as soon as we encounter \"../\" this string then simply we have to pop the last folder from the stack because this is how the folder works , as suppose firstly I am in the D drive then i move to it\\'s child E drive so when I write \"../\" so when I pop E from the stack then I will reach back to the D drive again . That\\'s why I have pushed \"x/\" named folder in the Stack and when I countered \"../\" this string so I have popped the last folder from the stack. No need to check for the string \"./\" because it means that we should remain sit in the same folder means we don\\'t have to perform any operation so there is no point to check for it as we don\\' have do anything in such cases .\\n\\nIn the end simply return the size of the stack because the element present in the stack took us to came out from that folder to main folder.\\n\\n# Approach\\n  LIFO based approach .\\n\\n# Complexity\\n- Time complexity:\\n  O(n)\\n\\n- Space complexity:\\n  O(n)\\n\\n# Code\\n```\\nclass Solution {\\n    public int minOperations(String[] logs) {\\n        Stack<String>stack = new Stack<>();\\n        for(String s:logs){\\n            if(!s.equals(\"../\") && !s.equals(\"./\")) stack.push(s);\\n            else if(s.equals(\"../\") && !stack.isEmpty()) stack.pop();\\n        }\\n        return stack.size();\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Array",
                    "String",
                    "Stack"
                ],
                "code": "```\\nclass Solution {\\n    public int minOperations(String[] logs) {\\n        Stack<String>stack = new Stack<>();\\n        for(String s:logs){\\n            if(!s.equals(\"../\") && !s.equals(\"./\")) stack.push(s);\\n            else if(s.equals(\"../\") && !stack.isEmpty()) stack.pop();\\n        }\\n        return stack.size();\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3975874,
                "title": "kotlin-simple-solution-with-when",
                "content": "# Intuition\\nClarity of code, one cycle.\\n\\n# Approach\\nCycle for the input array, \"when\" for founded actions in array.\\n\\n# Complexity\\n- Time complexity:\\n$$O(n)$$\\n\\n- Space complexity:\\n$$O(n)$$\\n\\n# Code\\n```\\nclass Solution {\\n    fun minOperations(logs: Array<String>): Int {\\n        var countDownDirectories = 0\\n\\n        for (i in logs){\\n            when (i){\\n                \"./\" -> continue\\n                \"../\" -> {\\n                    if (countDownDirectories > 0) countDownDirectories --\\n                }\\n                else -> countDownDirectories ++\\n            }\\n        }\\n\\n        return countDownDirectories\\n    }\\n}\\n```",
                "solutionTags": [
                    "Kotlin"
                ],
                "code": "```\\nclass Solution {\\n    fun minOperations(logs: Array<String>): Int {\\n        var countDownDirectories = 0\\n\\n        for (i in logs){\\n            when (i){\\n                \"./\" -> continue\\n                \"../\" -> {\\n                    if (countDownDirectories > 0) countDownDirectories --\\n                }\\n                else -> countDownDirectories ++\\n            }\\n        }\\n\\n        return countDownDirectories\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3967403,
                "title": "easy-to-understand",
                "content": "```\\nclass Solution {\\n    public int minOperations(String[] logs) {\\n        int count = 0;\\n        for(int i=0; i<logs.length; i++){\\n            // if first character of log is digit or character then increment the count.\\n            char ch = logs[i].charAt(0);\\n            if((ch >= \\'a\\' && ch <= \\'z\\') || Character.isDigit(ch)){\\n                count++;\\n            }\\n            // if log is equals to \"../\" and count is less than or equals to 0 then don\\'t increment count.\\n            else if(logs[i].equals(\"../\")){\\n                if(count<=0) continue;\\n                else count--;\\n            }\\n            else{\\n                continue;\\n            }\\n        }\\n        if(count < 0) count = 0;\\n        return count;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int minOperations(String[] logs) {\\n        int count = 0;\\n        for(int i=0; i<logs.length; i++){\\n            // if first character of log is digit or character then increment the count.\\n            char ch = logs[i].charAt(0);\\n            if((ch >= \\'a\\' && ch <= \\'z\\') || Character.isDigit(ch)){\\n                count++;\\n            }\\n            // if log is equals to \"../\" and count is less than or equals to 0 then don\\'t increment count.\\n            else if(logs[i].equals(\"../\")){\\n                if(count<=0) continue;\\n                else count--;\\n            }\\n            else{\\n                continue;\\n            }\\n        }\\n        if(count < 0) count = 0;\\n        return count;\\n    }\\n}\\n```",
                "codeTag": "Java"
            }
        ],
        "discussions": [
            {
                "id": 1798209,
                "content": [
                    {
                        "username": "fuc-",
                        "content": "The 2 hints provided are the same, kindly look into it! Cheers!"
                    },
                    {
                        "username": "soumyajit_0",
                        "content": "The question setter went out of Hints. :3"
                    },
                    {
                        "username": "soumyajit_0",
                        "content": "The guy who used Stack for solving this question should be declared as the most hardworking person on this planet after ChatGPT."
                    },
                    {
                        "username": "Coder-Haris",
                        "content": "haha\\n"
                    },
                    {
                        "username": "M_Suleman",
                        "content": "The solution is simple.\\n->create count varable\\n->If first char of log[i] is digit or charcter i.e(d2/, h21/) etc. Then increment count\\n->if you face \"../\" decrement count.\\n-> if you encounter \"./\" leave it \\n\\nSorry for my bad English.\\n"
                    },
                    {
                        "username": "piyush_mehta22",
                        "content": "when there is a stack, there is always a +1, -1.\\nconstant space\\uD83D\\uDE43"
                    },
                    {
                        "username": "yeedaKing",
                        "content": "just create a stack and append or pop folders to the stack based on the operations... then return the length of the stack"
                    },
                    {
                        "username": "jtoumi",
                        "content": "the description is misleading !!!\\nThis might help: think about how to get the final depth (after all operations have been performed)  "
                    },
                    {
                        "username": "anmol_8862",
                        "content": "The description is tricky.\\nyou need to give the minimum operation required to go back to main folder after performing whole operations of the given logs array"
                    }
                ]
            },
            {
                "id": 1980281,
                "content": [
                    {
                        "username": "fuc-",
                        "content": "The 2 hints provided are the same, kindly look into it! Cheers!"
                    },
                    {
                        "username": "soumyajit_0",
                        "content": "The question setter went out of Hints. :3"
                    },
                    {
                        "username": "soumyajit_0",
                        "content": "The guy who used Stack for solving this question should be declared as the most hardworking person on this planet after ChatGPT."
                    },
                    {
                        "username": "Coder-Haris",
                        "content": "haha\\n"
                    },
                    {
                        "username": "M_Suleman",
                        "content": "The solution is simple.\\n->create count varable\\n->If first char of log[i] is digit or charcter i.e(d2/, h21/) etc. Then increment count\\n->if you face \"../\" decrement count.\\n-> if you encounter \"./\" leave it \\n\\nSorry for my bad English.\\n"
                    },
                    {
                        "username": "piyush_mehta22",
                        "content": "when there is a stack, there is always a +1, -1.\\nconstant space\\uD83D\\uDE43"
                    },
                    {
                        "username": "yeedaKing",
                        "content": "just create a stack and append or pop folders to the stack based on the operations... then return the length of the stack"
                    },
                    {
                        "username": "jtoumi",
                        "content": "the description is misleading !!!\\nThis might help: think about how to get the final depth (after all operations have been performed)  "
                    },
                    {
                        "username": "anmol_8862",
                        "content": "The description is tricky.\\nyou need to give the minimum operation required to go back to main folder after performing whole operations of the given logs array"
                    }
                ]
            },
            {
                "id": 2022316,
                "content": [
                    {
                        "username": "fuc-",
                        "content": "The 2 hints provided are the same, kindly look into it! Cheers!"
                    },
                    {
                        "username": "soumyajit_0",
                        "content": "The question setter went out of Hints. :3"
                    },
                    {
                        "username": "soumyajit_0",
                        "content": "The guy who used Stack for solving this question should be declared as the most hardworking person on this planet after ChatGPT."
                    },
                    {
                        "username": "Coder-Haris",
                        "content": "haha\\n"
                    },
                    {
                        "username": "M_Suleman",
                        "content": "The solution is simple.\\n->create count varable\\n->If first char of log[i] is digit or charcter i.e(d2/, h21/) etc. Then increment count\\n->if you face \"../\" decrement count.\\n-> if you encounter \"./\" leave it \\n\\nSorry for my bad English.\\n"
                    },
                    {
                        "username": "piyush_mehta22",
                        "content": "when there is a stack, there is always a +1, -1.\\nconstant space\\uD83D\\uDE43"
                    },
                    {
                        "username": "yeedaKing",
                        "content": "just create a stack and append or pop folders to the stack based on the operations... then return the length of the stack"
                    },
                    {
                        "username": "jtoumi",
                        "content": "the description is misleading !!!\\nThis might help: think about how to get the final depth (after all operations have been performed)  "
                    },
                    {
                        "username": "anmol_8862",
                        "content": "The description is tricky.\\nyou need to give the minimum operation required to go back to main folder after performing whole operations of the given logs array"
                    }
                ]
            },
            {
                "id": 2019251,
                "content": [
                    {
                        "username": "fuc-",
                        "content": "The 2 hints provided are the same, kindly look into it! Cheers!"
                    },
                    {
                        "username": "soumyajit_0",
                        "content": "The question setter went out of Hints. :3"
                    },
                    {
                        "username": "soumyajit_0",
                        "content": "The guy who used Stack for solving this question should be declared as the most hardworking person on this planet after ChatGPT."
                    },
                    {
                        "username": "Coder-Haris",
                        "content": "haha\\n"
                    },
                    {
                        "username": "M_Suleman",
                        "content": "The solution is simple.\\n->create count varable\\n->If first char of log[i] is digit or charcter i.e(d2/, h21/) etc. Then increment count\\n->if you face \"../\" decrement count.\\n-> if you encounter \"./\" leave it \\n\\nSorry for my bad English.\\n"
                    },
                    {
                        "username": "piyush_mehta22",
                        "content": "when there is a stack, there is always a +1, -1.\\nconstant space\\uD83D\\uDE43"
                    },
                    {
                        "username": "yeedaKing",
                        "content": "just create a stack and append or pop folders to the stack based on the operations... then return the length of the stack"
                    },
                    {
                        "username": "jtoumi",
                        "content": "the description is misleading !!!\\nThis might help: think about how to get the final depth (after all operations have been performed)  "
                    },
                    {
                        "username": "anmol_8862",
                        "content": "The description is tricky.\\nyou need to give the minimum operation required to go back to main folder after performing whole operations of the given logs array"
                    }
                ]
            },
            {
                "id": 1979113,
                "content": [
                    {
                        "username": "fuc-",
                        "content": "The 2 hints provided are the same, kindly look into it! Cheers!"
                    },
                    {
                        "username": "soumyajit_0",
                        "content": "The question setter went out of Hints. :3"
                    },
                    {
                        "username": "soumyajit_0",
                        "content": "The guy who used Stack for solving this question should be declared as the most hardworking person on this planet after ChatGPT."
                    },
                    {
                        "username": "Coder-Haris",
                        "content": "haha\\n"
                    },
                    {
                        "username": "M_Suleman",
                        "content": "The solution is simple.\\n->create count varable\\n->If first char of log[i] is digit or charcter i.e(d2/, h21/) etc. Then increment count\\n->if you face \"../\" decrement count.\\n-> if you encounter \"./\" leave it \\n\\nSorry for my bad English.\\n"
                    },
                    {
                        "username": "piyush_mehta22",
                        "content": "when there is a stack, there is always a +1, -1.\\nconstant space\\uD83D\\uDE43"
                    },
                    {
                        "username": "yeedaKing",
                        "content": "just create a stack and append or pop folders to the stack based on the operations... then return the length of the stack"
                    },
                    {
                        "username": "jtoumi",
                        "content": "the description is misleading !!!\\nThis might help: think about how to get the final depth (after all operations have been performed)  "
                    },
                    {
                        "username": "anmol_8862",
                        "content": "The description is tricky.\\nyou need to give the minimum operation required to go back to main folder after performing whole operations of the given logs array"
                    }
                ]
            },
            {
                "id": 1968836,
                "content": [
                    {
                        "username": "fuc-",
                        "content": "The 2 hints provided are the same, kindly look into it! Cheers!"
                    },
                    {
                        "username": "soumyajit_0",
                        "content": "The question setter went out of Hints. :3"
                    },
                    {
                        "username": "soumyajit_0",
                        "content": "The guy who used Stack for solving this question should be declared as the most hardworking person on this planet after ChatGPT."
                    },
                    {
                        "username": "Coder-Haris",
                        "content": "haha\\n"
                    },
                    {
                        "username": "M_Suleman",
                        "content": "The solution is simple.\\n->create count varable\\n->If first char of log[i] is digit or charcter i.e(d2/, h21/) etc. Then increment count\\n->if you face \"../\" decrement count.\\n-> if you encounter \"./\" leave it \\n\\nSorry for my bad English.\\n"
                    },
                    {
                        "username": "piyush_mehta22",
                        "content": "when there is a stack, there is always a +1, -1.\\nconstant space\\uD83D\\uDE43"
                    },
                    {
                        "username": "yeedaKing",
                        "content": "just create a stack and append or pop folders to the stack based on the operations... then return the length of the stack"
                    },
                    {
                        "username": "jtoumi",
                        "content": "the description is misleading !!!\\nThis might help: think about how to get the final depth (after all operations have been performed)  "
                    },
                    {
                        "username": "anmol_8862",
                        "content": "The description is tricky.\\nyou need to give the minimum operation required to go back to main folder after performing whole operations of the given logs array"
                    }
                ]
            },
            {
                "id": 1930046,
                "content": [
                    {
                        "username": "fuc-",
                        "content": "The 2 hints provided are the same, kindly look into it! Cheers!"
                    },
                    {
                        "username": "soumyajit_0",
                        "content": "The question setter went out of Hints. :3"
                    },
                    {
                        "username": "soumyajit_0",
                        "content": "The guy who used Stack for solving this question should be declared as the most hardworking person on this planet after ChatGPT."
                    },
                    {
                        "username": "Coder-Haris",
                        "content": "haha\\n"
                    },
                    {
                        "username": "M_Suleman",
                        "content": "The solution is simple.\\n->create count varable\\n->If first char of log[i] is digit or charcter i.e(d2/, h21/) etc. Then increment count\\n->if you face \"../\" decrement count.\\n-> if you encounter \"./\" leave it \\n\\nSorry for my bad English.\\n"
                    },
                    {
                        "username": "piyush_mehta22",
                        "content": "when there is a stack, there is always a +1, -1.\\nconstant space\\uD83D\\uDE43"
                    },
                    {
                        "username": "yeedaKing",
                        "content": "just create a stack and append or pop folders to the stack based on the operations... then return the length of the stack"
                    },
                    {
                        "username": "jtoumi",
                        "content": "the description is misleading !!!\\nThis might help: think about how to get the final depth (after all operations have been performed)  "
                    },
                    {
                        "username": "anmol_8862",
                        "content": "The description is tricky.\\nyou need to give the minimum operation required to go back to main folder after performing whole operations of the given logs array"
                    }
                ]
            }
        ]
    },
    {
        "title": "Maximum Profit of Operating a Centennial Wheel",
        "question_content": "<p>You are the operator of a Centennial Wheel that has <strong>four gondolas</strong>, and each gondola has room for <strong>up</strong> <strong>to</strong> <strong>four people</strong>. You have the ability to rotate the gondolas <strong>counterclockwise</strong>, which costs you <code>runningCost</code> dollars.</p>\n\n<p>You are given an array <code>customers</code> of length <code>n</code> where <code>customers[i]</code> is the number of new customers arriving just before the <code>i<sup>th</sup></code> rotation (0-indexed). This means you <strong>must rotate the wheel </strong><code>i</code><strong> times before the </strong><code>customers[i]</code><strong> customers arrive</strong>. <strong>You cannot make customers wait if there is room in the gondola</strong>. Each customer pays <code>boardingCost</code> dollars when they board on the gondola closest to the ground and will exit once that gondola reaches the ground again.</p>\n\n<p>You can stop the wheel at any time, including <strong>before</strong> <strong>serving</strong> <strong>all</strong> <strong>customers</strong>. If you decide to stop serving customers, <strong>all subsequent rotations are free</strong> in order to get all the customers down safely. Note that if there are currently more than four customers waiting at the wheel, only four will board the gondola, and the rest will wait <strong>for the next rotation</strong>.</p>\n\n<p>Return<em> the minimum number of rotations you need to perform to maximize your profit.</em> If there is <strong>no scenario</strong> where the profit is positive, return <code>-1</code>.</p>\n\n<p>&nbsp;</p>\n<p><strong class=\"example\">Example 1:</strong></p>\n<img alt=\"\" src=\"https://assets.leetcode.com/uploads/2020/09/09/wheeldiagram12.png\" style=\"width: 700px; height: 225px;\" />\n<pre>\n<strong>Input:</strong> customers = [8,3], boardingCost = 5, runningCost = 6\n<strong>Output:</strong> 3\n<strong>Explanation:</strong> The numbers written on the gondolas are the number of people currently there.\n1. 8 customers arrive, 4 board and 4 wait for the next gondola, the wheel rotates. Current profit is 4 * $5 - 1 * $6 = $14.\n2. 3 customers arrive, the 4 waiting board the wheel and the other 3 wait, the wheel rotates. Current profit is 8 * $5 - 2 * $6 = $28.\n3. The final 3 customers board the gondola, the wheel rotates. Current profit is 11 * $5 - 3 * $6 = $37.\nThe highest profit was $37 after rotating the wheel 3 times.\n</pre>\n\n<p><strong class=\"example\">Example 2:</strong></p>\n\n<pre>\n<strong>Input:</strong> customers = [10,9,6], boardingCost = 6, runningCost = 4\n<strong>Output:</strong> 7\n<strong>Explanation:</strong>\n1. 10 customers arrive, 4 board and 6 wait for the next gondola, the wheel rotates. Current profit is 4 * $6 - 1 * $4 = $20.\n2. 9 customers arrive, 4 board and 11 wait (2 originally waiting, 9 newly waiting), the wheel rotates. Current profit is 8 * $6 - 2 * $4 = $40.\n3. The final 6 customers arrive, 4 board and 13 wait, the wheel rotates. Current profit is 12 * $6 - 3 * $4 = $60.\n4. 4 board and 9 wait, the wheel rotates. Current profit is 16 * $6 - 4 * $4 = $80.\n5. 4 board and 5 wait, the wheel rotates. Current profit is 20 * $6 - 5 * $4 = $100.\n6. 4 board and 1 waits, the wheel rotates. Current profit is 24 * $6 - 6 * $4 = $120.\n7. 1 boards, the wheel rotates. Current profit is 25 * $6 - 7 * $4 = $122.\nThe highest profit was $122 after rotating the wheel 7 times.\n</pre>\n\n<p><strong class=\"example\">Example 3:</strong></p>\n\n<pre>\n<strong>Input:</strong> customers = [3,4,0,5,1], boardingCost = 1, runningCost = 92\n<strong>Output:</strong> -1\n<strong>Explanation:</strong>\n1. 3 customers arrive, 3 board and 0 wait, the wheel rotates. Current profit is 3 * $1 - 1 * $92 = -$89.\n2. 4 customers arrive, 4 board and 0 wait, the wheel rotates. Current profit is 7 * $1 - 2 * $92 = -$177.\n3. 0 customers arrive, 0 board and 0 wait, the wheel rotates. Current profit is 7 * $1 - 3 * $92 = -$269.\n4. 5 customers arrive, 4 board and 1 waits, the wheel rotates. Current profit is 11 * $1 - 4 * $92 = -$357.\n5. 1 customer arrives, 2 board and 0 wait, the wheel rotates. Current profit is 13 * $1 - 5 * $92 = -$447.\nThe profit was never positive, so return -1.\n</pre>\n\n<p>&nbsp;</p>\n<p><strong>Constraints:</strong></p>\n\n<ul>\n\t<li><code>n == customers.length</code></li>\n\t<li><code>1 &lt;= n &lt;= 10<sup>5</sup></code></li>\n\t<li><code>0 &lt;= customers[i] &lt;= 50</code></li>\n\t<li><code>1 &lt;= boardingCost, runningCost &lt;= 100</code></li>\n</ul>\n",
        "solutions": [
            {
                "id": 866409,
                "title": "java-simple-o-n-greedy",
                "content": "Cleaner ones:\\ntime: O(N), N is the total passenger count / 4;\\n```\\n    public int minOperationsMaxProfit(int[] cs, int bc, int rc) {\\n        int run = 0, maxRun = 1, prof = 0, maxProf = prof, sum = 0, i = 0;\\n        while (sum > 0 || i < cs.length) {\\n            if (i < cs.length) sum += cs[i++];\\n            int bd = Math.min(4, sum);  // boarding people by greedy. \\n            sum -= bd;\\n            prof = prof + bd * bc - rc;\\n            run++;\\n            if (prof > maxProf) {\\n                maxProf = prof;\\n                maxRun = run;\\n            }\\n        }\\n        return maxProf > 0 ? maxRun : -1;\\n    }\\n```\\n",
                "solutionTags": [],
                "code": "```\\n    public int minOperationsMaxProfit(int[] cs, int bc, int rc) {\\n        int run = 0, maxRun = 1, prof = 0, maxProf = prof, sum = 0, i = 0;\\n        while (sum > 0 || i < cs.length) {\\n            if (i < cs.length) sum += cs[i++];\\n            int bd = Math.min(4, sum);  // boarding people by greedy. \\n            sum -= bd;\\n            prof = prof + bd * bc - rc;\\n            run++;\\n            if (prof > maxProf) {\\n                maxProf = prof;\\n                maxRun = run;\\n            }\\n        }\\n        return maxProf > 0 ? maxRun : -1;\\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 868458,
                "title": "c-simulation",
                "content": "Just do exactly what the problem says until you run out of customers. Track the maximum profit so far and it\\'s turn number.\\n\\n```cpp\\nint minOperationsMaxProfit(vector<int>& cust, int boardingCost, int runningCost) {\\n    int wait = 0, prof = 0, max_prof = 0, max_i = -1;\\n    for (int i = 0; i < cust.size() || wait > 0; ++i) {\\n        if (i < cust.size())\\n            wait += cust[i];\\n        prof += min(4, wait) * boardingCost - runningCost;\\n        wait -= min(4, wait);\\n        if (max_prof < prof) {\\n            max_prof = prof;\\n            max_i = i + 1;\\n        }\\n    }\\n    return max_i;\\n}\\n```",
                "solutionTags": [],
                "code": "```cpp\\nint minOperationsMaxProfit(vector<int>& cust, int boardingCost, int runningCost) {\\n    int wait = 0, prof = 0, max_prof = 0, max_i = -1;\\n    for (int i = 0; i < cust.size() || wait > 0; ++i) {\\n        if (i < cust.size())\\n            wait += cust[i];\\n        prof += min(4, wait) * boardingCost - runningCost;\\n        wait -= min(4, wait);\\n        if (max_prof < prof) {\\n            max_prof = prof;\\n            max_i = i + 1;\\n        }\\n    }\\n    return max_i;\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 866375,
                "title": "very-easy-idea-simulation-problem-readable-code-with-comments",
                "content": "```\\n\\n/*\\n\\nOne small idea that makes the code a lot simpler is to only accept 4 customers from customers[i] \\nat a time and defer the rest into\\ncustomer[i+1].\\nAt the end we can deal with all the waiting customers at once.\\n\\n*/\\n\\nclass Solution {\\n\\tint rotations = 0;  // Stores number of rotations made so far.\\n    int profit = 0;        // Stores current profit after \"rotations\" rotations.\\n\\tint maxProfit = 0;  // Stores max profit reached so far.\\n\\tint bestRotations = 0;   // Stores rotations corresponding to \"maxProfit\".\\n\\n\\n    int bCost, rCost;  // Boarding and Running costs.\\npublic:\\n\\n    // Updates the necessary variables and computes maxProfit, bestRotations etc.\\n    void report(int boarded) {\\n        profit += (boarded*bCost - rCost);  // add the profit earned.\\n        rotations++;                        // count this rotation.\\n        if (profit > maxProfit) {           // update maximum profit.\\n            maxProfit = profit;\\n            bestRotations = rotations;\\n        }\\n    }\\n    \\n    int minOperationsMaxProfit(vector<int>& customers, int boardingCost, int runnningCost) {\\n        bCost = boardingCost;\\n        rCost = runnningCost;\\n        int n = customers.size();\\n        for (int i=0; i<n-1; i++) {   // For each group of customers -\\n            if (customers[i] > 4) {   // Limit it to just 4\\n                customers[i+1] += (customers[i]-4);  // Add remaining to next\\n                customers[i] = 4;  // update the current group.\\n            }\\n            report(customers[i]);  // generate report of this rotation\\n        }\\n        \\n        int waiting = customers[n-1]; \\n        while (waiting > 0) {\\n            int boarded = min(4, waiting); // max 4 at a time.\\n            waiting -= boarded; // reduce the people in waiting\\n            report(boarded);  // generate report\\n        }\\n        \\n        return maxProfit > 0 ? bestRotations : -1;\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\n\\n/*\\n\\nOne small idea that makes the code a lot simpler is to only accept 4 customers from customers[i] \\nat a time and defer the rest into\\ncustomer[i+1].\\nAt the end we can deal with all the waiting customers at once.\\n\\n*/\\n\\nclass Solution {\\n\\tint rotations = 0;  // Stores number of rotations made so far.\\n    int profit = 0;        // Stores current profit after \"rotations\" rotations.\\n\\tint maxProfit = 0;  // Stores max profit reached so far.\\n\\tint bestRotations = 0;   // Stores rotations corresponding to \"maxProfit\".\\n\\n\\n    int bCost, rCost;  // Boarding and Running costs.\\npublic:\\n\\n    // Updates the necessary variables and computes maxProfit, bestRotations etc.\\n    void report(int boarded) {\\n        profit += (boarded*bCost - rCost);  // add the profit earned.\\n        rotations++;                        // count this rotation.\\n        if (profit > maxProfit) {           // update maximum profit.\\n            maxProfit = profit;\\n            bestRotations = rotations;\\n        }\\n    }\\n    \\n    int minOperationsMaxProfit(vector<int>& customers, int boardingCost, int runnningCost) {\\n        bCost = boardingCost;\\n        rCost = runnningCost;\\n        int n = customers.size();\\n        for (int i=0; i<n-1; i++) {   // For each group of customers -\\n            if (customers[i] > 4) {   // Limit it to just 4\\n                customers[i+1] += (customers[i]-4);  // Add remaining to next\\n                customers[i] = 4;  // update the current group.\\n            }\\n            report(customers[i]);  // generate report of this rotation\\n        }\\n        \\n        int waiting = customers[n-1]; \\n        while (waiting > 0) {\\n            int boarded = min(4, waiting); // max 4 at a time.\\n            waiting -= boarded; // reduce the people in waiting\\n            report(boarded);  // generate report\\n        }\\n        \\n        return maxProfit > 0 ? bestRotations : -1;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 866356,
                "title": "python3-simulation",
                "content": "\\n```\\nclass Solution:\\n    def minOperationsMaxProfit(self, customers: List[int], boardingCost: int, runningCost: int) -> int:\\n        ans = -1\\n        most = pnl = waiting = 0\\n        for i, x in enumerate(customers): \\n            waiting += x # more people waiting in line \\n            waiting -= (chg := min(4, waiting)) # boarding \\n            pnl += chg * boardingCost - runningCost \\n            if most < pnl: ans, most = i+1, pnl\\n        q, r = divmod(waiting, 4)\\n        if 4*boardingCost > runningCost: ans += q\\n        if r*boardingCost > runningCost: ans += 1\\n        return ans \\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def minOperationsMaxProfit(self, customers: List[int], boardingCost: int, runningCost: int) -> int:\\n        ans = -1\\n        most = pnl = waiting = 0\\n        for i, x in enumerate(customers): \\n            waiting += x # more people waiting in line \\n            waiting -= (chg := min(4, waiting)) # boarding \\n            pnl += chg * boardingCost - runningCost \\n            if most < pnl: ans, most = i+1, pnl\\n        q, r = divmod(waiting, 4)\\n        if 4*boardingCost > runningCost: ans += q\\n        if r*boardingCost > runningCost: ans += 1\\n        return ans \\n```",
                "codeTag": "Java"
            },
            {
                "id": 866896,
                "title": "simulate-the-problem-detailed-explanation-java",
                "content": "```\\npublic int minOperationsMaxProfit(int[] customers, int boardingCost, int runningCost) {\\n    //Keep track of customers who are waiting and customers who are on-board.\\n\\tint waitingCustomers = customers[0], totalOnBoard = 0;\\n    int result = -1, maxProfit = 0;\\n    for(int i=1; i<customers.length || waitingCustomers>0; i++){\\n         //In one round you can board max. 4 customers\\n\\t\\tint newlyOnboarded = Math.min(4,waitingCustomers);\\n\\t\\t//Substract newlyOnBoarded customer from waiting-list.\\n        waitingCustomers-=newlyOnboarded;\\n        totalOnBoard+=newlyOnboarded;\\n\\n        int profit = totalOnBoard*boardingCost - i*runningCost;\\n\\t\\t//If the profit is maximum, update the result.\\n        if(profit>maxProfit){\\n            maxProfit = profit;\\n            result = i;\\n        }\\n\\t\\t//customers will be added to waiting customer count.\\n        if(i<customers.length) waitingCustomers +=customers[i];\\n    }\\n    return result;\\n}\\n```",
                "solutionTags": [],
                "code": "```\\npublic int minOperationsMaxProfit(int[] customers, int boardingCost, int runningCost) {\\n    //Keep track of customers who are waiting and customers who are on-board.\\n\\tint waitingCustomers = customers[0], totalOnBoard = 0;\\n    int result = -1, maxProfit = 0;\\n    for(int i=1; i<customers.length || waitingCustomers>0; i++){\\n         //In one round you can board max. 4 customers\\n\\t\\tint newlyOnboarded = Math.min(4,waitingCustomers);\\n\\t\\t//Substract newlyOnBoarded customer from waiting-list.\\n        waitingCustomers-=newlyOnboarded;\\n        totalOnBoard+=newlyOnboarded;\\n\\n        int profit = totalOnBoard*boardingCost - i*runningCost;\\n\\t\\t//If the profit is maximum, update the result.\\n        if(profit>maxProfit){\\n            maxProfit = profit;\\n            result = i;\\n        }\\n\\t\\t//customers will be added to waiting customer count.\\n        if(i<customers.length) waitingCustomers +=customers[i];\\n    }\\n    return result;\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 917385,
                "title": "python-c-easy-solution-o-n",
                "content": "**C++**\\n```\\nclass Solution {\\npublic:\\n    int minOperationsMaxProfit(vector<int>& customers, int boardingCost, int runningCost) {\\n        int rotate = 0, total = 0, money = 0, num = 0, i;\\n\\t\\tint maxx = INT_MIN, ans = rotate;\\n        for(i = 0; i< customers.size(); i++){\\n            total += customers[i];\\n            rotate = i+1;\\n            if(total >= 4) {num += 4; total -= 4;}\\n            else { num += total; total = 0;}\\n            money = num * boardingCost - rotate * runningCost;\\n            if(maxx < money) {maxx = money; ans = rotate;}\\n        }\\n        while(total > 0){\\n            rotate = i+1;\\n            if(total >= 4) {num += 4; total -= 4;}\\n            else { num += total; total = 0;}\\n            money = num * boardingCost - rotate * runningCost;\\n            if(maxx < money) {maxx = money; ans = rotate;}\\n            i++;\\n\\n        }\\n        if(maxx < 0) return -1;\\n        return ans;\\n    }\\n};\\n```\\n**Python**\\n\\n```\\nimport sys\\nMIN_INT = -sys.maxsize-1\\nclass Solution:\\n    def minOperationsMaxProfit(self, customers: List[int], boardingCost: int, runningCost: int) -> int:\\n        maxx = MIN_INT\\n        rotate = total =  ans = money = num = i = 0\\n        for i in range(len(customers)):\\n            total += customers[i]\\n            rotate = i+1\\n            if total >= 4:\\n                num += 4\\n                total -= 4\\n            else: \\n                num += total\\n                total = 0\\n            money = num * boardingCost - rotate * runningCost\\n            if maxx < money:\\n                maxx = money\\n                ans = rotate\\n        i+=1\\n        while(total > 0):\\n            rotate = i+1\\n            if total >= 4:\\n                num += 4\\n                total -= 4\\n            else: \\n                num += total\\n                total = 0\\n            money = num * boardingCost - rotate * runningCost\\n            if maxx < money:\\n                maxx = money\\n                ans = rotate\\n            i+=1\\n        if maxx < 0: return -1\\n        return ans\\n```",
                "solutionTags": [
                    "C"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int minOperationsMaxProfit(vector<int>& customers, int boardingCost, int runningCost) {\\n        int rotate = 0, total = 0, money = 0, num = 0, i;\\n\\t\\tint maxx = INT_MIN, ans = rotate;\\n        for(i = 0; i< customers.size(); i++){\\n            total += customers[i];\\n            rotate = i+1;\\n            if(total >= 4) {num += 4; total -= 4;}\\n            else { num += total; total = 0;}\\n            money = num * boardingCost - rotate * runningCost;\\n            if(maxx < money) {maxx = money; ans = rotate;}\\n        }\\n        while(total > 0){\\n            rotate = i+1;\\n            if(total >= 4) {num += 4; total -= 4;}\\n            else { num += total; total = 0;}\\n            money = num * boardingCost - rotate * runningCost;\\n            if(maxx < money) {maxx = money; ans = rotate;}\\n            i++;\\n\\n        }\\n        if(maxx < 0) return -1;\\n        return ans;\\n    }\\n};\\n```\n```\\nimport sys\\nMIN_INT = -sys.maxsize-1\\nclass Solution:\\n    def minOperationsMaxProfit(self, customers: List[int], boardingCost: int, runningCost: int) -> int:\\n        maxx = MIN_INT\\n        rotate = total =  ans = money = num = i = 0\\n        for i in range(len(customers)):\\n            total += customers[i]\\n            rotate = i+1\\n            if total >= 4:\\n                num += 4\\n                total -= 4\\n            else: \\n                num += total\\n                total = 0\\n            money = num * boardingCost - rotate * runningCost\\n            if maxx < money:\\n                maxx = money\\n                ans = rotate\\n        i+=1\\n        while(total > 0):\\n            rotate = i+1\\n            if total >= 4:\\n                num += 4\\n                total -= 4\\n            else: \\n                num += total\\n                total = 0\\n            money = num * boardingCost - rotate * runningCost\\n            if maxx < money:\\n                maxx = money\\n                ans = rotate\\n            i+=1\\n        if maxx < 0: return -1\\n        return ans\\n```",
                "codeTag": "Java"
            },
            {
                "id": 876078,
                "title": "python-easiest-to-understand-imo",
                "content": "We need to keep track of the profit at that iteration and compare it to our max profit. We don\\'t return a value which is not the maxProfit. This is was the case I struggled with.\\n\\n```\\ni = 1 # start at 1\\nwaiting, onBoard, result, maxProfit  = customers[0],  0, -1, 0\\n        while i < len(customers) or waiting > 0:\\n            newToOnboard = min(4, waiting) # get 4 or remainder + current passangers\\n\\n            waiting -= newToOnboard # remove people waiting\\n            onBoard += newToOnboard # add people to go\\n\\n            profit = onBoard*boardingCost - i*runningCost # get profit of all to go\\n\\n            if(profit>maxProfit): # if profit is over max then reset the maxProfit\\n                maxProfit = profit\\n                result = i\\n            if(i<len(customers)): waiting +=customers[i] # stop adding customers once we finish list\\n            i +=  1\\n        return result",
                "solutionTags": [],
                "code": "We need to keep track of the profit at that iteration and compare it to our max profit. We don\\'t return a value which is not the maxProfit. This is was the case I struggled with.\\n\\n```\\ni = 1 # start at 1\\nwaiting, onBoard, result, maxProfit  = customers[0],  0, -1, 0\\n        while i < len(customers) or waiting > 0:\\n            newToOnboard = min(4, waiting) # get 4 or remainder + current passangers\\n\\n            waiting -= newToOnboard # remove people waiting\\n            onBoard += newToOnboard # add people to go\\n\\n            profit = onBoard*boardingCost - i*runningCost # get profit of all to go\\n\\n            if(profit>maxProfit): # if profit is over max then reset the maxProfit\\n                maxProfit = profit\\n                result = i\\n            if(i<len(customers)): waiting +=customers[i] # stop adding customers once we finish list\\n            i +=  1\\n        return result",
                "codeTag": "Unknown"
            },
            {
                "id": 866526,
                "title": "python-simulation",
                "content": "```\\nclass Solution:\\n    def minOperationsMaxProfit(self, arr: List[int], boardingCost : int, runningCost : int) -> int:\\n        # Dividing people in the groups of <=4\\n        grps = []\\n        # length of customers array\\n        n = len(arr)\\n        # rem--> number of people waiting\\n        rem = 0\\n        \\n        # traversing the customers array\\n        for i in range(n):\\n            # total number of people available right now \\n            avail = arr[i]+rem\\n            # number of available people >=4 then append grp of 4 and update remaining [rem]\\n            if avail>=4:\\n                avail-=4\\n                grps.append(4)\\n                rem = avail\\n            # number of available people <4  then make group of available people and update remaining [rem=0]\\n            else:\\n                rem = 0\\n                grps.append(avail)\\n        \\n        # make groups of 4 until remaining >=4 otherwise make <4 and break\\n        while rem>0:\\n            if rem>=4:\\n                rem-=4\\n                grps.append(4)\\n            else:\\n                grps.append(rem)\\n                rem = 0\\n        \\n        # mex--> represents maximum profit\\n        mex = -10**10\\n        # cost--> represents current total cost\\n        cost = 0\\n        # ind --> represents rotation number\\n        ind = 0\\n        for i in range(len(grps)):\\n            # calculate net cost till now\\n            cost+= boardingCost*grps[i]-runningCost\\n            # upadte max profit and rotation number\\n            if mex<cost:\\n                mex = max(mex,cost)\\n                ind = i+1\\n        # max profit< 0\\n        if mex<0:\\n            return -1\\n        # return rotation number\\n        return ind\\n        \\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def minOperationsMaxProfit(self, arr: List[int], boardingCost : int, runningCost : int) -> int:\\n        # Dividing people in the groups of <=4\\n        grps = []\\n        # length of customers array\\n        n = len(arr)\\n        # rem--> number of people waiting\\n        rem = 0\\n        \\n        # traversing the customers array\\n        for i in range(n):\\n            # total number of people available right now \\n            avail = arr[i]+rem\\n            # number of available people >=4 then append grp of 4 and update remaining [rem]\\n            if avail>=4:\\n                avail-=4\\n                grps.append(4)\\n                rem = avail\\n            # number of available people <4  then make group of available people and update remaining [rem=0]\\n            else:\\n                rem = 0\\n                grps.append(avail)\\n        \\n        # make groups of 4 until remaining >=4 otherwise make <4 and break\\n        while rem>0:\\n            if rem>=4:\\n                rem-=4\\n                grps.append(4)\\n            else:\\n                grps.append(rem)\\n                rem = 0\\n        \\n        # mex--> represents maximum profit\\n        mex = -10**10\\n        # cost--> represents current total cost\\n        cost = 0\\n        # ind --> represents rotation number\\n        ind = 0\\n        for i in range(len(grps)):\\n            # calculate net cost till now\\n            cost+= boardingCost*grps[i]-runningCost\\n            # upadte max profit and rotation number\\n            if mex<cost:\\n                mex = max(mex,cost)\\n                ind = i+1\\n        # max profit< 0\\n        if mex<0:\\n            return -1\\n        # return rotation number\\n        return ind\\n        \\n```",
                "codeTag": "Java"
            },
            {
                "id": 866471,
                "title": "java-beats-100-time-and-space",
                "content": "```\\nclass Solution {\\n    public int minOperationsMaxProfit(int[] customers, int boardingCost, int runningCost) {\\n        int i=0,profit=0,extra=0,maxprofit=0,rotations=0,waiting=0;    \\n        while(i<customers.length || extra>0){\\n            waiting=i<customers.length?customers[i]+extra:extra;\\n            profit += Math.min(waiting,4) * boardingCost - runningCost;\\n            rotations = profit>maxprofit? i+1 : rotations;\\n            maxprofit = profit>maxprofit? profit : maxprofit;\\n            extra = waiting>4 ? waiting-4 : 0;\\n            i++;\\n        }\\n        return rotations==0?-1:rotations;\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    public int minOperationsMaxProfit(int[] customers, int boardingCost, int runningCost) {\\n        int i=0,profit=0,extra=0,maxprofit=0,rotations=0,waiting=0;    \\n        while(i<customers.length || extra>0){\\n            waiting=i<customers.length?customers[i]+extra:extra;\\n            profit += Math.min(waiting,4) * boardingCost - runningCost;\\n            rotations = profit>maxprofit? i+1 : rotations;\\n            maxprofit = profit>maxprofit? profit : maxprofit;\\n            extra = waiting>4 ? waiting-4 : 0;\\n            i++;\\n        }\\n        return rotations==0?-1:rotations;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 866607,
                "title": "c-o-n-simple-code-explained",
                "content": "\\tHint to try yourselves.\\n\\t1. Accumulate the customers in every rotation and compute the total profit till now.\\n\\t2. Keep the rotation count where max profit occurs.\\n\\t\\n\\tSolution Approach:\\n\\tVariable - 1. currentProfit - keeps track of cumulative profit\\n\\t\\t\\t   2. totalCustomer - updates total customer in queue before the wheel runs once\\n\\t\\t\\t   3. maxProfit - maximum profit till now\\n\\t\\t\\t   4. ans - total number of rotation when maxProfit was encountered\\n\\n\\tCode Explanation:\\n\\tTraverese the array and add the customers[i] to total waiting customer i.e totalCustomer\\n\\tNow after the for loop exits we haave made n number of total rotations.\\n\\tIf there are still customers i.e then board them 4 at once and calculate the profit and keep the max profit.\\n\\tWhereever max profit occurs store that count.\\n\\t\\n\\tExample 1: \\n\\tInput: customers = [10,9,6], boardingCost = 6, runningCost = 4\\n\\t\\n\\ti =0 \\n\\ttotal customer 10 \\n\\tCurrent profit is 4 * $6 - 1 * $4 = $20. max profit = 20 , ans =i+1 =1\\n\\ttotalCustomer=6\\n\\t\\n\\ti=1\\n\\ttotal customer 6+9=15 (6 waiting previously and 9 new arrived) \\n\\t Current profit is 8 * $6 - 2 * $4 = $40.. max profit = 40 , ans =i+1 =2\\n\\t totalCustomer=11\\n\\t \\n\\t i=2\\n\\ttotal customer 11+6=17 (11 waiting previously and 6 new arrived) \\n\\tCurrent profit is 12 * $6 - 3 * $4 = $60.. max profit = 60 , ans =i+1 =3\\n\\ttotalCustomer=13\\n\\t\\n\\tNow the for loop exits\\n\\tfor i=3,4,5 profit keep increasing similarly and totalRotations is 6\\n\\tnow again for i=6 ony 1 person boards the wheel which gives final maximum profit as 122\\n\\tand totalRotations as 7;\\n\\t\\n\\tExample 2;\\n\\tInput: customers = [10,10,6,4,7], boardingCost = 3, runningCost = 8\\n\\tI hope you all have got the logic so lets skip this to  i=8\\n\\tfor 8 the roation profit is 32\\n\\tfor 9 th rotation its 36\\n\\tbut in last as only person boards the wheel profit therfore reduces to 31.\\n\\t\\n\\tSo we return 9 where maximum profit occured.\\n\\t\\n\\tIf profit was never positive return -1;\\n\\n```\\nclass Solution\\n{\\npublic:\\n    int minOperationsMaxProfit(vector<int> &customers, int boardingCost, int runningCost)\\n    {\\n        int n = customers.size(), i;\\n        int currentProfit = 0;\\n        int totalCustomer = 0;\\n        int maxProfit = 0;\\n        int ans = -1;\\n        for (i = 0; i < n; i++)\\n        {\\n            totalCustomer += customers[i];\\n            if (totalCustomer >= 4)\\n            {\\n                totalCustomer -= 4;\\n                currentProfit += 4 * boardingCost - runningCost;\\n                if (currentProfit > maxProfit)\\n                {\\n                    maxProfit = currentProfit;\\n                    ans = i + 1;\\n                }\\n            }\\n            else\\n            {\\n                currentProfit += totalCustomer * boardingCost - runningCost;\\n                totalCustomer = 0;\\n                if (currentProfit > maxProfit)\\n                {\\n                    maxProfit = currentProfit;\\n                    ans = i + 1;\\n                }\\n            }\\n        }\\n        int totalRoatation = n;\\n        while (totalCustomer > 0)\\n        {\\n\\n            if (totalCustomer >= 4)\\n            {\\n                totalCustomer -= 4;\\n                currentProfit += 4 * boardingCost - runningCost;\\n                totalRoatation++;\\n                if (currentProfit > maxProfit)\\n                {\\n                    maxProfit = currentProfit;\\n                    ans = i + 1;\\n                }\\n                i++;\\n            }\\n            else\\n            {\\n                currentProfit += totalCustomer * boardingCost - runningCost;\\n                totalCustomer = 0;\\n                totalRoatation++;\\n                if (currentProfit > maxProfit)\\n                {\\n                    maxProfit = currentProfit;\\n                    ans = i + 1;\\n                }\\n                i++;\\n            }\\n        }\\n        if (currentProfit > 0)\\n            return ans;\\n        return -1;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C"
                ],
                "code": "```\\nclass Solution\\n{\\npublic:\\n    int minOperationsMaxProfit(vector<int> &customers, int boardingCost, int runningCost)\\n    {\\n        int n = customers.size(), i;\\n        int currentProfit = 0;\\n        int totalCustomer = 0;\\n        int maxProfit = 0;\\n        int ans = -1;\\n        for (i = 0; i < n; i++)\\n        {\\n            totalCustomer += customers[i];\\n            if (totalCustomer >= 4)\\n            {\\n                totalCustomer -= 4;\\n                currentProfit += 4 * boardingCost - runningCost;\\n                if (currentProfit > maxProfit)\\n                {\\n                    maxProfit = currentProfit;\\n                    ans = i + 1;\\n                }\\n            }\\n            else\\n            {\\n                currentProfit += totalCustomer * boardingCost - runningCost;\\n                totalCustomer = 0;\\n                if (currentProfit > maxProfit)\\n                {\\n                    maxProfit = currentProfit;\\n                    ans = i + 1;\\n                }\\n            }\\n        }\\n        int totalRoatation = n;\\n        while (totalCustomer > 0)\\n        {\\n\\n            if (totalCustomer >= 4)\\n            {\\n                totalCustomer -= 4;\\n                currentProfit += 4 * boardingCost - runningCost;\\n                totalRoatation++;\\n                if (currentProfit > maxProfit)\\n                {\\n                    maxProfit = currentProfit;\\n                    ans = i + 1;\\n                }\\n                i++;\\n            }\\n            else\\n            {\\n                currentProfit += totalCustomer * boardingCost - runningCost;\\n                totalCustomer = 0;\\n                totalRoatation++;\\n                if (currentProfit > maxProfit)\\n                {\\n                    maxProfit = currentProfit;\\n                    ans = i + 1;\\n                }\\n                i++;\\n            }\\n        }\\n        if (currentProfit > 0)\\n            return ans;\\n        return -1;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 866597,
                "title": "java-clear-solution-in-linear-time",
                "content": "Rotate till customers are there or are in waiting. If customer available then add them to waiting count (doing this because we can choose customers from waiting pool as well as customers at current index). Extract at max 4 customers from waiting and update profit and rotate. If profit exceeds max profit update max rotations.\\n```\\nclass Solution {\\n    public int minOperationsMaxProfit(int[] customers, int boardingCost, int runningCost) {\\n        int profit = 0;\\n        int maxProfit = 0;\\n        int rotations = 0;\\n        int maxRotations = -1;\\n        int waiting = 0;\\n        int i = 0;\\n        while (i < customers.length || waiting > 0) {\\n\\t\\t\\t// We can choose customers from waiting pool as well as customers at current index\\n            if (i < customers.length) {\\n                waiting += customers[i++];\\n            }\\n\\t\\t\\t// Try accomodating as much customers (max possible is 4)\\n\\t\\t\\t// If more than 4 available then use 4 else use all of the waiting\\n            int count = (waiting >= 4) ? 4 : waiting;\\n            waiting -= count;\\n            profit += count * boardingCost - runningCost;\\n            rotations++;\\n            if (profit > maxProfit) {\\n                maxProfit = profit;\\n                maxRotations = rotations;\\n            }\\n        }\\n        return maxRotations;\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    public int minOperationsMaxProfit(int[] customers, int boardingCost, int runningCost) {\\n        int profit = 0;\\n        int maxProfit = 0;\\n        int rotations = 0;\\n        int maxRotations = -1;\\n        int waiting = 0;\\n        int i = 0;\\n        while (i < customers.length || waiting > 0) {\\n\\t\\t\\t// We can choose customers from waiting pool as well as customers at current index\\n            if (i < customers.length) {\\n                waiting += customers[i++];\\n            }\\n\\t\\t\\t// Try accomodating as much customers (max possible is 4)\\n\\t\\t\\t// If more than 4 available then use 4 else use all of the waiting\\n            int count = (waiting >= 4) ? 4 : waiting;\\n            waiting -= count;\\n            profit += count * boardingCost - runningCost;\\n            rotations++;\\n            if (profit > maxProfit) {\\n                maxProfit = profit;\\n                maxRotations = rotations;\\n            }\\n        }\\n        return maxRotations;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1371844,
                "title": "python-o-n-solution-faster-than-100",
                "content": "**First Observation:** If `boardingCost * 4 <= runningCost`, there is no way to make profit, so return `-1`  \\n  \\n**Second Observation**: Instead of looping with increment of 4 per cycle, if we can directly calculate number of rounds for the given number of *waiting* customers, we can save a lot of time.\\nLet\\'s say there are 18 customers, so number of rounds = `18//4 = 4`, so instead of looping 4 times we can directly update our *rotation count*. But what will be the *waiting count* now? Is it 2?\\n\\n**Third Observation**: Continuing with the above example, by the time we complete our 4 rounds, more customers might have come, so our *waiting count won\\'t be 2*.\\n\\n**Fourth Observation**: We can handle `customers[i : j]` at once using the above technique only iff, *waiting customers* till `j` is greater than minimum number of *waiting customers for index j*.\\nFor Example, `[6, 2, 1, 1, 8, 3]`\\nHere for index 0, `minimum waiting customers = 4` and `waiting customers = 6` , since `6 > 4`, so we can include\\n\\nFor index 1,  `minimum waiting customers = 4+4 = 8` and `waiting customers = 6+2 = 8` so we can include. Remember we are just looking upto which index we can handle at once, we haven\\'t handled them yet.\\n\\nFor index 2  `minimum waiting customers = 4+4+4 = 12` and `waiting customers = 6+2+1 = 9`, since `9 < 12` we will stop here and handle cases upto index 2, i.e, `[6 ,2, 1]`\\nWhich will be 2 rounds with 4 passengers each and 1 more round with 1 passenger.\\n\\nFor index 3, we will reset,  `minimum waiting customers = 4` and  `waiting customers = 1`, since `1 < 4`, we will handle it\\n\\nFor index 4, we will reset,  `minimum waiting customers = 4` and  `waiting customers = 8`, since `8 > 4`, we will include it\\n\\nFor index 5,  `minimum waiting customers = 4+4` and  `waiting customers = 8+3`, since `11 > 4`, we will include it\\n\\nSince customer list is over, we will now handle everything.\\n\\nMake sure to calculate **profit** whenever you handle customers and update accordingly.\\n\\n```python\\nclass Solution:\\n    def minOperationsMaxProfit(self, customers: List[int], boardingCost: int, runningCost: int) -> int:\\n\\t\\t# Our First obsevation\\n        if boardingCost*4 <= runningCost: return -1\\n        \\n        n = len(customers)\\n        count = 0              # To keep track of number of rounds\\n        max_count = 0          # To keep track of round where we had maximum profit\\n        profit = 0             # Profit till now\\n        max_profit = 0         # Maximum Profit till now\\n        i = 0                  # Index of customer list\\n        while i < n:\\n            wait = 0           # We will always start with 0 waiting customers\\n            min_wait = 0       # Minimum waiting count to include\\n\\t\\t\\t\\n\\t\\t\\t# Include all customers[i] until wait >= min_wait\\n            while i < n and wait >= min_wait:\\n                wait += customers[i]\\n                min_wait += 4\\n                i += 1\\n\\t\\t\\t\\t\\n\\t\\t\\t# Calcuate number of rounds and update count and profit\\n            rounds = wait//4\\n            count += rounds\\n            profit += rounds*(4*boardingCost - runningCost)\\n\\t\\t\\t\\n\\t\\t\\t# Update max_profit and max_count if required\\n            if profit > max_profit:\\n                max_profit = profit\\n                max_count = count\\n            \\n\\t\\t\\t# Update waiting customer count\\n            wait %= 4\\n\\t\\t\\t\\n\\t\\t\\t# If some passengers are still waiting, do one more round\\n            if wait > 0 or rounds == 0:\\n                count += 1\\n                profit += wait*boardingCost - runningCost\\n                wait = 0   # No more passengers are waiting,  for sure\\n\\t\\t\\t\\t# Update max_profit and max_count if required\\n                if profit > max_profit:\\n                    max_profit = profit\\n                    max_count = count \\n\\n\\t\\t# If max_count is still 0, then our wheel hasn\\'t moved at all\\n\\t\\t# Return -1 in this case, otherwise return max_count\\n        return max_count if max_count else -1\\n```\\n\\n**Submission details**: Runtime: 900 ms, faster than 100.00% of Python3 online submissions for Maximum Profit of Operating a Centennial Wheel.\\nMemory Usage: 17.8 MB, less than 29.09% of Python3 online submissions for Maximum Profit of Operating a Centennial Wheel.\\n\\nHope it helps you :)",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```python\\nclass Solution:\\n    def minOperationsMaxProfit(self, customers: List[int], boardingCost: int, runningCost: int) -> int:\\n\\t\\t# Our First obsevation\\n        if boardingCost*4 <= runningCost: return -1\\n        \\n        n = len(customers)\\n        count = 0              # To keep track of number of rounds\\n        max_count = 0          # To keep track of round where we had maximum profit\\n        profit = 0             # Profit till now\\n        max_profit = 0         # Maximum Profit till now\\n        i = 0                  # Index of customer list\\n        while i < n:\\n            wait = 0           # We will always start with 0 waiting customers\\n            min_wait = 0       # Minimum waiting count to include\\n\\t\\t\\t\\n\\t\\t\\t# Include all customers[i] until wait >= min_wait\\n            while i < n and wait >= min_wait:\\n                wait += customers[i]\\n                min_wait += 4\\n                i += 1\\n\\t\\t\\t\\t\\n\\t\\t\\t# Calcuate number of rounds and update count and profit\\n            rounds = wait//4\\n            count += rounds\\n            profit += rounds*(4*boardingCost - runningCost)\\n\\t\\t\\t\\n\\t\\t\\t# Update max_profit and max_count if required\\n            if profit > max_profit:\\n                max_profit = profit\\n                max_count = count\\n            \\n\\t\\t\\t# Update waiting customer count\\n            wait %= 4\\n\\t\\t\\t\\n\\t\\t\\t# If some passengers are still waiting, do one more round\\n            if wait > 0 or rounds == 0:\\n                count += 1\\n                profit += wait*boardingCost - runningCost\\n                wait = 0   # No more passengers are waiting,  for sure\\n\\t\\t\\t\\t# Update max_profit and max_count if required\\n                if profit > max_profit:\\n                    max_profit = profit\\n                    max_count = count \\n\\n\\t\\t# If max_count is still 0, then our wheel hasn\\'t moved at all\\n\\t\\t# Return -1 in this case, otherwise return max_count\\n        return max_count if max_count else -1\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3124803,
                "title": "c-99ms-solution-explained",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nMy intuition for solving this problem is to use a greedy approach\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\nI will use a greedy approach to solve this problem. I will iterate through the customers array and for each iteration, I will calculate the maximum number of customers boarded, calculate the profit, and compare it with the current maximum profit. If the calculated profit is higher, I will update the maximum profit and the number of rotations.\\n# Complexity\\n- Time complexity: $$O(n)$$\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\nwhere n is the length of the customers array.\\n- Space complexity: $$O(1)$$\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\n#pragma GCC optimize(\"Ofast\",\"inline\",\"fast-math\",\"unroll-loops\",\"no-stack-protector\")\\n#pragma GCC target(\"sse,sse2,sse3,ssse3,sse4,popcnt,abm,mmx,avx,avx2,tune=native\",\"f16c\")\\nstatic const auto fast = []() {ios_base::sync_with_stdio(false); cin.tie(0); cout.tie(0); return 0; } ();class Solution {\\npublic:\\n    int minOperationsMaxProfit(vector<int>& customers, int boardingCost, int runningCost) {\\n        int n = customers.size();\\n        int maxRotations = 0;\\n        int profit = 0;\\n        int rotations = 0;\\n        int waiting = 0;\\n        int maxProfit = 0;\\n        for (int i = 0; i < n || waiting > 0; ++i) {\\n            if (i < n) waiting += customers[i];\\n            profit += boarding(waiting, boardingCost, runningCost);\\n            ++rotations;\\n            if (profit > maxProfit) {\\n                maxProfit = profit;\\n                maxRotations = rotations;\\n            }\\n        }\\n        return maxProfit > 0 ? maxRotations : -1;\\n    }\\n    \\n    int boarding(int& waiting, int boardingCost, int runningCost) {\\n        int board = min(waiting, 4);\\n        waiting -= board;\\n        return board * boardingCost - runningCost;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Array",
                    "Simulation"
                ],
                "code": "```\\n#pragma GCC optimize(\"Ofast\",\"inline\",\"fast-math\",\"unroll-loops\",\"no-stack-protector\")\\n#pragma GCC target(\"sse,sse2,sse3,ssse3,sse4,popcnt,abm,mmx,avx,avx2,tune=native\",\"f16c\")\\nstatic const auto fast = []() {ios_base::sync_with_stdio(false); cin.tie(0); cout.tie(0); return 0; } ();class Solution {\\npublic:\\n    int minOperationsMaxProfit(vector<int>& customers, int boardingCost, int runningCost) {\\n        int n = customers.size();\\n        int maxRotations = 0;\\n        int profit = 0;\\n        int rotations = 0;\\n        int waiting = 0;\\n        int maxProfit = 0;\\n        for (int i = 0; i < n || waiting > 0; ++i) {\\n            if (i < n) waiting += customers[i];\\n            profit += boarding(waiting, boardingCost, runningCost);\\n            ++rotations;\\n            if (profit > maxProfit) {\\n                maxProfit = profit;\\n                maxRotations = rotations;\\n            }\\n        }\\n        return maxProfit > 0 ? maxRotations : -1;\\n    }\\n    \\n    int boarding(int& waiting, int boardingCost, int runningCost) {\\n        int board = min(waiting, 4);\\n        waiting -= board;\\n        return board * boardingCost - runningCost;\\n    }\\n};\\n```",
                "codeTag": "C++"
            },
            {
                "id": 1358305,
                "title": "java-solution-basic-calculation",
                "content": "```\\nclass Solution {\\n    public int minOperationsMaxProfit(int[] customers, int boardingCost, int runningCost) {\\n        \\n        int len = customers.length;\\n        int waiting = 0;\\n        \\n        int idx = 0;\\n        int max = 0;\\n        int rotation = -1;\\n        int cost = 0;\\n        while(idx < len || waiting > 0)\\n        {\\n            int val = idx < len ? customers[idx] : 0 ;\\n            if(idx < len && customers[idx] > 4)\\n            {\\n                waiting += (val - 4);\\n                val = 4;\\n            }\\n            \\n            if( val < 4 && waiting > 0)\\n            {\\n                int free = 4 - val;\\n                val += waiting >= free ? free : waiting;\\n                waiting = waiting >= free ? waiting - free : 0;\\n            }\\n            \\n            cost = cost +  ((boardingCost * val) - runningCost);\\n            \\n            if(max < cost)\\n            {\\n                max = cost;\\n                rotation = idx+ 1;\\n            }\\n            idx++;\\n        }        \\n        return rotation;\\n    }\\n}",
                "solutionTags": [],
                "code": "class Solution {\\n    public int minOperationsMaxProfit(int[] customers, int boardingCost, int runningCost) {\\n        \\n        int len = customers.length;\\n        int waiting = 0;\\n        \\n        int idx = 0;\\n        int max = 0;\\n        int rotation = -1;\\n        int cost = 0;\\n        while(idx < len || waiting > 0)\\n        {\\n            int val = idx < len ? customers[idx] : 0 ;\\n            if(idx < len && customers[idx] > 4)\\n            {\\n                waiting += (val - 4);\\n                val = 4;\\n            }",
                "codeTag": "Java"
            },
            {
                "id": 1088901,
                "title": "c-greedy",
                "content": "```\\nclass Solution {\\npublic:\\n    int minOperationsMaxProfit(vector<int>& customers, int boardingCost, int runningCost) {\\n        int x = runningCost / boardingCost;\\n        if(x >= 4) return -1;\\n        \\n        int wait = 0, profit = 0, maxProfit = INT_MIN, ans = -1;\\n        int r = 0;\\n        while(true) {\\n            if(r < customers.size()) wait += customers[r];\\n            int board = min(wait, 4); // Board as many people as possible.\\n            wait -= board;\\n            \\n            profit += board * boardingCost - runningCost;\\n            \\n            if(profit > 0 && profit > maxProfit) {\\n                ans = r+1;\\n                maxProfit = profit;\\n            }\\n            \\n            if(r >= customers.size() && wait == 0) break;\\n            r++;\\n        }\\n        \\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    int minOperationsMaxProfit(vector<int>& customers, int boardingCost, int runningCost) {\\n        int x = runningCost / boardingCost;\\n        if(x >= 4) return -1;\\n        \\n        int wait = 0, profit = 0, maxProfit = INT_MIN, ans = -1;\\n        int r = 0;\\n        while(true) {\\n            if(r < customers.size()) wait += customers[r];\\n            int board = min(wait, 4); // Board as many people as possible.\\n            wait -= board;\\n            \\n            profit += board * boardingCost - runningCost;\\n            \\n            if(profit > 0 && profit > maxProfit) {\\n                ans = r+1;\\n                maxProfit = profit;\\n            }\\n            \\n            if(r >= customers.size() && wait == 0) break;\\n            r++;\\n        }\\n        \\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 896189,
                "title": "c-simple-approach-as-mentioned-in-the-question",
                "content": "```\\nclass Solution {\\npublic:\\n    int minOperationsMaxProfit(vector<int>& customers, int boardingCost, int runningCost) {\\n        int sum=0,profit=0,count=0,gondola=0;\\n        vector<int> p;\\n        p.push_back(-1);\\n        for(int i=0;i<customers.size();i++)\\n        {\\n            if(customers[i]<=4){gondola+=customers[i];\\n                                customers[i]=0;}\\n            else {\\n                gondola+=4;\\n                customers[i]-=4;\\n                if(i<customers.size()-1)customers[i+1]+=customers[i];\\n            }\\n            count++;\\n            profit=gondola*boardingCost - count*runningCost;\\n            p.push_back(profit);\\n            if(i==customers.size() && customers[i]==0)break;\\n            if(i==customers.size()-1)\\n            {\\n                while(customers[i]>0)\\n                {\\n                    if(customers[i]<=4){\\n                        gondola+=customers[i];\\n                        customers[i]=0;\\n                    }\\n                    else{\\n                    gondola+=4;\\n                    customers[i]-=4;}\\n                    count++;\\n                     profit=gondola*boardingCost - count*runningCost;\\n                    p.push_back(profit);\\n                }\\n            }\\n        }\\n        int maxim=INT_MIN,ans;\\n       if(p.back()<=0)return -1;\\n        else {\\n           for(int j=1;j<p.size();j++) {\\n               if(p[j]>maxim)ans=j;\\n               maxim=max(maxim,p[j]);\\n           }\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    int minOperationsMaxProfit(vector<int>& customers, int boardingCost, int runningCost) {\\n        int sum=0,profit=0,count=0,gondola=0;\\n        vector<int> p;\\n        p.push_back(-1);\\n        for(int i=0;i<customers.size();i++)\\n        {\\n            if(customers[i]<=4){gondola+=customers[i];\\n                                customers[i]=0;}\\n            else {\\n                gondola+=4;\\n                customers[i]-=4;\\n                if(i<customers.size()-1)customers[i+1]+=customers[i];\\n            }\\n            count++;\\n            profit=gondola*boardingCost - count*runningCost;\\n            p.push_back(profit);\\n            if(i==customers.size() && customers[i]==0)break;\\n            if(i==customers.size()-1)\\n            {\\n                while(customers[i]>0)\\n                {\\n                    if(customers[i]<=4){\\n                        gondola+=customers[i];\\n                        customers[i]=0;\\n                    }\\n                    else{\\n                    gondola+=4;\\n                    customers[i]-=4;}\\n                    count++;\\n                     profit=gondola*boardingCost - count*runningCost;\\n                    p.push_back(profit);\\n                }\\n            }\\n        }\\n        int maxim=INT_MIN,ans;\\n       if(p.back()<=0)return -1;\\n        else {\\n           for(int j=1;j<p.size();j++) {\\n               if(p[j]>maxim)ans=j;\\n               maxim=max(maxim,p[j]);\\n           }\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 874943,
                "title": "c-straightforward-simulation-greedy-approach",
                "content": "```\\nclass Solution {\\npublic:\\n    int minOperationsMaxProfit(vector<int>& customers, int boarding_cost, int running_cost) {\\n        int maximum_profit = 0, maximum_profit_run = -1, boarded = 0, waiting = 0;\\n        for (auto i = 0; i < customers.size() || waiting > 0; i++) {\\n            if (i < customers.size()) {\\n                // Add customers arriving just before ith rotation to waiting customers.\\n                waiting += customers[i];\\n            }\\n            \\n            // Update total boarded customers. At most 4 customers can board, but if there are less than 4 customers waiting, then only those will board.\\n            boarded += min(4, waiting);\\n            \\n            // Reduce the number of waiting customers.\\n            waiting = max(0, waiting - 4);\\n            \\n            // Compute the profit after current rotation.\\n            auto current_profit = (boarded * boarding_cost) - ((i + 1) * running_cost);\\n            if (maximum_profit < current_profit) {\\n                maximum_profit = current_profit;\\n                maximum_profit_run = i + 1;\\n            }\\n        }\\n        \\n        // If maximum profit possible is not positive, return -1. Otherwise return the rotation after which profit is maximum.\\n        return maximum_profit > 0 ? maximum_profit_run : -1;\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    int minOperationsMaxProfit(vector<int>& customers, int boarding_cost, int running_cost) {\\n        int maximum_profit = 0, maximum_profit_run = -1, boarded = 0, waiting = 0;\\n        for (auto i = 0; i < customers.size() || waiting > 0; i++) {\\n            if (i < customers.size()) {\\n                // Add customers arriving just before ith rotation to waiting customers.\\n                waiting += customers[i];\\n            }\\n            \\n            // Update total boarded customers. At most 4 customers can board, but if there are less than 4 customers waiting, then only those will board.\\n            boarded += min(4, waiting);\\n            \\n            // Reduce the number of waiting customers.\\n            waiting = max(0, waiting - 4);\\n            \\n            // Compute the profit after current rotation.\\n            auto current_profit = (boarded * boarding_cost) - ((i + 1) * running_cost);\\n            if (maximum_profit < current_profit) {\\n                maximum_profit = current_profit;\\n                maximum_profit_run = i + 1;\\n            }\\n        }\\n        \\n        // If maximum profit possible is not positive, return -1. Otherwise return the rotation after which profit is maximum.\\n        return maximum_profit > 0 ? maximum_profit_run : -1;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 869288,
                "title": "python3-simple-simulation-o-n-940ms-100",
                "content": "```\\nclass Solution:\\n    def minOperationsMaxProfit(self, customers: List[int], boardingCost: int, runningCost: int) -> int:\\n        wait = 0\\n        pro = 0\\n        high = 0\\n        res = -1\\n        for i in range(len(customers)):\\n            vacc = 4 - wait\\n            if vacc <= 0:\\n                wait += customers[i] - 4\\n                pro += 4 * boardingCost - runningCost\\n            # board all\\n            elif customers[i] <= vacc: # board=customers[i]+wait\\n                pro += boardingCost * (customers[i] + wait) - runningCost\\n                wait = 0\\n            else:\\n                pro += boardingCost * 4 - runningCost\\n                wait += customers[i] - 4\\n            if pro > high:\\n                high = pro\\n                res = i\\n        # determine after all arrives\\n        pro_per = boardingCost * 4 - runningCost\\n        if pro_per > 0:\\n            last = wait % 4\\n            if wait >= 4:\\n                if boardingCost * last - runningCost > 0: return len(customers) + wait // 4 + 1\\n                else: return len(customers) + wait // 4\\n            if boardingCost * last - runningCost > 0: return len(customers) + 1\\n        return res + 1 if res >= 0 else -1\\n```\\nTwo parts: when customers incoming; after all customers arrived.\\nFor the first part, simple simulation.\\nFor the second part, determine whether profit per round with 4 or fewer (at the very last round) is positive.",
                "solutionTags": [],
                "code": "```\\nclass Solution:\\n    def minOperationsMaxProfit(self, customers: List[int], boardingCost: int, runningCost: int) -> int:\\n        wait = 0\\n        pro = 0\\n        high = 0\\n        res = -1\\n        for i in range(len(customers)):\\n            vacc = 4 - wait\\n            if vacc <= 0:\\n                wait += customers[i] - 4\\n                pro += 4 * boardingCost - runningCost\\n            # board all\\n            elif customers[i] <= vacc: # board=customers[i]+wait\\n                pro += boardingCost * (customers[i] + wait) - runningCost\\n                wait = 0\\n            else:\\n                pro += boardingCost * 4 - runningCost\\n                wait += customers[i] - 4\\n            if pro > high:\\n                high = pro\\n                res = i\\n        # determine after all arrives\\n        pro_per = boardingCost * 4 - runningCost\\n        if pro_per > 0:\\n            last = wait % 4\\n            if wait >= 4:\\n                if boardingCost * last - runningCost > 0: return len(customers) + wait // 4 + 1\\n                else: return len(customers) + wait // 4\\n            if boardingCost * last - runningCost > 0: return len(customers) + 1\\n        return res + 1 if res >= 0 else -1\\n```",
                "codeTag": "Java"
            },
            {
                "id": 867960,
                "title": "java-beats-100-time-and-space",
                "content": "```\\nclass Solution {\\n    public int minOperationsMaxProfit(int[] customers, int boardingCost, int runningCost) {\\n        int profit = 0, peeps = 0, max = 0, maxRotations = -1, iterations = 0;\\n        while (peeps > 0 || iterations < customers.length){\\n            if (iterations < customers.length){\\n                peeps += customers[iterations];\\n            }\\n            int customersToBoard = Math.min(peeps, 4);\\n            profit += customersToBoard * boardingCost - runningCost;\\n            peeps -= customersToBoard;\\n            \\n            iterations++;\\n            if (max < profit){\\n                max = profit;\\n                maxRotations = iterations;\\n            }\\n        }\\n        return maxRotations;\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    public int minOperationsMaxProfit(int[] customers, int boardingCost, int runningCost) {\\n        int profit = 0, peeps = 0, max = 0, maxRotations = -1, iterations = 0;\\n        while (peeps > 0 || iterations < customers.length){\\n            if (iterations < customers.length){\\n                peeps += customers[iterations];\\n            }\\n            int customersToBoard = Math.min(peeps, 4);\\n            profit += customersToBoard * boardingCost - runningCost;\\n            peeps -= customersToBoard;\\n            \\n            iterations++;\\n            if (max < profit){\\n                max = profit;\\n                maxRotations = iterations;\\n            }\\n        }\\n        return maxRotations;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 867766,
                "title": "simple-java-greedy-solution-with-description-9ms-single-loop",
                "content": "Till no more new customers are coming we must compute profit (no of waiting customers = 0 and no new customers are coming).\\nStore maxProfit and it\\'s corresponding shift no. Return the shift no corresponding to the maximum profit.\\n```\\nclass Solution {\\n    public int minOperationsMaxProfit(int[] customers, int boardingCost, int runningCost) {\\n        int noWaiting = 0;\\n        int maxProfit = -1;\\n        int profit = -1;\\n        int shifts = 0;\\n        int i = 0;\\n        int maxShifts = -1;\\n        do {\\n            \\n            if(i < customers.length) {\\n                noWaiting += customers[i];\\n                i++;\\n            }\\n            if(noWaiting > 4) {\\n                noWaiting -= 4;\\n                profit += 4 * boardingCost - runningCost;\\n            }\\n            else {\\n                profit += noWaiting * boardingCost - runningCost;\\n                noWaiting = 0;\\n            }\\n            shifts++;\\n            if(profit > maxProfit) {\\n                maxShifts = shifts;\\n                maxProfit = profit;\\n            }\\n        } while(noWaiting > 0 || i < customers.length);\\n        return maxShifts;\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    public int minOperationsMaxProfit(int[] customers, int boardingCost, int runningCost) {\\n        int noWaiting = 0;\\n        int maxProfit = -1;\\n        int profit = -1;\\n        int shifts = 0;\\n        int i = 0;\\n        int maxShifts = -1;\\n        do {\\n            \\n            if(i < customers.length) {\\n                noWaiting += customers[i];\\n                i++;\\n            }\\n            if(noWaiting > 4) {\\n                noWaiting -= 4;\\n                profit += 4 * boardingCost - runningCost;\\n            }\\n            else {\\n                profit += noWaiting * boardingCost - runningCost;\\n                noWaiting = 0;\\n            }\\n            shifts++;\\n            if(profit > maxProfit) {\\n                maxShifts = shifts;\\n                maxProfit = profit;\\n            }\\n        } while(noWaiting > 0 || i < customers.length);\\n        return maxShifts;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 867139,
                "title": "java-100-faster",
                "content": "```\\n public static int minOperationsMaxProfit(int[] customers, int boardingCost, int runningCost) {\\n\\n        int maxProfit = -1;\\n        int maxRounds = 0;\\n        int currentProfit = 0;\\n        int currentround = 0;\\n        int prev = 0;\\n        for (int x: customers)\\n        {\\n            if (prev + x <=4)\\n            {\\n                currentProfit += (prev + x) * boardingCost - runningCost;\\n                prev = 0;\\n            }\\n            else {\\n                currentProfit += 4*boardingCost - runningCost;\\n                prev = prev + x - 4;\\n            }\\n            currentround++;\\n            if (maxProfit < currentProfit)\\n            {\\n                maxProfit = currentProfit;\\n                maxRounds = currentround;\\n            }\\n        }\\n\\n        while (prev != 0)\\n        {\\n            if (prev <= 4)\\n            {\\n                currentProfit += prev*boardingCost - runningCost;\\n                prev = 0;\\n            }else\\n            {\\n                currentProfit += 4*boardingCost - runningCost;\\n                prev = prev -4;\\n            }\\n            currentround++;\\n            if (maxProfit < currentProfit)\\n            {\\n                maxProfit = currentProfit;\\n                maxRounds = currentround;\\n            }\\n        }\\n\\n      return maxProfit > 0 ? maxRounds : -1;\\n    }",
                "solutionTags": [],
                "code": "```\\n public static int minOperationsMaxProfit(int[] customers, int boardingCost, int runningCost) {\\n\\n        int maxProfit = -1;\\n        int maxRounds = 0;\\n        int currentProfit = 0;\\n        int currentround = 0;\\n        int prev = 0;\\n        for (int x: customers)\\n        {\\n            if (prev + x <=4)\\n            {\\n                currentProfit += (prev + x) * boardingCost - runningCost;\\n                prev = 0;\\n            }\\n            else {\\n                currentProfit += 4*boardingCost - runningCost;\\n                prev = prev + x - 4;\\n            }\\n            currentround++;\\n            if (maxProfit < currentProfit)\\n            {\\n                maxProfit = currentProfit;\\n                maxRounds = currentround;\\n            }\\n        }\\n\\n        while (prev != 0)\\n        {\\n            if (prev <= 4)\\n            {\\n                currentProfit += prev*boardingCost - runningCost;\\n                prev = 0;\\n            }else\\n            {\\n                currentProfit += 4*boardingCost - runningCost;\\n                prev = prev -4;\\n            }\\n            currentround++;\\n            if (maxProfit < currentProfit)\\n            {\\n                maxProfit = currentProfit;\\n                maxRounds = currentround;\\n            }\\n        }\\n\\n      return maxProfit > 0 ? maxRounds : -1;\\n    }",
                "codeTag": "Unknown"
            },
            {
                "id": 866440,
                "title": "c-o-n",
                "content": "Runtime: 288 ms\\nMemory Usage: 45.6 MB\\n```\\n    public int MinOperationsMaxProfit(int[] customers, int boardingCost, int runningCost) {\\n        \\n        int waiting = 0;\\n        int maxProfit = -1;\\n        int profit = 0;\\n        int rotations = 0;\\n        int result = 0;\\n        int p;\\n        \\n            \\n        for(int i=0; i< customers.Length; i++)\\n        {\\n            waiting += customers[i];\\n            p = (waiting > 4)? 4 : waiting % 4;\\n            waiting -=p;\\n            \\n            profit += p * boardingCost - runningCost;\\n            rotations++;\\n            \\n            if (profit > maxProfit) { maxProfit =  profit; result = rotations; }\\n        }\\n        \\n        if (waiting > 0)\\n        {\\n            int rem = waiting % 4;\\n            int div = waiting / 4;\\n            \\n            if (div > 0)\\n            {\\n                profit += div * (4 * boardingCost - runningCost);\\n                rotations += div; \\n                \\n                if (profit > maxProfit) { maxProfit =  profit; result = rotations; }\\n            }\\n            \\n            if (rem > 0)\\n            {\\n                profit += rem * boardingCost - runningCost;\\n                rotations++; \\n                \\n                if (profit > maxProfit) { maxProfit =  profit; result = rotations; }\\n            }            \\n        }\\n\\n        \\n        return (maxProfit == -1)? -1 : result;\\n    }",
                "solutionTags": [],
                "code": "Runtime: 288 ms\\nMemory Usage: 45.6 MB\\n```\\n    public int MinOperationsMaxProfit(int[] customers, int boardingCost, int runningCost) {\\n        \\n        int waiting = 0;\\n        int maxProfit = -1;\\n        int profit = 0;\\n        int rotations = 0;\\n        int result = 0;\\n        int p;\\n        \\n            \\n        for(int i=0; i< customers.Length; i++)\\n        {\\n            waiting += customers[i];\\n            p = (waiting > 4)? 4 : waiting % 4;\\n            waiting -=p;\\n            \\n            profit += p * boardingCost - runningCost;\\n            rotations++;\\n            \\n            if (profit > maxProfit) { maxProfit =  profit; result = rotations; }\\n        }\\n        \\n        if (waiting > 0)\\n        {\\n            int rem = waiting % 4;\\n            int div = waiting / 4;\\n            \\n            if (div > 0)\\n            {\\n                profit += div * (4 * boardingCost - runningCost);\\n                rotations += div; \\n                \\n                if (profit > maxProfit) { maxProfit =  profit; result = rotations; }\\n            }\\n            \\n            if (rem > 0)\\n            {\\n                profit += rem * boardingCost - runningCost;\\n                rotations++; \\n                \\n                if (profit > maxProfit) { maxProfit =  profit; result = rotations; }\\n            }            \\n        }\\n\\n        \\n        return (maxProfit == -1)? -1 : result;\\n    }",
                "codeTag": "Unknown"
            },
            {
                "id": 866413,
                "title": "c-o-1-space-o-n-time-simple-solution-just-go-through-line-by-line-explanation-added",
                "content": "Intuition:We just want to maximize profit and we want to return minimum number of rounds we need to maximize that profit.\\nSo, There is nothing to worry about this line in problem statement \\'You can stop the wheel at any time, including before serving all customers. If you decide to stop serving customers, all subsequent rotations are free in order to get all the customers down safely. Note that if there are currently more than four customers waiting at the wheel, only four will board the gondola, and the rest will wait for the next rotation.\\'\\nAlgorithm:\\n1.first update total customers in rem variable as remaining+=custumer[i]\\n2.At each step updating total available customers for ride as available+=min(4,remaining),  each step we cannot take more than 4 customers to  our ride so  we use min(4,remaining);\\n3.Subtract the number of customers from total remaining customers.\\n4.Update result.\\n\\n```\\nclass Solution {\\npublic:\\n    int minOperationsMaxProfit(vector<int>& a, int board, int run) {\\n        int n=a.size(),ans=INT_MIN;\\n        int cnt=1; \\n        long long res; //res will keep track of profit at each step;\\n        long long rem=0,tp,h=4; \\n        int ava=0,sub;\\n        for(int i=0;i<n;i++)\\n        {\\n            rem+=a[i]; //rem will keep track of total remaining customers at each step\\n            ava+=min(h,rem); //updating ava ,we cannot add more than 4 customers to our ride;\\n            sub=min(h,rem);  //sub will take care of how many customers we have to subtract from remaining customers.\\n            rem-=sub; //reducing number of remaining customers\\n            res=(ava*board)-(cnt*run); //calculating result.\\n            if(res>ans)\\n            {\\n                ans=res;\\n                tp=cnt; // tp variable will keep track of our required number of rounds for maximum profit.\\n            }\\n            cnt++; //cnt will keep track of number of rounds.\\n        }\\n       while(rem>0) //taking care of remaining customers if any \\n        {\\n           if(rem<=0) break;\\n            ava+=min(h,rem);\\n            sub=min(h,rem);\\n            rem-=sub;\\n            res=(ava*board)-(cnt*run);\\n            if(res>ans)\\n            {\\n                ans=res;\\n                tp=cnt;\\n            }\\n            cnt++;\\n        }\\n        if(ans<=0) return -1;\\n        else return tp;\\n    }\\n};\\n```\\nHope it helps:)",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    int minOperationsMaxProfit(vector<int>& a, int board, int run) {\\n        int n=a.size(),ans=INT_MIN;\\n        int cnt=1; \\n        long long res; //res will keep track of profit at each step;\\n        long long rem=0,tp,h=4; \\n        int ava=0,sub;\\n        for(int i=0;i<n;i++)\\n        {\\n            rem+=a[i]; //rem will keep track of total remaining customers at each step\\n            ava+=min(h,rem); //updating ava ,we cannot add more than 4 customers to our ride;\\n            sub=min(h,rem);  //sub will take care of how many customers we have to subtract from remaining customers.\\n            rem-=sub; //reducing number of remaining customers\\n            res=(ava*board)-(cnt*run); //calculating result.\\n            if(res>ans)\\n            {\\n                ans=res;\\n                tp=cnt; // tp variable will keep track of our required number of rounds for maximum profit.\\n            }\\n            cnt++; //cnt will keep track of number of rounds.\\n        }\\n       while(rem>0) //taking care of remaining customers if any \\n        {\\n           if(rem<=0) break;\\n            ava+=min(h,rem);\\n            sub=min(h,rem);\\n            rem-=sub;\\n            res=(ava*board)-(cnt*run);\\n            if(res>ans)\\n            {\\n                ans=res;\\n                tp=cnt;\\n            }\\n            cnt++;\\n        }\\n        if(ans<=0) return -1;\\n        else return tp;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 4016368,
                "title": "easy-java-solution-simulation",
                "content": "\\n# Complexity\\n- Time complexity:\\nO(totalCustomers/4);\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\n    public int minOperationsMaxProfit(int[] customers, int boardingCost, int runningCost) {\\n        int rotatn = 0;\\n        int cust = 0;\\n        int profit = Integer.MIN_VALUE;\\n        int prRotn = 0;\\n        int cSit = 0;\\n\\n        for(int i = 0 ; i < customers.length ; i++){\\n            cust += customers[i];\\n            rotatn++;\\n\\n            int prof = 0;\\n            if(cust >= 4){\\n                \\n                cust = cust - 4;\\n                cSit += 4;\\n            }else{\\n                cSit += cust;\\n                cust = 0;\\n            }\\n            prof = cSit*boardingCost - rotatn*runningCost ;\\n            if(prof > profit){\\n                profit = prof;\\n                prRotn = rotatn;\\n            }  \\n        }\\n        while(cust > 0){\\n            rotatn++;\\n\\n            int prof = 0;\\n            if(cust >= 4){\\n                cust = cust - 4;\\n                cSit += 4;\\n            }else{\\n                cSit += cust;\\n                cust = 0;\\n            }\\n            prof = cSit*boardingCost - rotatn*runningCost ;\\n\\n            if(prof > profit){\\n                profit = prof;\\n\\n                prRotn = rotatn;\\n            } \\n        }\\n        if(profit > 0) return prRotn;\\n        return -1;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Array",
                    "Simulation"
                ],
                "code": "```\\nclass Solution {\\n    public int minOperationsMaxProfit(int[] customers, int boardingCost, int runningCost) {\\n        int rotatn = 0;\\n        int cust = 0;\\n        int profit = Integer.MIN_VALUE;\\n        int prRotn = 0;\\n        int cSit = 0;\\n\\n        for(int i = 0 ; i < customers.length ; i++){\\n            cust += customers[i];\\n            rotatn++;\\n\\n            int prof = 0;\\n            if(cust >= 4){\\n                \\n                cust = cust - 4;\\n                cSit += 4;\\n            }else{\\n                cSit += cust;\\n                cust = 0;\\n            }\\n            prof = cSit*boardingCost - rotatn*runningCost ;\\n            if(prof > profit){\\n                profit = prof;\\n                prRotn = rotatn;\\n            }  \\n        }\\n        while(cust > 0){\\n            rotatn++;\\n\\n            int prof = 0;\\n            if(cust >= 4){\\n                cust = cust - 4;\\n                cSit += 4;\\n            }else{\\n                cSit += cust;\\n                cust = 0;\\n            }\\n            prof = cSit*boardingCost - rotatn*runningCost ;\\n\\n            if(prof > profit){\\n                profit = prof;\\n\\n                prRotn = rotatn;\\n            } \\n        }\\n        if(profit > 0) return prRotn;\\n        return -1;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 4012141,
                "title": "easy-to-understand-javascript-solution",
                "content": "# Complexity\\n- Time complexity:\\n$$O(n)$$\\n\\n- Space complexity:\\n$$O(1)$$\\n\\n# Code\\n```\\nvar minOperationsMaxProfit = function(customers, boardingCost, runningCost) {\\n    const result = { rotate: -1, profit: 0 };\\n    let wait = profit = rotate = 0;\\n\\n    for (const customer of customers) {\\n        wait += customer;\\n        runningWheel();\\n    }\\n    while (wait > 0) runningWheel();\\n\\n    return result.rotate;\\n\\n    function runningWheel() {\\n        rotate += 1;\\n        profit += wait >= 4\\n            ? 4 * boardingCost - runningCost\\n            : wait * boardingCost - runningCost;\\n\\n        wait = Math.max(wait - 4, 0);\\n        if (profit < 0 || result.profit >= profit) return;\\n        result.rotate = rotate;\\n        result.profit = profit;\\n    }\\n};\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\nvar minOperationsMaxProfit = function(customers, boardingCost, runningCost) {\\n    const result = { rotate: -1, profit: 0 };\\n    let wait = profit = rotate = 0;\\n\\n    for (const customer of customers) {\\n        wait += customer;\\n        runningWheel();\\n    }\\n    while (wait > 0) runningWheel();\\n\\n    return result.rotate;\\n\\n    function runningWheel() {\\n        rotate += 1;\\n        profit += wait >= 4\\n            ? 4 * boardingCost - runningCost\\n            : wait * boardingCost - runningCost;\\n\\n        wait = Math.max(wait - 4, 0);\\n        if (profit < 0 || result.profit >= profit) return;\\n        result.rotate = rotate;\\n        result.profit = profit;\\n    }\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3992743,
                "title": "javascript-1599-maximum-profit-of-operating-a-centennial-wheel",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\nDo as problem suggests\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n\\n```\\nvar minOperationsMaxProfit = function (customers, boardingCost, runningCost) {\\n  const n = customers.length\\n  let maxRotations = 0\\n  let waitingCustomers = 0\\n  let currentProfit = 0\\n  let maxProfit = 0\\n\\n  for (let rotation = 1; rotation <= n || waitingCustomers > 0; rotation++) {\\n    if (rotation <= n) {\\n      waitingCustomers += customers[rotation - 1]\\n    }\\n    const boardedRiders = Math.min(waitingCustomers, 4)\\n    waitingCustomers -= boardedRiders\\n    currentProfit += boardedRiders * boardingCost - runningCost\\n\\n    if (currentProfit > maxProfit) {\\n      maxProfit = currentProfit\\n      maxRotations = rotation\\n    }\\n  }\\n\\n  return maxRotations || -1\\n}\\n```\\n",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\nvar minOperationsMaxProfit = function (customers, boardingCost, runningCost) {\\n  const n = customers.length\\n  let maxRotations = 0\\n  let waitingCustomers = 0\\n  let currentProfit = 0\\n  let maxProfit = 0\\n\\n  for (let rotation = 1; rotation <= n || waitingCustomers > 0; rotation++) {\\n    if (rotation <= n) {\\n      waitingCustomers += customers[rotation - 1]\\n    }\\n    const boardedRiders = Math.min(waitingCustomers, 4)\\n    waitingCustomers -= boardedRiders\\n    currentProfit += boardedRiders * boardingCost - runningCost\\n\\n    if (currentProfit > maxProfit) {\\n      maxProfit = currentProfit\\n      maxRotations = rotation\\n    }\\n  }\\n\\n  return maxRotations || -1\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3968662,
                "title": "c-solution",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\n public:\\n  int minOperationsMaxProfit(vector<int>& customers, int boardingCost,\\n                             int runningCost) {\\n    int waiting = 0;\\n    int profit = 0;\\n    int maxProfit = 0;\\n    int rotate = 0;\\n    int maxRotate = -1;\\n    int i = 0;\\n\\n    while (waiting > 0 || i < customers.size()) {\\n      if (i < customers.size())\\n        waiting += customers[i++];\\n      // Onboard new customers\\n      const int newOnboard = min(waiting, 4);\\n      waiting -= newOnboard;\\n      profit += newOnboard * boardingCost - runningCost;\\n      ++rotate;\\n      if (profit > maxProfit) {\\n        maxProfit = profit;\\n        maxRotate = rotate;\\n      }\\n    }\\n\\n    return maxRotate;\\n  }\\n};\\n\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\n public:\\n  int minOperationsMaxProfit(vector<int>& customers, int boardingCost,\\n                             int runningCost) {\\n    int waiting = 0;\\n    int profit = 0;\\n    int maxProfit = 0;\\n    int rotate = 0;\\n    int maxRotate = -1;\\n    int i = 0;\\n\\n    while (waiting > 0 || i < customers.size()) {\\n      if (i < customers.size())\\n        waiting += customers[i++];\\n      // Onboard new customers\\n      const int newOnboard = min(waiting, 4);\\n      waiting -= newOnboard;\\n      profit += newOnboard * boardingCost - runningCost;\\n      ++rotate;\\n      if (profit > maxProfit) {\\n        maxProfit = profit;\\n        maxRotate = rotate;\\n      }\\n    }\\n\\n    return maxRotate;\\n  }\\n};\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3852855,
                "title": "c-faster-than-100ms-clean-explanation-nice-variable-naming",
                "content": "# Code\\n```\\nclass Solution {\\npublic:\\n    int minOperationsMaxProfit(vector<int>& customers, int boardingCost, int runningCost) {\\n        // Intution\\n        // The idea in here is really very simple. We will maintain the variable to keep track of baorded customers and also we will keep the number of rotations made till now. At any instance we can stop the gondola so we will at every position check if the profit is maximum or not. If the profit at the index is max then we will change the current index to the number which we obtained now. We need to keep track of waiting number of customers and every time we will board a minimum of waiting and the board and the current profit earned will be the number of persons enjoyed the rotation and the number of times wheel was rotated for running the gondon.\\n\\n        \\n        // This is used to store max profit earned till now\\n\\n        int profit = INT_MIN;\\n\\n        // This is used to store the optimal number of moves\\n\\n        int optimal = -1;\\n\\n        // Variable to store number of waiting customers\\n\\n        int waiting = 0;\\n\\n        // Variable to stores number of rotations made\\n        int number = 1;\\n\\n        // Vairable to store boarded number of customers\\n        int boarded = 0;\\n\\n        // Looping and checking if at the current turn we can obtain max answer\\n        for(auto &cust : customers){\\n            waiting += cust;\\n            boarded += min(4, waiting);\\n            int currProfit = boarded * boardingCost - number * runningCost;\\n            if(currProfit > profit){\\n                profit = currProfit;\\n                optimal = number;\\n            }\\n            waiting -= min(4, waiting);\\n            number += 1;\\n        }\\n\\n        // Also, checking for the waiting customers\\n\\n        while(waiting > 0){\\n            boarded += min(4, waiting);\\n            int currProfit = boarded * boardingCost - number * runningCost;\\n            if(currProfit > profit){\\n                profit = currProfit;\\n                optimal = number;\\n            }\\n            waiting -= min(4, waiting);\\n            number += 1;\\n        }\\n\\n        return profit > 0 ? optimal : -1;\\n\\n    }\\n};\\n```\\n**Please upvote if you like the solution.**\\n![Screenshot 2023-08-02 at 4.49.00 PM.png](https://assets.leetcode.com/users/images/3b8a4366-0dc8-4c18-a11d-b1b23d1539c7_1690975213.9889958.png)\\n",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int minOperationsMaxProfit(vector<int>& customers, int boardingCost, int runningCost) {\\n        // Intution\\n        // The idea in here is really very simple. We will maintain the variable to keep track of baorded customers and also we will keep the number of rotations made till now. At any instance we can stop the gondola so we will at every position check if the profit is maximum or not. If the profit at the index is max then we will change the current index to the number which we obtained now. We need to keep track of waiting number of customers and every time we will board a minimum of waiting and the board and the current profit earned will be the number of persons enjoyed the rotation and the number of times wheel was rotated for running the gondon.\\n\\n        \\n        // This is used to store max profit earned till now\\n\\n        int profit = INT_MIN;\\n\\n        // This is used to store the optimal number of moves\\n\\n        int optimal = -1;\\n\\n        // Variable to store number of waiting customers\\n\\n        int waiting = 0;\\n\\n        // Variable to stores number of rotations made\\n        int number = 1;\\n\\n        // Vairable to store boarded number of customers\\n        int boarded = 0;\\n\\n        // Looping and checking if at the current turn we can obtain max answer\\n        for(auto &cust : customers){\\n            waiting += cust;\\n            boarded += min(4, waiting);\\n            int currProfit = boarded * boardingCost - number * runningCost;\\n            if(currProfit > profit){\\n                profit = currProfit;\\n                optimal = number;\\n            }\\n            waiting -= min(4, waiting);\\n            number += 1;\\n        }\\n\\n        // Also, checking for the waiting customers\\n\\n        while(waiting > 0){\\n            boarded += min(4, waiting);\\n            int currProfit = boarded * boardingCost - number * runningCost;\\n            if(currProfit > profit){\\n                profit = currProfit;\\n                optimal = number;\\n            }\\n            waiting -= min(4, waiting);\\n            number += 1;\\n        }\\n\\n        return profit > 0 ? optimal : -1;\\n\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3788148,
                "title": "java-solution-faster-than-90",
                "content": "# Intuition\\nNeed to calculate the the profit at each step.\\n\\n# Approach\\n1)Calculate the profit at step for max people and pass rest to next index\\n2)do it till last index\\n3)then for people of last index calculate people/4 and people%4\\nbecause last remaining people may reduce the profit\\n4)at each point note max ans and at that point nos of rotation and according to that the point when it was max rotation is need to be returned\\n# Complexity\\n- Time complexity:\\nO(n)\\n\\n- Space complexity:\\nO(n)\\n\\n# Code\\n```\\nclass Solution {\\n    public int minOperationsMaxProfit(int[] cus, int board, int run) {\\n        if(4*board<run)return -1;\\n        int ans=0,max=0,ro=0,anro=0;\\n        for(int i=0;i<cus.length-1;i++)\\n        {\\n            int t=cus[i];\\n            if(t>4){cus[i+1]+=cus[i]-4;cus[i]=4;}\\n            ans+=(cus[i]*board)-(run);\\n            int o=max;ro++;\\n            max=Math.max(max,ans);\\n            if(o!=max){anro=ro;}\\n            \\n        }\\n        System.out.print(anro);\\n        int h=cus[cus.length-1];\\nif(h>0)\\n{\\n    int j=h/4;\\n    if((h%4)==0){ans+=(4*j*board)-(j*run);ro+=j;if(ans>max){anro=ro;}}\\n    else{\\n        if(h<4){ans+=(h*board)-(run);ro++;if(ans>max){anro=ro;}}\\n        else{\\n            ans+=(4*j*board)-(j*run);\\n            ro+=j;if(ans>max){anro=ro;}\\n            int g=h%4;\\n            ans+=(g*board)-run;\\n            if(((g*board)-run)>0)ro++;\\n            if(ans>max){anro=ro;}\\n        }\\n    }\\n}\\n\\nreturn anro==0?-1:anro;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int minOperationsMaxProfit(int[] cus, int board, int run) {\\n        if(4*board<run)return -1;\\n        int ans=0,max=0,ro=0,anro=0;\\n        for(int i=0;i<cus.length-1;i++)\\n        {\\n            int t=cus[i];\\n            if(t>4){cus[i+1]+=cus[i]-4;cus[i]=4;}\\n            ans+=(cus[i]*board)-(run);\\n            int o=max;ro++;\\n            max=Math.max(max,ans);\\n            if(o!=max){anro=ro;}\\n            \\n        }\\n        System.out.print(anro);\\n        int h=cus[cus.length-1];\\nif(h>0)\\n{\\n    int j=h/4;\\n    if((h%4)==0){ans+=(4*j*board)-(j*run);ro+=j;if(ans>max){anro=ro;}}\\n    else{\\n        if(h<4){ans+=(h*board)-(run);ro++;if(ans>max){anro=ro;}}\\n        else{\\n            ans+=(4*j*board)-(j*run);\\n            ro+=j;if(ans>max){anro=ro;}\\n            int g=h%4;\\n            ans+=(g*board)-run;\\n            if(((g*board)-run)>0)ro++;\\n            if(ans>max){anro=ro;}\\n        }\\n    }\\n}\\n\\nreturn anro==0?-1:anro;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3788147,
                "title": "java-solution-faster-than-90",
                "content": "# Intuition\\nNeed to calculate the the profit at each step.\\n\\n# Approach\\n1)Calculate the profit at step for max people and pass rest to next index\\n2)do it till last index\\n3)then for people of last index calculate people/4 and people%4\\nbecause last remaining people may reduce the profit\\n4)at each point note max ans and at that point nos of rotation and according to that the point when it was max rotation is need to be returned\\n# Complexity\\n- Time complexity:\\nO(n)\\n\\n- Space complexity:\\nO(n)\\n\\n# Code\\n```\\nclass Solution {\\n    public int minOperationsMaxProfit(int[] cus, int board, int run) {\\n        if(4*board<run)return -1;\\n        int ans=0,max=0,ro=0,anro=0;\\n        for(int i=0;i<cus.length-1;i++)\\n        {\\n            int t=cus[i];\\n            if(t>4){cus[i+1]+=cus[i]-4;cus[i]=4;}\\n            ans+=(cus[i]*board)-(run);\\n            int o=max;ro++;\\n            max=Math.max(max,ans);\\n            if(o!=max){anro=ro;}\\n            \\n        }\\n        System.out.print(anro);\\n        int h=cus[cus.length-1];\\nif(h>0)\\n{\\n    int j=h/4;\\n    if((h%4)==0){ans+=(4*j*board)-(j*run);ro+=j;if(ans>max){anro=ro;}}\\n    else{\\n        if(h<4){ans+=(h*board)-(run);ro++;if(ans>max){anro=ro;}}\\n        else{\\n            ans+=(4*j*board)-(j*run);\\n            ro+=j;if(ans>max){anro=ro;}\\n            int g=h%4;\\n            ans+=(g*board)-run;\\n            if(((g*board)-run)>0)ro++;\\n            if(ans>max){anro=ro;}\\n        }\\n    }\\n}\\n\\nreturn anro==0?-1:anro;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int minOperationsMaxProfit(int[] cus, int board, int run) {\\n        if(4*board<run)return -1;\\n        int ans=0,max=0,ro=0,anro=0;\\n        for(int i=0;i<cus.length-1;i++)\\n        {\\n            int t=cus[i];\\n            if(t>4){cus[i+1]+=cus[i]-4;cus[i]=4;}\\n            ans+=(cus[i]*board)-(run);\\n            int o=max;ro++;\\n            max=Math.max(max,ans);\\n            if(o!=max){anro=ro;}\\n            \\n        }\\n        System.out.print(anro);\\n        int h=cus[cus.length-1];\\nif(h>0)\\n{\\n    int j=h/4;\\n    if((h%4)==0){ans+=(4*j*board)-(j*run);ro+=j;if(ans>max){anro=ro;}}\\n    else{\\n        if(h<4){ans+=(h*board)-(run);ro++;if(ans>max){anro=ro;}}\\n        else{\\n            ans+=(4*j*board)-(j*run);\\n            ro+=j;if(ans>max){anro=ro;}\\n            int g=h%4;\\n            ans+=(g*board)-run;\\n            if(((g*board)-run)>0)ro++;\\n            if(ans>max){anro=ro;}\\n        }\\n    }\\n}\\n\\nreturn anro==0?-1:anro;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3688726,
                "title": "python3-o-n-simplest-simulation-beats-90-users-simple-and-elegant",
                "content": "```\\nclass Solution:\\n    def minOperationsMaxProfit(self, customers: List[int], boardingCost: int, runningCost: int) -> int:\\n        maxProfit=-1\\n        ans=i=curRounds=curCustomers=rem=0\\n        while i<len(customers) or rem:\\n            if i<len(customers):\\n                rem+=customers[i]\\n                i+=1\\n            curRounds+=1\\n            if rem-4>=0:\\n                rem-=4\\n                curCustomers+=4\\n            else:\\n                curCustomers+=rem\\n                rem=0\\n            curProfit=(curCustomers*boardingCost)-(curRounds*runningCost)\\n            if curProfit>maxProfit:\\n                maxProfit=curProfit\\n                ans=curRounds\\n        return -1 if maxProfit<=0 else ans\\n```",
                "solutionTags": [
                    "Python3",
                    "Simulation"
                ],
                "code": "```\\nclass Solution:\\n    def minOperationsMaxProfit(self, customers: List[int], boardingCost: int, runningCost: int) -> int:\\n        maxProfit=-1\\n        ans=i=curRounds=curCustomers=rem=0\\n        while i<len(customers) or rem:\\n            if i<len(customers):\\n                rem+=customers[i]\\n                i+=1\\n            curRounds+=1\\n            if rem-4>=0:\\n                rem-=4\\n                curCustomers+=4\\n            else:\\n                curCustomers+=rem\\n                rem=0\\n            curProfit=(curCustomers*boardingCost)-(curRounds*runningCost)\\n            if curProfit>maxProfit:\\n                maxProfit=curProfit\\n                ans=curRounds\\n        return -1 if maxProfit<=0 else ans\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3573104,
                "title": "simple-rust-solution-using-simulation",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nThe basic idea is to simulate the rotations of the wheel based on the number of customers. We will also keep track of the maximum profit we encounter across this entire simulation.\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\nWe create variables to keep track of the number of customers waiting `num_waiting`, maximum profit encountered `max_profit`, the rotation count where we encouter this maximum profit `rotations_where_max_profit`, as well as the current total profit `profit` and current rotation count `rotations`.\\n\\nWe then create a while loop which terminates only when we account for all customers, which means we must both have exceeded the length of the customer vector and have the number of customers waiting be 0 to exit the loop.\\n\\nWithin this loop, we simply find the number of customers we can board (upto 4) and calculate the profit based on this number. If the profit exceeds our previously seen maximum profit, we update both the rotation count where this happens as well as the maximum profit number. We return the rotation count where we encoutered the maximum profit (or -1 if we never see a profit).\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n$$O(c)$$ where c is the total number of customers (sum of customers vector)\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n$$O(1)$$\\n\\n# Code\\n```\\nimpl Solution {\\n    pub fn min_operations_max_profit(customers: Vec<i32>, boarding_cost: i32, running_cost: i32) -> i32 {\\n        let mut num_waiting: i32 = customers[0];\\n        let mut max_profit: i32 = 0;\\n        let mut rotations_where_max_profit: i32 = -1;\\n        let mut profit: i32 = 0;\\n        let mut rotations: usize = 1;\\n\\n        while rotations < customers.len() || num_waiting > 0 {\\n            \\n            let num_boarding = std::cmp::min(4, num_waiting);\\n            num_waiting -= num_boarding;\\n            profit += boarding_cost * num_boarding - running_cost;\\n            \\n            if profit > max_profit {\\n                rotations_where_max_profit = rotations as i32;\\n                max_profit = profit;\\n            }\\n\\n            if rotations < customers.len() {\\n                num_waiting += customers[rotations];\\n            }\\n            rotations += 1;\\n        }\\n        return rotations_where_max_profit;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Rust",
                    "Simulation"
                ],
                "code": "```\\nimpl Solution {\\n    pub fn min_operations_max_profit(customers: Vec<i32>, boarding_cost: i32, running_cost: i32) -> i32 {\\n        let mut num_waiting: i32 = customers[0];\\n        let mut max_profit: i32 = 0;\\n        let mut rotations_where_max_profit: i32 = -1;\\n        let mut profit: i32 = 0;\\n        let mut rotations: usize = 1;\\n\\n        while rotations < customers.len() || num_waiting > 0 {\\n            \\n            let num_boarding = std::cmp::min(4, num_waiting);\\n            num_waiting -= num_boarding;\\n            profit += boarding_cost * num_boarding - running_cost;\\n            \\n            if profit > max_profit {\\n                rotations_where_max_profit = rotations as i32;\\n                max_profit = profit;\\n            }\\n\\n            if rotations < customers.len() {\\n                num_waiting += customers[rotations];\\n            }\\n            rotations += 1;\\n        }\\n        return rotations_where_max_profit;\\n    }\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3391513,
                "title": "board-passengers-only-when-it-is-possible",
                "content": "# Intuition\\nParse through all the inputs.\\n\\nBoard only when it is profitable (onboarding n people makes more money than it costs to run the wheel).\\n\\n# Code\\n```\\nclass Solution:\\n    def minOperationsMaxProfit(self, customers: List[int], boardingCost: int, runningCost: int) -> int:\\n        result = -1\\n        profit = 0\\n        max_profit = 0\\n        waiting = 0\\n        for i,c in enumerate(customers):\\n            waiting += c\\n            boarding = 0\\n            if waiting >=4:\\n                boarding = 4\\n            else:\\n                boarding = waiting\\n            if boarding*boardingCost > runningCost:\\n                waiting -= boarding\\n                profit += (boarding*boardingCost) - runningCost\\n                if profit > max_profit:\\n                    max_profit = profit\\n                    result = i+1\\n        q, r = divmod(waiting, 4)\\n        if 4*boardingCost > runningCost: result += q\\n        if r*boardingCost > runningCost: result += 1\\n        return result\\n                \\n        \\n                \\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def minOperationsMaxProfit(self, customers: List[int], boardingCost: int, runningCost: int) -> int:\\n        result = -1\\n        profit = 0\\n        max_profit = 0\\n        waiting = 0\\n        for i,c in enumerate(customers):\\n            waiting += c\\n            boarding = 0\\n            if waiting >=4:\\n                boarding = 4\\n            else:\\n                boarding = waiting\\n            if boarding*boardingCost > runningCost:\\n                waiting -= boarding\\n                profit += (boarding*boardingCost) - runningCost\\n                if profit > max_profit:\\n                    max_profit = profit\\n                    result = i+1\\n        q, r = divmod(waiting, 4)\\n        if 4*boardingCost > runningCost: result += q\\n        if r*boardingCost > runningCost: result += 1\\n        return result\\n                \\n        \\n                \\n```",
                "codeTag": "Java"
            },
            {
                "id": 3355705,
                "title": "beats-100-memory",
                "content": "# Code\\n```\\nfunction minOperationsMaxProfit(customers: number[], boardingCost: number, runningCost: number): number {\\n  let profit = 0;\\n  let maxProfitRound = -1;\\n  let maxProfit = -Infinity;\\n  let round = 1\\n  while (true) {\\n    let toBoard = 0\\n    const maybeBoard = customers.shift()\\n    if (maybeBoard) {\\n      toBoard = Math.min(maybeBoard, 4)\\n      const rest = maybeBoard - toBoard\\n      if (rest > 0) {\\n        if (typeof customers[0] == \"number\") {\\n          customers[0] += rest\\n        } else {\\n          customers.push(rest)\\n        }\\n      }\\n      profit += boardingCost * toBoard\\n    }\\n    profit -= runningCost\\n    if (profit > 0 && maxProfit < profit) {\\n      maxProfit = profit\\n      maxProfitRound = round\\n    }\\n    round++\\n    if (customers.length === 0) break;\\n  }\\n  return maxProfitRound\\n};\\n\\n```",
                "solutionTags": [
                    "TypeScript"
                ],
                "code": "```\\nfunction minOperationsMaxProfit(customers: number[], boardingCost: number, runningCost: number): number {\\n  let profit = 0;\\n  let maxProfitRound = -1;\\n  let maxProfit = -Infinity;\\n  let round = 1\\n  while (true) {\\n    let toBoard = 0\\n    const maybeBoard = customers.shift()\\n    if (maybeBoard) {\\n      toBoard = Math.min(maybeBoard, 4)\\n      const rest = maybeBoard - toBoard\\n      if (rest > 0) {\\n        if (typeof customers[0] == \"number\") {\\n          customers[0] += rest\\n        } else {\\n          customers.push(rest)\\n        }\\n      }\\n      profit += boardingCost * toBoard\\n    }\\n    profit -= runningCost\\n    if (profit > 0 && maxProfit < profit) {\\n      maxProfit = profit\\n      maxProfitRound = round\\n    }\\n    round++\\n    if (customers.length === 0) break;\\n  }\\n  return maxProfitRound\\n};\\n\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3259000,
                "title": "lc-1599-m-python3-a-plain-solution",
                "content": "Determine the actual length of the customers\\' queue, and then use the iteration. (This approach is straightforward but not fast.)\\n\\n```python3 []\\nclass Solution:\\n    def minOperationsMaxProfit(self, customers: List[int], boardingCost: int, runningCost: int) -> int:\\n        if 4 * boardingCost < runningCost:\\n            return -1\\n        \\n        more_than_once = list(filter(lambda x: x > 4, customers))\\n        customers += [0] * (ceil(sum(more_than_once)/4) - len(more_than_once))\\n        n = len(customers)\\n        total_profit = max_profit = min(customers[0], 4) * boardingCost - runningCost\\n        if n > 1:\\n            customers[1] += max(0, customers[0]-4)\\n\\n        res = 1\\n        for i in range(1, n):\\n            profit = min(customers[i], 4) * boardingCost - runningCost\\n            total_profit += profit\\n            if i + 1 < n:\\n                customers[i+1] += max(0, customers[i]-4)\\n            if total_profit > max_profit:\\n                max_profit = total_profit\\n                res = i + 1\\n        \\n        return res if max_profit > 0 else -1\\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```python3 []\\nclass Solution:\\n    def minOperationsMaxProfit(self, customers: List[int], boardingCost: int, runningCost: int) -> int:\\n        if 4 * boardingCost < runningCost:\\n            return -1\\n        \\n        more_than_once = list(filter(lambda x: x > 4, customers))\\n        customers += [0] * (ceil(sum(more_than_once)/4) - len(more_than_once))\\n        n = len(customers)\\n        total_profit = max_profit = min(customers[0], 4) * boardingCost - runningCost\\n        if n > 1:\\n            customers[1] += max(0, customers[0]-4)\\n\\n        res = 1\\n        for i in range(1, n):\\n            profit = min(customers[i], 4) * boardingCost - runningCost\\n            total_profit += profit\\n            if i + 1 < n:\\n                customers[i+1] += max(0, customers[i]-4)\\n            if total_profit > max_profit:\\n                max_profit = total_profit\\n                res = i + 1\\n        \\n        return res if max_profit > 0 else -1\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3255475,
                "title": "python-simple-maths",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution:\\n    def minOperationsMaxProfit(self, customers, boardingCost, runningCost):\\n        n, profit, i, waiting, max_val, max_valAt = len(customers), 0, 0, 0, 0, 0\\n\\n        while (waiting > 0 or i < n):\\n            if i < n:\\n                waiting += customers[i]\\n            \\n            min_val = min(4,waiting)\\n            profit += min_val*boardingCost - runningCost\\n            waiting -= min_val\\n\\n            if profit > max_val:\\n                max_val = profit\\n                max_valAt = i + 1\\n\\n            i += 1\\n\\n        return max_valAt if max_valAt > 0 else -1\\n\\n\\n\\n\\n\\n\\n        \\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def minOperationsMaxProfit(self, customers, boardingCost, runningCost):\\n        n, profit, i, waiting, max_val, max_valAt = len(customers), 0, 0, 0, 0, 0\\n\\n        while (waiting > 0 or i < n):\\n            if i < n:\\n                waiting += customers[i]\\n            \\n            min_val = min(4,waiting)\\n            profit += min_val*boardingCost - runningCost\\n            waiting -= min_val\\n\\n            if profit > max_val:\\n                max_val = profit\\n                max_valAt = i + 1\\n\\n            i += 1\\n\\n        return max_valAt if max_valAt > 0 else -1\\n\\n\\n\\n\\n\\n\\n        \\n```",
                "codeTag": "Java"
            },
            {
                "id": 3175264,
                "title": "just-a-runnable-solution",
                "content": "# Code\\n```\\nimpl Solution {\\n    pub fn min_operations_max_profit(customers: Vec<i32>, boarding_cost: i32, running_cost: i32) -> i32 {\\n        let mut profit = 0;\\n        let mut max_profit = 0;\\n        let mut max_profit_rotation = 0;\\n        let mut waiting = 0;\\n        for (i, &c) in customers.iter().enumerate() {\\n            waiting += c;\\n            let boarding = std::cmp::min(waiting, 4);\\n            waiting -= boarding;\\n            profit += boarding * boarding_cost - running_cost;\\n            if profit > max_profit {\\n                max_profit = profit;\\n                max_profit_rotation = i as i32 + 1;\\n            }\\n        }\\n        let mut i = customers.len() as i32;\\n        while waiting > 0 {\\n            let boarding = std::cmp::min(waiting, 4);\\n            waiting -= boarding;\\n            profit += boarding * boarding_cost - running_cost;\\n            i += 1;\\n            if profit > max_profit {\\n                max_profit = profit;\\n                max_profit_rotation = i;\\n            }\\n        }\\n        if max_profit > 0 {\\n            max_profit_rotation\\n        } else {\\n            -1\\n        }\\n    }\\n}\\n```",
                "solutionTags": [
                    "Rust"
                ],
                "code": "```\\nimpl Solution {\\n    pub fn min_operations_max_profit(customers: Vec<i32>, boarding_cost: i32, running_cost: i32) -> i32 {\\n        let mut profit = 0;\\n        let mut max_profit = 0;\\n        let mut max_profit_rotation = 0;\\n        let mut waiting = 0;\\n        for (i, &c) in customers.iter().enumerate() {\\n            waiting += c;\\n            let boarding = std::cmp::min(waiting, 4);\\n            waiting -= boarding;\\n            profit += boarding * boarding_cost - running_cost;\\n            if profit > max_profit {\\n                max_profit = profit;\\n                max_profit_rotation = i as i32 + 1;\\n            }\\n        }\\n        let mut i = customers.len() as i32;\\n        while waiting > 0 {\\n            let boarding = std::cmp::min(waiting, 4);\\n            waiting -= boarding;\\n            profit += boarding * boarding_cost - running_cost;\\n            i += 1;\\n            if profit > max_profit {\\n                max_profit = profit;\\n                max_profit_rotation = i;\\n            }\\n        }\\n        if max_profit > 0 {\\n            max_profit_rotation\\n        } else {\\n            -1\\n        }\\n    }\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2992772,
                "title": "wa-can-someone-help",
                "content": "Can someone explain what I may be doing wrong?\\nhttps://leetcode.com/submissions/detail/870460598/",
                "solutionTags": [],
                "code": "",
                "codeTag": "Unknown"
            },
            {
                "id": 2600023,
                "title": "python-solution",
                "content": "```\\ndef minOperationsMaxProfit(self, nums: List[int], c1: int, c2: int) -> int:\\n\\tpre, nums = 0, deque(nums)\\n\\tcur_pro, cur_n, ans_pro, ans_n = 0, 0, 0, -1\\n\\twhile(pre>0 or nums):\\n\\t\\tcur_n += 1\\n\\t\\tif nums:\\n\\t\\t\\tpre += nums.popleft()\\n\\t\\tk = min(4, pre)\\n\\t\\tpre -= k\\n\\t\\tcur_pro += (c1*k-c2)\\n\\t\\tif cur_pro > ans_pro:\\n\\t\\t\\tans_pro, ans_n = cur_pro, cur_n\\n\\treturn ans_n if ans_pro else -1\\n```",
                "solutionTags": [],
                "code": "```\\ndef minOperationsMaxProfit(self, nums: List[int], c1: int, c2: int) -> int:\\n\\tpre, nums = 0, deque(nums)\\n\\tcur_pro, cur_n, ans_pro, ans_n = 0, 0, 0, -1\\n\\twhile(pre>0 or nums):\\n\\t\\tcur_n += 1\\n\\t\\tif nums:\\n\\t\\t\\tpre += nums.popleft()\\n\\t\\tk = min(4, pre)\\n\\t\\tpre -= k\\n\\t\\tcur_pro += (c1*k-c2)\\n\\t\\tif cur_pro > ans_pro:\\n\\t\\t\\tans_pro, ans_n = cur_pro, cur_n\\n\\treturn ans_n if ans_pro else -1\\n```",
                "codeTag": "Python3"
            },
            {
                "id": 2511851,
                "title": "c-solution-runtime-100-faster-memory-100-less",
                "content": "```\\npublic class Solution {\\n    public int MinOperationsMaxProfit(int[] customers, int boardingCost, int runningCost) {\\n        int group = 0;\\n        int totalRotations = 1;\\n        int currentProfit = 0;\\n        (int rotation, int profit) best = (0,0);\\n        \\n        // if enough customers have arrived, we can do multiple groups to make 4 people\\n        while (group < customers.Length) {\\n            var boardingNumber = 0;\\n            if (customers[group] > 4){\\n                boardingNumber = 4;\\n                customers[group]-= boardingNumber;\\n            } else {\\n                boardingNumber = customers[group];\\n                group++;\\n\\n                while (group < totalRotations && group < customers.Length && boardingNumber < 4){\\n                    if (customers[group] > 0) { \\n                        customers[group]--;\\n                        boardingNumber++;\\n                    }\\n                    if (customers[group] == 0)\\n                        group++;\\n                }\\n            }\\n            \\n            currentProfit+= (boardingCost * boardingNumber - runningCost);\\n            \\n            if (currentProfit > best.profit)\\n                best = (totalRotations, currentProfit);\\n            \\n            totalRotations++;\\n        }\\n        \\n        return best.rotation > 0 ? best.rotation : -1;\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\npublic class Solution {\\n    public int MinOperationsMaxProfit(int[] customers, int boardingCost, int runningCost) {\\n        int group = 0;\\n        int totalRotations = 1;\\n        int currentProfit = 0;\\n        (int rotation, int profit) best = (0,0);\\n        \\n        // if enough customers have arrived, we can do multiple groups to make 4 people\\n        while (group < customers.Length) {\\n            var boardingNumber = 0;\\n            if (customers[group] > 4){\\n                boardingNumber = 4;\\n                customers[group]-= boardingNumber;\\n            } else {\\n                boardingNumber = customers[group];\\n                group++;\\n\\n                while (group < totalRotations && group < customers.Length && boardingNumber < 4){\\n                    if (customers[group] > 0) { \\n                        customers[group]--;\\n                        boardingNumber++;\\n                    }\\n                    if (customers[group] == 0)\\n                        group++;\\n                }\\n            }\\n            \\n            currentProfit+= (boardingCost * boardingNumber - runningCost);\\n            \\n            if (currentProfit > best.profit)\\n                best = (totalRotations, currentProfit);\\n            \\n            totalRotations++;\\n        }\\n        \\n        return best.rotation > 0 ? best.rotation : -1;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2467928,
                "title": "c-solution-easy-to-understand",
                "content": "```\\nclass Solution {\\npublic:\\n    int minOperationsMaxProfit(vector<int>& customers, int boardingCost, int runningCost) {\\n        int maxProfit=0;\\n        int round=0, ans=0, servedCust=0, remCust=0,i=0;\\n        \\n        while(i<customers.size() || remCust>0)\\n        {\\n            if(i<customers.size()) remCust += customers[i];\\n            round++;\\n            i++;\\n            if(remCust>=4)\\n            {\\n                servedCust += 4;\\n                remCust -= 4; \\n            }\\n            else\\n            {\\n                servedCust += remCust;\\n                remCust = 0;\\n            }\\n            \\n            int p = (servedCust*boardingCost)-(round*runningCost);\\n            if(p>maxProfit) \\n            {\\n                maxProfit = p;\\n                ans = round;\\n            }\\n        }\\n        return maxProfit==0?-1:ans;\\n        \\n    }\\n};\\n```",
                "solutionTags": [
                    "C",
                    "Iterator"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int minOperationsMaxProfit(vector<int>& customers, int boardingCost, int runningCost) {\\n        int maxProfit=0;\\n        int round=0, ans=0, servedCust=0, remCust=0,i=0;\\n        \\n        while(i<customers.size() || remCust>0)\\n        {\\n            if(i<customers.size()) remCust += customers[i];\\n            round++;\\n            i++;\\n            if(remCust>=4)\\n            {\\n                servedCust += 4;\\n                remCust -= 4; \\n            }\\n            else\\n            {\\n                servedCust += remCust;\\n                remCust = 0;\\n            }\\n            \\n            int p = (servedCust*boardingCost)-(round*runningCost);\\n            if(p>maxProfit) \\n            {\\n                maxProfit = p;\\n                ans = round;\\n            }\\n        }\\n        return maxProfit==0?-1:ans;\\n        \\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2320987,
                "title": "python-3-simulation-clean-code",
                "content": "long code but faster because of less Comparison\\'s and less variables used:\\n\\n\\tclass Solution:\\n\\t\\tdef minOperationsMaxProfit(self, customers: List[int], boardingCost: int, runningCost: int) -> int:\\n\\t\\t\\tmax_profit=Profit=curr=0\\n\\t\\t\\tmax_profit_rotation=-1\\n\\t\\t\\tfor i,x in enumerate(customers):\\n\\t\\t\\t\\tcurr+=x\\n\\t\\t\\t\\tchange=min(curr,4)\\n\\t\\t\\t\\tcurr-=change\\n\\t\\t\\t\\tProfit+=change*boardingCost-runningCost\\n\\t\\t\\t\\tif Profit>max_profit:\\n\\t\\t\\t\\t\\tmax_profit=Profit\\n\\t\\t\\t\\t\\tmax_profit_rotation=i+1\\n\\n\\t\\t\\ta,b=curr//4,curr%4\\n\\t\\t\\tmax_profit_rotation+=a if (4*boardingCost-runningCost)>0 else 0\\n\\t\\t\\tmax_profit_rotation+=1 if (b*boardingCost-runningCost)>0 else 0\\n\\t\\t\\treturn max_profit_rotation\\n\\t\\t\\t\\nShort code but with some Extra comparison:\\n\\n\\t\\n\\tclass Solution:\\n\\t\\tdef minOperationsMaxProfit(self, customers: List[int], boardingCost: int, runningCost: int) -> int:\\n\\t\\t\\tmax_profit=Profit=t=curr=0\\n\\t\\t\\tmax_profit_rotation=-1\\n\\t\\t\\ti,n=0,len(customers)\\n\\t\\t\\twhile i<n or curr:\\n\\t\\t\\t\\tcurr+=customers[i] if i<n else 0\\n\\t\\t\\t\\tProfit+=min(4,curr)*boardingCost-runningCost\\n\\t\\t\\t\\tt+=1\\n\\t\\t\\t\\tif Profit>max_profit:\\n\\t\\t\\t\\t\\tmax_profit=Profit\\n\\t\\t\\t\\t\\tmax_profit_rotation=t\\n\\t\\t\\t\\tcurr-=min(4,curr)\\n\\t\\t\\t\\ti+=1\\n\\t\\t\\treturn max_profit_rotation\\n\\t\\t\\t\\n",
                "solutionTags": [
                    "Python3",
                    "Simulation"
                ],
                "code": "long code but faster because of less Comparison\\'s and less variables used:\\n\\n\\tclass Solution:\\n\\t\\tdef minOperationsMaxProfit(self, customers: List[int], boardingCost: int, runningCost: int) -> int:\\n\\t\\t\\tmax_profit=Profit=curr=0\\n\\t\\t\\tmax_profit_rotation=-1\\n\\t\\t\\tfor i,x in enumerate(customers):\\n\\t\\t\\t\\tcurr+=x\\n\\t\\t\\t\\tchange=min(curr,4)\\n\\t\\t\\t\\tcurr-=change\\n\\t\\t\\t\\tProfit+=change*boardingCost-runningCost\\n\\t\\t\\t\\tif Profit>max_profit:\\n\\t\\t\\t\\t\\tmax_profit=Profit\\n\\t\\t\\t\\t\\tmax_profit_rotation=i+1\\n\\n\\t\\t\\ta,b=curr//4,curr%4\\n\\t\\t\\tmax_profit_rotation+=a if (4*boardingCost-runningCost)>0 else 0\\n\\t\\t\\tmax_profit_rotation+=1 if (b*boardingCost-runningCost)>0 else 0\\n\\t\\t\\treturn max_profit_rotation\\n\\t\\t\\t\\nShort code but with some Extra comparison:\\n\\n\\t\\n\\tclass Solution:\\n\\t\\tdef minOperationsMaxProfit(self, customers: List[int], boardingCost: int, runningCost: int) -> int:\\n\\t\\t\\tmax_profit=Profit=t=curr=0\\n\\t\\t\\tmax_profit_rotation=-1\\n\\t\\t\\ti,n=0,len(customers)\\n\\t\\t\\twhile i<n or curr:\\n\\t\\t\\t\\tcurr+=customers[i] if i<n else 0\\n\\t\\t\\t\\tProfit+=min(4,curr)*boardingCost-runningCost\\n\\t\\t\\t\\tt+=1\\n\\t\\t\\t\\tif Profit>max_profit:\\n\\t\\t\\t\\t\\tmax_profit=Profit\\n\\t\\t\\t\\t\\tmax_profit_rotation=t\\n\\t\\t\\t\\tcurr-=min(4,curr)\\n\\t\\t\\t\\ti+=1\\n\\t\\t\\treturn max_profit_rotation\\n\\t\\t\\t\\n",
                "codeTag": "Java"
            },
            {
                "id": 2309665,
                "title": "not-very-fast-but-explained-with-comments-python3",
                "content": "\\'\\'\\'\\nclass Solution(object):\\n    def minOperationsMaxProfit(self, customers, boardingCost, runningCost):\\n        \"\"\"\\n        :type customers: List[int]\\n        :type boardingCost: int\\n        :type runningCost: int\\n        :rtype: int\\n        \"\"\"\\n        \\n        q = []\\n        first_round = True\\n        for i in range(len(customers)):\\n            while True:\\n                sample = min(customers[i],4)\\n\\n                if sample == 4:\\n                    q.append(sample)\\n                    customers[i] = customers[i] - sample\\n\\n                if sample == 0 and first_round == True:\\n                    q.append(sample)\\n\\n                if sample < 4 and first_round == True and sample >= 1:\\n                    q.append(sample)\\n                    customers[i] = customers[i] - sample\\n\\n\\n                if sample < 4 and first_round == False and sample >= 1:\\n                    if i == len(customers) - 1:\\n                        q.append(sample)\\n                        break\\n                    customers[i+1] = customers[i] + customers[i+1]  \\n                    customers[i] = customers[i] - sample\\n                    first_round = False\\n                    break\\n\\n                if customers[i] == 0:\\n                    break\\n\\n                first_round = False\\n\\n\\n        profits = []\\n        profit = 0\\n\\n        for ppl in q:\\n            profit = ppl * boardingCost - runningCost + profit\\n            profits.append(profit)\\n\\n        if profits[len(profits)-1] <= 0:\\n            return -1\\n\\n\\n        max_val = max(profits)\\n        min_round = profits.index(max_val)\\n        return min_round+1\\n\\'\\'\\'\\n\\nThis problem is not very hard however, the describtion is so bad. \\n\\nWhen you come and try to attempt this challenge make sure to have the this  in mind: \\n1- That if you know how the queue will be organized you nearly solved the problem. \\n\\nfor example the q for customers = [0,0,0,0,0,50] is \\nq = [0, 0, 0, 0, 0, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 2]\\n\\nsee that you will still rotate the wheel even if there is no one. \\n\\nexample2: \\ncustomers = [3,4,0,5,1]\\nq = [3, 4, 0, 4, 2]\\n\\nYou see that if the number of customers less than  4 and this is the first time you look at those waiting customers in that index you will select all of them! However, when you loop and this is the second time you look at those customers in the same index you will try to take all of them (4 in this case) which being as greedy as possible and the customers were waiting before. \\n\\n\\nMy code by no mean is fast but it does the job. Maybe the explaination is a little vague as well feel free to ask questions here!",
                "solutionTags": [],
                "code": "\\'\\'\\'\\nclass Solution(object):\\n    def minOperationsMaxProfit(self, customers, boardingCost, runningCost):\\n        \"\"\"\\n        :type customers: List[int]\\n        :type boardingCost: int\\n        :type runningCost: int\\n        :rtype: int\\n        \"\"\"\\n        \\n        q = []\\n        first_round = True\\n        for i in range(len(customers)):\\n            while True:\\n                sample = min(customers[i],4)\\n\\n                if sample == 4:\\n                    q.append(sample)\\n                    customers[i] = customers[i] - sample\\n\\n                if sample == 0 and first_round == True:\\n                    q.append(sample)\\n\\n                if sample < 4 and first_round == True and sample >= 1:\\n                    q.append(sample)\\n                    customers[i] = customers[i] - sample\\n\\n\\n                if sample < 4 and first_round == False and sample >= 1:\\n                    if i == len(customers) - 1:\\n                        q.append(sample)\\n                        break\\n                    customers[i+1] = customers[i] + customers[i+1]  \\n                    customers[i] = customers[i] - sample\\n                    first_round = False\\n                    break\\n\\n                if customers[i] == 0:\\n                    break\\n\\n                first_round = False\\n\\n\\n        profits = []\\n        profit = 0\\n\\n        for ppl in q:\\n            profit = ppl * boardingCost - runningCost + profit\\n            profits.append(profit)\\n\\n        if profits[len(profits)-1] <= 0:\\n            return -1\\n\\n\\n        max_val = max(profits)\\n        min_round = profits.index(max_val)\\n        return min_round+1\\n\\'\\'\\'\\n\\nThis problem is not very hard however, the describtion is so bad. \\n\\nWhen you come and try to attempt this challenge make sure to have the this  in mind: \\n1- That if you know how the queue will be organized you nearly solved the problem. \\n\\nfor example the q for customers = [0,0,0,0,0,50] is \\nq = [0, 0, 0, 0, 0, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 2]\\n\\nsee that you will still rotate the wheel even if there is no one. \\n\\nexample2: \\ncustomers = [3,4,0,5,1]\\nq = [3, 4, 0, 4, 2]\\n\\nYou see that if the number of customers less than  4 and this is the first time you look at those waiting customers in that index you will select all of them! However, when you loop and this is the second time you look at those customers in the same index you will try to take all of them (4 in this case) which being as greedy as possible and the customers were waiting before. \\n\\n\\nMy code by no mean is fast but it does the job. Maybe the explaination is a little vague as well feel free to ask questions here!",
                "codeTag": "Java"
            },
            {
                "id": 2240888,
                "title": "c-literally-simulated-the-whole-process",
                "content": "```\\nclass Solution {\\npublic:\\n    int minOperationsMaxProfit(vector<int>& customers, int BC , int RC) {\\n        int maxProfit = INT_MIN , profit = 0 , rots = 1 , maxRots = 0 ;\\n        int waiting = 0 , totalPeople = 0 ;\\n        \\n        for(int i = 0 ; i < customers.size() ; ++i ){\\n            int onBoard = min(4,customers[i]) ;\\n            totalPeople += onBoard ;\\n            waiting += abs(customers[i] - onBoard) ;\\n            \\n            if(onBoard < 4){\\n                int diff = abs(4 - onBoard) ;\\n                int take = min(waiting,diff) ;\\n                waiting -= take ; totalPeople += take ; onBoard += take ; \\n            }\\n            profit = totalPeople * BC  - rots * RC ;\\n            if(maxProfit < profit) maxProfit = profit , maxRots = rots ;\\n            ++rots ;\\n        }\\n        while(waiting){\\n            int onBoard = min(4,waiting) ;\\n            totalPeople += onBoard ;\\n            waiting -= onBoard ;\\n            profit = totalPeople * BC - rots *RC ;\\n            if(maxProfit < profit) maxProfit = profit , maxRots = rots ;\\n            ++rots ;\\n        } \\n        return maxProfit > 0 ? maxRots : -1 ;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int minOperationsMaxProfit(vector<int>& customers, int BC , int RC) {\\n        int maxProfit = INT_MIN , profit = 0 , rots = 1 , maxRots = 0 ;\\n        int waiting = 0 , totalPeople = 0 ;\\n        \\n        for(int i = 0 ; i < customers.size() ; ++i ){\\n            int onBoard = min(4,customers[i]) ;\\n            totalPeople += onBoard ;\\n            waiting += abs(customers[i] - onBoard) ;\\n            \\n            if(onBoard < 4){\\n                int diff = abs(4 - onBoard) ;\\n                int take = min(waiting,diff) ;\\n                waiting -= take ; totalPeople += take ; onBoard += take ; \\n            }\\n            profit = totalPeople * BC  - rots * RC ;\\n            if(maxProfit < profit) maxProfit = profit , maxRots = rots ;\\n            ++rots ;\\n        }\\n        while(waiting){\\n            int onBoard = min(4,waiting) ;\\n            totalPeople += onBoard ;\\n            waiting -= onBoard ;\\n            profit = totalPeople * BC - rots *RC ;\\n            if(maxProfit < profit) maxProfit = profit , maxRots = rots ;\\n            ++rots ;\\n        } \\n        return maxProfit > 0 ? maxRots : -1 ;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2128647,
                "title": "c-basic-implementation",
                "content": "```\\nclass Solution {\\npublic:\\n    int minOperationsMaxProfit(vector<int>& c, int b, int r) {\\n        int wt=0,ind=-1,mx=0,n=size(c),prof=0;\\n        for(int i=0;i<n||wt>0;++i){\\n            if(i<n)wt+=c[i];\\n            int go=min(4,wt);\\n            prof+=go*b-r;\\n            wt-=go;\\n            if(mx<prof){\\n                mx=prof;\\n                ind=i+1;\\n            }            \\n        }\\n        return ind;        \\n    }\\n};\\n```",
                "solutionTags": [
                    "C"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int minOperationsMaxProfit(vector<int>& c, int b, int r) {\\n        int wt=0,ind=-1,mx=0,n=size(c),prof=0;\\n        for(int i=0;i<n||wt>0;++i){\\n            if(i<n)wt+=c[i];\\n            int go=min(4,wt);\\n            prof+=go*b-r;\\n            wt-=go;\\n            if(mx<prof){\\n                mx=prof;\\n                ind=i+1;\\n            }            \\n        }\\n        return ind;        \\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2108313,
                "title": "simulation",
                "content": "Though it would be more decent to merge the two while-loops,\\nI prefer this way to separate two logic units and avoid putting if-condition inside loops.\\n\\n```cpp\\nint n = customers.size();\\nint waiting = 0;\\nint boarding = 0;\\nint profit = 0;\\nint max_profit = 0;\\nint max_profit_at = -1;\\nint i = 0;\\n\\nwhile (i < n)\\n{\\n\\t// new customers arrive.\\n\\twaiting += customers[i];\\n\\t\\n\\t// at most board 4 customers at a time.\\n\\tboarding = min(4, waiting);\\n\\twaiting -= boarding;\\n\\t// accumulate the profit.\\n\\tprofit += (boardingCost * boarding) - runningCost;\\n\\t\\n\\t++ i;\\n\\t\\n\\t// update the max profit.\\n\\tif (max_profit < profit)\\n\\t{\\n\\t\\tmax_profit = profit;\\n\\t\\tmax_profit_at = i;\\n\\t}\\n}\\n\\n// while there are customers awaiting.\\nwhile (waiting)\\n{\\n\\tboarding = min(4, waiting);\\n\\twaiting -= boarding;\\n\\tprofit += (boardingCost * boarding) - runningCost;\\n\\t\\n\\t++ i;\\n\\t\\n\\tif (max_profit < profit)\\n\\t{\\n\\t\\tmax_profit = profit;\\n\\t\\tmax_profit_at = i;\\n\\t}\\n}\\n\\nreturn max_profit_at;\\n```\\n",
                "solutionTags": [
                    "C",
                    "Simulation"
                ],
                "code": "```cpp\\nint n = customers.size();\\nint waiting = 0;\\nint boarding = 0;\\nint profit = 0;\\nint max_profit = 0;\\nint max_profit_at = -1;\\nint i = 0;\\n\\nwhile (i < n)\\n{\\n\\t// new customers arrive.\\n\\twaiting += customers[i];\\n\\t\\n\\t// at most board 4 customers at a time.\\n\\tboarding = min(4, waiting);\\n\\twaiting -= boarding;\\n\\t// accumulate the profit.\\n\\tprofit += (boardingCost * boarding) - runningCost;\\n\\t\\n\\t++ i;\\n\\t\\n\\t// update the max profit.\\n\\tif (max_profit < profit)\\n\\t{\\n\\t\\tmax_profit = profit;\\n\\t\\tmax_profit_at = i;\\n\\t}\\n}\\n\\n// while there are customers awaiting.\\nwhile (waiting)\\n{\\n\\tboarding = min(4, waiting);\\n\\twaiting -= boarding;\\n\\tprofit += (boardingCost * boarding) - runningCost;\\n\\t\\n\\t++ i;\\n\\t\\n\\tif (max_profit < profit)\\n\\t{\\n\\t\\tmax_profit = profit;\\n\\t\\tmax_profit_at = i;\\n\\t}\\n}\\n\\nreturn max_profit_at;\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2085542,
                "title": "c",
                "content": "```\\nclass Solution {\\npublic:\\n    int minOperationsMaxProfit(vector<int>& customers, int boardingCost, int runningCost) {\\n\\n        int n = customers.size(),wait = 0,board=0,curProfit = 0, maxProfit = INT_MIN,minRotate = -1,round = 0,i = 0;\\n        while (true) {\\n            round++;\\n            if (i < n) wait += customers[i++];\\n            board = min(4, wait);\\n            wait -= board;\\n            curProfit += board * boardingCost - runningCost;\\n\\n            if (curProfit > maxProfit) {\\n                minRotate = round;\\n                maxProfit = curProfit;\\n            }\\n\\n            if (i == n && wait <= 0) break;\\n        }\\n        \\n        return maxProfit <= 0 ? -1 : minRotate;\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    int minOperationsMaxProfit(vector<int>& customers, int boardingCost, int runningCost) {\\n\\n        int n = customers.size(),wait = 0,board=0,curProfit = 0, maxProfit = INT_MIN,minRotate = -1,round = 0,i = 0;\\n        while (true) {\\n            round++;\\n            if (i < n) wait += customers[i++];\\n            board = min(4, wait);\\n            wait -= board;\\n            curProfit += board * boardingCost - runningCost;\\n\\n            if (curProfit > maxProfit) {\\n                minRotate = round;\\n                maxProfit = curProfit;\\n            }\\n\\n            if (i == n && wait <= 0) break;\\n        }\\n        \\n        return maxProfit <= 0 ? -1 : minRotate;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1963523,
                "title": "100-faster-easy-javascript",
                "content": "```\\nvar minOperationsMaxProfit = function(customers, bCost, rCost) {\\n    let max=0; let ans=-1;\\n    var extra=0; var people;\\n    var total=0; let count=0;\\n    for(let i=0; i<customers.length; i++){\\n       count++;\\n       \\n       extra+=customers[i];\\n       if(extra>=4){ people=4; }\\n       else{ people=extra; }\\n       extra-=people;\\n       total+=people;\\n\\n      let profit=(total*bCost)-(count*rCost);\\n      if(profit>max){ max=profit; ans=count; }\\n    }\\n    while(extra){\\n       count++;\\n       if(extra>=4){ people=4; }\\n       else{ people=extra; }\\n       extra-=people;\\n       total+=people;\\n  \\n       let profit=(total*bCost)-(count*rCost);\\n       if(profit>max){ max=profit; ans=count; }\\n    }\\n    return ans;       \\n};\\n```",
                "solutionTags": [],
                "code": "```\\nvar minOperationsMaxProfit = function(customers, bCost, rCost) {\\n    let max=0; let ans=-1;\\n    var extra=0; var people;\\n    var total=0; let count=0;\\n    for(let i=0; i<customers.length; i++){\\n       count++;\\n       \\n       extra+=customers[i];\\n       if(extra>=4){ people=4; }\\n       else{ people=extra; }\\n       extra-=people;\\n       total+=people;\\n\\n      let profit=(total*bCost)-(count*rCost);\\n      if(profit>max){ max=profit; ans=count; }\\n    }\\n    while(extra){\\n       count++;\\n       if(extra>=4){ people=4; }\\n       else{ people=extra; }\\n       extra-=people;\\n       total+=people;\\n  \\n       let profit=(total*bCost)-(count*rCost);\\n       if(profit>max){ max=profit; ans=count; }\\n    }\\n    return ans;       \\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1674698,
                "title": "long-simulation-easy-to-understand",
                "content": "\\tclass Solution {\\n\\tpublic:\\n\\t\\tint minOperationsMaxProfit(vector<int>& customers, int boardingCost, int runningCost) {\\n\\t\\t\\tint i = 0;\\n\\t\\t\\tint answer = 0;\\n\\t\\t\\tint temp = 0;\\n\\t\\t\\tint rides = 0;\\n\\t\\t\\tint customer = 0;\\n\\n\\t\\t\\twhile(i<customers.size()){\\n\\t\\t\\t\\tcustomer+= customers[i];\\n\\t\\t\\t\\ttemp-=runningCost;\\n\\t\\t\\t\\tif(customer>=4){\\n\\t\\t\\t\\t\\ttemp+= boardingCost*4;\\n\\t\\t\\t\\t\\tcustomer-=4;\\n\\t\\t\\t\\t}else if(customer==3){\\n\\t\\t\\t\\t\\ttemp+= boardingCost*3;\\n\\t\\t\\t\\t\\tcustomer-=3;\\n\\t\\t\\t\\t}else if(customer==2){\\n\\t\\t\\t\\t\\ttemp+= boardingCost*2;\\n\\t\\t\\t\\t\\tcustomer-=2;\\n\\t\\t\\t\\t}else if(customer==1){\\n\\t\\t\\t\\t\\ttemp+= boardingCost*1;\\n\\t\\t\\t\\t\\tcustomer-=1;\\n\\t\\t\\t\\t}\\n\\t\\t\\t\\ti++;\\n\\t\\t\\t\\tif(answer<temp){\\n\\t\\t\\t\\t\\tanswer = temp;\\n\\t\\t\\t\\t\\trides = i;\\n\\t\\t\\t\\t}\\n\\t\\t\\t}\\n\\t\\t\\twhile(customer>0){\\n\\t\\t\\t\\ttemp-=runningCost;\\n\\t\\t\\t\\tif(customer>=4){\\n\\t\\t\\t\\t\\ttemp+= boardingCost*4;\\n\\t\\t\\t\\t\\tcustomer-=4;\\n\\t\\t\\t\\t}else if(customer==3){\\n\\t\\t\\t\\t\\ttemp+= boardingCost*3;\\n\\t\\t\\t\\t\\tcustomer-=3;\\n\\t\\t\\t\\t}else if(customer==2){\\n\\t\\t\\t\\t\\ttemp+= boardingCost*2;\\n\\t\\t\\t\\t\\tcustomer-=2;\\n\\t\\t\\t\\t}else if(customer==1){\\n\\t\\t\\t\\t\\ttemp+= boardingCost*1;\\n\\t\\t\\t\\t\\tcustomer-=1;\\n\\t\\t\\t\\t}\\n\\t\\t\\t\\ti++;\\n\\t\\t\\t\\tif(answer<temp){\\n\\t\\t\\t\\t\\tanswer = temp;\\n\\t\\t\\t\\t\\trides = i;\\n\\t\\t\\t\\t}\\n\\t\\t\\t}\\n\\t\\t\\tif(rides == 0){\\n\\t\\t\\t\\treturn -1;\\n\\t\\t\\t}\\n\\t\\t\\treturn rides;\\n\\t\\t}\\n\\t};",
                "solutionTags": [
                    "C"
                ],
                "code": "class Solution {\\n\\tpublic:\\n\\t\\tint minOperationsMaxProfit(vector<int>& customers, int boardingCost, int runningCost) {\\n\\t\\t\\tint i = 0;\\n\\t\\t\\tint answer = 0;\\n\\t\\t\\tint temp = 0;\\n\\t\\t\\tint rides = 0;\\n\\t\\t\\tint customer = 0;\\n\\n\\t\\t\\twhile(i<customers.size()){\\n\\t\\t\\t\\tcustomer+= customers[i];\\n\\t\\t\\t\\ttemp-=runningCost;\\n\\t\\t\\t\\tif(customer>=4){\\n\\t\\t\\t\\t\\ttemp+= boardingCost*4;\\n\\t\\t\\t\\t\\tcustomer-=4;\\n\\t\\t\\t\\t}",
                "codeTag": "Java"
            },
            {
                "id": 1571897,
                "title": "python3-easy-to-understand",
                "content": "```\\nclass Solution:\\n    def minOperationsMaxProfit(self, customers: List[int], boardingCost: int, runningCost: int) -> int:\\n        if 4 * boardingCost <= runningCost:\\n            return -1\\n        customer = 0\\n        max_profit = profit = 0\\n        r = 0\\n        out = -1\\n        while customer or r < len(customers):\\n            if r < len(customers):\\n                customer += customers[r]\\n            r += 1\\n            n = min(4, customer)\\n            # print(f\"r = {r} n ={n} {n * boardingCost - runningCost}\")\\n            profit += n * boardingCost - runningCost\\n            if profit > max_profit:\\n                out = r\\n                max_profit = profit\\n            customer -= n\\n        return out\\n            \\n        \\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution:\\n    def minOperationsMaxProfit(self, customers: List[int], boardingCost: int, runningCost: int) -> int:\\n        if 4 * boardingCost <= runningCost:\\n            return -1\\n        customer = 0\\n        max_profit = profit = 0\\n        r = 0\\n        out = -1\\n        while customer or r < len(customers):\\n            if r < len(customers):\\n                customer += customers[r]\\n            r += 1\\n            n = min(4, customer)\\n            # print(f\"r = {r} n ={n} {n * boardingCost - runningCost}\")\\n            profit += n * boardingCost - runningCost\\n            if profit > max_profit:\\n                out = r\\n                max_profit = profit\\n            customer -= n\\n        return out\\n            \\n        \\n```",
                "codeTag": "Java"
            },
            {
                "id": 1545127,
                "title": "java-simulation-o-n-concise-beat-99",
                "content": "I would like to call out and seperate the \"serving all the remaining waiting line after n shifts \" from the for loop, b/c if there are a lot of remaining passengers after n shfits, the other solutions which combine both cases will have the time complexity of O(sum(customers)) instead of O(length(customers)), it may not a big downside with customers[i] <= 50, but if the customers[i] could be as large as n. Then the time comlexity of the other solution could be O(n^2).\\n```\\nclass Solution {\\n    public int minOperationsMaxProfit(int[] customers, int boardingCost, int runningCost) {\\n        int maxProfit = 0, shift = -1, waiting = 0, profit = 0;\\n        for(int i = 0; i < customers.length; i++) {\\n            waiting += customers[i]; // In each shift adding new passenger to the waiting line\\n            profit += Math.min(waiting, 4) * boardingCost - runningCost;\\n            if(profit > maxProfit) {\\n                shift = i + 1;\\n                maxProfit = profit;\\n            }\\n            waiting = Math.max(waiting - 4, 0);\\n        }\\n        if(boardingCost * 4 > runningCost) { // profitable to serve all the remaining waiting line?\\n            shift += waiting / 4;\\n            shift += waiting % 4 * boardingCost - runningCost > 0 ? 1:0; // profitable for the last round?\\n        }\\n        return shift;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int minOperationsMaxProfit(int[] customers, int boardingCost, int runningCost) {\\n        int maxProfit = 0, shift = -1, waiting = 0, profit = 0;\\n        for(int i = 0; i < customers.length; i++) {\\n            waiting += customers[i]; // In each shift adding new passenger to the waiting line\\n            profit += Math.min(waiting, 4) * boardingCost - runningCost;\\n            if(profit > maxProfit) {\\n                shift = i + 1;\\n                maxProfit = profit;\\n            }\\n            waiting = Math.max(waiting - 4, 0);\\n        }\\n        if(boardingCost * 4 > runningCost) { // profitable to serve all the remaining waiting line?\\n            shift += waiting / 4;\\n            shift += waiting % 4 * boardingCost - runningCost > 0 ? 1:0; // profitable for the last round?\\n        }\\n        return shift;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1535377,
                "title": "mistake-in-example-4",
                "content": "Please help me to understand why in the example 4 the result should be 9 and not 10",
                "solutionTags": [],
                "code": "",
                "codeTag": "Unknown"
            },
            {
                "id": 1494199,
                "title": "python-simulation",
                "content": "```\\nclass Solution:\\n    def minOperationsMaxProfit(self, customers: List[int], boardingCost: int, runningCost: int) -> int:\\n        \\n        def rotate(wheel):\\n            return [0, wheel[0], wheel[1], wheel[2]]\\n        \\n        waiting = customers[0]\\n        wheel = [0, 0, 0, 0]\\n        rotations = 0\\n        maxp = [-float(\\'inf\\'), 0]\\n        admissions = 0\\n        i = 0\\n        while waiting > 0 or i < len(customers):\\n            if waiting > 0:\\n                if waiting > 4:\\n                    wheel[0] = 4\\n                    waiting -= 4\\n                    admissions += 4\\n                    wheel = rotate(wheel)\\n                else:\\n                    wheel[0] = waiting\\n                    admissions += waiting\\n                    waiting = 0\\n                    wheel = rotate(wheel)\\n            rotations += 1\\n            profit = admissions * boardingCost - rotations * runningCost\\n            if profit > maxp[0]:\\n                maxp = [profit, rotations]\\n            if rotations < len(customers):\\n                waiting += customers[rotations]\\n            i += 1\\n            \\n        return maxp[1] if maxp[0] > 0 else -1\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution:\\n    def minOperationsMaxProfit(self, customers: List[int], boardingCost: int, runningCost: int) -> int:\\n        \\n        def rotate(wheel):\\n            return [0, wheel[0], wheel[1], wheel[2]]\\n        \\n        waiting = customers[0]\\n        wheel = [0, 0, 0, 0]\\n        rotations = 0\\n        maxp = [-float(\\'inf\\'), 0]\\n        admissions = 0\\n        i = 0\\n        while waiting > 0 or i < len(customers):\\n            if waiting > 0:\\n                if waiting > 4:\\n                    wheel[0] = 4\\n                    waiting -= 4\\n                    admissions += 4\\n                    wheel = rotate(wheel)\\n                else:\\n                    wheel[0] = waiting\\n                    admissions += waiting\\n                    waiting = 0\\n                    wheel = rotate(wheel)\\n            rotations += 1\\n            profit = admissions * boardingCost - rotations * runningCost\\n            if profit > maxp[0]:\\n                maxp = [profit, rotations]\\n            if rotations < len(customers):\\n                waiting += customers[rotations]\\n            i += 1\\n            \\n        return maxp[1] if maxp[0] > 0 else -1\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1465193,
                "title": "java-solution",
                "content": "\\tclass Solution {\\n    public int minOperationsMaxProfit(int[] customers, int boardingCost, int runningCost) {\\n        int waiting = 0, riding = 0, profit = 0, maxProfit = -1, maxRotation = -1, rotation = 0;\\n        int index = 0;\\n        while(index < customers.length || waiting > 0)\\n        {\\n            waiting += index >= customers.length ? 0 : customers[index];\\n            index++;\\n            if(waiting > 0)\\n            {\\n                int newriders = waiting >= 4 ? 4 : waiting;\\n                riding += newriders;\\n                waiting = waiting - newriders;\\n            }\\n            \\n            rotation++;\\n            profit = riding*boardingCost - runningCost*rotation;\\n            if(maxProfit < profit)\\n            {\\n                maxProfit = profit;\\n                maxRotation = rotation;\\n            }\\n        }\\n        \\n        return profit <= 0 ? -1 : maxRotation;\\n    }\\n\\t}",
                "solutionTags": [],
                "code": "class Solution {\\n    public int minOperationsMaxProfit(int[] customers, int boardingCost, int runningCost) {\\n        int waiting = 0, riding = 0, profit = 0, maxProfit = -1, maxRotation = -1, rotation = 0;\\n        int index = 0;\\n        while(index < customers.length || waiting > 0)\\n        {\\n            waiting += index >= customers.length ? 0 : customers[index];\\n            index++;\\n            if(waiting > 0)\\n            {\\n                int newriders = waiting >= 4 ? 4 : waiting;\\n                riding += newriders;\\n                waiting = waiting - newriders;\\n            }",
                "codeTag": "Java"
            },
            {
                "id": 1460317,
                "title": "just-simulation-should-have-been-an-easy-question-but-really-lousy-description",
                "content": "```scala\\n  def minOperationsMaxProfit(customers: Array[Int], boardingCost: Int, runningCost: Int): Int = {\\n\\n    var times   = 0\\n    var total   = 0\\n    var waiting = 0\\n    var max     = 0\\n    var res     = -1\\n    var i       = 0\\n\\n    while (waiting > 0 || i < customers.length) {\\n      if (i < customers.length) waiting += customers(i)\\n      i += 1\\n      val board = if (waiting <= 4) waiting else 4\\n      times += 1\\n      total += boardingCost * board - runningCost\\n      waiting -= board\\n      if (total > max) {\\n        max = total\\n        res = times\\n      }\\n\\n    }\\n\\n    if (max > 0) res else -1\\n  }\\n```",
                "solutionTags": [],
                "code": "```scala\\n  def minOperationsMaxProfit(customers: Array[Int], boardingCost: Int, runningCost: Int): Int = {\\n\\n    var times   = 0\\n    var total   = 0\\n    var waiting = 0\\n    var max     = 0\\n    var res     = -1\\n    var i       = 0\\n\\n    while (waiting > 0 || i < customers.length) {\\n      if (i < customers.length) waiting += customers(i)\\n      i += 1\\n      val board = if (waiting <= 4) waiting else 4\\n      times += 1\\n      total += boardingCost * board - runningCost\\n      waiting -= board\\n      if (total > max) {\\n        max = total\\n        res = times\\n      }\\n\\n    }\\n\\n    if (max > 0) res else -1\\n  }\\n```",
                "codeTag": "Python3"
            },
            {
                "id": 1453449,
                "title": "naive-approach-python-solution",
                "content": "```\\nclass Solution:\\n    def minOperationsMaxProfit(self, customers: List[int], boardingCost: int, runningCost: int) -> int:\\n        \\n        if len(customers)==1:\\n            if customers[0]<4:\\n                return -1\\n        \\n        l = []\\n        count = 1\\n        waiting = 0\\n        boardedPeople = 0\\n        for i in range(len(customers)):\\n            \\n            waiting+=customers[i]\\n            \\n            boardedPeople += min(4,waiting)\\n            diff=min(4,waiting)\\n            waiting-=diff\\n            profit = boardingCost*boardedPeople - runningCost*count\\n            l.append(profit)\\n            count+=1\\n            \\n            \\n        while waiting>0:\\n            \\n            boardedPeople += min(4,waiting)\\n            \\n            profit = boardingCost*boardedPeople - runningCost*count\\n            l.append(profit)\\n            waiting-=min(4,waiting)\\n            count+=1\\n            \\n          \\n        mx = max(l)\\n        if mx < 0:\\n            return -1\\n        \\n        return l.index(mx)+1\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution:\\n    def minOperationsMaxProfit(self, customers: List[int], boardingCost: int, runningCost: int) -> int:\\n        \\n        if len(customers)==1:\\n            if customers[0]<4:\\n                return -1\\n        \\n        l = []\\n        count = 1\\n        waiting = 0\\n        boardedPeople = 0\\n        for i in range(len(customers)):\\n            \\n            waiting+=customers[i]\\n            \\n            boardedPeople += min(4,waiting)\\n            diff=min(4,waiting)\\n            waiting-=diff\\n            profit = boardingCost*boardedPeople - runningCost*count\\n            l.append(profit)\\n            count+=1\\n            \\n            \\n        while waiting>0:\\n            \\n            boardedPeople += min(4,waiting)\\n            \\n            profit = boardingCost*boardedPeople - runningCost*count\\n            l.append(profit)\\n            waiting-=min(4,waiting)\\n            count+=1\\n            \\n          \\n        mx = max(l)\\n        if mx < 0:\\n            return -1\\n        \\n        return l.index(mx)+1\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1452334,
                "title": "c-o-n-o-1-space",
                "content": "```\\npublic class Solution {\\n    public int MinOperationsMaxProfit(int[] customers, int boardingCost, int runningCost) {\\n        int pSoFar = 0;\\n        int maxP = int.MinValue;\\n        int optimalRotation = 0;\\n        int rotationCount = 0;\\n        int rem = 0;\\n        for(int i = 0; i < customers.Length; i++) {\\n            rem = rem + customers[i];\\n            int cProfit = 0;\\n            if (rem >=4) {\\n                cProfit = boardingCost * 4 - 1 * runningCost;\\n                rem = rem - 4;\\n                rotationCount++;\\n            } else if (rem != 0){\\n                cProfit = boardingCost * rem - 1 * runningCost;\\n                rem = 0;\\n                rotationCount++;\\n            } else {\\n                rotationCount++;\\n                continue;\\n            }\\n            \\n            pSoFar += cProfit;\\n            if (pSoFar > maxP) {\\n                maxP = pSoFar;\\n                optimalRotation = rotationCount;\\n            }\\n        }\\n        \\n        while (rem != 0) {\\n            int cProfit = 0;\\n            if (rem >=4) {\\n                cProfit = boardingCost * 4 - 1 * runningCost;\\n                rem = rem - 4;\\n                rotationCount++;\\n            } else if (rem != 0){\\n                cProfit = boardingCost * rem - 1 * runningCost;\\n                rem = 0;\\n                rotationCount++;\\n            }\\n            \\n            pSoFar += cProfit;\\n            if (pSoFar > maxP) {\\n                maxP = pSoFar;\\n                optimalRotation = rotationCount;\\n            }\\n        }\\n        \\n        if (maxP <= 0) {\\n            return -1;\\n        }\\n        \\n        return optimalRotation;\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\npublic class Solution {\\n    public int MinOperationsMaxProfit(int[] customers, int boardingCost, int runningCost) {\\n        int pSoFar = 0;\\n        int maxP = int.MinValue;\\n        int optimalRotation = 0;\\n        int rotationCount = 0;\\n        int rem = 0;\\n        for(int i = 0; i < customers.Length; i++) {\\n            rem = rem + customers[i];\\n            int cProfit = 0;\\n            if (rem >=4) {\\n                cProfit = boardingCost * 4 - 1 * runningCost;\\n                rem = rem - 4;\\n                rotationCount++;\\n            } else if (rem != 0){\\n                cProfit = boardingCost * rem - 1 * runningCost;\\n                rem = 0;\\n                rotationCount++;\\n            } else {\\n                rotationCount++;\\n                continue;\\n            }\\n            \\n            pSoFar += cProfit;\\n            if (pSoFar > maxP) {\\n                maxP = pSoFar;\\n                optimalRotation = rotationCount;\\n            }\\n        }\\n        \\n        while (rem != 0) {\\n            int cProfit = 0;\\n            if (rem >=4) {\\n                cProfit = boardingCost * 4 - 1 * runningCost;\\n                rem = rem - 4;\\n                rotationCount++;\\n            } else if (rem != 0){\\n                cProfit = boardingCost * rem - 1 * runningCost;\\n                rem = 0;\\n                rotationCount++;\\n            }\\n            \\n            pSoFar += cProfit;\\n            if (pSoFar > maxP) {\\n                maxP = pSoFar;\\n                optimalRotation = rotationCount;\\n            }\\n        }\\n        \\n        if (maxP <= 0) {\\n            return -1;\\n        }\\n        \\n        return optimalRotation;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1431384,
                "title": "typescript-one-loop-solution",
                "content": "```typescript\\nfunction minOperationsMaxProfit(customers: number[], boardingCost: number, runningCost: number): number {\\n    let rotation = 0;\\n    let waiting = 0;\\n    let boarded = 0;\\n    let maxProfit = 0;\\n    let maxProfitRotation = -1;\\n    while (rotation < customers.length || waiting > 0) {\\n        waiting += customers[rotation] || 0;\\n        boarded += Math.min(waiting, 4);\\n        waiting -= Math.min(waiting, 4);\\n        ++rotation;\\n        let profit = boarded * boardingCost - rotation * runningCost;\\n        if (maxProfit < profit) {\\n            maxProfit = profit;\\n            maxProfitRotation = rotation;\\n        }\\n    }\\n    return maxProfitRotation;\\n};\\n```",
                "solutionTags": [],
                "code": "```typescript\\nfunction minOperationsMaxProfit(customers: number[], boardingCost: number, runningCost: number): number {\\n    let rotation = 0;\\n    let waiting = 0;\\n    let boarded = 0;\\n    let maxProfit = 0;\\n    let maxProfitRotation = -1;\\n    while (rotation < customers.length || waiting > 0) {\\n        waiting += customers[rotation] || 0;\\n        boarded += Math.min(waiting, 4);\\n        waiting -= Math.min(waiting, 4);\\n        ++rotation;\\n        let profit = boarded * boardingCost - rotation * runningCost;\\n        if (maxProfit < profit) {\\n            maxProfit = profit;\\n            maxProfitRotation = rotation;\\n        }\\n    }\\n    return maxProfitRotation;\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1310291,
                "title": "simple-go",
                "content": "```\\nfunc minOperationsMaxProfit(customers []int, boardingCost int, runningCost int) int {\\n    waiting := 0\\n    curProfit := 0\\n    maxProfit := 0\\n    maxProfitIndex := -1\\n    \\n    idx := 0\\n    \\n    for idx < len(customers) || waiting > 0 {\\n        if idx < len(customers) {\\n            waiting += customers[idx]\\n        }\\n        if waiting > 0 {\\n            boardNow := 0\\n            if waiting >= 4 {\\n                boardNow = 4\\n                waiting -= 4\\n            } else {\\n                boardNow = waiting\\n                waiting = 0\\n            }\\n            curProfit += boardingCost * boardNow - runningCost\\n            if curProfit > maxProfit {\\n                maxProfit = curProfit\\n                maxProfitIndex = idx\\n            }\\n        }\\n        idx++\\n    }\\n    if maxProfitIndex != -1 { // compensation for being zero-index\\n        maxProfitIndex += 1\\n    }\\n    return maxProfitIndex\\n}\\n\\nfunc max(a, b int) int {\\n    if a > b {\\n        return a\\n    }\\n    return b\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nfunc minOperationsMaxProfit(customers []int, boardingCost int, runningCost int) int {\\n    waiting := 0\\n    curProfit := 0\\n    maxProfit := 0\\n    maxProfitIndex := -1\\n    \\n    idx := 0\\n    \\n    for idx < len(customers) || waiting > 0 {\\n        if idx < len(customers) {\\n            waiting += customers[idx]\\n        }\\n        if waiting > 0 {\\n            boardNow := 0\\n            if waiting >= 4 {\\n                boardNow = 4\\n                waiting -= 4\\n            } else {\\n                boardNow = waiting\\n                waiting = 0\\n            }\\n            curProfit += boardingCost * boardNow - runningCost\\n            if curProfit > maxProfit {\\n                maxProfit = curProfit\\n                maxProfitIndex = idx\\n            }\\n        }\\n        idx++\\n    }\\n    if maxProfitIndex != -1 { // compensation for being zero-index\\n        maxProfitIndex += 1\\n    }\\n    return maxProfitIndex\\n}\\n\\nfunc max(a, b int) int {\\n    if a > b {\\n        return a\\n    }\\n    return b\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1290792,
                "title": "golang-solution",
                "content": "```\\nfunc minOperationsMaxProfit(customers []int, boardingCost int, runningCost int) int {\\n    tot := 0\\n    i:=0\\n    cust := 0\\n    for ;i<len(customers) || cust > 0; i++ {\\n        if i<len(customers) {\\n            cust+=customers[i]\\n        }\\n        if cust>0 {\\n            v := min(cust, 4)\\n            val := v*boardingCost - runningCost\\n            tot += val\\n            cust-=v\\n            if val <= 0 {\\n                break\\n            }\\n        }\\n    }\\n    if tot <= 0 {\\n        return -1\\n    }\\n    return i\\n}\\nfunc min(a,b int) int {\\n    if a<b {\\n        return a\\n    }\\n    return b\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nfunc minOperationsMaxProfit(customers []int, boardingCost int, runningCost int) int {\\n    tot := 0\\n    i:=0\\n    cust := 0\\n    for ;i<len(customers) || cust > 0; i++ {\\n        if i<len(customers) {\\n            cust+=customers[i]\\n        }\\n        if cust>0 {\\n            v := min(cust, 4)\\n            val := v*boardingCost - runningCost\\n            tot += val\\n            cust-=v\\n            if val <= 0 {\\n                break\\n            }\\n        }\\n    }\\n    if tot <= 0 {\\n        return -1\\n    }\\n    return i\\n}\\nfunc min(a,b int) int {\\n    if a<b {\\n        return a\\n    }\\n    return b\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1267592,
                "title": "javascript-o-n-simulation-faster-than-78",
                "content": "```\\n/**\\n * @param {number[]} customers\\n * @param {number} boardingCost\\n * @param {number} runningCost\\n * @return {number}\\n */\\nvar minOperationsMaxProfit = function(customers, boardingCost, runningCost) {\\n    if (runningCost >= boardingCost * 4)    return -1\\n    \\n    \\n    let earning = 0\\n    let cost = 0\\n    let waiting = 0\\n    let profit = 0\\n    let maxProfit = 0\\n    let bestTime = -1\\n    \\n    \\n    for (const val of customers.values()) {\\n        waiting += val\\n        \\n        if (waiting > 4) {\\n            earning += 4 * boardingCost\\n            waiting -= 4\\n        } else {\\n            earning += waiting * boardingCost\\n            waiting = 0\\n        }\\n\\n        cost += runningCost\\n        \\n        const time = cost / runningCost\\n        profit = earning - cost\\n\\n        if (profit >= maxProfit) {\\n            maxProfit = profit\\n            bestTime = time\\n        }\\n    }\\n    \\n    \\n    if (waiting > 0) {\\n        let lastSize = waiting % 4\\n        if (lastSize === 0) lastSize = 4\\n        const rotateCount = Math.ceil(waiting / 4)\\n        \\n        \\n        cost += rotateCount * runningCost\\n        earning += waiting * boardingCost\\n        waiting = 0\\n        \\n        const time = cost / runningCost\\n        profit = earning - cost\\n\\n        if (profit > maxProfit) {\\n            maxProfit = profit\\n            bestTime = time\\n        }\\n        \\n        \\n        const lastDiff = lastSize * boardingCost - runningCost\\n        if (lastDiff <= 0 && rotateCount > 1) {\\n            maxProfit -= lastDiff\\n            bestTime--\\n        }\\n    }\\n    \\n    \\n    if (maxProfit <= 0) return -1\\n    return bestTime\\n};\\n```",
                "solutionTags": [],
                "code": "```\\n/**\\n * @param {number[]} customers\\n * @param {number} boardingCost\\n * @param {number} runningCost\\n * @return {number}\\n */\\nvar minOperationsMaxProfit = function(customers, boardingCost, runningCost) {\\n    if (runningCost >= boardingCost * 4)    return -1\\n    \\n    \\n    let earning = 0\\n    let cost = 0\\n    let waiting = 0\\n    let profit = 0\\n    let maxProfit = 0\\n    let bestTime = -1\\n    \\n    \\n    for (const val of customers.values()) {\\n        waiting += val\\n        \\n        if (waiting > 4) {\\n            earning += 4 * boardingCost\\n            waiting -= 4\\n        } else {\\n            earning += waiting * boardingCost\\n            waiting = 0\\n        }\\n\\n        cost += runningCost\\n        \\n        const time = cost / runningCost\\n        profit = earning - cost\\n\\n        if (profit >= maxProfit) {\\n            maxProfit = profit\\n            bestTime = time\\n        }\\n    }\\n    \\n    \\n    if (waiting > 0) {\\n        let lastSize = waiting % 4\\n        if (lastSize === 0) lastSize = 4\\n        const rotateCount = Math.ceil(waiting / 4)\\n        \\n        \\n        cost += rotateCount * runningCost\\n        earning += waiting * boardingCost\\n        waiting = 0\\n        \\n        const time = cost / runningCost\\n        profit = earning - cost\\n\\n        if (profit > maxProfit) {\\n            maxProfit = profit\\n            bestTime = time\\n        }\\n        \\n        \\n        const lastDiff = lastSize * boardingCost - runningCost\\n        if (lastDiff <= 0 && rotateCount > 1) {\\n            maxProfit -= lastDiff\\n            bestTime--\\n        }\\n    }\\n    \\n    \\n    if (maxProfit <= 0) return -1\\n    return bestTime\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1262378,
                "title": "python-simulation",
                "content": "```\\nclass Solution:\\n    def minOperationsMaxProfit(self, customers: List[int], bc: int, rc: int) -> int:\\n        d=0;c=0;p=customers[::-1]\\n        while p:\\n            n=p.pop()\\n            if n==0 and d>=0:c+=1;continue\\n            old=d\\n            if n<=4:d+=(n*bc)-rc\\n            else:\\n                n-=4\\n                d+=((4*bc)-rc)\\n                if p:p[-1]+=n\\n                else:p.append(n)\\n            if d-old>0:c+=1\\n        return c if c>0 else -1\\n            \\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution:\\n    def minOperationsMaxProfit(self, customers: List[int], bc: int, rc: int) -> int:\\n        d=0;c=0;p=customers[::-1]\\n        while p:\\n            n=p.pop()\\n            if n==0 and d>=0:c+=1;continue\\n            old=d\\n            if n<=4:d+=(n*bc)-rc\\n            else:\\n                n-=4\\n                d+=((4*bc)-rc)\\n                if p:p[-1]+=n\\n                else:p.append(n)\\n            if d-old>0:c+=1\\n        return c if c>0 else -1\\n            \\n```",
                "codeTag": "Java"
            },
            {
                "id": 1255006,
                "title": "kotlin-faster-100-memory-usage-100",
                "content": "```\\nclass Solution {\\n    fun minOperationsMaxProfit(customers: IntArray, boardingCost: Int, runningCost: Int): Int {\\n        var ridingP = 0\\n        var waitingP = 0\\n        var res = 0\\n        var idx = 0\\n        var max = -987654321\\n        var ans = 0\\n\\n        while (true) {\\n            if(waitingP <= 0 && idx >= customers.size) {\\n                break\\n            }\\n\\n            if (idx < customers.size) {\\n                waitingP += customers[idx]\\n            }\\n            if (waitingP >= 4) {\\n                ridingP = 4\\n                waitingP -= 4\\n            } else {\\n                ridingP = waitingP\\n                waitingP = 0\\n            }\\n\\n            res += ridingP * boardingCost - runningCost\\n            //println(\"$ridingP * $boardingCost - $runningCost = $res\")\\n\\n            if(max < res) {\\n                max = res\\n                ans = idx\\n            }\\n            idx++\\n        }\\n\\n        if(max <= 0) {\\n            return -1\\n        }\\n\\n        return ans + 1\\n    }\\n}\\n```",
                "solutionTags": [
                    "Kotlin"
                ],
                "code": "```\\nclass Solution {\\n    fun minOperationsMaxProfit(customers: IntArray, boardingCost: Int, runningCost: Int): Int {\\n        var ridingP = 0\\n        var waitingP = 0\\n        var res = 0\\n        var idx = 0\\n        var max = -987654321\\n        var ans = 0\\n\\n        while (true) {\\n            if(waitingP <= 0 && idx >= customers.size) {\\n                break\\n            }\\n\\n            if (idx < customers.size) {\\n                waitingP += customers[idx]\\n            }\\n            if (waitingP >= 4) {\\n                ridingP = 4\\n                waitingP -= 4\\n            } else {\\n                ridingP = waitingP\\n                waitingP = 0\\n            }\\n\\n            res += ridingP * boardingCost - runningCost\\n            //println(\"$ridingP * $boardingCost - $runningCost = $res\")\\n\\n            if(max < res) {\\n                max = res\\n                ans = idx\\n            }\\n            idx++\\n        }\\n\\n        if(max <= 0) {\\n            return -1\\n        }\\n\\n        return ans + 1\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1217698,
                "title": "swift-solution-simulation",
                "content": "Swift solution (simulation)\\n```\\nclass Solution {\\n    func minOperationsMaxProfit(_ customers: [Int], _ boardingCost: Int, _ runningCost: Int) -> Int {\\n        var waiting = 0, profit = 0, maxProfit = 0, turn = 0, result = -1\\n        func run() {\\n            let ongoing = min(waiting, 4)\\n            waiting -= ongoing\\n            profit += ongoing * boardingCost - runningCost\\n            turn += 1\\n            if profit > maxProfit {\\n                maxProfit = profit\\n                result = turn\\n            }\\n        }\\n        for customer in customers {\\n            waiting += customer\\n            run()\\n        }\\n        while waiting > 0 {\\n            run()\\n        }\\n        return result\\n    }\\n}\\n```",
                "solutionTags": [
                    "Swift"
                ],
                "code": "```\\nclass Solution {\\n    func minOperationsMaxProfit(_ customers: [Int], _ boardingCost: Int, _ runningCost: Int) -> Int {\\n        var waiting = 0, profit = 0, maxProfit = 0, turn = 0, result = -1\\n        func run() {\\n            let ongoing = min(waiting, 4)\\n            waiting -= ongoing\\n            profit += ongoing * boardingCost - runningCost\\n            turn += 1\\n            if profit > maxProfit {\\n                maxProfit = profit\\n                result = turn\\n            }\\n        }\\n        for customer in customers {\\n            waiting += customer\\n            run()\\n        }\\n        while waiting > 0 {\\n            run()\\n        }\\n        return result\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1195020,
                "title": "c-simulation-the-steps",
                "content": "* We simulate the behavior of the centennial wheel. For each rotation we update the # of waiting passengers, maximum/current profit, as well as the minimum rotate so far.\\n```\\nclass Solution {\\npublic:\\n    int minOperationsMaxProfit(vector<int>& customers, int boardingCost, int runningCost) {\\n        int wait = 0, curProfit = 0, maxProfit = 0, minRotate = -1, size = customers.size();\\n        vector<int> wheel(4, 0);\\n        for (int i = 0; (i < size || wait > 0) && !isFull(wheel); ++i)\\n        {\\n            int passengers = wheel[i % 4], cust = i < size ? customers[i] : 0;\\n            int board = min(4 - passengers, wait + cust);\\n            wait += cust - board;\\n            curProfit += board * boardingCost - runningCost;\\n            \\n            if (curProfit > maxProfit)\\n            {\\n                maxProfit = curProfit;\\n                minRotate = i + 1;\\n            }\\n        }\\n        \\n        return minRotate;\\n    }\\n    \\nprivate:\\n    inline bool isFull(const vector<int>& wheel)\\n    {\\n        return wheel == vector<int>{4, 4, 4, 4};\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    int minOperationsMaxProfit(vector<int>& customers, int boardingCost, int runningCost) {\\n        int wait = 0, curProfit = 0, maxProfit = 0, minRotate = -1, size = customers.size();\\n        vector<int> wheel(4, 0);\\n        for (int i = 0; (i < size || wait > 0) && !isFull(wheel); ++i)\\n        {\\n            int passengers = wheel[i % 4], cust = i < size ? customers[i] : 0;\\n            int board = min(4 - passengers, wait + cust);\\n            wait += cust - board;\\n            curProfit += board * boardingCost - runningCost;\\n            \\n            if (curProfit > maxProfit)\\n            {\\n                maxProfit = curProfit;\\n                minRotate = i + 1;\\n            }\\n        }\\n        \\n        return minRotate;\\n    }\\n    \\nprivate:\\n    inline bool isFull(const vector<int>& wheel)\\n    {\\n        return wheel == vector<int>{4, 4, 4, 4};\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1189557,
                "title": "two-loops",
                "content": "```\\nclass Solution:\\n    def minOperationsMaxProfit(self, customers, boardingCost: int, runningCost: int) -> int:\\n        profit = 0\\n        waiting = 0\\n        lst_profit = []\\n        for arrived in customers:\\n            waiting += arrived\\n            loading = min(4, waiting)\\n            waiting -= loading\\n            profit += loading * boardingCost - runningCost\\n            lst_profit.append(profit)\\n        while waiting:\\n            loading = min(4, waiting)\\n            waiting -= loading\\n            profit += loading * boardingCost - runningCost\\n            lst_profit.append(profit)\\n        max_profit = max(lst_profit)\\n        return lst_profit.index(max_profit) + 1 if max_profit > 0 else -1\\n```",
                "solutionTags": [
                    "Python",
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def minOperationsMaxProfit(self, customers, boardingCost: int, runningCost: int) -> int:\\n        profit = 0\\n        waiting = 0\\n        lst_profit = []\\n        for arrived in customers:\\n            waiting += arrived\\n            loading = min(4, waiting)\\n            waiting -= loading\\n            profit += loading * boardingCost - runningCost\\n            lst_profit.append(profit)\\n        while waiting:\\n            loading = min(4, waiting)\\n            waiting -= loading\\n            profit += loading * boardingCost - runningCost\\n            lst_profit.append(profit)\\n        max_profit = max(lst_profit)\\n        return lst_profit.index(max_profit) + 1 if max_profit > 0 else -1\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1094459,
                "title": "java-10ms-simple-solution-easy-to-understand",
                "content": "```\\nclass Solution {\\n    public int minOperationsMaxProfit(int[] customers, int boardingCost, int runningCost) {\\n        int waiting=0;\\n        int max=0;\\n        int profit=0;\\n        int running=0;\\n        int boarded=0;\\n        int gain_rotation=0;\\n        for(int i=0;i<customers.length;i++){\\n            running++;\\n            if(customers[i]>=4){\\n                waiting+=customers[i]-4;\\n                boarded+=4;\\n                profit=(boarded*boardingCost)-(running*runningCost);\\n                if(profit>max){\\n                    max=profit;\\n                    gain_rotation=running;\\n                }\\n            }else{\\n                if(waiting>=4-customers[i]){\\n                    boarded+=4;\\n                    waiting-=4-customers[i];\\n                }else{\\n                    boarded+=customers[i];\\n                }\\n                profit=(boarded*boardingCost)-(running*runningCost);\\n                if(profit>max){\\n                    max=profit;\\n                    gain_rotation=running;\\n                    \\n                }\\n            }\\n        }\\n        while(waiting>0){\\n            running++;\\n            if(waiting>=4){\\n                boarded+=4;\\n                waiting-=4;\\n                profit=(boarded*boardingCost)-(running*runningCost);\\n                if(profit>max){\\n                    max=profit;\\n                    gain_rotation=running;\\n                }\\n            }else{\\n                boarded+=waiting;\\n                waiting=0;\\n                profit=(boarded*boardingCost)-(running*runningCost);\\n                if(profit>max){\\n                    max=profit;\\n                    gain_rotation=running;\\n                }\\n            }\\n        }\\n        return max==0?-1:gain_rotation;\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    public int minOperationsMaxProfit(int[] customers, int boardingCost, int runningCost) {\\n        int waiting=0;\\n        int max=0;\\n        int profit=0;\\n        int running=0;\\n        int boarded=0;\\n        int gain_rotation=0;\\n        for(int i=0;i<customers.length;i++){\\n            running++;\\n            if(customers[i]>=4){\\n                waiting+=customers[i]-4;\\n                boarded+=4;\\n                profit=(boarded*boardingCost)-(running*runningCost);\\n                if(profit>max){\\n                    max=profit;\\n                    gain_rotation=running;\\n                }\\n            }else{\\n                if(waiting>=4-customers[i]){\\n                    boarded+=4;\\n                    waiting-=4-customers[i];\\n                }else{\\n                    boarded+=customers[i];\\n                }\\n                profit=(boarded*boardingCost)-(running*runningCost);\\n                if(profit>max){\\n                    max=profit;\\n                    gain_rotation=running;\\n                    \\n                }\\n            }\\n        }\\n        while(waiting>0){\\n            running++;\\n            if(waiting>=4){\\n                boarded+=4;\\n                waiting-=4;\\n                profit=(boarded*boardingCost)-(running*runningCost);\\n                if(profit>max){\\n                    max=profit;\\n                    gain_rotation=running;\\n                }\\n            }else{\\n                boarded+=waiting;\\n                waiting=0;\\n                profit=(boarded*boardingCost)-(running*runningCost);\\n                if(profit>max){\\n                    max=profit;\\n                    gain_rotation=running;\\n                }\\n            }\\n        }\\n        return max==0?-1:gain_rotation;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1077817,
                "title": "scenario-outcome",
                "content": "[0,4,1]\\n43\\n54\\n\\nAccording to me result should be 1 rotation as profit would be maximized:\\n4*43 - 1*54 = 118\\n\\nbut answer expected is two rotation where profit will be\\n4*43 - 2 * 54 = 107\\n\\nAny ideas?",
                "solutionTags": [],
                "code": "[0,4,1]\\n43\\n54\\n\\nAccording to me result should be 1 rotation as profit would be maximized:\\n4*43 - 1*54 = 118\\n\\nbut answer expected is two rotation where profit will be\\n4*43 - 2 * 54 = 107\\n\\nAny ideas?",
                "codeTag": "Unknown"
            },
            {
                "id": 1069445,
                "title": "java-short-solution",
                "content": "```\\n    public int minOperationsMaxProfit(int[] customers, int boardingCost, int runningCost) {\\n        int r = 0, p = 0, max_p = 0, max_r = -1, count = 0, idx = 0;\\n        while(idx < customers.length || count > 0) {\\n            int e = idx < customers.length ? customers[idx++] : 0;\\n            r++;\\n            count += e;\\n            int on = Math.min(count, 4);\\n            count -= on;\\n            \\n            p += boardingCost*on - runningCost;\\n            \\n            if(p > max_p) {\\n                max_p = p;\\n                max_r = r;\\n            }\\n        }\\n        return max_r;\\n    }\\n```",
                "solutionTags": [],
                "code": "```\\n    public int minOperationsMaxProfit(int[] customers, int boardingCost, int runningCost) {\\n        int r = 0, p = 0, max_p = 0, max_r = -1, count = 0, idx = 0;\\n        while(idx < customers.length || count > 0) {\\n            int e = idx < customers.length ? customers[idx++] : 0;\\n            r++;\\n            count += e;\\n            int on = Math.min(count, 4);\\n            count -= on;\\n            \\n            p += boardingCost*on - runningCost;\\n            \\n            if(p > max_p) {\\n                max_p = p;\\n                max_r = r;\\n            }\\n        }\\n        return max_r;\\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1067632,
                "title": "java-greedy",
                "content": "```\\nclass Solution {\\n    public int minOperationsMaxProfit(int[] customers, int boardingCost, int runningCost) {\\n\\t\\t// if running cost is too high, it\\'s not possible to make profit\\n        if(runningCost>=4*boardingCost) return -1;\\n        int profit=0,maxProfit=0,waitingCnt=0,opCnt=0,result=-1;\\n        while(true) {\\n\\t\\t\\t// running cost\\n            profit-=runningCost;\\n            if(opCnt<customers.length) {\\n\\t\\t\\t\\t// add customer to waiting list\\n                waitingCnt+=customers[opCnt];\\n            }\\n\\t\\t\\t\\n\\t\\t\\t// add operation count\\n            opCnt++;\\n\\t\\t\\t\\n\\t\\t\\t// onboard and make profit\\n            var onboard=Math.min(4,waitingCnt);\\n            waitingCnt-=onboard;\\n            profit+=onboard*boardingCost;\\n\\t\\t\\t\\n\\t\\t\\t// check if make better profit \\n            if(profit>maxProfit) {\\n                maxProfit=profit;\\n                result=opCnt;\\n            }\\n            \\n\\t\\t\\t// quit if there is no more new customer and waiting list is empty\\n            if(waitingCnt==0&&opCnt>=customers.length) break;\\n        }\\n        return result;\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    public int minOperationsMaxProfit(int[] customers, int boardingCost, int runningCost) {\\n\\t\\t// if running cost is too high, it\\'s not possible to make profit\\n        if(runningCost>=4*boardingCost) return -1;\\n        int profit=0,maxProfit=0,waitingCnt=0,opCnt=0,result=-1;\\n        while(true) {\\n\\t\\t\\t// running cost\\n            profit-=runningCost;\\n            if(opCnt<customers.length) {\\n\\t\\t\\t\\t// add customer to waiting list\\n                waitingCnt+=customers[opCnt];\\n            }\\n\\t\\t\\t\\n\\t\\t\\t// add operation count\\n            opCnt++;\\n\\t\\t\\t\\n\\t\\t\\t// onboard and make profit\\n            var onboard=Math.min(4,waitingCnt);\\n            waitingCnt-=onboard;\\n            profit+=onboard*boardingCost;\\n\\t\\t\\t\\n\\t\\t\\t// check if make better profit \\n            if(profit>maxProfit) {\\n                maxProfit=profit;\\n                result=opCnt;\\n            }\\n            \\n\\t\\t\\t// quit if there is no more new customer and waiting list is empty\\n            if(waitingCnt==0&&opCnt>=customers.length) break;\\n        }\\n        return result;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1030200,
                "title": "c-14-line",
                "content": "```\\n    int minOperationsMaxProfit(vector<int>& customers, int boardingCost, int runningCost) {\\n        int maxProfit = 0, curProfit = 0, bestRotate = 0, numRotate = 0, numWait = 0;\\n        auto oneRotate = [&]() mutable{\\n            int numIn = min(4, numWait);\\n            numWait -= numIn;\\n            numRotate++;\\n            curProfit += numIn * boardingCost - runningCost;\\n            if(curProfit > maxProfit) maxProfit = curProfit, bestRotate = numRotate;\\n        };\\n                \\n        for(auto x:customers){\\n            numWait += x;\\n            oneRotate();\\n        }\\n        while(numWait > 0) oneRotate();\\n        return maxProfit > 0 ? bestRotate : -1; \\n    }",
                "solutionTags": [],
                "code": "```\\n    int minOperationsMaxProfit(vector<int>& customers, int boardingCost, int runningCost) {\\n        int maxProfit = 0, curProfit = 0, bestRotate = 0, numRotate = 0, numWait = 0;\\n        auto oneRotate = [&]() mutable{\\n            int numIn = min(4, numWait);\\n            numWait -= numIn;\\n            numRotate++;\\n            curProfit += numIn * boardingCost - runningCost;\\n            if(curProfit > maxProfit) maxProfit = curProfit, bestRotate = numRotate;\\n        };\\n                \\n        for(auto x:customers){\\n            numWait += x;\\n            oneRotate();\\n        }\\n        while(numWait > 0) oneRotate();\\n        return maxProfit > 0 ? bestRotate : -1; \\n    }",
                "codeTag": "Unknown"
            },
            {
                "id": 1016720,
                "title": "c-100-100",
                "content": "to be honest surprised with result, didnt even try smaller types, noone practice C nowadays?\\n\\n...\\nint minOperationsMaxProfit(int* customers, int customersSize, int boardingCost, int runningCost)\\n{\\n\\n    int bestprofit[2]= {0,0}; /*Rotation,profit*/\\n    int gondola_max = 4;\\n    int pplOnGondola = 0;\\n    int waiting_ppl = 0;\\n    int i = 0;\\n    int iter = 1;\\n    int sum = 0;\\n    bool flag = false;\\n\\t\\n    while( waiting_ppl != 0 || i < customersSize )\\n    {\\n\\t\\n        if (i < customersSize)\\n        {\\n            waiting_ppl += customers[i];\\n            i++;\\n        }\\n\\t\\t\\n        if (gondola_max < waiting_ppl)\\n        {\\n            pplOnGondola += gondola_max;\\n            waiting_ppl -=gondola_max;\\n        }\\n\\t\\t\\n        else{\\n            pplOnGondola += waiting_ppl;\\n            waiting_ppl= 0;\\n        }\\n\\t\\t\\n        sum = (pplOnGondola*boardingCost)-(iter*runningCost);\\n\\n        if(bestprofit[1]<sum)\\n        {\\n            bestprofit[0]=iter;\\n            bestprofit[1]=sum;\\n            flag=true;\\n        }\\n        sum = 0;\\n        iter +=1; \\n    }\\n    if (flag==false)\\n    {\\n        return -1;\\n    }\\n    else{\\n        return bestprofit[0];\\n    }\\n}\\n...",
                "solutionTags": [],
                "code": "to be honest surprised with result, didnt even try smaller types, noone practice C nowadays?\\n\\n...\\nint minOperationsMaxProfit(int* customers, int customersSize, int boardingCost, int runningCost)\\n{\\n\\n    int bestprofit[2]= {0,0}; /*Rotation,profit*/\\n    int gondola_max = 4;\\n    int pplOnGondola = 0;\\n    int waiting_ppl = 0;\\n    int i = 0;\\n    int iter = 1;\\n    int sum = 0;\\n    bool flag = false;\\n\\t\\n    while( waiting_ppl != 0 || i < customersSize )\\n    {\\n\\t\\n        if (i < customersSize)\\n        {\\n            waiting_ppl += customers[i];\\n            i++;\\n        }\\n\\t\\t\\n        if (gondola_max < waiting_ppl)\\n        {\\n            pplOnGondola += gondola_max;\\n            waiting_ppl -=gondola_max;\\n        }\\n\\t\\t\\n        else{\\n            pplOnGondola += waiting_ppl;\\n            waiting_ppl= 0;\\n        }\\n\\t\\t\\n        sum = (pplOnGondola*boardingCost)-(iter*runningCost);\\n\\n        if(bestprofit[1]<sum)\\n        {\\n            bestprofit[0]=iter;\\n            bestprofit[1]=sum;\\n            flag=true;\\n        }\\n        sum = 0;\\n        iter +=1; \\n    }\\n    if (flag==false)\\n    {\\n        return -1;\\n    }\\n    else{\\n        return bestprofit[0];\\n    }\\n}\\n...",
                "codeTag": "Unknown"
            },
            {
                "id": 1013725,
                "title": "my-java-solution-9ms",
                "content": "The problem is nothing special but the description itself is a bit confusing (or too much detailed information).\\n\\n```\\nclass Solution {\\n    public int minOperationsMaxProfit(int[] customers, int boardingCost, int runningCost) {\\n        int res = -1, profit = 0, maxProfit = 0, currCustomers = 0, rotations = 0;\\n        \\n        while (rotations < customers.length || currCustomers > 0) {\\n            if (rotations < customers.length)\\n                currCustomers += customers[rotations];\\n            int board = currCustomers >= 4 ? 4 : currCustomers;\\n            profit += board * boardingCost - runningCost;\\n            \\n            if (profit > maxProfit) {\\n                maxProfit = profit;\\n                res = rotations + 1;\\n            }\\n            currCustomers -= board;\\n            rotations++;\\n        }\\n        return res;\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    public int minOperationsMaxProfit(int[] customers, int boardingCost, int runningCost) {\\n        int res = -1, profit = 0, maxProfit = 0, currCustomers = 0, rotations = 0;\\n        \\n        while (rotations < customers.length || currCustomers > 0) {\\n            if (rotations < customers.length)\\n                currCustomers += customers[rotations];\\n            int board = currCustomers >= 4 ? 4 : currCustomers;\\n            profit += board * boardingCost - runningCost;\\n            \\n            if (profit > maxProfit) {\\n                maxProfit = profit;\\n                res = rotations + 1;\\n            }\\n            currCustomers -= board;\\n            rotations++;\\n        }\\n        return res;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 997205,
                "title": "c-simulation-solution",
                "content": "Run-time is `O(N)`, space is `O(1)`. \\n\\n```\\nclass Solution {\\npublic:\\n    int minOperationsMaxProfit(vector<int>& customers, int boardingCost, int runningCost) {\\n        int maxProfit{0}, counter{-1}, numPeople{0}, curProfit{0};\\n        for(int i{0}, j{1}, size{(int)customers.size()}; i < size || numPeople; ++i, ++j) {\\n            if(i < size) numPeople += customers[i];\\n            int board{std::min(4,numPeople)};\\n            numPeople -= board;\\n            curProfit += board * boardingCost - runningCost;\\n            if(curProfit > maxProfit) maxProfit = curProfit, counter = j;\\n        }\\n        \\n        return counter;\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    int minOperationsMaxProfit(vector<int>& customers, int boardingCost, int runningCost) {\\n        int maxProfit{0}, counter{-1}, numPeople{0}, curProfit{0};\\n        for(int i{0}, j{1}, size{(int)customers.size()}; i < size || numPeople; ++i, ++j) {\\n            if(i < size) numPeople += customers[i];\\n            int board{std::min(4,numPeople)};\\n            numPeople -= board;\\n            curProfit += board * boardingCost - runningCost;\\n            if(curProfit > maxProfit) maxProfit = curProfit, counter = j;\\n        }\\n        \\n        return counter;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 946205,
                "title": "simple-c-code-faster-than-94-37-c-submissions",
                "content": "Take a variable ```buffer``` which will store the number of customer currently in the queue. If ```buffer<=4```, empty the buffer and if ```buffer>4``` place 4 customer into the gondola and perform further rotation. Keep filling ```buffer``` till the customers array is empty.\\n\\n```\\nclass Solution {\\npublic:\\n    int minOperationsMaxProfit(vector<int>& customers, int boardingCost, int runningCost) {\\n        int max_profit = 0;\\n        int rotations = -1;\\n        int n = customers.size();\\n        if(n==0) return -1;\\n        int buffer = 0;\\n        int profit = 0;\\n        int i=0;\\n        while(buffer!=0 || i<n) {\\n            if(i<n) buffer+=customers[i];\\n            if(buffer<4) {\\n                profit+=((buffer*boardingCost)-runningCost);\\n                buffer=0;\\n            } else {\\n                profit+=((4*boardingCost)-runningCost);\\n                buffer-=4;\\n            }\\n            if(profit>max_profit) {\\n                max_profit=profit;\\n                rotations=i+1;\\n            }\\n            i++;\\n        }\\n        return rotations;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C"
                ],
                "code": "```buffer```\n```buffer<=4```\n```buffer>4```\n```buffer```\n```\\nclass Solution {\\npublic:\\n    int minOperationsMaxProfit(vector<int>& customers, int boardingCost, int runningCost) {\\n        int max_profit = 0;\\n        int rotations = -1;\\n        int n = customers.size();\\n        if(n==0) return -1;\\n        int buffer = 0;\\n        int profit = 0;\\n        int i=0;\\n        while(buffer!=0 || i<n) {\\n            if(i<n) buffer+=customers[i];\\n            if(buffer<4) {\\n                profit+=((buffer*boardingCost)-runningCost);\\n                buffer=0;\\n            } else {\\n                profit+=((4*boardingCost)-runningCost);\\n                buffer-=4;\\n            }\\n            if(profit>max_profit) {\\n                max_profit=profit;\\n                rotations=i+1;\\n            }\\n            i++;\\n        }\\n        return rotations;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 912457,
                "title": "java-with-comments",
                "content": "```\\npublic int minOperationsMaxProfit(int[] customers, int boardingCost, int runningCost) {\\n        \\n        int qCnt = 0, max = 0, profit = 0, i = 0, rotateCnt = 0;\\n        int res = -1;\\n\\t\\t\\n\\t\\t//continue while there is queue or there are new customers\\n        while (qCnt > 0 || i < customers.length) {\\n            int currCnt = 0;\\n\\t\\t\\t\\n\\t\\t\\t//add new customers if avail\\n            if (i < customers.length) {\\n                qCnt += customers[i++];\\n            }\\n\\n          //calculate current number of customer\\n            if (qCnt >= 4) {\\n                currCnt = 4;\\n                qCnt -= 4;\\n            } else {\\n                currCnt = qCnt;\\n                qCnt = 0;\\n            }\\n\\t\\t\\t\\n\\t\\t\\t//calculate current round profit\\n            profit += (currCnt * boardingCost - runningCost);\\n            rotateCnt++;\\n\\t\\t\\t\\n\\t\\t\\t//store to results if profit is more\\n            if (profit > max) {\\n                max = profit;\\n                res = rotateCnt;\\n            }\\n        }\\n        return res;\\n    }\\n\\t```",
                "solutionTags": [],
                "code": "```\\npublic int minOperationsMaxProfit(int[] customers, int boardingCost, int runningCost) {\\n        \\n        int qCnt = 0, max = 0, profit = 0, i = 0, rotateCnt = 0;\\n        int res = -1;\\n\\t\\t\\n\\t\\t//continue while there is queue or there are new customers\\n        while (qCnt > 0 || i < customers.length) {\\n            int currCnt = 0;\\n\\t\\t\\t\\n\\t\\t\\t//add new customers if avail\\n            if (i < customers.length) {\\n                qCnt += customers[i++];\\n            }\\n\\n          //calculate current number of customer\\n            if (qCnt >= 4) {\\n                currCnt = 4;\\n                qCnt -= 4;\\n            } else {\\n                currCnt = qCnt;\\n                qCnt = 0;\\n            }\\n\\t\\t\\t\\n\\t\\t\\t//calculate current round profit\\n            profit += (currCnt * boardingCost - runningCost);\\n            rotateCnt++;\\n\\t\\t\\t\\n\\t\\t\\t//store to results if profit is more\\n            if (profit > max) {\\n                max = profit;\\n                res = rotateCnt;\\n            }\\n        }\\n        return res;\\n    }\\n\\t```",
                "codeTag": "Unknown"
            },
            {
                "id": 885982,
                "title": "golang-solution",
                "content": "```go\\nfunc minOperationsMaxProfit(customers []int, boardingCost int, runningCost int) int {\\n    \\n    waiting := 0\\n    served := 0\\n    \\n    rotation := 1\\n    max := -1\\n    optimalRotation := -1\\n    for {\\n        newCustomers := waiting\\n        if rotation <= len(customers) {\\n            newCustomers = customers[rotation-1] + waiting \\n        }\\n \\n        if newCustomers >= 4 {\\n            waiting = newCustomers - 4\\n            served += 4\\n        } else {\\n            waiting = 0\\n            served += newCustomers\\n        }\\n        \\n        newProfit := calculateProfit(served, rotation, boardingCost, runningCost)\\n        if max < newProfit {\\n            max = newProfit\\n            optimalRotation = rotation\\n        }\\n        if rotation > len(customers) && waiting == 0 {\\n            break\\n        }\\n        rotation++\\n\\n    }\\n    \\n    if max <= 0 {\\n        return -1\\n    }\\n\\n    return optimalRotation\\n}\\n\\nfunc calculateProfit(served, rotation, boardingCost, runningCost int) int {\\n    // fmt.Println(served, boardingCost, rotation, runningCost)\\n    return served*boardingCost - rotation * runningCost\\n}\\n```",
                "solutionTags": [
                    "Go"
                ],
                "code": "```go\\nfunc minOperationsMaxProfit(customers []int, boardingCost int, runningCost int) int {\\n    \\n    waiting := 0\\n    served := 0\\n    \\n    rotation := 1\\n    max := -1\\n    optimalRotation := -1\\n    for {\\n        newCustomers := waiting\\n        if rotation <= len(customers) {\\n            newCustomers = customers[rotation-1] + waiting \\n        }\\n \\n        if newCustomers >= 4 {\\n            waiting = newCustomers - 4\\n            served += 4\\n        } else {\\n            waiting = 0\\n            served += newCustomers\\n        }\\n        \\n        newProfit := calculateProfit(served, rotation, boardingCost, runningCost)\\n        if max < newProfit {\\n            max = newProfit\\n            optimalRotation = rotation\\n        }\\n        if rotation > len(customers) && waiting == 0 {\\n            break\\n        }\\n        rotation++\\n\\n    }\\n    \\n    if max <= 0 {\\n        return -1\\n    }\\n\\n    return optimalRotation\\n}\\n\\nfunc calculateProfit(served, rotation, boardingCost, runningCost int) int {\\n    // fmt.Println(served, boardingCost, rotation, runningCost)\\n    return served*boardingCost - rotation * runningCost\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 882525,
                "title": "java-straight-forward-solution",
                "content": "```\\nclass Solution {\\n    public int minOperationsMaxProfit(int[] customers, int boardingCost, int runningCost) {\\n        int rest = 0, i = 0, max = 0, profit = 0, time = 0, res = -1;\\n        while (i < customers.length || rest > 0) {\\n            time++;\\n            if (i < customers.length) rest += customers[i++];\\n            if (rest >= 4) {\\n                profit += boardingCost * 4;\\n                rest -= 4;\\n            } else {\\n                profit += boardingCost * rest;\\n                rest = 0;\\n            }\\n            profit -= runningCost;\\n            if (profit > max) {\\n                max = profit;\\n                res = time;\\n            }\\n        }\\n        return res;\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    public int minOperationsMaxProfit(int[] customers, int boardingCost, int runningCost) {\\n        int rest = 0, i = 0, max = 0, profit = 0, time = 0, res = -1;\\n        while (i < customers.length || rest > 0) {\\n            time++;\\n            if (i < customers.length) rest += customers[i++];\\n            if (rest >= 4) {\\n                profit += boardingCost * 4;\\n                rest -= 4;\\n            } else {\\n                profit += boardingCost * rest;\\n                rest = 0;\\n            }\\n            profit -= runningCost;\\n            if (profit > max) {\\n                max = profit;\\n                res = time;\\n            }\\n        }\\n        return res;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 875718,
                "title": "c-greedy-approach",
                "content": "```\\nclass Solution {\\npublic:\\n    /*\\n    [10,10,6,4,7]\\n    3\\n    8\\n    */\\n    int minOperationsMaxProfit(vector<int>& customers, int boardingCost, int runningCost) {\\n        int i=0;\\n        int rc = 1, ans, cc = 0; //rc -- current running counter; cc -- current customer count\\n        int tempProfit, profit = 0; \\n        int tot = 0; //waiting customers\\n        while(i<customers.size() || tot > 0) {\\n            if(i<customers.size()) tot += customers[i];\\n            if(tot >= 4) {\\n                cc += 4;\\n                tot -= 4;\\n            } else {\\n                cc += tot;\\n                tot = 0;\\n            }\\n            tempProfit = cc*boardingCost - (rc*runningCost);\\n            if(tempProfit > profit) {\\n                profit = tempProfit;\\n                ans = rc;\\n            }\\n            rc++;\\n            i++;\\n        }\\n        return profit == 0 ? -1 : ans;\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    /*\\n    [10,10,6,4,7]\\n    3\\n    8\\n    */\\n    int minOperationsMaxProfit(vector<int>& customers, int boardingCost, int runningCost) {\\n        int i=0;\\n        int rc = 1, ans, cc = 0; //rc -- current running counter; cc -- current customer count\\n        int tempProfit, profit = 0; \\n        int tot = 0; //waiting customers\\n        while(i<customers.size() || tot > 0) {\\n            if(i<customers.size()) tot += customers[i];\\n            if(tot >= 4) {\\n                cc += 4;\\n                tot -= 4;\\n            } else {\\n                cc += tot;\\n                tot = 0;\\n            }\\n            tempProfit = cc*boardingCost - (rc*runningCost);\\n            if(tempProfit > profit) {\\n                profit = tempProfit;\\n                ans = rc;\\n            }\\n            rc++;\\n            i++;\\n        }\\n        return profit == 0 ? -1 : ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 872937,
                "title": "javascript",
                "content": "```js\\nvar minOperationsMaxProfit = function(A, bc, rc) {\\n    let lineSize = 0;\\n    let max = 0;\\n    let profit = 0;\\n    let i = 0;\\n    let r = -1;\\n    while (lineSize || i < A.length) {\\n        if (A[i]) lineSize += A[i];\\n        const inSize = Math.min(4, lineSize);\\n        lineSize -= inSize;\\n        profit += (inSize * bc) - rc;\\n        ++i;\\n        if (profit > max) {\\n            r = i;\\n            max = profit;\\n        }\\n    }\\n    return r;\\n};\\n```",
                "solutionTags": [],
                "code": "```js\\nvar minOperationsMaxProfit = function(A, bc, rc) {\\n    let lineSize = 0;\\n    let max = 0;\\n    let profit = 0;\\n    let i = 0;\\n    let r = -1;\\n    while (lineSize || i < A.length) {\\n        if (A[i]) lineSize += A[i];\\n        const inSize = Math.min(4, lineSize);\\n        lineSize -= inSize;\\n        profit += (inSize * bc) - rc;\\n        ++i;\\n        if (profit > max) {\\n            r = i;\\n            max = profit;\\n        }\\n    }\\n    return r;\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 871319,
                "title": "brute-force-easy-to-understand",
                "content": "class Solution {\\n    public int minOperationsMaxProfit(int[] customers, int boardingCost, int runningCost) {\\n        int profit = 0;\\n        int result = -1;\\n        int waiting = 0;\\n        int maxprofit = 0;\\n        \\n        for(int i = 0; i < customers.length || waiting > 0; i++){\\n            if(i < customers.length ){\\n                waiting += customers[i];\\n            }\\n            int onborading = Math.min(waiting,4);\\n            waiting -= onborading;\\n            profit += onborading * boardingCost;\\n            profit -= runningCost;\\n            if(profit > maxprofit){\\n                maxprofit = profit;\\n                result = i + 1;\\n            }\\n        }\\n        return result;\\n    }\\n}",
                "solutionTags": [],
                "code": "class Solution {\\n    public int minOperationsMaxProfit(int[] customers, int boardingCost, int runningCost) {\\n        int profit = 0;\\n        int result = -1;\\n        int waiting = 0;\\n        int maxprofit = 0;\\n        \\n        for(int i = 0; i < customers.length || waiting > 0; i++){\\n            if(i < customers.length ){\\n                waiting += customers[i];\\n            }",
                "codeTag": "Java"
            },
            {
                "id": 871179,
                "title": "rust-translated-20ms-75",
                "content": "```rust\\nimpl Solution {\\n    pub fn min_operations_max_profit(\\n        customers: Vec<i32>,\\n        boarding_cost: i32,\\n        running_cost: i32,\\n    ) -> i32 {\\n        let mut run = 0;\\n        let mut max_run = 0;\\n        let mut profit = 0;\\n        let mut max_profit = 0;\\n        let mut sum = 0;\\n        let mut i = 0;\\n        while sum > 0 || i < customers.len() {\\n            if i < customers.len() {\\n                sum += customers[i];\\n                i += 1;\\n            }\\n            let board = if sum > 4 { 4 } else { sum };\\n            sum -= board;\\n            profit += board * boarding_cost - running_cost;\\n            run += 1;\\n            if profit > max_profit {\\n                max_profit = profit;\\n                max_run = run;\\n            }\\n        }\\n        if max_profit > 0 {\\n            max_run\\n        } else {\\n            -1\\n        }\\n    }\\n}\\n\\n#[cfg(test)]\\nmod tests {\\n    use super::*;\\n\\n    #[test]\\n    fn test_min_operations_max_profit() {\\n        assert_eq!(Solution::min_operations_max_profit(vec![8, 3], 5, 6), 3);\\n    }\\n\\n    #[test]\\n    fn test_min_operations_max_profit_02() {\\n        assert_eq!(Solution::min_operations_max_profit(vec![10, 9, 6], 6, 4), 7);\\n    }\\n\\n    #[test]\\n    fn test_min_operations_max_profit_03() {\\n        assert_eq!(\\n            Solution::min_operations_max_profit(vec![3, 4, 0, 5, 1], 1, 92),\\n            -1\\n        );\\n    }\\n\\n    #[test]\\n    fn test_min_operations_max_profit_04() {\\n        assert_eq!(\\n            Solution::min_operations_max_profit(vec![10, 10, 6, 4, 7], 3, 8),\\n            9\\n        );\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```rust\\nimpl Solution {\\n    pub fn min_operations_max_profit(\\n        customers: Vec<i32>,\\n        boarding_cost: i32,\\n        running_cost: i32,\\n    ) -> i32 {\\n        let mut run = 0;\\n        let mut max_run = 0;\\n        let mut profit = 0;\\n        let mut max_profit = 0;\\n        let mut sum = 0;\\n        let mut i = 0;\\n        while sum > 0 || i < customers.len() {\\n            if i < customers.len() {\\n                sum += customers[i];\\n                i += 1;\\n            }\\n            let board = if sum > 4 { 4 } else { sum };\\n            sum -= board;\\n            profit += board * boarding_cost - running_cost;\\n            run += 1;\\n            if profit > max_profit {\\n                max_profit = profit;\\n                max_run = run;\\n            }\\n        }\\n        if max_profit > 0 {\\n            max_run\\n        } else {\\n            -1\\n        }\\n    }\\n}\\n\\n#[cfg(test)]\\nmod tests {\\n    use super::*;\\n\\n    #[test]\\n    fn test_min_operations_max_profit() {\\n        assert_eq!(Solution::min_operations_max_profit(vec![8, 3], 5, 6), 3);\\n    }\\n\\n    #[test]\\n    fn test_min_operations_max_profit_02() {\\n        assert_eq!(Solution::min_operations_max_profit(vec![10, 9, 6], 6, 4), 7);\\n    }\\n\\n    #[test]\\n    fn test_min_operations_max_profit_03() {\\n        assert_eq!(\\n            Solution::min_operations_max_profit(vec![3, 4, 0, 5, 1], 1, 92),\\n            -1\\n        );\\n    }\\n\\n    #[test]\\n    fn test_min_operations_max_profit_04() {\\n        assert_eq!(\\n            Solution::min_operations_max_profit(vec![10, 10, 6, 4, 7], 3, 8),\\n            9\\n        );\\n    }\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 869693,
                "title": "golang-116ms-100",
                "content": "```go\\nfunc minOperationsMaxProfit(customers []int, boardingCost int, runningCost int) int {\\n\\tprofit := math.MinInt32\\n\\tpeople := 0\\n\\twait := 0\\n\\tmaxRound := 0\\n\\tfor i, c := range customers {\\n\\t\\twait += c\\n\\t\\tpeople += c\\n\\t\\tif wait <= 4 {\\n\\t\\t\\twait = 0\\n\\t\\t} else {\\n\\t\\t\\twait -= 4\\n\\t\\t}\\n\\t\\tcurr, round := currentProfit(wait, people, i+1, boardingCost, runningCost)\\n\\t\\tif curr > profit {\\n\\t\\t\\tprofit = curr\\n\\t\\t\\tmaxRound = round\\n\\t\\t}\\n\\t}\\n\\tif profit <= 0 {\\n\\t\\treturn -1\\n\\t}\\n\\treturn maxRound\\n}\\n\\nfunc currentProfit(wait, people, round, boardingCost, runningCost int) (int, int) {\\n\\tround += wait/4\\n\\tprofit := (people - wait%4) * boardingCost - round * runningCost\\n\\tif wait % 4 != 0 {\\n\\t\\ttemp := people * boardingCost - (round+1) * runningCost\\n\\t\\tif temp > profit {\\n\\t\\t\\treturn temp, round+1\\n\\t\\t}\\n\\t}\\n\\treturn profit, round\\n}\\n```",
                "solutionTags": [
                    "Go"
                ],
                "code": "```go\\nfunc minOperationsMaxProfit(customers []int, boardingCost int, runningCost int) int {\\n\\tprofit := math.MinInt32\\n\\tpeople := 0\\n\\twait := 0\\n\\tmaxRound := 0\\n\\tfor i, c := range customers {\\n\\t\\twait += c\\n\\t\\tpeople += c\\n\\t\\tif wait <= 4 {\\n\\t\\t\\twait = 0\\n\\t\\t} else {\\n\\t\\t\\twait -= 4\\n\\t\\t}\\n\\t\\tcurr, round := currentProfit(wait, people, i+1, boardingCost, runningCost)\\n\\t\\tif curr > profit {\\n\\t\\t\\tprofit = curr\\n\\t\\t\\tmaxRound = round\\n\\t\\t}\\n\\t}\\n\\tif profit <= 0 {\\n\\t\\treturn -1\\n\\t}\\n\\treturn maxRound\\n}\\n\\nfunc currentProfit(wait, people, round, boardingCost, runningCost int) (int, int) {\\n\\tround += wait/4\\n\\tprofit := (people - wait%4) * boardingCost - round * runningCost\\n\\tif wait % 4 != 0 {\\n\\t\\ttemp := people * boardingCost - (round+1) * runningCost\\n\\t\\tif temp > profit {\\n\\t\\t\\treturn temp, round+1\\n\\t\\t}\\n\\t}\\n\\treturn profit, round\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 869623,
                "title": "python-linear-time",
                "content": "```\\nclass Solution:\\n    def minOperationsMaxProfit(self, customers: List[int], boardingCost: int, runningCost: int) -> int:\\n        if len(customers)==0:\\n            return -1\\n        wait = 0\\n        onboard = 0\\n        r=0\\n        max_prof, max_r, cost = float(\\'-inf\\'),0,0\\n        while customers[r] == 0:\\n            r+=1\\n            \\n        if customers:\\n            wait+=customers[r]\\n            while wait >0:\\n                c = min(wait, 4)\\n                wait = max(0, wait-4)\\n                onboard+=c\\n                r+=1\\n                cost = onboard*boardingCost - r*runningCost\\n                if cost >max_prof:\\n                    max_r = r\\n                    max_prof = cost\\n                if r<len(customers):\\n                    wait+=customers[r]\\n\\n        if max_prof <=0:\\n            return -1\\n        return max_r\\n            \\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution:\\n    def minOperationsMaxProfit(self, customers: List[int], boardingCost: int, runningCost: int) -> int:\\n        if len(customers)==0:\\n            return -1\\n        wait = 0\\n        onboard = 0\\n        r=0\\n        max_prof, max_r, cost = float(\\'-inf\\'),0,0\\n        while customers[r] == 0:\\n            r+=1\\n            \\n        if customers:\\n            wait+=customers[r]\\n            while wait >0:\\n                c = min(wait, 4)\\n                wait = max(0, wait-4)\\n                onboard+=c\\n                r+=1\\n                cost = onboard*boardingCost - r*runningCost\\n                if cost >max_prof:\\n                    max_r = r\\n                    max_prof = cost\\n                if r<len(customers):\\n                    wait+=customers[r]\\n\\n        if max_prof <=0:\\n            return -1\\n        return max_r\\n            \\n```",
                "codeTag": "Java"
            },
            {
                "id": 869303,
                "title": "passing-all-the-test-cases-except-last-two-which-case-missing",
                "content": "```\\nclass Solution {\\npublic:\\n    int minOperationsMaxProfit(vector<int>& customers, int boardingCost, int runningCost) {\\n        int sum = 0;\\n        int l = customers.size();\\n        for(int i = 0; i < l; i++){\\n            sum += customers[i];\\n        }\\n        int shift = sum / 4;\\n        int remain = sum - (shift * 4);\\n        //cout<<\"shift \"<<shift<<endl;\\n        //cout<<\"remain \"<<remain<<endl;\\n        int ans = INT_MIN;\\n        int j, index = 0;\\n        for(j = 1; j <= shift; j++){\\n            int cost = 4 * j * boardingCost - j * runningCost;\\n            if(ans < cost){\\n                ans = cost;\\n                index = j;\\n            }\\n        }\\n        if(remain > 0){\\n            int remainCost = sum * boardingCost - j *  runningCost;\\n            if(ans < remainCost){\\n                ans = remainCost;\\n                index = j;\\n            }\\n        }\\n        //cout<<\"ans \"<<ans<<endl;\\n        return ans < 0 ? -1 : index;\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    int minOperationsMaxProfit(vector<int>& customers, int boardingCost, int runningCost) {\\n        int sum = 0;\\n        int l = customers.size();\\n        for(int i = 0; i < l; i++){\\n            sum += customers[i];\\n        }\\n        int shift = sum / 4;\\n        int remain = sum - (shift * 4);\\n        //cout<<\"shift \"<<shift<<endl;\\n        //cout<<\"remain \"<<remain<<endl;\\n        int ans = INT_MIN;\\n        int j, index = 0;\\n        for(j = 1; j <= shift; j++){\\n            int cost = 4 * j * boardingCost - j * runningCost;\\n            if(ans < cost){\\n                ans = cost;\\n                index = j;\\n            }\\n        }\\n        if(remain > 0){\\n            int remainCost = sum * boardingCost - j *  runningCost;\\n            if(ans < remainCost){\\n                ans = remainCost;\\n                index = j;\\n            }\\n        }\\n        //cout<<\"ans \"<<ans<<endl;\\n        return ans < 0 ? -1 : index;\\n    }\\n};\\n```",
                "codeTag": "C++"
            },
            {
                "id": 869291,
                "title": "python3-simple-simulation-o-n-940ms-100",
                "content": "```\\nclass Solution:\\n    def minOperationsMaxProfit(self, customers: List[int], boardingCost: int, runningCost: int) -> int:\\n        wait = 0\\n        pro = 0\\n        high = 0\\n        res = -1\\n        for i in range(len(customers)):\\n            vacc = 4 - wait\\n            if vacc <= 0:\\n                wait += customers[i] - 4\\n                pro += 4 * boardingCost - runningCost\\n            # board all\\n            elif customers[i] <= vacc: # board=customers[i]+wait\\n                pro += boardingCost * (customers[i] + wait) - runningCost\\n                wait = 0\\n            else:\\n                pro += boardingCost * 4 - runningCost\\n                wait += customers[i] - 4\\n            if pro > high:\\n                high = pro\\n                res = i\\n        # determine after all arrives\\n        pro_per = boardingCost * 4 - runningCost\\n        if pro_per > 0:\\n            last = wait % 4\\n            if wait >= 4:\\n                if boardingCost * last - runningCost > 0: return len(customers) + wait // 4 + 1\\n                else: return len(customers) + wait // 4\\n            if boardingCost * last - runningCost > 0: return len(customers) + 1\\n        return res + 1 if res >= 0 else -1\\n```\\nTwo parts: when customers incoming; after all customers arrived.\\nFor the first part, simple simulation.\\nFor the second part, determine whether profit per round with 4 or fewer (at the very last round) is positive.",
                "solutionTags": [],
                "code": "```\\nclass Solution:\\n    def minOperationsMaxProfit(self, customers: List[int], boardingCost: int, runningCost: int) -> int:\\n        wait = 0\\n        pro = 0\\n        high = 0\\n        res = -1\\n        for i in range(len(customers)):\\n            vacc = 4 - wait\\n            if vacc <= 0:\\n                wait += customers[i] - 4\\n                pro += 4 * boardingCost - runningCost\\n            # board all\\n            elif customers[i] <= vacc: # board=customers[i]+wait\\n                pro += boardingCost * (customers[i] + wait) - runningCost\\n                wait = 0\\n            else:\\n                pro += boardingCost * 4 - runningCost\\n                wait += customers[i] - 4\\n            if pro > high:\\n                high = pro\\n                res = i\\n        # determine after all arrives\\n        pro_per = boardingCost * 4 - runningCost\\n        if pro_per > 0:\\n            last = wait % 4\\n            if wait >= 4:\\n                if boardingCost * last - runningCost > 0: return len(customers) + wait // 4 + 1\\n                else: return len(customers) + wait // 4\\n            if boardingCost * last - runningCost > 0: return len(customers) + 1\\n        return res + 1 if res >= 0 else -1\\n```",
                "codeTag": "Java"
            },
            {
                "id": 869130,
                "title": "c-easy-to-understand",
                "content": "```\\n int minOperationsMaxProfit(vector<int>& customers, int boardingCost, int runningCost) {\\n        int que=0, maxProfit = INT_MIN, profit=0, people=0;\\n        int i=1, count=1 ,maxCount=-1;\\n        que = customers[0];\\n \\n        while(que > 0 || i<customers.size() )\\n        {\\n            people = people + min(4, que);\\n            profit = (people*boardingCost) - (count * runningCost);\\n     \\n            if(profit > maxProfit)\\n            {\\n                maxCount = count;\\n                maxProfit = profit;\\n            }\\n            que = max(que-4, 0);\\n            if(i<customers.size())\\n                que = que+customers[i];\\n           \\n            i++;\\n            count++;\\n        }\\n    return maxProfit >=0? maxCount: -1;\\n    }",
                "solutionTags": [],
                "code": "```\\n int minOperationsMaxProfit(vector<int>& customers, int boardingCost, int runningCost) {\\n        int que=0, maxProfit = INT_MIN, profit=0, people=0;\\n        int i=1, count=1 ,maxCount=-1;\\n        que = customers[0];\\n \\n        while(que > 0 || i<customers.size() )\\n        {\\n            people = people + min(4, que);\\n            profit = (people*boardingCost) - (count * runningCost);\\n     \\n            if(profit > maxProfit)\\n            {\\n                maxCount = count;\\n                maxProfit = profit;\\n            }\\n            que = max(que-4, 0);\\n            if(i<customers.size())\\n                que = que+customers[i];\\n           \\n            i++;\\n            count++;\\n        }\\n    return maxProfit >=0? maxCount: -1;\\n    }",
                "codeTag": "Unknown"
            },
            {
                "id": 869126,
                "title": "c-solution",
                "content": "class Solution {\\npublic:\\n    int minOperationsMaxProfit(vector<int>& customers, int boardingCost, int runningCost) {\\n        int n=customers.size();\\n        if(n==0)\\n        {\\n            return -1;\\n        }\\n        int sum=0;\\n        int ind=-1;\\n        int mx=0;\\n        int total=0;\\n        for(int i=0;i<n;i++)\\n        {\\n            total=total+customers[i];\\n            int profit=0;\\n            int temp;\\n            if(total>=4)\\n            {\\n                temp=4;\\n                total=total-4;\\n            }\\n            else\\n            {\\n                temp=total;\\n                total=0;\\n            }\\n            sum=sum+temp;\\n            profit=sum*boardingCost-(i+1)*runningCost;\\n            if(profit>mx)\\n            {\\n                mx=profit;\\n                ind=i+1;\\n            }\\n        }\\n        int round=n+1;\\n        while(total>0)\\n        {\\n            int profit=0;\\n            int temp;\\n            if(total>=4)\\n            {\\n                temp=4;\\n                total=total-4;\\n            }\\n            else\\n            {\\n                temp=total;\\n                total=0;\\n            }\\n            sum=sum+temp;\\n            profit=sum*boardingCost-(round)*runningCost;\\n            \\n            if(mx<profit)\\n            {\\n                mx=profit;\\n                ind=round;\\n            }\\n            round++;\\n        }\\n        if(ind==-1)\\n        {\\n            return -1;\\n        }\\n        else\\n        {\\n        return ind;\\n        }\\n    }\\n};",
                "solutionTags": [],
                "code": "class Solution {\\npublic:\\n    int minOperationsMaxProfit(vector<int>& customers, int boardingCost, int runningCost) {\\n        int n=customers.size();\\n        if(n==0)\\n        {\\n            return -1;\\n        }",
                "codeTag": "Java"
            },
            {
                "id": 868944,
                "title": "c-simple",
                "content": "```\\n int minOperationsMaxProfit(vector<int>& customers, int boardingCost, int runningCost) {\\n        int maxProfit = 0, ans = 0;\\n        int n = 0, i=0;\\n        int count = 0;\\n        while(i<customers.size() || n>0){\\n            if(i<customers.size())\\n                n+=customers[i++];\\n            int m = min(4, n);\\n            n = n-m>0? n-m: 0;\\n            int temp = m*boardingCost - runningCost;\\n            count++;\\n            if(maxProfit+temp > maxProfit){\\n                maxProfit +=temp;\\n                ans = count;\\n            }\\n        }\\n        \\n        return maxProfit == 0? -1: ans;\\n        \\n    }\\n```",
                "solutionTags": [],
                "code": "```\\n int minOperationsMaxProfit(vector<int>& customers, int boardingCost, int runningCost) {\\n        int maxProfit = 0, ans = 0;\\n        int n = 0, i=0;\\n        int count = 0;\\n        while(i<customers.size() || n>0){\\n            if(i<customers.size())\\n                n+=customers[i++];\\n            int m = min(4, n);\\n            n = n-m>0? n-m: 0;\\n            int temp = m*boardingCost - runningCost;\\n            count++;\\n            if(maxProfit+temp > maxProfit){\\n                maxProfit +=temp;\\n                ans = count;\\n            }\\n        }\\n        \\n        return maxProfit == 0? -1: ans;\\n        \\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 868826,
                "title": "python-solution-faster-than-100",
                "content": "\\t\\tdef minOperationsMaxProfit(self, customers, boardingCost, runningCost):\\n\\t\\t\\tans=0\\n\\t\\t\\tro =0\\n\\t\\t\\tr=t=p_max=0\\n\\t\\t\\tfor i in customers:\\n\\t\\t\\t\\tc=0\\n\\t\\t\\t\\tro+=1\\n\\t\\t\\t\\tif r<=0:\\n\\t\\t\\t\\t\\tt += min(4,i) \\n\\t\\t\\t\\t\\tr = max(0,i-4)\\n\\t\\t\\t\\t\\tc = t*boardingCost - ro*runningCost\\n\\t\\t\\t\\t\\tif c>p_max:\\n\\t\\t\\t\\t\\t\\tp_max=c\\n\\t\\t\\t\\t\\t\\tans=ro\\n\\n\\t\\t\\t\\telif r>0:\\n\\t\\t\\t\\t\\tt += 4\\n\\t\\t\\t\\t\\tr += i-4\\n\\t\\t\\t\\t\\tc = t*boardingCost - ro*runningCost\\n\\t\\t\\t\\t\\tif c>p_max:\\n\\t\\t\\t\\t\\t\\tp_max=c\\n\\t\\t\\t\\t\\t\\tans = ro\\n\\n\\t\\t\\twhile r>0:\\n\\t\\t\\t\\tro +=1\\n\\t\\t\\t\\tc=0\\n\\t\\t\\t\\tt += min(4,r)\\n\\t\\t\\t\\tr -= 4\\n\\t\\t\\t\\tc = t*boardingCost - ro*runningCost\\n\\t\\t\\t\\tif c>p_max:\\n\\t\\t\\t\\t\\tp_max= c\\n\\t\\t\\t\\t\\tans = ro\\n\\t\\t\\tif p_max==0:\\n\\t\\t\\t\\treturn -1\\n\\t\\t\\telse:\\n\\t\\t\\t\\treturn ans",
                "solutionTags": [],
                "code": "\\t\\tdef minOperationsMaxProfit(self, customers, boardingCost, runningCost):\\n\\t\\t\\tans=0\\n\\t\\t\\tro =0\\n\\t\\t\\tr=t=p_max=0\\n\\t\\t\\tfor i in customers:\\n\\t\\t\\t\\tc=0\\n\\t\\t\\t\\tro+=1\\n\\t\\t\\t\\tif r<=0:\\n\\t\\t\\t\\t\\tt += min(4,i) \\n\\t\\t\\t\\t\\tr = max(0,i-4)\\n\\t\\t\\t\\t\\tc = t*boardingCost - ro*runningCost\\n\\t\\t\\t\\t\\tif c>p_max:\\n\\t\\t\\t\\t\\t\\tp_max=c\\n\\t\\t\\t\\t\\t\\tans=ro\\n\\n\\t\\t\\t\\telif r>0:\\n\\t\\t\\t\\t\\tt += 4\\n\\t\\t\\t\\t\\tr += i-4\\n\\t\\t\\t\\t\\tc = t*boardingCost - ro*runningCost\\n\\t\\t\\t\\t\\tif c>p_max:\\n\\t\\t\\t\\t\\t\\tp_max=c\\n\\t\\t\\t\\t\\t\\tans = ro\\n\\n\\t\\t\\twhile r>0:\\n\\t\\t\\t\\tro +=1\\n\\t\\t\\t\\tc=0\\n\\t\\t\\t\\tt += min(4,r)\\n\\t\\t\\t\\tr -= 4\\n\\t\\t\\t\\tc = t*boardingCost - ro*runningCost\\n\\t\\t\\t\\tif c>p_max:\\n\\t\\t\\t\\t\\tp_max= c\\n\\t\\t\\t\\t\\tans = ro\\n\\t\\t\\tif p_max==0:\\n\\t\\t\\t\\treturn -1\\n\\t\\t\\telse:\\n\\t\\t\\t\\treturn ans",
                "codeTag": "Python3"
            },
            {
                "id": 868824,
                "title": "greedy-javascript-straightforward",
                "content": "Not much to it. Just calculate the profit at each turn and keep track of which turn has the max profit.\\n\\n```\\nconst minOperationsMaxProfit = ( customers, boardingCost, runningCost ) => {\\n    let boarding, i = 0\\n    let sum = 0, waiting = 0\\n    let max = 1, turn = -1\\n\\n    while ( waiting || i < customers.length ) {\\n        waiting += customers[ i++ ] || 0\\n        boarding = Math.min( 4, waiting )\\n        \\n        sum += boardingCost * boarding - runningCost\\n        waiting -= boarding\\n\\n        if ( sum > max ) {\\n            max = sum\\n            turn = i\\n        }\\n    }\\n\\n    return turn\\n}\\n```\\n",
                "solutionTags": [
                    "JavaScript",
                    "Greedy"
                ],
                "code": "```\\nconst minOperationsMaxProfit = ( customers, boardingCost, runningCost ) => {\\n    let boarding, i = 0\\n    let sum = 0, waiting = 0\\n    let max = 1, turn = -1\\n\\n    while ( waiting || i < customers.length ) {\\n        waiting += customers[ i++ ] || 0\\n        boarding = Math.min( 4, waiting )\\n        \\n        sum += boardingCost * boarding - runningCost\\n        waiting -= boarding\\n\\n        if ( sum > max ) {\\n            max = sum\\n            turn = i\\n        }\\n    }\\n\\n    return turn\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 868668,
                "title": "java-solution-o-n-time-and-space-o-1",
                "content": "class Solution {\\n    public int minOperationsMaxProfit(int[] customers, int boardingCost, int runningCost) {\\n        int count=0,currentTotal = 0,total=0;\\n        int minMax = 0,currentProfit=0,profitCount=-1;\\n        int i=0;\\n        \\n        if(customers.length==0){\\n            profitCount=0;\\n        }\\n        \\n        do{\\n            count++;\\n            if(i<customers.length){\\n                currentTotal += customers[i];\\n                total += customers[i];\\n            }\\n            \\n            if(currentTotal>4){\\n                currentTotal -=4;\\n            }\\n            else{\\n                currentTotal = 0;\\n            }\\n            currentProfit = (((total-currentTotal)*boardingCost)-(count*runningCost));\\n            if(minMax< currentProfit){\\n                minMax = currentProfit;\\n                profitCount = count;\\n            }\\n            i++;\\n        }while(i<customers.length||currentTotal>0);\\n        \\n        \\n        return profitCount>=0?profitCount:-1;\\n    }\\n}",
                "solutionTags": [],
                "code": "class Solution {\\n    public int minOperationsMaxProfit(int[] customers, int boardingCost, int runningCost) {\\n        int count=0,currentTotal = 0,total=0;\\n        int minMax = 0,currentProfit=0,profitCount=-1;\\n        int i=0;\\n        \\n        if(customers.length==0){\\n            profitCount=0;\\n        }",
                "codeTag": "Java"
            },
            {
                "id": 868665,
                "title": "python-beats-100-time",
                "content": "```python\\nclass Solution:\\n    def minOperationsMaxProfit(self, customers: List[int], boardingCost: int, runningCost: int) -> int:\\n        ans , board , wait = 0 , 0 , 0\\n        mc, mv  , c = 0,0 , 0\\n        for cur in customers:\\n            c+=1# for counting in which time we are just rotating the wheel\\n            if cur >= 4 or cur + wait >=4:\\n                ans += 4* boardingCost - runningCost\\n                wait += cur - 4\\n            else:\\n                ans += (cur + wait) * boardingCost - runningCost\\n                wait = 0\\n            \\n            # for finding the maximum\\n            if ans > mv:    mv = ans;mc = c\\n        # if still wait is there means we will calculate the ans\\n        while wait > 0:\\n            c += 1\\n            if wait >= 4:\\n                ans += 4* boardingCost - runningCost\\n                \\n            else:\\n                ans += wait * boardingCost - runningCost\\n            wait -=4\\n            # for finding the maximum\\n            if ans > mv:    mv = ans;mc = c\\n        return mc if mc > 0 else -1\\n        \\n```",
                "solutionTags": [],
                "code": "```python\\nclass Solution:\\n    def minOperationsMaxProfit(self, customers: List[int], boardingCost: int, runningCost: int) -> int:\\n        ans , board , wait = 0 , 0 , 0\\n        mc, mv  , c = 0,0 , 0\\n        for cur in customers:\\n            c+=1# for counting in which time we are just rotating the wheel\\n            if cur >= 4 or cur + wait >=4:\\n                ans += 4* boardingCost - runningCost\\n                wait += cur - 4\\n            else:\\n                ans += (cur + wait) * boardingCost - runningCost\\n                wait = 0\\n            \\n            # for finding the maximum\\n            if ans > mv:    mv = ans;mc = c\\n        # if still wait is there means we will calculate the ans\\n        while wait > 0:\\n            c += 1\\n            if wait >= 4:\\n                ans += 4* boardingCost - runningCost\\n                \\n            else:\\n                ans += wait * boardingCost - runningCost\\n            wait -=4\\n            # for finding the maximum\\n            if ans > mv:    mv = ans;mc = c\\n        return mc if mc > 0 else -1\\n        \\n```",
                "codeTag": "Java"
            },
            {
                "id": 868457,
                "title": "java-beaating-100-solution-with-explaination",
                "content": "class Solution {\\n    public int minOperationsMaxProfit(int[] customers, int boardingCost, int runningCost) {\\n\\t\\n       int wait=0,customer=0,mx=Integer.MIN_VALUE,currentProfit=0,round=-1;\\n        for(int i=1;i<=customers.length||wait>0;i++){\\n            wait=wait+ (i-1 < customers.length ? customers[i-1]:0);//if greater than length than no increment in wait as queue of customer ends\\n   \\n            if(wait>=4){  //the logic of customer waiting\\n             customer+=4;\\n                wait-=4;\\n            }else{                 //add current wait to customer \\n                customer+=wait;\\n                wait=0;\\n            }\\n            currentProfit = customer*boardingCost - i*runningCost; //cuurrent profit\\n            if(mx<currentProfit){ \\n                mx=currentProfit;\\n                round=i;      //round is the iteration times i.e the index or number of iteration with highest profit\\n            }\\n        }\\n        return currentProfit > 0 ? round:-1; //for last testcase negative profit than return -1\\n  \\n  }\\n}",
                "solutionTags": [],
                "code": "class Solution {\\n    public int minOperationsMaxProfit(int[] customers, int boardingCost, int runningCost) {\\n\\t\\n       int wait=0,customer=0,mx=Integer.MIN_VALUE,currentProfit=0,round=-1;\\n        for(int i=1;i<=customers.length||wait>0;i++){\\n            wait=wait+ (i-1 < customers.length ? customers[i-1]:0);//if greater than length than no increment in wait as queue of customer ends\\n   \\n            if(wait>=4){  //the logic of customer waiting\\n             customer+=4;\\n                wait-=4;\\n            }",
                "codeTag": "Java"
            },
            {
                "id": 868370,
                "title": "c-o-n-simple-code",
                "content": "```\\n int minOperationsMaxProfit(vector<int>& customers, int boardingCost, int runningCost) {\\n        vector<int> lookup;\\n        int wait_people = 0;\\n        int next_batch = 0;\\n        int max_people_to_serve = 4;\\n        for (int i = 0 ; i < customers.size(); i++){\\n            wait_people  += customers[i];              \\n           if (wait_people >= max_people_to_serve) {\\n                lookup.push_back(max_people_to_serve);\\n                wait_people = wait_people - max_people_to_serve;\\n                cout <<  wait_people << endl;            \\n            }         \\n        }\\n         while (wait_people > 0) {\\n          if (wait_people >= max_people_to_serve) lookup.push_back(max_people_to_serve);\\n          else lookup.push_back(wait_people);  \\n          wait_people -= max_people_to_serve;\\n        }\\n        if (wait_people > 0) lookup.push_back(wait_people);\\n        int profit =0, max_profit = 0;\\n        if  (wait_people > 0)\\n            lookup.push_back(wait_people);\\n        int rounds = 0;\\n        for ( auto v : lookup)  {\\n            cout << v << \" \"; \\n             profit += v * boardingCost - 1 * runningCost;\\n            cout << profit  << \" \" << max_profit;\\n            if (profit >  max_profit) {\\n              max_profit = profit;\\n              ++rounds;\\n            }\\n        }\\n        cout << \"profit \" << max_profit << \" \" << rounds  ;\\n        return max_profit > 0 ? rounds : -1;\\n    }\\n```",
                "solutionTags": [],
                "code": "```\\n int minOperationsMaxProfit(vector<int>& customers, int boardingCost, int runningCost) {\\n        vector<int> lookup;\\n        int wait_people = 0;\\n        int next_batch = 0;\\n        int max_people_to_serve = 4;\\n        for (int i = 0 ; i < customers.size(); i++){\\n            wait_people  += customers[i];              \\n           if (wait_people >= max_people_to_serve) {\\n                lookup.push_back(max_people_to_serve);\\n                wait_people = wait_people - max_people_to_serve;\\n                cout <<  wait_people << endl;            \\n            }         \\n        }\\n         while (wait_people > 0) {\\n          if (wait_people >= max_people_to_serve) lookup.push_back(max_people_to_serve);\\n          else lookup.push_back(wait_people);  \\n          wait_people -= max_people_to_serve;\\n        }\\n        if (wait_people > 0) lookup.push_back(wait_people);\\n        int profit =0, max_profit = 0;\\n        if  (wait_people > 0)\\n            lookup.push_back(wait_people);\\n        int rounds = 0;\\n        for ( auto v : lookup)  {\\n            cout << v << \" \"; \\n             profit += v * boardingCost - 1 * runningCost;\\n            cout << profit  << \" \" << max_profit;\\n            if (profit >  max_profit) {\\n              max_profit = profit;\\n              ++rounds;\\n            }\\n        }\\n        cout << \"profit \" << max_profit << \" \" << rounds  ;\\n        return max_profit > 0 ? rounds : -1;\\n    }\\n```",
                "codeTag": "C++"
            },
            {
                "id": 868253,
                "title": "c-simulation",
                "content": "```\\nclass Solution {\\npublic:\\n    int minOperationsMaxProfit(vector<int>& customers, int boardingCost, int runningCost) {\\n        int rot = -2, mxm = 0, waiting = 0, n = customers.size(), profit = 0, i = 0;\\n        while (waiting > 0 or i < n) {\\n            if (i < n) \\n                waiting += customers[i];\\n            profit = profit + min(4, waiting) * boardingCost - runningCost;\\n            if (profit > mxm) {\\n                mxm = profit;\\n                rot = i;\\n            }\\n            waiting -= min(4, waiting);\\n            ++i;\\n        }\\n        return rot+1;\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    int minOperationsMaxProfit(vector<int>& customers, int boardingCost, int runningCost) {\\n        int rot = -2, mxm = 0, waiting = 0, n = customers.size(), profit = 0, i = 0;\\n        while (waiting > 0 or i < n) {\\n            if (i < n) \\n                waiting += customers[i];\\n            profit = profit + min(4, waiting) * boardingCost - runningCost;\\n            if (profit > mxm) {\\n                mxm = profit;\\n                rot = i;\\n            }\\n            waiting -= min(4, waiting);\\n            ++i;\\n        }\\n        return rot+1;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 868052,
                "title": "video-solution",
                "content": "https://youtu.be/ynxGGIoVY3g",
                "solutionTags": [],
                "code": "",
                "codeTag": "Unknown"
            },
            {
                "id": 868007,
                "title": "python-time-o-n-and-space-o-1",
                "content": "```\\nclass Solution:\\n    def minOperationsMaxProfit(self, customers: List[int], boardingCost: int, runningCost: int) -> int:\\n        \\n        rotations = 0\\n        profit, max_profit = 0, 0\\n        res = -1\\n        \\n        def xreport(boarded:int):\\n            nonlocal profit, rotations, max_profit, res\\n            profit +=boarded*boardingCost - runningCost\\n            rotations +=1\\n            if profit>max_profit:\\n                max_profit = profit\\n                res = rotations\\n            #print(f\\'p: {profit}, mprofit: {max_profit}, rotations:{rotations}\\')\\n            return\\n        \\n        for i in range(len(customers)-1):\\n            if customers[i] >4:\\n                customers[i+1]+=customers[i]-4\\n                customers[i] =4\\n            \\n            xreport(customers[i])\\n        \\n            \\n        waiting = customers[-1]\\n        while waiting>0:\\n            if waiting>4:\\n                waiting-=4\\n                xreport(4)\\n            else:\\n                xreport(waiting)\\n                waiting = 0\\n            \\n        return res\\n\\t\\t",
                "solutionTags": [
                    "Python3"
                ],
                "code": "class Solution:\\n    def minOperationsMaxProfit(self, customers: List[int], boardingCost: int, runningCost: int) -> int:\\n        \\n        rotations = 0\\n        profit, max_profit = 0, 0\\n        res = -1\\n        \\n        def xreport(boarded:int):\\n            nonlocal profit, rotations, max_profit, res\\n            profit +=boarded*boardingCost - runningCost\\n            rotations +=1\\n            if profit>max_profit:\\n                max_profit = profit\\n                res = rotations\\n            #print(f\\'p: {profit}",
                "codeTag": "Java"
            },
            {
                "id": 867879,
                "title": "1599-maximum-profit-centennial-wheel-bug-in-example-3",
                "content": "Example 3 says:\\n\\nInput: customers = [3,4,0,5,1], boardingCost = 1, runningCost = 92\\nOutput: -1\\nExplanation:\\n1. 3 customers arrive, 3 board and 0 wait, the wheel rotates. Current profit is 3 * $1 - 1 * $92 = -$89.\\n2. 4 customers arrive, 4 board and 0 wait, the wheel rotates. Current profit is 7 * $1 - 2 * $92 = -$177.\\n3. 0 customers arrive, 0 board and 0 wait, the wheel rotates. Current profit is 7 * $1 - 3 * $92 = -$269.\\n*4. 5 customers arrive, 4 board and 1 waits, the wheel rotates. Current profit is 12  $1 - 4  $92 = -$356.*\\n5. 1 customer arrives, 2 board and 0 wait, the wheel rotates. Current profit is 13 * $1 - 5 * $92 = -$447.\\nThe profit was never positive, so return -1.\\n\\n----\\nAt time 4 it says \"4 board and 1 waits\" which is correct.  But it shows riders boarded jump from 7 at time 3, to 12 at time 4.  You can\\'t board 5 riders, max is 4.  Line 4 above should say:\\n\\n\"4. 5 customers arrive, 4 board and 1 waits, the wheel rotates. Current profit is 11  $1 - 4  $92 = -$357.\"\\n\\nI mention this because the bug/error in the example description cost me about 10 minutes to figure out it was wrong, during Weekly Contest 208 on 9/26/2020.  So I lost 10 minutes time/placement... (whining)",
                "solutionTags": [],
                "code": "Example 3 says:\\n\\nInput: customers = [3,4,0,5,1], boardingCost = 1, runningCost = 92\\nOutput: -1\\nExplanation:\\n1. 3 customers arrive, 3 board and 0 wait, the wheel rotates. Current profit is 3 * $1 - 1 * $92 = -$89.\\n2. 4 customers arrive, 4 board and 0 wait, the wheel rotates. Current profit is 7 * $1 - 2 * $92 = -$177.\\n3. 0 customers arrive, 0 board and 0 wait, the wheel rotates. Current profit is 7 * $1 - 3 * $92 = -$269.\\n*4. 5 customers arrive, 4 board and 1 waits, the wheel rotates. Current profit is 12  $1 - 4  $92 = -$356.*\\n5. 1 customer arrives, 2 board and 0 wait, the wheel rotates. Current profit is 13 * $1 - 5 * $92 = -$447.\\nThe profit was never positive, so return -1.\\n\\n----\\nAt time 4 it says \"4 board and 1 waits\" which is correct.  But it shows riders boarded jump from 7 at time 3, to 12 at time 4.  You can\\'t board 5 riders, max is 4.  Line 4 above should say:\\n\\n\"4. 5 customers arrive, 4 board and 1 waits, the wheel rotates. Current profit is 11  $1 - 4  $92 = -$357.\"\\n\\nI mention this because the bug/error in the example description cost me about 10 minutes to figure out it was wrong, during Weekly Contest 208 on 9/26/2020.  So I lost 10 minutes time/placement... (whining)",
                "codeTag": "Unknown"
            },
            {
                "id": 867855,
                "title": "c-o-n-easy-to-understand",
                "content": "```\\n/*\\n    Calculate running cost accumulated. Return max.\\n*/\\n\\npublic class Solution {\\n    public int MinOperationsMaxProfit(int[] customers, int boardingCost, int runningCost) {\\n        int accumulated = customers[0];\\n        int profit = 0, maxProfit = Int32.MinValue, index = -1, i = 0;  \\n        while ( accumulated > 0 || i < customers.Length ) {      \\n            int toBoard = accumulated >= 4? 4: accumulated;\\n            accumulated -= toBoard;\\n            \\n            profit+= toBoard * boardingCost - runningCost;\\n            if (profit > maxProfit && profit > 0){\\n                maxProfit = profit;\\n                index = i + 1;\\n            }\\n            \\n            i++;\\n            \\n            accumulated += i < customers.Length? customers[i] : 0; \\n        }\\n        \\n        return index;      \\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\n/*\\n    Calculate running cost accumulated. Return max.\\n*/\\n\\npublic class Solution {\\n    public int MinOperationsMaxProfit(int[] customers, int boardingCost, int runningCost) {\\n        int accumulated = customers[0];\\n        int profit = 0, maxProfit = Int32.MinValue, index = -1, i = 0;  \\n        while ( accumulated > 0 || i < customers.Length ) {      \\n            int toBoard = accumulated >= 4? 4: accumulated;\\n            accumulated -= toBoard;\\n            \\n            profit+= toBoard * boardingCost - runningCost;\\n            if (profit > maxProfit && profit > 0){\\n                maxProfit = profit;\\n                index = i + 1;\\n            }\\n            \\n            i++;\\n            \\n            accumulated += i < customers.Length? customers[i] : 0; \\n        }\\n        \\n        return index;      \\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 867836,
                "title": "python3-simulation",
                "content": "\\n```\\nclass Solution:\\n    def minOperationsMaxProfit(self, customers: List[int], boardingCost: int, runningCost: int) -> int:\\n        if not customers: return 0\\n        rem = 0 # remaining customers waiting for onboard\\n        customers = customers[::-1] # reverse it for popping out easily\\n        t = 1\\n        onboard = 0\\n        ans = -1\\n        maxa = 0\\n        while customers or rem:\\n            if customers:\\n                rem += customers.pop()\\n            onboard += min(rem, 4)\\n            cur = onboard * boardingCost - runningCost * t\\n            if cur > maxa:\\n                maxa = cur\\n                ans = t\\n                \\n            t += 1\\n            rem -= min(rem, 4)\\n        return ans\\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def minOperationsMaxProfit(self, customers: List[int], boardingCost: int, runningCost: int) -> int:\\n        if not customers: return 0\\n        rem = 0 # remaining customers waiting for onboard\\n        customers = customers[::-1] # reverse it for popping out easily\\n        t = 1\\n        onboard = 0\\n        ans = -1\\n        maxa = 0\\n        while customers or rem:\\n            if customers:\\n                rem += customers.pop()\\n            onboard += min(rem, 4)\\n            cur = onboard * boardingCost - runningCost * t\\n            if cur > maxa:\\n                maxa = cur\\n                ans = t\\n                \\n            t += 1\\n            rem -= min(rem, 4)\\n        return ans\\n```",
                "codeTag": "Java"
            },
            {
                "id": 867730,
                "title": "cpp-soln",
                "content": "class Solution {\\npublic:\\n    int minOperationsMaxProfit(vector<int>& a, int board, int run) {\\n        int ind=0;\\n        int wait=0,profit=0,max=INT_MIN,best=0;\\n        for(int i=0;i<a.size();i++){\\n           int on = min(wait+a[i],4);\\n            \\n            wait += a[i]-on;\\n            \\n            profit += on*board-run;\\n            if(profit>max){\\n                max = profit;\\n                best = ind+1;\\n            }\\n            ind++;\\n        }\\n        while(wait>0){\\n            int on = min(wait,4);\\n            wait = wait-on;\\n            \\n            profit += on*board-run;\\n            if(profit>max){\\n                max = profit;\\n                best = ind+1;\\n            }\\n            ind++;\\n        }\\n        if(profit<0)\\n            return -1;\\n        return best;\\n    }\\n};",
                "solutionTags": [],
                "code": "class Solution {\\npublic:\\n    int minOperationsMaxProfit(vector<int>& a, int board, int run) {\\n        int ind=0;\\n        int wait=0,profit=0,max=INT_MIN,best=0;\\n        for(int i=0;i<a.size();i++){\\n           int on = min(wait+a[i],4);\\n            \\n            wait += a[i]-on;\\n            \\n            profit += on*board-run;\\n            if(profit>max){\\n                max = profit;\\n                best = ind+1;\\n            }",
                "codeTag": "Java"
            },
            {
                "id": 867667,
                "title": "simulation-in-python-o-n",
                "content": "The idea of the solution is to simulate what is described in the \"lengthy\" desription of the problem. we try to board as much as cusotmers in each turn if it is more than 4 then we add them to waiting customers and in each tuen keep track of profit. The edge case was when the first element in the customers is zero.\\n\\n```class Solution(object):\\n    def minOperationsMaxProfit(self, customers, boardingCost, runningCost):\\n        \"\"\"\\n        :type customers: List[int]\\n        :type boardingCost: int\\n        :type runningCost: int\\n        :rtype: int\\n        \"\"\"\\n        if runningCost >= 4 * boardingCost:\\n            return -1\\n        profit = 0\\n        max_profit = float(\\'-inf\\')\\n        wc = customers[0]\\n        i = 1\\n        rot = 1\\n        max_rot = 0\\n        print len(customers)\\n        while  wc > 0 or i < len(customers):\\n            \\n                if wc >= 4:\\n                    #print wc\\n                    wc -=  4 \\n                    profit += 4 * boardingCost\\n               elif wc < 4:\\n                    bc = wc\\n                    wc = 0\\n                    profit +=  bc * boardingCost\\n                profit -= runningCost\\n                prev = max_profit\\n                max_profit = max(profit, max_profit)\\n                if max_profit != prev:\\n                    max_rot = rot\\n                if i < len(customers):\\n                    wc += customers[i]\\n                    i+=1\\n                    \\n                rot +=1\\n                \\n        if max_profit > 0:\\n            return max_rot\\n        else:\\n            return -1\\n```",
                "solutionTags": [],
                "code": "```class Solution(object):\\n    def minOperationsMaxProfit(self, customers, boardingCost, runningCost):\\n        \"\"\"\\n        :type customers: List[int]\\n        :type boardingCost: int\\n        :type runningCost: int\\n        :rtype: int\\n        \"\"\"\\n        if runningCost >= 4 * boardingCost:\\n            return -1\\n        profit = 0\\n        max_profit = float(\\'-inf\\')\\n        wc = customers[0]\\n        i = 1\\n        rot = 1\\n        max_rot = 0\\n        print len(customers)\\n        while  wc > 0 or i < len(customers):\\n            \\n                if wc >= 4:\\n                    #print wc\\n                    wc -=  4 \\n                    profit += 4 * boardingCost\\n               elif wc < 4:\\n                    bc = wc\\n                    wc = 0\\n                    profit +=  bc * boardingCost\\n                profit -= runningCost\\n                prev = max_profit\\n                max_profit = max(profit, max_profit)\\n                if max_profit != prev:\\n                    max_rot = rot\\n                if i < len(customers):\\n                    wc += customers[i]\\n                    i+=1\\n                    \\n                rot +=1\\n                \\n        if max_profit > 0:\\n            return max_rot\\n        else:\\n            return -1\\n```",
                "codeTag": "Java"
            },
            {
                "id": 867640,
                "title": "java-another-stupid-problem",
                "content": "```\\nclass Solution {\\n    public int minOperationsMaxProfit(int[] customers, int boardingCost, int runningCost) {\\n        int profit = 0;\\n        int wait = 0;\\n        int rot = 0;\\n        int max = Integer.MIN_VALUE;\\n        int res = -1;\\n        while (rot < customers.length) {\\n            wait += customers[rot];\\n            profit += Math.min(4, wait) * boardingCost - runningCost;\\n            rot++;\\n            if (profit > max) {\\n                max = profit;\\n                res = rot;\\n            }\\n            wait -= Math.min(4, wait);\\n        }\\n        while (wait > 0) {\\n            profit += Math.min(4, wait) * boardingCost - runningCost;\\n            wait -= Math.min(4, wait);\\n            rot++;\\n            if (profit > max) {\\n                max = profit;\\n                res = rot;\\n            }\\n        }\\n        if (max < 0) {\\n            return -1;\\n        }\\n        return res;\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    public int minOperationsMaxProfit(int[] customers, int boardingCost, int runningCost) {\\n        int profit = 0;\\n        int wait = 0;\\n        int rot = 0;\\n        int max = Integer.MIN_VALUE;\\n        int res = -1;\\n        while (rot < customers.length) {\\n            wait += customers[rot];\\n            profit += Math.min(4, wait) * boardingCost - runningCost;\\n            rot++;\\n            if (profit > max) {\\n                max = profit;\\n                res = rot;\\n            }\\n            wait -= Math.min(4, wait);\\n        }\\n        while (wait > 0) {\\n            profit += Math.min(4, wait) * boardingCost - runningCost;\\n            wait -= Math.min(4, wait);\\n            rot++;\\n            if (profit > max) {\\n                max = profit;\\n                res = rot;\\n            }\\n        }\\n        if (max < 0) {\\n            return -1;\\n        }\\n        return res;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 867635,
                "title": "java-o-n-solution",
                "content": "```\\nclass Solution {\\n    public int minOperationsMaxProfit(int[] customers, int boardingCost, int runningCost) {\\n        int max = Integer.MIN_VALUE;\\n        int count=0, maxcount=0;\\n        int remCustomers =0, currCost = 0;\\n        for(int i=0; i< customers.length; i++){\\n            remCustomers += customers[i];\\n            if(remCustomers >4){\\n                remCustomers -=4;\\n                currCost += 4* boardingCost - runningCost;\\n            }else{\\n                currCost += remCustomers*boardingCost - runningCost;\\n                remCustomers = 0;\\n            }\\n            count++;\\n            if(currCost > max){\\n                max = currCost;\\n                maxcount = count;\\n            }\\n        }\\n        while(remCustomers > 0){\\n            if(remCustomers >4){\\n                remCustomers -=4;\\n                currCost += 4* boardingCost - runningCost;\\n            }else{\\n                currCost += remCustomers*boardingCost - runningCost;\\n                remCustomers = 0;\\n            }\\n            count++;\\n            if(currCost > max){\\n                max = currCost;\\n                maxcount = count;\\n            }\\n        }\\n        return max>0?maxcount:-1;\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    public int minOperationsMaxProfit(int[] customers, int boardingCost, int runningCost) {\\n        int max = Integer.MIN_VALUE;\\n        int count=0, maxcount=0;\\n        int remCustomers =0, currCost = 0;\\n        for(int i=0; i< customers.length; i++){\\n            remCustomers += customers[i];\\n            if(remCustomers >4){\\n                remCustomers -=4;\\n                currCost += 4* boardingCost - runningCost;\\n            }else{\\n                currCost += remCustomers*boardingCost - runningCost;\\n                remCustomers = 0;\\n            }\\n            count++;\\n            if(currCost > max){\\n                max = currCost;\\n                maxcount = count;\\n            }\\n        }\\n        while(remCustomers > 0){\\n            if(remCustomers >4){\\n                remCustomers -=4;\\n                currCost += 4* boardingCost - runningCost;\\n            }else{\\n                currCost += remCustomers*boardingCost - runningCost;\\n                remCustomers = 0;\\n            }\\n            count++;\\n            if(currCost > max){\\n                max = currCost;\\n                maxcount = count;\\n            }\\n        }\\n        return max>0?maxcount:-1;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 867560,
                "title": "swift-o-n",
                "content": "```\\nclass Solution {\\n    func minOperationsMaxProfit(_ customers: [Int], _ boardingCost: Int, _ runningCost: Int) -> Int {\\n        var maxProfit = 0\\n        var maxRotation = 0\\n        var waitingCustomers = 0\\n        var profit = 0\\n        var rotation = 0\\n        \\n        for _customers in customers{\\n            waitingCustomers += _customers\\n            helper(&waitingCustomers, &maxProfit, &maxRotation, &profit, &rotation, boardingCost, runningCost)\\n        }\\n        \\n        \\n        while waitingCustomers > 0{\\n            helper(&waitingCustomers, &maxProfit, &maxRotation, &profit, &rotation, boardingCost, runningCost)\\n        }\\n        \\n        return maxRotation > 0 ? maxRotation : -1\\n    }\\n    \\n    private func helper(_ waitingCustomers: inout Int, _ maxProfit: inout Int, _ maxRotation: inout Int, _ profit: inout Int, _ rotation: inout Int, _ boardingCost: Int, _ runningCost: Int){\\n        let onboardingCustomers = min(waitingCustomers, 4)\\n        waitingCustomers -= onboardingCustomers            \\n        profit += onboardingCustomers * boardingCost - runningCost\\n        rotation += 1\\n        if maxProfit < profit{\\n            maxProfit = profit\\n            maxRotation = rotation\\n        }\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    func minOperationsMaxProfit(_ customers: [Int], _ boardingCost: Int, _ runningCost: Int) -> Int {\\n        var maxProfit = 0\\n        var maxRotation = 0\\n        var waitingCustomers = 0\\n        var profit = 0\\n        var rotation = 0\\n        \\n        for _customers in customers{\\n            waitingCustomers += _customers\\n            helper(&waitingCustomers, &maxProfit, &maxRotation, &profit, &rotation, boardingCost, runningCost)\\n        }\\n        \\n        \\n        while waitingCustomers > 0{\\n            helper(&waitingCustomers, &maxProfit, &maxRotation, &profit, &rotation, boardingCost, runningCost)\\n        }\\n        \\n        return maxRotation > 0 ? maxRotation : -1\\n    }\\n    \\n    private func helper(_ waitingCustomers: inout Int, _ maxProfit: inout Int, _ maxRotation: inout Int, _ profit: inout Int, _ rotation: inout Int, _ boardingCost: Int, _ runningCost: Int){\\n        let onboardingCustomers = min(waitingCustomers, 4)\\n        waitingCustomers -= onboardingCustomers            \\n        profit += onboardingCustomers * boardingCost - runningCost\\n        rotation += 1\\n        if maxProfit < profit{\\n            maxProfit = profit\\n            maxRotation = rotation\\n        }\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 867552,
                "title": "simple-c-solution",
                "content": "```\\nclass Solution {\\npublic:\\n    int minOperationsMaxProfit(vector<int>& customers, int boardingCost, int runningCost) {\\n        int cost=0,time=-1,curr=0;\\n        int count=0;\\n        int n=customers.size(),i=0;\\n        int cust=0;\\n        do{\\n            //curr++;\\n            if(i<n)\\n                count+=customers[i];\\n            i++;\\n            if(count>=4){\\n                cust+=4;\\n                count-=4;\\n            }\\n            else if(count>0 && count<4){\\n                cust+=count;\\n                count=0;\\n            }\\n            cost=boardingCost*cust-runningCost*i;\\n            \\n            if(curr<cost){\\n                curr=cost;\\n                time=i;\\n            }\\n            //cout<<cost<<\" \";\\n            \\n        } while(count>0 || i<n);\\n        return time;\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    int minOperationsMaxProfit(vector<int>& customers, int boardingCost, int runningCost) {\\n        int cost=0,time=-1,curr=0;\\n        int count=0;\\n        int n=customers.size(),i=0;\\n        int cust=0;\\n        do{\\n            //curr++;\\n            if(i<n)\\n                count+=customers[i];\\n            i++;\\n            if(count>=4){\\n                cust+=4;\\n                count-=4;\\n            }\\n            else if(count>0 && count<4){\\n                cust+=count;\\n                count=0;\\n            }\\n            cost=boardingCost*cust-runningCost*i;\\n            \\n            if(curr<cost){\\n                curr=cost;\\n                time=i;\\n            }\\n            //cout<<cost<<\" \";\\n            \\n        } while(count>0 || i<n);\\n        return time;\\n    }\\n};\\n```",
                "codeTag": "C++"
            },
            {
                "id": 867513,
                "title": "java-simple-o-n-solution-sequential-processing-input",
                "content": "```\\n\\nclass Solution {\\n    public int minOperationsMaxProfit(int[] customers, int boardingCost, int runningCost) {\\n        int ans = 0; \\n        int moves = 1;\\n        int balance = 0;\\n        int max = 0;\\n        int p = 0;\\n        for(int i=0; i< customers.length; i++){\\n            balance += customers[i];\\n            int px = Math.min(balance, 4);\\n            balance = balance - px;\\n            p+=px;\\n            int curr =  (p*boardingCost) - runningCost*moves;\\n            if(Math.abs(max) < Math.abs(curr)){\\n                max  = curr;\\n                ans = moves;\\n            }\\n            moves++;\\n        }\\n        while(balance > 0){\\n            int py = Math.min(balance, 4);\\n            balance = balance - py;\\n            p += py;\\n            int c = (p*boardingCost) - runningCost*moves;\\n            if(Math.abs(max) < Math.abs(c)){\\n                max  = c;\\n                ans = moves;\\n            }\\n            moves++;\\n        }\\n        return max >0? ans:-1;\\n    }\\n}\\n\\n```",
                "solutionTags": [],
                "code": "```\\n\\nclass Solution {\\n    public int minOperationsMaxProfit(int[] customers, int boardingCost, int runningCost) {\\n        int ans = 0; \\n        int moves = 1;\\n        int balance = 0;\\n        int max = 0;\\n        int p = 0;\\n        for(int i=0; i< customers.length; i++){\\n            balance += customers[i];\\n            int px = Math.min(balance, 4);\\n            balance = balance - px;\\n            p+=px;\\n            int curr =  (p*boardingCost) - runningCost*moves;\\n            if(Math.abs(max) < Math.abs(curr)){\\n                max  = curr;\\n                ans = moves;\\n            }\\n            moves++;\\n        }\\n        while(balance > 0){\\n            int py = Math.min(balance, 4);\\n            balance = balance - py;\\n            p += py;\\n            int c = (p*boardingCost) - runningCost*moves;\\n            if(Math.abs(max) < Math.abs(c)){\\n                max  = c;\\n                ans = moves;\\n            }\\n            moves++;\\n        }\\n        return max >0? ans:-1;\\n    }\\n}\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 867470,
                "title": "java-solution",
                "content": "```\\nclass Solution {\\n    public int minOperationsMaxProfit(int[] customers, int boardingCost, int runningCost) {\\n        int waiting = 0;\\n        int count = 0;\\n        int profit = 0;\\n        int max = -1;\\n        int maxCount = 0;\\n        for(int i : customers){\\n           waiting += i;\\n           int val = waiting>4? 4:waiting;\\n           waiting = val>4? waiting-4:waiting-val;\\n           count++;\\n           profit = val>0?profit+(val*boardingCost - runningCost): profit - runningCost;\\n            if(profit>max){\\n                max = profit;\\n                maxCount = count;\\n            }\\n        }\\n        \\n        while(waiting>0){\\n            int val = waiting>4? 4:waiting;\\n           waiting = val>4? waiting-4:waiting-val;\\n           count++;\\n           profit = val>0?profit+(val*boardingCost - runningCost): profit - runningCost;\\n             if(profit>max){\\n                max = profit;\\n                maxCount = count;\\n            }\\n        }\\n        \\n        if(max>0){\\n            return maxCount;\\n        }else{\\n            return -1;\\n        }\\n    }\\n}``\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    public int minOperationsMaxProfit(int[] customers, int boardingCost, int runningCost) {\\n        int waiting = 0;\\n        int count = 0;\\n        int profit = 0;\\n        int max = -1;\\n        int maxCount = 0;\\n        for(int i : customers){\\n           waiting += i;\\n           int val = waiting>4? 4:waiting;\\n           waiting = val>4? waiting-4:waiting-val;\\n           count++;\\n           profit = val>0?profit+(val*boardingCost - runningCost): profit - runningCost;\\n            if(profit>max){\\n                max = profit;\\n                maxCount = count;\\n            }\\n        }\\n        \\n        while(waiting>0){\\n            int val = waiting>4? 4:waiting;\\n           waiting = val>4? waiting-4:waiting-val;\\n           count++;\\n           profit = val>0?profit+(val*boardingCost - runningCost): profit - runningCost;\\n             if(profit>max){\\n                max = profit;\\n                maxCount = count;\\n            }\\n        }\\n        \\n        if(max>0){\\n            return maxCount;\\n        }else{\\n            return -1;\\n        }\\n    }\\n}``\\n```",
                "codeTag": "Java"
            },
            {
                "id": 867440,
                "title": "o-n-greedy-implementation",
                "content": "```\\nclass Solution {\\npublic:\\n    int minOperationsMaxProfit(vector<int>& customers, int boardingCost, int runningCost) {\\n        int profit = 0, k = 0, n = customers.size();\\n        \\n        if(n < 1) {\\n            return -1;\\n        }\\n        \\n        for(int i = 0; i < n; i++) {\\n            if(i) {\\n                customers[i] += max(0, customers[i-1] - 4);\\n            }\\n            profit += min(4, customers[i]) * boardingCost - runningCost;\\n        }\\n        \\n        int c = max(0, customers.back() - 4);\\n        profit += (4 * boardingCost - runningCost) * (c / 4);\\n        \\n        if(c % 4 * boardingCost - runningCost > 0) {\\n            n++;\\n        }\\n        \\n        if(profit <= 0) {\\n            return -1;\\n        }\\n        \\n        return n + (c / 4);\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    int minOperationsMaxProfit(vector<int>& customers, int boardingCost, int runningCost) {\\n        int profit = 0, k = 0, n = customers.size();\\n        \\n        if(n < 1) {\\n            return -1;\\n        }\\n        \\n        for(int i = 0; i < n; i++) {\\n            if(i) {\\n                customers[i] += max(0, customers[i-1] - 4);\\n            }\\n            profit += min(4, customers[i]) * boardingCost - runningCost;\\n        }\\n        \\n        int c = max(0, customers.back() - 4);\\n        profit += (4 * boardingCost - runningCost) * (c / 4);\\n        \\n        if(c % 4 * boardingCost - runningCost > 0) {\\n            n++;\\n        }\\n        \\n        if(profit <= 0) {\\n            return -1;\\n        }\\n        \\n        return n + (c / 4);\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 867429,
                "title": "my-python-solution-using-simulation-to-solve-the-problem",
                "content": "Just using simulation to solve the problem, the code is a little bit tricky, since I find that we only the max_op_nb. There is no need to store all the money earned after each operation.\\n\\n````python\\nclass Solution:\\n    def minOperationsMaxProfit(self, customers: List[int], boardingCost: int, runningCost: int) -> int:\\n        # simulation of operations\\n        res = []\\n        remaining = 0\\n        nb_roation = 0\\n        total_boardingCost = 0\\n\\n        while customers:\\n            nb_roation += 1\\n            if (customers[0] + remaining) <= 4:\\n                total_boardingCost += boardingCost * (customers[0] + remaining)\\n                remaining = 0\\n            else:\\n                total_boardingCost += boardingCost * 4\\n                remaining += customers[0] - 4\\n            res.append( total_boardingCost - runningCost * nb_roation)\\n            customers.pop(0)\\n        \\n        # clear waiting lines\\n        while remaining:\\n            nb_roation += 1\\n            if remaining >= 4:\\n                total_boardingCost += boardingCost * 4\\n                remaining -= 4\\n            else:\\n                total_boardingCost += boardingCost * remaining\\n                remaining = 0\\n            res.append( total_boardingCost - runningCost * nb_roation)\\n        \\n        if max(res) < 0:\\n            return -1\\n        else:\\n            return res.index(max(res)) + 1\\n        \\n```",
                "solutionTags": [
                    "Python3",
                    "Simulation"
                ],
                "code": "````python\\nclass Solution:\\n    def minOperationsMaxProfit(self, customers: List[int], boardingCost: int, runningCost: int) -> int:\\n        # simulation of operations\\n        res = []\\n        remaining = 0\\n        nb_roation = 0\\n        total_boardingCost = 0\\n\\n        while customers:\\n            nb_roation += 1\\n            if (customers[0] + remaining) <= 4:\\n                total_boardingCost += boardingCost * (customers[0] + remaining)\\n                remaining = 0\\n            else:\\n                total_boardingCost += boardingCost * 4\\n                remaining += customers[0] - 4\\n            res.append( total_boardingCost - runningCost * nb_roation)\\n            customers.pop(0)\\n        \\n        # clear waiting lines\\n        while remaining:\\n            nb_roation += 1\\n            if remaining >= 4:\\n                total_boardingCost += boardingCost * 4\\n                remaining -= 4\\n            else:\\n                total_boardingCost += boardingCost * remaining\\n                remaining = 0\\n            res.append( total_boardingCost - runningCost * nb_roation)\\n        \\n        if max(res) < 0:\\n            return -1\\n        else:\\n            return res.index(max(res)) + 1\\n        \\n```",
                "codeTag": "Java"
            },
            {
                "id": 867385,
                "title": "c-easy-solution-in-o-n-with-constant-space",
                "content": "class Solution {\\npublic:\\n    int minOperationsMaxProfit(vector<int>& customers, int boardingCost, int runningCost) {\\n        int c=0,r=0,rem=0,p_max=-1,ans=0;\\n        for(int i=0;i<customers.size() || (rem);i++)\\n        {\\n            r++;\\n            if(i<customers.size())\\n                rem+=customers[i];\\n            else\\n                rem+=0;\\n            if(rem<4)\\n            {\\n                c+=rem;\\n                rem=0;\\n            }\\n            else\\n            {\\n                c+=4;\\n                rem-=4;\\n            }\\n            int p=c*boardingCost-r*runningCost;\\n            if(p>p_max)\\n            {\\n                p_max=p;\\n                ans=r;\\n            }\\n        }\\n        if(p_max<0)\\n            return -1;\\n        else\\n            return ans;\\n    }\\n};",
                "solutionTags": [],
                "code": "class Solution {\\npublic:\\n    int minOperationsMaxProfit(vector<int>& customers, int boardingCost, int runningCost) {\\n        int c=0,r=0,rem=0,p_max=-1,ans=0;\\n        for(int i=0;i<customers.size() || (rem);i++)\\n        {\\n            r++;\\n            if(i<customers.size())\\n                rem+=customers[i];\\n            else\\n                rem+=0;\\n            if(rem<4)\\n            {\\n                c+=rem;\\n                rem=0;\\n            }",
                "codeTag": "Java"
            },
            {
                "id": 867357,
                "title": "java-easy-to-understand",
                "content": "```\\npublic int minOperationsMaxProfit(int[] customers, int boardingCost, int runningCost) {\\n        \\n        int totalCustomerWaitingForBoarding = customers[0], totalCustomersBoarded = 0;\\n        int maxProfit = 0, profit = 0, res = 0;\\n        \\n        for(int shift = 1; shift < customers.length || totalCustomerWaitingForBoarding > 0 ; shift++ ){\\n            \\n            int customerBoarding = Math.min(4, totalCustomerWaitingForBoarding); \\n            totalCustomerWaitingForBoarding -= customerBoarding;\\n            totalCustomersBoarded += customerBoarding;\\n            \\n            profit = (totalCustomersBoarded * boardingCost) - (shift * runningCost); \\n            \\n            if (profit > maxProfit){  \\n                maxProfit = profit;   \\n                res = shift;   \\n            }\\n            \\n            if (shift < customers.length){ \\n                totalCustomerWaitingForBoarding += customers[shift];  \\n            }\\n        }\\n        return (maxProfit == 0) ? -1 : res;\\n    }",
                "solutionTags": [],
                "code": "```\\npublic int minOperationsMaxProfit(int[] customers, int boardingCost, int runningCost) {\\n        \\n        int totalCustomerWaitingForBoarding = customers[0], totalCustomersBoarded = 0;\\n        int maxProfit = 0, profit = 0, res = 0;\\n        \\n        for(int shift = 1; shift < customers.length || totalCustomerWaitingForBoarding > 0 ; shift++ ){\\n            \\n            int customerBoarding = Math.min(4, totalCustomerWaitingForBoarding); \\n            totalCustomerWaitingForBoarding -= customerBoarding;\\n            totalCustomersBoarded += customerBoarding;\\n            \\n            profit = (totalCustomersBoarded * boardingCost) - (shift * runningCost); \\n            \\n            if (profit > maxProfit){  \\n                maxProfit = profit;   \\n                res = shift;   \\n            }\\n            \\n            if (shift < customers.length){ \\n                totalCustomerWaitingForBoarding += customers[shift];  \\n            }\\n        }\\n        return (maxProfit == 0) ? -1 : res;\\n    }",
                "codeTag": "Unknown"
            },
            {
                "id": 867345,
                "title": "doubt-in-approaching",
                "content": "Just a question, if we should consider the rotating cost to let the customers go down as well",
                "solutionTags": [],
                "code": "",
                "codeTag": "Unknown"
            },
            {
                "id": 867324,
                "title": "java-solution-super-easy-to-understand",
                "content": "```\\nclass Solution {\\n    public int minOperationsMaxProfit(int[] customers, int boardingCost, int runningCost) {\\n        int remaning = 0;\\n        int maxProfit = 0;\\n        int maxRotation = 0;\\n        int rotation = 1;\\n        int current_people_in_wheel = 0;\\n        for(int i=0 ; i<customers.length ; i++){\\n           // int people_boarding_currently = 0;\\n           int profit = 0;\\n           int current_total = remaning + customers[i];\\n           if(current_total > 4){\\n              remaning = current_total - 4;\\n             current_people_in_wheel += 4;\\n            \\n           }\\n          else{\\n            remaning = 0;\\n            current_people_in_wheel += current_total;\\n          }\\n          profit = current_people_in_wheel*boardingCost - rotation*runningCost;\\n          if(profit > maxProfit){\\n            maxProfit = profit;\\n            maxRotation = rotation;\\n          }\\n          rotation++;\\n           \\n        }\\n        while(remaning != 0){\\n           int profit = 0;\\n          if(remaning > 4){\\n            current_people_in_wheel += 4;\\n            remaning -= 4;\\n          }\\n          else{\\n             current_people_in_wheel += remaning;\\n             remaning -= remaning;\\n          }\\n          profit = current_people_in_wheel*boardingCost - rotation*runningCost;\\n          if(profit > maxProfit){\\n            maxProfit = profit;\\n            maxRotation = rotation;\\n          }\\n          rotation++; \\n        }\\n      \\n        return maxProfit == 0?-1:maxRotation;\\n       \\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    public int minOperationsMaxProfit(int[] customers, int boardingCost, int runningCost) {\\n        int remaning = 0;\\n        int maxProfit = 0;\\n        int maxRotation = 0;\\n        int rotation = 1;\\n        int current_people_in_wheel = 0;\\n        for(int i=0 ; i<customers.length ; i++){\\n           // int people_boarding_currently = 0;\\n           int profit = 0;\\n           int current_total = remaning + customers[i];\\n           if(current_total > 4){\\n              remaning = current_total - 4;\\n             current_people_in_wheel += 4;\\n            \\n           }\\n          else{\\n            remaning = 0;\\n            current_people_in_wheel += current_total;\\n          }\\n          profit = current_people_in_wheel*boardingCost - rotation*runningCost;\\n          if(profit > maxProfit){\\n            maxProfit = profit;\\n            maxRotation = rotation;\\n          }\\n          rotation++;\\n           \\n        }\\n        while(remaning != 0){\\n           int profit = 0;\\n          if(remaning > 4){\\n            current_people_in_wheel += 4;\\n            remaning -= 4;\\n          }\\n          else{\\n             current_people_in_wheel += remaning;\\n             remaning -= remaning;\\n          }\\n          profit = current_people_in_wheel*boardingCost - rotation*runningCost;\\n          if(profit > maxProfit){\\n            maxProfit = profit;\\n            maxRotation = rotation;\\n          }\\n          rotation++; \\n        }\\n      \\n        return maxProfit == 0?-1:maxRotation;\\n       \\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 867313,
                "title": "super-easy-c-solution-100-faster-runtime-and-memory",
                "content": "```class Solution {\\npublic:\\n    int minOperationsMaxProfit(vector<int>& nums, int boardingCost, int runningCost) {\\n        if(nums.size()==0) return 0;\\n        \\n        int curr = 0;\\n        int count = 0;\\n        int inside = 0;\\n        int cost = 0;\\n        int pos = 1;\\n        int maxCost = -1;\\n        int hook = 0;\\n        \\n        for(int i =0;i<nums.size();i++){\\n            pos = i +1;\\n            curr += nums[i];\\n            if(curr>4){\\n                curr-=4;\\n                inside += 4;\\n            }\\n            else{\\n                \\n                inside += curr;\\n                curr = 0;\\n            }\\n            cost = inside*boardingCost - pos*runningCost;\\n            if(cost>maxCost){\\n                maxCost = cost;\\n                hook  = pos;\\n            }\\n        }\\n        \\n        while(curr>0){\\n            pos++;\\n            if(curr>4){\\n                curr-=4;\\n                inside += 4;\\n            }\\n            else{\\n                \\n                inside += curr;\\n                curr = 0;\\n            }\\n            cost = inside*boardingCost - pos * runningCost;\\n            if(cost>maxCost){\\n                maxCost = cost;\\n                hook = pos;\\n            }\\n        }\\n        if(hook == 0){\\n            return -1;\\n        }\\n        \\n        return hook;\\n        \\n        \\n    }\\n};",
                "solutionTags": [
                    "C"
                ],
                "code": "class Solution {\\npublic:\\n    int minOperationsMaxProfit(vector<int>& nums, int boardingCost, int runningCost) {\\n        if(nums.size()==0) return 0;\\n        \\n        int curr = 0;\\n        int count = 0;\\n        int inside = 0;\\n        int cost = 0;\\n        int pos = 1;\\n        int maxCost = -1;\\n        int hook = 0;\\n        \\n        for(int i =0;i<nums.size();i++){\\n            pos = i +1;\\n            curr += nums[i];\\n            if(curr>4){\\n                curr-=4;\\n                inside += 4;\\n            }",
                "codeTag": "Java"
            },
            {
                "id": 867306,
                "title": "java-solution-runtime-8-ms-memory-usage-49-3-mb",
                "content": "import java.io.*;\\n\\nclass Solution\\n{\\n    public int minOperationsMaxProfit(int[] customers, int boardingCost, int runningCost)\\n    {\\n\\n        int current_customers = 0;\\n        int waiting_customers = 0;\\n        int rotations = 0;\\n        int out = 0;\\n        int max_profit = -1;\\n\\n        for(int i = 0; i < customers.length; i++)\\n        {\\n            rotations += 1;\\n            if (i < customers.length)\\n                waiting_customers += customers[i];\\n            else\\n                i = 0;\\n            if (waiting_customers < 4)\\n            {\\n                current_customers += waiting_customers;\\n                waiting_customers = 0;\\n            }\\n            else\\n            {\\n                current_customers += 4;\\n                waiting_customers -= 4;\\n            }\\n            int profit = current_customers * boardingCost - rotations * runningCost;\\n            if (profit > max_profit)\\n            {\\n                max_profit = profit;\\n                out = rotations;\\n            }\\n        }\\n\\n        while(waiting_customers != 0)\\n        {\\n            rotations += 1;\\n            if (waiting_customers < 4)\\n            {\\n                current_customers += waiting_customers;\\n                waiting_customers = 0;\\n            }\\n            else\\n            {\\n                current_customers += 4;\\n                waiting_customers -= 4;\\n            }\\n            int profit = current_customers * boardingCost - rotations * runningCost;\\n            if (profit > max_profit)\\n            {\\n                max_profit = profit;\\n                out = rotations;\\n            }\\n        }\\n\\n        if (max_profit < 0)\\n            return -1;\\n        else\\n            return out;\\n\\n    }\\n}\\n",
                "solutionTags": [],
                "code": "class Solution\\n{\\n    public int minOperationsMaxProfit(int[] customers, int boardingCost, int runningCost)\\n    {\\n\\n        int current_customers = 0;\\n        int waiting_customers = 0;\\n        int rotations = 0;\\n        int out = 0;\\n        int max_profit = -1;\\n\\n        for(int i = 0; i < customers.length; i++)\\n        {\\n            rotations += 1;\\n            if (i < customers.length)\\n                waiting_customers += customers[i];\\n            else\\n                i = 0;\\n            if (waiting_customers < 4)\\n            {\\n                current_customers += waiting_customers;\\n                waiting_customers = 0;\\n            }",
                "codeTag": "Java"
            },
            {
                "id": 867276,
                "title": "c-simple-simulation-very-easy-to-understand",
                "content": "```\\nclass Solution {\\npublic:\\n    int minOperationsMaxProfit(vector<int>& customers, int boardingCost, int runningCost) {\\n        int n = customers.size(); if (n == 0) return -1;\\n        int waiting = 0, onboard  = 0, rotations = 0, maxcost = -1, i = 0, cost = 0, maxi;\\n        while (true) {\\n            if (i < n ) waiting += customers[i];\\n            int newonboarded = (waiting < 4)? waiting: 4;\\n            onboard += newonboarded;\\n            waiting -= newonboarded;\\n            i ++;\\n            cost = onboard * boardingCost - i * runningCost;\\n            if (cost > maxcost) {\\n                maxi = i;\\n                maxcost = cost;\\n            }\\n            if (waiting == 0 && i >= n) break;\\n        }\\n        return maxcost == -1 ? -1 : maxi;\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    int minOperationsMaxProfit(vector<int>& customers, int boardingCost, int runningCost) {\\n        int n = customers.size(); if (n == 0) return -1;\\n        int waiting = 0, onboard  = 0, rotations = 0, maxcost = -1, i = 0, cost = 0, maxi;\\n        while (true) {\\n            if (i < n ) waiting += customers[i];\\n            int newonboarded = (waiting < 4)? waiting: 4;\\n            onboard += newonboarded;\\n            waiting -= newonboarded;\\n            i ++;\\n            cost = onboard * boardingCost - i * runningCost;\\n            if (cost > maxcost) {\\n                maxi = i;\\n                maxcost = cost;\\n            }\\n            if (waiting == 0 && i >= n) break;\\n        }\\n        return maxcost == -1 ? -1 : maxi;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 867235,
                "title": "java-simple-o-m-time-solution",
                "content": "```\\nclass Solution {\\n    public int minOperationsMaxProfit(int[] customers, int boardingCost, int runningCost) {\\n        int mx = 0, answer = -1;\\n        int cur = 0;\\n        int waiting = 0;\\n        int index = 0;\\n        \\n        while (waiting > 0 || index < customers.length) {\\n            if (index < customers.length) {\\n                waiting += customers[index];\\n            }\\n            \\n            int boarding = Math.min(waiting, 4);\\n            waiting -= boarding;\\n            cur += boarding * boardingCost;\\n            cur -= runningCost;\\n            index++;\\n            \\n            if (cur > mx) {\\n                mx = cur;\\n                answer = index;\\n            }\\n        }\\n        \\n        \\n        return answer;\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    public int minOperationsMaxProfit(int[] customers, int boardingCost, int runningCost) {\\n        int mx = 0, answer = -1;\\n        int cur = 0;\\n        int waiting = 0;\\n        int index = 0;\\n        \\n        while (waiting > 0 || index < customers.length) {\\n            if (index < customers.length) {\\n                waiting += customers[index];\\n            }\\n            \\n            int boarding = Math.min(waiting, 4);\\n            waiting -= boarding;\\n            cur += boarding * boardingCost;\\n            cur -= runningCost;\\n            index++;\\n            \\n            if (cur > mx) {\\n                mx = cur;\\n                answer = index;\\n            }\\n        }\\n        \\n        \\n        return answer;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 867158,
                "title": "python-beautiful-easy-and-most-readable-o-n-solution-well-commented",
                "content": "```\\nclass Solution:\\n\\n    def minOperationsMaxProfit(self, customers: List[int], boardingCost: int, runningCost: int) -> int:\\n        \\n        CAPACITY = 4\\n        NO_PROFIT = -1\\n        \\n        numCustomersWaiting = 0\\n        totalCustomers = 0\\n\\n        currentProfit = NO_PROFIT\\n        previousProfit = NO_PROFIT\\n        maxProfit = NO_PROFIT\\n        \\n        numRotations = 0\\n        minRotationsForMaxProfit = NO_PROFIT\\n        \\n        while customers or numCustomersWaiting:\\n            \\n            # GET THE NEXT GROUP OF CUSTOMERS\\n            currentNumCustomers = customers.pop(0) if customers else 0\\n            \\n            # ADD TO TOTAL NUMBER OF CUSTOMERS WAITING\\n            numCustomersWaiting += currentNumCustomers \\n            \\n            # BOARD THE NEXT GROUP, 4 IS THE CAPACITY\\n            numCustomersBoarding = min(numCustomersWaiting, CAPACITY)\\n            \\n            # REMOVE BOARDING GROUP FROM NUMBER OF CUSTOMERS WAITING\\n            numCustomersWaiting = numCustomersWaiting - numCustomersBoarding\\n                       \\n            # KEEP TOTAL COUNT OF CUSTOMERS TO CALCULATE PROFIT\\n            totalCustomers += numCustomersBoarding\\n            \\n            # ROTATE THE CENTENNIAL WHEEL\\n            numRotations += 1\\n            \\n            # CALCULATE CURRENT PROFIT\\n            currentProfit = (totalCustomers * boardingCost) - (numRotations * runningCost)\\n            \\n            # MAINTAIN HIGHEST PROFIT NUMBER FOR RETURN\\n            if 0 < currentProfit > maxProfit:\\n                maxProfit = currentProfit\\n                minRotationsForMaxProfit = numRotations\\n            \\n            # SET UP FOR NEXT ITERATION\\n            previousProfit = currentProfit\\n            \\n        return minRotationsForMaxProfit\\n\\t\\t\\n```",
                "solutionTags": [
                    "Python",
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n\\n    def minOperationsMaxProfit(self, customers: List[int], boardingCost: int, runningCost: int) -> int:\\n        \\n        CAPACITY = 4\\n        NO_PROFIT = -1\\n        \\n        numCustomersWaiting = 0\\n        totalCustomers = 0\\n\\n        currentProfit = NO_PROFIT\\n        previousProfit = NO_PROFIT\\n        maxProfit = NO_PROFIT\\n        \\n        numRotations = 0\\n        minRotationsForMaxProfit = NO_PROFIT\\n        \\n        while customers or numCustomersWaiting:\\n            \\n            # GET THE NEXT GROUP OF CUSTOMERS\\n            currentNumCustomers = customers.pop(0) if customers else 0\\n            \\n            # ADD TO TOTAL NUMBER OF CUSTOMERS WAITING\\n            numCustomersWaiting += currentNumCustomers \\n            \\n            # BOARD THE NEXT GROUP, 4 IS THE CAPACITY\\n            numCustomersBoarding = min(numCustomersWaiting, CAPACITY)\\n            \\n            # REMOVE BOARDING GROUP FROM NUMBER OF CUSTOMERS WAITING\\n            numCustomersWaiting = numCustomersWaiting - numCustomersBoarding\\n                       \\n            # KEEP TOTAL COUNT OF CUSTOMERS TO CALCULATE PROFIT\\n            totalCustomers += numCustomersBoarding\\n            \\n            # ROTATE THE CENTENNIAL WHEEL\\n            numRotations += 1\\n            \\n            # CALCULATE CURRENT PROFIT\\n            currentProfit = (totalCustomers * boardingCost) - (numRotations * runningCost)\\n            \\n            # MAINTAIN HIGHEST PROFIT NUMBER FOR RETURN\\n            if 0 < currentProfit > maxProfit:\\n                maxProfit = currentProfit\\n                minRotationsForMaxProfit = numRotations\\n            \\n            # SET UP FOR NEXT ITERATION\\n            previousProfit = currentProfit\\n            \\n        return minRotationsForMaxProfit\\n\\t\\t\\n```",
                "codeTag": "Java"
            },
            {
                "id": 867145,
                "title": "python-o-n-beats-66",
                "content": "```\\nclass Solution:\\n    def minOperationsMaxProfit(self, customers: List[int], boardingCost: int, runningCost: int):\\n        if 4*boardingCost < runningCost:\\n            return -1\\n        \\n        n = len(customers)\\n        maxtotal, maxrotations = 0, -1\\n        total, rotations = 0, 1\\n        i = 0\\n        \\n        while True:\\n            if i == n-1 and customers[n-1] == 0:\\n                break\\n                \\n            if customers[i]>4:\\n                total += boardingCost*4 - runningCost\\n                \\n                if i < n-1:\\n                    customers[i+1] += customers[i]-4\\n                    customers[i] = 0\\n                else:\\n                    customers[i] -= 4\\n                    \\n            else:\\n                total += customers[i]*boardingCost - runningCost\\n                customers[i] = 0\\n            \\n            if total>maxtotal:\\n                maxtotal = total\\n                maxrotations = rotations\\n                \\n            if i<n-1: i += 1\\n            rotations += 1\\n            \\n        return maxrotations\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution:\\n    def minOperationsMaxProfit(self, customers: List[int], boardingCost: int, runningCost: int):\\n        if 4*boardingCost < runningCost:\\n            return -1\\n        \\n        n = len(customers)\\n        maxtotal, maxrotations = 0, -1\\n        total, rotations = 0, 1\\n        i = 0\\n        \\n        while True:\\n            if i == n-1 and customers[n-1] == 0:\\n                break\\n                \\n            if customers[i]>4:\\n                total += boardingCost*4 - runningCost\\n                \\n                if i < n-1:\\n                    customers[i+1] += customers[i]-4\\n                    customers[i] = 0\\n                else:\\n                    customers[i] -= 4\\n                    \\n            else:\\n                total += customers[i]*boardingCost - runningCost\\n                customers[i] = 0\\n            \\n            if total>maxtotal:\\n                maxtotal = total\\n                maxrotations = rotations\\n                \\n            if i<n-1: i += 1\\n            rotations += 1\\n            \\n        return maxrotations\\n```",
                "codeTag": "Java"
            },
            {
                "id": 867089,
                "title": "java-2ms-100-beats-other-java-submissions-by-space-and-time",
                "content": "The idea is to find the remaining customers after iterating all customer to which calculate the rotation required.\\n\\n```\\nclass Solution {\\n    public int minOperationsMaxProfit(int[] customers, int boardingCost, int runningCost) {\\n        if (4 * boardingCost <= runningCost) {\\n            return -1;\\n        }\\n\\n        int remainingCustomers = 0;\\n        for (int i = 0; i < customers.length; i++) {\\n            customers[i] = customers[i] + remainingCustomers;\\n            remainingCustomers = customers[i] - Math.min(customers[i], 4);\\n        }\\n\\n        return customers.length + findRotations(remainingCustomers, boardingCost, runningCost);\\n    }\\n\\n    public int findRotations(int ramainingCustomers, int boardingCost, int runningCost) {\\n        int rotations = ramainingCustomers / 4;\\n        int r = ramainingCustomers % 4;\\n\\n        int profit = (ramainingCustomers - r) * boardingCost - (rotations * runningCost);\\n\\n        for (int i = ramainingCustomers - r + 1; i <= ramainingCustomers; i++) {\\n            int t = i * boardingCost - ((rotations + 1) * runningCost);\\n            if (t > profit) {\\n                return rotations + 1;\\n            }\\n        }\\n        return rotations;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int minOperationsMaxProfit(int[] customers, int boardingCost, int runningCost) {\\n        if (4 * boardingCost <= runningCost) {\\n            return -1;\\n        }\\n\\n        int remainingCustomers = 0;\\n        for (int i = 0; i < customers.length; i++) {\\n            customers[i] = customers[i] + remainingCustomers;\\n            remainingCustomers = customers[i] - Math.min(customers[i], 4);\\n        }\\n\\n        return customers.length + findRotations(remainingCustomers, boardingCost, runningCost);\\n    }\\n\\n    public int findRotations(int ramainingCustomers, int boardingCost, int runningCost) {\\n        int rotations = ramainingCustomers / 4;\\n        int r = ramainingCustomers % 4;\\n\\n        int profit = (ramainingCustomers - r) * boardingCost - (rotations * runningCost);\\n\\n        for (int i = ramainingCustomers - r + 1; i <= ramainingCustomers; i++) {\\n            int t = i * boardingCost - ((rotations + 1) * runningCost);\\n            if (t > profit) {\\n                return rotations + 1;\\n            }\\n        }\\n        return rotations;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 867051,
                "title": "python-easy-code-solution",
                "content": "```\\nclass Solution:\\n    def minOperationsMaxProfit(self, customers: List[int], boardingCost: int, runningCost: int) -> int:\\n        total = 0 #total number of people currently available to ride\\n        totalProf = 0 #total global profit earned till now\\n        ans = 0  #minimum number of rides that need to be taken to earn max profit\\n        rides = 0 #number of rides done till any specific time\\n        prof = 0 #local profit/running profit.\\n        for i in customers:\\n            total += i\\n            rides+=1\\n            canRide = min(4,total)\\n            prof += canRide * boardingCost - runningCost\\n            total -= canRide\\n            if prof > totalProf:\\n                totalProf = prof\\n                ans = rides\\n        #no more people will arrive. So, try to maximize profit by using the remanining people.\\n        while total > 0:\\n            rides+=1\\n            canRide = min(4,total)\\n            prof += canRide * boardingCost - runningCost\\n            total -= canRide\\n            if prof > totalProf:\\n                totalProf = prof\\n                ans = rides\\n        if totalProf <= 0:\\n            return -1\\n        return ans\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution:\\n    def minOperationsMaxProfit(self, customers: List[int], boardingCost: int, runningCost: int) -> int:\\n        total = 0 #total number of people currently available to ride\\n        totalProf = 0 #total global profit earned till now\\n        ans = 0  #minimum number of rides that need to be taken to earn max profit\\n        rides = 0 #number of rides done till any specific time\\n        prof = 0 #local profit/running profit.\\n        for i in customers:\\n            total += i\\n            rides+=1\\n            canRide = min(4,total)\\n            prof += canRide * boardingCost - runningCost\\n            total -= canRide\\n            if prof > totalProf:\\n                totalProf = prof\\n                ans = rides\\n        #no more people will arrive. So, try to maximize profit by using the remanining people.\\n        while total > 0:\\n            rides+=1\\n            canRide = min(4,total)\\n            prof += canRide * boardingCost - runningCost\\n            total -= canRide\\n            if prof > totalProf:\\n                totalProf = prof\\n                ans = rides\\n        if totalProf <= 0:\\n            return -1\\n        return ans\\n```",
                "codeTag": "Java"
            },
            {
                "id": 866990,
                "title": "java-simple-solution-beats-100-o-n-time-o-1-space",
                "content": "Calculate the totOnBoard by keeping track of incoming customers, as well as wait list. Ensure to only pick 4 from combined lists. When the customers drain out, then drain out the wait list. Track the profit across the rotations.\\n\\nTime `O(N)` Space `O(1)`\\n\\n```\\nclass Solution {\\n    public int minOperationsMaxProfit(int[] customers, int boardingCost, int runningCost) {\\n        int totOnBoard = 0, totWaiting = 0, maxProfit = 0, numTimes = -1;\\n        for (int i = 0; i < customers.length || totWaiting > 0; i++) {\\n            int boardedCurrentCycle = 0;\\n            if (i < customers.length) {\\n                boardedCurrentCycle = Math.min(4, customers[i]);\\n                totWaiting += customers[i] - boardedCurrentCycle;\\n            }\\n            \\n            if (boardedCurrentCycle < 4 && totWaiting > 0) {\\n                int broughInFromWaitList = Math.min(4-boardedCurrentCycle, totWaiting);\\n                boardedCurrentCycle +=  broughInFromWaitList;\\n                totWaiting -=  broughInFromWaitList;\\n            }\\n            totOnBoard += boardedCurrentCycle;\\n            int profitSoFar = boardingCost*totOnBoard - runningCost*(i+1);\\n            if (profitSoFar > maxProfit) {\\n                numTimes = i+1;\\n                maxProfit = profitSoFar;\\n            }\\n        }\\n        return numTimes;\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    public int minOperationsMaxProfit(int[] customers, int boardingCost, int runningCost) {\\n        int totOnBoard = 0, totWaiting = 0, maxProfit = 0, numTimes = -1;\\n        for (int i = 0; i < customers.length || totWaiting > 0; i++) {\\n            int boardedCurrentCycle = 0;\\n            if (i < customers.length) {\\n                boardedCurrentCycle = Math.min(4, customers[i]);\\n                totWaiting += customers[i] - boardedCurrentCycle;\\n            }\\n            \\n            if (boardedCurrentCycle < 4 && totWaiting > 0) {\\n                int broughInFromWaitList = Math.min(4-boardedCurrentCycle, totWaiting);\\n                boardedCurrentCycle +=  broughInFromWaitList;\\n                totWaiting -=  broughInFromWaitList;\\n            }\\n            totOnBoard += boardedCurrentCycle;\\n            int profitSoFar = boardingCost*totOnBoard - runningCost*(i+1);\\n            if (profitSoFar > maxProfit) {\\n                numTimes = i+1;\\n                maxProfit = profitSoFar;\\n            }\\n        }\\n        return numTimes;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 866961,
                "title": "java-greedy-o-n-well-explained",
                "content": "This solution involves taking at most 4 values at a time.  These values (no. of customers) we can get from either the new set of customers, or from remaining ones.\\nWe keep track of remaining (waiting) number of people, and when new set of customers come, we update the count of waiting set of customers.\\nalso, **GREEDILY** number of people to board = Minimum of (new set of customers coming, 4).\\n\\nSince each onboarding is a rotation in itself, we increment rotation by 1.\\nWe also keep track of profit updating it cumulatively and update the maximum profit , also updating the rotation at which we got the maximum profit. \\nIf the maxProfit is positive, we return it or else -1. (No need to check profit here, since max profit will always be greater than profit.)\\n\\n```\\nclass Solution {\\n    public int minOperationsMaxProfit(int[] customers, int boardingCost, int runningCost) {\\n        int remaining = 0;\\n        int cIdx = 0, l = customers.length;\\n        int profit = 0, maxProfit = 0, rotation = 0, rotationAtMaxProfit = 0;\\n        \\n        while(cIdx<l || remaining!=0){\\n            if(cIdx<l)\\n                remaining += customers[cIdx++];\\n            int onBoard = Math.min(remaining,4);\\n            remaining -=onBoard;\\n            profit += onBoard*boardingCost - runningCost;\\n            rotation++;\\n            if(profit > maxProfit){\\n                maxProfit = profit;\\n                rotationAtMaxProfit = rotation;\\n            }\\n        }\\n        \\n        return (maxProfit>0) ? rotationAtMaxProfit : -1;\\n        \\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    public int minOperationsMaxProfit(int[] customers, int boardingCost, int runningCost) {\\n        int remaining = 0;\\n        int cIdx = 0, l = customers.length;\\n        int profit = 0, maxProfit = 0, rotation = 0, rotationAtMaxProfit = 0;\\n        \\n        while(cIdx<l || remaining!=0){\\n            if(cIdx<l)\\n                remaining += customers[cIdx++];\\n            int onBoard = Math.min(remaining,4);\\n            remaining -=onBoard;\\n            profit += onBoard*boardingCost - runningCost;\\n            rotation++;\\n            if(profit > maxProfit){\\n                maxProfit = profit;\\n                rotationAtMaxProfit = rotation;\\n            }\\n        }\\n        \\n        return (maxProfit>0) ? rotationAtMaxProfit : -1;\\n        \\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 866948,
                "title": "java-with-simple-comments-time-complexity-o-n",
                "content": "\\nThe idea is to allow 4 customers who have been waiting untill the ```i```th rotation is done  ( denoted by ```customers[i]``` )  and then, calculate the profit at every rotation while keeping two constraints \\n\\nFirst is  ->  _the wheel must have been rotated \\'i\\' times before the ith iteration  \\nSecond is  ->  maximum of 4 persons can board the gandola._\\n\\n```\\nclass Solution {\\n    public int minOperationsMaxProfit(int[] customers, int boardingCost, int runningCost) {\\n        //calculate profit at each step and then store max profit.\\n        \\n        int totalC = 0, nR=0, maxNR = 0, waiting=0, maxProfit = - (int) 10e9 ;\\n        for(int i=0 ; i<customers.length ; i++) {\\n            waiting += customers[i] ; \\n            if(nR < i) nR = i;\\n            if(waiting > 0) {\\n                //fill max of 4 customers.\\n                int d = Math.min(waiting,4);\\n                waiting -= d;\\n                totalC += d;\\n                nR++;\\n                int p = totalC*boardingCost - runningCost*nR;\\n               //boarded d at round nR, profit booked = p;\\n                if(p > maxProfit){\\n                    maxNR = nR;\\n                    maxProfit = p;\\n                }\\n            }\\n        }\\n        \\n        while(waiting > 0){\\n           //fill max of 4 customers.\\n            int d = Math.min(waiting,4);\\n            waiting -= d;\\n            totalC += d;\\n            nR++;\\n            int p = totalC*boardingCost - runningCost*nR;\\n            //boarded d at round nR, profit booked = p;\\n            if(p > maxProfit){\\n                maxNR = nR;\\n                maxProfit = p;\\n            }\\n        }\\n        return maxProfit > 0 ? maxNR : -1;\\n   }\\n}",
                "solutionTags": [],
                "code": "```i```\n```customers[i]```",
                "codeTag": "Unknown"
            },
            {
                "id": 866904,
                "title": "python3-o-n-solution",
                "content": "```\\nclass Solution:\\n    def minOperationsMaxProfit(self, customers: List[int], boardingCost: int, runningCost: int) -> int:\\n        if not customers:\\n            return -1\\n        i, profit, maxi, res = 1, 0, -1, -1\\n        board = min(4, customers[0])\\n        wait = customers[0] - board\\n        while i < len(customers) or wait > 0:\\n            profit += board * boardingCost - runningCost\\n            if profit > maxi:\\n                maxi = profit\\n                res = i\\n            \\n            if i < len(customers):\\n\\t\\t\\t\\t# there are still customers to arrive\\n                board = min(4, wait + customers[i])\\n                wait = wait - board + customers[i]\\n            else:\\n\\t\\t\\t\\t# all remaining customers are now waiting\\n                board = min(4, wait)\\n                wait = wait - board\\n\\n            i += 1\\n        profit += board * boardingCost - runningCost\\n        if profit > maxi:\\n            maxi = profit\\n            res = i \\n        \\n        return res\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution:\\n    def minOperationsMaxProfit(self, customers: List[int], boardingCost: int, runningCost: int) -> int:\\n        if not customers:\\n            return -1\\n        i, profit, maxi, res = 1, 0, -1, -1\\n        board = min(4, customers[0])\\n        wait = customers[0] - board\\n        while i < len(customers) or wait > 0:\\n            profit += board * boardingCost - runningCost\\n            if profit > maxi:\\n                maxi = profit\\n                res = i\\n            \\n            if i < len(customers):\\n\\t\\t\\t\\t# there are still customers to arrive\\n                board = min(4, wait + customers[i])\\n                wait = wait - board + customers[i]\\n            else:\\n\\t\\t\\t\\t# all remaining customers are now waiting\\n                board = min(4, wait)\\n                wait = wait - board\\n\\n            i += 1\\n        profit += board * boardingCost - runningCost\\n        if profit > maxi:\\n            maxi = profit\\n            res = i \\n        \\n        return res\\n```",
                "codeTag": "Java"
            },
            {
                "id": 866876,
                "title": "c-simple-solution",
                "content": "```\\npublic class Solution {\\n    \\n    int maxProfit;\\n    int minRotationForMaxProfit;\\n    int boardingCost;\\n    int runningCost;\\n    \\n    public int MinOperationsMaxProfit(int[] customers, int boardingCost, int runningCost) \\n    {\\n        this.boardingCost = boardingCost;\\n        this.runningCost = runningCost;\\n        this.maxProfit = -1;\\n        this.minRotationForMaxProfit = -1;\\n        int waitingClients = 0, rotation = 0, boardedCustomers = 0;\\n        \\n        foreach(int customer in customers)\\n        {\\n            waitingClients+=customer;\\n            calculateProfit(ref boardedCustomers, ref rotation, ref waitingClients);\\n        }\\n        while(waitingClients>0)\\n        {\\n            calculateProfit(ref boardedCustomers, ref rotation, ref waitingClients);\\n        }\\n        return minRotationForMaxProfit;\\n    }\\n    \\n    private void calculateProfit(ref int boardedCustomers, ref int rotation, ref int waitingClients)\\n\\t{\\n        int board = Math.Min(4,waitingClients);\\n        waitingClients-= board;\\n        boardedCustomers += board;\\n        rotation++;\\n        int profit = (boardedCustomers * boardingCost) - (rotation * runningCost);\\n        if(maxProfit<profit)\\n        {\\n            maxProfit = profit;\\n            minRotationForMaxProfit = rotation;\\n        }\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\npublic class Solution {\\n    \\n    int maxProfit;\\n    int minRotationForMaxProfit;\\n    int boardingCost;\\n    int runningCost;\\n    \\n    public int MinOperationsMaxProfit(int[] customers, int boardingCost, int runningCost) \\n    {\\n        this.boardingCost = boardingCost;\\n        this.runningCost = runningCost;\\n        this.maxProfit = -1;\\n        this.minRotationForMaxProfit = -1;\\n        int waitingClients = 0, rotation = 0, boardedCustomers = 0;\\n        \\n        foreach(int customer in customers)\\n        {\\n            waitingClients+=customer;\\n            calculateProfit(ref boardedCustomers, ref rotation, ref waitingClients);\\n        }\\n        while(waitingClients>0)\\n        {\\n            calculateProfit(ref boardedCustomers, ref rotation, ref waitingClients);\\n        }\\n        return minRotationForMaxProfit;\\n    }\\n    \\n    private void calculateProfit(ref int boardedCustomers, ref int rotation, ref int waitingClients)\\n\\t{\\n        int board = Math.Min(4,waitingClients);\\n        waitingClients-= board;\\n        boardedCustomers += board;\\n        rotation++;\\n        int profit = (boardedCustomers * boardingCost) - (rotation * runningCost);\\n        if(maxProfit<profit)\\n        {\\n            maxProfit = profit;\\n            minRotationForMaxProfit = rotation;\\n        }\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 866867,
                "title": "javascript-endless-loop",
                "content": "```\\nconst minOperationsMaxProfit = (customers, boardingCost, runningCost) => {\\n    let rotate = 0;\\n    let wait = 0;\\n    let board = 0;\\n    let record = [];\\n    let n = customers.length;\\n    while (true) {\\n        if (rotate > n && record.length == 0) return -1;\\n        let l = record[record.length - 1];\\n        let sl = record[record.length - 2];\\n        if (l <= sl) break;\\n        rotate++;\\n        if (customers.length != 0) {\\n            wait += customers[0];\\n            customers.shift();\\n        }\\n        if (wait > 4) {\\n            board += 4;\\n            wait -= 4;\\n        } else {\\n            let tmp = wait;\\n            wait-= tmp;\\n            board += tmp;\\n        }\\n        let profit = board * boardingCost - rotate * runningCost;\\n        if(profit > 0) record.push(profit);\\n    }\\n    return rotate - 1;\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nconst minOperationsMaxProfit = (customers, boardingCost, runningCost) => {\\n    let rotate = 0;\\n    let wait = 0;\\n    let board = 0;\\n    let record = [];\\n    let n = customers.length;\\n    while (true) {\\n        if (rotate > n && record.length == 0) return -1;\\n        let l = record[record.length - 1];\\n        let sl = record[record.length - 2];\\n        if (l <= sl) break;\\n        rotate++;\\n        if (customers.length != 0) {\\n            wait += customers[0];\\n            customers.shift();\\n        }\\n        if (wait > 4) {\\n            board += 4;\\n            wait -= 4;\\n        } else {\\n            let tmp = wait;\\n            wait-= tmp;\\n            board += tmp;\\n        }\\n        let profit = board * boardingCost - rotate * runningCost;\\n        if(profit > 0) record.push(profit);\\n    }\\n    return rotate - 1;\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 866860,
                "title": "java-greedy-9-ms-faster-than-100-00-48-9-mb-less-than-100-00",
                "content": "```\\nclass Solution {\\n    public int minOperationsMaxProfit(int[] customers, int boardingCost, int runningCost) {\\n        if (4 * boardingCost <= runningCost) {\\n            return -1;\\n        }\\n        int max = 0;\\n        int maxCnt = 0;\\n        int left = 0;\\n        int profit = 0;\\n        int cnt = 0;\\n        int i = 0;\\n        int n = customers.length;\\n        while (left > 0 || i < n) {\\n            if (i < n) {\\n                left += customers[i++];\\n            }\\n            int cur = Math.min(left, 4);\\n            left -= cur;\\n            ++cnt;\\n            profit += boardingCost * cur - runningCost;\\n            if (profit > max) {\\n                max = profit;\\n                maxCnt = cnt;\\n            }\\n        }\\n        return max > 0 ? maxCnt : -1;\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    public int minOperationsMaxProfit(int[] customers, int boardingCost, int runningCost) {\\n        if (4 * boardingCost <= runningCost) {\\n            return -1;\\n        }\\n        int max = 0;\\n        int maxCnt = 0;\\n        int left = 0;\\n        int profit = 0;\\n        int cnt = 0;\\n        int i = 0;\\n        int n = customers.length;\\n        while (left > 0 || i < n) {\\n            if (i < n) {\\n                left += customers[i++];\\n            }\\n            int cur = Math.min(left, 4);\\n            left -= cur;\\n            ++cnt;\\n            profit += boardingCost * cur - runningCost;\\n            if (profit > max) {\\n                max = profit;\\n                maxCnt = cnt;\\n            }\\n        }\\n        return max > 0 ? maxCnt : -1;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 866802,
                "title": "java-ac-solution-using-lot-of-variables",
                "content": "```\\nclass Solution {\\n    public int minOperationsMaxProfit(int[] customers, int boardingCost, int runningCost) {\\n        \\n        int maxProfit = 0;\\n        int waiting = 0;\\n        int i = 0;\\n        int index = 0;\\n        int profit = 0;\\n        int ans = 0;\\n        \\n        for(i=0; i<customers.length; i++){\\n            profit = 0;\\n            \\n            if(waiting > 0){\\n                customers[i] += waiting;\\n            }\\n            \\n            if(customers[i] > 4){\\n                waiting = customers[i] - 4;\\n                index = 4 * (i+1);\\n            }\\n            else{\\n                index = customers[i];\\n            }\\n            \\n            profit = index * boardingCost - (i+1) * runningCost;\\n            if(profit > maxProfit){\\n                maxProfit = profit;\\n                ans = i+1;\\n            }\\n        }\\n        \\n        while(waiting > 0){\\n            if(waiting <= 4){\\n                profit = (index+waiting) * boardingCost - (i+1) * runningCost;\\n                waiting = 0;\\n            }\\n            else{\\n                index += 4;\\n                profit = (index) * boardingCost - (i+1) * runningCost;\\n                waiting -= 4;\\n            }\\n            \\n            i++;\\n            if(profit > maxProfit){\\n                maxProfit = profit;\\n                ans = i;\\n            }\\n        }\\n        \\n        return maxProfit==0 ? -1 : ans;\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    public int minOperationsMaxProfit(int[] customers, int boardingCost, int runningCost) {\\n        \\n        int maxProfit = 0;\\n        int waiting = 0;\\n        int i = 0;\\n        int index = 0;\\n        int profit = 0;\\n        int ans = 0;\\n        \\n        for(i=0; i<customers.length; i++){\\n            profit = 0;\\n            \\n            if(waiting > 0){\\n                customers[i] += waiting;\\n            }\\n            \\n            if(customers[i] > 4){\\n                waiting = customers[i] - 4;\\n                index = 4 * (i+1);\\n            }\\n            else{\\n                index = customers[i];\\n            }\\n            \\n            profit = index * boardingCost - (i+1) * runningCost;\\n            if(profit > maxProfit){\\n                maxProfit = profit;\\n                ans = i+1;\\n            }\\n        }\\n        \\n        while(waiting > 0){\\n            if(waiting <= 4){\\n                profit = (index+waiting) * boardingCost - (i+1) * runningCost;\\n                waiting = 0;\\n            }\\n            else{\\n                index += 4;\\n                profit = (index) * boardingCost - (i+1) * runningCost;\\n                waiting -= 4;\\n            }\\n            \\n            i++;\\n            if(profit > maxProfit){\\n                maxProfit = profit;\\n                ans = i;\\n            }\\n        }\\n        \\n        return maxProfit==0 ? -1 : ans;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 866779,
                "title": "you-will-like-this-c",
                "content": "```\\n int minOperationsMaxProfit(vector<int>& customers, int boardingCost, int runningCost) {\\n        \\n        vector<int>profitarr;\\n        \\n        int left=0,board,prevboard=0,prevrot=0,currot,jawab,x,profit,loss;\\n        \\n        for(int i=0;i<customers.size();i++){\\n            \\n             x=customers[i]+left;\\n            \\n            if(x>4){\\n             board=prevboard+4;\\n             left=x-4;}\\n            \\n            else{\\n             board=prevboard+x;\\n             left=0;}\\n            \\n            prevboard=board;\\n            \\n             profit=board*boardingCost;\\n            currot=prevrot+1;\\n            \\n             loss=(currot)*runningCost;\\n            prevrot=currot;\\n            \\n            profitarr.push_back(profit-loss);\\n        }\\n           while(left>0) //taking care of remaining customers if any \\n        {\\n                \\n            if(left>4){\\n             board=prevboard+4;\\n             left-=4;}\\n            \\n            else{\\n             board=prevboard+left;\\n             left=0;}\\n            \\n            prevboard=board;\\n            \\n            profit=board*boardingCost;\\n            currot=prevrot+1;\\n            \\n            loss=(currot)*runningCost;\\n            prevrot=currot;\\n            \\n            profitarr.push_back(profit-loss);\\n           \\n           \\n        }\\n        \\n        \\n        int maax=INT_MIN;\\n        \\n        for(int i=0;i<profitarr.size();i++){\\n            \\n            if(profitarr[i]>maax)\\n                \\n            {\\n               maax=profitarr[i];\\n               jawab=i;\\n            }\\n        }\\n        if(maax<0) return -1;\\n        \\n        else return jawab+1;}\\n```",
                "solutionTags": [],
                "code": "```\\n int minOperationsMaxProfit(vector<int>& customers, int boardingCost, int runningCost) {\\n        \\n        vector<int>profitarr;\\n        \\n        int left=0,board,prevboard=0,prevrot=0,currot,jawab,x,profit,loss;\\n        \\n        for(int i=0;i<customers.size();i++){\\n            \\n             x=customers[i]+left;\\n            \\n            if(x>4){\\n             board=prevboard+4;\\n             left=x-4;}\\n            \\n            else{\\n             board=prevboard+x;\\n             left=0;}\\n            \\n            prevboard=board;\\n            \\n             profit=board*boardingCost;\\n            currot=prevrot+1;\\n            \\n             loss=(currot)*runningCost;\\n            prevrot=currot;\\n            \\n            profitarr.push_back(profit-loss);\\n        }\\n           while(left>0) //taking care of remaining customers if any \\n        {\\n                \\n            if(left>4){\\n             board=prevboard+4;\\n             left-=4;}\\n            \\n            else{\\n             board=prevboard+left;\\n             left=0;}\\n            \\n            prevboard=board;\\n            \\n            profit=board*boardingCost;\\n            currot=prevrot+1;\\n            \\n            loss=(currot)*runningCost;\\n            prevrot=currot;\\n            \\n            profitarr.push_back(profit-loss);\\n           \\n           \\n        }\\n        \\n        \\n        int maax=INT_MIN;\\n        \\n        for(int i=0;i<profitarr.size();i++){\\n            \\n            if(profitarr[i]>maax)\\n                \\n            {\\n               maax=profitarr[i];\\n               jawab=i;\\n            }\\n        }\\n        if(maax<0) return -1;\\n        \\n        else return jawab+1;}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 866774,
                "title": "c-o-n-simple-solution-comment-100-100",
                "content": "```\\nclass Solution {\\npublic:\\n    int minOperationsMaxProfit(vector<int>& customers, int boardingCost, int runningCost) {\\n\\n        int i=0, waitingCustomers = 0, boardedCustomers = 0, maximumProfit = INT_MIN, rotations = 0;\\n        while(i < customers.size() || waitingCustomers > 0)\\n        {\\n        \\t//Process customer at index i, and add them in waiting lists.\\n            if(i < customers.size())\\n                waitingCustomers += customers[i];\\n            \\n            i++;\\n            \\n            //If there are customers, process them.\\n            if(waitingCustomers > 0)\\n            {\\n            \\t//At a time max 4 can board\\n                int canBoard = (waitingCustomers >= 4 ? 4 : waitingCustomers);\\n                boardedCustomers += canBoard;\\n                waitingCustomers -= canBoard;\\n                \\n\\t\\t\\t\\t//Calculate the profit.\\n                int profit = (boardedCustomers * boardingCost) - ( (i) *runningCost);\\n                if(maximumProfit < profit)\\n                {\\n                    maximumProfit = profit;\\n                    rotations = i;\\n                }                \\n            }\\n        }\\n        \\n        return maximumProfit < 0 ? -1 : rotations;\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    int minOperationsMaxProfit(vector<int>& customers, int boardingCost, int runningCost) {\\n\\n        int i=0, waitingCustomers = 0, boardedCustomers = 0, maximumProfit = INT_MIN, rotations = 0;\\n        while(i < customers.size() || waitingCustomers > 0)\\n        {\\n        \\t//Process customer at index i, and add them in waiting lists.\\n            if(i < customers.size())\\n                waitingCustomers += customers[i];\\n            \\n            i++;\\n            \\n            //If there are customers, process them.\\n            if(waitingCustomers > 0)\\n            {\\n            \\t//At a time max 4 can board\\n                int canBoard = (waitingCustomers >= 4 ? 4 : waitingCustomers);\\n                boardedCustomers += canBoard;\\n                waitingCustomers -= canBoard;\\n                \\n\\t\\t\\t\\t//Calculate the profit.\\n                int profit = (boardedCustomers * boardingCost) - ( (i) *runningCost);\\n                if(maximumProfit < profit)\\n                {\\n                    maximumProfit = profit;\\n                    rotations = i;\\n                }                \\n            }\\n        }\\n        \\n        return maximumProfit < 0 ? -1 : rotations;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 866761,
                "title": "east-to-understand-c",
                "content": "```\\nclass Solution {\\npublic:\\n    int minOperationsMaxProfit(vector<int>& c, int bCost, int rCost) {\\n        int in_queue = 0;\\n        int n_rotations = 0;\\n        int boarded = 0;\\n        \\n        int ans = 0;\\n        int max_profit = 0;\\n        \\n        int i = 0;\\n        while(in_queue > 0 || i < c.size()){\\n            if( i < c.size())\\n                in_queue += c[i++];\\n            n_rotations++;\\n            if(in_queue < 4){\\n                boarded += in_queue;\\n                in_queue = 0;\\n            }\\n            else {\\n                boarded += 4;\\n                in_queue = in_queue - 4;\\n            }\\n            \\n            auto curr_profit = (boarded * bCost) - (n_rotations * rCost);\\n            if(curr_profit > max_profit){\\n                ans = n_rotations;\\n                max_profit = curr_profit;\\n            }\\n        }\\n\\n        if(ans == 0)\\n            return -1;\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    int minOperationsMaxProfit(vector<int>& c, int bCost, int rCost) {\\n        int in_queue = 0;\\n        int n_rotations = 0;\\n        int boarded = 0;\\n        \\n        int ans = 0;\\n        int max_profit = 0;\\n        \\n        int i = 0;\\n        while(in_queue > 0 || i < c.size()){\\n            if( i < c.size())\\n                in_queue += c[i++];\\n            n_rotations++;\\n            if(in_queue < 4){\\n                boarded += in_queue;\\n                in_queue = 0;\\n            }\\n            else {\\n                boarded += 4;\\n                in_queue = in_queue - 4;\\n            }\\n            \\n            auto curr_profit = (boarded * bCost) - (n_rotations * rCost);\\n            if(curr_profit > max_profit){\\n                ans = n_rotations;\\n                max_profit = curr_profit;\\n            }\\n        }\\n\\n        if(ans == 0)\\n            return -1;\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 866734,
                "title": "c-easy-approach",
                "content": "```\\nclass Solution {\\npublic:\\n    int minOperationsMaxProfit(vector<int>& customers, int boardingCost, int runningCost) {\\n        int waiting = 0, cost = 0, rounds = 0, maxCost = 0, maxRound = -1;\\n        for (int i = 0; i < customers.size(); i++)  {\\n            waiting+=customers[i];\\n            if (waiting >=4 ) {\\n                cost+=(4 * boardingCost);\\n                waiting-=4;\\n            } else {\\n                cost+=(waiting * boardingCost);\\n                waiting = 0;\\n            } \\n            cost-=runningCost;\\n            rounds++;\\n            if (cost > maxCost) {\\n                maxRound = rounds;\\n                maxCost = cost;\\n            } \\n        }\\n        while(waiting) {\\n            if (waiting >=4) {\\n                cost+=(4 * boardingCost);\\n                waiting-=4;         \\n            } else {\\n                cost+=waiting * boardingCost;\\n                waiting = 0;\\n            }  \\n            cost-=runningCost;\\n            rounds++;\\n            if (cost > maxCost) {\\n                maxRound = rounds;\\n                maxCost = cost; \\n            } \\n        }\\n        return maxRound; \\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    int minOperationsMaxProfit(vector<int>& customers, int boardingCost, int runningCost) {\\n        int waiting = 0, cost = 0, rounds = 0, maxCost = 0, maxRound = -1;\\n        for (int i = 0; i < customers.size(); i++)  {\\n            waiting+=customers[i];\\n            if (waiting >=4 ) {\\n                cost+=(4 * boardingCost);\\n                waiting-=4;\\n            } else {\\n                cost+=(waiting * boardingCost);\\n                waiting = 0;\\n            } \\n            cost-=runningCost;\\n            rounds++;\\n            if (cost > maxCost) {\\n                maxRound = rounds;\\n                maxCost = cost;\\n            } \\n        }\\n        while(waiting) {\\n            if (waiting >=4) {\\n                cost+=(4 * boardingCost);\\n                waiting-=4;         \\n            } else {\\n                cost+=waiting * boardingCost;\\n                waiting = 0;\\n            }  \\n            cost-=runningCost;\\n            rounds++;\\n            if (cost > maxCost) {\\n                maxRound = rounds;\\n                maxCost = cost; \\n            } \\n        }\\n        return maxRound; \\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 866728,
                "title": "go-single-pass-o-n",
                "content": "After seeing example, I thought this problem is about checking `final profit > final cost`. For each round, maximum 4 people can get in, which means max profit each round is `4 * boardingCost`, so if `runningCost >= 4 * boardingCost` means this centennial will never able to profit.\\n\\nBut last paragraph says about stopping wheel, I was wondering what it is saying, then I realized that it is trying to handle folloing conditions of customers: [4, 0, 0, 0, 0, 0]. After 4 people coming, there\\'s no other people which means maximum profitable can only occurs at first round.\\n\\n```golang\\nfunc minOperationsMaxProfit(customers []int, boardingCost int, runningCost int) int {\\n\\t// never profitable\\n\\tif runningCost >= boardingCost*4 {\\n\\t\\treturn -1\\n\\t}\\n\\n\\tvar profit, cost, waiting int\\n\\tmaxProfit, maxProfitAt := 0, -1\\n\\n\\t// what if at some point, 0 customer come, e.g. [4, 0, 0, 0, 0]\\n\\tfor i := 0; i < len(customers) || waiting > 0; i++ {\\n\\t\\tif i < len(customers) {\\n\\t\\t\\twaiting += customers[i]\\n\\t\\t}\\n\\t\\tcost += runningCost\\n\\n\\t\\tprofit += min(4, waiting) * boardingCost\\n\\t\\twaiting = max(0, waiting-4)\\n\\n\\t\\tif c := profit - cost; c > maxProfit {\\n\\t\\t\\tmaxProfit = c\\n\\t\\t\\tmaxProfitAt = i + 1\\n\\t\\t}\\n\\t}\\n\\n\\treturn maxProfitAt\\n}\\n\\nfunc max(i, j int) int {\\n\\tif i >= j {\\n\\t\\treturn i\\n\\t}\\n\\treturn j\\n}\\n\\nfunc min(i, j int) int {\\n\\tif i <= j {\\n\\t\\treturn i\\n\\t}\\n\\treturn j\\n}\\n```",
                "solutionTags": [
                    "Go"
                ],
                "code": "```golang\\nfunc minOperationsMaxProfit(customers []int, boardingCost int, runningCost int) int {\\n\\t// never profitable\\n\\tif runningCost >= boardingCost*4 {\\n\\t\\treturn -1\\n\\t}\\n\\n\\tvar profit, cost, waiting int\\n\\tmaxProfit, maxProfitAt := 0, -1\\n\\n\\t// what if at some point, 0 customer come, e.g. [4, 0, 0, 0, 0]\\n\\tfor i := 0; i < len(customers) || waiting > 0; i++ {\\n\\t\\tif i < len(customers) {\\n\\t\\t\\twaiting += customers[i]\\n\\t\\t}\\n\\t\\tcost += runningCost\\n\\n\\t\\tprofit += min(4, waiting) * boardingCost\\n\\t\\twaiting = max(0, waiting-4)\\n\\n\\t\\tif c := profit - cost; c > maxProfit {\\n\\t\\t\\tmaxProfit = c\\n\\t\\t\\tmaxProfitAt = i + 1\\n\\t\\t}\\n\\t}\\n\\n\\treturn maxProfitAt\\n}\\n\\nfunc max(i, j int) int {\\n\\tif i >= j {\\n\\t\\treturn i\\n\\t}\\n\\treturn j\\n}\\n\\nfunc min(i, j int) int {\\n\\tif i <= j {\\n\\t\\treturn i\\n\\t}\\n\\treturn j\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 866724,
                "title": "java-solution-at-contest",
                "content": "Guess this is greedy problem? \\u9898\\u76EE\\u63CF\\u8FF0\\u5F88\\u590D\\u6742\\uFF0C\\u4F46\\u6CA1\\u89C9\\u5F97\\u6709\\u5565\\u7279\\u522B\\u7684\\u8003\\u70B9\\u3002\\n```\\nclass Solution {\\n    public int minOperationsMaxProfit(int[] customers, int boardingCost, int runningCost) {\\n        int remain = 0, count = 0;\\n        int run = 0;\\n        int max = Integer.MIN_VALUE;\\n        List<Integer> res = new ArrayList<>();\\n        for (int i = 0; i < customers.length; i++) {\\n            remain += customers[i];\\n            if (remain >= 4) {\\n                remain -= 4;\\n                run += 4;\\n            } else {\\n                run += remain;\\n                remain = 0;\\n            }\\n            count++;\\n            \\n            int profit = boardingCost * run - runningCost * count;\\n            max = Math.max(max, profit);\\n            res.add(profit);\\n        }\\n        \\n        while (remain > 0) {\\n            if (remain >= 4) {\\n                remain -= 4;\\n                run += 4;\\n            } else {\\n                run += remain;\\n                remain = 0;\\n            }\\n            count++;\\n            int profit = boardingCost * run - runningCost * count;\\n            max = Math.max(max, profit);\\n            res.add(profit);\\n            \\n        }\\n        \\n        if (max < 0) return -1;\\n        \\n        for (int i = 0; i < res.size(); i++) {\\n            if (res.get(i) == max) {\\n                return i + 1;\\n            }\\n        }\\n        \\n        return 0;\\n        \\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    public int minOperationsMaxProfit(int[] customers, int boardingCost, int runningCost) {\\n        int remain = 0, count = 0;\\n        int run = 0;\\n        int max = Integer.MIN_VALUE;\\n        List<Integer> res = new ArrayList<>();\\n        for (int i = 0; i < customers.length; i++) {\\n            remain += customers[i];\\n            if (remain >= 4) {\\n                remain -= 4;\\n                run += 4;\\n            } else {\\n                run += remain;\\n                remain = 0;\\n            }\\n            count++;\\n            \\n            int profit = boardingCost * run - runningCost * count;\\n            max = Math.max(max, profit);\\n            res.add(profit);\\n        }\\n        \\n        while (remain > 0) {\\n            if (remain >= 4) {\\n                remain -= 4;\\n                run += 4;\\n            } else {\\n                run += remain;\\n                remain = 0;\\n            }\\n            count++;\\n            int profit = boardingCost * run - runningCost * count;\\n            max = Math.max(max, profit);\\n            res.add(profit);\\n            \\n        }\\n        \\n        if (max < 0) return -1;\\n        \\n        for (int i = 0; i < res.size(); i++) {\\n            if (res.get(i) == max) {\\n                return i + 1;\\n            }\\n        }\\n        \\n        return 0;\\n        \\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 866717,
                "title": "just-greedy-but-it-is-hard-to-understand-the-problem",
                "content": "The most hard part is to understand the problem itself.\\n\\nBecause it says \\\\`I \\' can stop the game any time, So:\\n\\n- At first, I thought it was ask for the max profile \\\\`I\\' can earn. If \\\\`I\\u2019 can earn money (the profile is always negative), it is OK \\\\`I\\u2019 just don\\u2019t play this game. So max profile is 0, why -1? Alright, it is my mistake.\\n- When I read it one more time, I am confused again. If \\\\`I\\u2019 do not play this, the max profit (0) is got when rotate wheel 0 times, why -1?\\n\\nFinally, I try to forget the \\\\`Why -1 not 0\\u2019, and just code it, and it actually gets accepted\\u2026  \\uD83D\\uDE05\\t :sweat_smile:\\n\\nAccidentally, I find the markdown render in LeetCode doesn\\u2019t support emoji shortcode, sad\\u2026 \\uD83D\\uDE1E :disappointed:\\n\\n```c++\\nint minOperationsMaxProfit(vector<int>& C, int B, int R)\\n{\\n  int len = static_cast<int>(C.size());\\n  int profile = 0, ans = -1;\\n  int cur = 0, num = 0, play;\\n  vector<pair<int, int>> A;\\n  for (int i = 0; i < len; ++i)\\n  {\\n    num += C[i];\\n    play = min(num, 4);\\n    num -= play;\\n    cur += play * B - R;\\n    if (cur > profile)\\n    {\\n      profile = cur;\\n      ans = i + 1;\\n    }\\n  }\\n  for (int i = len; num > 0; ++i)\\n  {\\n    play = min(num, 4);\\n    num -= play;\\n    cur += play * B - R;\\n    if (cur > profile)\\n    {\\n      profile = cur;\\n      ans = i + 1;\\n    }\\n  }\\n  return ans;\\n}\\n```",
                "solutionTags": [],
                "code": "```c++\\nint minOperationsMaxProfit(vector<int>& C, int B, int R)\\n{\\n  int len = static_cast<int>(C.size());\\n  int profile = 0, ans = -1;\\n  int cur = 0, num = 0, play;\\n  vector<pair<int, int>> A;\\n  for (int i = 0; i < len; ++i)\\n  {\\n    num += C[i];\\n    play = min(num, 4);\\n    num -= play;\\n    cur += play * B - R;\\n    if (cur > profile)\\n    {\\n      profile = cur;\\n      ans = i + 1;\\n    }\\n  }\\n  for (int i = len; num > 0; ++i)\\n  {\\n    play = min(num, 4);\\n    num -= play;\\n    cur += play * B - R;\\n    if (cur > profile)\\n    {\\n      profile = cur;\\n      ans = i + 1;\\n    }\\n  }\\n  return ans;\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 866697,
                "title": "easy-java-solution",
                "content": "class Solution {\\n    public int minOperationsMaxProfit(int[] customers, int boardingCost, int runningCost) {\\n        if(customers.length==0)\\n            return 0;\\n        int sum=0;\\n        int count=0;\\n        int left=0;\\n        int ans=0;\\n        int d=0;\\n        int max=-1;\\n        for(int i=0;i<customers.length;i++)\\n        {    \\n            \\n             left+=customers[i];\\n            \\n            \\n           \\n            if(left>4)\\n            { left=left-4;\\n            sum=sum+4;}\\n            else\\n            {sum=sum+left;\\n             left=0;}\\n             \\n             \\n            count++;\\n             d=sum*boardingCost-count*runningCost;\\n            if(d>max)\\n            {max=Math.max(max,sum*boardingCost-count*runningCost);\\n             ans=count;}\\n        }\\n        while(left>0)\\n        {\\n            if(left>4)\\n            { left-=4;\\n            sum+=4;}\\n            else\\n            {\\n                sum+=left;\\n                left=0;\\n            }\\n            count++;\\n            d=sum*boardingCost-count*runningCost;\\n            if(d>max)\\n            {max=Math.max(max,sum*boardingCost-count*runningCost);\\n             ans=count;}\\n             //max=Math.max(max,sum*boardingCost-count*runningCost);\\n        }\\n        if(max<0)\\n            return -1;\\n        else\\n            return ans;\\n    }\\n}",
                "solutionTags": [],
                "code": "class Solution {\\n    public int minOperationsMaxProfit(int[] customers, int boardingCost, int runningCost) {\\n        if(customers.length==0)\\n            return 0;\\n        int sum=0;\\n        int count=0;\\n        int left=0;\\n        int ans=0;\\n        int d=0;\\n        int max=-1;\\n        for(int i=0;i<customers.length;i++)\\n        {    \\n            \\n             left+=customers[i];\\n            \\n            \\n           \\n            if(left>4)\\n            { left=left-4;\\n            sum=sum+4;}",
                "codeTag": "Java"
            },
            {
                "id": 866694,
                "title": "java-clear-and-easy-solution-beats-100-time",
                "content": "```\\nclass Solution {\\n    public int minOperationsMaxProfit(int[] customers, int boardingCost, int runningCost) {\\n        if(customers.length == 0)\\n            return 0;\\n        int pass = customers[0], profit = 0, i = 1, served = 0, rotation = 0, res = -1;\\n        \\n        while(pass > 0 || i < customers.length) {\\n\\t\\t\\tint onboard = Math.max(4, pass);\\n\\t\\t\\tserved += onboard;\\n\\t\\t\\tpass -= onboard;\\n\\t\\t\\t\\n            rotation++;\\n            int pr = served * boardingCost - runningCost * rotation;\\n            if(pr > profit) {\\n                profit = pr;\\n                res = rotation;\\n            }\\n            \\n            pass += i < customers.length ? customers[i++] : 0;\\n        }\\n        \\n        return res;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int minOperationsMaxProfit(int[] customers, int boardingCost, int runningCost) {\\n        if(customers.length == 0)\\n            return 0;\\n        int pass = customers[0], profit = 0, i = 1, served = 0, rotation = 0, res = -1;\\n        \\n        while(pass > 0 || i < customers.length) {\\n\\t\\t\\tint onboard = Math.max(4, pass);\\n\\t\\t\\tserved += onboard;\\n\\t\\t\\tpass -= onboard;\\n\\t\\t\\t\\n            rotation++;\\n            int pr = served * boardingCost - runningCost * rotation;\\n            if(pr > profit) {\\n                profit = pr;\\n                res = rotation;\\n            }\\n            \\n            pass += i < customers.length ? customers[i++] : 0;\\n        }\\n        \\n        return res;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 866670,
                "title": "c-solution-simply-simulate-the-process",
                "content": "```\\nclass Solution {\\npublic:\\n    int minOperationsMaxProfit(vector<int>& customers, int boardingCost, int runningCost) {\\n        int result = -1;\\n        int remaining = 0;\\n        int profit = 0;\\n        int afterProfit = 0;\\n        int i = 0;\\n        while(i < customers.size() || remaining > 0){\\n            if(i < customers.size()) remaining += customers[i];\\n            int num = min(remaining, 4);     \\n            afterProfit = profit + num * boardingCost - runningCost;\\n            if(afterProfit > profit){\\n                result = i + 1;\\n            }\\n            profit = afterProfit;\\n            i++;\\n            remaining -= num;\\n        }\\n        return result;\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    int minOperationsMaxProfit(vector<int>& customers, int boardingCost, int runningCost) {\\n        int result = -1;\\n        int remaining = 0;\\n        int profit = 0;\\n        int afterProfit = 0;\\n        int i = 0;\\n        while(i < customers.size() || remaining > 0){\\n            if(i < customers.size()) remaining += customers[i];\\n            int num = min(remaining, 4);     \\n            afterProfit = profit + num * boardingCost - runningCost;\\n            if(afterProfit > profit){\\n                result = i + 1;\\n            }\\n            profit = afterProfit;\\n            i++;\\n            remaining -= num;\\n        }\\n        return result;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 866642,
                "title": "c-o-n-brute-force",
                "content": "```csharp\\npublic int MinOperationsMaxProfit(int[] customers, int boardingCost, int runningCost)\\n{\\n\\tint maxProfit = int.MinValue;\\n\\tint waitingCustomers = 0;\\n\\tint maxCapacity = 4;\\n\\tint rotationCount = 0;\\n\\tint result = 0;\\n\\tint profit = 0;\\n\\n\\tfor (int i = 0; i < customers.Length; i++)\\n\\t{\\n\\t\\trotationCount++;\\n\\t\\tint currentCount;\\n\\n\\t\\tint customer = customers[i] + waitingCustomers;\\n\\t\\tif (customer >= maxCapacity)\\n\\t\\t{\\n\\t\\t\\tcurrentCount = maxCapacity;\\n\\t\\t\\twaitingCustomers = customer - maxCapacity;\\n\\t\\t}\\n\\t\\telse\\n\\t\\t{\\n\\t\\t\\tcurrentCount = customer;\\n\\t\\t\\twaitingCustomers = 0;\\n\\t\\t}\\n\\n\\t\\tprofit += (currentCount * boardingCost) - runningCost;\\n\\t\\tif (profit > maxProfit)\\n\\t\\t{\\n\\t\\t\\tmaxProfit = profit;\\n\\t\\t\\tresult = rotationCount;\\n\\t\\t}                \\n\\t}\\n\\n\\twhile (waitingCustomers > 0)\\n\\t{\\n\\t\\trotationCount++;\\n\\t\\tint currentCount = waitingCustomers <= maxCapacity ? waitingCustomers : maxCapacity;\\n\\t\\twaitingCustomers -= currentCount;\\n\\n\\t\\tprofit += (currentCount * boardingCost) - runningCost;\\n\\t\\tif (profit > maxProfit)\\n\\t\\t{\\n\\t\\t\\tmaxProfit = profit;\\n\\t\\t\\tresult = rotationCount;\\n\\t\\t}               \\n\\t}\\n\\n\\treturn maxProfit < 0 ? -1 : result;\\n}\\n```",
                "solutionTags": [],
                "code": "```csharp\\npublic int MinOperationsMaxProfit(int[] customers, int boardingCost, int runningCost)\\n{\\n\\tint maxProfit = int.MinValue;\\n\\tint waitingCustomers = 0;\\n\\tint maxCapacity = 4;\\n\\tint rotationCount = 0;\\n\\tint result = 0;\\n\\tint profit = 0;\\n\\n\\tfor (int i = 0; i < customers.Length; i++)\\n\\t{\\n\\t\\trotationCount++;\\n\\t\\tint currentCount;\\n\\n\\t\\tint customer = customers[i] + waitingCustomers;\\n\\t\\tif (customer >= maxCapacity)\\n\\t\\t{\\n\\t\\t\\tcurrentCount = maxCapacity;\\n\\t\\t\\twaitingCustomers = customer - maxCapacity;\\n\\t\\t}\\n\\t\\telse\\n\\t\\t{\\n\\t\\t\\tcurrentCount = customer;\\n\\t\\t\\twaitingCustomers = 0;\\n\\t\\t}\\n\\n\\t\\tprofit += (currentCount * boardingCost) - runningCost;\\n\\t\\tif (profit > maxProfit)\\n\\t\\t{\\n\\t\\t\\tmaxProfit = profit;\\n\\t\\t\\tresult = rotationCount;\\n\\t\\t}                \\n\\t}\\n\\n\\twhile (waitingCustomers > 0)\\n\\t{\\n\\t\\trotationCount++;\\n\\t\\tint currentCount = waitingCustomers <= maxCapacity ? waitingCustomers : maxCapacity;\\n\\t\\twaitingCustomers -= currentCount;\\n\\n\\t\\tprofit += (currentCount * boardingCost) - runningCost;\\n\\t\\tif (profit > maxProfit)\\n\\t\\t{\\n\\t\\t\\tmaxProfit = profit;\\n\\t\\t\\tresult = rotationCount;\\n\\t\\t}               \\n\\t}\\n\\n\\treturn maxProfit < 0 ? -1 : result;\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 866635,
                "title": "java-simple-and-clean-solution",
                "content": "```\\npublic int minOperationsMaxProfit(int[] customers, int boardingCost, int runningCost) {\\n        int customersLeft = 0, currProfit = 0, maxProfit = 0;\\n        int i = 0, rotations = -1;\\n\\n        while (i < customers.length || customersLeft > 0) {\\n            if (i < customers.length) {\\n                customersLeft += customers[i];\\n            }\\n\\n            int thisRoundCustomers = Math.min(customersLeft, 4);\\n            customersLeft -= thisRoundCustomers;\\n\\n            currProfit += (thisRoundCustomers * boardingCost) - runningCost;\\n            if (currProfit > maxProfit) {\\n                maxProfit = currProfit;\\n                rotations = i + 1;\\n            }\\n\\n            i++;\\n        }\\n\\n        return rotations;\\n    }\\n```",
                "solutionTags": [],
                "code": "```\\npublic int minOperationsMaxProfit(int[] customers, int boardingCost, int runningCost) {\\n        int customersLeft = 0, currProfit = 0, maxProfit = 0;\\n        int i = 0, rotations = -1;\\n\\n        while (i < customers.length || customersLeft > 0) {\\n            if (i < customers.length) {\\n                customersLeft += customers[i];\\n            }\\n\\n            int thisRoundCustomers = Math.min(customersLeft, 4);\\n            customersLeft -= thisRoundCustomers;\\n\\n            currProfit += (thisRoundCustomers * boardingCost) - runningCost;\\n            if (currProfit > maxProfit) {\\n                maxProfit = currProfit;\\n                rotations = i + 1;\\n            }\\n\\n            i++;\\n        }\\n\\n        return rotations;\\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 866628,
                "title": "c-o-n-time-and-o-1-space",
                "content": "```\\nclass Solution {\\npublic:\\n    int minOperationsMaxProfit(vector<int>& customers, int boardingCost, int runningCost) \\n\\t{\\n\\t\\tif(boardingCost * 4 < runningCost)\\n\\t\\t\\treturn -1;\\n\\n    \\tlong long int res = -1, max_profit = 0, curr_profit = 0;\\n    \\tfor(int i = 0; i < customers.size(); i++)\\n    \\t{\\n    \\t\\tif(i > 0)\\n    \\t\\t\\tcustomers[i] += max(0, customers[i - 1] - 4);\\n    \\t\\t\\n    \\t\\tint boarding = min(4, customers[i]);\\n    \\t\\t\\n    \\t\\tint profit = boarding * boardingCost - runningCost;\\n    \\t\\tcurr_profit += profit;\\n    \\t\\tif(curr_profit > max_profit)\\n    \\t\\t{\\n    \\t\\t\\tmax_profit = curr_profit;\\n    \\t\\t\\tres = i + 1;\\n    \\t\\t}\\n    \\t}\\n\\n    \\t\\n    \\tcustomers.back() -= 4;\\n\\n    \\tif(customers.back() > 0)\\n    \\t\\tcurr_profit += (boardingCost * (customers.back() / 4) * 4) - (customers.back() / 4) * runningCost;\\n\\n    \\tif(curr_profit > max_profit)\\n    \\t\\tres = customers.size() + customers.back() / 4;\\n\\n    \\tif((customers.back() % 4 * boardingCost) > runningCost)\\n    \\t\\tres = customers.size() + customers.back() / 4 + 1; \\n\\n    \\treturn res;\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    int minOperationsMaxProfit(vector<int>& customers, int boardingCost, int runningCost) \\n\\t{\\n\\t\\tif(boardingCost * 4 < runningCost)\\n\\t\\t\\treturn -1;\\n\\n    \\tlong long int res = -1, max_profit = 0, curr_profit = 0;\\n    \\tfor(int i = 0; i < customers.size(); i++)\\n    \\t{\\n    \\t\\tif(i > 0)\\n    \\t\\t\\tcustomers[i] += max(0, customers[i - 1] - 4);\\n    \\t\\t\\n    \\t\\tint boarding = min(4, customers[i]);\\n    \\t\\t\\n    \\t\\tint profit = boarding * boardingCost - runningCost;\\n    \\t\\tcurr_profit += profit;\\n    \\t\\tif(curr_profit > max_profit)\\n    \\t\\t{\\n    \\t\\t\\tmax_profit = curr_profit;\\n    \\t\\t\\tres = i + 1;\\n    \\t\\t}\\n    \\t}\\n\\n    \\t\\n    \\tcustomers.back() -= 4;\\n\\n    \\tif(customers.back() > 0)\\n    \\t\\tcurr_profit += (boardingCost * (customers.back() / 4) * 4) - (customers.back() / 4) * runningCost;\\n\\n    \\tif(curr_profit > max_profit)\\n    \\t\\tres = customers.size() + customers.back() / 4;\\n\\n    \\tif((customers.back() % 4 * boardingCost) > runningCost)\\n    \\t\\tres = customers.size() + customers.back() / 4 + 1; \\n\\n    \\treturn res;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 866625,
                "title": "java-easy",
                "content": "```\\nclass Solution {\\n    public int minOperationsMaxProfit(int[] customers, int boardingCost, int runningCost) {\\n        int customersWaiting = 0;\\n        int profit = 0;\\n        int maxProfit = -1;\\n        int roationNoWhenProfitisMax = -1;\\n        int customersOnBoard = 0;\\n        int rotation = 0;\\n        \\n        for(int i=0; i<customers.length; i++){\\n            customersWaiting+=customers[i];\\n            int board= customersWaiting>=4 ? 4: customersWaiting;\\n            customersOnBoard+=board;\\n            customersWaiting-=board;\\n            rotation++;\\n            \\n            profit = customersOnBoard*boardingCost - rotation*runningCost;\\n            \\n            if(maxProfit < profit){\\n                maxProfit = profit;\\n                roationNoWhenProfitisMax = rotation;\\n            }\\n            \\n        }\\n        \\n        while(customersWaiting!=0){\\n            int board= customersWaiting>=4 ? 4: customersWaiting;\\n            customersOnBoard+=board;\\n            customersWaiting-=board;\\n            rotation++;\\n            \\n            profit = customersOnBoard*boardingCost - rotation*runningCost;\\n            \\n            if(maxProfit < profit){\\n                maxProfit = profit;\\n                roationNoWhenProfitisMax = rotation;\\n            }   \\n        }\\n        \\n        return roationNoWhenProfitisMax;\\n        \\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    public int minOperationsMaxProfit(int[] customers, int boardingCost, int runningCost) {\\n        int customersWaiting = 0;\\n        int profit = 0;\\n        int maxProfit = -1;\\n        int roationNoWhenProfitisMax = -1;\\n        int customersOnBoard = 0;\\n        int rotation = 0;\\n        \\n        for(int i=0; i<customers.length; i++){\\n            customersWaiting+=customers[i];\\n            int board= customersWaiting>=4 ? 4: customersWaiting;\\n            customersOnBoard+=board;\\n            customersWaiting-=board;\\n            rotation++;\\n            \\n            profit = customersOnBoard*boardingCost - rotation*runningCost;\\n            \\n            if(maxProfit < profit){\\n                maxProfit = profit;\\n                roationNoWhenProfitisMax = rotation;\\n            }\\n            \\n        }\\n        \\n        while(customersWaiting!=0){\\n            int board= customersWaiting>=4 ? 4: customersWaiting;\\n            customersOnBoard+=board;\\n            customersWaiting-=board;\\n            rotation++;\\n            \\n            profit = customersOnBoard*boardingCost - rotation*runningCost;\\n            \\n            if(maxProfit < profit){\\n                maxProfit = profit;\\n                roationNoWhenProfitisMax = rotation;\\n            }   \\n        }\\n        \\n        return roationNoWhenProfitisMax;\\n        \\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 866623,
                "title": "simple-c-beats-100-few-lines-greedy-solution",
                "content": "result: the final profits\\ntimes: the final return value\\ncurrent: the current profits\\npeople: current number of people waiting\\nnumber: number of new arriving people in current round\\nboardWheel: people boarding the wheel currently\\n```\\nint minOperationsMaxProfit(vector<int>& customers, int boardingCost, int runningCost) \\n{\\n\\tint result=-1,times=-1,current=0,people=0;\\n\\tfor(int i=0;i<customers.size()||people>0;i++)\\n\\t{\\n\\t\\tint number=(i<customers.size())?customers[i]:0;\\n\\t\\tint boardWheel=min(4,number+people);\\n\\t\\tpeople+=number-boardWheel;\\n\\t\\tcurrent+=boardWheel*boardingCost-runningCost;\\n\\t\\tif(current>result)\\n\\t\\t{\\n\\t\\t\\tresult=current;\\n\\t\\t\\ttimes=i+1;\\n\\t\\t}\\n\\t}\\n\\treturn times;\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nint minOperationsMaxProfit(vector<int>& customers, int boardingCost, int runningCost) \\n{\\n\\tint result=-1,times=-1,current=0,people=0;\\n\\tfor(int i=0;i<customers.size()||people>0;i++)\\n\\t{\\n\\t\\tint number=(i<customers.size())?customers[i]:0;\\n\\t\\tint boardWheel=min(4,number+people);\\n\\t\\tpeople+=number-boardWheel;\\n\\t\\tcurrent+=boardWheel*boardingCost-runningCost;\\n\\t\\tif(current>result)\\n\\t\\t{\\n\\t\\t\\tresult=current;\\n\\t\\t\\ttimes=i+1;\\n\\t\\t}\\n\\t}\\n\\treturn times;\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 866615,
                "title": "need-help-java-solved",
                "content": "```java\\nclass Solution {\\n    public int minOperationsMaxProfit(int[] customers, int boardingCost, int runningCost) {\\n\\n        int sum = 0;\\n        int profit = 0;\\n        int maxProfit = 0;\\n        int run = 0;\\n        int maxRun = 0;\\n        \\n        for(int i=0; i<customers.length; i++) {\\n            sum += customers[i];   // The total customers arrivied when i-th batch customers arrived.\\n            profit = Math.min(sum, 4 * (i+1)) * boardingCost - (i+1) * runningCost;  // After (i+1) rotations, at most 4*(i+1) customers can on board.\\n            run++;  // Wrong here! If there is no customer waiting, it needs no rotation.\\n            \\n            if(profit > maxProfit) {\\n                maxProfit = profit;\\n                maxRun = run;\\n            }\\n        }\\n        sum -= 4 * customers.length;\\n\\n        while(sum >= 4) {\\n            profit += (4 * boardingCost - runningCost);\\n            sum -= 4;\\n            run++;\\n            if(profit > maxProfit) {\\n                maxProfit = profit;\\n                maxRun = run;\\n            }\\n        }\\n        if(sum > 0) {\\n            profit += (sum * boardingCost - runningCost);\\n            run++;\\n            if(profit > maxProfit) {\\n                maxProfit = profit;\\n                maxRun = run;\\n            }\\n        }\\n        return (maxProfit < 0) ? -1 : maxRun;\\n    }\\n}\\n```\\n\\nUnpass Test: \\n```java\\n[0,43,37,9,23,35,18,7,45,3,8,24,1,6,37,2,38,15,1,14,39,27,4,25,27,33,43,8,44,30,38,40,20,5,17,27,43,11,6,2,30,49,30,25,32,3,18,23,45,43,30,14,41,17,42,42,44,38,18,26,32,48,37,5,37,21,2,9,48,48,40,45,25,30,49,41,4,48,40,29,23,17,7,5,44,23,43,9,35,26,44,3,26,16,31,11,9,4,28,49,43,39,9,39,37,7,6,7,16,1,30,2,4,43,23,16,39,5,30,23,39,29,31,26,35,15,5,11,45,44,45,43,4,24,40,7,36,10,10,18,6,20,13,11,20,3,32,49,34,41,13,11,3,13,0,13,44,48,43,23,12,23,2]\\n43\\n54\\n```\\n\\nOutput: 992\\nExpect: 993",
                "solutionTags": [],
                "code": "```java\\nclass Solution {\\n    public int minOperationsMaxProfit(int[] customers, int boardingCost, int runningCost) {\\n\\n        int sum = 0;\\n        int profit = 0;\\n        int maxProfit = 0;\\n        int run = 0;\\n        int maxRun = 0;\\n        \\n        for(int i=0; i<customers.length; i++) {\\n            sum += customers[i];   // The total customers arrivied when i-th batch customers arrived.\\n            profit = Math.min(sum, 4 * (i+1)) * boardingCost - (i+1) * runningCost;  // After (i+1) rotations, at most 4*(i+1) customers can on board.\\n            run++;  // Wrong here! If there is no customer waiting, it needs no rotation.\\n            \\n            if(profit > maxProfit) {\\n                maxProfit = profit;\\n                maxRun = run;\\n            }\\n        }\\n        sum -= 4 * customers.length;\\n\\n        while(sum >= 4) {\\n            profit += (4 * boardingCost - runningCost);\\n            sum -= 4;\\n            run++;\\n            if(profit > maxProfit) {\\n                maxProfit = profit;\\n                maxRun = run;\\n            }\\n        }\\n        if(sum > 0) {\\n            profit += (sum * boardingCost - runningCost);\\n            run++;\\n            if(profit > maxProfit) {\\n                maxProfit = profit;\\n                maxRun = run;\\n            }\\n        }\\n        return (maxProfit < 0) ? -1 : maxRun;\\n    }\\n}\\n```\n```java\\n[0,43,37,9,23,35,18,7,45,3,8,24,1,6,37,2,38,15,1,14,39,27,4,25,27,33,43,8,44,30,38,40,20,5,17,27,43,11,6,2,30,49,30,25,32,3,18,23,45,43,30,14,41,17,42,42,44,38,18,26,32,48,37,5,37,21,2,9,48,48,40,45,25,30,49,41,4,48,40,29,23,17,7,5,44,23,43,9,35,26,44,3,26,16,31,11,9,4,28,49,43,39,9,39,37,7,6,7,16,1,30,2,4,43,23,16,39,5,30,23,39,29,31,26,35,15,5,11,45,44,45,43,4,24,40,7,36,10,10,18,6,20,13,11,20,3,32,49,34,41,13,11,3,13,0,13,44,48,43,23,12,23,2]\\n43\\n54\\n```",
                "codeTag": "Java"
            },
            {
                "id": 866611,
                "title": "some-test-cases-fail-python3",
                "content": "Simple brute force approach, not sure why few test cases are failing, any idea please?\\n\\n\\n\\n\\t\\tboarded = 0\\n        shifts_so_far = 0\\n        max_shifts = -1\\n        max_profit = float(\\'-inf\\')\\n        shifts = 0\\n        waiting = 0\\n        \\n        for c in customers:\\n            waiting = waiting+c\\n            while waiting>=4:\\n                boarded += 4\\n                shifts += 1\\n                profit = boarded*boardingCost - shifts*runningCost\\n                if profit>0 and profit>max_profit:\\n                    max_profit = profit\\n                    max_shifts = shifts\\n\\n                waiting -= 4\\n            else:\\n                continue\\n        \\n        \\n        shifts += 1\\n        boarded += waiting\\n        profit = boarded*boardingCost - shifts*runningCost\\n        if profit>0 and profit>max_profit:\\n            print (shifts)\\n            max_profit = profit\\n            max_shifts = shifts    \\n        waiting = 0\\n                \\n        \\n        return max_shifts",
                "solutionTags": [],
                "code": "Simple brute force approach, not sure why few test cases are failing, any idea please?\\n\\n\\n\\n\\t\\tboarded = 0\\n        shifts_so_far = 0\\n        max_shifts = -1\\n        max_profit = float(\\'-inf\\')\\n        shifts = 0\\n        waiting = 0\\n        \\n        for c in customers:\\n            waiting = waiting+c\\n            while waiting>=4:\\n                boarded += 4\\n                shifts += 1\\n                profit = boarded*boardingCost - shifts*runningCost\\n                if profit>0 and profit>max_profit:\\n                    max_profit = profit\\n                    max_shifts = shifts\\n\\n                waiting -= 4\\n            else:\\n                continue\\n        \\n        \\n        shifts += 1\\n        boarded += waiting\\n        profit = boarded*boardingCost - shifts*runningCost\\n        if profit>0 and profit>max_profit:\\n            print (shifts)\\n            max_profit = profit\\n            max_shifts = shifts    \\n        waiting = 0\\n                \\n        \\n        return max_shifts",
                "codeTag": "Unknown"
            },
            {
                "id": 866610,
                "title": "python-solution",
                "content": "\\tclass Solution:\\n\\t\\tdef minOperationsMaxProfit(self, customers: List[int], boardingCost: int, runningCost: int) -> int:        \\n\\t\\t\\tremain = 0\\n\\t\\t\\tboard = 0\\n\\t\\t\\tprofit = -float(\"inf\")\\n\\t\\t\\tcnt = 0\\n\\t\\t\\tres = 0\\n\\t\\t\\twhile board != sum(customers):\\n\\t\\t\\t\\tfor i in customers:\\n\\t\\t\\t\\t\\tremain += i                \\n\\t\\t\\t\\t\\tif remain > 4:\\n\\t\\t\\t\\t\\t\\tboard += 4\\n\\t\\t\\t\\t\\t\\tremain -= 4\\n\\t\\t\\t\\t\\telse:\\n\\t\\t\\t\\t\\t\\tboard += remain\\n\\t\\t\\t\\t\\t\\tremain = 0\\n\\t\\t\\t\\t\\tif board * boardingCost - (cnt + 1) * runningCost > profit:\\n\\t\\t\\t\\t\\t\\tprofit = board * boardingCost - (cnt + 1) * runningCost\\n\\t\\t\\t\\t\\t\\tres = cnt + 1\\n\\t\\t\\t\\t\\tcnt += 1\\n\\t\\t\\t\\twhile remain > 0:\\n\\t\\t\\t\\t\\tif remain > 4:\\n\\t\\t\\t\\t\\t\\tboard += 4\\n\\t\\t\\t\\t\\t\\tremain -= 4\\n\\t\\t\\t\\t\\telse:\\n\\t\\t\\t\\t\\t\\tboard += remain\\n\\t\\t\\t\\t\\t\\tremain = 0\\n\\t\\t\\t\\t\\tif board * boardingCost - (cnt + 1) * runningCost > profit:\\n\\t\\t\\t\\t\\t\\tprofit = board * boardingCost - (cnt + 1) * runningCost\\n\\t\\t\\t\\t\\t\\tres = cnt + 1\\n\\t\\t\\t\\t\\tcnt += 1\\n\\t\\t\\tif profit > 0:\\n\\t\\t\\t\\treturn res\\n\\t\\t\\telse:\\n\\t\\t\\t\\treturn -1",
                "solutionTags": [],
                "code": "\\tclass Solution:\\n\\t\\tdef minOperationsMaxProfit(self, customers: List[int], boardingCost: int, runningCost: int) -> int:        \\n\\t\\t\\tremain = 0\\n\\t\\t\\tboard = 0\\n\\t\\t\\tprofit = -float(\"inf\")\\n\\t\\t\\tcnt = 0\\n\\t\\t\\tres = 0\\n\\t\\t\\twhile board != sum(customers):\\n\\t\\t\\t\\tfor i in customers:\\n\\t\\t\\t\\t\\tremain += i                \\n\\t\\t\\t\\t\\tif remain > 4:\\n\\t\\t\\t\\t\\t\\tboard += 4\\n\\t\\t\\t\\t\\t\\tremain -= 4\\n\\t\\t\\t\\t\\telse:\\n\\t\\t\\t\\t\\t\\tboard += remain\\n\\t\\t\\t\\t\\t\\tremain = 0\\n\\t\\t\\t\\t\\tif board * boardingCost - (cnt + 1) * runningCost > profit:\\n\\t\\t\\t\\t\\t\\tprofit = board * boardingCost - (cnt + 1) * runningCost\\n\\t\\t\\t\\t\\t\\tres = cnt + 1\\n\\t\\t\\t\\t\\tcnt += 1\\n\\t\\t\\t\\twhile remain > 0:\\n\\t\\t\\t\\t\\tif remain > 4:\\n\\t\\t\\t\\t\\t\\tboard += 4\\n\\t\\t\\t\\t\\t\\tremain -= 4\\n\\t\\t\\t\\t\\telse:\\n\\t\\t\\t\\t\\t\\tboard += remain\\n\\t\\t\\t\\t\\t\\tremain = 0\\n\\t\\t\\t\\t\\tif board * boardingCost - (cnt + 1) * runningCost > profit:\\n\\t\\t\\t\\t\\t\\tprofit = board * boardingCost - (cnt + 1) * runningCost\\n\\t\\t\\t\\t\\t\\tres = cnt + 1\\n\\t\\t\\t\\t\\tcnt += 1\\n\\t\\t\\tif profit > 0:\\n\\t\\t\\t\\treturn res\\n\\t\\t\\telse:\\n\\t\\t\\t\\treturn -1",
                "codeTag": "Java"
            },
            {
                "id": 866598,
                "title": "java-o-n-easy-solution-with-comments",
                "content": "The goal here is to record the best possible(profitable or maximum) cost and rotations  that can be acheived  during the entire process (until all customers are served). The best possible solution is to simulate the rotation and record the profit for each rotation.  \\nUPDATE - A greedy solution also works. well with less code\\n```\\nclass Solution {\\n     int cost = 0; \\n     int times  = 0;\\n      int ans = Integer.MIN_VALUE;\\n    public int minOperationsMaxProfit(int[] customers, int boardingCost, int runningCost) {\\n        int n = customers.length; \\n      \\n        int totalBoarded =0; // curr boarded passengers\\n        int waiting = 0; // waiting queue\\n        int rotate = 0;\\n       \\n        for(int i = 0 ; i < n ; i++){\\n            rotate++; // rotate the wheel for every input irrespective of 0 or more customers;\\n            waiting += customers[i]; // add the customers to waiting queue first\\n            if(waiting > 4){\\n                waiting-= 4;\\n                totalBoarded += 4;\\n            }else{\\n                totalBoarded += waiting;\\n                waiting = 0;\\n            }\\t\\t\\n\\t\\t\\tcalculatecostSofar(totalBoarded,boardingCost,rotate,runningCost);             \\n        }\\n\\t\\t// After servicing all customers , if still there are customers in waiting queue , repeat the same process;\\n         while(waiting > 0){\\n            rotate ++; \\n            if(waiting > 4){\\n                waiting-= 4;\\n                totalBoarded += 4;\\n            }else{\\n                totalBoarded += waiting;\\n                waiting = 0;\\n            }\\n          calculatecostSofar(totalBoarded,boardingCost,rotate,runningCost);    \\n        }\\n\\t\\t//if the answer is less than 0 then the spinner did not get a profit atall so return -1 else return the recorded \\n\\t\\t//optimal times rotated.\\n\\t\\treturn ans < 0 ? -1 : times;\\n    }\\n\\tprivate void calculatecostSofar(int boarded, int boardincost, int rotationsMadeSofar, int runningCost){\\n\\t       //calculate cost ref quest\\n\\t\\t\\tcost = boarded * boardincost - rotationsMadeSofar * runningCost;\\n\\t\\t\\t//Check if the cost is greater than the one recorded so far , if yes update the final answer\\n\\t\\t\\t// Note - the question states that , if during the process at any point i get a positive amount \\n\\t\\t\\t//that is the maximum amount i get, so i need to record that value . \\n\\t\\t\\tif(cost > ans){\\n                ans = cost;\\n                times = rotationsMadeSofar;\\n           }\\n\\t}  \\n}",
                "solutionTags": [],
                "code": "class Solution {\\n     int cost = 0; \\n     int times  = 0;\\n      int ans = Integer.MIN_VALUE;\\n    public int minOperationsMaxProfit(int[] customers, int boardingCost, int runningCost) {\\n        int n = customers.length; \\n      \\n        int totalBoarded =0; // curr boarded passengers\\n        int waiting = 0; // waiting queue\\n        int rotate = 0;\\n       \\n        for(int i = 0 ; i < n ; i++){\\n            rotate++; // rotate the wheel for every input irrespective of 0 or more customers;\\n            waiting += customers[i]; // add the customers to waiting queue first\\n            if(waiting > 4){\\n                waiting-= 4;\\n                totalBoarded += 4;\\n            }",
                "codeTag": "Java"
            }
        ],
        "discussions": []
    }
]