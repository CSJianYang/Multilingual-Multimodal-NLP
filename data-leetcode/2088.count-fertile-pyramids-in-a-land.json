[
    {
        "title": "Count Fertile Pyramids in a Land",
        "question_content": "A farmer has a rectangular grid of land with m rows and n columns that can be divided into unit cells. Each cell is either fertile (represented by a 1) or barren (represented by a 0). All cells outside the grid are considered barren.\nA pyramidal plot of land can be defined as a set of cells with the following criteria:\n\n\tThe number of cells in the set has to be greater than 1 and all cells must be fertile.\n\tThe apex of a pyramid is the topmost cell of the pyramid. The height of a pyramid is the number of rows it covers. Let (r, c) be the apex of the pyramid, and its height be h. Then, the plot comprises of cells (i, j) where r <= i <= r + h - 1 and c - (i - r) <= j <= c + (i - r).\n\nAn inverse pyramidal plot of land can be defined as a set of cells with similar criteria:\n\n\tThe number of cells in the set has to be greater than 1 and all cells must be fertile.\n\tThe apex of an inverse pyramid is the bottommost cell of the inverse pyramid. The height of an inverse pyramid is the number of rows it covers. Let (r, c) be the apex of the pyramid, and its height be h. Then, the plot comprises of cells (i, j) where r - h + 1 <= i <= r and c - (r - i) <= j <= c + (r - i).\n\nSome examples of valid and invalid pyramidal (and inverse pyramidal) plots are shown below. Black cells indicate fertile cells.\nGiven a 0-indexed m x n binary matrix grid representing the farmland, return the total number of pyramidal and inverse pyramidal plots that can be found in grid.\n&nbsp;\nExample 1:\n\nInput: grid = [[0,1,1,0],[1,1,1,1]]\nOutput: 2\nExplanation: The 2 possible pyramidal plots are shown in blue and red respectively.\nThere are no inverse pyramidal plots in this grid. \nHence total number of pyramidal and inverse pyramidal plots is 2 + 0 = 2.\n\nExample 2:\n\nInput: grid = [[1,1,1],[1,1,1]]\nOutput: 2\nExplanation: The pyramidal plot is shown in blue, and the inverse pyramidal plot is shown in red. \nHence the total number of plots is 1 + 1 = 2.\n\nExample 3:\n\nInput: grid = [[1,1,1,1,0],[1,1,1,1,1],[1,1,1,1,1],[0,1,0,0,1]]\nOutput: 13\nExplanation: There are 7 pyramidal plots, 3 of which are shown in the 2nd and 3rd figures.\nThere are 6 inverse pyramidal plots, 2 of which are shown in the last figure.\nThe total number of plots is 7 + 6 = 13.\n\n&nbsp;\nConstraints:\n\n\tm == grid.length\n\tn == grid[i].length\n\t1 <= m, n <= 1000\n\t1 <= m * n <= 105\n\tgrid[i][j] is either 0 or 1.",
        "solutions": [
            {
                "id": 1598908,
                "title": "simple-dp-solution-with-explanation-c-o-n-m",
                "content": "The key point here is how to represent a pyramid. For sake of simplicity assume a fertile land as a pyramid of height 1. \\n\\nNow, A pyramid of height 2 can be seen as two joint pyramid of height 1 and two extra 1s (the peak and one just below it).\\n```\\n0 1 0        0 2 0\\n1 1 1        1 1 1\\n```\\n\\n\\nSimiliarly, A pyramid of height 3 can be seen as two joint pyramid of height 2 and two extra 1s (the peak and one just below it).\\n```\\n0 0 1 0 0           0 0 3 0 0\\n0 1 1 1 0           0 2 2 2 0\\n1 1 1 1 1           1 1 1 1 1\\n```\\n\\nAnd so on...\\n\\nOnce this is clear, the rest of the code is simple. We just need to keep the count of all pyramids with height greater than 1. For that just itererate over the grid and check whether the current cell is the tip of pyramid or not. If it is a pyramid, then find its height. This can be done in O(1).\\n\\nAnd we only need to write code for one type of pyramid (inverse). For other type simply reverse all the rows and count again.\\n\\n\\n**NOTE: The examples above are for Simple Pyramid. But the code below counts for the inverse pyramids as it is easier to write.**\\n\\n```\\nclass Solution {\\npublic:\\n    int count(vector<vector<int>> grid){\\n        int i, j, n = grid.size(), m = grid[0].size(), ans = 0;\\n        for(i = 1; i < n; i++){\\n            for(j = 1; j < m - 1; j++){\\n                if(grid[i][j] && grid[i - 1][j]){ // check if current cell can be a tip of pyramid or not.\\n                    grid[i][j] = min(grid[i - 1][j - 1], grid[i - 1][j + 1]) + 1; // if its a pyramid, find the height.\\n                    ans += grid[i][j] - 1;\\n\\t\\t\\t\\t\\t// pyramid of size n contributes n - 1 times to the answer.\\n                }\\n            }\\n        }\\n        return ans;\\n    }\\n    int countPyramids(vector<vector<int>>& grid) {\\n        int ans = count(grid); // this will count inverse pyramid.\\n        reverse(grid.begin(), grid.end());  \\n        ans += count(grid); // this will count simple pyramid.\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "Dynamic Programming"
                ],
                "code": "```\\n0 1 0        0 2 0\\n1 1 1        1 1 1\\n```\n```\\n0 0 1 0 0           0 0 3 0 0\\n0 1 1 1 0           0 2 2 2 0\\n1 1 1 1 1           1 1 1 1 1\\n```\n```\\nclass Solution {\\npublic:\\n    int count(vector<vector<int>> grid){\\n        int i, j, n = grid.size(), m = grid[0].size(), ans = 0;\\n        for(i = 1; i < n; i++){\\n            for(j = 1; j < m - 1; j++){\\n                if(grid[i][j] && grid[i - 1][j]){ // check if current cell can be a tip of pyramid or not.\\n                    grid[i][j] = min(grid[i - 1][j - 1], grid[i - 1][j + 1]) + 1; // if its a pyramid, find the height.\\n                    ans += grid[i][j] - 1;\\n\\t\\t\\t\\t\\t// pyramid of size n contributes n - 1 times to the answer.\\n                }\\n            }\\n        }\\n        return ans;\\n    }\\n    int countPyramids(vector<vector<int>>& grid) {\\n        int ans = count(grid); // this will count inverse pyramid.\\n        reverse(grid.begin(), grid.end());  \\n        ans += count(grid); // this will count simple pyramid.\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1599051,
                "title": "python-short-dp-explained",
                "content": "How to find the biggest piramide with given top `(x, y)`? We need to look at points `(x +1, y - 1)` and `(x+1, y+1)` and find the biggest pyramides for these points: we choose the minimum of it and we also check that `G[x+1][y]` is also equal to `1`. How to deal with upside-down pyramides? In very similar way, but now we use `dr` direction variable.\\n\\n#### Complexity\\nIt is `O(mn)` for time and space.\\n\\n#### Code\\n```python\\nclass Solution:\\n    def countPyramids(self, G):\\n        m, n, ans = len(G), len(G[0]), 0\\n        \\n        @lru_cache(None)\\n        def dp(i, j, dr):\\n            if G[i][j] == 1 and 0 <= i + dr < m and j > 0 and j + 1 < n and G[i+dr][j] == 1:\\n                return min(dp(i+dr, j-1, dr), dp(i+dr, j+1, dr)) + 1\\n            return G[i][j]\\n        \\n        for i, j in product(range(m), range(n)):\\n            ans += max(0, dp(i, j, 1) - 1)\\n            ans += max(0, dp(i, j, -1) - 1)\\n        \\n        return ans\\n```\\n\\nIf you have any question, feel free to ask. If you like the explanations, please **Upvote!**",
                "solutionTags": [
                    "Dynamic Programming"
                ],
                "code": "```python\\nclass Solution:\\n    def countPyramids(self, G):\\n        m, n, ans = len(G), len(G[0]), 0\\n        \\n        @lru_cache(None)\\n        def dp(i, j, dr):\\n            if G[i][j] == 1 and 0 <= i + dr < m and j > 0 and j + 1 < n and G[i+dr][j] == 1:\\n                return min(dp(i+dr, j-1, dr), dp(i+dr, j+1, dr)) + 1\\n            return G[i][j]\\n        \\n        for i, j in product(range(m), range(n)):\\n            ans += max(0, dp(i, j, 1) - 1)\\n            ans += max(0, dp(i, j, -1) - 1)\\n        \\n        return ans\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1599491,
                "title": "stack-pyramids",
                "content": "The center of a pyramid with height `h` must be right below the center of a pyramid with height `h - 1` (or greater).\\n\\n![image](https://assets.leetcode.com/users/images/b14f3f82-92bd-4f3d-b4a2-a3d90214d283_1638048398.8601263.png)\\n\\nWe count consecutive land in a row. For a given count `cnt`, we can potentially have pyramids with `h` from `1` up to `(cnt - 1) / 2`. So, we check the height of pyramids above each potential pyramid (`g[i - 1][j - h]`). If a new pyramid can be formed, we mark its center with `h + 1` - so that we can use it to quickly check pyramids below.\\n\\n**C++**\\n```cpp\\nint count(vector<vector<int>>& g) {\\n    int m = g.size(), n = g[0].size(), res = 0;\\n    for (int i = 1; i < m; ++i) {\\n        for (int j = 0, cnt = 0; j < n; ++j) {\\n            cnt = g[i][j] + (g[i][j] ? cnt : 0);\\n            for (int h = 1; cnt > h * 2 && g[i - 1][j - h] >= h; ++h, ++res)\\n                g[i][j - h] = h + 1;\\n        }\\n    }\\n    return res;\\n}\\nint countPyramids(vector<vector<int>>& grid) {\\n    vector<vector<int>> flip_grid(rbegin(grid), rend(grid));\\n    return count(grid) + count(flip_grid);\\n}\\n```",
                "solutionTags": [
                    "C"
                ],
                "code": "```cpp\\nint count(vector<vector<int>>& g) {\\n    int m = g.size(), n = g[0].size(), res = 0;\\n    for (int i = 1; i < m; ++i) {\\n        for (int j = 0, cnt = 0; j < n; ++j) {\\n            cnt = g[i][j] + (g[i][j] ? cnt : 0);\\n            for (int h = 1; cnt > h * 2 && g[i - 1][j - h] >= h; ++h, ++res)\\n                g[i][j - h] = h + 1;\\n        }\\n    }\\n    return res;\\n}\\nint countPyramids(vector<vector<int>>& grid) {\\n    vector<vector<int>> flip_grid(rbegin(grid), rend(grid));\\n    return count(grid) + count(flip_grid);\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1598926,
                "title": "java-o-mn-label-and-count-with-explanation-14ms-beats-100",
                "content": "**Thinking Process**\\n* At the beginning, I consider of using prefix sum so that I can check if current row is valid in O(1)\\n* For a 3-layer pyramid, f(3) = 1 + 3 x f(2), it seems it can be calculated by math approach. But how do I remove duplicates?\\n* Then I think I may try the approach similar to calculating the largest histogram or rectangle areas problems. \\n* So I focused on `the pyramids formed by the current cell` and drew some examples to find out the rules.\\n* We can count the number of pyramid with the bottom-right cell located at grid[i][j].\\n* Let `grid[i][j] indicates the layer of largest pyramid which the bottom-right cell is the current cell` then the number of pyramid formed by current cell is equal to `grid[i][j] - 1`\\n* grid[i][j] is determined by grid[i - 1][j - 1] and the number of consecutive fertile cells which ends at the current cell. For example, if `grid[i - 1][j - 1] is 3` then the largest pyramid can be formed by current cell is at most `4`. If the consecutive fertile cells is `3`, the layer is at most `2` for the current cell. Thus, we pick the smaller one.\\n\\n**Example**\\nInput\\n```\\n1 1 1 1 0\\n1 1 1 1 1\\n1 1 1 1 1\\n0 1 0 0 1\\n```\\nAfter labelling\\n```\\n1 1 1 1 0 \\n1 1 2 2 2 \\n1 1 2 2 3 \\n0 1 0 0 1\\n```\\n```\\nclass Solution {\\n    public int countPyramids(int[][] grid) {\\n        int m = grid.length, n = grid[0].length;\\n        int[][] rev = new int[m][n];\\n        for (int i = 0; i < m; ++i) {\\n            for (int j = 0; j < n; ++j) rev[m - i - 1][j] = grid[i][j];\\n        }\\n        return cal(grid) + cal(rev);\\n    }\\n    private int cal(int[][] grid) {\\n        int m = grid.length, n = grid[0].length, res = 0;\\n        for (int i = 1; i < m; ++i) {\\n            for (int j = 0, cnt = 0; j < n; ++j) {\\n                if (0 != grid[i][j]) cnt++;\\n                else cnt = 0;\\n                if (0 == cnt || 0 == j) continue;\\n                grid[i][j] = Math.min(grid[i - 1][j - 1] + 1, (cnt + 1) >> 1);\\n                res += grid[i][j] - 1;\\n            }\\n        }\\n        return res;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Dynamic Programming"
                ],
                "code": "```\\n1 1 1 1 0\\n1 1 1 1 1\\n1 1 1 1 1\\n0 1 0 0 1\\n```\n```\\n1 1 1 1 0 \\n1 1 2 2 2 \\n1 1 2 2 3 \\n0 1 0 0 1\\n```\n```\\nclass Solution {\\n    public int countPyramids(int[][] grid) {\\n        int m = grid.length, n = grid[0].length;\\n        int[][] rev = new int[m][n];\\n        for (int i = 0; i < m; ++i) {\\n            for (int j = 0; j < n; ++j) rev[m - i - 1][j] = grid[i][j];\\n        }\\n        return cal(grid) + cal(rev);\\n    }\\n    private int cal(int[][] grid) {\\n        int m = grid.length, n = grid[0].length, res = 0;\\n        for (int i = 1; i < m; ++i) {\\n            for (int j = 0, cnt = 0; j < n; ++j) {\\n                if (0 != grid[i][j]) cnt++;\\n                else cnt = 0;\\n                if (0 == cnt || 0 == j) continue;\\n                grid[i][j] = Math.min(grid[i - 1][j - 1] + 1, (cnt + 1) >> 1);\\n                res += grid[i][j] - 1;\\n            }\\n        }\\n        return res;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1602439,
                "title": "python-dp-o-m-n-explained-faster-than-100",
                "content": "```\\nclass Solution:\\n    def countPyramids(self, grid):      \\n        # dp[i][j] represents the number of layers of the largest pyramid with (i, j) as the vertex.\\n        # Note that the 1-level pyramid is invalid in the problem, so it should be removed when summing.\\n        # Note that if grid[i][j] is 0, dp[i][j] will always be 0.\\n        # The dp recurrence formula is dp[i][j] = min(dp[i + 1][j - 1], dp[i + 1][j + 1]) + 1\\n        m, n, dp, cnt = len(grid), len(grid[0]), copy.deepcopy(grid), 0\\n        # triangle\\n        for i in range(m - 2, -1, -1):\\n            for j in range(1, n - 1):\\n                if dp[i][j] > 0 and dp[i + 1][j] > 0:\\n                    dp[i][j] = min(dp[i + 1][j - 1], dp[i + 1][j + 1]) + 1\\n                    cnt += dp[i][j] - 1\\n        # inverted triangle\\n        dp = grid\\n        for i in range(1, m):\\n            for j in range(1, n - 1):\\n                if dp[i][j] > 0 and dp[i - 1][j] > 0:\\n                    dp[i][j] = min(dp[i - 1][j - 1], dp[i - 1][j + 1]) + 1\\n                    cnt += dp[i][j] - 1\\n        return cnt\\n```\\n**Please UPVOTE!**",
                "solutionTags": [
                    "Python",
                    "Dynamic Programming"
                ],
                "code": "```\\nclass Solution:\\n    def countPyramids(self, grid):      \\n        # dp[i][j] represents the number of layers of the largest pyramid with (i, j) as the vertex.\\n        # Note that the 1-level pyramid is invalid in the problem, so it should be removed when summing.\\n        # Note that if grid[i][j] is 0, dp[i][j] will always be 0.\\n        # The dp recurrence formula is dp[i][j] = min(dp[i + 1][j - 1], dp[i + 1][j + 1]) + 1\\n        m, n, dp, cnt = len(grid), len(grid[0]), copy.deepcopy(grid), 0\\n        # triangle\\n        for i in range(m - 2, -1, -1):\\n            for j in range(1, n - 1):\\n                if dp[i][j] > 0 and dp[i + 1][j] > 0:\\n                    dp[i][j] = min(dp[i + 1][j - 1], dp[i + 1][j + 1]) + 1\\n                    cnt += dp[i][j] - 1\\n        # inverted triangle\\n        dp = grid\\n        for i in range(1, m):\\n            for j in range(1, n - 1):\\n                if dp[i][j] > 0 and dp[i - 1][j] > 0:\\n                    dp[i][j] = min(dp[i - 1][j - 1], dp[i - 1][j + 1]) + 1\\n                    cnt += dp[i][j] - 1\\n        return cnt\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1599416,
                "title": "c-recursion-memoization-with-images",
                "content": "**Intuition:** Every pyramid can be broken into **two** smaller overlapping pyramids, and those 2 pyramids can be further broken.\\n\\nIf the cell below the apex, is non-zero and the 2 smaller pyramids are valid, we can extend the height of the two overlapping smaller pyramids, by 1.\\n\\nRecurrence relation, \\n`f(i, j) = 1 + min(f(i+1, j-1), f(i+1, j+1))`\\nwhere f(i, j) is the height of largest pyramid, whose apex is at i,j.\\n\\nThe height helps us induce, the count of total pyramids, whose apex is (i, j).\\nfor eg. a pyramid with height 3 (covers 3 rows), has 2 pyramids.\\nSo essentially, by finding the height, we can also count the pyramids, for a given (i, j).\\n\\nThese examples will clarify some doubts.\\n![image](https://assets.leetcode.com/users/images/db67d6b0-40c5-4d4e-b413-e233e73b440f_1638043914.6366222.png)\\n\\nIn order to count the inverse pyramids, the given grid can be reversed.\\n\\nBelow is the C++ implementation of this approach.\\n```\\nclass Solution {\\npublic:\\n    int f(vector<vector<int>>&grid, int i, int j, vector<vector<int>>&dp){\\n        if(j<0 || j>=grid[0].size() || !grid[i][j]) return -1;\\n        else if(dp[i][j]!=-1) return dp[i][j];\\n\\t\\t\\n        if(i+1>=grid.size() || !grid[i+1][j]) return dp[i][j] = 0;\\n        return dp[i][j] =  1 + min(f(grid, i+1, j-1, dp), f(grid, i+1, j+1, dp));\\n    }\\n    int countPyramids(vector<vector<int>>& grid) {\\n        int res = 0, n = grid.size(), m = grid[0].size();\\n        vector<vector<int>>dp(n, vector<int>(m, -1));\\n        \\n        for(int i=0; i<n-1; i++)\\n            for(int j=0; j<m-1; j++)\\n                if(grid[i][j]) res+=f(grid, i, j, dp);\\n        \\n        dp = vector<vector<int>>(n, vector<int>(m, -1));\\n        reverse(grid.begin(), grid.end());//flip the grid to consider upside-down pyramid\\n        \\n        for(int i=0; i<n-1; i++)\\n            for(int j=0; j<m-1; j++)\\n                if(grid[i][j]) res+=f(grid, i, j, dp);\\n        \\n        return res;\\n    }\\n};\\n```\\nWithout memoization, the time complexity would be, O(N * M * 2^min(N, M)), this can be figured out by drawing the recursion tree.\\n\\nWith memoization,\\n**Time Complexity:** O(N * M)\\n**Space Complexity:** O(N * M)\\n\\nA simple way of analysing time complexity of a memoized dfs, is, by looking at the *table dimensions* and the *time complexity of the dfs function*.\\n\\n**Similar Question:** [221. Maximal Square](https://leetcode.com/problems/count-fertile-pyramids-in-a-land/)\\n\\n",
                "solutionTags": [
                    "C",
                    "Dynamic Programming"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int f(vector<vector<int>>&grid, int i, int j, vector<vector<int>>&dp){\\n        if(j<0 || j>=grid[0].size() || !grid[i][j]) return -1;\\n        else if(dp[i][j]!=-1) return dp[i][j];\\n\\t\\t\\n        if(i+1>=grid.size() || !grid[i+1][j]) return dp[i][j] = 0;\\n        return dp[i][j] =  1 + min(f(grid, i+1, j-1, dp), f(grid, i+1, j+1, dp));\\n    }\\n    int countPyramids(vector<vector<int>>& grid) {\\n        int res = 0, n = grid.size(), m = grid[0].size();\\n        vector<vector<int>>dp(n, vector<int>(m, -1));\\n        \\n        for(int i=0; i<n-1; i++)\\n            for(int j=0; j<m-1; j++)\\n                if(grid[i][j]) res+=f(grid, i, j, dp);\\n        \\n        dp = vector<vector<int>>(n, vector<int>(m, -1));\\n        reverse(grid.begin(), grid.end());//flip the grid to consider upside-down pyramid\\n        \\n        for(int i=0; i<n-1; i++)\\n            for(int j=0; j<m-1; j++)\\n                if(grid[i][j]) res+=f(grid, i, j, dp);\\n        \\n        return res;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1881968,
                "title": "c-simple-explained-code-easy-to-understand-tc-o-n-m-sc-o-n-m",
                "content": "#### *Please Upvote if it helps\\u2B06\\uFE0F*\\n```\\n//        For the first call of pyramid function the given matrix results :\\n//\\t\\t  [[1,1,1,1,0],                 [[1,1,1,1,0],\\n//\\t       [1,1,1,1,1],                  [1,2,2,1,1],\\n//  \\t   [1,1,1,1,1],   --------->     [1,2,2,2,1],\\n//\\t\\t   [0,1,0,0,1]]                  [0,2,0,0,1]]\\n\\n//        After reversing the matrix and second call of pyramid function the given matrix results :\\n//\\t\\t  [[0,1,0,0,1],                 [[0,1,0,0,1],\\n//\\t       [1,1,1,1,1],                  [1,1,1,1,1],\\n//  \\t   [1,1,1,1,1],   --------->     [1,2,2,2,1],\\n//\\t\\t   [1,1,1,1,0]]                  [1,2,3,2,0]]\\n\\tvoid pyramids(vector<vector<int>> grid, int &ans){\\n        int n = grid.size(), m = grid[0].size();\\n        for(int i = 1; i < n; i++){\\n            for(int j = 1; j < m - 1; j++){\\n                if(grid[i][j]){\\n                    grid[i][j]= 1+ min(grid[i - 1][j],min(grid[i - 1][j - 1], grid[i - 1][j + 1]));\\n                    ans += grid[i][j] - 1;\\n                }\\n            }\\n        }\\n    }\\n    int countPyramids(vector<vector<int>>& grid) {\\n        int ans =0;\\n        pyramids(grid, ans);\\n        reverse(grid.begin(), grid.end());  \\n        pyramids(grid, ans);\\n        return ans;\\n    }\\n\\t\\n\\t// Time Complexity : O( n*m );\\n\\t// Space Complexity : O( n*m );\\n```",
                "solutionTags": [
                    "C",
                    "Dynamic Programming"
                ],
                "code": "```\\n//        For the first call of pyramid function the given matrix results :\\n//\\t\\t  [[1,1,1,1,0],                 [[1,1,1,1,0],\\n//\\t       [1,1,1,1,1],                  [1,2,2,1,1],\\n//  \\t   [1,1,1,1,1],   --------->     [1,2,2,2,1],\\n//\\t\\t   [0,1,0,0,1]]                  [0,2,0,0,1]]\\n\\n//        After reversing the matrix and second call of pyramid function the given matrix results :\\n//\\t\\t  [[0,1,0,0,1],                 [[0,1,0,0,1],\\n//\\t       [1,1,1,1,1],                  [1,1,1,1,1],\\n//  \\t   [1,1,1,1,1],   --------->     [1,2,2,2,1],\\n//\\t\\t   [1,1,1,1,0]]                  [1,2,3,2,0]]\\n\\tvoid pyramids(vector<vector<int>> grid, int &ans){\\n        int n = grid.size(), m = grid[0].size();\\n        for(int i = 1; i < n; i++){\\n            for(int j = 1; j < m - 1; j++){\\n                if(grid[i][j]){\\n                    grid[i][j]= 1+ min(grid[i - 1][j],min(grid[i - 1][j - 1], grid[i - 1][j + 1]));\\n                    ans += grid[i][j] - 1;\\n                }\\n            }\\n        }\\n    }\\n    int countPyramids(vector<vector<int>>& grid) {\\n        int ans =0;\\n        pyramids(grid, ans);\\n        reverse(grid.begin(), grid.end());  \\n        pyramids(grid, ans);\\n        return ans;\\n    }\\n\\t\\n\\t// Time Complexity : O( n*m );\\n\\t// Space Complexity : O( n*m );\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1598960,
                "title": "python-from-o-m-2-n-2-to-o-mn-detailed-explanation",
                "content": "**Time complexity = O(M^2 * N^2):**\\nSuppose we only need to check non-inverse pyramid (we can just reverse the grid and check again), then we can easily come up with a brute force solution:\\n\\n```\\nans = 0\\nfor every apex (r, c):\\n    for h from 1 to N:\\n        if grid[r][c] == 0:\\n            continue\\n        if h is out of range:\\n            break\\n        if grid[r+h][c-h:c+h+1] has some zeros:\\n            break\\n    ans += h - 1\\n```\\n\\nWe check ```m * n``` apexes, for each apex we check at most ```m``` heights, for each height we check at most ```n``` slots.  The time complexity is ```O(M * M * N * N)```.\\n\\n**Time complexity = O(M^2 * N):**\\nAn obvious optimization is using prefix sum to check if ```grid[r+h][c-h:c+h+1]``` are all 1\\'s:\\n\\n```python\\nclass Solution:\\n    def countPyramids(self, grid: List[List[int]]) -> int:\\n\\n        def get_ans(grid):\\n\\n            cum_sums = [list(accumulate(row, initial=0)) for row in grid]\\n            \\n            ans = 0\\n            for r in range(len(grid)):\\n                for c in range(len(grid[0])):\\n                    if not grid[r][c]:\\n                        continue\\n\\n                    # check pyramid with apex (r, c) and height = h\\n                    for h in count(1):\\n                        # check if h is out of range\\n                        if r + h >= len(grid) or c - h < 0 or c + h >= len(grid[0]):\\n                            break\\n                        # check if row: r+h, col: c-h:c+h+1 are all ones\\n                        if cum_sums[r+h][c+h+1] - cum_sums[r+h][c-h] < h * 2 + 1:\\n                            break\\n                    h -= 1\\n                    ans += h\\n            return ans\\n        \\n        ans = get_ans(grid) + get_ans(grid[::-1])\\n        return ans\\n```\\n\\nWe check ```m * n``` apexes, for each apex we check at most ```m``` heights in ```O(1)```, the total time complexity is ```O(M * M * N)```. However, this is still not enough.\\n\\n**Time complexity = O(M * N):**\\nThe key observation is that:\\n* When we check the max height of ```apex = (0, 2)```, we can get ```h = 2```.\\n* When we check the max height of ```apex = (1, 2)```, we do not need to check ```h = 1``` (the brown pyramid) anymore because the answer of ```apex = (0, 2)``` (the red pyramid) suggests that the brown pyramid exists. We can check from ```h = 2``` (the orange row) instead.\\n\\n![](https://i.imgur.com/FWUMAS5.png)\\n\\n\\nSo we add `last_check` to record the previous answer of every column, and start from the first `h` that we needs to check.\\n\\nLet `last_check[c] = the lowest bottom of valid pyramid with apex in column c`, then the `last_check` will looks like below when we check every row:\\n```\\nrow = 0, last_check = [0, 1, 2, 1, 0]\\nrow = 1, last_check = [1, 2, 2, 2, 1]\\nrow = 1, last_check = [2, 2, 2, 2, 2]\\nrow = 2, last_check = [2, 3, 2, 2, 3]\\n```\\n\\nWe check ```n``` columns, for each column we check at most ```2 * m``` different heights, so the total time complexity is `O(M * N)`.\\n\\n```python\\nclass Solution:\\n    def countPyramids(self, grid: List[List[int]]) -> int:\\n\\n        def get_ans(grid):\\n\\n            cum_sums = [list(accumulate(row, initial=0)) for row in grid]\\n            \\n            # record the lowest bottom of every column index\\n            last_check = [0] * len(grid[0])\\n            \\n            ans = 0\\n            for r in range(len(grid)):\\n                for c in range(len(grid[0])):\\n                    if not grid[r][c]:\\n                        continue\\n\\n                    # check pyramid with apex (r, c) and height = h\\n                    # but start from a larger h\\n                    for h in count(max(1, last_check[c] - r)):\\n                        # check if h is out of range\\n                        if r + h >= len(grid) or c - h < 0 or c + h >= len(grid[0]):\\n                            break\\n                        # check if row: r+h, col: c-h:c+h+1 are all ones\\n                        if cum_sums[r+h][c+h+1] - cum_sums[r+h][c-h] < h * 2 + 1:\\n                            break\\n                    ans += h - 1\\n                    # update the last_check\\n                    last_check[c] = r + h - 1\\n            return ans\\n        \\n        ans = get_ans(grid) + get_ans(grid[::-1])\\n        return ans",
                "solutionTags": [],
                "code": "```\\nans = 0\\nfor every apex (r, c):\\n    for h from 1 to N:\\n        if grid[r][c] == 0:\\n            continue\\n        if h is out of range:\\n            break\\n        if grid[r+h][c-h:c+h+1] has some zeros:\\n            break\\n    ans += h - 1\\n```\n```m * n```\n```m```\n```n```\n```O(M * M * N * N)```\n```grid[r+h][c-h:c+h+1]```\n```python\\nclass Solution:\\n    def countPyramids(self, grid: List[List[int]]) -> int:\\n\\n        def get_ans(grid):\\n\\n            cum_sums = [list(accumulate(row, initial=0)) for row in grid]\\n            \\n            ans = 0\\n            for r in range(len(grid)):\\n                for c in range(len(grid[0])):\\n                    if not grid[r][c]:\\n                        continue\\n\\n                    # check pyramid with apex (r, c) and height = h\\n                    for h in count(1):\\n                        # check if h is out of range\\n                        if r + h >= len(grid) or c - h < 0 or c + h >= len(grid[0]):\\n                            break\\n                        # check if row: r+h, col: c-h:c+h+1 are all ones\\n                        if cum_sums[r+h][c+h+1] - cum_sums[r+h][c-h] < h * 2 + 1:\\n                            break\\n                    h -= 1\\n                    ans += h\\n            return ans\\n        \\n        ans = get_ans(grid) + get_ans(grid[::-1])\\n        return ans\\n```\n```m * n```\n```m```\n```O(1)```\n```O(M * M * N)```\n```apex = (0, 2)```\n```h = 2```\n```apex = (1, 2)```\n```h = 1```\n```apex = (0, 2)```\n```h = 2```\n```\\nrow = 0, last_check = [0, 1, 2, 1, 0]\\nrow = 1, last_check = [1, 2, 2, 2, 1]\\nrow = 1, last_check = [2, 2, 2, 2, 2]\\nrow = 2, last_check = [2, 3, 2, 2, 3]\\n```\n```n```\n```2 * m```",
                "codeTag": "Java"
            },
            {
                "id": 1598873,
                "title": "python3-just-count",
                "content": "Downvoters, leave a comment! \\n\\nFor solutions of biweekly 66, please check out this [commit](https://github.com/gaosanyong/leetcode/commit/2efa877859ad8f79f212b8ebde3edf5730d457ad)\\n```\\nclass Solution:\\n    def countPyramids(self, grid: List[List[int]]) -> int:\\n        m, n = len(grid), len(grid[0])\\n        vals = [[inf]*n for _ in range(m)]\\n        for i in range(m):\\n            for j in range(n): \\n                if grid[i][j] == 0: vals[i][j] = 0\\n                elif j == 0: vals[i][j] = 1\\n                else: vals[i][j] = min(vals[i][j], 1 + vals[i][j-1])\\n                if grid[i][~j] == 0: vals[i][~j] = 0\\n                elif j == 0: vals[i][~j] = 1\\n                else: vals[i][~j] = min(vals[i][~j], 1 + vals[i][~j+1])\\n        \\n        def fn(vals): \\n            \"\"\"Return count of pyramid in given grid.\"\"\"\\n            ans = 0 \\n            for j in range(n):\\n                width = 0\\n                for i in range(m): \\n                    if vals[i][j]: width = min(width+1, vals[i][j])\\n                    else: width = 0\\n                    ans += max(0, width-1)\\n            return ans \\n        \\n        return fn(vals) + fn(vals[::-1])\\n```\\n\\n**AofA**\\ntime complexity `O(MN)`\\nspace complexity `O(MN)`",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def countPyramids(self, grid: List[List[int]]) -> int:\\n        m, n = len(grid), len(grid[0])\\n        vals = [[inf]*n for _ in range(m)]\\n        for i in range(m):\\n            for j in range(n): \\n                if grid[i][j] == 0: vals[i][j] = 0\\n                elif j == 0: vals[i][j] = 1\\n                else: vals[i][j] = min(vals[i][j], 1 + vals[i][j-1])\\n                if grid[i][~j] == 0: vals[i][~j] = 0\\n                elif j == 0: vals[i][~j] = 1\\n                else: vals[i][~j] = min(vals[i][~j], 1 + vals[i][~j+1])\\n        \\n        def fn(vals): \\n            \"\"\"Return count of pyramid in given grid.\"\"\"\\n            ans = 0 \\n            for j in range(n):\\n                width = 0\\n                for i in range(m): \\n                    if vals[i][j]: width = min(width+1, vals[i][j])\\n                    else: width = 0\\n                    ans += max(0, width-1)\\n            return ans \\n        \\n        return fn(vals) + fn(vals[::-1])\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1606479,
                "title": "easy-prefix-sum-accepted-intuition-comment-without-dp",
                "content": "### Easy prefix sum | without DP | step by step\\n#### At the end of the post i have mention how i reach to solution. \\n  \\n  \"\"\"\\n        Intution prefix sum holds the total current consecutive 1\\'s. \\n        ex. \\n        \\n        0 1 1 1 0 0 1 1    prefix       0 1 2 3 0 0 1 2\\n        1 1 1 0 0 1 1 1    ------>      1 2 3 0 0 1 2 3\\n        1 1 0 1 1 0 1 0                 1 2 0 1 2 0 1 0\\n        \\n        1. Now we can see that, \\n            a. for pyramid we need to find that from current i,j next i+1, j+1 should be >= size(i,j) + 2\\n            b. for inverse pyramid we neect to find that from current i,j next i-1,j+1 should be >= size(i,j) + 2\\n            \\n            \\n        \\n        \"\"\"\\n        \\n```\\n        row = len(grid)\\n        col = len(grid[0])\\n        \\n        def downcount(i,j):\\n            \"\"\"find the pramid of all size for i,j\"\"\"\\n            \\n            cnt = 0 \\n            base_length = 1 \\n            while i + 1 < row and j + 1 < col and grid[i+1][j+1] >= base_length + 2:\\n                cnt += 1 \\n                i += 1\\n                j += 1\\n                base_length += 2\\n                \\n            return cnt\\n        \\n        def upcount(i,j):\\n            \"\"\"find the inverse pyramid of all size for i,j\"\"\"\\n            cnt = 0 \\n            base_length = 1 \\n            \\n            while i-1 >= 0 and j + 1 < col and grid[i-1][j+1] >= base_length + 2:\\n                cnt += 1 \\n                i -= 1 \\n                j += 1 \\n                base_length += 2 \\n                \\n            return cnt \\n        \\n        \\n        # make prefix sum of all row\\n        for i in range(row):\\n            for j in range(1, col):\\n                \\n                if grid[i][j]:\\n                    grid[i][j] += grid[i][j-1]\\n                \\n        ans = 0 \\n        \\n        # find all pyramid \\n        for i in range(row):\\n            for j in range(col):\\n                \\n                if not grid[i][j]:\\n                    continue\\n                    \\n                ans += downcount(i,j)\\n                \\n        # find all inverse pyramid\\n        for i in range(row-1, -1, -1):\\n            for j in range(col):\\n                \\n                if not grid[i][j]:\\n                    continue\\n                    \\n                ans += upcount(i,j)\\n                \\n        return ans \\n\\n```\\n\\n\\n**Note** : I was also confused by the question first of all like many of us do after looking at the hard question label and large explaination but i sit for 20 minutes think for different ways.\\n\\n* First came in my mind was brut force which is obvious from each i,j find all possible pyramid\\n* Then, i realize i am doing the same thing again for adjacent pyramid as well there should be some logic to solve this in O(1). \\n* Then, i was thinking that from each cell we just need to do down and check , except first & last (in that case we need to check one for left & right boundary cell) \\n* then, i realise i just need to know consecutive 1\\'s in last cell of next row. **prefix sum** is the solution for that. \\n* simple, i code it and it is slow but it worked.",
                "solutionTags": [
                    "Python",
                    "Prefix Sum"
                ],
                "code": "```\\n        row = len(grid)\\n        col = len(grid[0])\\n        \\n        def downcount(i,j):\\n            \"\"\"find the pramid of all size for i,j\"\"\"\\n            \\n            cnt = 0 \\n            base_length = 1 \\n            while i + 1 < row and j + 1 < col and grid[i+1][j+1] >= base_length + 2:\\n                cnt += 1 \\n                i += 1\\n                j += 1\\n                base_length += 2\\n                \\n            return cnt\\n        \\n        def upcount(i,j):\\n            \"\"\"find the inverse pyramid of all size for i,j\"\"\"\\n            cnt = 0 \\n            base_length = 1 \\n            \\n            while i-1 >= 0 and j + 1 < col and grid[i-1][j+1] >= base_length + 2:\\n                cnt += 1 \\n                i -= 1 \\n                j += 1 \\n                base_length += 2 \\n                \\n            return cnt \\n        \\n        \\n        # make prefix sum of all row\\n        for i in range(row):\\n            for j in range(1, col):\\n                \\n                if grid[i][j]:\\n                    grid[i][j] += grid[i][j-1]\\n                \\n        ans = 0 \\n        \\n        # find all pyramid \\n        for i in range(row):\\n            for j in range(col):\\n                \\n                if not grid[i][j]:\\n                    continue\\n                    \\n                ans += downcount(i,j)\\n                \\n        # find all inverse pyramid\\n        for i in range(row-1, -1, -1):\\n            for j in range(col):\\n                \\n                if not grid[i][j]:\\n                    continue\\n                    \\n                ans += upcount(i,j)\\n                \\n        return ans \\n\\n```",
                "codeTag": "Python3"
            },
            {
                "id": 1603708,
                "title": "dp-python-time-o-2rc-space-o-2rc",
                "content": "Using dp, inspired by [DBabichev\\'s post](https://leetcode.com/problems/count-fertile-pyramids-in-a-land/discuss/1599051/Python-short-dp-explained). (Thank you!)\\n\\nBasically, I am doing the same thing as him, but using the dp table, and split the process for pyramid and inverse pyramid because it was clearer to me.\\n\\n```\\nimport copy\\n\\nclass Solution:\\n    def countPyramids(self, grid):\\n        def in_range(i, j):\\n            return 0 <= i < R and 0 <= j < C\\n        \\n        #count the total number of pyramids. \\n        #Note that dp[i][j] == 1 means it\\'s a cell of only one fertile land, so we don\\'t want to count them\\n        def get_sum(dp):\\n            res = 0\\n            for i in range(R):\\n                for j in range(C):\\n                    if dp[i][j] >= 2:\\n                        res += dp[i][j] - 1\\n            return res\\n        \\n        R, C = len(grid), len(grid[0])\\n        \\n        #count the number of pyramidal plot\\n        dp = copy.deepcopy(grid)\\n        for i in range(R - 1, -1, -1):\\n            for j in range(C - 1, -1, -1):\\n                if grid[i][j] == 1:\\n                    val1 = dp[i + 1][j + 1] if in_range(i + 1, j + 1) else 0\\n                    val2 = dp[i + 1][j - 1] if in_range(i + 1, j - 1) else 0\\n                    dp[i][j] = min(val1, val2) + 1 if in_range(i + 1, j) and grid[i + 1][j] == 1 else 1\\n        \\n        #count the number of inverse pyramidal plot\\n        dp_inv = copy.deepcopy(grid)\\n        for i in range(R):\\n            for j in range(C):\\n                if grid[i][j] == 1:\\n                    val1 = dp_inv[i - 1][j + 1] if in_range(i - 1, j + 1) else 0\\n                    val2 = dp_inv[i - 1][j - 1] if in_range(i - 1, j - 1) else 0\\n                    dp_inv[i][j] = min(val1, val2) + 1 if in_range(i - 1, j) and grid[i - 1][j] == 1 else 1\\n        \\n        return get_sum(dp) + get_sum(dp_inv)\\n```",
                "solutionTags": [
                    "Python",
                    "Python3",
                    "Dynamic Programming"
                ],
                "code": "```\\nimport copy\\n\\nclass Solution:\\n    def countPyramids(self, grid):\\n        def in_range(i, j):\\n            return 0 <= i < R and 0 <= j < C\\n        \\n        #count the total number of pyramids. \\n        #Note that dp[i][j] == 1 means it\\'s a cell of only one fertile land, so we don\\'t want to count them\\n        def get_sum(dp):\\n            res = 0\\n            for i in range(R):\\n                for j in range(C):\\n                    if dp[i][j] >= 2:\\n                        res += dp[i][j] - 1\\n            return res\\n        \\n        R, C = len(grid), len(grid[0])\\n        \\n        #count the number of pyramidal plot\\n        dp = copy.deepcopy(grid)\\n        for i in range(R - 1, -1, -1):\\n            for j in range(C - 1, -1, -1):\\n                if grid[i][j] == 1:\\n                    val1 = dp[i + 1][j + 1] if in_range(i + 1, j + 1) else 0\\n                    val2 = dp[i + 1][j - 1] if in_range(i + 1, j - 1) else 0\\n                    dp[i][j] = min(val1, val2) + 1 if in_range(i + 1, j) and grid[i + 1][j] == 1 else 1\\n        \\n        #count the number of inverse pyramidal plot\\n        dp_inv = copy.deepcopy(grid)\\n        for i in range(R):\\n            for j in range(C):\\n                if grid[i][j] == 1:\\n                    val1 = dp_inv[i - 1][j + 1] if in_range(i - 1, j + 1) else 0\\n                    val2 = dp_inv[i - 1][j - 1] if in_range(i - 1, j - 1) else 0\\n                    dp_inv[i][j] = min(val1, val2) + 1 if in_range(i - 1, j) and grid[i - 1][j] == 1 else 1\\n        \\n        return get_sum(dp) + get_sum(dp_inv)\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1599060,
                "title": "o-m-n-time-and-space-dynamic-programming-concise",
                "content": "* degree of a pyramid is 1 less than the number of rows in a pyramid as defined in the problem\\n* if a pyramid with degree 1 is found (apexed at a cell), we can calculate its degree from the degree of the cells in its second row (apex cell is the first row), which is nothing but dynamic programming \\n* inverse pyramids can be calculated by reversing the grid\\n\\n```\\n    def countPyramids(self, grid: List[List[int]]) -> int:\\n        \\n        def count(grid):\\n            m, n = len(grid), len(grid[0])\\n            degree = [[0 for _ in range(n)] for _ in range(m)]\\n            for x in range(1, m):\\n                for y in range(1, n-1):\\n                    if grid[x][y] == grid[x-1][y-1] == grid[x-1][y] == grid[x-1][y+1] == 1:\\n                        degree[x][y] = 1 + min(degree[x-1][y-1], degree[x-1][y], degree[x-1][y+1])\\n                        \\n            return sum(sum(row) for row in degree)\\n        \\n        return count(grid) + count(grid[::-1])\\n```\\n\\n* update:\\nWe can just pick `min` of the degrees of two diagonally lower (or upper) cells, the degree of the center one doesn\\'t matter. So we could replace:\\n```\\n                        degree[x][y] = 1 + min(degree[x-1][y-1], degree[x-1][y], degree[x-1][y+1])\\n```\\nwith\\n```\\n                        degree[x][y] = 1 + min(degree[x-1][y-1], degree[x-1][y+1])\\n```\\n",
                "solutionTags": [
                    "Python3",
                    "Dynamic Programming"
                ],
                "code": "```\\n    def countPyramids(self, grid: List[List[int]]) -> int:\\n        \\n        def count(grid):\\n            m, n = len(grid), len(grid[0])\\n            degree = [[0 for _ in range(n)] for _ in range(m)]\\n            for x in range(1, m):\\n                for y in range(1, n-1):\\n                    if grid[x][y] == grid[x-1][y-1] == grid[x-1][y] == grid[x-1][y+1] == 1:\\n                        degree[x][y] = 1 + min(degree[x-1][y-1], degree[x-1][y], degree[x-1][y+1])\\n                        \\n            return sum(sum(row) for row in degree)\\n        \\n        return count(grid) + count(grid[::-1])\\n```\n```\\n                        degree[x][y] = 1 + min(degree[x-1][y-1], degree[x-1][y], degree[x-1][y+1])\\n```\n```\\n                        degree[x][y] = 1 + min(degree[x-1][y-1], degree[x-1][y+1])\\n```",
                "codeTag": "Python3"
            },
            {
                "id": 2724194,
                "title": "c-easy-short",
                "content": "\\n# Code\\n```\\nclass Solution {\\npublic:\\n   int count(vector<vector<int>> grid){\\n        int i, j, n = grid.size(), m = grid[0].size(), ans = 0;\\n        for(i = 1; i < n; i++){\\n            for(j = 1; j < m - 1; j++){\\n                if(grid[i][j] && grid[i - 1][j]){ \\n                    grid[i][j] = min(grid[i - 1][j - 1], grid[i - 1][j + 1]) + 1; \\n                    ans += grid[i][j] - 1;\\n                }\\n            }\\n        }\\n        return ans;\\n    }\\n    int countPyramids(vector<vector<int>>& grid) {\\n        int ans = count(grid); \\n        reverse(grid.begin(), grid.end());  \\n        ans += count(grid);\\n        return ans;\\n    }\\n\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n   int count(vector<vector<int>> grid){\\n        int i, j, n = grid.size(), m = grid[0].size(), ans = 0;\\n        for(i = 1; i < n; i++){\\n            for(j = 1; j < m - 1; j++){\\n                if(grid[i][j] && grid[i - 1][j]){ \\n                    grid[i][j] = min(grid[i - 1][j - 1], grid[i - 1][j + 1]) + 1; \\n                    ans += grid[i][j] - 1;\\n                }\\n            }\\n        }\\n        return ans;\\n    }\\n    int countPyramids(vector<vector<int>>& grid) {\\n        int ans = count(grid); \\n        reverse(grid.begin(), grid.end());  \\n        ans += count(grid);\\n        return ans;\\n    }\\n\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2362365,
                "title": "c-8-lines-both-100-solution-95ms-31-8mb-o-n-2-o-n",
                "content": "```\\nclass Solution {\\npublic:\\n    int countPyramids(vector<vector<int>>& grid) {\\n        int n=grid.size(),m=grid[0].size(),dp[2][m],tot = 0;\\n        for(int i=0;i<n;++i)\\n            for(int j=0,c=0;j<m;++j)\\n                grid[i][j]?++c,tot+=(dp[i&1][j]=(i&&j)?min((c+1)/2,1+dp[(i-1)&1][j-1]):1)-1:dp[i&1][j]=c=0;\\n        for(int i=n-1;i>=0;--i)\\n            for(int j=0,c=0;j<m;++j)\\n                grid[i][j]?++c,tot+=(dp[i&1][j]=(i<n-1&&j)?min((c+1)/2,1+dp[(i+1)&1][j-1]):1)-1:dp[i&1][j]=c=0;\\n        return tot;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C",
                    "Dynamic Programming",
                    "Memoization"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int countPyramids(vector<vector<int>>& grid) {\\n        int n=grid.size(),m=grid[0].size(),dp[2][m],tot = 0;\\n        for(int i=0;i<n;++i)\\n            for(int j=0,c=0;j<m;++j)\\n                grid[i][j]?++c,tot+=(dp[i&1][j]=(i&&j)?min((c+1)/2,1+dp[(i-1)&1][j-1]):1)-1:dp[i&1][j]=c=0;\\n        for(int i=n-1;i>=0;--i)\\n            for(int j=0,c=0;j<m;++j)\\n                grid[i][j]?++c,tot+=(dp[i&1][j]=(i<n-1&&j)?min((c+1)/2,1+dp[(i+1)&1][j-1]):1)-1:dp[i&1][j]=c=0;\\n        return tot;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1600482,
                "title": "c-neat-code-in-o-n-m-n-solution",
                "content": "class Solution {\\npublic:\\n    int countPyramids(vector<vector<int>>& grid) {\\n        \\n         int n = grid.size(), m = grid[0].size();\\n        \\n         for( int i = 0 ; i<n ; i++ ){\\n             \\n             int temp = 0;\\n             \\n             for( int j = 0 ; j<m ; j++ ){\\n                 \\n                  if( grid[i][j] == 0 ) temp = 0;\\n                  else temp ++;\\n                 \\n                  grid[i][j] = temp;\\n             }\\n             \\n             temp = 0;\\n             \\n             for( int j = m-1 ; j >= 0 ; j-- ){\\n                 \\n                  if( grid[i][j] == 0 ) temp = 0;\\n                  else temp ++;\\n                 \\n                  grid[i][j] = min( temp, grid[i][j] );\\n             }\\n         }\\n        \\n         int count = 0;\\n        \\n         for( int i=0 ; i<n ; i++ ){\\n             \\n             for( int j=0 ; j<m ; j++ ){\\n                 \\n                 if( grid[i][j] == 0 ) continue;\\n                 \\n                 int k = 1;\\n                 \\n                 while( ( i + k )< n and grid[ i+k ][ j ] > k  )k++;\\n                 \\n                 k--;\\n                 \\n                 count += k;\\n                 \\n                 k = 1;\\n                 \\n                 while( ( i - k ) >= 0 and grid[ i-k ][ j ] > k  )k++;\\n                 \\n                 k--;\\n                 \\n                 count += k;\\n             }\\n         }\\n         return count;\\n    }\\n};",
                "solutionTags": [],
                "code": "class Solution {\\npublic:\\n    int countPyramids(vector<vector<int>>& grid) {\\n        \\n         int n = grid.size(), m = grid[0].size();\\n        \\n         for( int i = 0 ; i<n ; i++ ){\\n             \\n             int temp = 0;\\n             \\n             for( int j = 0 ; j<m ; j++ ){\\n                 \\n                  if( grid[i][j] == 0 ) temp = 0;\\n                  else temp ++;\\n                 \\n                  grid[i][j] = temp;\\n             }",
                "codeTag": "Java"
            },
            {
                "id": 1599425,
                "title": "c-prefix-count-dp-o-m-n",
                "content": "Idea is to initially count for each cell number of 1 from left and from right, so we can quickly calculate the size of pyramid.\\nThen traverse each column from first row up to the last and get the max size of pyramid for each cell.\\nAnd based on the size, update the final result, e.g. if in a cell we can have a pyramid size equal 3 (3 cells in each direction from this cel including the start) \\nthen it means that we have additionally `size - 1` (because we don\\'t have 1 cell pyramids) pyramids.\\nAnd repeat the same for the inverse case - traverse from the last row up to the first.\\n\\nTime complexity = `O(m*n)`.\\nSpace = `O(m*n)` (for keeping prefix counts).\\n\\n```\\npublic int CountPyramids(int[][] grid) {\\n        var m = grid.Length;\\n        var n = grid[0].Length;        \\n       \\n        var onesLeft = new int[m, n];\\n        var onesRight = new int[m, n];\\n        \\n\\t\\t// Calculate prefix counts of 1 in each row from left and right sides\\n\\t\\t// Left side\\n        for (int i = 0; i < m; i++)\\n        {\\n            var count = 0;\\n            for (int j = 0; j < n; j++)\\n            {\\n                onesLeft[i, j] = count;\\n                if (grid[i][j] == 1)\\n                    count++;\\n                else\\n                    count = 0;\\n            }\\n        }\\n        \\n\\t\\t// Right side\\n        for (int i = 0; i < m; i++)\\n        {\\n            var count = 0;\\n            for (int j = n - 1; j >= 0; j--)\\n            {\\n                onesRight[i, j] = count;\\n                if (grid[i][j] == 1)\\n                    count++;\\n                else\\n                    count = 0;\\n            }\\n        }\\n        \\n\\t\\tvar res = 0;\\n\\t\\t\\n\\t\\t// Using DP calculate max sizes of Pyramids for each cell for normal case\\n\\t    // going for each column from 0 row to the last\\n        for (int j = 0; j < n; j++)\\n        {\\n            var prev = 0; // Max size of Pyramid in previous row\\n            for (int i = 0; i < m; i++)\\n            {\\n                if (grid[i][j] == 1)\\n                { \\n\\t\\t\\t\\t\\t// Using counts of 1 from left and right sides and the max size from prev row\\n\\t\\t\\t\\t\\t// size is amount of cells from the grid[i][j] including the start\\n                    var size = (new int[] {onesLeft[i, j], onesRight[i, j], prev}).Min() + 1;\\n                    prev = size;\\n                    \\n                    if (size > 1)\\n\\t\\t\\t\\t\\t    // we don\\'t have 1 cell pyramids, so it can be only size - 1 new pyramids\\n                        res += size - 1;                                        \\n                }\\n                else\\n                    prev = 0; // if prev row didn\\'t have any pyramid we reset prev value to 0\\n            }\\n        }\\n        \\n\\t\\t// Inverse case\\n        for (int j = 0; j < n; j++)\\n        {\\n            var prev = 0;\\n            for (int i = m - 1; i >= 0; i--)\\n            {\\n                if (grid[i][j] == 1)\\n                { \\n                    var size = (new int[] {onesLeft[i, j], onesRight[i, j], prev}).Min() + 1;\\n                    prev = size;\\n                    \\n                    if (size > 1)\\n                        res += size - 1;\\n                }\\n                else\\n                    prev = 0;\\n            }\\n        }\\n        \\n        return res;\\n    }\\n```",
                "solutionTags": [
                    "Dynamic Programming",
                    "Prefix Sum"
                ],
                "code": "```\\npublic int CountPyramids(int[][] grid) {\\n        var m = grid.Length;\\n        var n = grid[0].Length;        \\n       \\n        var onesLeft = new int[m, n];\\n        var onesRight = new int[m, n];\\n        \\n\\t\\t// Calculate prefix counts of 1 in each row from left and right sides\\n\\t\\t// Left side\\n        for (int i = 0; i < m; i++)\\n        {\\n            var count = 0;\\n            for (int j = 0; j < n; j++)\\n            {\\n                onesLeft[i, j] = count;\\n                if (grid[i][j] == 1)\\n                    count++;\\n                else\\n                    count = 0;\\n            }\\n        }\\n        \\n\\t\\t// Right side\\n        for (int i = 0; i < m; i++)\\n        {\\n            var count = 0;\\n            for (int j = n - 1; j >= 0; j--)\\n            {\\n                onesRight[i, j] = count;\\n                if (grid[i][j] == 1)\\n                    count++;\\n                else\\n                    count = 0;\\n            }\\n        }\\n        \\n\\t\\tvar res = 0;\\n\\t\\t\\n\\t\\t// Using DP calculate max sizes of Pyramids for each cell for normal case\\n\\t    // going for each column from 0 row to the last\\n        for (int j = 0; j < n; j++)\\n        {\\n            var prev = 0; // Max size of Pyramid in previous row\\n            for (int i = 0; i < m; i++)\\n            {\\n                if (grid[i][j] == 1)\\n                { \\n\\t\\t\\t\\t\\t// Using counts of 1 from left and right sides and the max size from prev row\\n\\t\\t\\t\\t\\t// size is amount of cells from the grid[i][j] including the start\\n                    var size = (new int[] {onesLeft[i, j], onesRight[i, j], prev}).Min() + 1;\\n                    prev = size;\\n                    \\n                    if (size > 1)\\n\\t\\t\\t\\t\\t    // we don\\'t have 1 cell pyramids, so it can be only size - 1 new pyramids\\n                        res += size - 1;                                        \\n                }\\n                else\\n                    prev = 0; // if prev row didn\\'t have any pyramid we reset prev value to 0\\n            }\\n        }\\n        \\n\\t\\t// Inverse case\\n        for (int j = 0; j < n; j++)\\n        {\\n            var prev = 0;\\n            for (int i = m - 1; i >= 0; i--)\\n            {\\n                if (grid[i][j] == 1)\\n                { \\n                    var size = (new int[] {onesLeft[i, j], onesRight[i, j], prev}).Min() + 1;\\n                    prev = size;\\n                    \\n                    if (size > 1)\\n                        res += size - 1;\\n                }\\n                else\\n                    prev = 0;\\n            }\\n        }\\n        \\n        return res;\\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1598844,
                "title": "python-prefix-sum-solution",
                "content": "```python\\n# prefix sum with continuous 1\\nm, n = len(grid), len(grid[0])\\nfor i in range(m):\\n\\tfor j in range(1, n):\\n\\t\\tif grid[i][j] == 1:\\n\\t\\t\\tgrid[i][j] += grid[i][j - 1]\\n\\nresult = 0\\nfor i in range(m):\\n\\tfor j in range(n):\\n\\t\\tif grid[i][j] != 0:\\n\\t\\t\\tfor k in range(1, min(i, j, n - 1 - j) + 1):\\n\\t\\t\\t\\tif grid[i - k][j + k] < k * 2 + 1:\\n\\t\\t\\t\\t\\tbreak\\n\\t\\t\\t\\tresult += 1\\n\\t\\t\\tfor k in range(1, min(m - 1 - i, j, n - 1 - j) + 1):\\n\\t\\t\\t\\tif grid[i + k][j + k] < k * 2 + 1:\\n\\t\\t\\t\\t\\tbreak\\n\\t\\t\\t\\tresult += 1\\nreturn result\\n```",
                "solutionTags": [],
                "code": "```python\\n# prefix sum with continuous 1\\nm, n = len(grid), len(grid[0])\\nfor i in range(m):\\n\\tfor j in range(1, n):\\n\\t\\tif grid[i][j] == 1:\\n\\t\\t\\tgrid[i][j] += grid[i][j - 1]\\n\\nresult = 0\\nfor i in range(m):\\n\\tfor j in range(n):\\n\\t\\tif grid[i][j] != 0:\\n\\t\\t\\tfor k in range(1, min(i, j, n - 1 - j) + 1):\\n\\t\\t\\t\\tif grid[i - k][j + k] < k * 2 + 1:\\n\\t\\t\\t\\t\\tbreak\\n\\t\\t\\t\\tresult += 1\\n\\t\\t\\tfor k in range(1, min(m - 1 - i, j, n - 1 - j) + 1):\\n\\t\\t\\t\\tif grid[i + k][j + k] < k * 2 + 1:\\n\\t\\t\\t\\t\\tbreak\\n\\t\\t\\t\\tresult += 1\\nreturn result\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1598838,
                "title": "count-fertile-pyramids-in-a-land-simple-dp-solution-with-example",
                "content": "We may solve this problem with help of dynamic programming. \\nLet\\'s dp[i][j] - the length of subsequence that ends in grid[i][j], starts in previous column in i row and consists only of 1.\\nThen, let\\'s find for every cell maximum size of pyramidal plot with top in this cell. \\nJust check if dp[i + k][j + k] has not less then 2* k + 1 value (number of ones on k + 1 level of pyramidal plot). The same logic for inverse pyramidal - dp[i - k][j + k].\\n\\n**Example**:\\n**grid:**\\n11110\\n11111\\n11111\\n01001\\n**dp:**\\n12340\\n12345\\n12345\\n01001\\nAll pyramidal plots for cell (0, 2).\\n1. dp[1][3] >= 2 * 1 + 1 \\n12**3**40\\n1**234**5\\n12345\\n01001\\n2. dp[2][4] >= 2 * 2 + 1\\n12**3**40\\n1**234**5\\n**12345**\\n01001\\n\\n**Code:**\\n```\\nclass Solution {\\npublic:\\n    int countPyramids(vector<vector<int>>& grid) {\\n        int n = grid.size(), m = grid[0].size();\\n        vector<vector<int>> dp = grid;\\n        for (int i = 0; i < n; ++i){\\n            for (int j = 0; j < m; ++j){\\n                if (grid[i][j] != 0 && j != 0){\\n                    dp[i][j] += dp[i][j - 1];\\n                }\\n            }\\n        }\\n        \\n        int ans = 0;\\n        for (int i = 0; i < n; ++i){\\n            for (int j = 0; j < m; ++j){\\n                for (int k = 0; k < min(n, m); ++k){\\n                    if (i + k >= n || j + k >= m || dp[i + k][j + k] < 2 * k + 1) break;\\n                    if (k != 0) ans++;\\n                }\\n                for (int k = 0; k < m; ++k){\\n                    if (i - k < 0 || j + k >= m || dp[i - k][j + k] < 2 * k + 1) break;\\n                    if (k != 0) ans++;\\n                }\\n            }\\n        }\\n        \\n        return ans;       \\n    }\\n};\\n```\\n\\n**Time Complexity:** O(n * m * min(n, m))\\n**Space Complexity:** O(n * m)\\n\\nIf you find this post useful upvote it!",
                "solutionTags": [
                    "Dynamic Programming"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int countPyramids(vector<vector<int>>& grid) {\\n        int n = grid.size(), m = grid[0].size();\\n        vector<vector<int>> dp = grid;\\n        for (int i = 0; i < n; ++i){\\n            for (int j = 0; j < m; ++j){\\n                if (grid[i][j] != 0 && j != 0){\\n                    dp[i][j] += dp[i][j - 1];\\n                }\\n            }\\n        }\\n        \\n        int ans = 0;\\n        for (int i = 0; i < n; ++i){\\n            for (int j = 0; j < m; ++j){\\n                for (int k = 0; k < min(n, m); ++k){\\n                    if (i + k >= n || j + k >= m || dp[i + k][j + k] < 2 * k + 1) break;\\n                    if (k != 0) ans++;\\n                }\\n                for (int k = 0; k < m; ++k){\\n                    if (i - k < 0 || j + k >= m || dp[i - k][j + k] < 2 * k + 1) break;\\n                    if (k != 0) ans++;\\n                }\\n            }\\n        }\\n        \\n        return ans;       \\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2762527,
                "title": "c-counting-from-right-corner",
                "content": "-> grid is the prefix array.\\n-> size of  X  is considered as 2\\n...............XXX............................\\n-> pyramid size will be the minimum of pyramid[i-1][j-1]+1 and prefix[i][j] to the left by 2.\\n```\\nclass Solution {\\npublic:\\n    void count(vector<vector<int>>& grid, vector<vector<int>>& up, int &n, int &m, int &ans){\\n        for (int i=1; i<n; i++){\\n            for (int j=2; j<m; j++){\\n                if (up[i-1][j-1] && grid[i][j]){\\n                    up[i][j] = min(up[i-1][j-1]+1, (grid[i][j]+1)/2);\\n                    ans += up[i][j] - 1;\\n                }\\n            }\\n        }\\n    }\\n    int countPyramids(vector<vector<int>>& grid) {\\n        int n = size(grid), ans = 0;\\n        int m = size(grid[0]);\\n        auto up = grid, dw = grid;\\n        for (int i=0; i<n; i++){\\n            for (int j=1; j<m; j++){\\n                if (grid[i][j]) grid[i][j] = grid[i][j-1]+1;\\n                else grid[i][j] = 0;\\n            }\\n        }\\n        count(grid, up, n, m, ans);\\n        reverse(begin(grid), end(grid));\\n        reverse(begin(dw), end(dw));\\n        count(grid, dw, n, m, ans);\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Dynamic Programming"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    void count(vector<vector<int>>& grid, vector<vector<int>>& up, int &n, int &m, int &ans){\\n        for (int i=1; i<n; i++){\\n            for (int j=2; j<m; j++){\\n                if (up[i-1][j-1] && grid[i][j]){\\n                    up[i][j] = min(up[i-1][j-1]+1, (grid[i][j]+1)/2);\\n                    ans += up[i][j] - 1;\\n                }\\n            }\\n        }\\n    }\\n    int countPyramids(vector<vector<int>>& grid) {\\n        int n = size(grid), ans = 0;\\n        int m = size(grid[0]);\\n        auto up = grid, dw = grid;\\n        for (int i=0; i<n; i++){\\n            for (int j=1; j<m; j++){\\n                if (grid[i][j]) grid[i][j] = grid[i][j-1]+1;\\n                else grid[i][j] = 0;\\n            }\\n        }\\n        count(grid, up, n, m, ans);\\n        reverse(begin(grid), end(grid));\\n        reverse(begin(dw), end(dw));\\n        count(grid, dw, n, m, ans);\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2725970,
                "title": "c-bottom-up-dp",
                "content": "Time Complexity: ```O(n * m)```\\nSpace Complexity: ```O(n * m)```\\n\\n```\\nclass Solution {\\npublic:\\n    int n, m;\\n    int helper(vector<vector<int>> A){\\n        int res = 0;\\n        for(int i = n - 2; i >= 0; i--){\\n            for(int j = 1; j < m - 1; j++){\\n                if(A[i][j])\\n                    A[i][j] = min({A[i + 1][j - 1], A[i + 1][j], A[i + 1][j + 1]}) + 1, res += A[i][j] - 1;\\n            }\\n        }\\n        return res;\\n    }\\n    int countPyramids(vector<vector<int>>& A) {\\n        n = A.size(), m = A[0].size();\\n        int res = 0;\\n        res += helper(A);\\n        reverse(A.begin(), A.end());\\n        res += helper(A);\\n        return res;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "C",
                    "Dynamic Programming"
                ],
                "code": "```O(n * m)```\n```O(n * m)```\n```\\nclass Solution {\\npublic:\\n    int n, m;\\n    int helper(vector<vector<int>> A){\\n        int res = 0;\\n        for(int i = n - 2; i >= 0; i--){\\n            for(int j = 1; j < m - 1; j++){\\n                if(A[i][j])\\n                    A[i][j] = min({A[i + 1][j - 1], A[i + 1][j], A[i + 1][j + 1]}) + 1, res += A[i][j] - 1;\\n            }\\n        }\\n        return res;\\n    }\\n    int countPyramids(vector<vector<int>>& A) {\\n        n = A.size(), m = A[0].size();\\n        int res = 0;\\n        res += helper(A);\\n        reverse(A.begin(), A.end());\\n        res += helper(A);\\n        return res;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2031184,
                "title": "easy-explanation-to-n-m-so-n-m-think-pascal-triangle",
                "content": "we did as hint says us (`hint` : **think of pascal triangle**):\\n[118. Pascal\\'s Triangle](https://leetcode.com/problems/pascals-triangle/)\\n\\n\\twhen mat[i][j] make pyramid :\\n\\t\\t- top to down if mat[i-1][j] == mat[i-1][j-1] == mat[i-1][j+1] == 1;\\n\\t\\t- top down   (i=1;i<row;++i),(j=1;j<col-1;++j)\\n\\t\\t- bottom up    if mat[i+1][j] == mat[i+1][j-1] == mat[i+1][j+1] == 1;\\n\\t\\t- bottom up   (i=row-2;i>=0;--i),(j=1;j<col-1;++j)\\n\\t\\t\\n**How dp works :**\\n\\n\\t\\t- if mat[i][j] make pyramid then :\\n\\t\\t\\t1. what length of pyramid made by its neighbours we add min of them to dp[i][j];\\n\\t\\t\\t\\t- plus row neighbors bottom up  of [i+1][j+1] , [i+1][j-1];\\n\\t\\t\\t\\t- minus row neigbours top down of [i-1][j+1] , [i-1][j-1];\\n\\t\\t\\t2. will perform this on both:\\n\\t\\t\\t\\t- from 2last row to 0th row;\\n\\t\\t\\t\\t- from 1row to last row;\\n\\t\\t\\t\\t\\n\\tExample 3:\\n\\t1   1   1   1   0\\n\\t1   1   1   1   1\\n\\t1   1   1   1   1\\n\\t0   1   0   0   1\\n\\n\\tbottom to top\\n\\t0   0   0   0   0              0   0   0   0   0               0   0   0   0   0  \\n\\t0   0   0   0   0              0   0   0   0   0   1 row       0   1   1   1   0\\n\\t0   0   0   0   0   2 row      0   0   0   0   0               0   0   0   0   0\\n\\t0   0   0   0   0              0   0   0   0   0               0   0   0   0   0\\n\\n\\t0   1   2   1   0   0th row,          in zero th row 2 col is ==2 bcs \\n\\t0   1   1   1   0                          mat[0+1][2-1]==mat[0+1][2]==mat[0+1][2+1]==1\\n\\t0   0   0   0   0                          and +min(dp[0+1][2-1],dp[0+1][2+1]);\\n\\t0   0   0   0   0\\n\\n\\ttop to bottom\\n\\t0   0   0   0   0               0   0   0   0   0               0   0   0   0   0  \\n\\t0   0   0   0   0   1 row       0   1   1   0   0               0   1   1   0   0\\n\\t0   0   0   0   0               0   0   0   0   0    2 row      0   1   1   1   0\\n\\t0   0   0   0   0               0   0   0   0   0               0   0   0   0   0\\n\\n\\t0   0   0   0   0   \\n\\t0   1   1   0   0\\n\\t0   1   1   1   0\\n\\t0   1   0   0   0   3 row\\n\\n.\\n \\n\\tclass Solution {\\n\\tpublic:\\n\\t\\tint countPyramids(vector<vector<int>>& mat) {\\n\\t\\t\\tint n=mat.size();\\n\\t\\t\\tint m=mat[0].size();\\n\\t\\t\\tint ans=0;\\n\\t\\t\\tvector<vector<int>>dp(n,vector<int>(m,0));\\n\\t\\t\\tfor(int i=n-2;i>=0;--i){\\n\\t\\t\\t\\tfor(int j=1;j<m-1;++j){\\n\\t\\t\\t\\t\\tif(mat[i][j] && mat[i+1][j-1] && mat[i+1][j+1] && mat[i+1][j]){\\n\\t\\t\\t\\t\\t\\tdp[i][j]=1+min(dp[i+1][j+1],dp[i+1][j-1]);\\n\\t\\t\\t\\t\\t\\tans+=dp[i][j];\\n\\t\\t\\t\\t\\t}\\n\\t\\t\\t\\t}\\n\\t\\t\\t}\\n\\t\\t\\tdp.assign(n,vector<int>(m,0));\\n\\t\\t\\tfor(int i=1;i<n;++i){\\n\\t\\t\\t\\tfor(int j=1;j<m-1;++j){\\n\\t\\t\\t\\t\\tif(mat[i][j] && mat[i-1][j-1] && mat[i-1][j+1] && mat[i-1][j]){\\n\\t\\t\\t\\t\\t\\tdp[i][j]=1+min(dp[i-1][j+1],dp[i-1][j-1]);\\n\\t\\t\\t\\t\\t\\tans+=dp[i][j];\\n\\t\\t\\t\\t\\t}\\n\\t\\t\\t\\t}\\n\\t\\t\\t}\\n\\t\\t\\treturn ans;\\n\\t\\t}\\n\\t};\\n\\n##### I Tried to Explain if any suggestion or query comment below  (: \\n",
                "solutionTags": [
                    "C",
                    "Dynamic Programming"
                ],
                "code": "class Solution {\\n\\tpublic:\\n\\t\\tint countPyramids(vector<vector<int>>& mat) {\\n\\t\\t\\tint n=mat.size();\\n\\t\\t\\tint m=mat[0].size();\\n\\t\\t\\tint ans=0;\\n\\t\\t\\tvector<vector<int>>dp(n,vector<int>(m,0));\\n\\t\\t\\tfor(int i=n-2;i>=0;--i){\\n\\t\\t\\t\\tfor(int j=1;j<m-1;++j){\\n\\t\\t\\t\\t\\tif(mat[i][j] && mat[i+1][j-1] && mat[i+1][j+1] && mat[i+1][j]){\\n\\t\\t\\t\\t\\t\\tdp[i][j]=1+min(dp[i+1][j+1],dp[i+1][j-1]);\\n\\t\\t\\t\\t\\t\\tans+=dp[i][j];\\n\\t\\t\\t\\t\\t}",
                "codeTag": "Java"
            },
            {
                "id": 1825617,
                "title": "python-clean-dp-with-comment-explanation",
                "content": "```\\nimport copy\\nclass Solution:\\n    def countPyramids(self, grid: List[List[int]]) -> int:\\n        m, n = len(grid), len(grid[0])\\n        def count(grid):\\n            ans = 0\\n            for i in range(m-2,-1,-1):\\n                for j in range(1,n-1):\\n                    if grid[i][j] and grid[i+1][j]:\\n\\t\\t\\t\\t\\t\\t#two pyramidal plots makes one story higher pyramidal plot\\n                        grid[i][j] = min(grid[i+1][j-1],grid[i+1][j+1])+1\\n                        ans += grid[i][j]-1\\n            #computed grid[i][j] is the height of the highest pyramidal plot whose apex is (i,j)\\n            return ans\\n        #count pyramidal plot\\n        res = count(copy.deepcopy(grid))\\n        #count inverse pyramidal plot\\n        res += count([ grid[i] for i in range(m-1,-1,-1)])\\n        return res\\n```",
                "solutionTags": [
                    "Dynamic Programming"
                ],
                "code": "```\\nimport copy\\nclass Solution:\\n    def countPyramids(self, grid: List[List[int]]) -> int:\\n        m, n = len(grid), len(grid[0])\\n        def count(grid):\\n            ans = 0\\n            for i in range(m-2,-1,-1):\\n                for j in range(1,n-1):\\n                    if grid[i][j] and grid[i+1][j]:\\n\\t\\t\\t\\t\\t\\t#two pyramidal plots makes one story higher pyramidal plot\\n                        grid[i][j] = min(grid[i+1][j-1],grid[i+1][j+1])+1\\n                        ans += grid[i][j]-1\\n            #computed grid[i][j] is the height of the highest pyramidal plot whose apex is (i,j)\\n            return ans\\n        #count pyramidal plot\\n        res = count(copy.deepcopy(grid))\\n        #count inverse pyramidal plot\\n        res += count([ grid[i] for i in range(m-1,-1,-1)])\\n        return res\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1734032,
                "title": "o-m-n-c-prefix-sum",
                "content": "```\\nclass Solution {\\npublic:\\n    int res(vector<vector<int>>& grid){\\n        int n=grid.size();\\n        int m=grid[0].size();\\n        \\n        vector<vector<int>> l(n,vector<int>(m,0)), r(n,vector<int>(m,0)),w(n,vector<int>(m,0)),lis(n,vector<int>(m,0)) ;\\n        \\n        for(int i=0;i<n;i++){\\n            l[i][0]=grid[i][0];\\n            \\n            for(int j=1;j<m;j++){\\n               if(grid[i][j]) l[i][j]=l[i][j-1]+1;\\n                \\n            }\\n        }\\n        \\n        for(int i=0;i<n;i++){\\n            r[i][m-1]=grid[i][m-1];\\n            \\n            for(int j=m-2;j>=0;j--){\\n               if(grid[i][j]) r[i][j]=r[i][j+1]+1;\\n                \\n            }\\n        }\\n        for(int i=0;i<n;i++){ \\n            for(int j=0;j<m;j++){\\n               if(grid[i][j]) {\\n                   int wide=min(l[i][j],r[i][j])-1;\\n                   w[i][j]=1+2*wide;\\n                }\\n             }\\n         }\\n        for(int j=0;j<m;j++){\\n            lis[0][j]=grid[0][j]; \\n          \\n            for(int i=1;i<n;i++){\\n               if(!grid[i][j]) continue;\\n               if(lis[i-1][j]==0) {lis[i][j]=grid[i][j]; continue;}\\n                \\n               if(w[i][j]>=lis[i-1][j]+2) lis[i][j]=2+lis[i-1][j];\\n               else  lis[i][j]=w[i][j];\\n                \\n            }\\n            \\n        }\\n        \\n        int ans=0;\\n        \\n        for(int i=0;i<n;i++){ \\n            for(int j=0;j<m;j++){\\n               if(lis[i][j]>1){\\n                    ans=ans+lis[i][j]/2;\\n               }   \\n                \\n            }\\n        }\\n        return ans;\\n    }\\n    \\n    \\n    \\n    int countPyramids(vector<vector<int>>& grid) {\\n        \\n        int up=res(grid);\\n       \\n        for(auto& v:grid){\\n            reverse(v.begin(),v.end());\\n        }\\n        reverse(grid.begin(),grid.end());\\n        int down=res(grid);\\n         \\n        return up+down;\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    int res(vector<vector<int>>& grid){\\n        int n=grid.size();\\n        int m=grid[0].size();\\n        \\n        vector<vector<int>> l(n,vector<int>(m,0)), r(n,vector<int>(m,0)),w(n,vector<int>(m,0)),lis(n,vector<int>(m,0)) ;\\n        \\n        for(int i=0;i<n;i++){\\n            l[i][0]=grid[i][0];\\n            \\n            for(int j=1;j<m;j++){\\n               if(grid[i][j]) l[i][j]=l[i][j-1]+1;\\n                \\n            }\\n        }\\n        \\n        for(int i=0;i<n;i++){\\n            r[i][m-1]=grid[i][m-1];\\n            \\n            for(int j=m-2;j>=0;j--){\\n               if(grid[i][j]) r[i][j]=r[i][j+1]+1;\\n                \\n            }\\n        }\\n        for(int i=0;i<n;i++){ \\n            for(int j=0;j<m;j++){\\n               if(grid[i][j]) {\\n                   int wide=min(l[i][j],r[i][j])-1;\\n                   w[i][j]=1+2*wide;\\n                }\\n             }\\n         }\\n        for(int j=0;j<m;j++){\\n            lis[0][j]=grid[0][j]; \\n          \\n            for(int i=1;i<n;i++){\\n               if(!grid[i][j]) continue;\\n               if(lis[i-1][j]==0) {lis[i][j]=grid[i][j]; continue;}\\n                \\n               if(w[i][j]>=lis[i-1][j]+2) lis[i][j]=2+lis[i-1][j];\\n               else  lis[i][j]=w[i][j];\\n                \\n            }\\n            \\n        }\\n        \\n        int ans=0;\\n        \\n        for(int i=0;i<n;i++){ \\n            for(int j=0;j<m;j++){\\n               if(lis[i][j]>1){\\n                    ans=ans+lis[i][j]/2;\\n               }   \\n                \\n            }\\n        }\\n        return ans;\\n    }\\n    \\n    \\n    \\n    int countPyramids(vector<vector<int>>& grid) {\\n        \\n        int up=res(grid);\\n       \\n        for(auto& v:grid){\\n            reverse(v.begin(),v.end());\\n        }\\n        reverse(grid.begin(),grid.end());\\n        int down=res(grid);\\n         \\n        return up+down;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1728661,
                "title": "c-unique-counting-approach-o-n-m-n",
                "content": "Here we store the count of 1\\'s in a row for each column. And finally, considering every 1 as the tip of a pyramid, for each possible height, we check if the difference between the counts of one of the two extremes matches the count required at that height using the following logic:\\nIf height = n, count of one\\'s in the base = 2 * n + 1\\n\\n```\\nclass Solution {\\npublic:\\n    int countPyramids(vector<vector<int>>& grid) {\\n        int n = grid.size(), m = grid[0].size();\\n        vector<vector<int>> count(n, vector<int>(m));\\n        \\n        for(int i = 0; i<n; i++) {\\n            count[i][0] = grid[i][0];\\n        }\\n        \\n        for(int i = 0; i<n; i++) {\\n            for(int j = 1; j<m; j++) {\\n                count[i][j] = grid[i][j] ? count[i][j-1]+1 : count[i][j-1];\\n            }\\n        }\\n        \\n        int res = 0;\\n        for(int i = 0; i<n; i++) {\\n            for(int j = 0; j<m; j++) {\\n                if(grid[i][j] == 1) {\\n                    int height = 1;\\n                    bool up = true, down = true;\\n                    while(((i-height >= 0 && up) || (i+height < n && down)) && j-height >= 0 && j+height < m) {\\n                        if(i-height >= 0 && up) {\\n                            int prev = j-height-1 >= 0 ? count[i-height][j-height-1] : 0;\\n                            int next = count[i-height][j+height];\\n                            int ones = 2*height + 1;\\n                            if(next-prev == ones) res++;\\n                            else up = false;\\n                        }\\n                        if(i+height < n && down) {\\n                            int prev = j-height-1 >= 0 ? count[i+height][j-height-1] : 0;\\n                            int next = count[i+height][j+height];\\n                            int ones = 2*height + 1;\\n                            if(next-prev == ones) res++;\\n                            else down = false;\\n                        }\\n                        height++;\\n                    }\\n                }\\n            }\\n        }\\n        \\n        return res;\\n    }\\n};\\n```\\n\\nThe boolean vairables are required to get rid of the cases like -\\n          0 1 0\\n\\t\\t 0  0 0\\n\\t\\t1 1 1",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    int countPyramids(vector<vector<int>>& grid) {\\n        int n = grid.size(), m = grid[0].size();\\n        vector<vector<int>> count(n, vector<int>(m));\\n        \\n        for(int i = 0; i<n; i++) {\\n            count[i][0] = grid[i][0];\\n        }\\n        \\n        for(int i = 0; i<n; i++) {\\n            for(int j = 1; j<m; j++) {\\n                count[i][j] = grid[i][j] ? count[i][j-1]+1 : count[i][j-1];\\n            }\\n        }\\n        \\n        int res = 0;\\n        for(int i = 0; i<n; i++) {\\n            for(int j = 0; j<m; j++) {\\n                if(grid[i][j] == 1) {\\n                    int height = 1;\\n                    bool up = true, down = true;\\n                    while(((i-height >= 0 && up) || (i+height < n && down)) && j-height >= 0 && j+height < m) {\\n                        if(i-height >= 0 && up) {\\n                            int prev = j-height-1 >= 0 ? count[i-height][j-height-1] : 0;\\n                            int next = count[i-height][j+height];\\n                            int ones = 2*height + 1;\\n                            if(next-prev == ones) res++;\\n                            else up = false;\\n                        }\\n                        if(i+height < n && down) {\\n                            int prev = j-height-1 >= 0 ? count[i+height][j-height-1] : 0;\\n                            int next = count[i+height][j+height];\\n                            int ones = 2*height + 1;\\n                            if(next-prev == ones) res++;\\n                            else down = false;\\n                        }\\n                        height++;\\n                    }\\n                }\\n            }\\n        }\\n        \\n        return res;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1657348,
                "title": "java-5-loops",
                "content": "Using a DP similar to [221. Maximal Square](https://leetcode.com/problems/maximal-square/)\\n\\n```\\npublic int countPyramids(int[][] grid) {\\n\\tint m= grid.length, n= grid[0].length;\\n\\tint[][] ul= new int[m][n], ur= new int[m][n], dl= new int[m][n], dr= new int[m][n];\\n\\t// ul\\n\\tfor(int i=1; i<m; i++)\\n\\t\\tfor(int j=1; j<n; j++)\\n\\t\\t\\tif(grid[i][j]==1 && grid[i-1][j]==1 && grid[i][j-1]==1) ul[i][j]= 1+Math.min(ul[i-1][j], ul[i][j-1]);\\n\\t// ur\\n\\tfor(int i=1; i<m; i++)\\n\\t\\tfor(int j=n-2; j>-1; j--)\\n\\t\\t\\tif(grid[i][j]==1 && grid[i-1][j]==1 && grid[i][j+1]==1) ur[i][j]= 1+Math.min(ur[i-1][j], ur[i][j+1]);\\n\\t// dl\\n\\tfor(int i=m-2; i>-1; i--)\\n\\t\\tfor(int j=1; j<n; j++)\\n\\t\\t\\tif(grid[i][j]==1 && grid[i+1][j]==1 && grid[i][j-1]==1) dl[i][j]= 1+Math.min(dl[i+1][j], dl[i][j-1]);\\n\\t// dr\\n\\tfor(int i=m-2; i>-1; i--)\\n\\t\\tfor(int j=n-2; j>-1; j--)\\n\\t\\t\\tif(grid[i][j]==1 && grid[i+1][j]==1 && grid[i][j+1]==1) dr[i][j]= 1+Math.min(dr[i+1][j], dr[i][j+1]);\\n\\t// sum\\n\\tint sum= 0;\\n\\tfor(int i=0; i<m; i++)\\n\\t\\tfor(int j=0; j<n; j++)\\n\\t\\t\\tsum+= Math.min(ul[i][j], ur[i][j]) + Math.min(dl[i][j], dr[i][j]);\\n\\treturn sum;\\n}\\n",
                "solutionTags": [],
                "code": "Using a DP similar to [221. Maximal Square](https://leetcode.com/problems/maximal-square/)\\n\\n```\\npublic int countPyramids(int[][] grid) {\\n\\tint m= grid.length, n= grid[0].length;\\n\\tint[][] ul= new int[m][n], ur= new int[m][n], dl= new int[m][n], dr= new int[m][n];\\n\\t// ul\\n\\tfor(int i=1; i<m; i++)\\n\\t\\tfor(int j=1; j<n; j++)\\n\\t\\t\\tif(grid[i][j]==1 && grid[i-1][j]==1 && grid[i][j-1]==1) ul[i][j]= 1+Math.min(ul[i-1][j], ul[i][j-1]);\\n\\t// ur\\n\\tfor(int i=1; i<m; i++)\\n\\t\\tfor(int j=n-2; j>-1; j--)\\n\\t\\t\\tif(grid[i][j]==1 && grid[i-1][j]==1 && grid[i][j+1]==1) ur[i][j]= 1+Math.min(ur[i-1][j], ur[i][j+1]);\\n\\t// dl\\n\\tfor(int i=m-2; i>-1; i--)\\n\\t\\tfor(int j=1; j<n; j++)\\n\\t\\t\\tif(grid[i][j]==1 && grid[i+1][j]==1 && grid[i][j-1]==1) dl[i][j]= 1+Math.min(dl[i+1][j], dl[i][j-1]);\\n\\t// dr\\n\\tfor(int i=m-2; i>-1; i--)\\n\\t\\tfor(int j=n-2; j>-1; j--)\\n\\t\\t\\tif(grid[i][j]==1 && grid[i+1][j]==1 && grid[i][j+1]==1) dr[i][j]= 1+Math.min(dr[i+1][j], dr[i][j+1]);\\n\\t// sum\\n\\tint sum= 0;\\n\\tfor(int i=0; i<m; i++)\\n\\t\\tfor(int j=0; j<n; j++)\\n\\t\\t\\tsum+= Math.min(ul[i][j], ur[i][j]) + Math.min(dl[i][j], dr[i][j]);\\n\\treturn sum;\\n}\\n",
                "codeTag": "Unknown"
            },
            {
                "id": 1655710,
                "title": "python-2-solutions-prefix-sum-dp",
                "content": "First solution is weird but intuitive-\\nleft,right keeps count of 1s on left and right side of the element if that element is 1\\nvalid tells whether upper block was a valid pyramid or not, its value shows the order of that valid pyramid\\nLike [] has order 1 and [] has order 2 and so on....\\n##[] [] []##########[] [] []\\n##############[] [] [] [] []\\n\\t\\t\\t\\t\\t\\t\\t\\t\\t\\nFinally if order<=min of left and right, it means given pyramid is of order=order+1 and simply add order+1 to ans\\nelif order>min of left and right, we can conclude that order of given pyramid is min of left and right and simply add min of left and right to ans\\nalso we check some other small constraints by observation and adjustments....\\nFor reverse pyramid, just invert original grid and pass it to same function!!!!!!!\\nFirst Solution-\\n```\\nclass Solution:\\n    def countPyramids(self, grid: List[List[int]]) -> int:\\n        m,n=len(grid),len(grid[0])\\n        def solve(arr):\\n            left,right=[[0]*n for _ in range(m)],[[0]*n for _ in range(m)]\\n            ans=0\\n            for i in range(m):\\n                for j in range(1,n):\\n                    if arr[i][j]==1:\\n                        left[i][j]=left[i][j-1]+(1 if arr[i][j-1]==1 else 0)\\n                for j in range(n-2,-1,-1):\\n                    if arr[i][j]==1:\\n                        right[i][j]=right[i][j+1]+(1 if arr[i][j+1]==1 else 0)\\n            valid=[[0]*n for _ in range(m)]\\n            for i in range(1,m):\\n                for j in range(1,n):\\n                    dist=min(left[i][j],right[i][j])\\n                    order=valid[i-1][j]\\n                    if arr[i][j]==1:\\n                        if arr[i-1][j] and order<=dist-1:\\n                            ans+=order+1\\n                            valid[i][j]=order+1\\n                        elif arr[i-1][j] and dist:\\n                            ans+=dist\\n                            valid[i][j]=dist\\n            return ans\\n        new_grid=[[0]*n for _ in range(m)]\\n        for i in range(m):\\n            for j in range(n):\\n                new_grid[i][j]=grid[m-i-1][n-j-1]\\n        return solve(grid)+solve(new_grid)\\n            \\n                   \\n```\\nSecond is direct DP\\nSecond Solution-\\n```\\nclass Solution:\\n    def countPyramids(self, grid: List[List[int]]) -> int:\\n        m,n=len(grid),len(grid[0])\\n        def solve(arr):\\n            dp=arr\\n            ans=0\\n            for i in range(1,m):\\n                for j in range(1,n-1):\\n                    if dp[i][j]:\\n                        dp[i][j]+=min(dp[i-1][j],dp[i-1][j-1],dp[i-1][j+1])\\n                        ans+=dp[i][j]-1\\n            return ans\\n        new_grid=[[0]*n for _ in range(m)]\\n        for i in range(m):\\n            for j in range(n):\\n                new_grid[i][j]=grid[m-i-1][n-j-1]\\n        return solve(grid)+solve(new_grid)\\n            \\n                    \\n```",
                "solutionTags": [
                    "Python",
                    "Python3",
                    "Dynamic Programming",
                    "Prefix Sum"
                ],
                "code": "```\\nclass Solution:\\n    def countPyramids(self, grid: List[List[int]]) -> int:\\n        m,n=len(grid),len(grid[0])\\n        def solve(arr):\\n            left,right=[[0]*n for _ in range(m)],[[0]*n for _ in range(m)]\\n            ans=0\\n            for i in range(m):\\n                for j in range(1,n):\\n                    if arr[i][j]==1:\\n                        left[i][j]=left[i][j-1]+(1 if arr[i][j-1]==1 else 0)\\n                for j in range(n-2,-1,-1):\\n                    if arr[i][j]==1:\\n                        right[i][j]=right[i][j+1]+(1 if arr[i][j+1]==1 else 0)\\n            valid=[[0]*n for _ in range(m)]\\n            for i in range(1,m):\\n                for j in range(1,n):\\n                    dist=min(left[i][j],right[i][j])\\n                    order=valid[i-1][j]\\n                    if arr[i][j]==1:\\n                        if arr[i-1][j] and order<=dist-1:\\n                            ans+=order+1\\n                            valid[i][j]=order+1\\n                        elif arr[i-1][j] and dist:\\n                            ans+=dist\\n                            valid[i][j]=dist\\n            return ans\\n        new_grid=[[0]*n for _ in range(m)]\\n        for i in range(m):\\n            for j in range(n):\\n                new_grid[i][j]=grid[m-i-1][n-j-1]\\n        return solve(grid)+solve(new_grid)\\n            \\n                   \\n```\n```\\nclass Solution:\\n    def countPyramids(self, grid: List[List[int]]) -> int:\\n        m,n=len(grid),len(grid[0])\\n        def solve(arr):\\n            dp=arr\\n            ans=0\\n            for i in range(1,m):\\n                for j in range(1,n-1):\\n                    if dp[i][j]:\\n                        dp[i][j]+=min(dp[i-1][j],dp[i-1][j-1],dp[i-1][j+1])\\n                        ans+=dp[i][j]-1\\n            return ans\\n        new_grid=[[0]*n for _ in range(m)]\\n        for i in range(m):\\n            for j in range(n):\\n                new_grid[i][j]=grid[m-i-1][n-j-1]\\n        return solve(grid)+solve(new_grid)\\n            \\n                    \\n```",
                "codeTag": "Java"
            },
            {
                "id": 1653961,
                "title": "standard-dfs-memoization",
                "content": "too long but easy to understand\\n```\\nclass Solution {\\n    public int countPyramids(int[][] grid) {\\n        int m= grid.length;\\n        int n= grid[0].length;\\n        int[][] fdp=  new int[m][n];\\n        for(int i=0;i<m;i++){\\n            for(int j=0;j<n;j++){\\n                fdp[i][j]=-1;\\n            }\\n        }\\n        int count=0;\\n          for(int i=0;i<m;i++){\\n            for(int j=0;j<n;j++){\\n             if(grid[i][j]==0)  continue;\\n                count+=dfs(grid,fdp,i,j,n,m);\\n            }\\n        }\\n         int[][] bdp=  new int[m][n];\\n        for(int i=0;i<m;i++){\\n            for(int j=0;j<n;j++){\\n                bdp[i][j]=-1;\\n            }\\n        }\\n         for(int i=m-1;i>=0;i--){\\n            for(int j=n-1;j>=0;j--){\\n             if(grid[i][j]==0)  continue;\\n                count+=bdfs(grid,bdp,i,j,n,m);\\n            }\\n        }\\n        \\n        return count;\\n        \\n    }\\n    public int dfs(int[][]  grid,int[][]  fdp,int r,int c,int n ,int m){\\n        if(r<0||c<0||r>=m||c>=n||grid[r][c]==0){\\n            return 0;\\n        }\\n        if(fdp[r][c]!=-1)   return fdp[r][c];\\n        if(r+1<m&&grid[r+1][c]==0) return fdp[r][c]=0;\\n        int lft=0;\\n        int rgh=0;\\n          if(r+1<m&&c-1>=0&&grid[r+1][c-1]==1){\\n              lft=1+dfs(grid,fdp,r+1,c-1,n,m);\\n          }\\n        if(r+1<m&&c+1<n&&grid[r+1][c+1]==1){\\n              rgh=1+dfs(grid,fdp,r+1,c+1,n,m);\\n          }\\n      return   fdp[r][c]=Math.min(lft,rgh);\\n        \\n    }\\n        public int bdfs(int[][]  grid,int[][]  bdp,int r,int c,int n ,int m){\\n        if(r<0||c<0||r>=m||c>=n||grid[r][c]==0){\\n            return 0;\\n        }\\n        if(bdp[r][c]!=-1)   return bdp[r][c];\\n        if(r-1>=0&&grid[r-1][c]==0) return bdp[r][c]=0;\\n        int lft=0;\\n        int rgh=0;\\n          if(r-1>=0&&c-1>=0&&grid[r-1][c-1]==1){\\n              lft=1+bdfs(grid,bdp,r-1,c-1,n,m);\\n          }\\n        if(r-1>=0&&c+1<n&&grid[r-1][c+1]==1){\\n              rgh=1+bdfs(grid,bdp,r-1,c+1,n,m);\\n          }\\n      return   bdp[r][c]=Math.min(lft,rgh);\\n        \\n    }\\n}\\n```",
                "solutionTags": [
                    "Depth-First Search",
                    "Memoization"
                ],
                "code": "```\\nclass Solution {\\n    public int countPyramids(int[][] grid) {\\n        int m= grid.length;\\n        int n= grid[0].length;\\n        int[][] fdp=  new int[m][n];\\n        for(int i=0;i<m;i++){\\n            for(int j=0;j<n;j++){\\n                fdp[i][j]=-1;\\n            }\\n        }\\n        int count=0;\\n          for(int i=0;i<m;i++){\\n            for(int j=0;j<n;j++){\\n             if(grid[i][j]==0)  continue;\\n                count+=dfs(grid,fdp,i,j,n,m);\\n            }\\n        }\\n         int[][] bdp=  new int[m][n];\\n        for(int i=0;i<m;i++){\\n            for(int j=0;j<n;j++){\\n                bdp[i][j]=-1;\\n            }\\n        }\\n         for(int i=m-1;i>=0;i--){\\n            for(int j=n-1;j>=0;j--){\\n             if(grid[i][j]==0)  continue;\\n                count+=bdfs(grid,bdp,i,j,n,m);\\n            }\\n        }\\n        \\n        return count;\\n        \\n    }\\n    public int dfs(int[][]  grid,int[][]  fdp,int r,int c,int n ,int m){\\n        if(r<0||c<0||r>=m||c>=n||grid[r][c]==0){\\n            return 0;\\n        }\\n        if(fdp[r][c]!=-1)   return fdp[r][c];\\n        if(r+1<m&&grid[r+1][c]==0) return fdp[r][c]=0;\\n        int lft=0;\\n        int rgh=0;\\n          if(r+1<m&&c-1>=0&&grid[r+1][c-1]==1){\\n              lft=1+dfs(grid,fdp,r+1,c-1,n,m);\\n          }\\n        if(r+1<m&&c+1<n&&grid[r+1][c+1]==1){\\n              rgh=1+dfs(grid,fdp,r+1,c+1,n,m);\\n          }\\n      return   fdp[r][c]=Math.min(lft,rgh);\\n        \\n    }\\n        public int bdfs(int[][]  grid,int[][]  bdp,int r,int c,int n ,int m){\\n        if(r<0||c<0||r>=m||c>=n||grid[r][c]==0){\\n            return 0;\\n        }\\n        if(bdp[r][c]!=-1)   return bdp[r][c];\\n        if(r-1>=0&&grid[r-1][c]==0) return bdp[r][c]=0;\\n        int lft=0;\\n        int rgh=0;\\n          if(r-1>=0&&c-1>=0&&grid[r-1][c-1]==1){\\n              lft=1+bdfs(grid,bdp,r-1,c-1,n,m);\\n          }\\n        if(r-1>=0&&c+1<n&&grid[r-1][c+1]==1){\\n              rgh=1+bdfs(grid,bdp,r-1,c+1,n,m);\\n          }\\n      return   bdp[r][c]=Math.min(lft,rgh);\\n        \\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1636317,
                "title": "c-dp-28-lines",
                "content": "```\\nclass Solution {\\npublic:\\n    int countPyramids(vector<vector>& grid) {\\n        int m = grid.size();\\n        int n = grid[0].size();\\n        int count = 0;\\n\\n        // count inverted\\n        vector<vector<int>> dp = grid;\\n        for(int i=1; i<m; ++i)\\n            for(int j=1; j<n-1; ++j)\\n                if(dp[i][j]) {\\n                    dp[i][j] += min(dp[i-1][j], min(dp[i-1][j-1], dp[i-1][j+1]));\\n                    count += dp[i][j] - 1;\\n                }\\n    \\n        // count normal\\n\\t    dp = grid;\\n        for(int i=m-2; i>=0; --i)\\n            for(int j=1; j<n-1; ++j)\\n                if(dp[i][j]) {\\n                    dp[i][j] += min(dp[i+1][j], min(dp[i+1][j-1], dp[i+1][j+1]));\\n                    count += dp[i][j] - 1;\\n                }\\n    \\n        return count;\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    int countPyramids(vector<vector>& grid) {\\n        int m = grid.size();\\n        int n = grid[0].size();\\n        int count = 0;\\n\\n        // count inverted\\n        vector<vector<int>> dp = grid;\\n        for(int i=1; i<m; ++i)\\n            for(int j=1; j<n-1; ++j)\\n                if(dp[i][j]) {\\n                    dp[i][j] += min(dp[i-1][j], min(dp[i-1][j-1], dp[i-1][j+1]));\\n                    count += dp[i][j] - 1;\\n                }\\n    \\n        // count normal\\n\\t    dp = grid;\\n        for(int i=m-2; i>=0; --i)\\n            for(int j=1; j<n-1; ++j)\\n                if(dp[i][j]) {\\n                    dp[i][j] += min(dp[i+1][j], min(dp[i+1][j-1], dp[i+1][j+1]));\\n                    count += dp[i][j] - 1;\\n                }\\n    \\n        return count;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1608136,
                "title": "python-dp-using-pyramid-heights",
                "content": "Essentially, if you know the maximum height of a pyramid starting at a particular cell, you have max(0, max_height-1) pyramids that have a tip at that cell. It\\'s then just a matter of determining the heights for each cell and counting\\n\\n```\\nclass Solution:\\n    \\n    def count(self, grid):\\n        n,m = len(grid), len(grid[0])\\n        if(n == 1):\\n            return 0\\n        ansr = 0\\n\\n        dp = [[0]*m for _ in range(n)]\\n        #alright dp[i,j] is the maximum heigh of a pyarmid with i,j as tip\\n        # height 1 is invalid\\n        for i in range(1,m-1):\\n            if(grid[-2][i] == 1):\\n                if(grid[-1][i] == grid[-1][i-1] == grid[-1][i+1] == 1):\\n                    dp[-2][i] = 2\\n                    ansr += 1\\n        ## now fill out the rest of the dp\\n        for i in range(n-3, -1, -1):\\n            for j in range(1, m-1):\\n                #print(i,j)\\n                if(grid[i][j] == 1 and grid[i+1][j] == 1):\\n                    dp[i][j] = min(dp[i+1][j+1], dp[i+1][j-1])+1\\n                if(grid[i][j] == grid[i+1][j+1] == grid[i+1][j-1] == grid[i+1][j] == 1):\\n                    dp[i][j] = max(dp[i][j], 2)\\n                \\n                ansr += max(0,dp[i][j]-1)\\n        #print(dp)\\n\\n        return ansr\\n    \\n    def countPyramids(self, grid: List[List[int]]) -> int:\\n        #print(grid[::-1])\\n        return self.count(grid)+self.count(grid[::-1])\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution:\\n    \\n    def count(self, grid):\\n        n,m = len(grid), len(grid[0])\\n        if(n == 1):\\n            return 0\\n        ansr = 0\\n\\n        dp = [[0]*m for _ in range(n)]\\n        #alright dp[i,j] is the maximum heigh of a pyarmid with i,j as tip\\n        # height 1 is invalid\\n        for i in range(1,m-1):\\n            if(grid[-2][i] == 1):\\n                if(grid[-1][i] == grid[-1][i-1] == grid[-1][i+1] == 1):\\n                    dp[-2][i] = 2\\n                    ansr += 1\\n        ## now fill out the rest of the dp\\n        for i in range(n-3, -1, -1):\\n            for j in range(1, m-1):\\n                #print(i,j)\\n                if(grid[i][j] == 1 and grid[i+1][j] == 1):\\n                    dp[i][j] = min(dp[i+1][j+1], dp[i+1][j-1])+1\\n                if(grid[i][j] == grid[i+1][j+1] == grid[i+1][j-1] == grid[i+1][j] == 1):\\n                    dp[i][j] = max(dp[i][j], 2)\\n                \\n                ansr += max(0,dp[i][j]-1)\\n        #print(dp)\\n\\n        return ansr\\n    \\n    def countPyramids(self, grid: List[List[int]]) -> int:\\n        #print(grid[::-1])\\n        return self.count(grid)+self.count(grid[::-1])\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1600584,
                "title": "why-tle-for-o-n-m-n-c",
                "content": "Why this solution gave TLE at contest time (max time complexity is O(n*m*n)  which is less than or equal to 10^8 ) ? But now this solution passed all test case......\\n\\n```\\nclass Solution {\\npublic:\\n    \\n    \\n    int call(vector<vector<int>> a)\\n    {\\n        int n = a.size() , m = a[0].size(),ans=0,f=0;\\n        while(1)\\n        {\\n            f =0 ;\\n            for(int i=0;i<n-1;i++)\\n            {\\n                for(int j=1;j<m-1;j++)\\n                {\\n                    if(a[i][j]!=0&&a[i][j]==a[i+1][j]&&a[i][j]==a[i+1][j-1]&&a[i][j]==a[i+1][j+1])\\n                    {\\n                        f=1;\\n                        a[i][j] += 1;\\n                    }\\n                }\\n            }\\n            if(f==0)\\n                break;\\n        }\\n        \\n        for(int i=0;i<n;i++)\\n        {\\n            for(int j=0;j<m;j++)\\n            {\\n                if(a[i][j]!=0)\\n                ans += a[i][j]-1;\\n            }\\n        }\\n        \\n        return ans;\\n    }\\n    \\n    int countPyramids(vector<vector<int>>& a) {\\n        \\n        int ans = call(a);\\n        int n = a.size();\\n        for(int i=0,j=n-1;i<j;i++,j--)\\n        {\\n            swap(a[i],a[j]);\\n        }\\n        \\n        int b = call(a);\\n       // cout<<ans<<\" \"<<b;\\n        return b+ans;\\n        \\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    \\n    \\n    int call(vector<vector<int>> a)\\n    {\\n        int n = a.size() , m = a[0].size(),ans=0,f=0;\\n        while(1)\\n        {\\n            f =0 ;\\n            for(int i=0;i<n-1;i++)\\n            {\\n                for(int j=1;j<m-1;j++)\\n                {\\n                    if(a[i][j]!=0&&a[i][j]==a[i+1][j]&&a[i][j]==a[i+1][j-1]&&a[i][j]==a[i+1][j+1])\\n                    {\\n                        f=1;\\n                        a[i][j] += 1;\\n                    }\\n                }\\n            }\\n            if(f==0)\\n                break;\\n        }\\n        \\n        for(int i=0;i<n;i++)\\n        {\\n            for(int j=0;j<m;j++)\\n            {\\n                if(a[i][j]!=0)\\n                ans += a[i][j]-1;\\n            }\\n        }\\n        \\n        return ans;\\n    }\\n    \\n    int countPyramids(vector<vector<int>>& a) {\\n        \\n        int ans = call(a);\\n        int n = a.size();\\n        for(int i=0,j=n-1;i<j;i++,j--)\\n        {\\n            swap(a[i],a[j]);\\n        }\\n        \\n        int b = call(a);\\n       // cout<<ans<<\" \"<<b;\\n        return b+ans;\\n        \\n    }\\n};\\n```",
                "codeTag": "C++"
            },
            {
                "id": 1599023,
                "title": "python-dp-solution",
                "content": "```\\nclass Solution:\\n    def countPyramids(self, grid: List[List[int]]) -> int:\\n        #checks if there are 3 ones below (x,y)\\n        def check(x,y):\\n            count = 0\\n            to_check = {(1,0),(1,-1),(1,1)}\\n            for dx,dy in to_check:\\n                if(0<=x+dx<len(grid) and 0<=y+dy<len(grid[0]) and grid[x+dx][y+dy]==1):\\n                    count += 1\\n            if(count == 3):\\n                return True\\n            else:\\n                return False\\n        \\n        memo = {}\\n        #dp returns the number of pyramid levels under (x,y)\\n        def dp(x,y):\\n            if((x,y) in memo):\\n                return memo[(x,y)]\\n            levels = 0\\n            if(check(x,y)==True):\\n                levels += 1\\n            else:\\n                return levels\\n            to_check = {(1,0),(1,-1),(1,1)}\\n            t = float(\\'inf\\')\\n            #t is the number of additional levels\\n            for dx,dy in to_check: \\n                if(0<=x+dx<len(grid) and 0<=y+dy<len(grid[0]) and grid[x+dx][y+dy]==1):\\n                    t = min(t,dp(x+dx,y+dy))\\n            memo[(x,y)] = levels + t\\n            return levels + t      \\n        \\n\\t\\t#check number of normal pyramidal plots\\n        ans = 0\\n        for i in range(len(grid)):\\n            for j in range(len(grid[0])):\\n                if(grid[i][j] == 1):\\n                    ans += dp(i,j)\\n        \\n\\t\\t#check number of inverse pyramidal plots\\n        memo = {}\\n        grid = grid[::-1]\\n        for i in range(len(grid)):\\n            for j in range(len(grid[0])):\\n                if(grid[i][j] == 1):\\n                    ans += dp(i,j)\\n        return ans\\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def countPyramids(self, grid: List[List[int]]) -> int:\\n        #checks if there are 3 ones below (x,y)\\n        def check(x,y):\\n            count = 0\\n            to_check = {(1,0),(1,-1),(1,1)}\\n            for dx,dy in to_check:\\n                if(0<=x+dx<len(grid) and 0<=y+dy<len(grid[0]) and grid[x+dx][y+dy]==1):\\n                    count += 1\\n            if(count == 3):\\n                return True\\n            else:\\n                return False\\n        \\n        memo = {}\\n        #dp returns the number of pyramid levels under (x,y)\\n        def dp(x,y):\\n            if((x,y) in memo):\\n                return memo[(x,y)]\\n            levels = 0\\n            if(check(x,y)==True):\\n                levels += 1\\n            else:\\n                return levels\\n            to_check = {(1,0),(1,-1),(1,1)}\\n            t = float(\\'inf\\')\\n            #t is the number of additional levels\\n            for dx,dy in to_check: \\n                if(0<=x+dx<len(grid) and 0<=y+dy<len(grid[0]) and grid[x+dx][y+dy]==1):\\n                    t = min(t,dp(x+dx,y+dy))\\n            memo[(x,y)] = levels + t\\n            return levels + t      \\n        \\n\\t\\t#check number of normal pyramidal plots\\n        ans = 0\\n        for i in range(len(grid)):\\n            for j in range(len(grid[0])):\\n                if(grid[i][j] == 1):\\n                    ans += dp(i,j)\\n        \\n\\t\\t#check number of inverse pyramidal plots\\n        memo = {}\\n        grid = grid[::-1]\\n        for i in range(len(grid)):\\n            for j in range(len(grid[0])):\\n                if(grid[i][j] == 1):\\n                    ans += dp(i,j)\\n        return ans\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1598977,
                "title": "python3-dp",
                "content": "for cell `(r, c)`, if `grid[r][c] == 1`:\\n1. let `l` be the count of continuous 1s until column `c` on row `r`, which is the previous dp value + 1\\n2. let `h` be the max height of valid fertile pyramid that \"ends\" at (r, c) (r, c is the bottom right cell of the pyramid), which is min(max height of upper left pyramid + 1, (l + 1)//2) -- the number of 1s of each pyramid row is `h\\'*2 - 1`, `l` continuous 1s can form pyramids on top of them of max height `(l + 1)//2`\\n3. add `h - 1` to final answer, since we can form `h` pyramids that ends at (r, c), but the one with height 1 (just (r, c)) doesn\\'t count.\\n\\nexample:\\n```text\\n[dp]\\n.................................\\n......... (??, ph), (??, ??) ....\\n......... (pl, ??), ( l,  h) <- calculating\\n\\nif the cell in grid is 1:\\n    l = pl + 1\\n\\th = min(ph + 1, (l + 1)//2)\\nelse:\\n    l = h = 0\\n```\\n\\ncount from top to bottom, then from bottom to top.\\n\\n```python\\ndef countPyramids(self, grid: List[List[int]]) -> int:\\n\\tR, C = len(grid), len(grid[0])\\n\\tdef count(rg):\\n\\t\\tcnt = 0\\n\\t\\tdp = [(0, 0) for _ in range(C + 1)]\\n\\t\\tfor r in rg:\\n\\t\\t\\tndp = [(0, 0)]\\n\\t\\t\\tfor c in range(C):\\n\\t\\t\\t\\tif grid[r][c]:\\n\\t\\t\\t\\t\\tl = ndp[-1][0] + 1\\n\\t\\t\\t\\t\\th = min(dp[c][1] + 1, (l + 1)//2)\\n\\t\\t\\t\\t\\tcnt += h - 1\\n\\t\\t\\t\\t\\tndp.append((l, h))\\n\\t\\t\\t\\telse:\\n\\t\\t\\t\\t\\tndp.append((0, 0))\\n\\t\\t\\tdp = ndp\\n\\t\\treturn cnt\\n\\treturn count(range(R)) + count(range(R - 1, -1, -1))\\n```\\n\\ntime: O(R\\\\*C)\\nspace: O(C)",
                "solutionTags": [],
                "code": "```text\\n[dp]\\n.................................\\n......... (??, ph), (??, ??) ....\\n......... (pl, ??), ( l,  h) <- calculating\\n\\nif the cell in grid is 1:\\n    l = pl + 1\\n\\th = min(ph + 1, (l + 1)//2)\\nelse:\\n    l = h = 0\\n```\n```python\\ndef countPyramids(self, grid: List[List[int]]) -> int:\\n\\tR, C = len(grid), len(grid[0])\\n\\tdef count(rg):\\n\\t\\tcnt = 0\\n\\t\\tdp = [(0, 0) for _ in range(C + 1)]\\n\\t\\tfor r in rg:\\n\\t\\t\\tndp = [(0, 0)]\\n\\t\\t\\tfor c in range(C):\\n\\t\\t\\t\\tif grid[r][c]:\\n\\t\\t\\t\\t\\tl = ndp[-1][0] + 1\\n\\t\\t\\t\\t\\th = min(dp[c][1] + 1, (l + 1)//2)\\n\\t\\t\\t\\t\\tcnt += h - 1\\n\\t\\t\\t\\t\\tndp.append((l, h))\\n\\t\\t\\t\\telse:\\n\\t\\t\\t\\t\\tndp.append((0, 0))\\n\\t\\t\\tdp = ndp\\n\\t\\treturn cnt\\n\\treturn count(range(R)) + count(range(R - 1, -1, -1))\\n```",
                "codeTag": "Python3"
            },
            {
                "id": 1598898,
                "title": "c-2088-count-fertile-pyramids-in-a-land",
                "content": "\\n```\\nclass Solution {\\npublic:\\n    int countPyramids(vector<vector<int>>& grid) {\\n        int m = grid.size(), n = grid[0].size(); \\n        vector<vector<int>> vals(m, vector<int>(n, INT_MAX)); \\n        for (int i = 0; i < m; ++i) \\n            for (int j = 0; j < n; ++j) {\\n                if (grid[i][j] == 0) vals[i][j] = 0; \\n                else if (j == 0) vals[i][j] = 1; \\n                else vals[i][j] = min(vals[i][j], 1 + vals[i][j-1]); \\n\\n                if (grid[i][n-1-j] == 0) vals[i][n-1-j] = 0; \\n                else if (j == 0) vals[i][n-1-j] = 1; \\n                else vals[i][n-1-j] = min(vals[i][n-1-j], 1 + vals[i][n-j]); \\n            }\\n        \\n        auto fn = [&](vector<vector<int>>& vals) {\\n            int ans = 0; \\n            for (int j = 0; j < n; ++j) {\\n                int width = 0; \\n                for (int i = 0; i < m; ++i) {\\n                    if (vals[i][j]) width = min(1+width, vals[i][j]); \\n                    else width = 0; \\n                    ans += max(0, width-1); \\n                }\\n            }\\n            return ans; \\n        }; \\n        \\n        int ans = fn(vals); \\n        reverse(vals.begin(), vals.end()); \\n        ans += fn(vals); \\n        return ans; \\n    }\\n};\\n```",
                "solutionTags": [
                    "C"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int countPyramids(vector<vector<int>>& grid) {\\n        int m = grid.size(), n = grid[0].size(); \\n        vector<vector<int>> vals(m, vector<int>(n, INT_MAX)); \\n        for (int i = 0; i < m; ++i) \\n            for (int j = 0; j < n; ++j) {\\n                if (grid[i][j] == 0) vals[i][j] = 0; \\n                else if (j == 0) vals[i][j] = 1; \\n                else vals[i][j] = min(vals[i][j], 1 + vals[i][j-1]); \\n\\n                if (grid[i][n-1-j] == 0) vals[i][n-1-j] = 0; \\n                else if (j == 0) vals[i][n-1-j] = 1; \\n                else vals[i][n-1-j] = min(vals[i][n-1-j], 1 + vals[i][n-j]); \\n            }\\n        \\n        auto fn = [&](vector<vector<int>>& vals) {\\n            int ans = 0; \\n            for (int j = 0; j < n; ++j) {\\n                int width = 0; \\n                for (int i = 0; i < m; ++i) {\\n                    if (vals[i][j]) width = min(1+width, vals[i][j]); \\n                    else width = 0; \\n                    ans += max(0, width-1); \\n                }\\n            }\\n            return ans; \\n        }; \\n        \\n        int ans = fn(vals); \\n        reverse(vals.begin(), vals.end()); \\n        ans += fn(vals); \\n        return ans; \\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 4070209,
                "title": "screw-dp-parent-pyramid-is-just-left-right-sub-pyramid",
                "content": "Start solving this problem by drawing a pyramid. You will notice that pyramid consist of left sub-pyramid + right sub-pyramid and one extra cell right below the top\\n```\\n     .\\n   . . .\\n . . . . .\\n \\n or\\n \\n     x\\n 1   x   2\\nx x x x x x\\n```\\nwhere 1 is left sub-pyramid and 2 is right sub-pyraid.  \\nThe hight of the parent pyramid depens on the height of the left and right sub-pyramid. Now that you have the picture in mind, to find hight of your pyramid you need to recursively find height of the left and right pyramid and make sure there is cell right below the top of the current pyramid. This infromation is enough to tell you the height of the current pyramid.\\n\\n```\\n    def countPyramids(self, grid: List[List[int]]) -> int:\\n        M = len(grid)\\n        N = len(grid[0])\\n        \\n        @cache\\n        def getPyramidHeight(r, c, isInverse):\\n            if r < 0 or r == M or c < 0 or c == N: return 0\\n            if grid[r][c] == 0: return 0\\n            \\n            rowDelta = -1 if isInverse else 1\\n            leftPyramidHeight = getPyramidHeight(r + rowDelta, c - 1, isInverse)\\n            middlePyramidHeight = getPyramidHeight(r + rowDelta, c, isInverse)\\n            rightPyramidHeight = getPyramidHeight(r + rowDelta, c + 1, isInverse)\\n            \\n            if middlePyramidHeight == 0: return 1\\n            return 1 + min(leftPyramidHeight, rightPyramidHeight)\\n       \\n        totalNumber = 0\\n    \\n        for r in range(M):\\n            for c in range(N):\\n                height = getPyramidHeight(r, c, False)\\n                inverseHeight = getPyramidHeight(r, c, True)\\n                if height > 1: totalNumber += height - 1\\n                if inverseHeight > 1: totalNumber += inverseHeight - 1\\n                    \\n        return totalNumber\\n\\t",
                "solutionTags": [],
                "code": "```\\n     .\\n   . . .\\n . . . . .\\n \\n or\\n \\n     x\\n 1   x   2\\nx x x x x x\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 4054653,
                "title": "c-3d-dp-solution",
                "content": "# Approach\\nFor every cell, we find the maximum height pyramid possible, For Example, if a pyramid of height 2 is possible for a cell, then 2 pyramids can be formed starting at the cell. So we simply do this for every cell. The mode parameter indicates whether we are finding normal or inverse pyramid.\\n\\n# Complexity\\n- Time complexity: $$O(n*m)$$\\n\\n- Space complexity: $$O(n*m*2)$$\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n\\n    int dp[1001][1001][2];\\n    \\n    int f(int i, int j, vector<vector<int>>& grid, int mode){\\n        if(dp[i][j][mode] != -1) return dp[i][j][mode];\\n        int ans = 0;\\n        int x = mode ? i + 1 : i - 1;\\n        if(x < grid.size() and x >= 0 and j - 1 >= 0 and j + 1 < grid[0].size() and grid[x][j] and grid[x][j - 1] and grid[x][j + 1]){\\n           ans = 1 + min(f(x, j - 1, grid, mode), f(x, j + 1, grid, mode));\\n        }\\n        return dp[i][j][mode] = ans;\\n    }\\n\\n    int countPyramids(vector<vector<int>>& grid) {\\n        memset(dp, -1, sizeof dp);\\n        int ans = 0;\\n        for(int i = 0, n = grid.size(), m = grid[0].size(); i < n; i++){\\n            for(int j = 0; j < m; j++){\\n                if(grid[i][j]){\\n                    ans += f(i, j, grid, 0) + f(i, j, grid, 1);\\n                }\\n            }\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Dynamic Programming",
                    "Memoization",
                    "Matrix"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n\\n    int dp[1001][1001][2];\\n    \\n    int f(int i, int j, vector<vector<int>>& grid, int mode){\\n        if(dp[i][j][mode] != -1) return dp[i][j][mode];\\n        int ans = 0;\\n        int x = mode ? i + 1 : i - 1;\\n        if(x < grid.size() and x >= 0 and j - 1 >= 0 and j + 1 < grid[0].size() and grid[x][j] and grid[x][j - 1] and grid[x][j + 1]){\\n           ans = 1 + min(f(x, j - 1, grid, mode), f(x, j + 1, grid, mode));\\n        }\\n        return dp[i][j][mode] = ans;\\n    }\\n\\n    int countPyramids(vector<vector<int>>& grid) {\\n        memset(dp, -1, sizeof dp);\\n        int ans = 0;\\n        for(int i = 0, n = grid.size(), m = grid[0].size(); i < n; i++){\\n            for(int j = 0; j < m; j++){\\n                if(grid[i][j]){\\n                    ans += f(i, j, grid, 0) + f(i, j, grid, 1);\\n                }\\n            }\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 4028791,
                "title": "python-dp-with-clear-naming",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution:\\n\\n    def countPyramids(self, G):\\n        \\n        num_rows = len(G)\\n        num_cols = len(G[0])\\n\\n        @cache\\n        def get_height_with_apex(row, col, dir):\\n\\n            if G[row][col] == 1 and 0 <= row + dir <= num_rows - 1 and col - 1 >= 0 and col + 1 <= num_cols - 1 and G[row + dir][col] == 1:\\n                return min(get_height_with_apex(row + dir, col - 1, dir), get_height_with_apex(row + dir, col + 1, dir)) + 1\\n            \\n            return G[row][col]\\n\\n        total_num_pyriads = 0\\n        for row in range(num_rows):\\n            for col in range(num_cols):\\n                top_apex_height = get_height_with_apex(row, col, 1)\\n                # num pyriads with this (row, col) as apex\\n                num_pyriads_with_top_apex = max(0, top_apex_height - 1)\\n\\n                total_num_pyriads += num_pyriads_with_top_apex \\n\\n                bot_apex_height = get_height_with_apex(row, col, -1)\\n                num_pyriads_with_bot_apex = max(0, bot_apex_height - 1)\\n\\n                total_num_pyriads += num_pyriads_with_bot_apex\\n\\n        return total_num_pyriads\\n\\n        \\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n\\n    def countPyramids(self, G):\\n        \\n        num_rows = len(G)\\n        num_cols = len(G[0])\\n\\n        @cache\\n        def get_height_with_apex(row, col, dir):\\n\\n            if G[row][col] == 1 and 0 <= row + dir <= num_rows - 1 and col - 1 >= 0 and col + 1 <= num_cols - 1 and G[row + dir][col] == 1:\\n                return min(get_height_with_apex(row + dir, col - 1, dir), get_height_with_apex(row + dir, col + 1, dir)) + 1\\n            \\n            return G[row][col]\\n\\n        total_num_pyriads = 0\\n        for row in range(num_rows):\\n            for col in range(num_cols):\\n                top_apex_height = get_height_with_apex(row, col, 1)\\n                # num pyriads with this (row, col) as apex\\n                num_pyriads_with_top_apex = max(0, top_apex_height - 1)\\n\\n                total_num_pyriads += num_pyriads_with_top_apex \\n\\n                bot_apex_height = get_height_with_apex(row, col, -1)\\n                num_pyriads_with_bot_apex = max(0, bot_apex_height - 1)\\n\\n                total_num_pyriads += num_pyriads_with_bot_apex\\n\\n        return total_num_pyriads\\n\\n        \\n```",
                "codeTag": "Java"
            },
            {
                "id": 3898932,
                "title": "easy-c-solution",
                "content": "\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\nint n,m;\\nbool valid(int i,int j)\\n{\\n    return i>=0 && j>=0 && i<n && j<m;\\n}\\n    int countPyramids(vector<vector<int>>& grid) {\\n        n=grid.size();\\n        m=grid[0].size();\\n        vector<vector<int>>temp=grid;\\n        int ans=0;\\n        for (int i=n-2;i>=0;i--)\\n        {\\n            for (int j=m-1;j>=0;j--)\\n            {\\n              if (grid[i][j]==1)\\n              {\\n                  if (valid(i+1,j-1) && valid(i+1,j) && valid(i+1,j+1))\\n                  {\\n                      grid[i][j]=1+min(grid[i+1][j-1],min(grid[i+1][j],grid[i+1][j+1]));\\n                      ans+=(grid[i][j]-1);\\n                  }\\n              }\\n            }\\n        }\\n        for (int i=1;i<n;i++)\\n        {\\n            for (int j=0;j<m;j++)\\n            {\\n                if (temp[i][j]==1)\\n                {\\n                    if (valid(i-1,j-1) && valid(i-1,j) && valid(i-1,j+1))\\n                    {\\n                        temp[i][j]=1+min(temp[i-1][j-1],min(temp[i-1][j],temp[i-1][j+1]));\\n                        ans+=(temp[i][j]-1);\\n                    }\\n                }\\n            }\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\nint n,m;\\nbool valid(int i,int j)\\n{\\n    return i>=0 && j>=0 && i<n && j<m;\\n}\\n    int countPyramids(vector<vector<int>>& grid) {\\n        n=grid.size();\\n        m=grid[0].size();\\n        vector<vector<int>>temp=grid;\\n        int ans=0;\\n        for (int i=n-2;i>=0;i--)\\n        {\\n            for (int j=m-1;j>=0;j--)\\n            {\\n              if (grid[i][j]==1)\\n              {\\n                  if (valid(i+1,j-1) && valid(i+1,j) && valid(i+1,j+1))\\n                  {\\n                      grid[i][j]=1+min(grid[i+1][j-1],min(grid[i+1][j],grid[i+1][j+1]));\\n                      ans+=(grid[i][j]-1);\\n                  }\\n              }\\n            }\\n        }\\n        for (int i=1;i<n;i++)\\n        {\\n            for (int j=0;j<m;j++)\\n            {\\n                if (temp[i][j]==1)\\n                {\\n                    if (valid(i-1,j-1) && valid(i-1,j) && valid(i-1,j+1))\\n                    {\\n                        temp[i][j]=1+min(temp[i-1][j-1],min(temp[i-1][j],temp[i-1][j+1]));\\n                        ans+=(temp[i][j]-1);\\n                    }\\n                }\\n            }\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3889961,
                "title": "intutive-solution",
                "content": "\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\nO(m*n)\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\nO(m*n)\\n# Code\\n```\\nclass Solution{\\n    int InversePyramids(vector<vector<int>>& grid){\\n        int m=grid.size(),n=grid[0].size();\\n        vector<vector<int>> dp=grid;\\n        int ans=0;\\n        for(int i=1;i<m;i++){\\n            for(int j=1;j<n-1;j++){\\n                if(dp[i][j]==1 && dp[i-1][j]){\\n                    dp[i][j]=min(dp[i-1][j-1],dp[i-1][j+1])+1;\\n                    ans+=dp[i][j]-1;\\n                }\\n            }\\n        }\\n        return ans;\\n    }\\npublic:\\n    int countPyramids(vector<vector<int>>& grid) {\\n        vector<vector<int>> rev=grid;\\n        reverse(rev.begin(),rev.end());\\n        return InversePyramids(grid)+InversePyramids(rev);\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution{\\n    int InversePyramids(vector<vector<int>>& grid){\\n        int m=grid.size(),n=grid[0].size();\\n        vector<vector<int>> dp=grid;\\n        int ans=0;\\n        for(int i=1;i<m;i++){\\n            for(int j=1;j<n-1;j++){\\n                if(dp[i][j]==1 && dp[i-1][j]){\\n                    dp[i][j]=min(dp[i-1][j-1],dp[i-1][j+1])+1;\\n                    ans+=dp[i][j]-1;\\n                }\\n            }\\n        }\\n        return ans;\\n    }\\npublic:\\n    int countPyramids(vector<vector<int>>& grid) {\\n        vector<vector<int>> rev=grid;\\n        reverse(rev.begin(),rev.end());\\n        return InversePyramids(grid)+InversePyramids(rev);\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3826968,
                "title": "c-prefix-sum-dfs-slow-but-great-intution",
                "content": "# Code\\n```\\nclass Solution {\\n\\nprivate:\\n    int dfsTop(vector<vector<int>> &ones, vector<vector<int>> &grid, int row, int colLeft, int colRight, int limit, int number){\\n        if(colLeft < 0 || colRight >= limit || row < 0 ) return 0;\\n\\n        int count = ones[row][colRight] - ones[row][colLeft];\\n\\n        if(grid[row][colLeft] == 1) count += 1;\\n\\n        if(count != number) return 0;\\n\\n\\n        int answer = 0;\\n\\n        answer = 1 + dfsTop(ones, grid, row - 1, colLeft - 1, colRight + 1, limit, number + 2);\\n\\n        return answer;\\n    }\\n\\n    int dfsBottom(vector<vector<int>> &ones, vector<vector<int>> &grid, int row, int colLeft, int colRight, int limitCol, int limitRow, int number){\\n\\n        if(colLeft < 0 || colRight >= limitCol || row >= limitRow) return 0;\\n\\n        int count = ones[row][colRight] - ones[row][colLeft];\\n\\n        if(grid[row][colLeft] == 1) count += 1;\\n\\n        if(count != number) return 0; \\n\\n        int answer = 0;\\n\\n        answer = 1 + dfsBottom(ones, grid, row + 1, colLeft - 1, colRight + 1, limitCol, limitRow, number + 2);\\n\\n        return answer;\\n    }\\n\\npublic:\\n    int countPyramids(vector<vector<int>>& grid) {\\n        // Intution\\n        // Once we found one do the dfs traversal\\n        int m = grid.size();\\n        int n = grid[0].size();\\n        vector<vector<int>> count(m, vector<int> (n, 0));\\n        for(int i = 0 ; i < m ; i++){\\n            int currCount = 0;\\n            for(int j = 0 ; j < n ; j++){\\n                currCount += (grid[i][j] == 1);\\n                count[i][j] = currCount;\\n            }\\n        }\\n        int answer = 0;\\n        for(int i = 0 ; i < m; i++){\\n            for(int j = 0 ; j < n ; j++){\\n                if(grid[i][j] == 1){\\n                    int ans1 = dfsTop(count, grid, i, j, j, n, 1);\\n                    int ans2 = dfsBottom(count, grid, i, j, j, n, m, 1);\\n                    answer += (ans1 - 1) + (ans2 - 1);\\n                 }\\n            }\\n        }\\n        return answer;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\n\\nprivate:\\n    int dfsTop(vector<vector<int>> &ones, vector<vector<int>> &grid, int row, int colLeft, int colRight, int limit, int number){\\n        if(colLeft < 0 || colRight >= limit || row < 0 ) return 0;\\n\\n        int count = ones[row][colRight] - ones[row][colLeft];\\n\\n        if(grid[row][colLeft] == 1) count += 1;\\n\\n        if(count != number) return 0;\\n\\n\\n        int answer = 0;\\n\\n        answer = 1 + dfsTop(ones, grid, row - 1, colLeft - 1, colRight + 1, limit, number + 2);\\n\\n        return answer;\\n    }\\n\\n    int dfsBottom(vector<vector<int>> &ones, vector<vector<int>> &grid, int row, int colLeft, int colRight, int limitCol, int limitRow, int number){\\n\\n        if(colLeft < 0 || colRight >= limitCol || row >= limitRow) return 0;\\n\\n        int count = ones[row][colRight] - ones[row][colLeft];\\n\\n        if(grid[row][colLeft] == 1) count += 1;\\n\\n        if(count != number) return 0; \\n\\n        int answer = 0;\\n\\n        answer = 1 + dfsBottom(ones, grid, row + 1, colLeft - 1, colRight + 1, limitCol, limitRow, number + 2);\\n\\n        return answer;\\n    }\\n\\npublic:\\n    int countPyramids(vector<vector<int>>& grid) {\\n        // Intution\\n        // Once we found one do the dfs traversal\\n        int m = grid.size();\\n        int n = grid[0].size();\\n        vector<vector<int>> count(m, vector<int> (n, 0));\\n        for(int i = 0 ; i < m ; i++){\\n            int currCount = 0;\\n            for(int j = 0 ; j < n ; j++){\\n                currCount += (grid[i][j] == 1);\\n                count[i][j] = currCount;\\n            }\\n        }\\n        int answer = 0;\\n        for(int i = 0 ; i < m; i++){\\n            for(int j = 0 ; j < n ; j++){\\n                if(grid[i][j] == 1){\\n                    int ans1 = dfsTop(count, grid, i, j, j, n, 1);\\n                    int ans2 = dfsBottom(count, grid, i, j, j, n, m, 1);\\n                    answer += (ans1 - 1) + (ans2 - 1);\\n                 }\\n            }\\n        }\\n        return answer;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3764946,
                "title": "counting-pyramids-conquer-the-grid-with-recursive-memoization",
                "content": "# Intuition : \\n<!-- Describe your first thoughts on how to solve this problem. -->\\nThe code counts pyramids in a grid using a recursive approach with memoization. It iterates over each cell, calculates pyramid sizes, and returns the total count.\\n# Approach / Algorithm :\\n<!-- Describe your approach to solving the problem. -->\\n- The inBound function checks if the current position (r, c) is within the bounds of the grid.\\n- The memo function is a recursive function that calculates the size of the pyramid with the top at position (r, c) in the grid.\\n  - It checks if the current position is out of bounds or if the cells below the current position are not part of a pyramid (values are not equal to 1), and returns 0 in such cases.\\n  - It recursively calculates the sizes of the pyramids for the three positions below the current position (left-bottom, bottom, right-bottom) and returns the minimum size among them plus 1, which represents the size of the current pyramid. The calculated size is also stored in the dp (dynamic programming) table for memoization.\\n- The countPyramids function iterates over all cells in the input grid, checks if the current cell is the top of a pyramid (value is equal to 1), and calculates the total count of pyramids by summing up the pyramid sizes obtained from calling the memo function.\\n- It also creates a reversed grid (grid2) to count pyramids with tops at the bottom of the original grid, using a similar approach as above.\\nThe final count is the sum of the pyramid counts from the original grid (upTri) and the reversed grid (lowTri).\\n# Complexity : \\n- Time complexity: $$O(m * n * k)$$\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n- Space complexity: $$O(m * n)$$\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code :\\n```\\nclass Solution {\\nprivate:\\n    bool inBound(int r,int c,int m,int n){\\n        if(r<0 || r>=m-1 || c<=0 || c>=n-1) return false;\\n        return true;\\n    }\\n    int memo(int r,int c,vector<vector<int>>& grid,vector<vector<int>>& dp){\\n        int m=grid.size();\\n        int n=grid[0].size();\\n\\n        if(!inBound(r,c,m,n)) return 0;\\n\\n        if(dp[r][c]!=-1) return dp[r][c];\\n\\n        if(grid[r+1][c-1]!=1 || grid[r+1][c]!=1 || grid[r+1][c+1]!=1 ) return 0;\\n\\n        int lb=memo(r+1,c-1,grid,dp);\\n        int b=memo(r+1,c,grid,dp);\\n        int rb=memo(r+1,c+1,grid,dp);\\n\\n        return dp[r][c]=min(lb,min(b,rb))+1;\\n    }\\npublic:\\n    int countPyramids(vector<vector<int>>& grid) {\\n        int m=grid.size();\\n        int n=grid[0].size();\\n\\n        vector<vector<int>> dp1(m,vector<int>(n,-1));\\n        int upTri=0;\\n        for(int i=0;i<m;i++){\\n            for(int j=0;j<n;j++){\\n                if(grid[i][j]==1){\\n                    upTri+=memo(i,j,grid,dp1);\\n                }\\n                else{\\n                    dp1[i][j]=0;\\n                }\\n            }\\n        }\\n\\n        vector<vector<int>> grid2(m,vector<int>(n));\\n        vector<vector<int>> dp2(m,vector<int>(n,-1));\\n        for(int i=0;i<m;i++){\\n            for(int j=0;j<n;j++){\\n                grid2[i][j]=grid[m-i-1][n-j-1];\\n            }\\n        }\\n        int lowTri=0;\\n        for(int i=0;i<m;i++){\\n            for(int j=0;j<n;j++){\\n                if(grid2[i][j]==1){\\n                    lowTri+=memo(i,j,grid2,dp2);\\n                }\\n                else{\\n                    dp2[i][j]=0;\\n                }\\n            }\\n        }\\n        return upTri+lowTri;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Array",
                    "Dynamic Programming",
                    "Matrix"
                ],
                "code": "```\\nclass Solution {\\nprivate:\\n    bool inBound(int r,int c,int m,int n){\\n        if(r<0 || r>=m-1 || c<=0 || c>=n-1) return false;\\n        return true;\\n    }\\n    int memo(int r,int c,vector<vector<int>>& grid,vector<vector<int>>& dp){\\n        int m=grid.size();\\n        int n=grid[0].size();\\n\\n        if(!inBound(r,c,m,n)) return 0;\\n\\n        if(dp[r][c]!=-1) return dp[r][c];\\n\\n        if(grid[r+1][c-1]!=1 || grid[r+1][c]!=1 || grid[r+1][c+1]!=1 ) return 0;\\n\\n        int lb=memo(r+1,c-1,grid,dp);\\n        int b=memo(r+1,c,grid,dp);\\n        int rb=memo(r+1,c+1,grid,dp);\\n\\n        return dp[r][c]=min(lb,min(b,rb))+1;\\n    }\\npublic:\\n    int countPyramids(vector<vector<int>>& grid) {\\n        int m=grid.size();\\n        int n=grid[0].size();\\n\\n        vector<vector<int>> dp1(m,vector<int>(n,-1));\\n        int upTri=0;\\n        for(int i=0;i<m;i++){\\n            for(int j=0;j<n;j++){\\n                if(grid[i][j]==1){\\n                    upTri+=memo(i,j,grid,dp1);\\n                }\\n                else{\\n                    dp1[i][j]=0;\\n                }\\n            }\\n        }\\n\\n        vector<vector<int>> grid2(m,vector<int>(n));\\n        vector<vector<int>> dp2(m,vector<int>(n,-1));\\n        for(int i=0;i<m;i++){\\n            for(int j=0;j<n;j++){\\n                grid2[i][j]=grid[m-i-1][n-j-1];\\n            }\\n        }\\n        int lowTri=0;\\n        for(int i=0;i<m;i++){\\n            for(int j=0;j<n;j++){\\n                if(grid2[i][j]==1){\\n                    lowTri+=memo(i,j,grid2,dp2);\\n                }\\n                else{\\n                    dp2[i][j]=0;\\n                }\\n            }\\n        }\\n        return upTri+lowTri;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3759541,
                "title": "my-solution",
                "content": "```\\n/**\\n * Time Complexity: O(rows * cols)\\n * Space Complexity: O(rows * cols)\\n * where `rows` is the number of the rows of the grid `grid`\\n *       `cols` is the number of the columns of the grid `grid`\\n */\\nclass Solution {\\n public:\\n  int countPyramids(const vector<vector<int>> &grid) {\\n    constexpr int fertile = 1;\\n    const int rows = static_cast<int>(grid.size());\\n    const int cols = static_cast<int>(grid.front().size());\\n    vector<vector<int>> left(rows, vector<int>(cols));\\n    vector<vector<int>> right(rows, vector<int>(cols));\\n    for (int r = 0; r < rows; ++r) {\\n      int left_count = 0;\\n      int right_count = 0;\\n      for (int c = 0; c < cols; ++c) {\\n        if (grid[r][c] == fertile) {\\n          ++left_count;\\n        } else {\\n          left_count = 0;\\n        }\\n        left[r][c] = left_count;\\n        \\n        if (grid[r][cols - c - 1] == fertile) {\\n          ++right_count;\\n        } else {\\n          right_count = 0;\\n        }\\n        right[r][cols - c - 1] = right_count;\\n      }\\n    }\\n    \\n    int ret = count(left, right);\\n    reverse(left.begin(), left.end());\\n    reverse(right.begin(), right.end());\\n    ret += count(left, right);\\n    return ret;\\n  }\\n  \\n private:\\n  int count(const vector<vector<int>> &left, const vector<vector<int>> &right) {\\n    const int rows = static_cast<int>(left.size());\\n    const int cols = static_cast<int>(left.front().size());\\n    int ret = 0;\\n    int dp[rows][cols];\\n    memset(dp, 0, sizeof(dp));\\n    for (int r = 0; r < rows; ++r) {\\n      for (int c = 0; c < cols; ++c) {\\n        if (left[r][c] == 0) {\\n          continue;\\n        }\\n        \\n        dp[r][c] = min({left[r][c], right[r][c], (r > 0 ? dp[r - 1][c] : 0) + 1});\\n        ret += dp[r][c] - 1;\\n      }\\n    }\\n    return ret;\\n  }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\n/**\\n * Time Complexity: O(rows * cols)\\n * Space Complexity: O(rows * cols)\\n * where `rows` is the number of the rows of the grid `grid`\\n *       `cols` is the number of the columns of the grid `grid`\\n */\\nclass Solution {\\n public:\\n  int countPyramids(const vector<vector<int>> &grid) {\\n    constexpr int fertile = 1;\\n    const int rows = static_cast<int>(grid.size());\\n    const int cols = static_cast<int>(grid.front().size());\\n    vector<vector<int>> left(rows, vector<int>(cols));\\n    vector<vector<int>> right(rows, vector<int>(cols));\\n    for (int r = 0; r < rows; ++r) {\\n      int left_count = 0;\\n      int right_count = 0;\\n      for (int c = 0; c < cols; ++c) {\\n        if (grid[r][c] == fertile) {\\n          ++left_count;\\n        } else {\\n          left_count = 0;\\n        }\\n        left[r][c] = left_count;\\n        \\n        if (grid[r][cols - c - 1] == fertile) {\\n          ++right_count;\\n        } else {\\n          right_count = 0;\\n        }\\n        right[r][cols - c - 1] = right_count;\\n      }\\n    }\\n    \\n    int ret = count(left, right);\\n    reverse(left.begin(), left.end());\\n    reverse(right.begin(), right.end());\\n    ret += count(left, right);\\n    return ret;\\n  }\\n  \\n private:\\n  int count(const vector<vector<int>> &left, const vector<vector<int>> &right) {\\n    const int rows = static_cast<int>(left.size());\\n    const int cols = static_cast<int>(left.front().size());\\n    int ret = 0;\\n    int dp[rows][cols];\\n    memset(dp, 0, sizeof(dp));\\n    for (int r = 0; r < rows; ++r) {\\n      for (int c = 0; c < cols; ++c) {\\n        if (left[r][c] == 0) {\\n          continue;\\n        }\\n        \\n        dp[r][c] = min({left[r][c], right[r][c], (r > 0 ? dp[r - 1][c] : 0) + 1});\\n        ret += dp[r][c] - 1;\\n      }\\n    }\\n    return ret;\\n  }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3669689,
                "title": "simple-o-n-m-solution",
                "content": "# Approach\\nIts atcually quite an easy solution, not sure why it\\'s maked hard. In first loop we went top to bottom counting the straight pyramids. Everytime we find one we increment the root so if on next layer 3 roots make base for a bigger pyramid we can count all possibilities. Second loop resets the grid. Third loops just as the first one counts inverted pyramids.\\n\\n# Complexity\\n- Time complexity: $$O(n*m)$$\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n\\n# Code\\n```\\nfunction countPyramids(grid: number[][]): number {\\n    let count=0;\\n    for(let r=1;r<grid.length;r++){\\n        for(let c=1;c<grid[0].length-1;c++){\\n            if(grid[r][c]>0 && (grid[r-1][c-1]>0 )&& (grid[r-1][c]>0 )&&(grid[r-1][c+1]>0)){\\n                grid[r][c]=Math.min(grid[r-1][c-1],grid[r-1][c],grid[r-1][c+1])+1\\n                count+=(grid[r][c]-1);\\n            }\\n        }\\n    }\\n    for(let r=1;r<grid.length;r++){\\n        for(let c=1;c<grid[0].length-1;c++){\\n            if(grid[r][c]>0) grid[r][c]=1\\n        }\\n    }\\n    for(let r=grid.length-2;r>-1;r--){\\n        for(let c=1;c<grid[0].length-1;c++){\\n            if(grid[r][c]>0 && (grid[r+1][c-1]>0) && (grid[r+1][c]>0) && (grid[r+1][c+1]>0)){\\n                grid[r][c]=Math.min(grid[r+1][c-1],grid[r+1][c],grid[r+1][c+1])+1\\n                count+=(grid[r][c]-1)\\n            }\\n        }\\n    }\\n    return count;\\n};\\n```",
                "solutionTags": [
                    "JavaScript",
                    "TypeScript",
                    "Array",
                    "Dynamic Programming",
                    "Matrix"
                ],
                "code": "```\\nfunction countPyramids(grid: number[][]): number {\\n    let count=0;\\n    for(let r=1;r<grid.length;r++){\\n        for(let c=1;c<grid[0].length-1;c++){\\n            if(grid[r][c]>0 && (grid[r-1][c-1]>0 )&& (grid[r-1][c]>0 )&&(grid[r-1][c+1]>0)){\\n                grid[r][c]=Math.min(grid[r-1][c-1],grid[r-1][c],grid[r-1][c+1])+1\\n                count+=(grid[r][c]-1);\\n            }\\n        }\\n    }\\n    for(let r=1;r<grid.length;r++){\\n        for(let c=1;c<grid[0].length-1;c++){\\n            if(grid[r][c]>0) grid[r][c]=1\\n        }\\n    }\\n    for(let r=grid.length-2;r>-1;r--){\\n        for(let c=1;c<grid[0].length-1;c++){\\n            if(grid[r][c]>0 && (grid[r+1][c-1]>0) && (grid[r+1][c]>0) && (grid[r+1][c+1]>0)){\\n                grid[r][c]=Math.min(grid[r+1][c-1],grid[r+1][c],grid[r+1][c+1])+1\\n                count+=(grid[r][c]-1)\\n            }\\n        }\\n    }\\n    return count;\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3518333,
                "title": "c",
                "content": "```\\nclass Solution {\\npublic:\\n    int countPyramids(vector<vector<int>>& grid) {\\n        int m = grid.size() ;\\n        int n = grid[0].size() ;\\n        vector<vector<int>>left(m, vector<int>(n)) ;\\n        vector<vector<int>>right(m, vector<int>(n)) ;\\n        vector<vector<int>>dp(m, vector<int>(n)) ;\\n        for(int i = 0; i < m; i++){\\n            int cn = 0 ;\\n            for(int j = 0; j < n; j++){\\n                if(grid[i][j] == 0)\\n                    cn = 0 ;\\n                else\\n                    cn++ ;\\n                left[i][j] = cn ;\\n            }\\n        }\\n        for(int i = 0; i < m; i++){\\n            int cn = 0 ;\\n            for(int j = n-1; j >= 0; j--){\\n                if(grid[i][j] == 0)\\n                    cn = 0 ;\\n                else\\n                    cn++ ;\\n                right[i][j] = cn ;\\n            }\\n        }\\n        int ret = 0 ;\\n        for(int i = 0; i < m ; i++){\\n            for(int j = 0; j < n; j++){\\n                if(grid[i][j] == 0){\\n                    dp[i][j] =  0 ;\\n                    continue ;\\n                }\\n                if(i == 0)\\n                    dp[i][j] = 1 ;\\n                else\\n                    dp[i][j] = min(min(left[i][j], right[i][j]) , dp[i-1][j]+1 ) ;\\n                ret += dp[i][j] - 1 ;\\n            }\\n        }\\n        //reuse dp\\n        for(int i = m-1; i >= 0 ; i--){\\n            for(int j = 0; j < n; j++){\\n                if(grid[i][j] == 0){\\n                    dp[i][j] =  0 ;\\n                    continue ;\\n                }\\n                if(i == m-1)\\n                    dp[i][j] = 1 ;\\n                else\\n                    dp[i][j] = min(min(left[i][j], right[i][j]) , dp[i+1][j]+1 ) ;\\n                ret += dp[i][j] - 1 ;\\n            }\\n        }\\n        return ret ;\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    int countPyramids(vector<vector<int>>& grid) {\\n        int m = grid.size() ;\\n        int n = grid[0].size() ;\\n        vector<vector<int>>left(m, vector<int>(n)) ;\\n        vector<vector<int>>right(m, vector<int>(n)) ;\\n        vector<vector<int>>dp(m, vector<int>(n)) ;\\n        for(int i = 0; i < m; i++){\\n            int cn = 0 ;\\n            for(int j = 0; j < n; j++){\\n                if(grid[i][j] == 0)\\n                    cn = 0 ;\\n                else\\n                    cn++ ;\\n                left[i][j] = cn ;\\n            }\\n        }\\n        for(int i = 0; i < m; i++){\\n            int cn = 0 ;\\n            for(int j = n-1; j >= 0; j--){\\n                if(grid[i][j] == 0)\\n                    cn = 0 ;\\n                else\\n                    cn++ ;\\n                right[i][j] = cn ;\\n            }\\n        }\\n        int ret = 0 ;\\n        for(int i = 0; i < m ; i++){\\n            for(int j = 0; j < n; j++){\\n                if(grid[i][j] == 0){\\n                    dp[i][j] =  0 ;\\n                    continue ;\\n                }\\n                if(i == 0)\\n                    dp[i][j] = 1 ;\\n                else\\n                    dp[i][j] = min(min(left[i][j], right[i][j]) , dp[i-1][j]+1 ) ;\\n                ret += dp[i][j] - 1 ;\\n            }\\n        }\\n        //reuse dp\\n        for(int i = m-1; i >= 0 ; i--){\\n            for(int j = 0; j < n; j++){\\n                if(grid[i][j] == 0){\\n                    dp[i][j] =  0 ;\\n                    continue ;\\n                }\\n                if(i == m-1)\\n                    dp[i][j] = 1 ;\\n                else\\n                    dp[i][j] = min(min(left[i][j], right[i][j]) , dp[i+1][j]+1 ) ;\\n                ret += dp[i][j] - 1 ;\\n            }\\n        }\\n        return ret ;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3384682,
                "title": "c-dp",
                "content": "check the hints which is best explanation for solution\\nspace can be reduced to O(n) but I keep it this way to be more clear\\n\\n```\\npublic class Solution {\\n    int[,] dp2;\\n    public int CountPyramids(int[][] grid) {\\n        int m=grid.Length;\\n        int n=grid[0].Length;\\n        int res=0;\\n        int[,] dp=new int[m,n];\\n        dp2=new int[m,n];\\n        \\n        \\n        for(int i=0;i<m;i++){\\n            for(int j=0;j<n;j++){\\n                if(i==0 || j==0 || j==n-1){\\n                    dp2[i,j]= grid[i][j];\\n                }else if(grid[i][j]==1){\\n                    dp2[i,j]=1+Math.Min(dp2[i-1,j] \\n                                     ,Math.Min(dp2[i-1,j+1] ,dp2[i-1,j-1])\\n                                    );\\n                        }\\n                \\n            }\\n        }\\n        \\n        for(int i=m-1;i>=0;i--){\\n            for(int j=0;j<n;j++){\\n                if(i==m-1 || j==0 || j==n-1){\\n                    dp[i,j]= grid[i][j];\\n                }else if(grid[i][j]==1){\\n                    dp[i,j]=1+Math.Min(dp[i+1,j] \\n                                     ,Math.Min(dp[i+1,j+1] ,dp[i+1,j-1])\\n                                    );\\n                }\\n            }\\n        }\\n\\n        for(int i=0;i<m;i++){\\n            for(int j=0;j<n;j++){\\n                res+=dp[i,j]>1 ? dp[i,j]-1 :0;\\n                res+=dp2[i,j]>1 ? dp2[i,j]-1 :0;\\n            }\\n        }\\n\\n        return res;\\n    }\\n    \\n}\\n   \\n```",
                "solutionTags": [
                    "Dynamic Programming"
                ],
                "code": "```\\npublic class Solution {\\n    int[,] dp2;\\n    public int CountPyramids(int[][] grid) {\\n        int m=grid.Length;\\n        int n=grid[0].Length;\\n        int res=0;\\n        int[,] dp=new int[m,n];\\n        dp2=new int[m,n];\\n        \\n        \\n        for(int i=0;i<m;i++){\\n            for(int j=0;j<n;j++){\\n                if(i==0 || j==0 || j==n-1){\\n                    dp2[i,j]= grid[i][j];\\n                }else if(grid[i][j]==1){\\n                    dp2[i,j]=1+Math.Min(dp2[i-1,j] \\n                                     ,Math.Min(dp2[i-1,j+1] ,dp2[i-1,j-1])\\n                                    );\\n                        }\\n                \\n            }\\n        }\\n        \\n        for(int i=m-1;i>=0;i--){\\n            for(int j=0;j<n;j++){\\n                if(i==m-1 || j==0 || j==n-1){\\n                    dp[i,j]= grid[i][j];\\n                }else if(grid[i][j]==1){\\n                    dp[i,j]=1+Math.Min(dp[i+1,j] \\n                                     ,Math.Min(dp[i+1,j+1] ,dp[i+1,j-1])\\n                                    );\\n                }\\n            }\\n        }\\n\\n        for(int i=0;i<m;i++){\\n            for(int j=0;j<n;j++){\\n                res+=dp[i,j]>1 ? dp[i,j]-1 :0;\\n                res+=dp2[i,j]>1 ? dp2[i,j]-1 :0;\\n            }\\n        }\\n\\n        return res;\\n    }\\n    \\n}\\n   \\n```",
                "codeTag": "Java"
            },
            {
                "id": 3371865,
                "title": "python-dp-97-97",
                "content": "# Intuition\\nFirst of all the direct and inverted pyramids are just the same problem, solved with direct and reversed order or rows.\\n\\n# Approach\\nThe smallest pyramind is a single cell (not counted in the result)\\nEach pyramid step sits on 3 other overlapping pyramids and can extend below as far as the shortest of those 3 pyramids below. So build a DP trying to send the pyramid height. On the very left and right sides only pyramids of height 1 is possible.\\nAs you go sum how many pyramids there were seen with height 2 or larger\\n\\n# Complexity\\n- Time complexity:\\n$$O(nRows*nCols)$$\\n\\n- Space complexity:\\n$$O(nCols)$$\\n\\n# Code\\n```\\nclass Solution:\\n    def countPyramids(self, grid: List[List[int]]) -> int:\\n        nCols = len(grid[0])\\n\\n        result = 0\\n        dp0 = [0] * nCols\\n        dp1 = [0] * nCols\\n        nCols -= 1\\n\\n        for g in (iter(grid), reversed(grid)):\\n            dp0[:] = next(g)\\n            \\n            for r in g:\\n                dp1[0] = r[0]\\n                dp1[-1] = r[-1]\\n                for ci in range(1, nCols):\\n                    if r[ci]:\\n                        dp1[ci] = 1 + min(dp0[ci - 1], dp0[ci], dp0[ci + 1])\\n                        result += dp1[ci] - 1\\n                    else:\\n                        dp1[ci] = 0\\n                dp1, dp0 = dp0, dp1\\n\\n\\n\\n        return result\\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def countPyramids(self, grid: List[List[int]]) -> int:\\n        nCols = len(grid[0])\\n\\n        result = 0\\n        dp0 = [0] * nCols\\n        dp1 = [0] * nCols\\n        nCols -= 1\\n\\n        for g in (iter(grid), reversed(grid)):\\n            dp0[:] = next(g)\\n            \\n            for r in g:\\n                dp1[0] = r[0]\\n                dp1[-1] = r[-1]\\n                for ci in range(1, nCols):\\n                    if r[ci]:\\n                        dp1[ci] = 1 + min(dp0[ci - 1], dp0[ci], dp0[ci + 1])\\n                        result += dp1[ci] - 1\\n                    else:\\n                        dp1[ci] = 0\\n                dp1, dp0 = dp0, dp1\\n\\n\\n\\n        return result\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3292324,
                "title": "python3-faster-than-100-o-m-n-time-o-n-space-no-in-place-grid-modification",
                "content": "# Intuition\\nLarger pyramids contain smaller pyramids suggesting recursion.\\n\\nThere are two key notions: \\nIf a cell hosts some pyramid then it also hosts any pyramid of smaller size. Most solutions look at the apex, while I prefer the base\\n\\nTo decide if a cell hosts a pyramid of height $H$ we need knowledge about neighbors in same row and which pyramids are hosted by cells of the previous row\\n\\nCombining these two observations we see that we can run from the top to bottom once for plain pyramids and another time back from bottom to top for inverse pyramids.\\n\\nSince we only need results of the previous row to solve the current row, we only need to store $$O(n)$$ worth of data.\\n\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\nWe want to calculate how many pyramids each cell hosts. We say a cell hosts a pyramid if there\\'s a valid pyramid with it\\'s mid-base located at the given cell. \\n\\nIf the heighest pyramid hosted has height $$H$$, then the cell hosts $$H-1$$ distinct pyramids total (height $$1$$ pyramids are single blocks and are not counted)\\n\\nTo host a pyramid of height $$H$$ a cell must have $$H-1$$ fertile cells on each side (left and right) and the cell immediately above it must host a size $$H-1$$ pyramid. Thus, we can go from top row to bottom row of grid, writing down $$H$$ for each cell in a row and storing this info to use when handling the next row.\\n\\nWe use a single row \"prev\" of data storing $H$ for the previous row, i.e. $O(n)$ memory. This could be avoided by in-place modifications, however 1) in-place modifications are uncalled for here 2) this might mess up the backwards run counting inverse pyramids\\n\\nThere is no recursion here and thus no stack memory costs\\n\\nInverse pyramids are treated similarly by inversing the scanning order. This is technically implemented within the function \"runDown2\" and controlled by a \"reverse\" argument.\\n\\nWhen working on a row we try to be as efficient as possible by hopping over cells that cannot host pyramids (e.g. if cell $i$ is infertile then the next cell that might host pyramids is $i+2$). Whenever a promising streak (i.e. $3+$ cells) of fertile cells is encountered we directly calculate its length. The memory row \"prev\" is updated with new values on the fly, cell by cell, to avoid using another row-worth of memory (though obviously $$O(n)=O(2n)$$).\\n\\nSorry for the messy code. This is my first solution submission :)\\nPartially, the mess is due to incorporating different increments in the row scan and the cell-by-cell update process for \"prev\".\\n\\n# Complexity\\n- Time complexity:\\n$$O(m*n)$$\\n\\n- Space complexity:\\n $$O(n)$$ \\n\\n# Code\\n```\\nclass Solution:\\n    def countPyramids(self, grid: List[List[int]]) -> int:\\n        m, n = len(grid), len(grid[0])\\n        def runDown2(g, reverse=False):\\n            \\'\\'\\'\\n            look for pyramids starting with top row (row 0)\\n            reverse=True commands to start from bottom and look for inverse pyramids\\n            \\'\\'\\'\\n            if reverse: prev = g[m-1].copy() #prev will be written over to store recent row data\\n            else: prev = g[0].copy()\\n            total = 0 #pyramid counter\\n            for h in range(1,m):\\n                if reverse: l = g[m-h-1].copy()\\n                else: l = g[h].copy()\\n                i = 1 #edges do not host pyramids, thus 0 and L-1 are excluded from run\\n                while i < n-1: \\n                    if l[i+1] == 0: \\n                        prev[i], prev[i+1] = l[i], 0 #update prev to the left of pointer i\\n                        if i+2 < n: prev[i+2] = l[i+2] #update prev (note edges are irrelevant)\\n                        i += 3 #barrens to the right: skip current, skip barrens, skip next\\n                    elif l[i] == 0: #barrens here: skip current, skip next\\n                        prev[i], prev[i+1] = 0, l[i+1]\\n                        i += 2 \\n                    elif l[i-1] == 0: #barrens to the left: skip current\\n                        prev[i] = l[i]\\n                        i += 1 \\n                    else: #now i-1, i, i+1 are 3 fertile in a row -- pyramid possible\\n                        first = i-1 #first fertile cell in current 3+ fertile streak\\n                        j = i+2 #pointer to seek ahead for end of fertile streak\\n                        while (j < n) and l[j]: j+=1 #while fertile and on-grid move right\\n                        last = j-1 #last fertile cell of current fertile streak\\n                        for i in range(first+1,last): #run over fertile streak\\n                            l[i] = 1 + min(i-first, last-i, prev[i]) #how many pyrs -1\\n                            prev[i] = l[i] #update prev[i], we already used its info in this run\\n                            if l[i] > 1: \\n                                total += l[i] - 1 #count pyramids buildable here\\n                        prev[last] = 1\\n                        if last+1 < n: \\n                            prev[last+1] = 0\\n                            if last+2 < n: \\n                                prev[last+2] = l[last+2]\\n                        i = last + 3 #last+1 = barren => last+3 is the first posible inner fertile\\n            return total\\n\\n        if m < 2 or n < 3: return 0 #if too shallow or too narrow for any pyramids to fit\\n        return runDown2(grid) + runDown2(grid, reverse = True)\\n             \\n                    \\n\\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def countPyramids(self, grid: List[List[int]]) -> int:\\n        m, n = len(grid), len(grid[0])\\n        def runDown2(g, reverse=False):\\n            \\'\\'\\'\\n            look for pyramids starting with top row (row 0)\\n            reverse=True commands to start from bottom and look for inverse pyramids\\n            \\'\\'\\'\\n            if reverse: prev = g[m-1].copy() #prev will be written over to store recent row data\\n            else: prev = g[0].copy()\\n            total = 0 #pyramid counter\\n            for h in range(1,m):\\n                if reverse: l = g[m-h-1].copy()\\n                else: l = g[h].copy()\\n                i = 1 #edges do not host pyramids, thus 0 and L-1 are excluded from run\\n                while i < n-1: \\n                    if l[i+1] == 0: \\n                        prev[i], prev[i+1] = l[i], 0 #update prev to the left of pointer i\\n                        if i+2 < n: prev[i+2] = l[i+2] #update prev (note edges are irrelevant)\\n                        i += 3 #barrens to the right: skip current, skip barrens, skip next\\n                    elif l[i] == 0: #barrens here: skip current, skip next\\n                        prev[i], prev[i+1] = 0, l[i+1]\\n                        i += 2 \\n                    elif l[i-1] == 0: #barrens to the left: skip current\\n                        prev[i] = l[i]\\n                        i += 1 \\n                    else: #now i-1, i, i+1 are 3 fertile in a row -- pyramid possible\\n                        first = i-1 #first fertile cell in current 3+ fertile streak\\n                        j = i+2 #pointer to seek ahead for end of fertile streak\\n                        while (j < n) and l[j]: j+=1 #while fertile and on-grid move right\\n                        last = j-1 #last fertile cell of current fertile streak\\n                        for i in range(first+1,last): #run over fertile streak\\n                            l[i] = 1 + min(i-first, last-i, prev[i]) #how many pyrs -1\\n                            prev[i] = l[i] #update prev[i], we already used its info in this run\\n                            if l[i] > 1: \\n                                total += l[i] - 1 #count pyramids buildable here\\n                        prev[last] = 1\\n                        if last+1 < n: \\n                            prev[last+1] = 0\\n                            if last+2 < n: \\n                                prev[last+2] = l[last+2]\\n                        i = last + 3 #last+1 = barren => last+3 is the first posible inner fertile\\n            return total\\n\\n        if m < 2 or n < 3: return 0 #if too shallow or too narrow for any pyramids to fit\\n        return runDown2(grid) + runDown2(grid, reverse = True)\\n             \\n                    \\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3198608,
                "title": "python-simple-dp",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution:\\n    def countPyramids(self, grid):\\n        m, n, total = len(grid), len(grid[0]), 0\\n\\n        @lru_cache(None)\\n        def dfs(i,j,df):\\n            if grid[i][j] == 1 and 0 <= i + df < m and j > 0 and j + 1 < n and grid[i+df][j] == 1:\\n                return min(dfs(i+df,j-1,df),dfs(i+df,j+1,df)) + 1\\n            return grid[i][j]\\n\\n        for i in range(m):\\n            for j in range(n):\\n                total += max(0,dfs(i,j,1)-1)\\n                total += max(0,dfs(i,j,-1)-1)\\n\\n        return total\\n\\n\\n\\n        \\n\\n\\n\\n        \\n        \\n        \\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def countPyramids(self, grid):\\n        m, n, total = len(grid), len(grid[0]), 0\\n\\n        @lru_cache(None)\\n        def dfs(i,j,df):\\n            if grid[i][j] == 1 and 0 <= i + df < m and j > 0 and j + 1 < n and grid[i+df][j] == 1:\\n                return min(dfs(i+df,j-1,df),dfs(i+df,j+1,df)) + 1\\n            return grid[i][j]\\n\\n        for i in range(m):\\n            for j in range(n):\\n                total += max(0,dfs(i,j,1)-1)\\n                total += max(0,dfs(i,j,-1)-1)\\n\\n        return total\\n\\n\\n\\n        \\n\\n\\n\\n        \\n        \\n        \\n```",
                "codeTag": "Java"
            },
            {
                "id": 3148806,
                "title": "easy-c-solution-using-constructive-grid",
                "content": "```\\nclass Solution {\\npublic:\\n    int countPyramids(vector<vector<int>>& g1) {\\n        vector<vector<int>> g2=g1;\\n        for(int i=g1.size()-1;i>0;i--)\\n        {\\n            for(int j=1;j<g1[0].size()-1;j++)\\n            {\\n                if(g1[i][j]>=1 && g1[i][j-1] && g1[i][j+1] && g1[i-1][j])\\n                    g1[i-1][j]+=min({g1[i][j],g1[i][j-1],g1[i][j+1]});\\n            }\\n        }\\n        int s=0;\\n        for(auto t: g1)\\n            for(auto tt: t)\\n                if(tt>1)\\n                    s+=tt-1;\\n        g1=g2;\\n        for(int i=0;i<g1.size()-1;i++)\\n        {\\n            for(int j=1;j<g1[0].size()-1;j++)\\n            {\\n                if(g1[i][j]>=1 && g1[i][j-1] && g1[i][j+1] && g1[i+1][j])\\n                    g1[i+1][j]+=min({g1[i][j],g1[i][j-1],g1[i][j+1]});\\n            }\\n        }\\n        for(auto t: g1)\\n            for(auto tt: t)\\n                if(tt>1)\\n                    s+=tt-1;\\n        return s;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int countPyramids(vector<vector<int>>& g1) {\\n        vector<vector<int>> g2=g1;\\n        for(int i=g1.size()-1;i>0;i--)\\n        {\\n            for(int j=1;j<g1[0].size()-1;j++)\\n            {\\n                if(g1[i][j]>=1 && g1[i][j-1] && g1[i][j+1] && g1[i-1][j])\\n                    g1[i-1][j]+=min({g1[i][j],g1[i][j-1],g1[i][j+1]});\\n            }\\n        }\\n        int s=0;\\n        for(auto t: g1)\\n            for(auto tt: t)\\n                if(tt>1)\\n                    s+=tt-1;\\n        g1=g2;\\n        for(int i=0;i<g1.size()-1;i++)\\n        {\\n            for(int j=1;j<g1[0].size()-1;j++)\\n            {\\n                if(g1[i][j]>=1 && g1[i][j-1] && g1[i][j+1] && g1[i+1][j])\\n                    g1[i+1][j]+=min({g1[i][j],g1[i][j-1],g1[i][j+1]});\\n            }\\n        }\\n        for(auto t: g1)\\n            for(auto tt: t)\\n                if(tt>1)\\n                    s+=tt-1;\\n        return s;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3131526,
                "title": "simple-dp-stuff-o-m-n",
                "content": "\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int n , m;\\n    int ans;\\n\\n    void count(vector<vector<int>> &grid) {\\n        vector<vector<int>> dup(n,vector<int>(m,0));\\n        // counting simple pyramids\\n        for(int i=n-1;i>=0;i--) {\\n            for(int j=0;j<m;j++) {\\n                if(grid[i][j] == 1) {\\n                    if(i+1 < n) {\\n                        if(j-1 < 0 || j+1 == m) dup[i][j] = 1;\\n                        else {\\n                            dup[i][j] = min({dup[i+1][j],dup[i+1][j-1],dup[i+1][j+1]}) + 1;\\n                            if(dup[i][j] > 1) ans += dup[i][j]-1;\\n                        }\\n                    }\\n                    else dup[i][j] = 1;\\n                }\\n                else dup[i][j] = 0;\\n            }\\n        }\\n        // counting inverse pyramids\\n        for(int i=0;i<n;i++) {\\n            for(int j=0;j<m;j++) {\\n                if(grid[i][j] == 1) {\\n                    if(i-1 >= 0) {\\n                        if(j-1 < 0 || j+1 == m) dup[i][j] = 1;\\n                        else {\\n                            dup[i][j] = min({dup[i-1][j],dup[i-1][j-1],dup[i-1][j+1]}) + 1;\\n                            if(dup[i][j] > 1) ans += dup[i][j]-1;\\n                        }\\n                    }\\n                    else dup[i][j] = 1;\\n                }\\n                else dup[i][j] = 0;\\n            }\\n        }\\n        \\n    }\\n    int countPyramids(vector<vector<int>>& grid) {\\n        n = grid.size();\\n        m = grid[0].size();\\n        // int ans = 0;\\n\\n        count(grid);\\n\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int n , m;\\n    int ans;\\n\\n    void count(vector<vector<int>> &grid) {\\n        vector<vector<int>> dup(n,vector<int>(m,0));\\n        // counting simple pyramids\\n        for(int i=n-1;i>=0;i--) {\\n            for(int j=0;j<m;j++) {\\n                if(grid[i][j] == 1) {\\n                    if(i+1 < n) {\\n                        if(j-1 < 0 || j+1 == m) dup[i][j] = 1;\\n                        else {\\n                            dup[i][j] = min({dup[i+1][j],dup[i+1][j-1],dup[i+1][j+1]}) + 1;\\n                            if(dup[i][j] > 1) ans += dup[i][j]-1;\\n                        }\\n                    }\\n                    else dup[i][j] = 1;\\n                }\\n                else dup[i][j] = 0;\\n            }\\n        }\\n        // counting inverse pyramids\\n        for(int i=0;i<n;i++) {\\n            for(int j=0;j<m;j++) {\\n                if(grid[i][j] == 1) {\\n                    if(i-1 >= 0) {\\n                        if(j-1 < 0 || j+1 == m) dup[i][j] = 1;\\n                        else {\\n                            dup[i][j] = min({dup[i-1][j],dup[i-1][j-1],dup[i-1][j+1]}) + 1;\\n                            if(dup[i][j] > 1) ans += dup[i][j]-1;\\n                        }\\n                    }\\n                    else dup[i][j] = 1;\\n                }\\n                else dup[i][j] = 0;\\n            }\\n        }\\n        \\n    }\\n    int countPyramids(vector<vector<int>>& grid) {\\n        n = grid.size();\\n        m = grid[0].size();\\n        // int ans = 0;\\n\\n        count(grid);\\n\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3040786,
                "title": "2-times-dp-c-simple-clean-short-fast",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    #define ll long long\\n    ll dp1[1001][1001],dp2[1001][1001];\\n\\n    bool issafe(ll x,ll y,ll n,ll m,vector<vector<int>>&grid){\\n        return x<0 || y<0 || x>=n || y>=m || grid[x][y]==0;\\n    }\\n\\n    ll solve1(vector<vector<int>>&grid,ll i,ll j,ll n,ll m){\\n        if(issafe(i,j,n,m,grid)){\\n            return 0;\\n        }\\n        if(dp1[i][j]!=-1){\\n            return dp1[i][j];\\n        }\\n        ll answer,temp1,temp2,temp3;\\n        temp1=solve1(grid,i+1,j-1,n,m),temp2=solve1(grid,i+1,j,n,m),temp3=solve1(grid,i+1,j+1,n,m);\\n        answer=1+min({temp1,temp2,temp3});\\n        return dp1[i][j]=answer;\\n    }\\n\\n    ll solve2(vector<vector<int>>&grid,ll i,ll j,ll n,ll m){\\n        if(issafe(i,j,n,m,grid)){\\n            return 0;\\n        }\\n        if(dp2[i][j]!=-1){\\n            return dp2[i][j];\\n        }\\n        ll answer,temp1,temp2,temp3;\\n        temp1=solve2(grid,i-1,j-1,n,m),temp2=solve2(grid,i-1,j,n,m),temp3=solve2(grid,i-1,j+1,n,m);\\n        answer=1+min({temp1,temp2,temp3});\\n        return dp2[i][j]=answer;\\n    }\\n\\n    int countPyramids(vector<vector<int>>& grid) {\\n        ll n=grid.size(),m=grid[0].size(),answer=0;\\n        memset(dp1,-1,sizeof(dp1));memset(dp2,-1,sizeof(dp2));\\n        for(ll i=0;i<n;i++){\\n            for(ll j=0;j<m;j++){\\n                if(grid[i][j]==1){\\n                    answer+=solve1(grid,i,j,n,m)-1;\\n                }\\n            }\\n        }\\n        for(ll i=0;i<n;i++){\\n            for(ll j=0;j<m;j++){\\n                if(grid[i][j]==1){\\n                    answer+=solve2(grid,i,j,n,m)-1;\\n                }\\n            }\\n        }\\n        return answer;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Dynamic Programming",
                    "Matrix"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    #define ll long long\\n    ll dp1[1001][1001],dp2[1001][1001];\\n\\n    bool issafe(ll x,ll y,ll n,ll m,vector<vector<int>>&grid){\\n        return x<0 || y<0 || x>=n || y>=m || grid[x][y]==0;\\n    }\\n\\n    ll solve1(vector<vector<int>>&grid,ll i,ll j,ll n,ll m){\\n        if(issafe(i,j,n,m,grid)){\\n            return 0;\\n        }\\n        if(dp1[i][j]!=-1){\\n            return dp1[i][j];\\n        }\\n        ll answer,temp1,temp2,temp3;\\n        temp1=solve1(grid,i+1,j-1,n,m),temp2=solve1(grid,i+1,j,n,m),temp3=solve1(grid,i+1,j+1,n,m);\\n        answer=1+min({temp1,temp2,temp3});\\n        return dp1[i][j]=answer;\\n    }\\n\\n    ll solve2(vector<vector<int>>&grid,ll i,ll j,ll n,ll m){\\n        if(issafe(i,j,n,m,grid)){\\n            return 0;\\n        }\\n        if(dp2[i][j]!=-1){\\n            return dp2[i][j];\\n        }\\n        ll answer,temp1,temp2,temp3;\\n        temp1=solve2(grid,i-1,j-1,n,m),temp2=solve2(grid,i-1,j,n,m),temp3=solve2(grid,i-1,j+1,n,m);\\n        answer=1+min({temp1,temp2,temp3});\\n        return dp2[i][j]=answer;\\n    }\\n\\n    int countPyramids(vector<vector<int>>& grid) {\\n        ll n=grid.size(),m=grid[0].size(),answer=0;\\n        memset(dp1,-1,sizeof(dp1));memset(dp2,-1,sizeof(dp2));\\n        for(ll i=0;i<n;i++){\\n            for(ll j=0;j<m;j++){\\n                if(grid[i][j]==1){\\n                    answer+=solve1(grid,i,j,n,m)-1;\\n                }\\n            }\\n        }\\n        for(ll i=0;i<n;i++){\\n            for(ll j=0;j<m;j++){\\n                if(grid[i][j]==1){\\n                    answer+=solve2(grid,i,j,n,m)-1;\\n                }\\n            }\\n        }\\n        return answer;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2940600,
                "title": "c-easy-to-understand-code",
                "content": "```\\nclass Solution {\\npublic:\\n    int countPyramids(vector<vector<int>>& grid) {\\n        int r = grid.size();\\n        int c = grid[0].size();\\n        vector<int> prev(c,0);\\n        vector<int> cur(c,0);\\n        int result = 0;\\n        // Assume each cell as apex and check how much it can increase the hieght of new apxex\\n        // a new apex will be apex if its 3 children beneath are apex\\n        for (int i = r-2; i >= 0; i--) {\\n            for (int j = 1; j < c-1; j++) {\\n                cur[j] = 0;\\n                if (grid[i][j]) {\\n                    if (grid[i+1][j-1] && grid[i+1][j] && grid[i+1][j+1])\\n                        cur[j] = 1 + min({prev[j-1], prev[j], prev[j+1]});\\n                        result += cur[j];\\n                }\\n            }\\n            swap(prev,cur);\\n        }\\n        fill(begin(prev),end(prev),0);\\n        // iterate it reverse for reverse pyramid\\n        for (int i = 1; i < r; i++) {\\n            for (int j = 1; j < c-1; j++) {\\n                cur[j] = 0;\\n                if (grid[i][j]) {\\n                    if (grid[i-1][j-1] && grid[i-1][j] && grid[i-1][j+1])\\n                        cur[j] = 1 + min({prev[j-1], prev[j], prev[j+1]});\\n                        result += cur[j];\\n                }\\n            }\\n            swap(prev,cur);\\n        }\\n        return result;\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    int countPyramids(vector<vector<int>>& grid) {\\n        int r = grid.size();\\n        int c = grid[0].size();\\n        vector<int> prev(c,0);\\n        vector<int> cur(c,0);\\n        int result = 0;\\n        // Assume each cell as apex and check how much it can increase the hieght of new apxex\\n        // a new apex will be apex if its 3 children beneath are apex\\n        for (int i = r-2; i >= 0; i--) {\\n            for (int j = 1; j < c-1; j++) {\\n                cur[j] = 0;\\n                if (grid[i][j]) {\\n                    if (grid[i+1][j-1] && grid[i+1][j] && grid[i+1][j+1])\\n                        cur[j] = 1 + min({prev[j-1], prev[j], prev[j+1]});\\n                        result += cur[j];\\n                }\\n            }\\n            swap(prev,cur);\\n        }\\n        fill(begin(prev),end(prev),0);\\n        // iterate it reverse for reverse pyramid\\n        for (int i = 1; i < r; i++) {\\n            for (int j = 1; j < c-1; j++) {\\n                cur[j] = 0;\\n                if (grid[i][j]) {\\n                    if (grid[i-1][j-1] && grid[i-1][j] && grid[i-1][j+1])\\n                        cur[j] = 1 + min({prev[j-1], prev[j], prev[j+1]});\\n                        result += cur[j];\\n                }\\n            }\\n            swap(prev,cur);\\n        }\\n        return result;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2904506,
                "title": "c-normal-array-operation-code",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nEach cell marked as \"1\" can be the top of the pyramid / bottom of the inverted pyramid.\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\nAs long as the next cell at the diagonal position has >= 1s to be the next row of the pyramid, (1 -> 3 -> 5 -> 7...) +1 to the total count. No need to consider the sub-pyramids as each cell has the chance to become the top / bottom point of the pyramid / inverted pyramid.\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\nO(N^3), looks bad, but not exactly N^3...\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\nO(1)\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int C[2][1004][1004];\\n    int countPyramids(vector<vector<int>>& grid) {\\n        int m = grid.size();\\n        int n = grid[0].size();\\n        for (int i = 0; i < m; i++) {\\n            for (int j = 0; j < n; j++) {\\n                if (grid[i][j] == 1)\\n                    C[0][i + 1][j + 1] = C[0][i + 1][j] + grid[i][j];\\n            }\\n            for (int j = n - 1; j >= 0; j--) {\\n                if (grid[i][j] == 1)\\n                    C[1][i + 1][j + 1] = C[1][i + 1][j + 2] + grid[i][j];\\n            }\\n        }\\n        int res = 0;\\n        for (int i = 1; i <= m; i++) {\\n            for (int j = 1; j <= n; j++) {\\n                if (C[0][i][j] > 0) {\\n                    int cur = 3;\\n                    int k = i + 1;\\n                    int l = j + 1;\\n                    int tmp;\\n                    while (k <= m && l <= n) {\\n                        tmp = C[0][k][l];\\n                        if ((tmp & 1) == 0) {\\n                            tmp--;\\n                        } \\n                        if (tmp < cur)\\n                            break;\\n                        res++;\\n                        cur += 2;\\n                        k++;\\n                        l++;\\n                    }\\n                }\\n                if (C[1][i][j] > 0) {\\n                    int cur = 3;\\n                    int k = i - 1;\\n                    int l = j - 1;\\n                    int tmp;\\n                    while (k >= 1 && l >= 1) {\\n                        tmp = C[1][k][l];\\n                        if ((tmp & 1) == 0) {\\n                            tmp--;\\n                        } \\n                        if (tmp < cur)\\n                            break;\\n                        res++;\\n                        cur += 2;\\n                        k--;\\n                        l--;\\n                    }\\n                }\\n            }\\n        }\\n        return res;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int C[2][1004][1004];\\n    int countPyramids(vector<vector<int>>& grid) {\\n        int m = grid.size();\\n        int n = grid[0].size();\\n        for (int i = 0; i < m; i++) {\\n            for (int j = 0; j < n; j++) {\\n                if (grid[i][j] == 1)\\n                    C[0][i + 1][j + 1] = C[0][i + 1][j] + grid[i][j];\\n            }\\n            for (int j = n - 1; j >= 0; j--) {\\n                if (grid[i][j] == 1)\\n                    C[1][i + 1][j + 1] = C[1][i + 1][j + 2] + grid[i][j];\\n            }\\n        }\\n        int res = 0;\\n        for (int i = 1; i <= m; i++) {\\n            for (int j = 1; j <= n; j++) {\\n                if (C[0][i][j] > 0) {\\n                    int cur = 3;\\n                    int k = i + 1;\\n                    int l = j + 1;\\n                    int tmp;\\n                    while (k <= m && l <= n) {\\n                        tmp = C[0][k][l];\\n                        if ((tmp & 1) == 0) {\\n                            tmp--;\\n                        } \\n                        if (tmp < cur)\\n                            break;\\n                        res++;\\n                        cur += 2;\\n                        k++;\\n                        l++;\\n                    }\\n                }\\n                if (C[1][i][j] > 0) {\\n                    int cur = 3;\\n                    int k = i - 1;\\n                    int l = j - 1;\\n                    int tmp;\\n                    while (k >= 1 && l >= 1) {\\n                        tmp = C[1][k][l];\\n                        if ((tmp & 1) == 0) {\\n                            tmp--;\\n                        } \\n                        if (tmp < cur)\\n                            break;\\n                        res++;\\n                        cur += 2;\\n                        k--;\\n                        l--;\\n                    }\\n                }\\n            }\\n        }\\n        return res;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2891679,
                "title": "python3-beats-90-short-solution",
                "content": "# Code\\n```\\nclass Solution:\\n    def countPyramids(self, G):\\n        m, n, ans = len(G), len(G[0]), 0\\n        \\n        @lru_cache(None)\\n        def dp(i, j, dr):\\n            if G[i][j] == 1 and 0 <= i + dr < m and j > 0 and j + 1 < n and G[i+dr][j] == 1:\\n                return min(dp(i+dr, j-1, dr), dp(i+dr, j+1, dr)) + 1\\n            return G[i][j]\\n        \\n        for i, j in product(range(m), range(n)):\\n            ans += max(0, dp(i, j, 1) - 1)\\n            ans += max(0, dp(i, j, -1) - 1)\\n        \\n        return ans\\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def countPyramids(self, G):\\n        m, n, ans = len(G), len(G[0]), 0\\n        \\n        @lru_cache(None)\\n        def dp(i, j, dr):\\n            if G[i][j] == 1 and 0 <= i + dr < m and j > 0 and j + 1 < n and G[i+dr][j] == 1:\\n                return min(dp(i+dr, j-1, dr), dp(i+dr, j+1, dr)) + 1\\n            return G[i][j]\\n        \\n        for i, j in product(range(m), range(n)):\\n            ans += max(0, dp(i, j, 1) - 1)\\n            ans += max(0, dp(i, j, -1) - 1)\\n        \\n        return ans\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2889955,
                "title": "2-python-approach-brute-force-to-most-optimized-solution",
                "content": "\\tclass Solution:\\n\\t\\tdef countPyramids(self, grid: List[List[int]]) -> int:\\n\\t\\t\\t#Simple Idea one - Brute Force\\n\\t\\t\\t#This will give us tle sometime and sometimes passes\\n\\t\\t\\t#F-LC\\n\\t\\t\\t\"\"\"\\n\\t\\t\\tn = len(grid)\\n\\t\\t\\tm = len(grid[0])\\n\\t\\t\\tprefix = [[0 for _ in range(m+1)] for i in range(n+1)]\\n\\t\\t\\tfor i in range(1,n+1):\\n\\t\\t\\t\\tfor j in range(1,m+1):\\n\\t\\t\\t\\t\\tprefix[i][j] = grid[i-1][j-1]+prefix[i][j-1]\\n\\t\\t\\tans = 0\\n\\t\\t\\tfor i in range(n):\\n\\t\\t\\t\\tfor j in range(m):\\n\\t\\t\\t\\t\\tx = i\\n\\t\\t\\t\\t\\ty1 = j\\n\\t\\t\\t\\t\\ty2 = j\\n\\t\\t\\t\\t\\tcnt = 1\\n\\t\\t\\t\\t\\twhile x<n and y1>=0 and y2<m:\\n\\t\\t\\t\\t\\t\\tval = prefix[x+1][y2+1] - prefix[x+1][y1]\\n\\t\\t\\t\\t\\t\\tif val==cnt:\\n\\t\\t\\t\\t\\t\\t\\tif cnt>1: ans+=1\\n\\t\\t\\t\\t\\t\\t\\tcnt+=2\\n\\t\\t\\t\\t\\t\\telse:\\n\\t\\t\\t\\t\\t\\t\\tbreak\\n\\t\\t\\t\\t\\t\\tx+=1\\n\\t\\t\\t\\t\\t\\ty1-=1\\n\\t\\t\\t\\t\\t\\ty2+=1\\n\\n\\t\\t\\tfor i in range(n):\\n\\t\\t\\t\\tfor j in range(m):\\n\\t\\t\\t\\t\\tx = i\\n\\t\\t\\t\\t\\ty1 = j\\n\\t\\t\\t\\t\\ty2 = j\\n\\t\\t\\t\\t\\tcnt = 1\\n\\t\\t\\t\\t\\twhile x>=0 and y1>=0 and y2<m:\\n\\t\\t\\t\\t\\t\\tval = prefix[x+1][y2+1] - prefix[x+1][y1]\\n\\t\\t\\t\\t\\t\\tif val==cnt:\\n\\t\\t\\t\\t\\t\\t\\tif cnt>1: ans+=1\\n\\t\\t\\t\\t\\t\\t\\tcnt+=2\\n\\t\\t\\t\\t\\t\\telse:\\n\\t\\t\\t\\t\\t\\t\\tbreak\\n\\t\\t\\t\\t\\t\\tx-=1\\n\\t\\t\\t\\t\\t\\ty1-=1\\n\\t\\t\\t\\t\\t\\ty2+=1\\n\\t\\t\\treturn ans\\n\\t\\t\\t\"\"\"\\n\\t\\t\\t#Here we are using dp concept\\n\\t\\t\\t#It is like a pyramid question\\n\\t\\t\\t#0 0 1 0 0\\n\\t\\t\\t#0 1 1 1 0\\n\\t\\t\\t#1 1 1 1 1\\n\\t\\t\\t#If we take idea of this example then we can get our answer easily\\n\\t\\t\\t#First we are processing from the last row and checking all four directions such as \\n\\t\\t\\t#down left, down ,down right and own\\n\\t\\t\\t#Same idea for the inverse\\n\\n\\t\\t\\tdef findPyramids(mat):\\n\\t\\t\\t\\trows,cols = len(mat),len(mat[0])\\n\\t\\t\\t\\tres = 0\\n\\t\\t\\t\\tfor r in range(rows-2,-1,-1):\\n\\t\\t\\t\\t\\tfor c in range(1,cols-1):\\n\\t\\t\\t\\t\\t\\tif mat[r][c] and mat[r+1][c] and mat[r+1][c-1] and mat[r+1][c+1] :\\n\\t\\t\\t\\t\\t\\t\\tmat[r][c] = min(mat[r+1][c-1],mat[r+1][c],mat[r+1][c+1]) + 1\\n\\t\\t\\t\\t\\t\\t\\tres += (mat[r][c] - 1)\\n\\t\\t\\t\\treturn res\\n\\n\\n\\t\\t\\treverseGrid = []\\n\\t\\t\\tfor i in range(len(grid)-1,-1,-1) :\\n\\t\\t\\t\\treverseGrid.append(list(grid[i]))\\n\\t\\t\\tres = findPyramids(grid)\\n\\t\\t\\tres += findPyramids(reverseGrid)\\n\\t\\t\\treturn res",
                "solutionTags": [
                    "Java",
                    "Python",
                    "Python3",
                    "C",
                    "Dynamic Programming",
                    "Prefix Sum"
                ],
                "code": "\\tclass Solution:\\n\\t\\tdef countPyramids(self, grid: List[List[int]]) -> int:\\n\\t\\t\\t#Simple Idea one - Brute Force\\n\\t\\t\\t#This will give us tle sometime and sometimes passes\\n\\t\\t\\t#F-LC\\n\\t\\t\\t\"\"\"\\n\\t\\t\\tn = len(grid)\\n\\t\\t\\tm = len(grid[0])\\n\\t\\t\\tprefix = [[0 for _ in range(m+1)] for i in range(n+1)]\\n\\t\\t\\tfor i in range(1,n+1):\\n\\t\\t\\t\\tfor j in range(1,m+1):\\n\\t\\t\\t\\t\\tprefix[i][j] = grid[i-1][j-1]+prefix[i][j-1]\\n\\t\\t\\tans = 0\\n\\t\\t\\tfor i in range(n):\\n\\t\\t\\t\\tfor j in range(m):\\n\\t\\t\\t\\t\\tx = i\\n\\t\\t\\t\\t\\ty1 = j\\n\\t\\t\\t\\t\\ty2 = j\\n\\t\\t\\t\\t\\tcnt = 1\\n\\t\\t\\t\\t\\twhile x<n and y1>=0 and y2<m:\\n\\t\\t\\t\\t\\t\\tval = prefix[x+1][y2+1] - prefix[x+1][y1]\\n\\t\\t\\t\\t\\t\\tif val==cnt:\\n\\t\\t\\t\\t\\t\\t\\tif cnt>1: ans+=1\\n\\t\\t\\t\\t\\t\\t\\tcnt+=2\\n\\t\\t\\t\\t\\t\\telse:\\n\\t\\t\\t\\t\\t\\t\\tbreak\\n\\t\\t\\t\\t\\t\\tx+=1\\n\\t\\t\\t\\t\\t\\ty1-=1\\n\\t\\t\\t\\t\\t\\ty2+=1\\n\\n\\t\\t\\tfor i in range(n):\\n\\t\\t\\t\\tfor j in range(m):\\n\\t\\t\\t\\t\\tx = i\\n\\t\\t\\t\\t\\ty1 = j\\n\\t\\t\\t\\t\\ty2 = j\\n\\t\\t\\t\\t\\tcnt = 1\\n\\t\\t\\t\\t\\twhile x>=0 and y1>=0 and y2<m:\\n\\t\\t\\t\\t\\t\\tval = prefix[x+1][y2+1] - prefix[x+1][y1]\\n\\t\\t\\t\\t\\t\\tif val==cnt:\\n\\t\\t\\t\\t\\t\\t\\tif cnt>1: ans+=1\\n\\t\\t\\t\\t\\t\\t\\tcnt+=2\\n\\t\\t\\t\\t\\t\\telse:\\n\\t\\t\\t\\t\\t\\t\\tbreak\\n\\t\\t\\t\\t\\t\\tx-=1\\n\\t\\t\\t\\t\\t\\ty1-=1\\n\\t\\t\\t\\t\\t\\ty2+=1\\n\\t\\t\\treturn ans\\n\\t\\t\\t\"\"\"\\n\\t\\t\\t#Here we are using dp concept\\n\\t\\t\\t#It is like a pyramid question\\n\\t\\t\\t#0 0 1 0 0\\n\\t\\t\\t#0 1 1 1 0\\n\\t\\t\\t#1 1 1 1 1\\n\\t\\t\\t#If we take idea of this example then we can get our answer easily\\n\\t\\t\\t#First we are processing from the last row and checking all four directions such as \\n\\t\\t\\t#down left, down ,down right and own\\n\\t\\t\\t#Same idea for the inverse\\n\\n\\t\\t\\tdef findPyramids(mat):\\n\\t\\t\\t\\trows,cols = len(mat),len(mat[0])\\n\\t\\t\\t\\tres = 0\\n\\t\\t\\t\\tfor r in range(rows-2,-1,-1):\\n\\t\\t\\t\\t\\tfor c in range(1,cols-1):\\n\\t\\t\\t\\t\\t\\tif mat[r][c] and mat[r+1][c] and mat[r+1][c-1] and mat[r+1][c+1] :\\n\\t\\t\\t\\t\\t\\t\\tmat[r][c] = min(mat[r+1][c-1],mat[r+1][c],mat[r+1][c+1]) + 1\\n\\t\\t\\t\\t\\t\\t\\tres += (mat[r][c] - 1)\\n\\t\\t\\t\\treturn res\\n\\n\\n\\t\\t\\treverseGrid = []\\n\\t\\t\\tfor i in range(len(grid)-1,-1,-1) :\\n\\t\\t\\t\\treverseGrid.append(list(grid[i]))\\n\\t\\t\\tres = findPyramids(grid)\\n\\t\\t\\tres += findPyramids(reverseGrid)\\n\\t\\t\\treturn res",
                "codeTag": "Java"
            },
            {
                "id": 2828716,
                "title": "javascript-dp",
                "content": "```\\n/**\\n * @param {number[][]} grid\\n * @return {number}\\n */\\nvar countPyramids = function (grid) {\\n  const n = grid.length;\\n  const m = grid[0].length;\\n  const copy = grid.map((row) => row.slice());\\n  let ans = 0;\\n\\n  for (let i = 0; i < n; i++) {\\n    for (let j = 0; j < m; j++) {\\n      ans += Math.max(0, helper(i, j, n, m, grid, 1) - 1);\\n      ans += Math.max(0, helper(i, j, n, m, copy, -1) - 1);\\n    }\\n  }\\n\\n  return ans;\\n};\\n\\nfunction helper(i, j, n, m, matrix, dir) {\\n  if (\\n    matrix[i][j] === 1 &&\\n    i + dir >= 0 &&\\n    i + dir < n &&\\n    matrix[i + dir][j] > 0 &&\\n    j - 1 >= 0 &&\\n    j + 1 < m\\n  ) {\\n    const left = helper(i + dir, j - 1, n, m, matrix, dir);\\n    const right = helper(i + dir, j + 1, n, m, matrix, dir);\\n\\n    return (matrix[i][j] = Math.min(left, right) + 1);\\n  }\\n\\n  return matrix[i][j];\\n}\\n```",
                "solutionTags": [
                    "Dynamic Programming"
                ],
                "code": "```\\n/**\\n * @param {number[][]} grid\\n * @return {number}\\n */\\nvar countPyramids = function (grid) {\\n  const n = grid.length;\\n  const m = grid[0].length;\\n  const copy = grid.map((row) => row.slice());\\n  let ans = 0;\\n\\n  for (let i = 0; i < n; i++) {\\n    for (let j = 0; j < m; j++) {\\n      ans += Math.max(0, helper(i, j, n, m, grid, 1) - 1);\\n      ans += Math.max(0, helper(i, j, n, m, copy, -1) - 1);\\n    }\\n  }\\n\\n  return ans;\\n};\\n\\nfunction helper(i, j, n, m, matrix, dir) {\\n  if (\\n    matrix[i][j] === 1 &&\\n    i + dir >= 0 &&\\n    i + dir < n &&\\n    matrix[i + dir][j] > 0 &&\\n    j - 1 >= 0 &&\\n    j + 1 < m\\n  ) {\\n    const left = helper(i + dir, j - 1, n, m, matrix, dir);\\n    const right = helper(i + dir, j + 1, n, m, matrix, dir);\\n\\n    return (matrix[i][j] = Math.min(left, right) + 1);\\n  }\\n\\n  return matrix[i][j];\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2806342,
                "title": "c-dp-easy-to-understand",
                "content": "```\\nclass Solution {\\npublic:\\n    int count(vector<vector<int>> grid)\\n    {\\n        int m=grid.size(),n=grid[0].size(),ans=0;\\n        for(int i=1;i<m;i++)\\n        {\\n            for(int j=1;j<n-1;j++)\\n            {\\n                if(grid[i][j]&&grid[i-1][j])\\n                {\\n                    grid[i][j]=min(grid[i-1][j-1],grid[i-1][j+1])+1;\\n                    ans+=grid[i][j]-1;\\n                }\\n            }\\n        }\\n        return ans;\\n    }\\n    int countPyramids(vector<vector<int>>& grid)\\n    {\\n        int ans=0;\\n        ans=count(grid); //for inverse\\n        reverse(grid.begin(),grid.end());\\n        ans+=count(grid);//for normal pyramid\\n        return ans;\\n        \\n    }\\n};\\n//if you like the solution plz upvote.",
                "solutionTags": [
                    "C"
                ],
                "code": "class Solution {\\npublic:\\n    int count(vector<vector<int>> grid)\\n    {\\n        int m=grid.size(),n=grid[0].size(),ans=0;\\n        for(int i=1;i<m;i++)\\n        {\\n            for(int j=1;j<n-1;j++)\\n            {\\n                if(grid[i][j]&&grid[i-1][j])\\n                {\\n                    grid[i][j]=min(grid[i-1][j-1],grid[i-1][j+1])+1;\\n                    ans+=grid[i][j]-1;\\n                }",
                "codeTag": "Java"
            },
            {
                "id": 2782763,
                "title": "c-solution",
                "content": "```\\nclass Solution {\\npublic:\\n    int countPyramids(vector<vector<int>>& grid) {\\n        int res = 0;\\n        for(int i = grid.size() - 2; i >= 0; i--){\\n            for(int j = 1; j < grid[0].size() - 1; j++){\\n                if(grid[i][j]){\\n                    grid[i][j] = min(grid[i+1][j-1],min(grid[i+1][j],grid[i+1][j+1])) + 1;\\n                }\\n            }\\n        }\\n        \\n        for(int i = 0; i <= grid.size() - 1; i++){\\n            for(int j = 1; j < grid[0].size() - 1; j++){\\n                if(grid[i][j]){\\n                    res += (grid[i][j] - 1);\\n                    grid[i][j] = 1;\\n                }\\n            }\\n        }\\n        \\n        for(int i = 1; i <= grid.size() - 1; i++){\\n            for(int j = 1; j < grid[0].size() - 1; j++){\\n                if(grid[i][j]){\\n                    grid[i][j] = min(grid[i-1][j-1],min(grid[i-1][j],grid[i-1][j+1])) + 1;\\n                }\\n            }\\n        }\\n                \\n        for(int i = grid.size() - 1; i > 0; i--){\\n            for(int j = 1; j < grid[0].size() - 1; j++){\\n                if(grid[i][j]){\\n                    res += (grid[i][j] - 1);\\n                }\\n            }\\n        }\\n        return res;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int countPyramids(vector<vector<int>>& grid) {\\n        int res = 0;\\n        for(int i = grid.size() - 2; i >= 0; i--){\\n            for(int j = 1; j < grid[0].size() - 1; j++){\\n                if(grid[i][j]){\\n                    grid[i][j] = min(grid[i+1][j-1],min(grid[i+1][j],grid[i+1][j+1])) + 1;\\n                }\\n            }\\n        }\\n        \\n        for(int i = 0; i <= grid.size() - 1; i++){\\n            for(int j = 1; j < grid[0].size() - 1; j++){\\n                if(grid[i][j]){\\n                    res += (grid[i][j] - 1);\\n                    grid[i][j] = 1;\\n                }\\n            }\\n        }\\n        \\n        for(int i = 1; i <= grid.size() - 1; i++){\\n            for(int j = 1; j < grid[0].size() - 1; j++){\\n                if(grid[i][j]){\\n                    grid[i][j] = min(grid[i-1][j-1],min(grid[i-1][j],grid[i-1][j+1])) + 1;\\n                }\\n            }\\n        }\\n                \\n        for(int i = grid.size() - 1; i > 0; i--){\\n            for(int j = 1; j < grid[0].size() - 1; j++){\\n                if(grid[i][j]){\\n                    res += (grid[i][j] - 1);\\n                }\\n            }\\n        }\\n        return res;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2771179,
                "title": "easy-o-nm-java-dp-solution-variant-of-count-squares-in-binary-grid",
                "content": "```\\nvariant of : count # of squares in a binary grid . \\n1. find the maximum length of left oriented triangle and right oriented triangle and take min of both find the # of pyramids formed for a particlar cell.\\n2. Finding the maximum length triangle for a particular cell follows the same idea as we do in case of maximum length of square.\\n3. swap the arrays to find the inverted pyramids using above apporach \\n\\nclass Solution {\\n    public int countPyramids(int[][] arr) {\\n        int ans = find(arr);\\n        int n = arr.length;\\n        int m = arr[0].length;\\n        for(int i=0;i<n/2;i++){\\n            for(int j=0;j<m;j++){\\n                int t = arr[i][j];\\n                arr[i][j] =arr[n-i-1][j];\\n                arr[n-i-1][j] = t;\\n            }\\n        }\\n        ans += find(arr);\\n        return ans;\\n    }\\n    private int find(int[][] arr){\\n        int n = arr.length;\\n        int m = arr[0].length;\\n        int [] [] dp = new int [n][m];\\n        int ans = 0;\\n        for(int i = 0;i<n;i++){\\n\\t\\t// for left oriented trinagle\\n            for(int j = 0;j<m;j++)\\n                if(arr[i][j]==0)dp[i][j] = 0;\\n                else {\\n                    int up = i==0?0:dp[i-1][j];\\n                    int left = j==0 ? 0 : dp[i][j-1];\\n                    dp[i][j] =  1 + Math.min(up,left);\\n                }\\n                // for right oriented triangle\\n                for(int j = m-1;j>=0;j--)\\n                    if(arr[i][j]==0)dp[i][j] = 0;\\n                    else {\\n                        int up = i==0?0:dp[i-1][j];\\n                        int right = j==m-1 ? 0 : dp[i][j+1];\\n                        dp[i][j] =  Math.min(dp[i][j],1 + Math.min(up,right));\\n                        ans+=dp[i][j]-1;\\n                    }\\n        }\\n        return ans;\\n                \\n    }\\n}",
                "solutionTags": [],
                "code": "class Solution {\\n    public int countPyramids(int[][] arr) {\\n        int ans = find(arr);\\n        int n = arr.length;\\n        int m = arr[0].length;\\n        for(int i=0;i<n/2;i++){\\n            for(int j=0;j<m;j++){\\n                int t = arr[i][j];\\n                arr[i][j] =arr[n-i-1][j];\\n                arr[n-i-1][j] = t;\\n            }",
                "codeTag": "Java"
            },
            {
                "id": 2733085,
                "title": "rust-bit-of-an-odd-solution-that-builds-valid-ranges-for-each-row",
                "content": "Scored faster than 100%.  Take it with a grain of salt cause there\\'s few rust solutions.\\n```\\nstruct IndRange {\\n    left: i16,\\n    right: i16,\\n}\\n\\nimpl IndRange {\\n    fn new(left: i16, right: i16) -> Self {\\n        Self {\\n            left: left,\\n            right: right,\\n        }\\n    }\\n\\n    // Is the other range inside this range (inclusive on both ends)\\n    fn contains(&self, other: IndRange) -> bool {\\n        if self.left > other.left {\\n            return false\\n        }\\n        if self.right < other.right {\\n            return false\\n        }\\n        return true\\n    }\\n\\n    fn is_zero(&self) -> bool {\\n        return self.left == -1;\\n    }\\n}\\n\\nimpl Clone for IndRange {\\n    fn clone(&self) -> Self {\\n        Self {\\n            left: self.left,\\n            right: self.right,\\n        }\\n    }\\n}\\n\\nimpl Solution {\\n\\n    fn ranges_for_row(rvec: &Vec<i32>) -> Vec<IndRange> {\\n        let mut smallvec: Vec<IndRange> = Vec::new();\\n        let mut low: i16 = 0;\\n        let mut high: i16 = 0;\\n        let mut last_was_0 = true;\\n        let len = rvec.len();\\n        for i in 0..=len {\\n            let val_m = rvec.get(i);\\n            let val;\\n            if let Some(v) = val_m {\\n                val = *v;\\n            } else {\\n                val = 0;\\n            }\\n            if val == 0 {\\n                if last_was_0 {\\n                    continue;\\n                }\\n                smallvec.push(IndRange::new(low, high));\\n                last_was_0 = true;\\n                continue;\\n            }\\n            if last_was_0 {\\n                low = i as i16;\\n                last_was_0 = false;\\n            }\\n            high = i as i16;\\n        }\\n        return smallvec\\n    }\\n\\n    fn unroll_small_ranges_vec(rvec: Vec<IndRange>, len: usize) -> Vec<IndRange> {\\n        let mut vec: Vec<IndRange> = vec![IndRange::new(-1, -1); len];\\n\\n        for rng in rvec {\\n            let left = rng.left;\\n            let right = rng.right;\\n            for i in left..=right {\\n                vec[i as usize] = rng.clone();\\n            }\\n        }\\n        return vec\\n    }\\n\\n    fn init_ranges(grid: &Vec<Vec<i32>>, ranges: &mut Vec<Vec<IndRange>>) {\\n        for r in grid {\\n            let svec = Self::ranges_for_row(r);\\n            let rng_row = Self::unroll_small_ranges_vec(svec, r.len());\\n            ranges.push(rng_row);\\n        }\\n    }\\n\\n    fn signed_get<T>(grid: &Vec<T>, ind: i16) -> Option<&T> {\\n        if ind < 0 {\\n            return None\\n        }\\n        grid.get(ind as usize)\\n    }\\n\\n\\n    fn pyramids_at(ranges: &Vec<Vec<IndRange>>, row: i16, col: i16) -> i32 {\\n        let mut num_pyramids = 0;\\n        let mut h: i16 = 1;\\n        if ranges[row as usize][col as usize].is_zero() {\\n            return 0;\\n        }\\n        loop {\\n            let meta_row = row + h;\\n            let rvec_m = Self::signed_get(ranges, meta_row);\\n            let rvec;\\n            match rvec_m {\\n                Some(rvec_i) => rvec = rvec_i,\\n                None => break,\\n            }\\n            let range = IndRange::new(col - h, col + h);\\n            if !rvec[col as usize].contains(range) {\\n                break;\\n            }\\n            num_pyramids += 1;\\n            h += 1;\\n        }\\n        h = 1;\\n        loop {\\n            let meta_row = row - h;\\n            let rvec_m = Self::signed_get(ranges, meta_row);\\n            let rvec;\\n            match rvec_m {\\n                Some(rvec_i) => rvec = rvec_i,\\n                None => break,\\n            }\\n            let range = IndRange::new(col - h, col + h);\\n            if !rvec[col as usize].contains(range) {\\n                break;\\n            }\\n            num_pyramids += 1;\\n            h += 1;\\n        }\\n        return num_pyramids;\\n    }\\n\\n\\n\\n    pub fn count_pyramids(grid: Vec<Vec<i32>>) -> i32 {\\n        let mut ranges: Vec<Vec<IndRange>> = Vec::new();\\n        Self::init_ranges(&grid, &mut ranges); \\n        let rlen = grid.len();\\n        let mut num_pyramids = 0;\\n        for r in 0..rlen {\\n            let clen = grid[r].len();\\n            for c in 0..clen {\\n                num_pyramids += Self::pyramids_at(&ranges, r as i16, c as i16);\\n            }\\n        }\\n        return num_pyramids\\n    }\\n}\\n```",
                "solutionTags": [
                    "Rust"
                ],
                "code": "```\\nstruct IndRange {\\n    left: i16,\\n    right: i16,\\n}\\n\\nimpl IndRange {\\n    fn new(left: i16, right: i16) -> Self {\\n        Self {\\n            left: left,\\n            right: right,\\n        }\\n    }\\n\\n    // Is the other range inside this range (inclusive on both ends)\\n    fn contains(&self, other: IndRange) -> bool {\\n        if self.left > other.left {\\n            return false\\n        }\\n        if self.right < other.right {\\n            return false\\n        }\\n        return true\\n    }\\n\\n    fn is_zero(&self) -> bool {\\n        return self.left == -1;\\n    }\\n}\\n\\nimpl Clone for IndRange {\\n    fn clone(&self) -> Self {\\n        Self {\\n            left: self.left,\\n            right: self.right,\\n        }\\n    }\\n}\\n\\nimpl Solution {\\n\\n    fn ranges_for_row(rvec: &Vec<i32>) -> Vec<IndRange> {\\n        let mut smallvec: Vec<IndRange> = Vec::new();\\n        let mut low: i16 = 0;\\n        let mut high: i16 = 0;\\n        let mut last_was_0 = true;\\n        let len = rvec.len();\\n        for i in 0..=len {\\n            let val_m = rvec.get(i);\\n            let val;\\n            if let Some(v) = val_m {\\n                val = *v;\\n            } else {\\n                val = 0;\\n            }\\n            if val == 0 {\\n                if last_was_0 {\\n                    continue;\\n                }\\n                smallvec.push(IndRange::new(low, high));\\n                last_was_0 = true;\\n                continue;\\n            }\\n            if last_was_0 {\\n                low = i as i16;\\n                last_was_0 = false;\\n            }\\n            high = i as i16;\\n        }\\n        return smallvec\\n    }\\n\\n    fn unroll_small_ranges_vec(rvec: Vec<IndRange>, len: usize) -> Vec<IndRange> {\\n        let mut vec: Vec<IndRange> = vec![IndRange::new(-1, -1); len];\\n\\n        for rng in rvec {\\n            let left = rng.left;\\n            let right = rng.right;\\n            for i in left..=right {\\n                vec[i as usize] = rng.clone();\\n            }\\n        }\\n        return vec\\n    }\\n\\n    fn init_ranges(grid: &Vec<Vec<i32>>, ranges: &mut Vec<Vec<IndRange>>) {\\n        for r in grid {\\n            let svec = Self::ranges_for_row(r);\\n            let rng_row = Self::unroll_small_ranges_vec(svec, r.len());\\n            ranges.push(rng_row);\\n        }\\n    }\\n\\n    fn signed_get<T>(grid: &Vec<T>, ind: i16) -> Option<&T> {\\n        if ind < 0 {\\n            return None\\n        }\\n        grid.get(ind as usize)\\n    }\\n\\n\\n    fn pyramids_at(ranges: &Vec<Vec<IndRange>>, row: i16, col: i16) -> i32 {\\n        let mut num_pyramids = 0;\\n        let mut h: i16 = 1;\\n        if ranges[row as usize][col as usize].is_zero() {\\n            return 0;\\n        }\\n        loop {\\n            let meta_row = row + h;\\n            let rvec_m = Self::signed_get(ranges, meta_row);\\n            let rvec;\\n            match rvec_m {\\n                Some(rvec_i) => rvec = rvec_i,\\n                None => break,\\n            }\\n            let range = IndRange::new(col - h, col + h);\\n            if !rvec[col as usize].contains(range) {\\n                break;\\n            }\\n            num_pyramids += 1;\\n            h += 1;\\n        }\\n        h = 1;\\n        loop {\\n            let meta_row = row - h;\\n            let rvec_m = Self::signed_get(ranges, meta_row);\\n            let rvec;\\n            match rvec_m {\\n                Some(rvec_i) => rvec = rvec_i,\\n                None => break,\\n            }\\n            let range = IndRange::new(col - h, col + h);\\n            if !rvec[col as usize].contains(range) {\\n                break;\\n            }\\n            num_pyramids += 1;\\n            h += 1;\\n        }\\n        return num_pyramids;\\n    }\\n\\n\\n\\n    pub fn count_pyramids(grid: Vec<Vec<i32>>) -> i32 {\\n        let mut ranges: Vec<Vec<IndRange>> = Vec::new();\\n        Self::init_ranges(&grid, &mut ranges); \\n        let rlen = grid.len();\\n        let mut num_pyramids = 0;\\n        for r in 0..rlen {\\n            let clen = grid[r].len();\\n            for c in 0..clen {\\n                num_pyramids += Self::pyramids_at(&ranges, r as i16, c as i16);\\n            }\\n        }\\n        return num_pyramids\\n    }\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2731002,
                "title": "dp-solution-on-grid",
                "content": "```\\nclass Solution {\\npublic:\\n    int solve(vector<vector<int> > grid){\\n        int n=grid.size();\\n        int m=grid[0].size();\\n        for(int i=n-2;i>=0;i--){\\n            for(int j=m-2;j>=1;j--){\\n                if(grid[i][j]!=0){\\n                    grid[i][j]=1+min({grid[i+1][j-1],grid[i+1][j],grid[i+1][j+1]});\\n                }\\n            }\\n        }\\n        int ans=0;\\n        for(int i=0;i<n;i++){\\n            for(int j=0;j<m;j++){\\n                \\n                if(grid[i][j]!=0){\\n                    ans+=grid[i][j]-1;\\n                }\\n            }\\n           \\n        }\\n        return ans;\\n    }\\n    int countPyramids(vector<vector<int>>& grid) {\\n        int ans=solve(grid);\\n        int st=0;\\n        int en=grid.size()-1;\\n        while(st<en){\\n            swap(grid[st],grid[en]);\\n            st++;\\n            en--;\\n        }\\n        ans+=solve(grid);\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    int solve(vector<vector<int> > grid){\\n        int n=grid.size();\\n        int m=grid[0].size();\\n        for(int i=n-2;i>=0;i--){\\n            for(int j=m-2;j>=1;j--){\\n                if(grid[i][j]!=0){\\n                    grid[i][j]=1+min({grid[i+1][j-1],grid[i+1][j],grid[i+1][j+1]});\\n                }\\n            }\\n        }\\n        int ans=0;\\n        for(int i=0;i<n;i++){\\n            for(int j=0;j<m;j++){\\n                \\n                if(grid[i][j]!=0){\\n                    ans+=grid[i][j]-1;\\n                }\\n            }\\n           \\n        }\\n        return ans;\\n    }\\n    int countPyramids(vector<vector<int>>& grid) {\\n        int ans=solve(grid);\\n        int st=0;\\n        int en=grid.size()-1;\\n        while(st<en){\\n            swap(grid[st],grid[en]);\\n            st++;\\n            en--;\\n        }\\n        ans+=solve(grid);\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2704938,
                "title": "java-12ms-tabulation",
                "content": "```\\nclass Solution {\\n    public int countPyramids(int[][] grid) {\\n\\t\\tint n = grid.length;\\n\\t\\tint m = grid[0].length;\\n        int dp [][] = new int[n][m];\\n\\t\\tint x = 0;\\n\\t\\t//Counting all inverted pyramids\\n\\t\\tfor (int i = 1; i < n; i++) {\\n\\t\\t\\tfor (int j = 1; j < m-1; j++) {\\n\\t\\t\\t\\tif (grid[i][j]==1&&grid[i-1][j-1]==1&&grid[i-1][j]==1&&grid[i-1][j+1]==1) {\\n\\t\\t\\t\\t\\tdp[i][j] = 1 + Math.min(dp[i-1][j-1], Math.min(dp[i-1][j], dp[i-1][j+1]));\\n\\t\\t\\t\\t\\tx+=dp[i][j];\\n\\t\\t\\t\\t}\\n\\t\\t\\t}\\n\\t\\t}\\n\\n\\t\\tdp = new int[n][m];\\n\\t//Inverting the grid and counting normal pyramids\\n\\t\\tfor (int i = n-2; i>=0; i--) {\\n\\t\\t\\tfor (int j = m-2; j>=1; j--) {\\n\\t\\t\\t\\tif (grid[i][j]==1&&grid[i+1][j-1]==1&&grid[i+1][j]==1&&grid[i+1][j+1]==1) {\\n\\t\\t\\t\\t\\tdp[i][j] = 1+ Math.min(dp[i+1][j+1], Math.min(dp[i+1][j], dp[i+1][j-1]));\\n\\t\\t\\t\\t\\tx+=dp[i][j];\\n\\t\\t\\t\\t}\\n\\t\\t\\t}\\n\\t\\t}\\n\\t\\treturn x;\\n    }\\n}\\n```\\n",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int countPyramids(int[][] grid) {\\n\\t\\tint n = grid.length;\\n\\t\\tint m = grid[0].length;\\n        int dp [][] = new int[n][m];\\n\\t\\tint x = 0;\\n\\t\\t//Counting all inverted pyramids\\n\\t\\tfor (int i = 1; i < n; i++) {\\n\\t\\t\\tfor (int j = 1; j < m-1; j++) {\\n\\t\\t\\t\\tif (grid[i][j]==1&&grid[i-1][j-1]==1&&grid[i-1][j]==1&&grid[i-1][j+1]==1) {\\n\\t\\t\\t\\t\\tdp[i][j] = 1 + Math.min(dp[i-1][j-1], Math.min(dp[i-1][j], dp[i-1][j+1]));\\n\\t\\t\\t\\t\\tx+=dp[i][j];\\n\\t\\t\\t\\t}\\n\\t\\t\\t}\\n\\t\\t}\\n\\n\\t\\tdp = new int[n][m];\\n\\t//Inverting the grid and counting normal pyramids\\n\\t\\tfor (int i = n-2; i>=0; i--) {\\n\\t\\t\\tfor (int j = m-2; j>=1; j--) {\\n\\t\\t\\t\\tif (grid[i][j]==1&&grid[i+1][j-1]==1&&grid[i+1][j]==1&&grid[i+1][j+1]==1) {\\n\\t\\t\\t\\t\\tdp[i][j] = 1+ Math.min(dp[i+1][j+1], Math.min(dp[i+1][j], dp[i+1][j-1]));\\n\\t\\t\\t\\t\\tx+=dp[i][j];\\n\\t\\t\\t\\t}\\n\\t\\t\\t}\\n\\t\\t}\\n\\t\\treturn x;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2671143,
                "title": "python-solution-faster-90",
                "content": "\\tclass Solution:\\n\\t\\tdef countPyramids(self, G):\\n\\t\\t\\tm, n, ans = len(G), len(G[0]), 0\\n\\n\\t\\t\\t@lru_cache(None)\\n\\t\\t\\tdef dp(i, j, dr):\\n\\t\\t\\t\\tif G[i][j] == 1 and 0 <= i + dr < m and j > 0 and j + 1 < n and G[i+dr][j] == 1:\\n\\t\\t\\t\\t\\treturn min(dp(i+dr, j-1, dr), dp(i+dr, j+1, dr)) + 1\\n\\t\\t\\t\\treturn G[i][j]\\n\\n\\t\\t\\tfor i, j in product(range(m), range(n)):\\n\\t\\t\\t\\tans += max(0, dp(i, j, 1) - 1)\\n\\t\\t\\t\\tans += max(0, dp(i, j, -1) - 1)\\n\\n\\t\\t\\treturn ans",
                "solutionTags": [],
                "code": "\\tclass Solution:\\n\\t\\tdef countPyramids(self, G):\\n\\t\\t\\tm, n, ans = len(G), len(G[0]), 0\\n\\n\\t\\t\\t@lru_cache(None)\\n\\t\\t\\tdef dp(i, j, dr):\\n\\t\\t\\t\\tif G[i][j] == 1 and 0 <= i + dr < m and j > 0 and j + 1 < n and G[i+dr][j] == 1:\\n\\t\\t\\t\\t\\treturn min(dp(i+dr, j-1, dr), dp(i+dr, j+1, dr)) + 1\\n\\t\\t\\t\\treturn G[i][j]\\n\\n\\t\\t\\tfor i, j in product(range(m), range(n)):\\n\\t\\t\\t\\tans += max(0, dp(i, j, 1) - 1)\\n\\t\\t\\t\\tans += max(0, dp(i, j, -1) - 1)\\n\\n\\t\\t\\treturn ans",
                "codeTag": "Java"
            },
            {
                "id": 2609252,
                "title": "python3-dp",
                "content": "```\\nclass Solution:\\n    def countPyramids(self, grid: List[List[int]]) -> int:\\n        f_ans=0\\n        def countPyramids(grid):\\n            r,c=len(grid),len(grid[0])\\n            dp=copy.deepcopy(grid)\\n            ans=0\\n            for i in range(r-2,-1,-1):\\n                for j in range(1,c-1):\\n                    if dp[i][j]:\\n                        dp[i][j]=min(dp[i+1][j-1],dp[i+1][j],dp[i+1][j+1])+1\\n                        ans+=dp[i][j]-1\\n            return ans\\n        f_ans+=countPyramids(grid)\\n        f_ans+=countPyramids(grid[::-1])\\n        return f_ans\\n                    \\n```",
                "solutionTags": [
                    "Python3",
                    "Dynamic Programming"
                ],
                "code": "```\\nclass Solution:\\n    def countPyramids(self, grid: List[List[int]]) -> int:\\n        f_ans=0\\n        def countPyramids(grid):\\n            r,c=len(grid),len(grid[0])\\n            dp=copy.deepcopy(grid)\\n            ans=0\\n            for i in range(r-2,-1,-1):\\n                for j in range(1,c-1):\\n                    if dp[i][j]:\\n                        dp[i][j]=min(dp[i+1][j-1],dp[i+1][j],dp[i+1][j+1])+1\\n                        ans+=dp[i][j]-1\\n            return ans\\n        f_ans+=countPyramids(grid)\\n        f_ans+=countPyramids(grid[::-1])\\n        return f_ans\\n                    \\n```",
                "codeTag": "Java"
            },
            {
                "id": 2500640,
                "title": "very-big-lengthy-solution",
                "content": "```\\nclass Solution {\\npublic:\\n    int getPyramidCount(vector<vector<int>>& grid) {\\n        int n = grid.size();\\n        int m = grid[0].size();\\n        vector<vector<int>> left(n, vector<int> (m));\\n        vector<vector<int>> right(n, vector<int> (m));\\n        vector<vector<int>> hor(n, vector<int> (m));\\n        for (int i = 0; i < n; i++) {\\n            int row = i;\\n            int col = 0;\\n            while (row >= 0 && col < m - 1) {\\n                int prev = 0;\\n                if (grid[row][col] == 0) {\\n                    right[row][col] = 0;\\n                } else {\\n                    if (row + 1 < n && col - 1 >= 0) {\\n                        prev = left[row + 1][col - 1];\\n                    }\\n                    left[row][col] += prev + grid[row][col];\\n                }\\n                --row;\\n                ++col;\\n            }\\n        }\\n        for (int i = 1; i < m; i++) {\\n            int row = n - 1;\\n            int col = i;\\n            while (row >= 0 && col < m - 1) {\\n                int prev = 0;\\n                if (grid[row][col] == 0) {\\n                    right[row][col] = 0;\\n                } else {\\n                    if (row + 1 < n && col - 1 >= 0) {\\n                        prev = left[row + 1][col - 1];\\n                    }\\n                    left[row][col] += prev + grid[row][col];\\n                }\\n                --row;\\n                ++col;\\n            }\\n        }\\n        for (int i = 0; i < n; i++) {\\n            int row = i;\\n            int col = m - 1;\\n            while (row >= 0 && col >= 0) {\\n                int prev = 0;\\n                if (grid[row][col] == 0) {\\n                    right[row][col] = 0;\\n                } else {\\n                    if (row + 1 < n && col + 1 < m) {\\n                        prev = right[row + 1][col + 1];\\n                    }\\n                    right[row][col] = prev + grid[row][col];\\n                }\\n                --row;\\n                --col;\\n            }\\n        }\\n        for (int i = m - 2; i >= 0; i--) {\\n            int row = n - 1;\\n            int col = i;\\n            while (row >= 0 && col >= 0) {\\n                int prev = 0;\\n                if (grid[row][col] == 0) {\\n                    right[row][col] = 0;\\n                } else {\\n                    if (row + 1 < n && col + 1 < m) {\\n                        prev = right[row + 1][col + 1];\\n                    }\\n                    right[row][col] = prev + grid[row][col];\\n                }\\n                --row;\\n                --col;\\n            }\\n        }\\n        for (int i = 0; i < n; i++) {\\n            for (int j = 0; j < m; j++) {\\n                hor[i][j] = (j == 0 ? 0 : hor[i][j - 1]) + grid[i][j];\\n            }\\n        }\\n        vector<vector<pair<int, int>>> dp(n, vector<pair<int, int>> (m));\\n        for (int i = 0; i < m; i++) {\\n            for (int j = n - 1; j >= 0; j--) {\\n                if (j + 1 == n && grid[j][i] == 1) {\\n                    dp[j][i] = {1, 1};\\n                } else if (grid[j][i] == 1) {\\n                    int l = dp[j + 1][i].first;\\n                    int r = dp[j + 1][i].second;\\n                    if (l == 0 && r == 0) {\\n                        dp[j][i] = {1, 1};\\n                    } else {\\n                        int l1 = left[j][i]; \\n                        int r1 = right[j][i];\\n                        if (l1 > l && r1 > r) {\\n                            if (j == 0 && i == 4) {\\n                                cout << l << endl;\\n                            }\\n                            int mn = l + 1;\\n                            if (i - mn + 1 >= 0 && j + mn - 1 < n && i + mn - 1 < m) {\\n                                int sum = 2 * mn - 1;\\n                                \\n                                int value = 0;\\n                                if (i - mn >= 0) {\\n                                    value = hor[j + mn - 1][i - mn];\\n                                }\\n                                int s = hor[j + mn -1][i + mn - 1] - value;\\n                                if (sum == s) {\\n                                    \\n                                    dp[j][i] = {l + 1, r + 1};\\n                                } else {\\n                                    \\n                                    dp[j][i] = {l, r};\\n                                }\\n                            } \\n                        } else {\\n                            int mn = min(l1, r1);\\n                            dp[j][i] = {mn, mn};\\n                        }\\n                    }\\n                }\\n                \\n            }\\n        }\\n        int sol = 0;\\n        for (int i = 0; i < n; i++) {\\n            for (int j = 0; j < m; j++) {\\n                if (dp[i][j].first > 0 && dp[i][j].second > 0) {\\n                    sol += dp[i][j].first - 1;\\n                }\\n            }\\n        }\\n        return sol;\\n    }\\n    int countPyramids(vector<vector<int>>& grid) {\\n        int sol = 0;\\n        sol += getPyramidCount(grid);\\n        reverse(grid.begin(), grid.end());\\n        sol += getPyramidCount(grid);\\n        return sol;\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    int getPyramidCount(vector<vector<int>>& grid) {\\n        int n = grid.size();\\n        int m = grid[0].size();\\n        vector<vector<int>> left(n, vector<int> (m));\\n        vector<vector<int>> right(n, vector<int> (m));\\n        vector<vector<int>> hor(n, vector<int> (m));\\n        for (int i = 0; i < n; i++) {\\n            int row = i;\\n            int col = 0;\\n            while (row >= 0 && col < m - 1) {\\n                int prev = 0;\\n                if (grid[row][col] == 0) {\\n                    right[row][col] = 0;\\n                } else {\\n                    if (row + 1 < n && col - 1 >= 0) {\\n                        prev = left[row + 1][col - 1];\\n                    }\\n                    left[row][col] += prev + grid[row][col];\\n                }\\n                --row;\\n                ++col;\\n            }\\n        }\\n        for (int i = 1; i < m; i++) {\\n            int row = n - 1;\\n            int col = i;\\n            while (row >= 0 && col < m - 1) {\\n                int prev = 0;\\n                if (grid[row][col] == 0) {\\n                    right[row][col] = 0;\\n                } else {\\n                    if (row + 1 < n && col - 1 >= 0) {\\n                        prev = left[row + 1][col - 1];\\n                    }\\n                    left[row][col] += prev + grid[row][col];\\n                }\\n                --row;\\n                ++col;\\n            }\\n        }\\n        for (int i = 0; i < n; i++) {\\n            int row = i;\\n            int col = m - 1;\\n            while (row >= 0 && col >= 0) {\\n                int prev = 0;\\n                if (grid[row][col] == 0) {\\n                    right[row][col] = 0;\\n                } else {\\n                    if (row + 1 < n && col + 1 < m) {\\n                        prev = right[row + 1][col + 1];\\n                    }\\n                    right[row][col] = prev + grid[row][col];\\n                }\\n                --row;\\n                --col;\\n            }\\n        }\\n        for (int i = m - 2; i >= 0; i--) {\\n            int row = n - 1;\\n            int col = i;\\n            while (row >= 0 && col >= 0) {\\n                int prev = 0;\\n                if (grid[row][col] == 0) {\\n                    right[row][col] = 0;\\n                } else {\\n                    if (row + 1 < n && col + 1 < m) {\\n                        prev = right[row + 1][col + 1];\\n                    }\\n                    right[row][col] = prev + grid[row][col];\\n                }\\n                --row;\\n                --col;\\n            }\\n        }\\n        for (int i = 0; i < n; i++) {\\n            for (int j = 0; j < m; j++) {\\n                hor[i][j] = (j == 0 ? 0 : hor[i][j - 1]) + grid[i][j];\\n            }\\n        }\\n        vector<vector<pair<int, int>>> dp(n, vector<pair<int, int>> (m));\\n        for (int i = 0; i < m; i++) {\\n            for (int j = n - 1; j >= 0; j--) {\\n                if (j + 1 == n && grid[j][i] == 1) {\\n                    dp[j][i] = {1, 1};\\n                } else if (grid[j][i] == 1) {\\n                    int l = dp[j + 1][i].first;\\n                    int r = dp[j + 1][i].second;\\n                    if (l == 0 && r == 0) {\\n                        dp[j][i] = {1, 1};\\n                    } else {\\n                        int l1 = left[j][i]; \\n                        int r1 = right[j][i];\\n                        if (l1 > l && r1 > r) {\\n                            if (j == 0 && i == 4) {\\n                                cout << l << endl;\\n                            }\\n                            int mn = l + 1;\\n                            if (i - mn + 1 >= 0 && j + mn - 1 < n && i + mn - 1 < m) {\\n                                int sum = 2 * mn - 1;\\n                                \\n                                int value = 0;\\n                                if (i - mn >= 0) {\\n                                    value = hor[j + mn - 1][i - mn];\\n                                }\\n                                int s = hor[j + mn -1][i + mn - 1] - value;\\n                                if (sum == s) {\\n                                    \\n                                    dp[j][i] = {l + 1, r + 1};\\n                                } else {\\n                                    \\n                                    dp[j][i] = {l, r};\\n                                }\\n                            } \\n                        } else {\\n                            int mn = min(l1, r1);\\n                            dp[j][i] = {mn, mn};\\n                        }\\n                    }\\n                }\\n                \\n            }\\n        }\\n        int sol = 0;\\n        for (int i = 0; i < n; i++) {\\n            for (int j = 0; j < m; j++) {\\n                if (dp[i][j].first > 0 && dp[i][j].second > 0) {\\n                    sol += dp[i][j].first - 1;\\n                }\\n            }\\n        }\\n        return sol;\\n    }\\n    int countPyramids(vector<vector<int>>& grid) {\\n        int sol = 0;\\n        sol += getPyramidCount(grid);\\n        reverse(grid.begin(), grid.end());\\n        sol += getPyramidCount(grid);\\n        return sol;\\n    }\\n};\\n```",
                "codeTag": "C++"
            },
            {
                "id": 2396802,
                "title": "python-3-dp-short-and-concise",
                "content": "\\tclass Solution:\\n\\t\\tdef countPyramids(self, grid: List[List[int]]) -> int:\\n\\t\\t\\tn,m=len(grid),len(grid[0])\\n\\t\\t\\tdef solve(grid):\\n\\t\\t\\t\\tres=0\\n\\t\\t\\t\\tdp=[[0]*m for _ in range(n)]\\n\\t\\t\\t\\tfor i in range(n-2,-1,-1):\\n\\t\\t\\t\\t\\tfor j in range(1,m-1):\\n\\t\\t\\t\\t\\t\\tif grid[i][j] and grid[i+1][j] and grid[i+1][j+1] and grid[i+1][j-1]:\\n\\t\\t\\t\\t\\t\\t\\tdp[i][j]=1+min(dp[i+1][j-1],dp[i+1][j+1])\\n\\t\\t\\t\\t\\t\\tres+=dp[i][j]\\n\\t\\t\\t\\treturn res\\n\\t\\t\\treturn solve(grid)+solve(grid[::-1])",
                "solutionTags": [],
                "code": "\\tclass Solution:\\n\\t\\tdef countPyramids(self, grid: List[List[int]]) -> int:\\n\\t\\t\\tn,m=len(grid),len(grid[0])\\n\\t\\t\\tdef solve(grid):\\n\\t\\t\\t\\tres=0\\n\\t\\t\\t\\tdp=[[0]*m for _ in range(n)]\\n\\t\\t\\t\\tfor i in range(n-2,-1,-1):\\n\\t\\t\\t\\t\\tfor j in range(1,m-1):\\n\\t\\t\\t\\t\\t\\tif grid[i][j] and grid[i+1][j] and grid[i+1][j+1] and grid[i+1][j-1]:\\n\\t\\t\\t\\t\\t\\t\\tdp[i][j]=1+min(dp[i+1][j-1],dp[i+1][j+1])\\n\\t\\t\\t\\t\\t\\tres+=dp[i][j]\\n\\t\\t\\t\\treturn res\\n\\t\\t\\treturn solve(grid)+solve(grid[::-1])",
                "codeTag": "Java"
            },
            {
                "id": 2369461,
                "title": "java",
                "content": "class Solution {\\n    public int countPyramids(int[][] grid) {\\n\\n        int n = grid.length;\\n        int m = grid[0].length;\\n\\n        int ans = solve(grid,n,m);\\n        reverse(grid,n,m);\\n        ans += solve(grid,n,m);\\n        return ans;\\n        \\n    }\\n\\n    public void reverse(int[][] grid,int n,int m){\\n\\n\\n        for(int i=0;i<n;i++) {\\n\\n            int a = 0;\\n            int b = m - 1;\\n            while (a < b) {\\n                int temp = grid[i][a];\\n                grid[i][a] = grid[i][b];\\n                grid[i][b] = temp;\\n                a++;\\n                b--;\\n            }\\n        }\\n\\n\\n        int a=0;\\n        int b = n-1;\\n        \\n        while(a<b){\\n            int []temp = grid[a];\\n            grid[a] = grid[b];\\n            grid[b]=temp;\\n            a++;\\n            b--;\\n         }\\n        \\n\\n\\n    }\\n\\n    public int solve(int[][]grid,int n,int m){\\n        int[][]l = new int[n][m];\\n\\n        for(int i=0;i<n;i++){\\n            l[i][0]=grid[i][0];\\n            for(int j=1;j<m;j++){\\n                if(grid[i][j]==1){\\n                    l[i][j] =1 + l[i][j-1];\\n                }\\n            }\\n        }\\n\\n        int [][] r = new int[n][m];\\n\\n\\n        for(int i=0;i<n;i++){\\n            r[i][m-1]=grid[i][m-1];\\n            for(int j=m-2;j>=0;j--){\\n                if(grid[i][j]==1){\\n                    r[i][j] =1 + r[i][j+1];\\n                }\\n            }\\n        }\\n        \\n       \\n\\n        \\n        \\n        int[][]w = new int[n][m];\\n\\n\\n        for(int i=0;i<n;i++){\\n            for(int j=0;j<m;j++){\\n                if(grid[i][j]==1){\\n                    int wid = Math.min(l[i][j],r[i][j]);\\n                    w[i][j] = 2*wid-1;\\n                }\\n            }\\n        }\\n        \\n\\n\\n        \\n    \\n        \\n        \\n        \\n\\n        int[][] lis = new int[n][m];\\n\\n        for(int j=0;j<m;j++){\\n            if(w[0][j]>0){\\n               lis[0][j]=1;\\n            }\\n            for(int i=1;i<n;i++){\\n                if(grid[i][j]==0){\\n                    continue;\\n                }\\n                \\n                if(lis[i-1][j]==0){\\n                    lis[i][j]=grid[i][j];\\n                    continue;\\n                }\\n\\n                if(w[i][j]>=lis[i-1][j]+2){\\n                    lis[i][j] = lis[i-1][j]+2;\\n                }else{\\n                    lis[i][j]=w[i][j];\\n                }\\n            }\\n        }\\n\\n              \\n    \\n      \\n        int ans=0;\\n\\n        for(int i=0;i<n;i++){\\n            for(int j=0;j<m;j++){\\n                ans += lis[i][j]/2;\\n            }\\n        }\\n        return ans;\\n    }\\n}",
                "solutionTags": [
                    "Java",
                    "Prefix Sum"
                ],
                "code": "class Solution {\\n    public int countPyramids(int[][] grid) {\\n\\n        int n = grid.length;\\n        int m = grid[0].length;\\n\\n        int ans = solve(grid,n,m);\\n        reverse(grid,n,m);\\n        ans += solve(grid,n,m);\\n        return ans;\\n        \\n    }",
                "codeTag": "Java"
            },
            {
                "id": 2351936,
                "title": "python3-dp-memoization-o-m-n",
                "content": "```\\nclass Solution:\\n    def countPyramids(self, grid: List[List[int]]) -> int:\\n        \\n        m, n = len(grid), len(grid[0])\\n        \\n        @cache\\n        def countDown(i, j):\\n            nonlocal m, n\\n            if i + 1 < m and j - 1 > -1 and j + 1 < n and grid[i][j] == 1:\\n                left = countDown(i+1, j-1)\\n                bottom = countDown(i+1, j)\\n                right = countDown(i+1, j+1)\\n                return 1 + min(left, bottom, right)\\n            else:\\n                return grid[i][j]\\n        \\n        @cache\\n        def countUp(i, j):\\n            nonlocal m, n\\n            if i - 1 > -1 and j - 1 > -1 and j + 1 < n and grid[i][j] == 1:\\n                left = countUp(i-1, j-1)\\n                top = countUp(i-1, j)\\n                right = countUp(i-1, j+1)\\n                return 1 + min(left, top, right)\\n            else:\\n                return grid[i][j]\\n            \\n        ans = 0\\n            \\n        for i in range(m):\\n            for j in range(n):\\n                if countDown(i, j) != 0:\\n                    ans += countDown(i, j) - 1\\n                if countUp(i, j) != 0:\\n                    ans += countUp(i, j) - 1\\n\\n        return ans\\n```",
                "solutionTags": [
                    "Python3",
                    "Dynamic Programming",
                    "Memoization"
                ],
                "code": "```\\nclass Solution:\\n    def countPyramids(self, grid: List[List[int]]) -> int:\\n        \\n        m, n = len(grid), len(grid[0])\\n        \\n        @cache\\n        def countDown(i, j):\\n            nonlocal m, n\\n            if i + 1 < m and j - 1 > -1 and j + 1 < n and grid[i][j] == 1:\\n                left = countDown(i+1, j-1)\\n                bottom = countDown(i+1, j)\\n                right = countDown(i+1, j+1)\\n                return 1 + min(left, bottom, right)\\n            else:\\n                return grid[i][j]\\n        \\n        @cache\\n        def countUp(i, j):\\n            nonlocal m, n\\n            if i - 1 > -1 and j - 1 > -1 and j + 1 < n and grid[i][j] == 1:\\n                left = countUp(i-1, j-1)\\n                top = countUp(i-1, j)\\n                right = countUp(i-1, j+1)\\n                return 1 + min(left, top, right)\\n            else:\\n                return grid[i][j]\\n            \\n        ans = 0\\n            \\n        for i in range(m):\\n            for j in range(n):\\n                if countDown(i, j) != 0:\\n                    ans += countDown(i, j) - 1\\n                if countUp(i, j) != 0:\\n                    ans += countUp(i, j) - 1\\n\\n        return ans\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2349838,
                "title": "simple-dp",
                "content": "```\\nclass Solution {\\n    public int Up(int[][]grid){\\n        int[][]dp=new int[grid.length][grid[0].length];\\n        \\n        for(int i=0;i<grid[0].length;i++)\\n            dp[grid.length-1][i]=grid[grid.length-1][i];\\n        int count=0;\\n        \\n        for(int i=grid.length-2;i>=0;i--){\\n            dp[i][0]=grid[i][0];\\n            dp[i][grid[0].length-1]=grid[i][grid[0].length-1];\\n            \\n            for(int j=1;j<grid[0].length-1;j++){\\n                dp[i][j]=grid[i][j]*(Math.min(dp[i+1][j-1],Math.min(dp[i+1][j+1],dp[i+1][j]))+1);\\n                \\n                count +=dp[i][j]>0?dp[i][j]-1:0;\\n            }\\n        }\\n        return count;\\n    }\\n    public int Down(int[][]grid){\\n        int[][]dp=new int[grid.length][grid[0].length];\\n        \\n        for(int i=0;i<grid[0].length;i++){\\n            dp[0][i]=grid[0][i];\\n            }\\n        \\n        \\n        int count=0;\\n        \\n        for(int i=1;i<grid.length;i++){\\n            dp[i][0]=grid[i][0];\\n            dp[i][grid[0].length-1]=grid[i][grid[0].length-1];\\n            \\n            for(int j=1;j<grid[0].length-1;j++){\\n                dp[i][j]=grid[i][j]*(Math.min(dp[i-1][j-1],Math.min(dp[i-1][j+1],dp[i-1][j]))+1);\\n                \\n                //System.out.print(dp[i][j]+\" \");\\n                count +=dp[i][j] >0?dp[i][j]-1:0;\\n            }\\n        }\\n        return count;\\n    }\\n    public int countPyramids(int[][] grid) {\\n        //dp(r,c)=min(dp(r+1,c-1),dp(r+1,c+1))+1\\n        int tmp1=Up(grid);\\n      //  System.out.println(tmp1);\\n        \\n        int tmp2=Down(grid);\\n       // System.out.println(tmp2);\\n        \\n       return tmp1+tmp2;\\n      \\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    public int Up(int[][]grid){\\n        int[][]dp=new int[grid.length][grid[0].length];\\n        \\n        for(int i=0;i<grid[0].length;i++)\\n            dp[grid.length-1][i]=grid[grid.length-1][i];\\n        int count=0;\\n        \\n        for(int i=grid.length-2;i>=0;i--){\\n            dp[i][0]=grid[i][0];\\n            dp[i][grid[0].length-1]=grid[i][grid[0].length-1];\\n            \\n            for(int j=1;j<grid[0].length-1;j++){\\n                dp[i][j]=grid[i][j]*(Math.min(dp[i+1][j-1],Math.min(dp[i+1][j+1],dp[i+1][j]))+1);\\n                \\n                count +=dp[i][j]>0?dp[i][j]-1:0;\\n            }\\n        }\\n        return count;\\n    }\\n    public int Down(int[][]grid){\\n        int[][]dp=new int[grid.length][grid[0].length];\\n        \\n        for(int i=0;i<grid[0].length;i++){\\n            dp[0][i]=grid[0][i];\\n            }\\n        \\n        \\n        int count=0;\\n        \\n        for(int i=1;i<grid.length;i++){\\n            dp[i][0]=grid[i][0];\\n            dp[i][grid[0].length-1]=grid[i][grid[0].length-1];\\n            \\n            for(int j=1;j<grid[0].length-1;j++){\\n                dp[i][j]=grid[i][j]*(Math.min(dp[i-1][j-1],Math.min(dp[i-1][j+1],dp[i-1][j]))+1);\\n                \\n                //System.out.print(dp[i][j]+\" \");\\n                count +=dp[i][j] >0?dp[i][j]-1:0;\\n            }\\n        }\\n        return count;\\n    }\\n    public int countPyramids(int[][] grid) {\\n        //dp(r,c)=min(dp(r+1,c-1),dp(r+1,c+1))+1\\n        int tmp1=Up(grid);\\n      //  System.out.println(tmp1);\\n        \\n        int tmp2=Down(grid);\\n       // System.out.println(tmp2);\\n        \\n       return tmp1+tmp2;\\n      \\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2339835,
                "title": "optimal-c-solution-beats-92-89-time",
                "content": "```\\nclass Solution {\\npublic:\\n    int solve(vector<vector<int>>& dp) {\\n        ios_base::sync_with_stdio(false);\\n        cin.tie(NULL);\\n        int m = dp.size(), n = dp[0].size(), sum = 0, i, j;\\n        for (i = 1; i < m; i++) {\\n            for (j = 1; j < n-1; j++) {\\n                if(dp[i][j] && dp[i-1][j]) {\\n                    dp[i][j] = 1+min(dp[i-1][j-1], dp[i-1][j+1]);\\n                    sum += dp[i][j]-1;\\n                }\\n            }\\n        }\\n        return sum;\\n    }\\n    \\n    int countPyramids(vector<vector<int>>& grid) {\\n        ios_base::sync_with_stdio(false);\\n        cin.tie(NULL);\\n        vector<vector<int>>dp1, dp2;\\n        dp1 = grid;\\n        dp2 = grid;\\n        reverse(dp1.begin(), dp1.end());\\n        return solve(dp1)+solve(dp2);\\n    }\\n};\\n```",
                "solutionTags": [
                    "Prefix Sum"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int solve(vector<vector<int>>& dp) {\\n        ios_base::sync_with_stdio(false);\\n        cin.tie(NULL);\\n        int m = dp.size(), n = dp[0].size(), sum = 0, i, j;\\n        for (i = 1; i < m; i++) {\\n            for (j = 1; j < n-1; j++) {\\n                if(dp[i][j] && dp[i-1][j]) {\\n                    dp[i][j] = 1+min(dp[i-1][j-1], dp[i-1][j+1]);\\n                    sum += dp[i][j]-1;\\n                }\\n            }\\n        }\\n        return sum;\\n    }\\n    \\n    int countPyramids(vector<vector<int>>& grid) {\\n        ios_base::sync_with_stdio(false);\\n        cin.tie(NULL);\\n        vector<vector<int>>dp1, dp2;\\n        dp1 = grid;\\n        dp2 = grid;\\n        reverse(dp1.begin(), dp1.end());\\n        return solve(dp1)+solve(dp2);\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2299122,
                "title": "python3-dp",
                "content": "class Solution:\\n\\n    def countPyramids(self, grid: List[List[int]]) -> int:\\n        ROWS,COLS = len(grid),len(grid[0])\\n        \\n        def calculate(grid):\\n            LU = [[0]*COLS for _ in range(ROWS)]\\n            RU = [[0]*COLS for _ in range(ROWS)]\\n            count = 0\\n            for i in range(1,ROWS):\\n                for j in range(1,COLS):\\n                    if grid[i][j] and grid[i-1][j] and grid[i][j-1]:\\n                        LU[i][j] = 1 + min(LU[i-1][j],LU[i][j-1])\\n                for j in reversed(range(COLS-1)):\\n                    if grid[i][j] and grid[i-1][j] and grid[i][j+1]:\\n                        RU[i][j] = 1 + min(RU[i-1][j],RU[i][j+1])\\n                        count+=min(LU[i][j],RU[i][j])\\n            return count\\n            \\n        return calculate(grid) + calculate(grid[::-1])",
                "solutionTags": [],
                "code": "class Solution:\\n\\n    def countPyramids(self, grid: List[List[int]]) -> int:\\n        ROWS,COLS = len(grid),len(grid[0])\\n        \\n        def calculate(grid):\\n            LU = [[0]*COLS for _ in range(ROWS)]\\n            RU = [[0]*COLS for _ in range(ROWS)]\\n            count = 0\\n            for i in range(1,ROWS):\\n                for j in range(1,COLS):\\n                    if grid[i][j] and grid[i-1][j] and grid[i][j-1]:\\n                        LU[i][j] = 1 + min(LU[i-1][j],LU[i][j-1])\\n                for j in reversed(range(COLS-1)):\\n                    if grid[i][j] and grid[i-1][j] and grid[i][j+1]:\\n                        RU[i][j] = 1 + min(RU[i-1][j],RU[i][j+1])\\n                        count+=min(LU[i][j],RU[i][j])\\n            return count\\n            \\n        return calculate(grid) + calculate(grid[::-1])",
                "codeTag": "Java"
            },
            {
                "id": 2284301,
                "title": "c-easy-to-understand-simple-prefix-sum",
                "content": "```\\nclass Solution {\\npublic:\\n    int countPyramids(vector<vector<int>>& grid) {\\n        int n=grid.size();\\n        int m=grid[0].size();\\n        vector<vector<int>> pre(n,vector<int>(m));\\n        // Calculating Prefix Sum\\n        for(int i=0;i<n;i++)\\n        {\\n            for(int j=0;j<m;j++)\\n            {\\n                if(j==0)\\n                {\\n                    pre[i][j]=grid[i][j];\\n                }\\n                else\\n                {\\n                    pre[i][j]=pre[i][j-1]+grid[i][j];\\n                }\\n            }\\n        }\\n        //Checking for pyramids\\n        int ans=0;\\n        for(int i=0;i<n;i++)\\n        {\\n            for(int j=0;j<m;j++)\\n            {\\n                if(grid[i][j])\\n                {\\n                    int c=1;\\n                    int r,c1,c2;\\n                    r=i;\\n                    c1=j;\\n                    c2=j;\\n                    while(r<n&&c1>=0&&c2<m)\\n                    {\\n                        int count;\\n                        if(c1<1)\\n                        count=pre[r][c2];\\n                        else\\n                        count=pre[r][c2]-pre[r][c1-1];\\n                        if(count==c)\\n                        {\\n                            if(c>1)\\n                            ans++;\\n                        }\\n                        else\\n                        break;\\n                        c+=2;\\n                        r++;\\n                        c1--;\\n                        c2++;\\n                    }\\n                }\\n            }\\n        }\\n        \\n        //Checking for inverted Pyramids\\n        for(int i=0;i<n;i++)\\n        {\\n            for(int j=0;j<m;j++)\\n            {\\n                if(grid[i][j])\\n                {\\n                    int c=1;\\n                    int r,c1,c2;\\n                    r=i;\\n                    c1=j;\\n                    c2=j;\\n                    while(r>=0&&c1>=0&&c2<m)\\n                    {\\n                        int count;\\n                        if(c1<1)\\n                        count=pre[r][c2];\\n                        else\\n                        count=pre[r][c2]-pre[r][c1-1];\\n                        if(count==c)\\n                        {\\n                            if(c>1)\\n                            ans++;\\n                        }\\n                        else\\n                        break;\\n                        c+=2;\\n                        r--;\\n                        c1--;\\n                        c2++;\\n                    }\\n                }\\n            }\\n        }\\n    return ans;\\n    }\\n};\\n```\\n**Please upvote to motivate me in my quest of documenting all leetcode solutions. HAPPY CODING:)\\nAny suggestions and improvements are always welcome**\\n",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    int countPyramids(vector<vector<int>>& grid) {\\n        int n=grid.size();\\n        int m=grid[0].size();\\n        vector<vector<int>> pre(n,vector<int>(m));\\n        // Calculating Prefix Sum\\n        for(int i=0;i<n;i++)\\n        {\\n            for(int j=0;j<m;j++)\\n            {\\n                if(j==0)\\n                {\\n                    pre[i][j]=grid[i][j];\\n                }\\n                else\\n                {\\n                    pre[i][j]=pre[i][j-1]+grid[i][j];\\n                }\\n            }\\n        }\\n        //Checking for pyramids\\n        int ans=0;\\n        for(int i=0;i<n;i++)\\n        {\\n            for(int j=0;j<m;j++)\\n            {\\n                if(grid[i][j])\\n                {\\n                    int c=1;\\n                    int r,c1,c2;\\n                    r=i;\\n                    c1=j;\\n                    c2=j;\\n                    while(r<n&&c1>=0&&c2<m)\\n                    {\\n                        int count;\\n                        if(c1<1)\\n                        count=pre[r][c2];\\n                        else\\n                        count=pre[r][c2]-pre[r][c1-1];\\n                        if(count==c)\\n                        {\\n                            if(c>1)\\n                            ans++;\\n                        }\\n                        else\\n                        break;\\n                        c+=2;\\n                        r++;\\n                        c1--;\\n                        c2++;\\n                    }\\n                }\\n            }\\n        }\\n        \\n        //Checking for inverted Pyramids\\n        for(int i=0;i<n;i++)\\n        {\\n            for(int j=0;j<m;j++)\\n            {\\n                if(grid[i][j])\\n                {\\n                    int c=1;\\n                    int r,c1,c2;\\n                    r=i;\\n                    c1=j;\\n                    c2=j;\\n                    while(r>=0&&c1>=0&&c2<m)\\n                    {\\n                        int count;\\n                        if(c1<1)\\n                        count=pre[r][c2];\\n                        else\\n                        count=pre[r][c2]-pre[r][c1-1];\\n                        if(count==c)\\n                        {\\n                            if(c>1)\\n                            ans++;\\n                        }\\n                        else\\n                        break;\\n                        c+=2;\\n                        r--;\\n                        c1--;\\n                        c2++;\\n                    }\\n                }\\n            }\\n        }\\n    return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2170461,
                "title": "clear-dp-solution-cpp",
                "content": "```\\n    int countPyramids(vector<vector<int>>& grid) {\\n        int n=grid.size();\\n        int m=grid[0].size();\\n        int ans=0;\\n        vector<vector<int>> dp(n, vector<int>(m,0));\\n        for(int i=n-2; i>=0; i--)\\n            for(int j=1; j<m-1; j++)\\n                if(grid[i][j] && grid[i+1][j-1] && grid[i+1][j] && grid[i+1][j+1])\\n                    dp[i][j]=min(dp[i+1][j-1],min(dp[i+1][j] , dp[i+1][j+1]))+1;\\n                \\n        for(int i=n-2; i>=0; i--)\\n            for(int j=1; j<m-1; j++)\\n                ans+=dp[i][j];\\n        \\n        dp = vector<vector<int>>(n, vector<int>(m,0));\\n        for(int i=1; i<n; i++)\\n            for(int j=1; j<m-1; j++)\\n                if(grid[i][j] && grid[i-1][j-1] && grid[i-1][j] && grid[i-1][j+1])\\n                    dp[i][j]=min(dp[i-1][j-1],min(dp[i-1][j] , dp[i-1][j+1]))+1;\\n                \\n        for(int i=1; i<n; i++)\\n            for(int j=1; j<m-1; j++)\\n                ans+=dp[i][j];\\n        \\n        return ans;\\n    }\\n```",
                "solutionTags": [],
                "code": "```\\n    int countPyramids(vector<vector<int>>& grid) {\\n        int n=grid.size();\\n        int m=grid[0].size();\\n        int ans=0;\\n        vector<vector<int>> dp(n, vector<int>(m,0));\\n        for(int i=n-2; i>=0; i--)\\n            for(int j=1; j<m-1; j++)\\n                if(grid[i][j] && grid[i+1][j-1] && grid[i+1][j] && grid[i+1][j+1])\\n                    dp[i][j]=min(dp[i+1][j-1],min(dp[i+1][j] , dp[i+1][j+1]))+1;\\n                \\n        for(int i=n-2; i>=0; i--)\\n            for(int j=1; j<m-1; j++)\\n                ans+=dp[i][j];\\n        \\n        dp = vector<vector<int>>(n, vector<int>(m,0));\\n        for(int i=1; i<n; i++)\\n            for(int j=1; j<m-1; j++)\\n                if(grid[i][j] && grid[i-1][j-1] && grid[i-1][j] && grid[i-1][j+1])\\n                    dp[i][j]=min(dp[i-1][j-1],min(dp[i-1][j] , dp[i-1][j+1]))+1;\\n                \\n        for(int i=1; i<n; i++)\\n            for(int j=1; j<m-1; j++)\\n                ans+=dp[i][j];\\n        \\n        return ans;\\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2156629,
                "title": "o-nm-prefix-suffix-counts-dynamic-programming",
                "content": "We need to count the number of fertile and inverse fertile pyramids in our `m-by-n` matrix `grid` of size > 1. Note that if we know how to compute the first, we can simply reverse each column of the matrix, using standard two-pointer technique, and re-compute on this new matrix. Thus, we restrict to the first case.\\n\\n**LOCAL PROBLEM**\\nFor a given cell `(i, j)`, we tackle the local problem of counting how many fertile pyramids have a base centered at cell `(i, j)`. Let\\'s define the function:\\n```\\ncount(i,j) = # of fertile pyramids whose base is centered at cell (i, j)\\n```\\nThere\\'s a couple of no-brainer things we can say right off the bat about it:\\n- if `grid(i, j) = 0`, then  `count(i, j) = 0`\\n- if `grid(i-1, j) = 0`, then `count(i, j) = 0`. Directly above cell needs to be 1 to ensure row `(i, j)` can form center of the base of a pyramid.\\n\\nSo now that we know a couple of prerequisites for `(i, j)` to serve as the center of the base for a fertile pyramid, we assume them moving forward, i.e. `grid(i,j) = 1` and `grid(i-1, j) = 1`.\\n\\nThere\\'s two things that contribute to `count(i, j)`:\\n- extending cell `(i-1, j)` to a pyramid of height 2 with base centered at `(i, j)`\\n- the number of pyramids with base centered at above cell `(i-1, j)`, `count(i-1, j)`; how many of these extend to a larger pyramid with base centered at `(i, j)`?\\n\\nIf we denote the first count by `new(i, j)`, and the second by `old(i, j)`, we have then:\\n```\\ncount(i, j) = new(i, j) + old(i, j)\\n```\\n\\nLet\\'s tackle `new(i, j)` first, since it\\'s straight-forward. We only get this new height 2 pyramid if `grid(i, j-1) = grid(i, j + 1) = 1` (here, under the obvious assumption these horizontally adjacent cells are actually in our grid; if not, then we, of course, cannot get a height 2 pyramid). \\n\\nNow, what about `old(i, j)`, i.e. trying to extend pyramids with base centered at `(i - 1, j)` down a level? Suppose there are precisely `k` of these; how many extend down to a fertile pyramid centered at `(i, j)`? We know if one of these has height `h`, where `2 <= h <= k`, then that base consists of `2h - 1` blocks of consecutive 1\\'s, centered at cell `(i - 1, j)` (prove this via induction). So this means to extend something from height `h` with base centered at `(i-1, j)` to height `h+1` with base centered at `(i, j)`, we need a sequence of `2h + 1` consecutive 1\\'s in the `i`th row centered at `(i, j)`. Let\\'s briefly see how to determine this.\\n\\n**PREFIX AND SUFFIX COUNTS**\\nWe need `2h+1` 1\\'s in a row, centered at cell `(i, j)`. This means we need the prior `h` cells before `(i, j)` and following `h` cells after `(i, j)`\\nto be of value `1` (same row). We can easily compute this information in `O(mn)` time for later `O(1)` lookup by defined the following prefix and suffix counts:\\n```\\nprefix(i, j) = 0 if grid(i, j) = 0\\nprefix(i, j) = 1 + prefix(i - 1, j), if grid(i, j) = 1\\n\\nsuffix(i, j) = 0 if grid(i, j) = 0\\nsuffix(i, j) = 1 + suffix(i + 1, j), if grid(i, j) = 1\\n```\\nThen checking if we get `2h + 1` 1\\'s centered at `(i, j)` is the same as:\\n```\\nmin(prefix(i, j), suffix(i, j)) >= h + 1\\n```\\n\\n**RECURRENCE**\\nSo we know how to check if a height `h` fertile pyramid based at `(i-1, j)` can be extended to one of height `h+1` based at `(i, j)` using the above prefix and suffix counts. \\n\\nBut notice, if we can extend something of height `h` based at `(i-1, j)` to one of height `h+1`, then we can extend all lower height pyramids based at `(i-1, j)`; that\\'s because the requirement of consecutive 1\\'s in row `i` centered at `(i,j)` has already been met for `h`, so it\\'s met for smaller heights. Thus we need the max extendable height `H`, and then heights `2, ..., H` all extend down to row `i+1`.\\n\\nThis is easy. If we know `count(i-1, j) = k`, the max height of anything based at `(i-1, j)` is `k + 1`. But we know the max height the can be supported by base center `(i, j)` will be:\\n```\\nmin(prefix(i, j), suffix(i, j))\\n```\\nTherefore, we get that the max extendable height from row `i-1` to row `i` will be:\\n```\\nH = min(prefix(i, j) - 1, suffix(i, j) - 1, count(i-1, j) + 1)\\n```\\nand we can extend precisely `max(0, H-1)` fertile pyramids based at `(i-1, j)` to be based at `(i, j)`. So we get the following equation:\\n```\\nold(i, j) = max(0, min(prefix(i, j) - 1, suffix(i, j) - 1, count(i-1, j) + 1) - 1)\\n```\\nand finally returning to our original quantity `count(i, j)`:\\n```\\ncount(i, j) = \\nnew(i, j) + old(i, j) = \\nnew(i, j) + max(0, min(prefix(i, j) - 1, suffix(i, j) - 1, count(i-1, j) + 1) - 1)\\n```\\n\\n**PUTTING IT ALL TOGETHER**\\nOnce we know `count(i, j)` for each cell `(i, j)`, then our final result is just the sum of the results from the local problems:\\n```\\ntotal fertiel pyramids = sum_{i, j} count(i, j)\\n```\\n\\n**CODE**\\n```\\nclass Solution:\\n    def countPyramids(self, grid: List[List[int]]) -> int:\\n        m = len(grid)\\n        n = len(grid[0])\\n        \\n        \\n        def count_fertile(mat: List[List[int]]):\\n            # compute running prefix count for each row\\n            prefix = [[0] * n for i in range(m)]\\n            for i in range(m):\\n                for j in range(n):\\n                    if grid[i][j] == 0:\\n                        continue\\n                    prefix[i][j] = prefix[i][j - 1] + 1\\n            # compute running suffix count for each row\\n            suffix = [[0] * n for i in range(m)]\\n            for i in range(m):\\n                for j in range(n - 1, -1, -1):\\n                    if grid[i][j] == 0:\\n                        continue\\n                    suffix[i][j] = suffix[i][(j + 1) % n] + 1\\n            # dynamic programming\\n            count = 0\\n            dp = [[0] * n for i in range(m)]\\n            for i in range(1, m):\\n                for j in range(n):\\n                    if grid[i][j] == 0:\\n                        continue\\n                    if grid[i-1][j] == 0:\\n                        continue\\n                    # COUNT 1: can we form a new pyramid of height 2?\\n                    if min(prefix[i][j] - 1, suffix[i][j] - 1) > 0:\\n                        dp[i][j] += 1\\n                    # COUNT 2: how many existing fertile pyramids with based centered at (i-1, j) can we extend down?\\n                    H = min(dp[i-1][j] + 1, prefix[i][j] - 1, suffix[i][j] - 1)\\n                    dp[i][j] += max(H - 1, 0)\\n                    count += dp[i][j]\\n            return count\\n        \\n        \\n        # STEP 1: count fertile pyramids\\n        total = count_fertile(grid)\\n        \\n        # STEP 2: flip the pyramid in place, using two-pointer technique\\n        for j in range(n):\\n            l = 0\\n            r = m - 1\\n            while l < r:\\n                temp = grid[l][j]\\n                grid[l][j] = grid[r][j]\\n                grid[r][j] = temp\\n                l += 1\\n                r -= 1\\n                \\n        # STEP 3: count inverse fertile pyramids\\n        total += count_fertile(grid)\\n        return total\\n```\\n\\n\\n\\n",
                "solutionTags": [],
                "code": "```\\ncount(i,j) = # of fertile pyramids whose base is centered at cell (i, j)\\n```\n```\\ncount(i, j) = new(i, j) + old(i, j)\\n```\n```\\nprefix(i, j) = 0 if grid(i, j) = 0\\nprefix(i, j) = 1 + prefix(i - 1, j), if grid(i, j) = 1\\n\\nsuffix(i, j) = 0 if grid(i, j) = 0\\nsuffix(i, j) = 1 + suffix(i + 1, j), if grid(i, j) = 1\\n```\n```\\nmin(prefix(i, j), suffix(i, j)) >= h + 1\\n```\n```\\nmin(prefix(i, j), suffix(i, j))\\n```\n```\\nH = min(prefix(i, j) - 1, suffix(i, j) - 1, count(i-1, j) + 1)\\n```\n```\\nold(i, j) = max(0, min(prefix(i, j) - 1, suffix(i, j) - 1, count(i-1, j) + 1) - 1)\\n```\n```\\ncount(i, j) = \\nnew(i, j) + old(i, j) = \\nnew(i, j) + max(0, min(prefix(i, j) - 1, suffix(i, j) - 1, count(i-1, j) + 1) - 1)\\n```\n```\\ntotal fertiel pyramids = sum_{i, j} count(i, j)\\n```\n```\\nclass Solution:\\n    def countPyramids(self, grid: List[List[int]]) -> int:\\n        m = len(grid)\\n        n = len(grid[0])\\n        \\n        \\n        def count_fertile(mat: List[List[int]]):\\n            # compute running prefix count for each row\\n            prefix = [[0] * n for i in range(m)]\\n            for i in range(m):\\n                for j in range(n):\\n                    if grid[i][j] == 0:\\n                        continue\\n                    prefix[i][j] = prefix[i][j - 1] + 1\\n            # compute running suffix count for each row\\n            suffix = [[0] * n for i in range(m)]\\n            for i in range(m):\\n                for j in range(n - 1, -1, -1):\\n                    if grid[i][j] == 0:\\n                        continue\\n                    suffix[i][j] = suffix[i][(j + 1) % n] + 1\\n            # dynamic programming\\n            count = 0\\n            dp = [[0] * n for i in range(m)]\\n            for i in range(1, m):\\n                for j in range(n):\\n                    if grid[i][j] == 0:\\n                        continue\\n                    if grid[i-1][j] == 0:\\n                        continue\\n                    # COUNT 1: can we form a new pyramid of height 2?\\n                    if min(prefix[i][j] - 1, suffix[i][j] - 1) > 0:\\n                        dp[i][j] += 1\\n                    # COUNT 2: how many existing fertile pyramids with based centered at (i-1, j) can we extend down?\\n                    H = min(dp[i-1][j] + 1, prefix[i][j] - 1, suffix[i][j] - 1)\\n                    dp[i][j] += max(H - 1, 0)\\n                    count += dp[i][j]\\n            return count\\n        \\n        \\n        # STEP 1: count fertile pyramids\\n        total = count_fertile(grid)\\n        \\n        # STEP 2: flip the pyramid in place, using two-pointer technique\\n        for j in range(n):\\n            l = 0\\n            r = m - 1\\n            while l < r:\\n                temp = grid[l][j]\\n                grid[l][j] = grid[r][j]\\n                grid[r][j] = temp\\n                l += 1\\n                r -= 1\\n                \\n        # STEP 3: count inverse fertile pyramids\\n        total += count_fertile(grid)\\n        return total\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2155814,
                "title": "python-soln",
                "content": "```\\nclass Solution:\\n    def countPyramids(self, grid: List[List[int]]) -> int:\\n        m=len(grid)\\n        n=len(grid[0])\\n        \\n        dp=[[0 for j in range(n)] for i in range(m)]\\n        mx=0\\n        for i in range(m-2,-1,-1):\\n            for j in range(1,n-1):\\n                \\n                if grid[i][j]==1 and grid[i+1][j-1]==1 and grid[i+1][j]==1 and grid[i+1][j+1]==1:\\n                    \\n                    dp[i][j]=min(dp[i+1][j-1],dp[i+1][j],dp[i+1][j+1])+1\\n                    \\n                mx+=dp[i][j]\\n        \\n        dp=[[0 for j in range(n)] for i in range(m)]\\n        mx1=0\\n        for i in range(1,m):\\n            for j in range(1,n-1):\\n                \\n                if grid[i][j]==1 and grid[i-1][j-1]==1 and grid[i-1][j]==1 and grid[i-1][j+1]==1:\\n                    \\n                    dp[i][j]=min(dp[i-1][j-1],dp[i-1][j],dp[i-1][j+1])+1\\n                    \\n                mx1+=dp[i][j]\\n        return mx+mx1\\n        \\n        \\n        \\n                    \\n    \\n        \\n```",
                "solutionTags": [
                    "Python",
                    "Dynamic Programming"
                ],
                "code": "```\\nclass Solution:\\n    def countPyramids(self, grid: List[List[int]]) -> int:\\n        m=len(grid)\\n        n=len(grid[0])\\n        \\n        dp=[[0 for j in range(n)] for i in range(m)]\\n        mx=0\\n        for i in range(m-2,-1,-1):\\n            for j in range(1,n-1):\\n                \\n                if grid[i][j]==1 and grid[i+1][j-1]==1 and grid[i+1][j]==1 and grid[i+1][j+1]==1:\\n                    \\n                    dp[i][j]=min(dp[i+1][j-1],dp[i+1][j],dp[i+1][j+1])+1\\n                    \\n                mx+=dp[i][j]\\n        \\n        dp=[[0 for j in range(n)] for i in range(m)]\\n        mx1=0\\n        for i in range(1,m):\\n            for j in range(1,n-1):\\n                \\n                if grid[i][j]==1 and grid[i-1][j-1]==1 and grid[i-1][j]==1 and grid[i-1][j+1]==1:\\n                    \\n                    dp[i][j]=min(dp[i-1][j-1],dp[i-1][j],dp[i-1][j+1])+1\\n                    \\n                mx1+=dp[i][j]\\n        return mx+mx1\\n        \\n        \\n        \\n                    \\n    \\n        \\n```",
                "codeTag": "Java"
            },
            {
                "id": 2130433,
                "title": "simple-c-dp-soution-wih-comments",
                "content": "```\\nclass Solution {\\npublic:\\n    \\n    int countPyramids(vector<vector<int>>& grid){\\n        int dp[1001][1001] = {0};\\n        int n = grid.size() , m = grid[0].size();\\n        int ans = 0;\\n//         Straight Pyramids count\\n        for(int i = n-2 ; i >= 0 ; i--)\\n        {\\n            for(int j = 1 ; j < m-1 ; j++)\\n            {\\n                //Check Number of Pyramids Starting from that index\\n                if(grid[i][j] && grid[i+1][j] && grid[i+1][j+1] && grid[i+1][j-1])\\n                {\\n                    ans += min({dp[i+1][j]  , dp[i+1][j+1] , dp[i+1][j-1]});\\n                    ans++;\\n                    dp[i][j]= 1 + min({dp[i+1][j]  , dp[i+1][j+1] , dp[i+1][j-1]});\\n                }\\n            }\\n        }\\n//         Inverted Pyramids \\n        int drp[1000][1000] = {0};\\n        for(int i = 1 ; i < n ; i++)\\n        {\\n            for(int j = 1 ; j < m-1 ; j++)\\n            {\\n                //Check Number of Inverse Pyramids Starting from that index\\n                if(grid[i][j] && grid[i-1][j] && grid[i-1][j+1] && grid[i-1][j-1])\\n                {\\n                    ans += min({drp[i-1][j]  , drp[i-1][j+1] , drp[i-1][j-1]});\\n                    ans++;\\n                    drp[i][j]= 1 + min({drp[i-1][j]  , drp[i-1][j+1] , drp[i-1][j-1]});\\n                }\\n            }\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C",
                    "Dynamic Programming"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    \\n    int countPyramids(vector<vector<int>>& grid){\\n        int dp[1001][1001] = {0};\\n        int n = grid.size() , m = grid[0].size();\\n        int ans = 0;\\n//         Straight Pyramids count\\n        for(int i = n-2 ; i >= 0 ; i--)\\n        {\\n            for(int j = 1 ; j < m-1 ; j++)\\n            {\\n                //Check Number of Pyramids Starting from that index\\n                if(grid[i][j] && grid[i+1][j] && grid[i+1][j+1] && grid[i+1][j-1])\\n                {\\n                    ans += min({dp[i+1][j]  , dp[i+1][j+1] , dp[i+1][j-1]});\\n                    ans++;\\n                    dp[i][j]= 1 + min({dp[i+1][j]  , dp[i+1][j+1] , dp[i+1][j-1]});\\n                }\\n            }\\n        }\\n//         Inverted Pyramids \\n        int drp[1000][1000] = {0};\\n        for(int i = 1 ; i < n ; i++)\\n        {\\n            for(int j = 1 ; j < m-1 ; j++)\\n            {\\n                //Check Number of Inverse Pyramids Starting from that index\\n                if(grid[i][j] && grid[i-1][j] && grid[i-1][j+1] && grid[i-1][j-1])\\n                {\\n                    ans += min({drp[i-1][j]  , drp[i-1][j+1] , drp[i-1][j-1]});\\n                    ans++;\\n                    drp[i][j]= 1 + min({drp[i-1][j]  , drp[i-1][j+1] , drp[i-1][j-1]});\\n                }\\n            }\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2121032,
                "title": "c-dp-solution",
                "content": "*Time complexity: O(mn)*\\n*Space complexity: O(mn)*\\n```\\nclass Solution {\\npublic:\\n    int countPyramids(vector<vector<int>>& grid) {\\n        int n = grid.size();\\n        int m = grid[0].size();\\n        vector<vector<int>> dpPy(n, vector<int>(m,0)); // to store the number of pyramid\\n        vector<vector<int>> dpinvPy(n, vector<int>(m,0)); // to store the number of inverse pyramid\\n        //since for i = n - 1, j = 0 and j = m - 1 pyramid is not possible, i and j are taken accordingly\\n        for(int i = n-2; i>=0; i--){\\n            for(int j = 1; j<m-1; j++){\\n                if(grid[i][j] && grid[i+1][j] && grid[i+1][j-1] && grid[i+1][j+1] ) //checking for the smallest pyramid\\n                    dpPy[i][j] = 1 + min(dpPy[i+1][j-1],dpPy[i+1][j+1]);\\n            }\\n        }\\n        //since for i = 0, j = 0 and j = m - 1 inverse pyramid is not possible, i and j are taken accordingly\\n        for(int i = 1; i<n; i++){\\n            for(int j = 1; j<m-1; j++){\\n                if(grid[i][j] && grid[i-1][j] && grid[i-1][j-1] && grid[i-1][j+1] ) //checking for the smallest inverse pyramid\\n                    dpinvPy[i][j] = 1 + min(dpinvPy[i-1][j-1],dpinvPy[i-1][j+1]);\\n            }\\n        }\\n       //count the total number\\n        int count = 0;\\n        for(int i = 0 ; i<n ; i++){\\n            for(int j = 0; j<m; j++){\\n                count += (dpPy[i][j]+dpinvPy[i][j]);\\n            }\\n        }\\n        return count;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C",
                    "Dynamic Programming"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int countPyramids(vector<vector<int>>& grid) {\\n        int n = grid.size();\\n        int m = grid[0].size();\\n        vector<vector<int>> dpPy(n, vector<int>(m,0)); // to store the number of pyramid\\n        vector<vector<int>> dpinvPy(n, vector<int>(m,0)); // to store the number of inverse pyramid\\n        //since for i = n - 1, j = 0 and j = m - 1 pyramid is not possible, i and j are taken accordingly\\n        for(int i = n-2; i>=0; i--){\\n            for(int j = 1; j<m-1; j++){\\n                if(grid[i][j] && grid[i+1][j] && grid[i+1][j-1] && grid[i+1][j+1] ) //checking for the smallest pyramid\\n                    dpPy[i][j] = 1 + min(dpPy[i+1][j-1],dpPy[i+1][j+1]);\\n            }\\n        }\\n        //since for i = 0, j = 0 and j = m - 1 inverse pyramid is not possible, i and j are taken accordingly\\n        for(int i = 1; i<n; i++){\\n            for(int j = 1; j<m-1; j++){\\n                if(grid[i][j] && grid[i-1][j] && grid[i-1][j-1] && grid[i-1][j+1] ) //checking for the smallest inverse pyramid\\n                    dpinvPy[i][j] = 1 + min(dpinvPy[i-1][j-1],dpinvPy[i-1][j+1]);\\n            }\\n        }\\n       //count the total number\\n        int count = 0;\\n        for(int i = 0 ; i<n ; i++){\\n            for(int j = 0; j<m; j++){\\n                count += (dpPy[i][j]+dpinvPy[i][j]);\\n            }\\n        }\\n        return count;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2116180,
                "title": "python-8-lines-count-the-number-of-square-with-thought-process-when-being-asked-during-interviews",
                "content": "### Dynamic Programming\\nFirst of all, let\\'s simply the problem by not considering the reversed case since we can make use of the same algorithm on the reversed grid.\\nSecondly, how we can get the solution on the original grid. My first idea is that we might follow the solution resolving the maximum rectangle size, where we append each row to construct `heights`, and get the rectangle size using stack.\\nHowever, we don\\'t have further insights then. \\nAnother similar problem is that count the square where each square is constructed by smaller squares. We can treat this in similar way, each pyramid is constructed by 3 smaller pyramids.\\nFor example, `grid[i][j]` is an apex of a pyramid if only if `grid[i+1][j-1]`, `grid[i+1][j]`, and `grid[i+1][j+1]` are `1`, all of which are in turn apex of pyramids at the next row `[i+2]`.\\nSo `dp[i][j]` means the number of pyramids with apex at `grid[i][j]`. \\nWe calcualte the `dp[i][j]` when `grid[i][j]` is `1` and the number is the minimum number of pyramids of `dp[i+1][j-1], dp[i + 1][j], dp[i+1][j+1]` plus 1.\\n```\\ndp[i][j] = min(dp[i+1][j-1], dp[i+1][j], dp[i+1][j+1]) + 1\\n```\\nFinally, run the same algorithm using reversed grid.\\n\\n```python\\ndef countPyramids(self, grid: List[List[int]]) -> int:\\n\\tm, n = len(grid), len(grid[0])\\n        \\n\\tdef helper(grid):\\n\\t\\tdp = [[-1] * (n + 2) for _ in range(m + 1)] \\n\\t\\tfor i in range(m - 1, -1, -1):\\n\\t\\t\\tfor j in range(1, n + 1):\\n\\t\\t\\t\\tif grid[i][j - 1]:\\n\\t\\t\\t\\t\\tdp[i][j] = min(dp[i + 1][j - 1], dp[i + 1][j], dp[i + 1][j + 1]) + 1\\n\\t\\treturn sum(max(0, col) for row in dp for col in row)\\n\\treturn helper(grid) + helper([row[::-1] for row in grid[::-1]]) \\n```\\n\\n*Time Complexity*= **O(MN)**\\n*Space Complexity*= **O(MN)**",
                "solutionTags": [
                    "Dynamic Programming"
                ],
                "code": "```\\ndp[i][j] = min(dp[i+1][j-1], dp[i+1][j], dp[i+1][j+1]) + 1\\n```\n```python\\ndef countPyramids(self, grid: List[List[int]]) -> int:\\n\\tm, n = len(grid), len(grid[0])\\n        \\n\\tdef helper(grid):\\n\\t\\tdp = [[-1] * (n + 2) for _ in range(m + 1)] \\n\\t\\tfor i in range(m - 1, -1, -1):\\n\\t\\t\\tfor j in range(1, n + 1):\\n\\t\\t\\t\\tif grid[i][j - 1]:\\n\\t\\t\\t\\t\\tdp[i][j] = min(dp[i + 1][j - 1], dp[i + 1][j], dp[i + 1][j + 1]) + 1\\n\\t\\treturn sum(max(0, col) for row in dp for col in row)\\n\\treturn helper(grid) + helper([row[::-1] for row in grid[::-1]]) \\n```",
                "codeTag": "Python3"
            },
            {
                "id": 1991205,
                "title": "python3-2-different-solutions-with-speical-case-optimization-1-prefix-sum-2-dp",
                "content": "speical case:the grid is filled with 1, every node\\'s pyramid count is determined by min([r, c, n - 1 - c]) + min([m - 1 - r, c, n - 1 - c].\\n(1)Presum solution, O(m * n * n), accepted, 2700ms.\\n```\\nfrom itertools import product\\n\\nclass Solution:\\n    def countPyramids(self, grid: List[List[int]]) -> int:\\n        m, n = len(grid), len(grid[0])\\n        if sum(sum(row) for row in grid) == m * n:\\n            return sum(min([r, c, n - 1 - c]) + min([m - 1 - r, c, n - 1 - c]) for r, c in product(range(m), range(n)))\\n        presum = [[0] * (n + 1) for _ in range(m)]\\n        for r, c in product(range(m), range(n)): presum[r][c + 1] = presum[r][c] + grid[r][c]\\n        ans = 0\\n        for x, y in product(range(m), range(n)):\\n            if grid[x][y] == 0: continue\\n            ur, l, r = x - 1, y - 1, y + 1\\n            while ur >= 0 and l >= 0 and r < n and presum[ur][r + 1] - presum[ur][l] == r - l + 1:\\n                ans += 1\\n                ur, l, r = ur - 1, l - 1, r + 1\\n            dr, l, r = x + 1, y - 1, y + 1\\n            while dr < m and l >= 0 and r < n and presum[dr][r + 1] - presum[dr][l] == r - l + 1:\\n                ans += 1\\n                dr, l, r = dr + 1, l - 1, r + 1\\n        return ans\\n```\\n(2) two direction dp,  O(m * n),1850ms.\\n```\\nfrom functools import lru_cache\\nfrom itertools import product\\n\\nclass Solution:\\n    def countPyramids(self, grid: List[List[int]]) -> int:\\n        m, n = len(grid), len(grid[0])\\n        if sum(sum(row) for row in grid) == m * n:\\n            return sum(min([r, c, n - 1 - c]) + min([m - 1 - r, c, n - 1 - c]) for r, c in product(range(m), range(n)))\\n        @lru_cache(None)\\n        def dp(r, c, d):\\n            if d == 1 and r == m - 1 or d == -1 and r == 0 or c < 0 or c == n or grid[r][c] == 0: return 0\\n            ret = 0\\n            if grid[r + d][c]:\\n                ret = min(dp(r + d, c - 1, d), dp(r + d, c + 1, d))\\n                if 0 < c < n - 1 and grid[r + d][c - 1] and grid[r + d][c + 1]: ret += 1\\n            return ret\\n        return sum(dp(r, c, 1) + dp(r, c, -1) for r, c in product(range(m), range(n)))\\n```\\n\\n",
                "solutionTags": [],
                "code": "```\\nfrom itertools import product\\n\\nclass Solution:\\n    def countPyramids(self, grid: List[List[int]]) -> int:\\n        m, n = len(grid), len(grid[0])\\n        if sum(sum(row) for row in grid) == m * n:\\n            return sum(min([r, c, n - 1 - c]) + min([m - 1 - r, c, n - 1 - c]) for r, c in product(range(m), range(n)))\\n        presum = [[0] * (n + 1) for _ in range(m)]\\n        for r, c in product(range(m), range(n)): presum[r][c + 1] = presum[r][c] + grid[r][c]\\n        ans = 0\\n        for x, y in product(range(m), range(n)):\\n            if grid[x][y] == 0: continue\\n            ur, l, r = x - 1, y - 1, y + 1\\n            while ur >= 0 and l >= 0 and r < n and presum[ur][r + 1] - presum[ur][l] == r - l + 1:\\n                ans += 1\\n                ur, l, r = ur - 1, l - 1, r + 1\\n            dr, l, r = x + 1, y - 1, y + 1\\n            while dr < m and l >= 0 and r < n and presum[dr][r + 1] - presum[dr][l] == r - l + 1:\\n                ans += 1\\n                dr, l, r = dr + 1, l - 1, r + 1\\n        return ans\\n```\n```\\nfrom functools import lru_cache\\nfrom itertools import product\\n\\nclass Solution:\\n    def countPyramids(self, grid: List[List[int]]) -> int:\\n        m, n = len(grid), len(grid[0])\\n        if sum(sum(row) for row in grid) == m * n:\\n            return sum(min([r, c, n - 1 - c]) + min([m - 1 - r, c, n - 1 - c]) for r, c in product(range(m), range(n)))\\n        @lru_cache(None)\\n        def dp(r, c, d):\\n            if d == 1 and r == m - 1 or d == -1 and r == 0 or c < 0 or c == n or grid[r][c] == 0: return 0\\n            ret = 0\\n            if grid[r + d][c]:\\n                ret = min(dp(r + d, c - 1, d), dp(r + d, c + 1, d))\\n                if 0 < c < n - 1 and grid[r + d][c - 1] and grid[r + d][c + 1]: ret += 1\\n            return ret\\n        return sum(dp(r, c, 1) + dp(r, c, -1) for r, c in product(range(m), range(n)))\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1904076,
                "title": "c-dp-solution",
                "content": "```\\nclass Solution {\\npublic:\\n\\tint countPyramids(vector<vector<int>>& grid) {\\n\\n\\n\\t\\tint rows = grid.size(); int cols = grid[0].size();\\n\\t\\tif (rows < 2 || cols < 2) return 0;\\n\\n\\t\\tvector<vector<int>> dp(rows, vector<int> (cols, 0));\\n\\t\\tint ans = 0;\\n\\n\\n\\n\\t\\tfor (int i = rows - 2; i >= 0; i--) {\\n\\t\\t\\tfor (int j = 1; j < cols - 1; j++) {\\n\\t\\t\\t\\tif (grid[i][j] == 0) continue;\\n\\t\\t\\t\\tif (grid[i + 1][j] == 1 && grid[i + 1][j + 1] == 1 && grid[i + 1][j - 1] == 1) dp[i][j] = 1 + min(dp[i + 1][j], min(dp[i + 1][j + 1], dp[i + 1][j - 1]));\\n\\t\\t\\t\\tans += dp[i][j];\\n\\t\\t\\t}\\n\\t\\t}\\n\\n\\n\\t\\tvector<vector<int>> dp2(rows, vector<int> (cols, 0));\\n\\n\\n\\n\\t\\tfor (int i = 1; i < rows; i++) {\\n\\t\\t\\tfor (int j = 1; j < cols - 1; j++) {\\n\\t\\t\\t\\tif (grid[i][j] == 0) continue;\\n\\n\\t\\t\\t\\tif (grid[i - 1][j] == 1  && grid[i - 1][j - 1] == 1 && grid[i - 1][j + 1] == 1) {\\n\\t\\t\\t\\t\\tdp2[i][j] = 1 + min(dp2[i - 1][j + 1], min(dp2[i - 1][j - 1], dp2[i - 1][j]));\\n\\t\\t\\t\\t} ans += dp2[i][j];\\n\\t\\t\\t}\\n\\t\\t}\\n\\n\\t\\treturn ans;\\n\\n\\t}\\n};\\n```",
                "solutionTags": [
                    "Dynamic Programming"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n\\tint countPyramids(vector<vector<int>>& grid) {\\n\\n\\n\\t\\tint rows = grid.size(); int cols = grid[0].size();\\n\\t\\tif (rows < 2 || cols < 2) return 0;\\n\\n\\t\\tvector<vector<int>> dp(rows, vector<int> (cols, 0));\\n\\t\\tint ans = 0;\\n\\n\\n\\n\\t\\tfor (int i = rows - 2; i >= 0; i--) {\\n\\t\\t\\tfor (int j = 1; j < cols - 1; j++) {\\n\\t\\t\\t\\tif (grid[i][j] == 0) continue;\\n\\t\\t\\t\\tif (grid[i + 1][j] == 1 && grid[i + 1][j + 1] == 1 && grid[i + 1][j - 1] == 1) dp[i][j] = 1 + min(dp[i + 1][j], min(dp[i + 1][j + 1], dp[i + 1][j - 1]));\\n\\t\\t\\t\\tans += dp[i][j];\\n\\t\\t\\t}\\n\\t\\t}\\n\\n\\n\\t\\tvector<vector<int>> dp2(rows, vector<int> (cols, 0));\\n\\n\\n\\n\\t\\tfor (int i = 1; i < rows; i++) {\\n\\t\\t\\tfor (int j = 1; j < cols - 1; j++) {\\n\\t\\t\\t\\tif (grid[i][j] == 0) continue;\\n\\n\\t\\t\\t\\tif (grid[i - 1][j] == 1  && grid[i - 1][j - 1] == 1 && grid[i - 1][j + 1] == 1) {\\n\\t\\t\\t\\t\\tdp2[i][j] = 1 + min(dp2[i - 1][j + 1], min(dp2[i - 1][j - 1], dp2[i - 1][j]));\\n\\t\\t\\t\\t} ans += dp2[i][j];\\n\\t\\t\\t}\\n\\t\\t}\\n\\n\\t\\treturn ans;\\n\\n\\t}\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1898531,
                "title": "solution-similar-to-lc-221-lc-1277",
                "content": "This Problem is Exactly similar if not a Good Followup of [this](https://leetcode.com/problems/count-square-submatrices-with-all-ones/) Problem which in turn is a Followup of [this](https://leetcode.com/problems/maximal-square/) Problem.\\n\\nWe will essentially make 2 Iterations for both Straight & Inverse Pyramids & to find whether a Pyramid can be formed at the following Cell. \\nTo Check if we can form a Pyramid we would check if the **Top 3 cells** are all 1s -> `grid[i+1][j] == 1 && grid[i+1][j+1] == 1 && grid[i+1][j-1] == 1` for ***Inverse Pyramid*** & **Bottom 3 cells** are all 1s -> `grid[i-1][j] == 1 && grid[i-1][j+1] == 1 && grid[i-1][j-1] == 1` for ***Straight Pyramid***.\\n\\nWell if you have solved **[221. Maximal Square](https://leetcode.com/problems/maximal-square/)** and **[1277. Count Square Submatrices with All Ones](https://leetcode.com/problems/count-square-submatrices-with-all-ones/)** we can spot on how we would calculate on How Many Squares we are Building from the 3 cells (Top, Top Left & Left). This is a Similar Strategy we are using here.\\n\\n\\n```\\nclass Solution {\\n    public int countPyramids(int[][] grid) {\\n        int row = grid.length;\\n        int col = grid[0].length;\\n        \\n        int[][] dp = new int[row][col];\\n        int[][] dp2 = new int[row][col];\\n        \\n        int total = 0;\\n        // for solving Straight Pyramid\\n        for(int i = row - 2; i > -1; i--)\\n        {\\n            for(int j = 1; j < col - 1; j++)\\n            {\\n                if(grid[i][j] == 1 && grid[i+1][j] == 1 && grid[i+1][j+1] == 1 && grid[i+1][j-1] == 1)\\n                {\\n                    dp[i][j] = Math.min(dp[i+1][j], Math.min(dp[i+1][j+1], dp[i+1][j-1])) + 1;\\n                    total += dp[i][j];\\n                }   \\n            }\\n        }\\n        // for Solving Inverse Pyramid\\n        for(int i = 1; i < row; i++)\\n        {\\n            for(int j = 1; j < col-1; j++)\\n            {\\n                if(grid[i][j] == 1 && grid[i-1][j] == 1 && grid[i-1][j+1] == 1 && grid[i-1][j-1] == 1)\\n                {\\n                    dp2[i][j] = Math.min(dp2[i-1][j], Math.min(dp2[i-1][j+1], dp2[i-1][j-1])) + 1;\\n                    total += dp2[i][j];\\n                }\\n            }\\n        }\\n        \\n        return total;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Dynamic Programming"
                ],
                "code": "```\\nclass Solution {\\n    public int countPyramids(int[][] grid) {\\n        int row = grid.length;\\n        int col = grid[0].length;\\n        \\n        int[][] dp = new int[row][col];\\n        int[][] dp2 = new int[row][col];\\n        \\n        int total = 0;\\n        // for solving Straight Pyramid\\n        for(int i = row - 2; i > -1; i--)\\n        {\\n            for(int j = 1; j < col - 1; j++)\\n            {\\n                if(grid[i][j] == 1 && grid[i+1][j] == 1 && grid[i+1][j+1] == 1 && grid[i+1][j-1] == 1)\\n                {\\n                    dp[i][j] = Math.min(dp[i+1][j], Math.min(dp[i+1][j+1], dp[i+1][j-1])) + 1;\\n                    total += dp[i][j];\\n                }   \\n            }\\n        }\\n        // for Solving Inverse Pyramid\\n        for(int i = 1; i < row; i++)\\n        {\\n            for(int j = 1; j < col-1; j++)\\n            {\\n                if(grid[i][j] == 1 && grid[i-1][j] == 1 && grid[i-1][j+1] == 1 && grid[i-1][j-1] == 1)\\n                {\\n                    dp2[i][j] = Math.min(dp2[i-1][j], Math.min(dp2[i-1][j+1], dp2[i-1][j-1])) + 1;\\n                    total += dp2[i][j];\\n                }\\n            }\\n        }\\n        \\n        return total;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1749331,
                "title": "share-my-c-solution",
                "content": "```\\nclass Solution {\\npublic:\\n    int countPyramids(vector<vector<int>>& grid) {\\n        int row = grid.size();\\n        int col = grid[0].size();\\n        int res = 0;\\n        int* arr = new int[row * col];\\n        \\n        auto getMin = [](int a, int b, int c) {\\n            return min(a, min(b, c));\\n        };\\n        \\n\\t\\t// Count inverse pyramidal plot\\n        for(int i = 0; i < row; i++) {\\n            for(int j = 0; j < col ; j++) {\\n                if(!i) {*(arr + i * col + j) = grid[i][j]; continue;}\\n                if(grid[i][j] == 0) {*(arr + i * col + j) = 0; continue;}\\n\\n                int left = j > 0 ? *(arr + (i - 1) * col + (j - 1)) : 0;\\n                int up = *(arr + (i - 1) * col + j);\\n                int right = j < col - 1 ? *(arr + (i - 1) * col + (j + 1)) : 0;\\n\\n                int value = getMin(left, up, right);\\n                res += value;\\n                *(arr + i * col + j) = value + 1;\\n            }\\n        }\\n        \\n\\t\\t// Do the opposite way to get pyramidal plot\\n        for(int i = row - 1; i >= 0; i--) {\\n            for(int j = 0; j < col ; j++) {\\n                if(i == row - 1) {*(arr + i * col + j) = grid[i][j]; continue;}\\n                if(grid[i][j] == 0) {*(arr + i * col + j) = 0; continue;}\\n\\n                int left = j > 0 ? *(arr + (i + 1) * col + (j - 1)) : 0;\\n                int up = *(arr + (i + 1) * col + j);\\n                int right = j < col - 1 ? *(arr + (i + 1) * col + (j + 1)) : 0;\\n\\n                int value = getMin(left, up, right);\\n                res += value;\\n                *(arr + i * col + j) = value + 1;\\n            }\\n        }\\n        \\n        return res;\\n    }\\n};",
                "solutionTags": [
                    "Prefix Sum"
                ],
                "code": "class Solution {\\npublic:\\n    int countPyramids(vector<vector<int>>& grid) {\\n        int row = grid.size();\\n        int col = grid[0].size();\\n        int res = 0;\\n        int* arr = new int[row * col];\\n        \\n        auto getMin = [](int a, int b, int c) {\\n            return min(a, min(b, c));\\n        }",
                "codeTag": "Java"
            },
            {
                "id": 1719959,
                "title": "java-brute-force-o-m-2-n-time-o-1-space",
                "content": "1. Update the grid, and store the count of the continuous 1s from left. E.g.\\n(1 0 1 1) to (1 0 1 2), (1 1 1 1) to (1 2 3 4)\\n2. The 2 inner loops are count for the up pyramids and the down pyramids.\\n3. Retrieve all cells one by on as the apex of the pyramids.\\n```\\n    public int countPyramids(int[][] grid) {\\n    \\tint m = grid.length, n = grid[0].length, res = 0;\\n    \\tfor (int i = 0; i < m; i++)\\n        \\tfor (int j = 1; j < n; j++)\\n        \\t\\tif (grid[i][j] == 1)\\n        \\t\\t\\tgrid[i][j] = grid[i][j - 1] + 1;\\n        for (int r = 0; r < m; r++)\\n        \\tfor (int c = 1; c < n; c++)\\n        \\t\\tif (grid[r][c] > 0) {\\n                \\tfor (int d = r + 1, left = c - 1, right = c + 1; left >= 0 && right < n && d < m && grid[d][left] > 0 && grid[d][right] - grid[d][left] >= 2 * (d - r); d++, left--, right++)\\n                \\t\\t\\tres++;\\n                \\tfor (int u = r - 1, left = c - 1, right = c + 1; left >= 0 && right < n && u >= 0 && grid[u][left] > 0 && grid[u][right] - grid[u][left] >= 2 * (r - u); u--, left--, right++)\\n                \\t\\t\\tres++;\\n                }\\n        return res;\\n    }\\n",
                "solutionTags": [
                    "Java"
                ],
                "code": "1. Update the grid, and store the count of the continuous 1s from left. E.g.\\n(1 0 1 1) to (1 0 1 2), (1 1 1 1) to (1 2 3 4)\\n2. The 2 inner loops are count for the up pyramids and the down pyramids.\\n3. Retrieve all cells one by on as the apex of the pyramids.\\n```\\n    public int countPyramids(int[][] grid) {\\n    \\tint m = grid.length, n = grid[0].length, res = 0;\\n    \\tfor (int i = 0; i < m; i++)\\n        \\tfor (int j = 1; j < n; j++)\\n        \\t\\tif (grid[i][j] == 1)\\n        \\t\\t\\tgrid[i][j] = grid[i][j - 1] + 1;\\n        for (int r = 0; r < m; r++)\\n        \\tfor (int c = 1; c < n; c++)\\n        \\t\\tif (grid[r][c] > 0) {\\n                \\tfor (int d = r + 1, left = c - 1, right = c + 1; left >= 0 && right < n && d < m && grid[d][left] > 0 && grid[d][right] - grid[d][left] >= 2 * (d - r); d++, left--, right++)\\n                \\t\\t\\tres++;\\n                \\tfor (int u = r - 1, left = c - 1, right = c + 1; left >= 0 && right < n && u >= 0 && grid[u][left] > 0 && grid[u][right] - grid[u][left] >= 2 * (r - u); u--, left--, right++)\\n                \\t\\t\\tres++;\\n                }\\n        return res;\\n    }\\n",
                "codeTag": "Unknown"
            },
            {
                "id": 1713231,
                "title": "javascript-dynamic-programming",
                "content": "```\\nvar countPyramids = function(grid) {\\n    const m = grid.length, n = grid[0].length;\\n\\n    var count = (pyramidBase) => {\\n        let totalPyramids = 0;\\n        \\n        for (let i = 1; i < m; i++) {\\n            for (let j = 0, base = 1; j < n; j++, base++) {\\n                if (pyramidBase[i][j] === 0) {\\n                    base = 0;\\n                    continue;\\n                }\\n\\n\\t\\t\\t\\t//   pyramidBase[i][j] = largest valid pyramid base that ends at (i, j) cell\\n\\n                if (pyramidBase[i - 1][j - 1])\\n                    pyramidBase[i][j] = Math.min(pyramidBase[i - 1][j - 1] + 2, (base - 1) | 1);\\n\\n                totalPyramids += pyramidBase[i][j] >> 1;\\n            }\\n        }\\n\\n        return totalPyramids;\\n    }\\n\\n    const pyramid = JSON.parse(JSON.stringify(grid)), inversePyramid = grid.reverse();\\n    const pyramidsCount = count(pyramid);\\n    const inversePyramidsCount = count(inversePyramid);\\n\\n    return pyramidsCount + inversePyramidsCount;\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nvar countPyramids = function(grid) {\\n    const m = grid.length, n = grid[0].length;\\n\\n    var count = (pyramidBase) => {\\n        let totalPyramids = 0;\\n        \\n        for (let i = 1; i < m; i++) {\\n            for (let j = 0, base = 1; j < n; j++, base++) {\\n                if (pyramidBase[i][j] === 0) {\\n                    base = 0;\\n                    continue;\\n                }\\n\\n\\t\\t\\t\\t//   pyramidBase[i][j] = largest valid pyramid base that ends at (i, j) cell\\n\\n                if (pyramidBase[i - 1][j - 1])\\n                    pyramidBase[i][j] = Math.min(pyramidBase[i - 1][j - 1] + 2, (base - 1) | 1);\\n\\n                totalPyramids += pyramidBase[i][j] >> 1;\\n            }\\n        }\\n\\n        return totalPyramids;\\n    }\\n\\n    const pyramid = JSON.parse(JSON.stringify(grid)), inversePyramid = grid.reverse();\\n    const pyramidsCount = count(pyramid);\\n    const inversePyramidsCount = count(inversePyramid);\\n\\n    return pyramidsCount + inversePyramidsCount;\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1712829,
                "title": "java-solution",
                "content": "```\\nclass Solution {\\n    \\n     int cnt(int[][] pref , int[][] grid , int diff)\\n    {\\n        \\n         int n = pref.length;\\n         int m = pref[0].length , ans = 0;\\n        \\n         for(int i=0;i<n;i++){\\n             for(int j=0;j<m;j++){\\n                 \\n                 if(grid[i][j]!=0)\\n                 {\\n                     int pi = i+diff ,  pjr = j+1 ,pjl = j-1 , cnt1 = 3;\\n                     while(pi>=0 && pi<n && pjl>=0 && pjr<m)\\n                     {\\n                        \\n                         int currdiff = grid[pi][pjl]==0 ? (pref[pi][pjr]-pref[pi][pjl]) : (pref[pi][pjr]-pref[pi][pjl]+1);\\n                         \\n                         if(currdiff==cnt1)\\n                         {\\n                             ans++;\\n                         }\\n                         else\\n                         {\\n                             break;\\n                         }\\n                         \\n                         \\n                         pi += diff;\\n                         pjl -= 1;\\n                         pjr += 1;\\n                         cnt1 += 2;\\n                         \\n                     }\\n                 }\\n                 \\n             }\\n         }\\n        \\n        return ans;\\n    }\\n    \\n    \\n    public int countPyramids(int[][] grid) {\\n        \\n        \\n        int n = grid.length;\\n        int m = grid[0].length;\\n        \\n         int[][] pref = new int[n][m];\\n        \\n        for(int i=0;i<n;i++)\\n        {\\n            for(int j=0;j<m;j++)\\n            {\\n                pref[i][j] = grid[i][j];\\n            }\\n            \\n        }\\n        \\n        for(int i=0;i<n;i++)\\n        {\\n            for(int j=1;j<m;j++)\\n            {\\n                pref[i][j] += pref[i][j-1];\\n            }\\n            \\n        }\\n        return cnt(pref ,grid ,  1) + cnt(pref , grid, -1);  // diff = 1 for pyramid and diff = -1 for inverse pyramid\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    \\n     int cnt(int[][] pref , int[][] grid , int diff)\\n    {\\n        \\n         int n = pref.length;\\n         int m = pref[0].length , ans = 0;\\n        \\n         for(int i=0;i<n;i++){\\n             for(int j=0;j<m;j++){\\n                 \\n                 if(grid[i][j]!=0)\\n                 {\\n                     int pi = i+diff ,  pjr = j+1 ,pjl = j-1 , cnt1 = 3;\\n                     while(pi>=0 && pi<n && pjl>=0 && pjr<m)\\n                     {\\n                        \\n                         int currdiff = grid[pi][pjl]==0 ? (pref[pi][pjr]-pref[pi][pjl]) : (pref[pi][pjr]-pref[pi][pjl]+1);\\n                         \\n                         if(currdiff==cnt1)\\n                         {\\n                             ans++;\\n                         }\\n                         else\\n                         {\\n                             break;\\n                         }\\n                         \\n                         \\n                         pi += diff;\\n                         pjl -= 1;\\n                         pjr += 1;\\n                         cnt1 += 2;\\n                         \\n                     }\\n                 }\\n                 \\n             }\\n         }\\n        \\n        return ans;\\n    }\\n    \\n    \\n    public int countPyramids(int[][] grid) {\\n        \\n        \\n        int n = grid.length;\\n        int m = grid[0].length;\\n        \\n         int[][] pref = new int[n][m];\\n        \\n        for(int i=0;i<n;i++)\\n        {\\n            for(int j=0;j<m;j++)\\n            {\\n                pref[i][j] = grid[i][j];\\n            }\\n            \\n        }\\n        \\n        for(int i=0;i<n;i++)\\n        {\\n            for(int j=1;j<m;j++)\\n            {\\n                pref[i][j] += pref[i][j-1];\\n            }\\n            \\n        }\\n        return cnt(pref ,grid ,  1) + cnt(pref , grid, -1);  // diff = 1 for pyramid and diff = -1 for inverse pyramid\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1665290,
                "title": "c-dp-similar-to-221-maximal-square",
                "content": "```\\nclass Solution {\\npublic:\\n    \\n    int solve(vector<vector<int>> &grid){\\n        int n = grid.size(), m = grid[0].size();\\n        vector<vector<int>> dp(n, vector<int>(m, INT_MAX));\\n        \\n        for(int j = m - 1; j >= 0; j--){\\n            dp[n - 1][j] = 0;\\n        }\\n        int res = 0;\\n        for(int i = n - 2; i >= 0; i--){\\n            for(int j = m - 1; j >= 0; j--){\\n                bool pyr = (i + 1 < n && j + 1 < m && j - 1 >= 0 && grid[i][j] == 1 && grid[i + 1][j] == 1 && grid[i + 1][j + 1] == 1 && grid[i + 1][j - 1] == 1);\\n                if(pyr){\\n                    dp[i][j] = min({dp[i + 1][j], dp[i + 1][j + 1], dp[i + 1][j - 1]}) + 1;\\n                }\\n                else{\\n                    dp[i][j] = 0;\\n                }\\n                res += dp[i][j];\\n            }\\n        }\\n        return res;\\n    }\\n    \\n    int countPyramids(vector<vector<int>>& grid) {\\n        int res = 0;\\n        res += solve(grid);\\n        reverse(grid.begin(), grid.end());\\n        res += solve(grid);\\n        return res;\\n    }   \\n};\\n```",
                "solutionTags": [
                    "Dynamic Programming"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    \\n    int solve(vector<vector<int>> &grid){\\n        int n = grid.size(), m = grid[0].size();\\n        vector<vector<int>> dp(n, vector<int>(m, INT_MAX));\\n        \\n        for(int j = m - 1; j >= 0; j--){\\n            dp[n - 1][j] = 0;\\n        }\\n        int res = 0;\\n        for(int i = n - 2; i >= 0; i--){\\n            for(int j = m - 1; j >= 0; j--){\\n                bool pyr = (i + 1 < n && j + 1 < m && j - 1 >= 0 && grid[i][j] == 1 && grid[i + 1][j] == 1 && grid[i + 1][j + 1] == 1 && grid[i + 1][j - 1] == 1);\\n                if(pyr){\\n                    dp[i][j] = min({dp[i + 1][j], dp[i + 1][j + 1], dp[i + 1][j - 1]}) + 1;\\n                }\\n                else{\\n                    dp[i][j] = 0;\\n                }\\n                res += dp[i][j];\\n            }\\n        }\\n        return res;\\n    }\\n    \\n    int countPyramids(vector<vector<int>>& grid) {\\n        int res = 0;\\n        res += solve(grid);\\n        reverse(grid.begin(), grid.end());\\n        res += solve(grid);\\n        return res;\\n    }   \\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1633421,
                "title": "pythoe-dp-o-mn-with-explanation",
                "content": "Idea1 : If the height of a pyramidal is \\'h\\' at (r,c), then it\\'s top must be \\'1\\' and there are three pyramidal with height \\'h-1\\' at (r-1,c-1), (r-1,c), (r-1,c+1).\\nIdea2 : A pyramidal with hieght = \\'h\\' at (r,c)  contains height range(2, h) at (r,c)\\n\\nGo though the gird from top to bottom and bottom to top, and count the total number of pyramidal.\\n\\n```\\nclass Solution:\\n    def countPyramids(self, grid: List[List[int]]) -> int:\\n        m,n = len(grid),len(grid[0])\\n        dpU = [ [ grid[i][j] for j in range(n)] for i in range(m)]\\n        dpD = [ [ grid[i][j] for j in range(n)] for i in range(m)]\\n        res = 0\\n        for r in range(1,m):\\n            for c in range(1,n-1):\\n                if grid[r][c] == 1:\\n                    dpD[r][c] = min([dpD[r-1][c-1],dpD[r-1][c],dpD[r-1][c+1]]) + 1\\n                    res += dpD[r][c] - 1\\n                if grid[~r][c] == 1:\\n                    dpU[~r][c] = min([dpU[~(r-1)][c-1],dpU[~(r-1)][c],dpU[~(r-1)][c+1]]) + 1\\n                    res += dpU[~r][c] - 1\\n        return res\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution:\\n    def countPyramids(self, grid: List[List[int]]) -> int:\\n        m,n = len(grid),len(grid[0])\\n        dpU = [ [ grid[i][j] for j in range(n)] for i in range(m)]\\n        dpD = [ [ grid[i][j] for j in range(n)] for i in range(m)]\\n        res = 0\\n        for r in range(1,m):\\n            for c in range(1,n-1):\\n                if grid[r][c] == 1:\\n                    dpD[r][c] = min([dpD[r-1][c-1],dpD[r-1][c],dpD[r-1][c+1]]) + 1\\n                    res += dpD[r][c] - 1\\n                if grid[~r][c] == 1:\\n                    dpU[~r][c] = min([dpU[~(r-1)][c-1],dpU[~(r-1)][c],dpU[~(r-1)][c+1]]) + 1\\n                    res += dpU[~r][c] - 1\\n        return res\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1631252,
                "title": "java-accepted-without-dp",
                "content": "```\\n    public int countPyramids(int[][] grid) {\\n        int m = grid.length;\\n        int n = grid[0].length;\\n        \\n        for(int i = 0; i < m; i++) {\\n            for(int j = 1; j < n; j++) {\\n                if (grid[i][j] != 0)\\n                    grid[i][j] = grid[i][j-1]+1;\\n            }\\n        }\\n        \\n        int count = 0;\\n        \\n        for(int r = 0; r < m-1; r++) {\\n            for(int c = 1; c < n-1; c++) {\\n                if (grid[r][c] != 0) {\\n                    int maxHeight = m-r;\\n                    for (int h = 2; h <= maxHeight; h++) {\\n                        int i = r+h-1;\\n                        int left = c - (i - r);\\n                        int right = c + (i - r);\\n                        if (withinLand(left, right, n) &&\\n                                (grid[i][left] != 0 && grid[i][right]-grid[i][left] == right-left)) {\\n                            count++;\\n                        } else {\\n                            break;\\n                        }\\n                    }\\n                }\\n            }\\n        }\\n        \\n        for(int r = m-1; r > 0; r--) {\\n            for(int c = 1; c < n-1; c++) {\\n                if (grid[r][c] != 0) {\\n                    int maxHeight = r+1;\\n                    for (int h = 2; h <= maxHeight; h++) {\\n                        int i = r-h+1;\\n                        int left = c - (r - i);\\n                        int right = c + (r - i);\\n                        if (withinLand(left, right, n) &&\\n                                (grid[i][left] != 0 && grid[i][right]-grid[i][left] == right-left)) {\\n                            count++;\\n                        } else {\\n                            break;\\n                        }\\n                    }\\n                }\\n            }\\n        }\\n        \\n        return count;\\n    }\\n    \\n    private boolean withinLand(int l, int r, int n) {\\n        return l >= 0 && r < n;\\n    }",
                "solutionTags": [],
                "code": "```\\n    public int countPyramids(int[][] grid) {\\n        int m = grid.length;\\n        int n = grid[0].length;\\n        \\n        for(int i = 0; i < m; i++) {\\n            for(int j = 1; j < n; j++) {\\n                if (grid[i][j] != 0)\\n                    grid[i][j] = grid[i][j-1]+1;\\n            }\\n        }\\n        \\n        int count = 0;\\n        \\n        for(int r = 0; r < m-1; r++) {\\n            for(int c = 1; c < n-1; c++) {\\n                if (grid[r][c] != 0) {\\n                    int maxHeight = m-r;\\n                    for (int h = 2; h <= maxHeight; h++) {\\n                        int i = r+h-1;\\n                        int left = c - (i - r);\\n                        int right = c + (i - r);\\n                        if (withinLand(left, right, n) &&\\n                                (grid[i][left] != 0 && grid[i][right]-grid[i][left] == right-left)) {\\n                            count++;\\n                        } else {\\n                            break;\\n                        }\\n                    }\\n                }\\n            }\\n        }\\n        \\n        for(int r = m-1; r > 0; r--) {\\n            for(int c = 1; c < n-1; c++) {\\n                if (grid[r][c] != 0) {\\n                    int maxHeight = r+1;\\n                    for (int h = 2; h <= maxHeight; h++) {\\n                        int i = r-h+1;\\n                        int left = c - (r - i);\\n                        int right = c + (r - i);\\n                        if (withinLand(left, right, n) &&\\n                                (grid[i][left] != 0 && grid[i][right]-grid[i][left] == right-left)) {\\n                            count++;\\n                        } else {\\n                            break;\\n                        }\\n                    }\\n                }\\n            }\\n        }\\n        \\n        return count;\\n    }\\n    \\n    private boolean withinLand(int l, int r, int n) {\\n        return l >= 0 && r < n;\\n    }",
                "codeTag": "Unknown"
            },
            {
                "id": 1620333,
                "title": "c-3-solution",
                "content": "Iterative\\n```\\npublic class Solution {\\n    public int CountPyramids(int[][] g) {\\n        int r = 0;\\n        for (int i = 0; i < g.Length; ++i) {\\n            for (int j = 1; j < g[0].Length - 1; ++j) {\\n                if (g[i][j] == 1) {\\n                    r += ValidPyramid(g, i, j);\\n                    r += ValidInvertedPyramid(g, i, j);\\n                }\\n            }\\n        }\\n        return r;\\n    }\\n    \\n    public int ValidPyramid(int[][] g, int r, int c) {\\n        int h = 1, i = r, j1 = c, j2 = c, res = 0;\\n        while (true) {\\n            if ((i < g.Length && j1 >= 0 && j2 < g[0].Length) && i + 1 < g.Length && j1 - 1 >= 0 && j2 + 1 < g[0].Length && g[i + 1][j1 - 1] == 1 && g[i + 1][j2 + 1] == 1) { \\n                i++;\\n                j1--;\\n                j2++;\\n            } else {\\n                break;\\n            }\\n            \\n            if (ValidBelly(g, i, j1, j2)) {\\n                h++;\\n                res++;\\n            } else {\\n                break;\\n            }\\n        }\\n        \\n        return res;\\n    }\\n    \\n    public int ValidInvertedPyramid(int[][] g, int r, int c) {\\n        int h = 1, i = r, j1 = c, j2 = c, res = 0;\\n        while (true) {\\n            if ((i >= 0 && j1 >= 0 && j2 < g[0].Length) && i - 1 >= 0 && j1 - 1 >= 0 && j2 + 1 < g[0].Length && g[i - 1][j1 - 1] == 1 && g[i - 1][j2 + 1] == 1) {\\n                i--;\\n                j1--;\\n                j2++;\\n            } else {\\n                break;\\n            }\\n            \\n            if (ValidBelly(g, i, j1, j2)) {\\n                h++;\\n                res++;\\n            } else {\\n                break;\\n            }\\n        }\\n        \\n        return res;\\n    }\\n    \\n    public bool ValidBelly(int[][] g, int i, int l, int r) {\\n        while (l <= r) {\\n            if (g[i][l++] != 1 || g[i][r--] != 1) {\\n                return false;\\n            }\\n        }\\n                \\n        return true;\\n    }\\n}\\n```\\n\\nPrefix Sum\\n```\\npublic class Solution {\\n    public int CountPyramids(int[][] g) {\\n        int rows = g.Length, cols = g[0].Length, res = 0;\\n        for (int i = 0; i < rows; ++i)\\n            for (int j = 1; j < cols; ++j)\\n                if (g[i][j] == 1)\\n                    g[i][j] += g[i][j - 1];\\n        \\n        for (int i = 0; i < rows; ++i) {\\n            for (int j = 1; j < cols - 1; ++j) {\\n                if (g[i][j] != 0) {\\n                    int r = i, c = j, b = 1;\\n                    while (r + 1 < rows && c + 1 < cols && g[r + 1][c + 1] >= b + 2) {\\n                        r++;\\n                        c++;\\n                        res++;\\n                        b += 2;\\n                    }\\n\\n                    r = i;\\n                    c = j;\\n                    b = 1;\\n                    while (r - 1 >= 0 && c + 1 < cols && g[r - 1][c + 1] >= b + 2) {\\n                        r--;\\n                        c++;\\n                        res++;\\n                        b += 2;\\n                    }\\n                }\\n            }\\n        }\\n        \\n        return res;\\n    }\\n}\\n```\\n\\nDP\\n```\\npublic class Solution {\\n    public int CountPyramids(int[][] g) {\\n        int r = 0;\\n        \\n        r += CountPyramid(g);\\n        \\n        for (int i = 0; i < g.Length; ++i) {\\n            for (int j = 0; j < g[0].Length; ++j) {\\n                if (g[i][j] > 0) g[i][j] = 1;\\n            }\\n        }\\n        \\n        // Flip Multidimensional Array\\n        for (int i = 0, j = g.Length - 1; i <= j; i++, j--) {\\n            for (int k = 0; k < g[i].Length; ++k) {\\n                int t = g[i][k];\\n                g[i][k] = g[j][k];\\n                g[j][k] = t;\\n            }\\n        }\\n        \\n        r += CountPyramid(g);\\n        \\n        return r;\\n    }\\n    \\n    // Search for pyramids upside down for easier coding\\n    public int CountPyramid(int[][] g) {\\n        int rows = g.Length, cols = g[0].Length, res = 0;\\n        \\n        for (int i = 1; i < rows; ++i) {\\n            for (int j = 1; j < cols - 1; ++j) {\\n                if (g[i][j] != 0 && g[i - 1][j] != 0) {\\n                    g[i][j] = Math.Min(g[i - 1][j - 1], g[i - 1][j + 1]) + 1;\\n                    res += g[i][j] - 1;\\n                }\\n            }\\n        }\\n        \\n        return res;\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\npublic class Solution {\\n    public int CountPyramids(int[][] g) {\\n        int r = 0;\\n        for (int i = 0; i < g.Length; ++i) {\\n            for (int j = 1; j < g[0].Length - 1; ++j) {\\n                if (g[i][j] == 1) {\\n                    r += ValidPyramid(g, i, j);\\n                    r += ValidInvertedPyramid(g, i, j);\\n                }\\n            }\\n        }\\n        return r;\\n    }\\n    \\n    public int ValidPyramid(int[][] g, int r, int c) {\\n        int h = 1, i = r, j1 = c, j2 = c, res = 0;\\n        while (true) {\\n            if ((i < g.Length && j1 >= 0 && j2 < g[0].Length) && i + 1 < g.Length && j1 - 1 >= 0 && j2 + 1 < g[0].Length && g[i + 1][j1 - 1] == 1 && g[i + 1][j2 + 1] == 1) { \\n                i++;\\n                j1--;\\n                j2++;\\n            } else {\\n                break;\\n            }\\n            \\n            if (ValidBelly(g, i, j1, j2)) {\\n                h++;\\n                res++;\\n            } else {\\n                break;\\n            }\\n        }\\n        \\n        return res;\\n    }\\n    \\n    public int ValidInvertedPyramid(int[][] g, int r, int c) {\\n        int h = 1, i = r, j1 = c, j2 = c, res = 0;\\n        while (true) {\\n            if ((i >= 0 && j1 >= 0 && j2 < g[0].Length) && i - 1 >= 0 && j1 - 1 >= 0 && j2 + 1 < g[0].Length && g[i - 1][j1 - 1] == 1 && g[i - 1][j2 + 1] == 1) {\\n                i--;\\n                j1--;\\n                j2++;\\n            } else {\\n                break;\\n            }\\n            \\n            if (ValidBelly(g, i, j1, j2)) {\\n                h++;\\n                res++;\\n            } else {\\n                break;\\n            }\\n        }\\n        \\n        return res;\\n    }\\n    \\n    public bool ValidBelly(int[][] g, int i, int l, int r) {\\n        while (l <= r) {\\n            if (g[i][l++] != 1 || g[i][r--] != 1) {\\n                return false;\\n            }\\n        }\\n                \\n        return true;\\n    }\\n}\\n```\n```\\npublic class Solution {\\n    public int CountPyramids(int[][] g) {\\n        int rows = g.Length, cols = g[0].Length, res = 0;\\n        for (int i = 0; i < rows; ++i)\\n            for (int j = 1; j < cols; ++j)\\n                if (g[i][j] == 1)\\n                    g[i][j] += g[i][j - 1];\\n        \\n        for (int i = 0; i < rows; ++i) {\\n            for (int j = 1; j < cols - 1; ++j) {\\n                if (g[i][j] != 0) {\\n                    int r = i, c = j, b = 1;\\n                    while (r + 1 < rows && c + 1 < cols && g[r + 1][c + 1] >= b + 2) {\\n                        r++;\\n                        c++;\\n                        res++;\\n                        b += 2;\\n                    }\\n\\n                    r = i;\\n                    c = j;\\n                    b = 1;\\n                    while (r - 1 >= 0 && c + 1 < cols && g[r - 1][c + 1] >= b + 2) {\\n                        r--;\\n                        c++;\\n                        res++;\\n                        b += 2;\\n                    }\\n                }\\n            }\\n        }\\n        \\n        return res;\\n    }\\n}\\n```\n```\\npublic class Solution {\\n    public int CountPyramids(int[][] g) {\\n        int r = 0;\\n        \\n        r += CountPyramid(g);\\n        \\n        for (int i = 0; i < g.Length; ++i) {\\n            for (int j = 0; j < g[0].Length; ++j) {\\n                if (g[i][j] > 0) g[i][j] = 1;\\n            }\\n        }\\n        \\n        // Flip Multidimensional Array\\n        for (int i = 0, j = g.Length - 1; i <= j; i++, j--) {\\n            for (int k = 0; k < g[i].Length; ++k) {\\n                int t = g[i][k];\\n                g[i][k] = g[j][k];\\n                g[j][k] = t;\\n            }\\n        }\\n        \\n        r += CountPyramid(g);\\n        \\n        return r;\\n    }\\n    \\n    // Search for pyramids upside down for easier coding\\n    public int CountPyramid(int[][] g) {\\n        int rows = g.Length, cols = g[0].Length, res = 0;\\n        \\n        for (int i = 1; i < rows; ++i) {\\n            for (int j = 1; j < cols - 1; ++j) {\\n                if (g[i][j] != 0 && g[i - 1][j] != 0) {\\n                    g[i][j] = Math.Min(g[i - 1][j - 1], g[i - 1][j + 1]) + 1;\\n                    res += g[i][j] - 1;\\n                }\\n            }\\n        }\\n        \\n        return res;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1618688,
                "title": "java-count-forward-pyramids-dp-binary-search-o-m-n-log-n",
                "content": "The idea is to count forward pyramids, each pyramid is formed by what is above it, and its base line row. Suppose we use dp[i][j] to record the pyramid scale centering at i,j location, then dp[i+1][j] would be computed by checking if the baseline bar at i+1 row is long enough to formulate a bigger pyramid, or rather, it is smaller than desired, so the pyramid scale has to decrease. In order to check how many continuous 1s we can find on the baseline bar, we can use prefix sum to quickly compute number of 1\\'s between a range [left, right]. To find the exact range where everything in it are ones, we can rely on binary search: if current [left, right] gives all ones, we can expand it; Else we must shrink it.\\n\\nThe overall space complexity is O(mn) and time complexity is O(mn log n). A slight improvement on naive DP solution, but I would say the optimal solution is to [compute reverse pyramids](https://leetcode.com/problems/count-fertile-pyramids-in-a-land/discuss/1598908/Simple-DP-Solution-with-Explanation-or-C%2B%2B-or-O(n-*-m)).\\n\\nAnyways, code is here.\\n```\\nclass Solution {\\n    int m, n;\\n    \\n    public int countPyramids(int[][] grid) {\\n        m = grid.length;\\n        n = grid[0].length;\\n        int[][] pref = prefixSum(grid); \\n        \\n        int res = 0;\\n        res += coreFunc(grid, pref);\\n        \\n        // reverse\\n        for (int i = 0; i < (m/2); i++) {\\n            int[] tmp = grid[i];\\n            grid[i] = grid[m - 1 - i];\\n            grid[m - 1 - i] = tmp;\\n            \\n            tmp = pref[i];\\n            pref[i] = pref[m - 1 - i];\\n            pref[m - 1 - i] = tmp;\\n        }\\n        \\n        res += coreFunc(grid, pref);\\n        return res;\\n    }\\n    \\n    public int coreFunc(int[][] grid, int[][] pref) {\\n        // Dp records forward pyramid scale at i,j.\\n        int[][] dp = new int[m][n];\\n        for (int i = 0; i < m; i++) {\\n            for (int j = 0; j < n; j++) {\\n                // check [i - 1, j]\\'s scale\\n                int prevScale = (i == 0) ? 0 : dp[i - 1][j];\\n                \\n                // Handle boundary case\\n                prevScale = Math.min(prevScale, j);\\n                prevScale = Math.min(prevScale, n - 1 - j);\\n                \\n                // left right bound of base bar.\\n                // Binary search the correct pyramid scale.\\n                int lowScale = 0;\\n                int highScale = prevScale;\\n                while (lowScale + 1 < highScale) {\\n                    int midScale = (lowScale + highScale) / 2;\\n                    // mid works, search mid -> high\\n                    if (checkBase(i, j, midScale, pref)) {\\n                        lowScale = midScale;\\n                    } else {\\n                        highScale = midScale;\\n                    }\\n                }\\n                \\n                if (checkBase(i, j, highScale, pref)) {\\n                    dp[i][j] = highScale + 1;\\n                } else if (checkBase(i, j, lowScale, pref)) {\\n                    dp[i][j] = lowScale + 1;\\n                } else dp[i][j] = 0;\\n            }\\n        }\\n        \\n        int res = 0;\\n        for (int i = 0; i < m; i++) {\\n            for (int j = 0; j < n; j++) {\\n                if (dp[i][j] > 1) res += dp[i][j] - 1;\\n            }\\n        }\\n        \\n        return res;\\n    }\\n    \\n    public boolean checkBase(int i, int j, int range, int[][] pref) {\\n        int left = j - range;\\n        int right = j + range;\\n        int baseBar = pref[i][right] - \\n            (left == 0 ? 0 : pref[i][left - 1]);\\n        \\n        return baseBar == right - left + 1;\\n    }\\n    \\n    public int[][] prefixSum(int[][] grid) {\\n        int[][] res = new int[m][n];\\n        for (int i = 0; i < m; i++) {\\n            for (int j = 0; j < n; j++) {\\n                res[i][j] = \\n                (j > 0 ? res[i][j-1] : 0) + grid[i][j];\\n            }\\n        }\\n        \\n        return res;\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    int m, n;\\n    \\n    public int countPyramids(int[][] grid) {\\n        m = grid.length;\\n        n = grid[0].length;\\n        int[][] pref = prefixSum(grid); \\n        \\n        int res = 0;\\n        res += coreFunc(grid, pref);\\n        \\n        // reverse\\n        for (int i = 0; i < (m/2); i++) {\\n            int[] tmp = grid[i];\\n            grid[i] = grid[m - 1 - i];\\n            grid[m - 1 - i] = tmp;\\n            \\n            tmp = pref[i];\\n            pref[i] = pref[m - 1 - i];\\n            pref[m - 1 - i] = tmp;\\n        }\\n        \\n        res += coreFunc(grid, pref);\\n        return res;\\n    }\\n    \\n    public int coreFunc(int[][] grid, int[][] pref) {\\n        // Dp records forward pyramid scale at i,j.\\n        int[][] dp = new int[m][n];\\n        for (int i = 0; i < m; i++) {\\n            for (int j = 0; j < n; j++) {\\n                // check [i - 1, j]\\'s scale\\n                int prevScale = (i == 0) ? 0 : dp[i - 1][j];\\n                \\n                // Handle boundary case\\n                prevScale = Math.min(prevScale, j);\\n                prevScale = Math.min(prevScale, n - 1 - j);\\n                \\n                // left right bound of base bar.\\n                // Binary search the correct pyramid scale.\\n                int lowScale = 0;\\n                int highScale = prevScale;\\n                while (lowScale + 1 < highScale) {\\n                    int midScale = (lowScale + highScale) / 2;\\n                    // mid works, search mid -> high\\n                    if (checkBase(i, j, midScale, pref)) {\\n                        lowScale = midScale;\\n                    } else {\\n                        highScale = midScale;\\n                    }\\n                }\\n                \\n                if (checkBase(i, j, highScale, pref)) {\\n                    dp[i][j] = highScale + 1;\\n                } else if (checkBase(i, j, lowScale, pref)) {\\n                    dp[i][j] = lowScale + 1;\\n                } else dp[i][j] = 0;\\n            }\\n        }\\n        \\n        int res = 0;\\n        for (int i = 0; i < m; i++) {\\n            for (int j = 0; j < n; j++) {\\n                if (dp[i][j] > 1) res += dp[i][j] - 1;\\n            }\\n        }\\n        \\n        return res;\\n    }\\n    \\n    public boolean checkBase(int i, int j, int range, int[][] pref) {\\n        int left = j - range;\\n        int right = j + range;\\n        int baseBar = pref[i][right] - \\n            (left == 0 ? 0 : pref[i][left - 1]);\\n        \\n        return baseBar == right - left + 1;\\n    }\\n    \\n    public int[][] prefixSum(int[][] grid) {\\n        int[][] res = new int[m][n];\\n        for (int i = 0; i < m; i++) {\\n            for (int j = 0; j < n; j++) {\\n                res[i][j] = \\n                (j > 0 ? res[i][j-1] : 0) + grid[i][j];\\n            }\\n        }\\n        \\n        return res;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1613549,
                "title": "java-o-mn-solution-dp",
                "content": "```\\nclass Solution {\\n    public int countPyramids(int[][] grid) {\\n        int R = grid.length;\\n        int C = grid[0].length;\\n        int []dp = new int[C];\\n        int res = 0;\\n        for(int i = R-1; i>=0; i--){\\n            int prev = 0;\\n            for(int j = C-1; j>=0 ;j--){\\n                int curr = dp[j];\\n                if(grid[i][j] == 0)\\n                    dp[j] = 0;\\n                else\\n                    dp[j] = 1 + Math.min(prev, Math.min(dp[j], j==0?0:dp[j-1]));\\n                res += Math.max(0, dp[j]-1);\\n                prev = curr;\\n            }\\n        }\\n        Arrays.fill(dp, 0);\\n        for(int i = 0; i<R; i++){\\n            int prev = 0;\\n            for(int j = 0; j<C ;j++){\\n                int curr = dp[j];\\n                if(grid[i][j] == 0)\\n                    dp[j] = 0;\\n                else\\n                    dp[j] = 1 + Math.min(prev, Math.min(dp[j], j==(C-1)?0:dp[j+1]));\\n                res += Math.max(0, dp[j]-1);\\n                prev = curr;\\n            }\\n        }\\n        return res;\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    public int countPyramids(int[][] grid) {\\n        int R = grid.length;\\n        int C = grid[0].length;\\n        int []dp = new int[C];\\n        int res = 0;\\n        for(int i = R-1; i>=0; i--){\\n            int prev = 0;\\n            for(int j = C-1; j>=0 ;j--){\\n                int curr = dp[j];\\n                if(grid[i][j] == 0)\\n                    dp[j] = 0;\\n                else\\n                    dp[j] = 1 + Math.min(prev, Math.min(dp[j], j==0?0:dp[j-1]));\\n                res += Math.max(0, dp[j]-1);\\n                prev = curr;\\n            }\\n        }\\n        Arrays.fill(dp, 0);\\n        for(int i = 0; i<R; i++){\\n            int prev = 0;\\n            for(int j = 0; j<C ;j++){\\n                int curr = dp[j];\\n                if(grid[i][j] == 0)\\n                    dp[j] = 0;\\n                else\\n                    dp[j] = 1 + Math.min(prev, Math.min(dp[j], j==(C-1)?0:dp[j+1]));\\n                res += Math.max(0, dp[j]-1);\\n                prev = curr;\\n            }\\n        }\\n        return res;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1612438,
                "title": "simple-easy-to-understand-c-code-tc-o-nm-sc-o-nm",
                "content": "We just count thre number of straight pyramids and the number of inverted pyramids separately and add them up.\\nFor staright Pyramid we keep the 0th row same a grid matrix and traverse over the matrix to see if it is 1 and then we find the minimum of top-left, to, top-right cells and add 1 to it ti see if it forms a pyramid and we keep on incrementing our ans if the value of cell is greater than 1 as it signifies that height is greater than 1. \\nwe do the same thing to find inverted pyramids too. only difference is that we keeth the last row constant here and move upward to find inverted pyramids.\\n\\n```int countPyramids(vector<vector<int>>& grid) {\\n        int ans=0;\\n        int n=grid.size(), m=grid[0].size();\\n        //straight pyramid\\n        vector<vector<int>> a=grid;\\n        for(int i=1;i<n;i++)\\n        {\\n            for(int j=1;j<m-1;j++)\\n            {\\n                if(a[i][j]==1)\\n                {\\n                    a[i][j]=min({a[i-1][j-1],a[i-1][j], a[i-1][j+1]})+1;\\n                }\\n                if(a[i][j]>1)\\n                {\\n                    ans+=(a[i][j]-1);\\n                }\\n            }\\n        }\\n        //inverted pyramid\\n        a=grid;\\n        for(int i=n-2;i>=0;i--)\\n        {\\n            for(int j=1;j<m-1;j++)\\n            {\\n                if(a[i][j]==1)\\n                {\\n                    a[i][j]=min({a[i+1][j-1],a[i+1][j], a[i+1][j+1]})+1;\\n                }\\n                if(a[i][j]>1)\\n                    ans+=(a[i][j]-1);\\n            }\\n        }\\n        return ans;\\n    }```\\n\\t\\n\\tIf you have any doubt in understnding the code feel free to comment. Thanks for reading!",
                "solutionTags": [
                    "C"
                ],
                "code": "```int countPyramids(vector<vector<int>>& grid) {\\n        int ans=0;\\n        int n=grid.size(), m=grid[0].size();\\n        //straight pyramid\\n        vector<vector<int>> a=grid;\\n        for(int i=1;i<n;i++)\\n        {\\n            for(int j=1;j<m-1;j++)\\n            {\\n                if(a[i][j]==1)\\n                {\\n                    a[i][j]=min({a[i-1][j-1],a[i-1][j], a[i-1][j+1]})+1;\\n                }\\n                if(a[i][j]>1)\\n                {\\n                    ans+=(a[i][j]-1);\\n                }\\n            }\\n        }\\n        //inverted pyramid\\n        a=grid;\\n        for(int i=n-2;i>=0;i--)\\n        {\\n            for(int j=1;j<m-1;j++)\\n            {\\n                if(a[i][j]==1)\\n                {\\n                    a[i][j]=min({a[i+1][j-1],a[i+1][j], a[i+1][j+1]})+1;\\n                }\\n                if(a[i][j]>1)\\n                    ans+=(a[i][j]-1);\\n            }\\n        }\\n        return ans;\\n    }```",
                "codeTag": "Unknown"
            },
            {
                "id": 1611759,
                "title": "c-dp",
                "content": "```\\nclass Solution {\\npublic:\\n    int countPyramids(vector<vector<int>>& g) {\\n        int n=g.size();\\n        int m=g[0].size();\\n        vector<vector<int>>dp(n,vector<int>(m));\\n        int ans=0;\\n         dp=g;\\n        for(int i=n-2;i>=0;i--)\\n        {\\n            for(int j=1;j<m-1;j++)\\n            {\\n               \\n              if(g[i][j]==1)\\n              {\\n                  dp[i][j]=min(dp[i+1][j-1],min(dp[i+1][j],dp[i+1][j+1]))+1;\\n              }\\n            }\\n        }\\n        for(int i=0;i<n;i++)\\n        {\\n            for(int j=0;j<m;j++)\\n            {\\n                ans+=max(0,dp[i][j]-1);\\n            }\\n        }\\n        dp=g;\\n        for(int i=1;i<n;i++)\\n        {\\n            for(int j=1;j<m-1;j++)\\n            {\\n                if(g[i][j])\\n                {\\n                    dp[i][j]=min(dp[i-1][j],min(dp[i-1][j-1],dp[i-1][j+1]))+1;\\n                }\\n            }\\n        }\\n        for(int i=0;i<n;i++)\\n            for(int j=0;j<m;j++)\\n                ans+=max(0,dp[i][j]-1);\\n        return ans;\\n        \\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    int countPyramids(vector<vector<int>>& g) {\\n        int n=g.size();\\n        int m=g[0].size();\\n        vector<vector<int>>dp(n,vector<int>(m));\\n        int ans=0;\\n         dp=g;\\n        for(int i=n-2;i>=0;i--)\\n        {\\n            for(int j=1;j<m-1;j++)\\n            {\\n               \\n              if(g[i][j]==1)\\n              {\\n                  dp[i][j]=min(dp[i+1][j-1],min(dp[i+1][j],dp[i+1][j+1]))+1;\\n              }\\n            }\\n        }\\n        for(int i=0;i<n;i++)\\n        {\\n            for(int j=0;j<m;j++)\\n            {\\n                ans+=max(0,dp[i][j]-1);\\n            }\\n        }\\n        dp=g;\\n        for(int i=1;i<n;i++)\\n        {\\n            for(int j=1;j<m-1;j++)\\n            {\\n                if(g[i][j])\\n                {\\n                    dp[i][j]=min(dp[i-1][j],min(dp[i-1][j-1],dp[i-1][j+1]))+1;\\n                }\\n            }\\n        }\\n        for(int i=0;i<n;i++)\\n            for(int j=0;j<m;j++)\\n                ans+=max(0,dp[i][j]-1);\\n        return ans;\\n        \\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1609561,
                "title": "java-dp",
                "content": "Java Simple DP Solution , We only need to look at  3 cells above and 3 cells below.\\n```\\nclass Solution {\\n    public int countPyramids(int[][] grid) {\\n        int[][] dp = new int[grid.length][grid[0].length];\\n        int inversePyramidal = 0;\\n        for (int i = 0; i < grid.length; i++) {\\n            for (int j = 0; j < grid[i].length; j++) {\\n                if (grid[i][j] == 1 && i - 1 >= 0 && j + 1 < grid[i].length && j - 1 >= 0 && grid[i - 1][j - 1] == 1 && grid[i - 1][j] == 1 && grid[i - 1][j + 1] == 1) {\\n                    dp[i][j] = 1 + Math.min(dp[i - 1][j - 1], Math.min(dp[i - 1][j], dp[i - 1][j + 1]));\\n                    inversePyramidal += dp[i][j];\\n                }\\n            }\\n        }\\n        int pyramidal = 0;\\n        dp = new int[grid.length][grid[0].length];\\n        for (int i = grid.length - 1; i >= 0; i--) {\\n            for (int j = grid[i].length - 1; j >= 0; j--) {\\n                if (grid[i][j] == 1 && i + 1 < grid.length && j + 1 < grid[i].length && j - 1 >= 0 && grid[i + 1][j - 1] == 1 && grid[i + 1][j] == 1 && grid[i + 1][j + 1] == 1) {\\n                    dp[i][j] = 1 + Math.min(dp[i + 1][j - 1], Math.min(dp[i + 1][j], dp[i + 1][j + 1]));\\n                    pyramidal += dp[i][j];\\n                }\\n            }\\n        }\\n\\n        return inversePyramidal + pyramidal;\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    public int countPyramids(int[][] grid) {\\n        int[][] dp = new int[grid.length][grid[0].length];\\n        int inversePyramidal = 0;\\n        for (int i = 0; i < grid.length; i++) {\\n            for (int j = 0; j < grid[i].length; j++) {\\n                if (grid[i][j] == 1 && i - 1 >= 0 && j + 1 < grid[i].length && j - 1 >= 0 && grid[i - 1][j - 1] == 1 && grid[i - 1][j] == 1 && grid[i - 1][j + 1] == 1) {\\n                    dp[i][j] = 1 + Math.min(dp[i - 1][j - 1], Math.min(dp[i - 1][j], dp[i - 1][j + 1]));\\n                    inversePyramidal += dp[i][j];\\n                }\\n            }\\n        }\\n        int pyramidal = 0;\\n        dp = new int[grid.length][grid[0].length];\\n        for (int i = grid.length - 1; i >= 0; i--) {\\n            for (int j = grid[i].length - 1; j >= 0; j--) {\\n                if (grid[i][j] == 1 && i + 1 < grid.length && j + 1 < grid[i].length && j - 1 >= 0 && grid[i + 1][j - 1] == 1 && grid[i + 1][j] == 1 && grid[i + 1][j + 1] == 1) {\\n                    dp[i][j] = 1 + Math.min(dp[i + 1][j - 1], Math.min(dp[i + 1][j], dp[i + 1][j + 1]));\\n                    pyramidal += dp[i][j];\\n                }\\n            }\\n        }\\n\\n        return inversePyramidal + pyramidal;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1608791,
                "title": "python3-o-mn-using-prefix-suffix-counts",
                "content": "**Examples of \"complete\" and \"incomplete\" bases:**\\n\\n![image](https://assets.leetcode.com/users/images/0a24841f-5342-4282-b2f7-d2f451e75cd7_1638494580.2273853.png)\\n![image](https://assets.leetcode.com/users/images/eb28698f-01c6-4df7-916b-d2409d2bda51_1638494580.2334616.png)\\n\\n\\n\\n```\\n# O(mn) time and O(mn) space\\nclass Solution:\\n    def countPyramids(self, grid):\\n        self.grid, self.count = grid, 0\\n        # Initialize prefix and suffix grids\\n        # prefix[i][j] = number of consecutive ones to the left of grid[i][j]\\n        # suffix[i][j] = number of consecutive ones to the right of grid[i][j]\\n        self.prefixSuffix()\\n        # Count all pyramids\\n        self.countFromBase()\\n        # Count all inverse pyramids\\n        self.countFromBase(True)\\n        return self.count\\n\\n    def countFromBase(self, inverse=False):\\n        m, n = len(self.grid), len(self.grid[0])\\n        # traverse column by column each time considering each row as the base of some pyramids\\n        # that are centered at the current column\\n        # the number of pyramids starting at some \"complete\" base of length n is (n - 1) // 2\\n        for col in range(n):\\n            # previous \"complete\" base size\\n            prev_base = 0\\n            for i in (range(m - 1, -1, -1) if inverse else range(m)):\\n                # minimum \"radius\" of the base =  min(self.prefix[i][col], self.suffix[i][col])\\n                # base size  = 2 * radius + 1\\n                base = 0 if not self.grid[i][col] else min(self.prefix[i][col], self.suffix[i][col]) * 2 + 1\\n                # if the previous base is not large enough to make the\\n                # current base \"complete\" then decrease the current base\\'s length accordingly\\n                if base > prev_base: base = prev_base + 2 if prev_base else 1\\n                # for a pyramid with a base of length n we can make (n - 1) // 2 pyramids\\n                # that start with the same base row\\n                self.count += base // 2\\n                prev_base = base\\n\\n    def prefixSuffix(self):\\n        m, n = len(self.grid), len(self.grid[0])\\n        self.prefix, self.suffix = [[0] * n for _ in range(m)], [[0] * n for _ in range(m)]\\n        for row in range(m):\\n            curri = currj = 0\\n            for i in range(n):\\n                j = n - 1 - i\\n                self.prefix[row][i] = curri\\n                self.suffix[row][j] = currj\\n                if self.grid[row][i]: curri += 1\\n                else: curri = 0\\n                if self.grid[row][j]: currj += 1\\n                else: currj = 0\\n\\t```",
                "solutionTags": [],
                "code": "```\\n# O(mn) time and O(mn) space\\nclass Solution:\\n    def countPyramids(self, grid):\\n        self.grid, self.count = grid, 0\\n        # Initialize prefix and suffix grids\\n        # prefix[i][j] = number of consecutive ones to the left of grid[i][j]\\n        # suffix[i][j] = number of consecutive ones to the right of grid[i][j]\\n        self.prefixSuffix()\\n        # Count all pyramids\\n        self.countFromBase()\\n        # Count all inverse pyramids\\n        self.countFromBase(True)\\n        return self.count\\n\\n    def countFromBase(self, inverse=False):\\n        m, n = len(self.grid), len(self.grid[0])\\n        # traverse column by column each time considering each row as the base of some pyramids\\n        # that are centered at the current column\\n        # the number of pyramids starting at some \"complete\" base of length n is (n - 1) // 2\\n        for col in range(n):\\n            # previous \"complete\" base size\\n            prev_base = 0\\n            for i in (range(m - 1, -1, -1) if inverse else range(m)):\\n                # minimum \"radius\" of the base =  min(self.prefix[i][col], self.suffix[i][col])\\n                # base size  = 2 * radius + 1\\n                base = 0 if not self.grid[i][col] else min(self.prefix[i][col], self.suffix[i][col]) * 2 + 1\\n                # if the previous base is not large enough to make the\\n                # current base \"complete\" then decrease the current base\\'s length accordingly\\n                if base > prev_base: base = prev_base + 2 if prev_base else 1\\n                # for a pyramid with a base of length n we can make (n - 1) // 2 pyramids\\n                # that start with the same base row\\n                self.count += base // 2\\n                prev_base = base\\n\\n    def prefixSuffix(self):\\n        m, n = len(self.grid), len(self.grid[0])\\n        self.prefix, self.suffix = [[0] * n for _ in range(m)], [[0] * n for _ in range(m)]\\n        for row in range(m):\\n            curri = currj = 0\\n            for i in range(n):\\n                j = n - 1 - i\\n                self.prefix[row][i] = curri\\n                self.suffix[row][j] = currj\\n                if self.grid[row][i]: curri += 1\\n                else: curri = 0\\n                if self.grid[row][j]: currj += 1\\n                else: currj = 0\\n\\t```",
                "codeTag": "Java"
            },
            {
                "id": 1607462,
                "title": "go-golang-stacked-pyramids-with-inverse-100-runtime-88-ms-memory-usage-7-6-mb",
                "content": "```\\nfunc countPyramids(grid [][]int) int {\\n    res:=count(grid)\\n    for i,j:=0,len(grid)-1;i<j;i,j=i+1,j-1{\\n        grid[i],grid[j]=grid[j],grid[i]\\n    }\\n    res+=count(grid)\\n    return res\\n}\\n\\nfunc count(grid [][]int) int{\\n    n,m,res:=len(grid),len(grid[0]),0\\n    for i:=1;i<n;i++{\\n        for j:=1;j<m-1;j++{\\n            if grid[i][j]>0 && grid[i-1][j]>0{\\n                grid[i][j]=min(grid[i-1][j-1], grid[i-1][j+1])+1\\n                res+=grid[i][j]-1\\n            }\\n        }\\n    }\\n    for i:=1;i<n;i++{\\n        for j:=1;j<m-1;j++{\\n            if grid[i][j]>0{\\n                grid[i][j]=1\\n            }\\n        }\\n    }\\n    return res\\n}\\n\\nfunc min(a,b int)int{\\n    if a<b{\\n        return a\\n    }\\n    return b\\n}",
                "solutionTags": [
                    "Go"
                ],
                "code": "```\\nfunc countPyramids(grid [][]int) int {\\n    res:=count(grid)\\n    for i,j:=0,len(grid)-1;i<j;i,j=i+1,j-1{\\n        grid[i],grid[j]=grid[j],grid[i]\\n    }\\n    res+=count(grid)\\n    return res\\n}\\n\\nfunc count(grid [][]int) int{\\n    n,m,res:=len(grid),len(grid[0]),0\\n    for i:=1;i<n;i++{\\n        for j:=1;j<m-1;j++{\\n            if grid[i][j]>0 && grid[i-1][j]>0{\\n                grid[i][j]=min(grid[i-1][j-1], grid[i-1][j+1])+1\\n                res+=grid[i][j]-1\\n            }\\n        }\\n    }\\n    for i:=1;i<n;i++{\\n        for j:=1;j<m-1;j++{\\n            if grid[i][j]>0{\\n                grid[i][j]=1\\n            }\\n        }\\n    }\\n    return res\\n}\\n\\nfunc min(a,b int)int{\\n    if a<b{\\n        return a\\n    }\\n    return b\\n}",
                "codeTag": "Unknown"
            },
            {
                "id": 1607015,
                "title": "java",
                "content": "```\\nclass Solution {\\n    public int countPyramids(int[][] grid) {\\n        int rows = grid.length;\\n        int cols = grid[0].length;\\n        int l = 0; \\n        int h = rows-1;\\n        int[][] reverse = new int[rows][cols];\\n        while(l<=h){\\n            for(int i=0; i<cols; i++){\\n                reverse[l][i] = grid[h][i];\\n                reverse[h][i] = grid[l][i];\\n            }\\n            l++;\\n            h--;\\n        }\\n        return count(grid)+count(reverse);\\n    }\\n    \\n    public int count(int[][] grid) {\\n        int rows = grid.length;\\n        int cols = grid[0].length;\\n        int cnt = 0;\\n        for(int i=rows-1; i>0; i--){\\n            for(int j=2; j<cols; j++){\\n                int min = Integer.MAX_VALUE;\\n                for(int z=j-2; z<=j; z++){\\n                    if(grid[i][z]<min)\\n                        min = grid[i][z];\\n                    if(min==0)\\n                        break;\\n                }\\n                if(min>0 && grid[i-1][j-1]>0){\\n                    cnt += min;\\n                    grid[i-1][j-1] += min;\\n                }\\n            }\\n        }\\n        return cnt;\\n    }\\n    \\n}",
                "solutionTags": [],
                "code": "class Solution {\\n    public int countPyramids(int[][] grid) {\\n        int rows = grid.length;\\n        int cols = grid[0].length;\\n        int l = 0; \\n        int h = rows-1;\\n        int[][] reverse = new int[rows][cols];\\n        while(l<=h){\\n            for(int i=0; i<cols; i++){\\n                reverse[l][i] = grid[h][i];\\n                reverse[h][i] = grid[l][i];\\n            }",
                "codeTag": "Java"
            },
            {
                "id": 1606808,
                "title": "c-simple-o-m-n-solution-using-prefix-array",
                "content": "```\\npublic int CountPyramids(int[][] grid) {\\n    \\n        // build prefix sum array\\n        int[][] ones_before = new int[grid.Length][];\\n        for ( int y = 0; y < grid.Length; y++ )\\n        {   \\n            ones_before[y] = new int[grid[y].Length];\\n            \\n            ones_before[y][0] = grid[y][0];\\n            for( int x = 1; x < grid[y].Length; x++ )\\n            {\\n                if ( grid[y][x] == 1 )\\n                {\\n                    ones_before[y][x] = 1 + ones_before[y][x-1];\\n                }\\n            }\\n        }\\n        \\n        int sumTriangles = 0;\\n        for( int y = 0; y < grid.Length; y++ )\\n        {\\n            for( int x = 1; x < grid[y].Length - 1; x++ )\\n            {\\n                // count how many pyramids this is the top of using prefix array\\n                // check the top point, and then move down and diagonally to the right in the prefix array\\n                // if encounter a row without enough preceding 1s, then stop and check the size is big enough\\n                // if a triangle is of size N, then it includes N-1 triangles in it\\n                int curSize = 0;\\n                while ( y + curSize < grid.Length && x + curSize < grid[y].Length \\n                    && ones_before[y+curSize][x+curSize] >= 1 + curSize * 2 )\\n                {\\n                    curSize++;\\n                }\\n                sumTriangles += Math.Max( 0, ( curSize - 1 ) );\\n                \\n                // now count how many inverse pyramids this is the top of.\\n                // check the bottom point, moving up and diagonally to the right at each step.\\n                int yInverse = grid.Length - y - 1;\\n                curSize = 0;\\n                 while ( yInverse - curSize >= 0 && x + curSize < grid[yInverse].Length \\n                    && ones_before[yInverse-curSize][x+curSize] >= 1 + curSize * 2 )\\n                {\\n                    curSize++;\\n                }\\n                sumTriangles += Math.Max( 0, ( curSize - 1 ) );\\n                \\n            }\\n        }       \\n        \\n        return sumTriangles;\\n    }\\n```",
                "solutionTags": [],
                "code": "```\\npublic int CountPyramids(int[][] grid) {\\n    \\n        // build prefix sum array\\n        int[][] ones_before = new int[grid.Length][];\\n        for ( int y = 0; y < grid.Length; y++ )\\n        {   \\n            ones_before[y] = new int[grid[y].Length];\\n            \\n            ones_before[y][0] = grid[y][0];\\n            for( int x = 1; x < grid[y].Length; x++ )\\n            {\\n                if ( grid[y][x] == 1 )\\n                {\\n                    ones_before[y][x] = 1 + ones_before[y][x-1];\\n                }\\n            }\\n        }\\n        \\n        int sumTriangles = 0;\\n        for( int y = 0; y < grid.Length; y++ )\\n        {\\n            for( int x = 1; x < grid[y].Length - 1; x++ )\\n            {\\n                // count how many pyramids this is the top of using prefix array\\n                // check the top point, and then move down and diagonally to the right in the prefix array\\n                // if encounter a row without enough preceding 1s, then stop and check the size is big enough\\n                // if a triangle is of size N, then it includes N-1 triangles in it\\n                int curSize = 0;\\n                while ( y + curSize < grid.Length && x + curSize < grid[y].Length \\n                    && ones_before[y+curSize][x+curSize] >= 1 + curSize * 2 )\\n                {\\n                    curSize++;\\n                }\\n                sumTriangles += Math.Max( 0, ( curSize - 1 ) );\\n                \\n                // now count how many inverse pyramids this is the top of.\\n                // check the bottom point, moving up and diagonally to the right at each step.\\n                int yInverse = grid.Length - y - 1;\\n                curSize = 0;\\n                 while ( yInverse - curSize >= 0 && x + curSize < grid[yInverse].Length \\n                    && ones_before[yInverse-curSize][x+curSize] >= 1 + curSize * 2 )\\n                {\\n                    curSize++;\\n                }\\n                sumTriangles += Math.Max( 0, ( curSize - 1 ) );\\n                \\n            }\\n        }       \\n        \\n        return sumTriangles;\\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1605740,
                "title": "javascript-reverse-grid-to-execute-same-logic-can-help-to-check-the-time-space-complexity",
                "content": "var countPyramids = function(grid) {\\n    let result = 0;\\n\\n    let reverseGrid = [];\\n    for (let i=grid.length-1; i>=0; i--) {\\n        let row = [];\\n        for (let j=grid[i].length; j>=0; j--) {\\n            row.push(grid[i][j]);\\n        }\\n        reverseGrid.push(row);\\n    }\\n    \\n    let currentValue = 1;\\n    let hash = { 1: 0 };\\n    let coverage = 1;\\n    while (currentValue !== -1) {\\n        currentValue = checkPyramidal(grid, hash, currentValue, coverage);\\n        coverage++;\\n    }\\n    \\n    Object.keys(hash).forEach((k) => {\\n        result += hash[k];\\n    });\\n    \\n    currentValue = 1;\\n    hash = { 1: 0 };\\n    \\n    while (currentValue !== -1) {\\n        currentValue = checkPyramidal(reverseGrid, hash, currentValue);\\n    }\\n    \\n    Object.keys(hash).forEach((k) => {\\n        result += hash[k];\\n    })\\n\\n    return result;\\n};\\n\\nvar checkPyramidal = (grid, hash, currentValue, coverage=1) => {\\n    let m = grid.length;\\n    let n = grid[0].length;\\n    let nextValue = -1;\\n    for ( let i=coverage; i<m; i++) {\\n        for ( let j=coverage; j<n-coverage; j++) {\\n            if (grid[i][j] < currentValue) continue;\\n            let plot = isPyramidal(grid, i ,j, currentValue);\\n            if (plot !== -1) {\\n                nextValue = plot;\\n                hash[plot] = 0;\\n                hash[currentValue]++;\\n            }\\n        }\\n    }\\n    return nextValue;\\n}\\n\\n\\nvar isPyramidal = (grid, row, column, value) => {\\n    if (grid[row][column]       >= value &&\\n        grid[row][column - 1]   >= value &&\\n        grid[row][column + 1]   >= value &&\\n        grid[row - 1][column]   >= value \\n       ) {\\n        grid[row][column] ++;\\n        return grid[row][column];\\n    }\\n    return -1;\\n}",
                "solutionTags": [],
                "code": "var countPyramids = function(grid) {\\n    let result = 0;\\n\\n    let reverseGrid = [];\\n    for (let i=grid.length-1; i>=0; i--) {\\n        let row = [];\\n        for (let j=grid[i].length; j>=0; j--) {\\n            row.push(grid[i][j]);\\n        }\\n        reverseGrid.push(row);\\n    }\\n    \\n    let currentValue = 1;\\n    let hash = { 1: 0 };\\n    let coverage = 1;\\n    while (currentValue !== -1) {\\n        currentValue = checkPyramidal(grid, hash, currentValue, coverage);\\n        coverage++;\\n    }\\n    \\n    Object.keys(hash).forEach((k) => {\\n        result += hash[k];\\n    });\\n    \\n    currentValue = 1;\\n    hash = { 1: 0 };\\n    \\n    while (currentValue !== -1) {\\n        currentValue = checkPyramidal(reverseGrid, hash, currentValue);\\n    }\\n    \\n    Object.keys(hash).forEach((k) => {\\n        result += hash[k];\\n    })\\n\\n    return result;\\n};\\n\\nvar checkPyramidal = (grid, hash, currentValue, coverage=1) => {\\n    let m = grid.length;\\n    let n = grid[0].length;\\n    let nextValue = -1;\\n    for ( let i=coverage; i<m; i++) {\\n        for ( let j=coverage; j<n-coverage; j++) {\\n            if (grid[i][j] < currentValue) continue;\\n            let plot = isPyramidal(grid, i ,j, currentValue);\\n            if (plot !== -1) {\\n                nextValue = plot;\\n                hash[plot] = 0;\\n                hash[currentValue]++;\\n            }\\n        }\\n    }\\n    return nextValue;\\n}\\n\\n\\nvar isPyramidal = (grid, row, column, value) => {\\n    if (grid[row][column]       >= value &&\\n        grid[row][column - 1]   >= value &&\\n        grid[row][column + 1]   >= value &&\\n        grid[row - 1][column]   >= value \\n       ) {\\n        grid[row][column] ++;\\n        return grid[row][column];\\n    }\\n    return -1;\\n}",
                "codeTag": "Unknown"
            },
            {
                "id": 1603126,
                "title": "scala-just-brutal-force-to-count-each-pyramids",
                "content": "```scala\\n\\n  def countPyramids(grid: Array[Array[Int]]): Int = {\\n    type int = Int\\n    val m   = grid.length\\n    val n   = grid(0).length\\n    val tab = Array.ofDim[int](m, n)\\n    (0 until m).foreach(i => {\\n      tab(i)(n - 1) = if (grid(i)(n - 1) == 1) 1 else 0\\n      (n - 2 to 0 by -1).foreach(j => {\\n        if (grid(i)(j) == 0) tab(i)(j) = 0 else tab(i)(j) = 1 + tab(i)(j + 1)\\n      })\\n    })\\n\\n    def f(x: int, y: int, dx: int, dy: int): int = {\\n      var nx    = x + dx\\n      var ny    = y + dy\\n      var need  = 3\\n      var count = 0\\n      while (nx >= 0 && ny >= 0 && nx < m && ny < n && tab(nx)(ny) >= need) {\\n        count += 1\\n        nx += dx\\n        ny += dy\\n        need += 2\\n      }\\n\\n      count\\n    }\\n\\n    var count = 0\\n    for (i <- 0 until m; j <- 0 until n; if (grid(i)(j)) == 1) {\\n      count += f(i, j, 1, -1)\\n      count += f(i, j, -1, -1)\\n    }\\n\\n    count\\n  }\\n```",
                "solutionTags": [],
                "code": "```scala\\n\\n  def countPyramids(grid: Array[Array[Int]]): Int = {\\n    type int = Int\\n    val m   = grid.length\\n    val n   = grid(0).length\\n    val tab = Array.ofDim[int](m, n)\\n    (0 until m).foreach(i => {\\n      tab(i)(n - 1) = if (grid(i)(n - 1) == 1) 1 else 0\\n      (n - 2 to 0 by -1).foreach(j => {\\n        if (grid(i)(j) == 0) tab(i)(j) = 0 else tab(i)(j) = 1 + tab(i)(j + 1)\\n      })\\n    })\\n\\n    def f(x: int, y: int, dx: int, dy: int): int = {\\n      var nx    = x + dx\\n      var ny    = y + dy\\n      var need  = 3\\n      var count = 0\\n      while (nx >= 0 && ny >= 0 && nx < m && ny < n && tab(nx)(ny) >= need) {\\n        count += 1\\n        nx += dx\\n        ny += dy\\n        need += 2\\n      }\\n\\n      count\\n    }\\n\\n    var count = 0\\n    for (i <- 0 until m; j <- 0 until n; if (grid(i)(j)) == 1) {\\n      count += f(i, j, 1, -1)\\n      count += f(i, j, -1, -1)\\n    }\\n\\n    count\\n  }\\n```",
                "codeTag": "Python3"
            },
            {
                "id": 1602603,
                "title": "java-easy-to-understand-image-included",
                "content": "Idea: \\n1. If we are able to find count of normal pyramids then count of inverse pyramid can be obtained by reversing the grid row wise.\\n2. We can use sub-problems `dp(i+1)(j+1)` and `dp(i+1)(j-1)` to calculate `dp(i)(j)`, where dp(i)(j) is maximum height of a pyramid with apex at i, j.\\n\\n![image](https://assets.leetcode.com/users/images/c92e3a61-6208-4113-91c9-1ac28f40b859_1638189960.8647623.png)\\n\\n```\\nclass Solution {\\n    public int countPyramids(int[][] grid) {\\n        int res = 0;\\n        int n = grid.length;\\n        int m = grid[0].length;\\n        int [][] gridCopy = new int[n][m];\\n        \\n        res += dp(grid);\\n        \\n        for(int i = n-1; i>=0; i--){\\n            for(int j = 0; j <m;j ++){\\n                gridCopy[i][j] = grid[n-i-1][j];\\n            }\\n        }\\n      res += dp(gridCopy);\\n        \\n        return res;\\n    }\\n\\t\\n    private int dp(int [][ ] grid){\\n        int n = grid.length;\\n        int m = grid[0].length;\\n        int [][] dp = new int [n][m];\\n    \\n        for(int j = 0; j < m;  j++){\\n            dp[n-1][j] = grid[n-1][j];\\n        }\\n        for(int i = 0; i < n-1; i++){\\n            dp[i][0] = grid[i][0];\\n            dp[i][m-1] = grid[i][m-1];\\n        } \\n        for(int i = n-2; i>=0; i--){\\n            for(int j = 1; j < m-1; j++){\\n                    \\n                if(grid[i][j] == 0){\\n                    dp[i][j] = 0 ;\\n                }else{\\n                    int min = Math.min(dp[i+1][j+1], dp[i+1][j-1]);\\n                    min = Math.min(min, dp[i+1][j]);\\n                    dp[i][j] = min +1 ;\\n                }\\n            }\\n        }\\n\\n        int res = 0;\\n        for(int i = 0 ; i < n; i++){\\n            for(int j = 0; j < m; j++){\\n                if(dp[i][j] > 1)\\n                    res+= dp[i][j] -1 ;\\n            }\\n        }\\n        \\n        return res;\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    public int countPyramids(int[][] grid) {\\n        int res = 0;\\n        int n = grid.length;\\n        int m = grid[0].length;\\n        int [][] gridCopy = new int[n][m];\\n        \\n        res += dp(grid);\\n        \\n        for(int i = n-1; i>=0; i--){\\n            for(int j = 0; j <m;j ++){\\n                gridCopy[i][j] = grid[n-i-1][j];\\n            }\\n        }\\n      res += dp(gridCopy);\\n        \\n        return res;\\n    }\\n\\t\\n    private int dp(int [][ ] grid){\\n        int n = grid.length;\\n        int m = grid[0].length;\\n        int [][] dp = new int [n][m];\\n    \\n        for(int j = 0; j < m;  j++){\\n            dp[n-1][j] = grid[n-1][j];\\n        }\\n        for(int i = 0; i < n-1; i++){\\n            dp[i][0] = grid[i][0];\\n            dp[i][m-1] = grid[i][m-1];\\n        } \\n        for(int i = n-2; i>=0; i--){\\n            for(int j = 1; j < m-1; j++){\\n                    \\n                if(grid[i][j] == 0){\\n                    dp[i][j] = 0 ;\\n                }else{\\n                    int min = Math.min(dp[i+1][j+1], dp[i+1][j-1]);\\n                    min = Math.min(min, dp[i+1][j]);\\n                    dp[i][j] = min +1 ;\\n                }\\n            }\\n        }\\n\\n        int res = 0;\\n        for(int i = 0 ; i < n; i++){\\n            for(int j = 0; j < m; j++){\\n                if(dp[i][j] > 1)\\n                    res+= dp[i][j] -1 ;\\n            }\\n        }\\n        \\n        return res;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1602330,
                "title": "fast-c-solutoin-beats-100-in-runtime-and-memory-usage",
                "content": "To avoid copying `grid`, I did two passes on the original vector which resulted in a fast runtime (108ms).\\n```\\nclass Solution {\\npublic:\\n    int countPyramids(vector<vector<int>>& grid) {\\n        int total = 0;\\n        int nrow = grid.size();\\n        int ncol = grid[0].size();\\n        for (int r = nrow - 2; r >= 0; r--) {\\n            for (int c = 1; c < ncol - 1; c++) {\\n                if (grid[r][c] == 0) continue;\\n                int min = grid.size();\\n                for (int i = -1; i <= 1; i++) {\\n                    if (grid[r+1][c+i] < min) min = grid[r+1][c+i];\\n                }\\n                if (min == 0) continue;\\n                grid[r][c] += min;\\n                total += min;\\n            }\\n        }\\n        for (int c = 1; c < ncol - 1; c++) {\\n            if (grid[0][c] > 0) grid[0][c] = 1;\\n        }\\n        for (int r = 1; r < nrow; r++) {\\n            for (int c = 1; c < ncol - 1; c++) {\\n                if (grid[r][c] == 0) continue;\\n                grid[r][c] = 1;         \\n                int min = grid.size();\\n                for (int i = -1; i <= 1; i++) {\\n                    if (grid[r-1][c+i] < min) min = grid[r-1][c+i];\\n                }\\n                if (min == 0) continue;\\n                grid[r][c] += min;\\n                total += min;\\n            }\\n        }\\n    return total;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int countPyramids(vector<vector<int>>& grid) {\\n        int total = 0;\\n        int nrow = grid.size();\\n        int ncol = grid[0].size();\\n        for (int r = nrow - 2; r >= 0; r--) {\\n            for (int c = 1; c < ncol - 1; c++) {\\n                if (grid[r][c] == 0) continue;\\n                int min = grid.size();\\n                for (int i = -1; i <= 1; i++) {\\n                    if (grid[r+1][c+i] < min) min = grid[r+1][c+i];\\n                }\\n                if (min == 0) continue;\\n                grid[r][c] += min;\\n                total += min;\\n            }\\n        }\\n        for (int c = 1; c < ncol - 1; c++) {\\n            if (grid[0][c] > 0) grid[0][c] = 1;\\n        }\\n        for (int r = 1; r < nrow; r++) {\\n            for (int c = 1; c < ncol - 1; c++) {\\n                if (grid[r][c] == 0) continue;\\n                grid[r][c] = 1;         \\n                int min = grid.size();\\n                for (int i = -1; i <= 1; i++) {\\n                    if (grid[r-1][c+i] < min) min = grid[r-1][c+i];\\n                }\\n                if (min == 0) continue;\\n                grid[r][c] += min;\\n                total += min;\\n            }\\n        }\\n    return total;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1602170,
                "title": "python3-remember-maximal-square-leetcode-221",
                "content": "If you did the problem[ LeetCode 221 Maximal Square](https://leetcode.com/problems/maximal-square/), then this problem should be pretty straightforward where in this problem we are dealing with Pyramids instead of Squares.\\n```\\nclass Solution:\\n    def countPyramids(self, grid: List[List[int]]) -> int:\\n        return self.helper(grid) + self.helper(grid[::-1])\\n    \\n    def helper(self, grid):\\n        n = len(grid)\\n        m = len(grid[0])\\n        dp = [[-1] * m for _ in range(n)]\\n        res = 0\\n\\n        def dfs(i, j):\\n            if i >= n or j < 0 or j >= m:\\n                return 0\\n            if dp[i][j] != -1:\\n                return dp[i][j]\\n            if grid[i][j] == 0:\\n                dp[i][j] = 0\\n                return dp[i][j]\\n            first = dfs(i + 1, j - 1)\\n            second = dfs(i + 1, j)\\n            third = dfs(i + 1, j + 1)\\n            dp[i][j] = min(first, second, third) + 1\\n            return dp[i][j]\\n\\n        for i in range(n):\\n            for j in range(m):\\n                dfs(i, j)\\n                res += max(dp[i][j] - 1, 0)\\n        return res\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution:\\n    def countPyramids(self, grid: List[List[int]]) -> int:\\n        return self.helper(grid) + self.helper(grid[::-1])\\n    \\n    def helper(self, grid):\\n        n = len(grid)\\n        m = len(grid[0])\\n        dp = [[-1] * m for _ in range(n)]\\n        res = 0\\n\\n        def dfs(i, j):\\n            if i >= n or j < 0 or j >= m:\\n                return 0\\n            if dp[i][j] != -1:\\n                return dp[i][j]\\n            if grid[i][j] == 0:\\n                dp[i][j] = 0\\n                return dp[i][j]\\n            first = dfs(i + 1, j - 1)\\n            second = dfs(i + 1, j)\\n            third = dfs(i + 1, j + 1)\\n            dp[i][j] = min(first, second, third) + 1\\n            return dp[i][j]\\n\\n        for i in range(n):\\n            for j in range(m):\\n                dfs(i, j)\\n                res += max(dp[i][j] - 1, 0)\\n        return res\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1601901,
                "title": "c-easy-solution-prefix-sum",
                "content": "```\\nclass Solution {\\npublic:\\n    int countPyramids(vector<vector<int>>& grid) {\\n        for(int i=0;i<grid.size();i++)\\n        {\\n            for(int j=0;j<grid[0].size();j++)\\n            {\\n                if(grid[i][j]==1 && j-1>=0)\\n                {\\n                    grid[i][j]=1+grid[i][j-1];\\n                }\\n            }\\n        }\\n        int ans = 0;\\n        for(int i=0;i<grid.size();i++)\\n        {\\n            for(int j=0;j<grid[0].size();j++)\\n            {\\n               if(grid[i][j]!=0)\\n               {\\n                   int curr = j+1;\\n                   int rr=3;\\n                   int prev=1;\\n                   for(int k=i+1;k<grid.size() && curr<grid[0].size();k++)\\n                   {\\n                       int s1 = grid[k][curr];\\n                       if(curr-rr>=0)\\n                       {\\n                           s1-=grid[k][curr-rr];\\n                       }\\n                       if(s1-prev==2)\\n                       {\\n                           ans++;\\n                       }\\n                       else\\n                       {\\n                           break;\\n                       }\\n                       curr+=1;\\n                       rr+=2;\\n                       prev+=2;\\n                   }\\n               }\\n            }\\n        }\\n        for(int i=grid.size()-1;i>=0;i--)\\n        {\\n            for(int j=0;j<grid[0].size();j++)\\n            {\\n               if(grid[i][j]!=0)\\n               {\\n                   int curr = j+1;\\n                   int rr=3;\\n                   int prev=1;\\n                   for(int k=i-1;k>=0 && curr<grid[0].size();k--)\\n                   {\\n                       int s1 = grid[k][curr];\\n                       if(curr-rr>=0)\\n                       {\\n                           s1-=grid[k][curr-rr];\\n                       }\\n                       if(s1-prev==2)\\n                       {\\n                           ans++;\\n                       }\\n                       else\\n                       {\\n                           break;\\n                       }\\n                       curr+=1;\\n                       rr+=2;\\n                       prev+=2;\\n                   }\\n               }\\n            }\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    int countPyramids(vector<vector<int>>& grid) {\\n        for(int i=0;i<grid.size();i++)\\n        {\\n            for(int j=0;j<grid[0].size();j++)\\n            {\\n                if(grid[i][j]==1 && j-1>=0)\\n                {\\n                    grid[i][j]=1+grid[i][j-1];\\n                }\\n            }\\n        }\\n        int ans = 0;\\n        for(int i=0;i<grid.size();i++)\\n        {\\n            for(int j=0;j<grid[0].size();j++)\\n            {\\n               if(grid[i][j]!=0)\\n               {\\n                   int curr = j+1;\\n                   int rr=3;\\n                   int prev=1;\\n                   for(int k=i+1;k<grid.size() && curr<grid[0].size();k++)\\n                   {\\n                       int s1 = grid[k][curr];\\n                       if(curr-rr>=0)\\n                       {\\n                           s1-=grid[k][curr-rr];\\n                       }\\n                       if(s1-prev==2)\\n                       {\\n                           ans++;\\n                       }\\n                       else\\n                       {\\n                           break;\\n                       }\\n                       curr+=1;\\n                       rr+=2;\\n                       prev+=2;\\n                   }\\n               }\\n            }\\n        }\\n        for(int i=grid.size()-1;i>=0;i--)\\n        {\\n            for(int j=0;j<grid[0].size();j++)\\n            {\\n               if(grid[i][j]!=0)\\n               {\\n                   int curr = j+1;\\n                   int rr=3;\\n                   int prev=1;\\n                   for(int k=i-1;k>=0 && curr<grid[0].size();k--)\\n                   {\\n                       int s1 = grid[k][curr];\\n                       if(curr-rr>=0)\\n                       {\\n                           s1-=grid[k][curr-rr];\\n                       }\\n                       if(s1-prev==2)\\n                       {\\n                           ans++;\\n                       }\\n                       else\\n                       {\\n                           break;\\n                       }\\n                       curr+=1;\\n                       rr+=2;\\n                       prev+=2;\\n                   }\\n               }\\n            }\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1601894,
                "title": "python-dp-solution",
                "content": "```\\nclass Solution:\\n    def countPyramids(self, grid: List[List[int]]) -> int:\\n        m = len(grid)\\n        n = len(grid[0])\\n        fromLeft = [[0 for j in range(n)] for i in range(m)] \\n        fromRight = [[0 for j in range(n)] for i in range(m)] \\n        \\n        for i in range(m):\\n            fromLeft[i][0] = grid[i][0]\\n            for j in range(1, n):\\n                if grid[i][j] == 0:\\n                    fromLeft[i][j] = 0\\n                else:\\n                    fromLeft[i][j] = fromLeft[i][j-1] + 1\\n                    \\n        for i in range(m):\\n            fromRight[i][n-1] = grid[i][n-1]\\n            for j in range(n-2, -1, -1):\\n                if grid[i][j] == 0:\\n                    fromRight[i][j] = 0\\n                else:\\n                    fromRight[i][j] = fromRight[i][j + 1] + 1\\n                    \\n        oneCount = [[0 for j in range(n)] for i in range(m)]  #how many consecutive ones centered at [i][j]\\n        for i in range(m):\\n            for j in range(n):\\n                if grid[i][j] == 0:\\n                    oneCount[i][j] = 0\\n                else:\\n                    oneCount[i][j] = (min(fromLeft[i][j], fromRight[i][j]) - 1) * 2 + 1\\n                    \\n        # Count pyramid\\n        total = 0\\n        height = [0] * (m + 1)\\n        for j in range(n):\\n            for i in range(m):\\n                # layer = i + 1\\n                height[i + 1] = min((oneCount[i][j] + 1)//2, height[i] + 1)\\n                total += max(0, height[i + 1] - 1)\\n        \\n        # Count inverse pyramid\\n        height = [0] * (m + 1)\\n        for j in range(n):\\n            for i in range(m-1, -1, -1):\\n                # layer = i\\n                height[i] = min((oneCount[i][j] + 1)//2, height[i+1] + 1)\\n                total += max(0, height[i] - 1)\\n                \\n        return total\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution:\\n    def countPyramids(self, grid: List[List[int]]) -> int:\\n        m = len(grid)\\n        n = len(grid[0])\\n        fromLeft = [[0 for j in range(n)] for i in range(m)] \\n        fromRight = [[0 for j in range(n)] for i in range(m)] \\n        \\n        for i in range(m):\\n            fromLeft[i][0] = grid[i][0]\\n            for j in range(1, n):\\n                if grid[i][j] == 0:\\n                    fromLeft[i][j] = 0\\n                else:\\n                    fromLeft[i][j] = fromLeft[i][j-1] + 1\\n                    \\n        for i in range(m):\\n            fromRight[i][n-1] = grid[i][n-1]\\n            for j in range(n-2, -1, -1):\\n                if grid[i][j] == 0:\\n                    fromRight[i][j] = 0\\n                else:\\n                    fromRight[i][j] = fromRight[i][j + 1] + 1\\n                    \\n        oneCount = [[0 for j in range(n)] for i in range(m)]  #how many consecutive ones centered at [i][j]\\n        for i in range(m):\\n            for j in range(n):\\n                if grid[i][j] == 0:\\n                    oneCount[i][j] = 0\\n                else:\\n                    oneCount[i][j] = (min(fromLeft[i][j], fromRight[i][j]) - 1) * 2 + 1\\n                    \\n        # Count pyramid\\n        total = 0\\n        height = [0] * (m + 1)\\n        for j in range(n):\\n            for i in range(m):\\n                # layer = i + 1\\n                height[i + 1] = min((oneCount[i][j] + 1)//2, height[i] + 1)\\n                total += max(0, height[i + 1] - 1)\\n        \\n        # Count inverse pyramid\\n        height = [0] * (m + 1)\\n        for j in range(n):\\n            for i in range(m-1, -1, -1):\\n                # layer = i\\n                height[i] = min((oneCount[i][j] + 1)//2, height[i+1] + 1)\\n                total += max(0, height[i] - 1)\\n                \\n        return total\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1601587,
                "title": "simple-count-question",
                "content": "Similar to other counting questions, all you need to know is the number of consecutive 1s in the grid cell, and you can go upper diagonal or lower. \\n```\\npublic int countPyramids(int[][] grid) {\\n        int r = grid.length, c = grid[0].length, count[][] = new int[r][c], cnt = 0, res = 0;\\n        \\n        for (int i = 0; i < r; i++){\\n            cnt = 0;\\n            for (int j = 0; j < c; j++){\\n                cnt = grid[i][j] == 1?cnt+1:0;\\n                count[i][j] = cnt;\\n            }\\n        }\\n        \\n        for (int i = 0; i < r; i++){\\n            for (int j = 0; j < c; j++){\\n                if (count[i][j] == 0) continue;         // can\\'t be apex\\n                \\n                // count top\\n                int row = i, col = j, val = 1;\\n                while (row + 1 < r && col + 1 < c){\\n                    if (count[row+1][col+1] >= val + 2){\\n                        res++;\\n                        val+=2;\\n                        row++;\\n                        col++;\\n                    }else{\\n                        break;\\n                    }\\n                }\\n                \\n                row = i; col = j; val = 1;\\n                while (row -1 >= 0 && col + 1 < c){\\n                    if (count[row-1][col+1] >= val + 2){\\n                        res++;\\n                        val+=2;\\n                        row--;\\n                        col++;\\n                    }else{\\n                        break;\\n                    }\\n                }\\n            }\\n        }\\n        \\n        return res;\\n    }\\n```",
                "solutionTags": [
                    "Dynamic Programming"
                ],
                "code": "```\\npublic int countPyramids(int[][] grid) {\\n        int r = grid.length, c = grid[0].length, count[][] = new int[r][c], cnt = 0, res = 0;\\n        \\n        for (int i = 0; i < r; i++){\\n            cnt = 0;\\n            for (int j = 0; j < c; j++){\\n                cnt = grid[i][j] == 1?cnt+1:0;\\n                count[i][j] = cnt;\\n            }\\n        }\\n        \\n        for (int i = 0; i < r; i++){\\n            for (int j = 0; j < c; j++){\\n                if (count[i][j] == 0) continue;         // can\\'t be apex\\n                \\n                // count top\\n                int row = i, col = j, val = 1;\\n                while (row + 1 < r && col + 1 < c){\\n                    if (count[row+1][col+1] >= val + 2){\\n                        res++;\\n                        val+=2;\\n                        row++;\\n                        col++;\\n                    }else{\\n                        break;\\n                    }\\n                }\\n                \\n                row = i; col = j; val = 1;\\n                while (row -1 >= 0 && col + 1 < c){\\n                    if (count[row-1][col+1] >= val + 2){\\n                        res++;\\n                        val+=2;\\n                        row--;\\n                        col++;\\n                    }else{\\n                        break;\\n                    }\\n                }\\n            }\\n        }\\n        \\n        return res;\\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1601530,
                "title": "python-o-n-bottom-up-dp",
                "content": "O(n) where n is number of cells wich is equal to ROWS*COLS\\n```\\nclass Solution:\\n    def bottom_up_counting(self, dp):\\n        result = 0\\n        for row in range(self.ROWS - 1, -1, -1):\\n            for col in range(self.COLS):\\n                if dp[(row, col)] >= 1:\\n                    dp[(row, col)] = dp[(row, col)] + min(dp[(row + 1, col - 1)], dp[(row + 1, col)], dp[(row + 1, col + 1)])\\n                    result += dp[(row, col)] - 1\\n        return result\\n\\n    def convert_to_dict(self, g):\\n        dp = defaultdict(int)\\n        for row in range(self.ROWS):\\n            for col in range(self.COLS):\\n                dp[(row, col)] = g[row][col]\\n        return dp\\n\\n    def countPyramids(self, grid: List[List[int]]) -> int:\\n        self.ROWS, self.COLS = len(grid), len(grid[0])\\n        dp, dp_rev = self.convert_to_dict(grid), self.convert_to_dict(grid[::-1])                    \\n        return self.bottom_up_counting(dp) + self.bottom_up_counting(dp_rev)  \\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution:\\n    def bottom_up_counting(self, dp):\\n        result = 0\\n        for row in range(self.ROWS - 1, -1, -1):\\n            for col in range(self.COLS):\\n                if dp[(row, col)] >= 1:\\n                    dp[(row, col)] = dp[(row, col)] + min(dp[(row + 1, col - 1)], dp[(row + 1, col)], dp[(row + 1, col + 1)])\\n                    result += dp[(row, col)] - 1\\n        return result\\n\\n    def convert_to_dict(self, g):\\n        dp = defaultdict(int)\\n        for row in range(self.ROWS):\\n            for col in range(self.COLS):\\n                dp[(row, col)] = g[row][col]\\n        return dp\\n\\n    def countPyramids(self, grid: List[List[int]]) -> int:\\n        self.ROWS, self.COLS = len(grid), len(grid[0])\\n        dp, dp_rev = self.convert_to_dict(grid), self.convert_to_dict(grid[::-1])                    \\n        return self.bottom_up_counting(dp) + self.bottom_up_counting(dp_rev)  \\n```",
                "codeTag": "Java"
            },
            {
                "id": 1600213,
                "title": "faster-than-100-00-of-c-online-submissions-o-n-m",
                "content": "```\\nclass Solution {\\npublic:\\n    int row, col;\\n    bool isValid(int x, int y){\\n        return x>=0 and x<row and y>=0 and y<col;\\n    }\\n    bool isLowerPyramid(int x, int y, vector<vector<int>>& a){\\n        return a[x][y] and isValid(x+1, y-1) and isValid(x+1, y) and isValid(x+1, y+1) and a[x+1][y-1] and a[x+1][y] and a[x+1][y+1];\\n    }\\n    bool isUpperPyramid(int x, int y, vector<vector<int>>& a){\\n        return a[x][y] and isValid(x-1, y-1) and isValid(x-1, y) and isValid(x-1, y+1) and a[x-1][y-1] and a[x-1][y] and a[x-1][y+1];\\n    }\\n    int countPyramids(vector<vector<int>>& a) {\\n        row = a.size(); col = a[0].size();\\n        vector<vector<int>> lower(row, vector<int> (col, 0));\\n        vector<vector<int>> upper(row, vector<int> (col, 0));\\n        for(int k=row-1; k>=0; k--){\\n            for(int x=0; x<col; x++){\\n                if(isLowerPyramid(k, x, a)){\\n                    lower[k][x]+=min({lower[k+1][x-1], lower[k+1][x], lower[k+1][x+1]})+1;\\n                }\\n            }\\n        }\\n        for(int k=0; k<row; k++){\\n            for(int x=0; x<col; x++){\\n                if(isUpperPyramid(k, x, a)){\\n                    upper[k][x]+=min({upper[k-1][x-1], upper[k-1][x], upper[k-1][x+1]})+1;\\n                }\\n            }\\n        }\\n        int res = 0;\\n        for(int k=0; k<row; k++){\\n            for(int x=0; x<col; x++){\\n                res+=(lower[k][x]+upper[k][x]);\\n            }\\n        }\\n        return res;\\n    }\\n};\\n\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    int row, col;\\n    bool isValid(int x, int y){\\n        return x>=0 and x<row and y>=0 and y<col;\\n    }\\n    bool isLowerPyramid(int x, int y, vector<vector<int>>& a){\\n        return a[x][y] and isValid(x+1, y-1) and isValid(x+1, y) and isValid(x+1, y+1) and a[x+1][y-1] and a[x+1][y] and a[x+1][y+1];\\n    }\\n    bool isUpperPyramid(int x, int y, vector<vector<int>>& a){\\n        return a[x][y] and isValid(x-1, y-1) and isValid(x-1, y) and isValid(x-1, y+1) and a[x-1][y-1] and a[x-1][y] and a[x-1][y+1];\\n    }\\n    int countPyramids(vector<vector<int>>& a) {\\n        row = a.size(); col = a[0].size();\\n        vector<vector<int>> lower(row, vector<int> (col, 0));\\n        vector<vector<int>> upper(row, vector<int> (col, 0));\\n        for(int k=row-1; k>=0; k--){\\n            for(int x=0; x<col; x++){\\n                if(isLowerPyramid(k, x, a)){\\n                    lower[k][x]+=min({lower[k+1][x-1], lower[k+1][x], lower[k+1][x+1]})+1;\\n                }\\n            }\\n        }\\n        for(int k=0; k<row; k++){\\n            for(int x=0; x<col; x++){\\n                if(isUpperPyramid(k, x, a)){\\n                    upper[k][x]+=min({upper[k-1][x-1], upper[k-1][x], upper[k-1][x+1]})+1;\\n                }\\n            }\\n        }\\n        int res = 0;\\n        for(int k=0; k<row; k++){\\n            for(int x=0; x<col; x++){\\n                res+=(lower[k][x]+upper[k][x]);\\n            }\\n        }\\n        return res;\\n    }\\n};\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1599697,
                "title": "python-3-count-twice-using-defaultdict",
                "content": "O(MN) for both space and time\\n\\n```\\nclass Solution:\\n    def countPyramids(self, grid: List[List[int]]) -> int:\\n        m = len(grid)\\n        n = len(grid[0])\\n        ans = 0 \\n        \\n        # use a default dict since this removes the boundary conditions\\n        d = collections.defaultdict(int)\\n        for i in range(m):\\n            for j in range(n):\\n                v = grid[i][j]\\n                if v == 1:\\n                    d[(i, j)] = 1\\n                    \\n        # reverted shape\\n        for i in range(m):\\n            for j in range(n):\\n                if d[(i, j)] == 1:\\n                    d[(i, j)] = d[(i, j)] + min(d[(i - 1, j - 1)], d[(i - 1, j)], d[(i - 1, j + 1)])\\n                    if d[(i, j)] > 1:\\n                        ans += d[(i, j)] - 1\\n                        \\n        # usual shape\\n        for i in reversed(range(m)):\\n            for j in range(n):\\n                if d[(i, j)] >= 1:\\n                    d[(i, j)] = 1  # reset the value back to the normal 1\\n                    d[(i, j)] = d[(i, j)] + min(d[(i + 1, j - 1)], d[(i + 1, j)], d[(i + 1, j + 1)])\\n                    if d[(i, j)] > 1:\\n                        ans += d[(i, j)] - 1\\n                        \\n        return ans    \\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def countPyramids(self, grid: List[List[int]]) -> int:\\n        m = len(grid)\\n        n = len(grid[0])\\n        ans = 0 \\n        \\n        # use a default dict since this removes the boundary conditions\\n        d = collections.defaultdict(int)\\n        for i in range(m):\\n            for j in range(n):\\n                v = grid[i][j]\\n                if v == 1:\\n                    d[(i, j)] = 1\\n                    \\n        # reverted shape\\n        for i in range(m):\\n            for j in range(n):\\n                if d[(i, j)] == 1:\\n                    d[(i, j)] = d[(i, j)] + min(d[(i - 1, j - 1)], d[(i - 1, j)], d[(i - 1, j + 1)])\\n                    if d[(i, j)] > 1:\\n                        ans += d[(i, j)] - 1\\n                        \\n        # usual shape\\n        for i in reversed(range(m)):\\n            for j in range(n):\\n                if d[(i, j)] >= 1:\\n                    d[(i, j)] = 1  # reset the value back to the normal 1\\n                    d[(i, j)] = d[(i, j)] + min(d[(i + 1, j - 1)], d[(i + 1, j)], d[(i + 1, j + 1)])\\n                    if d[(i, j)] > 1:\\n                        ans += d[(i, j)] - 1\\n                        \\n        return ans    \\n```",
                "codeTag": "Java"
            },
            {
                "id": 1599637,
                "title": "dp",
                "content": "![image](https://assets.leetcode.com/users/images/83080a47-ec7d-4f37-a8e7-eac96c5c4b32_1638100527.750287.png)\\n\\n\\n\\n\\n\\n\\n\\n```\\nclass Solution(object):\\n    def countPyramids(self, grid):\\n        rev = [[e for e in r] for r in grid][::-1]\\n        return self.f(grid) + self.f(rev)\\n    def f(self, grid):\\n        ans = 0\\n        n,m = len(grid), len(grid[0])\\n        for i in range(n-2,-1,-1):\\n            for j in range(1,m-1):\\n                if grid[i][j]:\\n                    a = grid[i+1][j-1]\\n                    b = grid[i+1][j]\\n                    c = grid[i+1][j+1]\\n                    grid[i][j] = 1+min(a,b,c)\\n                    ans += grid[i][j] -1\\n        \\n        return ans\\n```\\n",
                "solutionTags": [
                    "Dynamic Programming"
                ],
                "code": "```\\nclass Solution(object):\\n    def countPyramids(self, grid):\\n        rev = [[e for e in r] for r in grid][::-1]\\n        return self.f(grid) + self.f(rev)\\n    def f(self, grid):\\n        ans = 0\\n        n,m = len(grid), len(grid[0])\\n        for i in range(n-2,-1,-1):\\n            for j in range(1,m-1):\\n                if grid[i][j]:\\n                    a = grid[i+1][j-1]\\n                    b = grid[i+1][j]\\n                    c = grid[i+1][j+1]\\n                    grid[i][j] = 1+min(a,b,c)\\n                    ans += grid[i][j] -1\\n        \\n        return ans\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1599545,
                "title": "python3-reduces-to-finding-an-increasing-sequence-in-columns",
                "content": "We fist need to populate a table counting how many ones we see when traversing from left to right, then we count how many ones we see from right to left. Then, construct a dp table that contains the min(left, right). Finally, we count the increasing sequence in each column and add to the answer. \\n```\\nclass Solution:\\n    def countPyramids(self, grid: List[List[int]]) -> int:\\n        m, n = len(grid), len(grid[0])\\n        dp = [[0]*n for _ in range(m)]\\n        \\n\\t\\t# count \"1\" from left to right\\n        for r in range(m):\\n            for c in range(n):\\n                if grid[r][c] == 0: continue\\n                if c == 0:\\n                    dp[r][c] = grid[r][c]\\n                else:\\n                    dp[r][c] += dp[r][c - 1] + 1\\n             \\n\\t\\t\\t # count \"1\" from right to left and take min(left, right) in one loop\\n            for c in range(n-1, -1, -1):\\n                if grid[r][c] == 0: continue\\n                if c == n - 1:\\n                    dp[r][c] = min(dp[r][c], grid[r][c])\\n                else:\\n                    dp[r][c] = min(dp[r][c], dp[r][c + 1] + 1)\\n        \\n        #print(dp)\\n        ans = 0\\n        for r in range(m):\\n            for c in range(n):\\n                if dp[r][c] == 0:\\n                    continue\\n                k = 0\\n                while (r + k) < m and dp[r + k][c] >= (k + 1):  k += 1\\n                ans += (k-1)\\n\\n                #print(ans)\\n                k = 0\\n                while (r - k) >= 0 and dp[r - k][c] >= k + 1:   k += 1\\n                ans += (k-1)\\n\\n        return ans\\n```",
                "solutionTags": [
                    "Python3",
                    "Dynamic Programming"
                ],
                "code": "```\\nclass Solution:\\n    def countPyramids(self, grid: List[List[int]]) -> int:\\n        m, n = len(grid), len(grid[0])\\n        dp = [[0]*n for _ in range(m)]\\n        \\n\\t\\t# count \"1\" from left to right\\n        for r in range(m):\\n            for c in range(n):\\n                if grid[r][c] == 0: continue\\n                if c == 0:\\n                    dp[r][c] = grid[r][c]\\n                else:\\n                    dp[r][c] += dp[r][c - 1] + 1\\n             \\n\\t\\t\\t # count \"1\" from right to left and take min(left, right) in one loop\\n            for c in range(n-1, -1, -1):\\n                if grid[r][c] == 0: continue\\n                if c == n - 1:\\n                    dp[r][c] = min(dp[r][c], grid[r][c])\\n                else:\\n                    dp[r][c] = min(dp[r][c], dp[r][c + 1] + 1)\\n        \\n        #print(dp)\\n        ans = 0\\n        for r in range(m):\\n            for c in range(n):\\n                if dp[r][c] == 0:\\n                    continue\\n                k = 0\\n                while (r + k) < m and dp[r + k][c] >= (k + 1):  k += 1\\n                ans += (k-1)\\n\\n                #print(ans)\\n                k = 0\\n                while (r - k) >= 0 and dp[r - k][c] >= k + 1:   k += 1\\n                ans += (k-1)\\n\\n        return ans\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1599532,
                "title": "python3-recursion-one-testcase-run-into-runtime-limit-though",
                "content": "```\\nclass Solution(object):\\n    ans = 0 \\n    def countPyramids(self, grid):\\n        \"\"\"\\n        :type grid: List[List[int]]\\n        :rtype: int\\n        \"\"\"\\n        def isPyramidApex(g,i,j,c):\\n            if (j - c) < 0:\\n                return \\n            try:\\n                for x in range(j-c, j+c+1):\\n                    if g[i+1][x] != 1: \\n                        return \\n                self.ans += 1\\n                isPyramidApex(g, i+1, j, c+1)\\n            except Exception as e:\\n                return\\n\\t\\t\\t\\t\\n        def getPyrimadsCount(g):\\n            n = len(g)\\n            m = len(g[0])\\n            for i in range(n):\\n                for j in range(m):\\n\\t\\t\\t\\t    # each point is a potential pyrmiad apex if it holds value of 1 \\n                    if g[i][j]:\\n                        isPyramidApex(g, i,j, 1)\\n            return \\n\\t\\t\\t\\n\\t\\t\\n        getPyrimadsCount(grid)\\n\\t\\t# flip array on X then Y direction and tally pyrimads \\n        getPyrimadsCount([list(reversed(x)) for x in reversed(grid)])\\n        return self.ans\\n```\\n\\nmy submission failed one testcase of 100 x 1000 array , all 1s, due to run time limit. \\nfor that particular testcase, my local machine report 9233400 valid pyrimads. \\nHow would you optimize the above code ?",
                "solutionTags": [
                    "Python3",
                    "Recursion"
                ],
                "code": "```\\nclass Solution(object):\\n    ans = 0 \\n    def countPyramids(self, grid):\\n        \"\"\"\\n        :type grid: List[List[int]]\\n        :rtype: int\\n        \"\"\"\\n        def isPyramidApex(g,i,j,c):\\n            if (j - c) < 0:\\n                return \\n            try:\\n                for x in range(j-c, j+c+1):\\n                    if g[i+1][x] != 1: \\n                        return \\n                self.ans += 1\\n                isPyramidApex(g, i+1, j, c+1)\\n            except Exception as e:\\n                return\\n\\t\\t\\t\\t\\n        def getPyrimadsCount(g):\\n            n = len(g)\\n            m = len(g[0])\\n            for i in range(n):\\n                for j in range(m):\\n\\t\\t\\t\\t    # each point is a potential pyrmiad apex if it holds value of 1 \\n                    if g[i][j]:\\n                        isPyramidApex(g, i,j, 1)\\n            return \\n\\t\\t\\t\\n\\t\\t\\n        getPyrimadsCount(grid)\\n\\t\\t# flip array on X then Y direction and tally pyrimads \\n        getPyrimadsCount([list(reversed(x)) for x in reversed(grid)])\\n        return self.ans\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1599392,
                "title": "python3-o-h-2-w-not-the-fastest-but-this-wasn-t-on-here-so-thought-i-d-share",
                "content": "I see some solutions in `O(h*w)` so look elsewhere if you want an optimal solution. But here\\'s mine, which seemed simple. Calculate how many left and right pieces each position has. Then, for each position, expand the pyramid up and down by checking for sequentially larger pyramids (adding a new layer to the top when going up or to the bottom when going down with an incrementing size).\\n\\n```python\\nclass Solution:\\n    def countPyramids(self, grid: List[List[int]]) -> int:\\n        h, w = len(grid), len(grid[0])\\n        L = [[0] * w for _ in range(h)]\\n        R = [[0] * w for _ in range(h)]\\n        \\n        for i, row in enumerate(grid):\\n            for j, tile in enumerate(row[1:], start=1):\\n                if tile:\\n                    L[i][j] += L[i][j-1] + grid[i][j-1]\\n        \\n            for j, tile in reversed(list(enumerate(row[:-1]))):\\n                if tile:\\n                    R[i][j] += R[i][j+1] + grid[i][j+1]\\n                    \\n        number = 0\\n        for i, row in enumerate(grid):\\n            for j, tile in enumerate(row):\\n                if tile:\\n                    size = 0\\n                    cur = i + 1\\n                    while cur < h and L[cur][j] > size and R[cur][j] > size:\\n                        size += 1\\n                        cur += 1\\n                    number += size\\n                        \\n                    size = 0\\n                    cur = i - 1\\n                    while cur >= 0 and L[cur][j] > size and R[cur][j] > size:\\n                        size += 1\\n                        cur -= 1\\n                    number += size\\n                    \\n        return number\\n```",
                "solutionTags": [],
                "code": "```python\\nclass Solution:\\n    def countPyramids(self, grid: List[List[int]]) -> int:\\n        h, w = len(grid), len(grid[0])\\n        L = [[0] * w for _ in range(h)]\\n        R = [[0] * w for _ in range(h)]\\n        \\n        for i, row in enumerate(grid):\\n            for j, tile in enumerate(row[1:], start=1):\\n                if tile:\\n                    L[i][j] += L[i][j-1] + grid[i][j-1]\\n        \\n            for j, tile in reversed(list(enumerate(row[:-1]))):\\n                if tile:\\n                    R[i][j] += R[i][j+1] + grid[i][j+1]\\n                    \\n        number = 0\\n        for i, row in enumerate(grid):\\n            for j, tile in enumerate(row):\\n                if tile:\\n                    size = 0\\n                    cur = i + 1\\n                    while cur < h and L[cur][j] > size and R[cur][j] > size:\\n                        size += 1\\n                        cur += 1\\n                    number += size\\n                        \\n                    size = 0\\n                    cur = i - 1\\n                    while cur >= 0 and L[cur][j] > size and R[cur][j] > size:\\n                        size += 1\\n                        cur -= 1\\n                    number += size\\n                    \\n        return number\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1599335,
                "title": "prefix-sum-dp-c",
                "content": "```\\nclass Solution {\\npublic:\\n    int countPyramids(vector<vector<int>>& a) {\\n        int n=a.size();\\n        int m=a[0].size();\\n        vector< vector<int> > dp(n,vector<int> (m,0));\\n        for(int i=0;i<m;i++)\\n        {\\n            dp[0][i]=a[0][i];\\n        }\\n        vector< vector<int> > pre(n,vector<int> (m,0));\\n        for(int i=0;i<n;i++)\\n        {\\n            for(int j=0;j<m;j++)\\n            {\\n                if(j==0)\\n                {\\n                    pre[i][0]=a[i][0];\\n                }\\n                else\\n                {\\n                    pre[i][j]=a[i][j]+pre[i][j-1];\\n                }\\n            }\\n        }\\n        int ans=0;\\n        for(int i=1;i<n;i++)\\n        {\\n            for(int j=0;j<m;j++)\\n            {\\n                if(a[i][j]==1)dp[i][j]=1;\\n                if(a[i][j]==0)continue;\\n                int val=dp[i-1][j];\\n                if(val==0)continue;\\n                int mx_chck=2*val+1;\\n                int curr_col=j;\\n                int diff=1;\\n                while(curr_col+diff<m && curr_col-diff>=0 && 2*diff+1<=mx_chck)\\n                {\\n                    int prev=curr_col-diff;\\n                    int next=curr_col+diff;\\n                    int temp_val=pre[i][next];\\n                    if(prev>0)temp_val-=pre[i][prev-1];\\n                    if(next-prev+1==temp_val)\\n                    {\\n                        dp[i][j]++;\\n                    }\\n                    else break;\\n                    diff++;\\n                }\\n                \\n            }\\n        }\\n        for(int i=0;i<n;i++)\\n        {\\n            for(int j=0;j<m;j++)\\n            {\\n                //cout<<dp[i][j]<<\" \";\\n                if(dp[i][j]>=2)ans+=dp[i][j]-1;\\n            }\\n            //cout<<endl;\\n        }\\n        for(int i=0;i<n;i++)\\n        {\\n            for(int j=0;j<m;j++)\\n            {\\n                dp[i][j]=0;\\n            }\\n        }\\n        for(int i=0;i<m;i++)\\n        {\\n            dp[n-1][i]=a[n-1][i];\\n        }\\n        for(int i=n-2;i>=0;i--)\\n        {\\n            for(int j=0;j<m;j++)\\n            {\\n                if(a[i][j]==1)dp[i][j]=1;\\n                if(a[i][j]==0)continue;\\n                int val=dp[i+1][j];\\n                if(val==0)continue;\\n                int mx_chck=2*val+1;\\n                int curr_col=j;\\n                int diff=1;\\n                while(curr_col+diff<m && curr_col-diff>=0 && 2*diff+1<=mx_chck)\\n                {\\n                    int prev=curr_col-diff;\\n                    int next=curr_col+diff;\\n                    int temp_val=pre[i][next];\\n                    if(prev>0)temp_val-=pre[i][prev-1];\\n                    if(next-prev+1==temp_val)\\n                    {\\n                        dp[i][j]++;\\n                    }\\n                    else break;\\n                    diff++;\\n                }\\n            }\\n        }\\n        for(int i=0;i<n;i++)\\n        {\\n            for(int j=0;j<m;j++)\\n            {\\n                //cout<<dp[i][j]<<\" \";\\n                if(dp[i][j]>=2)ans+=dp[i][j]-1;\\n            }\\n            //cout<<endl;\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "Dynamic Programming",
                    "Prefix Sum"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int countPyramids(vector<vector<int>>& a) {\\n        int n=a.size();\\n        int m=a[0].size();\\n        vector< vector<int> > dp(n,vector<int> (m,0));\\n        for(int i=0;i<m;i++)\\n        {\\n            dp[0][i]=a[0][i];\\n        }\\n        vector< vector<int> > pre(n,vector<int> (m,0));\\n        for(int i=0;i<n;i++)\\n        {\\n            for(int j=0;j<m;j++)\\n            {\\n                if(j==0)\\n                {\\n                    pre[i][0]=a[i][0];\\n                }\\n                else\\n                {\\n                    pre[i][j]=a[i][j]+pre[i][j-1];\\n                }\\n            }\\n        }\\n        int ans=0;\\n        for(int i=1;i<n;i++)\\n        {\\n            for(int j=0;j<m;j++)\\n            {\\n                if(a[i][j]==1)dp[i][j]=1;\\n                if(a[i][j]==0)continue;\\n                int val=dp[i-1][j];\\n                if(val==0)continue;\\n                int mx_chck=2*val+1;\\n                int curr_col=j;\\n                int diff=1;\\n                while(curr_col+diff<m && curr_col-diff>=0 && 2*diff+1<=mx_chck)\\n                {\\n                    int prev=curr_col-diff;\\n                    int next=curr_col+diff;\\n                    int temp_val=pre[i][next];\\n                    if(prev>0)temp_val-=pre[i][prev-1];\\n                    if(next-prev+1==temp_val)\\n                    {\\n                        dp[i][j]++;\\n                    }\\n                    else break;\\n                    diff++;\\n                }\\n                \\n            }\\n        }\\n        for(int i=0;i<n;i++)\\n        {\\n            for(int j=0;j<m;j++)\\n            {\\n                //cout<<dp[i][j]<<\" \";\\n                if(dp[i][j]>=2)ans+=dp[i][j]-1;\\n            }\\n            //cout<<endl;\\n        }\\n        for(int i=0;i<n;i++)\\n        {\\n            for(int j=0;j<m;j++)\\n            {\\n                dp[i][j]=0;\\n            }\\n        }\\n        for(int i=0;i<m;i++)\\n        {\\n            dp[n-1][i]=a[n-1][i];\\n        }\\n        for(int i=n-2;i>=0;i--)\\n        {\\n            for(int j=0;j<m;j++)\\n            {\\n                if(a[i][j]==1)dp[i][j]=1;\\n                if(a[i][j]==0)continue;\\n                int val=dp[i+1][j];\\n                if(val==0)continue;\\n                int mx_chck=2*val+1;\\n                int curr_col=j;\\n                int diff=1;\\n                while(curr_col+diff<m && curr_col-diff>=0 && 2*diff+1<=mx_chck)\\n                {\\n                    int prev=curr_col-diff;\\n                    int next=curr_col+diff;\\n                    int temp_val=pre[i][next];\\n                    if(prev>0)temp_val-=pre[i][prev-1];\\n                    if(next-prev+1==temp_val)\\n                    {\\n                        dp[i][j]++;\\n                    }\\n                    else break;\\n                    diff++;\\n                }\\n            }\\n        }\\n        for(int i=0;i<n;i++)\\n        {\\n            for(int j=0;j<m;j++)\\n            {\\n                //cout<<dp[i][j]<<\" \";\\n                if(dp[i][j]>=2)ans+=dp[i][j]-1;\\n            }\\n            //cout<<endl;\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "C++"
            },
            {
                "id": 1599278,
                "title": "java-dp-o-m-n",
                "content": "\\n\\n```\\nclass Solution {\\n    public int countPyramids(int[][] grid) {\\n        int n = grid.length;\\n        int m = grid[0].length;\\n        int ans = 0;\\n        int dp[][] = new int[n][m];\\n        \\n\\t\\t// for pyramidplot \\n        for(int i = 1; i<n; i++){\\n            int sum = 0;\\n            for(int j = 0; j<m; j++){\\n                sum = grid[i][j] == 0 ? 0 : sum+1;\\n                if(j != 0){\\n                    if(sum > 2 && grid[i-1][j-1] == 1){\\n                        // min is taken since we have to consider the base as well as the layers the pyramid has\\n\\t\\t\\t\\t\\t\\tdp[i][j] = Math.min(dp[i-1][j-1] + 1, (sum-1)/2);    // (sum-1) is done for even sum\\n\\t\\t\\t\\t\\t}\\n                }\\n                ans += dp[i][j];\\n            }\\n        }\\n        \\n        dp = new int[n][m];\\n\\t\\t// for reverse pyramid plot\\n\\t\\tfor(int i = n-2; i>=0; i--){\\n            int sum = 0;\\n            for(int j = 0; j<m; j++){\\n                sum = grid[i][j] == 0 ? 0 : sum+1;\\n                if(j != 0){\\n                    if(sum > 2 && grid[i+1][j-1] == 1){\\n                        dp[i][j] = Math.min(dp[i+1][j-1] + 1, (sum-1)/2);\\n                    }\\n                }\\n                ans += dp[i][j];\\n            }\\n        }\\n        \\n        return ans;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Dynamic Programming"
                ],
                "code": "```\\nclass Solution {\\n    public int countPyramids(int[][] grid) {\\n        int n = grid.length;\\n        int m = grid[0].length;\\n        int ans = 0;\\n        int dp[][] = new int[n][m];\\n        \\n\\t\\t// for pyramidplot \\n        for(int i = 1; i<n; i++){\\n            int sum = 0;\\n            for(int j = 0; j<m; j++){\\n                sum = grid[i][j] == 0 ? 0 : sum+1;\\n                if(j != 0){\\n                    if(sum > 2 && grid[i-1][j-1] == 1){\\n                        // min is taken since we have to consider the base as well as the layers the pyramid has\\n\\t\\t\\t\\t\\t\\tdp[i][j] = Math.min(dp[i-1][j-1] + 1, (sum-1)/2);    // (sum-1) is done for even sum\\n\\t\\t\\t\\t\\t}\\n                }\\n                ans += dp[i][j];\\n            }\\n        }\\n        \\n        dp = new int[n][m];\\n\\t\\t// for reverse pyramid plot\\n\\t\\tfor(int i = n-2; i>=0; i--){\\n            int sum = 0;\\n            for(int j = 0; j<m; j++){\\n                sum = grid[i][j] == 0 ? 0 : sum+1;\\n                if(j != 0){\\n                    if(sum > 2 && grid[i+1][j-1] == 1){\\n                        dp[i][j] = Math.min(dp[i+1][j-1] + 1, (sum-1)/2);\\n                    }\\n                }\\n                ans += dp[i][j];\\n            }\\n        }\\n        \\n        return ans;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1599240,
                "title": "sharing-my-dp-solution-100-faster",
                "content": "```\\nclass Solution {\\npublic:\\n    \\n    int solve(vector<vector<int>> arr){\\n        int r = arr.size();\\n        int c = arr[0].size();\\n        \\n        vector<vector<int>> vals(r, vector<int>(c));\\n        \\n        for(int i = 0; i < r; ++i){\\n            int cnt = 0;\\n            for(int j = 0; j < c; ++j){\\n                if(arr[i][j] == 0){\\n                    cnt = 0;\\n                }\\n                else{\\n                    cnt++;\\n                }\\n                vals[i][j] = cnt;\\n            }\\n        }\\n        for(int i = 0; i < r; ++i){\\n            int cnt = 0;\\n            for(int j = c-1; j >= 0; --j){\\n                if(arr[i][j] == 0){\\n                    cnt = 0;\\n                }\\n                else{\\n                    cnt++;\\n                }\\n                vals[i][j] = min(vals[i][j],cnt);\\n            }\\n        }\\n        \\n        int ans = 0;\\n        for(int i = 0; i < r; ++i){\\n            for(int j = 0; j < c; ++j){\\n                if(vals[i][j] == 0) continue;\\n                int k = 0;\\n                while(i + k < r && vals[i+k][j] >= k+1) k++;\\n                ans += k-1;\\n            }\\n        }\\n        return ans;\\n        \\n    }\\n    \\n    int countPyramids(vector<vector<int>>& arr) {\\n        \\n        int ans = 0;\\n        ans += solve(arr);\\n        reverse(arr.begin(), arr.end());\\n        ans += solve(arr);\\n        return ans;\\n        \\n        \\n        \\n    }\\n};\\n```",
                "solutionTags": [
                    "Dynamic Programming"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    \\n    int solve(vector<vector<int>> arr){\\n        int r = arr.size();\\n        int c = arr[0].size();\\n        \\n        vector<vector<int>> vals(r, vector<int>(c));\\n        \\n        for(int i = 0; i < r; ++i){\\n            int cnt = 0;\\n            for(int j = 0; j < c; ++j){\\n                if(arr[i][j] == 0){\\n                    cnt = 0;\\n                }\\n                else{\\n                    cnt++;\\n                }\\n                vals[i][j] = cnt;\\n            }\\n        }\\n        for(int i = 0; i < r; ++i){\\n            int cnt = 0;\\n            for(int j = c-1; j >= 0; --j){\\n                if(arr[i][j] == 0){\\n                    cnt = 0;\\n                }\\n                else{\\n                    cnt++;\\n                }\\n                vals[i][j] = min(vals[i][j],cnt);\\n            }\\n        }\\n        \\n        int ans = 0;\\n        for(int i = 0; i < r; ++i){\\n            for(int j = 0; j < c; ++j){\\n                if(vals[i][j] == 0) continue;\\n                int k = 0;\\n                while(i + k < r && vals[i+k][j] >= k+1) k++;\\n                ans += k-1;\\n            }\\n        }\\n        return ans;\\n        \\n    }\\n    \\n    int countPyramids(vector<vector<int>>& arr) {\\n        \\n        int ans = 0;\\n        ans += solve(arr);\\n        reverse(arr.begin(), arr.end());\\n        ans += solve(arr);\\n        return ans;\\n        \\n        \\n        \\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1599169,
                "title": "simple-c-brute-force-solution-o-n-n-m-prefix-sum",
                "content": "```\\nclass Solution {\\npublic:\\n    int countPyramids(vector<vector<int>>& a) {\\n        int n=a.size(),m=a[0].size();\\n        vector<vector<int>> p=a;\\n        for(int i=0;i<n;i++){\\n            for(int j=1;j<m;j++){\\n                if(a[i][j]==0) continue;\\n                p[i][j]+=p[i][j-1];\\n            }\\n        }\\n        int ans=0;\\n        for(int i=0;i<n;i++){\\n            for(int j=0;j<m;j++){\\n                if(a[i][j]==0) continue;\\n                int b=i-1,c=j+1,d=3;\\n                while(b>=0 && c<m && p[b][c]>=d){\\n                    ans++;b--;c++;d+=2;\\n                }\\n                b=i+1,c=j+1,d=3;\\n                while(b<n && c<m && p[b][c]>=d){\\n                    ans++;b++;c++;d+=2;\\n                }\\n            }\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C",
                    "Prefix Sum"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int countPyramids(vector<vector<int>>& a) {\\n        int n=a.size(),m=a[0].size();\\n        vector<vector<int>> p=a;\\n        for(int i=0;i<n;i++){\\n            for(int j=1;j<m;j++){\\n                if(a[i][j]==0) continue;\\n                p[i][j]+=p[i][j-1];\\n            }\\n        }\\n        int ans=0;\\n        for(int i=0;i<n;i++){\\n            for(int j=0;j<m;j++){\\n                if(a[i][j]==0) continue;\\n                int b=i-1,c=j+1,d=3;\\n                while(b>=0 && c<m && p[b][c]>=d){\\n                    ans++;b--;c++;d+=2;\\n                }\\n                b=i+1,c=j+1,d=3;\\n                while(b<n && c<m && p[b][c]>=d){\\n                    ans++;b++;c++;d+=2;\\n                }\\n            }\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1599149,
                "title": "python3-dp-o-mn-100-100",
                "content": "Let\\'s define D[i][j] as the number of pyramids where apex is (i, j).\\nWe can calculate that by `(the maximum height of pyramid with apex (i, j)) - 1`.  (We don\\'t have to count 1 size pyramid.)\\nFor example, if the maximum height of pyramids is 4, the number of pyramids sharing the same apex is 3.\\n\\nLet\\'s consider non-inverse pyramids first.\\nWhen we construct pyramids with apex (i, j), the maximum height should be `1 + (minimum height of 3 sub-pyramids where apexes are (i + 1, j - 1), (i + 1, j), (i + 1, j + 1)`.\\n\\nAs I said above, we can get the number of pyramids sharing the same apex by substracting 1 from the maximum height with following rules.\\nIf we cannot construct any pyramids as grid[i][j] is 0, set D[i][j] as -1.\\nIf we can construct a pyramid but the maximum height is 1, set D[i][j] as 0. As we set it as 0 instead of 1, this has the same effect of substracting 1 from the maximum height.\\nFor else, `D[i][j] = min(D[i + 1][j - 1], D[i + 1][j], D[i + 1][j + 1]) + 1`.\\nFinally, the total number of non-inverse pyramids should be the sum of max(D[i][j], 0).\\n\\nWe can do the same thing for inverse pyramids.\\nNote that, I memorized only last 2 rows, because we don\\'t need old ones in the future.\\n\\n- time complexity: O(MN)\\n- space complexity: O(N)\\n\\n```\\nclass Solution:\\n    def countPyramids(self, grid: List[List[int]]) -> int:\\n        m, n = len(grid), len(grid[0])\\n        D = [[-1] * n for _ in range(2)] # D[i][j] = the number of pyramids where apex is (i, j)\\n        DI = [[-1] * n for _ in range(2)] # for inverse\\n        ans = 0\\n        turn = 0\\n\\n        for j in range(n):\\n            D[0][j] = 0 if grid[m - 1][j] else -1\\n            DI[0][j] = 0 if grid[0][j] else -1\\n\\n        for i in range(m - 2, -1, -1):\\n            for j in range(n):\\n                if grid[i][j] == 0:\\n                    D[not turn][j] = -1\\n                else:\\n                    if j == 0 or j == n - 1: D[not turn][j] = 0\\n                    else: D[not turn][j] = min(D[turn][j - 1], D[turn][j], D[turn][j + 1]) + 1\\n\\n                if grid[m - i - 1][j] == 0:\\n                    DI[not turn][j] = -1\\n                else:\\n                    if j == 0 or j == n - 1: DI[not turn][j] = 0\\n                    else: DI[not turn][j] = min(DI[turn][j - 1], DI[turn][j], DI[turn][j + 1]) + 1\\n\\n                ans += max(D[not turn][j], 0) + max(DI[not turn][j], 0)\\n\\n            turn = not turn\\n\\n        return ans\\n```",
                "solutionTags": [
                    "Python3",
                    "Dynamic Programming"
                ],
                "code": "```\\nclass Solution:\\n    def countPyramids(self, grid: List[List[int]]) -> int:\\n        m, n = len(grid), len(grid[0])\\n        D = [[-1] * n for _ in range(2)] # D[i][j] = the number of pyramids where apex is (i, j)\\n        DI = [[-1] * n for _ in range(2)] # for inverse\\n        ans = 0\\n        turn = 0\\n\\n        for j in range(n):\\n            D[0][j] = 0 if grid[m - 1][j] else -1\\n            DI[0][j] = 0 if grid[0][j] else -1\\n\\n        for i in range(m - 2, -1, -1):\\n            for j in range(n):\\n                if grid[i][j] == 0:\\n                    D[not turn][j] = -1\\n                else:\\n                    if j == 0 or j == n - 1: D[not turn][j] = 0\\n                    else: D[not turn][j] = min(D[turn][j - 1], D[turn][j], D[turn][j + 1]) + 1\\n\\n                if grid[m - i - 1][j] == 0:\\n                    DI[not turn][j] = -1\\n                else:\\n                    if j == 0 or j == n - 1: DI[not turn][j] = 0\\n                    else: DI[not turn][j] = min(DI[turn][j - 1], DI[turn][j], DI[turn][j + 1]) + 1\\n\\n                ans += max(D[not turn][j], 0) + max(DI[not turn][j], 0)\\n\\n            turn = not turn\\n\\n        return ans\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1599075,
                "title": "java-easiest-solution-possible",
                "content": "class Solution {\\n    public int countPyramids(int[][] grid) {\\n        \\n        int n = grid.length;\\n        int m = grid[0].length;\\n        \\n        for(int i = 0; i< n; i++){\\n            \\n            int tmp = 0;\\n            for(int j = 0; j<m; j++){\\n                if(grid[i][j] == 0){\\n                    tmp = 0;\\n                }else{\\n                    tmp++;\\n                }\\n                grid[i][j] = tmp;\\n            }\\n         \\n            tmp = 0;\\n            for(int j = m-1; j>=0; j--){\\n                if(grid[i][j] == 0 ){\\n                    tmp=0;\\n                }else {\\n                    tmp++;\\n                }\\n                grid[i][j] = Math.min(grid[i][j], tmp);\\n            }\\n           \\n        }\\n        int ans = 0;\\n        \\n        for(int i=0; i<n; i++){\\n            for(int j=0;j<m;j++){\\n                if(grid[i][j] == 0) continue;\\n                \\n                int k = 0;\\n                while( k+i < n && grid[k+i][j] > k ) k++;\\n                ans += k - 1;\\n                \\n                k = 0;\\n                while(i-k>=0 && grid[i-k][j] > k) k++;\\n                ans += k - 1;\\n            }\\n        }\\n        \\n        return ans;\\n    }\\n}\\n\\n\\n\\n",
                "solutionTags": [
                    "Java",
                    "Prefix Sum"
                ],
                "code": "class Solution {\\n    public int countPyramids(int[][] grid) {\\n        \\n        int n = grid.length;\\n        int m = grid[0].length;\\n        \\n        for(int i = 0; i< n; i++){\\n            \\n            int tmp = 0;\\n            for(int j = 0; j<m; j++){\\n                if(grid[i][j] == 0){\\n                    tmp = 0;\\n                }",
                "codeTag": "Java"
            },
            {
                "id": 1599063,
                "title": "python-thinking-process-and-straightforward-solution-o-m-n",
                "content": "Thinking process:\\n\\n1. we only need to count one type of pyramids. For the other type, just reverse the grid and count again.\\n2. Let\\'s say we count the face-up type. \\n\\t* Let `dp[i][j]` be the height of the pyramid with `(i,j)` as the top. \\n\\t* To get the height (if `grid[i][j]==1`),  we only need to look at the three cells in the next row, `dp[i+1][j-1], dp[i+1][j], dp[i+1][j+1]`in the next row  (look at the pictures given in the problem and you can see this is true)\\n\\t* So the height is `dp[i][j] = min(dp[i+1][j-1],dp[i+1][j],dp[i+1][j+1])+1     if grid[i][j]= 1` \\n\\t* Then the number of pyramids with `(i,j)` as top is `dp[i][j]-1`\\n3. To sum up, we just scan the grid from bottom row to top and build `dp` and count\\n\\nSo time complexity O(m * n) and space complexity is O(m * n).\\n\\nSince this count only relies on two consecutive rows, we may further optimize the space complexity to O(n)  (just use two rows)\\n\\n\\n```\\nclass Solution:\\n    def countPyramids(self, grid: List[List[int]]) -> int:\\n        \\n        def helper(grid):\\n\\t\\t\\t# count the face-up type pyramid\\n            m, n = len(grid), len(grid[0])\\n            ct = 0\\n\\n            dp = [[0]*n for _ in range(m)]\\n\\n            for i in range(m-1,-1,-1):\\n                for j in range(n):\\n                    if i==m-1:\\n                        dp[i][j] = grid[i][j]\\n                    else:\\n                        if j==0 or j==n-1:\\n                            dp[i][j] = grid[i][j]\\n                        else:\\n                            if grid[i][j]==0:\\n                                dp[i][j]=0\\n                            else:\\n                                dp[i][j] = min(dp[i+1][j-1],dp[i+1][j],dp[i+1][j+1])+1\\n                    if dp[i][j]>1:\\n                        ct += dp[i][j]-1\\n            return ct\\n        \\n        \\n        m, n = len(grid), len(grid[0])\\n        reverse_grid = [[grid[m-1-i][j] for j in range(n)] for i in range(m)]\\n        return helper(grid) +helper(reverse_grid)\\n        \\n        \\n        \\n```",
                "solutionTags": [
                    "Dynamic Programming"
                ],
                "code": "```\\nclass Solution:\\n    def countPyramids(self, grid: List[List[int]]) -> int:\\n        \\n        def helper(grid):\\n\\t\\t\\t# count the face-up type pyramid\\n            m, n = len(grid), len(grid[0])\\n            ct = 0\\n\\n            dp = [[0]*n for _ in range(m)]\\n\\n            for i in range(m-1,-1,-1):\\n                for j in range(n):\\n                    if i==m-1:\\n                        dp[i][j] = grid[i][j]\\n                    else:\\n                        if j==0 or j==n-1:\\n                            dp[i][j] = grid[i][j]\\n                        else:\\n                            if grid[i][j]==0:\\n                                dp[i][j]=0\\n                            else:\\n                                dp[i][j] = min(dp[i+1][j-1],dp[i+1][j],dp[i+1][j+1])+1\\n                    if dp[i][j]>1:\\n                        ct += dp[i][j]-1\\n            return ct\\n        \\n        \\n        m, n = len(grid), len(grid[0])\\n        reverse_grid = [[grid[m-1-i][j] for j in range(n)] for i in range(m)]\\n        return helper(grid) +helper(reverse_grid)\\n        \\n        \\n        \\n```",
                "codeTag": "Java"
            },
            {
                "id": 1599044,
                "title": "java-100-faster-dp-solution-easy-explanation-with-code",
                "content": "A quick observation is just find how many pyramidal plots are there. You can find the count of inverse pyramidal plots by rotating the matrix. So for simplicity, lets just talk about how many pyramidal plots are there in total.\\n\\n1. Ask this question: \\n\\t* if `grid[i][j]==1`, how many pyramids you can get with `(i,j)` as the apex.\\n\\n2. The answer is `(h - 1)`, where h is the height of the pyramidal plot with `(i,j)` as the apex.\\n3. So lets, compute the height of the pyramidal plot with `(i,j)` as the apex.\\n4. Now, the height of this plot is the `(minimum height of 3 plots below the apex) + 1`\\n\\t\\n5. So, keep an dp array, such that dp[i][j] tells the maximum height of the pyramid with apex (i,j), then,\\n\\t`dp[i][j] = min( dp[i+1][j-1] , min ( dp[i+1][j] , dp[i+1][j+1] ) ) + 1`\\n\\t\\n-> Simply find the sum of all dp[i][j].\\n-> Repeat the process for inverse-pyramidal plot and return the value of count\\n\\nThe Code of the above explanation is herewith:\\n\\n```\\nclass Solution {\\n    public int countPyramids(int[][] grid) {\\n        int n = grid.length;\\n        int m = grid[0].length;\\n        \\n        int[][] dp = new int[n][m];\\n        int count = 0;\\n        \\n        //counting for the pyramidal plot\\n        for(int i=n-2;i>=0;i--){\\n            for(int j=1;j<m-1;j++){\\n                if(grid[i][j]==1){\\n                    if(grid[i+1][j-1]==1 && grid[i+1][j]==1 && grid[i+1][j+1]==1){\\n                        dp[i][j] = Math.min(dp[i+1][j-1], Math.min(dp[i+1][j], dp[i+1][j+1])) + 1;\\n                        count += dp[i][j];\\n                    }\\n                }\\n            }\\n        }\\n        \\n        dp = new int[n][m];\\n        //counting for the inverse pyramidal plot\\n        for(int i=1;i<n;i++){\\n            for(int j=1;j<m-1;j++){\\n                if(grid[i][j]==1){\\n                    if(grid[i-1][j-1]==1 && grid[i-1][j]==1 && grid[i-1][j+1]==1){\\n                        dp[i][j] = Math.min(dp[i-1][j-1], Math.min(dp[i-1][j], dp[i-1][j+1])) + 1;\\n                        count += dp[i][j];\\n                    }\\n                }\\n            }\\n        }\\n        \\n        return count;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Dynamic Programming"
                ],
                "code": "```\\nclass Solution {\\n    public int countPyramids(int[][] grid) {\\n        int n = grid.length;\\n        int m = grid[0].length;\\n        \\n        int[][] dp = new int[n][m];\\n        int count = 0;\\n        \\n        //counting for the pyramidal plot\\n        for(int i=n-2;i>=0;i--){\\n            for(int j=1;j<m-1;j++){\\n                if(grid[i][j]==1){\\n                    if(grid[i+1][j-1]==1 && grid[i+1][j]==1 && grid[i+1][j+1]==1){\\n                        dp[i][j] = Math.min(dp[i+1][j-1], Math.min(dp[i+1][j], dp[i+1][j+1])) + 1;\\n                        count += dp[i][j];\\n                    }\\n                }\\n            }\\n        }\\n        \\n        dp = new int[n][m];\\n        //counting for the inverse pyramidal plot\\n        for(int i=1;i<n;i++){\\n            for(int j=1;j<m-1;j++){\\n                if(grid[i][j]==1){\\n                    if(grid[i-1][j-1]==1 && grid[i-1][j]==1 && grid[i-1][j+1]==1){\\n                        dp[i][j] = Math.min(dp[i-1][j-1], Math.min(dp[i-1][j], dp[i-1][j+1])) + 1;\\n                        count += dp[i][j];\\n                    }\\n                }\\n            }\\n        }\\n        \\n        return count;\\n    }\\n}\\n```",
                "codeTag": "Java"
            }
        ],
        "discussions": [
            {
                "id": 1989159,
                "content": [
                    {
                        "username": "QuakerOATI",
                        "content": "A very nice problem.  The solution I landed on is extremely simple yet nonobvious."
                    },
                    {
                        "username": "Aman__Bhardwaj",
                        "content": "I\\'m First, Funny ?? \\uD83D\\uDE05\\uD83D\\uDE05"
                    }
                ]
            },
            {
                "id": 1922650,
                "content": [
                    {
                        "username": "QuakerOATI",
                        "content": "A very nice problem.  The solution I landed on is extremely simple yet nonobvious."
                    },
                    {
                        "username": "Aman__Bhardwaj",
                        "content": "I\\'m First, Funny ?? \\uD83D\\uDE05\\uD83D\\uDE05"
                    }
                ]
            }
        ]
    }
]