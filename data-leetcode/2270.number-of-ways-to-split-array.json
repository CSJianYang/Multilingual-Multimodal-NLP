[
    {
        "title": "Replace Non-Coprime Numbers in Array",
        "question_content": "You are given an array of integers nums. Perform the following steps:\n\n\tFind any two adjacent numbers in nums that are non-coprime.\n\tIf no such numbers are found, stop the process.\n\tOtherwise, delete the two numbers and replace them with their LCM (Least Common Multiple).\n\tRepeat this process as long as you keep finding two adjacent non-coprime numbers.\n\nReturn the final modified array. It can be shown that replacing adjacent non-coprime numbers in any arbitrary order will lead to the same result.\nThe test cases are generated such that the values in the final array are less than or equal to 108.\nTwo values x and y are non-coprime if GCD(x, y) > 1 where GCD(x, y) is the Greatest Common Divisor of x and y.\n&nbsp;\nExample 1:\n\nInput: nums = [6,4,3,2,7,6,2]\nOutput: [12,7,6]\nExplanation: \n- (6, 4) are non-coprime with LCM(6, 4) = 12. Now, nums = [12,3,2,7,6,2].\n- (12, 3) are non-coprime with LCM(12, 3) = 12. Now, nums = [12,2,7,6,2].\n- (12, 2) are non-coprime with LCM(12, 2) = 12. Now, nums = [12,7,6,2].\n- (6, 2) are non-coprime with LCM(6, 2) = 6. Now, nums = [12,7,6].\nThere are no more adjacent non-coprime numbers in nums.\nThus, the final modified array is [12,7,6].\nNote that there are other ways to obtain the same resultant array.\n\nExample 2:\n\nInput: nums = [2,2,1,1,3,3,3]\nOutput: [2,1,1,3]\nExplanation: \n- (3, 3) are non-coprime with LCM(3, 3) = 3. Now, nums = [2,2,1,1,3,3].\n- (3, 3) are non-coprime with LCM(3, 3) = 3. Now, nums = [2,2,1,1,3].\n- (2, 2) are non-coprime with LCM(2, 2) = 2. Now, nums = [2,1,1,3].\nThere are no more adjacent non-coprime numbers in nums.\nThus, the final modified array is [2,1,1,3].\nNote that there are other ways to obtain the same resultant array.\n\n&nbsp;\nConstraints:\n\n\t1 <= nums.length <= 105\n\t1 <= nums[i] <= 105\n\tThe test cases are generated such that the values in the final array are less than or equal to 108.",
        "solutions": [
            {
                "id": 1823596,
                "title": "c-python-stack-math",
                "content": "## Observations\\n\\nThis hint made the question very easy.\\n\\n```\\nIt can be shown that replacing adjacent non-coprime numbers in any arbitrary order will lead to the same result.\\n```\\nIt could have been transformed to a trick question if this fact was not stated.\\n\\nNow, since the order doesn\\'t matter we have the following observations.\\n\\n### Observation 1\\n\\nIf we start processing from the first element one by one, we only care about the last two elements so we can simply check if they have a `gcd > 1` in `O(log(n))` time (using built in functions or Eucledian algorithm). If they are co-prime we can replace them with their LCM, more on that in `Observation 2`. Once replaced by the LCM we have reduced the previous two elements by one and thus we can check the LCM element with the 3rd last element. Eg: `[x,y,z]` -> `[x, LCM(y,z)]` -> `[LCM(x,(LCM(y,z)))]`. \\n\\nThis setting is similar to many stack related questions like:\\n\\n[1047. Remove All Adjacent Duplicates In String](https://leetcode.com/problems/remove-all-adjacent-duplicates-in-string/)\\n[1209. Remove All Adjacent Duplicates in String II](https://leetcode.com/problems/remove-all-adjacent-duplicates-in-string-ii/)\\n[1717. Maximum Score From Removing Substrings](https://leetcode.com/problems/maximum-score-from-removing-substrings/)\\n\\nThus using a stack we can keep repeating this process until the stack is empty or the last two numbers are co-prime and then move on to the next iteration/element of the input and repeat.\\n\\n### Observation 2\\n\\nHow do we get `LCM` of two numbers? Well there is a mathematical formula to do that for two numbers `a` and `b`.\\n`LCM(a,b) * GCD(a,b) = a * b` therefore `LCM(a,b) = (a * b) / GCD(a,b)`.\\n\\nWe can use these two observations to formulate our solution.\\n\\n## Solution\\n**C++**\\n\\n```c++\\nclass Solution {\\npublic:\\n    vector<int> replaceNonCoprimes(vector<int>& nums) {\\n        vector<int> result;\\n        for(int &i:nums) {\\n            result.push_back(i);        // Push the new element in stack.\\n            while(result.size()>1&&__gcd(result.back(),result[result.size()-2])>1) {    // While we have two elements and they are not co-prime.\\n                long long a=result.back(),b=result[result.size()-2],g=__gcd(a,b);  // Get the last two numbers in the stack and their GCD.\\n                \\n                // Remove the two elements.\\n                result.pop_back();      \\n                result.pop_back();\\n                result.push_back(a*b/g); // Push the LCM of the two numbers, replacing them.\\n            }\\n        }\\n        return result;\\n    }\\n};\\n```\\n\\n**Python**\\n\\nCredits to [@tojuna](https://leetcode.com/tojuna/) for the python solution, please upvote his comment!\\n```python\\ndef replaceNonCoprimes(self, nums: List[int]) -> List[int]:\\n\\tstk = []\\n\\tfor num in nums:\\n\\t\\tstk.append(num)\\n\\t\\twhile len(stk) > 1 and gcd(stk[-1], stk[-2]) > 1:\\n\\t\\t\\tstk.append(lcm(stk.pop(), stk.pop()))\\n\\treturn stk\\n```\\n\\n## Complexity\\nSpace: `O(1)`. If you don\\'t consider the output space.\\nTime: `O(nlog(m))`. GCD of two numbers takes `O(log(min(a,b))`.\\n",
                "solutionTags": [],
                "code": "```\\nIt can be shown that replacing adjacent non-coprime numbers in any arbitrary order will lead to the same result.\\n```\n```c++\\nclass Solution {\\npublic:\\n    vector<int> replaceNonCoprimes(vector<int>& nums) {\\n        vector<int> result;\\n        for(int &i:nums) {\\n            result.push_back(i);        // Push the new element in stack.\\n            while(result.size()>1&&__gcd(result.back(),result[result.size()-2])>1) {    // While we have two elements and they are not co-prime.\\n                long long a=result.back(),b=result[result.size()-2],g=__gcd(a,b);  // Get the last two numbers in the stack and their GCD.\\n                \\n                // Remove the two elements.\\n                result.pop_back();      \\n                result.pop_back();\\n                result.push_back(a*b/g); // Push the LCM of the two numbers, replacing them.\\n            }\\n        }\\n        return result;\\n    }\\n};\\n```\n```python\\ndef replaceNonCoprimes(self, nums: List[int]) -> List[int]:\\n\\tstk = []\\n\\tfor num in nums:\\n\\t\\tstk.append(num)\\n\\t\\twhile len(stk) > 1 and gcd(stk[-1], stk[-2]) > 1:\\n\\t\\t\\tstk.append(lcm(stk.pop(), stk.pop()))\\n\\treturn stk\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1823798,
                "title": "java-c-python-stack-one-pass-solution",
                "content": "# **Explanation**\\nFor each number `a` in input array `A`,\\ncheck if it is coprime with the last number `b` in `res`.\\nIf it\\'s not coprime, then we can merge them by calculate `a * b / gcd(a, b)`.\\nand check we can continue to do this process.\\n\\nUntil it\\'s coprime with the last element in `res`,\\nwe append `a` at the end of `res`.\\n\\nWe do this for all elements `a` in `A`, and return the final result.\\n<br>\\n\\n# **Complexity**\\nTime `O(nlogn)`\\nSpace `O(n)`\\n<br>\\n\\n**Java**\\n```java\\n    public List<Integer> replaceNonCoprimes(int[] A) {\\n        LinkedList<Integer> res = new LinkedList();\\n        for (int a : A) {\\n            while (true) {\\n                int last = res.isEmpty() ? 1 : res.getLast();\\n                int x = gcd(last, a);\\n                if (x == 1) break; // co-prime\\n                a *= res.removeLast() / x;\\n            }\\n            res.add(a);\\n        }\\n        return res;\\n    }\\n\\n    private int gcd(int a, int b) {\\n        return b > 0 ? gcd(b, a % b) : a;\\n    }\\n```\\n\\n**C++**\\n```cpp\\n    vector<int> replaceNonCoprimes(vector<int>& A) {\\n        vector<int> res;\\n        for (int a: A) {   \\n            while (true) {   \\n                int x = gcd(res.empty() ? 1 : res.back(), a);\\n                if (x == 1) break; // co-prime\\n                a *= res.back() / x;\\n                res.pop_back();\\n            }\\n            res.push_back(a);\\n        }\\n        return res;\\n    }\\n```\\n\\n**Python3**\\n```py\\n    def replaceNonCoprimes(self, A):\\n        res = []\\n        for a in A:\\n            while True:\\n                x = math.gcd(res[-1] if res else 1, a)\\n                if x == 1: break # co-prime\\n                a *= res.pop() // x\\n            res.append(a)\\n        return res\\n```\\n",
                "solutionTags": [
                    "Java",
                    "Python",
                    "C"
                ],
                "code": "```java\\n    public List<Integer> replaceNonCoprimes(int[] A) {\\n        LinkedList<Integer> res = new LinkedList();\\n        for (int a : A) {\\n            while (true) {\\n                int last = res.isEmpty() ? 1 : res.getLast();\\n                int x = gcd(last, a);\\n                if (x == 1) break; // co-prime\\n                a *= res.removeLast() / x;\\n            }\\n            res.add(a);\\n        }\\n        return res;\\n    }\\n\\n    private int gcd(int a, int b) {\\n        return b > 0 ? gcd(b, a % b) : a;\\n    }\\n```\n```cpp\\n    vector<int> replaceNonCoprimes(vector<int>& A) {\\n        vector<int> res;\\n        for (int a: A) {   \\n            while (true) {   \\n                int x = gcd(res.empty() ? 1 : res.back(), a);\\n                if (x == 1) break; // co-prime\\n                a *= res.back() / x;\\n                res.pop_back();\\n            }\\n            res.push_back(a);\\n        }\\n        return res;\\n    }\\n```\n```py\\n    def replaceNonCoprimes(self, A):\\n        res = []\\n        for a in A:\\n            while True:\\n                x = math.gcd(res[-1] if res else 1, a)\\n                if x == 1: break # co-prime\\n                a *= res.pop() // x\\n            res.append(a)\\n        return res\\n```",
                "codeTag": "Python3"
            },
            {
                "id": 1823681,
                "title": "list",
                "content": "No need to overcomplicate. This is just a brute-force. Using the list just for fun; I feel it\\'s a bit easier to get right than a stack or two-pointer.\\n\\n**C++**\\n```cpp\\nvector<int> replaceNonCoprimes(vector<int>& nums) {\\n    list<int> l(begin(nums), end(nums));\\n    for (auto it = begin(l); it != end(l); ++it)\\n        if (it != begin(l)) {\\n            int n1 = *prev(it), n2 = *it;\\n            int it_gcd = gcd(n1, n2);\\n            if (it_gcd > 1) {\\n                l.erase(prev(it));\\n                *it = (long long)n1 * n2 / it_gcd;\\n                --it;\\n            }\\n        }\\n    return vector<int>(begin(l), end(l));\\n}\\n```",
                "solutionTags": [],
                "code": "```cpp\\nvector<int> replaceNonCoprimes(vector<int>& nums) {\\n    list<int> l(begin(nums), end(nums));\\n    for (auto it = begin(l); it != end(l); ++it)\\n        if (it != begin(l)) {\\n            int n1 = *prev(it), n2 = *it;\\n            int it_gcd = gcd(n1, n2);\\n            if (it_gcd > 1) {\\n                l.erase(prev(it));\\n                *it = (long long)n1 * n2 / it_gcd;\\n                --it;\\n            }\\n        }\\n    return vector<int>(begin(l), end(l));\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1823592,
                "title": "c-in-place-simulation-o-nlogm-time-o-1-extra-space",
                "content": "\\nSee my latest update in repo [LeetCode](https://github.com/lzl124631x/LeetCode)\\n\\n## Solution 1. Simulation + Two Pointers\\n\\n**Intuition**: From left to right, replace two adjacent non-coprime numbers with their LCM. When a merge happens, try keep merging leftwards.\\n\\n**Algorithm**: `i` is a read pointer scaning `A` from left to right. `j` is a write pointer. After reading a new number `A[j] = A[i]`, we keep trying to merge `A[j]` with `A[j-1]` if they are non-coprime. The new `A[j-1]` after merge is `LCM(A[j], A[j-1])`.\\n\\n**Time Complexity**:\\n\\nSince `gcd(a, b)`\\'s time complexity is `log(min(a, b))`, the time complexity is `O(NlogM)` overall where `M` is the maximum number in `A`.\\n\\n```cpp\\n// OJ: https://leetcode.com/contest/weekly-contest-283/problems/replace-non-coprime-numbers-in-array/\\n// Author: github.com/lzl124631x\\n// Time: O(N)\\n// Space: O(1) extra space\\nclass Solution {\\npublic:\\n    vector<int> replaceNonCoprimes(vector<int>& A) {\\n        int j = 0, N = A.size();\\n        for (int i = 0; i < N; ++i, ++j) {\\n            A[j] = A[i];\\n            for (; j - 1 >= 0 && gcd(A[j], A[j - 1]) > 1; --j) { // When we can merge leftwards from `A[j]`, keep merging\\n                A[j - 1] = (long)A[j] * A[j - 1] / gcd(A[j], A[j - 1]); // replace `A[j-1]` with LCM of `A[j-1]` and `A[j]`.\\n            }\\n        }\\n        A.resize(j);\\n        return A;\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```cpp\\n// OJ: https://leetcode.com/contest/weekly-contest-283/problems/replace-non-coprime-numbers-in-array/\\n// Author: github.com/lzl124631x\\n// Time: O(N)\\n// Space: O(1) extra space\\nclass Solution {\\npublic:\\n    vector<int> replaceNonCoprimes(vector<int>& A) {\\n        int j = 0, N = A.size();\\n        for (int i = 0; i < N; ++i, ++j) {\\n            A[j] = A[i];\\n            for (; j - 1 >= 0 && gcd(A[j], A[j - 1]) > 1; --j) { // When we can merge leftwards from `A[j]`, keep merging\\n                A[j - 1] = (long)A[j] * A[j - 1] / gcd(A[j], A[j - 1]); // replace `A[j-1]` with LCM of `A[j-1]` and `A[j]`.\\n            }\\n        }\\n        A.resize(j);\\n        return A;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1823645,
                "title": "c-python3-javascript-stack-one-pass",
                "content": "## idea\\n- we process the numbers from left to right, when processing a number, merge it to the left (with the already processed elements) until we can\\'t.\\n- maintain the processed elements by a stack.\\n## code\\n- C++\\n```\\nclass Solution {\\npublic:\\n    vector<int> replaceNonCoprimes(vector<int>& nums) {\\n        vector<int> res;\\n        for (auto num : nums) {\\n            while (!res.empty() && gcd(res.back(), num) > 1) {\\n                num = lcm(res.back(), num);\\n                res.pop_back();\\n            }\\n            res.push_back(num);\\n        }\\n        return res;\\n    }\\n};\\n```\\n- Python3\\n```\\nclass Solution:\\n    def replaceNonCoprimes(self, nums: List[int]) -> List[int]:\\n        res = []\\n        for num in nums:\\n            while res and gcd(res[-1], num) > 1:\\n                num = lcm(res[-1], num)\\n                res.pop()\\n            res.append(num)\\n        return res\\n```\\n- JavaScript (is there any built-in `gcd` or `lcm` in js?)\\n```\\nfunction gcd(a, b) {\\n    while (b > 0) {\\n        a %= b;\\n        [a, b] = [b, a];\\n    }\\n    return a;\\n}\\nfunction lcm(a, b) {\\n    return a / gcd(a, b) * b;\\n}\\n\\nvar replaceNonCoprimes = function(nums) {\\n    let res = new Array();\\n    for (let num of nums) {\\n        while (res.length > 0 && gcd(res.at(-1), num) > 1) {\\n            num = lcm(res.at(-1), num);\\n            res.pop();\\n        }\\n        res.push(num);\\n    }\\n    return res;\\n};\\n```\\n- Time Complexity\\n\\t- `O(n * log(1e8))` as we process each element once, and the complexity of both `gcd(a, b)` and `lcm(a, b)` are known to be `O(log(max(a, b)))`\\n- Space Complexity\\n\\t- `O(n)` used by `res`.\\n## Similar Problems\\n- Although the concepts are not exactly the same, the code of this problem looks like those related to **monotonic stacks**\\n- [LC 496 - Next Greater Element I](https://leetcode.com/problems/next-greater-element-i/) (solve it in linear time)\\n- [LC 503 - Next Greater Element II](https://leetcode.com/problems/next-greater-element-ii/)\\n- [LC 739 - Daily Temperatures](https://leetcode.com/problems/daily-temperatures/)\\n- [LC 402 - Remove K Digits](https://leetcode.com/problems/remove-k-digits/)\\n- [LC 1944 - Number of Visible People in a Queue](https://leetcode.com/problems/number-of-visible-people-in-a-queue/)\\n- [LC 84 - Largest Rectangle in Histogram](https://leetcode.com/problems/largest-rectangle-in-histogram/)\\n- [LC 85 - Maximum Rectangle](https://leetcode.com/problems/maximal-rectangle/)\\n- [LC 1340 - Jump Game V](https://leetcode.com/problems/jump-game-v/)",
                "solutionTags": [
                    "Python",
                    "C",
                    "JavaScript",
                    "Stack"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<int> replaceNonCoprimes(vector<int>& nums) {\\n        vector<int> res;\\n        for (auto num : nums) {\\n            while (!res.empty() && gcd(res.back(), num) > 1) {\\n                num = lcm(res.back(), num);\\n                res.pop_back();\\n            }\\n            res.push_back(num);\\n        }\\n        return res;\\n    }\\n};\\n```\n```\\nclass Solution:\\n    def replaceNonCoprimes(self, nums: List[int]) -> List[int]:\\n        res = []\\n        for num in nums:\\n            while res and gcd(res[-1], num) > 1:\\n                num = lcm(res[-1], num)\\n                res.pop()\\n            res.append(num)\\n        return res\\n```\n```\\nfunction gcd(a, b) {\\n    while (b > 0) {\\n        a %= b;\\n        [a, b] = [b, a];\\n    }\\n    return a;\\n}\\nfunction lcm(a, b) {\\n    return a / gcd(a, b) * b;\\n}\\n\\nvar replaceNonCoprimes = function(nums) {\\n    let res = new Array();\\n    for (let num of nums) {\\n        while (res.length > 0 && gcd(res.at(-1), num) > 1) {\\n            num = lcm(res.at(-1), num);\\n            res.pop();\\n        }\\n        res.push(num);\\n    }\\n    return res;\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1823603,
                "title": "c-stack-time-complexity-nlogd",
                "content": "**Approach** - \\n\\n0) As in questions says we have to choose adjacent , then I thought **stack** can be used .\\n1) we have to check whether the top value in the stack and the current val in array is non-coprime or not.\\n2) If the **gcd>1** then it means they are non-coprime , so just take the lcm of top value from stack(pop it also) and the current value and push it back to stack.\\n\\nImpo-\\n\\n3)Now first I think this will be valid let\\'s take an example - \\n\\n```\\nA = [4 2 3 5]\\nA = [4,3,5] , 4 and 2 are non-coprime so replace with LCM(4)\\nA = [4,3,5] , 4 and 3 are coprime nothing happens\\nA = [4,3,5] , 3 and 5 are coprime nothing happens\\n```\\n\\nBut wait , take another example where this is wrong-\\n\\n```\\nA = [5,2,3,6]\\nA = [5,2,3,6] , 5 and 2 are coprime nothing happens\\nA = [5,2,3,6] , 2 and 3 are coprime nothing happens\\nA = [5,2,6] , 3 and 6 are non-coprime so replace with LCM(6)\\n\\nin last my stack contains [5,2 6], I returned , this is wrong.\\n```\\n\\n**we have to do step 2 , untill we have non-coprime value from the current element and the top element , and then return it.**\\n\\n\\n\\n\\n```\\nclass Solution\\n{\\n    public:\\n        vector<int> replaceNonCoprimes(vector<int> &a)\\n        {\\n            stack<int> st;\\n            int n = a.size();\\n            for (int i = 0; i < n; i++)\\n            {\\n                int cr = a[i];\\n                int gcd, LCM, tp;\\n                while (!st.empty())\\n                {\\n\\n                    int gcd = __gcd(cr, st.top());\\n                    if (gcd > 1)\\n                    {\\n                        tp = st.top();\\n                        st.pop();\\n                        LCM = (cr / gcd) * tp;\\n                        cr = LCM;\\n                    }\\n                    else\\n                        break;\\n                }\\n                st.push(cr);\\n            }\\n\\n            vector<int> ans;\\n\\n            while (!st.empty())\\n            {\\n                ans.push_back(st.top());\\n                st.pop();\\n            }\\n\\n            reverse(ans.begin(), ans.end());\\n\\n            return ans;\\n        }\\n};\\n```\\nTime complexity : **NlogD** , where D is **maxA** , correct me if I am wrong.\\n\\n",
                "solutionTags": [
                    "Stack"
                ],
                "code": "```\\nA = [4 2 3 5]\\nA = [4,3,5] , 4 and 2 are non-coprime so replace with LCM(4)\\nA = [4,3,5] , 4 and 3 are coprime nothing happens\\nA = [4,3,5] , 3 and 5 are coprime nothing happens\\n```\n```\\nA = [5,2,3,6]\\nA = [5,2,3,6] , 5 and 2 are coprime nothing happens\\nA = [5,2,3,6] , 2 and 3 are coprime nothing happens\\nA = [5,2,6] , 3 and 6 are non-coprime so replace with LCM(6)\\n\\nin last my stack contains [5,2 6], I returned , this is wrong.\\n```\n```\\nclass Solution\\n{\\n    public:\\n        vector<int> replaceNonCoprimes(vector<int> &a)\\n        {\\n            stack<int> st;\\n            int n = a.size();\\n            for (int i = 0; i < n; i++)\\n            {\\n                int cr = a[i];\\n                int gcd, LCM, tp;\\n                while (!st.empty())\\n                {\\n\\n                    int gcd = __gcd(cr, st.top());\\n                    if (gcd > 1)\\n                    {\\n                        tp = st.top();\\n                        st.pop();\\n                        LCM = (cr / gcd) * tp;\\n                        cr = LCM;\\n                    }\\n                    else\\n                        break;\\n                }\\n                st.push(cr);\\n            }\\n\\n            vector<int> ans;\\n\\n            while (!st.empty())\\n            {\\n                ans.push_back(st.top());\\n                st.pop();\\n            }\\n\\n            reverse(ans.begin(), ans.end());\\n\\n            return ans;\\n        }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1823618,
                "title": "easy-c-stack",
                "content": "```\\nclass Solution {\\npublic:\\n    int gcd(int a, int b) {\\n      if (b == 0)\\n        return a;\\n      return gcd(b, a % b);\\n    }\\n\\n    int lcm(int a, int b) {\\n        return (a / gcd(a, b)) * b;\\n    }\\n    vector<int> replaceNonCoprimes(vector<int>& nums) {\\n        vector<int> modified;\\n        for (int i : nums) {\\n            int pre = 0, cur = i;\\n            while (modified.size() && gcd(modified.back(), cur) > 1) {\\n                pre  = modified.back();\\n                cur = lcm(cur, pre);\\n                modified.pop_back();\\n            }\\n            modified.push_back(cur);\\n        }\\n        \\n        return modified;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C",
                    "Math",
                    "Stack"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int gcd(int a, int b) {\\n      if (b == 0)\\n        return a;\\n      return gcd(b, a % b);\\n    }\\n\\n    int lcm(int a, int b) {\\n        return (a / gcd(a, b)) * b;\\n    }\\n    vector<int> replaceNonCoprimes(vector<int>& nums) {\\n        vector<int> modified;\\n        for (int i : nums) {\\n            int pre = 0, cur = i;\\n            while (modified.size() && gcd(modified.back(), cur) > 1) {\\n                pre  = modified.back();\\n                cur = lcm(cur, pre);\\n                modified.pop_back();\\n            }\\n            modified.push_back(cur);\\n        }\\n        \\n        return modified;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1823911,
                "title": "clean-java-code",
                "content": "\\tclass Solution {\\n\\t\\tpublic List<Integer> replaceNonCoprimes(int[] nums) \\n\\t\\t{\\n\\t\\t\\tList<Integer> al=new ArrayList<>();\\n\\t\\t\\tlong n1=nums[0];\\n\\t\\t\\tint idx=1;\\n\\n\\t\\t\\twhile(idx<nums.length)\\n\\t\\t\\t{\\n\\t\\t\\t\\tif((int)gcd(n1,nums[idx])==1)\\n\\t\\t\\t\\t{\\n\\t\\t\\t\\t\\twhile(al.size()!=0)\\n\\t\\t\\t\\t\\t{\\n\\t\\t\\t\\t\\t\\tint t=al.get(al.size()-1);\\n\\t\\t\\t\\t\\t\\tif(gcd(n1,t)==1)\\n\\t\\t\\t\\t\\t\\t\\tbreak;\\n\\t\\t\\t\\t\\t\\telse\\n\\t\\t\\t\\t\\t\\t{\\n\\t\\t\\t\\t\\t\\t\\tal.remove(al.size()-1);\\n\\t\\t\\t\\t\\t\\t\\tn1=lcm(t,n1);\\n\\t\\t\\t\\t\\t\\t}\\n\\t\\t\\t\\t\\t}\\n\\n\\t\\t\\t\\t\\tal.add((int)n1);\\n\\t\\t\\t\\t\\tn1=nums[idx];\\n\\t\\t\\t\\t\\tidx++;\\n\\t\\t\\t\\t}\\n\\t\\t\\t\\telse\\n\\t\\t\\t\\t{\\n\\t\\t\\t\\t\\tn1=lcm(n1,nums[idx]);\\n\\t\\t\\t\\t\\tidx++;\\n\\t\\t\\t\\t}\\n\\t\\t\\t}\\n\\n\\t\\t\\twhile(al.size()!=0)\\n\\t\\t\\t{\\n\\t\\t\\t\\tint t=al.get(al.size()-1);\\n\\t\\t\\t\\tif(gcd(n1,t)==1)\\n\\t\\t\\t\\t\\tbreak;\\n\\t\\t\\t\\telse\\n\\t\\t\\t\\t{\\n\\t\\t\\t\\t\\tal.remove(al.size()-1);\\n\\t\\t\\t\\t\\tn1=lcm(t,n1);\\n\\t\\t\\t\\t}\\n\\t\\t\\t} \\n\\t\\t\\tal.add((int)n1);\\n\\n\\t\\t\\treturn al;\\n\\t\\t}\\n\\n\\t\\tpublic long gcd(long a,long b)\\n\\t\\t{\\n\\t\\t\\tif (b == 0)   \\n\\t\\t\\t\\treturn a;  \\n\\n\\t\\t\\treturn gcd(b, a % b);  \\n\\t\\t}\\n\\n\\t\\tpublic long lcm(long a,long b)\\n\\t\\t{\\n\\t\\t\\tlong hcf=gcd(a,b);\\n\\t\\t\\treturn (a*b)/hcf;\\n\\t\\t}\\n\\t}",
                "solutionTags": [
                    "Java",
                    "Math"
                ],
                "code": "class Solution {\\n\\t\\tpublic List<Integer> replaceNonCoprimes(int[] nums) \\n\\t\\t{\\n\\t\\t\\tList<Integer> al=new ArrayList<>();\\n\\t\\t\\tlong n1=nums[0];\\n\\t\\t\\tint idx=1;\\n\\n\\t\\t\\twhile(idx<nums.length)\\n\\t\\t\\t{\\n\\t\\t\\t\\tif((int)gcd(n1,nums[idx])==1)\\n\\t\\t\\t\\t{\\n\\t\\t\\t\\t\\twhile(al.size()!=0)\\n\\t\\t\\t\\t\\t{\\n\\t\\t\\t\\t\\t\\tint t=al.get(al.size()-1);\\n\\t\\t\\t\\t\\t\\tif(gcd(n1,t)==1)\\n\\t\\t\\t\\t\\t\\t\\tbreak;\\n\\t\\t\\t\\t\\t\\telse\\n\\t\\t\\t\\t\\t\\t{\\n\\t\\t\\t\\t\\t\\t\\tal.remove(al.size()-1);\\n\\t\\t\\t\\t\\t\\t\\tn1=lcm(t,n1);\\n\\t\\t\\t\\t\\t\\t}",
                "codeTag": "Java"
            },
            {
                "id": 1847170,
                "title": "c-stack-with-approach",
                "content": "**C++ solution with Time Complexity = O(nlog m) and space complexity O(n)**,\\nwhere the length of the array and the maximum number present in the array is m.\\n## Approach\\nLet the final array be ans. \\n1.  For each number ```curr``` in array ```nums```, check whether it is Coprime with the last number ```top``` of ```ans``` array. Now, we have two possibilities:\\n\\t\\t\\ta. If they are Coprime, then insert ```curr``` to ```ans```.\\n\\t\\t\\tb. If they are not Coprime, replace ```curr``` with ```LCM (top, curr)``` and pop the last element of ```ans```. Repeat 1 until ```top``` and ```curr``` are not Coprime.\\n\\n\\n```cpp\\nclass Solution\\n{\\n    private:\\n        bool isCoprime(int x, int y)\\t// O(logM)  where M is max(x, y)\\n        {\\n            return gcd(x, y) == 1;\\t\\t\\n        }\\n        int gcd(int x, int y)\\t\\t\\t// O(logM)  where M is max(x, y)\\n        {\\n            return __gcd(x, y);\\t\\t\\n        }\\n        int lcm(int x, int y)\\t\\t\\t// O(logM)  where M is max(x, y)\\n        {\\n            long long LCM = x;\\n            LCM *= y;\\n            LCM /= gcd(x, y);\\n            return LCM;\\n        }\\n    public:\\n        vector<int> replaceNonCoprimes(vector<int> &nums)\\n        {\\n\\n            vector<int> ans;\\n            int n = nums.size();\\n            ans.push_back(nums[0]);\\n            for (int i = 1; i < n; i++)\\n            {\\n                int curr = nums[i];\\n                while (ans.size() && !isCoprime(ans.back(), curr))\\n                {\\n                    int top = ans.back();\\n                    ans.pop_back();\\n                    curr = lcm(curr, top);\\n                }\\n                ans.push_back(curr);\\n            }\\n            return ans;\\n        }\\n};\\n```\\n*If you find this helpful, please consider giving an upvote!!*",
                "solutionTags": [
                    "C",
                    "Math",
                    "Stack"
                ],
                "code": "```curr```\n```nums```\n```top```\n```ans```\n```curr```\n```ans```\n```curr```\n```LCM (top, curr)```\n```ans```\n```top```\n```curr```\n```cpp\\nclass Solution\\n{\\n    private:\\n        bool isCoprime(int x, int y)\\t// O(logM)  where M is max(x, y)\\n        {\\n            return gcd(x, y) == 1;\\t\\t\\n        }\\n        int gcd(int x, int y)\\t\\t\\t// O(logM)  where M is max(x, y)\\n        {\\n            return __gcd(x, y);\\t\\t\\n        }\\n        int lcm(int x, int y)\\t\\t\\t// O(logM)  where M is max(x, y)\\n        {\\n            long long LCM = x;\\n            LCM *= y;\\n            LCM /= gcd(x, y);\\n            return LCM;\\n        }\\n    public:\\n        vector<int> replaceNonCoprimes(vector<int> &nums)\\n        {\\n\\n            vector<int> ans;\\n            int n = nums.size();\\n            ans.push_back(nums[0]);\\n            for (int i = 1; i < n; i++)\\n            {\\n                int curr = nums[i];\\n                while (ans.size() && !isCoprime(ans.back(), curr))\\n                {\\n                    int top = ans.back();\\n                    ans.pop_back();\\n                    curr = lcm(curr, top);\\n                }\\n                ans.push_back(curr);\\n            }\\n            return ans;\\n        }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3621447,
                "title": "c-most-simple",
                "content": "# Code\\n```\\nclass Solution {\\npublic:\\n    vector<int> replaceNonCoprimes(vector<int>& nums) {\\n        vector<int> ans;\\n        for(auto i: nums){\\n            while(!ans.empty() && __gcd(ans.back(),i) != 1){\\n                i = (i*1LL*ans.back())/__gcd(i,ans.back());\\n                ans.pop_back();\\n            }\\n            ans.push_back(i);\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Array",
                    "Math",
                    "Stack",
                    "Number Theory"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<int> replaceNonCoprimes(vector<int>& nums) {\\n        vector<int> ans;\\n        for(auto i: nums){\\n            while(!ans.empty() && __gcd(ans.back(),i) != 1){\\n                i = (i*1LL*ans.back())/__gcd(i,ans.back());\\n                ans.pop_back();\\n            }\\n            ans.push_back(i);\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3296323,
                "title": "stack-gcd-short-sweet-c-iterative-code",
                "content": "```\\n#define lli long long int\\nclass Solution {\\npublic:\\n    vector<int> replaceNonCoprimes(vector<int>& nums) {\\n        lli a,b;\\n        int n;\\n        vector<int> ans;\\n        for(auto &i: nums){\\n            ans.push_back(i);\\n            n = ans.size();\\n            while(n>1&&__gcd(ans[n-1],ans[n-2])>1){\\n                a = ans[n-1],b = ans[n-2];\\n                ans.pop_back();\\n                ans.pop_back();\\n                ans.push_back(a*b/__gcd(a,b));\\n                n--;\\n            }\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "C",
                    "Math",
                    "Stack"
                ],
                "code": "```\\n#define lli long long int\\nclass Solution {\\npublic:\\n    vector<int> replaceNonCoprimes(vector<int>& nums) {\\n        lli a,b;\\n        int n;\\n        vector<int> ans;\\n        for(auto &i: nums){\\n            ans.push_back(i);\\n            n = ans.size();\\n            while(n>1&&__gcd(ans[n-1],ans[n-2])>1){\\n                a = ans[n-1],b = ans[n-2];\\n                ans.pop_back();\\n                ans.pop_back();\\n                ans.push_back(a*b/__gcd(a,b));\\n                n--;\\n            }\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3034901,
                "title": "easiest-python-code-7-line-code-99-faster-stack",
                "content": "# Complexity\\n- Time complexity: $$O(nlogn)$$\\n\\n- Space complexity: $$O(nlogn)$$\\n\\n# Code\\n```\\nclass Solution:\\n    def replaceNonCoprimes(self, nums: List[int]) -> List[int]:\\n        stack = []\\n        for i in nums:\\n            toBeAppended = i\\n            while stack and gcd(stack[-1], toBeAppended) > 1:\\n                toBeAppended = lcm(toBeAppended, stack.pop())\\n            stack.append(toBeAppended)\\n        return stack        \\n```",
                "solutionTags": [
                    "Python3",
                    "Math",
                    "Stack"
                ],
                "code": "```\\nclass Solution:\\n    def replaceNonCoprimes(self, nums: List[int]) -> List[int]:\\n        stack = []\\n        for i in nums:\\n            toBeAppended = i\\n            while stack and gcd(stack[-1], toBeAppended) > 1:\\n                toBeAppended = lcm(toBeAppended, stack.pop())\\n            stack.append(toBeAppended)\\n        return stack        \\n```",
                "codeTag": "Java"
            },
            {
                "id": 2289568,
                "title": "python-stack-solution",
                "content": "```\\ndef replaceNonCoprimes(self, nums: List[int]) -> List[int]:\\n\\tstack = [nums[0]]\\n\\tfor n in nums[1:]:\\n\\t\\tstack.append(n)\\n\\t\\twhile(len(stack)>=2 and gcd(stack[-1], stack[-2])>1):\\n\\t\\t\\ta = stack.pop()\\n\\t\\t\\tb = stack.pop()\\n\\t\\t\\tstack.append(a*b//gcd(a, b))\\n\\treturn stack\\n```",
                "solutionTags": [],
                "code": "```\\ndef replaceNonCoprimes(self, nums: List[int]) -> List[int]:\\n\\tstack = [nums[0]]\\n\\tfor n in nums[1:]:\\n\\t\\tstack.append(n)\\n\\t\\twhile(len(stack)>=2 and gcd(stack[-1], stack[-2])>1):\\n\\t\\t\\ta = stack.pop()\\n\\t\\t\\tb = stack.pop()\\n\\t\\t\\tstack.append(a*b//gcd(a, b))\\n\\treturn stack\\n```",
                "codeTag": "Python3"
            },
            {
                "id": 1856486,
                "title": "c-stack",
                "content": "* If the top two elements in stack are non coprime replace them with LCM of those two numbers and keep repeating this step until condition satisfies\\n```\\nclass Solution {\\npublic:\\n    #define ll long long  \\n    vector<int> replaceNonCoprimes(vector<int>& nums) {\\n        stack<ll> st ;\\n        for(int i = 0 ; i < nums.size() ;++i ){\\n            st.push(nums[i]) ;\\n            while(st.size() >= 2){\\n                ll a = st.top() ; st.pop() ;\\n                ll b = st.top() ; st.pop() ;\\n                if(__gcd(a,b) > 1) st.push((a*b) / __gcd(a,b)) ;\\n                else{\\n                    st.push(b) ; \\n                    st.push(a) ;\\n                    break ;\\n                }\\n            }\\n        }\\n        vector<int> ans ;\\n        while(!st.empty()){\\n            ans.push_back(st.top()) ;\\n            st.pop() ;\\n        }\\n        reverse(begin(ans),end(ans)) ;\\n        return ans ;\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    #define ll long long  \\n    vector<int> replaceNonCoprimes(vector<int>& nums) {\\n        stack<ll> st ;\\n        for(int i = 0 ; i < nums.size() ;++i ){\\n            st.push(nums[i]) ;\\n            while(st.size() >= 2){\\n                ll a = st.top() ; st.pop() ;\\n                ll b = st.top() ; st.pop() ;\\n                if(__gcd(a,b) > 1) st.push((a*b) / __gcd(a,b)) ;\\n                else{\\n                    st.push(b) ; \\n                    st.push(a) ;\\n                    break ;\\n                }\\n            }\\n        }\\n        vector<int> ans ;\\n        while(!st.empty()){\\n            ans.push_back(st.top()) ;\\n            st.pop() ;\\n        }\\n        reverse(begin(ans),end(ans)) ;\\n        return ans ;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1827205,
                "title": "c-one-pass-easy-to-understand",
                "content": "**Algorithm/Intuition:**\\n1. Traverse the array and push the elements onto the stack.\\n2. After pushing each element, **recursively** check if the gcd of the top 2 elements > 1. If yes, then they are co-prime. Pop both the elements and push their LCM into the stack. If not, then leave both the elements in the stack.\\n3. After all the elements have been pushed, pop them one by one and insert them into a vector and return. Alternatively, you can directly work on a vector(like a stack) and return it.\\n\\n**Example:**\\n\\nnums = [6,4,3,2,7,6,2]\\nInitially - stack is empty\\nFor 1st element, push 6 into stack. Then check if the top 2 elements have gcd > 1. Since there is only one element in the stack, we move to the next.\\nstack = [6]\\nFor the 2nd element, push 4 into the stack. Since [6, 4] have have gcd = 2, pop 6 and 4 and push their lcm 12 into the stack.\\nstack = [12]\\nFor the 3rd element, push 3 into the stack. Since [12, 3] has gcd = 3, therefore pop 12 and 3, and insert their lcm 12 into the stack.\\nstack = [12]\\nFor the 4th element, push 2 into the stack. Since [12, 2] has gcd = 2, therefore pop 12 and 2, and insert their lcm 12 into the stack.\\nstack = [12]\\nFor the 5th element, push 7 into the stack. Since [12, 7] have gcd = 1, we do nothing.\\nstack = [12, 7]\\nFor the 6th element, push 6 into stack. Since [7, 6] have gcd = 1, we do nothing.\\nstack = [12, 7, 6]\\nFor the 7th element, push 2 into the stack. Since [6, 2] have gcd = 2, we pop 2 and 6 and push their lcm 6 into the stack. Then, we check [7, 6] and since their gcd = 1, we do nothing.\\nstack = [12, 7, 6]\\n**Code:**\\n```\\nclass Solution {\\npublic:\\n    vector<int> replaceNonCoprimes(vector<int>& nums) {\\n        vector<int> st;\\n        for(auto it : nums){\\n            //push elements one by one into the stack\\n            st.push_back(it);\\n            //recursively check if the top 2 elements have gcd > 1\\n            while(st.size() > 1){\\n                int n = st.size();\\n                //if the gcd > 1, then pop the top 2 elements and push their lcm into the stack\\n                //keep continuing this process until the gcd == 1 or only one element in the stack\\n                int gcd = __gcd(st[n - 2], st[n - 1]);\\n                if(gcd > 1){\\n                    //lcm = (a * b) / gcd(a, b)\\n                    int num = st[n - 1] * (st[n - 2] / gcd);\\n                    st.pop_back();\\n                    st.pop_back();\\n                    st.push_back(num);\\n                }\\n                else\\n                    break;\\n            }\\n        }\\n        return st;\\n    }\\n};\\n```\\n**Time complexity** - O(nlogm) //logm due to gcd function\\n**Space complexity** - O(n)",
                "solutionTags": [
                    "Stack"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<int> replaceNonCoprimes(vector<int>& nums) {\\n        vector<int> st;\\n        for(auto it : nums){\\n            //push elements one by one into the stack\\n            st.push_back(it);\\n            //recursively check if the top 2 elements have gcd > 1\\n            while(st.size() > 1){\\n                int n = st.size();\\n                //if the gcd > 1, then pop the top 2 elements and push their lcm into the stack\\n                //keep continuing this process until the gcd == 1 or only one element in the stack\\n                int gcd = __gcd(st[n - 2], st[n - 1]);\\n                if(gcd > 1){\\n                    //lcm = (a * b) / gcd(a, b)\\n                    int num = st[n - 1] * (st[n - 2] / gcd);\\n                    st.pop_back();\\n                    st.pop_back();\\n                    st.push_back(num);\\n                }\\n                else\\n                    break;\\n            }\\n        }\\n        return st;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1825174,
                "title": "c-o-n-solution-my-own-intuitive-simple-approach-single-traversal",
                "content": "```\\nclass Solution {\\npublic:\\n    long long lcm(long long a,long long b){\\n        return (a*b)/gcd(a,b);\\n    }\\n    vector<int> replaceNonCoprimes(vector<int>& nums) {\\n     stack<int>st;\\n        int n = nums.size();\\n        st.push(nums[0]);\\n        for(int i = 1; i <n;++i){\\n                st.push(nums[i]);\\n                    int t1 = st.top();st.pop();\\n                    int t2 = st.top();st.pop();\\n                    while(!st.empty() && gcd(t1,t2)>1){\\n                        long long z = lcm(t1,t2);\\n                        t2 = st.top();st.pop();\\n                        t1 = z;\\n                    }\\n            if(gcd(t1,t2)>1){\\n                st.push(lcm(t1,t2));\\n            }\\n            else{\\n                st.push(t2);\\n                st.push(t1);\\n            }\\n        }\\n        vector<int>v;\\n        while(!st.empty()){\\n            v.push_back(st.top());st.pop();\\n        }\\n        reverse(v.begin(),v.end());\\n        return v;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C",
                    "Math",
                    "Stack"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    long long lcm(long long a,long long b){\\n        return (a*b)/gcd(a,b);\\n    }\\n    vector<int> replaceNonCoprimes(vector<int>& nums) {\\n     stack<int>st;\\n        int n = nums.size();\\n        st.push(nums[0]);\\n        for(int i = 1; i <n;++i){\\n                st.push(nums[i]);\\n                    int t1 = st.top();st.pop();\\n                    int t2 = st.top();st.pop();\\n                    while(!st.empty() && gcd(t1,t2)>1){\\n                        long long z = lcm(t1,t2);\\n                        t2 = st.top();st.pop();\\n                        t1 = z;\\n                    }\\n            if(gcd(t1,t2)>1){\\n                st.push(lcm(t1,t2));\\n            }\\n            else{\\n                st.push(t2);\\n                st.push(t1);\\n            }\\n        }\\n        vector<int>v;\\n        while(!st.empty()){\\n            v.push_back(st.top());st.pop();\\n        }\\n        reverse(v.begin(),v.end());\\n        return v;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1824974,
                "title": "c-stack",
                "content": "```\\nclass Solution {\\npublic:\\n    vector<int> replaceNonCoprimes(vector<int>& nums) {\\n        vector<int> ans;\\n        \\n        for(auto& x:nums){\\n            while(!ans.empty() && gcd(ans.back(), x)>1){\\n                x=lcm(ans.back(), x);\\n                ans.pop_back();\\n            }\\n            ans.push_back(x);\\n        }\\n        \\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<int> replaceNonCoprimes(vector<int>& nums) {\\n        vector<int> ans;\\n        \\n        for(auto& x:nums){\\n            while(!ans.empty() && gcd(ans.back(), x)>1){\\n                x=lcm(ans.back(), x);\\n                ans.pop_back();\\n            }\\n            ans.push_back(x);\\n        }\\n        \\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1824851,
                "title": "doubly-linked-list-in-python",
                "content": "By using doubly linked list, you can access the deletable pair in O(1) time.\\nEvery time you delete some pair, you need to add a new node with the value of lcm. Also, it might be possible that one of the pair is already deleted, so you need to keep track of which nodes are already deleted. (`wasted` stores all the finished nodes.)\\n\\n```\\nclass DoublyLinkedNode:\\n    def __init__(self, val=0):\\n        self.val = val\\n        self.prev = None\\n        self.next = None\\n\\nfrom math import gcd, lcm\\nclass Solution:\\n    def replaceNonCoprimes(self, nums: List[int]) -> List[int]:\\n        def connect(node1, node2):\\n            node1.next, node2.prev = node2, node1\\n        \\n        def are_deletable(node1, node2):\\n            return node1.val != 0 and node2.val != 0 and gcd(node1.val, node2.val) > 1\\n        \\n        #Create doubly linked list\\n        dummy_head, dummy_tail = DoublyLinkedNode(), DoublyLinkedNode()\\n        nodes = [DoublyLinkedNode(num) for num in nums]\\n        N = len(nodes)\\n        deletables = []\\n        for i in range(1, N):\\n            connect(nodes[i - 1], nodes[i])\\n            if are_deletable(nodes[i - 1], nodes[i]):\\n                deletables.append((nodes[i - 1], nodes[i]))\\n        connect(dummy_head, nodes[0]); connect(nodes[-1], dummy_tail);\\n        \\n        #connect adjacent nodes while deletables exist\\n        wasted = set()\\n        while deletables:\\n            node1, node2 = deletables.pop()\\n            if node1 in wasted or node2 in wasted:\\n                continue\\n            new_node = DoublyLinkedNode(val=lcm(node1.val, node2.val))\\n            connect(node1.prev, new_node); connect(new_node, node2.next);\\n            wasted.add(node1); wasted.add(node2);\\n            if are_deletable(new_node.prev, new_node):\\n                deletables.append((new_node.prev, new_node))\\n            if are_deletable(new_node, new_node.next):\\n                deletables.append((new_node, new_node.next)) \\n        \\n\\t\\t#output\\n        curr = dummy_head.next\\n        res = []\\n        while curr != dummy_tail:\\n            res.append(curr.val)\\n            curr = curr.next\\n        return res\\n```",
                "solutionTags": [
                    "Python",
                    "Python3",
                    "Linked List"
                ],
                "code": "```\\nclass DoublyLinkedNode:\\n    def __init__(self, val=0):\\n        self.val = val\\n        self.prev = None\\n        self.next = None\\n\\nfrom math import gcd, lcm\\nclass Solution:\\n    def replaceNonCoprimes(self, nums: List[int]) -> List[int]:\\n        def connect(node1, node2):\\n            node1.next, node2.prev = node2, node1\\n        \\n        def are_deletable(node1, node2):\\n            return node1.val != 0 and node2.val != 0 and gcd(node1.val, node2.val) > 1\\n        \\n        #Create doubly linked list\\n        dummy_head, dummy_tail = DoublyLinkedNode(), DoublyLinkedNode()\\n        nodes = [DoublyLinkedNode(num) for num in nums]\\n        N = len(nodes)\\n        deletables = []\\n        for i in range(1, N):\\n            connect(nodes[i - 1], nodes[i])\\n            if are_deletable(nodes[i - 1], nodes[i]):\\n                deletables.append((nodes[i - 1], nodes[i]))\\n        connect(dummy_head, nodes[0]); connect(nodes[-1], dummy_tail);\\n        \\n        #connect adjacent nodes while deletables exist\\n        wasted = set()\\n        while deletables:\\n            node1, node2 = deletables.pop()\\n            if node1 in wasted or node2 in wasted:\\n                continue\\n            new_node = DoublyLinkedNode(val=lcm(node1.val, node2.val))\\n            connect(node1.prev, new_node); connect(new_node, node2.next);\\n            wasted.add(node1); wasted.add(node2);\\n            if are_deletable(new_node.prev, new_node):\\n                deletables.append((new_node.prev, new_node))\\n            if are_deletable(new_node, new_node.next):\\n                deletables.append((new_node, new_node.next)) \\n        \\n\\t\\t#output\\n        curr = dummy_head.next\\n        res = []\\n        while curr != dummy_tail:\\n            res.append(curr.val)\\n            curr = curr.next\\n        return res\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1823886,
                "title": "python-traverse-doubly-linked-o-n-sqrt-n",
                "content": "Intuition:\\n1. It\\'s easy to pop, but we need some data structure to improve time complexity of the merging ops -> Linked List\\n2. If traverse backward is needed, only the recently changed node should be considered. \\n```python\\nclass Solution:\\n    def replaceNonCoprimes(self, nums: List[int]) -> List[int]:\\n        i = 0\\n        queue = deque(nums)\\n        # [2, 7, 2, 14]\\n        # [2, 7, 14]\\n        # [2, 14]\\n        # [14]\\n        \\n        # Need a better way to mark\\n        # to traverse between two\\n        # This would be much easier if this is a list\\n        class ListNode():\\n            def __init__(self, val, prev=None, nxt=None):\\n                self.val = val\\n                self.next = nxt\\n                self.prev = prev\\n                \\n        h = ListNode(nums[0])\\n        curr = h\\n        for n in nums[1:]:\\n            ln = ListNode(n, curr, None)\\n            curr.next = ln\\n            curr = ln\\n        \\n        # Now traverse the list\\n        curr = h\\n        prev = h\\n        # Note that only one the change may occur is to one before it.\\n        # So... if changed: traverse backward\\n        while curr:\\n            if curr.next and math.gcd(curr.val, curr.next.val) > 1:\\n                # Replaces this and next with a new list node\\n                curr.val = math.lcm(curr.val, curr.next.val)\\n                if curr.next.next:\\n                    curr.next.next.prev = curr\\n                curr.next = curr.next.next\\n                if curr.prev is not None:\\n                    curr = curr.prev\\n            else:\\n                curr = curr.next\\n        curr = h\\n        out = []\\n        while curr:\\n            out.append(curr.val)\\n            curr = curr.next\\n        return out\\n```\\n",
                "solutionTags": [
                    "Python",
                    "Linked List"
                ],
                "code": "```python\\nclass Solution:\\n    def replaceNonCoprimes(self, nums: List[int]) -> List[int]:\\n        i = 0\\n        queue = deque(nums)\\n        # [2, 7, 2, 14]\\n        # [2, 7, 14]\\n        # [2, 14]\\n        # [14]\\n        \\n        # Need a better way to mark\\n        # to traverse between two\\n        # This would be much easier if this is a list\\n        class ListNode():\\n            def __init__(self, val, prev=None, nxt=None):\\n                self.val = val\\n                self.next = nxt\\n                self.prev = prev\\n                \\n        h = ListNode(nums[0])\\n        curr = h\\n        for n in nums[1:]:\\n            ln = ListNode(n, curr, None)\\n            curr.next = ln\\n            curr = ln\\n        \\n        # Now traverse the list\\n        curr = h\\n        prev = h\\n        # Note that only one the change may occur is to one before it.\\n        # So... if changed: traverse backward\\n        while curr:\\n            if curr.next and math.gcd(curr.val, curr.next.val) > 1:\\n                # Replaces this and next with a new list node\\n                curr.val = math.lcm(curr.val, curr.next.val)\\n                if curr.next.next:\\n                    curr.next.next.prev = curr\\n                curr.next = curr.next.next\\n                if curr.prev is not None:\\n                    curr = curr.prev\\n            else:\\n                curr = curr.next\\n        curr = h\\n        out = []\\n        while curr:\\n            out.append(curr.val)\\n            curr = curr.next\\n        return out\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3274747,
                "title": "c-stack-maths",
                "content": "class Solution {\\npublic:\\n    \\n    vector<int> replaceNonCoprimes(vector<int>& nums) {\\n        vector<int>arr;\\n        arr.push_back(nums[0]);\\n        for(int i=1;i<nums.size();i++){   \\n            int val=arr.back();\\n            if(__gcd(val,nums[i])>1){\\n                arr.pop_back();\\n                int rem=lcm(val,nums[i]);\\n                while(!arr.empty() && __gcd(arr.back(),rem)>1){\\n                    rem=lcm(arr.back(),rem);\\n                    arr.pop_back();\\n                }\\n                arr.push_back(rem);\\n            }\\n            else{\\n                arr.push_back(nums[i]);\\n            }\\n        }\\n        return arr;\\n    }\\n};",
                "solutionTags": [
                    "Array",
                    "Stack"
                ],
                "code": "class Solution {\\npublic:\\n    \\n    vector<int> replaceNonCoprimes(vector<int>& nums) {\\n        vector<int>arr;\\n        arr.push_back(nums[0]);\\n        for(int i=1;i<nums.size();i++){   \\n            int val=arr.back();\\n            if(__gcd(val,nums[i])>1){\\n                arr.pop_back();\\n                int rem=lcm(val,nums[i]);\\n                while(!arr.empty() && __gcd(arr.back(),rem)>1){\\n                    rem=lcm(arr.back(),rem);\\n                    arr.pop_back();\\n                }",
                "codeTag": "Java"
            },
            {
                "id": 2000527,
                "title": "easy-stack",
                "content": "```\\nvector<int> replaceNonCoprimes(vector<int>& nums) {\\n        \\n        auto lcm = [&](int x , int y){ \\n\\t\\t    /* long long conversion is needed because temporarily \\n\\t\\t\\tx * y might be big enough to cross INT_MAX */\\n            return (int)((long long) x * y / __gcd(x , y)) ; \\n        };\\n        \\n        vector<int> stk ; \\n        for(auto x : nums){\\n            int lcmVal = x ;\\n            while(stk.size() and __gcd(stk.back() , lcmVal) > 1){\\n                lcmVal = lcm(lcmVal , stk.back()) ;\\n                stk.pop_back() ;\\n            }\\n            stk.push_back(lcmVal) ;\\n        }\\n        return stk ; \\n    }\\n```",
                "solutionTags": [],
                "code": "```\\nvector<int> replaceNonCoprimes(vector<int>& nums) {\\n        \\n        auto lcm = [&](int x , int y){ \\n\\t\\t    /* long long conversion is needed because temporarily \\n\\t\\t\\tx * y might be big enough to cross INT_MAX */\\n            return (int)((long long) x * y / __gcd(x , y)) ; \\n        };\\n        \\n        vector<int> stk ; \\n        for(auto x : nums){\\n            int lcmVal = x ;\\n            while(stk.size() and __gcd(stk.back() , lcmVal) > 1){\\n                lcmVal = lcm(lcmVal , stk.back()) ;\\n                stk.pop_back() ;\\n            }\\n            stk.push_back(lcmVal) ;\\n        }\\n        return stk ; \\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1825538,
                "title": "python-3-stack-solution",
                "content": "```\\nclass Solution:\\n    def replaceNonCoprimes(self, nums: List[int]) -> List[int]:       \\n\\n        stack = nums[:1]\\n        \\n        for j in range(1, len(nums)):\\n            cur = nums[j]\\n            while stack and math.gcd(stack[-1], cur) > 1:\\n                prev = stack.pop()\\n                cur = math.lcm(prev, cur)\\n            stack.append(cur)            \\n               \\n        return stack",
                "solutionTags": [
                    "Python",
                    "Python3",
                    "Stack"
                ],
                "code": "```\\nclass Solution:\\n    def replaceNonCoprimes(self, nums: List[int]) -> List[int]:       \\n\\n        stack = nums[:1]\\n        \\n        for j in range(1, len(nums)):\\n            cur = nums[j]\\n            while stack and math.gcd(stack[-1], cur) > 1:\\n                prev = stack.pop()\\n                cur = math.lcm(prev, cur)\\n            stack.append(cur)            \\n               \\n        return stack",
                "codeTag": "Java"
            },
            {
                "id": 1825209,
                "title": "easy-stack-solution-in-c",
                "content": "```\\n\\n\\nclass Solution {\\npublic:\\n    vector<int> replaceNonCoprimes(vector<int>& nums) {\\n        stack<int> s;\\n        s.push(nums[0]);\\n        if(nums.size()==1)\\n            return nums;\\n        for(int i=1;i<nums.size();i++)\\n        {\\n            if(__gcd(nums[i],s.top())!=1)\\n            {\\n                int y=s.top();\\n                s.pop();\\n                long long z=1ll*y*nums[i];\\n                int t=z/__gcd(nums[i],y);\\n                while(s.size()>0&&__gcd(s.top(),t)!=1)\\n                {\\n                    y=s.top();\\n                    s.pop();\\n                    z=1ll*y*t;\\n                    t=z/__gcd(y,t);\\n                }\\n                s.push(t);\\n            }\\n            else\\n            {\\n                s.push(nums[i]);\\n            }\\n        }\\n        vector<int> ans;\\n        while(s.size()>0)\\n        {\\n            ans.push_back(s.top());\\n            s.pop();\\n        }\\n        reverse(ans.begin(),ans.end());\\n        return ans;\\n    }\\n};\\n\\n",
                "solutionTags": [
                    "C++",
                    "Stack"
                ],
                "code": "class Solution {\\npublic:\\n    vector<int> replaceNonCoprimes(vector<int>& nums) {\\n        stack<int> s;\\n        s.push(nums[0]);\\n        if(nums.size()==1)\\n            return nums;\\n        for(int i=1;i<nums.size();i++)\\n        {\\n            if(__gcd(nums[i],s.top())!=1)\\n            {\\n                int y=s.top();\\n                s.pop();\\n                long long z=1ll*y*nums[i];\\n                int t=z/__gcd(nums[i],y);\\n                while(s.size()>0&&__gcd(s.top(),t)!=1)\\n                {\\n                    y=s.top();\\n                    s.pop();\\n                    z=1ll*y*t;\\n                    t=z/__gcd(y,t);\\n                }",
                "codeTag": "Java"
            },
            {
                "id": 1823902,
                "title": "c-stack-o-n-simple-approach",
                "content": "The problem is vey simple if you think it as stack problem. \\n**Approach**: iterate through every element of nums. Push it onto the stack and do the following.\\n* if the stack size is >=2, the pop top 2 element.\\n* find the GCD of both the poped elements\\n* if **GCD**>1, find **LCM** and push it onto the stack, continue\\n* if **GCD**==1, push both the poped element onto the stack in same order and move to next element in nums.\\n\\nContinue the above steps untill `stack.size()<2` or **GCD**==1\\n\\n**Time: O(n)**\\nupvote if it helps\\n ```\\nclass Solution {\\npublic:\\n    vector<int> replaceNonCoprimes(vector<int>& nums) {\\n        if(nums.size()==1) return nums;\\n        vector<int> re;\\n        stack<int> st; \\n        for(int i = 0;i<nums.size();++i){\\n            st.push(nums[i]);\\n            while(st.size()>=2){\\n                int p1 = st.top(); st.pop();\\n                int p2 = st.top(); st.pop();\\n                int k = __gcd(p1,p2);\\n                if(k>1){\\n                    long lcm = (long long)p1*p2/k;\\n                    st.push((int)lcm);\\n                }\\n                else{\\n                    st.push(p2); st.push(p1); break;\\n                }\\n            }\\n        }\\n        while(!st.empty()){\\n            re.push_back(st.top()); st.pop();\\n        }\\n        reverse(re.begin(),re.end());\\n        return re;\\n    }\\n};\\n        \\n```",
                "solutionTags": [
                    "C"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<int> replaceNonCoprimes(vector<int>& nums) {\\n        if(nums.size()==1) return nums;\\n        vector<int> re;\\n        stack<int> st; \\n        for(int i = 0;i<nums.size();++i){\\n            st.push(nums[i]);\\n            while(st.size()>=2){\\n                int p1 = st.top(); st.pop();\\n                int p2 = st.top(); st.pop();\\n                int k = __gcd(p1,p2);\\n                if(k>1){\\n                    long lcm = (long long)p1*p2/k;\\n                    st.push((int)lcm);\\n                }\\n                else{\\n                    st.push(p2); st.push(p1); break;\\n                }\\n            }\\n        }\\n        while(!st.empty()){\\n            re.push_back(st.top()); st.pop();\\n        }\\n        reverse(re.begin(),re.end());\\n        return re;\\n    }\\n};\\n        \\n```",
                "codeTag": "Java"
            },
            {
                "id": 1823742,
                "title": "python3-stack",
                "content": "Please pull this [commit](https://github.com/gaosanyong/leetcode/commit/bb5647e856ff11b072f9c51a140e0f243c100171) for solutions of weekly 283.\\n\\n```\\nclass Solution:\\n    def replaceNonCoprimes(self, nums: List[int]) -> List[int]:\\n        stack = []\\n        for x in nums: \\n            while stack and gcd(stack[-1], x) > 1: x = lcm(x, stack.pop())\\n            stack.append(x)\\n        return stack\\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def replaceNonCoprimes(self, nums: List[int]) -> List[int]:\\n        stack = []\\n        for x in nums: \\n            while stack and gcd(stack[-1], x) > 1: x = lcm(x, stack.pop())\\n            stack.append(x)\\n        return stack\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1823616,
                "title": "stack",
                "content": "Let begin with some mathamatics \\na.b=lcm(a,b).gcd(a,b)\\nlcm(a,b)=(a.b)/gcd(a,b)\\n\\nSo its easy to calculate gcd and lcm in Log(n) time so use internal c++ implementaion.\\n```\\nclass Solution {\\npublic:\\n    vector<int> replaceNonCoprimes(vector<int>& nums) {\\n        vector<long long>st;\\n        for(auto a:nums)\\n        {\\n\\t\\t\\tlong long num=a;\\n            if(st.emtpy())\\n            {\\n                st.push_back(a);\\n            }\\n            else\\n            {\\n                long long t=__gcd(num,st.back());\\n                if(t>1)\\n                {\\t\\t\\t\\t\\n                    long long temp=(num*st.back())/t;\\n                    st.pop_back();\\n                    t=__gcd(st.back(),temp);\\n                    while(!st.empty() && t>1)\\n                    {\\n                        temp=(temp*st.back())/t;\\n                        t=__gcd(st.back(),temp);\\n                        st.pop_back();\\n                    }\\n                    st.push_back(temp);\\n                }\\n                else \\n                {\\n                    st.push_back(a);\\n                }\\n            }\\n        }\\n\\t\\tvector<int>ans(st.begin(),st.end());\\n        return ans;\\n        \\n    }\\n};\\n``` \\n\\n",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<int> replaceNonCoprimes(vector<int>& nums) {\\n        vector<long long>st;\\n        for(auto a:nums)\\n        {\\n\\t\\t\\tlong long num=a;\\n            if(st.emtpy())\\n            {\\n                st.push_back(a);\\n            }\\n            else\\n            {\\n                long long t=__gcd(num,st.back());\\n                if(t>1)\\n                {\\t\\t\\t\\t\\n                    long long temp=(num*st.back())/t;\\n                    st.pop_back();\\n                    t=__gcd(st.back(),temp);\\n                    while(!st.empty() && t>1)\\n                    {\\n                        temp=(temp*st.back())/t;\\n                        t=__gcd(st.back(),temp);\\n                        st.pop_back();\\n                    }\\n                    st.push_back(temp);\\n                }\\n                else \\n                {\\n                    st.push_back(a);\\n                }\\n            }\\n        }\\n\\t\\tvector<int>ans(st.begin(),st.end());\\n        return ans;\\n        \\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2438809,
                "title": "one-pass-stack-in-python",
                "content": "```python\\nclass Solution:\\n    def replaceNonCoprimes(self, nums: List[int]) -> List[int]:\\n        res = [1]\\n        for num in nums:\\n            new_num = num\\n            while gcd(res[-1], new_num) > 1:\\n                new_num = lcm(res.pop(), new_num)\\n            res.append(new_num)\\n        return res[1:]\\n```",
                "solutionTags": [],
                "code": "```python\\nclass Solution:\\n    def replaceNonCoprimes(self, nums: List[int]) -> List[int]:\\n        res = [1]\\n        for num in nums:\\n            new_num = num\\n            while gcd(res[-1], new_num) > 1:\\n                new_num = lcm(res.pop(), new_num)\\n            res.append(new_num)\\n        return res[1:]\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2013507,
                "title": "java-n-log-n-solution",
                "content": "```\\nclass Solution {\\n    public List<Integer> replaceNonCoprimes(int[] nums) {\\n        List<Integer> ans = new ArrayList<>();\\n        \\n        for(int i=0;i<nums.length;i++){\\n            ans.add(nums[i]);\\n            while(ans.size()>1){\\n                int a = ans.get(ans.size()-1), b = ans.get(ans.size()-2);\\n                int gcd = gcd(a,b);\\n                if(gcd==1) break;\\n                \\n                int lcm = (a/gcd)*(b/gcd)*gcd;\\n                ans.remove(ans.size()-1);\\n                ans.remove(ans.size()-1);\\n                ans.add(lcm);\\n            }\\n        }\\n        \\n        return ans;\\n    }\\n    static int gcd(int a,int b){\\n        if(a==0) return b;\\n        return gcd(b%a,a);\\n    }\\n}\\n```\\n",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public List<Integer> replaceNonCoprimes(int[] nums) {\\n        List<Integer> ans = new ArrayList<>();\\n        \\n        for(int i=0;i<nums.length;i++){\\n            ans.add(nums[i]);\\n            while(ans.size()>1){\\n                int a = ans.get(ans.size()-1), b = ans.get(ans.size()-2);\\n                int gcd = gcd(a,b);\\n                if(gcd==1) break;\\n                \\n                int lcm = (a/gcd)*(b/gcd)*gcd;\\n                ans.remove(ans.size()-1);\\n                ans.remove(ans.size()-1);\\n                ans.add(lcm);\\n            }\\n        }\\n        \\n        return ans;\\n    }\\n    static int gcd(int a,int b){\\n        if(a==0) return b;\\n        return gcd(b%a,a);\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1856371,
                "title": "99-fast-simple-code",
                "content": "```cpp\\nclass Solution {\\npublic:\\n    vector<int> replaceNonCoprimes(vector<int>& nums) {\\n        vector<int>ans;\\n        for(auto num: nums){\\n           ans.push_back(num);\\n            \\n           while(ans.size() >=2){\\n               int top = ans.back();\\n               int stop = ans[ans.size()-2];\\n               \\n               if(__gcd(top,stop) > 1){\\n                   ans.pop_back();\\n                   ans.pop_back();\\n                   ans.push_back(top*1LL*stop/__gcd(top, stop));\\n               }\\n               else break;\\n           }\\n        }\\n        \\n        return ans;\\n    }\\n};",
                "solutionTags": [],
                "code": "class Solution {\\npublic:\\n    vector<int> replaceNonCoprimes(vector<int>& nums) {\\n        vector<int>ans;\\n        for(auto num: nums){\\n           ans.push_back(num);\\n            \\n           while(ans.size() >=2){\\n               int top = ans.back();\\n               int stop = ans[ans.size()-2];\\n               \\n               if(__gcd(top,stop) > 1){\\n                   ans.pop_back();\\n                   ans.pop_back();\\n                   ans.push_back(top*1LL*stop/__gcd(top, stop));\\n               }",
                "codeTag": "Java"
            },
            {
                "id": 1836123,
                "title": "java-solution",
                "content": "```\\nclass Solution {\\n    public List<Integer> replaceNonCoprimes(int[] nums) {\\n        ArrayList<Integer> res = new ArrayList<>();\\n        if(nums.length<2 || (nums.length == 2 && gcd(nums[0],nums[1])==1)){\\n            for(int ele:nums){\\n                res.add(ele);\\n            }\\n            return res;\\n        }\\n        int i=1;\\n        res.add(nums[0]);\\n        boolean flag = false;\\n        while(i<nums.length){\\n            int first = res.get(res.size()-1);\\n            int second = nums[i];\\n            int gcd = gcd(first,second);\\n            if(gcd>1){\\n                long lcm = ((long)first *(long)second)/gcd;\\n                if(res.size()>0)\\n                    res.remove(res.size()-1);\\n                res.add((int)lcm);\\n                recursivelyCheck(res);\\n            }else{\\n                res.add(second);\\n            }\\n            i++;\\n        }\\n        return res;\\n    }\\n    public int gcd(int a,int b){\\n        if(a>b){\\n            return gcd(b,a);\\n        }\\n        if(b%a == 0){\\n            return a;\\n        }\\n        return gcd(b%a,a);\\n    }\\n    public void recursivelyCheck(ArrayList<Integer> list){\\n        if(list.size()<2){\\n            return;\\n        }\\n        int a=list.remove(list.size()-1);\\n        int b = list.remove(list.size()-1);\\n        int gcd = gcd(a,b); \\n        if(gcd>1){\\n            long lcm = ((long)(a)*(long)(b))/gcd;\\n            list.add((int)lcm);\\n            recursivelyCheck(list);\\n        }else{\\n            list.add(b);\\n            list.add(a);\\n        }\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    public List<Integer> replaceNonCoprimes(int[] nums) {\\n        ArrayList<Integer> res = new ArrayList<>();\\n        if(nums.length<2 || (nums.length == 2 && gcd(nums[0],nums[1])==1)){\\n            for(int ele:nums){\\n                res.add(ele);\\n            }\\n            return res;\\n        }\\n        int i=1;\\n        res.add(nums[0]);\\n        boolean flag = false;\\n        while(i<nums.length){\\n            int first = res.get(res.size()-1);\\n            int second = nums[i];\\n            int gcd = gcd(first,second);\\n            if(gcd>1){\\n                long lcm = ((long)first *(long)second)/gcd;\\n                if(res.size()>0)\\n                    res.remove(res.size()-1);\\n                res.add((int)lcm);\\n                recursivelyCheck(res);\\n            }else{\\n                res.add(second);\\n            }\\n            i++;\\n        }\\n        return res;\\n    }\\n    public int gcd(int a,int b){\\n        if(a>b){\\n            return gcd(b,a);\\n        }\\n        if(b%a == 0){\\n            return a;\\n        }\\n        return gcd(b%a,a);\\n    }\\n    public void recursivelyCheck(ArrayList<Integer> list){\\n        if(list.size()<2){\\n            return;\\n        }\\n        int a=list.remove(list.size()-1);\\n        int b = list.remove(list.size()-1);\\n        int gcd = gcd(a,b); \\n        if(gcd>1){\\n            long lcm = ((long)(a)*(long)(b))/gcd;\\n            list.add((int)lcm);\\n            recursivelyCheck(list);\\n        }else{\\n            list.add(b);\\n            list.add(a);\\n        }\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1830994,
                "title": "lol-i-really-don-t-know-why-it-passed",
                "content": "Is This Approach Correct or testcases are weak?\\nI just Iterated Forward and backward and merged elements and if answer is reduced I made the recursive call to check if answer can be reduced or not..\\n\\nPS: I thought about Stack Solution Afterwards But just wondered if this is correct or it can give TLE in given contstraints?\\n\\n```\\n#define ll long long\\nclass Solution {\\npublic:\\n    vector<int> replaceNonCoprimes(vector<int>& nums) {\\n        vector<int> ans;\\n        ll lcm = nums[0];\\n        if(nums.size()==1)\\n        {\\n            return nums;\\n        }\\n        for(int i=1;i<nums.size();i++)\\n        {\\n            ll val = nums[i];\\n            ll g = __gcd(lcm,val); \\n            if(g!=1)\\n            {\\n                lcm = (lcm/g)*val;\\n            }\\n            else\\n            {\\n                ans.push_back(lcm);\\n                lcm = nums[i];\\n            }\\n        }\\n        ans.push_back(lcm);\\n        \\n        vector<int> ans2;\\n        if(ans.size()==1)\\n        {\\n            return ans;\\n        }\\n        lcm = ans.back();\\n        for(int i=ans.size()-2;i>=0;i--)\\n        {\\n            ll val = ans[i];\\n            ll g = __gcd(lcm,val); \\n            if(g!=1)\\n            {\\n                lcm = (lcm/g)*val;\\n            }\\n            else\\n            {\\n                ans2.push_back(lcm);\\n                lcm = ans[i];\\n            }\\n        }\\n        ans2.push_back(lcm);\\n        reverse(ans2.begin(),ans2.end());\\n        if(ans2 == nums)\\n        {\\n            return ans2;\\n        }\\n        return replaceNonCoprimes(ans2);\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\n#define ll long long\\nclass Solution {\\npublic:\\n    vector<int> replaceNonCoprimes(vector<int>& nums) {\\n        vector<int> ans;\\n        ll lcm = nums[0];\\n        if(nums.size()==1)\\n        {\\n            return nums;\\n        }\\n        for(int i=1;i<nums.size();i++)\\n        {\\n            ll val = nums[i];\\n            ll g = __gcd(lcm,val); \\n            if(g!=1)\\n            {\\n                lcm = (lcm/g)*val;\\n            }\\n            else\\n            {\\n                ans.push_back(lcm);\\n                lcm = nums[i];\\n            }\\n        }\\n        ans.push_back(lcm);\\n        \\n        vector<int> ans2;\\n        if(ans.size()==1)\\n        {\\n            return ans;\\n        }\\n        lcm = ans.back();\\n        for(int i=ans.size()-2;i>=0;i--)\\n        {\\n            ll val = ans[i];\\n            ll g = __gcd(lcm,val); \\n            if(g!=1)\\n            {\\n                lcm = (lcm/g)*val;\\n            }\\n            else\\n            {\\n                ans2.push_back(lcm);\\n                lcm = ans[i];\\n            }\\n        }\\n        ans2.push_back(lcm);\\n        reverse(ans2.begin(),ans2.end());\\n        if(ans2 == nums)\\n        {\\n            return ans2;\\n        }\\n        return replaceNonCoprimes(ans2);\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1827741,
                "title": "faster-than-100-of-submission-c-product-of-numbers-gcd-lcm-easy-implementation",
                "content": "```\\nclass Solution {\\npublic:\\nint gcd(int a, int b){\\n    return (b==0)? a : gcd(b, a%b);\\n}\\nvector<int> replaceNonCoprimes(vector<int>& arr) {\\n    vector<int>ans;\\n    int n=arr.size();\\n    ans.push_back(arr[0]);\\n    if(n==1)return ans;\\n\\n    for(int i=1;i<n;i++){\\n        int curr=arr[i];\\n        if(gcd(curr, ans.back())==1){\\n            ans.push_back(curr);\\n            continue;\\n        }\\n        \\n        while(!ans.empty() && gcd(curr, ans.back())!=1){\\n            int lcm=1LL*curr*ans.back()/gcd(curr, ans.back());\\n            ans.pop_back();\\n            curr=lcm;\\n        }\\n        ans.push_back(curr);\\n    }\\n    return ans;\\n}\\n};\\n```",
                "solutionTags": [
                    "C"
                ],
                "code": "```\\nclass Solution {\\npublic:\\nint gcd(int a, int b){\\n    return (b==0)? a : gcd(b, a%b);\\n}\\nvector<int> replaceNonCoprimes(vector<int>& arr) {\\n    vector<int>ans;\\n    int n=arr.size();\\n    ans.push_back(arr[0]);\\n    if(n==1)return ans;\\n\\n    for(int i=1;i<n;i++){\\n        int curr=arr[i];\\n        if(gcd(curr, ans.back())==1){\\n            ans.push_back(curr);\\n            continue;\\n        }\\n        \\n        while(!ans.empty() && gcd(curr, ans.back())!=1){\\n            int lcm=1LL*curr*ans.back()/gcd(curr, ans.back());\\n            ans.pop_back();\\n            curr=lcm;\\n        }\\n        ans.push_back(curr);\\n    }\\n    return ans;\\n}\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1827181,
                "title": "python-stack-solution-using-gcd",
                "content": "class Solution:\\n    def replaceNonCoprimes(self, nums: List[int]) -> List[int]:\\n        \\n        ans=[nums[0]]\\n        \\n        for i in range (1,len(nums)):\\n            \\n            y=nums[i]\\n            while(len(ans)>0 and math.gcd(ans[-1],y)>1):\\n                x=ans.pop()\\n                y=x*y//math.gcd(x,y)\\n                \\n            ans.append(y)\\n            \\n        return ans\\n",
                "solutionTags": [
                    "Python"
                ],
                "code": "class Solution:\\n    def replaceNonCoprimes(self, nums: List[int]) -> List[int]:\\n        \\n        ans=[nums[0]]\\n        \\n        for i in range (1,len(nums)):\\n            \\n            y=nums[i]\\n            while(len(ans)>0 and math.gcd(ans[-1],y)>1):\\n                x=ans.pop()\\n                y=x*y//math.gcd(x,y)\\n                \\n            ans.append(y)\\n            \\n        return ans\\n",
                "codeTag": "Java"
            },
            {
                "id": 1825537,
                "title": "java-no-stack-solution-25ms-100-faster-o-1-space-with-explanation",
                "content": "No need to utilize external stack structure. The basic idea is to use two indices and update the values in the array inplace:\\n1- `i` this index walks through the input array of numbers.\\n2- `j` this index keeps track of how many numbers to be included in the results array. It will point to the recent number included in the output. When the two numbers are co-prime, it is incremnted by 1.\\n\\nNow, whenever a non-coprime pair is found, the number at index `j` is replaced with their LCM value. Then a look back search is performed to check if this LCM is non-coprime with the previous number, i.e., at index `j-1` (the internal while loop).\\n\\nTime O(nlogn)\\nSpace O(1)\\n\\n```java\\n    public List<Integer> replaceNonCoprimes(int[] nums) {\\n        int n = nums.length;\\n        int i, j;\\n        boolean b = true;\\n        for(i = 1, j = 0; i < n; i++){\\n            int g = gcd(nums[j], nums[i]);\\n            if (g == 1){\\n                nums[++j] = nums[i];\\n            } else {\\n                nums[j] *= nums[i] / g;\\n                b = true;\\n                while(j > 0 && b){\\n                    g = gcd(nums[j], nums[j-1]);\\n                    b = g > 1;\\n                    if(b) {\\n                        nums[j-1] *= nums[j] / g;\\n                        j--;\\n                    }\\n                }\\n            }\\n        }\\n        var res = new ArrayList<Integer>();\\n        for(i = 0; i <= j; i++)\\n            res.add(nums[i]);\\n        \\n        return res;\\n    }\\n    \\n    private int gcd(int a, int b) {\\n        return b > 0 ? gcd(b, a % b) : a;\\n    }\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```java\\n    public List<Integer> replaceNonCoprimes(int[] nums) {\\n        int n = nums.length;\\n        int i, j;\\n        boolean b = true;\\n        for(i = 1, j = 0; i < n; i++){\\n            int g = gcd(nums[j], nums[i]);\\n            if (g == 1){\\n                nums[++j] = nums[i];\\n            } else {\\n                nums[j] *= nums[i] / g;\\n                b = true;\\n                while(j > 0 && b){\\n                    g = gcd(nums[j], nums[j-1]);\\n                    b = g > 1;\\n                    if(b) {\\n                        nums[j-1] *= nums[j] / g;\\n                        j--;\\n                    }\\n                }\\n            }\\n        }\\n        var res = new ArrayList<Integer>();\\n        for(i = 0; i <= j; i++)\\n            res.add(nums[i]);\\n        \\n        return res;\\n    }\\n    \\n    private int gcd(int a, int b) {\\n        return b > 0 ? gcd(b, a % b) : a;\\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1824272,
                "title": "c-try-two-pass-but-fail",
                "content": "Fail at very last case, currently no clue for this.\\n```\\nclass Solution {\\npublic:\\n    long long GCD (long long a, long long b) {\\n        if (b <= 1 || (a % b == 0)) return b; \\n        return GCD(b, a % b);\\n    }\\n    int LCM (long long a, long long b, long long gcd) {\\n        return a * b / gcd;\\n    }\\n    vector<int> replaceNonCoprimes(vector<int>& nums) {\\n        int n = nums.size();\\n        vector<int> s, r = {nums[n-1]};\\n        for (int i = n - 2; i >= 0; i--) {\\n            if (GCD(r.back(), nums[i]) > 1) {\\n                r.back() = LCM(nums[i], r.back(), GCD(r.back(), nums[i]));\\n            } else {\\n                r.push_back(nums[i]);\\n            }\\n        }\\n        n = r.size();\\n        s.push_back(r.back());\\n        for (int i = n - 2; i >= 0; i--) {\\n            if (GCD(s.back(), r[i]) > 1) {\\n                s.back() = LCM(r[i], s.back(), GCD(s.back(), r[i]));\\n            } else {\\n                s.push_back(r[i]);\\n            }\\n        }\\n        return s;\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    long long GCD (long long a, long long b) {\\n        if (b <= 1 || (a % b == 0)) return b; \\n        return GCD(b, a % b);\\n    }\\n    int LCM (long long a, long long b, long long gcd) {\\n        return a * b / gcd;\\n    }\\n    vector<int> replaceNonCoprimes(vector<int>& nums) {\\n        int n = nums.size();\\n        vector<int> s, r = {nums[n-1]};\\n        for (int i = n - 2; i >= 0; i--) {\\n            if (GCD(r.back(), nums[i]) > 1) {\\n                r.back() = LCM(nums[i], r.back(), GCD(r.back(), nums[i]));\\n            } else {\\n                r.push_back(nums[i]);\\n            }\\n        }\\n        n = r.size();\\n        s.push_back(r.back());\\n        for (int i = n - 2; i >= 0; i--) {\\n            if (GCD(s.back(), r[i]) > 1) {\\n                s.back() = LCM(r[i], s.back(), GCD(s.back(), r[i]));\\n            } else {\\n                s.push_back(r[i]);\\n            }\\n        }\\n        return s;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1824121,
                "title": "for-noobs-like-me-naive-sol-space-optimized-2-stack-method",
                "content": "1) Naive solution (which obviously didnt get accepted)\\n```\\nclass Solution {\\npublic:\\n    int gcd(int a,int b){\\n        if(b == 0){\\n            return a;\\n        }\\n        return gcd(b,a%b);\\n    }\\n    \\n    vector<int> replaceNonCoprimes(vector<int>& nums) {\\n        int n = nums.size();\\n        int i = 0;\\n        while(i < n-1){\\n            int g = gcd(nums[i],nums[i+1]);\\n            if(g != 1){\\n                long long t = nums[i];\\n                t*= nums[i+1];\\n                t/= g;\\n\\t\\t\\t\\t// t -- LCM\\n                nums[i] = t;\\n                nums.erase(nums.begin() + i+1);\\n                n--;\\n                i = 0;\\n            }\\n            else{\\n                i++;\\n            }\\n        }\\n        return nums;\\n    }\\n};\\n```\\n2) In the above version i was getting TLE so i though of optimizing it by finding a work around for .erase() method and so I used 2 stacks , by this way both time and space is optimized (time a little enough to get accepted).\\n```\\nclass Solution {\\npublic:\\n    int gcd(int a,int b){\\n        if(b == 0){\\n            return a;\\n        }\\n        return gcd(b,a%b);\\n    }\\n    \\n    vector<int> replaceNonCoprimes(vector<int>& nums) {\\n        int n = nums.size();\\n        int i = 0;\\n        vector<int> vec;\\n        stack<int> s1,s2;\\n        for(int i =0;i < n;i++){\\n            s1.push(nums[i]);\\n        }\\n        while(!s1.empty() && s1.size() >= 2){\\n                int a = s1.top();\\n                s1.pop();\\n                int b = s1.top();\\n                int g =gcd(max(a,b),min(a,b));\\n                long long t = a;\\n                if(g != 1){\\n                    // t - lcm\\n                    t*= b;\\n                    t/= g;\\n                    s1.pop();\\n                }\\n                while(!s2.empty()){\\n                    g = gcd(max((int)t,s2.top()),min((int)t,s2.top()));\\n                    if(g != 1){\\n                        // t - lcm\\n                        t*= s2.top();\\n                        t/= g;\\n                        s2.pop();\\n                    }\\n                    else{\\n                        break;\\n                    }\\n                } \\n              s2.push(t);\\n        }\\n        // if at all an element left in stack 1\\n        if(!s1.empty()){\\n                int a = s1.top();\\n                s1.pop();\\n                long long t = a;\\n                while(!s2.empty()){\\n                    int g = gcd(max((int)t,s2.top()),min((int)t,s2.top()));\\n                    if(g != 1){\\n                         // t - lcm\\n                        t*= s2.top();\\n                        t/= g;\\n                        s2.pop();\\n                    }\\n                    else{\\n                        break;\\n                    }\\n                } \\n              s2.push(t);\\n        }\\n        while(!s2.empty()){\\n            vec.push_back(s2.top());\\n            s2.pop();\\n        }\\n        return vec;\\n    }\\n};\\n```\\nNote: \\n1) Though its very basic i hope it helps people with little intution and afraid of Hard problem (like me :( )\\n2) Also I found the second approach only after contest :( \\n",
                "solutionTags": [
                    "Stack"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int gcd(int a,int b){\\n        if(b == 0){\\n            return a;\\n        }\\n        return gcd(b,a%b);\\n    }\\n    \\n    vector<int> replaceNonCoprimes(vector<int>& nums) {\\n        int n = nums.size();\\n        int i = 0;\\n        while(i < n-1){\\n            int g = gcd(nums[i],nums[i+1]);\\n            if(g != 1){\\n                long long t = nums[i];\\n                t*= nums[i+1];\\n                t/= g;\\n\\t\\t\\t\\t// t -- LCM\\n                nums[i] = t;\\n                nums.erase(nums.begin() + i+1);\\n                n--;\\n                i = 0;\\n            }\\n            else{\\n                i++;\\n            }\\n        }\\n        return nums;\\n    }\\n};\\n```\n```\\nclass Solution {\\npublic:\\n    int gcd(int a,int b){\\n        if(b == 0){\\n            return a;\\n        }\\n        return gcd(b,a%b);\\n    }\\n    \\n    vector<int> replaceNonCoprimes(vector<int>& nums) {\\n        int n = nums.size();\\n        int i = 0;\\n        vector<int> vec;\\n        stack<int> s1,s2;\\n        for(int i =0;i < n;i++){\\n            s1.push(nums[i]);\\n        }\\n        while(!s1.empty() && s1.size() >= 2){\\n                int a = s1.top();\\n                s1.pop();\\n                int b = s1.top();\\n                int g =gcd(max(a,b),min(a,b));\\n                long long t = a;\\n                if(g != 1){\\n                    // t - lcm\\n                    t*= b;\\n                    t/= g;\\n                    s1.pop();\\n                }\\n                while(!s2.empty()){\\n                    g = gcd(max((int)t,s2.top()),min((int)t,s2.top()));\\n                    if(g != 1){\\n                        // t - lcm\\n                        t*= s2.top();\\n                        t/= g;\\n                        s2.pop();\\n                    }\\n                    else{\\n                        break;\\n                    }\\n                } \\n              s2.push(t);\\n        }\\n        // if at all an element left in stack 1\\n        if(!s1.empty()){\\n                int a = s1.top();\\n                s1.pop();\\n                long long t = a;\\n                while(!s2.empty()){\\n                    int g = gcd(max((int)t,s2.top()),min((int)t,s2.top()));\\n                    if(g != 1){\\n                         // t - lcm\\n                        t*= s2.top();\\n                        t/= g;\\n                        s2.pop();\\n                    }\\n                    else{\\n                        break;\\n                    }\\n                } \\n              s2.push(t);\\n        }\\n        while(!s2.empty()){\\n            vec.push_back(s2.top());\\n            s2.pop();\\n        }\\n        return vec;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1824033,
                "title": "clean-python",
                "content": "```\\nclass Solution:\\n    def replaceNonCoprimes(self, nums: List[int]) -> List[int]:\\n        stack = []\\n        \\n        for num in nums:\\n            while stack and math.gcd(num, stack[-1]) > 1:\\n                num = math.lcm(num, stack.pop())\\n            stack.append(num)\\n                \\n        return stack\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution:\\n    def replaceNonCoprimes(self, nums: List[int]) -> List[int]:\\n        stack = []\\n        \\n        for num in nums:\\n            while stack and math.gcd(num, stack[-1]) > 1:\\n                num = math.lcm(num, stack.pop())\\n            stack.append(num)\\n                \\n        return stack\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1823972,
                "title": "stack-gcd-o-n-solution",
                "content": "```\\nclass Solution {\\npublic:\\n    vector<int> replaceNonCoprimes(vector<int>& nums) {\\n        stack<long long>st;\\n        int i=0,lc=0,gc=0;\\n        while(i<nums.size())\\n        {\\n            long long lc=nums[i];\\n            while(st.size()>0&&__gcd(st.top(),lc)>1)\\n            {\\n                lc=((long long )lc*st.top())/__gcd(lc,st.top());\\n                st.pop();\\n            }\\n            st.push(lc);\\n            i++;\\n        }\\n        vector<int>ans;\\n        while(st.size()>0)\\n        {\\n            ans.push_back(st.top());\\n            st.pop();\\n        }\\n        reverse(ans.begin(),ans.end());\\n        return ans;\\n        \\n    }\\n};\\n\\n```",
                "solutionTags": [
                    "Stack"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<int> replaceNonCoprimes(vector<int>& nums) {\\n        stack<long long>st;\\n        int i=0,lc=0,gc=0;\\n        while(i<nums.size())\\n        {\\n            long long lc=nums[i];\\n            while(st.size()>0&&__gcd(st.top(),lc)>1)\\n            {\\n                lc=((long long )lc*st.top())/__gcd(lc,st.top());\\n                st.pop();\\n            }\\n            st.push(lc);\\n            i++;\\n        }\\n        vector<int>ans;\\n        while(st.size()>0)\\n        {\\n            ans.push_back(st.top());\\n            st.pop();\\n        }\\n        reverse(ans.begin(),ans.end());\\n        return ans;\\n        \\n    }\\n};\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1823916,
                "title": "stack-cpp",
                "content": "```\\n#define ll long long int\\nclass Solution {\\npublic:\\n    vector<int> replaceNonCoprimes(vector<int>& nums) {\\n        stack<ll> stk;\\n        vector<int> a;\\n        for(auto& it:nums){\\n            ll num = it;\\n            while(!stk.empty() && __gcd(stk.top(),num) > 1){\\n                num = ((stk.top()*num)/__gcd(stk.top(),num));\\n                stk.pop();\\n            }stk.push(num);\\n        }while(!stk.empty()){\\n            a.push_back(stk.top());\\n            stk.pop();\\n        }reverse(a.begin(),a.end());\\n        return a;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "C",
                    "Stack"
                ],
                "code": "```\\n#define ll long long int\\nclass Solution {\\npublic:\\n    vector<int> replaceNonCoprimes(vector<int>& nums) {\\n        stack<ll> stk;\\n        vector<int> a;\\n        for(auto& it:nums){\\n            ll num = it;\\n            while(!stk.empty() && __gcd(stk.top(),num) > 1){\\n                num = ((stk.top()*num)/__gcd(stk.top(),num));\\n                stk.pop();\\n            }stk.push(num);\\n        }while(!stk.empty()){\\n            a.push_back(stk.top());\\n            stk.pop();\\n        }reverse(a.begin(),a.end());\\n        return a;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1823796,
                "title": "q4-is-easier-than-q2-1st-time-ak",
                "content": "Here\\'s my solution in < 10 loc. Simply do the simulation iteratively.\\nI created helper method cuz I thougt forward + backward pass is required. But forward pass can pass OJ, so I was happy in the contest.\\n\\n```\\ndef replaceNonCoprimes(self, nums: List[int]) -> List[int]:\\n    if len(nums) == 1:\\n        return nums\\n\\n    def helper(A):\\n        stk = []\\n        for i in range(len(nums)):\\n            while stk and gcd(stk[-1], nums[i]) > 1:\\n                a = stk.pop()\\n                nums[i] = lcm(a, nums[i])\\n            stk.append(nums[i])\\n        return stk\\n\\n    return helper(nums)\\n```\\n\\nBoomed by Q2 for 1hr...\\n![image](https://assets.leetcode.com/users/images/8ee99d1b-59b3-4569-a675-89cc90a69019_1646540195.627275.png)\\n",
                "solutionTags": [
                    "Python",
                    "Monotonic Stack"
                ],
                "code": "```\\ndef replaceNonCoprimes(self, nums: List[int]) -> List[int]:\\n    if len(nums) == 1:\\n        return nums\\n\\n    def helper(A):\\n        stk = []\\n        for i in range(len(nums)):\\n            while stk and gcd(stk[-1], nums[i]) > 1:\\n                a = stk.pop()\\n                nums[i] = lcm(a, nums[i])\\n            stk.append(nums[i])\\n        return stk\\n\\n    return helper(nums)\\n```",
                "codeTag": "Python3"
            },
            {
                "id": 1823706,
                "title": "c-2197-replace-non-coprime-numbers-in-array",
                "content": "\\n```\\nclass Solution {\\npublic:\\n    vector<int> replaceNonCoprimes(vector<int>& nums) {\\n        vector<int> stk; \\n        for (auto& x : nums) {\\n            while (stk.size() && gcd(stk.back(), x) > 1) {\\n                x = lcm(x, stk.back()); \\n                stk.pop_back(); \\n            }\\n            stk.push_back(x); \\n        }\\n        return stk; \\n    }\\n};\\n```",
                "solutionTags": [
                    "C"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<int> replaceNonCoprimes(vector<int>& nums) {\\n        vector<int> stk; \\n        for (auto& x : nums) {\\n            while (stk.size() && gcd(stk.back(), x) > 1) {\\n                x = lcm(x, stk.back()); \\n                stk.pop_back(); \\n            }\\n            stk.push_back(x); \\n        }\\n        return stk; \\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1823682,
                "title": "python-solution-cannot-find-easier-than-it",
                "content": "```\\nimport math\\nclass Solution:\\n    def replaceNonCoprimes(self, nums: List[int]) -> List[int]:\\n        i=1\\n        while i < len(nums):\\n            x = math.gcd(nums[i],nums[i-1])\\n            if x > 1:\\n                nums[i-1] = nums[i]*nums[i-1]//x\\n                nums.pop(i)\\n                i -= 1\\n            else:\\n                i += 1\\n            if i == 0:\\n                i+= 1\\n        return nums\\n```",
                "solutionTags": [
                    "Python"
                ],
                "code": "```\\nimport math\\nclass Solution:\\n    def replaceNonCoprimes(self, nums: List[int]) -> List[int]:\\n        i=1\\n        while i < len(nums):\\n            x = math.gcd(nums[i],nums[i-1])\\n            if x > 1:\\n                nums[i-1] = nums[i]*nums[i-1]//x\\n                nums.pop(i)\\n                i -= 1\\n            else:\\n                i += 1\\n            if i == 0:\\n                i+= 1\\n        return nums\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1823598,
                "title": "python-o-n-simulation-with-doubly-linked-list",
                "content": "\\n```\\nclass Solution:\\n    def replaceNonCoprimes(self, nums: List[int]) -> List[int]:\\n        if len(nums) == 1: return nums\\n\\n        class Node:\\n            def __init__(self, v):\\n                self.v = v\\n                self.next = None\\n                self.prev = None\\n                \\n        def addBetween(prev, next, cur):\\n            prev.next = cur\\n            cur.prev = prev\\n            cur.next = next\\n            next.prev = cur\\n\\n        head, tail = Node(0), Node(0)\\n        head.next = tail\\n        tail.prev = head\\n        for i in nums:\\n            cur = Node(i)\\n            prev = tail.prev\\n            addBetween(tail.prev, tail, cur)\\n        \\n        res = []\\n        first, second = head.next, head.next.next\\n        while second != tail:\\n            v1, v2 = first.v, second.v\\n            # replace\\n            if math.gcd(v1, v2) > 1:\\n                lcm = math.lcm(v1, v2)\\n                prev = first.prev\\n                next = second.next\\n                cur = Node(lcm)\\n                addBetween(prev, next, cur)\\n                # use prev as first if its not head\\n                if prev != head:\\n                    first = prev\\n                else:\\n                    first = cur\\n                second = first.next\\n            else: # move to next\\n                first = first.next\\n                second = first.next\\n\\n        cur = head.next\\n        while cur != tail:\\n            res.append(cur.v)\\n            cur = cur.next\\n\\n        return res\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution:\\n    def replaceNonCoprimes(self, nums: List[int]) -> List[int]:\\n        if len(nums) == 1: return nums\\n\\n        class Node:\\n            def __init__(self, v):\\n                self.v = v\\n                self.next = None\\n                self.prev = None\\n                \\n        def addBetween(prev, next, cur):\\n            prev.next = cur\\n            cur.prev = prev\\n            cur.next = next\\n            next.prev = cur\\n\\n        head, tail = Node(0), Node(0)\\n        head.next = tail\\n        tail.prev = head\\n        for i in nums:\\n            cur = Node(i)\\n            prev = tail.prev\\n            addBetween(tail.prev, tail, cur)\\n        \\n        res = []\\n        first, second = head.next, head.next.next\\n        while second != tail:\\n            v1, v2 = first.v, second.v\\n            # replace\\n            if math.gcd(v1, v2) > 1:\\n                lcm = math.lcm(v1, v2)\\n                prev = first.prev\\n                next = second.next\\n                cur = Node(lcm)\\n                addBetween(prev, next, cur)\\n                # use prev as first if its not head\\n                if prev != head:\\n                    first = prev\\n                else:\\n                    first = cur\\n                second = first.next\\n            else: # move to next\\n                first = first.next\\n                second = first.next\\n\\n        cur = head.next\\n        while cur != tail:\\n            res.append(cur.v)\\n            cur = cur.next\\n\\n        return res\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1823595,
                "title": "easy-stack-c",
                "content": "```\\nclass Solution {\\npublic:\\n    int lcm(int a, int b){\\n        return (a / __gcd(a, b)) * b;\\n    }\\n    \\n    vector<int> replaceNonCoprimes(vector<int>& nums) {\\n        stack<int> stk;\\n        for(auto& i : nums){\\n            // do what question asked\\n            if(!stk.empty() && __gcd(i, stk.top()) > 1){\\n                int t = stk.top();\\n                stk.pop();\\n                stk.push(lcm(i, t));\\n            }\\n            else stk.push(i);\\n            \\n            // maintain stack with only non-comprime elements\\n            while(stk.size() >= 2){\\n                int x = stk.top();\\n                stk.pop();\\n                int y = stk.top();\\n                stk.pop();\\n                \\n                if(__gcd(x, y) > 1){\\n                    stk.push(lcm(x, y));\\n                }\\n                else{\\n                    stk.push(y);\\n                    stk.push(x);\\n                    break;\\n                }\\n            }\\n        }\\n        \\n        // return answer array from stack\\n        vector<int> ans(stk.size());\\n        int i = stk.size() - 1;\\n        while(!stk.empty()){\\n            ans[i--] = stk.top();\\n            stk.pop();\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    int lcm(int a, int b){\\n        return (a / __gcd(a, b)) * b;\\n    }\\n    \\n    vector<int> replaceNonCoprimes(vector<int>& nums) {\\n        stack<int> stk;\\n        for(auto& i : nums){\\n            // do what question asked\\n            if(!stk.empty() && __gcd(i, stk.top()) > 1){\\n                int t = stk.top();\\n                stk.pop();\\n                stk.push(lcm(i, t));\\n            }\\n            else stk.push(i);\\n            \\n            // maintain stack with only non-comprime elements\\n            while(stk.size() >= 2){\\n                int x = stk.top();\\n                stk.pop();\\n                int y = stk.top();\\n                stk.pop();\\n                \\n                if(__gcd(x, y) > 1){\\n                    stk.push(lcm(x, y));\\n                }\\n                else{\\n                    stk.push(y);\\n                    stk.push(x);\\n                    break;\\n                }\\n            }\\n        }\\n        \\n        // return answer array from stack\\n        vector<int> ans(stk.size());\\n        int i = stk.size() - 1;\\n        while(!stk.empty()){\\n            ans[i--] = stk.top();\\n            stk.pop();\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 4075170,
                "title": "replace-non-coprime-numbers-in-array",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\n    public List<Integer> replaceNonCoprimes(int[] nums) {\\n    LinkedList<Integer> ans = new LinkedList<>();\\n    for (int num : nums) {\\n      while (!ans.isEmpty() && gcd(ans.getLast(), num) > 1)\\n        num = lcm(ans.removeLast(), num);\\n      ans.addLast(num);\\n    }\\n\\n    return ans;\\n  }\\n    private int gcd(int a, int b) {\\n    return b == 0 ? a : gcd(b, a % b);\\n  }\\n\\n  private int lcm(int a, int b) {\\n    return a * (b / gcd(a, b)); \\n}}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public List<Integer> replaceNonCoprimes(int[] nums) {\\n    LinkedList<Integer> ans = new LinkedList<>();\\n    for (int num : nums) {\\n      while (!ans.isEmpty() && gcd(ans.getLast(), num) > 1)\\n        num = lcm(ans.removeLast(), num);\\n      ans.addLast(num);\\n    }\\n\\n    return ans;\\n  }\\n    private int gcd(int a, int b) {\\n    return b == 0 ? a : gcd(b, a % b);\\n  }\\n\\n  private int lcm(int a, int b) {\\n    return a * (b / gcd(a, b)); \\n}}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3862762,
                "title": "rust-52ms-beats-100",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nWhen we find two adjacents non-coprime we would remove left, change right value to lcm and decrease index, but remove is slow, so let\\'s use a stack instead.\\n\\n\\n# Code\\n\\nThe gcd function is from here:\\nhttps://docs.rs/gcd/latest/src/gcd/lib.rs.html\\n\\n```\\nimpl Solution {\\n    pub fn replace_non_coprimes(mut nums: Vec<i32>) -> Vec<i32> {\\n        let len = nums.len();\\n        let mut x: u64 = nums[0] as u64;\\n        let mut idx = 1;\\n        let mut res: Vec<i32> = vec![];\\n\\n        while idx < len {\\n            let y = nums[idx] as u64;\\n            let gcd = x.gcd(y);\\n            if gcd > 1 {\\n                let lcm = x * y / gcd;\\n                nums[idx] = lcm as i32;\\n                if res.is_empty() {\\n                    x = lcm;\\n                    idx += 1;\\n                } else {\\n                    x = res.pop().unwrap() as u64;\\n                }\\n            } else {\\n                res.push(x as i32);\\n                x = y;\\n                idx += 1;\\n            }\\n        }\\n\\n        res.push(x as i32);\\n\\n        res\\n    }\\n}\\n\\n\\n\\n// https://docs.rs/gcd/latest/src/gcd/lib.rs.html\\n\\n\\nuse core::num::{NonZeroU128, NonZeroU16, NonZeroU32, NonZeroU64, NonZeroU8, NonZeroUsize};\\n\\npub trait Gcd {\\n    /// Determine [greatest common divisor](https://en.wikipedia.org/wiki/Greatest_common_divisor)\\n    /// using [`gcd_binary`].\\n    ///\\n    /// [`gcd_binary`]: #method.gcd_binary\\n    ///\\n    /// # Examples\\n    ///\\n    /// ```\\n    /// use gcd::Gcd;\\n    ///\\n    /// assert_eq!(0, 0u8.gcd(0));\\n    /// assert_eq!(10, 10u8.gcd(0));\\n    /// assert_eq!(10, 0u8.gcd(10));\\n    /// assert_eq!(10, 10u8.gcd(20));\\n    /// assert_eq!(44, 2024u32.gcd(748));\\n    /// ```\\n    fn gcd(self, other: Self) -> Self;\\n\\n    /// Determine [greatest common divisor](https://en.wikipedia.org/wiki/Greatest_common_divisor)\\n    /// using the [Binary GCD algorithm](https://en.wikipedia.org/wiki/Binary_GCD_algorithm).\\n    fn gcd_binary(self, other: Self) -> Self;\\n\\n    /// Determine [greatest common divisor](https://en.wikipedia.org/wiki/Greatest_common_divisor)\\n    /// using the [Euclidean algorithm](https://en.wikipedia.org/wiki/Euclidean_algorithm).\\n    fn gcd_euclid(self, other: Self) -> Self;\\n}\\n\\nmacro_rules! gcd_impl {\\n    ($(($T:ty) $binary:ident $euclid:ident),*) => {$(\\n        #[doc = concat!(\"Const binary GCD implementation for `\", stringify!($T), \"`.\")]\\n        pub const fn $binary(mut u: $T, mut v: $T) -> $T\\n        {\\n            if u == 0 { return v; }\\n            if v == 0 { return u; }\\n\\n            let shift = (u | v).trailing_zeros();\\n            u >>= shift;\\n            v >>= shift;\\n            u >>= u.trailing_zeros();\\n\\n            loop {\\n                v >>= v.trailing_zeros();\\n\\n                #[allow(clippy::manual_swap)]\\n                if u > v {\\n                    // mem::swap(&mut u, &mut v);\\n                    let temp = u;\\n                    u = v;\\n                    v = temp;\\n                }\\n\\n                v -= u; // here v >= u\\n\\n                if v == 0 { break; }\\n            }\\n\\n            u << shift\\n        }\\n\\n        #[doc = concat!(\"Const euclid GCD implementation for `\", stringify!($T), \"`.\")]\\n        pub const fn $euclid(a: $T, b: $T) -> $T\\n        {\\n            // variable names based off euclidean division equation: a = b \\xB7 q + r\\n            let (mut a, mut b) = if a > b {\\n                (a, b)\\n            } else {\\n                (b, a)\\n            };\\n\\n            #[allow(clippy::manual_swap)]\\n            while b != 0 {\\n                // mem::swap(&mut a, &mut b);\\n                let temp = a;\\n                a = b;\\n                b = temp;\\n\\n                b %= a;\\n            }\\n\\n            a\\n        }\\n\\n        impl Gcd for $T {\\n            #[inline]\\n            fn gcd(self, other: $T) -> $T {\\n                self.gcd_binary(other)\\n            }\\n\\n            #[inline]\\n            fn gcd_binary(self, v: $T) -> $T {\\n                $binary(self, v)\\n            }\\n\\n            #[inline]\\n            fn gcd_euclid(self, other: $T) -> $T {\\n                $euclid(self, other)\\n            }\\n        }\\n    )*};\\n}\\n\\ngcd_impl! {\\n    (u8) binary_u8 euclid_u8,\\n    (u16) binary_u16 euclid_u16,\\n    (u32) binary_u32 euclid_u32,\\n    (u64) binary_u64 euclid_u64,\\n    (u128) binary_u128 euclid_u128,\\n    (usize) binary_usize euclid_usize\\n}\\n\\nmacro_rules! gcd_impl_nonzero {\\n    ($(($T:ty) $binary_nonzero:ident/$binary:ident $euclid_nonzero:ident/$euclid:ident),*) => {$(\\n        #[doc = concat!(\"Const binary GCD implementation for `\", stringify!($T), \"`.\")]\\n        pub const fn $binary_nonzero(u: $T, v: $T) -> $T\\n        {\\n            match <$T>::new($binary(u.get(), v.get())) {\\n                Some(x) => x,\\n                None => unreachable!(),\\n            }\\n        }\\n\\n        #[doc = concat!(\"Const euclid GCD implementation for `\", stringify!($T), \"`.\")]\\n        pub const fn $euclid_nonzero(a: $T, b: $T) -> $T\\n        {\\n            match <$T>::new($euclid(a.get(), b.get())) {\\n                Some(x) => x,\\n                None => unreachable!(),\\n            }\\n        }\\n\\n        impl Gcd for $T {\\n            #[inline]\\n            fn gcd(self, other: $T) -> $T {\\n                self.gcd_binary(other)\\n            }\\n\\n            #[inline]\\n            fn gcd_binary(self, v: $T) -> $T {\\n                $binary_nonzero(self, v)\\n            }\\n\\n            #[inline]\\n            fn gcd_euclid(self, other: $T) -> $T {\\n                $euclid_nonzero(self, other)\\n            }\\n        }\\n    )*}\\n}\\n\\ngcd_impl_nonzero! {\\n    (NonZeroU8) binary_nonzero_u8/binary_u8 euclid_nonzero_u8/euclid_u8,\\n    (NonZeroU16) binary_nonzero_u16/binary_u16 euclid_nonzero_u16/euclid_u16,\\n    (NonZeroU32) binary_nonzero_u32/binary_u32 euclid_nonzero_u32/euclid_u32,\\n    (NonZeroU64) binary_nonzero_u64/binary_u64 euclid_nonzero_u64/euclid_u64,\\n    (NonZeroU128) binary_nonzero_u128/binary_u128 euclid_nonzero_u128/euclid_u128,\\n    (NonZeroUsize) binary_nonzero_usize/binary_usize euclid_nonzero_usize/euclid_usize\\n}\\n\\n\\n```",
                "solutionTags": [
                    "Rust"
                ],
                "code": "```\\nimpl Solution {\\n    pub fn replace_non_coprimes(mut nums: Vec<i32>) -> Vec<i32> {\\n        let len = nums.len();\\n        let mut x: u64 = nums[0] as u64;\\n        let mut idx = 1;\\n        let mut res: Vec<i32> = vec![];\\n\\n        while idx < len {\\n            let y = nums[idx] as u64;\\n            let gcd = x.gcd(y);\\n            if gcd > 1 {\\n                let lcm = x * y / gcd;\\n                nums[idx] = lcm as i32;\\n                if res.is_empty() {\\n                    x = lcm;\\n                    idx += 1;\\n                } else {\\n                    x = res.pop().unwrap() as u64;\\n                }\\n            } else {\\n                res.push(x as i32);\\n                x = y;\\n                idx += 1;\\n            }\\n        }\\n\\n        res.push(x as i32);\\n\\n        res\\n    }\\n}\\n\\n\\n\\n// https://docs.rs/gcd/latest/src/gcd/lib.rs.html\\n\\n\\nuse core::num::{NonZeroU128, NonZeroU16, NonZeroU32, NonZeroU64, NonZeroU8, NonZeroUsize};\\n\\npub trait Gcd {\\n    /// Determine [greatest common divisor](https://en.wikipedia.org/wiki/Greatest_common_divisor)\\n    /// using [`gcd_binary`].\\n    ///\\n    /// [`gcd_binary`]: #method.gcd_binary\\n    ///\\n    /// # Examples\\n    ///\\n    /// ```\n```\\n    fn gcd(self, other: Self) -> Self;\\n\\n    /// Determine [greatest common divisor](https://en.wikipedia.org/wiki/Greatest_common_divisor)\\n    /// using the [Binary GCD algorithm](https://en.wikipedia.org/wiki/Binary_GCD_algorithm).\\n    fn gcd_binary(self, other: Self) -> Self;\\n\\n    /// Determine [greatest common divisor](https://en.wikipedia.org/wiki/Greatest_common_divisor)\\n    /// using the [Euclidean algorithm](https://en.wikipedia.org/wiki/Euclidean_algorithm).\\n    fn gcd_euclid(self, other: Self) -> Self;\\n}\\n\\nmacro_rules! gcd_impl {\\n    ($(($T:ty) $binary:ident $euclid:ident),*) => {$(\\n        #[doc = concat!(\"Const binary GCD implementation for `\", stringify!($T), \"`.\")]\\n        pub const fn $binary(mut u: $T, mut v: $T) -> $T\\n        {\\n            if u == 0 { return v; }\\n            if v == 0 { return u; }\\n\\n            let shift = (u | v).trailing_zeros();\\n            u >>= shift;\\n            v >>= shift;\\n            u >>= u.trailing_zeros();\\n\\n            loop {\\n                v >>= v.trailing_zeros();\\n\\n                #[allow(clippy::manual_swap)]\\n                if u > v {\\n                    // mem::swap(&mut u, &mut v);\\n                    let temp = u;\\n                    u = v;\\n                    v = temp;\\n                }\\n\\n                v -= u; // here v >= u\\n\\n                if v == 0 { break; }\\n            }\\n\\n            u << shift\\n        }\\n\\n        #[doc = concat!(\"Const euclid GCD implementation for `\", stringify!($T), \"`.\")]\\n        pub const fn $euclid(a: $T, b: $T) -> $T\\n        {\\n            // variable names based off euclidean division equation: a = b \\xB7 q + r\\n            let (mut a, mut b) = if a > b {\\n                (a, b)\\n            } else {\\n                (b, a)\\n            };\\n\\n            #[allow(clippy::manual_swap)]\\n            while b != 0 {\\n                // mem::swap(&mut a, &mut b);\\n                let temp = a;\\n                a = b;\\n                b = temp;\\n\\n                b %= a;\\n            }\\n\\n            a\\n        }\\n\\n        impl Gcd for $T {\\n            #[inline]\\n            fn gcd(self, other: $T) -> $T {\\n                self.gcd_binary(other)\\n            }\\n\\n            #[inline]\\n            fn gcd_binary(self, v: $T) -> $T {\\n                $binary(self, v)\\n            }\\n\\n            #[inline]\\n            fn gcd_euclid(self, other: $T) -> $T {\\n                $euclid(self, other)\\n            }\\n        }\\n    )*};\\n}\\n\\ngcd_impl! {\\n    (u8) binary_u8 euclid_u8,\\n    (u16) binary_u16 euclid_u16,\\n    (u32) binary_u32 euclid_u32,\\n    (u64) binary_u64 euclid_u64,\\n    (u128) binary_u128 euclid_u128,\\n    (usize) binary_usize euclid_usize\\n}\\n\\nmacro_rules! gcd_impl_nonzero {\\n    ($(($T:ty) $binary_nonzero:ident/$binary:ident $euclid_nonzero:ident/$euclid:ident),*) => {$(\\n        #[doc = concat!(\"Const binary GCD implementation for `\", stringify!($T), \"`.\")]\\n        pub const fn $binary_nonzero(u: $T, v: $T) -> $T\\n        {\\n            match <$T>::new($binary(u.get(), v.get())) {\\n                Some(x) => x,\\n                None => unreachable!(),\\n            }\\n        }\\n\\n        #[doc = concat!(\"Const euclid GCD implementation for `\", stringify!($T), \"`.\")]\\n        pub const fn $euclid_nonzero(a: $T, b: $T) -> $T\\n        {\\n            match <$T>::new($euclid(a.get(), b.get())) {\\n                Some(x) => x,\\n                None => unreachable!(),\\n            }\\n        }\\n\\n        impl Gcd for $T {\\n            #[inline]\\n            fn gcd(self, other: $T) -> $T {\\n                self.gcd_binary(other)\\n            }\\n\\n            #[inline]\\n            fn gcd_binary(self, v: $T) -> $T {\\n                $binary_nonzero(self, v)\\n            }\\n\\n            #[inline]\\n            fn gcd_euclid(self, other: $T) -> $T {\\n                $euclid_nonzero(self, other)\\n            }\\n        }\\n    )*}\\n}\\n\\ngcd_impl_nonzero! {\\n    (NonZeroU8) binary_nonzero_u8/binary_u8 euclid_nonzero_u8/euclid_u8,\\n    (NonZeroU16) binary_nonzero_u16/binary_u16 euclid_nonzero_u16/euclid_u16,\\n    (NonZeroU32) binary_nonzero_u32/binary_u32 euclid_nonzero_u32/euclid_u32,\\n    (NonZeroU64) binary_nonzero_u64/binary_u64 euclid_nonzero_u64/euclid_u64,\\n    (NonZeroU128) binary_nonzero_u128/binary_u128 euclid_nonzero_u128/euclid_u128,\\n    (NonZeroUsize) binary_nonzero_usize/binary_usize euclid_nonzero_usize/euclid_usize\\n}\\n\\n\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3862356,
                "title": "brute-force",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    vector<int> replaceNonCoprimes(vector<int>& nums) {\\n        stack<int>p;\\n        int n=nums.size();\\n        p.push(nums[0]);\\n        for(int i=1;i<n;i++){\\n            int sum=nums[i];\\n            while(!p.empty() && gcd(sum,p.top())>1){\\n                sum=lcm(sum,p.top());\\n                p.pop();\\n            }\\n            p.push(sum);\\n        }\\n        vector<int>ans;\\n        while(!p.empty()){\\n            ans.push_back(p.top());\\n            p.pop();\\n        }\\n        reverse(ans.begin(),ans.end());\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<int> replaceNonCoprimes(vector<int>& nums) {\\n        stack<int>p;\\n        int n=nums.size();\\n        p.push(nums[0]);\\n        for(int i=1;i<n;i++){\\n            int sum=nums[i];\\n            while(!p.empty() && gcd(sum,p.top())>1){\\n                sum=lcm(sum,p.top());\\n                p.pop();\\n            }\\n            p.push(sum);\\n        }\\n        vector<int>ans;\\n        while(!p.empty()){\\n            ans.push_back(p.top());\\n            p.pop();\\n        }\\n        reverse(ans.begin(),ans.end());\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3835720,
                "title": "c-clean-code-easy",
                "content": "\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    vector<int> replaceNonCoprimes(vector<int>& a) {\\n        stack<int> s;\\n        s.push(a[0]);\\n        vector<int> r;\\n        for(int i=1;i<a.size();i++)\\n            {\\n               int ans=a[i]; \\n               while(s.size() && __gcd(s.top(),ans)>1) \\n               { int x=s.top();\\n                 int y=ans;\\n                 s.pop();\\n                 ans=std::lcm(x,y);     \\n               }  \\n                s.push(ans);\\n            }\\n        while(s.size()){\\n            r.push_back(s.top());\\n            s.pop();\\n        }    \\n        reverse(r.begin(),r.end());\\n        return r;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<int> replaceNonCoprimes(vector<int>& a) {\\n        stack<int> s;\\n        s.push(a[0]);\\n        vector<int> r;\\n        for(int i=1;i<a.size();i++)\\n            {\\n               int ans=a[i]; \\n               while(s.size() && __gcd(s.top(),ans)>1) \\n               { int x=s.top();\\n                 int y=ans;\\n                 s.pop();\\n                 ans=std::lcm(x,y);     \\n               }  \\n                s.push(ans);\\n            }\\n        while(s.size()){\\n            r.push_back(s.top());\\n            s.pop();\\n        }    \\n        reverse(r.begin(),r.end());\\n        return r;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3687190,
                "title": "python-simple-stack-solution",
                "content": "As the problem statement says - Two values x and y are non-coprime if GCD(x, y) > 1 where GCD(x, y) is the Greatest Common Divisor of x and y.\\n\\nSo, we need to figure out a way by which we can take a number and find its GCD with the previous number. And if the GCD with previous is > 1 then we take the LCM of both, remove previous number from output and then again do the same calculation with previous numbers.\\n\\nAnd that can be done efficiently using a Stack.\\n\\nSo, as we traverse the list, we will maintain a stack of elements where, before pushing a value to the stack, we take the GCD of this value with whatever stack has on top. If the GCD is > 1, it means the current and previous values are non-coprime. So, it means, instead of those values, we need to push their LCM in the stack. Hence, we remove the top of stack and so the new value that we have to push is the LCM. \\n\\nBut now, this LCM itself may be non-coprime with the new stack top. So, we again need to do the same calculation. Hence, this will go on until stack is empty or we reach a point where top of stack and the current value are co prime.\\n\\nSince we already know the GCD of two numbers, finding the LCM is pretty straightforward.\\n\\n\\tLCM(a,b) = (a * b) // gcd(a,b)\\n\\n\\n```\\ndef replaceNonCoprimes(self, nums: List[int]) -> List[int]:\\n        # Stack\\n        stack = []\\n        \\n        # Loop over the input list\\n        for num in nums:\\n            \\n            # The value that we have to push to stack\\n            # It can be this value itself (if its gcd with previous value is 1)\\n            # Or, it can be the LCM with previous value(s)\\n            valToAppend = num\\n            \\n            # While stack is not empty\\n            while stack:\\n                # Get the GCD/HCF of the previous and current value\\n                gcd = math.gcd(stack[-1],valToAppend)\\n                \\n                # Two number are co-prime if their GCD is 1\\n                # So, if they are not co-prime\\n                if gcd > 1:\\n                    # Then, we have to push the LCM of those two numbers in the stack\\n                    # If we know the GCD/HCF, the LCM can be found easily\\n                    # LCM(a,b) = (a * b) // gcd(a,b)\\n                    valToAppend *= stack[-1] // gcd\\n                    \\n                    # And now, the previous value needs to be removed from the stack\\n                    stack.pop()\\n                    \\n                # If two numbers are co-prime, we have to keep both in stack\\n                # So, we pop nothing and break\\n                else: break\\n            \\n            # Finally, we push the \"valToAppend\" in the stack\\n            stack.append(valToAppend)\\n        \\n        # Finally, return the stack\\n        return stack\\n```",
                "solutionTags": [
                    "Python",
                    "Stack"
                ],
                "code": "```\\ndef replaceNonCoprimes(self, nums: List[int]) -> List[int]:\\n        # Stack\\n        stack = []\\n        \\n        # Loop over the input list\\n        for num in nums:\\n            \\n            # The value that we have to push to stack\\n            # It can be this value itself (if its gcd with previous value is 1)\\n            # Or, it can be the LCM with previous value(s)\\n            valToAppend = num\\n            \\n            # While stack is not empty\\n            while stack:\\n                # Get the GCD/HCF of the previous and current value\\n                gcd = math.gcd(stack[-1],valToAppend)\\n                \\n                # Two number are co-prime if their GCD is 1\\n                # So, if they are not co-prime\\n                if gcd > 1:\\n                    # Then, we have to push the LCM of those two numbers in the stack\\n                    # If we know the GCD/HCF, the LCM can be found easily\\n                    # LCM(a,b) = (a * b) // gcd(a,b)\\n                    valToAppend *= stack[-1] // gcd\\n                    \\n                    # And now, the previous value needs to be removed from the stack\\n                    stack.pop()\\n                    \\n                # If two numbers are co-prime, we have to keep both in stack\\n                # So, we pop nothing and break\\n                else: break\\n            \\n            # Finally, we push the \"valToAppend\" in the stack\\n            stack.append(valToAppend)\\n        \\n        # Finally, return the stack\\n        return stack\\n```",
                "codeTag": "Python3"
            },
            {
                "id": 3657296,
                "title": "easy-beginner-friendly-without-stack",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nIt\\'s an easy hard question .\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\njust go through the question ,just keep in the mind Integer overflow at the time of calculating lcm .\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\no(n^2)\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\nO(n)\\n\\n# Code\\n```\\nclass Solution {\\n    public List<Integer> replaceNonCoprimes(int[] nums) {\\n        ArrayList<Integer>ans=new ArrayList<>();\\n        for(int i=0;i<nums.length;i++){\\n           ans.add(nums[i]);\\n           while(ans.size()>1){\\n               int a=ans.get(ans.size()-1);\\n               int b=ans.get(ans.size()-2);\\n               if(gcd(a,b)==1){\\n                   break;\\n               }\\n               ans.remove(ans.size()-1);\\n               ans.remove(ans.size()-1);\\n               ans.add(lcm(a,b));\\n           }\\n        }\\n        return ans;\\n    }\\n    static int gcd(int a,int b){\\n        if(a==0){\\n            return b;\\n        }\\n        return gcd(b%a,a);\\n    }\\n    static int lcm(int a ,int b){\\n        return (a/gcd(a,b))*(b/gcd(a,b))*gcd(a,b);\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public List<Integer> replaceNonCoprimes(int[] nums) {\\n        ArrayList<Integer>ans=new ArrayList<>();\\n        for(int i=0;i<nums.length;i++){\\n           ans.add(nums[i]);\\n           while(ans.size()>1){\\n               int a=ans.get(ans.size()-1);\\n               int b=ans.get(ans.size()-2);\\n               if(gcd(a,b)==1){\\n                   break;\\n               }\\n               ans.remove(ans.size()-1);\\n               ans.remove(ans.size()-1);\\n               ans.add(lcm(a,b));\\n           }\\n        }\\n        return ans;\\n    }\\n    static int gcd(int a,int b){\\n        if(a==0){\\n            return b;\\n        }\\n        return gcd(b%a,a);\\n    }\\n    static int lcm(int a ,int b){\\n        return (a/gcd(a,b))*(b/gcd(a,b))*gcd(a,b);\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3538233,
                "title": "optimize-for-a-row-of-the-same-number-clear-code",
                "content": "# Approache\\nFailed: no extra vector, delete removed entries in num. too slow\\n\\nworking one:\\n1. store result in another vector, no deletion, much faster\\n2. copy 1s, no need to calculate\\n3. jump over a row of the same number\\n\\n\\n# Code\\n```\\n#include <numeric>\\n\\nclass Solution {\\npublic:\\n    vector<int> replaceNonCoprimes(vector<int>& nums) {\\n        vector<int> result; // store result to another vector to avoid too many slow deletion in nums\\n        result.push_back(nums[0]);\\n\\n        int i = 1, j;\\n        int factor;\\n        while (i < nums.size()) {\\n            // no need to calculate 1\\n            if (nums[i] == 1) {\\n                result.push_back(1);\\n                i++;\\n                continue;\\n            }\\n\\n            // jump over same numbers\\n            while(i+1 < nums.size() && nums[i] == nums[i+1]) {\\n                i++;\\n            }\\n\\n            // can merge?\\n            factor = gcd(result[result.size()-1], nums[i]);\\n            if (factor <= 1) { // no need to merge\\n                result.push_back(nums[i]);\\n                i++;\\n                continue;\\n            }\\n            \\n            // then, need to merge now\\n            nums[i-1] = nums[i-1] / factor * nums[i];\\n            result[result.size()-1] = result[result.size()-1] / factor * nums[i];\\n            i++;\\n\\n            // try to merge the last two numbers in result until no more to merge, maybe just use stack like other solutions?\\n            j = result.size()-1;\\n            while(j > 0) {\\n                factor = gcd(result[j-1], result[j]);\\n                if (factor <= 1) {\\n                    break;\\n                }\\n                result[j-1] = result[j-1] / factor * result[j];\\n                j -= 1;\\n            }\\n            // trimming after j, keep j\\n            result.erase(result.begin()+j+1, result.end());\\n        }\\n        \\n        return result;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\n#include <numeric>\\n\\nclass Solution {\\npublic:\\n    vector<int> replaceNonCoprimes(vector<int>& nums) {\\n        vector<int> result; // store result to another vector to avoid too many slow deletion in nums\\n        result.push_back(nums[0]);\\n\\n        int i = 1, j;\\n        int factor;\\n        while (i < nums.size()) {\\n            // no need to calculate 1\\n            if (nums[i] == 1) {\\n                result.push_back(1);\\n                i++;\\n                continue;\\n            }\\n\\n            // jump over same numbers\\n            while(i+1 < nums.size() && nums[i] == nums[i+1]) {\\n                i++;\\n            }\\n\\n            // can merge?\\n            factor = gcd(result[result.size()-1], nums[i]);\\n            if (factor <= 1) { // no need to merge\\n                result.push_back(nums[i]);\\n                i++;\\n                continue;\\n            }\\n            \\n            // then, need to merge now\\n            nums[i-1] = nums[i-1] / factor * nums[i];\\n            result[result.size()-1] = result[result.size()-1] / factor * nums[i];\\n            i++;\\n\\n            // try to merge the last two numbers in result until no more to merge, maybe just use stack like other solutions?\\n            j = result.size()-1;\\n            while(j > 0) {\\n                factor = gcd(result[j-1], result[j]);\\n                if (factor <= 1) {\\n                    break;\\n                }\\n                result[j-1] = result[j-1] / factor * result[j];\\n                j -= 1;\\n            }\\n            // trimming after j, keep j\\n            result.erase(result.begin()+j+1, result.end());\\n        }\\n        \\n        return result;\\n    }\\n};\\n```",
                "codeTag": "C++"
            },
            {
                "id": 3537434,
                "title": "c-stack",
                "content": "# Intuition\\n**lcm(a,b) = a*b/gcd(a,b)**.\\n\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    vector<int> replaceNonCoprimes(vector<int>& nums) {\\n        int n = nums.size();\\n        stack<long long> st;\\n        for(int i=0;i<n;i++)\\n        {\\n            st.push(nums[i]);\\n            while(st.size()>1)\\n            {\\n                long long n1 = st.top();\\n                st.pop();\\n                long long n2 = st.top();\\n                st.pop();\\n                if(__gcd(n1,n2)!=1)\\n                {\\n                    int num = (n1*n2)/(__gcd(n1,n2));\\n                    st.push(num);\\n                }\\n                else\\n                {\\n                    st.push(n2);\\n                    st.push(n1);\\n                    break;\\n                }\\n            }\\n        }\\n        vector<int> ans;\\n        while(!st.empty())\\n        {\\n            ans.push_back(st.top());\\n            st.pop();\\n        }\\n        reverse(ans.begin(),ans.end());\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Stack",
                    "Number Theory"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<int> replaceNonCoprimes(vector<int>& nums) {\\n        int n = nums.size();\\n        stack<long long> st;\\n        for(int i=0;i<n;i++)\\n        {\\n            st.push(nums[i]);\\n            while(st.size()>1)\\n            {\\n                long long n1 = st.top();\\n                st.pop();\\n                long long n2 = st.top();\\n                st.pop();\\n                if(__gcd(n1,n2)!=1)\\n                {\\n                    int num = (n1*n2)/(__gcd(n1,n2));\\n                    st.push(num);\\n                }\\n                else\\n                {\\n                    st.push(n2);\\n                    st.push(n1);\\n                    break;\\n                }\\n            }\\n        }\\n        vector<int> ans;\\n        while(!st.empty())\\n        {\\n            ans.push_back(st.top());\\n            st.pop();\\n        }\\n        reverse(ans.begin(),ans.end());\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3520171,
                "title": "c-solution-using-stack-easy-to-understand",
                "content": "\\n```\\npublic class Solution {\\n    public IList<int> ReplaceNonCoprimes(int[] nums) {\\n        // functions\\n        int gcd(int a, int b) => (a == 0) ? b : gcd(b % a,a);\\n        bool IsCoPrime(int a,int b) => gcd(a,b) == 1;\\n        int getLcm(int a, int b) => a / gcd(a,b) * b;\\n        //\\n        Stack<int> s = new Stack<int>();\\n        for(int i = 0;i < nums.Length;i++){\\n            int val = nums[i];\\n            while(s.Count > 0 && !IsCoPrime(s.Peek(),val))\\n                val = getLcm(val,s.Pop());\\n            s.Push(val);\\n        }\\n        List<int> res = new List<int>();\\n        while(s.Count > 0)res.Insert(0,s.Pop());\\n        return res;\\n    }\\n}\\n```",
                "solutionTags": [
                    "C#",
                    "Stack",
                    "Number Theory"
                ],
                "code": "```\\npublic class Solution {\\n    public IList<int> ReplaceNonCoprimes(int[] nums) {\\n        // functions\\n        int gcd(int a, int b) => (a == 0) ? b : gcd(b % a,a);\\n        bool IsCoPrime(int a,int b) => gcd(a,b) == 1;\\n        int getLcm(int a, int b) => a / gcd(a,b) * b;\\n        //\\n        Stack<int> s = new Stack<int>();\\n        for(int i = 0;i < nums.Length;i++){\\n            int val = nums[i];\\n            while(s.Count > 0 && !IsCoPrime(s.Peek(),val))\\n                val = getLcm(val,s.Pop());\\n            s.Push(val);\\n        }\\n        List<int> res = new List<int>();\\n        while(s.Count > 0)res.Insert(0,s.Pop());\\n        return res;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3282098,
                "title": "my-java-solution",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\n    public List<Integer> replaceNonCoprimes(int[] nums) {\\n        List<Integer> list = new ArrayList<>();\\n        for(int i : nums){\\n            while(list.size() > 0 && gcd(i, list.get(list.size() - 1)) != 1){\\n                int q = list.get(list.size() - 1);\\n                list.remove(list.size() - 1);\\n                i = lcm(q, i);\\n            }\\n            list.add(i);\\n        }\\n        \\n        return list;\\n\\n        \\n    }\\n    public int gcd(int a, int b){\\n        if(b == 0){\\n            return a;\\n        }\\n        return gcd(b, a % b);\\n    }\\n    public int lcm(int a, int b){\\n        return (a / gcd(a, b)) * b;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public List<Integer> replaceNonCoprimes(int[] nums) {\\n        List<Integer> list = new ArrayList<>();\\n        for(int i : nums){\\n            while(list.size() > 0 && gcd(i, list.get(list.size() - 1)) != 1){\\n                int q = list.get(list.size() - 1);\\n                list.remove(list.size() - 1);\\n                i = lcm(q, i);\\n            }\\n            list.add(i);\\n        }\\n        \\n        return list;\\n\\n        \\n    }\\n    public int gcd(int a, int b){\\n        if(b == 0){\\n            return a;\\n        }\\n        return gcd(b, a % b);\\n    }\\n    public int lcm(int a, int b){\\n        return (a / gcd(a, b)) * b;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3260347,
                "title": "just-a-runnable-solution",
                "content": "# Code\\n```\\nimpl Solution {\\n    pub fn replace_non_coprimes(nums: Vec<i32>) -> Vec<i32> {\\n        fn gcd(a: i32, b: i32) -> i32 {\\n            match b {\\n                0 => a,\\n                _ => gcd(b, a % b),\\n            }\\n        }\\n\\n        fn lcm(a: i32, b: i32, d: i32) -> i32 {\\n            let a = a as i64;\\n            let b = b as i64;\\n            let d = d as i64;\\n            let ans = (a * b) / d;\\n            ans as i32\\n        }\\n\\n        let mut res = vec![];\\n        for v in nums.iter() {\\n            let n = res.len();\\n            if n == 0 {\\n                res.push(*v);\\n                continue;\\n            }\\n            let mut m = *v;\\n            loop {\\n                let n = res.len() as i32;\\n                if n <= 0 {\\n                    break;\\n                }\\n\\n                let tail = res.pop().unwrap();\\n                let d = gcd(m, tail);\\n                if d == 1 {\\n                    res.push(tail);\\n                    break;\\n                }\\n                m = lcm(m, tail, d);\\n            }\\n            res.push(m);\\n        }\\n        res\\n    }\\n}\\n```",
                "solutionTags": [
                    "Rust"
                ],
                "code": "```\\nimpl Solution {\\n    pub fn replace_non_coprimes(nums: Vec<i32>) -> Vec<i32> {\\n        fn gcd(a: i32, b: i32) -> i32 {\\n            match b {\\n                0 => a,\\n                _ => gcd(b, a % b),\\n            }\\n        }\\n\\n        fn lcm(a: i32, b: i32, d: i32) -> i32 {\\n            let a = a as i64;\\n            let b = b as i64;\\n            let d = d as i64;\\n            let ans = (a * b) / d;\\n            ans as i32\\n        }\\n\\n        let mut res = vec![];\\n        for v in nums.iter() {\\n            let n = res.len();\\n            if n == 0 {\\n                res.push(*v);\\n                continue;\\n            }\\n            let mut m = *v;\\n            loop {\\n                let n = res.len() as i32;\\n                if n <= 0 {\\n                    break;\\n                }\\n\\n                let tail = res.pop().unwrap();\\n                let d = gcd(m, tail);\\n                if d == 1 {\\n                    res.push(tail);\\n                    break;\\n                }\\n                m = lcm(m, tail, d);\\n            }\\n            res.push(m);\\n        }\\n        res\\n    }\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3165052,
                "title": "keep-merging-with-stack-top",
                "content": "```\\nclass Solution:\\n    def gcd(self, a, b):\\n        while b:\\n            a, b = b, a % b\\n        return a\\n    \\n    def replaceNonCoprimes(self, nums: List[int]) -> List[int]:\\n        n = len(nums)\\n        stack = [nums[0]]\\n        for i in range(1, n):\\n            currval = nums[i]\\n            while len(stack) > 0 and self.gcd(stack[-1], currval) > 1:\\n                prev = stack.pop()\\n                currval = prev * currval // self.gcd(prev, currval)\\n            stack.append(currval)\\n        return stack\\n```",
                "solutionTags": [
                    "Python"
                ],
                "code": "```\\nclass Solution:\\n    def gcd(self, a, b):\\n        while b:\\n            a, b = b, a % b\\n        return a\\n    \\n    def replaceNonCoprimes(self, nums: List[int]) -> List[int]:\\n        n = len(nums)\\n        stack = [nums[0]]\\n        for i in range(1, n):\\n            currval = nums[i]\\n            while len(stack) > 0 and self.gcd(stack[-1], currval) > 1:\\n                prev = stack.pop()\\n                currval = prev * currval // self.gcd(prev, currval)\\n            stack.append(currval)\\n        return stack\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3030558,
                "title": "simply-c-easily-understandable-stack",
                "content": "# Intuition\\n\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\nCreate a stack, initially stack is empty so we push first element into stack then traverse again to next element. \\nwhile (st.empty()==false) we check if curr element and stack\\'s top element gcd > 1 or not if yes then we took out the element, calculate the lcm and assign it to curr variable and again check for this new curr value with stack top element.\\nAt any point our gcd == 1 we break out of the loop and push the curr into the stack.\\n\\nAfter that we took out all the element from stack and push them into vector, reverse the vector then return the vector.\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:O(nlogn)\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:(n)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int gcd(int a, int b)\\n{\\n    return b == 0 ? a : gcd(b, a % b);   \\n}\\n    vector<int> replaceNonCoprimes(vector<int>& nums) {\\n        int n = nums.size();\\n        if(n == 1)\\n        return nums;\\n        stack<int> st;\\n        int t, lc ;\\n        for(int i = 0;i<n;i++){\\n            int curr = nums[i];\\n\\n            while(!st.empty()){\\n                int gc = gcd(curr,st.top());\\n                if(gc > 1){\\n                    t = st.top();\\n                    st.pop();\\n                    lc = lcm(curr,t);\\n                    curr = lc;\\n                }\\n                else\\n                break;\\n            }\\n            st.push(curr);\\n        }\\n        vector<int> ans;\\n        while(!st.empty()){\\n            ans.push_back(st.top());\\n            st.pop();\\n        }\\n        reverse(ans.begin(),ans.end());\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Stack"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int gcd(int a, int b)\\n{\\n    return b == 0 ? a : gcd(b, a % b);   \\n}\\n    vector<int> replaceNonCoprimes(vector<int>& nums) {\\n        int n = nums.size();\\n        if(n == 1)\\n        return nums;\\n        stack<int> st;\\n        int t, lc ;\\n        for(int i = 0;i<n;i++){\\n            int curr = nums[i];\\n\\n            while(!st.empty()){\\n                int gc = gcd(curr,st.top());\\n                if(gc > 1){\\n                    t = st.top();\\n                    st.pop();\\n                    lc = lcm(curr,t);\\n                    curr = lc;\\n                }\\n                else\\n                break;\\n            }\\n            st.push(curr);\\n        }\\n        vector<int> ans;\\n        while(!st.empty()){\\n            ans.push_back(st.top());\\n            st.pop();\\n        }\\n        reverse(ans.begin(),ans.end());\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2891248,
                "title": "solution-in-scala",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nobject Solution {\\n    def gcd(a: Int, b: Int): Int = if (b == 0) a else gcd(b, a%b)\\n\\n  def updateStack(n: Int, stack: List[Int]): List[Int] = stack match {\\n    case h :: t =>\\n      val GCD = gcd(n, h)\\n      if (GCD == 1) n :: stack else updateStack(((n.toLong*h)/GCD).toInt, t)\\n    case Nil => n :: stack\\n  }\\n\\n  def replaceNonCoprimes(nums: Array[Int]): List[Int] = {\\n    def loop(index: Int, stack: List[Int]): List[Int] = {\\n      //print(index, stack); println()\\n      if (index == nums.length) stack.reverse\\n      else {\\n        val num = nums(index)\\n        loop(index+1, updateStack(num, stack))\\n      }\\n    }\\n\\n    loop(0, Nil)\\n  }\\n}\\n```",
                "solutionTags": [
                    "Scala"
                ],
                "code": "```\\nobject Solution {\\n    def gcd(a: Int, b: Int): Int = if (b == 0) a else gcd(b, a%b)\\n\\n  def updateStack(n: Int, stack: List[Int]): List[Int] = stack match {\\n    case h :: t =>\\n      val GCD = gcd(n, h)\\n      if (GCD == 1) n :: stack else updateStack(((n.toLong*h)/GCD).toInt, t)\\n    case Nil => n :: stack\\n  }\\n\\n  def replaceNonCoprimes(nums: Array[Int]): List[Int] = {\\n    def loop(index: Int, stack: List[Int]): List[Int] = {\\n      //print(index, stack); println()\\n      if (index == nums.length) stack.reverse\\n      else {\\n        val num = nums(index)\\n        loop(index+1, updateStack(num, stack))\\n      }\\n    }\\n\\n    loop(0, Nil)\\n  }\\n}\\n```",
                "codeTag": "Python3"
            },
            {
                "id": 2889295,
                "title": "python-in-place-w-stack",
                "content": "# Intuition\\nNote that we can greedily merge elements since the problem explicitly states that it can be shown that the order of merge does not matter. \\n# Approach\\nGiven that we can implement a greedy approach, we just need to keep track of the last number we have merged as we iterate over the array.\\n# Complexity\\n- Time complexity:\\n$O(n \\\\log(n))$\\nAlgorithm completes in one loop w/ a log(n) cost per iteration.\\n- Space complexity:\\n$O(n)$\\n# Code\\n```\\nimport math \\nclass Solution:\\n    def replaceNonCoprimes(self, nums: List[int]) -> List[int]:\\n        n = len(nums)\\n        i = 0\\n        stack = []\\n        while i < n:\\n            while stack and math.gcd(stack[-1][0], nums[i]) > 1:\\n                num, j = stack.pop()\\n                nums[i] = math.lcm(num, nums[i])\\n                nums[j] = float(\\'inf\\')\\n            stack.append([nums[i], i])\\n            i += 1\\n        return [ele for ele in nums if ele != float(\\'inf\\')]\\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nimport math \\nclass Solution:\\n    def replaceNonCoprimes(self, nums: List[int]) -> List[int]:\\n        n = len(nums)\\n        i = 0\\n        stack = []\\n        while i < n:\\n            while stack and math.gcd(stack[-1][0], nums[i]) > 1:\\n                num, j = stack.pop()\\n                nums[i] = math.lcm(num, nums[i])\\n                nums[j] = float(\\'inf\\')\\n            stack.append([nums[i], i])\\n            i += 1\\n        return [ele for ele in nums if ele != float(\\'inf\\')]\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2810140,
                "title": "brute-force-solution-using-stack-c",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nwe will use a stack to delete prev top elements\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\nStack\\n# Complexity\\n- Time complexity: \\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: O(N)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    // function to calculate gcd of a and b in log a\\n    int gcd(long int a,long int b){\\n        if(b == 0) return a;\\n        return gcd(b,a%b);\\n    }\\n\\n    vector<int> replaceNonCoprimes(vector<int>& nums) {\\n        stack<int> st;\\n        st.push(nums[0]);\\n        for(int i=1;i<nums.size();i++){\\n            if(st.top() == nums[i] && nums[i] != 1) continue;\\n            int g = nums[i] > st.top() ? gcd(nums[i],st.top()) : gcd(st.top(),nums[i]);\\n            if(g > 1){\\n                // this means we have to change these numbers with its LCM\\n                long int lcm = nums[i]*(st.top()/g);\\n                // Now we have to delete st.top and nums[i] and then insert lcm of both\\n                st.pop();\\n                // Now try to insert lcm while checking in stack for top element\\n                int ng = 1;\\n                if(st.size() > 0) ng = lcm > st.top() ? gcd(lcm,st.top()) : gcd(st.top(),lcm);\\n                while(st.size() > 1 && ng > 1){\\n                    lcm = lcm*(st.top()/ng);\\n                    st.pop();\\n                    ng = lcm > st.top() ? gcd(lcm,st.top()) : gcd(st.top(),lcm);\\n                }\\n                if(st.size() == 1 && ng > 1){\\n                    // we need to delete last element in stack\\n                    lcm = lcm*(st.top()/ng);\\n                    st.pop();\\n                }\\n                st.push(lcm);\\n            }else{\\n                st.push(nums[i]);\\n            }\\n        }\\n        vector<int> ans;\\n        while(!st.empty()){\\n            ans.push_back(st.top());\\n            st.pop();\\n        }\\n        reverse(ans.begin(),ans.end());\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Stack"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    // function to calculate gcd of a and b in log a\\n    int gcd(long int a,long int b){\\n        if(b == 0) return a;\\n        return gcd(b,a%b);\\n    }\\n\\n    vector<int> replaceNonCoprimes(vector<int>& nums) {\\n        stack<int> st;\\n        st.push(nums[0]);\\n        for(int i=1;i<nums.size();i++){\\n            if(st.top() == nums[i] && nums[i] != 1) continue;\\n            int g = nums[i] > st.top() ? gcd(nums[i],st.top()) : gcd(st.top(),nums[i]);\\n            if(g > 1){\\n                // this means we have to change these numbers with its LCM\\n                long int lcm = nums[i]*(st.top()/g);\\n                // Now we have to delete st.top and nums[i] and then insert lcm of both\\n                st.pop();\\n                // Now try to insert lcm while checking in stack for top element\\n                int ng = 1;\\n                if(st.size() > 0) ng = lcm > st.top() ? gcd(lcm,st.top()) : gcd(st.top(),lcm);\\n                while(st.size() > 1 && ng > 1){\\n                    lcm = lcm*(st.top()/ng);\\n                    st.pop();\\n                    ng = lcm > st.top() ? gcd(lcm,st.top()) : gcd(st.top(),lcm);\\n                }\\n                if(st.size() == 1 && ng > 1){\\n                    // we need to delete last element in stack\\n                    lcm = lcm*(st.top()/ng);\\n                    st.pop();\\n                }\\n                st.push(lcm);\\n            }else{\\n                st.push(nums[i]);\\n            }\\n        }\\n        vector<int> ans;\\n        while(!st.empty()){\\n            ans.push_back(st.top());\\n            st.pop();\\n        }\\n        reverse(ans.begin(),ans.end());\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2806602,
                "title": "easy-cpp-solution",
                "content": "\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n   \\n    vector<int> replaceNonCoprimes(vector<int>& nums) {\\n        vector<int> ans;\\n        ans.push_back(nums[0]);\\n        for(int i=1;i<nums.size();i++){\\n      \\n            while( !ans.empty() && gcd(nums[i],ans[ans.size()-1]) > 1){\\n                int lcm=(long)nums[i]*ans[ans.size()-1]/gcd(nums[i],ans[ans.size()-1]);\\n                ans.pop_back();\\n                nums[i]=lcm;\\n            }\\n            if(i<nums.size()) ans.push_back(nums[i]);\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n   \\n    vector<int> replaceNonCoprimes(vector<int>& nums) {\\n        vector<int> ans;\\n        ans.push_back(nums[0]);\\n        for(int i=1;i<nums.size();i++){\\n      \\n            while( !ans.empty() && gcd(nums[i],ans[ans.size()-1]) > 1){\\n                int lcm=(long)nums[i]*ans[ans.size()-1]/gcd(nums[i],ans[ans.size()-1]);\\n                ans.pop_back();\\n                nums[i]=lcm;\\n            }\\n            if(i<nums.size()) ans.push_back(nums[i]);\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2800781,
                "title": "c-easy-solution-stack-math-lcm-gcd",
                "content": "class Solution {\\npublic:\\n    \\n    int GCD(int x, int y){\\n        if(y==0) return x;\\n        return GCD(y, x%y);\\n    }\\n    int LCM (int x,int y){\\n        return x / GCD(x,y) * y;\\n    }\\n    \\n    vector<int> replaceNonCoprimes(vector<int>& nums) {\\n        vector<int> ans;\\n          for(auto num:nums){\\n              \\n               while (ans.size() && gcd(ans.back(), num) > 1) {\\n                    num = lcm(num, ans.back());\\n                    ans.pop_back();\\n                }\\n                ans.push_back(num);\\n          }   \\n         return ans;\\n    }\\n};\\n\\n\\n",
                "solutionTags": [
                    "C++",
                    "C",
                    "Math",
                    "Stack"
                ],
                "code": "class Solution {\\npublic:\\n    \\n    int GCD(int x, int y){\\n        if(y==0) return x;\\n        return GCD(y, x%y);\\n    }",
                "codeTag": "Java"
            },
            {
                "id": 2800201,
                "title": "python-c-c-100-00-100-00-98-46-faster-two-pointers",
                "content": "We don\\'t use another container as a stack and just move through the \\'nums\\' array with  two pointers i and j.\\n\\nRuntime: 1451 ms, faster than 100.00%\\nMemory Usage: 29.4 MB, less than 92.31%\\n\\n\\tclass Solution(object):\\n\\t\\tdef replaceNonCoprimes(self, nums):\\n\\t\\t\\t\"\"\"\\n\\t\\t\\t:type nums: List[int]\\n\\t\\t\\t:rtype: List[int]\\n\\t\\t\\t\"\"\"\\n\\t\\t\\tdef gcd(a, b):\\n\\t\\t\\t\\twhile b:\\n\\t\\t\\t\\t\\ta, b = b, a % b\\n\\t\\t\\t\\treturn a\\n\\n\\t\\t\\tj = 0   # left pointer\\n\\n\\t\\t\\tfor i in range(1, len(nums)):\\n\\t\\t\\t\\tg = gcd(nums[j], nums[i])\\n\\t\\t\\t\\tif g == 1:\\n\\t\\t\\t\\t\\tj += 1\\n\\t\\t\\t\\t\\tif j != i: nums[j] = nums[i]\\n\\t\\t\\t\\telse:\\n\\t\\t\\t\\t\\tnums[j] = nums[j] // g * nums[i]\\n\\n\\t\\t\\t\\t\\twhile j >= 1:\\n\\t\\t\\t\\t\\t\\tg = gcd(nums[j - 1], nums[j])\\n\\t\\t\\t\\t\\t\\tif g == 1: break\\n\\t\\t\\t\\t\\t\\tnums[j - 1] = nums[j - 1] // g * nums[j]\\n\\t\\t\\t\\t\\t\\tj -= 1\\n\\n\\t\\t\\treturn nums[:j + 1]\\n\\n\\nRuntime: 508 ms, faster than 100.00%\\nMemory Usage: 47.4 MB, less than 100.00%\\n\\n\\t/**\\n\\t * Note: The returned array must be malloced, assume caller calls free().\\n\\t */\\n\\tint tmp;\\n\\tint gcd(int a, int b)\\n\\t{\\n\\t\\twhile (b)\\n\\t\\t{\\n\\t\\t\\ttmp = a % b;\\n\\t\\t\\ta = b;\\n\\t\\t\\tb = tmp;\\n\\t\\t}\\n\\n\\t\\treturn a;\\n\\t}\\n\\n\\tint* replaceNonCoprimes(int* nums, int numsSize, int* returnSize)\\n\\t{\\n\\t\\tint j = 0;   // left pointer\\n\\t\\tint g;\\n\\n\\t\\tfor (int i = 1; i < numsSize; ++i)\\n\\t\\t{    \\n\\t\\t\\tg = gcd(nums[j], nums[i]);\\n\\n\\t\\t\\tif (g == 1)\\n\\t\\t\\t{    \\n\\t\\t\\t\\tif (++j != i)\\n\\t\\t\\t\\t\\tnums[j] = nums[i];\\n\\t\\t\\t}\\n\\n\\t\\t\\telse\\n\\t\\t\\t{    \\n\\t\\t\\t\\tnums[j] = nums[j] / g * nums[i];\\n\\n\\t\\t\\t\\twhile (j >= 1)\\n\\t\\t\\t\\t{    \\n\\t\\t\\t\\t\\tg = gcd(nums[j - 1], nums[j]);\\n\\n\\t\\t\\t\\t\\tif (g == 1) \\n\\t\\t\\t\\t\\t\\tbreak;\\n\\n\\t\\t\\t\\t\\tnums[j - 1] = nums[j - 1] / g * nums[j];\\n\\t\\t\\t\\t\\t--j;\\n\\t\\t\\t\\t}\\n\\t\\t\\t}\\n\\t\\t}\\n\\n\\t\\treturnSize[0] = j + 1; \\n\\t\\treturn nums;\\n\\t}\\n\\t\\nRuntime: 211 ms, faster than 98.46%\\nMemory Usage: 116.6 MB, less than 99.34%\\n\\n\\tclass Solution \\n\\t{\\n\\tpublic:\\n\\t\\tvector<int> replaceNonCoprimes(vector<int>& nums) \\n\\t\\t{\\n\\t\\t\\tint j = 0;   // left pointer\\n\\t\\t\\tint g;\\n\\n\\t\\t\\tfor (int i = 1; i < nums.size(); ++i)\\n\\t\\t\\t{    \\n\\t\\t\\t\\tg = gcd(nums[j], nums[i]);\\n\\n\\t\\t\\t\\tif (g == 1)\\n\\t\\t\\t\\t{    \\n\\t\\t\\t\\t\\tif (++j != i)\\n\\t\\t\\t\\t\\t\\tnums[j] = nums[i];\\n\\t\\t\\t\\t}\\n\\n\\t\\t\\t\\telse\\n\\t\\t\\t\\t{    \\n\\t\\t\\t\\t\\tnums[j] = nums[j] / g * nums[i];\\n\\n\\t\\t\\t\\t\\twhile (j >= 1)\\n\\t\\t\\t\\t\\t{    \\n\\t\\t\\t\\t\\t\\tg = gcd(nums[j - 1], nums[j]);\\n\\n\\t\\t\\t\\t\\t\\tif (g == 1) \\n\\t\\t\\t\\t\\t\\t\\tbreak;\\n\\n\\t\\t\\t\\t\\t\\tnums[j - 1] = nums[j - 1] / g * nums[j];\\n\\t\\t\\t\\t\\t\\t--j;\\n\\t\\t\\t\\t\\t}\\n\\t\\t\\t\\t}\\n\\t\\t\\t}\\n\\n\\t\\t\\treturn vector<int>(nums.begin(), nums.begin() + j + 1);\\n\\t\\t}\\n\\t};\\n\\t\\n\\n",
                "solutionTags": [
                    "Python",
                    "C",
                    "Two Pointers"
                ],
                "code": "class Solution(object):\\n\\t\\tdef replaceNonCoprimes(self, nums):\\n\\t\\t\\t\"\"\"\\n\\t\\t\\t:type nums: List[int]\\n\\t\\t\\t:rtype: List[int]\\n\\t\\t\\t\"\"\"\\n\\t\\t\\tdef gcd(a, b):\\n\\t\\t\\t\\twhile b:\\n\\t\\t\\t\\t\\ta, b = b, a % b\\n\\t\\t\\t\\treturn a\\n\\n\\t\\t\\tj = 0   # left pointer\\n\\n\\t\\t\\tfor i in range(1, len(nums)):\\n\\t\\t\\t\\tg = gcd(nums[j], nums[i])\\n\\t\\t\\t\\tif g == 1:\\n\\t\\t\\t\\t\\tj += 1\\n\\t\\t\\t\\t\\tif j != i: nums[j] = nums[i]\\n\\t\\t\\t\\telse:\\n\\t\\t\\t\\t\\tnums[j] = nums[j] // g * nums[i]\\n\\n\\t\\t\\t\\t\\twhile j >= 1:\\n\\t\\t\\t\\t\\t\\tg = gcd(nums[j - 1], nums[j])\\n\\t\\t\\t\\t\\t\\tif g == 1: break\\n\\t\\t\\t\\t\\t\\tnums[j - 1] = nums[j - 1] // g * nums[j]\\n\\t\\t\\t\\t\\t\\tj -= 1\\n\\n\\t\\t\\treturn nums[:j + 1]\\n\\n\\nRuntime: 508 ms, faster than 100.00%\\nMemory Usage: 47.4 MB, less than 100.00%\\n\\n\\t/**\\n\\t * Note: The returned array must be malloced, assume caller calls free().\\n\\t */\\n\\tint tmp;\\n\\tint gcd(int a, int b)\\n\\t{\\n\\t\\twhile (b)\\n\\t\\t{\\n\\t\\t\\ttmp = a % b;\\n\\t\\t\\ta = b;\\n\\t\\t\\tb = tmp;\\n\\t\\t}",
                "codeTag": "Java"
            },
            {
                "id": 2799460,
                "title": "cpp-one-pass-stack-easy-approach-beats-100",
                "content": "# Intuition\\nvariation of Remove All Adjacent Duplicates In String using stack\\n\\n# Approach\\nNote : I used ans vector as stack.\\n1. check gcd of (curr_element and last element in ans vector) \\n2. if(gcd==1) then push the curr_element in ans vector.\\n3. else find LCM and change the curr_element value\\n4. only push the curr_element in ans vector when ans.size()==1 or GCD==1\\n\\n# Complexity\\n- Time complexity:\\nO(NlogM)\\n\\n- Space complexity:\\nO(N) for ans vector otherwise O(1)\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    vector<int> replaceNonCoprimes(vector<int>& nums) {\\n        long int i,j,k;\\n        vector<int> ans;\\n        for(i=0;i<nums.size();){\\n            j = nums[i];\\n            if(!ans.empty()){\\n                k = GCD(j,ans.back());\\n                //cout<<j<<\" \"<<k<<\"\\\\n\";\\n                if(k!=1){\\n                    j *= ans.back();\\n                    ans.pop_back();\\n                    j /=k;\\n                    nums[i] = j;\\n                    continue;\\n                }\\n            }ans.push_back(j);\\n            i++;\\n        }\\n        return ans;\\n    }\\n    int GCD(int i,int j){\\n        int rem;\\n        while(j!=0){\\n            rem = i%j;\\n            i=j;\\n            j=rem;\\n        }\\n        return i;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Stack"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<int> replaceNonCoprimes(vector<int>& nums) {\\n        long int i,j,k;\\n        vector<int> ans;\\n        for(i=0;i<nums.size();){\\n            j = nums[i];\\n            if(!ans.empty()){\\n                k = GCD(j,ans.back());\\n                //cout<<j<<\" \"<<k<<\"\\\\n\";\\n                if(k!=1){\\n                    j *= ans.back();\\n                    ans.pop_back();\\n                    j /=k;\\n                    nums[i] = j;\\n                    continue;\\n                }\\n            }ans.push_back(j);\\n            i++;\\n        }\\n        return ans;\\n    }\\n    int GCD(int i,int j){\\n        int rem;\\n        while(j!=0){\\n            rem = i%j;\\n            i=j;\\n            j=rem;\\n        }\\n        return i;\\n    }\\n};\\n```",
                "codeTag": "C++"
            },
            {
                "id": 2799444,
                "title": "python-in-place-o-1-space",
                "content": "note this solution is worse in time complexity than solutions with additional stack\\n```\\nclass Solution:\\n    def replaceNonCoprimes(self, nums: List[int]) -> List[int]:\\n        i = 0\\n        while i < len(nums) - 1:\\n            gcd = math.gcd(nums[i], nums[i + 1])\\n            if gcd > 1:\\n                nums[i] = abs(nums[i] * nums[i + 1]) // gcd  # lcm\\n                del nums[i + 1]\\n                i = max(0, i - 1)\\n            else:\\n                i += 1\\n        return nums\\n```",
                "solutionTags": [
                    "Python",
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def replaceNonCoprimes(self, nums: List[int]) -> List[int]:\\n        i = 0\\n        while i < len(nums) - 1:\\n            gcd = math.gcd(nums[i], nums[i + 1])\\n            if gcd > 1:\\n                nums[i] = abs(nums[i] * nums[i + 1]) // gcd  # lcm\\n                del nums[i + 1]\\n                i = max(0, i - 1)\\n            else:\\n                i += 1\\n        return nums\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2742419,
                "title": "python3-o-n-time-o-n-space-stack",
                "content": "Key point:\\n1. lcm(numA, numB) = |numA * numB| / gcd(numA, numB)\\n2. If the incoming element nums[i] and the top element in the stack are non-coprime, then we calculate lcm(nums[i], stack[-1]), pop the top element in the stack, and append the lcm to the stack.\\n\\n```\\nclass Solution:\\n    def replaceNonCoprimes(self, nums: List[int]) -> List[int]:\\n        stack = []\\n        for idx in range(len(nums)):\\n            cur_num = nums[idx]\\n            while len(stack) > 0:\\n                cur_gcd = self.calculate_gcd(numA=stack[-1], numB=cur_num)\\n                if cur_gcd > 1:\\n                    cur_num = self.calculate_lcm(gcd=cur_gcd, numA=stack[-1], numB=cur_num)\\n                    stack.pop()\\n                else:\\n                    break\\n            stack.append(cur_num)\\n        return stack\\n        \\n    def calculate_gcd(self, numA: int, numB: int) -> int:\\n        while numA > 0 and numB > 0:\\n            if numA == numB:\\n                return numA\\n            if numA > numB:\\n                numA %= numB\\n            else:\\n                numB %= numA\\n        if numA > 0:\\n            return numA\\n        return numB\\n    \\n    def calculate_lcm(self, gcd: int, numA: int, numB: int) -> int:\\n        return (numA * numB) // gcd",
                "solutionTags": [
                    "Python3",
                    "Stack"
                ],
                "code": "Key point:\\n1. lcm(numA, numB) = |numA * numB| / gcd(numA, numB)\\n2. If the incoming element nums[i] and the top element in the stack are non-coprime, then we calculate lcm(nums[i], stack[-1]), pop the top element in the stack, and append the lcm to the stack.\\n\\n```\\nclass Solution:\\n    def replaceNonCoprimes(self, nums: List[int]) -> List[int]:\\n        stack = []\\n        for idx in range(len(nums)):\\n            cur_num = nums[idx]\\n            while len(stack) > 0:\\n                cur_gcd = self.calculate_gcd(numA=stack[-1], numB=cur_num)\\n                if cur_gcd > 1:\\n                    cur_num = self.calculate_lcm(gcd=cur_gcd, numA=stack[-1], numB=cur_num)\\n                    stack.pop()\\n                else:\\n                    break\\n            stack.append(cur_num)\\n        return stack\\n        \\n    def calculate_gcd(self, numA: int, numB: int) -> int:\\n        while numA > 0 and numB > 0:\\n            if numA == numB:\\n                return numA\\n            if numA > numB:\\n                numA %= numB\\n            else:\\n                numB %= numA\\n        if numA > 0:\\n            return numA\\n        return numB\\n    \\n    def calculate_lcm(self, gcd: int, numA: int, numB: int) -> int:\\n        return (numA * numB) // gcd",
                "codeTag": "Java"
            },
            {
                "id": 2740581,
                "title": "simple-c-solution-using-stack-and-gcd",
                "content": "```\\nclass Solution {\\npublic:\\n    int gcd(int a , int b){\\n        if(a==0){\\n            return b;\\n        }\\n        return gcd(b%a , a);\\n    }\\n    \\n    vector<int> replaceNonCoprimes(vector<int>& arr) {\\n        int n = arr.size();\\n        \\n        vector<int> ans;\\n        \\n        stack<int> st;\\n        \\n        for(int i=0 ; i<n ; i++){\\n            if(st.empty()){\\n                st.push(arr[i]);\\n            }\\n            else{\\n                int x = arr[i];\\n                int y = st.top();\\n                int g = gcd(x,y);\\n                if(g>1){\\n                    st.pop();\\n                    int lcm = (int)((1ll*x*y)/g);\\n                    st.push(lcm);\\n                    while(st.size()>1){\\n                        x = st.top();\\n                        st.pop();\\n                        y = st.top();\\n                        st.pop();\\n                        g = gcd(x,y);\\n                        if(g<=1){\\n                            st.push(y);\\n                            st.push(x);\\n                            break;\\n                        }\\n                        lcm = (int)((1ll*x*y)/g);\\n                        st.push(lcm);\\n                    }\\n                }\\n                else{\\n                    st.push(x);\\n                }\\n            }\\n        }\\n        \\n        while(!st.empty()){\\n            ans.push_back(st.top());\\n            st.pop();\\n        }\\n        \\n        reverse(ans.begin() , ans.end());\\n        \\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C",
                    "Stack"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int gcd(int a , int b){\\n        if(a==0){\\n            return b;\\n        }\\n        return gcd(b%a , a);\\n    }\\n    \\n    vector<int> replaceNonCoprimes(vector<int>& arr) {\\n        int n = arr.size();\\n        \\n        vector<int> ans;\\n        \\n        stack<int> st;\\n        \\n        for(int i=0 ; i<n ; i++){\\n            if(st.empty()){\\n                st.push(arr[i]);\\n            }\\n            else{\\n                int x = arr[i];\\n                int y = st.top();\\n                int g = gcd(x,y);\\n                if(g>1){\\n                    st.pop();\\n                    int lcm = (int)((1ll*x*y)/g);\\n                    st.push(lcm);\\n                    while(st.size()>1){\\n                        x = st.top();\\n                        st.pop();\\n                        y = st.top();\\n                        st.pop();\\n                        g = gcd(x,y);\\n                        if(g<=1){\\n                            st.push(y);\\n                            st.push(x);\\n                            break;\\n                        }\\n                        lcm = (int)((1ll*x*y)/g);\\n                        st.push(lcm);\\n                    }\\n                }\\n                else{\\n                    st.push(x);\\n                }\\n            }\\n        }\\n        \\n        while(!st.empty()){\\n            ans.push_back(st.top());\\n            st.pop();\\n        }\\n        \\n        reverse(ans.begin() , ans.end());\\n        \\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2739338,
                "title": "python-simple-stack",
                "content": "\\n    def replaceNonCoprimes(self, nums):\\n        stack = []\\n        \\n        for i in nums:\\n            stack.append(i)\\n            \\n            while len(stack) > 1 and math.gcd(stack[-1],stack[-2]) > 1:\\n                a, b = stack.pop(), stack.pop()\\n                stack.append(math.lcm(a,b))\\n                \\n        return stack",
                "solutionTags": [],
                "code": "\\n    def replaceNonCoprimes(self, nums):\\n        stack = []\\n        \\n        for i in nums:\\n            stack.append(i)\\n            \\n            while len(stack) > 1 and math.gcd(stack[-1],stack[-2]) > 1:\\n                a, b = stack.pop(), stack.pop()\\n                stack.append(math.lcm(a,b))\\n                \\n        return stack",
                "codeTag": "Python3"
            },
            {
                "id": 2725888,
                "title": "c",
                "content": "Runtime: 615 ms, faster than 100.00% of C online submissions for Replace Non-Coprime Numbers in Array.\\nMemory Usage: 50.3 MB, less than 100.00% of C online submissions for Replace Non-Coprime Numbers in Array.\\n```\\nint gcd(int n1, int n2){\\n\\n    while(n1 != 0 && n2 != 0){\\n        if(n1 >= n2)\\n            n1 %= n2;\\n        else\\n            n2 %= n1;\\n    }\\n    return fmax(n1, n2);\\n}\\n\\nint* replaceNonCoprimes(int* nums, int numsSize, int* returnSize){\\n    int* ans = malloc(numsSize * sizeof(int));\\n    int idx = 0;\\n   for (int i = 0; i < numsSize; i++) {\\n      if(nums[i] == 1){\\n          ans[idx] = 1;\\n          idx++;\\n          continue;\\n      }\\n      if(i > 0 && nums[i] == nums[i-1])\\n           continue;\\n      ans[idx] = nums[i];\\n      idx++;\\n      while (idx > 1) {\\n        const int n1 = ans[idx - 1]; \\n        const int n2 = ans[idx - 2]; \\n        const int d = gcd(n1, n2);\\n        if (d == 1) break;\\n        if(d == n1){\\n            idx--;\\n            continue;\\n        }\\n        if(d == n2){\\n            ans[idx-2] = n1;\\n            idx--;\\n            continue;\\n        }\\n        idx -= 2;\\n        ans[idx] = (n1 / d * n2);\\n        idx++;\\n      }\\n    }\\n    *returnSize = idx;\\n    return ans;\\n}\\n```",
                "solutionTags": [
                    "Math",
                    "Stack"
                ],
                "code": "```\\nint gcd(int n1, int n2){\\n\\n    while(n1 != 0 && n2 != 0){\\n        if(n1 >= n2)\\n            n1 %= n2;\\n        else\\n            n2 %= n1;\\n    }\\n    return fmax(n1, n2);\\n}\\n\\nint* replaceNonCoprimes(int* nums, int numsSize, int* returnSize){\\n    int* ans = malloc(numsSize * sizeof(int));\\n    int idx = 0;\\n   for (int i = 0; i < numsSize; i++) {\\n      if(nums[i] == 1){\\n          ans[idx] = 1;\\n          idx++;\\n          continue;\\n      }\\n      if(i > 0 && nums[i] == nums[i-1])\\n           continue;\\n      ans[idx] = nums[i];\\n      idx++;\\n      while (idx > 1) {\\n        const int n1 = ans[idx - 1]; \\n        const int n2 = ans[idx - 2]; \\n        const int d = gcd(n1, n2);\\n        if (d == 1) break;\\n        if(d == n1){\\n            idx--;\\n            continue;\\n        }\\n        if(d == n2){\\n            ans[idx-2] = n1;\\n            idx--;\\n            continue;\\n        }\\n        idx -= 2;\\n        ans[idx] = (n1 / d * n2);\\n        idx++;\\n      }\\n    }\\n    *returnSize = idx;\\n    return ans;\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2634808,
                "title": "12-6-question",
                "content": "In example 1 of task, we have final result [12, 7, 6]. \\nBut GCD(12,6) = 6 > 1, so those numbers are not coprime.\\nAnd their MCK = 12, due to condition of task they should be replaced with 1 number (12). \\nSo, final result should look [12, 7]. \\nOr have I missed something ?\\n",
                "solutionTags": [],
                "code": "In example 1 of task, we have final result [12, 7, 6]. \\nBut GCD(12,6) = 6 > 1, so those numbers are not coprime.\\nAnd their MCK = 12, due to condition of task they should be replaced with 1 number (12). \\nSo, final result should look [12, 7]. \\nOr have I missed something ?\\n",
                "codeTag": "Unknown"
            },
            {
                "id": 2546121,
                "title": "c-stack",
                "content": "```\\nclass Solution {\\npublic:\\n    vector<int> replaceNonCoprimes(vector<int>& nums) {\\n        vector<int> res;\\n        for(auto i: nums){\\n            res.push_back(i);\\n            while(res.size() > 1 && __gcd(res.back(), res[res.size() - 2]) > 1){\\n                long long a = res.back();\\n                long long b = res[res.size() - 2];\\n                long long g=__gcd(a,b);\\n                res.pop_back();\\n                res.pop_back();\\n                \\n                res.push_back(a*b/g);\\n            }\\n        }\\n        return res;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "C",
                    "Math",
                    "Stack"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<int> replaceNonCoprimes(vector<int>& nums) {\\n        vector<int> res;\\n        for(auto i: nums){\\n            res.push_back(i);\\n            while(res.size() > 1 && __gcd(res.back(), res[res.size() - 2]) > 1){\\n                long long a = res.back();\\n                long long b = res[res.size() - 2];\\n                long long g=__gcd(a,b);\\n                res.pop_back();\\n                res.pop_back();\\n                \\n                res.push_back(a*b/g);\\n            }\\n        }\\n        return res;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2514757,
                "title": "c-stack-one-pass",
                "content": "TAKE THE TOP 2 ELEMENTS OF THE STACK\\nIF THERE GCD IS >1 THEN POP THOSE 2 ELEMENTS AND PUSH LCM OF THEM\\nLCM OF 2 NUMBERS == (A*B)/GCD(A,B);\\n\\n```\\nclass Solution {\\npublic:\\n    vector<int> replaceNonCoprimes(vector<int>& nums) {\\n        \\n        stack<int>st;\\n        \\n        int n=nums.size();\\n        \\n        for(int i=0;i<n;i++)\\n        {\\n            st.push(nums[i]);\\n            \\n            while(st.size()>1)\\n            {\\n                long long a=st.top();\\n                st.pop();\\n                long long b=st.top();\\n                st.pop();\\n                \\n                if(__gcd(a,b)>1)\\n                {\\n                    st.push(((long long)(a*b)/(__gcd(a,b))));\\n                }\\n                else\\n                {\\n                    st.push(b);\\n                    st.push(a);\\n                    break;\\n                }\\n            }\\n        }\\n        \\n        vector<int>ans;\\n        \\n        while(!st.empty())\\n        {\\n            ans.push_back(st.top());\\n            st.pop();\\n        }\\n        reverse(ans.begin(),ans.end());\\n        \\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C",
                    "Stack"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<int> replaceNonCoprimes(vector<int>& nums) {\\n        \\n        stack<int>st;\\n        \\n        int n=nums.size();\\n        \\n        for(int i=0;i<n;i++)\\n        {\\n            st.push(nums[i]);\\n            \\n            while(st.size()>1)\\n            {\\n                long long a=st.top();\\n                st.pop();\\n                long long b=st.top();\\n                st.pop();\\n                \\n                if(__gcd(a,b)>1)\\n                {\\n                    st.push(((long long)(a*b)/(__gcd(a,b))));\\n                }\\n                else\\n                {\\n                    st.push(b);\\n                    st.push(a);\\n                    break;\\n                }\\n            }\\n        }\\n        \\n        vector<int>ans;\\n        \\n        while(!st.empty())\\n        {\\n            ans.push_back(st.top());\\n            st.pop();\\n        }\\n        reverse(ans.begin(),ans.end());\\n        \\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2504765,
                "title": "simple-c-implementation-easy",
                "content": "```\\nclass Solution {\\npublic:\\n    vector<int> replaceNonCoprimes(vector<int>& nums) {\\n        \\n        vector<int> ans;\\n        for(int i = 0 ;i < nums.size() ; i++)\\n        {\\n            while(!ans.empty() and __gcd(ans.back(), nums[i]) > 1)\\n            {\\n                nums[i] = lcm(ans.back(), nums[i]);\\n                ans.pop_back();\\n            }\\n            ans.push_back(nums[i]);\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<int> replaceNonCoprimes(vector<int>& nums) {\\n        \\n        vector<int> ans;\\n        for(int i = 0 ;i < nums.size() ; i++)\\n        {\\n            while(!ans.empty() and __gcd(ans.back(), nums[i]) > 1)\\n            {\\n                nums[i] = lcm(ans.back(), nums[i]);\\n                ans.pop_back();\\n            }\\n            ans.push_back(nums[i]);\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2404629,
                "title": "easy-c-stack",
                "content": "```\\nclass Solution {\\npublic:\\n    vector<int> replaceNonCoprimes(vector<int>& nums) {\\n        stack<int>st;\\n        int n=nums.size();\\n        st.push(nums[0]);\\n        for(int i=1;i<n;i++){\\n            if(__gcd(nums[i],st.top())!=1){ // we get a non coprime number here\\n              int y=st.top();\\n                st.pop();\\n                long long z=1ll*y*nums[i];\\n                int t=z/__gcd(nums[i],y);    \\n                while(st.size()>0&&__gcd(st.top(),t)!=1)// repeating the same process again \\n                {\\n                    y=st.top();\\n                    st.pop();\\n                    prod=1ll*y*t;\\n                    t=prod/__gcd(y,t); // inbuilt gcd function\\n                }\\n                // Checking the previous elements in the stack \\n                st.push(t);\\n            }else{\\n                st.push(nums[i]);\\n            }\\n        }\\n        vector<int>ans;\\n        while(!st.empty()){\\n            ans.push_back(st.top());\\n            st.pop();\\n        }\\n        reverse(ans.begin(),ans.end());\\n        return ans;\\n    }\\n\\n};\\n```",
                "solutionTags": [
                    "Stack"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<int> replaceNonCoprimes(vector<int>& nums) {\\n        stack<int>st;\\n        int n=nums.size();\\n        st.push(nums[0]);\\n        for(int i=1;i<n;i++){\\n            if(__gcd(nums[i],st.top())!=1){ // we get a non coprime number here\\n              int y=st.top();\\n                st.pop();\\n                long long z=1ll*y*nums[i];\\n                int t=z/__gcd(nums[i],y);    \\n                while(st.size()>0&&__gcd(st.top(),t)!=1)// repeating the same process again \\n                {\\n                    y=st.top();\\n                    st.pop();\\n                    prod=1ll*y*t;\\n                    t=prod/__gcd(y,t); // inbuilt gcd function\\n                }\\n                // Checking the previous elements in the stack \\n                st.push(t);\\n            }else{\\n                st.push(nums[i]);\\n            }\\n        }\\n        vector<int>ans;\\n        while(!st.empty()){\\n            ans.push_back(st.top());\\n            st.pop();\\n        }\\n        reverse(ans.begin(),ans.end());\\n        return ans;\\n    }\\n\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2350412,
                "title": "java-easy-solution-2-approach-stack",
                "content": "\\'\\'\\'\\n**Approach 1:**\\n\\nclass Solution {\\n    \\n    public int gcd(int a,int b){\\n        \\n        if(b==0){\\n            return a;\\n        }\\n        \\n        return gcd(b,a%b);\\n    }\\n    \\n    public int lcm(int a,int b,int gcd){\\n        \\n        return (a/gcd)*(b/gcd)*gcd;\\n    }\\n    \\n    public List<Integer> replaceNonCoprimes(int[] nums) {\\n        \\n        List<Integer> ans=new ArrayList<>();\\n        Stack<Integer> st=new Stack<>();\\n        st.push(nums[0]);\\n        for(int i=1;i<nums.length;i++){\\n            while(st.size()>=2){\\n                int a=st.pop();\\n                int b=st.pop();\\n                int gcd=gcd(a,b);\\n                if(gcd>1){\\n                    st.push(lcm(a,b,gcd));\\n                }else{\\n                    st.push(b);\\n                    st.push(a);\\n                    break;\\n                }\\n            }\\n            int a=st.pop();\\n            int b=nums[i];\\n            int gcd=gcd(a,b);\\n            \\n            if(gcd>1){\\n                st.push(lcm(a,b,gcd));\\n            }else{\\n                st.push(a);\\n                st.push(b);\\n            }\\n        }\\n        \\n        while(st.isEmpty()==false){\\n            ans.add(st.pop());\\n        }\\n        \\n        int i=0,j=ans.size()-1;\\n        \\n        while(i<j){\\n            int temp=ans.get(i);\\n            ans.set(i++,ans.get(j));\\n            ans.set(j--,temp);\\n            \\n        }\\n        \\n        return ans;\\n    }\\n}\\n\\n**Approach 2:**\\n\\nclass Solution {\\n    \\n    public int gcd(int a,int b){\\n        \\n        if(b==0){\\n            return a;\\n        }\\n        \\n        return gcd(b,a%b);\\n    }\\n    \\n    public int lcm(int a,int b,int gcd){\\n        \\n        return (a/gcd)*(b/gcd)*gcd;\\n    }\\n             \\n    public List<Integer> replaceNonCoprimes(int[] nums) {\\n        \\n        List<Integer> ans = new ArrayList<>();\\n        \\n        for(int i=0;i<nums.length;i++){\\n            \\n            ans.add(nums[i]);\\n            \\n            while(ans.size()>1){\\n                \\n                int a=ans.get(ans.size()-1), b=ans.get(ans.size()-2);\\n                \\n                int gcd=gcd(a,b);\\n                \\n                if(gcd==1)\\n                    break;\\n                ans.remove(ans.size()-1);\\n                ans.remove(ans.size()-1);\\n                ans.add(lcm(a,b,gcd));\\n            }\\n        }\\n        \\n        return ans;\\n    }\\n}\\n\\n\\n\\'\\'\\'",
                "solutionTags": [],
                "code": "class Solution {\\n    \\n    public int gcd(int a,int b){\\n        \\n        if(b==0){\\n            return a;\\n        }",
                "codeTag": "Java"
            },
            {
                "id": 2346543,
                "title": "c-monotonic-stack",
                "content": "Tips.\\n\\nThough this problem is **Monotonic Stack**, but we use an array instead of stack, to avoid TLE issue.\\nnon-coprime means that two number\\'s GCD is 1\\n```\\n        public IList<int> ReplaceNonCoprimes(int[] nums)\\n        {\\n            int n = nums.Length;\\n            int[] arr = new int[n];//donot use stack , it may TLE\\n            int j = -1;\\n            for(int i = 0; i < n; i++)\\n            {\\n                int curr = nums[i];//we need a local variable, it may update in later\\n                while (j>=0 && getGCD(arr[j], curr) > 1)//if current number is non-coprime with last one\\n                {\\n                    curr = getLCM(arr[j--], curr);//delete them and create their LCM\\n                }\\n                arr[++j]=curr;\\n            }\\n            return arr.Take(j+1).ToList();//j+1 = final count of elements in nums\\n        }\\n\\t\\tprivate int getGCD(int x, int y)//find the GCD of two numbers\\n        {\\n            return y == 0 ? x : getGCD(y, x % y);\\n        }\\n\\t\\tprivate int getLCM(int x, int y)//calculate the LCM of two numbers\\n        {\\n            return x / getGCD(x, y) * y;\\n        }\\n```",
                "solutionTags": [],
                "code": "```\\n        public IList<int> ReplaceNonCoprimes(int[] nums)\\n        {\\n            int n = nums.Length;\\n            int[] arr = new int[n];//donot use stack , it may TLE\\n            int j = -1;\\n            for(int i = 0; i < n; i++)\\n            {\\n                int curr = nums[i];//we need a local variable, it may update in later\\n                while (j>=0 && getGCD(arr[j], curr) > 1)//if current number is non-coprime with last one\\n                {\\n                    curr = getLCM(arr[j--], curr);//delete them and create their LCM\\n                }\\n                arr[++j]=curr;\\n            }\\n            return arr.Take(j+1).ToList();//j+1 = final count of elements in nums\\n        }\\n\\t\\tprivate int getGCD(int x, int y)//find the GCD of two numbers\\n        {\\n            return y == 0 ? x : getGCD(y, x % y);\\n        }\\n\\t\\tprivate int getLCM(int x, int y)//calculate the LCM of two numbers\\n        {\\n            return x / getGCD(x, y) * y;\\n        }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2328607,
                "title": "c-simple-c-code",
                "content": "# **If you like the implementation then Please help me by increasing my reputation. By clicking the up arrow on the left of my image.**\\n```\\nclass Solution {\\n    int LongestCM(int a, int b, int gcd)\\n    {\\n        int f = a / gcd;\\n        f *= b;\\n        return f;\\n    }\\npublic:\\n    vector<int> replaceNonCoprimes(vector<int>& nums) {\\n        int n = nums.size(), i = 0;\\n        stack<int> st;\\n        while(i < n)\\n        {\\n            int val = nums[i];\\n            while(!st.empty())\\n            {\\n                int gcd = __gcd(val,st.top());\\n                if(gcd == 1)\\n                    break;\\n                else\\n                {\\n                    int v = st.top();\\n                    st.pop();\\n                    val = LongestCM(v, val, gcd);\\n                }\\n            }\\n            st.push(val);\\n            i++;\\n        }\\n        vector<int> ans(st.size());\\n        int j = st.size()-1;\\n        while(!st.empty())\\n        {\\n            ans[j] = st.top();\\n            st.pop();\\n            j--;\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "Stack"
                ],
                "code": "```\\nclass Solution {\\n    int LongestCM(int a, int b, int gcd)\\n    {\\n        int f = a / gcd;\\n        f *= b;\\n        return f;\\n    }\\npublic:\\n    vector<int> replaceNonCoprimes(vector<int>& nums) {\\n        int n = nums.size(), i = 0;\\n        stack<int> st;\\n        while(i < n)\\n        {\\n            int val = nums[i];\\n            while(!st.empty())\\n            {\\n                int gcd = __gcd(val,st.top());\\n                if(gcd == 1)\\n                    break;\\n                else\\n                {\\n                    int v = st.top();\\n                    st.pop();\\n                    val = LongestCM(v, val, gcd);\\n                }\\n            }\\n            st.push(val);\\n            i++;\\n        }\\n        vector<int> ans(st.size());\\n        int j = st.size()-1;\\n        while(!st.empty())\\n        {\\n            ans[j] = st.top();\\n            st.pop();\\n            j--;\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2133831,
                "title": "c-stack-gcd-storing-temp-results-to-improve-performance",
                "content": "Sometimes it passes all the tests, sometimes produces TLE. Not yet sure how to improve it, but can be helpful for someone.\\n\\nUPD replaced result conversion to and not it is 500ms instead of 2500\\nList<int> result = stack.ToList();\\nresult.Reverse();\\n\\n\\n\\tpublic IList<int> ReplaceNonCoprimes(int[] nums) \\n    {\\n        Stack<int> stack = new Stack<int>();\\n        Dictionary<(int,int), long> gcds = new Dictionary<(int, int), long>();\\n        for(int i = 0; i < nums.Length; ++i)\\n        {\\n            stack.Push(nums[i]);\\n        \\n            while(stack.Count > 1)\\n            {\\n                var temp1 = stack.Pop();\\n                var temp2 = stack.Pop();\\n                \\n                if(!gcds.ContainsKey((temp1, temp2)))\\n                {\\n                    gcds.Add((temp1, temp2), GCD(temp1, temp2));\\n                }\\n                var gcd = gcds[(temp1, temp2)];\\n                    \\n                if(gcd != 1)\\n                {\\n                    long num = (long)temp1*(long)temp2;\\n                    num = num/gcd;\\n                    stack.Push((int)num);\\n                }\\n                else\\n                {\\n                    stack.Push(temp2);\\n                    stack.Push(temp1);\\n                    \\n                    break;\\n                }\\n            }\\n        }\\n        \\n       List<int> result = stack.ToList();\\n       result.Reverse();\\n        \\n        return result;\\n    }\\n    \\n    public static long LCM(int a, int b)\\n    {\\n        return a*b/GCD(a, b);\\n    }\\n        \\n    \\n    public static long GCD(int a, int b)\\n    {\\n        if(a == 0 || b == 0)\\n        {\\n            return a + b;\\n        }\\n        \\n        return GCD(b%a, a);\\n    }",
                "solutionTags": [],
                "code": "Sometimes it passes all the tests, sometimes produces TLE. Not yet sure how to improve it, but can be helpful for someone.\\n\\nUPD replaced result conversion to and not it is 500ms instead of 2500\\nList<int> result = stack.ToList();\\nresult.Reverse();\\n\\n\\n\\tpublic IList<int> ReplaceNonCoprimes(int[] nums) \\n    {\\n        Stack<int> stack = new Stack<int>();\\n        Dictionary<(int,int), long> gcds = new Dictionary<(int, int), long>();\\n        for(int i = 0; i < nums.Length; ++i)\\n        {\\n            stack.Push(nums[i]);\\n        \\n            while(stack.Count > 1)\\n            {\\n                var temp1 = stack.Pop();\\n                var temp2 = stack.Pop();\\n                \\n                if(!gcds.ContainsKey((temp1, temp2)))\\n                {\\n                    gcds.Add((temp1, temp2), GCD(temp1, temp2));\\n                }\\n                var gcd = gcds[(temp1, temp2)];\\n                    \\n                if(gcd != 1)\\n                {\\n                    long num = (long)temp1*(long)temp2;\\n                    num = num/gcd;\\n                    stack.Push((int)num);\\n                }\\n                else\\n                {\\n                    stack.Push(temp2);\\n                    stack.Push(temp1);\\n                    \\n                    break;\\n                }\\n            }\\n        }\\n        \\n       List<int> result = stack.ToList();\\n       result.Reverse();\\n        \\n        return result;\\n    }\\n    \\n    public static long LCM(int a, int b)\\n    {\\n        return a*b/GCD(a, b);\\n    }\\n        \\n    \\n    public static long GCD(int a, int b)\\n    {\\n        if(a == 0 || b == 0)\\n        {\\n            return a + b;\\n        }\\n        \\n        return GCD(b%a, a);\\n    }",
                "codeTag": "Unknown"
            },
            {
                "id": 2097455,
                "title": "c-o-n-solution-using-stack-using-gcd-function",
                "content": "```\\nvector<int> replaceNonCoprimes(vector<int>& nums) {\\n        stack<long long> st;\\n        long long n=nums.size();\\n        st.push(nums[n-1]);\\n        for(int i=n-2;i>=0;i--){\\n            long long x=nums[i];\\n            while(!st.empty() && __gcd(x,st.top())>1){\\n                long long temp=st.top();\\n                st.pop();\\n                long long product=temp*x;\\n                long long res=product/__gcd(x,temp);\\n                x=res;\\n            }\\n            st.push(x);\\n        }\\n        vector<int> sol;\\n        while(!st.empty()){\\n            sol.push_back(st.top());\\n            st.pop();\\n        }\\n        return sol;\\n    }",
                "solutionTags": [
                    "C",
                    "Stack"
                ],
                "code": "```\\nvector<int> replaceNonCoprimes(vector<int>& nums) {\\n        stack<long long> st;\\n        long long n=nums.size();\\n        st.push(nums[n-1]);\\n        for(int i=n-2;i>=0;i--){\\n            long long x=nums[i];\\n            while(!st.empty() && __gcd(x,st.top())>1){\\n                long long temp=st.top();\\n                st.pop();\\n                long long product=temp*x;\\n                long long res=product/__gcd(x,temp);\\n                x=res;\\n            }\\n            st.push(x);\\n        }\\n        vector<int> sol;\\n        while(!st.empty()){\\n            sol.push_back(st.top());\\n            st.pop();\\n        }\\n        return sol;\\n    }",
                "codeTag": "Unknown"
            },
            {
                "id": 2092421,
                "title": "simplest-python-solution-easy-to-understand",
                "content": "```\\nclass Solution:\\n    def replaceNonCoprimes(self, nums: List[int]) -> List[int]:\\n        stack = []\\n        for n in nums:\\n            while stack and math.gcd(n, stack[-1]) != 1:\\n                n = math.lcm(stack.pop(), n)\\n            stack.append(n)\\n        return stack\\n```\\n",
                "solutionTags": [],
                "code": "```\\nclass Solution:\\n    def replaceNonCoprimes(self, nums: List[int]) -> List[int]:\\n        stack = []\\n        for n in nums:\\n            while stack and math.gcd(n, stack[-1]) != 1:\\n                n = math.lcm(stack.pop(), n)\\n            stack.append(n)\\n        return stack\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2079605,
                "title": "i-shouted-ba-boom-as-the-code-got-accepted",
                "content": "The idea is:\\n1. traverse the array from left to right > update it\\n2. traverse the array from right to left > update it\\n3. traverse the array from left to right > update it\\n4. traverse the array from right to left > update it\\n.\\n.\\n.\\n... keep doing this until the length of the updated array is not changing. BA-BOOM !!\\n\\n\\n> oh..also, since we are using stack, we don\\'t know that in the end the answer array is reversed or not.\\n> I mean, lets say you did the traversal 5 times, 3 left to right and 2 right to left.\\n> so, eventually, your stack would have given the answer in reversed manner.\\n> you we need to keep track of number of turns we have done the traversal, and accordingly reverse the final answer array.\\n\\n\\nhere is the code..\\n\\n```\\nclass Solution {\\n    \\n    int fgcd(int m, int n){\\n        if(m==0 || n==0) return (m+n);\\n        if(n>m) swap(m,n);\\n        return fgcd(n,m%n);\\n    }\\n    \\npublic:\\n    vector<int> replaceNonCoprimes(vector<int>& nums) {\\n        stack<int> st;\\n        vector<int> ans(nums.begin(),nums.end());\\n        \\n        int sz=-1;\\n        int turn=0;\\n        while(sz!=ans.size()){\\n            for(auto it:ans) st.push(it);\\n            ans.clear();\\n            sz=st.size();\\n            \\n            while(st.size()>1){\\n                int n1=st.top();\\n                st.pop();\\n                int n2=st.top();\\n                st.pop();\\n                int gcd=fgcd(n1,n2);\\n                if(gcd>1){\\n                    int lcm = (n1/gcd)*n2;\\n                    st.push(lcm);\\n                }else{\\n                    st.push(n2);\\n                    ans.push_back(n1);\\n                }\\n            }\\n            while(!st.empty()){\\n                ans.push_back(st.top());\\n                st.pop();\\n            }\\n            turn++;\\n        }\\n        \\n        if(turn%2) reverse(ans.begin(),ans.end());\\n        \\n        return ans;\\n    }\\n};\\n\\n```",
                "solutionTags": [
                    "C",
                    "Math",
                    "Stack"
                ],
                "code": "```\\nclass Solution {\\n    \\n    int fgcd(int m, int n){\\n        if(m==0 || n==0) return (m+n);\\n        if(n>m) swap(m,n);\\n        return fgcd(n,m%n);\\n    }\\n    \\npublic:\\n    vector<int> replaceNonCoprimes(vector<int>& nums) {\\n        stack<int> st;\\n        vector<int> ans(nums.begin(),nums.end());\\n        \\n        int sz=-1;\\n        int turn=0;\\n        while(sz!=ans.size()){\\n            for(auto it:ans) st.push(it);\\n            ans.clear();\\n            sz=st.size();\\n            \\n            while(st.size()>1){\\n                int n1=st.top();\\n                st.pop();\\n                int n2=st.top();\\n                st.pop();\\n                int gcd=fgcd(n1,n2);\\n                if(gcd>1){\\n                    int lcm = (n1/gcd)*n2;\\n                    st.push(lcm);\\n                }else{\\n                    st.push(n2);\\n                    ans.push_back(n1);\\n                }\\n            }\\n            while(!st.empty()){\\n                ans.push_back(st.top());\\n                st.pop();\\n            }\\n            turn++;\\n        }\\n        \\n        if(turn%2) reverse(ans.begin(),ans.end());\\n        \\n        return ans;\\n    }\\n};\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2060111,
                "title": "simple-stack-solution-c",
                "content": "```\\nclass Solution {\\npublic:\\n    \\n    int lcm(int x, int y){\\n        return (x/__gcd(x,y))*y;\\n    }\\n    \\n    vector<int> replaceNonCoprimes(vector<int>& nums) {\\n        \\n        stack<int> st;\\n        for(int i=0;i<nums.size();i++){\\n            \\n            if(st.empty()){\\n                st.push(nums[i]);\\n                continue;\\n            }\\n            int lcmm = nums[i];\\n            while(!st.empty()){\\n                auto curr = st.top();\\n                if(__gcd(curr,lcmm)>1){\\n                    st.pop();\\n                     lcmm= lcm(curr,lcmm);\\n                    \\n                }\\n                else{\\n                    break;\\n                }\\n            }\\n            st.push(lcmm);\\n                       \\n            \\n        }\\n        \\n        int n = st.size();\\n        vector<int> ans(n);\\n        for(int i=n-1;i>=0;i--){\\n            ans[i] = st.top();\\n            st.pop();\\n        }\\n        \\n        return ans;\\n        \\n        \\n    }\\n};\\n```",
                "solutionTags": [
                    "C",
                    "Stack"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    \\n    int lcm(int x, int y){\\n        return (x/__gcd(x,y))*y;\\n    }\\n    \\n    vector<int> replaceNonCoprimes(vector<int>& nums) {\\n        \\n        stack<int> st;\\n        for(int i=0;i<nums.size();i++){\\n            \\n            if(st.empty()){\\n                st.push(nums[i]);\\n                continue;\\n            }\\n            int lcmm = nums[i];\\n            while(!st.empty()){\\n                auto curr = st.top();\\n                if(__gcd(curr,lcmm)>1){\\n                    st.pop();\\n                     lcmm= lcm(curr,lcmm);\\n                    \\n                }\\n                else{\\n                    break;\\n                }\\n            }\\n            st.push(lcmm);\\n                       \\n            \\n        }\\n        \\n        int n = st.size();\\n        vector<int> ans(n);\\n        for(int i=n-1;i>=0;i--){\\n            ans[i] = st.top();\\n            st.pop();\\n        }\\n        \\n        return ans;\\n        \\n        \\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2041431,
                "title": "js-2-o-n-log-n-solutions-250ms-stack-10x-slower-o-1-space-no-stack",
                "content": "```\\n/**\\n * @param {number[]} nums\\n * @return {number[]}\\n */\\n// O(n log N) time; O(1) space\\nvar replaceNonCoprimes = function(nums) {\\n  let x = nums[0];\\n  let y;\\n  for( let i = 1; i < nums.length; i++ ) {\\n    y = nums[i];\\n    const d = gcd(x,y);\\n    if ( d > 1 ) {\\n      nums.splice(i-1, 2, x*y/d);\\n      const newi = Math.max(i-2,0);\\n      x = nums[newi];\\n      i = newi;\\n      continue;\\n    }\\n    x = y;\\n  }\\n  return nums;\\n};\\n\\n// this solution is like 10x faster than above\\n// O(N log N) time; O(N) space\\nreplaceNonCoprimes = function(nums) {\\n  const stack = [nums[0]];\\n  stack.top = () => stack[stack.length-1];\\n  let y;\\n  let d;\\n  for( let i = 1; i < nums.length; i++ ) {\\n    y = nums[i];\\n    while(stack.length && (d = gcd(stack.top(),y)) > 1) {\\n      const x = stack.pop();\\n      y = x*y/d; \\n    }\\n    stack.push(y);\\n  }\\n  return stack;\\n};\\n\\n// O( log N ) time; O(1) space\\nfunction gcd(x,y) {\\n  while(y > 0) {\\n    ([x, y] = [y, x % y]);\\n  }\\n  return x;\\n}\\n```",
                "solutionTags": [],
                "code": "```\\n/**\\n * @param {number[]} nums\\n * @return {number[]}\\n */\\n// O(n log N) time; O(1) space\\nvar replaceNonCoprimes = function(nums) {\\n  let x = nums[0];\\n  let y;\\n  for( let i = 1; i < nums.length; i++ ) {\\n    y = nums[i];\\n    const d = gcd(x,y);\\n    if ( d > 1 ) {\\n      nums.splice(i-1, 2, x*y/d);\\n      const newi = Math.max(i-2,0);\\n      x = nums[newi];\\n      i = newi;\\n      continue;\\n    }\\n    x = y;\\n  }\\n  return nums;\\n};\\n\\n// this solution is like 10x faster than above\\n// O(N log N) time; O(N) space\\nreplaceNonCoprimes = function(nums) {\\n  const stack = [nums[0]];\\n  stack.top = () => stack[stack.length-1];\\n  let y;\\n  let d;\\n  for( let i = 1; i < nums.length; i++ ) {\\n    y = nums[i];\\n    while(stack.length && (d = gcd(stack.top(),y)) > 1) {\\n      const x = stack.pop();\\n      y = x*y/d; \\n    }\\n    stack.push(y);\\n  }\\n  return stack;\\n};\\n\\n// O( log N ) time; O(1) space\\nfunction gcd(x,y) {\\n  while(y > 0) {\\n    ([x, y] = [y, x % y]);\\n  }\\n  return x;\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2022851,
                "title": "fully-explained-stack-linear-cpp",
                "content": "Intuition behind using stack is we always need to make sure to replace all adjacent Non-Coprimes. so let\\'s say we replace some jth and (j+1)th index element with their LCM as they were Coprime then we need to check the resultant with (j-1)th element and (j+2)th element.\\n\\nSo in order to make sure that we are checking all of these possibility we can follow the below steps:\\n1. initiate a stack with 1st element\\n2. iterate throgh the given array and check if stack is empty or not\\n3. if not then run a while loop to check that top element is coprime with current element or not\\n4. if not then update the current as lcm of current and top and pop the top element from the stack.\\n5. push the current in stack and repeate step 3 to 5.\\n\\nNow we have our resultant array in stack but in reverse order.\\n\\nTC-O(NlogMaxi), SC-O(N) where N=number of elements in arr and Maxi is the maximum element.\\nPFB the code for your refernce:\\n```\\nclass Solution {\\npublic:\\n    int gcd(int a,int b){\\n        return b==0 ? a : gcd(b,a%b);\\n    }\\n    int lcm(int a,int b,int c){\\n        return a*1LL*b/c;\\n    } \\n    vector<int> replaceNonCoprimes(vector<int>& nums) {\\n        stack<int> ans;\\n        ans.push(nums[0]);\\n        for(int i=1;i<nums.size();i++){\\n            if(gcd(ans.top(),nums[i])!=1){\\n                int curr=lcm(ans.top(),nums[i],gcd(ans.top(),nums[i]));\\n                ans.pop();\\n                while(ans.size()>0 && gcd(curr,ans.top())!=1){\\n                    curr=lcm(ans.top(),curr,gcd(ans.top(),curr));\\n                    ans.pop();\\n                }\\n                ans.push(curr);\\n            }\\n            else\\n                ans.push(nums[i]);\\n        }\\n        vector<int> vect(ans.size(),0);\\n        for(int i=ans.size()-1;i>=0;i--){\\n            vect[i]=ans.top();\\n            ans.pop();\\n        }\\n        \\n        return vect;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Stack"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int gcd(int a,int b){\\n        return b==0 ? a : gcd(b,a%b);\\n    }\\n    int lcm(int a,int b,int c){\\n        return a*1LL*b/c;\\n    } \\n    vector<int> replaceNonCoprimes(vector<int>& nums) {\\n        stack<int> ans;\\n        ans.push(nums[0]);\\n        for(int i=1;i<nums.size();i++){\\n            if(gcd(ans.top(),nums[i])!=1){\\n                int curr=lcm(ans.top(),nums[i],gcd(ans.top(),nums[i]));\\n                ans.pop();\\n                while(ans.size()>0 && gcd(curr,ans.top())!=1){\\n                    curr=lcm(ans.top(),curr,gcd(ans.top(),curr));\\n                    ans.pop();\\n                }\\n                ans.push(curr);\\n            }\\n            else\\n                ans.push(nums[i]);\\n        }\\n        vector<int> vect(ans.size(),0);\\n        for(int i=ans.size()-1;i>=0;i--){\\n            vect[i]=ans.top();\\n            ans.pop();\\n        }\\n        \\n        return vect;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2019913,
                "title": "c-short-in-place-solution",
                "content": "```\\nvector<int> replaceNonCoprimes(vector<int>& nums) {\\n    int n = 0;\\n      \\n    for (int i = 1; i < nums.size(); i++) {\\n      const int num1 = nums[n];\\n      const int num2 = nums[i];\\n      if (std::gcd(num1, num2) < 2) {\\n        nums[++n] = num2;\\n        continue;\\n      }\\n\\n      nums[n] = std::lcm(num1, num2);\\n      // move left\\n      while (n > 0) {\\n        const int num3 = nums[n];\\n        const int num4 = nums[n - 1];\\n        if (std::gcd(num3, num4) < 2) {\\n          break;\\n        }\\n        \\n        nums[--n] = std::lcm(num3, num4);\\n      }\\n    }\\n      \\n    nums.resize(n + 1);\\n    return nums;\\n  }\\n  ```",
                "solutionTags": [],
                "code": "```\\nvector<int> replaceNonCoprimes(vector<int>& nums) {\\n    int n = 0;\\n      \\n    for (int i = 1; i < nums.size(); i++) {\\n      const int num1 = nums[n];\\n      const int num2 = nums[i];\\n      if (std::gcd(num1, num2) < 2) {\\n        nums[++n] = num2;\\n        continue;\\n      }\\n\\n      nums[n] = std::lcm(num1, num2);\\n      // move left\\n      while (n > 0) {\\n        const int num3 = nums[n];\\n        const int num4 = nums[n - 1];\\n        if (std::gcd(num3, num4) < 2) {\\n          break;\\n        }\\n        \\n        nums[--n] = std::lcm(num3, num4);\\n      }\\n    }\\n      \\n    nums.resize(n + 1);\\n    return nums;\\n  }\\n  ```",
                "codeTag": "Unknown"
            },
            {
                "id": 2014543,
                "title": "ruby-stack",
                "content": "```\\ndef replace_non_coprimes(nums)\\n    res = []\\n    nums.each do |ele|\\n        loop do\\n            gcd = (res.last || 1).gcd(ele)\\n            break if gcd == 1\\n            ele *= res.pop/gcd\\n        end\\n        res<<ele\\n    end\\n    res\\nend\\n```",
                "solutionTags": [
                    "Ruby"
                ],
                "code": "```\\ndef replace_non_coprimes(nums)\\n    res = []\\n    nums.each do |ele|\\n        loop do\\n            gcd = (res.last || 1).gcd(ele)\\n            break if gcd == 1\\n            ele *= res.pop/gcd\\n        end\\n        res<<ele\\n    end\\n    res\\nend\\n```",
                "codeTag": "Python3"
            },
            {
                "id": 2014326,
                "title": "easy-o-n-using-stack-c-with-comments",
                "content": "```\\nclass Solution {\\npublic:\\n    // make a function to get LCM of two numbers\\n    // make a function to get GCD of two numbers\\n    int gcd(int x, int y){\\n        if(y ==0){\\n            return x;\\n        }\\n        return gcd(y,x%y);\\n    }\\n    int lcm(int x, int y){\\n        return (x/gcd(x,y))*y;\\n    }\\n    bool checkNonCoPrime(int x, int y){\\n        int ans = gcd(x,y);\\n        return ans>1;\\n    }\\n    \\n    vector<int> replaceNonCoprimes(vector<int>& nums) {\\n        int n = nums.size();\\n        stack<int>stk;\\n        for(int i =0 ;i<n;i++){\\n            if(stk.empty() || !checkNonCoPrime(stk.top(),nums[i])){\\n                // if numbers are co prime\\n                stk.push(nums[i]);\\n            }\\n            else{\\n                // numbers are non co prime\\n                int lcmN = lcm(stk.top(),nums[i]);\\n                stk.pop();\\n                while(!stk.empty() && checkNonCoPrime(lcmN,stk.top())){\\n                    // we have to also check if our lcmN is also  non-co prime with stk.top() \\n                    lcmN = lcm(lcmN,stk.top());\\n                    stk.pop();    \\n                }\\n                stk.push(lcmN);\\n            }\\n        }\\n        nums.clear();\\n        while(!stk.empty()){\\n            nums.push_back(stk.top());\\n            stk.pop();\\n        }\\n        reverse(nums.begin(),nums.end());\\n        return nums;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C",
                    "Stack"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    // make a function to get LCM of two numbers\\n    // make a function to get GCD of two numbers\\n    int gcd(int x, int y){\\n        if(y ==0){\\n            return x;\\n        }\\n        return gcd(y,x%y);\\n    }\\n    int lcm(int x, int y){\\n        return (x/gcd(x,y))*y;\\n    }\\n    bool checkNonCoPrime(int x, int y){\\n        int ans = gcd(x,y);\\n        return ans>1;\\n    }\\n    \\n    vector<int> replaceNonCoprimes(vector<int>& nums) {\\n        int n = nums.size();\\n        stack<int>stk;\\n        for(int i =0 ;i<n;i++){\\n            if(stk.empty() || !checkNonCoPrime(stk.top(),nums[i])){\\n                // if numbers are co prime\\n                stk.push(nums[i]);\\n            }\\n            else{\\n                // numbers are non co prime\\n                int lcmN = lcm(stk.top(),nums[i]);\\n                stk.pop();\\n                while(!stk.empty() && checkNonCoPrime(lcmN,stk.top())){\\n                    // we have to also check if our lcmN is also  non-co prime with stk.top() \\n                    lcmN = lcm(lcmN,stk.top());\\n                    stk.pop();    \\n                }\\n                stk.push(lcmN);\\n            }\\n        }\\n        nums.clear();\\n        while(!stk.empty()){\\n            nums.push_back(stk.top());\\n            stk.pop();\\n        }\\n        reverse(nums.begin(),nums.end());\\n        return nums;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2014228,
                "title": "c-stack-easy-implementation",
                "content": "```\\nclass Solution {\\npublic:\\n    vector<int> replaceNonCoprimes(vector<int>& nums) {\\n        stack<int> st;\\n        \\n        for(int i=0; i<nums.size(); i++)\\n        {   \\n            st.push(nums[i]);\\n            while(st.size() > 1)        //If stack contain at least 2 elements then\\n            {   \\n                int a = st.top();\\n                st.pop();\\n                int b = st.top();\\n                st.pop();\\n                int gcd = __gcd(a, b);\\n                \\n                if(gcd > 1)\\n                {\\n                    int lcm = 1ll*a*b/gcd;      // A*B = LCM(A, B)*GCD(A, B)\\n                    st.push(lcm);\\n                }\\n                else{                           //Ig gcd comes out to be 1 then push back both A and B and break\\n                    st.push(b);\\n                    st.push(a);\\n                    break;\\n                }\\n            }\\n            \\n        }\\n        \\n        vector<int> ans;\\n        while(!st.empty())\\n        {\\n            ans.push_back(st.top());\\n            st.pop();\\n        }\\n        reverse(ans.begin(), ans.end());\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "C",
                    "Stack"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<int> replaceNonCoprimes(vector<int>& nums) {\\n        stack<int> st;\\n        \\n        for(int i=0; i<nums.size(); i++)\\n        {   \\n            st.push(nums[i]);\\n            while(st.size() > 1)        //If stack contain at least 2 elements then\\n            {   \\n                int a = st.top();\\n                st.pop();\\n                int b = st.top();\\n                st.pop();\\n                int gcd = __gcd(a, b);\\n                \\n                if(gcd > 1)\\n                {\\n                    int lcm = 1ll*a*b/gcd;      // A*B = LCM(A, B)*GCD(A, B)\\n                    st.push(lcm);\\n                }\\n                else{                           //Ig gcd comes out to be 1 then push back both A and B and break\\n                    st.push(b);\\n                    st.push(a);\\n                    break;\\n                }\\n            }\\n            \\n        }\\n        \\n        vector<int> ans;\\n        while(!st.empty())\\n        {\\n            ans.push_back(st.top());\\n            st.pop();\\n        }\\n        reverse(ans.begin(), ans.end());\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2014009,
                "title": "java-o-n-solution-using-stack",
                "content": "```\\nclass Solution {\\n    public int gcd(int a, int b) {\\n        while(b % a != 0) {\\n            int val = a;\\n            a = b % a;\\n            b = val;\\n        }\\n        return a;\\n    }\\n    public List<Integer> replaceNonCoprimes(int[] nums) {\\n        Stack<Integer> st = new Stack<>();\\n        for(int i = 0; i < nums.length; i++) {\\n            \\n            while(st.size() > 0 && gcd(st.peek(), nums[i]) > 1) {\\n                int val = st.pop();\\n                nums[i] = (val / gcd(val, nums[i])) * nums[i];\\n            } \\n            st.push(nums[i]);\\n            \\n        }\\n        List<Integer> ans = new ArrayList<>();\\n        while(st.size() > 0) {\\n            ans.add(st.pop());\\n        }\\n        Collections.reverse(ans);\\n        return ans;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Stack"
                ],
                "code": "```\\nclass Solution {\\n    public int gcd(int a, int b) {\\n        while(b % a != 0) {\\n            int val = a;\\n            a = b % a;\\n            b = val;\\n        }\\n        return a;\\n    }\\n    public List<Integer> replaceNonCoprimes(int[] nums) {\\n        Stack<Integer> st = new Stack<>();\\n        for(int i = 0; i < nums.length; i++) {\\n            \\n            while(st.size() > 0 && gcd(st.peek(), nums[i]) > 1) {\\n                int val = st.pop();\\n                nums[i] = (val / gcd(val, nums[i])) * nums[i];\\n            } \\n            st.push(nums[i]);\\n            \\n        }\\n        List<Integer> ans = new ArrayList<>();\\n        while(st.size() > 0) {\\n            ans.add(st.pop());\\n        }\\n        Collections.reverse(ans);\\n        return ans;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2013948,
                "title": "python-stack-clean-and-simple",
                "content": "**Solution**:\\n```\\nclass Solution:\\n    def replaceNonCoprimes(self, nums):\\n        stack = []\\n        for num in nums:\\n            while stack and gcd(num,stack[-1]) >= 2:\\n                num = lcm(num,stack[-1])\\n                stack.pop()\\n            stack.append(num)\\n        return stack\\n```",
                "solutionTags": [
                    "Python",
                    "Python3",
                    "Stack"
                ],
                "code": "```\\nclass Solution:\\n    def replaceNonCoprimes(self, nums):\\n        stack = []\\n        for num in nums:\\n            while stack and gcd(num,stack[-1]) >= 2:\\n                num = lcm(num,stack[-1])\\n                stack.pop()\\n            stack.append(num)\\n        return stack\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2013924,
                "title": "c-using-gcd",
                "content": "\\tpublic class Solution {\\n\\t\\tpublic IList<int> ReplaceNonCoprimes(int[] nums) {\\n\\t\\t\\tList<int> result = new List<int>();\\n\\t\\t\\tfor(int i=0;i<nums.Length;i++){\\n\\t\\t\\t\\twhile(true){\\n\\t\\t\\t\\t\\tint lastElem = 0;\\n\\t\\t\\t\\t\\tif(result.Count == 0){\\n\\t\\t\\t\\t\\t\\tlastElem = 1;\\n\\t\\t\\t\\t\\t}\\n\\t\\t\\t\\t\\telse{\\n\\t\\t\\t\\t\\t\\tlastElem = result.Last();\\n\\t\\t\\t\\t\\t}\\n\\n\\t\\t\\t\\t\\tint gcd = GCD(lastElem, nums[i]);\\n\\t\\t\\t\\t\\tif(gcd == 1) break;\\n\\t\\t\\t\\t\\tresult.RemoveAt(result.Count-1);\\n\\t\\t\\t\\t\\tnums[i] = nums[i]*(lastElem/gcd);\\n\\t\\t\\t\\t}\\n\\t\\t\\t\\tresult.Add(nums[i]);\\n\\t\\t\\t}\\n\\n\\t\\t\\treturn result;\\n\\t\\t}\\n\\n\\t\\tpublic int GCD(int num1, int num2){\\n\\t\\t\\treturn (num2>0)? GCD(num2,num1%num2) : num1;\\n\\t\\t}\\n\\t}",
                "solutionTags": [],
                "code": "class Solution {\\n\\t\\tpublic IList<int> ReplaceNonCoprimes(int[] nums) {\\n\\t\\t\\tList<int> result = new List<int>();\\n\\t\\t\\tfor(int i=0;i<nums.Length;i++){\\n\\t\\t\\t\\twhile(true){\\n\\t\\t\\t\\t\\tint lastElem = 0;\\n\\t\\t\\t\\t\\tif(result.Count == 0){\\n\\t\\t\\t\\t\\t\\tlastElem = 1;\\n\\t\\t\\t\\t\\t}",
                "codeTag": "Java"
            },
            {
                "id": 2012870,
                "title": "python-go-disgustingly-fast-with-caching",
                "content": "There\\'s not much I can add to the solution that hasn\\'t been said, but what I did do is make it go much faster by adding a cache to the GCD, and using an LCM that depends on that cached GCD.\\n\\nIn the Python `math` module, there\\'s a very fast C implementation of Lehmer\\'s algorithm for the GCD. New in 3.9, there\\'s also an LCM function implemented the same way we have here (two numbers multiplied, divided by their GCD), but, *critically*, the very fast GCD implementation doesn\\'t have caching in any way built in (duh). So we are calculating the GCD once to check if the numbers are coprime and *again* to calculate their LCM if they are (inside of the `math.LCM` function.\\n\\nWe can go faster by caching the C implementation of GCM, and writing our own LCM function that uses this cached implementation. The rest of the solution is almost exactly as @tojuna, with the exception of a trick of adding 1 as the initial item in the stack to avoid having to check the length of the stack every loop. Since 1 is coprime with every number, it will be left alone, and we can just chop it off at the end.\\n\\nHope you found the optimization fun!\\n\\n```python\\nfrom functools import cache\\nimport math\\n\\n# LRU cache math.gcd\\ngcd = cache(math.gcd)\\n\\ndef lcm(a: int, b: int) -> int:\\n    \"\"\"\\n    LCM is the product divided by the GCD\\n\\tUses our cached GCD\\n    \"\"\"\\n    return int((a * b) / gcd(a, b))\\n\\nclass Solution:\\n    def replaceNonCoprimes(self, nums: List[int]) -> List[int]:\\n        stack = [1] # Initial item, works since 1 is coprime with every number\\n        for i in nums:\\n            stack.append(i)\\n            while gcd(stack[-1], stack[-2]) > 1:\\n                stack.append(lcm(stack.pop(), stack.pop()))\\n        # Trim initial item\\n        return stack[1:]\\n```",
                "solutionTags": [],
                "code": "```python\\nfrom functools import cache\\nimport math\\n\\n# LRU cache math.gcd\\ngcd = cache(math.gcd)\\n\\ndef lcm(a: int, b: int) -> int:\\n    \"\"\"\\n    LCM is the product divided by the GCD\\n\\tUses our cached GCD\\n    \"\"\"\\n    return int((a * b) / gcd(a, b))\\n\\nclass Solution:\\n    def replaceNonCoprimes(self, nums: List[int]) -> List[int]:\\n        stack = [1] # Initial item, works since 1 is coprime with every number\\n        for i in nums:\\n            stack.append(i)\\n            while gcd(stack[-1], stack[-2]) > 1:\\n                stack.append(lcm(stack.pop(), stack.pop()))\\n        # Trim initial item\\n        return stack[1:]\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2012567,
                "title": "python-100-faster-and-easy-to-understand",
                "content": "\\t\"\"\"\\n\\tclass Solution(object):\\n    def replaceNonCoprimes(self, nums):\\n        def gcd(a,b):\\n            if b==0:\\n                return a\\n            return gcd(b,a%b)\\n        stack=[nums[0]]\\n        for i in nums[1:]:\\n            y=i\\n            while len(stack)>0 and gcd(y,stack[-1])>1:\\n                x=stack.pop()\\n                y=(x*y)//gcd(x,y)\\n            stack.append(y)\\n            # print(stack)\\n        return stack\\n                \\n        \"\"\"\\n        :type nums: List[int]\\n        :rtype: List[int]\\n        \"\"\"\\n        \\n\\t\"\"\"",
                "solutionTags": [
                    "Python",
                    "Python3",
                    "Math",
                    "Stack"
                ],
                "code": "\\t\"\"\"\\n\\tclass Solution(object):\\n    def replaceNonCoprimes(self, nums):\\n        def gcd(a,b):\\n            if b==0:\\n                return a\\n            return gcd(b,a%b)\\n        stack=[nums[0]]\\n        for i in nums[1:]:\\n            y=i\\n            while len(stack)>0 and gcd(y,stack[-1])>1:\\n                x=stack.pop()\\n                y=(x*y)//gcd(x,y)\\n            stack.append(y)\\n            # print(stack)\\n        return stack\\n                \\n        \"\"\"\\n        :type nums: List[int]\\n        :rtype: List[int]\\n        \"\"\"\\n        \\n\\t\"\"\"",
                "codeTag": "Java"
            },
            {
                "id": 2012348,
                "title": "easy-java-solution-using-stack",
                "content": "```\\nclass Solution {\\n    public List<Integer> replaceNonCoprimes(int[] nums) {\\n        int n = nums.length, i; Stack<Long>stk = new Stack<Long>();\\n        \\n        for(i = 0; i<n; i++)\\n        {\\n            long x = nums[i];\\n            \\n            while(!stk.isEmpty()){\\n                long gcd = calcGcd(stk.peek(), x);\\n                if(gcd==1) break;\\n                else{\\n                    long y = stk.peek(); stk.pop();\\n                    x = calcLcm(x, y);\\n                }\\n            }\\n            stk.add(x);\\n        }\\n        \\n        List<Integer>lst = new ArrayList<Integer>();\\n        \\n        while(!stk.isEmpty())\\n        {\\n            long x = stk.peek(); stk.pop();\\n            lst.add((int)x);\\n        }\\n        \\n        Collections.reverse(lst); return lst;\\n    }\\n    \\n    public long calcGcd(long a, long b)\\n    {\\n        if(a==0) return b;\\n        return calcGcd(b%a, a);\\n    }\\n    public long calcLcm(long a, long b)\\n    {\\n        long gcd = calcGcd(a, b);\\n        return (a*b)/gcd;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Stack"
                ],
                "code": "```\\nclass Solution {\\n    public List<Integer> replaceNonCoprimes(int[] nums) {\\n        int n = nums.length, i; Stack<Long>stk = new Stack<Long>();\\n        \\n        for(i = 0; i<n; i++)\\n        {\\n            long x = nums[i];\\n            \\n            while(!stk.isEmpty()){\\n                long gcd = calcGcd(stk.peek(), x);\\n                if(gcd==1) break;\\n                else{\\n                    long y = stk.peek(); stk.pop();\\n                    x = calcLcm(x, y);\\n                }\\n            }\\n            stk.add(x);\\n        }\\n        \\n        List<Integer>lst = new ArrayList<Integer>();\\n        \\n        while(!stk.isEmpty())\\n        {\\n            long x = stk.peek(); stk.pop();\\n            lst.add((int)x);\\n        }\\n        \\n        Collections.reverse(lst); return lst;\\n    }\\n    \\n    public long calcGcd(long a, long b)\\n    {\\n        if(a==0) return b;\\n        return calcGcd(b%a, a);\\n    }\\n    public long calcLcm(long a, long b)\\n    {\\n        long gcd = calcGcd(a, b);\\n        return (a*b)/gcd;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1967084,
                "title": "golang-stack",
                "content": "```\\nfunc replaceNonCoprimes(nums []int) []int {\\n    stack :=[]int{}\\n    count:=0\\n    for _,num := range nums{\\n        stack=append(stack,num)\\n        count++\\n        for count>1 && GCD(stack[count-2],stack[count-1])!=1{\\n            stack= append(stack[:count-2],LCM(stack[count-2],stack[count-1]))\\n            count--\\n        }\\n    }\\n    return stack\\n}\\n\\nfunc LCM(i,j int) int {\\n    return i*j/(GCD(i,j))\\n}\\n\\nfunc GCD(i,j int) int{\\n    if i<j{\\n        i,j=j,i\\n    }\\n    \\n    for i%j!=0{\\n        i,j = j,i%j\\n    }\\n    return j\\n}\\n```",
                "solutionTags": [
                    "Go"
                ],
                "code": "```\\nfunc replaceNonCoprimes(nums []int) []int {\\n    stack :=[]int{}\\n    count:=0\\n    for _,num := range nums{\\n        stack=append(stack,num)\\n        count++\\n        for count>1 && GCD(stack[count-2],stack[count-1])!=1{\\n            stack= append(stack[:count-2],LCM(stack[count-2],stack[count-1]))\\n            count--\\n        }\\n    }\\n    return stack\\n}\\n\\nfunc LCM(i,j int) int {\\n    return i*j/(GCD(i,j))\\n}\\n\\nfunc GCD(i,j int) int{\\n    if i<j{\\n        i,j=j,i\\n    }\\n    \\n    for i%j!=0{\\n        i,j = j,i%j\\n    }\\n    return j\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1930879,
                "title": "python-soln",
                "content": "```\\n\\n\\nclass Solution:\\n    def replaceNonCoprimes(self, nums: List[int]) -> List[int]:\\n        def findgcd(a,b):\\n            if b==0:\\n                return a\\n            return findgcd(b,a%b)\\n        res=[]\\n        res.append(nums[0])\\n        \\n        for i in range(1,len(nums)):\\n            a=nums[i]\\n            while(len(res)>0):\\n                z=findgcd(res[-1],a)\\n                if z>1:\\n                    x=res.pop()\\n                    a=(a*x)//z\\n                else:\\n                    break\\n            res.append(a)\\n        return res\\n```",
                "solutionTags": [
                    "Python",
                    "Array",
                    "Stack"
                ],
                "code": "```\\n\\n\\nclass Solution:\\n    def replaceNonCoprimes(self, nums: List[int]) -> List[int]:\\n        def findgcd(a,b):\\n            if b==0:\\n                return a\\n            return findgcd(b,a%b)\\n        res=[]\\n        res.append(nums[0])\\n        \\n        for i in range(1,len(nums)):\\n            a=nums[i]\\n            while(len(res)>0):\\n                z=findgcd(res[-1],a)\\n                if z>1:\\n                    x=res.pop()\\n                    a=(a*x)//z\\n                else:\\n                    break\\n            res.append(a)\\n        return res\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1913068,
                "title": "python-stack",
                "content": "```\\nclass Solution:\\n    def replaceNonCoprimes(self, nums: List[int]) -> List[int]:\\n        stack=[]\\n        def gcd(a,b):\\n            while(b>0):\\n                a,b=b,a%b\\n            return a\\n        for item in nums:\\n            while len(stack)>0 and (gcd(stack[-1],item)>1):\\n                a=stack.pop()\\n                item=a*item//gcd(a,item)\\n            stack.append(item)\\n        return stack",
                "solutionTags": [
                    "Python",
                    "Stack"
                ],
                "code": "```\\nclass Solution:\\n    def replaceNonCoprimes(self, nums: List[int]) -> List[int]:\\n        stack=[]\\n        def gcd(a,b):\\n            while(b>0):\\n                a,b=b,a%b\\n            return a\\n        for item in nums:\\n            while len(stack)>0 and (gcd(stack[-1],item)>1):\\n                a=stack.pop()\\n                item=a*item//gcd(a,item)\\n            stack.append(item)\\n        return stack",
                "codeTag": "Java"
            },
            {
                "id": 1848970,
                "title": "my-java-solution-o-length-log-min-n1-n2",
                "content": "```\\nclass Solution {\\n    public List<Integer> replaceNonCoprimes(int[] nums) {\\n        // lcm = (a * b) / gcd\\n        LinkedList<Integer> result = new LinkedList<>();\\n        if (nums == null || nums.length == 0) {\\n            return result;\\n        }\\n        if (nums.length == 1) {\\n            result.add(nums[0]);\\n            return result;\\n        }\\n        for (int number : nums) {\\n            while (true) {\\n                int lastElement = result.isEmpty() ? 1 : result.getLast(); // triggers mainly on the very first element\\n                int gcd = findGCD(lastElement, number);\\n                if (gcd == 1 ) {\\n                    break; // we should not want this\\n                }\\n                number = number * (result.removeLast() / gcd); // done division first to avoid overflow\\n            }\\n            result.add(number);\\n        }\\n        return result;\\n    }\\n    \\n    public int findGCD(int a, int b) {\\n        if (b == 0) {\\n            return a;\\n        }\\n        return findGCD(b, a % b);\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Math"
                ],
                "code": "```\\nclass Solution {\\n    public List<Integer> replaceNonCoprimes(int[] nums) {\\n        // lcm = (a * b) / gcd\\n        LinkedList<Integer> result = new LinkedList<>();\\n        if (nums == null || nums.length == 0) {\\n            return result;\\n        }\\n        if (nums.length == 1) {\\n            result.add(nums[0]);\\n            return result;\\n        }\\n        for (int number : nums) {\\n            while (true) {\\n                int lastElement = result.isEmpty() ? 1 : result.getLast(); // triggers mainly on the very first element\\n                int gcd = findGCD(lastElement, number);\\n                if (gcd == 1 ) {\\n                    break; // we should not want this\\n                }\\n                number = number * (result.removeLast() / gcd); // done division first to avoid overflow\\n            }\\n            result.add(number);\\n        }\\n        return result;\\n    }\\n    \\n    public int findGCD(int a, int b) {\\n        if (b == 0) {\\n            return a;\\n        }\\n        return findGCD(b, a % b);\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1844737,
                "title": "java-solution-with-a-stack-one-pass",
                "content": "```\\nclass Solution {\\n    public List<Integer> replaceNonCoprimes(int[] nums) {\\n        Stack<Integer> st = new Stack<>();\\n        st.push(nums[0]);\\n\\n        for (int i = 1; i < nums.length; i++) {\\n            int num = nums[i];\\n            while (!st.isEmpty() && GCD(st.peek(), num) != 1) {\\n                int cur = st.pop();\\n                int lcm = LCM(num, cur);\\n                num = lcm;\\n            }\\n            st.push(num);\\n        }\\n        List<Integer> ans = new ArrayList<>(st);\\n        return ans;\\n    }\\n\\n    private int GCD(int a, int b) {\\n        return a % b == 0 ? b : GCD(b, a % b) ;\\n    }\\n\\n    private int LCM(int a, int b) {\\n        int gcd = GCD(a, b);\\n        int lcm = a / gcd * b;\\n        return lcm;\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    public List<Integer> replaceNonCoprimes(int[] nums) {\\n        Stack<Integer> st = new Stack<>();\\n        st.push(nums[0]);\\n\\n        for (int i = 1; i < nums.length; i++) {\\n            int num = nums[i];\\n            while (!st.isEmpty() && GCD(st.peek(), num) != 1) {\\n                int cur = st.pop();\\n                int lcm = LCM(num, cur);\\n                num = lcm;\\n            }\\n            st.push(num);\\n        }\\n        List<Integer> ans = new ArrayList<>(st);\\n        return ans;\\n    }\\n\\n    private int GCD(int a, int b) {\\n        return a % b == 0 ? b : GCD(b, a % b) ;\\n    }\\n\\n    private int LCM(int a, int b) {\\n        int gcd = GCD(a, b);\\n        int lcm = a / gcd * b;\\n        return lcm;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1843597,
                "title": "kotlin-stack-math",
                "content": "```\\nclass Solution {\\n\\n    fun replaceNonCoprimes(nums: IntArray): List<Int> {\\n        val stack = Stack<Int>()\\n        if(nums.size <= 1) return nums.toList()\\n        stack.add(nums[0])        \\n        for(i in 1 until nums.size) {\\n            var lcm = nums[i]\\n            while(stack.isNotEmpty() && getGCD(lcm,stack.peek()) > 1) {\\n                lcm = getLCM(lcm, stack.pop())\\n            }\\n            stack.add(lcm)\\n        }\\n        \\n        return stack.toList()\\n    }\\n\\n    private fun getLCM(a: Int, b: Int): Int {\\n        return (a / getGCD(a, b)) * b\\n    }\\n\\n    private fun getGCD(a:Int, b:Int): Int {\\n        if (a == 0)\\n            return b\\n        return getGCD(b % a, a)\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n\\n    fun replaceNonCoprimes(nums: IntArray): List<Int> {\\n        val stack = Stack<Int>()\\n        if(nums.size <= 1) return nums.toList()\\n        stack.add(nums[0])        \\n        for(i in 1 until nums.size) {\\n            var lcm = nums[i]\\n            while(stack.isNotEmpty() && getGCD(lcm,stack.peek()) > 1) {\\n                lcm = getLCM(lcm, stack.pop())\\n            }\\n            stack.add(lcm)\\n        }\\n        \\n        return stack.toList()\\n    }\\n\\n    private fun getLCM(a: Int, b: Int): Int {\\n        return (a / getGCD(a, b)) * b\\n    }\\n\\n    private fun getGCD(a:Int, b:Int): Int {\\n        if (a == 0)\\n            return b\\n        return getGCD(b % a, a)\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1843542,
                "title": "rust-stack-gcd-and-lcm-o-n",
                "content": "```\\nfn gcd(a: i32, b: i32) -> i32\\n{\\n    if a < b {\\n        let (a, b) = (b, a);\\n    }\\n    match b {\\n        0 => a,\\n        _ => gcd(b, a % b),\\n    }\\n}\\n\\nfn lcm(a: i32, b: i32, d: i32) -> i32 {\\n    // let ans = (a as i64 * b as i64) / (d as i64);\\n    let a = a as i64;\\n    let b = b as i64;\\n    let d = d as i64;\\n    let ans = (a * b) / d;\\n    ans as i32\\n}\\n\\nimpl Solution {\\n    pub fn replace_non_coprimes(nums: Vec<i32>) -> Vec<i32> {\\n        let mut res = vec![];\\n        for v in nums.iter() {\\n            let n = res.len();\\n            if n == 0 {\\n                res.push(*v);\\n                continue;\\n            }\\n            let mut m = *v;\\n            loop {\\n                let n = res.len();\\n                if n <= 0 { break }\\n                \\n                let tail = res.pop().unwrap();\\n                let d = gcd(m, tail);\\n                if d == 1 {\\n                    res.push(tail);\\n                    break;\\n                }\\n                m = lcm(m, tail, d);\\n                // println!(\"v {} tail {}, gcd {}, lcm {}\", v, tail, d, m);\\n            }\\n            res.push(m);\\n            // println!(\"res {:?}\", res);\\n        }\\n        res\\n    }\\n}\\n```",
                "solutionTags": [
                    "Rust"
                ],
                "code": "```\\nfn gcd(a: i32, b: i32) -> i32\\n{\\n    if a < b {\\n        let (a, b) = (b, a);\\n    }\\n    match b {\\n        0 => a,\\n        _ => gcd(b, a % b),\\n    }\\n}\\n\\nfn lcm(a: i32, b: i32, d: i32) -> i32 {\\n    // let ans = (a as i64 * b as i64) / (d as i64);\\n    let a = a as i64;\\n    let b = b as i64;\\n    let d = d as i64;\\n    let ans = (a * b) / d;\\n    ans as i32\\n}\\n\\nimpl Solution {\\n    pub fn replace_non_coprimes(nums: Vec<i32>) -> Vec<i32> {\\n        let mut res = vec![];\\n        for v in nums.iter() {\\n            let n = res.len();\\n            if n == 0 {\\n                res.push(*v);\\n                continue;\\n            }\\n            let mut m = *v;\\n            loop {\\n                let n = res.len();\\n                if n <= 0 { break }\\n                \\n                let tail = res.pop().unwrap();\\n                let d = gcd(m, tail);\\n                if d == 1 {\\n                    res.push(tail);\\n                    break;\\n                }\\n                m = lcm(m, tail, d);\\n                // println!(\"v {} tail {}, gcd {}, lcm {}\", v, tail, d, m);\\n            }\\n            res.push(m);\\n            // println!(\"res {:?}\", res);\\n        }\\n        res\\n    }\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1842583,
                "title": "typescript-solution",
                "content": "```typescript\\nfunction replaceNonCoprimes(nums: number[]): number[] {\\n    function findGCD(a: number, b: number): number {\\n        const r = Math.min(Math.abs(b - a * Math.floor(b / a)), Math.abs(b - a * Math.ceil(b / a)));\\n        if (r === 0) return a;\\n        return findGCD(r, a);\\n    }\\n\\n    const result: number[] = [];\\n\\n    function process(num: number) {\\n        const top = result.pop();\\n        if (top === undefined) {\\n            result.push(num);\\n        } else {\\n            const GCD = findGCD(top, num);\\n            if (GCD !== 1) {\\n                const LCM = (top * num) / GCD;\\n                process(LCM);\\n            } else {\\n                result.push(top, num);\\n            }\\n        }\\n    }\\n\\n    for (let i = 0; i < nums.length; i++) {\\n        process(nums[i]);\\n    }\\n    return result;\\n}\\n```",
                "solutionTags": [
                    "TypeScript"
                ],
                "code": "```typescript\\nfunction replaceNonCoprimes(nums: number[]): number[] {\\n    function findGCD(a: number, b: number): number {\\n        const r = Math.min(Math.abs(b - a * Math.floor(b / a)), Math.abs(b - a * Math.ceil(b / a)));\\n        if (r === 0) return a;\\n        return findGCD(r, a);\\n    }\\n\\n    const result: number[] = [];\\n\\n    function process(num: number) {\\n        const top = result.pop();\\n        if (top === undefined) {\\n            result.push(num);\\n        } else {\\n            const GCD = findGCD(top, num);\\n            if (GCD !== 1) {\\n                const LCM = (top * num) / GCD;\\n                process(LCM);\\n            } else {\\n                result.push(top, num);\\n            }\\n        }\\n    }\\n\\n    for (let i = 0; i < nums.length; i++) {\\n        process(nums[i]);\\n    }\\n    return result;\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1841868,
                "title": "p5-js-interative-visualization-for-a-solution-that-resembles-zuma",
                "content": "Very intuitive!\\n\\nIt much resembles playing Zuma\\n\\nInteractive version is on the [p5.js playground](https://editor.p5js.org/nitroglycerine/full/eDfHUufPE) \\n\\n![image](https://assets.leetcode.com/users/images/cc1a4efc-2901-4fa3-a633-1875bf7c1586_1647072579.2999318.gif)\\n\\n",
                "solutionTags": [],
                "code": "Very intuitive!\\n\\nIt much resembles playing Zuma\\n\\nInteractive version is on the [p5.js playground](https://editor.p5js.org/nitroglycerine/full/eDfHUufPE) \\n\\n![image](https://assets.leetcode.com/users/images/cc1a4efc-2901-4fa3-a633-1875bf7c1586_1647072579.2999318.gif)\\n\\n",
                "codeTag": "Unknown"
            },
            {
                "id": 1841386,
                "title": "simple-c-solution",
                "content": "~~~\\nvector<int> replaceNonCoprimes(vector<int>& nums) {\\n        vector<int>v;\\n        v.push_back(nums[0]);\\n        \\n        for(int i=1;i<nums.size();i++)\\n        {\\n            int y=nums[i];\\n            while(v.size()>0 and __gcd(v.back(),y)>1)\\n            {\\n                int x=v.back();\\n                v.pop_back();\\n                y=(x/__gcd(x,y))*y;\\n            }\\n            v.push_back(y);\\n        }\\n        return v;\\n    }\\n\\t~~~\\n",
                "solutionTags": [],
                "code": "~~~\\nvector<int> replaceNonCoprimes(vector<int>& nums) {\\n        vector<int>v;\\n        v.push_back(nums[0]);\\n        \\n        for(int i=1;i<nums.size();i++)\\n        {\\n            int y=nums[i];\\n            while(v.size()>0 and __gcd(v.back(),y)>1)\\n            {\\n                int x=v.back();\\n                v.pop_back();\\n                y=(x/__gcd(x,y))*y;\\n            }\\n            v.push_back(y);\\n        }\\n        return v;\\n    }\\n\\t~~~\\n",
                "codeTag": "Unknown"
            },
            {
                "id": 1839455,
                "title": "c-solution-2197",
                "content": "A straight forward implementation of the given problem statement\\nMerge two adjacent numbers untill they are not co prime (GCD > 1). For this we can use stack as it gives us the adjacent number at the top of it and we can merge and pop untill the condition satisfies\\nHere we used vector as a stack for better time complexity\\n\\n```\\nclass Solution {\\npublic:\\n    vector<int> replaceNonCoprimes(vector<int>& nums) {\\n        vector<int>res;\\n        res.push_back(nums[0]);\\n        int n = nums.size(),GCD,LCM,val;\\n        long long product;\\n        for(int i=1;i<n;i++){\\n            val = nums[i];\\n            GCD = __gcd(res.back(),val);\\n            while(GCD > 1){\\n                product = (long long)(res.back()) * (long long)(val);\\n                LCM = product/GCD;\\n                res.pop_back();\\n                val = LCM;\\n\\t\\t\\t\\tGCD = res.empty() ? 1 : __gcd(res.back(),val);\\n            }\\n            res.push_back(val);\\n        }\\n        return res;\\n    }\\n};\\n```\\n\\nFeel free to comment your queries if any\\n**Upvote** if found useful\\n**Thank You :)**",
                "solutionTags": [
                    "C",
                    "Stack"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<int> replaceNonCoprimes(vector<int>& nums) {\\n        vector<int>res;\\n        res.push_back(nums[0]);\\n        int n = nums.size(),GCD,LCM,val;\\n        long long product;\\n        for(int i=1;i<n;i++){\\n            val = nums[i];\\n            GCD = __gcd(res.back(),val);\\n            while(GCD > 1){\\n                product = (long long)(res.back()) * (long long)(val);\\n                LCM = product/GCD;\\n                res.pop_back();\\n                val = LCM;\\n\\t\\t\\t\\tGCD = res.empty() ? 1 : __gcd(res.back(),val);\\n            }\\n            res.push_back(val);\\n        }\\n        return res;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1837561,
                "title": "c-o-n-log-m-solution-using-stack",
                "content": "```\\nclass Solution {\\npublic:\\n    vector<int> replaceNonCoprimes(vector<int>& nums) {\\n        deque<int> val;\\n        for(int i=0; i<nums.size(); i++){\\n            val.push_back(nums[i]);\\n            \\n            while(val.size()>1){\\n                int gcd = GCD(val[val.size()-1], val[val.size()-2]);\\n                if(gcd==1){\\n                    break;\\n                }else{\\n                    int newVal = (val[val.size()-1]/gcd)* val[val.size()-2];\\n                    val.pop_back();\\n                    val[val.size()-1] = newVal;\\n                }\\n            }\\n        }\\n        return vector<int>(val.begin(), val.end());\\n        \\n    }\\n    \\n    int GCD(int a, int b){\\n        if(a<b){\\n            swap(a,b);\\n        }\\n        if(a%b==0){\\n            return b;\\n        }\\n        return GCD(b, a%b);\\n    }\\n};\\n\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<int> replaceNonCoprimes(vector<int>& nums) {\\n        deque<int> val;\\n        for(int i=0; i<nums.size(); i++){\\n            val.push_back(nums[i]);\\n            \\n            while(val.size()>1){\\n                int gcd = GCD(val[val.size()-1], val[val.size()-2]);\\n                if(gcd==1){\\n                    break;\\n                }else{\\n                    int newVal = (val[val.size()-1]/gcd)* val[val.size()-2];\\n                    val.pop_back();\\n                    val[val.size()-1] = newVal;\\n                }\\n            }\\n        }\\n        return vector<int>(val.begin(), val.end());\\n        \\n    }\\n    \\n    int GCD(int a, int b){\\n        if(a<b){\\n            swap(a,b);\\n        }\\n        if(a%b==0){\\n            return b;\\n        }\\n        return GCD(b, a%b);\\n    }\\n};\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1835973,
                "title": "java-clean-simple-linkedlist",
                "content": "```\\n\\n\\nclass Solution {\\n    public List<Integer> replaceNonCoprimes(int[] nums) {\\n        // 2 numbers are coprime if their greatest common divisor is 1\\n        // LCM is x*y/gcd\\n        LinkedList<Integer> res = new LinkedList();        \\n\\n        for(int i = 0; i < nums.length; i++) {\\n            long cur = nums[i];\\n            \\n            // continuously comparing to the end of the constructed list, remove and re-add if needed\\n            while(!res.isEmpty()) {\\n                long last = res.getLast();\\n                long gcd = gcd(last, cur);\\n                if(gcd > 1) {\\n                    res.removeLast();\\n                    cur = cur*last/gcd;\\n                } else {\\n                    break;   \\n                }\\n            }\\n            \\n            res.add((int)cur);\\n        }\\n        \\n        return res;\\n    }\\n    \\n    // Euclidean algorithm\\n    private long gcd(long x, long y) {\\n        if(y == 0) {\\n            return x;\\n        }\\n        return gcd(y, x%y);\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\n\\n\\nclass Solution {\\n    public List<Integer> replaceNonCoprimes(int[] nums) {\\n        // 2 numbers are coprime if their greatest common divisor is 1\\n        // LCM is x*y/gcd\\n        LinkedList<Integer> res = new LinkedList();        \\n\\n        for(int i = 0; i < nums.length; i++) {\\n            long cur = nums[i];\\n            \\n            // continuously comparing to the end of the constructed list, remove and re-add if needed\\n            while(!res.isEmpty()) {\\n                long last = res.getLast();\\n                long gcd = gcd(last, cur);\\n                if(gcd > 1) {\\n                    res.removeLast();\\n                    cur = cur*last/gcd;\\n                } else {\\n                    break;   \\n                }\\n            }\\n            \\n            res.add((int)cur);\\n        }\\n        \\n        return res;\\n    }\\n    \\n    // Euclidean algorithm\\n    private long gcd(long x, long y) {\\n        if(y == 0) {\\n            return x;\\n        }\\n        return gcd(y, x%y);\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1835073,
                "title": "simple-python-with-comments",
                "content": "The time saving trick here is to check to the immediate left of each merge once it happens. This can be done easily by backtracking our current index.\\n\\n```class Solution:\\n    def replaceNonCoprimes(self, nums: List[int]) -> List[int]:\\n        hasUpdate = False\\n        isFirstIter = True # We want to simulate a do-while loop\\n        while hasUpdate or isFirstIter:\\n            isFirstIter = False\\n            hasUpdate = False\\n            n = len(nums) - 1\\n            i = 0\\n            while i < n: # We need n to be mutable during the loop\\n                a = nums[i]\\n                b = nums[i + 1]\\n                ab_gcd = gcd(a,b)\\n                if ab_gcd > 1:\\n                    nums[i] = lcm(a,b) # Update the left value\\n                    del nums[i + 1] # Delete the right value\\n                    n -= 1 # Decrement our array size\\n                    i = max(-1, i - 2) # We want to backtrack one to the left of our current index (-2 cause we will +1 in the loop)\\n                    hasUpdate = True\\n                i += 1\\n        return nums\\n        ```",
                "solutionTags": [
                    "Python",
                    "Python3"
                ],
                "code": "```class Solution:\\n    def replaceNonCoprimes(self, nums: List[int]) -> List[int]:\\n        hasUpdate = False\\n        isFirstIter = True # We want to simulate a do-while loop\\n        while hasUpdate or isFirstIter:\\n            isFirstIter = False\\n            hasUpdate = False\\n            n = len(nums) - 1\\n            i = 0\\n            while i < n: # We need n to be mutable during the loop\\n                a = nums[i]\\n                b = nums[i + 1]\\n                ab_gcd = gcd(a,b)\\n                if ab_gcd > 1:\\n                    nums[i] = lcm(a,b) # Update the left value\\n                    del nums[i + 1] # Delete the right value\\n                    n -= 1 # Decrement our array size\\n                    i = max(-1, i - 2) # We want to backtrack one to the left of our current index (-2 cause we will +1 in the loop)\\n                    hasUpdate = True\\n                i += 1\\n        return nums\\n        ```",
                "codeTag": "Java"
            },
            {
                "id": 1831410,
                "title": "c",
                "content": "```\\n long long gcd(long long a,long long b){\\n        if(b==0) return a;\\n        return gcd(b, a%b);\\n    }\\n    long long lcm(long long a,long long b){\\n         return (a / gcd(a, b)) * b;\\n    }\\n    vector<int> replaceNonCoprimes(vector<int>& nums) {\\n        vector<int> res;\\n        stack<int> stk;\\n        int n = nums.size();\\n        for(int i=0;i<n;i++){\\n            int curr = nums[i];\\n            while(!stk.empty() && gcd(curr,stk.top()) > 1){\\n               curr = lcm(curr,stk.top());\\n               stk.pop(); \\n            }\\n            stk.push(curr);\\n        }\\n        while(!stk.empty()){\\n            res.push_back(stk.top());\\n            stk.pop();\\n        }\\n        reverse(res.begin(),end(res));\\n        return res;\\n    }\\n```",
                "solutionTags": [
                    "C",
                    "Stack"
                ],
                "code": "```\\n long long gcd(long long a,long long b){\\n        if(b==0) return a;\\n        return gcd(b, a%b);\\n    }\\n    long long lcm(long long a,long long b){\\n         return (a / gcd(a, b)) * b;\\n    }\\n    vector<int> replaceNonCoprimes(vector<int>& nums) {\\n        vector<int> res;\\n        stack<int> stk;\\n        int n = nums.size();\\n        for(int i=0;i<n;i++){\\n            int curr = nums[i];\\n            while(!stk.empty() && gcd(curr,stk.top()) > 1){\\n               curr = lcm(curr,stk.top());\\n               stk.pop(); \\n            }\\n            stk.push(curr);\\n        }\\n        while(!stk.empty()){\\n            res.push_back(stk.top());\\n            stk.pop();\\n        }\\n        reverse(res.begin(),end(res));\\n        return res;\\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1831021,
                "title": "python-stack-solution",
                "content": "```\\nclass Solution:\\n    def replaceNonCoprimes(self, nums: List[int]) -> List[int]:\\n         \\n        stack = [nums[0]]\\n        \\n        for i in range(1,len(nums)):\\n            \\n            if math.gcd(stack[-1], nums[i]) > 1 :\\n                num1 = nums[i]\\n                \\n                while math.gcd(num1,stack[-1])>1 :\\n                    x = math.lcm(num1,stack[-1])\\n                    stack.pop()\\n                    if stack :\\n                        num1 = x\\n                    else:\\n                        break\\n                stack.append(x)\\n            else:\\n                stack.append(nums[i])\\n                \\n        return stack\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution:\\n    def replaceNonCoprimes(self, nums: List[int]) -> List[int]:\\n         \\n        stack = [nums[0]]\\n        \\n        for i in range(1,len(nums)):\\n            \\n            if math.gcd(stack[-1], nums[i]) > 1 :\\n                num1 = nums[i]\\n                \\n                while math.gcd(num1,stack[-1])>1 :\\n                    x = math.lcm(num1,stack[-1])\\n                    stack.pop()\\n                    if stack :\\n                        num1 = x\\n                    else:\\n                        break\\n                stack.append(x)\\n            else:\\n                stack.append(nums[i])\\n                \\n        return stack\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1830943,
                "title": "c-easiest-solution-12-lines-only",
                "content": "```\\nclass Solution {\\npublic:\\n    vector<int> replaceNonCoprimes(vector<int>& nums) {\\n        vector<int> dq;int n=nums.size();  \\n        for(int i=0;i<n;i++)\\n        { dq.push_back(nums[i]);\\n           while(dq.size()>1)\\n           {\\n            int a=dq.back();int b=dq[dq.size()-2];\\n            if(gcd(a,b)>1)\\n             {   \\n                dq.pop_back();\\n                dq.pop_back();\\n                dq.push_back(lcm(a,b));\\n             } \\n             else\\n\\t\\t\\t break;\\n           }\\n        }\\n        return dq;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C",
                    "Math"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<int> replaceNonCoprimes(vector<int>& nums) {\\n        vector<int> dq;int n=nums.size();  \\n        for(int i=0;i<n;i++)\\n        { dq.push_back(nums[i]);\\n           while(dq.size()>1)\\n           {\\n            int a=dq.back();int b=dq[dq.size()-2];\\n            if(gcd(a,b)>1)\\n             {   \\n                dq.pop_back();\\n                dq.pop_back();\\n                dq.push_back(lcm(a,b));\\n             } \\n             else\\n\\t\\t\\t break;\\n           }\\n        }\\n        return dq;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1830696,
                "title": "one-pass-with-stack-97-speed",
                "content": "![image](https://assets.leetcode.com/users/images/c0224dda-d8cc-4e0a-b4ed-32dd72da5a86_1646734026.5282936.png)\\n```\\nclass Solution:\\n    def replaceNonCoprimes(self, nums: List[int]) -> List[int]:\\n        stack = []\\n        for n in nums:\\n            if not stack:\\n                stack.append(n)\\n            else:\\n                last_gcd = gcd(stack[-1], n)\\n                while last_gcd > 1:\\n                    stack[-1] *= n\\n                    stack[-1] //= last_gcd\\n                    if len(stack) > 1:\\n                        n = stack.pop()\\n                        last_gcd = gcd(stack[-1], n)\\n                    else:\\n                        break\\n                else:\\n                    stack.append(n)\\n        return stack\\n```",
                "solutionTags": [
                    "Python",
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def replaceNonCoprimes(self, nums: List[int]) -> List[int]:\\n        stack = []\\n        for n in nums:\\n            if not stack:\\n                stack.append(n)\\n            else:\\n                last_gcd = gcd(stack[-1], n)\\n                while last_gcd > 1:\\n                    stack[-1] *= n\\n                    stack[-1] //= last_gcd\\n                    if len(stack) > 1:\\n                        n = stack.pop()\\n                        last_gcd = gcd(stack[-1], n)\\n                    else:\\n                        break\\n                else:\\n                    stack.append(n)\\n        return stack\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1830605,
                "title": "c-stack-solution",
                "content": "\\tvector<int> replaceNonCoprimes(vector<int>& nums) {\\n        stack<int> st;\\n        \\n        for(int i = 0; i < nums.size(); i++) {\\n            \\n            int curr = nums[i];\\n            \\n            while(st.empty() == false) {\\n                \\n                int gcd = __gcd(curr, st.top());\\n                if(gcd > 1) {\\n                    int lcm = (curr / gcd) * st.top();\\n                    curr = lcm;\\n                    st.pop();\\n                }\\n                else\\n                    break;\\n            }\\n            \\n            st.push(curr);\\n        }\\n        \\n        vector<int> ans;\\n        \\n        while(!st.empty()) {\\n            ans.push_back(st.top());\\n            st.pop();\\n        }\\n        \\n        reverse(ans.begin(), ans.end());\\n        \\n        return ans;\\n    }",
                "solutionTags": [
                    "Stack"
                ],
                "code": "\\tvector<int> replaceNonCoprimes(vector<int>& nums) {\\n        stack<int> st;\\n        \\n        for(int i = 0; i < nums.size(); i++) {\\n            \\n            int curr = nums[i];\\n            \\n            while(st.empty() == false) {\\n                \\n                int gcd = __gcd(curr, st.top());\\n                if(gcd > 1) {\\n                    int lcm = (curr / gcd) * st.top();\\n                    curr = lcm;\\n                    st.pop();\\n                }\\n                else\\n                    break;\\n            }\\n            \\n            st.push(curr);\\n        }\\n        \\n        vector<int> ans;\\n        \\n        while(!st.empty()) {\\n            ans.push_back(st.top());\\n            st.pop();\\n        }\\n        \\n        reverse(ans.begin(), ans.end());\\n        \\n        return ans;\\n    }",
                "codeTag": "Unknown"
            },
            {
                "id": 1829210,
                "title": "doubly-linked-list",
                "content": "We are trying to replace a pair of number if the gcd is greater than 1. And while we reduce a pair of number into one, I guess using doubly linked list can reduce the cost of `delete` to `O(1)` .\\n\\n```\\n    def replaceNonCoprimes(self, nums: List[int]) -> List[int]:\\n        def gcd(x,y):\\n            while True:\\n                if 0 == x:\\n                    return y\\n                elif 0 == y:\\n                    return x\\n                if x > y:\\n                    x = x%y\\n                else:\\n                    y = y%x\\n            return None\\n        \\n        head = LL(nums[0])\\n        curr = head\\n        N = len(nums)\\n        for i in range(1,N):\\n            curr = curr.append(nums[i])\\n            \\n        tail = curr\\n        while curr.fr is not None:\\n\\n            # get 2 numbers\\n            x,y = curr.fr.val,curr.val\\n            xgcd = gcd(x,y)\\n            if xgcd != 1: # they are coprime\\n                prev = curr.fr\\n                prev.val = (x*y)//xgcd\\n                curr.drop()\\n                if prev.to:\\n                    curr = prev.to\\n                else:\\n                    curr = prev\\n            else:\\n                curr = curr.fr\\n                \\n        result = []\\n        while curr:\\n            result.append(curr.val)\\n            curr = curr.to\\n        return result\\n```\\n\\nHere is the linked list I used.\\n\\n```\\nclass LL:\\n    __slots__ = [\\'val\\',\\'fr\\',\\'to\\']\\n    def __init__(self, given:int =0):\\n        self.val = given\\n        self.to = None\\n        self.fr = None\\n        \\n    def append(self, x):\\n        self.to = LL(x)\\n        self.to.fr = self\\n        return self.to\\n\\n    def drop(self) -> None:\\n        if self.fr is not None:\\n            self.fr.to = self.to\\n        if self.to is not None:\\n            self.to.fr = self.fr\\n```",
                "solutionTags": [
                    "Linked List"
                ],
                "code": "```\\n    def replaceNonCoprimes(self, nums: List[int]) -> List[int]:\\n        def gcd(x,y):\\n            while True:\\n                if 0 == x:\\n                    return y\\n                elif 0 == y:\\n                    return x\\n                if x > y:\\n                    x = x%y\\n                else:\\n                    y = y%x\\n            return None\\n        \\n        head = LL(nums[0])\\n        curr = head\\n        N = len(nums)\\n        for i in range(1,N):\\n            curr = curr.append(nums[i])\\n            \\n        tail = curr\\n        while curr.fr is not None:\\n\\n            # get 2 numbers\\n            x,y = curr.fr.val,curr.val\\n            xgcd = gcd(x,y)\\n            if xgcd != 1: # they are coprime\\n                prev = curr.fr\\n                prev.val = (x*y)//xgcd\\n                curr.drop()\\n                if prev.to:\\n                    curr = prev.to\\n                else:\\n                    curr = prev\\n            else:\\n                curr = curr.fr\\n                \\n        result = []\\n        while curr:\\n            result.append(curr.val)\\n            curr = curr.to\\n        return result\\n```\n```\\nclass LL:\\n    __slots__ = [\\'val\\',\\'fr\\',\\'to\\']\\n    def __init__(self, given:int =0):\\n        self.val = given\\n        self.to = None\\n        self.fr = None\\n        \\n    def append(self, x):\\n        self.to = LL(x)\\n        self.to.fr = self\\n        return self.to\\n\\n    def drop(self) -> None:\\n        if self.fr is not None:\\n            self.fr.to = self.to\\n        if self.to is not None:\\n            self.to.fr = self.fr\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1828494,
                "title": "python-stack",
                "content": "```\\nclass Solution:\\n    def replaceNonCoprimes(self, nums: List[int]) -> List[int]:\\n        # res -> stack that keep track the left value\\n        res = []\\n        @functools.lru_cache(maxsize = None)\\n        def gcd(a,b):\\n            if a < b: a,b = b,a\\n            while a % b:\\n                a,b = b,a%b\\n            return b \\n        for n in nums:\\n            # if current value and left value are non-coprime, replace current value with their LCM\\n            while res and gcd(res[-1],n) != 1:\\n                left = res.pop()\\n                d = gcd(left,n)\\n                n = left*n//d\\n            res.append(n)\\n        return res\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution:\\n    def replaceNonCoprimes(self, nums: List[int]) -> List[int]:\\n        # res -> stack that keep track the left value\\n        res = []\\n        @functools.lru_cache(maxsize = None)\\n        def gcd(a,b):\\n            if a < b: a,b = b,a\\n            while a % b:\\n                a,b = b,a%b\\n            return b \\n        for n in nums:\\n            # if current value and left value are non-coprime, replace current value with their LCM\\n            while res and gcd(res[-1],n) != 1:\\n                left = res.pop()\\n                d = gcd(left,n)\\n                n = left*n//d\\n            res.append(n)\\n        return res\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1828265,
                "title": "c-solution-using-stack",
                "content": "```\\nclass Solution {\\npublic:\\n    vector<int> replaceNonCoprimes(vector<int>& nums) {\\n        int n = nums.size();\\n        vector<int> st;\\n        for (int i = 0; i < n; i++) {\\n            int last = nums[i];\\n            while(!st.empty() && __gcd(last, st.back()) > 1) {\\n                last = ((long long) last * st.back()) / __gcd(last, st.back());\\n                st.pop_back();\\n            }\\n            st.push_back(last);\\n        }\\n        return st;\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<int> replaceNonCoprimes(vector<int>& nums) {\\n        int n = nums.size();\\n        vector<int> st;\\n        for (int i = 0; i < n; i++) {\\n            int last = nums[i];\\n            while(!st.empty() && __gcd(last, st.back()) > 1) {\\n                last = ((long long) last * st.back()) / __gcd(last, st.back());\\n                st.pop_back();\\n            }\\n            st.push_back(last);\\n        }\\n        return st;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1827920,
                "title": "python-o-n",
                "content": "1. The problem statement itself states that the resulting array is the same regardless of the order of the operations. We should leverage this observation.\\n2. Therefore, we can consider elements one by one and operate as soon as it becomes available. Convince yourself that the operation will be applied to the last two elements. \\n3. Therefore we can use a stack to keep track of the resulting array, adding elements one by one, and merging when possible.\\n\\n```python\\nclass Solution:\\n    def replaceNonCoprimes(self, array):\\n        compressed = []\\n        for element in array:\\n            while compressed and gcd(compressed[-1], element) > 1:\\n                element = lcm(compressed[-1], element)\\n                compressed.pop()\\n            compressed.append(element)\\n        return compressed\\n```\\n\\n0. This problem feels like Medium instead, as only a concept of a stack is used. Besides, the most crucial observation is stated in the problem itself, making it rather trivial.",
                "solutionTags": [
                    "Python",
                    "Math",
                    "Stack"
                ],
                "code": "```python\\nclass Solution:\\n    def replaceNonCoprimes(self, array):\\n        compressed = []\\n        for element in array:\\n            while compressed and gcd(compressed[-1], element) > 1:\\n                element = lcm(compressed[-1], element)\\n                compressed.pop()\\n            compressed.append(element)\\n        return compressed\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1827573,
                "title": "c-concise-code",
                "content": "```\\nclass Solution {\\npublic:\\n    vector<int> replaceNonCoprimes(vector<int>& nums) {\\n        int n = nums.size();\\n        int i = 0;\\n        vector<int> res;\\n        while (i < n) {\\n            int cur = nums[i];\\n            int j = i + 1;\\n            while (j < n and gcd(cur, nums[j]) > 1) {\\n                cur = lcm(cur, nums[j]);\\n                j++;\\n            }\\n            i = j;\\n            while (res.size() and gcd(cur, res.back()) > 1) {\\n                cur = lcm(cur, res.back());\\n                res.pop_back();\\n            }\\n            res.emplace_back(cur);\\n        }\\n        return res;\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<int> replaceNonCoprimes(vector<int>& nums) {\\n        int n = nums.size();\\n        int i = 0;\\n        vector<int> res;\\n        while (i < n) {\\n            int cur = nums[i];\\n            int j = i + 1;\\n            while (j < n and gcd(cur, nums[j]) > 1) {\\n                cur = lcm(cur, nums[j]);\\n                j++;\\n            }\\n            i = j;\\n            while (res.size() and gcd(cur, res.back()) > 1) {\\n                cur = lcm(cur, res.back());\\n                res.pop_back();\\n            }\\n            res.emplace_back(cur);\\n        }\\n        return res;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1827227,
                "title": "kotlin-solution-with-arraylist",
                "content": "```\\nclass Solution {\\n    fun replaceNonCoprimes(nums: IntArray): List<Int> {\\n        \\n        var resultList = mutableListOf<Int>()\\n        \\n        for(num in nums) {\\n            var newNum = num\\n            while(true) {\\n                val last = if(resultList.isEmpty()) 1 else resultList.get(resultList.size-1)\\n                val gcd = getGCD(last, newNum)\\n                if(gcd == 1) break\\n                newNum = newNum * (last / gcd)\\n                resultList.removeAt(resultList.size-1)\\n            }\\n            resultList.add(newNum)\\n        }\\n        \\n        return resultList\\n    }\\n    \\n    private fun getGCD(x: Int, y: Int): Int {    // Copied from lee215\\n        \\n        return if (y>0) getGCD(y, x%y) else x\\n    }\\n}",
                "solutionTags": [
                    "Kotlin",
                    "Array"
                ],
                "code": "class Solution {\\n    fun replaceNonCoprimes(nums: IntArray): List<Int> {\\n        \\n        var resultList = mutableListOf<Int>()\\n        \\n        for(num in nums) {\\n            var newNum = num\\n            while(true) {\\n                val last = if(resultList.isEmpty()) 1 else resultList.get(resultList.size-1)\\n                val gcd = getGCD(last, newNum)\\n                if(gcd == 1) break\\n                newNum = newNum * (last / gcd)\\n                resultList.removeAt(resultList.size-1)\\n            }",
                "codeTag": "Java"
            },
            {
                "id": 1827193,
                "title": "63-ms-faster-than-100-00-java-solution-with-detailed-comment",
                "content": "```\\nclass Solution {\\n    public List<Integer> replaceNonCoprimes(int[] nums) {\\n        int n = nums.length;\\n\\t\\t// Use linkedlist as stack like data structure and operator at the tail of list\\n        LinkedList<Integer> list = new LinkedList<>(); \\n        list.add(nums[0]);\\n        for (int i = 1; i < nums.length; i++) {\\n            int a = list.getLast();\\n            int b = nums[i];\\n            if (b > 1 && a == b) {\\n                continue;\\n            }\\n            \\n            int gcd = gcd(a, b);\\n            if (gcd == 1) { \\n                //coprime: append b\\n                list.add(b);\\n            } else { \\n                //non-coprime: replace last with lcm\\n                list.removeLast();\\n                int lcm = (int) ((a * (long) b) / gcd);\\n                \\n                //track back if new last and lcm are non-coprimes \\n                while (!list.isEmpty()) {\\n                    gcd = gcd(list.getLast(), lcm);\\n                    if (gcd == 1) {\\n                        break;\\n                    }\\n\\t\\t\\t\\t\\t //remove last and update lcm\\n                    lcm = (int)((list.removeLast() * (long) lcm) / gcd);\\n                }\\n                \\n                list.add(lcm);\\n            }\\n        }\\n        return list;\\n    }\\n    \\n    private int gcd(int a, int b) {\\n        if (a < b) \\n            return gcd(b, a);\\n        else if (a % b == 0) {\\n            return b;\\n        } else {\\n            return gcd(b, a % b);\\n        }\\n    }\\n}\\n```",
                "solutionTags": [
                    "Stack"
                ],
                "code": "```\\nclass Solution {\\n    public List<Integer> replaceNonCoprimes(int[] nums) {\\n        int n = nums.length;\\n\\t\\t// Use linkedlist as stack like data structure and operator at the tail of list\\n        LinkedList<Integer> list = new LinkedList<>(); \\n        list.add(nums[0]);\\n        for (int i = 1; i < nums.length; i++) {\\n            int a = list.getLast();\\n            int b = nums[i];\\n            if (b > 1 && a == b) {\\n                continue;\\n            }\\n            \\n            int gcd = gcd(a, b);\\n            if (gcd == 1) { \\n                //coprime: append b\\n                list.add(b);\\n            } else { \\n                //non-coprime: replace last with lcm\\n                list.removeLast();\\n                int lcm = (int) ((a * (long) b) / gcd);\\n                \\n                //track back if new last and lcm are non-coprimes \\n                while (!list.isEmpty()) {\\n                    gcd = gcd(list.getLast(), lcm);\\n                    if (gcd == 1) {\\n                        break;\\n                    }\\n\\t\\t\\t\\t\\t //remove last and update lcm\\n                    lcm = (int)((list.removeLast() * (long) lcm) / gcd);\\n                }\\n                \\n                list.add(lcm);\\n            }\\n        }\\n        return list;\\n    }\\n    \\n    private int gcd(int a, int b) {\\n        if (a < b) \\n            return gcd(b, a);\\n        else if (a % b == 0) {\\n            return b;\\n        } else {\\n            return gcd(b, a % b);\\n        }\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1826822,
                "title": "doubly-linked-list-solution",
                "content": "class Solution {\\npublic:\\n    struct List{\\n         List * next;\\n        List *prev;\\n        long long val;\\n        List(long long val1){\\n            val=val1;\\n            next=NULL;\\n            prev=NULL;\\n        }\\n    };\\n    vector<int> replaceNonCoprimes(vector<int>& nums) {\\n        vector<int> v;\\n       List * head=NULL;\\n        List *p=head;\\n        List *previous=NULL;\\n        for(int i=0;i<nums.size();i++){\\n            if(head==NULL){\\n                head= new List(nums[i]);\\n                p=head;\\n            }else{\\n                previous=p;\\n                p->next=new List(nums[i]);\\n                p=p->next;\\n                p->prev=previous;\\n            }\\n        }\\n        List *q=head;\\n        while(q->next!=NULL){\\n            if(gcd(q->val,q->next->val)>1){\\n                q->next->val=(q->val*q->next->val)/gcd(q->val,q->next->val);\\n                if(q->prev==NULL){\\n                    head=head->next;\\n                    head->prev=NULL;\\n                    q=head;\\n                }else{\\n                    q->prev->next=q->next;\\n                    q->next->prev=q->prev;\\n                    q=q->prev;\\n                }\\n            }else{\\n                q=q->next;\\n            }\\n        }\\n       while(head!=NULL){\\n           v.push_back(head->val);\\n           head=head->next;\\n       }\\n        return v;\\n    }\\n};",
                "solutionTags": [],
                "code": "class Solution {\\npublic:\\n    struct List{\\n         List * next;\\n        List *prev;\\n        long long val;\\n        List(long long val1){\\n            val=val1;\\n            next=NULL;\\n            prev=NULL;\\n        }",
                "codeTag": "Java"
            },
            {
                "id": 1826401,
                "title": "replace-non-coprime-numbers-in-array-please-help-understand-where-i-have-gone-wrong-in-my-solution",
                "content": "I have done the below code, but i \\'m getting a response for one particular input as wrong result. I am not sure where I am making any mistake. Could someone please help me to understand where I have gone wrong in my solution? \\n\\nHere is the response I got and the standard output from my program.\\nInput: [287,41,49,287,899,23,23,20677,5,825]\\nOutput: [2009,899,20677,825]\\nExpected: [2009,20677,825]\\n\\nStandard Output:\\ni=0;j=1\\nnums[0]=287;nums[1]=41\\ngcd= 41\\nlcm= 287\\npopping 0 element from nums\\n[41, 49, 287, 899, 23, 23, 20677, 5, 825]\\npopping 1 element from nums\\ninserting 287 at 0 position\\n[287, 49, 287, 899, 23, 23, 20677, 5, 825]\\ni=0;j=1\\nnums[0]=287;nums[1]=49\\ngcd= 7\\nlcm= 2009\\npopping 0 element from nums\\n[49, 287, 899, 23, 23, 20677, 5, 825]\\npopping 1 element from nums\\ninserting 2009 at 0 position\\n[2009, 287, 899, 23, 23, 20677, 5, 825]\\ni=0;j=1\\nnums[0]=2009;nums[1]=287\\ngcd= 287\\nlcm= 2009\\npopping 0 element from nums\\n[287, 899, 23, 23, 20677, 5, 825]\\npopping 1 element from nums\\ninserting 2009 at 0 position\\n[2009, 899, 23, 23, 20677, 5, 825]\\ni=0;j=1\\nnums[0]=2009;nums[1]=899\\ngcd= 1\\ni=1;j=2\\nnums[1]=899;nums[2]=23\\ngcd= 1\\ni=2;j=3\\nnums[2]=23;nums[3]=23\\ngcd= 23\\nlcm= 23\\npopping 2 element from nums\\n[2009, 899, 23, 20677, 5, 825]\\npopping 3 element from nums\\ninserting 23 at 2 position\\n[2009, 899, 23, 20677, 5, 825]\\ni=2;j=3\\nnums[2]=23;nums[3]=20677\\ngcd= 23\\nlcm= 20677\\npopping 2 element from nums\\n[2009, 899, 20677, 5, 825]\\npopping 3 element from nums\\ninserting 20677 at 2 position\\n[2009, 899, 20677, 5, 825]\\ni=2;j=3\\nnums[2]=20677;nums[3]=5\\ngcd= 1\\ni=3;j=4\\nnums[3]=5;nums[4]=825\\ngcd= 5\\nlcm= 825\\npopping 3 element from nums\\n[2009, 899, 20677, 825]\\npopping 4 element from nums\\ninserting 825 at 3 position\\n[2009, 899, 20677, 825]\\ni=3;j=4\\n\\n```\\nclass Solution:\\n    def replaceNonCoprimes(self, nums: List[int]) -> List[int]:\\n        l=len(nums)\\n        if l < 2:\\n            return nums\\n        if l==2:\\n            num1=nums[0]\\n            num2=nums[1]\\n            if num1==1 or num2==1:\\n                return nums\\n            gcd=math.gcd(num1,num2)\\n            if gcd==1:\\n                return nums\\n            else:\\n\\t\\t\\t    lcm=(num1*num2)/gcd\\n                return [lcm]\\n        if l > 2:\\n                l=len(nums)\\n                i=0\\n                j=1\\n                while True:\\n                    print(\"i=\"+str(i)+\";j=\"+str(j))\\n                    if i==l or j==l:\\n                        break\\n                    num1=nums[i]\\n                    num2=nums[j]\\n                    print(\"nums[\"+str(i)+\"]=\"+str(num1)+\";nums[\"+str(j)+\"]=\"+str(num2))\\n                    gcd=math.gcd(num1,num2)\\n                    print(\"gcd=\",str(gcd))\\n                    if gcd==1:\\n                        i=i+1\\n                        j=j+1\\n                        continue\\n                    lcm=int((num1*num2)/gcd)\\n                    print(\"lcm=\",str(lcm))\\n                    print(\"popping \"+str(i)+\" element from nums\")\\n                    nums.pop(i)\\n                    print(nums)\\n                    print(\"popping \"+str(j)+\" element from nums\")\\n                    nums.pop(i)\\n                    print(\"inserting \"+str(lcm)+\" at \"+str(i)+\" position\")\\n                    nums.insert(i,lcm)\\n                    print(nums)\\n                    l=len(nums)\\n                return nums\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution:\\n    def replaceNonCoprimes(self, nums: List[int]) -> List[int]:\\n        l=len(nums)\\n        if l < 2:\\n            return nums\\n        if l==2:\\n            num1=nums[0]\\n            num2=nums[1]\\n            if num1==1 or num2==1:\\n                return nums\\n            gcd=math.gcd(num1,num2)\\n            if gcd==1:\\n                return nums\\n            else:\\n\\t\\t\\t    lcm=(num1*num2)/gcd\\n                return [lcm]\\n        if l > 2:\\n                l=len(nums)\\n                i=0\\n                j=1\\n                while True:\\n                    print(\"i=\"+str(i)+\";j=\"+str(j))\\n                    if i==l or j==l:\\n                        break\\n                    num1=nums[i]\\n                    num2=nums[j]\\n                    print(\"nums[\"+str(i)+\"]=\"+str(num1)+\";nums[\"+str(j)+\"]=\"+str(num2))\\n                    gcd=math.gcd(num1,num2)\\n                    print(\"gcd=\",str(gcd))\\n                    if gcd==1:\\n                        i=i+1\\n                        j=j+1\\n                        continue\\n                    lcm=int((num1*num2)/gcd)\\n                    print(\"lcm=\",str(lcm))\\n                    print(\"popping \"+str(i)+\" element from nums\")\\n                    nums.pop(i)\\n                    print(nums)\\n                    print(\"popping \"+str(j)+\" element from nums\")\\n                    nums.pop(i)\\n                    print(\"inserting \"+str(lcm)+\" at \"+str(i)+\" position\")\\n                    nums.insert(i,lcm)\\n                    print(nums)\\n                    l=len(nums)\\n                return nums\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1826236,
                "title": "java-o-nlog-max-time-o-n-space-stack",
                "content": "Let\\'s understand this with an example,\\n[2, 3, 2, 3, 6, 1, 6, 3, 2, 3, 2]\\n\\nI. If a number is not coprime with last result, we just add it to the stack.\\nII. If it\\'s coprime with it, we obtain a new result (LCM of both) and pop the preceding result and we continue this process until we reach the first condition or stack becomes empty.\\n\\n1. We start with 2 in stack.\\n2. GCD(2, 3) = 1, PUSH 3.\\n3. Similarly, PUSH 2 -> PUSH 3.\\n4. GCD(6, 3) = 3 != 1  => POP  and newResult = LCM(6, 3) = 6\\n\\t\\t Continue checking for coprime with stack top\\n\\t     GCD(6, 2) = 2 != 1 => POP , newResult = LCM(6, 2) = 6\\n\\t\\t  ... Finally we have empty Stack. So, PUSH 6 (newResult).\\n5. GCD(6, 1) = 1, PUSH 1.\\n6. GCD(1, 6) = 1. PUSH 6.\\n7. GCD(6, 3) = 3 != 1 => POP  and newResult = LCM(6, 3) = 6\\n\\t\\tContinue checking for coprime with stack top\\n\\t\\tGCD(6, 1) = 1 => PUSH 6 (newResult).\\n8. At the end, we have our result stored in stack.\\n\\nComplexity : \\n\\tWe iterate through each element in the array. When while runs, it reduces the size of stack and we convert multiple values into just one (i.e. LCM), so a value gets processed only once. So, nested loop doesn\\'t make it quadratic solution.\\n\\tTime Comp. : O(nlogm) ( logm to find GCD where m = Maximum in nums)\\n\\tAux. Space   :  O(n)  (For Stack)\\n\\n[Solution can be modified to store result values directly in result. This will reduce Auxiliary Space to O(1) and optimize the solution further.]\\n\\n![image](https://assets.leetcode.com/users/images/8018a7d3-d440-4317-97c5-4a6464fafcf9_1646591950.6937635.png)\\n\\n\\n\\n\\n```\\nclass Solution {\\n    public List<Integer> replaceNonCoprimes(int[] nums) {\\n        int len = nums.length;\\n\\t\\t\\n        Stack<Integer> values = new Stack<>();\\n        \\n        for (int i = 0; i < len; i++) {\\n            int curr = nums[i];\\n            \\n            if (values.isEmpty())\\n                values.push(curr);\\n            else {\\n                while (true) {\\n                    if (values.isEmpty()) {\\n                        values.push(curr);\\n                        break;\\n                    }\\n                    \\n                    int gcd = gcd(curr, values.peek());\\n                    if (gcd == 1) {\\n                        values.push(curr);\\n                        break;\\n                    }\\n                    else {\\n                        int top = values.pop();\\n                        curr = lcm(curr, top);\\n                    }\\n                }\\n            }\\n        }\\n        \\n        List<Integer> result = new ArrayList<>();\\n        int resultLength = values.size();\\n        \\n        for (int i = 0; i < resultLength; i++) {\\n            result.add(values.pop());\\n        }\\n        \\n        int low = 0;\\n        int high = resultLength - 1;\\n        \\n        while (low < high) {\\n            int temp = result.get(low);\\n            result.set(low++, result.get(high));\\n            result.set(high--, temp);\\n        }\\n        \\n        return result;\\n    }\\n    \\n    private int gcd(long a, long b) {\\n        if (b > a) \\n            return gcd(b, a);\\n        \\n        while (b > 0) {\\n            long temp = b;\\n            b = a % b;\\n            a = temp;\\n        }\\n        \\n        return (int) a;\\n    }\\n    \\n    private int lcm(long a, long b) {\\n        long prod = a * b;\\n        long gcd = gcd(a, b);\\n        \\n        return (int) (prod / gcd);\\n    }\\n}\\n```",
                "solutionTags": [
                    "Stack"
                ],
                "code": "```\\nclass Solution {\\n    public List<Integer> replaceNonCoprimes(int[] nums) {\\n        int len = nums.length;\\n\\t\\t\\n        Stack<Integer> values = new Stack<>();\\n        \\n        for (int i = 0; i < len; i++) {\\n            int curr = nums[i];\\n            \\n            if (values.isEmpty())\\n                values.push(curr);\\n            else {\\n                while (true) {\\n                    if (values.isEmpty()) {\\n                        values.push(curr);\\n                        break;\\n                    }\\n                    \\n                    int gcd = gcd(curr, values.peek());\\n                    if (gcd == 1) {\\n                        values.push(curr);\\n                        break;\\n                    }\\n                    else {\\n                        int top = values.pop();\\n                        curr = lcm(curr, top);\\n                    }\\n                }\\n            }\\n        }\\n        \\n        List<Integer> result = new ArrayList<>();\\n        int resultLength = values.size();\\n        \\n        for (int i = 0; i < resultLength; i++) {\\n            result.add(values.pop());\\n        }\\n        \\n        int low = 0;\\n        int high = resultLength - 1;\\n        \\n        while (low < high) {\\n            int temp = result.get(low);\\n            result.set(low++, result.get(high));\\n            result.set(high--, temp);\\n        }\\n        \\n        return result;\\n    }\\n    \\n    private int gcd(long a, long b) {\\n        if (b > a) \\n            return gcd(b, a);\\n        \\n        while (b > 0) {\\n            long temp = b;\\n            b = a % b;\\n            a = temp;\\n        }\\n        \\n        return (int) a;\\n    }\\n    \\n    private int lcm(long a, long b) {\\n        long prod = a * b;\\n        long gcd = gcd(a, b);\\n        \\n        return (int) (prod / gcd);\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1826178,
                "title": "java-stack-solution-faster-than-100",
                "content": "```\\nclass Solution {\\n    public List<Integer> replaceNonCoprimes(int[] nums) {\\n        LinkedList<Integer> li=new LinkedList<>();\\n        for(int val:nums){\\n           while(true){\\n               int last=li.isEmpty()?1:li.getLast();\\n               int g=gcd(last,val);\\n               if(g==1){\\n                   break;\\n               }\\n               li.removeLast();\\n               val*=last/g;\\n           }\\n            li.add(val);\\n        }\\n        \\n        return li;\\n        \\n    }\\n    \\n     public int gcd(int a,int b){\\n        if(b==0){\\n            return a;\\n        }\\n        return gcd(b,a%b);\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Stack"
                ],
                "code": "```\\nclass Solution {\\n    public List<Integer> replaceNonCoprimes(int[] nums) {\\n        LinkedList<Integer> li=new LinkedList<>();\\n        for(int val:nums){\\n           while(true){\\n               int last=li.isEmpty()?1:li.getLast();\\n               int g=gcd(last,val);\\n               if(g==1){\\n                   break;\\n               }\\n               li.removeLast();\\n               val*=last/g;\\n           }\\n            li.add(val);\\n        }\\n        \\n        return li;\\n        \\n    }\\n    \\n     public int gcd(int a,int b){\\n        if(b==0){\\n            return a;\\n        }\\n        return gcd(b,a%b);\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1825915,
                "title": "python-stack",
                "content": "```\\nfrom math import gcd\\nclass Solution:         \\n    def replaceNonCoprimes(self, nums: List[int]) -> List[int]:\\n        if len(nums) < 2:\\n            return nums\\n        \\n        stack = []\\n        \\n        for n in nums:\\n            stack.append(n)\\n            while len(stack)>1 and (gcd_:=math.gcd(stack[-1], stack[-2]))>1:\\n                last = stack.pop()\\n                stack[-1] = stack[-1]*last//gcd_\\n                \\n        return stack\\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nfrom math import gcd\\nclass Solution:         \\n    def replaceNonCoprimes(self, nums: List[int]) -> List[int]:\\n        if len(nums) < 2:\\n            return nums\\n        \\n        stack = []\\n        \\n        for n in nums:\\n            stack.append(n)\\n            while len(stack)>1 and (gcd_:=math.gcd(stack[-1], stack[-2]))>1:\\n                last = stack.pop()\\n                stack[-1] = stack[-1]*last//gcd_\\n                \\n        return stack\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1825679,
                "title": "java-linkedlist",
                "content": "```\\nclass Solution {\\n    public List<Integer> replaceNonCoprimes(int[] nums) {\\n        LinkedList<Integer> ans= new LinkedList<>();\\n        for(int num:nums) ans.add(num);\\n\\n        for(ListIterator<Integer> it= ans.listIterator(); it.hasNext(); ){\\n            if(!it.hasPrevious()){\\n                it.next();\\n            }else{\\n                it.previous();\\n                int prev= it.next(), curr= it.next(), gcd= gcd(prev, curr);\\n                if(gcd>1){\\n                    it.previous(); \\n                    it.remove(); \\n                    it.previous(); \\n                    it.set((int)((long)prev*curr/gcd));\\n                }\\n            }\\n        }\\n        return ans;\\n    }\\n    \\n    int gcd(int a, int b){\\n        for(int t; b!=0; t=b, b=a%b, a=t);\\n        return a;\\n    }\\n}",
                "solutionTags": [],
                "code": "class Solution {\\n    public List<Integer> replaceNonCoprimes(int[] nums) {\\n        LinkedList<Integer> ans= new LinkedList<>();\\n        for(int num:nums) ans.add(num);\\n\\n        for(ListIterator<Integer> it= ans.listIterator(); it.hasNext(); ){\\n            if(!it.hasPrevious()){\\n                it.next();\\n            }",
                "codeTag": "Java"
            },
            {
                "id": 1825523,
                "title": "python3-solution",
                "content": "```\\nclass Solution:\\n    def replaceNonCoprimes(self, nums: List[int]) -> List[int]:\\n        ans = [];n = len(nums)\\n        i = 0\\n        while(i<n):\\n            ans.append(nums[i])\\n            while(len(ans)>=2):\\n                second = ans.pop()\\n                first = ans.pop()\\n                greatCD = gcd(first,second)\\n                if(greatCD>1):\\n                    ans.append(int(first*second/greatCD))\\n                else:\\n                    ans.append(first)\\n                    ans.append(second)\\n                    break\\n            i+=1\\n        return ans\\ndef gcd(m,n):\\n    if(n==0):\\n        return m\\n    else:\\n        return gcd(n,m%n)\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution:\\n    def replaceNonCoprimes(self, nums: List[int]) -> List[int]:\\n        ans = [];n = len(nums)\\n        i = 0\\n        while(i<n):\\n            ans.append(nums[i])\\n            while(len(ans)>=2):\\n                second = ans.pop()\\n                first = ans.pop()\\n                greatCD = gcd(first,second)\\n                if(greatCD>1):\\n                    ans.append(int(first*second/greatCD))\\n                else:\\n                    ans.append(first)\\n                    ans.append(second)\\n                    break\\n            i+=1\\n        return ans\\ndef gcd(m,n):\\n    if(n==0):\\n        return m\\n    else:\\n        return gcd(n,m%n)\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1825329,
                "title": "java-solution-using-stack-easy-to-understand",
                "content": "`Intuition`:\\n\\nIt can be observed that order of lcm doesn\\'t matter, but the real challenge is to calculate lcm efficeintly. One intution is to use recursion.\\n\\nLet\\'s say we have choosen any two indices `i` and `j`, where  `0<=i< j<n`  and `gcd(nums[i], nums[j) > 1`  then we can recurse to it\\'s left and right and when we found some indices let say.. `(k1< k2) < i and (l1 < l2) > j` to which can merge the result. Here, k1 and k2 are one of the pair indices to left of `i`. Similarly, l1 and l2 are one of the pair of indices in right of `j.`\\n\\nThis looks hard, but we can use a stack for same and simulate this process. Keep processing the element from left to right and once we find the proper pair of `i and j` , we can start popopping out the element from the stack(these elements were previously processed but they were not merged)\\n\\nWhile moving back to left or popping element from stack, we need to `re-calcluate ` `lcm` again and put it back to the stack. Check below code..\\n \\n```\\nclass Solution {\\n    public List<Integer> replaceNonCoprimes(int[] nums) {\\n        List<Integer> res = new ArrayList();\\n        int n = nums.length;\\n        Stack<Integer> st = new Stack();\\n        int lcm = nums[0];\\n        st.add(nums[0]);\\n        if(n ==1 ){\\n            res.add(nums[0]);\\n            return res;\\n        }\\n        for(int i = 1; i<n; i++){\\n            if( gcd( lcm, nums[i]) > 1){\\n                lcm = lcm(lcm, nums[i]);\\n                while(!st.isEmpty() && gcd(lcm, st.peek()) > 1){\\n                    lcm = lcm(lcm, st.peek());\\n                    st.pop();\\n                }\\n                st.push(lcm);\\n            }else{\\n                lcm = nums[i];\\n                st.push(nums[i]);\\n            }\\n        }\\n        Iterator<Integer> itr = st.iterator();\\n        while(itr.hasNext()){\\n            res.add(itr.next());\\n        }\\n        return res;\\n    }\\n    private int lcm(long a, long b)\\n    {\\n        return (int)((a * b) / gcd(a, b));\\n    }\\n    private int gcd(long a, long b){\\n        if(a == 0) return (int)b;\\n        return (int)gcd(b%a, a);\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    public List<Integer> replaceNonCoprimes(int[] nums) {\\n        List<Integer> res = new ArrayList();\\n        int n = nums.length;\\n        Stack<Integer> st = new Stack();\\n        int lcm = nums[0];\\n        st.add(nums[0]);\\n        if(n ==1 ){\\n            res.add(nums[0]);\\n            return res;\\n        }\\n        for(int i = 1; i<n; i++){\\n            if( gcd( lcm, nums[i]) > 1){\\n                lcm = lcm(lcm, nums[i]);\\n                while(!st.isEmpty() && gcd(lcm, st.peek()) > 1){\\n                    lcm = lcm(lcm, st.peek());\\n                    st.pop();\\n                }\\n                st.push(lcm);\\n            }else{\\n                lcm = nums[i];\\n                st.push(nums[i]);\\n            }\\n        }\\n        Iterator<Integer> itr = st.iterator();\\n        while(itr.hasNext()){\\n            res.add(itr.next());\\n        }\\n        return res;\\n    }\\n    private int lcm(long a, long b)\\n    {\\n        return (int)((a * b) / gcd(a, b));\\n    }\\n    private int gcd(long a, long b){\\n        if(a == 0) return (int)b;\\n        return (int)gcd(b%a, a);\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1825085,
                "title": "go-stack-and-primes-gcd-lcm-primer",
                "content": "Following along the theme of primes from [Count Array Pairs Divisible by K](https://leetcode.com/problems/count-array-pairs-divisible-by-k/)...\\n\\nMany CP problems require knowledge about primes and basic number theory.\\n\\nAll positive integers consist of prime factors. The primes only have one factor: themselves.\\n\\nFor two numbers to be co-prime, they must contain no common prime factors.\\n\\nAn example can easily be created by combining some random prime factors, like \\n`7 * 9 = 63` and `3 * 5 = 15`. There are unique prime factors in both numbers, and so\\nthe two numbers are co-prime.\\n\\nSo what does the if `gcd(a,b) != 1 { a = lcm(a,b) }` operation do?\\n\\nGCD will find any common prime between the two numbers. \\nLCM will combine a with b (and all of its factors) then divide by the common prime.\\n\\nFor example, if `a = 3*5` and `b = 2*3`, then `gcd(a,b) = 3`. Simply multiplying `a*b`\\ngives `3*5*2*3`. LCM divides by the common prime, i.e.  \\n`a*b / gcd(a,b) = 3*5*2*3 / 3 = 3*5*2`.\\n\\nSo in a way when looking at the input, you could say that adjacent numbers\\nare linked if they share a common prime. LCM combines numbers that are linked.\\nFor there to be more than one final group in the output, there must exist\\nsegments within nums that have sets of globally unique primes.\\n\\n```go\\nfunc replaceNonCoprimes(nums []int) []int {\\n\\tgcd := func(a, b int) int {\\n\\t\\tfor b != 0 {\\n\\t\\t\\ta, b = b, a%b\\n\\t\\t}\\n\\t\\treturn a\\n\\t}\\n\\tlcm := func(a, b int) int {\\n\\t\\treturn a * b / gcd(a, b)\\n\\t}\\n\\n\\tstack := make([]int, 0, len(nums))\\n\\tvar n int\\n\\n\\tfor _, num := range nums {\\n\\t\\tstack = append(stack, num)\\n\\t\\tn++\\n\\t\\tfor n > 1 && gcd(stack[n-2], stack[n-1]) != 1 {\\n\\t\\t\\tstack[n-2] = lcm(stack[n-2], stack[n-1])\\n\\t\\t\\tstack = stack[:n-1]\\n\\t\\t\\tn--\\n\\t\\t}\\n\\t}\\n\\treturn stack\\n}\\n```",
                "solutionTags": [
                    "Go"
                ],
                "code": "```go\\nfunc replaceNonCoprimes(nums []int) []int {\\n\\tgcd := func(a, b int) int {\\n\\t\\tfor b != 0 {\\n\\t\\t\\ta, b = b, a%b\\n\\t\\t}\\n\\t\\treturn a\\n\\t}\\n\\tlcm := func(a, b int) int {\\n\\t\\treturn a * b / gcd(a, b)\\n\\t}\\n\\n\\tstack := make([]int, 0, len(nums))\\n\\tvar n int\\n\\n\\tfor _, num := range nums {\\n\\t\\tstack = append(stack, num)\\n\\t\\tn++\\n\\t\\tfor n > 1 && gcd(stack[n-2], stack[n-1]) != 1 {\\n\\t\\t\\tstack[n-2] = lcm(stack[n-2], stack[n-1])\\n\\t\\t\\tstack = stack[:n-1]\\n\\t\\t\\tn--\\n\\t\\t}\\n\\t}\\n\\treturn stack\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1825010,
                "title": "stack",
                "content": "\\n\\n\\nclass Solution {\\npublic:\\n    int gcd(int a, int b)\\n    {\\n        return b == 0 ? a : gcd(b, a % b);\\n    }\\n\\n    int lcm(int a, int b)\\n    {\\n        return (a / gcd(a, b)) * b;\\n    }\\n\\n    vector<int> replaceNonCoprimes(vector<int> &nums)\\n    {\\n\\n        stack<int> st;\\n        int n = nums.size();\\n\\n        st.push(nums[0]);\\n        for (int i = 1; i < n; i++) {\\n            if (st.size() < 1) {\\n                st.push(nums[i]);\\n                continue;\\n            }\\n            st.push(nums[i]);\\n            while (st.size() >= 2) {\\n                int a = st.top();\\n                st.pop();\\n                int b = st.top();\\n                st.pop();\\n                if (gcd(a, b) > 1) {\\n\\n                    st.push(lcm(a, b));\\n                }\\n                else {\\n\\n                    st.push(b);\\n                    st.push(a);\\n                    break;\\n                }\\n            }\\n        }\\n\\n        vector<int> ans;\\n\\n        while (!st.empty()) {\\n            // cout<<st.top()<<endl;\\n            ans.push_back(st.top());\\n\\n            st.pop();\\n        }\\n\\n        reverse(ans.begin(), ans.end());\\n        return ans;\\n    }\\n};",
                "solutionTags": [],
                "code": "class Solution {\\npublic:\\n    int gcd(int a, int b)\\n    {\\n        return b == 0 ? a : gcd(b, a % b);\\n    }",
                "codeTag": "Java"
            },
            {
                "id": 1824935,
                "title": "java-simple-iterative-code-and-logic-with-explaination",
                "content": "```\\nclass Solution {\\n    // function to find gcd of a and b\\n    public static int gcd(int a,int b) {\\n        if(a==0) {\\n            return b;\\n        }\\n        return gcd(b%a,a);\\n    }\\n    \\n    public List<Integer> replaceNonCoprimes(int[] nums) {\\n        List<Integer> ans = new ArrayList<>();\\n        for(int i=0;i<nums.length-1;i++) {\\n            int hcf = gcd(nums[i],nums[i+1]);\\n            if(hcf==1) {\\n                while(ans.size()>0) {\\n                    int hcf1 = gcd(nums[i],ans.get(ans.size()-1));\\n                    if(hcf1==1) {\\n                        break;\\n                    } else {\\n                        nums[i]=(nums[i]/hcf1)*ans.get(ans.size()-1);\\n                        ans.remove(ans.size()-1);\\n                    }\\n                }\\n                ans.add(nums[i]);\\n            } else {\\n                nums[i+1]=(nums[i]/hcf)*nums[i+1];\\n                nums[i]=-1;\\n            }\\n        }\\n        if(nums[nums.length-1]!=-1) {\\n            while(ans.size()>0) {\\n                int hcf1 = gcd(nums[nums.length-1],ans.get(ans.size()-1));\\n                if(hcf1==1) {\\n                    break;\\n                } else {\\n                    nums[nums.length-1]=(nums[nums.length-1]/hcf1)*ans.get(ans.size()-1);\\n                    ans.remove(ans.size()-1);\\n                }\\n            }\\n            ans.add(nums[nums.length-1]);\\n        }\\n        return ans;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    // function to find gcd of a and b\\n    public static int gcd(int a,int b) {\\n        if(a==0) {\\n            return b;\\n        }\\n        return gcd(b%a,a);\\n    }\\n    \\n    public List<Integer> replaceNonCoprimes(int[] nums) {\\n        List<Integer> ans = new ArrayList<>();\\n        for(int i=0;i<nums.length-1;i++) {\\n            int hcf = gcd(nums[i],nums[i+1]);\\n            if(hcf==1) {\\n                while(ans.size()>0) {\\n                    int hcf1 = gcd(nums[i],ans.get(ans.size()-1));\\n                    if(hcf1==1) {\\n                        break;\\n                    } else {\\n                        nums[i]=(nums[i]/hcf1)*ans.get(ans.size()-1);\\n                        ans.remove(ans.size()-1);\\n                    }\\n                }\\n                ans.add(nums[i]);\\n            } else {\\n                nums[i+1]=(nums[i]/hcf)*nums[i+1];\\n                nums[i]=-1;\\n            }\\n        }\\n        if(nums[nums.length-1]!=-1) {\\n            while(ans.size()>0) {\\n                int hcf1 = gcd(nums[nums.length-1],ans.get(ans.size()-1));\\n                if(hcf1==1) {\\n                    break;\\n                } else {\\n                    nums[nums.length-1]=(nums[nums.length-1]/hcf1)*ans.get(ans.size()-1);\\n                    ans.remove(ans.size()-1);\\n                }\\n            }\\n            ans.add(nums[nums.length-1]);\\n        }\\n        return ans;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1824828,
                "title": "python-divide-and-conquer-with-explanation-o-n-log-n",
                "content": "We would like to divide [0, 1, 2, ... N - 1] into two subarrays. Let\\'s suppose that we have already handled two subarrays left and right. Now we can take a look at the left[-1] and right[0]. If their gcd is 1, then we are done. Otherwise, we can expand to left and to right until there is no lcm expansion.\\n\\nTC is O(n log n) because of master theorem. T(n) = 2 T(n/2) + O(n)\\n\\n```\\nfrom functools import lru_cache\\n\\nclass Solution:\\n    def replaceNonCoprimes(self, nums: List[int]) -> List[int]:\\n        @lru_cache(None)\\n        def gcd(a, b):\\n            if b == 0:\\n                return a\\n            return gcd(b, a % b)\\n        \\n        @lru_cache(None)\\n        def lcm(a, b):\\n            return a * b // gcd(a, b)\\n        \\n        def divide(l, r):\\n            if l == r:\\n                return [nums[l]]\\n            m = (l + r) // 2\\n            left, right = divide(l, m), divide(m + 1, r)\\n            if gcd(left[-1], right[0]) == 1:\\n                return left + right\\n            t = lcm(left[-1], right[0])\\n            li, ri = len(left) - 2, 1\\n            while li >= 0 or ri < len(right):\\n                if li >= 0 and gcd(t, left[li]) != 1:\\n                    t = lcm(t, left[li])\\n                    li -= 1\\n                elif ri < len(right) and gcd(t, right[ri]) != 1:\\n                    t = lcm(t, right[ri])\\n                    ri += 1\\n                else:\\n                    break\\n            return left[:li + 1] + [t] + right[ri:]\\n        return divide(0, len(nums) - 1)    \\n```",
                "solutionTags": [
                    "Divide and Conquer"
                ],
                "code": "```\\nfrom functools import lru_cache\\n\\nclass Solution:\\n    def replaceNonCoprimes(self, nums: List[int]) -> List[int]:\\n        @lru_cache(None)\\n        def gcd(a, b):\\n            if b == 0:\\n                return a\\n            return gcd(b, a % b)\\n        \\n        @lru_cache(None)\\n        def lcm(a, b):\\n            return a * b // gcd(a, b)\\n        \\n        def divide(l, r):\\n            if l == r:\\n                return [nums[l]]\\n            m = (l + r) // 2\\n            left, right = divide(l, m), divide(m + 1, r)\\n            if gcd(left[-1], right[0]) == 1:\\n                return left + right\\n            t = lcm(left[-1], right[0])\\n            li, ri = len(left) - 2, 1\\n            while li >= 0 or ri < len(right):\\n                if li >= 0 and gcd(t, left[li]) != 1:\\n                    t = lcm(t, left[li])\\n                    li -= 1\\n                elif ri < len(right) and gcd(t, right[ri]) != 1:\\n                    t = lcm(t, right[ri])\\n                    ri += 1\\n                else:\\n                    break\\n            return left[:li + 1] + [t] + right[ri:]\\n        return divide(0, len(nums) - 1)    \\n```",
                "codeTag": "Java"
            },
            {
                "id": 1824818,
                "title": "easy-to-understand-java-code-using-stack",
                "content": "```    \\n\\tpublic List<Integer> replaceNonCoprimes(int[] nums) {\\n        List<Integer> res = new ArrayList<>();\\n        \\n        Stack<Integer> stack = new Stack<>();\\n        stack.push(nums[0]);\\n        for (int i = 1; i < nums.length; i++) {\\n            if (gcd(stack.peek(), nums[i]) > 1) {\\n                stack.push(lcm(stack.pop(), nums[i]));\\n                while (stack.size() >= 2) {\\n                    int a = stack.pop(), b = stack.pop();\\n                    if (gcd(a, b) > 1) {\\n                        stack.push(lcm(a, b));\\n                    } else {\\n                        stack.push(b);\\n                        stack.push(a);\\n                        break;\\n                    }\\n                }\\n            } else {\\n                stack.push(nums[i]);\\n            }\\n        }\\n        \\n        while (!stack.isEmpty()) {\\n            res.add(stack.pop());\\n        }\\n        Collections.reverse(res);\\n        \\n        return res;\\n    }\\n    \\n    private int lcm(int a, int b) {\\n        int min = Math.min(a, b);\\n        int max = Math.max(a, b);\\n        int res = max;\\n        \\n        while (res % min != 0) {\\n            res += max;\\n        }\\n        \\n        return res;\\n    }\\n    \\n    private int gcd(int a, int b) {\\n        if (a < b) {\\n            return gcd(b, a);\\n        }\\n        if (b == 0) {\\n            return a;\\n        }\\n        return gcd(b, a % b);\\n    }",
                "solutionTags": [
                    "Stack"
                ],
                "code": "```    \\n\\tpublic List<Integer> replaceNonCoprimes(int[] nums) {\\n        List<Integer> res = new ArrayList<>();\\n        \\n        Stack<Integer> stack = new Stack<>();\\n        stack.push(nums[0]);\\n        for (int i = 1; i < nums.length; i++) {\\n            if (gcd(stack.peek(), nums[i]) > 1) {\\n                stack.push(lcm(stack.pop(), nums[i]));\\n                while (stack.size() >= 2) {\\n                    int a = stack.pop(), b = stack.pop();\\n                    if (gcd(a, b) > 1) {\\n                        stack.push(lcm(a, b));\\n                    } else {\\n                        stack.push(b);\\n                        stack.push(a);\\n                        break;\\n                    }\\n                }\\n            } else {\\n                stack.push(nums[i]);\\n            }\\n        }\\n        \\n        while (!stack.isEmpty()) {\\n            res.add(stack.pop());\\n        }\\n        Collections.reverse(res);\\n        \\n        return res;\\n    }\\n    \\n    private int lcm(int a, int b) {\\n        int min = Math.min(a, b);\\n        int max = Math.max(a, b);\\n        int res = max;\\n        \\n        while (res % min != 0) {\\n            res += max;\\n        }\\n        \\n        return res;\\n    }\\n    \\n    private int gcd(int a, int b) {\\n        if (a < b) {\\n            return gcd(b, a);\\n        }\\n        if (b == 0) {\\n            return a;\\n        }\\n        return gcd(b, a % b);\\n    }",
                "codeTag": "Unknown"
            },
            {
                "id": 1824782,
                "title": "100-faster-c-different-optimization",
                "content": "```\\nclass Solution {\\npublic:\\n    vector<int> replaceNonCoprimes(vector<int>& nums) \\n    {\\n      int n = nums.size();  \\n      vector<int> result;\\n      result.push_back(nums[0]);   \\n      for(int i =1; i < n; ++i)\\n      {\\n        int last = result.back();\\n        int g = __gcd(nums[i], last);\\n        if(g > 1)\\n        {\\n           result.pop_back();\\n           int lcm = static_cast<long long>((static_cast<long long>(nums[i])*last))/g; \\n           result.push_back(lcm);\\n           while(result.size() > 1)\\n           {\\n             int a = result.back();\\n             int b = result[result.size()-2];\\n             int g_ = __gcd(a, b);\\n             if(g_ > 1)\\n             {\\n               result.pop_back(); result.pop_back();   \\n               int lcm_ = static_cast<long long>((static_cast<long long>(a)*b))/g_;    \\n               result.push_back(lcm_);    \\n             }\\n             else\\n             {\\n               break;  \\n             }    \\n           }    \\n        }\\n        else\\n        {\\n          result.push_back(nums[i]);    \\n        }    \\n      }\\n      return result;  \\n        \\n    }      \\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<int> replaceNonCoprimes(vector<int>& nums) \\n    {\\n      int n = nums.size();  \\n      vector<int> result;\\n      result.push_back(nums[0]);   \\n      for(int i =1; i < n; ++i)\\n      {\\n        int last = result.back();\\n        int g = __gcd(nums[i], last);\\n        if(g > 1)\\n        {\\n           result.pop_back();\\n           int lcm = static_cast<long long>((static_cast<long long>(nums[i])*last))/g; \\n           result.push_back(lcm);\\n           while(result.size() > 1)\\n           {\\n             int a = result.back();\\n             int b = result[result.size()-2];\\n             int g_ = __gcd(a, b);\\n             if(g_ > 1)\\n             {\\n               result.pop_back(); result.pop_back();   \\n               int lcm_ = static_cast<long long>((static_cast<long long>(a)*b))/g_;    \\n               result.push_back(lcm_);    \\n             }\\n             else\\n             {\\n               break;  \\n             }    \\n           }    \\n        }\\n        else\\n        {\\n          result.push_back(nums[i]);    \\n        }    \\n      }\\n      return result;  \\n        \\n    }      \\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1824724,
                "title": "simple-solution-in-java-100-faster-concise-code",
                "content": "```\\nclass Solution {\\n    public List<Integer> replaceNonCoprimes(int[] nums) {\\n        List<Integer> res = new ArrayList<>();\\n        \\n        for(int i=0; i<nums.length; i++){\\n            res.add(nums[i]);\\n            \\n            while(res.size() >= 2){\\n                int top = res.get(res.size() - 1);\\n                int num = res.get(res.size() - 2);\\n                \\n                int gcdNum = findGCD(top, num);\\n                if(gcdNum > 1){\\n                    long lcm = (long) top * num / gcdNum;\\n                    res.remove(res.size()-1);\\n                    res.remove(res.size()-1);\\n                    res.add((int)lcm);\\n                }else break;\\n            }\\n        }\\n        \\n        return res;\\n    }\\n    \\n    private int findGCD(int a, int b){\\n        return b != 0 ? findGCD(b, a%b) : a;\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    public List<Integer> replaceNonCoprimes(int[] nums) {\\n        List<Integer> res = new ArrayList<>();\\n        \\n        for(int i=0; i<nums.length; i++){\\n            res.add(nums[i]);\\n            \\n            while(res.size() >= 2){\\n                int top = res.get(res.size() - 1);\\n                int num = res.get(res.size() - 2);\\n                \\n                int gcdNum = findGCD(top, num);\\n                if(gcdNum > 1){\\n                    long lcm = (long) top * num / gcdNum;\\n                    res.remove(res.size()-1);\\n                    res.remove(res.size()-1);\\n                    res.add((int)lcm);\\n                }else break;\\n            }\\n        }\\n        \\n        return res;\\n    }\\n    \\n    private int findGCD(int a, int b){\\n        return b != 0 ? findGCD(b, a%b) : a;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1824674,
                "title": "monotonic-coprime-stack",
                "content": "Build a monotonic coprime stack.\\n\\nWhile non-coprime pairs in stack then update it until all the pairs in stack are coprime.\\n\\n``` py\\nclass Solution:\\n    def replaceNonCoprimes(self, A: List[int]) -> List[int]:\\n        def is_coprime(x, y): return gcd(x, y) == 1\\n        \\n        stk = []\\n        for x in A:\\n            while stk and not is_coprime(stk[-1], x):\\n                xx = lcm(stk.pop(), x)\\n                x = xx\\n            else: stk.append(x)\\n        return stk\\n```",
                "solutionTags": [
                    "Stack",
                    "Monotonic Stack"
                ],
                "code": "``` py\\nclass Solution:\\n    def replaceNonCoprimes(self, A: List[int]) -> List[int]:\\n        def is_coprime(x, y): return gcd(x, y) == 1\\n        \\n        stk = []\\n        for x in A:\\n            while stk and not is_coprime(stk[-1], x):\\n                xx = lcm(stk.pop(), x)\\n                x = xx\\n            else: stk.append(x)\\n        return stk\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1824603,
                "title": "easy-c-code-beginner-level",
                "content": "\\n\\n```\\nclass Solution {\\n        long long int gcd(long long int a, long long int b)\\n         {\\n             if(b == 0)\\n                 return a;\\n             return gcd(b, a%b);\\n         }\\n        long long int lcm(long long int a, long long int b)\\n         {\\n             long long int x = a;\\n             long long int y = b;\\n             long long int temp,gcd;\\n              while (b != 0)  \\n            {  \\n            temp = b;  \\n            b = a % b;  \\n            a = temp;  \\n            }\\n             gcd = a;\\n            long long int xy = (x*y)/gcd;\\n             return xy;\\n         }\\npublic:\\n    vector<int> replaceNonCoprimes(vector<int>& nums) {\\n        stack<int>st;\\n        int i=0;\\n        int zx = 0;\\n        while(i < nums.size())\\n        {\\n            if(zx == 0)\\n            {\\n                zx = nums[i];\\n            }\\n            if(st.empty())\\n            {\\n                st.push(zx);\\n                zx = 0;\\n                i++;\\n            }\\n            else\\n            {\\n                int xy = gcd(zx,st.top());\\n                if(xy > 1)\\n                {\\n                    int temp = lcm(zx, st.top());\\n                    st.pop();\\n                    zx = temp;\\n                    // st.push(temp);\\n                    //i++;\\n                }\\n                else\\n                {\\n                    st.push(zx);\\n                    zx = 0;\\n                    i++;\\n                }\\n            }\\n        }\\n        vector<int>ans;\\n        while(!st.empty())\\n        {\\n            ans.push_back(st.top());\\n            st.pop();\\n        }\\n        reverse(ans.begin(), ans.end());\\n        return ans;\\n        \\n    }\\n};\\n```",
                "solutionTags": [
                    "C",
                    "Stack"
                ],
                "code": "```\\nclass Solution {\\n        long long int gcd(long long int a, long long int b)\\n         {\\n             if(b == 0)\\n                 return a;\\n             return gcd(b, a%b);\\n         }\\n        long long int lcm(long long int a, long long int b)\\n         {\\n             long long int x = a;\\n             long long int y = b;\\n             long long int temp,gcd;\\n              while (b != 0)  \\n            {  \\n            temp = b;  \\n            b = a % b;  \\n            a = temp;  \\n            }\\n             gcd = a;\\n            long long int xy = (x*y)/gcd;\\n             return xy;\\n         }\\npublic:\\n    vector<int> replaceNonCoprimes(vector<int>& nums) {\\n        stack<int>st;\\n        int i=0;\\n        int zx = 0;\\n        while(i < nums.size())\\n        {\\n            if(zx == 0)\\n            {\\n                zx = nums[i];\\n            }\\n            if(st.empty())\\n            {\\n                st.push(zx);\\n                zx = 0;\\n                i++;\\n            }\\n            else\\n            {\\n                int xy = gcd(zx,st.top());\\n                if(xy > 1)\\n                {\\n                    int temp = lcm(zx, st.top());\\n                    st.pop();\\n                    zx = temp;\\n                    // st.push(temp);\\n                    //i++;\\n                }\\n                else\\n                {\\n                    st.push(zx);\\n                    zx = 0;\\n                    i++;\\n                }\\n            }\\n        }\\n        vector<int>ans;\\n        while(!st.empty())\\n        {\\n            ans.push_back(st.top());\\n            st.pop();\\n        }\\n        reverse(ans.begin(), ans.end());\\n        return ans;\\n        \\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1824571,
                "title": "linked-list-and-merge-sort-type-divide-and-conquer-approach",
                "content": "**Stack/Linked List based approach**\\n```\\nclass Solution {\\n    private int gcd(int a, int b){\\n        if (a > b) return gcd(b,a);\\n        if (a == 0) return b;\\n        return gcd(b%a,a);\\n    }\\n    \\n    public List<Integer> replaceNonCoprimes(int[] nums) {\\n       LinkedList<Integer> linkedList = new LinkedList<>();\\n        for (int x : nums){\\n            int currLcm = x;\\n            while (!linkedList.isEmpty()){\\n                int g = gcd(linkedList.peekLast(), currLcm);\\n                if (g == 1) break;\\n                currLcm = (currLcm/g)*linkedList.removeLast();\\n            }\\n            linkedList.add(currLcm);\\n        }\\n        return linkedList;\\n    }\\n}\\n```\\n\\nAlthough the linkedList/Stack based solution is smaller in code, I found the divide and conquer approach more intuitive as it is very similar to merge sort.\\n\\n**Divide And Conquer approach**\\n1. Divide: Divide the list into two halves and solve each half recursively\\n2. Conquer: Merge the lists obtained from recursive calls.\\n\\n```\\n    private List<Integer> divideAndConquer(List<Integer> list){\\n        // base case\\n        if (list.size() <= 1) return list;\\n        \\n        // divide part\\n        int size = list.size();\\n        int mid = (size-1)/2;\\n        List<Integer> leftList = divideAndConquer(list.subList(0,mid+1));\\n        List<Integer> rightList = divideAndConquer(list.subList(mid+1, size));\\n        \\n        //conquer and return\\n        return conquer(leftList, rightList);\\n        \\n    }\\n```\\n\\n**Conquer implementation**\\n ```leftLast``` -> last element of leftList\\n```rightFirst``` -> first element of rightList\\nSince we already solved the left half and right half, new pairs can only be merged if ```leftLast``` and ```rightFirst``` are not coprimes.\\n ```if gcd(leftLast,rightFirst) != 1```  we compute their lcm. We scan the ```leftList``` backwards and ```rightList``` forward to check for more merges with this lcm and update the lcm as we scan.\\n We stop when the lcm is not updated or have exhausted the left and right pointers.\\n \\n\\n```\\n    private List<Integer> conquer(List<Integer> leftList, List<Integer> rightList){\\n        assert !leftList.isEmpty() && !rightList.isEmpty();\\n            \\n        int leftLast = leftList.get(leftList.size()-1);\\n        int rightFirst = rightList.get(0);\\n    \\n        List<Integer> mergedList = new ArrayList<>();\\n        if (gcd(leftLast,rightFirst) == 1){\\n            mergedList.addAll(leftList);\\n            mergedList.addAll(rightList);\\n            return mergedList;\\n        }\\n        \\n        \\n        int currLcm = lcm(leftLast,rightFirst);\\n        int leftPtr = leftList.size()-2;\\n        int rightPtr = 1;\\n        \\n        while (leftPtr >=  0 || rightPtr < rightList.size()){\\n            \\n           boolean isLcmUpdated = false;\\n           \\n            if (leftPtr >= 0 && gcd(leftList.get(leftPtr), currLcm) != 1){\\n              currLcm = lcm(currLcm, leftList.get(leftPtr));\\n              leftPtr--;\\n              isLcmUpdated = true;\\n           }\\n            \\n           if (rightPtr < rightList.size() && gcd(rightList.get(rightPtr), currLcm) != 1){\\n               currLcm = lcm(currLcm, rightList.get(rightPtr));\\n               rightPtr++;\\n               isLcmUpdated = true;\\n           }\\n           \\n           if (!isLcmUpdated) break;\\n        }\\n        \\n        // add everthing until the current position of leftPtr\\n        mergedList.addAll(leftList.subList(0, leftPtr+1));\\n        \\n        // add the lcm\\n        mergedList.add(currLcm);\\n        \\n        // add everything from and after the current position of rightPtr\\n        mergedList.addAll(rightList.subList(rightPtr, rightList.size()));\\n        \\n        return mergedList;\\n    }\\n```\\n\\n\\nTime Complexity:\\nThe recursive structure is very similar to merge sort namely,  Two recursive calls and O(n) work outside the recursive calls (For conquer Step) so the time complexity is O(nlogn)\\n\\n\\n**Full Divide And Conquer code for reference**\\n\\n```\\nclass Solution {\\n    private int gcd(int a, int b){\\n        if (a > b) return gcd(b,a);\\n        if (a == 0) return b;\\n        return gcd(b%a,a);\\n    }\\n    private int lcm(int a, int b){\\n        int g = gcd(a,b);\\n        return (a/g)*b;\\n    }\\n   \\n    \\n    private List<Integer> conquer(List<Integer> leftList, List<Integer> rightList){\\n        assert !leftList.isEmpty() && !rightList.isEmpty();\\n            \\n        int leftLast = leftList.get(leftList.size()-1);\\n        int rightFirst = rightList.get(0);\\n    \\n        List<Integer> mergedList = new ArrayList<>();\\n        if (gcd(leftLast,rightFirst) == 1){\\n            mergedList.addAll(leftList);\\n            mergedList.addAll(rightList);\\n            return mergedList;\\n        }\\n        \\n        \\n        int currLcm = lcm(leftLast,rightFirst);\\n        int leftPtr = leftList.size()-2;\\n        int rightPtr = 1;\\n        \\n        while (leftPtr >=  0 || rightPtr < rightList.size()){\\n            \\n           boolean isLcmUpdated = false;\\n           \\n            if (leftPtr >= 0 && gcd(leftList.get(leftPtr), currLcm) != 1){\\n              currLcm = lcm(currLcm, leftList.get(leftPtr));\\n              leftPtr--;\\n              isLcmUpdated = true;\\n           }\\n            \\n           if (rightPtr < rightList.size() && gcd(rightList.get(rightPtr), currLcm) != 1){\\n               currLcm = lcm(currLcm, rightList.get(rightPtr));\\n               rightPtr++;\\n               isLcmUpdated = true;\\n           }\\n           \\n           if (!isLcmUpdated) break;\\n        }\\n        \\n        // add everthing until the current position of leftPtr\\n        mergedList.addAll(leftList.subList(0, leftPtr+1));\\n        \\n        // add the lcm\\n        mergedList.add(currLcm);\\n        \\n        // add everything from and after the current position of rightPtr\\n        mergedList.addAll(rightList.subList(rightPtr, rightList.size()));\\n        \\n        return mergedList;\\n    }\\n    \\n    private List<Integer> divideAndConquer(List<Integer> list){\\n        // base case\\n        if (list.size() <= 1) return list;\\n        \\n        // divide part\\n        int size = list.size();\\n        int mid = (size-1)/2;\\n        List<Integer> leftList = divideAndConquer(list.subList(0,mid+1));\\n        List<Integer> rightList = divideAndConquer(list.subList(mid+1, size));\\n        \\n        //conquer and return\\n        return conquer(leftList, rightList);\\n        \\n    }\\n    \\n    \\n    public List<Integer> replaceNonCoprimes(int[] nums) {\\n        List<Integer> list = new ArrayList<>();\\n        for (int x : nums) list.add(x);\\n        return divideAndConquer(list);\\n        \\n    }\\n}\\n```\\n\\t",
                "solutionTags": [
                    "Divide and Conquer"
                ],
                "code": "```\\nclass Solution {\\n    private int gcd(int a, int b){\\n        if (a > b) return gcd(b,a);\\n        if (a == 0) return b;\\n        return gcd(b%a,a);\\n    }\\n    \\n    public List<Integer> replaceNonCoprimes(int[] nums) {\\n       LinkedList<Integer> linkedList = new LinkedList<>();\\n        for (int x : nums){\\n            int currLcm = x;\\n            while (!linkedList.isEmpty()){\\n                int g = gcd(linkedList.peekLast(), currLcm);\\n                if (g == 1) break;\\n                currLcm = (currLcm/g)*linkedList.removeLast();\\n            }\\n            linkedList.add(currLcm);\\n        }\\n        return linkedList;\\n    }\\n}\\n```\n```\\n    private List<Integer> divideAndConquer(List<Integer> list){\\n        // base case\\n        if (list.size() <= 1) return list;\\n        \\n        // divide part\\n        int size = list.size();\\n        int mid = (size-1)/2;\\n        List<Integer> leftList = divideAndConquer(list.subList(0,mid+1));\\n        List<Integer> rightList = divideAndConquer(list.subList(mid+1, size));\\n        \\n        //conquer and return\\n        return conquer(leftList, rightList);\\n        \\n    }\\n```\n```leftLast```\n```rightFirst```\n```leftLast```\n```rightFirst```\n```if gcd(leftLast,rightFirst) != 1```\n```leftList```\n```rightList```\n```\\n    private List<Integer> conquer(List<Integer> leftList, List<Integer> rightList){\\n        assert !leftList.isEmpty() && !rightList.isEmpty();\\n            \\n        int leftLast = leftList.get(leftList.size()-1);\\n        int rightFirst = rightList.get(0);\\n    \\n        List<Integer> mergedList = new ArrayList<>();\\n        if (gcd(leftLast,rightFirst) == 1){\\n            mergedList.addAll(leftList);\\n            mergedList.addAll(rightList);\\n            return mergedList;\\n        }\\n        \\n        \\n        int currLcm = lcm(leftLast,rightFirst);\\n        int leftPtr = leftList.size()-2;\\n        int rightPtr = 1;\\n        \\n        while (leftPtr >=  0 || rightPtr < rightList.size()){\\n            \\n           boolean isLcmUpdated = false;\\n           \\n            if (leftPtr >= 0 && gcd(leftList.get(leftPtr), currLcm) != 1){\\n              currLcm = lcm(currLcm, leftList.get(leftPtr));\\n              leftPtr--;\\n              isLcmUpdated = true;\\n           }\\n            \\n           if (rightPtr < rightList.size() && gcd(rightList.get(rightPtr), currLcm) != 1){\\n               currLcm = lcm(currLcm, rightList.get(rightPtr));\\n               rightPtr++;\\n               isLcmUpdated = true;\\n           }\\n           \\n           if (!isLcmUpdated) break;\\n        }\\n        \\n        // add everthing until the current position of leftPtr\\n        mergedList.addAll(leftList.subList(0, leftPtr+1));\\n        \\n        // add the lcm\\n        mergedList.add(currLcm);\\n        \\n        // add everything from and after the current position of rightPtr\\n        mergedList.addAll(rightList.subList(rightPtr, rightList.size()));\\n        \\n        return mergedList;\\n    }\\n```\n```\\nclass Solution {\\n    private int gcd(int a, int b){\\n        if (a > b) return gcd(b,a);\\n        if (a == 0) return b;\\n        return gcd(b%a,a);\\n    }\\n    private int lcm(int a, int b){\\n        int g = gcd(a,b);\\n        return (a/g)*b;\\n    }\\n   \\n    \\n    private List<Integer> conquer(List<Integer> leftList, List<Integer> rightList){\\n        assert !leftList.isEmpty() && !rightList.isEmpty();\\n            \\n        int leftLast = leftList.get(leftList.size()-1);\\n        int rightFirst = rightList.get(0);\\n    \\n        List<Integer> mergedList = new ArrayList<>();\\n        if (gcd(leftLast,rightFirst) == 1){\\n            mergedList.addAll(leftList);\\n            mergedList.addAll(rightList);\\n            return mergedList;\\n        }\\n        \\n        \\n        int currLcm = lcm(leftLast,rightFirst);\\n        int leftPtr = leftList.size()-2;\\n        int rightPtr = 1;\\n        \\n        while (leftPtr >=  0 || rightPtr < rightList.size()){\\n            \\n           boolean isLcmUpdated = false;\\n           \\n            if (leftPtr >= 0 && gcd(leftList.get(leftPtr), currLcm) != 1){\\n              currLcm = lcm(currLcm, leftList.get(leftPtr));\\n              leftPtr--;\\n              isLcmUpdated = true;\\n           }\\n            \\n           if (rightPtr < rightList.size() && gcd(rightList.get(rightPtr), currLcm) != 1){\\n               currLcm = lcm(currLcm, rightList.get(rightPtr));\\n               rightPtr++;\\n               isLcmUpdated = true;\\n           }\\n           \\n           if (!isLcmUpdated) break;\\n        }\\n        \\n        // add everthing until the current position of leftPtr\\n        mergedList.addAll(leftList.subList(0, leftPtr+1));\\n        \\n        // add the lcm\\n        mergedList.add(currLcm);\\n        \\n        // add everything from and after the current position of rightPtr\\n        mergedList.addAll(rightList.subList(rightPtr, rightList.size()));\\n        \\n        return mergedList;\\n    }\\n    \\n    private List<Integer> divideAndConquer(List<Integer> list){\\n        // base case\\n        if (list.size() <= 1) return list;\\n        \\n        // divide part\\n        int size = list.size();\\n        int mid = (size-1)/2;\\n        List<Integer> leftList = divideAndConquer(list.subList(0,mid+1));\\n        List<Integer> rightList = divideAndConquer(list.subList(mid+1, size));\\n        \\n        //conquer and return\\n        return conquer(leftList, rightList);\\n        \\n    }\\n    \\n    \\n    public List<Integer> replaceNonCoprimes(int[] nums) {\\n        List<Integer> list = new ArrayList<>();\\n        for (int x : nums) list.add(x);\\n        return divideAndConquer(list);\\n        \\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1824462,
                "title": "c-stack-implementation-clean-and-concise",
                "content": "```\\nclass Solution {\\npublic:\\n    vector<int> replaceNonCoprimes(vector<int>& nums) {\\n        vector<int>ans;\\n        \\n        for(auto  i:nums)\\n        {\\n            ans.push_back(i);\\n            while(ans.size()>=2)\\n            {\\n                \\n                int n=ans.size();\\n                long long int p1=ans[n-1];\\n                long long int p2=ans[n-2];\\n                int k=__gcd(p1,p2);\\n                \\n                if(k==1)\\n                    break;\\n                \\n                ans.pop_back();\\n                ans.pop_back();\\n                \\n                int lcm=(p1*p2)/k;\\n                ans.push_back(lcm);\\n                \\n                //cout<<p1<<\" \"<<p2<<\" \"<<lcm<<endl;\\n            }\\n        }\\n        return ans;\\n    }\\n};\\n\\n```\\n**Pls upvote the solution if you found helpful, it means a lot.\\nAlso comment down your doubts.\\nHappy Coding : )**\\n",
                "solutionTags": [
                    "C++",
                    "C",
                    "Math",
                    "Stack"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<int> replaceNonCoprimes(vector<int>& nums) {\\n        vector<int>ans;\\n        \\n        for(auto  i:nums)\\n        {\\n            ans.push_back(i);\\n            while(ans.size()>=2)\\n            {\\n                \\n                int n=ans.size();\\n                long long int p1=ans[n-1];\\n                long long int p2=ans[n-2];\\n                int k=__gcd(p1,p2);\\n                \\n                if(k==1)\\n                    break;\\n                \\n                ans.pop_back();\\n                ans.pop_back();\\n                \\n                int lcm=(p1*p2)/k;\\n                ans.push_back(lcm);\\n                \\n                //cout<<p1<<\" \"<<p2<<\" \"<<lcm<<endl;\\n            }\\n        }\\n        return ans;\\n    }\\n};\\n\\n```",
                "codeTag": "C++"
            },
            {
                "id": 1824407,
                "title": "python-3-doubly-linked-list-explanation",
                "content": "### Explanation\\n- Pretty much brute force with help of Doubly Linked List \\n- Use LinkedList since remove from list is slow `O(N)`\\n- Btw, the stack solution is way better. Ignore this if you want a faster solution.\\n### Implementation\\n```\\nclass ListNode:\\n    def __init__(self, val):\\n        self.val = val\\n        self.prev = self.next = None\\n        \\nclass Solution:\\n    def replaceNonCoprimes(self, nums: List[int]) -> List[int]:\\n        prev = cur = root = ListNode(int(1e9+7))\\n        for num in nums:\\n            cur = ListNode(num)\\n            cur.prev = prev\\n            prev.next = cur\\n            prev = cur\\n        prev, cur = root.next, root.next.next\\n        while cur:\\n            tmp = gcd(cur.val, prev.val)\\n            if tmp > 1:    \\n                lcm_node = ListNode(cur.val * prev.val // tmp)\\n                prev.prev.next = lcm_node\\n                lcm_node.prev = prev.prev\\n                lcm_node.next = cur.next\\n                if cur.next:\\n                    cur.next.prev = lcm_node\\n                cur.prev = cur.next = prev.prev = prev.next = None    \\n                prev, cur = lcm_node.prev, lcm_node\\n            else:    \\n                head, prev, cur = prev, cur, cur.next\\n        ans, root = [], root.next\\n        while root:\\n            ans.append(root.val)\\n            root = root.next\\n        return ans\\n```",
                "solutionTags": [
                    "Python",
                    "Python3",
                    "Linked List",
                    "Doubly-Linked List"
                ],
                "code": "```\\nclass ListNode:\\n    def __init__(self, val):\\n        self.val = val\\n        self.prev = self.next = None\\n        \\nclass Solution:\\n    def replaceNonCoprimes(self, nums: List[int]) -> List[int]:\\n        prev = cur = root = ListNode(int(1e9+7))\\n        for num in nums:\\n            cur = ListNode(num)\\n            cur.prev = prev\\n            prev.next = cur\\n            prev = cur\\n        prev, cur = root.next, root.next.next\\n        while cur:\\n            tmp = gcd(cur.val, prev.val)\\n            if tmp > 1:    \\n                lcm_node = ListNode(cur.val * prev.val // tmp)\\n                prev.prev.next = lcm_node\\n                lcm_node.prev = prev.prev\\n                lcm_node.next = cur.next\\n                if cur.next:\\n                    cur.next.prev = lcm_node\\n                cur.prev = cur.next = prev.prev = prev.next = None    \\n                prev, cur = lcm_node.prev, lcm_node\\n            else:    \\n                head, prev, cur = prev, cur, cur.next\\n        ans, root = [], root.next\\n        while root:\\n            ans.append(root.val)\\n            root = root.next\\n        return ans\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1824378,
                "title": "c-greedy-let-s-do-something-readable",
                "content": "The key point is you can merge adjacent non-co-prime as many as  as possible, in essence it\\'s an gready algorithm. \\n```\\n\\tvector<int> replaceNonCoprimes(vector<int>& nums) {\\n        vector<int> res;\\n        for (auto i : nums) {\\n            res.push_back(i);\\n            while(res.size() > 1) {\\n                auto last = res.back();\\n                auto penultimate = res[res.size()-2];\\n                if (gcd(last,pre) > 1) {\\n                    res.pop_back();\\n                    res.pop_back();\\n                    res.push_back(lcm(last,penultimate));\\n                }\\n                else break;\\n            }\\n        }\\n        return res;\\n    }\\n```",
                "solutionTags": [],
                "code": "```\\n\\tvector<int> replaceNonCoprimes(vector<int>& nums) {\\n        vector<int> res;\\n        for (auto i : nums) {\\n            res.push_back(i);\\n            while(res.size() > 1) {\\n                auto last = res.back();\\n                auto penultimate = res[res.size()-2];\\n                if (gcd(last,pre) > 1) {\\n                    res.pop_back();\\n                    res.pop_back();\\n                    res.push_back(lcm(last,penultimate));\\n                }\\n                else break;\\n            }\\n        }\\n        return res;\\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1824363,
                "title": "python-3-recursive-deque-solution",
                "content": "I feel like cheating doing it in Python, cuz we can import gcd and lcm from math.\\n```\\nclass Solution:\\n    def replaceNonCoprimes(self, nums: List[int]) -> List[int]:\\n        from math import gcd, lcm\\n        l = collections.deque(nums)\\n        \\n        def proc(l, i):\\n            if i >= len(l):\\n                return\\n            if i + 1 < len(l):\\n                if gcd(l[i], l[i + 1]) > 1: # non-coprime\\n                    l[i] = lcm(l[i], l[i + 1])\\n                    del l[i + 1]\\n                    proc(l, max(0, i - 1))\\n                else:\\n                    proc(l, i + 1)\\n        \\n        proc(l, 0)\\n        \\n        return list(l)\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution:\\n    def replaceNonCoprimes(self, nums: List[int]) -> List[int]:\\n        from math import gcd, lcm\\n        l = collections.deque(nums)\\n        \\n        def proc(l, i):\\n            if i >= len(l):\\n                return\\n            if i + 1 < len(l):\\n                if gcd(l[i], l[i + 1]) > 1: # non-coprime\\n                    l[i] = lcm(l[i], l[i + 1])\\n                    del l[i + 1]\\n                    proc(l, max(0, i - 1))\\n                else:\\n                    proc(l, i + 1)\\n        \\n        proc(l, 0)\\n        \\n        return list(l)\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1824359,
                "title": "c-69-71-cases-passing-getting-tle-can-anyone-optimise",
                "content": "```\\nvector<int> replaceNonCoprimes(vector<int>& nums) {\\n        int a,b;\\n        int flag=1;\\n        \\n        //flag indicates atleast one replacement is done, if not come out of loop\\n        while(flag){\\n            flag=0;\\n            \\n            a=0;\\n            //check where nums[a] is non zero and start from there\\n            while(!nums[a]) a++;\\n            //main logic\\n            for(int i=a+1;i<nums.size();i++){\\n                if(nums[i]>0){\\n                    b=i;\\n                    if(gcd(nums[a],nums[b])>1){\\n                        nums[b]=lcm(nums[b],nums[a]);\\n                        nums[a]=0;\\n                        flag=1;\\n                    }\\n                    a=b;\\n                }\\n            }\\n        }\\n        \\n        //storing in vector\\n        vector<int> vect;\\n        \\n        for(int i=0;i<nums.size();i++){\\n            if(nums[i]>0){\\n                vect.push_back(nums[i]);\\n            }\\n            \\n        }\\n        \\n        return vect;\\n        \\n           \\n        \\n    }\\n```\\n",
                "solutionTags": [
                    "C++",
                    "C"
                ],
                "code": "```\\nvector<int> replaceNonCoprimes(vector<int>& nums) {\\n        int a,b;\\n        int flag=1;\\n        \\n        //flag indicates atleast one replacement is done, if not come out of loop\\n        while(flag){\\n            flag=0;\\n            \\n            a=0;\\n            //check where nums[a] is non zero and start from there\\n            while(!nums[a]) a++;\\n            //main logic\\n            for(int i=a+1;i<nums.size();i++){\\n                if(nums[i]>0){\\n                    b=i;\\n                    if(gcd(nums[a],nums[b])>1){\\n                        nums[b]=lcm(nums[b],nums[a]);\\n                        nums[a]=0;\\n                        flag=1;\\n                    }\\n                    a=b;\\n                }\\n            }\\n        }\\n        \\n        //storing in vector\\n        vector<int> vect;\\n        \\n        for(int i=0;i<nums.size();i++){\\n            if(nums[i]>0){\\n                vect.push_back(nums[i]);\\n            }\\n            \\n        }\\n        \\n        return vect;\\n        \\n           \\n        \\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1824358,
                "title": "use-of-stack-cpp-easy-to-understand",
                "content": "```\\nvector<int> replaceNonCoprimes(vector<int>& nums) {\\n        \\n        if(nums.size()<2)\\n            return nums;\\n        vector<int>v;\\n        stack<int>st;\\n        for(int i=0;i<nums.size();i++)\\n        {\\n            \\n            while(!st.empty() and __gcd(st.top(),nums[i])>1)\\n            {\\n                nums[i]=lcm(st.top(),nums[i]);\\n                \\n                st.pop();\\n                \\n                \\n            }\\n            \\n            st.push(nums[i]);\\n                 \\n        }\\n        \\n        while(!st.empty())\\n        {\\n            v.push_back(st.top());\\n            st.pop();\\n        }\\n        \\n        reverse(v.begin(),v.end());\\n        return v;       \\n    }\\n};\\n\\n\\n",
                "solutionTags": [],
                "code": "```\\nvector<int> replaceNonCoprimes(vector<int>& nums) {\\n        \\n        if(nums.size()<2)\\n            return nums;\\n        vector<int>v;\\n        stack<int>st;\\n        for(int i=0;i<nums.size();i++)\\n        {\\n            \\n            while(!st.empty() and __gcd(st.top(),nums[i])>1)\\n            {\\n                nums[i]=lcm(st.top(),nums[i]);\\n                \\n                st.pop();\\n                \\n                \\n            }\\n            \\n            st.push(nums[i]);\\n                 \\n        }\\n        \\n        while(!st.empty())\\n        {\\n            v.push_back(st.top());\\n            st.pop();\\n        }\\n        \\n        reverse(v.begin(),v.end());\\n        return v;       \\n    }\\n};\\n\\n\\n",
                "codeTag": "Unknown"
            },
            {
                "id": 1824343,
                "title": "python3-8lines-solution-with-stack",
                "content": "```\\n    def replaceNonCoprimes(self, nums: List[int]) -> List[int]:\\n        nums, ans = deque(nums), []\\n        while nums:\\n            ans.append(nums.popleft())\\n            while len(ans) > 1:\\n                if gcd(ans[-1], ans[-2]) > 1: ans.append(lcm(ans.pop(), ans.pop()))\\n                else: break\\n        return ans\\n```\\n        \\n",
                "solutionTags": [
                    "Python",
                    "Python3",
                    "Stack"
                ],
                "code": "```\\n    def replaceNonCoprimes(self, nums: List[int]) -> List[int]:\\n        nums, ans = deque(nums), []\\n        while nums:\\n            ans.append(nums.popleft())\\n            while len(ans) > 1:\\n                if gcd(ans[-1], ans[-2]) > 1: ans.append(lcm(ans.pop(), ans.pop()))\\n                else: break\\n        return ans\\n```",
                "codeTag": "Python3"
            },
            {
                "id": 1824285,
                "title": "javascript-stack-gcd-398ms",
                "content": "```\\nconst gcd = (a, b) => b == 0 ? a : gcd(b, a % b);\\n\\nconst replaceNonCoprimes = (a) => {\\n    let st = [];\\n    for (let x of a) {\\n        if (st.length == 0) {\\n            st.push(x);\\n        } else {\\n            while (st.length && gcd(st[st.length - 1], x) != 1) { // check if it can be merged with the value to its left\\n                let last = st.pop(), g = gcd(x, last);\\n                x = x / g * last;  // merge value, update lcm to x\\n            }\\n            st.push(x);\\n        }\\n    }\\n    return st;\\n};\\n```",
                "solutionTags": [
                    "JavaScript",
                    "Math",
                    "Stack"
                ],
                "code": "```\\nconst gcd = (a, b) => b == 0 ? a : gcd(b, a % b);\\n\\nconst replaceNonCoprimes = (a) => {\\n    let st = [];\\n    for (let x of a) {\\n        if (st.length == 0) {\\n            st.push(x);\\n        } else {\\n            while (st.length && gcd(st[st.length - 1], x) != 1) { // check if it can be merged with the value to its left\\n                let last = st.pop(), g = gcd(x, last);\\n                x = x / g * last;  // merge value, update lcm to x\\n            }\\n            st.push(x);\\n        }\\n    }\\n    return st;\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1824282,
                "title": "java-stack-solution",
                "content": "```\\nclass Solution {\\n    public int gcd(int m, int n){\\n        if(m < n) return gcd(n, m); \\n        int tmp = 0;\\n        while (n != 0) {\\n            tmp = m % n;\\n            m = n;\\n            n = tmp;\\n        }\\n        return m;\\n    }\\n    \\n\\n    public int lcm(int n1, int n2) {\\n        if(n1 == n2) return n1;\\n        return n1 / gcd(n1, n2) * n2;\\n    }\\n\\n    public List<Integer> replaceNonCoprimes(int[] nums) {\\n        Stack<Integer> stack = new Stack<>();\\n        for(int i = 0; i < nums.length; i++){\\n            if(stack.empty()){\\n                stack.push(nums[i]);\\n            }else{\\n                while(stack.size() > 0){\\n                    int top = stack.peek();\\n                     if(gcd(top, nums[i]) == 1){\\n                        break;                             \\n                     }else{\\n                         nums[i] = lcm(stack.pop(), nums[i]);\\n                     }\\n                }\\n                stack.push(nums[i]);\\n            }\\n        }\\n        return stack.stream().toList();\\n\\n    }\\n}\\n```",
                "solutionTags": [
                    "Stack"
                ],
                "code": "```\\nclass Solution {\\n    public int gcd(int m, int n){\\n        if(m < n) return gcd(n, m); \\n        int tmp = 0;\\n        while (n != 0) {\\n            tmp = m % n;\\n            m = n;\\n            n = tmp;\\n        }\\n        return m;\\n    }\\n    \\n\\n    public int lcm(int n1, int n2) {\\n        if(n1 == n2) return n1;\\n        return n1 / gcd(n1, n2) * n2;\\n    }\\n\\n    public List<Integer> replaceNonCoprimes(int[] nums) {\\n        Stack<Integer> stack = new Stack<>();\\n        for(int i = 0; i < nums.length; i++){\\n            if(stack.empty()){\\n                stack.push(nums[i]);\\n            }else{\\n                while(stack.size() > 0){\\n                    int top = stack.peek();\\n                     if(gcd(top, nums[i]) == 1){\\n                        break;                             \\n                     }else{\\n                         nums[i] = lcm(stack.pop(), nums[i]);\\n                     }\\n                }\\n                stack.push(nums[i]);\\n            }\\n        }\\n        return stack.stream().toList();\\n\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1824245,
                "title": "c-180ms",
                "content": "```c++\\n vector<int> replaceNonCoprimes(vector<int> &nums) {\\n    int n = nums.size();\\n    vector<int> ret;\\n    ret.reserve(n);\\n    for (int i = 0; i < n; ++i) {\\n      if (ret.empty()) {\\n        ret.push_back(nums[i]);\\n        continue;\\n      }\\n      int a = ret.back();\\n      int b = nums[i];\\n      if (gcd(a, b) == 1) {\\n        ret.push_back(b);\\n      } else {\\n        ret.pop_back();\\n        nums[i] = lcm(a, b);\\n        --i;\\n      }\\n    }\\n    return ret;\\n  }\\n```",
                "solutionTags": [],
                "code": "```c++\\n vector<int> replaceNonCoprimes(vector<int> &nums) {\\n    int n = nums.size();\\n    vector<int> ret;\\n    ret.reserve(n);\\n    for (int i = 0; i < n; ++i) {\\n      if (ret.empty()) {\\n        ret.push_back(nums[i]);\\n        continue;\\n      }\\n      int a = ret.back();\\n      int b = nums[i];\\n      if (gcd(a, b) == 1) {\\n        ret.push_back(b);\\n      } else {\\n        ret.pop_back();\\n        nums[i] = lcm(a, b);\\n        --i;\\n      }\\n    }\\n    return ret;\\n  }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1824222,
                "title": "stack-one-pass-keep-popping-until-gcd-1",
                "content": "Space and time complexity are both O(N)\\n```\\ns = []\\nfor n in nums:\\n\\twhile s and gcd(s[-1], n) > 1:\\n\\t\\tprev = s.pop()\\n\\t\\tn = lcm(n, prev)\\n\\ts.append(n)\\n\\nreturn s\\n```\\nbtw Q2 is harder than Q1, Q3, Q4 combined...",
                "solutionTags": [],
                "code": "```\\ns = []\\nfor n in nums:\\n\\twhile s and gcd(s[-1], n) > 1:\\n\\t\\tprev = s.pop()\\n\\t\\tn = lcm(n, prev)\\n\\ts.append(n)\\n\\nreturn s\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1824215,
                "title": "python-stack-solution",
                "content": "```\\nclass Solution:\\n    def replaceNonCoprimes(self, nums: List[int]) -> List[int]:\\n        def gcd(a, b):\\n            if b == 0:\\n                return a\\n            \\n            return gcd(b, a%b)\\n        \\n        def lcm(a, b):\\n            return (a*b)//gcd(a,b)\\n        \\n       \\n        st = []\\n        for n in nums:\\n            st.append(n)\\n            while len(st) > 1 and gcd(st[-1], st[-2]) > 1:\\n                x = st.pop()\\n                y = st.pop()\\n                st.append(lcm(x,y))\\n        \\n        return st\\n```",
                "solutionTags": [
                    "Python",
                    "Stack"
                ],
                "code": "```\\nclass Solution:\\n    def replaceNonCoprimes(self, nums: List[int]) -> List[int]:\\n        def gcd(a, b):\\n            if b == 0:\\n                return a\\n            \\n            return gcd(b, a%b)\\n        \\n        def lcm(a, b):\\n            return (a*b)//gcd(a,b)\\n        \\n       \\n        st = []\\n        for n in nums:\\n            st.append(n)\\n            while len(st) > 1 and gcd(st[-1], st[-2]) > 1:\\n                x = st.pop()\\n                y = st.pop()\\n                st.append(lcm(x,y))\\n        \\n        return st\\n```",
                "codeTag": "Java"
            }
        ],
        "discussions": [
            {
                "id": 1576490,
                "content": [
                    {
                        "username": "Hamzawy",
                        "content": "It is stated in the problem that:\\n**It can be shown that replacing adjacent non-coprime numbers in any arbitrary order will lead to the same result.**\\nCan anyone prove why the result array will be always the same regardless of the operations\\' ordering ? \\n"
                    },
                    {
                        "username": "senthilPalanisamy",
                        "content": "One way to prove this is as follows - lets turn the problem into a graph problem. Each element in the array is connected to the next element and / or previous element, if there are not coprime. So you can imagine the array being transformed into a set of disconnected graphs. One operation of finding two elements and replacing it by their lcm on the array is equivalent to find any two nodes in any sub-graph and replacing it by their lcm. The new node will maintain its place in the graph since it will not be coprime with its predecessor or successor by definition. The termination point of the algorithm is when each subgraph is squeezed into a single node. Regardsless of the order you choose elements, the final node in the squeezed graph will be the lcm of all the nodes in the graph. Once the numbers are squeezed, you can put them back in the array in successive positions to get the array view. This way, it can be proved that regardless of the order you choose, the number of elements in the final graph is the number of disconnected subgraphs in the first array, the final result from each graph will be the lcm of all the elements it contains, the order in which they appear in the array is the order in which we discovered those disconnected subgraphs when moving left to right."
                    },
                    {
                        "username": "bedmuthaapoorv",
                        "content": "2 tips:\\n1. implement gcd efficiently\\n2. lcm(a,b)*gcd(a,b)=a*b"
                    },
                    {
                        "username": "bedmuthaapoorv",
                        "content": "Uber asked this very question in their OA\\n"
                    },
                    {
                        "username": "Furies",
                        "content": "I hate this problem. The core algorithm is not difficult to figure out, but I wasted an hour or two trying to figure out:\\n- the most effective way to calculate gcd and lcm.\\n- dealing with some obscure integer overlow\\n"
                    },
                    {
                        "username": "CODEX47",
                        "content": "Just a implementation question."
                    },
                    {
                        "username": "bantikumar",
                        "content": "This code is failed for this [31,97561,97561,97561,97561,97561,97561,97561,97561] testcase\\npublic List<Integer> replaceNonCoprimes(int[] nums) {\\n        ArrayList<Integer> ans=new ArrayList<>();\\n        for(int i=0; i<nums.length; i++)\\n              ans.add(nums[i]);\\n        int i=0;\\n        while(i<ans.size()-1)\\n        {\\n            int r=i;\\n            int hcf=gcd(ans.get(i), ans.get(r+1));\\n            if(hcf!=1)\\n            {\\n                \\n                ans.set(i, (int)(ans.get(i)*1L*ans.get(r+1))/hcf);\\n                ans.remove(r+1);\\n            }\\n            else\\n             i++;\\n        }   \\n        return ans;   \\n    }"
                    }
                ]
            },
            {
                "id": 2010050,
                "content": [
                    {
                        "username": "Hamzawy",
                        "content": "It is stated in the problem that:\\n**It can be shown that replacing adjacent non-coprime numbers in any arbitrary order will lead to the same result.**\\nCan anyone prove why the result array will be always the same regardless of the operations\\' ordering ? \\n"
                    },
                    {
                        "username": "senthilPalanisamy",
                        "content": "One way to prove this is as follows - lets turn the problem into a graph problem. Each element in the array is connected to the next element and / or previous element, if there are not coprime. So you can imagine the array being transformed into a set of disconnected graphs. One operation of finding two elements and replacing it by their lcm on the array is equivalent to find any two nodes in any sub-graph and replacing it by their lcm. The new node will maintain its place in the graph since it will not be coprime with its predecessor or successor by definition. The termination point of the algorithm is when each subgraph is squeezed into a single node. Regardsless of the order you choose elements, the final node in the squeezed graph will be the lcm of all the nodes in the graph. Once the numbers are squeezed, you can put them back in the array in successive positions to get the array view. This way, it can be proved that regardless of the order you choose, the number of elements in the final graph is the number of disconnected subgraphs in the first array, the final result from each graph will be the lcm of all the elements it contains, the order in which they appear in the array is the order in which we discovered those disconnected subgraphs when moving left to right."
                    },
                    {
                        "username": "bedmuthaapoorv",
                        "content": "2 tips:\\n1. implement gcd efficiently\\n2. lcm(a,b)*gcd(a,b)=a*b"
                    },
                    {
                        "username": "bedmuthaapoorv",
                        "content": "Uber asked this very question in their OA\\n"
                    },
                    {
                        "username": "Furies",
                        "content": "I hate this problem. The core algorithm is not difficult to figure out, but I wasted an hour or two trying to figure out:\\n- the most effective way to calculate gcd and lcm.\\n- dealing with some obscure integer overlow\\n"
                    },
                    {
                        "username": "CODEX47",
                        "content": "Just a implementation question."
                    },
                    {
                        "username": "bantikumar",
                        "content": "This code is failed for this [31,97561,97561,97561,97561,97561,97561,97561,97561] testcase\\npublic List<Integer> replaceNonCoprimes(int[] nums) {\\n        ArrayList<Integer> ans=new ArrayList<>();\\n        for(int i=0; i<nums.length; i++)\\n              ans.add(nums[i]);\\n        int i=0;\\n        while(i<ans.size()-1)\\n        {\\n            int r=i;\\n            int hcf=gcd(ans.get(i), ans.get(r+1));\\n            if(hcf!=1)\\n            {\\n                \\n                ans.set(i, (int)(ans.get(i)*1L*ans.get(r+1))/hcf);\\n                ans.remove(r+1);\\n            }\\n            else\\n             i++;\\n        }   \\n        return ans;   \\n    }"
                    }
                ]
            },
            {
                "id": 2010049,
                "content": [
                    {
                        "username": "Hamzawy",
                        "content": "It is stated in the problem that:\\n**It can be shown that replacing adjacent non-coprime numbers in any arbitrary order will lead to the same result.**\\nCan anyone prove why the result array will be always the same regardless of the operations\\' ordering ? \\n"
                    },
                    {
                        "username": "senthilPalanisamy",
                        "content": "One way to prove this is as follows - lets turn the problem into a graph problem. Each element in the array is connected to the next element and / or previous element, if there are not coprime. So you can imagine the array being transformed into a set of disconnected graphs. One operation of finding two elements and replacing it by their lcm on the array is equivalent to find any two nodes in any sub-graph and replacing it by their lcm. The new node will maintain its place in the graph since it will not be coprime with its predecessor or successor by definition. The termination point of the algorithm is when each subgraph is squeezed into a single node. Regardsless of the order you choose elements, the final node in the squeezed graph will be the lcm of all the nodes in the graph. Once the numbers are squeezed, you can put them back in the array in successive positions to get the array view. This way, it can be proved that regardless of the order you choose, the number of elements in the final graph is the number of disconnected subgraphs in the first array, the final result from each graph will be the lcm of all the elements it contains, the order in which they appear in the array is the order in which we discovered those disconnected subgraphs when moving left to right."
                    },
                    {
                        "username": "bedmuthaapoorv",
                        "content": "2 tips:\\n1. implement gcd efficiently\\n2. lcm(a,b)*gcd(a,b)=a*b"
                    },
                    {
                        "username": "bedmuthaapoorv",
                        "content": "Uber asked this very question in their OA\\n"
                    },
                    {
                        "username": "Furies",
                        "content": "I hate this problem. The core algorithm is not difficult to figure out, but I wasted an hour or two trying to figure out:\\n- the most effective way to calculate gcd and lcm.\\n- dealing with some obscure integer overlow\\n"
                    },
                    {
                        "username": "CODEX47",
                        "content": "Just a implementation question."
                    },
                    {
                        "username": "bantikumar",
                        "content": "This code is failed for this [31,97561,97561,97561,97561,97561,97561,97561,97561] testcase\\npublic List<Integer> replaceNonCoprimes(int[] nums) {\\n        ArrayList<Integer> ans=new ArrayList<>();\\n        for(int i=0; i<nums.length; i++)\\n              ans.add(nums[i]);\\n        int i=0;\\n        while(i<ans.size()-1)\\n        {\\n            int r=i;\\n            int hcf=gcd(ans.get(i), ans.get(r+1));\\n            if(hcf!=1)\\n            {\\n                \\n                ans.set(i, (int)(ans.get(i)*1L*ans.get(r+1))/hcf);\\n                ans.remove(r+1);\\n            }\\n            else\\n             i++;\\n        }   \\n        return ans;   \\n    }"
                    }
                ]
            },
            {
                "id": 1815760,
                "content": [
                    {
                        "username": "Hamzawy",
                        "content": "It is stated in the problem that:\\n**It can be shown that replacing adjacent non-coprime numbers in any arbitrary order will lead to the same result.**\\nCan anyone prove why the result array will be always the same regardless of the operations\\' ordering ? \\n"
                    },
                    {
                        "username": "senthilPalanisamy",
                        "content": "One way to prove this is as follows - lets turn the problem into a graph problem. Each element in the array is connected to the next element and / or previous element, if there are not coprime. So you can imagine the array being transformed into a set of disconnected graphs. One operation of finding two elements and replacing it by their lcm on the array is equivalent to find any two nodes in any sub-graph and replacing it by their lcm. The new node will maintain its place in the graph since it will not be coprime with its predecessor or successor by definition. The termination point of the algorithm is when each subgraph is squeezed into a single node. Regardsless of the order you choose elements, the final node in the squeezed graph will be the lcm of all the nodes in the graph. Once the numbers are squeezed, you can put them back in the array in successive positions to get the array view. This way, it can be proved that regardless of the order you choose, the number of elements in the final graph is the number of disconnected subgraphs in the first array, the final result from each graph will be the lcm of all the elements it contains, the order in which they appear in the array is the order in which we discovered those disconnected subgraphs when moving left to right."
                    },
                    {
                        "username": "bedmuthaapoorv",
                        "content": "2 tips:\\n1. implement gcd efficiently\\n2. lcm(a,b)*gcd(a,b)=a*b"
                    },
                    {
                        "username": "bedmuthaapoorv",
                        "content": "Uber asked this very question in their OA\\n"
                    },
                    {
                        "username": "Furies",
                        "content": "I hate this problem. The core algorithm is not difficult to figure out, but I wasted an hour or two trying to figure out:\\n- the most effective way to calculate gcd and lcm.\\n- dealing with some obscure integer overlow\\n"
                    },
                    {
                        "username": "CODEX47",
                        "content": "Just a implementation question."
                    },
                    {
                        "username": "bantikumar",
                        "content": "This code is failed for this [31,97561,97561,97561,97561,97561,97561,97561,97561] testcase\\npublic List<Integer> replaceNonCoprimes(int[] nums) {\\n        ArrayList<Integer> ans=new ArrayList<>();\\n        for(int i=0; i<nums.length; i++)\\n              ans.add(nums[i]);\\n        int i=0;\\n        while(i<ans.size()-1)\\n        {\\n            int r=i;\\n            int hcf=gcd(ans.get(i), ans.get(r+1));\\n            if(hcf!=1)\\n            {\\n                \\n                ans.set(i, (int)(ans.get(i)*1L*ans.get(r+1))/hcf);\\n                ans.remove(r+1);\\n            }\\n            else\\n             i++;\\n        }   \\n        return ans;   \\n    }"
                    }
                ]
            },
            {
                "id": 1790219,
                "content": [
                    {
                        "username": "Hamzawy",
                        "content": "It is stated in the problem that:\\n**It can be shown that replacing adjacent non-coprime numbers in any arbitrary order will lead to the same result.**\\nCan anyone prove why the result array will be always the same regardless of the operations\\' ordering ? \\n"
                    },
                    {
                        "username": "senthilPalanisamy",
                        "content": "One way to prove this is as follows - lets turn the problem into a graph problem. Each element in the array is connected to the next element and / or previous element, if there are not coprime. So you can imagine the array being transformed into a set of disconnected graphs. One operation of finding two elements and replacing it by their lcm on the array is equivalent to find any two nodes in any sub-graph and replacing it by their lcm. The new node will maintain its place in the graph since it will not be coprime with its predecessor or successor by definition. The termination point of the algorithm is when each subgraph is squeezed into a single node. Regardsless of the order you choose elements, the final node in the squeezed graph will be the lcm of all the nodes in the graph. Once the numbers are squeezed, you can put them back in the array in successive positions to get the array view. This way, it can be proved that regardless of the order you choose, the number of elements in the final graph is the number of disconnected subgraphs in the first array, the final result from each graph will be the lcm of all the elements it contains, the order in which they appear in the array is the order in which we discovered those disconnected subgraphs when moving left to right."
                    },
                    {
                        "username": "bedmuthaapoorv",
                        "content": "2 tips:\\n1. implement gcd efficiently\\n2. lcm(a,b)*gcd(a,b)=a*b"
                    },
                    {
                        "username": "bedmuthaapoorv",
                        "content": "Uber asked this very question in their OA\\n"
                    },
                    {
                        "username": "Furies",
                        "content": "I hate this problem. The core algorithm is not difficult to figure out, but I wasted an hour or two trying to figure out:\\n- the most effective way to calculate gcd and lcm.\\n- dealing with some obscure integer overlow\\n"
                    },
                    {
                        "username": "CODEX47",
                        "content": "Just a implementation question."
                    },
                    {
                        "username": "bantikumar",
                        "content": "This code is failed for this [31,97561,97561,97561,97561,97561,97561,97561,97561] testcase\\npublic List<Integer> replaceNonCoprimes(int[] nums) {\\n        ArrayList<Integer> ans=new ArrayList<>();\\n        for(int i=0; i<nums.length; i++)\\n              ans.add(nums[i]);\\n        int i=0;\\n        while(i<ans.size()-1)\\n        {\\n            int r=i;\\n            int hcf=gcd(ans.get(i), ans.get(r+1));\\n            if(hcf!=1)\\n            {\\n                \\n                ans.set(i, (int)(ans.get(i)*1L*ans.get(r+1))/hcf);\\n                ans.remove(r+1);\\n            }\\n            else\\n             i++;\\n        }   \\n        return ans;   \\n    }"
                    }
                ]
            },
            {
                "id": 1733221,
                "content": [
                    {
                        "username": "Hamzawy",
                        "content": "It is stated in the problem that:\\n**It can be shown that replacing adjacent non-coprime numbers in any arbitrary order will lead to the same result.**\\nCan anyone prove why the result array will be always the same regardless of the operations\\' ordering ? \\n"
                    },
                    {
                        "username": "senthilPalanisamy",
                        "content": "One way to prove this is as follows - lets turn the problem into a graph problem. Each element in the array is connected to the next element and / or previous element, if there are not coprime. So you can imagine the array being transformed into a set of disconnected graphs. One operation of finding two elements and replacing it by their lcm on the array is equivalent to find any two nodes in any sub-graph and replacing it by their lcm. The new node will maintain its place in the graph since it will not be coprime with its predecessor or successor by definition. The termination point of the algorithm is when each subgraph is squeezed into a single node. Regardsless of the order you choose elements, the final node in the squeezed graph will be the lcm of all the nodes in the graph. Once the numbers are squeezed, you can put them back in the array in successive positions to get the array view. This way, it can be proved that regardless of the order you choose, the number of elements in the final graph is the number of disconnected subgraphs in the first array, the final result from each graph will be the lcm of all the elements it contains, the order in which they appear in the array is the order in which we discovered those disconnected subgraphs when moving left to right."
                    },
                    {
                        "username": "bedmuthaapoorv",
                        "content": "2 tips:\\n1. implement gcd efficiently\\n2. lcm(a,b)*gcd(a,b)=a*b"
                    },
                    {
                        "username": "bedmuthaapoorv",
                        "content": "Uber asked this very question in their OA\\n"
                    },
                    {
                        "username": "Furies",
                        "content": "I hate this problem. The core algorithm is not difficult to figure out, but I wasted an hour or two trying to figure out:\\n- the most effective way to calculate gcd and lcm.\\n- dealing with some obscure integer overlow\\n"
                    },
                    {
                        "username": "CODEX47",
                        "content": "Just a implementation question."
                    },
                    {
                        "username": "bantikumar",
                        "content": "This code is failed for this [31,97561,97561,97561,97561,97561,97561,97561,97561] testcase\\npublic List<Integer> replaceNonCoprimes(int[] nums) {\\n        ArrayList<Integer> ans=new ArrayList<>();\\n        for(int i=0; i<nums.length; i++)\\n              ans.add(nums[i]);\\n        int i=0;\\n        while(i<ans.size()-1)\\n        {\\n            int r=i;\\n            int hcf=gcd(ans.get(i), ans.get(r+1));\\n            if(hcf!=1)\\n            {\\n                \\n                ans.set(i, (int)(ans.get(i)*1L*ans.get(r+1))/hcf);\\n                ans.remove(r+1);\\n            }\\n            else\\n             i++;\\n        }   \\n        return ans;   \\n    }"
                    }
                ]
            }
        ]
    },
    {
        "title": "Users With Two Purchases Within Seven Days",
        "question_content": null,
        "solutions": [],
        "discussions": [
            {
                "id": 1568759,
                "content": [
                    {
                        "username": "xinxinxinstar",
                        "content": "with t1 as(\\nselect distinct\\nuser_id, count(purchase_id) over (partition by user_id order by purchase_date range between current row and interval 7 day following ) as cn\\nfrom Purchases)\\n\\nselect distinct\\nuser_id\\nfrom t1\\nwhere cn =2"
                    },
                    {
                        "username": "vaibh_1406",
                        "content": "In MS-SQL\\nselect distinct p1.user_id\\nfrom purchases p1\\njoin purchases p2 on p1.user_id = p2.user_id and p1.purchase_id <> p2.purchase_id\\nand p2.purchase_date >= p1.purchase_date\\nwhere datediff(day, p1.purchase_date, p2.purchase_date)<=7"
                    },
                    {
                        "username": "baobui258",
                        "content": "```\\nselect\\n    distinct user_id\\nfrom\\n(\\n    select\\n        user_id, purchase_date, datediff(purchase_date,\\n            ifnull(LAG(purchase_date) over (\\n                partition by user_id\\n                order by purchase_date\\n            ), \\'1990-01-01\\')\\n        ) as diff\\n    from\\n        Purchases\\n) a\\nwhere diff <= 7\\n\\n```"
                    }
                ]
            },
            {
                "id": 1797987,
                "content": [
                    {
                        "username": "xinxinxinstar",
                        "content": "with t1 as(\\nselect distinct\\nuser_id, count(purchase_id) over (partition by user_id order by purchase_date range between current row and interval 7 day following ) as cn\\nfrom Purchases)\\n\\nselect distinct\\nuser_id\\nfrom t1\\nwhere cn =2"
                    },
                    {
                        "username": "vaibh_1406",
                        "content": "In MS-SQL\\nselect distinct p1.user_id\\nfrom purchases p1\\njoin purchases p2 on p1.user_id = p2.user_id and p1.purchase_id <> p2.purchase_id\\nand p2.purchase_date >= p1.purchase_date\\nwhere datediff(day, p1.purchase_date, p2.purchase_date)<=7"
                    },
                    {
                        "username": "baobui258",
                        "content": "```\\nselect\\n    distinct user_id\\nfrom\\n(\\n    select\\n        user_id, purchase_date, datediff(purchase_date,\\n            ifnull(LAG(purchase_date) over (\\n                partition by user_id\\n                order by purchase_date\\n            ), \\'1990-01-01\\')\\n        ) as diff\\n    from\\n        Purchases\\n) a\\nwhere diff <= 7\\n\\n```"
                    }
                ]
            },
            {
                "id": 1638364,
                "content": [
                    {
                        "username": "xinxinxinstar",
                        "content": "with t1 as(\\nselect distinct\\nuser_id, count(purchase_id) over (partition by user_id order by purchase_date range between current row and interval 7 day following ) as cn\\nfrom Purchases)\\n\\nselect distinct\\nuser_id\\nfrom t1\\nwhere cn =2"
                    },
                    {
                        "username": "vaibh_1406",
                        "content": "In MS-SQL\\nselect distinct p1.user_id\\nfrom purchases p1\\njoin purchases p2 on p1.user_id = p2.user_id and p1.purchase_id <> p2.purchase_id\\nand p2.purchase_date >= p1.purchase_date\\nwhere datediff(day, p1.purchase_date, p2.purchase_date)<=7"
                    },
                    {
                        "username": "baobui258",
                        "content": "```\\nselect\\n    distinct user_id\\nfrom\\n(\\n    select\\n        user_id, purchase_date, datediff(purchase_date,\\n            ifnull(LAG(purchase_date) over (\\n                partition by user_id\\n                order by purchase_date\\n            ), \\'1990-01-01\\')\\n        ) as diff\\n    from\\n        Purchases\\n) a\\nwhere diff <= 7\\n\\n```"
                    }
                ]
            }
        ]
    },
    {
        "title": "Intersection of Multiple Arrays",
        "question_content": "Given a 2D integer array <code>nums</code> where <code>nums[i]</code> is a non-empty array of <strong>distinct</strong> positive integers, return <em>the list of integers that are present in <strong>each array</strong> of</em> <code>nums</code><em> sorted in <strong>ascending order</strong></em>.\n<p>&nbsp;</p>\n<p><strong class=\"example\">Example 1:</strong></p>\n\n<pre>\n<strong>Input:</strong> nums = [[<u><strong>3</strong></u>,1,2,<u><strong>4</strong></u>,5],[1,2,<u><strong>3</strong></u>,<u><strong>4</strong></u>],[<u><strong>3</strong></u>,<u><strong>4</strong></u>,5,6]]\n<strong>Output:</strong> [3,4]\n<strong>Explanation:</strong> \nThe only integers present in each of nums[0] = [<u><strong>3</strong></u>,1,2,<u><strong>4</strong></u>,5], nums[1] = [1,2,<u><strong>3</strong></u>,<u><strong>4</strong></u>], and nums[2] = [<u><strong>3</strong></u>,<u><strong>4</strong></u>,5,6] are 3 and 4, so we return [3,4].</pre>\n\n<p><strong class=\"example\">Example 2:</strong></p>\n\n<pre>\n<strong>Input:</strong> nums = [[1,2,3],[4,5,6]]\n<strong>Output:</strong> []\n<strong>Explanation:</strong> \nThere does not exist any integer present both in nums[0] and nums[1], so we return an empty list [].\n</pre>\n\n<p>&nbsp;</p>\n<p><strong>Constraints:</strong></p>\n\n<ul>\n\t<li><code>1 &lt;= nums.length &lt;= 1000</code></li>\n\t<li><code>1 &lt;= sum(nums[i].length) &lt;= 1000</code></li>\n\t<li><code>1 &lt;= nums[i][j] &lt;= 1000</code></li>\n\t<li>All the values of <code>nums[i]</code> are <strong>unique</strong>.</li>\n</ul>\n",
        "solutions": [
            {
                "id": 1976940,
                "title": "java-easy-solution",
                "content": "```\\n\\nclass Solution {\\n    public List<Integer> intersection(int[][] nums) {\\n        \\n        List<Integer> ans = new ArrayList<>();\\n        \\n        int[] count  = new int[1001];\\n        \\n        for(int[] arr : nums){\\n            for(int i : arr){\\n                count[i]++;\\n            }\\n        }\\n        \\n       for(int i=0;i<count.length;i++){\\n           if(count[i]==nums.length){\\n               ans.add(i);\\n           }\\n       }\\n        \\n        return ans;\\n    }\\n}\\n\\n```",
                "solutionTags": [
                    "Java",
                    "Array"
                ],
                "code": "```\\n\\nclass Solution {\\n    public List<Integer> intersection(int[][] nums) {\\n        \\n        List<Integer> ans = new ArrayList<>();\\n        \\n        int[] count  = new int[1001];\\n        \\n        for(int[] arr : nums){\\n            for(int i : arr){\\n                count[i]++;\\n            }\\n        }\\n        \\n       for(int i=0;i<count.length;i++){\\n           if(count[i]==nums.length){\\n               ans.add(i);\\n           }\\n       }\\n        \\n        return ans;\\n    }\\n}\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1977782,
                "title": "python3-1-line-solution-simple-explanation",
                "content": "# **Idea**\\n<br>\\n\\n##### To solve this question easily, we can take advantage of one of the specifications:\\n\\n*nums[i] is a non-empty array of **distinct** positive integers*\\n\\n<br>\\n\\n##### Since the integers in each sub-list of nums are distinct (i.e. unique), we can count the number of occurences of every integer in nums.\\n<br>\\n\\n##### Suppose it happens that the number of occurences for some integer x is equal to the length of nums (the number of sub-lists).\\n##### It would mean, that x must have appeared in every single sub-list of nums (because it could appear in each of the sub-lists at most 1 time).\\n\\n<br>\\n\\n##### Notice, that the result is a list of integers like x, so we just need to find all of them.\\n\\n<br>\\n<br>\\n\\n# **Code**\\n<br>\\n\\n```\\n\\nclass Solution:\\n    def intersection(self, A: List[List[int]]) -> List[int]:\\n        return sorted([k for k,v in Counter([x for l in A for x in l]).items() if v==len(A)])\\n\\t\\t\\n```\\n\\n<br>\\n<br>\\n\\n# **Breakdown**\\n\\n##### Here\\'s a breakdown of each operation that\\'s happening in the line above:\\n\\n<br>\\n\\n```\\n\\nclass Solution:\\n    def intersection(self, A: List[List[int]]) -> List[int]:\\n        # Flattening the list A\\n        # For example, if A = [[3, 5, 1], [2, 3, 1]] then flat_list = [3, 5, 1, 2, 3, 1]\\n        flat_list = [x for lst in A for x in lst]\\n\\n        # Counter - a container from the collections module\\n        # Here, it is pretty much a dictionary, where:\\n        # keys - the integers from flat_list\\n        # values - the number of occurences of the keys\\n\\n        # counts from the above flat_list would be equal to {3: 2, 5: 1, 1: 2, 2: 1}\\n        counts = Counter(flat_list)\\n\\n        # dict.items() is a method that returns a list of pairs that look like (key, value)\\n        # Here, items would be equal to [(3, 2), (5, 1), (1, 2), (2, 1)]\\n        items = counts.items()\\n\\n        # result array created by taking every key from items array\\n        # which has the value (number of key\\'s occurences) equal to the length of A (here, 2)\\n        # The result would be equal to [3, 1]\\n        result = [key for (key, value) in items if value == len(A)]\\n\\n        # Sort the result array and return it\\n        # The result is [1, 3]\\n        return sorted(result)\\n\\t\\t\\n```\\n\\n<br>\\n\\n---\\n\\n<br>\\n\\n\\n### Thanks for reading, and have an amazing day! \\uFF3C(\\uFF3E\\u25BD\\uFF3E)\\uFF0F\\n\\n<br>",
                "solutionTags": [
                    "Python",
                    "Python3"
                ],
                "code": "```\\n\\nclass Solution:\\n    def intersection(self, A: List[List[int]]) -> List[int]:\\n        return sorted([k for k,v in Counter([x for l in A for x in l]).items() if v==len(A)])\\n\\t\\t\\n```\n```\\n\\nclass Solution:\\n    def intersection(self, A: List[List[int]]) -> List[int]:\\n        # Flattening the list A\\n        # For example, if A = [[3, 5, 1], [2, 3, 1]] then flat_list = [3, 5, 1, 2, 3, 1]\\n        flat_list = [x for lst in A for x in lst]\\n\\n        # Counter - a container from the collections module\\n        # Here, it is pretty much a dictionary, where:\\n        # keys - the integers from flat_list\\n        # values - the number of occurences of the keys\\n\\n        # counts from the above flat_list would be equal to {3: 2, 5: 1, 1: 2, 2: 1}\\n        counts = Counter(flat_list)\\n\\n        # dict.items() is a method that returns a list of pairs that look like (key, value)\\n        # Here, items would be equal to [(3, 2), (5, 1), (1, 2), (2, 1)]\\n        items = counts.items()\\n\\n        # result array created by taking every key from items array\\n        # which has the value (number of key\\'s occurences) equal to the length of A (here, 2)\\n        # The result would be equal to [3, 1]\\n        result = [key for (key, value) in items if value == len(A)]\\n\\n        # Sort the result array and return it\\n        # The result is [1, 3]\\n        return sorted(result)\\n\\t\\t\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2195235,
                "title": "c-explained-beats-100-optimized",
                "content": "**PLEASE UPVOTE IF YOU FIND MY APPROACH HELPFUL, MEANS A LOT \\uD83D\\uDE0A**\\n\\n**Explanation:**\\n\\n* Initialize an ordered map mp and vector vec.\\n\\n* Traverse the 2D array and store the elements present with their frequency.\\n* Now check if the element.second (frequency) stored in the map is equal to the no. of rows in the array.\\n* If element.second == no. of rows then it implies that the element is present in every array.\\n* Push all the elements which satisfy this condition.\\n* Return the vector vec as it now contains the intersecting elements.\\n\\n```\\nclass Solution {\\npublic:\\n    vector<int> intersection(vector<vector<int>>& nums) {\\n        int n = nums.size(); // gives the no. of rows\\n        map<int,int> mp; // we don\\'t need unordered_map because we need the elements to be in sorted format.\\n        vector<int> vec;\\n        \\n        // traverse through the 2D array and store the frequency of each element\\n        for(int row=0;row<n;row++)\\n        {\\n            for(int col=0;col<nums[row].size();col++)\\n            {\\n                mp[nums[row][col]]++;\\n            }\\n        }\\n        \\n        // In the 2D array, intersection occurs when the elements are present in every row.\\n        // So the frequency of the element should match with the no. or rows in the 2D array.\\n        for(auto element : mp)\\n            if(element.second == n)\\n                vec.push_back(element.first);\\n        \\n        // return the intersecting elements\\n        return vec;\\n    }\\n};\\n```\\n",
                "solutionTags": [
                    "C++",
                    "C"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<int> intersection(vector<vector<int>>& nums) {\\n        int n = nums.size(); // gives the no. of rows\\n        map<int,int> mp; // we don\\'t need unordered_map because we need the elements to be in sorted format.\\n        vector<int> vec;\\n        \\n        // traverse through the 2D array and store the frequency of each element\\n        for(int row=0;row<n;row++)\\n        {\\n            for(int col=0;col<nums[row].size();col++)\\n            {\\n                mp[nums[row][col]]++;\\n            }\\n        }\\n        \\n        // In the 2D array, intersection occurs when the elements are present in every row.\\n        // So the frequency of the element should match with the no. or rows in the 2D array.\\n        for(auto element : mp)\\n            if(element.second == n)\\n                vec.push_back(element.first);\\n        \\n        // return the intersecting elements\\n        return vec;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1977345,
                "title": "java-c-clean-short",
                "content": "### Java \\n```\\npublic List<Integer> intersection(int[][] nums) {\\n        Map<Integer, Integer> countMap = new HashMap<>();\\n        List<Integer> inEachArray = new ArrayList<>();\\n        for (int[] num : nums) {\\n            for (int x : num) {\\n                countMap.put(x, countMap.getOrDefault(x, 0) + 1);\\n                if (countMap.get(x) == nums.length) inEachArray.add(x);\\n            }\\n        }\\n        inEachArray.sort(Comparator.naturalOrder());\\n        return inEachArray;\\n    }\\n```\\n### C++\\n```\\npublic:\\n    vector<int> intersection(vector<vector<int>>&nums) {\\n        map<int, int> countMap;\\n        vector<int> inEachArray;\\n        for (auto num : nums) {\\n            for (auto x : num) {\\n                countMap[x]++;\\n                if (countMap[x] == nums.size())\\n                     inEachArray.push_back(x);\\n            }\\n        }\\n        sort(inEachArray.begin(), inEachArray.end());\\n        return inEachArray;\\n    }\\n```\\n\\n### + 3-Line Java\\n```\\npublic List<Integer> intersection(int[][] nums) {\\n        Map<Integer, Integer> countMap = new HashMap<>();\\n        Arrays.stream(nums).forEach(a -> Arrays.stream(a).forEach(x -> countMap.put(x, countMap.getOrDefault(x, 0) + 1)));\\n        return countMap.entrySet().stream().filter(e -> e.getValue() == nums.length).map(Map.Entry::getKey).sorted().collect(Collectors.toList());\\n    }\\n```\\n\\nMy repositories with leetcode problems solving - [Java](https://github.com/FLlGHT/algorithms/tree/master/j-algorithms/src/main/java),  [C++](https://github.com/FLlGHT/algorithms/tree/master/c-algorithms/src/main/c%2B%2B)",
                "solutionTags": [
                    "Java",
                    "C"
                ],
                "code": "```\\npublic List<Integer> intersection(int[][] nums) {\\n        Map<Integer, Integer> countMap = new HashMap<>();\\n        List<Integer> inEachArray = new ArrayList<>();\\n        for (int[] num : nums) {\\n            for (int x : num) {\\n                countMap.put(x, countMap.getOrDefault(x, 0) + 1);\\n                if (countMap.get(x) == nums.length) inEachArray.add(x);\\n            }\\n        }\\n        inEachArray.sort(Comparator.naturalOrder());\\n        return inEachArray;\\n    }\\n```\n```\\npublic:\\n    vector<int> intersection(vector<vector<int>>&nums) {\\n        map<int, int> countMap;\\n        vector<int> inEachArray;\\n        for (auto num : nums) {\\n            for (auto x : num) {\\n                countMap[x]++;\\n                if (countMap[x] == nums.size())\\n                     inEachArray.push_back(x);\\n            }\\n        }\\n        sort(inEachArray.begin(), inEachArray.end());\\n        return inEachArray;\\n    }\\n```\n```\\npublic List<Integer> intersection(int[][] nums) {\\n        Map<Integer, Integer> countMap = new HashMap<>();\\n        Arrays.stream(nums).forEach(a -> Arrays.stream(a).forEach(x -> countMap.put(x, countMap.getOrDefault(x, 0) + 1)));\\n        return countMap.entrySet().stream().filter(e -> e.getValue() == nums.length).map(Map.Entry::getKey).sorted().collect(Collectors.toList());\\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1982397,
                "title": "counter",
                "content": "Since numbers in each array are unique, we can just count all numbers.\\n\\nNumbers that are present in each array will be counted `nums.size()` number of times.\\n\\n**C++**\\n```cpp\\nvector<int> intersection(vector<vector<int>>& nums) {\\n    vector<int> cnt(1001), res;\\n    for (auto &arr: nums)\\n        for (int n : arr)\\n            ++cnt[n];\\n    for (int i = 0; i < cnt.size(); ++i)\\n        if (cnt[i] == nums.size())\\n            res.push_back(i);\\n    return res;\\n}\\n```",
                "solutionTags": [
                    "C"
                ],
                "code": "```cpp\\nvector<int> intersection(vector<vector<int>>& nums) {\\n    vector<int> cnt(1001), res;\\n    for (auto &arr: nums)\\n        for (int n : arr)\\n            ++cnt[n];\\n    for (int i = 0; i < cnt.size(); ++i)\\n        if (cnt[i] == nums.size())\\n            res.push_back(i);\\n    return res;\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2428232,
                "title": "94-58-faster-using-set-and-operator-in-python",
                "content": "![image](https://assets.leetcode.com/users/images/792f0a0d-82a2-4dd3-8bf8-54384899e999_1660553213.0318358.png)\\n\\n```\\nclass Solution:\\n    def intersection(self, nums: List[List[int]]) -> List[int]:\\n        res = set(nums[0])\\n        for i in range(1, len(nums)):\\n            res &= set(nums[i])\\n        res = list(res)\\n        res.sort()\\n        return res\\n        \\n```",
                "solutionTags": [
                    "Python",
                    "Python3",
                    "Ordered Set"
                ],
                "code": "```\\nclass Solution:\\n    def intersection(self, nums: List[List[int]]) -> List[int]:\\n        res = set(nums[0])\\n        for i in range(1, len(nums)):\\n            res &= set(nums[i])\\n        res = list(res)\\n        res.sort()\\n        return res\\n        \\n```",
                "codeTag": "Java"
            },
            {
                "id": 1977004,
                "title": "one-solution-if-elements-in-arrays-are-distinct-or-duplicate",
                "content": "**Similar Question**: [2032. Two Out of Three](https://leetcode.com/contest/weekly-contest-262/problems/two-out-of-three/)\\n\\n**Explanation:**\\nJust Resisit the increase of count of same elements multiple times in an array.\\n\\n**Fot this We use**: `pair<int,int>`\\n`First int`- Count of arrays in which we have seen this element\\n`Second int` - Array number in which it was last found. **{This will help in preventing from increase in count of same element muliple times in a single array}**\\n\\n> This Solution will also work if elements across the arrays are not distinct.  **[BOTH TYPES USES SAME SPACE i.e if all are {distinct or not-distinct}]**\\n\\n**Type A**\\nWe simply use a `map` and return the answer as map gives a `sorted sequence`.\\n**Runtime - 24ms**\\n# C++\\n \\n    vector<int> intersection(vector<vector<int>>& nums) {\\n        map<int,pair<int,int>> mp; \\n        int cnt=1;\\n        for(auto i:nums){\\n\\t\\t    for(auto j:i) if(mp[j].second!=cnt) mp[j].first++, mp[j].second=cnt;\\n\\t\\t    cnt++;\\n\\t    }\\n        vector<int> res;\\n        for(auto i:mp) if(i.second.first==size(nums)) res.push_back(i.first);\\n        return res;\\n    }\\n\\t\\n**Type B**\\nWe simply use a `unordered_map` and return the answer after `sorting manually`.\\n**Runtime - 7ms**\\n# C++\\n    vector<int> intersection(vector<vector<int>>& nums) {\\n        unordered_map<int,pair<int,int>> mp; \\n        int cnt=1;\\n        for(auto i:nums){\\n\\t        for(auto j:i) if(mp[j].second!=cnt) mp[j].first++, mp[j].second=cnt;\\n\\t        cnt++;\\n        }\\n        vector<int> res;\\n        for(auto i:mp) if(i.second.first==size(nums)) res.push_back(i.first);\\n        sort(begin(res),end(res));\\n        return res;  \\n    }\\n\\n",
                "solutionTags": [
                    "C"
                ],
                "code": "**Similar Question**: [2032. Two Out of Three](https://leetcode.com/contest/weekly-contest-262/problems/two-out-of-three/)\\n\\n**Explanation:**\\nJust Resisit the increase of count of same elements multiple times in an array.\\n\\n**Fot this We use**: `pair<int,int>`\\n`First int`- Count of arrays in which we have seen this element\\n`Second int` - Array number in which it was last found. **{This will help in preventing from increase in count of same element muliple times in a single array}**\\n\\n> This Solution will also work if elements across the arrays are not distinct.  **[BOTH TYPES USES SAME SPACE i.e if all are {distinct or not-distinct}]**\\n\\n**Type A**\\nWe simply use a `map` and return the answer as map gives a `sorted sequence`.\\n**Runtime - 24ms**\\n# C++\\n \\n    vector<int> intersection(vector<vector<int>>& nums) {\\n        map<int,pair<int,int>> mp; \\n        int cnt=1;\\n        for(auto i:nums){\\n\\t\\t    for(auto j:i) if(mp[j].second!=cnt) mp[j].first++, mp[j].second=cnt;\\n\\t\\t    cnt++;\\n\\t    }\\n        vector<int> res;\\n        for(auto i:mp) if(i.second.first==size(nums)) res.push_back(i.first);\\n        return res;\\n    }\\n\\t\\n**Type B**\\nWe simply use a `unordered_map` and return the answer after `sorting manually`.\\n**Runtime - 7ms**\\n# C++\\n    vector<int> intersection(vector<vector<int>>& nums) {\\n        unordered_map<int,pair<int,int>> mp; \\n        int cnt=1;\\n        for(auto i:nums){\\n\\t        for(auto j:i) if(mp[j].second!=cnt) mp[j].first++, mp[j].second=cnt;\\n\\t        cnt++;\\n        }\\n        vector<int> res;\\n        for(auto i:mp) if(i.second.first==size(nums)) res.push_back(i.first);\\n        sort(begin(res),end(res));\\n        return res;  \\n    }\\n\\n",
                "codeTag": "Unknown"
            },
            {
                "id": 1976970,
                "title": "c-easy-solution",
                "content": "\\n**Method-1(Simple Searching)**\\n\\nclass Solution {\\npublic:\\n\\n    vector<int> intersection(vector<vector<int>>& nums) {\\n        vector<int> sol;\\n         for(int i=0;i<nums[0].size();i++)\\n            {\\n            int f1=1;\\n            for(int j=1;j<nums.size();j++)\\n            {\\n                int f2=0;\\n                for(int p=0;p<nums[j].size();p++)\\n                    if(nums[j][p]==nums[0][i]) {f2=1; break;}\\n                if(f2==0) {f1=0; break;}\\n            } \\n            if(f1==1) sol.push_back(nums[0][i]);\\n        }\\n        sort(sol.begin(),sol.end());\\n        return sol;\\n    }\\n};\\n\\n\\n\\n\\n**Method-2** (Using Map)\\n\\'\\'\\'\\nclass Solution {\\npublic:\\n\\n    vector<int> intersection(vector<vector<int>>& nums) {\\n        vector<int> ans;\\n        map<int,int> mp;\\n        int m=nums.size();\\n        for(int i=0;i<m;i++){\\n            int n=nums[i].size();\\n            for(int j=0;j<n;j++)\\n                mp[nums[i][j]]++;\\n        }\\n        \\n        for(auto i=mp.begin();i!=mp.end();i++)\\n            if(i->second==m)    ans.push_back(i->first);\\n        \\n        return ans;\\n    }\\n};\\n\\'\\'\\'",
                "solutionTags": [
                    "C"
                ],
                "code": "class Solution {\\npublic:\\n\\n    vector<int> intersection(vector<vector<int>>& nums) {\\n        vector<int> sol;\\n         for(int i=0;i<nums[0].size();i++)\\n            {\\n            int f1=1;\\n            for(int j=1;j<nums.size();j++)\\n            {\\n                int f2=0;\\n                for(int p=0;p<nums[j].size();p++)\\n                    if(nums[j][p]==nums[0][i]) {f2=1; break;}",
                "codeTag": "Java"
            },
            {
                "id": 1982697,
                "title": "short-javascript-solution-using-a-set-object",
                "content": "```\\nconst intersection = nums => {\\n    if (nums.length === 1) return nums[0].sort((a, b) => a - b)\\n\\t\\n    let initSet = new Set(nums[0]) //Initial Set \\n\\n    for (let i = 1; i < nums.length; i++) {\\n        initSet = new Set([...nums[i]].filter(x => initSet.has(x)))\\n    }\\n\\t\\n    return Array.from(initSet).sort((a, b) => a - b)\\n};\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\nconst intersection = nums => {\\n    if (nums.length === 1) return nums[0].sort((a, b) => a - b)\\n\\t\\n    let initSet = new Set(nums[0]) //Initial Set \\n\\n    for (let i = 1; i < nums.length; i++) {\\n        initSet = new Set([...nums[i]].filter(x => initSet.has(x)))\\n    }\\n\\t\\n    return Array.from(initSet).sort((a, b) => a - b)\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1977585,
                "title": "java-3lines-beats-100-00-memory-speed-0ms-april-2022",
                "content": "```\\nclass Solution {\\n public List<Integer> intersection(int[][] aa){\\n        int[] counts = new int[1_001];\\n        Arrays.stream(aa).forEach(a -> Arrays.stream(a).forEach(n -> counts[n]++));\\n        return IntStream.range(0, counts.length).filter(n -> counts[n] == aa.length).boxed().collect(Collectors.toList());\\n    }\\n}\\n```\\n\\n***Consider upvote if useful!***",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n public List<Integer> intersection(int[][] aa){\\n        int[] counts = new int[1_001];\\n        Arrays.stream(aa).forEach(a -> Arrays.stream(a).forEach(n -> counts[n]++));\\n        return IntStream.range(0, counts.length).filter(n -> counts[n] == aa.length).boxed().collect(Collectors.toList());\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1978695,
                "title": "easy-to-understand-for-beginners-c",
                "content": "class Solution {\\npublic:\\n    vector<int> intersection(vector<vector<int>>& a) {\\n        unordered_map<int,int>mp;\\n        for(int i=0;i<a.size();i++)\\n        {\\n            for(int j=0;j<a[i].size();j++)\\n            {\\n                mp[a[i][j]]++;\\n            }\\n        }\\n        vector<int>res;\\n        for(auto it :mp)\\n        {\\n            if(it.second ==a.size())\\n            {\\n                res.push_back(it.first);\\n            }\\n                \\n        }\\n        sort(res.begin(),res.end());\\n        return res;\\n    }\\n};",
                "solutionTags": [
                    "C"
                ],
                "code": "class Solution {\\npublic:\\n    vector<int> intersection(vector<vector<int>>& a) {\\n        unordered_map<int,int>mp;\\n        for(int i=0;i<a.size();i++)\\n        {\\n            for(int j=0;j<a[i].size();j++)\\n            {\\n                mp[a[i][j]]++;\\n            }",
                "codeTag": "Java"
            },
            {
                "id": 2677805,
                "title": "python-solution-hashmap",
                "content": "```\\nclass Solution:\\n    def intersection(self, nums: List[List[int]]) -> List[int]:\\n        d = {}\\n        \\n        for i in range(len(nums)):\\n            for j in nums[i]:\\n                if j not in d:\\n                    d[j] = 1\\n                else:\\n                    d[j]+=1\\n                    \\n        res = []\\n        for k,v in d.items():\\n            if v == len(nums):\\n                res.append(k)\\n                \\n        return sorted(res)\\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def intersection(self, nums: List[List[int]]) -> List[int]:\\n        d = {}\\n        \\n        for i in range(len(nums)):\\n            for j in nums[i]:\\n                if j not in d:\\n                    d[j] = 1\\n                else:\\n                    d[j]+=1\\n                    \\n        res = []\\n        for k,v in d.items():\\n            if v == len(nums):\\n                res.append(k)\\n                \\n        return sorted(res)\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1977166,
                "title": "easy-python",
                "content": "\\t\\tres=[]\\n        arr=[]\\n        n=len(nums)\\n        for num in nums:\\n            arr.extend(num)\\n        count=Counter(arr)\\n        for i in count:\\n            if(count[i]==n):\\n                res.append(i)\\n        return sorted(res) if res else res",
                "solutionTags": [
                    "Python"
                ],
                "code": "\\t\\tres=[]\\n        arr=[]\\n        n=len(nums)\\n        for num in nums:\\n            arr.extend(num)\\n        count=Counter(arr)\\n        for i in count:\\n            if(count[i]==n):\\n                res.append(i)\\n        return sorted(res) if res else res",
                "codeTag": "Unknown"
            },
            {
                "id": 1981312,
                "title": "hashmap-accepted-solution-to-make-it-easily-understandable",
                "content": "```\\nclass Solution {\\n    public static List<Integer> intersection(int[][] nums) {\\n\\t\\tList<Integer> list = new ArrayList<>();\\n\\t\\tHashMap<Integer, Integer> map = new HashMap<>();\\n\\n\\t\\tfor (int i = 0; i < nums.length; i++) {\\n\\t\\t\\tfor (int j = 0; j < nums[i].length; j++) {\\n\\t\\t\\t\\tif (map.containsKey(nums[i][j])) {\\n\\t\\t\\t\\t\\tmap.put(nums[i][j], map.get(nums[i][j]) + 1);\\n\\t\\t\\t\\t} else {\\n\\t\\t\\t\\t\\tmap.put(nums[i][j], 1);\\n\\t\\t\\t\\t}\\n\\t\\t\\t}\\n\\t\\t}\\n        for (Map.Entry<Integer, Integer> ans : map.entrySet()) {\\n\\t\\t\\tif (ans.getValue() == nums.length) {\\n\\t\\t\\t\\tlist.add(ans.getKey());\\n\\t\\t\\t}\\n\\t\\t}\\t\\tCollections.sort(list);\\n\\t\\treturn list;\\n\\t}\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public static List<Integer> intersection(int[][] nums) {\\n\\t\\tList<Integer> list = new ArrayList<>();\\n\\t\\tHashMap<Integer, Integer> map = new HashMap<>();\\n\\n\\t\\tfor (int i = 0; i < nums.length; i++) {\\n\\t\\t\\tfor (int j = 0; j < nums[i].length; j++) {\\n\\t\\t\\t\\tif (map.containsKey(nums[i][j])) {\\n\\t\\t\\t\\t\\tmap.put(nums[i][j], map.get(nums[i][j]) + 1);\\n\\t\\t\\t\\t} else {\\n\\t\\t\\t\\t\\tmap.put(nums[i][j], 1);\\n\\t\\t\\t\\t}\\n\\t\\t\\t}\\n\\t\\t}\\n        for (Map.Entry<Integer, Integer> ans : map.entrySet()) {\\n\\t\\t\\tif (ans.getValue() == nums.length) {\\n\\t\\t\\t\\tlist.add(ans.getKey());\\n\\t\\t\\t}\\n\\t\\t}\\t\\tCollections.sort(list);\\n\\t\\treturn list;\\n\\t}\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1978602,
                "title": "simple-solution-using-unordered-map-c",
                "content": "Take an unordered map and simply store the values with their number of occurences in the array. Now check if the second value (ie number of occurences) stored in the map is equal to the size of vector (ie nums) then it implies that the value corresponding to this is present in every array. So just push this value in the vector \\'v\\'. The finally made vector v will be the answer.\\n\\n```\\n vector<int> intersection(vector<vector<int>>& nums) {\\n        \\n        int n=nums.size();\\n        unordered_map<int, int> mp;\\n        vector<int> v;\\n        \\n        for(int i=0; i<n; i++){\\n            for(int j=0; j<nums[i].size(); j++){\\n                mp[nums[i][j]]++;\\n            }\\n        }\\n        \\n        for(auto x: mp){\\n            if(x.second == n){\\n                v.push_back(x.first);\\n            }\\n        }\\n        \\n        sort(v.begin(), v.end());\\n        \\n        return v;\\n    }\\n\\t\\n\\t```",
                "solutionTags": [
                    "C"
                ],
                "code": "```\\n vector<int> intersection(vector<vector<int>>& nums) {\\n        \\n        int n=nums.size();\\n        unordered_map<int, int> mp;\\n        vector<int> v;\\n        \\n        for(int i=0; i<n; i++){\\n            for(int j=0; j<nums[i].size(); j++){\\n                mp[nums[i][j]]++;\\n            }\\n        }\\n        \\n        for(auto x: mp){\\n            if(x.second == n){\\n                v.push_back(x.first);\\n            }\\n        }\\n        \\n        sort(v.begin(), v.end());\\n        \\n        return v;\\n    }\\n\\t\\n\\t```",
                "codeTag": "Unknown"
            },
            {
                "id": 1988053,
                "title": "python-2-beginner-friendly-approaches",
                "content": "### Method 1\\n```\\nclass Solution:\\n    def intersection(self, nums: List[List[int]]) -> List[int]:\\n        res = []\\n        concat = []\\n        for i in range(len(nums)):\\n            concat += nums[i]\\n        for i in set(concat):\\n            if concat.count(i) == len(nums):\\n                res.append(i)\\n        return sorted(res)\\n```\\n\\n### Method 2\\n```\\nclass Solution:\\n    def intersection(self, nums: List[List[int]]) -> List[int]:\\n        res = []\\n        nums = sorted(nums, key=len)\\n        check = 0\\n        for i in nums[0]:\\n            for j in nums:\\n                if i in j:\\n                    check += 1\\n            if check == len(nums):\\n                res.append(i)\\n            check = 0\\n        return sorted(res)\\n```",
                "solutionTags": [
                    "Python",
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def intersection(self, nums: List[List[int]]) -> List[int]:\\n        res = []\\n        concat = []\\n        for i in range(len(nums)):\\n            concat += nums[i]\\n        for i in set(concat):\\n            if concat.count(i) == len(nums):\\n                res.append(i)\\n        return sorted(res)\\n```\n```\\nclass Solution:\\n    def intersection(self, nums: List[List[int]]) -> List[int]:\\n        res = []\\n        nums = sorted(nums, key=len)\\n        check = 0\\n        for i in nums[0]:\\n            for j in nums:\\n                if i in j:\\n                    check += 1\\n            if check == len(nums):\\n                res.append(i)\\n            check = 0\\n        return sorted(res)\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1986573,
                "title": "very-easy-cpp-solution-using-map",
                "content": "\\'\\'\\'\\nclass Solution {\\npublic:\\n    vector<int> intersection(vector<vector<int>>& nums) {\\n        unordered_map<int,int>mp;\\n        for(int i=0;i<nums.size();i++){\\n            for(int j=0;j<nums[i].size();j++){\\n                mp[nums[i][j]]++;\\n            }\\n        }\\n        vector<int>ans;\\n        for(auto i:mp){\\n            if(i.second==nums.size()) ans.push_back(i.first);\\n        }\\n        sort(ans.begin(),ans.end());\\n        return ans;\\n    }\\n};",
                "solutionTags": [
                    "C++",
                    "C"
                ],
                "code": "class Solution {\\npublic:\\n    vector<int> intersection(vector<vector<int>>& nums) {\\n        unordered_map<int,int>mp;\\n        for(int i=0;i<nums.size();i++){\\n            for(int j=0;j<nums[i].size();j++){\\n                mp[nums[i][j]]++;\\n            }",
                "codeTag": "Java"
            },
            {
                "id": 1978017,
                "title": "python-simple-solution-using-reduce-and-set",
                "content": "As its an interesection operation, I am using the set intersect using `&` operator to find the common elements. So basically, the code converts each list to set and then performs the intersect between adjacent sets.\\n\\nBelow is my python code for the same:\\n\\n```\\nclass Solution:\\n    def intersection(self, nums: List[List[int]]) -> List[int]:\\n        return sorted(reduce(lambda x,y: set(x) & set(y), nums))\\n```\\n\\n---\\n\\n***Please upvote if you find it useful***\\n\\n",
                "solutionTags": [
                    "Python",
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def intersection(self, nums: List[List[int]]) -> List[int]:\\n        return sorted(reduce(lambda x,y: set(x) & set(y), nums))\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1976877,
                "title": "hashmap-solution-easy-to-understand-c",
                "content": "The idea is to traverse through complete 2d array and count the frequency of every element and at last if the size of outer array is equal to the frequency we return the value.\\n\\n\\uD83D\\uDE42\\n\\n```\\nclass Solution {\\npublic:\\n    vector<int> intersection(vector<vector<int>>& nums) {\\n        map<int,int> hm;\\n        int n = 0;\\n        for(auto it: nums){\\n            for(auto x: it){\\n                hm[x]++;\\n            }\\n            n++;\\n        }\\n        vector<int> ans;\\n        for(auto it: hm){\\n            if(it.second == n){\\n                ans.push_back(it.first);\\n            }\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<int> intersection(vector<vector<int>>& nums) {\\n        map<int,int> hm;\\n        int n = 0;\\n        for(auto it: nums){\\n            for(auto x: it){\\n                hm[x]++;\\n            }\\n            n++;\\n        }\\n        vector<int> ans;\\n        for(auto it: hm){\\n            if(it.second == n){\\n                ans.push_back(it.first);\\n            }\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1976872,
                "title": "java-solution-with-comments-hashmap",
                "content": "```\\npublic List<Integer> intersection(int[][] nums) {\\n        HashMap<Integer,Integer> hm=new HashMap(); //To store the count of number\\n        List<Integer> li=new ArrayList(); // To store the result\\n        for(int i=0;i<nums.length;i++){\\n            for(int j=0;j<nums[i].length;j++){\\n                int val=hm.getOrDefault(nums[i][j],0);\\n                hm.put(nums[i][j],val+1);\\n                if(val+1==nums.length) li.add(nums[i][j]); //whenever we get the count of number equal to row length that mean it is present in every rows.\\n            }\\n        }\\n        Collections.sort(li); //Sort the number in result list.\\n        return li;\\n    }\\n```",
                "solutionTags": [
                    "Java",
                    "Hash Table"
                ],
                "code": "```\\npublic List<Integer> intersection(int[][] nums) {\\n        HashMap<Integer,Integer> hm=new HashMap(); //To store the count of number\\n        List<Integer> li=new ArrayList(); // To store the result\\n        for(int i=0;i<nums.length;i++){\\n            for(int j=0;j<nums[i].length;j++){\\n                int val=hm.getOrDefault(nums[i][j],0);\\n                hm.put(nums[i][j],val+1);\\n                if(val+1==nums.length) li.add(nums[i][j]); //whenever we get the count of number equal to row length that mean it is present in every rows.\\n            }\\n        }\\n        Collections.sort(li); //Sort the number in result list.\\n        return li;\\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3998675,
                "title": "similar-problems-hints-beats-99-clean-code",
                "content": "# Similar Problem:\\nIf you have premium you should definately solve this one after you\\'ve solved the current problem.\\n\\n[1198. Find Smallest Common Element in All Rows (Premium)](https://leetcode.com/problems/find-smallest-common-element-in-all-rows/description/)\\n\\n# Hints:\\n\\nClick to open the hints. Try it yourself!\\n\\n<details open>\\n  <summary>Hint 1</summary>\\n  Notice that each row has no duplicates.\\n</details>\\n<br>\\n<details>\\n  <summary>Hint 2</summary>\\n    Is counting the frequency of elements enough to find the answer?\\n</details>\\n<br>\\n<details>\\n  <summary>Hint 3</summary>\\n    Use a data structure to count the frequency of elements.\\n</details>\\n<br>\\n<details>\\n  <summary>Hint 3</summary>\\n    Iterate for each element in freqMap array. Find an element whose frequency equals the number of rows.\\n</details>\\n\\n# Code\\n``` java []\\nclass Solution {\\n    public List<Integer> intersection(int[][] nums) {\\n        int ROW = nums.length;\\n        int M = 1001;\\n        int[] freq = new int[M];\\n        for(int i=0; i<ROW; i++) {\\n            for(int j=0; j<nums[i].length; j++) {\\n                int num = nums[i][j];\\n                freq[num]++;\\n            }\\n        }\\n        List<Integer> ans = new ArrayList<>();\\n        for(int i=1; i<M; i++) {\\n            if(freq[i] == ROW) {\\n                ans.add(i);\\n            }\\n        }\\n        return ans;\\n    }\\n}\\n```\\n![image.png](https://assets.leetcode.com/users/images/81fc4b03-259b-4d59-983d-2d4028276d0d_1693771202.2572947.png)\\n",
                "solutionTags": [
                    "Java",
                    "Array",
                    "Counting"
                ],
                "code": "``` java []\\nclass Solution {\\n    public List<Integer> intersection(int[][] nums) {\\n        int ROW = nums.length;\\n        int M = 1001;\\n        int[] freq = new int[M];\\n        for(int i=0; i<ROW; i++) {\\n            for(int j=0; j<nums[i].length; j++) {\\n                int num = nums[i][j];\\n                freq[num]++;\\n            }\\n        }\\n        List<Integer> ans = new ArrayList<>();\\n        for(int i=1; i<M; i++) {\\n            if(freq[i] == ROW) {\\n                ans.add(i);\\n            }\\n        }\\n        return ans;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3242570,
                "title": "map-simple-neat-explanation-clean-c-java-code",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nWe need to find the intersection of elements present in all the sub-arrays of the given 2D integer array nums. For this, we can create a hashmap where we store the frequency of each element present in any sub-array of nums. Then, we traverse the hashmap and if the frequency of any element is equal to the number of sub-arrays, we add that element to the result vector.\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n1. We create an `unordered_map<int, int> map` to store the frequency of each element.\\n1. We traverse the `nums` 2D array and for each element in each sub-array, we increment its frequency in `map`.\\n1. We traverse the `map` and for each element whose frequency is equal to the number of sub-arrays, we add that element to the result vector.\\n1. We sort the result vector in ascending order and return it.\\n\\n# Complexity\\n- Time complexity: $$O(n log n)$$, We traverse the nums 2D array once and then the map hashmap once. Both of these operations take O(n) time, where n is the total number of elements in all sub-arrays of nums. Sorting the result vector takes O(k log k) time, where k is the number of elements in the result vector. Since k can be at most equal to the number of elements in any sub-array of nums, which is also equal to n, the time complexity of this algorithm is O(n log n).\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: $$O(n)$$, We store the frequency of each element in the map hashmap, which can contain at most all the elements in all sub-arrays of nums. Therefore, the space complexity of this algorithm is O(n).\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```cpp []\\nclass Solution {\\npublic:\\n    vector<int> intersection(vector<vector<int>>& nums) {\\n        unordered_map<int, int> map;\\n        for(const auto &arr: nums) {\\n            for(const auto &num: arr) {\\n                map[num]++;\\n            }\\n        }\\n        int n = nums.size();\\n        vector<int> res;\\n        for(const auto &it: map) {\\n            if(it.second == n) {\\n                res.push_back(it.first);\\n            }\\n        }\\n        sort(res.begin(), res.end());\\n        return res;\\n    }\\n};\\n```\\n```java []\\nclass Solution {\\n    public List<Integer> intersection(int[][] nums) {\\n        Map<Integer, Integer> map = new HashMap<>();\\n        for (int[] arr : nums) {\\n            for (int num : arr) {\\n                map.put(num, map.getOrDefault(num, 0) + 1);\\n            }\\n        }\\n        int n = nums.length;\\n        List<Integer> res = new ArrayList<>();\\n        for (Map.Entry<Integer, Integer> entry : map.entrySet()) {\\n            if (entry.getValue() == n) {\\n                res.add(entry.getKey());\\n            }\\n        }\\n        Collections.sort(res);\\n        return res;\\n    }\\n}\\n```",
                "solutionTags": [
                    "C++",
                    "Java",
                    "Array",
                    "Hash Table",
                    "Sort"
                ],
                "code": "```cpp []\\nclass Solution {\\npublic:\\n    vector<int> intersection(vector<vector<int>>& nums) {\\n        unordered_map<int, int> map;\\n        for(const auto &arr: nums) {\\n            for(const auto &num: arr) {\\n                map[num]++;\\n            }\\n        }\\n        int n = nums.size();\\n        vector<int> res;\\n        for(const auto &it: map) {\\n            if(it.second == n) {\\n                res.push_back(it.first);\\n            }\\n        }\\n        sort(res.begin(), res.end());\\n        return res;\\n    }\\n};\\n```\n```java []\\nclass Solution {\\n    public List<Integer> intersection(int[][] nums) {\\n        Map<Integer, Integer> map = new HashMap<>();\\n        for (int[] arr : nums) {\\n            for (int num : arr) {\\n                map.put(num, map.getOrDefault(num, 0) + 1);\\n            }\\n        }\\n        int n = nums.length;\\n        List<Integer> res = new ArrayList<>();\\n        for (Map.Entry<Integer, Integer> entry : map.entrySet()) {\\n            if (entry.getValue() == n) {\\n                res.add(entry.getKey());\\n            }\\n        }\\n        Collections.sort(res);\\n        return res;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2503163,
                "title": "easy-short-fast-solution",
                "content": "```\\nPLEASE UPVOTE IF YOU LIKE\\n```\\n```\\n        int[] arr = new int[1001];\\n\\n        for (int i = 0; i <nums.length; i++) {\\n            for (int j = 0; j < nums[i].length; j++) {\\n                arr[ nums[i][j] ]++;\\n            }\\n        }\\n\\n        List<Integer> ans = new ArrayList<>();\\n        for (int i = 1; i < arr.length; i++) {\\n            if (arr[i] == nums.length){\\n                ans.add(i);\\n            }\\n        }\\n        return ans;",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nPLEASE UPVOTE IF YOU LIKE\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2031279,
                "title": "javascript-solution-no-map-or-set-70-ms-4-1-mb",
                "content": "```\\nvar intersection = function(nums) {\\n     let ref = [...nums[0]]\\n     for(let i = 1; i < nums.length; i++){\\n         ref = ref.filter(n => nums[i].includes(n))\\n     }\\n    return ref.sort((a,b) => a-b)\\n};\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\nvar intersection = function(nums) {\\n     let ref = [...nums[0]]\\n     for(let i = 1; i < nums.length; i++){\\n         ref = ref.filter(n => nums[i].includes(n))\\n     }\\n    return ref.sort((a,b) => a-b)\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1978092,
                "title": "javascript-js",
                "content": "```\\n/**\\n * @param {number[][]} nums\\n * @return {number[]}\\n */\\nvar intersection = function (nums) {\\n  const result = [];\\n\\n  for (let i = 0; i < nums[0].length; i++) {\\n    if (nums.every((x) => x.includes(nums[0][i]))) {\\n      result.push(nums[0][i]);\\n    }\\n  }\\n\\n  return result.sort((a, b) => a - b);\\n};\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\n/**\\n * @param {number[][]} nums\\n * @return {number[]}\\n */\\nvar intersection = function (nums) {\\n  const result = [];\\n\\n  for (let i = 0; i < nums[0].length; i++) {\\n    if (nums.every((x) => x.includes(nums[0][i]))) {\\n      result.push(nums[0][i]);\\n    }\\n  }\\n\\n  return result.sort((a, b) => a - b);\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1977926,
                "title": "frequency-count-count-sort-w-array-c-100-fast-3ms",
                "content": "Since the numbers in each array are distinct and the range these numbers are in is limited to 1 to 1000 we can just use a frequency count. The answer is all these numbers that are found as often as the number of arrays.\\n\\n```\\n    vector<int> intersection(vector<vector<int>>& nums) {\\n        array<int, 1001> counts = {};\\n        for (const auto& as : nums) {\\n            for (int a : as) {\\n                ++counts[a];\\n            }\\n        }\\n        vector<int> ans;\\n        for (int i = 0; i < size(counts); ++i) {\\n            if (counts[i] == size(nums)) ans.push_back(i);\\n        }\\n        return ans;\\n    }\\n```",
                "solutionTags": [
                    "C",
                    "Array",
                    "Counting Sort"
                ],
                "code": "```\\n    vector<int> intersection(vector<vector<int>>& nums) {\\n        array<int, 1001> counts = {};\\n        for (const auto& as : nums) {\\n            for (int a : as) {\\n                ++counts[a];\\n            }\\n        }\\n        vector<int> ans;\\n        for (int i = 0; i < size(counts); ++i) {\\n            if (counts[i] == size(nums)) ans.push_back(i);\\n        }\\n        return ans;\\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1977109,
                "title": "c-easy-solution-beginners-friendly",
                "content": "```\\nclass Solution {\\npublic:\\n    vector<int> intersection(vector<vector<int>>& nums) {\\n        unordered_map<int,int> mp;\\n        int k = 0;\\n        int n = nums.size();\\n        for(int i=0;i<n;i++)\\n        {\\n            for(int j=0;j<nums[i].size();j++)\\n            {\\n                mp[nums[i][j]]++;\\n            }\\n        }\\n        vector<int> v;\\n        for(auto it : mp)\\n        {\\n            if(it.second == n)\\n            {\\n                v.push_back(it.first);\\n            }\\n        }\\n        sort(v.begin(),v.end());\\n        return v;\\n    }\\n};\\n",
                "solutionTags": [
                    "C"
                ],
                "code": "class Solution {\\npublic:\\n    vector<int> intersection(vector<vector<int>>& nums) {\\n        unordered_map<int,int> mp;\\n        int k = 0;\\n        int n = nums.size();\\n        for(int i=0;i<n;i++)\\n        {\\n            for(int j=0;j<nums[i].size();j++)\\n            {\\n                mp[nums[i][j]]++;\\n            }",
                "codeTag": "Java"
            },
            {
                "id": 1977024,
                "title": "beginners-friendly-unordered-map-c-solution-easy-to-understand",
                "content": "```\\nclass Solution {\\npublic:\\n    vector<int> intersection(vector<vector<int>>& nums) {\\n        int n=nums.size();\\n        vector<int> result;\\n        unordered_map<int,int> umap;\\n        for(int i=0;i<nums.size();i++)\\n        {\\n            for(int j=0;j<nums[i].size();j++)\\n            {\\n                if(umap[nums[i][j]]<i+1)\\n                {\\n                    umap[nums[i][j]]++;\\n                }\\n            }\\n        }\\n        \\n        for(auto i=umap.begin();i!=umap.end();i++)\\n        {\\n            if(i->second==n)\\n            {\\n                result.push_back(i->first);\\n            }\\n        }\\n        sort(result.begin(),result.end());\\n        return result;\\n    }\\n};\\n```\\n**Like it? Please Upvote ;-)**",
                "solutionTags": [
                    "C++",
                    "C"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<int> intersection(vector<vector<int>>& nums) {\\n        int n=nums.size();\\n        vector<int> result;\\n        unordered_map<int,int> umap;\\n        for(int i=0;i<nums.size();i++)\\n        {\\n            for(int j=0;j<nums[i].size();j++)\\n            {\\n                if(umap[nums[i][j]]<i+1)\\n                {\\n                    umap[nums[i][j]]++;\\n                }\\n            }\\n        }\\n        \\n        for(auto i=umap.begin();i!=umap.end();i++)\\n        {\\n            if(i->second==n)\\n            {\\n                result.push_back(i->first);\\n            }\\n        }\\n        sort(result.begin(),result.end());\\n        return result;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1977013,
                "title": "python-solution-3-line",
                "content": "```\\nclass Solution:\\n    def intersection(self, nums: List[List[int]]) -> List[int]:\\n        a=set(nums[0])\\n        inters=a.intersection(*nums)\\n        return sorted(list(inters))\\n\\n\\n```",
                "solutionTags": [
                    "Python",
                    "Python3",
                    "Ordered Set"
                ],
                "code": "```\\nclass Solution:\\n    def intersection(self, nums: List[List[int]]) -> List[int]:\\n        a=set(nums[0])\\n        inters=a.intersection(*nums)\\n        return sorted(list(inters))\\n\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1976938,
                "title": "python3-set-intersection",
                "content": "```\\nclass Solution:\\n    def intersection(self, nums: List[List[int]]) -> List[int]:\\n        return sorted(set.intersection(*[set(nums[i]) for i in range(len(nums))]))\\n```\\n\\nExplanation:\\n```\\nclass Solution:\\n    def intersection(self, nums: List[List[int]]) -> List[int]:\\n        answ=set(nums[0])\\n        for i in range(1,len(nums)):\\n            answ=answ.intersection(set(nums[i]))\\n        return sorted(answ)       \\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution:\\n    def intersection(self, nums: List[List[int]]) -> List[int]:\\n        return sorted(set.intersection(*[set(nums[i]) for i in range(len(nums))]))\\n```\n```\\nclass Solution:\\n    def intersection(self, nums: List[List[int]]) -> List[int]:\\n        answ=set(nums[0])\\n        for i in range(1,len(nums)):\\n            answ=answ.intersection(set(nums[i]))\\n        return sorted(answ)       \\n```",
                "codeTag": "Java"
            },
            {
                "id": 3735502,
                "title": "100-easy-java-solution",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n![download.png](https://assets.leetcode.com/users/images/b5a56023-fcae-487f-9530-a2acad56fab3_1688804872.161732.png)\\n```\\nclass Solution {\\n    public List<Integer> intersection(int[][] nums) {\\n        List<Integer>list=new ArrayList<>();\\n        for(int j=0;j<nums[0].length;j++)\\n        {\\n            list.add(nums[0][j]);\\n        }\\n\\n        for(int i=1;i<nums.length;i++)\\n        {\\n          List<Integer>list1=new ArrayList<>();\\n          for(int j=0;j<nums[i].length;j++)\\n          {\\n              if(list.contains(nums[i][j]))\\n              list1.add(nums[i][j]);\\n          }\\n          list=list1;\\n        }\\n        Collections.sort(list);\\n        return list;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public List<Integer> intersection(int[][] nums) {\\n        List<Integer>list=new ArrayList<>();\\n        for(int j=0;j<nums[0].length;j++)\\n        {\\n            list.add(nums[0][j]);\\n        }\\n\\n        for(int i=1;i<nums.length;i++)\\n        {\\n          List<Integer>list1=new ArrayList<>();\\n          for(int j=0;j<nums[i].length;j++)\\n          {\\n              if(list.contains(nums[i][j]))\\n              list1.add(nums[i][j]);\\n          }\\n          list=list1;\\n        }\\n        Collections.sort(list);\\n        return list;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3428183,
                "title": "python-good-looking-solution-easy-to-understand",
                "content": "\\n# Complexity\\n- Time complexity: O(n^2)\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: O(n^2)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution:\\n    def intersection(self, nums: List[List[int]]) -> List[int]:\\n\\n        ll = []\\n        sortedNums = sorted(nums)\\n\\n        for num in sortedNums[0]:\\n            cou = 1\\n\\n            for listNums in sortedNums[1:]:\\n                if num not in listNums:\\n                    cou = 0\\n                    break\\n            \\n            if cou:\\n                ll.append(num)\\n\\n        return sorted(ll)\\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def intersection(self, nums: List[List[int]]) -> List[int]:\\n\\n        ll = []\\n        sortedNums = sorted(nums)\\n\\n        for num in sortedNums[0]:\\n            cou = 1\\n\\n            for listNums in sortedNums[1:]:\\n                if num not in listNums:\\n                    cou = 0\\n                    break\\n            \\n            if cou:\\n                ll.append(num)\\n\\n        return sorted(ll)\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2830590,
                "title": "java-solution",
                "content": "# Code\\n```\\nclass Solution {\\n    public List<Integer> intersection(int[][] nums) {\\n        Map<Integer, Integer> map = new HashMap<>();\\n        for (int i = 0; i < nums.length; i++) {\\n            for (int j = 0; j < nums[i].length; j++) {\\n                if (map.containsKey(nums[i][j])) {\\n                    map.put(nums[i][j], map.get(nums[i][j]) + 1);\\n                } else {\\n                    map.put(nums[i][j], 1);\\n                }\\n            }\\n        }\\n        List<Integer> list = new ArrayList<>();\\n        for (Integer key : map.keySet()) {\\n            if (map.get(key) == nums.length) {\\n                list.add(key);\\n            }\\n        }\\n        Collections.sort(list);\\n        return list;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public List<Integer> intersection(int[][] nums) {\\n        Map<Integer, Integer> map = new HashMap<>();\\n        for (int i = 0; i < nums.length; i++) {\\n            for (int j = 0; j < nums[i].length; j++) {\\n                if (map.containsKey(nums[i][j])) {\\n                    map.put(nums[i][j], map.get(nums[i][j]) + 1);\\n                } else {\\n                    map.put(nums[i][j], 1);\\n                }\\n            }\\n        }\\n        List<Integer> list = new ArrayList<>();\\n        for (Integer key : map.keySet()) {\\n            if (map.get(key) == nums.length) {\\n                list.add(key);\\n            }\\n        }\\n        Collections.sort(list);\\n        return list;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2829559,
                "title": "python3-one-line-solution",
                "content": "```\\nclass Solution:\\n    def intersection(self, nums: List[List[int]]) -> List[int]:\\n        return sorted(reduce(lambda x,y: set(x) & set(y),nums))\\n```\\nYou don\\'t have to use Counter , just set and reduce.\\nIt\\'s easier than Counter.",
                "solutionTags": [
                    "Python3",
                    "Ordered Set"
                ],
                "code": "```\\nclass Solution:\\n    def intersection(self, nums: List[List[int]]) -> List[int]:\\n        return sorted(reduce(lambda x,y: set(x) & set(y),nums))\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2725370,
                "title": "python3",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution:\\n    def intersection(self, nums: List[List[int]]) -> List[int]:\\n        d = {}\\n        \\n        for i in range(len(nums)):\\n            for j in nums[i]:\\n                if j not in d:\\n                    d[j] = 1\\n                else:\\n                    d[j]+=1\\n                    \\n        res = []\\n        for k,v in d.items():\\n            if v == len(nums):\\n                res.append(k)\\n                \\n        return sorted(res)\\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def intersection(self, nums: List[List[int]]) -> List[int]:\\n        d = {}\\n        \\n        for i in range(len(nums)):\\n            for j in nums[i]:\\n                if j not in d:\\n                    d[j] = 1\\n                else:\\n                    d[j]+=1\\n                    \\n        res = []\\n        for k,v in d.items():\\n            if v == len(nums):\\n                res.append(k)\\n                \\n        return sorted(res)\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2633724,
                "title": "java-solution-count-sort-no-hashing-easy",
                "content": "### ***Please Upvote !!!*** **(\\u25E0\\u203F\\u25E0)**\\n```\\nclass Solution {\\n    public List<Integer> intersection(int[][] nums) {\\n        int[] freq = new int[1001];\\n\\n        for (int[] row : nums) {\\n            for (int n : row) {\\n                freq[n]++;\\n            }\\n        }\\n\\n        List<Integer> ans = new ArrayList<>();\\n\\t\\t\\n        for (int i = 1; i < freq.length; i++) {\\n            if (freq[i] == nums.length) {\\n                ans.add(i);\\n            }\\n        }\\n\\n        return ans;\\n    }\\n}\\n\\n// TC: O(m * n), SC: O(1) - ignoring the output array\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public List<Integer> intersection(int[][] nums) {\\n        int[] freq = new int[1001];\\n\\n        for (int[] row : nums) {\\n            for (int n : row) {\\n                freq[n]++;\\n            }\\n        }\\n\\n        List<Integer> ans = new ArrayList<>();\\n\\t\\t\\n        for (int i = 1; i < freq.length; i++) {\\n            if (freq[i] == nums.length) {\\n                ans.add(i);\\n            }\\n        }\\n\\n        return ans;\\n    }\\n}\\n\\n// TC: O(m * n), SC: O(1) - ignoring the output array\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2459309,
                "title": "java-stream-solution",
                "content": "`THIS IS NOT FASTER SOLUTION`\\n`BUT 1 LINE CODE `\\n```\\nclass Solution {\\n    public List<Integer> intersection(int[][] nums) {\\n\\t\\t//return Arrays.stream(nums).flatMapToInt(Arrays::stream).boxed().collect(Collectors.toMap(i -> i, i -> 1, Integer::sum)).entrySet().stream().sorted(Map.Entry.comparingByValue()).filter(item -> item.getValue() == nums.length).map(Map.Entry::getKey).sorted().collect(Collectors.toList());\\n\\n        return Arrays.stream(nums)\\n                .flatMapToInt(Arrays::stream)\\n                .boxed()\\n                .collect(Collectors.toMap(i -> i, i -> 1, Integer::sum))\\n                .entrySet()\\n                .stream()\\n                .sorted(Map.Entry.comparingByValue())\\n                .filter(item -> item.getValue() == nums.length)\\n                .map(Map.Entry::getKey)\\n                .sorted()\\n                .collect(Collectors.toList());\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public List<Integer> intersection(int[][] nums) {\\n\\t\\t//return Arrays.stream(nums).flatMapToInt(Arrays::stream).boxed().collect(Collectors.toMap(i -> i, i -> 1, Integer::sum)).entrySet().stream().sorted(Map.Entry.comparingByValue()).filter(item -> item.getValue() == nums.length).map(Map.Entry::getKey).sorted().collect(Collectors.toList());\\n\\n        return Arrays.stream(nums)\\n                .flatMapToInt(Arrays::stream)\\n                .boxed()\\n                .collect(Collectors.toMap(i -> i, i -> 1, Integer::sum))\\n                .entrySet()\\n                .stream()\\n                .sorted(Map.Entry.comparingByValue())\\n                .filter(item -> item.getValue() == nums.length)\\n                .map(Map.Entry::getKey)\\n                .sorted()\\n                .collect(Collectors.toList());\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2458233,
                "title": "funny-solution-with-go",
                "content": "```\\nfunc intersection(nums [][]int) []int {\\n    numSet := make([]int, 1001)\\n    \\n    for i := 0; i < len(nums); i++ {\\n        for j := 0; j < len(nums[i]); j++ {\\n            numSet[nums[i][j]]++\\n        }\\n    }\\n    \\n    var res []int\\n    \\n    for i := 0; i < 1001; i++ {\\n        if numSet[i] == len(nums) {\\n            res = append(res, i)\\n        }\\n    }\\n    \\n    sort.Ints(res)\\n    \\n    return res\\n}\\n```",
                "solutionTags": [
                    "Go"
                ],
                "code": "```\\nfunc intersection(nums [][]int) []int {\\n    numSet := make([]int, 1001)\\n    \\n    for i := 0; i < len(nums); i++ {\\n        for j := 0; j < len(nums[i]); j++ {\\n            numSet[nums[i][j]]++\\n        }\\n    }\\n    \\n    var res []int\\n    \\n    for i := 0; i < 1001; i++ {\\n        if numSet[i] == len(nums) {\\n            res = append(res, i)\\n        }\\n    }\\n    \\n    sort.Ints(res)\\n    \\n    return res\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2433257,
                "title": "intersection-of-multiple-arrays-solution-java",
                "content": "class Solution {\\n  public List<Integer> intersection(int[][] nums) {\\n    List<Integer> ans = new ArrayList<>();\\n    int[] count = new int[1001];\\n\\n    for (int[] A : nums)\\n      for (final int a : A)\\n        ++count[a];\\n\\n    for (int i = 1; i < 1001; ++i)\\n      if (count[i] == nums.length)\\n        ans.add(i);\\n\\n    return ans;\\n  }\\n}\\n",
                "solutionTags": [
                    "Array",
                    "Hash Table",
                    "Counting"
                ],
                "code": "class Solution {\\n  public List<Integer> intersection(int[][] nums) {\\n    List<Integer> ans = new ArrayList<>();\\n    int[] count = new int[1001];\\n\\n    for (int[] A : nums)\\n      for (final int a : A)\\n        ++count[a];\\n\\n    for (int i = 1; i < 1001; ++i)\\n      if (count[i] == nums.length)\\n        ans.add(i);\\n\\n    return ans;\\n  }",
                "codeTag": "Java"
            },
            {
                "id": 2336950,
                "title": "python-short-simple-set",
                "content": "```\\ndef intersection(self, nums: List[List[int]]) -> List[int]:\\n        temp = set(nums[0])\\n        for i in range(1,len(nums)):\\n            temp = (temp & set(nums[i]))\\n    \\n        return list(sorted(temp))\\n```",
                "solutionTags": [
                    "Python",
                    "Python3",
                    "Ordered Set"
                ],
                "code": "```\\ndef intersection(self, nums: List[List[int]]) -> List[int]:\\n        temp = set(nums[0])\\n        for i in range(1,len(nums)):\\n            temp = (temp & set(nums[i]))\\n    \\n        return list(sorted(temp))\\n```",
                "codeTag": "Python3"
            },
            {
                "id": 2234821,
                "title": "python-easy-understanding",
                "content": "```\\nclass Solution:\\n    def intersection(self, nums: List[List[int]]) -> List[int]:\\n        \\n        intersection = nums[0]\\n        \\n        for i in range(1,len(nums)):\\n            intersection = set(nums[i]) & set(intersection)\\n        \\n        return sorted(list(intersection))\\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def intersection(self, nums: List[List[int]]) -> List[int]:\\n        \\n        intersection = nums[0]\\n        \\n        for i in range(1,len(nums)):\\n            intersection = set(nums[i]) & set(intersection)\\n        \\n        return sorted(list(intersection))\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2013370,
                "title": "ruby-one-liner",
                "content": "```\\n# @param {Integer[][]} nums\\n# @return {Integer[]}\\ndef intersection(nums)\\n  nums.reduce(:&).sort  \\nend\\n```",
                "solutionTags": [],
                "code": "```\\n# @param {Integer[][]} nums\\n# @return {Integer[]}\\ndef intersection(nums)\\n  nums.reduce(:&).sort  \\nend\\n```",
                "codeTag": "Python3"
            },
            {
                "id": 1993733,
                "title": "easy-clear-and-detailed-explanation-faster-than-80-96-of-python3-online-submissions",
                "content": "* FInd the length of the 2D array \\n* Use hashtable to find out the frequency of each element \\n* Check whether the frequency of an element equals the length of the 2D array ( This would specify that the element occurs in all the array of the 2D array)\\n* Store the answer in the list and sort it\\n\\t\\t\\n\\t\\tdef intersection(self, nums: List[List[int]]) -> List[int]:\\n\\t\\t\\n\\t\\t\"\"\" Declarations \"\"\"\\n\\t\\t\\n        n_of_lists = len(nums)  # finding no. array within 2D array\\n\\t\\t\\n        hmap = {} # hashmap to map the elements with their frequency\\n\\t\\t\\n        ans = [] # list to store the final answer\\n\\t\\t\\n\\t\\t\"\"\" Finding the frequency of each element \"\"\"\\n\\t\\t\\n        for i in range(len(nums)):\\n\\t\\t\\n            for j in range(len(nums[i])):\\n\\t\\t\\t\\n                if nums[i][j] in hmap:\\n\\t\\t\\t\\t\\n                    hmap[nums[i][j]] += 1\\n\\t\\t\\t\\t\\t\\n                else:\\n\\t\\t\\t\\t\\n                    hmap[nums[i][j]] = 1\\n\\t\\t\\n\\t\\t\"\"\" Checking whether the frequency an element equals the no of the array within the 2D array \"\"\"\\n\\t\\t\\n        for k, v in hmap.items():\\n\\t\\t\\n            if v == n_of_lists:\\n\\t\\t\\t\\n                ans.append(k)  # appending the result\\n\\t\\t\\t\\t\\n        return sorted(ans)  # finally sorting the array ( given in the question)\\n\\t\\t\\nDo Upvote if you like it :))\\n",
                "solutionTags": [
                    "Python"
                ],
                "code": "* FInd the length of the 2D array \\n* Use hashtable to find out the frequency of each element \\n* Check whether the frequency of an element equals the length of the 2D array ( This would specify that the element occurs in all the array of the 2D array)\\n* Store the answer in the list and sort it\\n\\t\\t\\n\\t\\tdef intersection(self, nums: List[List[int]]) -> List[int]:\\n\\t\\t\\n\\t\\t\"\"\" Declarations \"\"\"\\n\\t\\t\\n        n_of_lists = len(nums)  # finding no. array within 2D array\\n\\t\\t\\n        hmap = {} # hashmap to map the elements with their frequency\\n\\t\\t\\n        ans = [] # list to store the final answer\\n\\t\\t\\n\\t\\t\"\"\" Finding the frequency of each element \"\"\"\\n\\t\\t\\n        for i in range(len(nums)):\\n\\t\\t\\n            for j in range(len(nums[i])):\\n\\t\\t\\t\\n                if nums[i][j] in hmap:\\n\\t\\t\\t\\t\\n                    hmap[nums[i][j]] += 1\\n\\t\\t\\t\\t\\t\\n                else:\\n\\t\\t\\t\\t\\n                    hmap[nums[i][j]] = 1\\n\\t\\t\\n\\t\\t\"\"\" Checking whether the frequency an element equals the no of the array within the 2D array \"\"\"\\n\\t\\t\\n        for k, v in hmap.items():\\n\\t\\t\\n            if v == n_of_lists:\\n\\t\\t\\t\\n                ans.append(k)  # appending the result\\n\\t\\t\\t\\t\\n        return sorted(ans)  # finally sorting the array ( given in the question)\\n\\t\\t\\nDo Upvote if you like it :))\\n",
                "codeTag": "Python3"
            },
            {
                "id": 1989394,
                "title": "c-easy-solution-unoredered-map",
                "content": "\\n\\n    class Solution {\\n    public:\\n    vector<int> intersection(vector<vector<int>>& nums) {\\n        vector<int>vect;\\n        int y=nums.size();\\n        unordered_map<int,int>mp;\\n        for(int i=0;i<nums.size();i++){\\n            for(int j=0;j<nums[i].size();j++){\\n                mp[nums[i][j]]++;\\n            }\\n        }\\n        for(auto x:mp){\\n            if(x.second>=y){\\n                vect.push_back(x.first);\\n            }\\n        }\\n        sort(vect.begin(),vect.end());\\n        return vect;\\n      }\\n    };\\n   \\n   \\n   \\n**IF U FIND IT USEFUL PLEASE UPVOTE IT**",
                "solutionTags": [
                    "C"
                ],
                "code": "class Solution {\\n    public:\\n    vector<int> intersection(vector<vector<int>>& nums) {\\n        vector<int>vect;\\n        int y=nums.size();\\n        unordered_map<int,int>mp;\\n        for(int i=0;i<nums.size();i++){\\n            for(int j=0;j<nums[i].size();j++){\\n                mp[nums[i][j]]++;\\n            }",
                "codeTag": "Java"
            },
            {
                "id": 1978809,
                "title": "rust-solution",
                "content": "```\\nimpl Solution {\\n    pub fn intersection(nums: Vec<Vec<i32>>) -> Vec<i32> {\\n        let l = nums.len();\\n        let mut counter = [0; 1001];\\n        nums.iter()\\n            .flat_map(|v| v.iter())\\n            .for_each(|v| counter[*v as usize] += 1);\\n\\n        counter\\n            .iter()\\n            .zip(0..)\\n            .filter_map(|(&num, idx)| if num == l { Some(idx) } else { None })\\n            .collect()\\n    }\\n}\\n```",
                "solutionTags": [
                    "Rust"
                ],
                "code": "```\\nimpl Solution {\\n    pub fn intersection(nums: Vec<Vec<i32>>) -> Vec<i32> {\\n        let l = nums.len();\\n        let mut counter = [0; 1001];\\n        nums.iter()\\n            .flat_map(|v| v.iter())\\n            .for_each(|v| counter[*v as usize] += 1);\\n\\n        counter\\n            .iter()\\n            .zip(0..)\\n            .filter_map(|(&num, idx)| if num == l { Some(idx) } else { None })\\n            .collect()\\n    }\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1977739,
                "title": "3-approach-java-sol",
                "content": "Using array as HashMap :\\n```\\n public List<Integer> intersection(int[][] a) {\\n        List<Integer> ans =new ArrayList<>();\\n        int dp[]=new int[1001];\\n        \\n        for(int i=0;i<a.length;i++)\\n        {\\n            for(int x: a[i])\\n            {\\n                dp[x]++;\\n            }\\n        }\\n        \\n        for(int i=1;i<=1000;i++) if(dp[i]==a.length)ans.add(i);\\n        \\n        return ans;\\n    }\\n```\\n\\nSimple Hashmap soln :\\n```\\npublic List<Integer> intersection(int[][] a) {\\n        List<Integer> ans =new ArrayList<>();\\n        HashMap<Integer,Integer> hm =new HashMap<>();\\n        \\n        for(int i=0;i<a.length;i++)\\n        {\\n            for(int x : a[i])\\n            {\\n                if(!hm.containsKey(x)) hm.put(x,0);\\n                  \\n                hm.put(x,hm.get(x)+1);\\n            }\\n        }\\n        \\n        for(int key : hm.keySet())\\n        {\\n            if(hm.get(key)==a.length)ans.add(key);\\n        }\\n        \\n        Collections.sort(ans);\\n        return ans;\\n    }\\n```\\nHashSet soln : \\n\\n```\\n    public List<Integer> intersection(int[][] a) {\\n        List<Integer> ans =new ArrayList<>();\\n        HashSet<Integer> cur =new HashSet<>();\\n        for(int i=0;i<a[0].length;i++) cur.add(a[0][i]);\\n        \\n        for(int i=1;i<a.length;i++)\\n        {  HashSet<Integer> newcur =new HashSet<>(); \\n           for(int x : a[i])\\n           {\\n               if(cur.contains(x)) newcur.add(x);\\n           }\\n           cur=newcur;\\n        }\\n        \\n        for(int x : cur) ans.add(x);\\n        \\n        Collections.sort(ans);\\n        \\n        return ans;\\n    }\\n```\\n",
                "solutionTags": [],
                "code": "```\\n public List<Integer> intersection(int[][] a) {\\n        List<Integer> ans =new ArrayList<>();\\n        int dp[]=new int[1001];\\n        \\n        for(int i=0;i<a.length;i++)\\n        {\\n            for(int x: a[i])\\n            {\\n                dp[x]++;\\n            }\\n        }\\n        \\n        for(int i=1;i<=1000;i++) if(dp[i]==a.length)ans.add(i);\\n        \\n        return ans;\\n    }\\n```\n```\\npublic List<Integer> intersection(int[][] a) {\\n        List<Integer> ans =new ArrayList<>();\\n        HashMap<Integer,Integer> hm =new HashMap<>();\\n        \\n        for(int i=0;i<a.length;i++)\\n        {\\n            for(int x : a[i])\\n            {\\n                if(!hm.containsKey(x)) hm.put(x,0);\\n                  \\n                hm.put(x,hm.get(x)+1);\\n            }\\n        }\\n        \\n        for(int key : hm.keySet())\\n        {\\n            if(hm.get(key)==a.length)ans.add(key);\\n        }\\n        \\n        Collections.sort(ans);\\n        return ans;\\n    }\\n```\n```\\n    public List<Integer> intersection(int[][] a) {\\n        List<Integer> ans =new ArrayList<>();\\n        HashSet<Integer> cur =new HashSet<>();\\n        for(int i=0;i<a[0].length;i++) cur.add(a[0][i]);\\n        \\n        for(int i=1;i<a.length;i++)\\n        {  HashSet<Integer> newcur =new HashSet<>(); \\n           for(int x : a[i])\\n           {\\n               if(cur.contains(x)) newcur.add(x);\\n           }\\n           cur=newcur;\\n        }\\n        \\n        for(int x : cur) ans.add(x);\\n        \\n        Collections.sort(ans);\\n        \\n        return ans;\\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3946874,
                "title": "no-set-sort-or-hashmap-use-masks",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n* It\\'s highlighted that the integers in each sublist are **distinct**.\\n* The result must be sorted in ascending order.\\n    * I think the point is to build your result in a way that it turns out to be ascending.\\n    * Not that you build however and finally sort it!\\n* Use the constraint: `1 <= nums[i] <= 1000`\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n* For each sublist create a `mask`\\n* `mask` is an integer.\\n* See it as an array of bits.\\n\\t* 0-indexed from the right.\\n* The length of this array is limited by the range of elements in each sublist of `nums`.\\n\\t* In this particular problem, `mask` can be, atmost, an array of 1000 bits.\\n\\t\\t* Now that could be a pretty large number. But Python can handle arbitrarily large numbers!\\n* Let `arr` be a sublist of `nums`\\n* For each `n` in `arr`\\n\\t* Set the `n-1`-th bit from the right.\\t    \\n\\t    * The right-most bit is the `0`-th bit.\\n\\t    * When we \"set a bit\", we mean we set it to `1`.\\n\\n* Take the intersection of all these masks.\\n* The bits that are set in `intersection` correspond to the desired numbers that are common in all the sublists.\\n* Iterate over each bit in `intersection` to check if the bit is set or not.\\n    * If set, add the corresponding element to the result.\\n\\n\\n# Complexity\\n- Time complexity: `O(n)`, where `n = len(nums)`\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: `O(n)`, where `n = len(nums)`\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution:\\n    def intersection(self, nums: List[List[int]]) -> List[int]:\\n        minVal = 1                \\n        \\n        def generateMask(arr):\\n            mask = 0\\n            for n in arr:\\n                mask |= (1 << (n - minVal))\\n            return mask\\n\\n        intersection = reduce(lambda x, y: x & y, map(generateMask, nums))\\n\\n        result = []\\n        ele = 0\\n        while intersection:\\n            if intersection & 1:\\n                result.append(ele + minVal)\\n            intersection >>= 1\\n            ele += 1\\n\\n        return result\\n```",
                "solutionTags": [
                    "Python3",
                    "Bit Manipulation"
                ],
                "code": "```\\nclass Solution:\\n    def intersection(self, nums: List[List[int]]) -> List[int]:\\n        minVal = 1                \\n        \\n        def generateMask(arr):\\n            mask = 0\\n            for n in arr:\\n                mask |= (1 << (n - minVal))\\n            return mask\\n\\n        intersection = reduce(lambda x, y: x & y, map(generateMask, nums))\\n\\n        result = []\\n        ele = 0\\n        while intersection:\\n            if intersection & 1:\\n                result.append(ele + minVal)\\n            intersection >>= 1\\n            ele += 1\\n\\n        return result\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3510601,
                "title": "beginners-friendly-solution",
                "content": "\\n# Code\\n```\\nclass Solution {\\n    public List<Integer> intersection(int[][] nums) {\\n        // add 1st row to set\\n        HashSet<Integer> common= new HashSet<>();\\n\\n        for(int i=0;i<nums[0].length;i++){\\n            common.add(nums[0][i]);\\n        }\\n        //now add other rows and retain only those in common if it present in current set;\\n\\n        for(int i=1;i<nums.length;i++){\\n            HashSet<Integer> current= new HashSet<>();\\n            for(int j=0;j<nums[i].length;j++){\\n                if(common.contains(nums[i][j]))\\n                        current.add(nums[i][j]);\\n            }\\n            common.retainAll(current);\\n        }\\n\\n        List<Integer> ls= new ArrayList<>(common);\\n        Collections.sort(ls);\\n\\n        return ls;\\n\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public List<Integer> intersection(int[][] nums) {\\n        // add 1st row to set\\n        HashSet<Integer> common= new HashSet<>();\\n\\n        for(int i=0;i<nums[0].length;i++){\\n            common.add(nums[0][i]);\\n        }\\n        //now add other rows and retain only those in common if it present in current set;\\n\\n        for(int i=1;i<nums.length;i++){\\n            HashSet<Integer> current= new HashSet<>();\\n            for(int j=0;j<nums[i].length;j++){\\n                if(common.contains(nums[i][j]))\\n                        current.add(nums[i][j]);\\n            }\\n            common.retainAll(current);\\n        }\\n\\n        List<Integer> ls= new ArrayList<>(common);\\n        Collections.sort(ls);\\n\\n        return ls;\\n\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3329787,
                "title": "intersection-of-multiple-arrays-solution-in-c",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\nO(n^2)\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\nO(n)\\n# Code\\n```\\nclass Solution {\\npublic:\\n    vector<int> intersection(vector<vector<int>>& nums) {\\n        int i, j, flag=0;\\n        vector<int> ans;\\n        for(i=0 ; i<nums[0].size() ; i++)\\n        {\\n            flag=0;\\n            for(j=1 ; j<nums.size() ; j++)\\n            {\\n                if(count(nums[j].begin(), nums[j].end(), nums[0][i])==0)\\n                {\\n                    flag=1;\\n                    break;\\n                }\\n            }\\n            if(flag==0)\\n            {\\n                ans.push_back(nums[0][i]);\\n            }\\n        }\\n        sort(ans.begin(), ans.end());\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<int> intersection(vector<vector<int>>& nums) {\\n        int i, j, flag=0;\\n        vector<int> ans;\\n        for(i=0 ; i<nums[0].size() ; i++)\\n        {\\n            flag=0;\\n            for(j=1 ; j<nums.size() ; j++)\\n            {\\n                if(count(nums[j].begin(), nums[j].end(), nums[0][i])==0)\\n                {\\n                    flag=1;\\n                    break;\\n                }\\n            }\\n            if(flag==0)\\n            {\\n                ans.push_back(nums[0][i]);\\n            }\\n        }\\n        sort(ans.begin(), ans.end());\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3261087,
                "title": "c-with-detailed-explanation",
                "content": "# Approach\\n1. Using a dictionary, we are going to count the number of occurrences of each integer in **ALL ARRAYS**.\\n2. After that, it checks WHICH NUMBERS have counts **EQUAL** to the **LENGTH** of the input array, meaning they are present in all subarrays.\\n\\n# C# Syntax Highlights\\n- **IList<int>** instead of a concrete implementation like List<int> in C# allows for more flexibility. A list is a more specific type that implement the interface IList. Problably not make a difference here.\\n\\n**LINQ FILTERS: Where, Select, OrderBy, ToArray**\\n- The Where method is used to filter a collection based on a condition specified by a lambda expression. In this code, it **returns a new collection of key-value pairs where the value of each key is equal to the length of the nums array**.\\n- The Select method takes the filtered collection of key-value pairs and **creates a new collection that contains only the keys**.\\n- The OrderBy method **sorts the collection** in ascending order by the key.\\n- Finally, the ToArray method converts the collection to an array.\\n\\n# Complexity\\n- Time complexity:\\n\\n    The time complexity of this code is O(nmlog(m)). \\n    n = number of subarrays \\n    m = maximum length each (so nm). \\n    \\n    The sorting adds the logm to the final complexity.\\n    \\n    Using a dictionary is generally faster than using a list for counting occurrences of elements, because dictionary lookup and insertion have an average time complexity of O(1), while list lookup and insertion have an average time complexity of O(n).\\n\\n\\n- Space complexity:\\n    The space complexity of this code is also O(n*m), because the code uses a dictionary to store the counts of each integer.\\n\\n# Code\\n```\\npublic class Solution {\\n    public IList<int> Intersection(int[][] nums) {\\n        Dictionary<int, int> counts = new Dictionary<int, int>();\\n\\n        foreach (int[] arr in nums) {\\n            foreach (int n in arr) {\\n                if (!counts.ContainsKey(n)) {\\n                    counts.Add(n, 1);\\n                }\\n                else {\\n                    counts[n]++;\\n                }\\n            }\\n        }\\n\\n        return counts.Where(x => x.Value == nums.Length)\\n                     .Select(x => x.Key)\\n                     .OrderBy(x => x)\\n                     .ToArray();\\n    }\\n}\\n```",
                "solutionTags": [
                    "C#"
                ],
                "code": "```\\npublic class Solution {\\n    public IList<int> Intersection(int[][] nums) {\\n        Dictionary<int, int> counts = new Dictionary<int, int>();\\n\\n        foreach (int[] arr in nums) {\\n            foreach (int n in arr) {\\n                if (!counts.ContainsKey(n)) {\\n                    counts.Add(n, 1);\\n                }\\n                else {\\n                    counts[n]++;\\n                }\\n            }\\n        }\\n\\n        return counts.Where(x => x.Value == nums.Length)\\n                     .Select(x => x.Key)\\n                     .OrderBy(x => x)\\n                     .ToArray();\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2905364,
                "title": "easy-approach-java",
                "content": "\\n\\n# Code\\n```\\nclass Solution {\\n    public List<Integer> intersection(int[][] nums) {\\n        List<Integer> ans = new ArrayList<>();\\n        int[] count = new int[1001];\\n        \\n        for(int[] arr : nums) {\\n            for(int i : arr) {\\n                count[i]++;\\n            }\\n        }\\n\\n        for(int i = 0; i < count.length; i++) {\\n            if(count[i] == nums.length) {\\n                ans.add(i);\\n            }\\n        }\\n        return ans;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public List<Integer> intersection(int[][] nums) {\\n        List<Integer> ans = new ArrayList<>();\\n        int[] count = new int[1001];\\n        \\n        for(int[] arr : nums) {\\n            for(int i : arr) {\\n                count[i]++;\\n            }\\n        }\\n\\n        for(int i = 0; i < count.length; i++) {\\n            if(count[i] == nums.length) {\\n                ans.add(i);\\n            }\\n        }\\n        return ans;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2622306,
                "title": "using-map-c",
                "content": "```\\nclass Solution {\\npublic:\\n    vector<int> intersection(vector<vector<int>>& nums) {\\n        map<int,int>mp1;\\n        vector<int>ans;\\n        for(int i=0;i<nums[0].size();i++)\\n        {\\n            mp1[nums[0][i]]++;\\n        }\\n        for(int i=1;i<nums.size();i++)\\n        {\\n            vector<int>temp=nums[i];\\n            for(int j=0;j<temp.size();j++)\\n            {\\n                if(mp1.find(temp[j])!=mp1.end())\\n                {\\n                    mp1[temp[j]]++;\\n                }\\n            }\\n        }\\n        for(auto it=mp1.begin();it!=mp1.end();it++)\\n        {\\n           if(it->second==nums.size())\\n           {\\n               ans.push_back(it->first);\\n           }\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "C"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<int> intersection(vector<vector<int>>& nums) {\\n        map<int,int>mp1;\\n        vector<int>ans;\\n        for(int i=0;i<nums[0].size();i++)\\n        {\\n            mp1[nums[0][i]]++;\\n        }\\n        for(int i=1;i<nums.size();i++)\\n        {\\n            vector<int>temp=nums[i];\\n            for(int j=0;j<temp.size();j++)\\n            {\\n                if(mp1.find(temp[j])!=mp1.end())\\n                {\\n                    mp1[temp[j]]++;\\n                }\\n            }\\n        }\\n        for(auto it=mp1.begin();it!=mp1.end();it++)\\n        {\\n           if(it->second==nums.size())\\n           {\\n               ans.push_back(it->first);\\n           }\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2607258,
                "title": "java-easy-solution-100-faster",
                "content": "```\\nclass Solution {\\n    public List<Integer> intersection(int[][] nums) {\\n        ArrayList<Integer> al= new ArrayList<>();\\n        int[] freq =new int[1001];\\n        for(int r=0;r<nums.length;r++){\\n            for(int c=0;c<nums[r].length;c++){\\n                freq[nums[r][c]]++;\\n            }\\n        }\\n        int n=nums.length;\\n        for(int i=0;i<freq.length;i++){\\n            if(freq[i]==n) al.add(i);\\n        }\\n        return al;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Array"
                ],
                "code": "```\\nclass Solution {\\n    public List<Integer> intersection(int[][] nums) {\\n        ArrayList<Integer> al= new ArrayList<>();\\n        int[] freq =new int[1001];\\n        for(int r=0;r<nums.length;r++){\\n            for(int c=0;c<nums[r].length;c++){\\n                freq[nums[r][c]]++;\\n            }\\n        }\\n        int n=nums.length;\\n        for(int i=0;i<freq.length;i++){\\n            if(freq[i]==n) al.add(i);\\n        }\\n        return al;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2601840,
                "title": "c-easy-solution-easy-to-understand",
                "content": "class Solution {\\npublic:\\n    vector<int> intersection(vector<vector<int>>& nums) {\\n    unordered_map<int,int>y;\\n        vector<int>w;\\n        int i,j;\\n        for(i=0;i<nums.size();i++){\\n            for(j=0;j<nums[i].size();j++){\\n            y[nums[i][j]]++;\\n            \\n        }}\\n        for(auto it=y.begin();it!=y.end();it++){\\n            if(it->second==nums.size()){\\n              w.push_back(it->first);  \\n            }\\n        }\\n     sort(w.begin(),w.end());\\n        \\n return w;   }\\n};",
                "solutionTags": [
                    "C"
                ],
                "code": "class Solution {\\npublic:\\n    vector<int> intersection(vector<vector<int>>& nums) {\\n    unordered_map<int,int>y;\\n        vector<int>w;\\n        int i,j;\\n        for(i=0;i<nums.size();i++){\\n            for(j=0;j<nums[i].size();j++){\\n            y[nums[i][j]]++;\\n            \\n        }",
                "codeTag": "Java"
            },
            {
                "id": 2596946,
                "title": "java-arraylist-faster-than-100-java-submissions",
                "content": "```\\nclass Solution {\\n    public List<Integer> intersection(int[][] nums) {\\n        ArrayList<Integer> list = new ArrayList<>();\\n        int arr[] = new int[1001];\\n        for(int i=0;i<nums.length;i++){\\n            for(int j=0;j<nums[i].length;j++)\\n                arr[nums[i][j]]++;\\n        }\\n        int num = nums.length;\\n        for(int k=1;k<arr.length;k++){\\n            if(arr[k]==num)\\n                list.add(k);\\n        }\\n        return list;\\n    }\\n}\\n```\\nKindly upvote if you like the code.",
                "solutionTags": [
                    "Java",
                    "Array",
                    "Counting"
                ],
                "code": "```\\nclass Solution {\\n    public List<Integer> intersection(int[][] nums) {\\n        ArrayList<Integer> list = new ArrayList<>();\\n        int arr[] = new int[1001];\\n        for(int i=0;i<nums.length;i++){\\n            for(int j=0;j<nums[i].length;j++)\\n                arr[nums[i][j]]++;\\n        }\\n        int num = nums.length;\\n        for(int k=1;k<arr.length;k++){\\n            if(arr[k]==num)\\n                list.add(k);\\n        }\\n        return list;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2586993,
                "title": "c-solution",
                "content": "```\\nclass Solution {\\npublic:\\n    vector<int> intersection(vector<vector<int>>& nums) {\\n        vector<int> hsh(1005,0),ans;\\n        for(auto&_nums:nums)\\n            for(int&x:_nums)\\n                hsh[x]++;\\n        for(int i=1; i<hsh.size(); i++)\\n            if(hsh[i]==nums.size()) ans.push_back(i);\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "C"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<int> intersection(vector<vector<int>>& nums) {\\n        vector<int> hsh(1005,0),ans;\\n        for(auto&_nums:nums)\\n            for(int&x:_nums)\\n                hsh[x]++;\\n        for(int i=1; i<hsh.size(); i++)\\n            if(hsh[i]==nums.size()) ans.push_back(i);\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2580024,
                "title": "java-solution-with-full-explanation",
                "content": "\\'\\'\\'\\nclass Solution {\\n    public List<Integer> intersection(int[][] nums) {\\n        List<Integer> arr1=new ArrayList<>();\\n            int maxi=0;\\n         // find the max of the oth index array   \\n       for(int i=0;i<nums[0].length;i++) maxi=Math.max(maxi,nums[0][i]);\\n        \\n        //create array with max+1 size\\n        int arr[]=new int[maxi+1];\\n        \\n        //increment elements count in array\\n        for(int i=0;i<nums.length;i++)\\n            for(int j=0;j<nums[i].length;j++)\\n                if(nums[i][j]<=maxi) arr[nums[i][j]]++;\\n    \\n        // if element count is equal to number of rows that means that particular elements occured in every row ,\\n      //  so put that element in our result list\\n        for(int i=0;i<=maxi;i++)\\n            if(arr[i]==nums.length) arr1.add(i);\\n        \\n        return arr1;\\n        \\n    }\\n}\\n\\'\\'\\'",
                "solutionTags": [
                    "Array"
                ],
                "code": "class Solution {\\n    public List<Integer> intersection(int[][] nums) {\\n        List<Integer> arr1=new ArrayList<>();\\n            int maxi=0;\\n         // find the max of the oth index array   \\n       for(int i=0;i<nums[0].length;i++) maxi=Math.max(maxi,nums[0][i]);\\n        \\n        //create array with max+1 size\\n        int arr[]=new int[maxi+1];\\n        \\n        //increment elements count in array\\n        for(int i=0;i<nums.length;i++)\\n            for(int j=0;j<nums[i].length;j++)\\n                if(nums[i][j]<=maxi) arr[nums[i][j]]++;\\n    \\n        // if element count is equal to number of rows that means that particular elements occured in every row ,\\n      //  so put that element in our result list\\n        for(int i=0;i<=maxi;i++)\\n            if(arr[i]==nums.length) arr1.add(i);\\n        \\n        return arr1;\\n        \\n    }",
                "codeTag": "Java"
            },
            {
                "id": 2562088,
                "title": "simple-solution-2ms-with-comments",
                "content": "```\\nclass Solution {\\n    public List<Integer> intersection(int[][] nums) {\\n        List<Integer> res = new ArrayList<>();\\n        int count[] = new int[1001]; // stores the number of array which has that element i\\n        for(int numsArray[]: nums)\\n            for(int num: numsArray)\\n                count[num]++;\\n        \\n        int n = nums.length;\\n        for(int i=0;i<1001;i++)\\n            if(count[i]==n) // if the count is == size of the array, then it is present in every array\\n                res.add(i);\\n        return res;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public List<Integer> intersection(int[][] nums) {\\n        List<Integer> res = new ArrayList<>();\\n        int count[] = new int[1001]; // stores the number of array which has that element i\\n        for(int numsArray[]: nums)\\n            for(int num: numsArray)\\n                count[num]++;\\n        \\n        int n = nums.length;\\n        for(int i=0;i<1001;i++)\\n            if(count[i]==n) // if the count is == size of the array, then it is present in every array\\n                res.add(i);\\n        return res;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2546702,
                "title": "python-fast-solution",
                "content": "```\\nclass Solution:\\n    def intersection(self, nums: List[List[int]]) -> List[int]:\\n        if not nums:\\n            return []\\n        a = set(nums[0])\\n        for i in nums[1:]:\\n            a = a & set(i)\\n        return sorted(a)\\n```",
                "solutionTags": [
                    "Python",
                    "Ordered Set"
                ],
                "code": "```\\nclass Solution:\\n    def intersection(self, nums: List[List[int]]) -> List[int]:\\n        if not nums:\\n            return []\\n        a = set(nums[0])\\n        for i in nums[1:]:\\n            a = a & set(i)\\n        return sorted(a)\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2492173,
                "title": "97-81-faster-using-set-and-set-intersection",
                "content": "![image](https://assets.leetcode.com/users/images/a155a472-e97a-456a-b8b3-7db652ebf923_1661637583.5699358.png)\\n```\\nclass Solution:\\n    def intersection(self, nums: List[List[int]]) -> List[int]:\\n        inter = set(nums[0])\\n        for i in range(1, len(nums)):\\n            inter = inter.intersection(set(nums[i]))\\n        inter = sorted(list(inter))\\n        return inter\\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def intersection(self, nums: List[List[int]]) -> List[int]:\\n        inter = set(nums[0])\\n        for i in range(1, len(nums)):\\n            inter = inter.intersection(set(nums[i]))\\n        inter = sorted(list(inter))\\n        return inter\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2462518,
                "title": "java-solution-3ms-faster-94-41-faster-easy-to-understand",
                "content": "```\\nclass Solution {\\n    public List<Integer> intersection(int[][] arr) {\\n        List<Integer> list = new ArrayList<>();\\n        for (int i : arr[0]) {\\n            if (helper(i, arr, 1)) list.add(i);\\n        }\\n        Collections.sort(list);\\n        return list;\\n    }\\n\\n    private static boolean helper(int target, int[][] arr, int start) {\\n        for (int i = start; i < arr.length; i++) {\\n            boolean b = false;\\n            for (int k : arr[i]){\\n                if (k == target) {\\n                    b = true;\\n                    break;\\n                }\\n            }\\n            if (!b) return false;\\n        }\\n        return true;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Array"
                ],
                "code": "```\\nclass Solution {\\n    public List<Integer> intersection(int[][] arr) {\\n        List<Integer> list = new ArrayList<>();\\n        for (int i : arr[0]) {\\n            if (helper(i, arr, 1)) list.add(i);\\n        }\\n        Collections.sort(list);\\n        return list;\\n    }\\n\\n    private static boolean helper(int target, int[][] arr, int start) {\\n        for (int i = start; i < arr.length; i++) {\\n            boolean b = false;\\n            for (int k : arr[i]){\\n                if (k == target) {\\n                    b = true;\\n                    break;\\n                }\\n            }\\n            if (!b) return false;\\n        }\\n        return true;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2453785,
                "title": "c-solution-time-o-m-n-memory-o-m-n-easy-to-understand-dictionary",
                "content": "```C#\\npublic class Solution {\\n    public IList<int> Intersection(int[][] nums) {\\n        Dictionary<int, int> d = new Dictionary<int, int>();\\n        for (int i = 0; i < nums.Length; i++) {\\n            for (int j = 0; j < nums[i].Length; j++) {\\n                if (!d.ContainsKey(nums[i][j])) d[nums[i][j]] = 0;\\n                d[nums[i][j]]++;\\n            }\\n        }\\n        \\n        List<int> ans = new List<int>();\\n        foreach (var (num, count) in d) {\\n            if (count == nums.Length) ans.Add(num);\\n        }\\n        \\n        return ans.OrderBy(x => x).ToList();\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```C#\\npublic class Solution {\\n    public IList<int> Intersection(int[][] nums) {\\n        Dictionary<int, int> d = new Dictionary<int, int>();\\n        for (int i = 0; i < nums.Length; i++) {\\n            for (int j = 0; j < nums[i].Length; j++) {\\n                if (!d.ContainsKey(nums[i][j])) d[nums[i][j]] = 0;\\n                d[nums[i][j]]++;\\n            }\\n        }\\n        \\n        List<int> ans = new List<int>();\\n        foreach (var (num, count) in d) {\\n            if (count == nums.Length) ans.Add(num);\\n        }\\n        \\n        return ans.OrderBy(x => x).ToList();\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2452113,
                "title": "easy-java-solution",
                "content": "**Please upvote if you understood the solution!!**\\n```\\nclass Solution {\\n    public List<Integer> intersection(int[][] nums) {\\n        List<Integer> list = new ArrayList<>();\\n        for (int j = 0; j < nums[0].length; j++) {\\n            list.add(nums[0][j]);\\n        }\\n        for (int i = 1; i < nums.length; i++) {\\n            List<Integer> list1 = new ArrayList<>();\\n            for (int j = 0; j < nums[i].length; j++) {\\n                if (list.contains(nums[i][j])) {\\n                    list1.add(nums[i][j]);\\n                }\\n            }\\n            list = list1;\\n        }\\n         Collections.sort(list);\\n        return list;\\n    }\\n}\\n```\\n# upvote",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public List<Integer> intersection(int[][] nums) {\\n        List<Integer> list = new ArrayList<>();\\n        for (int j = 0; j < nums[0].length; j++) {\\n            list.add(nums[0][j]);\\n        }\\n        for (int i = 1; i < nums.length; i++) {\\n            List<Integer> list1 = new ArrayList<>();\\n            for (int j = 0; j < nums[i].length; j++) {\\n                if (list.contains(nums[i][j])) {\\n                    list1.add(nums[i][j]);\\n                }\\n            }\\n            list = list1;\\n        }\\n         Collections.sort(list);\\n        return list;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2413182,
                "title": "python-using-counter-faster-than-93",
                "content": "```\\nclass Solution(object):\\n    def intersection(self, nums):\\n        \"\"\"\\n        :type nums: List[List[int]]\\n        :rtype: List[int]\\n        \"\"\"\\n        length=len(nums)\\n        all_nums=[]\\n        ans=[]\\n        for num in nums:\\n            all_nums+=num\\n        from collections import Counter\\n        counts=Counter(all_nums)\\n        for k in counts.keys():\\n            if counts[k]==length:\\n                ans.append(k)\\n        return sorted(ans)\\n```",
                "solutionTags": [
                    "Python"
                ],
                "code": "```\\nclass Solution(object):\\n    def intersection(self, nums):\\n        \"\"\"\\n        :type nums: List[List[int]]\\n        :rtype: List[int]\\n        \"\"\"\\n        length=len(nums)\\n        all_nums=[]\\n        ans=[]\\n        for num in nums:\\n            all_nums+=num\\n        from collections import Counter\\n        counts=Counter(all_nums)\\n        for k in counts.keys():\\n            if counts[k]==length:\\n                ans.append(k)\\n        return sorted(ans)\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2359927,
                "title": "simple-js-solution",
                "content": "\\tconst intersection = function(nums) {\\n\\t\\tlet map = new Map()\\n\\t\\tlet res = []\\n\\n\\t\\tnums.forEach(arr => {\\n\\t\\t\\tarr.forEach(num => map.set(num, map.get(num) + 1 || 1))\\n\\t\\t})\\n\\n\\t\\tfor(let [key, value] of map) {\\n\\t\\t\\tif (value === nums.length) {\\n\\t\\t\\t\\tres.push(key)\\n\\t\\t\\t}\\n\\t\\t}\\n\\n\\t\\treturn res.sort((a, b) => a - b)\\n\\t};",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "\\tconst intersection = function(nums) {\\n\\t\\tlet map = new Map()\\n\\t\\tlet res = []\\n\\n\\t\\tnums.forEach(arr => {\\n\\t\\t\\tarr.forEach(num => map.set(num, map.get(num) + 1 || 1))\\n\\t\\t})\\n\\n\\t\\tfor(let [key, value] of map) {\\n\\t\\t\\tif (value === nums.length) {\\n\\t\\t\\t\\tres.push(key)\\n\\t\\t\\t}\\n\\t\\t}\\n\\n\\t\\treturn res.sort((a, b) => a - b)\\n\\t};",
                "codeTag": "Unknown"
            },
            {
                "id": 2359519,
                "title": "java-simple-brute-force-solution",
                "content": "```\\nclass Solution {\\n    public List<Integer> intersection(int[][] nums) {\\n        ArrayList<Integer> arrList = new ArrayList<Integer>();\\n        List<Integer> resList = new ArrayList<Integer>();\\n        \\n        for(int i = 0; i < nums.length; i++){\\n            for(int j = 0; j < nums[i].length; j++){\\n                arrList.add(nums[i][j]); // adding all the elements of nums in arrList\\n            }\\n        }\\n        \\n        int numLength = nums.length;\\n        int count = 0;\\n        \\n        for(int i = 0; i < nums[0].length; i++){\\n            for(int j = 0; j < arrList.size(); j++){\\n                if(nums[0][i] == arrList.get(j)){\\n                    count++;    //increase count of nums[0][i] \\n                }\\n            }\\n            if(count == numLength){\\n                resList.add(nums[0][i]);    //if nums[0][i] count is equals 3 then add to another array\\n            }\\n            count = 0;\\n        }\\n        \\n        Collections.sort(resList);// sort the result array\\n        \\n        return resList;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public List<Integer> intersection(int[][] nums) {\\n        ArrayList<Integer> arrList = new ArrayList<Integer>();\\n        List<Integer> resList = new ArrayList<Integer>();\\n        \\n        for(int i = 0; i < nums.length; i++){\\n            for(int j = 0; j < nums[i].length; j++){\\n                arrList.add(nums[i][j]); // adding all the elements of nums in arrList\\n            }\\n        }\\n        \\n        int numLength = nums.length;\\n        int count = 0;\\n        \\n        for(int i = 0; i < nums[0].length; i++){\\n            for(int j = 0; j < arrList.size(); j++){\\n                if(nums[0][i] == arrList.get(j)){\\n                    count++;    //increase count of nums[0][i] \\n                }\\n            }\\n            if(count == numLength){\\n                resList.add(nums[0][i]);    //if nums[0][i] count is equals 3 then add to another array\\n            }\\n            count = 0;\\n        }\\n        \\n        Collections.sort(resList);// sort the result array\\n        \\n        return resList;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2357213,
                "title": "c-16ms-68-bruteforce-approach-with-explanation",
                "content": "```\\nclass Solution {\\npublic:\\n    vector<int> intersection(vector<vector<int>>& nums) {\\n        map<int,int>sk;\\n        vector<int>sk1;\\n        vector<int>res;\\n        for(int i=0;i<nums.size();i++){ ///////storing all elements in single array;\\n            for(int j=0;j<nums[i].size();j++){\\n                sk1.push_back(nums[i][j]);\\n            }\\n        }\\n\\t\\t\\n        for(int i=0;i<sk1.size();i++){ ////now adding all elements in map\\n            sk[sk1[i]]++;\\n            \\n        }\\n        \\n        for(auto i:sk){\\n            \\n            if(i.second==nums.size()){ //checking if duplicate element size is equal to nums.size() means it present in all three then pushing into result vector\\n                res.push_back(i.first);\\n            }\\n        }\\n        \\n        return res;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<int> intersection(vector<vector<int>>& nums) {\\n        map<int,int>sk;\\n        vector<int>sk1;\\n        vector<int>res;\\n        for(int i=0;i<nums.size();i++){ ///////storing all elements in single array;\\n            for(int j=0;j<nums[i].size();j++){\\n                sk1.push_back(nums[i][j]);\\n            }\\n        }\\n\\t\\t\\n        for(int i=0;i<sk1.size();i++){ ////now adding all elements in map\\n            sk[sk1[i]]++;\\n            \\n        }\\n        \\n        for(auto i:sk){\\n            \\n            if(i.second==nums.size()){ //checking if duplicate element size is equal to nums.size() means it present in all three then pushing into result vector\\n                res.push_back(i.first);\\n            }\\n        }\\n        \\n        return res;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2312722,
                "title": "c-simple-solution-using-merge-algorithm",
                "content": "```\\nclass Solution {\\nprivate:\\n    vector<int> doIntersection(vector<int> &first, vector<int> &second){\\n        vector<int> ans;\\n        int i = 0, j = 0;\\n        sort(first.begin(), first.end());\\n        sort(second.begin(), second.end());\\n        while(i < first.size() && j < second.size()){\\n            if(first[i] < second[j]){\\n                i++;\\n            }\\n            else if(first[i] > second[j]){\\n                j++;\\n            }else{\\n                ans.push_back(first[i]);\\n                i++;\\n                j++;\\n            }\\n        }\\n        return ans;\\n    }\\npublic:\\n    vector<int> intersection(vector<vector<int>>& nums) {\\n        if(nums.size() == 1){\\n            sort(nums[0].begin(), nums[0].end());\\n            return nums[0];\\n        }\\n        vector<int> ans = doIntersection(nums[0], nums[1]);\\n        for(int j = 2 ; j < nums.size() ; j++){\\n            ans = doIntersection(ans, nums[2]);\\n        }\\n        return ans;\\n\\n    }\\n};\\n```",
                "solutionTags": [
                    "C"
                ],
                "code": "```\\nclass Solution {\\nprivate:\\n    vector<int> doIntersection(vector<int> &first, vector<int> &second){\\n        vector<int> ans;\\n        int i = 0, j = 0;\\n        sort(first.begin(), first.end());\\n        sort(second.begin(), second.end());\\n        while(i < first.size() && j < second.size()){\\n            if(first[i] < second[j]){\\n                i++;\\n            }\\n            else if(first[i] > second[j]){\\n                j++;\\n            }else{\\n                ans.push_back(first[i]);\\n                i++;\\n                j++;\\n            }\\n        }\\n        return ans;\\n    }\\npublic:\\n    vector<int> intersection(vector<vector<int>>& nums) {\\n        if(nums.size() == 1){\\n            sort(nums[0].begin(), nums[0].end());\\n            return nums[0];\\n        }\\n        vector<int> ans = doIntersection(nums[0], nums[1]);\\n        for(int j = 2 ; j < nums.size() ; j++){\\n            ans = doIntersection(ans, nums[2]);\\n        }\\n        return ans;\\n\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2262639,
                "title": "very-easy-c-solution-with-explanation",
                "content": "```\\nclass Solution {\\npublic:\\n    vector<int> intersection(vector<vector<int>>& nums) {\\n        \\n        vector<int> ans ;\\n        \\n        int n = nums.size();\\n        \\n\\t\\t// This unorderd map will store all the numbers from the given vector (nums) \\n\\t\\t\\n        unordered_map <int,int> mp;\\n        \\n\\t\\t// The following \"For\" loop help to store all the number in the unordered map\\n\\t\\t\\n        for (int i =0; i<n; i++){\\n            \\n            for (int j =0; j<nums[i].size(); j++){\\n                \\n                mp[nums[i][j]]++;\\n            }\\n        }\\n        \\n\\t\\t// This following \"For\" loop help to store the common numbers in \"ans\" vector\\n\\t\\t\\n        for (auto x: mp){\\n            \\n            if (x.second % n == 0){\\n                \\n                ans.push_back(x.first);\\n            }\\n            \\n        }\\n        \\n        sort(ans.begin(),ans.end());\\n        \\n        return ans;\\n\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "C"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<int> intersection(vector<vector<int>>& nums) {\\n        \\n        vector<int> ans ;\\n        \\n        int n = nums.size();\\n        \\n\\t\\t// This unorderd map will store all the numbers from the given vector (nums) \\n\\t\\t\\n        unordered_map <int,int> mp;\\n        \\n\\t\\t// The following \"For\" loop help to store all the number in the unordered map\\n\\t\\t\\n        for (int i =0; i<n; i++){\\n            \\n            for (int j =0; j<nums[i].size(); j++){\\n                \\n                mp[nums[i][j]]++;\\n            }\\n        }\\n        \\n\\t\\t// This following \"For\" loop help to store the common numbers in \"ans\" vector\\n\\t\\t\\n        for (auto x: mp){\\n            \\n            if (x.second % n == 0){\\n                \\n                ans.push_back(x.first);\\n            }\\n            \\n        }\\n        \\n        sort(ans.begin(),ans.end());\\n        \\n        return ans;\\n\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2258686,
                "title": "python3-o-n-2-to-o-nlogn-countingsort-and-hashmap",
                "content": "```\\nclass Solution:\\n    def intersection(self, nums: List[List[int]]) -> List[int]:\\n        return self.solTwo(nums)\\n    \\n# Runtime: 95ms 64.64% || memory: 14.2mb 62.57%\\n# O(n^2) || O(1) you can do argure with this we have taken an array of size 1001\\n# but we are also returning an array, if you are taking that also as an extra space, this its O(m+n)\\n# where m is the number of elements present in the array, n is the elements present in the array\\n# otherwise you can say it O(1), if we aren\\'t count the return \\'array\\' as an extra space\\n\\n\\n    def solOne(self, nums):\\n        n = len(nums)\\n        count = [0] * 1001\\n        for i in range(len(nums)):\\n            self.countingSort(nums[i], count)\\n        \\n        return [num for num in range(1, 1001) if count[num] >= n]\\n        \\n    def countingSort(self, nums, count):\\n        for i in nums:\\n            count[i] += 1\\n        \\n# O(nlogn) || O(n)\\n# Runtime: 128ms 26.36% || Memory: 14.4mb 6.60%\\n    def solTwo(self, nums):\\n        n = len(nums)\\n        \\n        hashMap = {}\\n        \\n        for i in range(len(nums)):\\n            for j in range(len(nums[i])):\\n                num = nums[i][j]\\n                hashMap[num] = hashMap.get(num, 0) + 1\\n                \\n        return sorted([key for key in hashMap.keys() if hashMap[key] >= n])\\n```",
                "solutionTags": [
                    "Python",
                    "Python3",
                    "Counting Sort"
                ],
                "code": "```\\nclass Solution:\\n    def intersection(self, nums: List[List[int]]) -> List[int]:\\n        return self.solTwo(nums)\\n    \\n# Runtime: 95ms 64.64% || memory: 14.2mb 62.57%\\n# O(n^2) || O(1) you can do argure with this we have taken an array of size 1001\\n# but we are also returning an array, if you are taking that also as an extra space, this its O(m+n)\\n# where m is the number of elements present in the array, n is the elements present in the array\\n# otherwise you can say it O(1), if we aren\\'t count the return \\'array\\' as an extra space\\n\\n\\n    def solOne(self, nums):\\n        n = len(nums)\\n        count = [0] * 1001\\n        for i in range(len(nums)):\\n            self.countingSort(nums[i], count)\\n        \\n        return [num for num in range(1, 1001) if count[num] >= n]\\n        \\n    def countingSort(self, nums, count):\\n        for i in nums:\\n            count[i] += 1\\n        \\n# O(nlogn) || O(n)\\n# Runtime: 128ms 26.36% || Memory: 14.4mb 6.60%\\n    def solTwo(self, nums):\\n        n = len(nums)\\n        \\n        hashMap = {}\\n        \\n        for i in range(len(nums)):\\n            for j in range(len(nums[i])):\\n                num = nums[i][j]\\n                hashMap[num] = hashMap.get(num, 0) + 1\\n                \\n        return sorted([key for key in hashMap.keys() if hashMap[key] >= n])\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2247168,
                "title": "c-easy-simple-solution",
                "content": "***PLEASE UPVOTE IF YOU FIND MY APPROACH HELPFUL <3\\nHAPPY CODING!***\\n\\n```\\nclass Solution {\\npublic:\\n    vector<int> intersection(vector<vector<int>>& nums) {\\n        int n=nums.size();\\n        map<int,int>m;\\n        for(int i=0;i<nums.size();i++){\\n            vector<int>n=nums[i];\\n            for(int j=0;j<n.size();j++){\\n                m[n[j]]++;\\n            }\\n        }\\n        vector<int>v=nums[0];\\n        vector<int>V;\\n        for(int i=0;i<v.size();i++){\\n            if(m[v[i]]==nums.size()){\\n                V.push_back(v[i]);\\n            }\\n        }\\n        sort(V.begin(),V.end());\\n        return V;\\n    }\\n};",
                "solutionTags": [
                    "C"
                ],
                "code": "class Solution {\\npublic:\\n    vector<int> intersection(vector<vector<int>>& nums) {\\n        int n=nums.size();\\n        map<int,int>m;\\n        for(int i=0;i<nums.size();i++){\\n            vector<int>n=nums[i];\\n            for(int j=0;j<n.size();j++){\\n                m[n[j]]++;\\n            }",
                "codeTag": "Java"
            },
            {
                "id": 2224166,
                "title": "js-solution-using-set-and-sort",
                "content": "```\\nvar intersection = function(nums) {   \\n    let set = addToSet(nums[0]); \\n    for(let i=1; i<nums.length; i++) {\\n        let tempSet = addToSet(nums[i]);\\n        for(let key of set) {            \\n            if( !tempSet.has(key) ) \\n                set.delete(key);\\n        }\\n    }    \\n    return [...set].sort( (a,b) => a-b );\\n};\\n\\nfunction addToSet(arr) {\\n    let set = new Set(arr);\\n    return set;\\n}\\n```",
                "solutionTags": [
                    "JavaScript",
                    "Sorting",
                    "Ordered Set"
                ],
                "code": "```\\nvar intersection = function(nums) {   \\n    let set = addToSet(nums[0]); \\n    for(let i=1; i<nums.length; i++) {\\n        let tempSet = addToSet(nums[i]);\\n        for(let key of set) {            \\n            if( !tempSet.has(key) ) \\n                set.delete(key);\\n        }\\n    }    \\n    return [...set].sort( (a,b) => a-b );\\n};\\n\\nfunction addToSet(arr) {\\n    let set = new Set(arr);\\n    return set;\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2159947,
                "title": "python-beginner-approach-using-hashmap-with-explanation",
                "content": "```\\nclass Solution:\\n    def intersection(self, nums: List[List[int]]) -> List[int]:\\n        \\'\\'\\'\\n          Simple straight forward solution, Since every element is unique in sub lst, we can\\n          use this information i.e. create a hashmap and if any element is occuring n times(n = len(nums))\\n          it means it is occuring in all sub lists and rest elements are not occuring in all sub lists.\\n        \\'\\'\\'\\n        res = []\\n        d = {}\\n        for num in nums:\\n            for n in num:\\n                d[n] = 1 + d.get(n,0)\\n                \\n        for k,v in d.items():\\n            if v == len(nums):\\n                res.append(k)\\n        return sorted(res)\\n```",
                "solutionTags": [
                    "Python",
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def intersection(self, nums: List[List[int]]) -> List[int]:\\n        \\'\\'\\'\\n          Simple straight forward solution, Since every element is unique in sub lst, we can\\n          use this information i.e. create a hashmap and if any element is occuring n times(n = len(nums))\\n          it means it is occuring in all sub lists and rest elements are not occuring in all sub lists.\\n        \\'\\'\\'\\n        res = []\\n        d = {}\\n        for num in nums:\\n            for n in num:\\n                d[n] = 1 + d.get(n,0)\\n                \\n        for k,v in d.items():\\n            if v == len(nums):\\n                res.append(k)\\n        return sorted(res)\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2130578,
                "title": "java-simple-solution",
                "content": "```\\nclass Solution {\\n    public List<Integer> intersection(int[][] nums) {\\n        int[] arr = new int[1001];\\n        \\n        for(int i=0;i<nums.length;i++) {\\n            for(int j=0;j<nums[i].length;j++) {\\n                ++arr[nums[i][j]];\\n            }\\n        }\\n        \\n        List<Integer> result = new ArrayList<>();\\n        for(int i=1;i<1001;i++) {\\n            if (arr[i] == nums.length) result.add(i);\\n        }\\n        \\n        return result;\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    public List<Integer> intersection(int[][] nums) {\\n        int[] arr = new int[1001];\\n        \\n        for(int i=0;i<nums.length;i++) {\\n            for(int j=0;j<nums[i].length;j++) {\\n                ++arr[nums[i][j]];\\n            }\\n        }\\n        \\n        List<Integer> result = new ArrayList<>();\\n        for(int i=1;i<1001;i++) {\\n            if (arr[i] == nums.length) result.add(i);\\n        }\\n        \\n        return result;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2104131,
                "title": "c-10-ms",
                "content": "```\\nclass Solution {\\npublic:\\n    vector<int> intersection(const vector<vector<int>>& nums) {\\n        const int len=1001,arrays=nums.size();\\n        \\n        vector<int> vec(len);\\n        for(const auto& v:nums)\\n            for(auto i:v) ++vec[i];\\n        \\n        vector<int> res;\\n        for(int i=0; i<len; ++i)\\n            if(vec[i]==arrays) res.push_back(i);\\n        \\n        return res;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<int> intersection(const vector<vector<int>>& nums) {\\n        const int len=1001,arrays=nums.size();\\n        \\n        vector<int> vec(len);\\n        for(const auto& v:nums)\\n            for(auto i:v) ++vec[i];\\n        \\n        vector<int> res;\\n        for(int i=0; i<len; ++i)\\n            if(vec[i]==arrays) res.push_back(i);\\n        \\n        return res;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2076010,
                "title": "c-solution-unordered-map-easy-explained",
                "content": "```\\nclass Solution {\\npublic:\\n    vector<int> intersection(vector<vector<int>>& nums){\\n        unordered_map<int,int> m;\\n        int r=nums.size();\\n        for(int i=0;i<r;i++){\\n            for(int j=0;j<nums[i].size();j++){\\n                m[nums[i][j]]++;  // For counting frequency of every element in whole matrix\\n            }\\n        }\\n        vector<int> ans;\\n        for(auto i:m){\\n            if(i.second==r) ans.push_back(i.first);  // Pushing only those elements with frequency equal to no. of rows\\n        }\\n        sort(ans.begin(),ans.end());  // Sorting the array as answer is desired in the ascending order\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<int> intersection(vector<vector<int>>& nums){\\n        unordered_map<int,int> m;\\n        int r=nums.size();\\n        for(int i=0;i<r;i++){\\n            for(int j=0;j<nums[i].size();j++){\\n                m[nums[i][j]]++;  // For counting frequency of every element in whole matrix\\n            }\\n        }\\n        vector<int> ans;\\n        for(auto i:m){\\n            if(i.second==r) ans.push_back(i.first);  // Pushing only those elements with frequency equal to no. of rows\\n        }\\n        sort(ans.begin(),ans.end());  // Sorting the array as answer is desired in the ascending order\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2060765,
                "title": "c-fast-low-memory-bitset-based-solution",
                "content": "```\\nclass Solution {\\npublic:\\n    vector<int> intersection(vector<vector<int>>& nums) {\\n        static_assert(sizeof(unsigned long) == 8);\\n        uint64_t acc[16], buf[16];\\n        memset(acc, -1, sizeof(acc));\\n        for (auto &arr : nums) {\\n            memset(buf, 0, sizeof(buf));\\n            for (int v : arr) {\\n                buf[v >> 6] |= 1llu << (v & 0x3f);\\n            }\\n            for (int i=0; i < 16; i++) acc[i] &= buf[i];\\n        }\\n        vector<int> ans;\\n        for (int i=0, v=0; i < 16; i++, v=i<<6) {\\n            uint64_t b = acc[i];\\n            while (b) {\\n                ans.push_back(v + __builtin_ctzl(b));\\n                b ^= b & -b;\\n            }\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<int> intersection(vector<vector<int>>& nums) {\\n        static_assert(sizeof(unsigned long) == 8);\\n        uint64_t acc[16], buf[16];\\n        memset(acc, -1, sizeof(acc));\\n        for (auto &arr : nums) {\\n            memset(buf, 0, sizeof(buf));\\n            for (int v : arr) {\\n                buf[v >> 6] |= 1llu << (v & 0x3f);\\n            }\\n            for (int i=0; i < 16; i++) acc[i] &= buf[i];\\n        }\\n        vector<int> ans;\\n        for (int i=0, v=0; i < 16; i++, v=i<<6) {\\n            uint64_t b = acc[i];\\n            while (b) {\\n                ans.push_back(v + __builtin_ctzl(b));\\n                b ^= b & -b;\\n            }\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2057232,
                "title": "c-counting-sort-solution",
                "content": "```\\nclass Solution {\\npublic:\\n    vector<int> intersection(vector<vector<int>>& nums) {\\n        int n=nums.size();\\n        vector<int>a(1001,0),ans;\\n        for(int i=0;i<nums.size();i++){\\n            for(int j=0;j<nums[i].size();j++){\\n                a[nums[i][j]]++;\\n            } \\n        }\\n        for(int i=1;i<=1000;i++){\\n           if(a[i]==nums.size()){\\n               ans.push_back(i);\\n           }\\n        }\\n        return ans;\\n    }\\n};\\n\\n// if you liked the solution then please upvote it so that it can reach to more people \\n// If you have any doubt or want to discuss any thing related to solution please leave a comment, so that all of the viewers can discuss it\\n```",
                "solutionTags": [
                    "C",
                    "Counting Sort"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<int> intersection(vector<vector<int>>& nums) {\\n        int n=nums.size();\\n        vector<int>a(1001,0),ans;\\n        for(int i=0;i<nums.size();i++){\\n            for(int j=0;j<nums[i].size();j++){\\n                a[nums[i][j]]++;\\n            } \\n        }\\n        for(int i=1;i<=1000;i++){\\n           if(a[i]==nums.size()){\\n               ans.push_back(i);\\n           }\\n        }\\n        return ans;\\n    }\\n};\\n\\n// if you liked the solution then please upvote it so that it can reach to more people \\n// If you have any doubt or want to discuss any thing related to solution please leave a comment, so that all of the viewers can discuss it\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2036776,
                "title": "python-time-o-m-n-space-o-m",
                "content": "**Using set\\nTime Complexity: O(M*N)\\nSpaceComplexity: O(M)**\\n\\n````\\nclass Solution:\\n    def intersection(self, nums: List[List[int]]) -> List[int]:\\n        \\n        result = []\\n        numSet = set(nums[0])\\n        N = len(nums)\\n        \\n        for i in range(1,N):\\n            nextSet = set()\\n            for num in nums[i]:\\n                if num in numSet:\\n                    nextSet.add(num)\\n            numSet = nextSet\\n        \\n        return sorted([num for num in numSet])\\n````\\n\\n**Using HashMap\\nTime Complexity: O(M*N)\\nSpaceComplexity: O(M*N)**\\n\\n````\\nclass Solution:\\n    def intersection(self, nums: List[List[int]]) -> List[int]:\\n        \\n        result = []\\n        numMap = collections.defaultdict(int)\\n        rows = 0\\n        \\n        for row in nums:\\n            rows += 1\\n            for num in row:\\n                numMap[num] += 1\\n        \\n        result = [num for num in numMap if numMap[num] == rows]\\n        result.sort()\\n        \\n        return result\\n````",
                "solutionTags": [
                    "Python",
                    "Matrix",
                    "Ordered Set"
                ],
                "code": "````\\nclass Solution:\\n    def intersection(self, nums: List[List[int]]) -> List[int]:\\n        \\n        result = []\\n        numSet = set(nums[0])\\n        N = len(nums)\\n        \\n        for i in range(1,N):\\n            nextSet = set()\\n            for num in nums[i]:\\n                if num in numSet:\\n                    nextSet.add(num)\\n            numSet = nextSet\\n        \\n        return sorted([num for num in numSet])\\n```\n````\\nclass Solution:\\n    def intersection(self, nums: List[List[int]]) -> List[int]:\\n        \\n        result = []\\n        numMap = collections.defaultdict(int)\\n        rows = 0\\n        \\n        for row in nums:\\n            rows += 1\\n            for num in row:\\n                numMap[num] += 1\\n        \\n        result = [num for num in numMap if numMap[num] == rows]\\n        result.sort()\\n        \\n        return result\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2031665,
                "title": "2ms-99-5-faster-simple-java-solution",
                "content": "java code is:\\n\\n```\\nclass Solution {\\n    public List<Integer> intersection(int[][] nums) {\\n       int n=nums.length;\\n        List<Integer>ans=new ArrayList<>();\\n       int f[]=new int[1001];\\n        for(int num[] : nums){\\n            for(int v : num) {\\n                if(++f[v]==n)ans.add(v);\\n            }\\n        }\\n        Collections.sort(ans);\\n        return ans; \\n    }\\n}\\n```\\n# Time : O(n*m) \\n# Space : O(n+1000) => O(n) linear\\n# \\n# Please upvote if this is helpful",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    public List<Integer> intersection(int[][] nums) {\\n       int n=nums.length;\\n        List<Integer>ans=new ArrayList<>();\\n       int f[]=new int[1001];\\n        for(int num[] : nums){\\n            for(int v : num) {\\n                if(++f[v]==n)ans.add(v);\\n            }\\n        }\\n        Collections.sort(ans);\\n        return ans; \\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2022128,
                "title": "easy-peasy-approach",
                "content": "class Solution {\\n    public List<Integer> intersection(int[][] nums) {\\n        \\n        HashMap<Integer,Integer> map= new HashMap<>();\\n        List<Integer> list= new ArrayList<>();\\n\\n        for(int i=0;i<nums.length;i++)\\n        {\\n            for(int j=0;j<nums[i].length;j++)\\n            {\\n                int n= nums[i][j];\\n               if(map.containsKey(n))\\n               {\\n                   map.put(nums[i][j], map.get(n)+1);\\n               }\\n                else\\n                map.put(nums[i][j],1);\\n            }\\n        }\\n        \\n        for(int i:map.keySet())\\n        {\\n            // int v= map.get\\n                if(map.get(i) ==nums.length)\\n                    list.add(i);\\n            \\n        }\\n    Collections.sort(list);\\n    return list;\\n    }\\n}",
                "solutionTags": [
                    "Java"
                ],
                "code": "class Solution {\\n    public List<Integer> intersection(int[][] nums) {\\n        \\n        HashMap<Integer,Integer> map= new HashMap<>();\\n        List<Integer> list= new ArrayList<>();\\n\\n        for(int i=0;i<nums.length;i++)\\n        {\\n            for(int j=0;j<nums[i].length;j++)\\n            {\\n                int n= nums[i][j];\\n               if(map.containsKey(n))\\n               {\\n                   map.put(nums[i][j], map.get(n)+1);\\n               }",
                "codeTag": "Java"
            },
            {
                "id": 1997081,
                "title": "cpp-solution",
                "content": "Create an array of 1000 size (can be made because of small constraints or use hashmap) to keep the count of occurance of each and every element in the given 2-d array. \\nThe answer would be the list of elements whose count/frequency is equal to the rows(n) of the given matrix as each element will be unique in a row of the 2-d array.\\n\\n```\\nclass Solution {\\npublic:\\n    vector<int> intersection(vector<vector<int>>& nums) {\\n        int n = nums.size() ;\\n    \\n        vector<int> freq(1001) ;\\n        vector<int> ans ;\\n        \\n        for(auto &arr : nums)\\n            for(int i = 0 ; i < arr.size() ; i++)\\n                freq[arr[i]]++ ;\\n        \\n        for(int i = 0 ; i < 1001 ; i++){\\n            if(freq[i] == n)\\n                ans.push_back(i) ;\\n        }\\n        \\n        return ans ;\\n    }\\n};\\n```\\n\\nKeep Solving !!",
                "solutionTags": [
                    "C++",
                    "Array"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<int> intersection(vector<vector<int>>& nums) {\\n        int n = nums.size() ;\\n    \\n        vector<int> freq(1001) ;\\n        vector<int> ans ;\\n        \\n        for(auto &arr : nums)\\n            for(int i = 0 ; i < arr.size() ; i++)\\n                freq[arr[i]]++ ;\\n        \\n        for(int i = 0 ; i < 1001 ; i++){\\n            if(freq[i] == n)\\n                ans.push_back(i) ;\\n        }\\n        \\n        return ans ;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1991328,
                "title": "c-easy-fastest-solution",
                "content": "This problem can be solved by 2 ways:\\n1. Using unordered map\\n\\t\\tBut in this extra sorting will be needed at the end to get the solution in ascending order.\\n2. Using ordered map\\n\\t\\tAs by default Map stores the data in arranged order we needn\\'t sort it separately.\\n\\t\\t\\n**Code for Using unordered map**\\n```\\nclass Solution {\\npublic:\\n    vector<int> intersection(vector<vector<int>>& nums) {\\n        unordered_map<int, int> countMap;\\n        vector<int> res;\\n        int desiredCount = nums.size();\\n        for(auto num : nums) {\\n            for(int i : num) {\\n                countMap[i]++;\\n                if(countMap[i] == desiredCount) {\\n                    res.push_back(i);\\n                }\\n            }\\n        }\\n        sort(res.begin(), res.end());\\n        return res;\\n    }\\n};\\n```\\n\\n**Code for Using ordered map**\\n\\n```\\nclass Solution {\\npublic:\\n    vector<int> intersection(vector<vector<int>>& nums) {\\n        map<int, int> countMap;\\n        vector<int> res;\\n        int desiredCount = nums.size();\\n        for(auto num : nums) {\\n            for(int i : num) {\\n                countMap[i]++;\\n            }\\n        }\\n        for(auto num : countMap) {\\n            if(num.second == desiredCount) {\\n                res.push_back(num.first);\\n            }\\n        }\\n        return res;\\n    }\\n};\\n```\\n\\n**Comment for doubts**\\n**Please upvote if liked the solution**",
                "solutionTags": [
                    "C++",
                    "C"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<int> intersection(vector<vector<int>>& nums) {\\n        unordered_map<int, int> countMap;\\n        vector<int> res;\\n        int desiredCount = nums.size();\\n        for(auto num : nums) {\\n            for(int i : num) {\\n                countMap[i]++;\\n                if(countMap[i] == desiredCount) {\\n                    res.push_back(i);\\n                }\\n            }\\n        }\\n        sort(res.begin(), res.end());\\n        return res;\\n    }\\n};\\n```\n```\\nclass Solution {\\npublic:\\n    vector<int> intersection(vector<vector<int>>& nums) {\\n        map<int, int> countMap;\\n        vector<int> res;\\n        int desiredCount = nums.size();\\n        for(auto num : nums) {\\n            for(int i : num) {\\n                countMap[i]++;\\n            }\\n        }\\n        for(auto num : countMap) {\\n            if(num.second == desiredCount) {\\n                res.push_back(num.first);\\n            }\\n        }\\n        return res;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1987155,
                "title": "c",
                "content": "```\\n\\n    public IList<int> Intersection(int[][] nums) \\n\\t{        \\n        int[] arr = nums[0];\\n        for(int i=1; i<nums.Length; i++)\\n        {\\n            arr = arr.Intersect(nums[i]).ToArray();\\n        }\\n        \\n        Array.Sort(arr);\\n        \\n        return arr;\\n    }",
                "solutionTags": [],
                "code": "```\\n\\n    public IList<int> Intersection(int[][] nums) \\n\\t{        \\n        int[] arr = nums[0];\\n        for(int i=1; i<nums.Length; i++)\\n        {\\n            arr = arr.Intersect(nums[i]).ToArray();\\n        }\\n        \\n        Array.Sort(arr);\\n        \\n        return arr;\\n    }",
                "codeTag": "Unknown"
            },
            {
                "id": 1984726,
                "title": "kotlin-1-line",
                "content": "```\\nfun intersection(a: Array<IntArray>) = a.flatMap { it.toList() }.filter { n -> a.all { it.contains(n) } }.distinct().sorted()\\n```",
                "solutionTags": [
                    "Kotlin"
                ],
                "code": "```\\nfun intersection(a: Array<IntArray>) = a.flatMap { it.toList() }.filter { n -> a.all { it.contains(n) } }.distinct().sorted()\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1982221,
                "title": "java-solution-using-a-hash-table-100-faster-5ms",
                "content": "```\\nclass Solution {\\n    public List<Integer> intersection(int[][] nums) {\\n        List<Integer> list = new ArrayList<>();\\n        int row = nums.length;\\n        int col = nums[0].length;\\n        if(row == 1) {\\n            for(int n : nums[0]) {\\n                list.add(n);\\n            }\\n            Collections.sort(list);\\n            return list;\\n        }\\n        \\n        int[] Hash = new int[1001];\\n        \\n        \\n        for(int[] num : nums) {\\n           for(int i = 0; i < num.length; i++) {\\n               Hash[num[i]]++;\\n           }\\n        }\\n        \\n        for(int i = 0; i < Hash.length; i++) {\\n            if(Hash[i] == nums.length) {\\n                list.add(i);\\n            }\\n        }\\n        \\n        Collections.sort(list);\\n        // System.out.print(Arrays.toString(Hash));\\n        return list;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Hash Table"
                ],
                "code": "```\\nclass Solution {\\n    public List<Integer> intersection(int[][] nums) {\\n        List<Integer> list = new ArrayList<>();\\n        int row = nums.length;\\n        int col = nums[0].length;\\n        if(row == 1) {\\n            for(int n : nums[0]) {\\n                list.add(n);\\n            }\\n            Collections.sort(list);\\n            return list;\\n        }\\n        \\n        int[] Hash = new int[1001];\\n        \\n        \\n        for(int[] num : nums) {\\n           for(int i = 0; i < num.length; i++) {\\n               Hash[num[i]]++;\\n           }\\n        }\\n        \\n        for(int i = 0; i < Hash.length; i++) {\\n            if(Hash[i] == nums.length) {\\n                list.add(i);\\n            }\\n        }\\n        \\n        Collections.sort(list);\\n        // System.out.print(Arrays.toString(Hash));\\n        return list;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1978795,
                "title": "c-sort-unordered-map-easy-to-understand-binary-search-stl-c",
                "content": "```\\n           ***  Please upvote if you find this helpful ***\\n\\n/*\\n        Method 1 -> using Binary search \\nclass Solution {\\npublic:\\n    vector<int> intersection(vector<vector<int>>& arr) \\n    {\\n        //1st sort all the element of the row ;\\n        int n = arr.size() ;\\n        for(int i = 0; i< n; i++)\\n        {\\n            sort(arr[i].begin() , arr[i].end()) ;\\n        }\\n        vector<int> ans ;\\n        \\n        // search first row element into all vectors ;\\n        for(int j = 0 ; j< arr[0].size() ; j++)\\n        {\\n            int cnt = 0;\\n            int x = arr[0][j] ; // get all element of an array ;\\n            for(int i = 0 ; i< n; i++)\\n            {\\n                if(binary_search(arr[i].begin() , arr[i].end() , x) == true)\\n                {\\n                    cnt++;\\n                }\\n            }\\n            if(cnt ==  n)\\n            {\\n                ans.push_back(x) ;\\n            }\\n        }\\n        return ans;\\n    }\\n    \\n};\\n*/\\n            // Method 2 Map\\nclass Solution {\\npublic:\\n    vector<int> intersection(vector<vector<int>>& arr) \\n    {\\n        int n = arr.size(); int m = arr[0].size() ;\\n        unordered_map<int,int> mp;\\n        for(auto x : arr)\\n        {\\n            for(auto y : x)\\n            {\\n                mp[y]++;\\n            }\\n        }\\n    //if any of the element is present in all this means its frequency is equal to n         \\n        vector<int> ans ;\\n        for(auto it : mp)\\n        {\\n            if(it.second == n)\\n            {\\n                ans.push_back(it.first) ;\\n            }\\n        }\\n        sort(ans.begin() , ans.end()) ;\\n        return ans ;\\n    }\\n    \\n};\\n\\nstatic int x=[](){\\n    ios::sync_with_stdio(false);\\n    cin.tie(nullptr);\\n    cout.tie(nullptr);\\n    \\n    return 0;\\n}();\\n```",
                "solutionTags": [
                    "C",
                    "Sorting",
                    "Binary Tree"
                ],
                "code": "```\\n           ***  Please upvote if you find this helpful ***\\n\\n/*\\n        Method 1 -> using Binary search \\nclass Solution {\\npublic:\\n    vector<int> intersection(vector<vector<int>>& arr) \\n    {\\n        //1st sort all the element of the row ;\\n        int n = arr.size() ;\\n        for(int i = 0; i< n; i++)\\n        {\\n            sort(arr[i].begin() , arr[i].end()) ;\\n        }\\n        vector<int> ans ;\\n        \\n        // search first row element into all vectors ;\\n        for(int j = 0 ; j< arr[0].size() ; j++)\\n        {\\n            int cnt = 0;\\n            int x = arr[0][j] ; // get all element of an array ;\\n            for(int i = 0 ; i< n; i++)\\n            {\\n                if(binary_search(arr[i].begin() , arr[i].end() , x) == true)\\n                {\\n                    cnt++;\\n                }\\n            }\\n            if(cnt ==  n)\\n            {\\n                ans.push_back(x) ;\\n            }\\n        }\\n        return ans;\\n    }\\n    \\n};\\n*/\\n            // Method 2 Map\\nclass Solution {\\npublic:\\n    vector<int> intersection(vector<vector<int>>& arr) \\n    {\\n        int n = arr.size(); int m = arr[0].size() ;\\n        unordered_map<int,int> mp;\\n        for(auto x : arr)\\n        {\\n            for(auto y : x)\\n            {\\n                mp[y]++;\\n            }\\n        }\\n    //if any of the element is present in all this means its frequency is equal to n         \\n        vector<int> ans ;\\n        for(auto it : mp)\\n        {\\n            if(it.second == n)\\n            {\\n                ans.push_back(it.first) ;\\n            }\\n        }\\n        sort(ans.begin() , ans.end()) ;\\n        return ans ;\\n    }\\n    \\n};\\n\\nstatic int x=[](){\\n    ios::sync_with_stdio(false);\\n    cin.tie(nullptr);\\n    cout.tie(nullptr);\\n    \\n    return 0;\\n}();\\n```",
                "codeTag": "C++"
            },
            {
                "id": 1978629,
                "title": "java-easy-solution-100-fast",
                "content": "**Idea :** The basic Idea which comes to my mind as a beiginner was that was that I can create a temp array in which I\\'m gonnna store the number of occurrance of a number, as the numbers are going to be distinct it becomes clear that in order to get the intersection, a number has to occur exactly the length of the matrix then only it\\'ll be present in all the arrays. \\n\\n*For example* : [[3,1,2,4,5],[1,2,3,4],[3,4,5,6]] as 3 and 4 occurs exactly thrice which is equals to the length. So we can create a temp array of a length 1000 and keep count which would look something like this [0, 2, 2, 3, 3, 2, 6,........]. We can iterarate over the temp array and return the index if it matches the length of the matrix.\\n\\n**Code :**\\n\\n```\\npublic static List<Integer> intersection(int[][] nums) {\\n        int[] temp = new int[1001];\\n        List<Integer> ans = new ArrayList<>();\\n        for (int[] num : nums) {\\n            for (int i : num) {\\n                temp[i]++;\\n            }\\n        }\\n        for (int i = 0; i < temp.length; i++) {\\n            if (temp[i] == nums.length) ans.add(i);\\n        }\\n        return ans;\\n    }\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\npublic static List<Integer> intersection(int[][] nums) {\\n        int[] temp = new int[1001];\\n        List<Integer> ans = new ArrayList<>();\\n        for (int[] num : nums) {\\n            for (int i : num) {\\n                temp[i]++;\\n            }\\n        }\\n        for (int i = 0; i < temp.length; i++) {\\n            if (temp[i] == nums.length) ans.add(i);\\n        }\\n        return ans;\\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1978575,
                "title": "a-few-solutions",
                "content": "Use a map `m` to count each value `x` of each row of the input matrix `A`.  Filter the map to return the sorted values which occur `K` times, ie. once per row.\\n\\n---\\n\\n*Kotlin*\\n```\\nclass Solution {\\n    fun intersection(A: Array<IntArray>): List<Int> {\\n        var K = A.size\\n        var m = mutableMapOf<Int, Int>()\\n        for (row in A)\\n            for (x in row)\\n                m[x] = 1 + (m[x] ?: 0)\\n        return m.filter{ (_, cnt) -> cnt == K }.map{ (x, _) -> x }.sorted().toList()\\n    }\\n}\\n```\\n\\n*Javascript*\\n```\\nlet intersection = (A, m = new Map()) => {\\n    let K = A.length;\\n    for (let row of A)\\n        for (let x of row)\\n            m.set(x, 1 + (m.get(x) || 0));\\n    return [...m].filter(([_, cnt]) => cnt == K).map(([x, _]) => x).sort((a, b) => a - b);\\n};\\n```\\n\\n*Python3*\\n```\\nclass Solution:\\n    def intersection(self, A: List[List[int]]) -> List[int]:\\n        K = len(A)\\n        m = defaultdict(int)\\n        for row in A:\\n            for x in row:\\n                m[x] += 1\\n        return sorted([x for x, cnt in m.items() if cnt == K])\\n```\\n\\n*Rust*\\n```\\ntype VI = Vec<i32>;\\ntype VVI = Vec<VI>;\\nuse std::collections::HashMap;\\nimpl Solution {\\n    pub fn intersection(A: VVI) -> VI {\\n        let K = A.len() as i32;\\n        let mut m = HashMap::new();\\n        for row in A {\\n            for x in row {\\n                *m.entry(x).or_insert(0) += 1;\\n            }\\n        }\\n        let mut ans = vec![];\\n        for (x, cnt) in m.iter() {\\n            if *cnt == K {\\n                ans.push(*x);\\n            }\\n        }\\n        ans.sort();\\n        return ans;\\n    }\\n}\\n```\\n\\n*C++*\\n```\\nclass Solution {\\npublic:\\n    using VI = vector<int>;\\n    using VVI = vector<VI>;\\n    using Map = unordered_map<int, int>;\\n    using Set = set<int>;\\n    VI intersection(VVI& A, Map m = {}, Set ans = {}) {\\n        auto K = A.size();\\n        for (auto& row: A)\\n            for (auto x: row)\\n                ++m[x];\\n        for (auto [x, cnt]:  m)\\n            if (cnt == K)\\n                ans.insert(x);\\n        return { ans.begin(), ans.end() };\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    fun intersection(A: Array<IntArray>): List<Int> {\\n        var K = A.size\\n        var m = mutableMapOf<Int, Int>()\\n        for (row in A)\\n            for (x in row)\\n                m[x] = 1 + (m[x] ?: 0)\\n        return m.filter{ (_, cnt) -> cnt == K }.map{ (x, _) -> x }.sorted().toList()\\n    }\\n}\\n```\n```\\nlet intersection = (A, m = new Map()) => {\\n    let K = A.length;\\n    for (let row of A)\\n        for (let x of row)\\n            m.set(x, 1 + (m.get(x) || 0));\\n    return [...m].filter(([_, cnt]) => cnt == K).map(([x, _]) => x).sort((a, b) => a - b);\\n};\\n```\n```\\nclass Solution:\\n    def intersection(self, A: List[List[int]]) -> List[int]:\\n        K = len(A)\\n        m = defaultdict(int)\\n        for row in A:\\n            for x in row:\\n                m[x] += 1\\n        return sorted([x for x, cnt in m.items() if cnt == K])\\n```\n```\\ntype VI = Vec<i32>;\\ntype VVI = Vec<VI>;\\nuse std::collections::HashMap;\\nimpl Solution {\\n    pub fn intersection(A: VVI) -> VI {\\n        let K = A.len() as i32;\\n        let mut m = HashMap::new();\\n        for row in A {\\n            for x in row {\\n                *m.entry(x).or_insert(0) += 1;\\n            }\\n        }\\n        let mut ans = vec![];\\n        for (x, cnt) in m.iter() {\\n            if *cnt == K {\\n                ans.push(*x);\\n            }\\n        }\\n        ans.sort();\\n        return ans;\\n    }\\n}\\n```\n```\\nclass Solution {\\npublic:\\n    using VI = vector<int>;\\n    using VVI = vector<VI>;\\n    using Map = unordered_map<int, int>;\\n    using Set = set<int>;\\n    VI intersection(VVI& A, Map m = {}, Set ans = {}) {\\n        auto K = A.size();\\n        for (auto& row: A)\\n            for (auto x: row)\\n                ++m[x];\\n        for (auto [x, cnt]:  m)\\n            if (cnt == K)\\n                ans.insert(x);\\n        return { ans.begin(), ans.end() };\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1977652,
                "title": "easy-solution-using-maps-and-frequency-count",
                "content": "```\\nclass Solution {\\npublic:\\n    vector<int> intersection(vector<vector<int>>& nums) {\\n        \\n        vector<int>nv;\\n        vector<int>ans;\\n        map<int,int>mp;\\n        \\n        int row=nums.size();\\n       // int col=nums[0].size();\\n        \\n        for(int i=0;i<row;i++)\\n        {\\n            int col=nums[i].size();\\n            for(int j=0;j<col;j++)\\n            {\\n                nv.push_back(nums[i][j]);\\n            }\\n        } \\n        for(int i=0;i<nv.size();i++)\\n        {\\n            mp[nv[i]]=mp[nv[i]]+1;\\n        } \\n        int temp;\\n        for(auto it=mp.begin();it!=mp.end();it++)\\n        {\\n            if(it->second>=nums.size())\\n            {\\n                temp=it->first;\\n                ans.push_back(temp);\\n            }\\n        } \\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<int> intersection(vector<vector<int>>& nums) {\\n        \\n        vector<int>nv;\\n        vector<int>ans;\\n        map<int,int>mp;\\n        \\n        int row=nums.size();\\n       // int col=nums[0].size();\\n        \\n        for(int i=0;i<row;i++)\\n        {\\n            int col=nums[i].size();\\n            for(int j=0;j<col;j++)\\n            {\\n                nv.push_back(nums[i][j]);\\n            }\\n        } \\n        for(int i=0;i<nv.size();i++)\\n        {\\n            mp[nv[i]]=mp[nv[i]]+1;\\n        } \\n        int temp;\\n        for(auto it=mp.begin();it!=mp.end();it++)\\n        {\\n            if(it->second>=nums.size())\\n            {\\n                temp=it->first;\\n                ans.push_back(temp);\\n            }\\n        } \\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1977550,
                "title": "c-binary-search-best-optimized-approach-explained-with-comments",
                "content": "**please up if helps and built a community**\\t\\n\\t\\n\\t// firstly sort all the arrays \\n    int n = nums.size();\\n    vector<int> ans;\\n    for(int i=0; i<n; i++){\\n        sort(nums[i].begin(), nums[i].end());\\n    }\\n    // here traverse the first array and search that element into the rest of arrays \\n    for(int i=0; i<nums[0].size(); i++) {\\n        int cnt = 0;\\n        int search = nums[0][i];\\n        for(int j=0; j<n; j++) {\\n            if(binary_search(nums[j].begin(), nums[j].end(), search))        // binary search built in funtion in C++ this return true or false ; \\n                cnt++;\\n        }\\n        if(cnt==n) {\\n            ans.push_back(search);//push that element into the ans vector;\\n        }\\n    }\\n    return ans;\\n\\t\\n\\t\\n****upvote if it helps****",
                "solutionTags": [
                    "C",
                    "Binary Tree"
                ],
                "code": "**please up if helps and built a community**\\t\\n\\t\\n\\t// firstly sort all the arrays \\n    int n = nums.size();\\n    vector<int> ans;\\n    for(int i=0; i<n; i++){\\n        sort(nums[i].begin(), nums[i].end());\\n    }\\n    // here traverse the first array and search that element into the rest of arrays \\n    for(int i=0; i<nums[0].size(); i++) {\\n        int cnt = 0;\\n        int search = nums[0][i];\\n        for(int j=0; j<n; j++) {\\n            if(binary_search(nums[j].begin(), nums[j].end(), search))        // binary search built in funtion in C++ this return true or false ; \\n                cnt++;\\n        }\\n        if(cnt==n) {\\n            ans.push_back(search);//push that element into the ans vector;\\n        }\\n    }\\n    return ans;\\n\\t\\n\\t\\n****upvote if it helps****",
                "codeTag": "Unknown"
            },
            {
                "id": 1977407,
                "title": "ruby-solution",
                "content": "My first solution was just to iteratively AND the arrays together, but this ought to be faster: use a hash table, and count up each appearance of a given value, then sort the hash entries first by count, then by key... now just return those whose count equals the total number of arrays we were originally given, i.e., if there were seven original arrays to check, then any number that showed up seven times in the hash table must have been in each of them.\\n\\n```\\n# @param {Integer[][]} nums\\n# @return {Integer[]}\\ndef intersection(nums)\\n    num_hash = Hash.new(0)\\n    nums.each do |arr|\\n        arr.each {|num| num_hash[num] += 1 }\\n    end\\n    new_nums = num_hash.to_a.sort {|x,y| [-x[1],x[0]] <=> [-y[1],y[0]]}\\n    ret_array = []\\n    for i in 0...new_nums.length\\n        if new_nums[i][1]==nums.length\\n            ret_array<<new_nums[i][0]\\n        else\\n            return ret_array\\n        end\\n    end\\n    ret_array\\nend",
                "solutionTags": [],
                "code": "My first solution was just to iteratively AND the arrays together, but this ought to be faster: use a hash table, and count up each appearance of a given value, then sort the hash entries first by count, then by key... now just return those whose count equals the total number of arrays we were originally given, i.e., if there were seven original arrays to check, then any number that showed up seven times in the hash table must have been in each of them.\\n\\n```\\n# @param {Integer[][]} nums\\n# @return {Integer[]}\\ndef intersection(nums)\\n    num_hash = Hash.new(0)\\n    nums.each do |arr|\\n        arr.each {|num| num_hash[num] += 1 }\\n    end\\n    new_nums = num_hash.to_a.sort {|x,y| [-x[1],x[0]] <=> [-y[1],y[0]]}\\n    ret_array = []\\n    for i in 0...new_nums.length\\n        if new_nums[i][1]==nums.length\\n            ret_array<<new_nums[i][0]\\n        else\\n            return ret_array\\n        end\\n    end\\n    ret_array\\nend",
                "codeTag": "Python3"
            },
            {
                "id": 1977247,
                "title": "c-hashmap-simple-fast-o-n-n",
                "content": "```\\nint* intersection(int** nums, int numsSize, int* numsColSize, int* returnSize)\\n{\\n    int hash[1001] = {0};\\n    int *res = malloc(sizeof(int) * 1001);\\n    for (int i = 0; i < numsSize; i++)\\n        for (int j = 0; j < numsColSize[i]; j++)\\n            hash[nums[i][j]]++;\\n    int j = 0;\\n    for (int i = 0; i < 1001; i++) {\\n        if (hash[i] == numsSize) {\\n            res[j] = i;\\n            j++;\\n        }\\n    }\\n    *returnSize = j;\\n    return res;\\n}\\n```\\n\\n***If this was helpful, don\\'t hesitate to upvote! :)***\\nHave a nice day!\\n",
                "solutionTags": [
                    "C"
                ],
                "code": "```\\nint* intersection(int** nums, int numsSize, int* numsColSize, int* returnSize)\\n{\\n    int hash[1001] = {0};\\n    int *res = malloc(sizeof(int) * 1001);\\n    for (int i = 0; i < numsSize; i++)\\n        for (int j = 0; j < numsColSize[i]; j++)\\n            hash[nums[i][j]]++;\\n    int j = 0;\\n    for (int i = 0; i < 1001; i++) {\\n        if (hash[i] == numsSize) {\\n            res[j] = i;\\n            j++;\\n        }\\n    }\\n    *returnSize = j;\\n    return res;\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1977241,
                "title": "python-hashmap-solution",
                "content": "```\\nclass Solution:\\n    def intersection(self, nums):\\n        d = {}\\n        \\n\\t\\t# Flatted 2D list\\n        new_nums = sum(nums, [])\\n    \\n        for num in new_nums:\\n            d[num] = d.get(num, 0) + 1\\n        \\n        target = len(nums)\\n        result = []\\n        \\n        for k, val in d.items():\\n            if val == target:\\n                result.append(k)\\n        \\n        return sorted(result)\\n```\\n\\n\\nRuntime: 66 ms, faster than 100.00% of Python3 online submissions for Intersection of Multiple Arrays.\\n\\nMemory Usage: 14.3 MB, less than 70.00% of Python3 online submissions for Intersection of Multiple Arrays.",
                "solutionTags": [
                    "Python"
                ],
                "code": "```\\nclass Solution:\\n    def intersection(self, nums):\\n        d = {}\\n        \\n\\t\\t# Flatted 2D list\\n        new_nums = sum(nums, [])\\n    \\n        for num in new_nums:\\n            d[num] = d.get(num, 0) + 1\\n        \\n        target = len(nums)\\n        result = []\\n        \\n        for k, val in d.items():\\n            if val == target:\\n                result.append(k)\\n        \\n        return sorted(result)\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1976867,
                "title": "c-map",
                "content": "```\\nclass Solution {\\npublic:\\n    vector<int> intersection(vector<vector<int>>& nums) {\\n        if(nums.size() == 0)    return {};\\n        map<int,int>mp;\\n        vector<int>ans;\\n        int count = 0;\\n        \\n        for(int i = 0; i < nums.size(); i++){\\n            for(int j = 0; j < nums[i].size(); j ++){\\n                int x = nums[i][j];\\n                mp[x]++;\\n            }\\n            count ++;\\n        }\\n        int freq;\\n        for (auto i : mp){\\n            freq = i.second;\\n            if(freq == count)    ans.push_back(i.first);\\n        }\\n        //sort(ans.begin(),ans.end());\\n        return ans;\\n    }\\n};\\n```\\n\\nIf it is helpfull for you , Pleace upvote!\\nHappy coding! ;-)",
                "solutionTags": [
                    "C"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<int> intersection(vector<vector<int>>& nums) {\\n        if(nums.size() == 0)    return {};\\n        map<int,int>mp;\\n        vector<int>ans;\\n        int count = 0;\\n        \\n        for(int i = 0; i < nums.size(); i++){\\n            for(int j = 0; j < nums[i].size(); j ++){\\n                int x = nums[i][j];\\n                mp[x]++;\\n            }\\n            count ++;\\n        }\\n        int freq;\\n        for (auto i : mp){\\n            freq = i.second;\\n            if(freq == count)    ans.push_back(i.first);\\n        }\\n        //sort(ans.begin(),ans.end());\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1976856,
                "title": "simple-c-solution",
                "content": "```\\nvector<int> intersection(vector<vector<int>>& nums) {\\n        int m=nums.size(),n=nums[0].size();\\n        unordered_map<int,int> mp;\\n        for(int i=0;i<m;i++){\\n            for(int j=0;j<nums[i].size();j++){\\n                mp[nums[i][j]]++;\\n            }\\n        }\\n        vector<int> v;\\n        for(auto i:mp){\\n            if(i.second==m) v.push_back(i.first);\\n        }\\n        sort(v.begin(),v.end());\\n        return v;\\n    }\\n```",
                "solutionTags": [
                    "C++",
                    "C"
                ],
                "code": "```\\nvector<int> intersection(vector<vector<int>>& nums) {\\n        int m=nums.size(),n=nums[0].size();\\n        unordered_map<int,int> mp;\\n        for(int i=0;i<m;i++){\\n            for(int j=0;j<nums[i].size();j++){\\n                mp[nums[i][j]]++;\\n            }\\n        }\\n        vector<int> v;\\n        for(auto i:mp){\\n            if(i.second==m) v.push_back(i.first);\\n        }\\n        sort(v.begin(),v.end());\\n        return v;\\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1976842,
                "title": "python-one-line",
                "content": "```\\nclass Solution:\\n    def intersection(self, nums: List[List[int]]) -> List[int]:\\n        return sorted(set.intersection(*map(set,nums)))\\n                \\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution:\\n    def intersection(self, nums: List[List[int]]) -> List[int]:\\n        return sorted(set.intersection(*map(set,nums)))\\n                \\n```",
                "codeTag": "Java"
            },
            {
                "id": 1976838,
                "title": "c-using-map",
                "content": "```\\nclass Solution {\\npublic:\\n    vector<int> intersection(vector<vector<int>>& nums) {\\n        vector<int> ans;        \\n        map<int,int> mp;     \\n        \\n        for(int i=0; i<nums.size(); i++){\\n            for(int j=0; j<nums[i].size(); j++)\\n            {\\n                mp[nums[i][j]]++;\\n            }\\n        }\\n        \\n        for(auto it:mp){            \\n            if(it.second == nums.size())\\n                ans.push_back(it.first);           \\n        } \\n        return ans;\\n        \\n    }\\n};\\n```",
                "solutionTags": [
                    "C"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<int> intersection(vector<vector<int>>& nums) {\\n        vector<int> ans;        \\n        map<int,int> mp;     \\n        \\n        for(int i=0; i<nums.size(); i++){\\n            for(int j=0; j<nums[i].size(); j++)\\n            {\\n                mp[nums[i][j]]++;\\n            }\\n        }\\n        \\n        for(auto it:mp){            \\n            if(it.second == nums.size())\\n                ans.push_back(it.first);           \\n        } \\n        return ans;\\n        \\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1976832,
                "title": "c-2248-intersection-of-multiple-arrays",
                "content": "\\n```\\nclass Solution {\\npublic:\\n    vector<int> intersection(vector<vector<int>>& nums) {\\n        set<int> s(nums[0].begin(), nums[0].end()); \\n        for (int i = 1; i < nums.size(); ++i) {\\n            set<int> ss(nums[i].begin(), nums[i].end()), temp; \\n            set_intersection(s.begin(), s.end(), ss.begin(), ss.end(), inserter(temp, temp.begin())); \\n            swap(s, temp); \\n        }\\n        vector<int> ans(s.begin(), s.end()); \\n        sort(ans.begin(), ans.end()); \\n        return ans; \\n    }\\n};\\n```",
                "solutionTags": [
                    "C"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<int> intersection(vector<vector<int>>& nums) {\\n        set<int> s(nums[0].begin(), nums[0].end()); \\n        for (int i = 1; i < nums.size(); ++i) {\\n            set<int> ss(nums[i].begin(), nums[i].end()), temp; \\n            set_intersection(s.begin(), s.end(), ss.begin(), ss.end(), inserter(temp, temp.begin())); \\n            swap(s, temp); \\n        }\\n        vector<int> ans(s.begin(), s.end()); \\n        sort(ans.begin(), ans.end()); \\n        return ans; \\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 4093806,
                "title": "fixed-storage-with-single-iteration",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nFirst thought was counting the number of occurence. Since a common candidate number will intersect (exist) in each array. Hence the count of that said Number will be equal to the size of nums.\\n\\ne.g. if 4 exist in [ar1], [arr2] and [arr3]. then counts for number 4 should be 3.\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\nOne iteration of unnavoidable O(N^2) through the 2D Matrix\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\nO(1000 or 1) space for counting occurence\\nO(M) where M is the size of nums \\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    vector<int> intersection(vector<vector<int>>& nums) {\\n        int count[1001]={0};\\n        vector<int>ans;\\n        for (vector<int>& each: nums){\\n            for(int num:each){\\n                if (++count[num] == nums.size())ans.push_back(num);\\n            }\\n        }\\n        sort(ans.begin(), ans.end()); \\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Sort"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<int> intersection(vector<vector<int>>& nums) {\\n        int count[1001]={0};\\n        vector<int>ans;\\n        for (vector<int>& each: nums){\\n            for(int num:each){\\n                if (++count[num] == nums.size())ans.push_back(num);\\n            }\\n        }\\n        sort(ans.begin(), ans.end()); \\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 4090454,
                "title": "step-by-step-approach",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\n/**\\n * @param {number[][]} nums\\n * @return {number[]}\\n */\\nvar intersection = function(nums) {\\n    let count = new Map();\\n    \\n    nums.forEach( list => {\\n        for(let i = 0; i < list.length; i++){\\n            if(count.has(list[i]) == true){\\n                count.set(list[i], (count.get(list[i]) || 0) + 1);\\n            } else {\\n                count.set(list[i], 1);\\n            }\\n        }\\n    });\\n\\n    let keys = count.keys();\\n    let ans = [];\\n\\n    for(let i of keys){\\n        if(count.get(i) == nums.length){\\n            ans.push(i);\\n        }\\n    }\\n    return ans.sort( (a, b) => a - b);\\n};\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\n/**\\n * @param {number[][]} nums\\n * @return {number[]}\\n */\\nvar intersection = function(nums) {\\n    let count = new Map();\\n    \\n    nums.forEach( list => {\\n        for(let i = 0; i < list.length; i++){\\n            if(count.has(list[i]) == true){\\n                count.set(list[i], (count.get(list[i]) || 0) + 1);\\n            } else {\\n                count.set(list[i], 1);\\n            }\\n        }\\n    });\\n\\n    let keys = count.keys();\\n    let ans = [];\\n\\n    for(let i of keys){\\n        if(count.get(i) == nums.length){\\n            ans.push(i);\\n        }\\n    }\\n    return ans.sort( (a, b) => a - b);\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 4086881,
                "title": "easy-java-code",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\n    public List<Integer> intersection(int[][] nums) {\\n      List<Integer> ans=new ArrayList();\\n      if(nums.length==0 || nums==null || nums[0].length==0) return ans;\\n      List<Integer>[] list=new ArrayList[nums.length];\\n      for(int i=0;i<nums.length;i++){\\n        Arrays.sort(nums[i]);\\n        list[i]=new ArrayList();\\n        for(int j=0;j<nums[i].length;j++){\\n          list[i].add(nums[i][j]);\\n        }\\n      }\\n        for(int i=0;i<nums[0].length;i++){\\n          boolean check=false;\\n          for(int j=0;j<nums.length;j++){\\n            if(!list[j].contains(nums[0][i])){\\n              check=true;\\n              break;\\n            }\\n          }\\n          if(!check) ans.add(nums[0][i]);\\n        }\\n        return ans;\\n    }\\n}\\n\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public List<Integer> intersection(int[][] nums) {\\n      List<Integer> ans=new ArrayList();\\n      if(nums.length==0 || nums==null || nums[0].length==0) return ans;\\n      List<Integer>[] list=new ArrayList[nums.length];\\n      for(int i=0;i<nums.length;i++){\\n        Arrays.sort(nums[i]);\\n        list[i]=new ArrayList();\\n        for(int j=0;j<nums[i].length;j++){\\n          list[i].add(nums[i][j]);\\n        }\\n      }\\n        for(int i=0;i<nums[0].length;i++){\\n          boolean check=false;\\n          for(int j=0;j<nums.length;j++){\\n            if(!list[j].contains(nums[0][i])){\\n              check=true;\\n              break;\\n            }\\n          }\\n          if(!check) ans.add(nums[0][i]);\\n        }\\n        return ans;\\n    }\\n}\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 4072568,
                "title": "python-clear-solution-using-sets",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution:\\n    def intersection(self, nums: List[List[int]]) -> List[int]:\\n        if len(nums) == 1:\\n            return sorted(nums[0])\\n\\n        set1 = set(nums[0])\\n        set2 = set(nums[1])\\n        temp = set1.intersection(set2)\\n\\n        for i in range(2, len(nums)):\\n            temp = temp.intersection(nums[i])\\n\\n        res = list(temp)\\n        return sorted(res)\\n\\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def intersection(self, nums: List[List[int]]) -> List[int]:\\n        if len(nums) == 1:\\n            return sorted(nums[0])\\n\\n        set1 = set(nums[0])\\n        set2 = set(nums[1])\\n        temp = set1.intersection(set2)\\n\\n        for i in range(2, len(nums)):\\n            temp = temp.intersection(nums[i])\\n\\n        res = list(temp)\\n        return sorted(res)\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 4068361,
                "title": "2248-intersection-of-multiple-arrays",
                "content": "# Intuition\\nUSING HASH MAP / ARRAY\\n\\n# Complexity\\n- Time complexity:\\nHASH MAP: O(m\\u22C5(n+logm))\\nARRAY AND LIST: O(N.M)\\n\\n- Space complexity:\\nO(N.M)\\n\\n# Code\\nAPPROACH 1: USING HASH MAP\\n```\\nclass Solution {\\n    public List<Integer> intersection(int[][] nums) {\\n    Map<Integer,Integer> freq= new HashMap<Integer,Integer>();\\n    List<Integer> result = new ArrayList<>();\\n    for(int i=0;i<nums.length;i++){\\n        for(int j=0; j<nums[i].length; j++){\\n        freq.put(nums[i][j], freq.getOrDefault(nums[i][j],0)+1);\\n        if(freq.get(nums[i][j])==nums.length){\\n            result.add(nums[i][j]);\\n        }\\n    }\\n    }\\n    Collections.sort(result);\\n    return result; \\n    }\\n}\\n```\\n\\nApproach: USING ARRAY AND LIST\\n```\\nclass Solution {\\n    public List<Integer> intersection(int[][] nums) {\\n        int n = nums.length;\\n        int m = 1001;\\n        int[] freq = new int[m];\\n        for(int i=0; i<n; i++) {\\n            for(int j=0; j<nums[i].length; j++) {\\n                int num = nums[i][j];\\n                freq[num]++;\\n            }\\n        }\\n        List<Integer> ans = new ArrayList<>();\\n        for(int i=1; i<m; i++) {\\n            if(freq[i] == n) {\\n                ans.add(i);\\n            }\\n        }\\n        return ans;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Array",
                    "Hash Table"
                ],
                "code": "```\\nclass Solution {\\n    public List<Integer> intersection(int[][] nums) {\\n    Map<Integer,Integer> freq= new HashMap<Integer,Integer>();\\n    List<Integer> result = new ArrayList<>();\\n    for(int i=0;i<nums.length;i++){\\n        for(int j=0; j<nums[i].length; j++){\\n        freq.put(nums[i][j], freq.getOrDefault(nums[i][j],0)+1);\\n        if(freq.get(nums[i][j])==nums.length){\\n            result.add(nums[i][j]);\\n        }\\n    }\\n    }\\n    Collections.sort(result);\\n    return result; \\n    }\\n}\\n```\n```\\nclass Solution {\\n    public List<Integer> intersection(int[][] nums) {\\n        int n = nums.length;\\n        int m = 1001;\\n        int[] freq = new int[m];\\n        for(int i=0; i<n; i++) {\\n            for(int j=0; j<nums[i].length; j++) {\\n                int num = nums[i][j];\\n                freq[num]++;\\n            }\\n        }\\n        List<Integer> ans = new ArrayList<>();\\n        for(int i=1; i<m; i++) {\\n            if(freq[i] == n) {\\n                ans.add(i);\\n            }\\n        }\\n        return ans;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 4064282,
                "title": "c-easy-to-understand-solution",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nWe need to check if elements of first array in nums exists in all other arrays within num\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\nCreate two copies of the first array of num\\nStarting from second array of nums, iterate over the elements from first array\\n    If the current array does not contain the element from first array, remove the element from the first array\\nWhile doing so, if we exaust all elements from the first array, return empty result indicating no matching elements were found.\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\npublic class Solution {\\n    public IList<int> Intersection(int[][] nums) {\\n        List<int> temp = new List<int>();\\n        List<int> finalResult = new List<int>();\\n        for(int i=0;i<nums.Length;i++){\\n            if(i == 0){\\n                foreach(var number in nums[0]){\\n                    temp.Add(number);\\n                    finalResult.Add(number);\\n                }\\n            }\\n            else{\\n                if(finalResult.Count==0){\\n                    return finalResult;\\n                }\\n                foreach(var num in temp){\\n                    if(!nums[i].ToList().Contains(num)){\\n                        finalResult.Remove(num);\\n                    }\\n                }\\n                \\n            }\\n        }\\n        finalResult.Sort();\\n        return finalResult;\\n    }\\n}\\n```",
                "solutionTags": [
                    "C#"
                ],
                "code": "```\\npublic class Solution {\\n    public IList<int> Intersection(int[][] nums) {\\n        List<int> temp = new List<int>();\\n        List<int> finalResult = new List<int>();\\n        for(int i=0;i<nums.Length;i++){\\n            if(i == 0){\\n                foreach(var number in nums[0]){\\n                    temp.Add(number);\\n                    finalResult.Add(number);\\n                }\\n            }\\n            else{\\n                if(finalResult.Count==0){\\n                    return finalResult;\\n                }\\n                foreach(var num in temp){\\n                    if(!nums[i].ToList().Contains(num)){\\n                        finalResult.Remove(num);\\n                    }\\n                }\\n                \\n            }\\n        }\\n        finalResult.Sort();\\n        return finalResult;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 4063619,
                "title": "python3-solution",
                "content": "\\n\\n# Code\\n```\\nclass Solution:\\n    def intersection(self, nums: List[List[int]]) -> List[int]:\\n        res=[] \\n        for t in nums[0]:\\n            for y in range(1,len(nums)):\\n                if t not in nums[y]:\\n                    break \\n            else:\\n                res.append(t) \\n        return sorted(res)\\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def intersection(self, nums: List[List[int]]) -> List[int]:\\n        res=[] \\n        for t in nums[0]:\\n            for y in range(1,len(nums)):\\n                if t not in nums[y]:\\n                    break \\n            else:\\n                res.append(t) \\n        return sorted(res)\\n```",
                "codeTag": "Java"
            },
            {
                "id": 4062071,
                "title": "java-solution-hashmap",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\n    public List<Integer> intersection(int[][] nums) {\\n        Map<Integer, Integer> map = new HashMap<>();\\n        for(int[] num : nums){\\n            for(int n : num){\\n                map.putIfAbsent(n, 0);\\n                map.put(n, map.get(n) + 1);\\n            }\\n        }\\n        List<Integer> result = new ArrayList<>();\\n        int length = nums.length;\\n        for(Map.Entry<Integer, Integer> entry : map.entrySet()){\\n            if(entry.getValue() == length){\\n                result.add(entry.getKey());\\n            }\\n        }\\n        Collections.sort(result);\\n        return result;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public List<Integer> intersection(int[][] nums) {\\n        Map<Integer, Integer> map = new HashMap<>();\\n        for(int[] num : nums){\\n            for(int n : num){\\n                map.putIfAbsent(n, 0);\\n                map.put(n, map.get(n) + 1);\\n            }\\n        }\\n        List<Integer> result = new ArrayList<>();\\n        int length = nums.length;\\n        for(Map.Entry<Integer, Integer> entry : map.entrySet()){\\n            if(entry.getValue() == length){\\n                result.add(entry.getKey());\\n            }\\n        }\\n        Collections.sort(result);\\n        return result;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 4056675,
                "title": "simple-c-solution",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    vector<int> intersection(vector<vector<int>>& nums) {\\n        unordered_map<int,int> mp;\\n        vector<int> ans;\\n\\n        for(int i=0;i<nums.size();i++){\\n            for(int j=0;j<nums[i].size();j++){\\n                mp[nums[i][j]]++;\\n            }\\n        }\\n        for(auto x:mp){\\n            if(x.second==nums.size())\\n            ans.push_back(x.first);\\n        }\\n        sort(ans.begin(),ans.end());\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Hash Table"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<int> intersection(vector<vector<int>>& nums) {\\n        unordered_map<int,int> mp;\\n        vector<int> ans;\\n\\n        for(int i=0;i<nums.size();i++){\\n            for(int j=0;j<nums[i].size();j++){\\n                mp[nums[i][j]]++;\\n            }\\n        }\\n        for(auto x:mp){\\n            if(x.second==nums.size())\\n            ans.push_back(x.first);\\n        }\\n        sort(ans.begin(),ans.end());\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 4055380,
                "title": "ts-beats-100-00-of-users-wit-typescript-hashmap-easy-to-understand",
                "content": "# Intuition\\n\"Anytime you need to count anything, think about using a hash map to do it\".\\n\\n# Approach\\nHashing\\n\\n# Complexity\\n- Time complexity:\\n$$O(n^2)$$\\n\\n- Space complexity:\\n$$O(n)$$\\n\\n# Code\\n```\\nconst intersection = (nums: number[][]): number[] => {\\n    const map = new Map<number, number>()\\n\\n    for (let i = 0; i < nums.length; i++) {\\n        for (let j = 0; j < nums[i].length; j++) {\\n            map.set(nums[i][j], (map.get(nums[i][j]) || 0) + 1); \\n        }\\n    }\\n\\n    const ans = []\\n    for (const [key, value] of map) {\\n        if (value === nums.length) ans.push(key);\\n    }\\n\\n\\n    return ans.sort((a, b) => a - b);\\n};\\n```",
                "solutionTags": [
                    "TypeScript"
                ],
                "code": "```\\nconst intersection = (nums: number[][]): number[] => {\\n    const map = new Map<number, number>()\\n\\n    for (let i = 0; i < nums.length; i++) {\\n        for (let j = 0; j < nums[i].length; j++) {\\n            map.set(nums[i][j], (map.get(nums[i][j]) || 0) + 1); \\n        }\\n    }\\n\\n    const ans = []\\n    for (const [key, value] of map) {\\n        if (value === nums.length) ans.push(key);\\n    }\\n\\n\\n    return ans.sort((a, b) => a - b);\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 4046949,
                "title": "accepted-solution-with-set",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\n    func intersection(_ nums: [[Int]]) -> [Int] {\\n        \\n        var result = Set(nums[0])\\n\\n        for array in nums {\\n            result = result.intersection(array)\\n        }\\n\\n        return Array(result).sorted()\\n    }\\n}\\n```",
                "solutionTags": [
                    "Swift",
                    "Array",
                    "Hash Table"
                ],
                "code": "```\\nclass Solution {\\n    func intersection(_ nums: [[Int]]) -> [Int] {\\n        \\n        var result = Set(nums[0])\\n\\n        for array in nums {\\n            result = result.intersection(array)\\n        }\\n\\n        return Array(result).sorted()\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 4043780,
                "title": "java-simple-solution-hashmap",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\nO(N)\\n\\n- Space complexity:\\nO(N)\\n\\n# Code\\n```\\nclass Solution {\\n    public List<Integer> intersection(int[][] nums) {\\n       \\n       List<Integer>ans=new ArrayList<>();\\n\\n       HashMap<Integer,Integer>map=new HashMap<>();\\n\\n       for(int num[]:nums){\\n           for(int i:num){\\n               map.put(i,map.getOrDefault(i,0)+1);\\n           }\\n       }\\n\\n       for(Map.Entry<Integer,Integer>val:map.entrySet()){\\n           if(val.getValue()==nums.length){\\n               ans.add(val.getKey());\\n           }\\n       }\\n       Collections.sort(ans);\\n        return ans;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public List<Integer> intersection(int[][] nums) {\\n       \\n       List<Integer>ans=new ArrayList<>();\\n\\n       HashMap<Integer,Integer>map=new HashMap<>();\\n\\n       for(int num[]:nums){\\n           for(int i:num){\\n               map.put(i,map.getOrDefault(i,0)+1);\\n           }\\n       }\\n\\n       for(Map.Entry<Integer,Integer>val:map.entrySet()){\\n           if(val.getValue()==nums.length){\\n               ans.add(val.getKey());\\n           }\\n       }\\n       Collections.sort(ans);\\n        return ans;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 4040952,
                "title": "go-hashmap-easy",
                "content": "\\n\\n# Complexity\\n- Time complexity: O(n*m + mLogm)\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:O(n.m)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\n\\nfunc intersection(nums [][]int) []int {\\n    m := make(map[int]int)\\n    for _, arr := range nums {\\n        for _, v := range arr {\\n            m[v] += 1\\n        }\\n    }\\n    ans := []int{}\\n    for k, v := range m {\\n        if v == len(nums) {\\n            ans = append(ans, k)\\n        }\\n    }\\n    sort.Ints(ans)\\n    return ans\\n}\\n```",
                "solutionTags": [
                    "Go"
                ],
                "code": "```\\n\\nfunc intersection(nums [][]int) []int {\\n    m := make(map[int]int)\\n    for _, arr := range nums {\\n        for _, v := range arr {\\n            m[v] += 1\\n        }\\n    }\\n    ans := []int{}\\n    for k, v := range m {\\n        if v == len(nums) {\\n            ans = append(ans, k)\\n        }\\n    }\\n    sort.Ints(ans)\\n    return ans\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 4040034,
                "title": "easy-solution",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution:\\n    def intersection(self, nums: List[List[int]]) -> List[int]:\\n        d = {}\\n        l = []\\n        for i in range(len(nums)):\\n            for j in nums[i]:\\n                d[j] = 0\\n        for i in range(len(nums)):\\n            for j in nums[i]:\\n                if j in d.keys():\\n                    d[j] = d[j] + 1\\n        for key, value in d.items():\\n            if value == len(nums):\\n                l.append(key)\\n        return sorted(l)\\n       \\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def intersection(self, nums: List[List[int]]) -> List[int]:\\n        d = {}\\n        l = []\\n        for i in range(len(nums)):\\n            for j in nums[i]:\\n                d[j] = 0\\n        for i in range(len(nums)):\\n            for j in nums[i]:\\n                if j in d.keys():\\n                    d[j] = d[j] + 1\\n        for key, value in d.items():\\n            if value == len(nums):\\n                l.append(key)\\n        return sorted(l)\\n       \\n```",
                "codeTag": "Java"
            },
            {
                "id": 4036196,
                "title": "beginner-friendly-only-using-array-beats-99-runtime",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\n    public List<Integer> intersection(int[][] nums) {\\n        int arr[] = new int[1001];\\n        for(int i=0; i<nums.length; i++){\\n            for(int j=0; j<nums[i].length; j++)\\n                arr[nums[i][j]]++;\\n        }\\n        List<Integer> list = new ArrayList<>();\\n        for(int i=0; i<arr.length; i++){\\n            if(arr[i] == nums.length)\\n                list.add(i);\\n        }\\n        return list;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Array"
                ],
                "code": "```\\nclass Solution {\\n    public List<Integer> intersection(int[][] nums) {\\n        int arr[] = new int[1001];\\n        for(int i=0; i<nums.length; i++){\\n            for(int j=0; j<nums[i].length; j++)\\n                arr[nums[i][j]]++;\\n        }\\n        List<Integer> list = new ArrayList<>();\\n        for(int i=0; i<arr.length; i++){\\n            if(arr[i] == nums.length)\\n                list.add(i);\\n        }\\n        return list;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 4035246,
                "title": "ts-58ms-beats-86-54-of-users-with-typescript",
                "content": "# Approach\\nHashing\\n\\n# Complexity\\n- Time complexity:\\n$$O(m\\u22C5(n + log m))$$\\n\\n- Space complexity:\\n$$O(n\\u22C5m)$$\\n\\n# Code\\n```\\nconst intersection = (nums: number[][]): number[] => {\\n    const map = new Map<number, number>()\\n    \\n    for(const arr of nums) {\\n        for (const num of arr) {\\n            map.set(num, (map.get(num) || 0) + 1)\\n        }\\n    }\\n\\n    const ans = []\\n    for (const [key, value] of map) {\\n        if (value === nums.length) {\\n            ans.push(key)\\n        }\\n    }\\n\\n    return ans.sort((a, b) => a - b)\\n};\\n```",
                "solutionTags": [
                    "TypeScript"
                ],
                "code": "```\\nconst intersection = (nums: number[][]): number[] => {\\n    const map = new Map<number, number>()\\n    \\n    for(const arr of nums) {\\n        for (const num of arr) {\\n            map.set(num, (map.get(num) || 0) + 1)\\n        }\\n    }\\n\\n    const ans = []\\n    for (const [key, value] of map) {\\n        if (value === nums.length) {\\n            ans.push(key)\\n        }\\n    }\\n\\n    return ans.sort((a, b) => a - b)\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 4032095,
                "title": "easy-javascript-solution-with-line-by-line-explanation",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\n/**\\n * @param {number[][]} nums\\n * @return {number[]}\\n */\\nvar intersection = function (nums) {\\n    // initialize empty array result\\n    let result = [];\\n\\n    // loop through the every element of first element of array nums\\n    for (let i = 0; i < nums[0].length; i++) {\\n\\n        // initialize k to zero\\n        let k = 0;\\n\\n        // loop through every element of array nums from 1\\n        for (let j = 1; j < nums.length; j++) {\\n\\n            // if every element of nums does not includes number of first element of nums then increment k\\n            if (!nums[j].includes(nums[0][i])) {\\n                k++;\\n            }\\n        }\\n\\n        // if k is equal to zero then push number of first element of nums in array result\\n        if (k === 0) {\\n            result.push(nums[0][i]);\\n        }\\n    }\\n\\n    // return the result in ascending order\\n    return result.sort((a, b) => a - b);\\n};\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\n/**\\n * @param {number[][]} nums\\n * @return {number[]}\\n */\\nvar intersection = function (nums) {\\n    // initialize empty array result\\n    let result = [];\\n\\n    // loop through the every element of first element of array nums\\n    for (let i = 0; i < nums[0].length; i++) {\\n\\n        // initialize k to zero\\n        let k = 0;\\n\\n        // loop through every element of array nums from 1\\n        for (let j = 1; j < nums.length; j++) {\\n\\n            // if every element of nums does not includes number of first element of nums then increment k\\n            if (!nums[j].includes(nums[0][i])) {\\n                k++;\\n            }\\n        }\\n\\n        // if k is equal to zero then push number of first element of nums in array result\\n        if (k === 0) {\\n            result.push(nums[0][i]);\\n        }\\n    }\\n\\n    // return the result in ascending order\\n    return result.sort((a, b) => a - b);\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 4026451,
                "title": "easy",
                "content": "```class Solution {\\npublic:\\n    vector<int> intersection(vector<vector<int>>& nums) {\\n        vector<int>ans;\\n    // unordered_map<int,int>mp;\\n           map<int,int>mp;\\n    for( auto i:nums)\\n    {\\n        for(auto j:i)\\n        {\\n            mp[j]++;\\n        }\\n    }\\n    for(auto i:mp)\\n    {\\n        if(i.second>=nums.size())\\n        {\\n            ans.push_back(i.first);\\n        }\\n    }\\n    //sort(ans.begin(),ans.end());\\n    return ans;\\n\\n    }\\n};",
                "solutionTags": [
                    "C++"
                ],
                "code": "class Solution {\\npublic:\\n    vector<int> intersection(vector<vector<int>>& nums) {\\n        vector<int>ans;\\n    // unordered_map<int,int>mp;\\n           map<int,int>mp;\\n    for( auto i:nums)\\n    {\\n        for(auto j:i)\\n        {\\n            mp[j]++;\\n        }",
                "codeTag": "Java"
            },
            {
                "id": 4026322,
                "title": "succinct-java-1-liner",
                "content": "Well, technically 1-liner, just broken to multiple lines for readability :-)\\n\\n# Code\\n```\\nimport static java.util.function.Function.identity;\\nimport static java.util.stream.Collectors.toMap;\\nimport java.util.List;\\nimport java.util.Map.Entry;\\nimport java.util.stream.IntStream;\\nimport java.util.stream.Stream;\\n\\nclass Solution {\\n  public List<Integer> intersection(int[][] nums) {\\n    return Stream.of(nums)\\n      .flatMap(v -> IntStream.of(v).boxed())\\n      .collect(toMap(identity(), n -> 1, Integer::sum))\\n      .entrySet().stream()\\n      .filter(e -> e.getValue() == nums.length)\\n      .map(Entry::getKey)\\n      .sorted()\\n      .toList();\\n  }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nimport static java.util.function.Function.identity;\\nimport static java.util.stream.Collectors.toMap;\\nimport java.util.List;\\nimport java.util.Map.Entry;\\nimport java.util.stream.IntStream;\\nimport java.util.stream.Stream;\\n\\nclass Solution {\\n  public List<Integer> intersection(int[][] nums) {\\n    return Stream.of(nums)\\n      .flatMap(v -> IntStream.of(v).boxed())\\n      .collect(toMap(identity(), n -> 1, Integer::sum))\\n      .entrySet().stream()\\n      .filter(e -> e.getValue() == nums.length)\\n      .map(Entry::getKey)\\n      .sorted()\\n      .toList();\\n  }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 4023732,
                "title": "c-map-easy-solution",
                "content": "\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n1. The Approach is to keep counting the number of elemets present in the 2d-vector store the element Occurance with number of times they repeated in a map.\\n\\n1. Traverse the map and check if an element count in a map is equal to number of rows then that element is repeated in every array\\n\\n# Complexity\\n- Time complexity:\\nO(N^2) + O(N)\\n\\n\\n- Space complexity:\\nO(N)\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    vector<int> intersection(vector<vector<int>>& nums) {\\n        int n = nums.size();\\n        // int m = nums[0].size();\\n        unordered_map<int,int>mp;\\n      \\n        for(int i=0; i<n; i++){\\n            int m = nums[i].size();\\n            for(int j=0; j<m; j++){\\n                if(mp.find(nums[i][j])!=mp.end()){\\n                    mp[nums[i][j]]++;\\n                }\\n                else{\\n                    mp[nums[i][j]]++;\\n                }\\n            }\\n        }\\n        vector<int>ans;\\n        for(auto it = mp.begin(); it!=mp.end(); it++){\\n            if(it->second == n){\\n                ans.push_back(it->first);\\n            }\\n        }\\n        sort(ans.begin(), ans.end());\\n            return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Ordered Map",
                    "Counting"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<int> intersection(vector<vector<int>>& nums) {\\n        int n = nums.size();\\n        // int m = nums[0].size();\\n        unordered_map<int,int>mp;\\n      \\n        for(int i=0; i<n; i++){\\n            int m = nums[i].size();\\n            for(int j=0; j<m; j++){\\n                if(mp.find(nums[i][j])!=mp.end()){\\n                    mp[nums[i][j]]++;\\n                }\\n                else{\\n                    mp[nums[i][j]]++;\\n                }\\n            }\\n        }\\n        vector<int>ans;\\n        for(auto it = mp.begin(); it!=mp.end(); it++){\\n            if(it->second == n){\\n                ans.push_back(it->first);\\n            }\\n        }\\n        sort(ans.begin(), ans.end());\\n            return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 4023667,
                "title": "how-is-this-solution",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution(object):\\n    def intersection(self, nums):\\n        \"\"\"\\n        :type nums: List[List[int]]\\n        :rtype: List[int]\\n        \"\"\"\\n        \\n        fl = []\\n        \\n        flag = True\\n        \\n        for i in range(len(nums[0])):\\n            for j in range(1, len(nums)):\\n                if nums[0][i] not in nums[j]:\\n                    flag = False\\n                    break\\n                else:\\n                    flag = True\\n            if flag:\\n                fl.append(nums[0][i])\\n        fl.sort()\\n        return fl\\n        \\n        \\n```",
                "solutionTags": [
                    "Python"
                ],
                "code": "```\\nclass Solution(object):\\n    def intersection(self, nums):\\n        \"\"\"\\n        :type nums: List[List[int]]\\n        :rtype: List[int]\\n        \"\"\"\\n        \\n        fl = []\\n        \\n        flag = True\\n        \\n        for i in range(len(nums[0])):\\n            for j in range(1, len(nums)):\\n                if nums[0][i] not in nums[j]:\\n                    flag = False\\n                    break\\n                else:\\n                    flag = True\\n            if flag:\\n                fl.append(nums[0][i])\\n        fl.sort()\\n        return fl\\n        \\n        \\n```",
                "codeTag": "Java"
            },
            {
                "id": 4022525,
                "title": "simple-solution-for-intersection-of-multiple-arrays-beats-65-17",
                "content": "# Intuition\\nThe intuition is to count the occurrences of each distinct integer in the arrays and find those integers that occur in all arrays.\\n\\n# Approach\\n1. Use a dictionary to count the occurrences of each integer.\\n2. Iterate through the arrays, updating the count for each integer.\\n3. Identify integers with counts equal to the number of arrays.\\n4. Sort the identified integers in ascending order.\\n5. Return the sorted list.\\n\\n\\n# Complexity\\n- Time complexity: O(N), where N is the total number of integers in all arrays.\\n- Space complexity: O(K), where K is the number of distinct integers in all arrays.\\n\\n# Code\\n```\\npublic class Solution {\\n    public IList<int> Intersection(int[][] nums) {\\n        Dictionary<int, int> count = new Dictionary<int, int>();\\n        List<int> result = new List<int>();\\n\\n        int numArrays = nums.Length;\\n\\n        foreach (var numArray in nums) {\\n            foreach (var num in numArray) {\\n                if (count.ContainsKey(num)) {\\n                    count[num]++;\\n                } else {\\n                    count[num] = 1;\\n                }\\n            }\\n        }\\n\\n        foreach (var kvp in count) {\\n            if (kvp.Value == numArrays) {\\n                result.Add(kvp.Key);\\n            }\\n        }\\n\\n        result.Sort();\\n\\n        return result;\\n    }\\n}\\n\\n```",
                "solutionTags": [
                    "C#"
                ],
                "code": "```\\npublic class Solution {\\n    public IList<int> Intersection(int[][] nums) {\\n        Dictionary<int, int> count = new Dictionary<int, int>();\\n        List<int> result = new List<int>();\\n\\n        int numArrays = nums.Length;\\n\\n        foreach (var numArray in nums) {\\n            foreach (var num in numArray) {\\n                if (count.ContainsKey(num)) {\\n                    count[num]++;\\n                } else {\\n                    count[num] = 1;\\n                }\\n            }\\n        }\\n\\n        foreach (var kvp in count) {\\n            if (kvp.Value == numArrays) {\\n                result.Add(kvp.Key);\\n            }\\n        }\\n\\n        result.Sort();\\n\\n        return result;\\n    }\\n}\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 4018942,
                "title": "easy-and-simplest-approach",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->The goal of this code is to find the intersection of elements that are present in all the given lists of integers. The code does this by first converting the first list into a set called common_ele. Then, it iterates through the remaining lists, converting each of them into a set and taking the intersection with the common_ele set. Finally, it converts the resulting set back into a sorted list to return the intersection in ascending order.\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n1. Initialize a set called common_ele with the elements from the first list in nums.\\n2. Iterate through the remaining lists in nums (starting from the second list).\\n-->For each list, convert it into a set called current.\\n-->Update the common_ele set by taking the intersection with the current set using the intersection_update method. This step ensures that common_ele only contains elements that are common to all lists processed so far.\\n3. After processing all lists, convert the common_ele set into a sorted list using sorted and list functions.\\n4. Return the sorted list as the result, which contains the elements present in all input lists in ascending order.\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n1. Initializing the common_ele set from the first list takes O(m) time, where m is the average length of the lists.\\n2. The loop that iterates through the remaining lists takes O(n * m) time in total because, in the worst case, it processes each element of each list once.\\n3. Taking the intersection using intersection_update is an O(m) operation.\\n4. Converting the set back to a sorted list using sorted and list functions takes O(m * log(m)) time due to sorting.\\n5. Therefore, the overall time complexity of the code is O(m) + O(n * m) + O(m * log(m)), where n is the number of lists and m is the average length of the lists.\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n1. The space complexity mainly depends on the additional data structures used:\\n    -->common_ele set is created and contains a subset of the input elements, so its space complexity is O(m) where m is the average length of the lists.\\n    -->The resulting sorted list has a space complexity of O(m) as well.\\n2. Therefore, the overall space complexity of the code is O(m) + O(m) = O(m), where m is the average length of the lists.\\n\\n# Code\\n```\\nclass Solution:\\n    def intersection(self, nums: List[List[int]]) -> List[int]:\\n        # Initialize a set with the elements from the first array\\n        common_ele = set(nums[0])\\n        # Iterate through the remaining arrays and simultaneously update the common_ele\\n        for array in nums[1:]:\\n            # Convert the current to set\\n            current = set(array)\\n            # Update the common by considering intersection with the current\\n            common_ele.intersection_update(current)\\n        result = sorted(list(common_ele))\\n        return result\\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def intersection(self, nums: List[List[int]]) -> List[int]:\\n        # Initialize a set with the elements from the first array\\n        common_ele = set(nums[0])\\n        # Iterate through the remaining arrays and simultaneously update the common_ele\\n        for array in nums[1:]:\\n            # Convert the current to set\\n            current = set(array)\\n            # Update the common by considering intersection with the current\\n            common_ele.intersection_update(current)\\n        result = sorted(list(common_ele))\\n        return result\\n```",
                "codeTag": "Java"
            },
            {
                "id": 4014532,
                "title": "it-s-super-simple-solution",
                "content": "\\n# Code\\n```\\nclass Solution:\\n    def intersection(self, nums: List[List[int]]) -> List[int]:\\n        hash_ = {}\\n        ans = []\\n        for i in nums:\\n            for j in i:\\n                if j not in hash_:\\n                    hash_[j] = 1\\n                else:\\n                    hash_[j] += 1\\n        for i, k in enumerate (hash_):\\n            if hash_[k] == len(nums):\\n                ans.append(k)\\n        return sorted(ans)\\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def intersection(self, nums: List[List[int]]) -> List[int]:\\n        hash_ = {}\\n        ans = []\\n        for i in nums:\\n            for j in i:\\n                if j not in hash_:\\n                    hash_[j] = 1\\n                else:\\n                    hash_[j] += 1\\n        for i, k in enumerate (hash_):\\n            if hash_[k] == len(nums):\\n                ans.append(k)\\n        return sorted(ans)\\n```",
                "codeTag": "Java"
            },
            {
                "id": 4003999,
                "title": "easy-and-understandable-solution-for-beginners",
                "content": "\\n# Code\\n```\\nclass Solution {\\n    func intersection(_ nums: [[Int]]) -> [Int] {\\n        var answer:[Int] = []\\n\\n        let first = nums[0]\\n\\n        for i in first{\\n            var check = true\\n            for j in 1..<nums.count{\\n                if nums[j].contains(i) {\\n                    check = true\\n                } else {\\n                    check = false\\n                    break\\n                }\\n            }\\n            if check == true{\\n                answer.append(i)\\n            }\\n        }\\n\\n        return answer.sorted()\\n    }\\n}\\n```",
                "solutionTags": [
                    "Swift"
                ],
                "code": "```\\nclass Solution {\\n    func intersection(_ nums: [[Int]]) -> [Int] {\\n        var answer:[Int] = []\\n\\n        let first = nums[0]\\n\\n        for i in first{\\n            var check = true\\n            for j in 1..<nums.count{\\n                if nums[j].contains(i) {\\n                    check = true\\n                } else {\\n                    check = false\\n                    break\\n                }\\n            }\\n            if check == true{\\n                answer.append(i)\\n            }\\n        }\\n\\n        return answer.sorted()\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 4002909,
                "title": "dictionary-solution-in-c",
                "content": "\\n\\n# Code\\n```\\npublic class Solution {\\n    public IList<int> Intersection(int[][] nums) {\\n    var dict = new Dictionary<int, int>();\\n    var responseList = new List<int>();\\n    for (int i = 0; i < nums.Length; i++)\\n    {\\n        var innerArray = nums[i];\\n\\n        foreach (var element in innerArray)\\n        {\\n            if(!dict.ContainsKey(element))\\n                dict.Add(element, 1);\\n            else\\n            {\\n                var value = dict[element];\\n                dict[element] = value + 1;\\n            }\\n        }\\n        \\n    }\\n    \\n    var values = dict.Where(a => a.Value == nums.Length);\\n\\n    foreach (var value in values)\\n    {\\n        responseList.Add(value.Key);\\n    }\\n\\n    return responseList.OrderBy(a => a).ToList(); \\n    }\\n}\\n```",
                "solutionTags": [
                    "C#"
                ],
                "code": "```\\npublic class Solution {\\n    public IList<int> Intersection(int[][] nums) {\\n    var dict = new Dictionary<int, int>();\\n    var responseList = new List<int>();\\n    for (int i = 0; i < nums.Length; i++)\\n    {\\n        var innerArray = nums[i];\\n\\n        foreach (var element in innerArray)\\n        {\\n            if(!dict.ContainsKey(element))\\n                dict.Add(element, 1);\\n            else\\n            {\\n                var value = dict[element];\\n                dict[element] = value + 1;\\n            }\\n        }\\n        \\n    }\\n    \\n    var values = dict.Where(a => a.Value == nums.Length);\\n\\n    foreach (var value in values)\\n    {\\n        responseList.Add(value.Key);\\n    }\\n\\n    return responseList.OrderBy(a => a).ToList(); \\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3991799,
                "title": "js-beats-96-hashset",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\nO(n * k + k * logk) -> O(k * (n + logk)), k - subArray length\\n\\n- Space complexity:\\nO(k), k - subArray length\\n\\n# Code\\n```\\n/**\\n * @param {number[][]} nums\\n * @return {number[]}\\n */\\nvar intersection = function(nums) {\\n    let cache = new Set(nums[0]);\\n    nums = nums.slice(1);\\n\\n    for (const subArr of nums) {\\n        cache = new Set(subArr.filter((el) => cache.has(el)));\\n    }\\n    \\n    return Array.from(cache).sort((a, b) => a - b);\\n};\\n\\n// Time complexity: O(n * k + k * logk) -> O(k * (n + logk)), k - subArray length\\n// Space complexity: O(k), k - subArray length\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\n/**\\n * @param {number[][]} nums\\n * @return {number[]}\\n */\\nvar intersection = function(nums) {\\n    let cache = new Set(nums[0]);\\n    nums = nums.slice(1);\\n\\n    for (const subArr of nums) {\\n        cache = new Set(subArr.filter((el) => cache.has(el)));\\n    }\\n    \\n    return Array.from(cache).sort((a, b) => a - b);\\n};\\n\\n// Time complexity: O(n * k + k * logk) -> O(k * (n + logk)), k - subArray length\\n// Space complexity: O(k), k - subArray length\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3987240,
                "title": "beats-easy-beginner-friendly-solution-simple-and-easy-java-solution",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\n    public List<Integer> intersection(int[][] nums) {\\n        List<Integer> l=new ArrayList();\\n        int n=nums.length;\\n        int[] c=new int[1001];\\n        for(int i=0;i<n;i++){\\n            for(int j=0;j<nums[i].length;j++){\\n                c[nums[i][j]]++;\\n            }\\n        }\\n        for(int i=0;i<1001;i++){\\n            if(c[i]==n){\\n                l.add(i);\\n            }\\n        }\\n        return l;\\n\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public List<Integer> intersection(int[][] nums) {\\n        List<Integer> l=new ArrayList();\\n        int n=nums.length;\\n        int[] c=new int[1001];\\n        for(int i=0;i<n;i++){\\n            for(int j=0;j<nums[i].length;j++){\\n                c[nums[i][j]]++;\\n            }\\n        }\\n        for(int i=0;i<1001;i++){\\n            if(c[i]==n){\\n                l.add(i);\\n            }\\n        }\\n        return l;\\n\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3982712,
                "title": "beats-75-simple-set-intersection-in-python",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution:\\n    def intersection(self, nums: List[List[int]]) -> List[int]:\\n        listx=[]\\n        set1  = set(nums[0])\\n        for i in nums :\\n            listx.append(set(i))\\n        size =  len(listx)\\n        u = sorted(set.intersection(*listx))\\n        return u  \\n\\n            \\n            \\n\\n\\n\\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def intersection(self, nums: List[List[int]]) -> List[int]:\\n        listx=[]\\n        set1  = set(nums[0])\\n        for i in nums :\\n            listx.append(set(i))\\n        size =  len(listx)\\n        u = sorted(set.intersection(*listx))\\n        return u  \\n\\n            \\n            \\n\\n\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3980483,
                "title": "as-simple-as-it-gets",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nFirst step would be to simply count occurence of each number within grid. Since each subarray contains distinct numbers, it tells  us intersection will contain number which occurred exactly `len(nums)` times.\\n\\nP.S. Alternatively, one could use map instead of `[1001]int{}` to store number frequencies, but we can use given constraints to our advantage and make space requirements a fixed size. \\n\\n![image.png](https://assets.leetcode.com/users/images/4dce4c92-f98e-4e8a-b821-a4d74dd8adc1_1693396902.2433279.png)\\n\\n\\n# Code\\n```\\nfunc intersection(nums [][]int) []int {\\n   \\tcounts := [1001]int{}\\n\\tfor i := 0; i < len(nums); i++ {\\n\\t\\tfor j := 0; j < len(nums[i]); j++ {\\n\\t\\t\\tcounts[nums[i][j]]++\\n\\t\\t}\\n\\t}\\n\\n\\tans := []int{}\\n\\tfor i := 0; i < len(counts); i++ {\\n\\t\\tif counts[i] == len(nums) {\\n\\t\\t\\tans = append(ans, i)\\n\\t\\t}\\n\\t}\\n\\n\\treturn ans\\n}\\n```",
                "solutionTags": [
                    "Go"
                ],
                "code": "```\\nfunc intersection(nums [][]int) []int {\\n   \\tcounts := [1001]int{}\\n\\tfor i := 0; i < len(nums); i++ {\\n\\t\\tfor j := 0; j < len(nums[i]); j++ {\\n\\t\\t\\tcounts[nums[i][j]]++\\n\\t\\t}\\n\\t}\\n\\n\\tans := []int{}\\n\\tfor i := 0; i < len(counts); i++ {\\n\\t\\tif counts[i] == len(nums) {\\n\\t\\t\\tans = append(ans, i)\\n\\t\\t}\\n\\t}\\n\\n\\treturn ans\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3980084,
                "title": "nice-and-elegant-solution-in-java-beats-100-rt-and-98-memory",
                "content": "```\\nclass Solution {\\n    public List<Integer> intersection(int[][] nums) {\\n        int max = Integer.MIN_VALUE;\\n        int[] arr = new int[1001];\\n        for (int[] i : nums) {\\n            for (int j : i) {\\n                arr[j]++;\\n                max = Math.max(max, j);\\n            }\\n        }\\n        List<Integer> output = new ArrayList<>();\\n        for (int i = 1; i < max + 1; i++) {\\n            if (arr[i] == nums.length) {\\n                output.add(i);\\n            }\\n        }\\n        return output;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Array",
                    "Counting"
                ],
                "code": "```\\nclass Solution {\\n    public List<Integer> intersection(int[][] nums) {\\n        int max = Integer.MIN_VALUE;\\n        int[] arr = new int[1001];\\n        for (int[] i : nums) {\\n            for (int j : i) {\\n                arr[j]++;\\n                max = Math.max(max, j);\\n            }\\n        }\\n        List<Integer> output = new ArrayList<>();\\n        for (int i = 1; i < max + 1; i++) {\\n            if (arr[i] == nums.length) {\\n                output.add(i);\\n            }\\n        }\\n        return output;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3978734,
                "title": "c-ordered-hash-map-solution",
                "content": "\\n# Code\\n```\\nclass Solution {\\npublic:\\n    vector<int> intersection(vector<vector<int>>& nums) {\\n\\n      map<int,int> hash;\\n      for (int i = 0; i < nums.size(); i++){\\n        for(int j = 0; j < nums[i].size(); j++){\\n          hash[nums[i][j]]++;\\n        }\\n      }\\n      vector<int> ans;\\n\\n      for (auto i : hash){\\n        if(i.second == nums.size()){\\n          ans.push_back(i.first);\\n        }\\n      }\\n\\n      return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<int> intersection(vector<vector<int>>& nums) {\\n\\n      map<int,int> hash;\\n      for (int i = 0; i < nums.size(); i++){\\n        for(int j = 0; j < nums[i].size(); j++){\\n          hash[nums[i][j]]++;\\n        }\\n      }\\n      vector<int> ans;\\n\\n      for (auto i : hash){\\n        if(i.second == nums.size()){\\n          ans.push_back(i.first);\\n        }\\n      }\\n\\n      return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3978327,
                "title": "java-solution-with-hashmap",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\n    public List<Integer> intersection(int[][] nums) {\\n        HashMap<Integer,Integer> numHash = new HashMap<Integer,Integer>();\\n        ArrayList<Integer> arrayList = new ArrayList<>();\\n        for(int i =0; i<nums.length;i++){\\n            int[] subList = nums[i];\\n            if(i == (nums.length-1)){\\n            for(int num:subList){\\n             int count = numHash.getOrDefault(num,0);\\n                if(i == count){\\n                    arrayList.add(num);\\n                }\\n            }  \\n            }\\n            for(int num:subList){\\n                int count = numHash.getOrDefault(num,0);\\n                numHash.put(num,count+1);\\n            }\\n        }\\n             arrayList.sort(Integer::compareTo);\\n             return arrayList;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public List<Integer> intersection(int[][] nums) {\\n        HashMap<Integer,Integer> numHash = new HashMap<Integer,Integer>();\\n        ArrayList<Integer> arrayList = new ArrayList<>();\\n        for(int i =0; i<nums.length;i++){\\n            int[] subList = nums[i];\\n            if(i == (nums.length-1)){\\n            for(int num:subList){\\n             int count = numHash.getOrDefault(num,0);\\n                if(i == count){\\n                    arrayList.add(num);\\n                }\\n            }  \\n            }\\n            for(int num:subList){\\n                int count = numHash.getOrDefault(num,0);\\n                numHash.put(num,count+1);\\n            }\\n        }\\n             arrayList.sort(Integer::compareTo);\\n             return arrayList;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3975748,
                "title": "c-simple-set-approach",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    set<int>common(set<int>&st1,set<int>&st2)\\n      {\\n        set<int>temp;\\n          for(auto it:st1)\\n            {\\n              if(st2.find(it)!=st2.end())\\n                {\\n                    temp.insert(it);\\n                }\\n            }\\n            return temp;\\n            \\n      }\\n    vector<int> intersection(vector<vector<int>>& nums) {\\n        set<int>st;\\n        for(int i=0;i<nums[0].size();i++)\\n          st.insert(nums[0][i]);\\n          for(int i=1;i<nums.size();i++)\\n            {\\n                set<int>temp;\\n              for(int j=0;j<nums[i].size();j++)\\n                {\\n                    temp.insert(nums[i][j]);\\n                }\\n                st=common(st,temp);\\n            }\\n            vector<int>v(st.begin(),st.end());\\n            return v;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    set<int>common(set<int>&st1,set<int>&st2)\\n      {\\n        set<int>temp;\\n          for(auto it:st1)\\n            {\\n              if(st2.find(it)!=st2.end())\\n                {\\n                    temp.insert(it);\\n                }\\n            }\\n            return temp;\\n            \\n      }\\n    vector<int> intersection(vector<vector<int>>& nums) {\\n        set<int>st;\\n        for(int i=0;i<nums[0].size();i++)\\n          st.insert(nums[0][i]);\\n          for(int i=1;i<nums.size();i++)\\n            {\\n                set<int>temp;\\n              for(int j=0;j<nums[i].size();j++)\\n                {\\n                    temp.insert(nums[i][j]);\\n                }\\n                st=common(st,temp);\\n            }\\n            vector<int>v(st.begin(),st.end());\\n            return v;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3969736,
                "title": "best-sollution-in-java",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\n    public List<Integer> intersection(int[][] nums) {\\n     ArrayList<Integer>list = new ArrayList<>();\\n    \\n     for(int i:nums[0]){\\n         list.add(i);\\n     }   \\n     \\n    for(int i=1;i<nums.length;i++){\\n        ArrayList<Integer>list1 = new ArrayList<>();\\n        for(int j=0;j<nums[i].length;j++){\\n            if(list.contains(nums[i][j])){\\n                list1.add(nums[i][j]);\\n            }\\n        }\\n        list = list1;\\n    }     \\n    Collections.sort(list);\\n     return list;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public List<Integer> intersection(int[][] nums) {\\n     ArrayList<Integer>list = new ArrayList<>();\\n    \\n     for(int i:nums[0]){\\n         list.add(i);\\n     }   \\n     \\n    for(int i=1;i<nums.length;i++){\\n        ArrayList<Integer>list1 = new ArrayList<>();\\n        for(int j=0;j<nums[i].length;j++){\\n            if(list.contains(nums[i][j])){\\n                list1.add(nums[i][j]);\\n            }\\n        }\\n        list = list1;\\n    }     \\n    Collections.sort(list);\\n     return list;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3968272,
                "title": "easy-cpp-solution-using-map-beginner-friendly",
                "content": "\\n# Code\\n```\\nclass Solution {\\npublic:\\n    vector<int> intersection(vector<vector<int>>& nums) {\\n        int c = nums.size();\\n        map<int, int> mp;\\n        for(int i=0; i<nums.size(); i++){\\n            for(int j=0; j<nums[i].size(); j++)\\n                mp[nums[i][j]]++;\\n        }\\n        vector<int> ans;\\n        for(auto i : mp){\\n            if(i.second == c) ans.push_back(i.first);\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<int> intersection(vector<vector<int>>& nums) {\\n        int c = nums.size();\\n        map<int, int> mp;\\n        for(int i=0; i<nums.size(); i++){\\n            for(int j=0; j<nums[i].size(); j++)\\n                mp[nums[i][j]]++;\\n        }\\n        vector<int> ans;\\n        for(auto i : mp){\\n            if(i.second == c) ans.push_back(i.first);\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3964478,
                "title": "ruby-recursive-65ms",
                "content": "```\\ndef intersection(nums)\\n  return nums.flatten.sort if nums.size == 1\\n  nums[1] = nums[0].intersection(nums[1]); nums.shift\\n  intersection(nums)\\nend\\n```",
                "solutionTags": [
                    "Ruby"
                ],
                "code": "```\\ndef intersection(nums)\\n  return nums.flatten.sort if nums.size == 1\\n  nums[1] = nums[0].intersection(nums[1]); nums.shift\\n  intersection(nums)\\nend\\n```",
                "codeTag": "Python3"
            },
            {
                "id": 3963834,
                "title": "easiest-solution-for-beginners-in-c",
                "content": "# Intuition\\n\\nTo find the intersection of multiple arrays, we can use a frequency map to count the occurrences of each element. We iterate through each array in the input vector and for each element, we increment its count in the frequency map. After that, we iterate through the frequency map and add the elements with a count equal to the number of arrays to the result vector.\\n\\n# Approach\\n\\n1. Create a map called `freq` to store the frequency of each element.\\n2. Initialize an integer variable `n` to store the number of arrays in the input.\\n3. Iterate through each array in the input vector.\\n    - For each element in the array, increment its count in the `freq` map.\\n4. Create an empty vector called `res` to store the intersection elements.\\n5. Iterate through the `freq` map.\\n    - If the count of an element is equal to `n`, add the element to the `res` vector.\\n6. Return the `res` vector as the result.\\n\\n# Complexity Analysis\\n- Time complexity: The time complexity for this approach is O(m * k), where m is the number of arrays and k is the average length of the arrays. This is because we need to iterate through each element of each array to calculate the frequency map.\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: The space complexity is O(k), where k is the number of unique elements in all the arrays. This is because the frequency map will contain at most k elements.\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    vector<int> intersection(vector<vector<int>>& nums) {\\n        map<int, int> freq;\\n        int n = nums.size();\\n\\n        vector<int> res;\\n\\n        for (auto &arr : nums) {\\n            for (int &num : arr) {\\n                freq[num]++;\\n            }\\n        }\\n\\n        for (const auto &e : freq) {\\n            if (e.second == n) {\\n                res.push_back(e.first);\\n            }\\n        }\\n        return res;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Ordered Map"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<int> intersection(vector<vector<int>>& nums) {\\n        map<int, int> freq;\\n        int n = nums.size();\\n\\n        vector<int> res;\\n\\n        for (auto &arr : nums) {\\n            for (int &num : arr) {\\n                freq[num]++;\\n            }\\n        }\\n\\n        for (const auto &e : freq) {\\n            if (e.second == n) {\\n                res.push_back(e.first);\\n            }\\n        }\\n        return res;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3958363,
                "title": "c-easyy-approach-must-try-upvote",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    vector<int> intersection(vector<vector<int>>& nums) \\n    {\\n        int n=nums.size();\\n        unordered_map<int,int>mp;\\n        for(int i=0;i<n;i++)\\n        {\\n            for(auto x :nums[i])\\n            {\\n                mp[x]++;\\n            }\\n        }\\n        vector<int>ans;\\n        for(auto i : mp)\\n        {\\n            if(i.second==n)\\n            ans.push_back(i.first);\\n        }\\n        sort(ans.begin(),ans.end());\\n        return ans;\\n\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<int> intersection(vector<vector<int>>& nums) \\n    {\\n        int n=nums.size();\\n        unordered_map<int,int>mp;\\n        for(int i=0;i<n;i++)\\n        {\\n            for(auto x :nums[i])\\n            {\\n                mp[x]++;\\n            }\\n        }\\n        vector<int>ans;\\n        for(auto i : mp)\\n        {\\n            if(i.second==n)\\n            ans.push_back(i.first);\\n        }\\n        sort(ans.begin(),ans.end());\\n        return ans;\\n\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3955365,
                "title": "java-very-easy-solution-hash-table-sorting-100-beats",
                "content": "\\n\\n# Complexity\\n- Time complexity:O(m*n)+O(mlogm)\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: Hash Table of size 1001\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\n    public List<Integer> intersection(int[][] nums) {\\n        List<Integer> res = new ArrayList<>();\\n        int[] hash = new int[1001];\\n        for(int index=0; index<nums.length; index++) \\n        \\tfor(int n : nums[index]) \\n        \\t\\tif(index==nums.length-1) {\\n        \\t\\t\\thash[n]++;\\n        \\t\\t\\tif(hash[n]==nums.length)\\n        \\t\\t\\t\\tres.add(n);\\n        \\t\\t}\\n        \\t\\telse \\n        \\t\\t    hash[n]++;\\t\\n\\t\\t\\t\\tCollections.sort(res);\\t\\t\\t\\t\\n        return res;\\n    }\\n}\\n```\\n\\n![PLEASE_UPVOTE.png](https://assets.leetcode.com/users/images/3236fe42-085b-4efa-9c65-0e6ebb5c3cd1_1692897681.254539.jpeg)\\n",
                "solutionTags": [
                    "Java",
                    "Array",
                    "Hash Table",
                    "Sort",
                    "Sorting",
                    "Counting"
                ],
                "code": "```\\nclass Solution {\\n    public List<Integer> intersection(int[][] nums) {\\n        List<Integer> res = new ArrayList<>();\\n        int[] hash = new int[1001];\\n        for(int index=0; index<nums.length; index++) \\n        \\tfor(int n : nums[index]) \\n        \\t\\tif(index==nums.length-1) {\\n        \\t\\t\\thash[n]++;\\n        \\t\\t\\tif(hash[n]==nums.length)\\n        \\t\\t\\t\\tres.add(n);\\n        \\t\\t}\\n        \\t\\telse \\n        \\t\\t    hash[n]++;\\t\\n\\t\\t\\t\\tCollections.sort(res);\\t\\t\\t\\t\\n        return res;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3946943,
                "title": "easy-to-understand-python3",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution:\\n    def intersection(self, nums: List[List[int]]) -> List[int]:\\n        common = Counter(nums[0])\\n\\n        for i in nums[1:]:\\n            common &= Counter(i)\\n\\n        output = sorted((list(common.keys())))\\n\\n        return output\\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def intersection(self, nums: List[List[int]]) -> List[int]:\\n        common = Counter(nums[0])\\n\\n        for i in nums[1:]:\\n            common &= Counter(i)\\n\\n        output = sorted((list(common.keys())))\\n\\n        return output\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3943507,
                "title": "common-of-the-given-2d-array",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:O(n2)\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:O(n2)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\n    public List<Integer> intersection(int[][] nums) {\\n         HashSet<Integer> common= new HashSet<>();\\n\\n        for(int i=0;i<nums[0].length;i++){\\n            common.add(nums[0][i]);\\n        }\\n        //now add other rows and retain only those in common if it present in current set;\\n\\n        for(int i=1;i<nums.length;i++){\\n            HashSet<Integer> current= new HashSet<>();\\n            for(int j=0;j<nums[i].length;j++){\\n                if(common.contains(nums[i][j]))\\n                        current.add(nums[i][j]);\\n            }\\n            common.retainAll(current);\\n        }\\n\\n        List<Integer> ls= new ArrayList<>(common);\\n        Collections.sort(ls);\\n\\n        return ls;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Array",
                    "Hash Table",
                    "Counting"
                ],
                "code": "```\\nclass Solution {\\n    public List<Integer> intersection(int[][] nums) {\\n         HashSet<Integer> common= new HashSet<>();\\n\\n        for(int i=0;i<nums[0].length;i++){\\n            common.add(nums[0][i]);\\n        }\\n        //now add other rows and retain only those in common if it present in current set;\\n\\n        for(int i=1;i<nums.length;i++){\\n            HashSet<Integer> current= new HashSet<>();\\n            for(int j=0;j<nums[i].length;j++){\\n                if(common.contains(nums[i][j]))\\n                        current.add(nums[i][j]);\\n            }\\n            common.retainAll(current);\\n        }\\n\\n        List<Integer> ls= new ArrayList<>(common);\\n        Collections.sort(ls);\\n\\n        return ls;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3943506,
                "title": "common-of-the-given-2d-array",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:O(n2)\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:O(n2)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\n    public List<Integer> intersection(int[][] nums) {\\n         HashSet<Integer> common= new HashSet<>();\\n\\n        for(int i=0;i<nums[0].length;i++){\\n            common.add(nums[0][i]);\\n        }\\n        //now add other rows and retain only those in common if it present in current set;\\n\\n        for(int i=1;i<nums.length;i++){\\n            HashSet<Integer> current= new HashSet<>();\\n            for(int j=0;j<nums[i].length;j++){\\n                if(common.contains(nums[i][j]))\\n                        current.add(nums[i][j]);\\n            }\\n            common.retainAll(current);\\n        }\\n\\n        List<Integer> ls= new ArrayList<>(common);\\n        Collections.sort(ls);\\n\\n        return ls;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Array",
                    "Hash Table",
                    "Counting"
                ],
                "code": "```\\nclass Solution {\\n    public List<Integer> intersection(int[][] nums) {\\n         HashSet<Integer> common= new HashSet<>();\\n\\n        for(int i=0;i<nums[0].length;i++){\\n            common.add(nums[0][i]);\\n        }\\n        //now add other rows and retain only those in common if it present in current set;\\n\\n        for(int i=1;i<nums.length;i++){\\n            HashSet<Integer> current= new HashSet<>();\\n            for(int j=0;j<nums[i].length;j++){\\n                if(common.contains(nums[i][j]))\\n                        current.add(nums[i][j]);\\n            }\\n            common.retainAll(current);\\n        }\\n\\n        List<Integer> ls= new ArrayList<>(common);\\n        Collections.sort(ls);\\n\\n        return ls;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3941323,
                "title": "python-simple-solution-weekly-contest-290-problems-intersection-of-multiple-arrays",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nThe problem is to find the intersection of multiple lists of integers. The solution intends to identify the common elements that appear in all the given lists. By iteratively checking the presence of each element in all lists, the algorithm is able to identify elements that belong to the intersection.\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n1. Initialize a variable dummy with the first list in the nums input. This will serve as a reference list for comparison.\\n3. Initialize a variable found to keep track of whether an element from dummy is found in all other lists.\\n4. Initialize an empty list arr to store the intersection elements.\\n5. Iterate through each element i in the dummy list:\\n- Set found to 1, indicating that the current element is initially assumed to be present in all lists.\\n- Iterate through the remaining lists nums[1:]:\\n- If the element i is not found in the current list j, set found to 0 and break out of the inner loop.\\n- If found is still 1 after checking in all lists, it means the element i is present in all lists. Add it to the arr.\\n5. Sort the arr in ascending order.\\n6. Return the arr as the final result.\\n\\n---\\n\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\nO(m*n)\\nBeats 88% of python3 Users\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\nO(m)\\nBeats 91 % of python3 users\\n\\n---\\n\\n\\n# Code\\n```\\nclass Solution:\\n    def intersection(self, nums: List[List[int]]) -> List[int]:\\n        dummy = nums[0]\\n        found = 0\\n        arr = []\\n        for i in dummy:\\n            found = 1\\n            for j in nums[1:]:\\n                if i not in j:\\n                    found = 0\\n                    break\\n            if found:\\n                arr.append(i)\\n        arr = sorted(arr)\\n        return arr\\n            \\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def intersection(self, nums: List[List[int]]) -> List[int]:\\n        dummy = nums[0]\\n        found = 0\\n        arr = []\\n        for i in dummy:\\n            found = 1\\n            for j in nums[1:]:\\n                if i not in j:\\n                    found = 0\\n                    break\\n            if found:\\n                arr.append(i)\\n        arr = sorted(arr)\\n        return arr\\n            \\n```",
                "codeTag": "Java"
            },
            {
                "id": 3929814,
                "title": "dart-solution-using-set",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\n  List<int> intersection(List<List<int>> nums) {\\n      List<int> result = nums[0];\\n      for(var value in nums){\\n        result = (value.toSet().intersection(result.toSet()).toList());\\n      }\\n      result.sort();\\n      return result;\\n  }\\n}\\n```",
                "solutionTags": [
                    "Dart"
                ],
                "code": "```\\nclass Solution {\\n  List<int> intersection(List<List<int>> nums) {\\n      List<int> result = nums[0];\\n      for(var value in nums){\\n        result = (value.toSet().intersection(result.toSet()).toList());\\n      }\\n      result.sort();\\n      return result;\\n  }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3926017,
                "title": "easiest-beginner-friendly-code",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    vector<int> intersection(vector<vector<int>>& nums) {\\n        vector<int> answer;\\n        unordered_map<int,int> mp;\\n        int m = nums.size();\\n        for(int i = 0; i < m; i++){\\n            for(int j = 0; j< nums[i].size();j++){\\n                mp[nums[i][j]]++;\\n            }\\n        }\\n      for (auto& entry : mp) {\\n            if (entry.second == m) {\\n                answer.push_back(entry.first);\\n            }\\n        }\\n        sort(answer.begin(),answer.end());\\n        return answer;\\n    }\\n};\\n\\n\\n\\n\\n\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<int> intersection(vector<vector<int>>& nums) {\\n        vector<int> answer;\\n        unordered_map<int,int> mp;\\n        int m = nums.size();\\n        for(int i = 0; i < m; i++){\\n            for(int j = 0; j< nums[i].size();j++){\\n                mp[nums[i][j]]++;\\n            }\\n        }\\n      for (auto& entry : mp) {\\n            if (entry.second == m) {\\n                answer.push_back(entry.first);\\n            }\\n        }\\n        sort(answer.begin(),answer.end());\\n        return answer;\\n    }\\n};\\n\\n\\n\\n\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3923838,
                "title": "easy-c",
                "content": "\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    vector<int> intersection(vector<vector<int>>& nums) {\\n        unordered_map<int ,int>mp;\\n        vector<int> v;\\n        for(int i =0 ; i<nums.size(); i++){\\n            for(int j=0; j<nums[i].size();j++){\\n                mp[nums[i][j]]++;\\n            }\\n        }\\n        for(auto i : mp){\\n            if(i.second==nums.size())v.push_back(i.first);\\n        }\\n        sort(v.begin(),v.end());\\n        return v;\\n        \\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<int> intersection(vector<vector<int>>& nums) {\\n        unordered_map<int ,int>mp;\\n        vector<int> v;\\n        for(int i =0 ; i<nums.size(); i++){\\n            for(int j=0; j<nums[i].size();j++){\\n                mp[nums[i][j]]++;\\n            }\\n        }\\n        for(auto i : mp){\\n            if(i.second==nums.size())v.push_back(i.first);\\n        }\\n        sort(v.begin(),v.end());\\n        return v;\\n        \\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3916284,
                "title": "easy-simple-solution-c-tc-o-n-2-sc-o-n",
                "content": "# Intuition : Insert every element of the given 2D array in a map. Now the map will have every element of given 2D array mapped with their counts(number of times it appears in the 2D array). search for those pairs in map whose value (count) is equal to sizeof 2D vector and push them to the answer vector. Return the vector.\\n\\n# Approach : Hash-Table (Mapping)\\n\\n# Complexity\\n- Time complexity : O(N^2)\\n- Space complexity : O(N)\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    vector<int> intersection(vector<vector<int>>& nums) {\\n        int n = nums.size();\\n        map<int, int> numsCount;\\n        vector<int> answer;\\n        for(auto v : nums) {\\n            for(int x : v)\\n                numsCount[x]++;\\n        }\\n        for(auto entry : numsCount) {\\n            if(entry.second == n)\\n                answer.push_back(entry.first);\\n        }\\n        return answer;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Array",
                    "Hash Table",
                    "Counting"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<int> intersection(vector<vector<int>>& nums) {\\n        int n = nums.size();\\n        map<int, int> numsCount;\\n        vector<int> answer;\\n        for(auto v : nums) {\\n            for(int x : v)\\n                numsCount[x]++;\\n        }\\n        for(auto entry : numsCount) {\\n            if(entry.second == n)\\n                answer.push_back(entry.first);\\n        }\\n        return answer;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3915227,
                "title": "python3-one-liner-beats-99-36",
                "content": "# Code\\n```\\nclass Solution:\\n    def intersection(self, nums: List[List[int]]) -> List[int]:\\n        return sorted(reduce(operator.iand, (set(num) for num in nums)))\\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def intersection(self, nums: List[List[int]]) -> List[int]:\\n        return sorted(reduce(operator.iand, (set(num) for num in nums)))\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3908852,
                "title": "2248-intersection-of-multiple-arrays",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\n    public List<Integer> intersection(int[][] nums) {\\n        \\n    if(nums == null || nums.length == 0) return new ArrayList<>();\\n\\n    HashMap<Integer, Integer> h = new HashMap<>();\\n    List<Integer> ans = new ArrayList<>();\\n    int row = nums.length;\\n    int index = 0;\\n    \\n    for(int[] i : nums){\\n        for(int j= 0 ; j < i.length ; j++){\\n            h.put(nums[index][j],h.getOrDefault(nums[index][j],0)+1);\\n        }\\n        index++;\\n    }\\n\\n    for (int key : h.keySet()) {\\n            if (h.get(key) == row) {\\n                ans.add(key);\\n            }\\n    }\\n    Collections.sort(ans);\\n\\n    return ans;\\n   \\n    \\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Array"
                ],
                "code": "```\\nclass Solution {\\n    public List<Integer> intersection(int[][] nums) {\\n        \\n    if(nums == null || nums.length == 0) return new ArrayList<>();\\n\\n    HashMap<Integer, Integer> h = new HashMap<>();\\n    List<Integer> ans = new ArrayList<>();\\n    int row = nums.length;\\n    int index = 0;\\n    \\n    for(int[] i : nums){\\n        for(int j= 0 ; j < i.length ; j++){\\n            h.put(nums[index][j],h.getOrDefault(nums[index][j],0)+1);\\n        }\\n        index++;\\n    }\\n\\n    for (int key : h.keySet()) {\\n            if (h.get(key) == row) {\\n                ans.add(key);\\n            }\\n    }\\n    Collections.sort(ans);\\n\\n    return ans;\\n   \\n    \\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3907774,
                "title": "runtime-details-93ms-memory-details-16-62mb",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution:\\n    def intersection(self, nums: List[List[int]]) -> List[int]:\\n        nums0 = nums[0]\\n        result = []\\n        for n in nums0:\\n            flag = [True if n in arr else False for arr in nums ]\\n            if all(flag):\\n                result.append(n)\\n        return sorted(result)\\n\\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def intersection(self, nums: List[List[int]]) -> List[int]:\\n        nums0 = nums[0]\\n        result = []\\n        for n in nums0:\\n            flag = [True if n in arr else False for arr in nums ]\\n            if all(flag):\\n                result.append(n)\\n        return sorted(result)\\n\\n```",
                "codeTag": "Java"
            }
        ],
        "discussions": [
            {
                "id": 1775956,
                "content": [
                    {
                        "username": "vivekpalve9067",
                        "content": "1.Create hashmap of Integer Type.\\n2.Push all the element in the hashmap in the key value pair.\\n3.create one arraylist.\\n4.traverse through hashmap.\\n5.Add all the element in the arraylist whose count is equal to the length of given array.\\n6.return the arraylist."
                    },
                    {
                        "username": "changemyname",
                        "content": "you forgot the sorting of the array list. "
                    },
                    {
                        "username": "sangameshMath",
                        "content": "I understood this problem differently and increased the difficulty level of the problem myself. If you solved the problem and ready to accept challenges. This is for you. \\nFor the same problem, what if you are asked to print a possibility where one/more elements are in ascending order in each array of nums. Print such elements. If multiple such answers exist, print any one answer. Can someone code it up?"
                    },
                    {
                        "username": "ikhela-04KK",
                        "content": "I provided my answer and it is correct but I am not validated because my answers are sorted. for example ouput is [4,3] and expect is  [3,4]\\n"
                    },
                    {
                        "username": "AmanSinghRajawat",
                        "content": "sort the list.  ``` Collections.sort(list); ```\\nnow return list;"
                    },
                    {
                        "username": "minhle0105",
                        "content": "I am having one test case failed for this test (case 151/151) but I don't understand this test case. It does not show anything for nums, and in the constraints it says 1 <= nums.length <= 1000 so I assume the length can't be 0. Can anyone help me describe this failing test please?"
                    },
                    {
                        "username": "Subham_Singh-1",
                        "content": "[@bhuppidhamii](/bhuppidhamii)  Time Limit is Exceeded, the same happened with me in on problem and check in the submissions\\n"
                    },
                    {
                        "username": "bhuppidhamii",
                        "content": "https://leetcode.com/problems/intersection-of-multiple-arrays/submissions/966795626/?envType=list&envId=omoz4xxt"
                    },
                    {
                        "username": "Arsh_Arsh",
                        "content": "Count the frequency of all elements , if it\\'s equal to length of arr than ,these are the element"
                    }
                ]
            },
            {
                "id": 1929171,
                "content": [
                    {
                        "username": "vivekpalve9067",
                        "content": "1.Create hashmap of Integer Type.\\n2.Push all the element in the hashmap in the key value pair.\\n3.create one arraylist.\\n4.traverse through hashmap.\\n5.Add all the element in the arraylist whose count is equal to the length of given array.\\n6.return the arraylist."
                    },
                    {
                        "username": "changemyname",
                        "content": "you forgot the sorting of the array list. "
                    },
                    {
                        "username": "sangameshMath",
                        "content": "I understood this problem differently and increased the difficulty level of the problem myself. If you solved the problem and ready to accept challenges. This is for you. \\nFor the same problem, what if you are asked to print a possibility where one/more elements are in ascending order in each array of nums. Print such elements. If multiple such answers exist, print any one answer. Can someone code it up?"
                    },
                    {
                        "username": "ikhela-04KK",
                        "content": "I provided my answer and it is correct but I am not validated because my answers are sorted. for example ouput is [4,3] and expect is  [3,4]\\n"
                    },
                    {
                        "username": "AmanSinghRajawat",
                        "content": "sort the list.  ``` Collections.sort(list); ```\\nnow return list;"
                    },
                    {
                        "username": "minhle0105",
                        "content": "I am having one test case failed for this test (case 151/151) but I don't understand this test case. It does not show anything for nums, and in the constraints it says 1 <= nums.length <= 1000 so I assume the length can't be 0. Can anyone help me describe this failing test please?"
                    },
                    {
                        "username": "Subham_Singh-1",
                        "content": "[@bhuppidhamii](/bhuppidhamii)  Time Limit is Exceeded, the same happened with me in on problem and check in the submissions\\n"
                    },
                    {
                        "username": "bhuppidhamii",
                        "content": "https://leetcode.com/problems/intersection-of-multiple-arrays/submissions/966795626/?envType=list&envId=omoz4xxt"
                    },
                    {
                        "username": "Arsh_Arsh",
                        "content": "Count the frequency of all elements , if it\\'s equal to length of arr than ,these are the element"
                    }
                ]
            },
            {
                "id": 1881320,
                "content": [
                    {
                        "username": "vivekpalve9067",
                        "content": "1.Create hashmap of Integer Type.\\n2.Push all the element in the hashmap in the key value pair.\\n3.create one arraylist.\\n4.traverse through hashmap.\\n5.Add all the element in the arraylist whose count is equal to the length of given array.\\n6.return the arraylist."
                    },
                    {
                        "username": "changemyname",
                        "content": "you forgot the sorting of the array list. "
                    },
                    {
                        "username": "sangameshMath",
                        "content": "I understood this problem differently and increased the difficulty level of the problem myself. If you solved the problem and ready to accept challenges. This is for you. \\nFor the same problem, what if you are asked to print a possibility where one/more elements are in ascending order in each array of nums. Print such elements. If multiple such answers exist, print any one answer. Can someone code it up?"
                    },
                    {
                        "username": "ikhela-04KK",
                        "content": "I provided my answer and it is correct but I am not validated because my answers are sorted. for example ouput is [4,3] and expect is  [3,4]\\n"
                    },
                    {
                        "username": "AmanSinghRajawat",
                        "content": "sort the list.  ``` Collections.sort(list); ```\\nnow return list;"
                    },
                    {
                        "username": "minhle0105",
                        "content": "I am having one test case failed for this test (case 151/151) but I don't understand this test case. It does not show anything for nums, and in the constraints it says 1 <= nums.length <= 1000 so I assume the length can't be 0. Can anyone help me describe this failing test please?"
                    },
                    {
                        "username": "Subham_Singh-1",
                        "content": "[@bhuppidhamii](/bhuppidhamii)  Time Limit is Exceeded, the same happened with me in on problem and check in the submissions\\n"
                    },
                    {
                        "username": "bhuppidhamii",
                        "content": "https://leetcode.com/problems/intersection-of-multiple-arrays/submissions/966795626/?envType=list&envId=omoz4xxt"
                    },
                    {
                        "username": "Arsh_Arsh",
                        "content": "Count the frequency of all elements , if it\\'s equal to length of arr than ,these are the element"
                    }
                ]
            },
            {
                "id": 1872150,
                "content": [
                    {
                        "username": "vivekpalve9067",
                        "content": "1.Create hashmap of Integer Type.\\n2.Push all the element in the hashmap in the key value pair.\\n3.create one arraylist.\\n4.traverse through hashmap.\\n5.Add all the element in the arraylist whose count is equal to the length of given array.\\n6.return the arraylist."
                    },
                    {
                        "username": "changemyname",
                        "content": "you forgot the sorting of the array list. "
                    },
                    {
                        "username": "sangameshMath",
                        "content": "I understood this problem differently and increased the difficulty level of the problem myself. If you solved the problem and ready to accept challenges. This is for you. \\nFor the same problem, what if you are asked to print a possibility where one/more elements are in ascending order in each array of nums. Print such elements. If multiple such answers exist, print any one answer. Can someone code it up?"
                    },
                    {
                        "username": "ikhela-04KK",
                        "content": "I provided my answer and it is correct but I am not validated because my answers are sorted. for example ouput is [4,3] and expect is  [3,4]\\n"
                    },
                    {
                        "username": "AmanSinghRajawat",
                        "content": "sort the list.  ``` Collections.sort(list); ```\\nnow return list;"
                    },
                    {
                        "username": "minhle0105",
                        "content": "I am having one test case failed for this test (case 151/151) but I don't understand this test case. It does not show anything for nums, and in the constraints it says 1 <= nums.length <= 1000 so I assume the length can't be 0. Can anyone help me describe this failing test please?"
                    },
                    {
                        "username": "Subham_Singh-1",
                        "content": "[@bhuppidhamii](/bhuppidhamii)  Time Limit is Exceeded, the same happened with me in on problem and check in the submissions\\n"
                    },
                    {
                        "username": "bhuppidhamii",
                        "content": "https://leetcode.com/problems/intersection-of-multiple-arrays/submissions/966795626/?envType=list&envId=omoz4xxt"
                    },
                    {
                        "username": "Arsh_Arsh",
                        "content": "Count the frequency of all elements , if it\\'s equal to length of arr than ,these are the element"
                    }
                ]
            },
            {
                "id": 1866075,
                "content": [
                    {
                        "username": "vivekpalve9067",
                        "content": "1.Create hashmap of Integer Type.\\n2.Push all the element in the hashmap in the key value pair.\\n3.create one arraylist.\\n4.traverse through hashmap.\\n5.Add all the element in the arraylist whose count is equal to the length of given array.\\n6.return the arraylist."
                    },
                    {
                        "username": "changemyname",
                        "content": "you forgot the sorting of the array list. "
                    },
                    {
                        "username": "sangameshMath",
                        "content": "I understood this problem differently and increased the difficulty level of the problem myself. If you solved the problem and ready to accept challenges. This is for you. \\nFor the same problem, what if you are asked to print a possibility where one/more elements are in ascending order in each array of nums. Print such elements. If multiple such answers exist, print any one answer. Can someone code it up?"
                    },
                    {
                        "username": "ikhela-04KK",
                        "content": "I provided my answer and it is correct but I am not validated because my answers are sorted. for example ouput is [4,3] and expect is  [3,4]\\n"
                    },
                    {
                        "username": "AmanSinghRajawat",
                        "content": "sort the list.  ``` Collections.sort(list); ```\\nnow return list;"
                    },
                    {
                        "username": "minhle0105",
                        "content": "I am having one test case failed for this test (case 151/151) but I don't understand this test case. It does not show anything for nums, and in the constraints it says 1 <= nums.length <= 1000 so I assume the length can't be 0. Can anyone help me describe this failing test please?"
                    },
                    {
                        "username": "Subham_Singh-1",
                        "content": "[@bhuppidhamii](/bhuppidhamii)  Time Limit is Exceeded, the same happened with me in on problem and check in the submissions\\n"
                    },
                    {
                        "username": "bhuppidhamii",
                        "content": "https://leetcode.com/problems/intersection-of-multiple-arrays/submissions/966795626/?envType=list&envId=omoz4xxt"
                    },
                    {
                        "username": "Arsh_Arsh",
                        "content": "Count the frequency of all elements , if it\\'s equal to length of arr than ,these are the element"
                    }
                ]
            }
        ]
    },
    {
        "title": "Number of Ways to Split Array",
        "question_content": "<p>You are given a <strong>0-indexed</strong> integer array <code>nums</code> of length <code>n</code>.</p>\n\n<p><code>nums</code> contains a <strong>valid split</strong> at index <code>i</code> if the following are true:</p>\n\n<ul>\n\t<li>The sum of the first <code>i + 1</code> elements is <strong>greater than or equal to</strong> the sum of the last <code>n - i - 1</code> elements.</li>\n\t<li>There is <strong>at least one</strong> element to the right of <code>i</code>. That is, <code>0 &lt;= i &lt; n - 1</code>.</li>\n</ul>\n\n<p>Return <em>the number of <strong>valid splits</strong> in</em> <code>nums</code>.</p>\n\n<p>&nbsp;</p>\n<p><strong class=\"example\">Example 1:</strong></p>\n\n<pre>\n<strong>Input:</strong> nums = [10,4,-8,7]\n<strong>Output:</strong> 2\n<strong>Explanation:</strong> \nThere are three ways of splitting nums into two non-empty parts:\n- Split nums at index 0. Then, the first part is [10], and its sum is 10. The second part is [4,-8,7], and its sum is 3. Since 10 &gt;= 3, i = 0 is a valid split.\n- Split nums at index 1. Then, the first part is [10,4], and its sum is 14. The second part is [-8,7], and its sum is -1. Since 14 &gt;= -1, i = 1 is a valid split.\n- Split nums at index 2. Then, the first part is [10,4,-8], and its sum is 6. The second part is [7], and its sum is 7. Since 6 &lt; 7, i = 2 is not a valid split.\nThus, the number of valid splits in nums is 2.\n</pre>\n\n<p><strong class=\"example\">Example 2:</strong></p>\n\n<pre>\n<strong>Input:</strong> nums = [2,3,1,0]\n<strong>Output:</strong> 2\n<strong>Explanation:</strong> \nThere are two valid splits in nums:\n- Split nums at index 1. Then, the first part is [2,3], and its sum is 5. The second part is [1,0], and its sum is 1. Since 5 &gt;= 1, i = 1 is a valid split. \n- Split nums at index 2. Then, the first part is [2,3,1], and its sum is 6. The second part is [0], and its sum is 0. Since 6 &gt;= 0, i = 2 is a valid split.\n</pre>\n\n<p>&nbsp;</p>\n<p><strong>Constraints:</strong></p>\n\n<ul>\n\t<li><code>2 &lt;= nums.length &lt;= 10<sup>5</sup></code></li>\n\t<li><code>-10<sup>5</sup> &lt;= nums[i] &lt;= 10<sup>5</sup></code></li>\n</ul>\n",
        "solutions": [
            {
                "id": 2038118,
                "title": "prefix-sum-o-1-space",
                "content": "```\\nclass Solution {\\npublic:\\n    int waysToSplitArray(vector<int>& nums) {\\n     \\n        long long sumFromBack(0), sumFromFront(0);\\n        for (auto& i : nums)     sumFromBack += i;\\n        \\n        int n(size(nums)), res(0);\\n        for (auto i=0; i<n-1; i++) {\\n            \\n            sumFromFront += nums[i]; // sum of the first i + 1 elements\\n            sumFromBack -= nums[i]; // sum of the last n - i - 1 elements.\\n            if (sumFromFront >= sumFromBack)  res++;\\n        }\\n        return res;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C",
                    "Prefix Sum"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int waysToSplitArray(vector<int>& nums) {\\n     \\n        long long sumFromBack(0), sumFromFront(0);\\n        for (auto& i : nums)     sumFromBack += i;\\n        \\n        int n(size(nums)), res(0);\\n        for (auto i=0; i<n-1; i++) {\\n            \\n            sumFromFront += nums[i]; // sum of the first i + 1 elements\\n            sumFromBack -= nums[i]; // sum of the last n - i - 1 elements.\\n            if (sumFromFront >= sumFromBack)  res++;\\n        }\\n        return res;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2038541,
                "title": "python-easily-explained-brute-force-to-optimized",
                "content": "Here, they are asking to **count such events**/occurances where:\\n* the array can be splitted into **two non-empty parts**, such that \\n* the sum of elements in first part **>=** sum of elements in second parts.\\n\\nA prefix sum array is an array that stores at ith index,  the sum of all elements encountered from 0th index upto the ith index (inclusive). How can this help?\\n* The prefix sum has a property that it `avoids recomputation of sum`. \\n* The sum upto element i can be obtained by `prefix_sum[i]`.\\n* The sum from i + 1 to last element of array can be obtained by `prefix_sum[n-1] - prefix_sum[i]`\\n\\nThe full code (***written during contest***) is given below:\\n```\\nclass Solution:\\n    def waysToSplitArray(self, nums: List[int]) -> int:\\n        prefix_sum = [nums[0]]\\n        n = len(nums)\\n        for i in range(1, n):\\n            prefix_sum.append(nums[i] + prefix_sum[-1]) \\n        \\n        count = 0\\n        for i in range(n-1):\\n            if prefix_sum[i] >= prefix_sum[n-1] - prefix_sum[i]:\\n                count += 1\\n        return count\\n```\\n\\n**Time and Space Complexity Analysis:**\\nWe iterate through each element of the array in a linear fashion. Hence, **time complexity = O(n)**.\\nAlso, we maintain a extra space of size \\'n\\' for prefix_sum array. Hence, **space complexity = O(n)**.\\n\\n***Can we do any better?***\\n* In terms of time: **NO**. We will need to traverse the array atleast once (at any cost, in any situation).\\n* In terms of space: **YES**. We actually do not need a complete prefix array.\\n\\nLet\\'s see how!\\n\\nWe just need to have two sum variables storing the sum of left part and right part.\\nInitially, the left part will contain the `first element` and right part will contain `sum of array - the first element`.\\nAs we increment the index, we take the current nums[i] value and add it to the left part and remove it from the right part.\\n\\nHence ***reducing the space complexity to O(1).***\\n\\nSimple and Sweet.\\n\\nThe full code (***space optimized***) is given below:\\n```\\nclass Solution:\\n    def waysToSplitArray(self, nums: List[int]) -> int:\\n        count = 0\\n        left_sum, right_sum = 0, sum(nums)\\n        for i in range(len(nums) - 1):\\n            left_sum += nums[i]\\n            right_sum -= nums[i]\\n            if left_sum >= right_sum:\\n                count += 1\\n        return count\\n```\\n\\nUpvote, if helpful.",
                "solutionTags": [
                    "Python"
                ],
                "code": "```\\nclass Solution:\\n    def waysToSplitArray(self, nums: List[int]) -> int:\\n        prefix_sum = [nums[0]]\\n        n = len(nums)\\n        for i in range(1, n):\\n            prefix_sum.append(nums[i] + prefix_sum[-1]) \\n        \\n        count = 0\\n        for i in range(n-1):\\n            if prefix_sum[i] >= prefix_sum[n-1] - prefix_sum[i]:\\n                count += 1\\n        return count\\n```\n```\\nclass Solution:\\n    def waysToSplitArray(self, nums: List[int]) -> int:\\n        count = 0\\n        left_sum, right_sum = 0, sum(nums)\\n        for i in range(len(nums) - 1):\\n            left_sum += nums[i]\\n            right_sum -= nums[i]\\n            if left_sum >= right_sum:\\n                count += 1\\n        return count\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2038567,
                "title": "prefix-sum",
                "content": "**Python 3**\\n```python\\nclass Solution:\\n    def waysToSplitArray(self, n: List[int]) -> int:\\n        n = list(accumulate(n))\\n        return sum(n[i] >= n[-1] - n[i] for i in range(len(n) - 1))\\n```\\n\\n**C++**\\nWe could use a prefix sum, but in C++ we would need to store it in another `long long` vector (because of overflow). So, we are using a running sum here for efficiency.\\n```cpp\\nint waysToSplitArray(vector<int>& n) {\\n    long long right = accumulate(begin(n), end(n), 0LL), left = 0, res = 0;\\n    for (int i = 0; i < n.size() - 1; ++i) {\\n        left += n[i];\\n        right -= n[i];\\n        res += left >= right;\\n    }\\n    return res;\\n}\\n```",
                "solutionTags": [
                    "Python3",
                    "C"
                ],
                "code": "```python\\nclass Solution:\\n    def waysToSplitArray(self, n: List[int]) -> int:\\n        n = list(accumulate(n))\\n        return sum(n[i] >= n[-1] - n[i] for i in range(len(n) - 1))\\n```\n```cpp\\nint waysToSplitArray(vector<int>& n) {\\n    long long right = accumulate(begin(n), end(n), 0LL), left = 0, res = 0;\\n    for (int i = 0; i < n.size() - 1; ++i) {\\n        left += n[i];\\n        right -= n[i];\\n        res += left >= right;\\n    }\\n    return res;\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2038459,
                "title": "c-easy-to-understand-simple-sum-o-n",
                "content": "**Please Upvote If It Helps**\\n\\n* store total sum of nums in right_sum and iterate over nums\\n\\n* add nums[i] in left sum and subtract nums[i] from right sum\\n* when condition (left_sum>=right_sum) match increase valid_split by 1.\\n\\n```\\nclass Solution {\\npublic:\\n    int waysToSplitArray(vector<int>& nums) \\n    {\\n        int valid_split=0;\\n        long long right_sum=0;\\n        long long left_sum =0;\\n        \\n        //counting the total sum and store it into the right sum\\n        for(int i=0; i<nums.size(); i++) \\n            right_sum += nums[i];\\n        \\n        for(int i=0; i<nums.size()-1; i++)\\n        {\\n            // add nums[i] in left sum \\n            // subtract nums[i] from right sum\\n            left_sum += nums[i];  \\n            right_sum -= nums[i]; \\n            \\n            //check whether left_sum is greater than or equal to right_sum\\n            //if it is , then increase split by 1\\n            if(left_sum >= right_sum) \\n                valid_split++; \\n        }\\n        return valid_split;    \\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    int waysToSplitArray(vector<int>& nums) \\n    {\\n        int valid_split=0;\\n        long long right_sum=0;\\n        long long left_sum =0;\\n        \\n        //counting the total sum and store it into the right sum\\n        for(int i=0; i<nums.size(); i++) \\n            right_sum += nums[i];\\n        \\n        for(int i=0; i<nums.size()-1; i++)\\n        {\\n            // add nums[i] in left sum \\n            // subtract nums[i] from right sum\\n            left_sum += nums[i];  \\n            right_sum -= nums[i]; \\n            \\n            //check whether left_sum is greater than or equal to right_sum\\n            //if it is , then increase split by 1\\n            if(left_sum >= right_sum) \\n                valid_split++; \\n        }\\n        return valid_split;    \\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2038290,
                "title": "c-prefix-sum-easy-o-n-solution",
                "content": "**Please upvote if you find this solution helpful :)**\\n\\n**TC- O(N), SC- O(1)**\\n```\\nclass Solution {\\npublic:\\n    \\n    //store total sum of nums in right_sum and iterate over nums\\n    //add nums[i] in left sum and subtract nums[i] from right sum\\n    //when condition match increase valid_split by 1.\\n    int waysToSplitArray(vector<int>& nums) \\n    {\\n        int valid_split=0;\\n        long long right_sum=0, left_sum=0;\\n        \\n        //store total sum of nums in right_sum\\n        for(int i=0; i<nums.size(); i++) right_sum += nums[i];\\n        \\n        for(int i=0; i<nums.size()-1; i++)\\n        {\\n            left_sum += nums[i]; //add nums[i] in left sum \\n            right_sum -= nums[i]; // and subtract nums[i] from right sum\\n            \\n            //check whether left_sum is greater than or equal to right_sum\\n            //and increase the valid_split by 1\\n            if(left_sum >= right_sum) \\n                valid_split++; \\n        }\\n        return valid_split;\\n        \\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "C",
                    "Prefix Sum"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    \\n    //store total sum of nums in right_sum and iterate over nums\\n    //add nums[i] in left sum and subtract nums[i] from right sum\\n    //when condition match increase valid_split by 1.\\n    int waysToSplitArray(vector<int>& nums) \\n    {\\n        int valid_split=0;\\n        long long right_sum=0, left_sum=0;\\n        \\n        //store total sum of nums in right_sum\\n        for(int i=0; i<nums.size(); i++) right_sum += nums[i];\\n        \\n        for(int i=0; i<nums.size()-1; i++)\\n        {\\n            left_sum += nums[i]; //add nums[i] in left sum \\n            right_sum -= nums[i]; // and subtract nums[i] from right sum\\n            \\n            //check whether left_sum is greater than or equal to right_sum\\n            //and increase the valid_split by 1\\n            if(left_sum >= right_sum) \\n                valid_split++; \\n        }\\n        return valid_split;\\n        \\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2038386,
                "title": "java-o-n-time-and-o-1-space-easy",
                "content": "```\\nclass Solution {\\n    public int waysToSplitArray(int[] nums) {\\n        long sum = 0;\\n        for(int num : nums) {\\n            sum += num;\\n        }\\n        \\n        long leftSum = 0;\\n        int res = 0;\\n        for(int i = 0; i < nums.length-1; i++) {\\n            leftSum += nums[i];\\n            long rightSum = sum - leftSum;\\n            if(leftSum >= rightSum) {\\n                res++;\\n            }\\n        }\\n        return res;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Prefix Sum"
                ],
                "code": "```\\nclass Solution {\\n    public int waysToSplitArray(int[] nums) {\\n        long sum = 0;\\n        for(int num : nums) {\\n            sum += num;\\n        }\\n        \\n        long leftSum = 0;\\n        int res = 0;\\n        for(int i = 0; i < nums.length-1; i++) {\\n            leftSum += nums[i];\\n            long rightSum = sum - leftSum;\\n            if(leftSum >= rightSum) {\\n                res++;\\n            }\\n        }\\n        return res;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2876529,
                "title": "easy-java-solution-using-arrays-o-n",
                "content": "This is one of the easiest question, where we need to compare leftsum and rightsum\\n\\nNote that we have to take leftSum and rightSum as long type and not of int type looking at the constraints given in the problem.\\n\\nSteps: \\n1.First Calculate the sum of all elements present in the array.\\n2.Then Calculate left sum and rightSum for every index.\\n3.Compare leftSum and rightSum and if leftSum>rightSum, then increment the value of count.\\n4.return the count.\\n\\n```\\n\\nclass Solution {\\n    public int waysToSplitArray(int[] nums) {\\n        int n = nums.length;\\n        int count = 0;\\n        long sum = 0;\\n        long leftSum = 0;\\n        long rightSum = 0;\\n        \\n        for(int i=0;i<n;i++){\\n            \\n            sum += nums[i];\\n        }\\n        \\n        for(int j = 0;j<n-1;j++){\\n            leftSum += nums[j];\\n            rightSum = sum-leftSum;\\n    \\n            if(leftSum>=rightSum){\\n                count++;\\n            }\\n        }\\n        \\n        return count;\\n    }\\n}\\n```\\n\\n## Please upvote if it helped.",
                "solutionTags": [
                    "Java",
                    "Array"
                ],
                "code": "```\\n\\nclass Solution {\\n    public int waysToSplitArray(int[] nums) {\\n        int n = nums.length;\\n        int count = 0;\\n        long sum = 0;\\n        long leftSum = 0;\\n        long rightSum = 0;\\n        \\n        for(int i=0;i<n;i++){\\n            \\n            sum += nums[i];\\n        }\\n        \\n        for(int j = 0;j<n-1;j++){\\n            leftSum += nums[j];\\n            rightSum = sum-leftSum;\\n    \\n            if(leftSum>=rightSum){\\n                count++;\\n            }\\n        }\\n        \\n        return count;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2520796,
                "title": "python-easy-faster-than-99",
                "content": "```\\nclass Solution:\\n    def waysToSplitArray(self, nums: List[int]) -> int:\\n        sumtot= sum(nums)-nums[0]\\n        leftsum = nums[0]\\n        res = 0\\n        \\n        \\n        for i in range(1,len(nums)):\\n            if leftsum>=sumto:\\n                res+=1\\n            sumtot-=nums[i]\\n            leftsum+=nums[i]\\n                \\n        return res\\n   \\n```",
                "solutionTags": [
                    "Python"
                ],
                "code": "```\\nclass Solution:\\n    def waysToSplitArray(self, nums: List[int]) -> int:\\n        sumtot= sum(nums)-nums[0]\\n        leftsum = nums[0]\\n        res = 0\\n        \\n        \\n        for i in range(1,len(nums)):\\n            if leftsum>=sumto:\\n                res+=1\\n            sumtot-=nums[i]\\n            leftsum+=nums[i]\\n                \\n        return res\\n   \\n```",
                "codeTag": "Java"
            },
            {
                "id": 2878191,
                "title": "python3-beats-99-simple-solution",
                "content": "```\\nclass Solution:\\n\\tdef waysToSplitArray(self, nums: List[int]) -> int:\\n        s0 = sum(nums)\\n        s1, d = 0, 0\\n        for i in nums[:-1]:\\n            s1 += i\\n            if s1 >= (s0-s1):\\n                d += 1\\n        return d\\n```",
                "solutionTags": [
                    "Python3",
                    "Array",
                    "Prefix Sum"
                ],
                "code": "```\\nclass Solution:\\n\\tdef waysToSplitArray(self, nums: List[int]) -> int:\\n        s0 = sum(nums)\\n        s1, d = 0, 0\\n        for i in nums[:-1]:\\n            s1 += i\\n            if s1 >= (s0-s1):\\n                d += 1\\n        return d\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2781077,
                "title": "simple-o-n-time-and-o-1-space-solution-python",
                "content": "If you have any ***doubts*** or ***suggestion***, put in comments.\\n```\\nclass Solution(object):\\n    def waysToSplitArray(self, nums):\\n        lSum, rSum = 0, sum(nums)\\n        ans = 0\\n        for i in range(len(nums) - 1):\\n            lSum += nums[i]\\n            rSum -= nums[i]\\n            if lSum >= rSum: ans += 1\\n        return ans\\n```\\n**UpVote**, if you like it **:)**",
                "solutionTags": [
                    "Python",
                    "Python3"
                ],
                "code": "```\\nclass Solution(object):\\n    def waysToSplitArray(self, nums):\\n        lSum, rSum = 0, sum(nums)\\n        ans = 0\\n        for i in range(len(nums) - 1):\\n            lSum += nums[i]\\n            rSum -= nums[i]\\n            if lSum >= rSum: ans += 1\\n        return ans\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2038305,
                "title": "c-python3-very-concise-prefix-sum-o-1",
                "content": "**Python**\\n```\\nclass Solution:\\n    def waysToSplitArray(self, nums: List[int]) -> int:\\n        lsum, rsum, ans = 0, sum(nums), 0\\n        for i in range(len(nums) - 1):\\n            lsum += nums[i]\\n            rsum -= nums[i]\\n            ans += (lsum >= rsum)\\n        return ans\\n\\t\\t\\n```\\n\\n**C++**\\n```\\nclass Solution {\\npublic:\\n    int waysToSplitArray(vector<int>& nums) {\\n        long long lsum = 0, rsum = 0, ans = 0;\\n        for (int& num: nums) rsum += num;\\n        for (int i = 0; i < nums.size() - 1; ++i) {\\n            lsum += nums[i];\\n            rsum -= nums[i];\\n            ans += (lsum >= rsum);\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "Python3",
                    "Prefix Sum"
                ],
                "code": "```\\nclass Solution:\\n    def waysToSplitArray(self, nums: List[int]) -> int:\\n        lsum, rsum, ans = 0, sum(nums), 0\\n        for i in range(len(nums) - 1):\\n            lsum += nums[i]\\n            rsum -= nums[i]\\n            ans += (lsum >= rsum)\\n        return ans\\n\\t\\t\\n```\n```\\nclass Solution {\\npublic:\\n    int waysToSplitArray(vector<int>& nums) {\\n        long long lsum = 0, rsum = 0, ans = 0;\\n        for (int& num: nums) rsum += num;\\n        for (int i = 0; i < nums.size() - 1; ++i) {\\n            lsum += nums[i];\\n            rsum -= nums[i];\\n            ans += (lsum >= rsum);\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2038101,
                "title": "short-and-easy-python-solution-using-a-queue-o-n",
                "content": "\\n**Algorithm.**\\nInitialize 2 sums, Left and Right. where `left = nums[0]` and right will sum of the rest of the elements from 1 to n.\\nNow create a queue with `nums[1:]`\\nPop elements from the queue one by one until none are left.\\nFor each element\\n\\t - add this to left sum\\n\\t - subtract this from right sum\\n\\t - if our condition is satisfied, add 1 to our count.\\n\\n```\\ndef waysToSplitArray(self, nums: List[int]) -> int:\\n\\n    left_sum = nums[0]\\n    right_sum = sum(nums[1: ])\\n    count = 0\\n    queue = deque(nums[1:])\\n\\n    while queue:\\n        if left_sum >= right_sum:\\n            count += 1\\n\\n        ele = queue.popleft()\\n\\n        # add to left_sum\\n        left_sum += ele\\n        # remove from right\\n        right_sum -= ele\\n\\n    return count\\n```",
                "solutionTags": [
                    "Python"
                ],
                "code": "```\\ndef waysToSplitArray(self, nums: List[int]) -> int:\\n\\n    left_sum = nums[0]\\n    right_sum = sum(nums[1: ])\\n    count = 0\\n    queue = deque(nums[1:])\\n\\n    while queue:\\n        if left_sum >= right_sum:\\n            count += 1\\n\\n        ele = queue.popleft()\\n\\n        # add to left_sum\\n        left_sum += ele\\n        # remove from right\\n        right_sum -= ele\\n\\n    return count\\n```",
                "codeTag": "Python3"
            },
            {
                "id": 3712490,
                "title": "easiest-c-solution-beginner-friendly-approach-o-n-time-complexity",
                "content": "# Code\\n```\\nclass Solution {\\npublic:\\n    int waysToSplitArray(vector<int>& nums) {\\n        long long int sumLeft = 0, sumRight = 0, ans = 0;\\n        for(int i=0; i<nums.size(); i++)\\n            sumRight += nums[i];\\n        for(int i=0; i<nums.size()-1; i++){\\n            sumLeft += nums[i];\\n            sumRight -= nums[i];\\n            if(sumLeft >= sumRight)\\n                ans++;\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int waysToSplitArray(vector<int>& nums) {\\n        long long int sumLeft = 0, sumRight = 0, ans = 0;\\n        for(int i=0; i<nums.size(); i++)\\n            sumRight += nums[i];\\n        for(int i=0; i<nums.size()-1; i++){\\n            sumLeft += nums[i];\\n            sumRight -= nums[i];\\n            if(sumLeft >= sumRight)\\n                ans++;\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2038407,
                "title": "simple-java-solution",
                "content": "```\\nclass Solution {\\n    public int waysToSplitArray(int[] nums) {\\n        long sum = 0;\\n        for(int i : nums){\\n            sum+=i;\\n        }\\n        int sol = 0;\\n        long localSum = 0;\\n        for(int i=0; i<nums.length-1;i++){\\n            localSum += nums[i];\\n            if(localSum >= sum-localSum){\\n                sol++;\\n            }\\n        }\\n        return sol;\\n    }\\n}",
                "solutionTags": [
                    "Java"
                ],
                "code": "class Solution {\\n    public int waysToSplitArray(int[] nums) {\\n        long sum = 0;\\n        for(int i : nums){\\n            sum+=i;\\n        }",
                "codeTag": "Java"
            },
            {
                "id": 2038376,
                "title": "c-o-n-solution-with-comments",
                "content": "```\\nclass Solution {\\npublic:\\n    int waysToSplitArray(vector<int>& nums) {\\n        \\n        long long sum=0, lsum=0,rsum=0;\\n        \\n        //calculate sum of all values in nums\\n        for(auto i:nums){\\n            sum+=i;\\n        }\\n        \\n        int n=nums.size(),res=0;\\n    \\n        for(int i=0;i<n;i++){\\n            lsum+=nums[i];//calculate left sum\\n            \\n            rsum=sum-lsum;//calculate right sum\\n            \\n            if(i<n-1 && lsum>=rsum){\\n                // increment result if there is atleast \\n                //one element after i and left sum is \\n                //greater than equal to right sum\\n                res++; \\n            }\\n        }\\n        return res;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C",
                    "Prefix Sum"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int waysToSplitArray(vector<int>& nums) {\\n        \\n        long long sum=0, lsum=0,rsum=0;\\n        \\n        //calculate sum of all values in nums\\n        for(auto i:nums){\\n            sum+=i;\\n        }\\n        \\n        int n=nums.size(),res=0;\\n    \\n        for(int i=0;i<n;i++){\\n            lsum+=nums[i];//calculate left sum\\n            \\n            rsum=sum-lsum;//calculate right sum\\n            \\n            if(i<n-1 && lsum>=rsum){\\n                // increment result if there is atleast \\n                //one element after i and left sum is \\n                //greater than equal to right sum\\n                res++; \\n            }\\n        }\\n        return res;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2038121,
                "title": "cpp-short-and-simple-prefix-sum",
                "content": "```\\nclass Solution {\\npublic:\\n    typedef long ll;\\n    int waysToSplitArray(vector<int>& v,ll ss=0,ll ans=0) {\\n        ll s=accumulate(v.begin(),v.end(),0LL);\\n        for(int i=0;i<v.size()-1;i++){\\n            ss+=v[i];\\n            ans+=ss>=s-ss;\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Prefix Sum"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    typedef long ll;\\n    int waysToSplitArray(vector<int>& v,ll ss=0,ll ans=0) {\\n        ll s=accumulate(v.begin(),v.end(),0LL);\\n        for(int i=0;i<v.size()-1;i++){\\n            ss+=v[i];\\n            ans+=ss>=s-ss;\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3753422,
                "title": "7-lines-python-code-beats-82",
                "content": "# Intuition\\nso you have to count  the number of ways we can split array basically in two parts such that `sum of left Part >= right Part`\\nso first find the total sum of the array\\nand loop through your given array and add each element to left Part and subtract it from your totalSum (which is now your right Part)\\nif the condition satisfies increase count\\nreturn count of subarray as your ans\\n\\n# Code\\n```\\nclass Solution:\\n    def waysToSplitArray(self, nums: List[int]) -> int:\\n        summ = sum(nums)\\n        leftSum, count = 0, 0\\n        for i in range(len(nums) - 1):\\n            leftSum += nums[i]\\n            summ -= nums[i]\\n            if leftSum >= summ:\\n                count += 1\\n        return count\\n            \\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def waysToSplitArray(self, nums: List[int]) -> int:\\n        summ = sum(nums)\\n        leftSum, count = 0, 0\\n        for i in range(len(nums) - 1):\\n            leftSum += nums[i]\\n            summ -= nums[i]\\n            if leftSum >= summ:\\n                count += 1\\n        return count\\n            \\n```",
                "codeTag": "Java"
            },
            {
                "id": 2966281,
                "title": "java-easy-solution-100-faster-prefix-sum",
                "content": "# Approach\\nPrefix Sum\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity: O(N)\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:O(1)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\n    public int waysToSplitArray(int[] nums) {\\n        long sumR=0;\\n        long sumL=0;\\n        int ans=0;\\n        for(int i:nums){\\n            sumR+=i;\\n        }\\n        for(int i=0;i<nums.length-1;i++){\\n            sumL+=nums[i];\\n            sumR-=nums[i];\\n            if(sumL>=sumR) ans++;\\n        }\\n        return ans;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Prefix Sum"
                ],
                "code": "```\\nclass Solution {\\n    public int waysToSplitArray(int[] nums) {\\n        long sumR=0;\\n        long sumL=0;\\n        int ans=0;\\n        for(int i:nums){\\n            sumR+=i;\\n        }\\n        for(int i=0;i<nums.length-1;i++){\\n            sumL+=nums[i];\\n            sumR-=nums[i];\\n            if(sumL>=sumR) ans++;\\n        }\\n        return ans;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2962868,
                "title": "simple-prefix-sum-c",
                "content": "```\\nclass Solution {\\npublic:\\n    int waysToSplitArray(vector<int>& nums) {\\n        long long ls = 0, rs = 0, ans = 0, n = nums.size();\\n        for(int i : nums) rs += i;\\n\\n        for(int i=0; i<n-1; i++) {\\n            ls += nums[i];\\n            rs -= nums[i];\\n            ans += ls >= rs;\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Prefix Sum"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int waysToSplitArray(vector<int>& nums) {\\n        long long ls = 0, rs = 0, ans = 0, n = nums.size();\\n        for(int i : nums) rs += i;\\n\\n        for(int i=0; i<n-1; i++) {\\n            ls += nums[i];\\n            rs -= nums[i];\\n            ans += ls >= rs;\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2817202,
                "title": "c-easy-solution-number-of-ways-to-split-array",
                "content": "\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int waysToSplitArray(vector<int>& nums) {\\n        int n=nums.size();\\n        int ans=0;\\n        long long right_sum=0;\\n        long long left_sum=0;\\n\\n        for(int i=0;i<n;i++){\\n            right_sum+=nums[i];\\n        }\\n        for(int i=0;i<n-1;i++){\\n            left_sum+=nums[i];\\n            right_sum-=nums[i];\\n\\n            if(left_sum>=right_sum){\\n                ans++;\\n            }\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Array",
                    "Prefix Sum"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int waysToSplitArray(vector<int>& nums) {\\n        int n=nums.size();\\n        int ans=0;\\n        long long right_sum=0;\\n        long long left_sum=0;\\n\\n        for(int i=0;i<n;i++){\\n            right_sum+=nums[i];\\n        }\\n        for(int i=0;i<n-1;i++){\\n            left_sum+=nums[i];\\n            right_sum-=nums[i];\\n\\n            if(left_sum>=right_sum){\\n                ans++;\\n            }\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2742692,
                "title": "c-easy-solution-o-n",
                "content": "class Solution {\\npublic:\\n    int waysToSplitArray(vector<int>& nums) {\\n   long long sum=0;\\n        for(int i=0;i<nums.size();i++)\\n        {\\n            sum+=nums[i];\\n        }\\n        long long lsum=0,count=0;\\n        for(int i=0;i<nums.size()-1;i++)\\n        {    lsum+=nums[i];\\n         sum-=nums[i];\\n            if(lsum>=sum) count++;\\n              \\n        }\\n        return count;\\n    }\\n};",
                "solutionTags": [],
                "code": "class Solution {\\npublic:\\n    int waysToSplitArray(vector<int>& nums) {\\n   long long sum=0;\\n        for(int i=0;i<nums.size();i++)\\n        {\\n            sum+=nums[i];\\n        }",
                "codeTag": "Java"
            },
            {
                "id": 2079367,
                "title": "go-easy-solution",
                "content": "```\\nfunc waysToSplitArray(nums []int) int {\\n    sum := 0\\n\\tcount := 0\\n\\n\\tfor _, v := range nums {\\n\\t\\tsum += v\\n\\t}\\n\\tnum := 0\\n\\tfor i := 0; i < len(nums)-1; i++ {\\n\\t\\tnum = num + nums[i]\\n\\t\\tsum = sum - nums[i]\\n\\t\\tif num >= sum {\\n\\t\\t\\tcount++\\n\\t\\t}\\n\\t}\\n    return count\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nfunc waysToSplitArray(nums []int) int {\\n    sum := 0\\n\\tcount := 0\\n\\n\\tfor _, v := range nums {\\n\\t\\tsum += v\\n\\t}\\n\\tnum := 0\\n\\tfor i := 0; i < len(nums)-1; i++ {\\n\\t\\tnum = num + nums[i]\\n\\t\\tsum = sum - nums[i]\\n\\t\\tif num >= sum {\\n\\t\\t\\tcount++\\n\\t\\t}\\n\\t}\\n    return count\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2046529,
                "title": "c-prefix-sum-o-n-o-1-space-two-approach",
                "content": "**1. Prefix sum with O(N) space:**\\n```\\nclass Solution {\\npublic:\\n    int waysToSplitArray(vector<int>& nums) {\\n        int n=nums.size();\\n        vector<long long> preSum(n);\\n        preSum[0]=nums[0];\\n        for(int i=1;i<n;i++){\\n            preSum[i]=preSum[i-1]+nums[i];\\n        }\\n        int cnt=0;\\n        for(int i=0;i<n-1;i++){\\n            long long leftSum=preSum[i];\\n            long long rightSum=preSum[n-1]-preSum[i];\\n            if(leftSum>=rightSum) cnt++;\\n        }\\n        return cnt;\\n    }\\n};\\n```\\n\\n**2. Prefix sum with O(1) space:**\\n```\\nclass Solution {\\npublic:\\n    int waysToSplitArray(vector<int>& nums) {\\n        int n=nums.size();\\n        long long totalSum=0;\\n        for(auto x:nums) totalSum+=x;\\n        int cnt=0;\\n        long long leftSum=0;\\n        for(int i=0;i<n-1;i++){\\n            leftSum+=nums[i];\\n            long long rightSum=totalSum-leftSum;\\n            if(leftSum>=rightSum) cnt++;\\n        }\\n        return cnt;\\n    }\\n};\\n```\\n\\n**If you like this, Do a upVote!**",
                "solutionTags": [
                    "C",
                    "Prefix Sum"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int waysToSplitArray(vector<int>& nums) {\\n        int n=nums.size();\\n        vector<long long> preSum(n);\\n        preSum[0]=nums[0];\\n        for(int i=1;i<n;i++){\\n            preSum[i]=preSum[i-1]+nums[i];\\n        }\\n        int cnt=0;\\n        for(int i=0;i<n-1;i++){\\n            long long leftSum=preSum[i];\\n            long long rightSum=preSum[n-1]-preSum[i];\\n            if(leftSum>=rightSum) cnt++;\\n        }\\n        return cnt;\\n    }\\n};\\n```\n```\\nclass Solution {\\npublic:\\n    int waysToSplitArray(vector<int>& nums) {\\n        int n=nums.size();\\n        long long totalSum=0;\\n        for(auto x:nums) totalSum+=x;\\n        int cnt=0;\\n        long long leftSum=0;\\n        for(int i=0;i<n-1;i++){\\n            leftSum+=nums[i];\\n            long long rightSum=totalSum-leftSum;\\n            if(leftSum>=rightSum) cnt++;\\n        }\\n        return cnt;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2043034,
                "title": "c-prefix-sum-o-1-space",
                "content": "```\\nclass Solution {\\npublic:\\n    int waysToSplitArray(vector<int>& nums) {\\n        long long int leftSum = 0;\\n        long long int rightSum= 0;\\n        \\n        for(int i=0; i<nums.size(); i++){\\n            rightSum += nums[i];\\n        }\\n        \\n        int count = 0;\\n        for(int i=0; i<nums.size()-1; i++){\\n            leftSum += nums[i];\\n            rightSum -= nums[i]; \\n            if(leftSum >= rightSum)\\n                count++;\\n        }\\n        \\n        return count;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int waysToSplitArray(vector<int>& nums) {\\n        long long int leftSum = 0;\\n        long long int rightSum= 0;\\n        \\n        for(int i=0; i<nums.size(); i++){\\n            rightSum += nums[i];\\n        }\\n        \\n        int count = 0;\\n        for(int i=0; i<nums.size()-1; i++){\\n            leftSum += nums[i];\\n            rightSum -= nums[i]; \\n            if(leftSum >= rightSum)\\n                count++;\\n        }\\n        \\n        return count;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2042537,
                "title": "python-solution-100-faster",
                "content": "```\\nclass Solution:\\n    def waysToSplitArray(self, nums: List[int]) -> int:\\n        f=0\\n        r=sum(nums)\\n        c=0\\n        for i in range(len(nums)-1):\\n            f+=nums[i]\\n            r-=nums[i]\\n            if f>=r:\\n                c+=1\\n        return c\\n```\\n![image](https://assets.leetcode.com/users/images/f8c11002-a5f7-491f-8850-1d20b340a569_1652636285.8330252.png)\\n**UPVOTE IF YOU FIND IT HELPFUL**\\n",
                "solutionTags": [
                    "Python"
                ],
                "code": "```\\nclass Solution:\\n    def waysToSplitArray(self, nums: List[int]) -> int:\\n        f=0\\n        r=sum(nums)\\n        c=0\\n        for i in range(len(nums)-1):\\n            f+=nums[i]\\n            r-=nums[i]\\n            if f>=r:\\n                c+=1\\n        return c\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2038378,
                "title": "javascript-112ms",
                "content": "```\\n/**\\n * @param {number[]} nums\\n * @return {number}\\n */\\nvar waysToSplitArray = function(nums) {\\n    let result = 0;\\n    let letsum = 0;\\n    let rightsum = nums.reduce((a,b)=> a+b);\\n    let end = nums.length-1;\\n    for (let i = 0;i<end;i++) {\\n        letsum+=nums[i];\\n        rightsum-=nums[i];\\n        if (letsum>=rightsum) {\\n            result++;\\n        }\\n    }\\n    return result;\\n};\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\n/**\\n * @param {number[]} nums\\n * @return {number}\\n */\\nvar waysToSplitArray = function(nums) {\\n    let result = 0;\\n    let letsum = 0;\\n    let rightsum = nums.reduce((a,b)=> a+b);\\n    let end = nums.length-1;\\n    for (let i = 0;i<end;i++) {\\n        letsum+=nums[i];\\n        rightsum-=nums[i];\\n        if (letsum>=rightsum) {\\n            result++;\\n        }\\n    }\\n    return result;\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2038276,
                "title": "c-prefix-sum-o-n-time-best-optimized-approach",
                "content": "1-> FIrst we will store the sum in first itreation ;\\n2-> In second iteration we will subtract and compare the condition and increase the count ;\\n in second iteration we have iterated fron n-1 to 1 not to till 0; \\n\\t\\t\\n\\t\\t\\n****please up if you find it helpfull****\\n\\t\\t\\n\\t\\tlong long int sum1 = 0;\\n        int n = 0;\\n        for(int i=0; i<nums.size(); i++){\\n            sum1 += nums[i];\\n        }\\n        long long int sum2 = 0;\\n        for(int i=nums.size()-1; i>=1; i--){\\n            sum2 += nums[i];\\n            sum1 -= nums[i];\\n            if(sum1>=sum2) n++;\\n        }\\n        return n;",
                "solutionTags": [
                    "C",
                    "Prefix Sum"
                ],
                "code": "1-> FIrst we will store the sum in first itreation ;\\n2-> In second iteration we will subtract and compare the condition and increase the count ;\\n in second iteration we have iterated fron n-1 to 1 not to till 0; \\n\\t\\t\\n\\t\\t\\n****please up if you find it helpfull****\\n\\t\\t\\n\\t\\tlong long int sum1 = 0;\\n        int n = 0;\\n        for(int i=0; i<nums.size(); i++){\\n            sum1 += nums[i];\\n        }\\n        long long int sum2 = 0;\\n        for(int i=nums.size()-1; i>=1; i--){\\n            sum2 += nums[i];\\n            sum1 -= nums[i];\\n            if(sum1>=sum2) n++;\\n        }\\n        return n;",
                "codeTag": "Unknown"
            },
            {
                "id": 2038185,
                "title": "javascript-o-n-prefix-sum",
                "content": "\\nThe brute force solution is calculate sum at every index. At index i we need to calculate the sum for `(0 to i)` and `(i + 1 to n)` ( nums[0) + ... + nums[i] ) compare to (nums[i + 1] + ... + nums[n] )\\nWe realized that we don\\'t need to calculate the sum for every index cause: \\n\\n```\\n nums[0) + ... + nums[i] = prefixSum[i]\\n nums[i + 1] + ... + nums[n] = prefixSum[n] - prefixSum[i]\\n```\\n\\nLet\\'s go to see example: \\n\\nExample: `[10,4,-8,7]` \\nPrefix sum: `[10, 14, 6, 13]`\\n\\nSo comes to split array: \\n- `[10]` and `[4, -8, 7]` \\n\\t- First part sum is *10*  (**prefixSum[0]**)\\n\\t- Second part sum is 3 (**prefixSum[3] - prefixSum[0]**)\\n\\n- `[10, 4]` and `[-8, 7]` \\n\\t- First part sum is *14*  (**prefixSum[1]**)\\n\\t- Second part sum is -1 (**prefixSum[3] - prefixSum[1]**)\\n\\n- `[10, 4, -8]` and `[7]` \\n\\t- First part sum is *6*  (**prefixSum[2]**)\\n\\t- Second part sum is *7* (**prefixSum[3] - prefixSum[2]**)\\n\\nImplementation:\\n\\nFirst for loop is to calculate the prefix sum so we don\\'t need to calculate the sum for every index\\n\\nSecond loop is to count the result if it match the condition increase the result by 1\\n\\n\\n```\\n/**\\n * @param {number[]} nums\\n * @return {number}\\n */\\nconst waysToSplitArray = nums => {\\n    let prefixSum = [nums[0]]\\n    const len = nums.length\\n    \\n    for (let i = 1; i < nums.length; i++) {\\n        prefixSum[i] = prefixSum[i - 1] + nums[i]\\n    }\\n    \\n    \\n    let res = 0\\n    for (let i = 0; i < nums.length - 1; i++) {\\n        if (prefixSum[i] >= prefixSum[len - 1] - prefixSum[i])\\n            res++\\n    }\\n    \\n    return res\\n};\\n```\\n\\n<br />\\n\\n\\u2139\\uFE0F [My javascript solution collection](https://github.com/toantd90/leetcode-js-solutions)\\n\\n<br />",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\n nums[0) + ... + nums[i] = prefixSum[i]\\n nums[i + 1] + ... + nums[n] = prefixSum[n] - prefixSum[i]\\n```\n```\\n/**\\n * @param {number[]} nums\\n * @return {number}\\n */\\nconst waysToSplitArray = nums => {\\n    let prefixSum = [nums[0]]\\n    const len = nums.length\\n    \\n    for (let i = 1; i < nums.length; i++) {\\n        prefixSum[i] = prefixSum[i - 1] + nums[i]\\n    }\\n    \\n    \\n    let res = 0\\n    for (let i = 0; i < nums.length - 1; i++) {\\n        if (prefixSum[i] >= prefixSum[len - 1] - prefixSum[i])\\n            res++\\n    }\\n    \\n    return res\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2038104,
                "title": "once-again-totalsum-problem",
                "content": "**Approach**:\\n\\nStep-1: find sum of the array\\n\\nStep-2: leftsum = leftsum + currentelement\\n\\nStep-3: rightsum = totalsum - leftsum\\n\\nStep-4: if leftsum >= rightsum  increment count\\n\\n**Note** : \\n1. rightmost element has no rightsum  \\n2. Sums can be large so take long instead of int \\n\\n```\\nclass Solution\\n{\\n    public int waysToSplitArray(int[] nums)\\n    {\\n        int n = nums.length;\\n        long totalsum=0,leftsum=0,rightsum=0;\\n        int i,cnt=0;\\n        for(int num:nums)\\n        {\\n            totalsum+=num;\\n        }\\n        for(i=0;i<n-1;i++)\\n        {\\n            leftsum+=nums[i];   // sum of i+1 elements\\n            rightsum = totalsum-leftsum; // sum of (n-i-1) elements\\n            if(leftsum >= rightsum) cnt++;\\n        }\\n        return cnt;\\n    }\\n}\\n\\n```\\n",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution\\n{\\n    public int waysToSplitArray(int[] nums)\\n    {\\n        int n = nums.length;\\n        long totalsum=0,leftsum=0,rightsum=0;\\n        int i,cnt=0;\\n        for(int num:nums)\\n        {\\n            totalsum+=num;\\n        }\\n        for(i=0;i<n-1;i++)\\n        {\\n            leftsum+=nums[i];   // sum of i+1 elements\\n            rightsum = totalsum-leftsum; // sum of (n-i-1) elements\\n            if(leftsum >= rightsum) cnt++;\\n        }\\n        return cnt;\\n    }\\n}\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3655691,
                "title": "python-easy-solution-sliding-window",
                "content": "# Code\\n```\\nclass Solution:\\n    def waysToSplitArray(self, nums: List[int]) -> int:\\n        cnt=0\\n        left=nums[0]\\n        right=sum(nums[1:])\\n        if left>=right:\\n            cnt+=1\\n        for i in range(1,len(nums)-1):\\n            left+=nums[i]\\n            right-=nums[i]\\n            if left>=right:\\n                cnt+=1\\n        return cnt\\n\\n```\\n\\n***Please Upvote***",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def waysToSplitArray(self, nums: List[int]) -> int:\\n        cnt=0\\n        left=nums[0]\\n        right=sum(nums[1:])\\n        if left>=right:\\n            cnt+=1\\n        for i in range(1,len(nums)-1):\\n            left+=nums[i]\\n            right-=nums[i]\\n            if left>=right:\\n                cnt+=1\\n        return cnt\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3388855,
                "title": "swift-running-total",
                "content": "Learning this technique from the DS & algo course.\\n\\n```\\nclass Solution {\\n    func waysToSplitArray(_ nums: [Int]) -> Int {\\n    var total = 0, ans = 0, l = 0\\n    for num in nums {\\n        total += num\\n    }\\n    \\n    for i in 0..<nums.count - 1 {\\n        l += nums[i]\\n        ans += l >= total - l ? 1 : 0\\n    }\\n    \\n    return ans\\n    }\\n}\\n```",
                "solutionTags": [
                    "Swift"
                ],
                "code": "```\\nclass Solution {\\n    func waysToSplitArray(_ nums: [Int]) -> Int {\\n    var total = 0, ans = 0, l = 0\\n    for num in nums {\\n        total += num\\n    }\\n    \\n    for i in 0..<nums.count - 1 {\\n        l += nums[i]\\n        ans += l >= total - l ? 1 : 0\\n    }\\n    \\n    return ans\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3243110,
                "title": "kotlin-solution-with-explanation-o-n-time-complexity-o-1-space-complexity",
                "content": "# Approach\\n<!-- Describe your approach to solving the problem. -->\\n- Optimized from the classic prefix sum technique, which are:\\n- 1. We only need the total sum of the array instead of building the whole prefix array since we can calculate the leftSection as we went through the loop\\n- 2. The rightSection will be just whatever the total - leftSection.\\n- 3. If the leftSection is bigger than the rightSection, then we add to the result.\\n- 4. All of the total, leftSection, and rightSection variables need to declare Long to pass through all of the test cases.\\n# Complexity\\n- Time complexity: O(n) since it takes only single for loop through the array\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: O(1) since we just declared a few constant variable\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\n    fun waysToSplitArray(nums: IntArray): Int {\\n        var total : Long = 0\\n        var result = 0\\n        for (i in nums.indices) {\\n            total += nums[i]\\n        }\\n\\n        var leftSection : Long = 0\\n        for (i in 0 until nums.size - 1) {\\n            leftSection += nums[i]\\n            val rightSection : Long = total - leftSection\\n            if (leftSection >= rightSection) {\\n                result++\\n            }\\n        }\\n\\n        return result\\n    }\\n}\\n```",
                "solutionTags": [
                    "Kotlin"
                ],
                "code": "```\\nclass Solution {\\n    fun waysToSplitArray(nums: IntArray): Int {\\n        var total : Long = 0\\n        var result = 0\\n        for (i in nums.indices) {\\n            total += nums[i]\\n        }\\n\\n        var leftSection : Long = 0\\n        for (i in 0 until nums.size - 1) {\\n            leftSection += nums[i]\\n            val rightSection : Long = total - leftSection\\n            if (leftSection >= rightSection) {\\n                result++\\n            }\\n        }\\n\\n        return result\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2876494,
                "title": "prefix-sum-c-easy-to-understand",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nCalculate the prefix sum array and calculate for every index the condition.\\n\\n# Code\\n```\\nclass Solution {\\n#define ll long long int\\npublic:\\n    int waysToSplitArray(vector<int>& nums) {\\n        int n = nums.size();\\n        vector<ll> pre(n);\\n        pre[0] = nums[0];\\n        for(int i=1;i<n;i++) {\\n            pre[i] = pre[i-1] + nums[i];\\n        }\\n        ll ans = 0, tot = pre[n-1];\\n        for(int i=0;i<n-1;i++) {\\n            ll s = tot - pre[i];\\n            if(pre[i] >= s) ans++;\\n        }\\n        return ans;\\n    }\\n};\\n```\\nPlease upvote if you like the solution.",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\n#define ll long long int\\npublic:\\n    int waysToSplitArray(vector<int>& nums) {\\n        int n = nums.size();\\n        vector<ll> pre(n);\\n        pre[0] = nums[0];\\n        for(int i=1;i<n;i++) {\\n            pre[i] = pre[i-1] + nums[i];\\n        }\\n        ll ans = 0, tot = pre[n-1];\\n        for(int i=0;i<n-1;i++) {\\n            ll s = tot - pre[i];\\n            if(pre[i] >= s) ans++;\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2875751,
                "title": "c",
                "content": "```\\nint waysToSplitArray(int* nums, int numsSize){\\n    int n = numsSize;\\n    long long* presum = malloc(n * sizeof( long long));\\n    \\n    presum[0] = nums[0];\\n    for(int i = 1; i < n; i++){\\n        presum[i] = presum[i-1] + nums[i];\\n    }\\n    long long half = presum[n-1]/2;\\n    if(presum[n-1] %2){\\n        if(presum[n-1] > 0)\\n            half++;\\n    }\\n    int ans = 0;\\n    for(int i = 0; i <n-1;i++){\\n        if(presum[i] >= half)\\n            ans++;\\n    }\\n    return ans;\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nint waysToSplitArray(int* nums, int numsSize){\\n    int n = numsSize;\\n    long long* presum = malloc(n * sizeof( long long));\\n    \\n    presum[0] = nums[0];\\n    for(int i = 1; i < n; i++){\\n        presum[i] = presum[i-1] + nums[i];\\n    }\\n    long long half = presum[n-1]/2;\\n    if(presum[n-1] %2){\\n        if(presum[n-1] > 0)\\n            half++;\\n    }\\n    int ans = 0;\\n    for(int i = 0; i <n-1;i++){\\n        if(presum[i] >= half)\\n            ans++;\\n    }\\n    return ans;\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2875673,
                "title": "easy-approach-c",
                "content": "~~~\\nclass Solution {\\npublic:\\n    int waysToSplitArray(vector<int>& nums) {\\n        int n=nums.size();\\n        long long pref[n];\\n        long long postf[n];\\n        pref[0]=nums[0];\\n        postf[n-1]=nums[n-1];\\n        int c=0;\\n        for(int i=1;i<n;i++)\\n            pref[i]=pref[i-1]+nums[i];\\n        for(int i=n-2;i>=0;i--)\\n            postf[i]=postf[i+1]+nums[i];\\n        for(int i=0;i<n-1;i++)\\n            if(pref[i]>=postf[i+1]) \\n                c++;\\n        return c;\\n    }\\n};\\n~~~\\n***if helpful please upvote***",
                "solutionTags": [
                    "C",
                    "Prefix Sum"
                ],
                "code": "class Solution {\\npublic:\\n    int waysToSplitArray(vector<int>& nums) {\\n        int n=nums.size();\\n        long long pref[n];\\n        long long postf[n];\\n        pref[0]=nums[0];\\n        postf[n-1]=nums[n-1];\\n        int c=0;\\n        for(int i=1;i<n;i++)\\n            pref[i]=pref[i-1]+nums[i];\\n        for(int i=n-2;i>=0;i--)\\n            postf[i]=postf[i+1]+nums[i];\\n        for(int i=0;i<n-1;i++)\\n            if(pref[i]>=postf[i+1]) \\n                c++;\\n        return c;\\n    }",
                "codeTag": "Java"
            },
            {
                "id": 2814642,
                "title": "short-and-simple-c-solution",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nAs we are needed to find the first i+1 elements whose sum >= sum of last n-i-1 elements... So basically, we need to compare the sum of first (start----> end) and last (end -----> start) elements.\\nFor that, we have two approaches-->\\n1. With Space(beginner level)\\n2. Without Space \\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n1. **With Space** :-  Now we know, we need to compare the sum of starting and ending elements... It gives the hint that why dont we store the sum of starting elements (start----> end) in a vector (prefixSum). Similarly, for last elements, we will store the sum of elements from ending (end -----> start) in a vector (SuffixSum)...\\nNow, suppose to find for a particular nums[i] that the sum of first elements is greater than that of last elements or not. \\nWe will simply compare that the prefixSum[i] is greater than or equal to of suffixSum[i+1] or not. If prefixSum[i] is greater, then we have got our first validSplit\\n\\n2. **Without Space** :- In this case, we will first store the sum in a variable (suffixSum). Now suppose if we are needed to check for a particular nums[i], we will calculate the sum of elements till that index i and store them in any variable (prefixSum). Now, we will first remove that nums[i] from suffixSum and then, if prefixSum >= suffixSum, we got our first validSplit....\\n \\nONE MORE THING, as we know that we will have to keep one element at the right of i (validSplit). So we will run the loop till n-2 (0 based indexing).\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int waysToSplitArray(vector<int>& nums) {\\n        long long leftsum = 0, rightsum = 0;\\n        int cnt = 0, n = nums.size();\\n        vector<long long>presum(n), suffsum(n);\\n        for(int i = 0; i < n; i++){\\n            leftsum += nums[i];\\n            presum[i] = leftsum;//Storing the sum of elements from starting (start----> end) in prefixSum\\n        } \\n        for(int j = n-1; j >= 0; j--){\\n            rightsum += nums[j];\\n            suffsum[j] = rightsum;//Storing the sum of elements from ending (end -----> start)  in suffixSum\\n        } \\n        for(int k = 0; k < n-1; k++){ //Running the loop till n-2 to keep a element alwayas on the right side\\n        //Comparing if presum[k] >= suffsum[k+1], increase count\\n            if(presum[k] >= suffsum[k+1]) cnt++; \\n        }\\n        return cnt;\\n    }\\n};\\n\\n\\n\\nclass Solution {\\npublic:\\n    int waysToSplitArray(vector<int>& nums) {\\n        long long presum = 0, suffsum = 0;\\n        int cnt = 0;\\n        for(int i = 0; i < nums.size(); i++) suffsum+= nums[i];// Storing the sum of elements in suffixsum\\n        for(int j = 0; j < nums.size()-1; j++){//Running the loop till n-2 to keep a element alwayas on the right side\\n            presum += nums[j];//Storing the sum of elements till index i in prefixsum \\n            suffsum -= nums[j]; //Removing num[j] from suffixSum \\n        //Comparing if presum >= suffsum, increase count\\n            if(presum >= suffsum) cnt++;\\n        }\\n        return cnt;\\n    }\\n};\\n\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int waysToSplitArray(vector<int>& nums) {\\n        long long leftsum = 0, rightsum = 0;\\n        int cnt = 0, n = nums.size();\\n        vector<long long>presum(n), suffsum(n);\\n        for(int i = 0; i < n; i++){\\n            leftsum += nums[i];\\n            presum[i] = leftsum;//Storing the sum of elements from starting (start----> end) in prefixSum\\n        } \\n        for(int j = n-1; j >= 0; j--){\\n            rightsum += nums[j];\\n            suffsum[j] = rightsum;//Storing the sum of elements from ending (end -----> start)  in suffixSum\\n        } \\n        for(int k = 0; k < n-1; k++){ //Running the loop till n-2 to keep a element alwayas on the right side\\n        //Comparing if presum[k] >= suffsum[k+1], increase count\\n            if(presum[k] >= suffsum[k+1]) cnt++; \\n        }\\n        return cnt;\\n    }\\n};\\n\\n\\n\\nclass Solution {\\npublic:\\n    int waysToSplitArray(vector<int>& nums) {\\n        long long presum = 0, suffsum = 0;\\n        int cnt = 0;\\n        for(int i = 0; i < nums.size(); i++) suffsum+= nums[i];// Storing the sum of elements in suffixsum\\n        for(int j = 0; j < nums.size()-1; j++){//Running the loop till n-2 to keep a element alwayas on the right side\\n            presum += nums[j];//Storing the sum of elements till index i in prefixsum \\n            suffsum -= nums[j]; //Removing num[j] from suffixSum \\n        //Comparing if presum >= suffsum, increase count\\n            if(presum >= suffsum) cnt++;\\n        }\\n        return cnt;\\n    }\\n};\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2785333,
                "title": "2270-number-of-ways-to-split-array-prefix-sum-approach-c-fully-explained-with-comments",
                "content": "```\\nclass Solution {\\npublic:\\n    int waysToSplitArray(vector<int>& nums) {\\n        int splits{0};                        //Variable to Store number of valid splits\\n        long long int s=0;             //Sum variable to store sum of all elements\\n        int n=nums.size();             //N-->Stores size of nums array\\n        vector<long long int> preS(n,0);        //Prefix Sum array,preS[i] represents sum from 0...i index in nums\\n        for(int i=0;i<n;i++)          //Calculataion Of Prefix sum array\\n        {\\n            s+=nums[i];\\n            preS[i]=s;\\n        }\\n        for(int k=0;k<n-1;k++)       //Creating the splits\\n        {\\n            if(preS[k]>=preS[n-1]-preS[k])        //Condition-----> Sum from 0...k >= Sum from k+1...n-1 \\n                splits++;                                      //Valid Split count incremented\\n        }\\n        return splits;\\n    }\\n};",
                "solutionTags": [
                    "C",
                    "Array",
                    "Prefix Sum"
                ],
                "code": "class Solution {\\npublic:\\n    int waysToSplitArray(vector<int>& nums) {\\n        int splits{0}",
                "codeTag": "Java"
            },
            {
                "id": 2731740,
                "title": "c-easy-short",
                "content": "\\n# Code\\n```\\nclass Solution {\\npublic:\\n   int waysToSplitArray(vector<int>& nums) \\n    {\\n        int valid_split=0;\\n        long long right_sum=0;\\n        long long left_sum =0;\\n        \\n        for(int i=0; i<nums.size(); i++) \\n            right_sum += nums[i];\\n        \\n        for(int i=0; i<nums.size()-1; i++)\\n        {\\n            left_sum += nums[i];  \\n            right_sum -= nums[i]; \\n            \\n            if(left_sum >= right_sum) \\n                valid_split++; \\n        }\\n        return valid_split;    \\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n   int waysToSplitArray(vector<int>& nums) \\n    {\\n        int valid_split=0;\\n        long long right_sum=0;\\n        long long left_sum =0;\\n        \\n        for(int i=0; i<nums.size(); i++) \\n            right_sum += nums[i];\\n        \\n        for(int i=0; i<nums.size()-1; i++)\\n        {\\n            left_sum += nums[i];  \\n            right_sum -= nums[i]; \\n            \\n            if(left_sum >= right_sum) \\n                valid_split++; \\n        }\\n        return valid_split;    \\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2596834,
                "title": "with-explanation-comments-time-186-ms-89-02-space-85-5-mb-89-77",
                "content": "**Like it? ->Upvote please!** \\u30C4\\n\\nTC: O(n)   //iterate the array\\nSC: O(1)\\n\\n\\'\\'\\'\\nclass Solution {\\npublic:\\n    int waysToSplitArray(vector<int>& nums) {\\n        \\n        //initialize two sum variables-> one from the left or start & one from the right or end\\n        long long counter=0, sumLeft=0, sumRight=0;\\n        \\n        //loop to get the sumRight value\\n        for(int num:nums)\\n            sumRight+=num;\\n        //btw, you can use {sumRight=accumulate(nums.begin(), nums.end(), 0LL)} instead\\n        \\n        //loop over the whole array elements except the last one, as the element must have a right one \\n        for(int i=0;i<nums.size()-1;i++){\\n            \\n            //add the current value to the left sum-> (i+1) elements\\n            sumLeft+=nums[i];\\n            //subtract the current value from the right sum-> (n-i-1) elements\\n            sumRight-=nums[i];\\n            \\n            //check if the left sum greater than or equal the right one\\n            if(sumLeft>=sumRight)\\n                //add the counter by one\\n                counter++;\\n        }\\n        \\n        //return the final counter value\\n        return counter;\\n    }\\n};\\n\\'\\'\\'\\n\\n**Like it? ->Upvote please!** \\u30C4\\n**If still not understood, feel free to comment. I will help you out**\\n**Happy Coding :)**",
                "solutionTags": [
                    "C++",
                    "C",
                    "Array",
                    "Prefix Sum"
                ],
                "code": "class Solution {\\npublic:\\n    int waysToSplitArray(vector<int>& nums) {\\n        \\n        //initialize two sum variables-> one from the left or start & one from the right or end\\n        long long counter=0, sumLeft=0, sumRight=0;\\n        \\n        //loop to get the sumRight value\\n        for(int num:nums)\\n            sumRight+=num;\\n        //btw, you can use {sumRight=accumulate(nums.begin(), nums.end(), 0LL)}",
                "codeTag": "Java"
            },
            {
                "id": 2321766,
                "title": "java-runtime-4ms-time-o-n-space-o-1",
                "content": "```\\nclass Solution {\\n    public int waysToSplitArray(int[] nums) {\\n        long sumLeft = 0, sumRight = 0 ;\\n        int result = 0 ;\\n        \\n        for (int i : nums) sumRight += i ;\\n        \\n        for (int i = 0; i < nums.length-1; i++) {\\n            sumRight -= nums[i] ;\\n            sumLeft += nums[i] ;\\n            if (sumLeft >= sumRight) result++ ;\\n        }\\n        \\n        return result ;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Prefix Sum"
                ],
                "code": "```\\nclass Solution {\\n    public int waysToSplitArray(int[] nums) {\\n        long sumLeft = 0, sumRight = 0 ;\\n        int result = 0 ;\\n        \\n        for (int i : nums) sumRight += i ;\\n        \\n        for (int i = 0; i < nums.length-1; i++) {\\n            sumRight -= nums[i] ;\\n            sumLeft += nums[i] ;\\n            if (sumLeft >= sumRight) result++ ;\\n        }\\n        \\n        return result ;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2307329,
                "title": "c-simple-c-code",
                "content": "# **If you like the implementation then Please help me by increasing my reputation. By clicking the up arrow on the left of my image.**\\n```\\nclass Solution {\\npublic:\\n    int waysToSplitArray(vector<int>& nums) {\\n        int n = nums.size();\\n        long long lst = 0;\\n        for(int i = 0; i < n; i++)\\n        {\\n            lst += nums[i];\\n        }\\n        long long lft = 0, rht, ans = 0;\\n        for(int i = 0; i < n-1; i++)\\n        {\\n            lft += nums[i];\\n            rht = lst-lft;\\n            if(lft >= rht)\\n                ans++;\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Prefix Sum"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int waysToSplitArray(vector<int>& nums) {\\n        int n = nums.size();\\n        long long lst = 0;\\n        for(int i = 0; i < n; i++)\\n        {\\n            lst += nums[i];\\n        }\\n        long long lft = 0, rht, ans = 0;\\n        for(int i = 0; i < n-1; i++)\\n        {\\n            lft += nums[i];\\n            rht = lst-lft;\\n            if(lft >= rht)\\n                ans++;\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2181129,
                "title": "not-even-a-medium-problem-very-easy-c-solution",
                "content": "```\\nclass Solution {\\npublic:\\n    int waysToSplitArray(vector<int>& nums) {\\n        long long c=0, s1=0, s2=0;\\n        int l=nums.size();\\n        for(auto& i : nums){\\n            s1 += i;\\n        }\\n        for(int i=0; i<l-1; ++i){\\n            s1 -= nums[i];\\n            s2 += nums[i];\\n            if(s2>=s1){\\n                ++c;\\n            }\\n        }\\n        return c;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int waysToSplitArray(vector<int>& nums) {\\n        long long c=0, s1=0, s2=0;\\n        int l=nums.size();\\n        for(auto& i : nums){\\n            s1 += i;\\n        }\\n        for(int i=0; i<l-1; ++i){\\n            s1 -= nums[i];\\n            s2 += nums[i];\\n            if(s2>=s1){\\n                ++c;\\n            }\\n        }\\n        return c;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2133383,
                "title": "python-o-n-973ms-92-41-time-o-1-28-6mb-96-01-space",
                "content": "**Upvote if useful.**\\n```\\nclass Solution:\\n    def waysToSplitArray(self, nums: List[int]) -> int:\\n        # Similar: https://leetcode.com/problems/minimum-average-difference/\\n        size: int = len(nums)\\n        total: int = sum(nums)\\n        left_total: int = 0\\n        counter: int = 0\\n        for idx in range(0, size - 1):\\n            num = nums[idx]\\n            left_total += num\\n            total -= num\\n            if left_total >= total:\\n                counter += 1\\n        return counter\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution:\\n    def waysToSplitArray(self, nums: List[int]) -> int:\\n        # Similar: https://leetcode.com/problems/minimum-average-difference/\\n        size: int = len(nums)\\n        total: int = sum(nums)\\n        left_total: int = 0\\n        counter: int = 0\\n        for idx in range(0, size - 1):\\n            num = nums[idx]\\n            left_total += num\\n            total -= num\\n            if left_total >= total:\\n                counter += 1\\n        return counter\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2070021,
                "title": "java-simple-solution-beats-97",
                "content": "```\\nclass Solution {\\n    public int waysToSplitArray(int[] A) {\\n        long l = 0, r = 0, count = 0;\\n        long sum = 0;\\n        for (int n: A) sum += n;\\n        r = sum;\\n        for (int i = 0; i < A.length-1; i++) {\\n            l += A[i];\\n            r -= A[i];\\n            if (l >= r) count++;\\n        }    \\n        return (int)count;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int waysToSplitArray(int[] A) {\\n        long l = 0, r = 0, count = 0;\\n        long sum = 0;\\n        for (int n: A) sum += n;\\n        r = sum;\\n        for (int i = 0; i < A.length-1; i++) {\\n            l += A[i];\\n            r -= A[i];\\n            if (l >= r) count++;\\n        }    \\n        return (int)count;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2045792,
                "title": "using-prefix-sum-of-array",
                "content": "class Solution {\\npublic:\\n    int waysToSplitArray(vector<int>& nums) \\n    {\\n          int n=nums.size();\\n         long long int prefix[n+1];\\n        prefix[0]=nums[0];\\n        \\n        for(int i=1;i<n;i++)\\n        {\\n            prefix[i]=prefix[i-1]+nums[i];\\n        }\\n        // for(int i=0;i<n;i++)\\n        // {\\n        //     cout<<prefix[i];\\n        // }\\n        int cnt=0;\\n        for(int i=0;i<n-1;i++)\\n        {\\n           long long int sum=prefix[n-1]-prefix[i];\\n            if(prefix[i]>=sum)\\n                cnt++;\\n        }\\n        return cnt;\\n    }\\n};",
                "solutionTags": [],
                "code": "class Solution {\\npublic:\\n    int waysToSplitArray(vector<int>& nums) \\n    {\\n          int n=nums.size();\\n         long long int prefix[n+1];\\n        prefix[0]=nums[0];\\n        \\n        for(int i=1;i<n;i++)\\n        {\\n            prefix[i]=prefix[i-1]+nums[i];\\n        }",
                "codeTag": "Java"
            },
            {
                "id": 2042687,
                "title": "c-solution-easy-and-intuitive-solution",
                "content": "Crux of the problem:\\n* No need to compute the prefix and suffix sum everytime, add to the suffix and subtract from the prefix sum as you go\\n* The other thing is you have to take care of the datatypes. Can\\'t use int because it will overflow, can\\'t use unsigned int because the comparison will not be okay. Long long saves the day as always.\\n**Time complexity:**\\nO(N-1)=O(N) to compute the suffix sum\\nO(N-1)=O(N) to do the add/subtract operations as we go\\nOverall : O(N)\\n**Space complexity:**\\nO(1) since we use only 2 variables to store the sum. \\n```\\nclass Solution {\\npublic:\\n    int waysToSplitArray(vector<int>& nums) {\\n        int n = nums.size();\\n        long long int a =nums[0]; //prefix sum\\n        \\n        long long int b = 0;\\n        for (int i = 1 ;i<n;i++)\\n        {\\n            b += (long long)nums[i];  //suffix sum\\n        }\\n       \\n        int count = 0;\\n        for (int i = 1;i<n;i++)\\n        {\\n            if (a>=b)\\n                count++;\\n            \\n            a = a + (long long)nums[i];\\n            b = b - (long long)nums[i];\\n        }\\n        return count;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int waysToSplitArray(vector<int>& nums) {\\n        int n = nums.size();\\n        long long int a =nums[0]; //prefix sum\\n        \\n        long long int b = 0;\\n        for (int i = 1 ;i<n;i++)\\n        {\\n            b += (long long)nums[i];  //suffix sum\\n        }\\n       \\n        int count = 0;\\n        for (int i = 1;i<n;i++)\\n        {\\n            if (a>=b)\\n                count++;\\n            \\n            a = a + (long long)nums[i];\\n            b = b - (long long)nums[i];\\n        }\\n        return count;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2042685,
                "title": "c-prefix-sum",
                "content": "```\\nclass Solution {\\npublic:\\n    int waysToSplitArray(vector<int>& nums) {\\n        long long size = nums.size();\\n        vector<long long> res(size);\\n        res[0] = nums[0];\\n        for(int i=1;i<size;i++){ \\n\\t\\t\\tres[i]=res[i-1]+nums[i]; \\n\\t\\t}\\n        \\n        long long final = res[size-1];\\n        long long ans=0;\\n        for(int i=0;i<size-1;i++){\\n            if(res[i]>=final-res[i]){\\n                ans++;\\n            }\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    int waysToSplitArray(vector<int>& nums) {\\n        long long size = nums.size();\\n        vector<long long> res(size);\\n        res[0] = nums[0];\\n        for(int i=1;i<size;i++){ \\n\\t\\t\\tres[i]=res[i-1]+nums[i]; \\n\\t\\t}\\n        \\n        long long final = res[size-1];\\n        long long ans=0;\\n        for(int i=0;i<size-1;i++){\\n            if(res[i]>=final-res[i]){\\n                ans++;\\n            }\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2041914,
                "title": "go-idiomatic",
                "content": "The logic goes with maintaining the sum of the array and computing the sum of left and right subarrays using this sum, during each iteration.\\n\\n```\\nfunc waysToSplitArray(nums []int) int {\\n    \\n\\t\\n    total, sumL, sumR, ans := 0, 0, 0, 0\\n    \\n\\t//calculate sum and store in total\\n    for _, val := range nums {\\n        total += val\\n    }\\n    \\n    for i := 0; i < len(nums) - 1; i++ {\\n\\t\\t\\n\\t\\t//the following is the left and right subarray sum\\n        sumL += nums[i]\\n        sumR = total - sumL\\n        \\n\\t\\t//if the given constrain is satisfied increment answer\\n        if sumL >= sumR {\\n            ans++\\n        }\\n        \\n    }\\n    \\n    return ans\\n    \\n}\\n```",
                "solutionTags": [
                    "Go"
                ],
                "code": "```\\nfunc waysToSplitArray(nums []int) int {\\n    \\n\\t\\n    total, sumL, sumR, ans := 0, 0, 0, 0\\n    \\n\\t//calculate sum and store in total\\n    for _, val := range nums {\\n        total += val\\n    }\\n    \\n    for i := 0; i < len(nums) - 1; i++ {\\n\\t\\t\\n\\t\\t//the following is the left and right subarray sum\\n        sumL += nums[i]\\n        sumR = total - sumL\\n        \\n\\t\\t//if the given constrain is satisfied increment answer\\n        if sumL >= sumR {\\n            ans++\\n        }\\n        \\n    }\\n    \\n    return ans\\n    \\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2041101,
                "title": "python3",
                "content": "```\\nclass Solution:\\n    def waysToSplitArray(self, nums: List[int]) -> int:\\n        c=0\\n        s=[nums[0]]\\n        for i in range(1,len(nums)):\\n            s.append(nums[i]+s[-1])\\n        for i in range(len(s)-1):\\n            if s[i]>=s[-1]-s[i]:\\n                c+=1\\n        return c\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution:\\n    def waysToSplitArray(self, nums: List[int]) -> int:\\n        c=0\\n        s=[nums[0]]\\n        for i in range(1,len(nums)):\\n            s.append(nums[i]+s[-1])\\n        for i in range(len(s)-1):\\n            if s[i]>=s[-1]-s[i]:\\n                c+=1\\n        return c\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2040383,
                "title": "python-2-lines",
                "content": "calculate prefix sum and use the first condition.\\n\\n```\\nclass Solution:\\n    def waysToSplitArray(self, nums: List[int]) -> int:\\n        acc = list(accumulate(nums))\\n        return sum(acc[-1] <= 2*acc[i] for i in range(len(nums) - 1))\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution:\\n    def waysToSplitArray(self, nums: List[int]) -> int:\\n        acc = list(accumulate(nums))\\n        return sum(acc[-1] <= 2*acc[i] for i in range(len(nums) - 1))\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2040062,
                "title": "c-brute-force-o-n",
                "content": "...\\nclass Solution {\\npublic:\\n    int waysToSplitArray(vector<int>& nums) {\\n        \\n        int n = nums.size();\\n        \\n        int c = 0;                           // -> to COUNT number of WAYS\\n        long int sum = 0;              \\n        long int cs = 0;                 // -> current sum : will calculate sum as the array traverse;\\n        \\n        for(int i = 0; i<n; i++)       // -> for total sum\\n            sum = sum + nums[i];\\n\\t\\t\\t\\n// -> loop till SIZE-1, because if we take the last element then it will always                                                                  increase the count of number of ways.     \\ne.g [2,3,1,0]    : \\nIteration 1: cs < (sum of rest array) -> count = 0;\\nIteration 2: {2+3} > (sum of rest array) i.e (3+1)  -> count = 1;\\nIteration 3: {2+3+1} < (sum of rest array) i.e {0}  -> count = 2;\\nIteration 4: will NOT be executed -> { if it does then it will increment count , as  current sum (which is now total sum) >= total sum;\\n        \\n        for(int i = 0; i<n-1; i++)         \\n        {\\n            cs = cs + nums[i];                    // -> calculating current sum at every iteration\\n            \\n            if(cs >= (sum-cs))                  // -> checking if current sum >= sum of rest elements\\n                c++;\\n            \\n            \\n        }\\n        return c;\\n    }\\n};\\n...",
                "solutionTags": [
                    "C"
                ],
                "code": "class Solution {\\npublic:\\n    int waysToSplitArray(vector<int>& nums) {\\n        \\n        int n = nums.size();\\n        \\n        int c = 0;                           // -> to COUNT number of WAYS\\n        long int sum = 0;              \\n        long int cs = 0;                 // -> current sum : will calculate sum as the array traverse;\\n        \\n        for(int i = 0; i<n; i++)       // -> for total sum\\n            sum = sum + nums[i];\\n\\t\\t\\t\\n// -> loop till SIZE-1, because if we take the last element then it will always                                                                  increase the count of number of ways.     \\ne.g [2,3,1,0]    : \\nIteration 1: cs < (sum of rest array) -> count = 0;\\nIteration 2: {2+3}",
                "codeTag": "Java"
            },
            {
                "id": 2039076,
                "title": "easy-java-solution-using-prefix-and-suffix-sum-array",
                "content": "```\\nclass Solution {\\n    public int waysToSplitArray(int[] nums) {\\n        int count = 0;\\n        int n = nums.length;\\n        long[] prefix = new long[n];\\n        long[] suffix = new long[n];\\n        \\n        prefix[0] = nums[0];\\n        suffix[n - 1] = nums[n - 1];\\n        \\n        for(int i = 1; i < n; i++) {\\n            prefix[i] = prefix[i - 1] + nums[i];\\n        }\\n        \\n        for(int i = n - 2; i >= 0; i--) {\\n            suffix[i] = suffix[i + 1] + nums[i];\\n        }\\n        \\n        \\n        for(int i = 0; i < n - 1; i++) {\\n            if(prefix[i] >= suffix[i + 1] && i <= n - 1) {\\n                count++;\\n            }\\n        }\\n        return count;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Prefix Sum"
                ],
                "code": "```\\nclass Solution {\\n    public int waysToSplitArray(int[] nums) {\\n        int count = 0;\\n        int n = nums.length;\\n        long[] prefix = new long[n];\\n        long[] suffix = new long[n];\\n        \\n        prefix[0] = nums[0];\\n        suffix[n - 1] = nums[n - 1];\\n        \\n        for(int i = 1; i < n; i++) {\\n            prefix[i] = prefix[i - 1] + nums[i];\\n        }\\n        \\n        for(int i = n - 2; i >= 0; i--) {\\n            suffix[i] = suffix[i + 1] + nums[i];\\n        }\\n        \\n        \\n        for(int i = 0; i < n - 1; i++) {\\n            if(prefix[i] >= suffix[i + 1] && i <= n - 1) {\\n                count++;\\n            }\\n        }\\n        return count;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2038835,
                "title": "prefix-suffix-sum",
                "content": "```\\nclass Solution {\\npublic:\\n    int waysToSplitArray(vector<int>& nums) {\\n           int n=nums.size();\\n        vector< long long int> pre(n,0),suf(n,0);\\n        pre[0]=nums[0];\\n        suf[n-1]=nums[n-1];\\n        for(long long int i=1;i<n;i++){\\n            pre[i]=pre[i-1]+nums[i];\\n        }\\n        for(long long int i=n-2;i>=0;i--){\\n            suf[i]=suf[i+1]+nums[i];\\n        }\\n       int ans=0;\\n        for(long long int i=0;i<n-1;i++){\\n          long long int  left=pre[i];\\n            long long int  right=suf[i+1];\\n            if(left>=right){\\n                ans++;\\n            }\\n        }\\n        return ans;\\n        \\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Prefix Sum"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int waysToSplitArray(vector<int>& nums) {\\n           int n=nums.size();\\n        vector< long long int> pre(n,0),suf(n,0);\\n        pre[0]=nums[0];\\n        suf[n-1]=nums[n-1];\\n        for(long long int i=1;i<n;i++){\\n            pre[i]=pre[i-1]+nums[i];\\n        }\\n        for(long long int i=n-2;i>=0;i--){\\n            suf[i]=suf[i+1]+nums[i];\\n        }\\n       int ans=0;\\n        for(long long int i=0;i<n-1;i++){\\n          long long int  left=pre[i];\\n            long long int  right=suf[i+1];\\n            if(left>=right){\\n                ans++;\\n            }\\n        }\\n        return ans;\\n        \\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2038636,
                "title": "python-solution-o-n",
                "content": "```\\nclass Solution:\\n    def waysToSplitArray(self, nums: List[int]) -> int:\\n        c=0\\n        s=sum(nums)\\n        k=0\\n        for i in range(len(nums)-1):\\n            s=s-nums[i]\\n            c+=nums[i]\\n            if s<=c:\\n                k+=1\\n        return k\\n```\\n***Please Upvote if it helps.***",
                "solutionTags": [
                    "Python",
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def waysToSplitArray(self, nums: List[int]) -> int:\\n        c=0\\n        s=sum(nums)\\n        k=0\\n        for i in range(len(nums)-1):\\n            s=s-nums[i]\\n            c+=nums[i]\\n            if s<=c:\\n                k+=1\\n        return k\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2038525,
                "title": "using-prefix-sum-java-easy-to-understand",
                "content": "```\\nclass Solution {\\n    public int waysToSplitArray(int[] nums) {\\n         long totalSum = 0;\\n        for(int num: nums){\\n            totalSum += num;\\n        }\\n        long sumA = 0;\\n        int count = 0;\\n        for (int i = 0; i < nums.length-1; i++) {\\n            sumA += nums[i];\\n            if(sumA >= (totalSum-sumA))count++;\\n        }\\n        return count;\\n        \\n    }\\n}",
                "solutionTags": [
                    "Java",
                    "Prefix Sum"
                ],
                "code": "class Solution {\\n    public int waysToSplitArray(int[] nums) {\\n         long totalSum = 0;\\n        for(int num: nums){\\n            totalSum += num;\\n        }",
                "codeTag": "Java"
            },
            {
                "id": 2038440,
                "title": "c-detailed-and-easy-explanation-prefix-sum-tc-o-n-o-1",
                "content": "**GOAL**\\nFind total index position i in array such that:\\n1) Total sum till ith  index >= sum from i + 1 to N -> [N denote last index]\\n2) Index i should not be last index, it should be less than last index\\n\\n**Approach**\\n1) First find total sum of value in array, Note :: Total sum might get overflow so use Long long\\n2) Here we need to run a loop till N-1, for each index we will perform following:\\n* \\tAdd current index value to left sum (denote it as csum) \\n* \\tRight sum will be total sum - left sum\\n* \\tCheck if left sum >= right sum at Index i then increment answer\\n\\n\\nTime Complexity : O(N), We running single loop from 0 to N\\nSpace  Complexity : O(1) No extra space used here\\n```\\nclass Solution {\\n public:\\n  int waysToSplitArray(vector<int>& nums) {\\n    int n = nums.size();\\n    long long sum = 0;\\n\\n    // Calculating Total Sum\\n    for (int i = 0; i < n ; i++) {\\n      sum += nums[i];\\n    }\\n\\n    //Csum to store cummulative sum till ith index, and ans to store total ways to split array\\n    int ans = 0;\\n    long long int csum = 0;\\n\\n    for (int i = 0; i < n - 1; i++) {\\n      // find total sum till ith index\\n      csum += nums[i];\\n\\n      // check if csum till ith is greater than equal to remaining sum that is total - csum then increase ans by 1\\n      if (csum >= (sum - csum)) {\\n        ans += 1;\\n      }\\n    }\\n    return ans;\\n  }\\n};\\n```",
                "solutionTags": [
                    "C",
                    "Prefix Sum"
                ],
                "code": "```\\nclass Solution {\\n public:\\n  int waysToSplitArray(vector<int>& nums) {\\n    int n = nums.size();\\n    long long sum = 0;\\n\\n    // Calculating Total Sum\\n    for (int i = 0; i < n ; i++) {\\n      sum += nums[i];\\n    }\\n\\n    //Csum to store cummulative sum till ith index, and ans to store total ways to split array\\n    int ans = 0;\\n    long long int csum = 0;\\n\\n    for (int i = 0; i < n - 1; i++) {\\n      // find total sum till ith index\\n      csum += nums[i];\\n\\n      // check if csum till ith is greater than equal to remaining sum that is total - csum then increase ans by 1\\n      if (csum >= (sum - csum)) {\\n        ans += 1;\\n      }\\n    }\\n    return ans;\\n  }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2038365,
                "title": "c-solution-easy-and-clean-prefix-sum",
                "content": "Idea : Generating a array with prefix sum and satisfing the given condition \\n\\n```\\nclass Solution {\\npublic:\\n    int waysToSplitArray(vector<int>& nums) {\\n        vector<long long> prefixarr;\\n        long long temp = 0;\\n        long long sum = 0;\\n        for(int i =0;i<nums.size();i++){\\n            sum = sum +  nums[i];\\n            long long ans = temp+nums[i];\\n            prefixarr.push_back(ans);\\n            temp = temp+nums[i];\\n            \\n        }\\n        \\n        long long count = 0;\\n        \\n        for(int i = 0;i<nums.size()-1;i++){\\n            if(prefixarr[i] >= sum - prefixarr[i]){\\n                count++;\\n            }\\n        }\\n        return count;\\n        \\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    int waysToSplitArray(vector<int>& nums) {\\n        vector<long long> prefixarr;\\n        long long temp = 0;\\n        long long sum = 0;\\n        for(int i =0;i<nums.size();i++){\\n            sum = sum +  nums[i];\\n            long long ans = temp+nums[i];\\n            prefixarr.push_back(ans);\\n            temp = temp+nums[i];\\n            \\n        }\\n        \\n        long long count = 0;\\n        \\n        for(int i = 0;i<nums.size()-1;i++){\\n            if(prefixarr[i] >= sum - prefixarr[i]){\\n                count++;\\n            }\\n        }\\n        return count;\\n        \\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2038326,
                "title": "c-very-simple-solution",
                "content": "```\\nclass Solution {\\npublic:\\n    int waysToSplitArray(vector<int>& nums) {\\n        \\n       int len = nums.size();\\n        \\n        long sum = 0;\\n        for(int i=0; i<len; i++){\\n            sum = sum + nums[i];\\n        }\\n        long curr = 0;\\n        int ans = 0;\\n        for(int i=0; i<=len-2; i++){\\n            curr = curr + nums[i];\\n            if(curr >= sum - curr){\\n                ans++;\\n            }\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    int waysToSplitArray(vector<int>& nums) {\\n        \\n       int len = nums.size();\\n        \\n        long sum = 0;\\n        for(int i=0; i<len; i++){\\n            sum = sum + nums[i];\\n        }\\n        long curr = 0;\\n        int ans = 0;\\n        for(int i=0; i<=len-2; i++){\\n            curr = curr + nums[i];\\n            if(curr >= sum - curr){\\n                ans++;\\n            }\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2038271,
                "title": "python-o-n-prefix-sum-left-and-right-windows",
                "content": "Imagine we have two windows\\n \\n|-|...|------|\\n[10,4,-8,7]\\n\\n\\t\\t \\nSum of the left window = 10\\nSum of right window =  3\\n\\nSince LeftWindow >= RightWindow, we can split at position 0.\\n\\nWe then try to increase the window of left by adding 4 and decrease 4 from right.\\n\\n|-----|..|---|\\n[10,4,-8,7]\\n\\nSum of the left window = 10 + 4 = 14\\nSum of right window =  3 - 4 = -1\\n\\nIt is also a valid split.\\n\\nRepeat this until the before-last element of the array. (n-2 position).\\n\\nTime Complexity: O(n)\\nSpace Complexity: O(1)\\n\\n```\\nclass Solution:\\n    def waysToSplitArray(self, nums: List[int]) -> int:\\n        n = len(nums)\\n        left_window_sum = nums[0]\\n        right_window_sum = sum(nums[1:])\\n        \\n        count = 0\\n        split_pos = 0\\n\\n        while split_pos <= n-2:\\n            if left_window_sum >= right_window_sum:\\n                count += 1\\n            \\n            split_pos += 1\\n            left_window_sum += nums[split_pos]\\n            right_window_sum -= nums[split_pos]\\n            \\n        return count\\n```",
                "solutionTags": [
                    "Python3",
                    "Prefix Sum"
                ],
                "code": "```\\nclass Solution:\\n    def waysToSplitArray(self, nums: List[int]) -> int:\\n        n = len(nums)\\n        left_window_sum = nums[0]\\n        right_window_sum = sum(nums[1:])\\n        \\n        count = 0\\n        split_pos = 0\\n\\n        while split_pos <= n-2:\\n            if left_window_sum >= right_window_sum:\\n                count += 1\\n            \\n            split_pos += 1\\n            left_window_sum += nums[split_pos]\\n            right_window_sum -= nums[split_pos]\\n            \\n        return count\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2038230,
                "title": "javascript-solution-o-n",
                "content": "Keep a count of the left and right part.\\n\\nWhen looping through the array, simply remove the current number from the left group and add it to the right group.\\n```js\\n/**\\n * @param {number[]} nums\\n * @return {number}\\n */\\nvar waysToSplitArray = function(nums) {\\n    let left = nums[0]\\n    let right = nums.slice(1).reduce((acc, cur) => acc + cur, 0)\\n\\t\\n    let count = 0\\n    if (left >= right) count++\\n\\n    for (let i = 1; i < nums.length - 1; i++) {\\n        left += nums[i]\\n        right -= nums[i]\\n        if (left >= right) count++\\n    }\\n    return c\\n};\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```js\\n/**\\n * @param {number[]} nums\\n * @return {number}\\n */\\nvar waysToSplitArray = function(nums) {\\n    let left = nums[0]\\n    let right = nums.slice(1).reduce((acc, cur) => acc + cur, 0)\\n\\t\\n    let count = 0\\n    if (left >= right) count++\\n\\n    for (let i = 1; i < nums.length - 1; i++) {\\n        left += nums[i]\\n        right -= nums[i]\\n        if (left >= right) count++\\n    }\\n    return c\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2038168,
                "title": "cpp-always-use-long-long-int",
                "content": "```\\nclass Solution {\\npublic:\\n    int waysToSplitArray(vector<int>& nums) {\\n        long long int prefix[nums.size()];\\n        prefix[0] = nums[0];\\n        for(int i=1;i<nums.size();i++){\\n            prefix[i] = prefix[i-1] + nums[i];\\n        }\\n        \\n        int ans = 0;\\n        \\n        for(int i=0;i<nums.size()-1;i++){\\n            if(prefix[i] >= prefix[nums.size()-1] - prefix[i]) ans++;\\n        }\\n        \\n        return ans;\\n        \\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    int waysToSplitArray(vector<int>& nums) {\\n        long long int prefix[nums.size()];\\n        prefix[0] = nums[0];\\n        for(int i=1;i<nums.size();i++){\\n            prefix[i] = prefix[i-1] + nums[i];\\n        }\\n        \\n        int ans = 0;\\n        \\n        for(int i=0;i<nums.size()-1;i++){\\n            if(prefix[i] >= prefix[nums.size()-1] - prefix[i]) ans++;\\n        }\\n        \\n        return ans;\\n        \\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2038141,
                "title": "easy-c-solution",
                "content": "```\\n    int waysToSplitArray(vector<int>& nums) {\\n        int count=0,n=nums.size();\\n        long long int sum=0;\\n        for(int i=0;i<n;i++){\\n            sum+=nums[i];\\n        }\\n        long long int f=0,s=sum;\\n        for(int i=0;i<n-1;i++){\\n            f+=nums[i];\\n            s-=nums[i];\\n            if(f>=s){\\n                count++;\\n            }\\n        }\\n        return count;\\n    }\\n};\\n```",
                "solutionTags": [
                    "Prefix Sum"
                ],
                "code": "```\\n    int waysToSplitArray(vector<int>& nums) {\\n        int count=0,n=nums.size();\\n        long long int sum=0;\\n        for(int i=0;i<n;i++){\\n            sum+=nums[i];\\n        }\\n        long long int f=0,s=sum;\\n        for(int i=0;i<n-1;i++){\\n            f+=nums[i];\\n            s-=nums[i];\\n            if(f>=s){\\n                count++;\\n            }\\n        }\\n        return count;\\n    }\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2038138,
                "title": "easy-c-solution",
                "content": "```\\nclass Solution {\\npublic:\\n    int waysToSplitArray(vector<int>& nums) {\\n        int n = nums.size();\\n        long sum = 0;\\n        for(int i=0;i<n;i++){\\n            sum += nums[i];\\n        }\\n        int ans = 0;\\n        long curr = 0;\\n        for(int i=0;i<n-1;i++){\\n            curr+=nums[i];\\n            if(curr>= (sum - curr))\\n                ans++;\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int waysToSplitArray(vector<int>& nums) {\\n        int n = nums.size();\\n        long sum = 0;\\n        for(int i=0;i<n;i++){\\n            sum += nums[i];\\n        }\\n        int ans = 0;\\n        long curr = 0;\\n        for(int i=0;i<n-1;i++){\\n            curr+=nums[i];\\n            if(curr>= (sum - curr))\\n                ans++;\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2038119,
                "title": "easy-java-solution-o-n-time-complexity",
                "content": "class Solution {\\n    public int waysToSplitArray(int[] nums) {\\n        double sum=0;\\n        int res=0;\\n        for(int i=0; i<nums.length; i++)\\n        {\\n            sum+=nums[i];\\n        }\\n\\n        double lastSum=0;\\n        double firstSum=0;\\n\\n        for(int i=0; i<nums.length-1; i++)\\n        {\\n            firstSum+=nums[i];\\n            lastSum=sum-firstSum;\\n            if(firstSum>=lastSum)\\n                res++;\\n        }\\n        return res;\\n    }\\n}",
                "solutionTags": [
                    "Java"
                ],
                "code": "class Solution {\\n    public int waysToSplitArray(int[] nums) {\\n        double sum=0;\\n        int res=0;\\n        for(int i=0; i<nums.length; i++)\\n        {\\n            sum+=nums[i];\\n        }",
                "codeTag": "Java"
            },
            {
                "id": 2038107,
                "title": "python-its-just-prefix-sum",
                "content": "```\\nclass Solution:\\n    def waysToSplitArray(self, nums: List[int]) -> int:\\n        \\n        array = list(accumulate(nums, operator.add))\\n        count=0\\n        end = array[-1]\\n        for i in range (len(array)-1):\\n            \\n            left = array[i]-0\\n            right = end - array[i]\\n            \\n            if left >= right: count+=1\\n                \\n        return count\\n```",
                "solutionTags": [
                    "Python",
                    "Python3",
                    "Prefix Sum"
                ],
                "code": "```\\nclass Solution:\\n    def waysToSplitArray(self, nums: List[int]) -> int:\\n        \\n        array = list(accumulate(nums, operator.add))\\n        count=0\\n        end = array[-1]\\n        for i in range (len(array)-1):\\n            \\n            left = array[i]-0\\n            right = end - array[i]\\n            \\n            if left >= right: count+=1\\n                \\n        return count\\n```",
                "codeTag": "Java"
            },
            {
                "id": 4092230,
                "title": "easy-c-solution-beginner-s-friendly-full-explanation",
                "content": "\\n\\n# Complexity\\n- Time complexity:\\nO(n)\\n\\n- Space complexity:\\nO(1)\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int waysToSplitArray(vector<int>& nums) {\\n    long long int sumL=0;\\n    long long int Tsum=0;\\n    long long int count=0;\\n\\n    for(int i=0;i<nums.size();i++){\\n            Tsum+=nums[i];           //total sum\\n    }\\n    for(int i=0;i<nums.size()-1;i++){\\n        sumL+=nums[i];              //Leftsum \\n        Rsum=Tsum-nums[i];          //Rightsum=Total sum-Nums[i]\\n        if(sumL>=Rsum){\\n            count++;\\n        }\\n    }\\n    return count;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int waysToSplitArray(vector<int>& nums) {\\n    long long int sumL=0;\\n    long long int Tsum=0;\\n    long long int count=0;\\n\\n    for(int i=0;i<nums.size();i++){\\n            Tsum+=nums[i];           //total sum\\n    }\\n    for(int i=0;i<nums.size()-1;i++){\\n        sumL+=nums[i];              //Leftsum \\n        Rsum=Tsum-nums[i];          //Rightsum=Total sum-Nums[i]\\n        if(sumL>=Rsum){\\n            count++;\\n        }\\n    }\\n    return count;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 4083314,
                "title": "83ms-runtime-and-59-56mb-memory-solution",
                "content": "# Approach\\nWe can simply calculate the sums from both the left and right side and compare them at every index. For slight optimization, we do not need to calculate the very last index of leftSums (because we must have at least one element to the right) nor the first index of rightSums (because we must start with splitting it at index 0). \\n\\n# Complexity\\n- Time complexity: We have a while loop going over the original array and then a for loop iterating over an array of essentially the same length; therefore, our time complexity is O(3n) for a final complexity of O(n). \\n\\n- Space complexity: We are creating two new array data structures of same length as our original array; therefore, our space complexity is O(2n) for a final complexity of O(n).\\n\\n# Code\\n```\\n/**\\n * @param {number[]} nums\\n * @return {number}\\n */\\nvar waysToSplitArray = function(nums) {\\n\\n    if(nums.length == 2){\\n        return nums[0] >= nums[1] ? 1 : 0 \\n    }\\n\\n    let leftSums = new Array(nums.length - 1);\\n    let rightSums = new Array(nums.length - 1);\\n\\n    let lo = 0;\\n    let hi = nums.length - 1;\\n\\n    let leftSum = 0;\\n    let rightSum = 0;\\n\\n    let ans = 0;\\n\\n    while(lo < nums.length - 1){\\n        leftSum += nums[lo]\\n        rightSum += nums[hi]\\n\\n        leftSums[lo] = leftSum\\n        rightSums[hi - 1] = rightSum\\n\\n        lo ++\\n        hi --\\n    }\\n\\n    for(let i = 0; i < leftSums.length; i++){\\n        if(leftSums[i] >= rightSums[i]){\\n            ans++\\n        }\\n    }\\n\\n    return ans\\n};\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\n/**\\n * @param {number[]} nums\\n * @return {number}\\n */\\nvar waysToSplitArray = function(nums) {\\n\\n    if(nums.length == 2){\\n        return nums[0] >= nums[1] ? 1 : 0 \\n    }\\n\\n    let leftSums = new Array(nums.length - 1);\\n    let rightSums = new Array(nums.length - 1);\\n\\n    let lo = 0;\\n    let hi = nums.length - 1;\\n\\n    let leftSum = 0;\\n    let rightSum = 0;\\n\\n    let ans = 0;\\n\\n    while(lo < nums.length - 1){\\n        leftSum += nums[lo]\\n        rightSum += nums[hi]\\n\\n        leftSums[lo] = leftSum\\n        rightSums[hi - 1] = rightSum\\n\\n        lo ++\\n        hi --\\n    }\\n\\n    for(let i = 0; i < leftSums.length; i++){\\n        if(leftSums[i] >= rightSums[i]){\\n            ans++\\n        }\\n    }\\n\\n    return ans\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 4051331,
                "title": "easy-c-solution",
                "content": "# Intuition\\nwe will use the prefix sum approach here.\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\nWe will have to use extra long long array to overcome the overflow otherwise it could be in O(1) also.\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity: O(N)\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: O(N)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int waysToSplitArray(vector<int>& nums) {\\n        int i,n=nums.size(),cnt=0,cntz=0;\\n        vector<long long int> arr;\\n       \\n        for(auto x: nums) arr.push_back(x);\\n     \\n        for(i=1;i<n;i++){\\n            \\n            arr[i]+=arr[i-1];\\n        }\\n        for(i=0;i<n-1;i++){\\n            if(arr[i]>=arr[n-1]-arr[i]) cnt++;\\n        }\\n\\n\\n\\n        return cnt;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int waysToSplitArray(vector<int>& nums) {\\n        int i,n=nums.size(),cnt=0,cntz=0;\\n        vector<long long int> arr;\\n       \\n        for(auto x: nums) arr.push_back(x);\\n     \\n        for(i=1;i<n;i++){\\n            \\n            arr[i]+=arr[i-1];\\n        }\\n        for(i=0;i<n-1;i++){\\n            if(arr[i]>=arr[n-1]-arr[i]) cnt++;\\n        }\\n\\n\\n\\n        return cnt;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 4035385,
                "title": "2270-number-of-ways-to-split-array",
                "content": "# Intuition\\nPrefix Sum\\n\\n# Approach\\n1. Calculate the sum of all the values and store it in var sum.\\n2. Calculate sum of each value + prefix value and store it in sumLeft and compare with sum-sumLeft \\n3. if sum is higher, increment count\\n\\n# Complexity\\n- Time complexity:\\no(n)\\n\\n- Space complexity:\\no(1)\\n\\n# Code\\nApproach:1\\n```\\nclass Solution {\\npublic int waysToSplitArray(int[] nums) {\\n        if(nums.length<1) return 0;\\n        long[] prefix = new long[nums.length];\\n        prefix[0]=nums[0];\\n        int count = 0;\\n        long sum = nums[0];\\n\\n        for (int i = 1; i < nums.length; i++) {\\n            prefix[i] = prefix[i - 1] + nums[i];\\n            sum = sum + nums[i];\\n        }\\n\\n        for(int j=0; j<nums.length-1; j++){\\n            if(prefix[j]>=sum-prefix[j]){\\n                count++;\\n            }\\n        }\\n        return count;\\n    }\\n}\\n```\\n\\nApproach 2: \\nclass Solution {\\npublic int waysToSplitArray(int[] nums) {\\n        if(nums.length<1) return 0;\\n        int count = 0;\\n        long sum = 0;\\n        long prefixsumLeft = 0;\\n\\n        for (int i : nums) {\\n            sum += i;\\n        }\\n\\n        for(int j=0; j<nums.length-1; j++){\\n            prefixsumLeft += nums[j];\\n            if(prefixsumLeft>=(sum-prefixsumLeft)){\\n                count++;\\n            }\\n        }\\n        return count;\\n    }\\n}",
                "solutionTags": [
                    "Java",
                    "Array",
                    "Prefix Sum"
                ],
                "code": "```\\nclass Solution {\\npublic int waysToSplitArray(int[] nums) {\\n        if(nums.length<1) return 0;\\n        long[] prefix = new long[nums.length];\\n        prefix[0]=nums[0];\\n        int count = 0;\\n        long sum = nums[0];\\n\\n        for (int i = 1; i < nums.length; i++) {\\n            prefix[i] = prefix[i - 1] + nums[i];\\n            sum = sum + nums[i];\\n        }\\n\\n        for(int j=0; j<nums.length-1; j++){\\n            if(prefix[j]>=sum-prefix[j]){\\n                count++;\\n            }\\n        }\\n        return count;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 4026446,
                "title": "c-explanation-o-1-space-and-o-n-runtime-running-sum",
                "content": "# Approach\\n\\nAt each $i$th step the left sum is just the sum of `nums[0..i]` inclusively. So as we process each $i$ we can simply add it up to the left side as we go, and thus at each step just have the whole left sum handy at `O(1)`.\\n\\nIt works similarly for the right sum, except that we start with the sum `nums[i+1..n]` and decrease this sum at each step.\\n\\nI tagged the answer with `Prefix Sum` because as of writing the words there\\'s no tag `Running Sum`, however a prefix sum can easily degrade to a running sum in many problems including this one, so I presume the tag is suitable. \\n\\n# Complexity\\n- Time complexity: $$O(n)$$\\n- Space complexity: $$O(1)$$\\n\\n# Code\\n```c++\\nclass Solution {\\npublic:\\n    int waysToSplitArray(const vector<int>& nums) {\\n        ssize_t left = 0, right = accumulate(nums.begin(), nums.end(), ssize_t(0));\\n        int n_splits = 0;\\n        for (size_t i = 0; i < nums.size() - 1; ++i) {\\n            left  += nums[i];\\n            right -= nums[i];\\n            if (left >= right)\\n                n_splits++;\\n        }\\n        return n_splits;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Prefix Sum"
                ],
                "code": "```c++\\nclass Solution {\\npublic:\\n    int waysToSplitArray(const vector<int>& nums) {\\n        ssize_t left = 0, right = accumulate(nums.begin(), nums.end(), ssize_t(0));\\n        int n_splits = 0;\\n        for (size_t i = 0; i < nums.size() - 1; ++i) {\\n            left  += nums[i];\\n            right -= nums[i];\\n            if (left >= right)\\n                n_splits++;\\n        }\\n        return n_splits;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3979829,
                "title": "c-simple-prefix-sum",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int waysToSplitArray(vector<int>& nums) {\\n        int ct=0;\\n        int sz=nums.size();\\n        vector<long long >pref(sz,0);\\n        for(int i=0;i<sz;i++)\\n         {\\n           if(i==0)\\n           pref[0]=nums[0];\\n           else\\n           pref[i]=pref[i-1]+nums[i];\\n         }\\n      for(int i=0;i<sz-1;i++)\\n         {\\n           //left sum\\n           long long  lsum=0,rsum=0;\\n           lsum=pref[i];\\n           rsum=pref[sz-1]-pref[i];\\n          //  for(int j=0;j<=i;j++)\\n          //  lsum+=nums[j];\\n          //  for(int j=i+1;j<sz;j++)\\n          //  rsum+=nums[j];\\n           if(lsum>=rsum)\\n             ct++;\\n           \\n         }\\n          \\n         return ct;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Prefix Sum"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int waysToSplitArray(vector<int>& nums) {\\n        int ct=0;\\n        int sz=nums.size();\\n        vector<long long >pref(sz,0);\\n        for(int i=0;i<sz;i++)\\n         {\\n           if(i==0)\\n           pref[0]=nums[0];\\n           else\\n           pref[i]=pref[i-1]+nums[i];\\n         }\\n      for(int i=0;i<sz-1;i++)\\n         {\\n           //left sum\\n           long long  lsum=0,rsum=0;\\n           lsum=pref[i];\\n           rsum=pref[sz-1]-pref[i];\\n          //  for(int j=0;j<=i;j++)\\n          //  lsum+=nums[j];\\n          //  for(int j=i+1;j<sz;j++)\\n          //  rsum+=nums[j];\\n           if(lsum>=rsum)\\n             ct++;\\n           \\n         }\\n          \\n         return ct;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3979195,
                "title": "prefix-sum-linear-time-and-space-3ms",
                "content": "# Complexity\\n- Time complexity:\\nO(n)\\n\\n- Space complexity:\\nO(n)\\n\\n# Code\\n```\\nclass Solution {\\n  public int waysToSplitArray(int[] nums) {\\n    long[] psum = new long[nums.length];\\n\\n    for (int i = 0; i < nums.length; i++) {\\n      psum[i] = nums[i] + (i > 0 ? psum[i - 1] : 0);\\n    }\\n\\n    int countWays = 0;\\n\\n    int i = 0;\\n    while (i < nums.length - 1) {\\n      if (psum[i] >= psum[nums.length - 1] - psum[i++]) {\\n        countWays++;\\n      }\\n    }\\n\\n    return countWays;\\n  }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Prefix Sum"
                ],
                "code": "```\\nclass Solution {\\n  public int waysToSplitArray(int[] nums) {\\n    long[] psum = new long[nums.length];\\n\\n    for (int i = 0; i < nums.length; i++) {\\n      psum[i] = nums[i] + (i > 0 ? psum[i - 1] : 0);\\n    }\\n\\n    int countWays = 0;\\n\\n    int i = 0;\\n    while (i < nums.length - 1) {\\n      if (psum[i] >= psum[nums.length - 1] - psum[i++]) {\\n        countWays++;\\n      }\\n    }\\n\\n    return countWays;\\n  }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3973771,
                "title": "simple-prefix-sum-solution-o-n",
                "content": "\\n# Code\\n```\\nclass Solution {\\n    public int waysToSplitArray(int[] nums) {\\n        int length = nums.length;\\n        long[] prefix = new long[nums.length];\\n        prefix[0] = nums[0];\\n        for (int i = 1; i < length; i++) {\\n            prefix[i] = prefix[i - 1] + nums[i];\\n        }\\n\\n        int count = 0;\\n        for (int j = 0; j < length - 1; j++) {\\n            if (prefix[j] >= prefix[length - 1] - prefix[j])\\n                count++;\\n        }\\n        return count;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int waysToSplitArray(int[] nums) {\\n        int length = nums.length;\\n        long[] prefix = new long[nums.length];\\n        prefix[0] = nums[0];\\n        for (int i = 1; i < length; i++) {\\n            prefix[i] = prefix[i - 1] + nums[i];\\n        }\\n\\n        int count = 0;\\n        for (int j = 0; j < length - 1; j++) {\\n            if (prefix[j] >= prefix[length - 1] - prefix[j])\\n                count++;\\n        }\\n        return count;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3972277,
                "title": "c-whilst-using-prefix-sum",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int waysToSplitArray(vector<int>& nums) {\\n        \\n        if (nums.size() <= 1)\\n            return 0;\\n\\n        vector<long> sum(nums.begin(), nums.end());\\n        for (int i = 1; i < nums.size(); ++i)\\n        {\\n            sum[i] += sum[i - 1];\\n        }\\n\\n        vector<long> rSum(nums.begin(), nums.end());\\n        for (int i = nums.size() - 2; i > 0; --i)\\n        {\\n            rSum[i] += rSum[i + 1];\\n        }\\n        \\n        int res = 0;\\n        for(int i = 0; i < nums.size() - 1; ++i)\\n        {\\n            res += sum[i] >= rSum[i+1];\\n        }\\n\\n        return res;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int waysToSplitArray(vector<int>& nums) {\\n        \\n        if (nums.size() <= 1)\\n            return 0;\\n\\n        vector<long> sum(nums.begin(), nums.end());\\n        for (int i = 1; i < nums.size(); ++i)\\n        {\\n            sum[i] += sum[i - 1];\\n        }\\n\\n        vector<long> rSum(nums.begin(), nums.end());\\n        for (int i = nums.size() - 2; i > 0; --i)\\n        {\\n            rSum[i] += rSum[i + 1];\\n        }\\n        \\n        int res = 0;\\n        for(int i = 0; i < nums.size() - 1; ++i)\\n        {\\n            res += sum[i] >= rSum[i+1];\\n        }\\n\\n        return res;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3928300,
                "title": "java-solution-with-o-n",
                "content": "# Intuition\\nleft sum and right sum\\n\\n# Approach\\ncalculating left and right sum while first calculate the whole array sum and then approach the question\\n\\n# Complexity\\n- Time complexity:\\nO(n)\\n\\n- Space complexity:\\nO(n)\\n\\n# Code\\n```\\nclass Solution {\\n    public int waysToSplitArray(int[] nums) {\\n        long sum=0;int count=0;int i;\\n        for(i=0;i<nums.length;i++)\\n        sum=sum+nums[i];\\n        long temp=sum;\\n        long kemp=0;\\n        // System.out.println(\"sum \"+temp);\\n        for(i=0;i<nums.length-1;i++)\\n        {\\n            temp=temp-nums[i];\\n            kemp=kemp+nums[i];\\n            if(kemp>=temp)\\n            count++;\\n        }\\n        return count;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int waysToSplitArray(int[] nums) {\\n        long sum=0;int count=0;int i;\\n        for(i=0;i<nums.length;i++)\\n        sum=sum+nums[i];\\n        long temp=sum;\\n        long kemp=0;\\n        // System.out.println(\"sum \"+temp);\\n        for(i=0;i<nums.length-1;i++)\\n        {\\n            temp=temp-nums[i];\\n            kemp=kemp+nums[i];\\n            if(kemp>=temp)\\n            count++;\\n        }\\n        return count;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3917667,
                "title": "simple-sliding-window-approach",
                "content": "# Code\\n```\\nclass Solution {\\npublic:\\n    int waysToSplitArray(vector<int>& nums) {\\n        long long sum=0;\\n\\n        for(int i=0;i<nums.size();i++)\\n            sum=sum+nums[i];\\n\\n        long long sum1=0,count=0;\\n        for(int i=0;i<nums.size()-1;i++)\\n        {\\n            sum1=sum1+nums[i];\\n            sum=sum-nums[i];\\n\\n            if(sum1>=sum)\\n                count++;\\n        }\\n\\n        return count;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int waysToSplitArray(vector<int>& nums) {\\n        long long sum=0;\\n\\n        for(int i=0;i<nums.size();i++)\\n            sum=sum+nums[i];\\n\\n        long long sum1=0,count=0;\\n        for(int i=0;i<nums.size()-1;i++)\\n        {\\n            sum1=sum1+nums[i];\\n            sum=sum-nums[i];\\n\\n            if(sum1>=sum)\\n                count++;\\n        }\\n\\n        return count;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3899579,
                "title": "2ms-100-solution-java",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\ncheck the sum of elemets left to i+1 and right to i;\\n\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\nAdd nums[i] after each iteration in loop and subtract nums[i] from sum each time.\\nCompare left sum to right sum and increment the answer each time the condition hits true.\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\nO(n)\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\nO(3)\\n\\n# Code\\n```\\nclass Solution {\\n    public int waysToSplitArray(int[] nums) {\\n        long sum1 = 0;\\n        long sum2 = nums[0];\\n        int ans = 0;\\n        for(int i =1;nums.length>i;i++){\\n            sum1 += nums[i];\\n        }\\n        for(int i = 0;nums.length-1>i;i++){\\n            \\n            if(sum2>=sum1)ans++;\\n            sum2 += nums[i+1];\\n            sum1 -= nums[i+1];\\n        }\\n        return ans;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Array"
                ],
                "code": "```\\nclass Solution {\\n    public int waysToSplitArray(int[] nums) {\\n        long sum1 = 0;\\n        long sum2 = nums[0];\\n        int ans = 0;\\n        for(int i =1;nums.length>i;i++){\\n            sum1 += nums[i];\\n        }\\n        for(int i = 0;nums.length-1>i;i++){\\n            \\n            if(sum2>=sum1)ans++;\\n            sum2 += nums[i+1];\\n            sum1 -= nums[i+1];\\n        }\\n        return ans;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3882983,
                "title": "c-prefix-sum-easy-to-understand",
                "content": "```\\nclass Solution {\\npublic:\\n    int waysToSplitArray(vector<int>& numx) {\\n        vector<long long int> nums;\\n        for(auto x : numx)\\n        {\\n            nums.push_back(x);\\n        }\\n        long long int sum = 0;\\n        int ans = 0;\\n        int n = nums.size();\\n        for(auto x : nums)\\n        {\\n            sum += x;\\n        }\\n        if(nums[0] >= sum-nums[0])\\n        {\\n            ans++;\\n        }\\n        for(int i = 1 ; i < n-1 ; i++)\\n        {\\n            nums[i] += nums[i-1];\\n            if(nums[i] >= sum-nums[i])\\n            {\\n                ans++;\\n            }\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "C",
                    "Array",
                    "Prefix Sum"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int waysToSplitArray(vector<int>& numx) {\\n        vector<long long int> nums;\\n        for(auto x : numx)\\n        {\\n            nums.push_back(x);\\n        }\\n        long long int sum = 0;\\n        int ans = 0;\\n        int n = nums.size();\\n        for(auto x : nums)\\n        {\\n            sum += x;\\n        }\\n        if(nums[0] >= sum-nums[0])\\n        {\\n            ans++;\\n        }\\n        for(int i = 1 ; i < n-1 ; i++)\\n        {\\n            nums[i] += nums[i-1];\\n            if(nums[i] >= sum-nums[i])\\n            {\\n                ans++;\\n            }\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3874500,
                "title": "prefix-sum-100-runtime",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. --> \\n     Prefix Sum\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n     O(n)\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n     O(1)\\n\\n# Code\\n```\\nclass Solution {\\n    public int waysToSplitArray(int[] nums) {\\n        long sum=0;\\n        for(int i:nums){\\n            sum+=i;\\n        }\\n        long sumL=0,sumR=0;\\n        int count=0;\\n        for(int i=0;i<nums.length-1;i++){\\n            sumL+=nums[i];\\n            sumR=sum-sumL;\\n\\n            if(sumL>=sumR){\\n               count++;\\n            }\\n        }\\n        return count;\\n     }\\n}\\n```\\n**Pls upvote if u like it**",
                "solutionTags": [
                    "Java",
                    "Array",
                    "Prefix Sum"
                ],
                "code": "```\\nclass Solution {\\n    public int waysToSplitArray(int[] nums) {\\n        long sum=0;\\n        for(int i:nums){\\n            sum+=i;\\n        }\\n        long sumL=0,sumR=0;\\n        int count=0;\\n        for(int i=0;i<nums.length-1;i++){\\n            sumL+=nums[i];\\n            sumR=sum-sumL;\\n\\n            if(sumL>=sumR){\\n               count++;\\n            }\\n        }\\n        return count;\\n     }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3867165,
                "title": "java-two-traversal-of-array-2ms-execution-time-100-beat-runtime",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\n    public int waysToSplitArray(int[] nums) {\\n        int n=nums.length;\\n        long sum = Long.valueOf(0);\\n        for (int i = 0; i<n; i++){\\n            sum += nums[i];\\n        }\\n\\n        long sumSoFar = Long.valueOf(0);\\n        int validCnt = 0;\\n        for(int i=0; i<n-1; i++){\\n            sumSoFar += nums[i];\\n            sum -= nums[i];\\n            if (sumSoFar >= sum){\\n                validCnt++;\\n            }\\n        }\\n        return validCnt;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int waysToSplitArray(int[] nums) {\\n        int n=nums.length;\\n        long sum = Long.valueOf(0);\\n        for (int i = 0; i<n; i++){\\n            sum += nums[i];\\n        }\\n\\n        long sumSoFar = Long.valueOf(0);\\n        int validCnt = 0;\\n        for(int i=0; i<n-1; i++){\\n            sumSoFar += nums[i];\\n            sum -= nums[i];\\n            if (sumSoFar >= sum){\\n                validCnt++;\\n            }\\n        }\\n        return validCnt;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3857531,
                "title": "simple-prefixsum-easy-c-code-easy-to-understand",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int waysToSplitArray(vector<int>& nums) {\\n        long long n = nums.size()-1;\\n        vector<long long >prefix(n+1,0);\\n        vector<long long >suffix(n+1,0);\\n        prefix[0]=nums[0];\\n        suffix[n]=nums[n];\\n        long long cnt=0;\\n        for(int i = 1 ; i < n+1 ; i++){\\n            prefix[i]=prefix[i-1]+nums[i];\\n        }\\n        for(int i = n-1 ; i >= 0 ; i--){\\n            suffix[i]=suffix[i+1]+nums[i];\\n        }\\n        for(int i = 0 ; i < n ; i++){\\n            if(prefix[i] >= suffix[i+1] ){\\n                cnt++;\\n            }\\n        }\\n        return cnt;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Array",
                    "Math",
                    "Prefix Sum"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int waysToSplitArray(vector<int>& nums) {\\n        long long n = nums.size()-1;\\n        vector<long long >prefix(n+1,0);\\n        vector<long long >suffix(n+1,0);\\n        prefix[0]=nums[0];\\n        suffix[n]=nums[n];\\n        long long cnt=0;\\n        for(int i = 1 ; i < n+1 ; i++){\\n            prefix[i]=prefix[i-1]+nums[i];\\n        }\\n        for(int i = n-1 ; i >= 0 ; i--){\\n            suffix[i]=suffix[i+1]+nums[i];\\n        }\\n        for(int i = 0 ; i < n ; i++){\\n            if(prefix[i] >= suffix[i+1] ){\\n                cnt++;\\n            }\\n        }\\n        return cnt;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3845736,
                "title": "kotlin-prefix-sum",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\n    fun waysToSplitArray(nums: IntArray): Int {\\n        \\n        return withoutArray(nums)\\n        // return withArray(nums)\\n    }\\n\\n\\n    //-----Without Array-----\\n    private fun withoutArray(nums: IntArray): Int {\\n\\n        // Build the prefix sum\\n        var total = 0L\\n        for(num in nums){\\n            total += num.toLong()\\n        }\\n\\n        // Perform the logic\\n        var ans = 0\\n        var leftSide = 0L\\n        for(i in 0 until nums.size - 1){\\n            leftSide += nums[i].toLong()\\n            val rightSide = total - leftSide\\n            if(leftSide >= rightSide){\\n                ans++\\n            }\\n        }\\n\\n        return ans\\n    }\\n\\n\\n    //-----With Array-----\\n    private fun withArray(nums: IntArray): Int {\\n\\n        // Build the prefix sum\\n        val prefix = Array(nums.size){ 0L }\\n        prefix[0] = nums[0].toLong()\\n        for(i in 1 until nums.size){\\n            prefix[i] = nums[i] + prefix[i - 1]\\n        }\\n\\n        // Perform the logic\\n        var ans = 0\\n        for(i in 0 until prefix.size - 1){\\n            val leftSide = prefix[i]\\n            val rightSide = prefix[prefix.size - 1] - prefix[i]\\n            if(leftSide >= rightSide){\\n                ans++\\n            }\\n        }\\n\\n        return ans\\n    }\\n}\\n```",
                "solutionTags": [
                    "Kotlin"
                ],
                "code": "```\\nclass Solution {\\n    fun waysToSplitArray(nums: IntArray): Int {\\n        \\n        return withoutArray(nums)\\n        // return withArray(nums)\\n    }\\n\\n\\n    //-----Without Array-----\\n    private fun withoutArray(nums: IntArray): Int {\\n\\n        // Build the prefix sum\\n        var total = 0L\\n        for(num in nums){\\n            total += num.toLong()\\n        }\\n\\n        // Perform the logic\\n        var ans = 0\\n        var leftSide = 0L\\n        for(i in 0 until nums.size - 1){\\n            leftSide += nums[i].toLong()\\n            val rightSide = total - leftSide\\n            if(leftSide >= rightSide){\\n                ans++\\n            }\\n        }\\n\\n        return ans\\n    }\\n\\n\\n    //-----With Array-----\\n    private fun withArray(nums: IntArray): Int {\\n\\n        // Build the prefix sum\\n        val prefix = Array(nums.size){ 0L }\\n        prefix[0] = nums[0].toLong()\\n        for(i in 1 until nums.size){\\n            prefix[i] = nums[i] + prefix[i - 1]\\n        }\\n\\n        // Perform the logic\\n        var ans = 0\\n        for(i in 0 until prefix.size - 1){\\n            val leftSide = prefix[i]\\n            val rightSide = prefix[prefix.size - 1] - prefix[i]\\n            if(leftSide >= rightSide){\\n                ans++\\n            }\\n        }\\n\\n        return ans\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3830793,
                "title": "python-100-faster-prefix-sum-very-easy",
                "content": "![image.png](https://assets.leetcode.com/users/images/2a9dbec0-f5fe-40d0-be1b-d1cc275edb93_1690575186.7088983.png)\\n\\n# Intuition\\nThe goal is to find the number of ways to split the array into three subarrays, satisfying the given conditions.\\n\\n# Approach\\nWe use a two-pointer approach to efficiently find the valid splits. We maintain lsum and rsum as two pointers, one from the left and the other from the right. We traverse the array from left to right and check if the current split is valid. If it is, we increment the count of valid splits.\\n\\n# Complexity\\nTime complexity: O(n), where n is the length of the input array.\\nSpace complexity: O(1), as we use only a constant amount of additional space.\\n\\n# Code\\n```\\nclass Solution:\\n    def waysToSplitArray(self, nums: List[int]) -> int:\\n        lsum, rsum = 0, sum(nums)  # Initialize left and right sums.\\n        count = 0  # Initialize count of valid splits.\\n\\n        # Iterate from the left to the second-to-last element of the array.\\n        for i in range(len(nums) - 1):\\n            lsum += nums[i]  # Move the left pointer to the right.\\n            rsum -= nums[i]  # Move the right pointer to the left.\\n            \\n            # Check if the split is valid and increment count accordingly.\\n            if lsum >= rsum:\\n                count += 1\\n\\n        return count  # Return the total count of valid splits.\\n\\n```",
                "solutionTags": [
                    "Python",
                    "Python3",
                    "Prefix Sum"
                ],
                "code": "```\\nclass Solution:\\n    def waysToSplitArray(self, nums: List[int]) -> int:\\n        lsum, rsum = 0, sum(nums)  # Initialize left and right sums.\\n        count = 0  # Initialize count of valid splits.\\n\\n        # Iterate from the left to the second-to-last element of the array.\\n        for i in range(len(nums) - 1):\\n            lsum += nums[i]  # Move the left pointer to the right.\\n            rsum -= nums[i]  # Move the right pointer to the left.\\n            \\n            # Check if the split is valid and increment count accordingly.\\n            if lsum >= rsum:\\n                count += 1\\n\\n        return count  # Return the total count of valid splits.\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3828374,
                "title": "prefix-sum",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int waysToSplitArray(vector<int>& nums)\\n    {\\n        long long sum=0;\\n        vector<long long> prefix;\\n        for(int i=0;i<nums.size();i++)\\n        {\\n            sum=sum+nums[i];\\n            prefix.push_back(sum);\\n        }\\n        int count=0;\\n        for(int i=0;i<nums.size()-1;i++)\\n        {\\n            if(prefix[i]>=sum-prefix[i])\\n            {\\n                count++;\\n            }\\n        }\\n        return count;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int waysToSplitArray(vector<int>& nums)\\n    {\\n        long long sum=0;\\n        vector<long long> prefix;\\n        for(int i=0;i<nums.size();i++)\\n        {\\n            sum=sum+nums[i];\\n            prefix.push_back(sum);\\n        }\\n        int count=0;\\n        for(int i=0;i<nums.size()-1;i++)\\n        {\\n            if(prefix[i]>=sum-prefix[i])\\n            {\\n                count++;\\n            }\\n        }\\n        return count;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3772981,
                "title": "c-easy",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\nO(n)\\n\\n- Space complexity:\\nO(1)\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int waysToSplitArray(vector<int>& nums) {\\n        \\n       long long  total_sum=0;\\n        long long left_sum=0;\\n        long long  right_sum=0;\\n        int cnt=0;\\n\\n        for( auto i: nums)\\n         total_sum+=i;\\n\\n        for(int i=0;i<nums.size()-1;i++)\\n        {\\n        left_sum+=nums[i];\\n        right_sum=total_sum-left_sum;\\n\\n        if(left_sum>=right_sum)\\n          cnt++;\\n\\n        }\\n        return cnt;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int waysToSplitArray(vector<int>& nums) {\\n        \\n       long long  total_sum=0;\\n        long long left_sum=0;\\n        long long  right_sum=0;\\n        int cnt=0;\\n\\n        for( auto i: nums)\\n         total_sum+=i;\\n\\n        for(int i=0;i<nums.size()-1;i++)\\n        {\\n        left_sum+=nums[i];\\n        right_sum=total_sum-left_sum;\\n\\n        if(left_sum>=right_sum)\\n          cnt++;\\n\\n        }\\n        return cnt;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3762862,
                "title": "simple-c-solution-easy-prefix-sum-explained",
                "content": "\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\nHere we are asked the number of count of the splits so that the given condition ,\\n>  The sum of the first `i + 1` elements is greater than or equal to the sum of the last ,  ` n - i - 1` elements. \\n\\nFirstly we will compute the prefix sum of the given array , then we start iteratinf and will check that `pfl[i] >= pfl[n-1]-pfl[i]` and if true then we will keep the count of it and finally return the count. \\n\\n\\n---\\n\\n\\n\\n<!-- # Complexity -->\\n- Time complexity: $$O(n)$$\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n<!-- - Space complexity: -->\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int waysToSplitArray(vector<int>& nums) {\\n        int n = nums.size();\\n\\n        vector<long long>pfl(n,0);\\n        pfl[0] = nums[0];\\n        for(int i=1; i<n; i++){\\n            pfl[i] = pfl[i-1] + nums[i];\\n        }\\n        \\n        int cnt = 0;\\n        for(int i=0; i<n-1; i++){\\n            if(pfl[i] >= pfl[n-1]-pfl[i] ){\\n                cnt++;\\n            }\\n        }\\n        return cnt;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Array",
                    "Prefix Sum"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int waysToSplitArray(vector<int>& nums) {\\n        int n = nums.size();\\n\\n        vector<long long>pfl(n,0);\\n        pfl[0] = nums[0];\\n        for(int i=1; i<n; i++){\\n            pfl[i] = pfl[i-1] + nums[i];\\n        }\\n        \\n        int cnt = 0;\\n        for(int i=0; i<n-1; i++){\\n            if(pfl[i] >= pfl[n-1]-pfl[i] ){\\n                cnt++;\\n            }\\n        }\\n        return cnt;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3757754,
                "title": "prefix-sum-java-solution-with-o-n-time-complexity",
                "content": "# Approach\\n<!-- Describe your approach to solving the problem. -->\\nprefix sum \\n# Complexity\\n- Time complexity: O(n)\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: O(n)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\n    public int waysToSplitArray(int[] nums) {\\n        if (nums.length == 2){\\n            if (nums[0] >= nums[1]){\\n                return 1;\\n            }\\n            else{\\n                return 0;\\n            }\\n        }\\n        long[] sum = new long[nums.length];\\n        sum[0] = nums[0];\\n        for (int i = 1; i < nums.length; i++){\\n            sum[i] = sum[i-1] + nums[i];\\n        }\\n\\n        int ans = 0;\\n        for (int i = 0; i < (nums.length - 1); i++){\\n            if (sum[i] >= (sum[nums.length - 1] - sum[i])){\\n                ans++;\\n            }\\n        }\\n        return ans;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Array",
                    "Prefix Sum"
                ],
                "code": "```\\nclass Solution {\\n    public int waysToSplitArray(int[] nums) {\\n        if (nums.length == 2){\\n            if (nums[0] >= nums[1]){\\n                return 1;\\n            }\\n            else{\\n                return 0;\\n            }\\n        }\\n        long[] sum = new long[nums.length];\\n        sum[0] = nums[0];\\n        for (int i = 1; i < nums.length; i++){\\n            sum[i] = sum[i-1] + nums[i];\\n        }\\n\\n        int ans = 0;\\n        for (int i = 0; i < (nums.length - 1); i++){\\n            if (sum[i] >= (sum[nums.length - 1] - sum[i])){\\n                ans++;\\n            }\\n        }\\n        return ans;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3754429,
                "title": "easy-c-code-95-73-beats",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\nUse prefix sum.\\n\\n\\n# Complexity\\n- Time complexity: O(n)\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: O(1)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int waysToSplitArray(vector<int>& nums) {\\n        long long int tsum=0 ;\\n        for(int i=0 ;i<nums.size() ; i++)\\n        {\\n            tsum += nums[i];\\n        }\\n        long long int sum = 0;\\n        long long int c=0;\\n        for(int i=0 ; i<nums.size() ;i++)\\n        {\\n            sum += nums[i];\\n            tsum -= nums[i];\\n            if(sum>=tsum && i<nums.size()-1)\\n            {\\n                c++;\\n            }\\n        }\\n        return c;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Prefix Sum"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int waysToSplitArray(vector<int>& nums) {\\n        long long int tsum=0 ;\\n        for(int i=0 ;i<nums.size() ; i++)\\n        {\\n            tsum += nums[i];\\n        }\\n        long long int sum = 0;\\n        long long int c=0;\\n        for(int i=0 ; i<nums.size() ;i++)\\n        {\\n            sum += nums[i];\\n            tsum -= nums[i];\\n            if(sum>=tsum && i<nums.size()-1)\\n            {\\n                c++;\\n            }\\n        }\\n        return c;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3750408,
                "title": "100-its-long-bruh-not-int-realized-in-my-second-attempt",
                "content": "# Intuition\\n- Intially Calcualating the entire sum and storing it.\\n- then check is the prefsum is valid point or not ?\\n   1. if yes increase the valids else not\\n\\n# For the 100th test case(final one) our entire sum has to be a Long unless wanted some lossy conversion.\\n\\n# Complexity\\n- Time complexity: $$O(n)$$ \\n\\n- Space complexity: $$O(1)$$\\n\\n# Code\\n```\\nclass Solution {\\n    public int waysToSplitArray(int[] nums) {\\n        long sum=0;long prefsum =0;\\n        for(int i:nums) sum+=i;int n=nums.length;int valids=0;\\n        for(int i=0;i<n-1;i++){\\n            prefsum += nums[i];\\n            if(prefsum >= sum-prefsum) valids++;\\n        }\\n        return valids;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Array",
                    "Prefix Sum"
                ],
                "code": "```\\nclass Solution {\\n    public int waysToSplitArray(int[] nums) {\\n        long sum=0;long prefsum =0;\\n        for(int i:nums) sum+=i;int n=nums.length;int valids=0;\\n        for(int i=0;i<n-1;i++){\\n            prefsum += nums[i];\\n            if(prefsum >= sum-prefsum) valids++;\\n        }\\n        return valids;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3731303,
                "title": "optimal-prefix-sum-o-n",
                "content": "# Intuition\\nWe only have to loop until size of nums - 1 to preserve one value at the end.\\n\\n# Complexity\\n- Time complexity: O(N)\\n- Space complexity: O(1)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution:\\n    def waysToSplitArray(self, nums: List[int]) -> int:\\n        rightSum = sum(nums)\\n        leftSum = 0\\n        count = 0\\n        for i in range(len(nums) - 1):\\n            leftSum += nums[i]\\n            rightSum -= nums[i]\\n            if leftSum >= rightSum:\\n                count += 1\\n        return count\\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def waysToSplitArray(self, nums: List[int]) -> int:\\n        rightSum = sum(nums)\\n        leftSum = 0\\n        count = 0\\n        for i in range(len(nums) - 1):\\n            leftSum += nums[i]\\n            rightSum -= nums[i]\\n            if leftSum >= rightSum:\\n                count += 1\\n        return count\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3724367,
                "title": "my-overly-complex-solution-beats-5",
                "content": "# Intuition\\nI was just trying to not time out\\n\\n# Approach\\n\\nI decided to memoize the sums for all parts of the array, both for the first and last halves. I could have used 2 arrays but for some reason I felt the need to put them all in a 2d array.\\n\\n# Complexity\\n- Time complexity:\\n$$O(n)$$\\n\\n- Space complexity:\\n$$O(n)$$\\n\\n# Code\\n```\\nclass Solution:\\n    def waysToSplitArray(self, nums: List[int]) -> int:\\n        mem = [[0,0] for _ in range(len(nums))]\\n        \\n        last = 0\\n        for i in reversed(range(len(nums))):\\n            mem[i][1] = nums[i] + last\\n            last = nums[i] + last    \\n        # [14, 3 -1, 7]\\n        # print(mem)\\n\\n        last = 0\\n        for i in range(len(nums)):\\n            mem[i][0] = nums[i] + last\\n            last = nums[i] + last\\n            #[10, 14, 6, 15]\\n\\n        count = 0\\n        for i in range(len(mem)):\\n            if i < len(mem) - 1:\\n                if mem[i][0] >= mem[i+1][1]:\\n                    count += 1\\n        \\n        return count\\n```\\n\\nFeel free to downvote!",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def waysToSplitArray(self, nums: List[int]) -> int:\\n        mem = [[0,0] for _ in range(len(nums))]\\n        \\n        last = 0\\n        for i in reversed(range(len(nums))):\\n            mem[i][1] = nums[i] + last\\n            last = nums[i] + last    \\n        # [14, 3 -1, 7]\\n        # print(mem)\\n\\n        last = 0\\n        for i in range(len(nums)):\\n            mem[i][0] = nums[i] + last\\n            last = nums[i] + last\\n            #[10, 14, 6, 15]\\n\\n        count = 0\\n        for i in range(len(mem)):\\n            if i < len(mem) - 1:\\n                if mem[i][0] >= mem[i+1][1]:\\n                    count += 1\\n        \\n        return count\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3705630,
                "title": "constant-space-no-prefix-vector",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int waysToSplitArray(vector<int>& nums) \\n    {\\n       long long  int res = 0 ; \\n       long long  int sum = 0, leftsum =0 ; \\n        sum = accumulate(nums.begin(),nums.end(),sum);\\n\\n        for(int i = 0; i<nums.size()-1;i++)\\n        {\\n           leftsum += (long long )nums[i] ;\\n           if(leftsum>=sum-leftsum)\\n           res++;\\n\\n        }\\n\\n\\n\\n\\n        return res; \\n        \\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int waysToSplitArray(vector<int>& nums) \\n    {\\n       long long  int res = 0 ; \\n       long long  int sum = 0, leftsum =0 ; \\n        sum = accumulate(nums.begin(),nums.end(),sum);\\n\\n        for(int i = 0; i<nums.size()-1;i++)\\n        {\\n           leftsum += (long long )nums[i] ;\\n           if(leftsum>=sum-leftsum)\\n           res++;\\n\\n        }\\n\\n\\n\\n\\n        return res; \\n        \\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3696170,
                "title": "constant-space",
                "content": "# Intuition\\n**Here i thought lets sum all the elements first and then make the substraction into to sum and also create a sum for comparing i+1 elements.**\\n\\n# Approach\\n**I took two variables \"sum\" and \"presum\", \"sum\" have already sum of all elements and \"presum\" initially have first element of vector.**\\n\\n# Complexity\\n- Time complexity:\\n**O(n)**\\n\\n- Space complexity:\\n**O(1)**\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int waysToSplitArray(vector<int>& nums) {\\n        long long sum=0;\\n        for(int i=1;i<nums.size();i++)\\n            sum+=nums[i];\\n        int count=0;\\n        long long presum=nums[0];\\n        for(int i=1;i<nums.size();i++)\\n        {\\n            if(presum>=sum)\\n                count++;\\n            presum+=nums[i];\\n            sum-=nums[i];\\n        }\\n        return count;\\n        \\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Prefix Sum"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int waysToSplitArray(vector<int>& nums) {\\n        long long sum=0;\\n        for(int i=1;i<nums.size();i++)\\n            sum+=nums[i];\\n        int count=0;\\n        long long presum=nums[0];\\n        for(int i=1;i<nums.size();i++)\\n        {\\n            if(presum>=sum)\\n                count++;\\n            presum+=nums[i];\\n            sum-=nums[i];\\n        }\\n        return count;\\n        \\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3695357,
                "title": "java-solution-with-prefix-in-detail",
                "content": "\\n\\n# Code\\n```\\nclass Solution {\\n    public int waysToSplitArray(int[] nums) {\\n        int count = 0;\\n        //prefix example:\\n        //for array [1,2,3,4,5,6]\\n        //prefix array with above is[1,3,6,10,15,21] =>[1,1+2(3),3+3(6),6+4(10),10+5...]\\n        //each array[index] is sum of prefix and current index\\n        //for case 99, we need long type\\n        long[] prefix =new long[nums.length];\\n        prefix[0]=nums[0];\\n        for (int i=1;i<nums.length;i++){\\n            prefix[i] = prefix[i-1]+nums[i];\\n        }\\n        \\n        for(int i = 0;i<nums.length-1;i++){\\n            //the last prefix is sum of all element in nums\\n            //left side is prefix with current index, last prefix - current prefix\\n            // equal to total - leftside which is right side\\n            if(prefix[i]>=prefix[nums.length-1]-prefix[i]){count++;}\\n        }\\n        return count;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int waysToSplitArray(int[] nums) {\\n        int count = 0;\\n        //prefix example:\\n        //for array [1,2,3,4,5,6]\\n        //prefix array with above is[1,3,6,10,15,21] =>[1,1+2(3),3+3(6),6+4(10),10+5...]\\n        //each array[index] is sum of prefix and current index\\n        //for case 99, we need long type\\n        long[] prefix =new long[nums.length];\\n        prefix[0]=nums[0];\\n        for (int i=1;i<nums.length;i++){\\n            prefix[i] = prefix[i-1]+nums[i];\\n        }\\n        \\n        for(int i = 0;i<nums.length-1;i++){\\n            //the last prefix is sum of all element in nums\\n            //left side is prefix with current index, last prefix - current prefix\\n            // equal to total - leftside which is right side\\n            if(prefix[i]>=prefix[nums.length-1]-prefix[i]){count++;}\\n        }\\n        return count;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3694586,
                "title": "tc-o-n-sc-o-1-prefix-sum",
                "content": "# Code\\n```\\nclass Solution {\\npublic:\\n    int waysToSplitArray(vector<int>& nums) {\\n        int n = nums.size();\\n\\n        long long totalSum = 0;\\n        \\n        for (auto ele : nums)\\n            totalSum += ele;\\n            \\n        long long sum = 0;\\n        int count = 0;\\n\\n        for (int idx = 0; idx < n - 1; idx++) {\\n            sum += nums[idx];\\n\\n            if (sum >= totalSum - sum)\\n                count++;\\n        }\\n\\n        return count;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int waysToSplitArray(vector<int>& nums) {\\n        int n = nums.size();\\n\\n        long long totalSum = 0;\\n        \\n        for (auto ele : nums)\\n            totalSum += ele;\\n            \\n        long long sum = 0;\\n        int count = 0;\\n\\n        for (int idx = 0; idx < n - 1; idx++) {\\n            sum += nums[idx];\\n\\n            if (sum >= totalSum - sum)\\n                count++;\\n        }\\n\\n        return count;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3679759,
                "title": "easy-and-simple-o-n-solution",
                "content": "\\n\\n# Complexity\\n- Time complexity: O(N)\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: O(1)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int waysToSplitArray(vector<int>& nums) {\\n        long long sum = 0;\\n        for(int i=0;i<nums.size();i++){\\n            sum+=nums[i];\\n        }\\n        int cnt = 0;\\n        long long check = 0;\\n        for(int i=0;i<nums.size()-1;i++){\\n            check+=nums[i];\\n            sum-=nums[i];\\n            if(check>=sum) cnt++;\\n        }\\n        return cnt;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Array",
                    "Prefix Sum"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int waysToSplitArray(vector<int>& nums) {\\n        long long sum = 0;\\n        for(int i=0;i<nums.size();i++){\\n            sum+=nums[i];\\n        }\\n        int cnt = 0;\\n        long long check = 0;\\n        for(int i=0;i<nums.size()-1;i++){\\n            check+=nums[i];\\n            sum-=nums[i];\\n            if(check>=sum) cnt++;\\n        }\\n        return cnt;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3679524,
                "title": "ease-c-soln-using-prefix-sum",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->O(n)\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->O(1)\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int waysToSplitArray(vector<int>& nums) {\\n        int ans=0;\\n        int n=nums.size();\\n        long long s=0;\\n        vector<long long> ps; \\n        for (int i=0; i<n; i++){\\n            s+=nums[i];\\n            ps.push_back(s);\\n        }\\n\\n        for (int i=0; i<n-1; i++){\\n            if(ps[i]>=ps.back()-ps[i])\\n            ans++;\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int waysToSplitArray(vector<int>& nums) {\\n        int ans=0;\\n        int n=nums.size();\\n        long long s=0;\\n        vector<long long> ps; \\n        for (int i=0; i<n; i++){\\n            s+=nums[i];\\n            ps.push_back(s);\\n        }\\n\\n        for (int i=0; i<n-1; i++){\\n            if(ps[i]>=ps.back()-ps[i])\\n            ans++;\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3649796,
                "title": "easy-cpp-solution-simple-array-solution-easy-solution",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\ncalculate the sum of the element of the array store as right sum and then drecrese the right sum and increase the left sum and compare it.\\n\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\nO(n)\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n**********Bold**********\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int waysToSplitArray(vector<int>& nums) {\\n        long long int r=0;\\n        for(int i=0;i<nums.size();i++){\\n            r+=nums[i];\\n        }\\n        long long int l=0;\\n        int count =0;\\n        \\n        for(int i=0;i<nums.size()-1;i++){ \\n                 r=r-nums[i];\\n                l=l+nums[i];\\n            if(l>=(r)){\\n               count++;\\n            }\\n     \\n        }\\n        return count;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int waysToSplitArray(vector<int>& nums) {\\n        long long int r=0;\\n        for(int i=0;i<nums.size();i++){\\n            r+=nums[i];\\n        }\\n        long long int l=0;\\n        int count =0;\\n        \\n        for(int i=0;i<nums.size()-1;i++){ \\n                 r=r-nums[i];\\n                l=l+nums[i];\\n            if(l>=(r)){\\n               count++;\\n            }\\n     \\n        }\\n        return count;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3648962,
                "title": "c-solution",
                "content": "# Complexity\\n- Time complexity:\\n$$O(n)$$\\n\\n- Space complexity:\\n $$O(1)$$\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n  int waysToSplitArray(vector<int>& nums) {\\n    long leftSection = 0, rightSection = 0, ans = 0, total = 0;\\n\\n    for(const long& num: nums) {\\n      total += num;\\n    }\\n\\n    for(int i = 0; i < nums.size() - 1; i++) {\\n      leftSection += nums[i];\\n      rightSection = total - leftSection;\\n      if (leftSection >= rightSection) {\\n        ans++;\\n      }\\n    }\\n\\n    return ans;\\n  }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n  int waysToSplitArray(vector<int>& nums) {\\n    long leftSection = 0, rightSection = 0, ans = 0, total = 0;\\n\\n    for(const long& num: nums) {\\n      total += num;\\n    }\\n\\n    for(int i = 0; i < nums.size() - 1; i++) {\\n      leftSection += nums[i];\\n      rightSection = total - leftSection;\\n      if (leftSection >= rightSection) {\\n        ans++;\\n      }\\n    }\\n\\n    return ans;\\n  }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3628047,
                "title": "standard-prefix-sum-technique",
                "content": "# Intuition\\nGIVEN IN QUESTION SUM OF FIRST i+1 element = PREFIX SUM\\n\\n# Approach\\nTOTAL SUM - PSUM[I]<= PSUM[I] THEN VALID SPLIT.\\n\\n# Complexity\\n- Time complexity:\\nO(N)\\n\\n- Space complexity:\\nO(N)\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int waysToSplitArray(vector<int>& nums) {\\n        vector<long long>pSum(nums.size(),0);\\n\\n//prefix sum : \\n        for(int i = 0; i<pSum.size(); i++){\\n            if(i==0) pSum[i] = nums[i];\\n            else pSum[i] = pSum[i-1] + (long long )nums[i];\\n        }\\n\\n        long long totSum = pSum[nums.size()-1];  //total sum;\\n        long long cnt = 0;\\n\\n//THIS QUES. CAN ALSO BE DONE USING ONLY pSum variable only.\\n// pSum[i] = sum of first i+1 element : \\n        for( int i = 0; i<nums.size(); i++){\\n\\n            bool isGreater = pSum[i]>=totSum-pSum[i] ;\\n\\n            if( isGreater   &&  i<nums.size()-1) \\n                cnt++;\\n        }\\n\\n        return (int)cnt;\\n\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int waysToSplitArray(vector<int>& nums) {\\n        vector<long long>pSum(nums.size(),0);\\n\\n//prefix sum : \\n        for(int i = 0; i<pSum.size(); i++){\\n            if(i==0) pSum[i] = nums[i];\\n            else pSum[i] = pSum[i-1] + (long long )nums[i];\\n        }\\n\\n        long long totSum = pSum[nums.size()-1];  //total sum;\\n        long long cnt = 0;\\n\\n//THIS QUES. CAN ALSO BE DONE USING ONLY pSum variable only.\\n// pSum[i] = sum of first i+1 element : \\n        for( int i = 0; i<nums.size(); i++){\\n\\n            bool isGreater = pSum[i]>=totSum-pSum[i] ;\\n\\n            if( isGreater   &&  i<nums.size()-1) \\n                cnt++;\\n        }\\n\\n        return (int)cnt;\\n\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3627770,
                "title": "o-n-cpp-solution",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int waysToSplitArray(vector<int>& nums) {\\n       \\n            long long sum=0,total=0;\\n            for(auto x:nums)total+=x;\\n            int count=0;\\n        for(int i=0;i<nums.size()-1;i++){\\n            sum+=nums[i];\\n            if(sum>=total-sum )count++;\\n        }\\n        return count;\\n\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int waysToSplitArray(vector<int>& nums) {\\n       \\n            long long sum=0,total=0;\\n            for(auto x:nums)total+=x;\\n            int count=0;\\n        for(int i=0;i<nums.size()-1;i++){\\n            sum+=nums[i];\\n            if(sum>=total-sum )count++;\\n        }\\n        return count;\\n\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3625058,
                "title": "prefix-sum-c-very-simple-beats-70",
                "content": "# if its Help you,Please Upvote me...!\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\nfirstly findout the sum of the array and start from 0 and simply check the condition that is given in problem statement.\\n\\n# Complexity\\n- Time complexity:O(N)\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:O(1)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int waysToSplitArray(vector<int>& arr) {\\n\\n        long long n = arr.size(),sum1 = 0,sum2 = 0,ans = 0;\\n\\n        for(int i = 0;i<n;i++)\\n        sum1+=arr[i];\\n    \\n        for(int i = 0;i<n-1;i++)\\n        {\\n            sum2+=arr[i];\\n            sum1-=arr[i];\\n            if(sum2>=sum1)\\n            ans++;\\n        }\\n       \\n        return ans;   \\n    }\\n};\\n```\\n![upvote.jpg](https://assets.leetcode.com/users/images/2d64405f-0e8d-40d0-beee-d516a561837b_1686476294.415086.jpeg)\\n",
                "solutionTags": [
                    "C++",
                    "Array",
                    "Prefix Sum"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int waysToSplitArray(vector<int>& arr) {\\n\\n        long long n = arr.size(),sum1 = 0,sum2 = 0,ans = 0;\\n\\n        for(int i = 0;i<n;i++)\\n        sum1+=arr[i];\\n    \\n        for(int i = 0;i<n-1;i++)\\n        {\\n            sum2+=arr[i];\\n            sum1-=arr[i];\\n            if(sum2>=sum1)\\n            ans++;\\n        }\\n       \\n        return ans;   \\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3624004,
                "title": "python3-99-faster",
                "content": "# Complexity\\n- Time complexity:\\n$$O(n)$$\\n\\n- Space complexity:\\n$$O(1)$$\\n\\n# Code\\n```\\nclass Solution:\\n    def waysToSplitArray(self, nums: List[int]) -> int:\\n        left_section = ans = 0\\n        total = sum(nums)\\n\\n        for i in range(len(nums) - 1):\\n            left_section += nums[i]\\n            right_section = total - left_section\\n            if left_section >= right_section:\\n                ans += 1\\n\\n        return ans\\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def waysToSplitArray(self, nums: List[int]) -> int:\\n        left_section = ans = 0\\n        total = sum(nums)\\n\\n        for i in range(len(nums) - 1):\\n            left_section += nums[i]\\n            right_section = total - left_section\\n            if left_section >= right_section:\\n                ans += 1\\n\\n        return ans\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3592087,
                "title": "rust-solution-using-only-iterators",
                "content": "# Code\\n```\\nimpl Solution {\\n    pub fn ways_to_split_array(nums: Vec<i32>) -> i32 {\\n        let prefix: Vec<i64> = nums.iter().scan(0 as i64, |acc, x| {\\n            *acc += *x as i64;\\n            Some(*acc)\\n        }).collect();\\n\\n        let last = *prefix.last().unwrap();\\n        prefix[..prefix.len() - 1].iter().filter(|&&left| left >= last - left).count() as i32\\n    }\\n}\\n```",
                "solutionTags": [
                    "Rust"
                ],
                "code": "```\\nimpl Solution {\\n    pub fn ways_to_split_array(nums: Vec<i32>) -> i32 {\\n        let prefix: Vec<i64> = nums.iter().scan(0 as i64, |acc, x| {\\n            *acc += *x as i64;\\n            Some(*acc)\\n        }).collect();\\n\\n        let last = *prefix.last().unwrap();\\n        prefix[..prefix.len() - 1].iter().filter(|&&left| left >= last - left).count() as i32\\n    }\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3574759,
                "title": "number-of-ways-to-split-array-solution",
                "content": "# Intuition\\nThis is a problem to split array into two and compare sum of the two splits. \\n\\n# Approach\\nThe first thought that comes to mind is brute-force approach in which the steps would be run a loop of possible values for i and split the array, find the sum, compare them and update num of splits. In this approach there would be nested loops - loop of possible values of i, loop through list to find sum. Now outer loop of possible values of i can\\'t be optimized further but we can avoid looping through the array and find sum again and again. Instead what I have done here is I have calculated total sum before loop and everytime in the loop I will simply add the element in left_sum and subtract it from total_sum, which will become my right_sum. \\nThis way time complexity is rediced to O(n), instead of O(n^2)\\n\\n# Complexity\\n- Time complexity: O(n)\\n\\n\\n- Space complexity: O(1)\\n\\n\\n# Code\\n```\\nclass Solution:\\n    def waysToSplitArray(self, nums: List[int]) -> int:\\n        tot_sum = sum(nums)\\n        left_sum = 0\\n        num_splits = 0\\n        for i in range(len(nums) - 1):\\n            left_sum += nums[i] \\n            tot_sum -= nums[i]\\n            if left_sum >= tot_sum:\\n                num_splits += 1\\n        return num_splits\\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def waysToSplitArray(self, nums: List[int]) -> int:\\n        tot_sum = sum(nums)\\n        left_sum = 0\\n        num_splits = 0\\n        for i in range(len(nums) - 1):\\n            left_sum += nums[i] \\n            tot_sum -= nums[i]\\n            if left_sum >= tot_sum:\\n                num_splits += 1\\n        return num_splits\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3569789,
                "title": "swift-using-prefix-sum",
                "content": "Please do upvote if it helped. Thanks \\n\\n### Approach 1: Using Arrays ## \\n```\\nclass Solution {\\n    func waysToSplitArray(_ nums: [Int]) -> Int {\\n        \\n        var sumArray = [nums[0]]\\n        var ways = 0\\n        for i in 1..<nums.count {\\n            sumArray.append(nums[i] + sumArray[i-1])\\n        }\\n        for j in 0..<sumArray.count-1  {\\n            if sumArray[j] >= sumArray[sumArray.count-1] - sumArray[j]  {\\n                ways += 1\\n            }\\n        }\\n        \\n        return ways\\n        \\n    }\\n}\\n```\\n\\n### Approach 2: Using Runtime Calculation\\n### \\n```\\nclass Solution {\\n    func waysToSplitArray(_ nums: [Int]) -> Int {\\n        \\n        var total = 0\\n        var ans = 0\\n        var leftSum = 0\\n        for item in nums {\\n            total = total+item\\n        }\\n        \\n        for i in 0..<nums.count-1 {\\n            leftSum += nums[i]\\n            let rightSum = total - leftSum\\n            if leftSum >= rightSum {\\n                ans+=1\\n            }\\n        }\\n        \\n        return ans\\n        \\n    }\\n}\\n```",
                "solutionTags": [
                    "Swift",
                    "Prefix Sum"
                ],
                "code": "```\\nclass Solution {\\n    func waysToSplitArray(_ nums: [Int]) -> Int {\\n        \\n        var sumArray = [nums[0]]\\n        var ways = 0\\n        for i in 1..<nums.count {\\n            sumArray.append(nums[i] + sumArray[i-1])\\n        }\\n        for j in 0..<sumArray.count-1  {\\n            if sumArray[j] >= sumArray[sumArray.count-1] - sumArray[j]  {\\n                ways += 1\\n            }\\n        }\\n        \\n        return ways\\n        \\n    }\\n}\\n```\n```\\nclass Solution {\\n    func waysToSplitArray(_ nums: [Int]) -> Int {\\n        \\n        var total = 0\\n        var ans = 0\\n        var leftSum = 0\\n        for item in nums {\\n            total = total+item\\n        }\\n        \\n        for i in 0..<nums.count-1 {\\n            leftSum += nums[i]\\n            let rightSum = total - leftSum\\n            if leftSum >= rightSum {\\n                ans+=1\\n            }\\n        }\\n        \\n        return ans\\n        \\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3568442,
                "title": "easy-to-understand-typescript-solution-in-o-n-with-explanation",
                "content": "# Intuition\\n- Calculate sum for entire array, and increment left by `nums[i]`, and decrement right by `nums[i]`, and everytime `left >= right` increment the counter `c`.\\n- Also, Iterate over `nums.length - 1` due to the condition in the given:\\n \\n> There is at least one element to the right of i. That is, 0 <= i < n - 1.\\n\\n# Complexity\\n- Time complexity: O(N)\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: O(1) because only 3 variables have been used.\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nfunction waysToSplitArray(nums: number[]): number {\\n  let left = 0, right = nums.reduce((a, b) => a + b), c = 0;\\n  for ( let i = 0; i < nums.length - 1; i++ ) {\\n    left += nums[i]\\n    right -= nums[i]\\n    left >= right && c++\\n  }\\n  return c\\n};\\n```",
                "solutionTags": [
                    "TypeScript"
                ],
                "code": "```\\nfunction waysToSplitArray(nums: number[]): number {\\n  let left = 0, right = nums.reduce((a, b) => a + b), c = 0;\\n  for ( let i = 0; i < nums.length - 1; i++ ) {\\n    left += nums[i]\\n    right -= nums[i]\\n    left >= right && c++\\n  }\\n  return c\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3563114,
                "title": "beats-95-sc-92-tc-explained-beginner-friendly",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nWe are supposed to compare all the sums in subarray by the total sum of the array\\nSo I thought of making a new array, with prefixSum\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\nFollow these steps to get to the answer\\n- Lets make a array of type long (as the sum of integers we are going to add all the integers in the sum, so we need a big datatype like long or we wont be able to store if the array is too big)\\n- Now lets take a variable sum of datatype long **same reason as above**\\n- Using for loop:\\n- - add the value of nums[i] to sum sum += nums[i]\\n- - Now add the value of sum to our new array arr[i] = sum\\n- Take a variable count of datatype long\\n- Now using for loop again iterate the array till the end and check this condition:\\n- - Here if our arr[i] is greater than the arr[end] - current element in the array i.e. arr[i] then count++ as that number satisfies the condition.\\n- - if(arr[i] >= arr[nums.length - 1] - arr[i]) then count++;\\n- return count;\\n\\n**UPVOTE IF YOU LIKED THE APPROACH OR THE EXPLANATION**\\n\\n# Complexity\\n- Time complexity: O(N)\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: O(1)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\n    public int waysToSplitArray(int[] nums) {\\n        long[] arr = new long[nums.length];\\n        long sum = 0;\\n        for(int i = 0; i < nums.length; i++){\\n            sum+=nums[i];\\n            arr[i] = sum;\\n        }\\n        long count = 0;\\n        for(int i = 0; i < nums.length-1; i++){\\n            if(arr[i] >= arr[nums.length - 1] - arr[i]){\\n                count++;\\n            }\\n        }\\n        return (int)(count);\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int waysToSplitArray(int[] nums) {\\n        long[] arr = new long[nums.length];\\n        long sum = 0;\\n        for(int i = 0; i < nums.length; i++){\\n            sum+=nums[i];\\n            arr[i] = sum;\\n        }\\n        long count = 0;\\n        for(int i = 0; i < nums.length-1; i++){\\n            if(arr[i] >= arr[nums.length - 1] - arr[i]){\\n                count++;\\n            }\\n        }\\n        return (int)(count);\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3558836,
                "title": "java-easy-solution-using-sliding-window-concept",
                "content": "\\n# Code\\n```\\nclass Solution {\\n    public int waysToSplitArray(int[] nums) {\\n        int n = nums.length-1;\\n        int count =  0;\\n        long x = 0;\\n        long y = 0;\\n        x = firstSum(nums,1);\\n        y = lastSum(nums,n);\\n        if(x>=y)count=1;\\n   \\n        for(int i = 1; i<n; i++)\\n        {\\n            // sliding window concept\\n            x = x + nums[i];\\n            y = y - nums[i];\\n            if(x>=y)count++;\\n        }\\n        return count;\\n    }\\n/* these two functions are being used only once \\n   O(n+n) = linear time\\n*/\\n    private long firstSum(int[] nums,int n)\\n    {\\n        long sum = 0;\\n        int i = 0;\\n        while(n-->0)\\n        {\\n           sum = sum + nums[i++];\\n        }\\n        return sum;\\n    }\\n    private long lastSum(int[] nums,int n)\\n    {\\n        long sum = 0;\\n        int i = nums.length - 1;\\n        while(n-->0)\\n        {\\n            sum = sum + nums[i--];\\n        }\\n        return sum;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int waysToSplitArray(int[] nums) {\\n        int n = nums.length-1;\\n        int count =  0;\\n        long x = 0;\\n        long y = 0;\\n        x = firstSum(nums,1);\\n        y = lastSum(nums,n);\\n        if(x>=y)count=1;\\n   \\n        for(int i = 1; i<n; i++)\\n        {\\n            // sliding window concept\\n            x = x + nums[i];\\n            y = y - nums[i];\\n            if(x>=y)count++;\\n        }\\n        return count;\\n    }\\n/* these two functions are being used only once \\n   O(n+n) = linear time\\n*/\\n    private long firstSum(int[] nums,int n)\\n    {\\n        long sum = 0;\\n        int i = 0;\\n        while(n-->0)\\n        {\\n           sum = sum + nums[i++];\\n        }\\n        return sum;\\n    }\\n    private long lastSum(int[] nums,int n)\\n    {\\n        long sum = 0;\\n        int i = nums.length - 1;\\n        while(n-->0)\\n        {\\n            sum = sum + nums[i--];\\n        }\\n        return sum;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3497853,
                "title": "simple-prefix-sum",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\n    public int waysToSplitArray(int[] nums) {\\n        int n=nums.length;\\n        long[] pre=new long[n];\\n        pre[0]=nums[0];\\n        for(int i=1;i<n;i++){\\n            pre[i]=nums[i]+pre[i-1];\\n        }        \\n        long sum=pre[n-1];\\n        int ans=0;\\n        for(int i=0;i<n-1;i++){\\n            if(pre[i]>=sum-pre[i]) ans++;\\n        }\\n        return ans;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int waysToSplitArray(int[] nums) {\\n        int n=nums.length;\\n        long[] pre=new long[n];\\n        pre[0]=nums[0];\\n        for(int i=1;i<n;i++){\\n            pre[i]=nums[i]+pre[i-1];\\n        }        \\n        long sum=pre[n-1];\\n        int ans=0;\\n        for(int i=0;i<n-1;i++){\\n            if(pre[i]>=sum-pre[i]) ans++;\\n        }\\n        return ans;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3485169,
                "title": "solution-with-prefix-sum-time-o-n",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity: O(n)\\n- Space complexity: O(1)\\n\\n# Code\\n```\\nclass Solution {\\n    public int waysToSplitArray(int[] nums) {\\n   int res = 0;\\n        long leftSection = 0;\\n        long total = 0;\\n\\n        for (int num : nums) {\\n            total += num;\\n        }\\n\\n        for (int i = 0; i < nums.length - 1; i++) {\\n            leftSection += nums[i];\\n            long rightSection = total - leftSection;\\n            if (leftSection >= rightSection) {\\n                res++;\\n            }\\n        }\\n        return res;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int waysToSplitArray(int[] nums) {\\n   int res = 0;\\n        long leftSection = 0;\\n        long total = 0;\\n\\n        for (int num : nums) {\\n            total += num;\\n        }\\n\\n        for (int i = 0; i < nums.length - 1; i++) {\\n            leftSection += nums[i];\\n            long rightSection = total - leftSection;\\n            if (leftSection >= rightSection) {\\n                res++;\\n            }\\n        }\\n        return res;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3457478,
                "title": "cpp-solution",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int waysToSplitArray(vector<int>& nums) {\\n        long long ans=0;\\n        int n=nums.size();\\n        long long leftSum=nums[0];\\n        long long rightSum=0;\\n        for(int i=0;i<n;i++){\\n           rightSum+=nums[i];\\n        }\\n        for(int i=0;i<n-1;i++){\\n             rightSum-=nums[i];\\n             if(leftSum>=rightSum) ans++;\\n             leftSum+=nums[i+1];\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int waysToSplitArray(vector<int>& nums) {\\n        long long ans=0;\\n        int n=nums.size();\\n        long long leftSum=nums[0];\\n        long long rightSum=0;\\n        for(int i=0;i<n;i++){\\n           rightSum+=nums[i];\\n        }\\n        for(int i=0;i<n-1;i++){\\n             rightSum-=nums[i];\\n             if(leftSum>=rightSum) ans++;\\n             leftSum+=nums[i+1];\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3454831,
                "title": "prefix-sum-easy-c-solution",
                "content": "# Code\\n```\\nclass Solution \\n{\\npublic:\\n    int waysToSplitArray(vector<int>& nums) \\n    {\\n        int n=nums.size();\\n        vector<long long> prefix(n,0);\\n        prefix[0]=nums[0];\\n        for(int x=1; x<n; x++) prefix[x]=prefix[x-1]+(long long)nums[x];\\n        long long sum=0;\\n        for(auto it: nums) sum+=(long long)it;\\n        int cnt=0;\\n        for(int x=0; x<n-1; x++)\\n        {\\n            if(prefix[x]>=(sum-prefix[x])) cnt++;\\n        }\\n        return cnt;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution \\n{\\npublic:\\n    int waysToSplitArray(vector<int>& nums) \\n    {\\n        int n=nums.size();\\n        vector<long long> prefix(n,0);\\n        prefix[0]=nums[0];\\n        for(int x=1; x<n; x++) prefix[x]=prefix[x-1]+(long long)nums[x];\\n        long long sum=0;\\n        for(auto it: nums) sum+=(long long)it;\\n        int cnt=0;\\n        for(int x=0; x<n-1; x++)\\n        {\\n            if(prefix[x]>=(sum-prefix[x])) cnt++;\\n        }\\n        return cnt;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3443160,
                "title": "python-o-n-time-o-1-space",
                "content": "# Complexity\\n- Time complexity:\\n$$O(n)$$ \\n\\n- Space complexity:\\n$$O(1)$$\\n\\n# Code\\n```\\nclass Solution:\\n    def waysToSplitArray(self, nums: List[int]) -> int:\\n        total = sum(nums)\\n        count = 0\\n        curr_sum = nums[0]\\n        for i in range(1, len(nums)):\\n            if curr_sum >= total - curr_sum:\\n                count += 1\\n            \\n            curr_sum += nums[i]\\n\\n        return count\\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def waysToSplitArray(self, nums: List[int]) -> int:\\n        total = sum(nums)\\n        count = 0\\n        curr_sum = nums[0]\\n        for i in range(1, len(nums)):\\n            if curr_sum >= total - curr_sum:\\n                count += 1\\n            \\n            curr_sum += nums[i]\\n\\n        return count\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3426008,
                "title": "straightforward-js-solution",
                "content": "# Intuition\\nWe need to get the cumulative sum up to i pointer, and ensure that\\'s more than the remaining. We first get the cumulative sums at all positions, and the total. In the next iteration we derive the result count\\n\\n# Code\\n```\\n/**\\n * @param {number[]} nums\\n * @return {number}\\n */\\nvar waysToSplitArray = function(nums) {\\n    let cumulativeSum = new Array(nums.length)\\n    let results = 0\\n    cumulativeSum[0] = nums[0]\\n    for(let i=1; i<nums.length; i++){\\n        cumulativeSum[i] = cumulativeSum[i-1] + nums[i]\\n    }\\n    let total = cumulativeSum[nums.length-1]\\n    for(let i=0; i< nums.length -1 ; i++){\\n        if(cumulativeSum[i] >= total - cumulativeSum[i]){\\n            results++\\n        }\\n    }\\n\\n    return results\\n};\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\n/**\\n * @param {number[]} nums\\n * @return {number}\\n */\\nvar waysToSplitArray = function(nums) {\\n    let cumulativeSum = new Array(nums.length)\\n    let results = 0\\n    cumulativeSum[0] = nums[0]\\n    for(let i=1; i<nums.length; i++){\\n        cumulativeSum[i] = cumulativeSum[i-1] + nums[i]\\n    }\\n    let total = cumulativeSum[nums.length-1]\\n    for(let i=0; i< nums.length -1 ; i++){\\n        if(cumulativeSum[i] >= total - cumulativeSum[i]){\\n            results++\\n        }\\n    }\\n\\n    return results\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3410524,
                "title": "typescript-javascript",
                "content": "Solved with prefix sum approach\\n\\n# Complexity\\n- Time complexity: O(n)\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: O(n)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nfunction waysToSplitArray(nums: number[]): number {\\n    const prefix = [nums[0]];\\n    let valid = 0;\\n\\n    for (let i = 1; i < nums.length; i++) {\\n        prefix.push(nums[i] + prefix[prefix.length-1]);\\n    }\\n\\n    for (let i = 0; i < prefix.length-1; i++) {\\n        const left = prefix[i];\\n        const right = prefix[prefix.length-1] - left;\\n\\n        if (left >= right) {\\n            valid++;\\n        }\\n    }\\n\\n    return valid;\\n};\\n```",
                "solutionTags": [
                    "TypeScript"
                ],
                "code": "```\\nfunction waysToSplitArray(nums: number[]): number {\\n    const prefix = [nums[0]];\\n    let valid = 0;\\n\\n    for (let i = 1; i < nums.length; i++) {\\n        prefix.push(nums[i] + prefix[prefix.length-1]);\\n    }\\n\\n    for (let i = 0; i < prefix.length-1; i++) {\\n        const left = prefix[i];\\n        const right = prefix[prefix.length-1] - left;\\n\\n        if (left >= right) {\\n            valid++;\\n        }\\n    }\\n\\n    return valid;\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3398051,
                "title": "not-so-medium-beats-100",
                "content": "\\n\\n# Code\\n```\\nclass Solution {\\n    public int waysToSplitArray(int[] nums) {\\n        if(nums.length==0) {\\n            return -1;\\n        }\\n        long total=0;\\n        for(int num:nums) {\\n            total+=num;\\n        }\\n        int count=0;\\n        long leftSum=0;\\n        long rightSum=total;\\n        for(int i=0;i<nums.length-1;i++) {\\n                leftSum+=nums[i];\\n                rightSum-=nums[i];\\n                if(leftSum>=rightSum) {\\n                    count++;\\n                }\\n        }\\n        return count;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int waysToSplitArray(int[] nums) {\\n        if(nums.length==0) {\\n            return -1;\\n        }\\n        long total=0;\\n        for(int num:nums) {\\n            total+=num;\\n        }\\n        int count=0;\\n        long leftSum=0;\\n        long rightSum=total;\\n        for(int i=0;i<nums.length-1;i++) {\\n                leftSum+=nums[i];\\n                rightSum-=nums[i];\\n                if(leftSum>=rightSum) {\\n                    count++;\\n                }\\n        }\\n        return count;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3395262,
                "title": "python-very-easy-prefix-sum",
                "content": "# Code\\n```\\nclass Solution:\\n    def waysToSplitArray(self, nums: List[int]) -> int:\\n        prefs, sum, res = [0], 0, 0\\n        for i in range(len(nums)):\\n            prefs.append(prefs[-1] + nums[i])\\n        for i in range(len(nums) - 1, 0, -1):\\n            sum+=nums[i]\\n            if prefs[i] >= sum: res+=1\\n        return res\\n\\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def waysToSplitArray(self, nums: List[int]) -> int:\\n        prefs, sum, res = [0], 0, 0\\n        for i in range(len(nums)):\\n            prefs.append(prefs[-1] + nums[i])\\n        for i in range(len(nums) - 1, 0, -1):\\n            sum+=nums[i]\\n            if prefs[i] >= sum: res+=1\\n        return res\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3394596,
                "title": "c-solution",
                "content": "\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int waysToSplitArray(vector<int>& nums) \\n    {\\n        int n=nums.size();\\n        vector<long long>pre(n);\\n        pre[0]=nums[0];\\n        for (int i=1;i<n;i++) pre[i]=pre[i-1]+(long long)nums[i];\\n        int ans=0;\\n        for (int i=0;i<n-1;i++)\\n        {\\n            if (2*pre[i]>=pre[n-1])\\n            {\\n                ans++;\\n            }\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int waysToSplitArray(vector<int>& nums) \\n    {\\n        int n=nums.size();\\n        vector<long long>pre(n);\\n        pre[0]=nums[0];\\n        for (int i=1;i<n;i++) pre[i]=pre[i-1]+(long long)nums[i];\\n        int ans=0;\\n        for (int i=0;i<n-1;i++)\\n        {\\n            if (2*pre[i]>=pre[n-1])\\n            {\\n                ans++;\\n            }\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3392857,
                "title": "easy-solution",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int waysToSplitArray(vector<int>& nums) {\\n        long long sum = 0;\\n        for(int i = 0;i<nums.size();i++)sum = sum + nums[i];\\n        int ans = 0;\\n        long long cur = 0;\\n        for(int i = 0;i<nums.size()-1;i++){\\n            cur = cur + nums[i];\\n            if(sum -cur<=cur)ans++;\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int waysToSplitArray(vector<int>& nums) {\\n        long long sum = 0;\\n        for(int i = 0;i<nums.size();i++)sum = sum + nums[i];\\n        int ans = 0;\\n        long long cur = 0;\\n        for(int i = 0;i<nums.size()-1;i++){\\n            cur = cur + nums[i];\\n            if(sum -cur<=cur)ans++;\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3387835,
                "title": "easy-c-solution-prefix-sum",
                "content": "```\\nclass Solution {\\npublic:\\n    int waysToSplitArray(vector<int>& nums) {\\n        long long rightSum=0,leftSum=0,ct=0;\\n        int n = nums.size();\\n        \\n        for(auto it:nums) rightSum+=it;\\n\\n        for(int i=0;i<n-1;i++){\\n            leftSum+=nums[i];\\n            if(2*1ll*leftSum>=rightSum){\\n                ct++;\\n            } \\n        }\\n        \\n        return ct;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C",
                    "Prefix Sum"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int waysToSplitArray(vector<int>& nums) {\\n        long long rightSum=0,leftSum=0,ct=0;\\n        int n = nums.size();\\n        \\n        for(auto it:nums) rightSum+=it;\\n\\n        for(int i=0;i<n-1;i++){\\n            leftSum+=nums[i];\\n            if(2*1ll*leftSum>=rightSum){\\n                ct++;\\n            } \\n        }\\n        \\n        return ct;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3386053,
                "title": "c-easy-loop",
                "content": "```\\nclass Solution {\\npublic:\\n    int waysToSplitArray(vector<int>& nums) {\\n        int ans = 0;\\n        long long rSum = 0, lSum = 0;\\n        for (auto &n : nums) rSum += n;\\n        for (int i = 0; i < nums.size() - 1; ++i){\\n            lSum += nums[i];\\n            rSum -= nums[i];\\n            ans += lSum >= rSum;\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    int waysToSplitArray(vector<int>& nums) {\\n        int ans = 0;\\n        long long rSum = 0, lSum = 0;\\n        for (auto &n : nums) rSum += n;\\n        for (int i = 0; i < nums.size() - 1; ++i){\\n            lSum += nums[i];\\n            rSum -= nums[i];\\n            ans += lSum >= rSum;\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3362562,
                "title": "easy-simple-solution",
                "content": "```\\nclass Solution {\\npublic:\\n\\n    int waysToSplitArray(vector<int>& nums) {\\n    long long n = nums.size();\\n    vector<long long> ps(n ), ss(n);\\n    ps[0] = nums[0];\\n    for (long long i = 1; i < n; i++)\\n        ps[i] = ps[i - 1] + nums[i];\\n    ss[0] = nums[n - 1];\\n    for (long long i = 1; i < n; i++)\\n        ss[i] = nums[n - i - 1] + ss[i - 1];\\n\\n// cout<<\"ps is-- >\";\\n//     for( auto x : ps)\\n//         cout << x << \" \";\\n// cout<<endl;\\n\\n// cout<<\"ss is --> \";\\n//     for( auto x : ss)\\n//         cout << x << \" \";\\n    \\n    \\n    long long ans = 0;\\n    for (long long i = 0; i < n-1; i++){\\n        if(ps[i]>= ss[n-2-i])\\n            ans++;\\n            \\n    }\\n    return ans;\\n}\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Array",
                    "Prefix Sum"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n\\n    int waysToSplitArray(vector<int>& nums) {\\n    long long n = nums.size();\\n    vector<long long> ps(n ), ss(n);\\n    ps[0] = nums[0];\\n    for (long long i = 1; i < n; i++)\\n        ps[i] = ps[i - 1] + nums[i];\\n    ss[0] = nums[n - 1];\\n    for (long long i = 1; i < n; i++)\\n        ss[i] = nums[n - i - 1] + ss[i - 1];\\n\\n// cout<<\"ps is-- >\";\\n//     for( auto x : ps)\\n//         cout << x << \" \";\\n// cout<<endl;\\n\\n// cout<<\"ss is --> \";\\n//     for( auto x : ss)\\n//         cout << x << \" \";\\n    \\n    \\n    long long ans = 0;\\n    for (long long i = 0; i < n-1; i++){\\n        if(ps[i]>= ss[n-2-i])\\n            ans++;\\n            \\n    }\\n    return ans;\\n}\\n};\\n```",
                "codeTag": "C++"
            },
            {
                "id": 3356012,
                "title": "c-prefix-sum",
                "content": "\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int waysToSplitArray(vector<int>& nums) {\\n        int n = nums.size();\\n        vector<long long> pref(n);\\n        pref[0] = nums[0];\\n        for(int i=1;i<n;i++)\\n        pref[i] = pref[i-1]+nums[i];\\n        int ans=0;\\n        for(int i=1;i<n;i++)\\n        {\\n            long long sum1 = pref[i-1];\\n            long long sum2 = pref[n-1]-pref[i-1];\\n            if(sum1>=sum2)\\n            ans++;\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int waysToSplitArray(vector<int>& nums) {\\n        int n = nums.size();\\n        vector<long long> pref(n);\\n        pref[0] = nums[0];\\n        for(int i=1;i<n;i++)\\n        pref[i] = pref[i-1]+nums[i];\\n        int ans=0;\\n        for(int i=1;i<n;i++)\\n        {\\n            long long sum1 = pref[i-1];\\n            long long sum2 = pref[n-1]-pref[i-1];\\n            if(sum1>=sum2)\\n            ans++;\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3352846,
                "title": "easy-approach-beats-99",
                "content": "# Intuition\\nWe can start by setting a left side and right side and after every step we increase the left side up by one and decrease the right side by one. We are using a sliding window technique to evaluate if the new sum of each element on the left is >= the sum of each element on the right. \\n# Complexity\\n- Time complexity:\\nO(N) linear\\n\\n- Space complexity:\\nO(1) constant\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int waysToSplitArray(vector<int>& nums) {\\n        int c =0;\\n        int n = nums.size();\\n        long sumleft =nums[0];\\n        long sumright =0;\\n        for(int i =1 ;i<n;i++){\\n            sumright+=nums[i];\\n        }\\n        for(int i =1 ;i<n;i++){\\n            if(sumleft>=sumright)\\n            c++;\\n            sumleft+=nums[i];\\n            sumright-=nums[i];\\n        }\\n\\n        return c;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Sliding Window"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int waysToSplitArray(vector<int>& nums) {\\n        int c =0;\\n        int n = nums.size();\\n        long sumleft =nums[0];\\n        long sumright =0;\\n        for(int i =1 ;i<n;i++){\\n            sumright+=nums[i];\\n        }\\n        for(int i =1 ;i<n;i++){\\n            if(sumleft>=sumright)\\n            c++;\\n            sumleft+=nums[i];\\n            sumright-=nums[i];\\n        }\\n\\n        return c;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3298961,
                "title": "range-sum-query-c",
                "content": "# Intuition\\nWe need to have the sum of elements from index a to b in O(1) in order to satisfy the time constraint.\\nSo to get the sum of elements from index a to b in constant time, we can calculate the cumulative sum of the elements.\\nyou can search on web how Range sum query works\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\nO(n)\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\nO(n)\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int waysToSplitArray(vector<int>& nums) \\n    {\\n        vector<long long int> sums(nums.size(),0);\\n        sums[0]=nums[0];\\n        for(int i=1;i<nums.size();i++)\\n        {\\n            sums[i]=nums[i]+sums[i-1];\\n        }    \\n        int count=0;\\n        for(int i=0;i<nums.size()-1;i++)\\n        {\\n            if(sums[i]>=(sums[sums.size()-1]-sums[i]))\\n            {\\n                count++;\\n            }\\n        }\\n        return count;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int waysToSplitArray(vector<int>& nums) \\n    {\\n        vector<long long int> sums(nums.size(),0);\\n        sums[0]=nums[0];\\n        for(int i=1;i<nums.size();i++)\\n        {\\n            sums[i]=nums[i]+sums[i-1];\\n        }    \\n        int count=0;\\n        for(int i=0;i<nums.size()-1;i++)\\n        {\\n            if(sums[i]>=(sums[sums.size()-1]-sums[i]))\\n            {\\n                count++;\\n            }\\n        }\\n        return count;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3280800,
                "title": "cpp-eay",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int waysToSplitArray(vector<int>& nums) {\\n        int n=nums.size();\\n        long long right=0;long long left=0;\\n        for(int i=0;i<n;i++){\\n            right+=nums[i];\\n        }\\n        int count=0;\\n        for(int i=0;i<n-1;i++){\\n            right-=nums[i];\\n            left+=nums[i];\\n            if(left>=right)count++;\\n            \\n        }\\n        return count;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int waysToSplitArray(vector<int>& nums) {\\n        int n=nums.size();\\n        long long right=0;long long left=0;\\n        for(int i=0;i<n;i++){\\n            right+=nums[i];\\n        }\\n        int count=0;\\n        for(int i=0;i<n-1;i++){\\n            right-=nums[i];\\n            left+=nums[i];\\n            if(left>=right)count++;\\n            \\n        }\\n        return count;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3272037,
                "title": "cpp-easy",
                "content": "class Solution {\\npublic:\\n    int waysToSplitArray(vector<int>& nums) \\n    {\\n        int c=0;\\n        long long s1=0;\\n        long long s2=0;\\n        for(int i=0;i<nums.size();++i)\\n            s2=s2+(long long)nums[i];\\n        for(int i=0;i<nums.size()-1;++i)\\n        {\\n            s1+=(long long)nums[i];\\n            s2-=(long long)nums[i];\\n            if(s1>=s2)\\n            ++c;\\n            \\n        }\\n        return c;\\n    }\\n};",
                "solutionTags": [],
                "code": "class Solution {\\npublic:\\n    int waysToSplitArray(vector<int>& nums) \\n    {\\n        int c=0;\\n        long long s1=0;\\n        long long s2=0;\\n        for(int i=0;i<nums.size();++i)\\n            s2=s2+(long long)nums[i];\\n        for(int i=0;i<nums.size()-1;++i)\\n        {\\n            s1+=(long long)nums[i];\\n            s2-=(long long)nums[i];\\n            if(s1>=s2)\\n            ++c;\\n            \\n        }",
                "codeTag": "Java"
            },
            {
                "id": 3270887,
                "title": "93-33-o-n-time-o-1-space-simple-solution",
                "content": "# Intuition\\nI decided to use Two Pointer pattern to solve this.\\n\\n# Approach\\nReduce is a very performant and very simple in order to create the sums of the array. Then I used the two pointer pattern to get the count of ways to split an array.\\n\\n# Complexity\\n- Time complexity:\\nO(n)\\n\\n- Space complexity:\\nO(1)\\n\\n# Code\\n```\\nfunction waysToSplitArray(nums: number[]): number {\\n    let count = 0, left = 0\\n    const total = nums.reduce((total, num) => total+num)\\n\\n    for (let i = 0; i < nums.length -1 ; i++){\\n        left += nums[i]\\n        let right = total - left\\n        if(left >= right) count+=1\\n    }\\n\\n    return count\\n};\\n```",
                "solutionTags": [
                    "TypeScript"
                ],
                "code": "```\\nfunction waysToSplitArray(nums: number[]): number {\\n    let count = 0, left = 0\\n    const total = nums.reduce((total, num) => total+num)\\n\\n    for (let i = 0; i < nums.length -1 ; i++){\\n        left += nums[i]\\n        let right = total - left\\n        if(left >= right) count+=1\\n    }\\n\\n    return count\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3227513,
                "title": "prefix-sum-python",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\nUse prefix number array to reduce recalculate the sum\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\nO(N)\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\nO(N)\\n\\n# Code\\n```\\nclass Solution:\\n    def waysToSplitArray(self, nums: List[int]) -> int:\\n\\n        prefix_num = [nums[0]]\\n        for i in range(1, len(nums)):\\n            prefix_num.append(nums[i] + prefix_num[i-1])\\n\\n        valid = [(prefix_num[i] >= (prefix_num[len(nums)-1] - prefix_num[i])) for i in range(len(nums)-1)]\\n        valid_num = sum(valid)\\n\\n        return valid_num\\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def waysToSplitArray(self, nums: List[int]) -> int:\\n\\n        prefix_num = [nums[0]]\\n        for i in range(1, len(nums)):\\n            prefix_num.append(nums[i] + prefix_num[i-1])\\n\\n        valid = [(prefix_num[i] >= (prefix_num[len(nums)-1] - prefix_num[i])) for i in range(len(nums)-1)]\\n        valid_num = sum(valid)\\n\\n        return valid_num\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3226748,
                "title": "python-3-solution",
                "content": "# Code\\n```\\nclass Solution:\\n    def waysToSplitArray(self, nums: List[int]) -> int:\\n\\n        arrSum = (sum(nums)+1)//2\\n\\n        temp = 0\\n        res = 0\\n\\n        for x in nums[:-1]:\\n            temp += x\\n            if temp >= arrSum:\\n                res += 1\\n\\n        return res\\n        \\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def waysToSplitArray(self, nums: List[int]) -> int:\\n\\n        arrSum = (sum(nums)+1)//2\\n\\n        temp = 0\\n        res = 0\\n\\n        for x in nums[:-1]:\\n            temp += x\\n            if temp >= arrSum:\\n                res += 1\\n\\n        return res\\n        \\n```",
                "codeTag": "Java"
            },
            {
                "id": 3223114,
                "title": "rust-just-one-more-prefix-sum-solution",
                "content": "# Code\\n```\\nimpl Solution {\\n    pub fn ways_to_split_array(nums: Vec<i32>) -> i32 {\\n        // nums contains a valid split at index i if the following are true:\\n        //\\n        // The sum of the first i + 1 elements is greater than or equal to the sum of the last n - i - 1 elements.\\n        // There is at least one element to the right of i. That is, 0 <= i < n - 1.\\n        let mut prefix = vec![0; nums.len()];\\n        for i in 0..nums.len() {\\n            if i == 0 {\\n                prefix[i] = nums[i] as i64;\\n            } else {\\n                prefix[i] = prefix[i - 1] + nums[i] as i64;\\n            }\\n        }\\n        let mut ans = 0;\\n        for i in 0..nums.len() - 1 {\\n            if prefix[i] >= prefix[nums.len() - 1] - prefix[i] {\\n                ans += 1;\\n            }\\n        }\\n        ans\\n    }\\n}\\n```",
                "solutionTags": [
                    "Rust"
                ],
                "code": "```\\nimpl Solution {\\n    pub fn ways_to_split_array(nums: Vec<i32>) -> i32 {\\n        // nums contains a valid split at index i if the following are true:\\n        //\\n        // The sum of the first i + 1 elements is greater than or equal to the sum of the last n - i - 1 elements.\\n        // There is at least one element to the right of i. That is, 0 <= i < n - 1.\\n        let mut prefix = vec![0; nums.len()];\\n        for i in 0..nums.len() {\\n            if i == 0 {\\n                prefix[i] = nums[i] as i64;\\n            } else {\\n                prefix[i] = prefix[i - 1] + nums[i] as i64;\\n            }\\n        }\\n        let mut ans = 0;\\n        for i in 0..nums.len() - 1 {\\n            if prefix[i] >= prefix[nums.len() - 1] - prefix[i] {\\n                ans += 1;\\n            }\\n        }\\n        ans\\n    }\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3212620,
                "title": "python-prefix-sum",
                "content": "\\n\\n# Code\\n```\\nclass Solution:\\n    def waysToSplitArray(self, nums: List[int]) -> int:\\n        cur_sum = []\\n        curr = 0 \\n        for i in range(len(nums)):\\n            curr+=nums[i]\\n            cur_sum.append(curr)\\n        ans = 0\\n        for i in range(len(nums)-1):\\n            first_sum = cur_sum[i]\\n            second_sum = cur_sum[-1] - cur_sum[i]\\n            if first_sum >= second_sum:\\n                ans+=1\\n        return ans \\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def waysToSplitArray(self, nums: List[int]) -> int:\\n        cur_sum = []\\n        curr = 0 \\n        for i in range(len(nums)):\\n            curr+=nums[i]\\n            cur_sum.append(curr)\\n        ans = 0\\n        for i in range(len(nums)-1):\\n            first_sum = cur_sum[i]\\n            second_sum = cur_sum[-1] - cur_sum[i]\\n            if first_sum >= second_sum:\\n                ans+=1\\n        return ans \\n```",
                "codeTag": "Java"
            },
            {
                "id": 3205919,
                "title": "java-why-medium-it-s-easy",
                "content": "# Code\\n```\\nclass Solution {\\n    public int waysToSplitArray(int[] nums) {\\n        long sum = 0;\\n        for(int num : nums){\\n            sum += num;\\n        }\\n        long firstSum = 0;\\n        long lastSum = 0;\\n        int cnt = 0;\\n        for(int i = 0; i < nums.length - 1; i++){\\n            firstSum += nums[i];\\n            lastSum = sum - firstSum;\\n            if(firstSum >= lastSum) cnt++;\\n        }\\n        return cnt;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int waysToSplitArray(int[] nums) {\\n        long sum = 0;\\n        for(int num : nums){\\n            sum += num;\\n        }\\n        long firstSum = 0;\\n        long lastSum = 0;\\n        int cnt = 0;\\n        for(int i = 0; i < nums.length - 1; i++){\\n            firstSum += nums[i];\\n            lastSum = sum - firstSum;\\n            if(firstSum >= lastSum) cnt++;\\n        }\\n        return cnt;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3201329,
                "title": "c-prefix-sum",
                "content": "# Intuition\\nJust keep track of running sum to solve in O(n). \\n\\n# Approach\\n1. Store a prefix sum array \\n2. traverse that array \\n3. keep checking if (till now sum)>(remaining array sum).\\n4. if it is then keep count of it.\\n\\n# Complexity\\n- Time complexity:\\nO(n)\\n\\n- Space complexity:\\nO(n)\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int waysToSplitArray(vector<int>& nums) {int ans=0;\\n        vector<long long int>pf(nums.size());//prefix sum array\\n        pf[0]=nums[0];\\n        for(int i=1;i<nums.size();i++){\\n            pf[i]=pf[i-1]+nums[i];\\n        }\\n                                             int j=pf.size()-1;\\n        for(int i=0;i<pf.size()-1;i++){\\n            \\n            if(pf[i]>=(pf[j]-pf[i]))ans++;//if till now>remaining \\n        }\\n            return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Prefix Sum"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int waysToSplitArray(vector<int>& nums) {int ans=0;\\n        vector<long long int>pf(nums.size());//prefix sum array\\n        pf[0]=nums[0];\\n        for(int i=1;i<nums.size();i++){\\n            pf[i]=pf[i-1]+nums[i];\\n        }\\n                                             int j=pf.size()-1;\\n        for(int i=0;i<pf.size()-1;i++){\\n            \\n            if(pf[i]>=(pf[j]-pf[i]))ans++;//if till now>remaining \\n        }\\n            return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3194934,
                "title": "prefix-sum-c-easiest-8-lines-o-n",
                "content": "<!-- # Intuition -->\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\nFirst calculate the sum of array then traverse from back, and make a variable and adds the sum(currSum) of element from back and check if the calulated sum(pre)-currSum is greater than then currSum then it is the index from where we can split the array and return the count of these indices. \\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity: O(N)\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:O(1)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int waysToSplitArray(vector<int>& nums) {\\n        long long pre=accumulate(nums.begin(),nums.end(),0LL),sum=0,cnt=0;\\n        int n=nums.size();\\n        for(int i=n-1;i>=1;i--){\\n            sum+=nums[i];\\n            if(pre-sum>=sum)\\n                cnt++;\\n        }\\n        return cnt;\\n    }\\n};\\n```\\n\\n*ps:-if u like pls upvote:)*",
                "solutionTags": [
                    "C++",
                    "Prefix Sum"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int waysToSplitArray(vector<int>& nums) {\\n        long long pre=accumulate(nums.begin(),nums.end(),0LL),sum=0,cnt=0;\\n        int n=nums.size();\\n        for(int i=n-1;i>=1;i--){\\n            sum+=nums[i];\\n            if(pre-sum>=sum)\\n                cnt++;\\n        }\\n        return cnt;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3184702,
                "title": "java-easy-solution-with-explanation",
                "content": "**If you like my solution, Please Upvote!!**\\n\\n# Approach\\n1. Calculate the prefix sum.\\n2. If the total sum of the array is known, the calculate the ongoing sum. If current is greater than equal to ongoing sum then increment the counter variable.\\n3. Return the counter.\\n\\n# Complexity\\n- Time complexity: O(n)\\n- Space complexity: O(1)\\n\\n# Code\\n```\\nclass Solution {\\n    public int waysToSplitArray(int[] nums) {\\n        long sum = 0;\\n        int ans = 0;\\n        for(int i=0;i<nums.length;i++){\\n            sum+=nums[i];\\n        }\\n        long curr = 0;\\n        for(int i=0;i<nums.length-1;i++){\\n             curr += nums[i];\\n             sum -= nums[i];\\n             if(curr>=sum) ans++;\\n        }\\n        return ans;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Array",
                    "Prefix Sum"
                ],
                "code": "```\\nclass Solution {\\n    public int waysToSplitArray(int[] nums) {\\n        long sum = 0;\\n        int ans = 0;\\n        for(int i=0;i<nums.length;i++){\\n            sum+=nums[i];\\n        }\\n        long curr = 0;\\n        for(int i=0;i<nums.length-1;i++){\\n             curr += nums[i];\\n             sum -= nums[i];\\n             if(curr>=sum) ans++;\\n        }\\n        return ans;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3184002,
                "title": "c-easy-solution-using-prefix-sum-tc-o-n-sc-o-n",
                "content": "\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int waysToSplitArray(vector<int>& nums) {\\n        long long sum=0,n=nums.size(),c=0;\\n        vector<long long> prefix(n);\\n        for(int i=0;i<nums.size();i++){\\n            sum+=nums[i];\\n            prefix[i]=sum;\\n        }\\n        for(int i=0;i<n-1;i++){\\n            long long left=prefix[i];\\n            long long right=sum-prefix[i];\\n            if(left>=right){\\n                c++;\\n            }\\n        }\\n        return c;\\n    }\\n};\\n```\\n# AUTHOR: JAYESH BADGUJAR",
                "solutionTags": [
                    "C++",
                    "Array",
                    "Prefix Sum"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int waysToSplitArray(vector<int>& nums) {\\n        long long sum=0,n=nums.size(),c=0;\\n        vector<long long> prefix(n);\\n        for(int i=0;i<nums.size();i++){\\n            sum+=nums[i];\\n            prefix[i]=sum;\\n        }\\n        for(int i=0;i<n-1;i++){\\n            long long left=prefix[i];\\n            long long right=sum-prefix[i];\\n            if(left>=right){\\n                c++;\\n            }\\n        }\\n        return c;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3166799,
                "title": "c-easy-solution",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int waysToSplitArray(vector<int>& nums) {\\n        long long totalsum=0;\\n        for(auto i:nums){\\n            totalsum+=i;\\n        }\\n        int n=nums.size();\\n        long long sum=0;\\n        int count=0;\\n        for(int i=0;i<=n-2;i++){\\n            sum+=nums[i];\\n            if(sum>=(totalsum-sum)){\\n                count++;\\n            }\\n        }\\n        return count;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int waysToSplitArray(vector<int>& nums) {\\n        long long totalsum=0;\\n        for(auto i:nums){\\n            totalsum+=i;\\n        }\\n        int n=nums.size();\\n        long long sum=0;\\n        int count=0;\\n        for(int i=0;i<=n-2;i++){\\n            sum+=nums[i];\\n            if(sum>=(totalsum-sum)){\\n                count++;\\n            }\\n        }\\n        return count;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3138303,
                "title": "golang-solution-using-prefix-sum",
                "content": "\\n# Approach\\n- First assign the firstValue into a new array\\n- Loop though the input array from first index to last\\n- Append the sum of current index value and previous index value into newArray\\n- loop though the new array excluding the last element\\n- Check if value in current index > value of last element in new array - current index value\\n- if yes, increment the result counter and later return it\\n\\n# Complexity\\n- Time complexity: O(n)\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:  O(n)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nfunc waysToSplitArray(nums []int) int {\\n    preSumArr := []int{nums[0]}\\n\\tfor i := 1; i < len(nums); i++ {\\n\\t\\tpreSumArr = append(preSumArr, nums[i]+preSumArr[i-1])\\n\\t}\\n\\n\\tvalidArrCounter := 0\\n\\t// note: we need to run this loop excluding the last element\\n\\tfor i := 0; i < len(preSumArr)-1; i++ {\\n\\t\\tif preSumArr[i] >= (preSumArr[len(nums)-1] - preSumArr[i]) {\\n\\t\\t\\tvalidArrCounter++\\n\\t\\t}\\n\\t}\\n\\treturn validArrCounter\\n}\\n```",
                "solutionTags": [
                    "Go"
                ],
                "code": "```\\nfunc waysToSplitArray(nums []int) int {\\n    preSumArr := []int{nums[0]}\\n\\tfor i := 1; i < len(nums); i++ {\\n\\t\\tpreSumArr = append(preSumArr, nums[i]+preSumArr[i-1])\\n\\t}\\n\\n\\tvalidArrCounter := 0\\n\\t// note: we need to run this loop excluding the last element\\n\\tfor i := 0; i < len(preSumArr)-1; i++ {\\n\\t\\tif preSumArr[i] >= (preSumArr[len(nums)-1] - preSumArr[i]) {\\n\\t\\t\\tvalidArrCounter++\\n\\t\\t}\\n\\t}\\n\\treturn validArrCounter\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3128262,
                "title": "simple-java-solution-to-understand",
                "content": "# Complexity\\n- Time complexity:\\n- O(n)\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\nsim# Code\\n```\\nclass Solution {\\n    public int waysToSplitArray(int[] nums) {\\n        long lsum = nums[0];\\n        int count = 0;\\n        long rsum = 0; \\n# take the sum of all number present in array\\n        for(int i = 1 ;i < nums.length;i++){\\n            rsum += nums[i];\\n            }\\n# check the condition\\n        for(int i =1; i<nums.length; i++ ) {\\n        \\tif(lsum>=rsum) {\\n        \\t\\tcount++;\\n        \\t}\\n        \\tlsum +=nums[i];\\n    \\t\\trsum -= nums[i];\\n        }\\n\\t\\treturn count;\\n        \\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Array"
                ],
                "code": "```\\nclass Solution {\\n    public int waysToSplitArray(int[] nums) {\\n        long lsum = nums[0];\\n        int count = 0;\\n        long rsum = 0; \\n# take the sum of all number present in array\\n        for(int i = 1 ;i < nums.length;i++){\\n            rsum += nums[i];\\n            }\\n# check the condition\\n        for(int i =1; i<nums.length; i++ ) {\\n        \\tif(lsum>=rsum) {\\n        \\t\\tcount++;\\n        \\t}\\n        \\tlsum +=nums[i];\\n    \\t\\trsum -= nums[i];\\n        }\\n\\t\\treturn count;\\n        \\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3095634,
                "title": "with-integers-holding-sum-i-am-exceeding-the-max-value-in-test-case-99",
                "content": "# Intuition\\nIt is comparing sum of elements on the left and sum of elements on the right.\\n\\n# Approach\\nGet maximum sum on the right by going through all elements. Go second time through the array, increase left sum by this elements, decrease right sum by this element and compare.\\n\\n# Complexity\\n- Time complexity:\\n$$O(n)$$\\n\\n- Space complexity:\\n$$O(1)$$\\n\\n# Code\\n```\\nclass Solution {\\n    public int waysToSplitArray(int[] nums) {\\n        long sumRight=0;\\n        long sumLeft=0;\\n        int validSplits=0;\\n        for(int i:nums){\\n            sumRight+=i;\\n        }\\n        for(int i=0;i<nums.length-1;i++){\\n            sumLeft+=nums[i];\\n            sumRight-=nums[i];\\n            if(sumLeft>=sumRight) validSplits++;\\n        }\\n        return validSplits;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int waysToSplitArray(int[] nums) {\\n        long sumRight=0;\\n        long sumLeft=0;\\n        int validSplits=0;\\n        for(int i:nums){\\n            sumRight+=i;\\n        }\\n        for(int i=0;i<nums.length-1;i++){\\n            sumLeft+=nums[i];\\n            sumRight-=nums[i];\\n            if(sumLeft>=sumRight) validSplits++;\\n        }\\n        return validSplits;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3086904,
                "title": "easy-to-understand-solution-on-java-in-o-n-prefix-sum",
                "content": "\\n\\n# Approach\\nmake a prefix array of length of nums, find the prefix sum and store at each index of i. \\ntraverse the loop from 0 to n-1 and check if The sum of the first i + 1 elements is greater than or equal to the sum of the last n - i - 1 elements then increment the count.\\n\\n\\n# Complexity\\n- Time complexity:\\nO(n)\\n\\n- Space complexity:\\nO(n)\\n\\n# Code\\n```\\nclass Solution {\\n    public int waysToSplitArray(int[] nums) {\\n        int n = nums.length;\\n        long count=0;\\n        long sum=0;\\n        long pari[]=new long[n];\\n        \\n        for(int i=0;i<n;i++)\\n        {\\n            sum+=nums[i];\\n            pari[i]=sum;\\n        }\\n\\n        for(int i=0;i<n-1;i++)\\n        {\\n            if(pari[i] >= sum - pari[i])\\n            {\\n                count++;\\n            }\\n        }\\n        return (int)count;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int waysToSplitArray(int[] nums) {\\n        int n = nums.length;\\n        long count=0;\\n        long sum=0;\\n        long pari[]=new long[n];\\n        \\n        for(int i=0;i<n;i++)\\n        {\\n            sum+=nums[i];\\n            pari[i]=sum;\\n        }\\n\\n        for(int i=0;i<n-1;i++)\\n        {\\n            if(pari[i] >= sum - pari[i])\\n            {\\n                count++;\\n            }\\n        }\\n        return (int)count;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3064412,
                "title": "simple-solution-explained-c-java",
                "content": "\\n# Complexity\\n- Time complexity:O(N)\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:O(1)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\n    \\npublic:\\n    int waysToSplitArray(vector<int>& nums) {\\n        long long int sum=0,lsum=nums[0],split=0;\\n\\n        // calculating totalsum of array\\n        for(auto i:nums)\\n        {\\n            sum+=i;\\n        }\\n        for(int i=0; i<nums.size(); i++)\\n        {\\n                lsum+=nums[i];\\n                sum-=nums[i];\\n\\n   // checking the condition\\n            if(sum<=lsum)\\n            {\\n               split++;\\n            }\\n                \\n        }\\n        return c;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\n    \\npublic:\\n    int waysToSplitArray(vector<int>& nums) {\\n        long long int sum=0,lsum=nums[0],split=0;\\n\\n        // calculating totalsum of array\\n        for(auto i:nums)\\n        {\\n            sum+=i;\\n        }\\n        for(int i=0; i<nums.size(); i++)\\n        {\\n                lsum+=nums[i];\\n                sum-=nums[i];\\n\\n   // checking the condition\\n            if(sum<=lsum)\\n            {\\n               split++;\\n            }\\n                \\n        }\\n        return c;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3039825,
                "title": "prefix-sum-solution",
                "content": "```\\nclass Solution:\\n    def waysToSplitArray(self, nums: List[int]) -> int:\\n        prefix_sum = list(accumulate(nums))\\n        postfix_sum = list(accumulate(nums, lambda acc, n: acc - n, initial=prefix_sum[-1]))\\n        return sum(1 for i in range(len(nums) - 1) if prefix_sum[i] >= postfix_sum[i + 1])\\n```",
                "solutionTags": [
                    "Python",
                    "Python3",
                    "Prefix Sum"
                ],
                "code": "```\\nclass Solution:\\n    def waysToSplitArray(self, nums: List[int]) -> int:\\n        prefix_sum = list(accumulate(nums))\\n        postfix_sum = list(accumulate(nums, lambda acc, n: acc - n, initial=prefix_sum[-1]))\\n        return sum(1 for i in range(len(nums) - 1) if prefix_sum[i] >= postfix_sum[i + 1])\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3029463,
                "title": "easy-c-solution",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int waysToSplitArray(vector<int>& nums) {\\n        long long int totalSum = 0;\\n        int ctr = 0;\\n        int n = nums.size();\\n        long long int leftSum = 0;\\n        long long int rightSum = 0;\\n\\n        for(int i = 0; i < n; i++)\\n            totalSum += nums[i];\\n        \\n        for(int i = 0; i < n-1; i++){\\n            leftSum += nums[i];\\n            rightSum = totalSum - leftSum;\\n            if(leftSum >= rightSum)\\n                ctr += 1;\\n        }\\n        return ctr;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int waysToSplitArray(vector<int>& nums) {\\n        long long int totalSum = 0;\\n        int ctr = 0;\\n        int n = nums.size();\\n        long long int leftSum = 0;\\n        long long int rightSum = 0;\\n\\n        for(int i = 0; i < n; i++)\\n            totalSum += nums[i];\\n        \\n        for(int i = 0; i < n-1; i++){\\n            leftSum += nums[i];\\n            rightSum = totalSum - leftSum;\\n            if(leftSum >= rightSum)\\n                ctr += 1;\\n        }\\n        return ctr;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3008914,
                "title": "java-solution-using-prefix-sum",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n- we use three variables for prefix sum,total sum ,count\\n- **use long to store sum and prerefix as there will be an overflow in the edge test cases**\\n- find the total sum by interating over the array\\n- then iterate the array till n-2 and do this at every index \\n- pre+=nums[i];\\n- if pre*2>=sum then increment the count\\n# Complexity\\n- Time complexity:O(n)\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:O(1)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\n    public int waysToSplitArray(int[] nums) {\\n        long sum=0,pre=0,count=0;\\n        int i,n=nums.length;\\n        for(i=0;i<n;i++)\\n        {\\n            sum+=nums[i];\\n        }\\n        for(i=0;i<n-1;i++)\\n        {\\n            pre+=nums[i];\\n            if(2*pre>=sum)\\n            count++;\\n        }\\n        return (int)count;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int waysToSplitArray(int[] nums) {\\n        long sum=0,pre=0,count=0;\\n        int i,n=nums.length;\\n        for(i=0;i<n;i++)\\n        {\\n            sum+=nums[i];\\n        }\\n        for(i=0;i<n-1;i++)\\n        {\\n            pre+=nums[i];\\n            if(2*pre>=sum)\\n            count++;\\n        }\\n        return (int)count;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3004115,
                "title": "java-solution-with-o-1-space-complexity",
                "content": "# Complexity\\n- Time complexity:\\nO(n)\\n\\n- Space complexity:\\nO(1) \\uD83E\\uDD29\\uD83E\\uDD29\\uD83E\\uDD29\\uD83E\\uDD29\\uD83E\\uDD29\\uD83E\\uDD29\\uD83E\\uDD29\\n\\n# Code\\n```\\nclass Solution {\\n    public int waysToSplitArray(int[] nums) {\\n        int valid=0;\\n        long sum=0;\\n        for(int i=0;i<nums.length;i++)\\n        sum=sum+nums[i];\\n\\n// System.out.println(\"sum--->\"+sum);\\n        long left=0;\\n        for(int i=0;i<nums.length-1;i++)\\n        {\\n            left=left+nums[i];\\n            long right=sum-left;\\n            if(left>=right)\\n            {\\n                // System.out.println(\"i-->\"+i+\" left--->\"+left);\\n            valid++;\\n            }\\n        }\\n        return valid;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int waysToSplitArray(int[] nums) {\\n        int valid=0;\\n        long sum=0;\\n        for(int i=0;i<nums.length;i++)\\n        sum=sum+nums[i];\\n\\n// System.out.println(\"sum--->\"+sum);\\n        long left=0;\\n        for(int i=0;i<nums.length-1;i++)\\n        {\\n            left=left+nums[i];\\n            long right=sum-left;\\n            if(left>=right)\\n            {\\n                // System.out.println(\"i-->\"+i+\" left--->\"+left);\\n            valid++;\\n            }\\n        }\\n        return valid;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2979558,
                "title": "javascript-solution-2270-number-of-ways-to-split-array",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nUse prefixSum to solve the problem\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\nFirst, get the prefixSum. And then traversing from index: 0 to nums.length - 2 (We need at least one element in both parts). We can get the sum of left part and the sum of right part from prefixSum.\\n\\n# Complexity\\n- Time complexity: O(n)\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: O(n)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\n/**\\n * @param {number[]} nums\\n * @return {number}\\n */\\nvar waysToSplitArray = function(nums) {\\n    let validSplit = 0;\\n    const prefixSum = [nums[0]];\\n\\n    for (let i = 1; i < nums.length; i++) {\\n        prefixSum.push(prefixSum[prefixSum.length - 1] + nums[i]);\\n    }\\n\\n    for (let i = 0; i < nums.length - 1; i++) {\\n        const leftSum = prefixSum[i];\\n        const rightSum = prefixSum[prefixSum.length - 1] - leftSum;\\n        if (leftSum >= rightSum) validSplit++;\\n    }\\n\\n    return validSplit;\\n};\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\n/**\\n * @param {number[]} nums\\n * @return {number}\\n */\\nvar waysToSplitArray = function(nums) {\\n    let validSplit = 0;\\n    const prefixSum = [nums[0]];\\n\\n    for (let i = 1; i < nums.length; i++) {\\n        prefixSum.push(prefixSum[prefixSum.length - 1] + nums[i]);\\n    }\\n\\n    for (let i = 0; i < nums.length - 1; i++) {\\n        const leftSum = prefixSum[i];\\n        const rightSum = prefixSum[prefixSum.length - 1] - leftSum;\\n        if (leftSum >= rightSum) validSplit++;\\n    }\\n\\n    return validSplit;\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2971046,
                "title": "prefix-sum",
                "content": "\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int waysToSplitArray(vector<int>& nums) {\\n        long long int sum=0,temp=0;\\n        int count=0;\\n        for(auto i:nums) sum+=i;\\n        for(int i=1;i<nums.size();i++){\\n            temp+=nums[i-1];\\n            if(temp>=sum-temp)\\n                count++;\\n        }\\n        return count;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int waysToSplitArray(vector<int>& nums) {\\n        long long int sum=0,temp=0;\\n        int count=0;\\n        for(auto i:nums) sum+=i;\\n        for(int i=1;i<nums.size();i++){\\n            temp+=nums[i-1];\\n            if(temp>=sum-temp)\\n                count++;\\n        }\\n        return count;\\n    }\\n};\\n```",
                "codeTag": "Java"
            }
        ],
        "discussions": [
            {
                "id": 1656103,
                "content": [
                    {
                        "username": "gullyboy007",
                        "content": "use \"long long int\"  to store your prefix sum values.will save you a runtime error."
                    },
                    {
                        "username": "PHOENIX2000",
                        "content": "![image](https://assets.leetcode.com/users/images/65374d01-1b3f-43d0-933a-c3e402bf4b3a_1654579173.0506718.png)\\n"
                    },
                    {
                        "username": "iyanuu",
                        "content": "can anyone kindly explain why using a long array works but an int array doesn\\'t pass one of the test cases"
                    },
                    {
                        "username": "kenimaru360",
                        "content": "overflow / underflow"
                    },
                    {
                        "username": "waleedf",
                        "content": "Since the array is much larger in that last test case, what\\'s likely happening is that you reach a certain point where the sum is larger than Integer.MAX_VALUE or smaller than Integer.MIN_VALUE, when that happens in Java the value just wraps around, so you\\'re just getting incorrect results. Refer to this discussion:\\nhttps://stackoverflow.com/questions/3001836/how-does-java-handle-integer-underflows-and-overflows-and-how-would-you-check-fo"
                    },
                    {
                        "username": "aman1080phd",
                        "content": "Please explain the question briefly. I didn\\'t get the condition part."
                    },
                    {
                        "username": "Aman_gupta-9833",
                        "content": "pretty simple, just find a point where you can proof left is greater then right.\nofcourse the right should not empty\n\nand we have to find number of points"
                    }
                ]
            },
            {
                "id": 1576860,
                "content": [
                    {
                        "username": "gullyboy007",
                        "content": "use \"long long int\"  to store your prefix sum values.will save you a runtime error."
                    },
                    {
                        "username": "PHOENIX2000",
                        "content": "![image](https://assets.leetcode.com/users/images/65374d01-1b3f-43d0-933a-c3e402bf4b3a_1654579173.0506718.png)\\n"
                    },
                    {
                        "username": "iyanuu",
                        "content": "can anyone kindly explain why using a long array works but an int array doesn\\'t pass one of the test cases"
                    },
                    {
                        "username": "kenimaru360",
                        "content": "overflow / underflow"
                    },
                    {
                        "username": "waleedf",
                        "content": "Since the array is much larger in that last test case, what\\'s likely happening is that you reach a certain point where the sum is larger than Integer.MAX_VALUE or smaller than Integer.MIN_VALUE, when that happens in Java the value just wraps around, so you\\'re just getting incorrect results. Refer to this discussion:\\nhttps://stackoverflow.com/questions/3001836/how-does-java-handle-integer-underflows-and-overflows-and-how-would-you-check-fo"
                    },
                    {
                        "username": "aman1080phd",
                        "content": "Please explain the question briefly. I didn\\'t get the condition part."
                    },
                    {
                        "username": "Aman_gupta-9833",
                        "content": "pretty simple, just find a point where you can proof left is greater then right.\nofcourse the right should not empty\n\nand we have to find number of points"
                    }
                ]
            },
            {
                "id": 2053483,
                "content": [
                    {
                        "username": "gullyboy007",
                        "content": "use \"long long int\"  to store your prefix sum values.will save you a runtime error."
                    },
                    {
                        "username": "PHOENIX2000",
                        "content": "![image](https://assets.leetcode.com/users/images/65374d01-1b3f-43d0-933a-c3e402bf4b3a_1654579173.0506718.png)\\n"
                    },
                    {
                        "username": "iyanuu",
                        "content": "can anyone kindly explain why using a long array works but an int array doesn\\'t pass one of the test cases"
                    },
                    {
                        "username": "kenimaru360",
                        "content": "overflow / underflow"
                    },
                    {
                        "username": "waleedf",
                        "content": "Since the array is much larger in that last test case, what\\'s likely happening is that you reach a certain point where the sum is larger than Integer.MAX_VALUE or smaller than Integer.MIN_VALUE, when that happens in Java the value just wraps around, so you\\'re just getting incorrect results. Refer to this discussion:\\nhttps://stackoverflow.com/questions/3001836/how-does-java-handle-integer-underflows-and-overflows-and-how-would-you-check-fo"
                    },
                    {
                        "username": "aman1080phd",
                        "content": "Please explain the question briefly. I didn\\'t get the condition part."
                    },
                    {
                        "username": "Aman_gupta-9833",
                        "content": "pretty simple, just find a point where you can proof left is greater then right.\nofcourse the right should not empty\n\nand we have to find number of points"
                    }
                ]
            },
            {
                "id": 1624846,
                "content": [
                    {
                        "username": "gullyboy007",
                        "content": "use \"long long int\"  to store your prefix sum values.will save you a runtime error."
                    },
                    {
                        "username": "PHOENIX2000",
                        "content": "![image](https://assets.leetcode.com/users/images/65374d01-1b3f-43d0-933a-c3e402bf4b3a_1654579173.0506718.png)\\n"
                    },
                    {
                        "username": "iyanuu",
                        "content": "can anyone kindly explain why using a long array works but an int array doesn\\'t pass one of the test cases"
                    },
                    {
                        "username": "kenimaru360",
                        "content": "overflow / underflow"
                    },
                    {
                        "username": "waleedf",
                        "content": "Since the array is much larger in that last test case, what\\'s likely happening is that you reach a certain point where the sum is larger than Integer.MAX_VALUE or smaller than Integer.MIN_VALUE, when that happens in Java the value just wraps around, so you\\'re just getting incorrect results. Refer to this discussion:\\nhttps://stackoverflow.com/questions/3001836/how-does-java-handle-integer-underflows-and-overflows-and-how-would-you-check-fo"
                    },
                    {
                        "username": "aman1080phd",
                        "content": "Please explain the question briefly. I didn\\'t get the condition part."
                    },
                    {
                        "username": "Aman_gupta-9833",
                        "content": "pretty simple, just find a point where you can proof left is greater then right.\nofcourse the right should not empty\n\nand we have to find number of points"
                    }
                ]
            }
        ]
    }
]