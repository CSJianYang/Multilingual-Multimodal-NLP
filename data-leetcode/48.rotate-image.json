[
    {
        "title": "Rotate Image",
        "question_content": "You are given an n x n 2D matrix representing an image, rotate the image by 90 degrees (clockwise).\nYou have to rotate the image in-place, which means you have to modify the input 2D matrix directly. DO NOT allocate another 2D matrix and do the rotation.\n&nbsp;\nExample 1:\n\nInput: matrix = [[1,2,3],[4,5,6],[7,8,9]]\nOutput: [[7,4,1],[8,5,2],[9,6,3]]\n\nExample 2:\n\nInput: matrix = [[5,1,9,11],[2,4,8,10],[13,3,6,7],[15,14,12,16]]\nOutput: [[15,13,2,5],[14,3,4,1],[12,6,8,9],[16,7,10,11]]\n\n&nbsp;\nConstraints:\n\n\tn == matrix.length == matrix[i].length\n\t1 <= n <= 20\n\t-1000 <= matrix[i][j] <= 1000",
        "solutions": [
            {
                "id": 18872,
                "title": "a-common-method-to-rotate-the-image",
                "content": "here give a common method to solve the image rotation problems.\\n    \\n    /*\\n     * clockwise rotate\\n     * first reverse up to down, then swap the symmetry \\n     * 1 2 3     7 8 9     7 4 1\\n     * 4 5 6  => 4 5 6  => 8 5 2\\n     * 7 8 9     1 2 3     9 6 3\\n    */\\n    void rotate(vector<vector<int> > &matrix) {\\n        reverse(matrix.begin(), matrix.end());\\n        for (int i = 0; i < matrix.size(); ++i) {\\n            for (int j = i + 1; j < matrix[i].size(); ++j)\\n                swap(matrix[i][j], matrix[j][i]);\\n        }\\n    }\\n    \\n    /*\\n     * anticlockwise rotate\\n     * first reverse left to right, then swap the symmetry\\n     * 1 2 3     3 2 1     3 6 9\\n     * 4 5 6  => 6 5 4  => 2 5 8\\n     * 7 8 9     9 8 7     1 4 7\\n    */\\n    void anti_rotate(vector<vector<int> > &matrix) {\\n        for (auto vi : matrix) reverse(vi.begin(), vi.end());\\n        for (int i = 0; i < matrix.size(); ++i) {\\n            for (int j = i + 1; j < matrix[i].size(); ++j)\\n                swap(matrix[i][j], matrix[j][i]);\\n        }\\n    }",
                "solutionTags": [],
                "code": "here give a common method to solve the image rotation problems.\\n    \\n    /*\\n     * clockwise rotate\\n     * first reverse up to down, then swap the symmetry \\n     * 1 2 3     7 8 9     7 4 1\\n     * 4 5 6  => 4 5 6  => 8 5 2\\n     * 7 8 9     1 2 3     9 6 3\\n    */\\n    void rotate(vector<vector<int> > &matrix) {\\n        reverse(matrix.begin(), matrix.end());\\n        for (int i = 0; i < matrix.size(); ++i) {\\n            for (int j = i + 1; j < matrix[i].size(); ++j)\\n                swap(matrix[i][j], matrix[j][i]);\\n        }\\n    }\\n    \\n    /*\\n     * anticlockwise rotate\\n     * first reverse left to right, then swap the symmetry\\n     * 1 2 3     3 2 1     3 6 9\\n     * 4 5 6  => 6 5 4  => 2 5 8\\n     * 7 8 9     9 8 7     1 4 7\\n    */\\n    void anti_rotate(vector<vector<int> > &matrix) {\\n        for (auto vi : matrix) reverse(vi.begin(), vi.end());\\n        for (int i = 0; i < matrix.size(); ++i) {\\n            for (int j = i + 1; j < matrix[i].size(); ++j)\\n                swap(matrix[i][j], matrix[j][i]);\\n        }\\n    }",
                "codeTag": "Unknown"
            },
            {
                "id": 18884,
                "title": "seven-short-solutions-1-to-7-lines",
                "content": "While these solutions are Python, I think they're understandable/interesting for non-Python coders as well. But before I begin: No mathematician would call a matrix `matrix`, so I'll use the usual `A`. Also, btw, the 40 ms reached by two of the solutions is I think the fastest achieved by Python solutions so far.\\n\\n---\\n\\n**Most Pythonic - `[::-1]` and `zip`** - 44 ms\\n\\nThe most pythonic solution is a simple one-liner using `[::-1]` to flip the matrix upside down and then `zip` to transpose it. It assigns the result back into `A`, so it's \"in-place\" in a sense and the OJ accepts it as such, though some people might not.\\n\\n    class Solution:\\n        def rotate(self, A):\\n            A[:] = zip(*A[::-1])\\n\\n---\\n\\n**Most Direct** - 52 ms\\n\\nA 100% in-place solution. It even reads and writes each matrix element only once and doesn't even use an extra temporary variable to hold them. It walks over the *\"top-left quadrant\"* of the matrix and directly rotates each element with the three corresponding elements in the other three quadrants. Note that I'm moving the four elements in parallel and that `[~i]` is way nicer than `[n-1-i]`.\\n\\n    class Solution:\\n        def rotate(self, A):\\n            n = len(A)\\n            for i in range(n/2):\\n                for j in range(n-n/2):\\n                    A[i][j], A[~j][i], A[~i][~j], A[j][~i] = \\\\\\n                             A[~j][i], A[~i][~j], A[j][~i], A[i][j]\\n\\n---\\n\\n**Clean Most Pythonic** - 56 ms\\n\\nWhile the OJ accepts the above solution, the the result rows are actually tuples, not lists, so it's a bit dirty. To fix this, we can just apply `list` to every row:\\n\\n    class Solution:\\n        def rotate(self, A):\\n            A[:] = map(list, zip(*A[::-1]))\\n\\n---\\n\\n**List Comprehension** - 60 ms\\n\\nIf you don't like `zip`, you can use a nested list comprehension instead:\\n\\n    class Solution:\\n        def rotate(self, A):\\n            A[:] = [[row[i] for row in A[::-1]] for i in range(len(A))]\\n\\n---\\n\\n**Almost as Direct** - 40 ms\\n\\nIf you don't like the little repetitive code of the above \"Most Direct\" solution, we can instead do each four-cycle of elements by using three swaps of just two elements.\\n\\n    class Solution:\\n        def rotate(self, A):\\n            n = len(A)\\n            for i in range(n/2):\\n                for j in range(n-n/2):\\n                    for _ in '123':\\n                        A[i][j], A[~j][i], i, j = A[~j][i], A[i][j], ~j, ~i\\n                    i = ~j\\n\\n---\\n\\n**Flip Flip** - 40 ms\\n\\nBasically the same as the first solution, but using `reverse` instead of `[::-1]` and transposing the matrix with loops instead of `zip`. It's 100% in-place, just instead of only moving elements around, it also moves the rows around.\\n\\n    class Solution:\\n        def rotate(self, A):\\n            A.reverse()\\n            for i in range(len(A)):\\n                for j in range(i):\\n                    A[i][j], A[j][i] = A[j][i], A[i][j]\\n\\n---\\n\\n**Flip Flip, all by myself** - 48 ms\\n\\nSimilar again, but I first transpose and then flip left-right instead of upside-down, and do it all by myself in loops. This one is 100% in-place again in the sense of just moving the elements.\\n\\n    class Solution:\\n        def rotate(self, A):\\n            n = len(A)\\n            for i in range(n):\\n                for j in range(i):\\n                    A[i][j], A[j][i] = A[j][i], A[i][j]\\n            for row in A:\\n                for j in range(n/2):\\n                    row[j], row[~j] = row[~j], row[j]",
                "solutionTags": [
                    "Python"
                ],
                "code": "While these solutions are Python, I think they're understandable/interesting for non-Python coders as well. But before I begin: No mathematician would call a matrix `matrix`, so I'll use the usual `A`. Also, btw, the 40 ms reached by two of the solutions is I think the fastest achieved by Python solutions so far.\\n\\n---\\n\\n**Most Pythonic - `[::-1]` and `zip`** - 44 ms\\n\\nThe most pythonic solution is a simple one-liner using `[::-1]` to flip the matrix upside down and then `zip` to transpose it. It assigns the result back into `A`, so it's \"in-place\" in a sense and the OJ accepts it as such, though some people might not.\\n\\n    class Solution:\\n        def rotate(self, A):\\n            A[:] = zip(*A[::-1])\\n\\n---\\n\\n**Most Direct** - 52 ms\\n\\nA 100% in-place solution. It even reads and writes each matrix element only once and doesn't even use an extra temporary variable to hold them. It walks over the *\"top-left quadrant\"* of the matrix and directly rotates each element with the three corresponding elements in the other three quadrants. Note that I'm moving the four elements in parallel and that `[~i]` is way nicer than `[n-1-i]`.\\n\\n    class Solution:\\n        def rotate(self, A):\\n            n = len(A)\\n            for i in range(n/2):\\n                for j in range(n-n/2):\\n                    A[i][j], A[~j][i], A[~i][~j], A[j][~i] = \\\\\\n                             A[~j][i], A[~i][~j], A[j][~i], A[i][j]\\n\\n---\\n\\n**Clean Most Pythonic** - 56 ms\\n\\nWhile the OJ accepts the above solution, the the result rows are actually tuples, not lists, so it's a bit dirty. To fix this, we can just apply `list` to every row:\\n\\n    class Solution:\\n        def rotate(self, A):\\n            A[:] = map(list, zip(*A[::-1]))\\n\\n---\\n\\n**List Comprehension** - 60 ms\\n\\nIf you don't like `zip`, you can use a nested list comprehension instead:\\n\\n    class Solution:\\n        def rotate(self, A):\\n            A[:] = [[row[i] for row in A[::-1]] for i in range(len(A))]\\n\\n---\\n\\n**Almost as Direct** - 40 ms\\n\\nIf you don't like the little repetitive code of the above \"Most Direct\" solution, we can instead do each four-cycle of elements by using three swaps of just two elements.\\n\\n    class Solution:\\n        def rotate(self, A):\\n            n = len(A)\\n            for i in range(n/2):\\n                for j in range(n-n/2):\\n                    for _ in '123':\\n                        A[i][j], A[~j][i], i, j = A[~j][i], A[i][j], ~j, ~i\\n                    i = ~j\\n\\n---\\n\\n**Flip Flip** - 40 ms\\n\\nBasically the same as the first solution, but using `reverse` instead of `[::-1]` and transposing the matrix with loops instead of `zip`. It's 100% in-place, just instead of only moving elements around, it also moves the rows around.\\n\\n    class Solution:\\n        def rotate(self, A):\\n            A.reverse()\\n            for i in range(len(A)):\\n                for j in range(i):\\n                    A[i][j], A[j][i] = A[j][i], A[i][j]\\n\\n---\\n\\n**Flip Flip, all by myself** - 48 ms\\n\\nSimilar again, but I first transpose and then flip left-right instead of upside-down, and do it all by myself in loops. This one is 100% in-place again in the sense of just moving the elements.\\n\\n    class Solution:\\n        def rotate(self, A):\\n            n = len(A)\\n            for i in range(n):\\n                for j in range(i):\\n                    A[i][j], A[j][i] = A[j][i], A[i][j]\\n            for row in A:\\n                for j in range(n/2):\\n                    row[j], row[~j] = row[~j], row[j]",
                "codeTag": "Java"
            },
            {
                "id": 18879,
                "title": "ac-java-in-place-solution-with-explanation-easy-to-understand",
                "content": "The idea was firstly transpose the matrix and then flip it symmetrically. For instance, \\n\\n    1  2  3             \\n    4  5  6\\n    7  8  9\\n\\nafter transpose, it will be swap(matrix[i][j], matrix[j][i])\\n\\n    1  4  7\\n    2  5  8\\n    3  6  9\\n\\nThen flip the matrix horizontally.  (swap(matrix[i][j], matrix[i][matrix.length-1-j])\\n\\n    7  4  1\\n    8  5  2\\n    9  6  3\\n\\nHope this helps.\\n\\n    public class Solution {\\n        public void rotate(int[][] matrix) {\\n            for(int i = 0; i<matrix.length; i++){\\n                for(int j = i; j<matrix[0].length; j++){\\n                    int temp = 0;\\n                    temp = matrix[i][j];\\n                    matrix[i][j] = matrix[j][i];\\n                    matrix[j][i] = temp;\\n                }\\n            }\\n            for(int i =0 ; i<matrix.length; i++){\\n                for(int j = 0; j<matrix.length/2; j++){\\n                    int temp = 0;\\n                    temp = matrix[i][j];\\n                    matrix[i][j] = matrix[i][matrix.length-1-j];\\n                    matrix[i][matrix.length-1-j] = temp;\\n                }\\n            }\\n        }\\n    }",
                "solutionTags": [
                    "Java"
                ],
                "code": "class Solution {\\n        public void rotate(int[][] matrix) {\\n            for(int i = 0; i<matrix.length; i++){\\n                for(int j = i; j<matrix[0].length; j++){\\n                    int temp = 0;\\n                    temp = matrix[i][j];\\n                    matrix[i][j] = matrix[j][i];\\n                    matrix[j][i] = temp;\\n                }",
                "codeTag": "Java"
            },
            {
                "id": 3440564,
                "title": "animation-understand-in-30-seconds",
                "content": "*upvoting the answer will motivate me to create more animations! Thanks.*\\n\\n# Approach\\n2 Steps to rotate image\\n- Transpose the matrix\\n- Swap the columns \\n![ezgif.com-optimize.gif](https://assets.leetcode.com/users/images/0ab215cd-9cd8-4872-90a7-901fb660dc67_1682068950.8864057.gif)\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    void rotate(vector<vector<int>>& matrix) {\\n        int row = matrix.size();\\n        for(int i=0;i<row; i++){\\n            for(int j=0; j<=i;j++){\\n                swap(matrix[i][j], matrix[j][i]);\\n            }\\n        }\\n        for(int i=0;i<row;i++){\\n            reverse(matrix[i].begin(), matrix[i].end());\\n        }\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Array",
                    "Matrix"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    void rotate(vector<vector<int>>& matrix) {\\n        int row = matrix.size();\\n        for(int i=0;i<row; i++){\\n            for(int j=0; j<=i;j++){\\n                swap(matrix[i][j], matrix[j][i]);\\n            }\\n        }\\n        for(int i=0;i<row;i++){\\n            reverse(matrix[i].begin(), matrix[i].end());\\n        }\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 19002,
                "title": "4ms-few-lines-c-code-rotate-image-90-degree-for-o-1-space",
                "content": "    void rotate(vector<vector<int>>& matrix) {\\n            int n = matrix.size();\\n            int a = 0;\\n            int b = n-1;\\n            while(a<b){\\n                for(int i=0;i<(b-a);++i){\\n                    swap(matrix[a][a+i], matrix[a+i][b]);\\n                    swap(matrix[a][a+i], matrix[b][b-i]);\\n                    swap(matrix[a][a+i], matrix[b-i][a]);\\n                }\\n                ++a;\\n                --b;\\n            }\\n        }",
                "solutionTags": [],
                "code": "    void rotate(vector<vector<int>>& matrix) {\\n            int n = matrix.size();\\n            int a = 0;\\n            int b = n-1;\\n            while(a<b){\\n                for(int i=0;i<(b-a);++i){\\n                    swap(matrix[a][a+i], matrix[a+i][b]);\\n                    swap(matrix[a][a+i], matrix[b][b-i]);\\n                    swap(matrix[a][a+i], matrix[b-i][a]);\\n                }\\n                ++a;\\n                --b;\\n            }\\n        }",
                "codeTag": "Unknown"
            },
            {
                "id": 842087,
                "title": "easy-python-from-scratch-2-steps",
                "content": "\\t# reverse\\n\\tl = 0\\n\\tr = len(matrix) -1\\n\\twhile l < r:\\n\\t\\tmatrix[l], matrix[r] = matrix[r], matrix[l]\\n\\t\\tl += 1\\n\\t\\tr -= 1\\n\\t# transpose \\n\\tfor i in range(len(matrix)):\\n\\t\\tfor j in range(i):\\n\\t\\t\\tmatrix[i][j], matrix[j][i] = matrix[j][i], matrix[i][j]\\n\\t\\t\\t\\nWe want to rotate\\n[1,2,3],\\n[4,5,6],\\n[7,8,9]\\n->\\n[7,4,1],\\n[8,5,2],\\n[9,6,3]]\\n\\nWe can do this in two steps.\\nReversing the matrix does this:\\n[1,2,3],\\n[4,5,6],\\n[7,8,9]] \\n-> \\n[7, 8, 9],\\n[4, 5, 6], \\n[1, 2, 3]\\n\\nTransposing means: rows become columns, columns become rows.\\n\\n[7, 8, 9], \\n[4, 5, 6], \\n[1, 2, 3]\\n ->\\n[7,4,1],\\n[8,5,2],\\n[9,6,3]\\nIf you like this explanation, please consider giving it a star on my [github](https://github.com/bwiens/leetcode-python). Means a lot to me.",
                "solutionTags": [
                    "Python",
                    "Python3"
                ],
                "code": "\\t# reverse\\n\\tl = 0\\n\\tr = len(matrix) -1\\n\\twhile l < r:\\n\\t\\tmatrix[l], matrix[r] = matrix[r], matrix[l]\\n\\t\\tl += 1\\n\\t\\tr -= 1\\n\\t# transpose \\n\\tfor i in range(len(matrix)):\\n\\t\\tfor j in range(i):\\n\\t\\t\\tmatrix[i][j], matrix[j][i] = matrix[j][i], matrix[i][j]\\n\\t\\t\\t\\nWe want to rotate\\n[1,2,3],\\n[4,5,6],\\n[7,8,9]\\n->\\n[7,4,1],\\n[8,5,2],\\n[9,6,3]]\\n\\nWe can do this in two steps.\\nReversing the matrix does this:\\n[1,2,3],\\n[4,5,6],\\n[7,8,9]] \\n-> \\n[7, 8, 9],\\n[4, 5, 6], \\n[1, 2, 3]\\n\\nTransposing means: rows become columns, columns become rows.\\n\\n[7, 8, 9], \\n[4, 5, 6], \\n[1, 2, 3]\\n ->\\n[7,4,1],\\n[8,5,2],\\n[9,6,3]\\nIf you like this explanation, please consider giving it a star on my [github](https://github.com/bwiens/leetcode-python). Means a lot to me.",
                "codeTag": "Unknown"
            },
            {
                "id": 19123,
                "title": "6-lines-of-code-and-with-o-1-space-in-c",
                "content": "First we transpose the matrix and then reverse every row:\\n \\n   \\n    void rotate(vector<vector<int>>& m) {\\n            int n = m.size();\\n            \\n            for(int i=0; i<n; i++)\\n                for(int j=0; j<i; j++)\\n                    swap(m[i][j], m[j][i]);\\n            \\n            for(int i=0; i<n; i++)\\n                reverse(m[i].begin(), m[i].end());\\n        }",
                "solutionTags": [],
                "code": "First we transpose the matrix and then reverse every row:\\n \\n   \\n    void rotate(vector<vector<int>>& m) {\\n            int n = m.size();\\n            \\n            for(int i=0; i<n; i++)\\n                for(int j=0; j<i; j++)\\n                    swap(m[i][j], m[j][i]);\\n            \\n            for(int i=0; i<n; i++)\\n                reverse(m[i].begin(), m[i].end());\\n        }",
                "codeTag": "Unknown"
            },
            {
                "id": 1175496,
                "title": "js-python-java-c-easy-4-way-swap-solution-w-explanation",
                "content": "*(Note: This is part of a series of Leetcode solution explanations. If you like this solution or find it useful,* ***please upvote*** *this post.)*\\n\\n---\\n\\n#### ***Idea:***\\n\\nThe trick here is to realize that cells in our matrix (**M**) can be swapped out in groups of four in a self-contained manner. This will allow us to keep our **space complexity** down to **O(1)**.\\n\\nThe remaining difficulty lies in setting up our **nested for loops** to accomplish the entirety of these four-way swaps. If we consider each ring of data as a larger iteration, we can notice that each successive ring shortens in the length of its side by **2**. This means that we will need to perform this process to a maximum **depth** of **floor(n / 2)** times. We can use floor here because the center cell of an odd-sided matrix will not need to be swapped.\\n\\nFor each ring, we\\'ll need to perform a number of iterations equal to the length of the side minus 1, since we will have already swapped the far corner as our first iteration. As noticed earlier, the length of the side of a ring is shortened by **2** for each layer of depth we\\'ve achieved (**len = n - 2 * i - 1**).\\n\\nInside the nested for loops, we need to perform a four-way swap between the linked cells. In order to save on some processing, we can store the value of the opposite side of **i** (**opp = n - 1 - i**) as that value will be reused many times over.\\n\\n![Visual 1](https://i.imgur.com/LbkYex3.png)\\n\\nOnce the nested loops are finished, **M** has been successfully transformed in-place.\\n\\n - _**Time Complexity: O(N^2)** where N is the length of each side of the matrix_\\n - _**Space Complexity: O(1)**_\\n\\n---\\n\\n#### ***Implementation:***\\n\\nThere are only minor differences between the code of all four languages.\\n\\n---\\n\\n#### ***Javascript Code:***\\n\\nThe best result for the code below is **72ms / 38.4MB** (beats 94% / 92%).\\n```javascript\\nvar rotate = function(M) {\\n    let n = M.length, depth = ~~(n / 2)\\n    for (let i = 0; i < depth; i++) {\\n        let len = n - 2 * i - 1, opp = n - 1 - i\\n        for (let j = 0; j < len; j++) {\\n            let temp = M[i][i+j]\\n            M[i][i+j] = M[opp-j][i]\\n            M[opp-j][i] = M[opp][opp-j]\\n            M[opp][opp-j] = M[i+j][opp]\\n            M[i+j][opp] = temp\\n        }\\n    }\\n};\\n```\\n\\n---\\n\\n#### ***Python Code:***\\n\\nThe best result for the code below is **28ms / 14.2MB** (beats 95% / 84%).\\n```python\\nclass Solution:\\n    def rotate(self, M: List[List[int]]) -> None:\\n        n = len(M)\\n        depth = n // 2\\n        for i in range(depth):\\n            rlen, opp = n - 2 * i - 1, n - 1 - i\\n            for j in range(rlen):\\n                temp = M[i][i+j]\\n                M[i][i+j] = M[opp-j][i]\\n                M[opp-j][i] = M[opp][opp-j]\\n                M[opp][opp-j] = M[i+j][opp]\\n                M[i+j][opp] = temp\\n```\\n\\n---\\n\\n#### ***Java Code:***\\n\\nThe best result for the code below is **0ms / 38.7MB** (beats 100% / 96%).\\n```java\\nclass Solution {\\n    public void rotate(int[][] M) {\\n        int n = M.length, depth = n / 2;\\n        for (int i = 0; i < depth; i++) {\\n            int len = n - 2 * i - 1, opp = n - 1 - i;\\n            for (int j = 0; j < len; j++) {\\n                int temp = M[i][i+j];\\n                M[i][i+j] = M[opp-j][i];\\n                M[opp-j][i] = M[opp][opp-j];\\n                M[opp][opp-j] = M[i+j][opp];\\n                M[i+j][opp] = temp;\\n            }\\n        }\\n    }\\n}\\n```\\n\\n---\\n\\n#### ***C++ Code:***\\n\\nThe best result for the code below is **0ms / 7.0MB** (beats 100% / 68%).\\n```c++\\nclass Solution {\\npublic:\\n    void rotate(vector<vector<int>>& M) {\\n        int n = M.size(), depth = n / 2;\\n        for (int i = 0; i < depth; i++) {\\n            int len = n - 2 * i - 1, opp = n - 1 - i;\\n            for (int j = 0; j < len; j++) {\\n                int temp = M[i][i+j];\\n                M[i][i+j] = M[opp-j][i];\\n                M[opp-j][i] = M[opp][opp-j];\\n                M[opp][opp-j] = M[i+j][opp];\\n                M[i+j][opp] = temp;\\n            }\\n        }\\n    }\\n};\\n```",
                "solutionTags": [
                    "Java",
                    "Python",
                    "C",
                    "JavaScript"
                ],
                "code": "```javascript\\nvar rotate = function(M) {\\n    let n = M.length, depth = ~~(n / 2)\\n    for (let i = 0; i < depth; i++) {\\n        let len = n - 2 * i - 1, opp = n - 1 - i\\n        for (let j = 0; j < len; j++) {\\n            let temp = M[i][i+j]\\n            M[i][i+j] = M[opp-j][i]\\n            M[opp-j][i] = M[opp][opp-j]\\n            M[opp][opp-j] = M[i+j][opp]\\n            M[i+j][opp] = temp\\n        }\\n    }\\n};\\n```\n```python\\nclass Solution:\\n    def rotate(self, M: List[List[int]]) -> None:\\n        n = len(M)\\n        depth = n // 2\\n        for i in range(depth):\\n            rlen, opp = n - 2 * i - 1, n - 1 - i\\n            for j in range(rlen):\\n                temp = M[i][i+j]\\n                M[i][i+j] = M[opp-j][i]\\n                M[opp-j][i] = M[opp][opp-j]\\n                M[opp][opp-j] = M[i+j][opp]\\n                M[i+j][opp] = temp\\n```\n```java\\nclass Solution {\\n    public void rotate(int[][] M) {\\n        int n = M.length, depth = n / 2;\\n        for (int i = 0; i < depth; i++) {\\n            int len = n - 2 * i - 1, opp = n - 1 - i;\\n            for (int j = 0; j < len; j++) {\\n                int temp = M[i][i+j];\\n                M[i][i+j] = M[opp-j][i];\\n                M[opp-j][i] = M[opp][opp-j];\\n                M[opp][opp-j] = M[i+j][opp];\\n                M[i+j][opp] = temp;\\n            }\\n        }\\n    }\\n}\\n```\n```c++\\nclass Solution {\\npublic:\\n    void rotate(vector<vector<int>>& M) {\\n        int n = M.size(), depth = n / 2;\\n        for (int i = 0; i < depth; i++) {\\n            int len = n - 2 * i - 1, opp = n - 1 - i;\\n            for (int j = 0; j < len; j++) {\\n                int temp = M[i][i+j];\\n                M[i][i+j] = M[opp-j][i];\\n                M[opp-j][i] = M[opp][opp-j];\\n                M[opp][opp-j] = M[i+j][opp];\\n                M[i+j][opp] = temp;\\n            }\\n        }\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 18895,
                "title": "clear-java-solution",
                "content": "    public class Solution {\\n    public void rotate(int[][] matrix) {\\n        int n=matrix.length;\\n        for (int i=0; i<n/2; i++) \\n            for (int j=i; j<n-i-1; j++) {\\n                int tmp=matrix[i][j];\\n                matrix[i][j]=matrix[n-j-1][i];\\n                matrix[n-j-1][i]=matrix[n-i-1][n-j-1];\\n                matrix[n-i-1][n-j-1]=matrix[j][n-i-1];\\n                matrix[j][n-i-1]=tmp;\\n            }\\n        }\\n}",
                "solutionTags": [],
                "code": "class Solution {\\n    public void rotate(int[][] matrix) {\\n        int n=matrix.length;\\n        for (int i=0; i<n/2; i++) \\n            for (int j=i; j<n-i-1; j++) {\\n                int tmp=matrix[i][j];\\n                matrix[i][j]=matrix[n-j-1][i];\\n                matrix[n-j-1][i]=matrix[n-i-1][n-j-1];\\n                matrix[n-i-1][n-j-1]=matrix[j][n-i-1];\\n                matrix[j][n-i-1]=tmp;\\n            }",
                "codeTag": "Java"
            },
            {
                "id": 247174,
                "title": "easy-java-solution-with-explanation-processing-the-matrix-from-outer-to-inner",
                "content": "The basic idea is that we process the matrix from outer to inner. First we process the outer circle of the matrix, and then the inner circle until the side length of the last inner cirlce is smaller than 2(meaning there is only one center element left). For each circle, we exchange elements clockwise and after we finish one circle, we can continue processing the next.\\n\\nFor example, given a ```4*4``` matrix, we first process the outer circle(side length of 4), then process the inner circle(side length of 2).\\n\\n```\\nclass Solution {\\n    public void rotate(int[][] matrix) {\\n        int n = matrix.length;\\n\\t\\t// l is the side length of the matrix we are processing\\n        for(int l = n; l > 1; l -= 2){\\n\\t\\t    // lo is the start index of the matrix we are processing\\n            int lo = (n-l)/2;\\n\\t\\t\\t// hi is the end index of the matrix we are processing\\n            int hi = lo + l -1;\\n            for(int i = 0; i < l-1; i++){\\n\\t\\t\\t    // move number on one side to the other side clockwise\\n                int temp = matrix[hi-i][lo];\\n                matrix[hi-i][lo] = matrix[hi][hi-i];\\n                matrix[hi][hi-i] = matrix[lo+i][hi];\\n                matrix[lo+i][hi] = matrix[lo][lo+i];\\n                matrix[lo][lo+i] = temp;\\n            }\\n        }\\n        return;\\n    }\\n    \\n}\\n```",
                "solutionTags": [],
                "code": "```4*4```\n```\\nclass Solution {\\n    public void rotate(int[][] matrix) {\\n        int n = matrix.length;\\n\\t\\t// l is the side length of the matrix we are processing\\n        for(int l = n; l > 1; l -= 2){\\n\\t\\t    // lo is the start index of the matrix we are processing\\n            int lo = (n-l)/2;\\n\\t\\t\\t// hi is the end index of the matrix we are processing\\n            int hi = lo + l -1;\\n            for(int i = 0; i < l-1; i++){\\n\\t\\t\\t    // move number on one side to the other side clockwise\\n                int temp = matrix[hi-i][lo];\\n                matrix[hi-i][lo] = matrix[hi][hi-i];\\n                matrix[hi][hi-i] = matrix[lo+i][hi];\\n                matrix[lo+i][hi] = matrix[lo][lo+i];\\n                matrix[lo][lo+i] = temp;\\n            }\\n        }\\n        return;\\n    }\\n    \\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3173266,
                "title": "best-c-2-solution-in-place-matrix-optimized-solution-one-stop-solution",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nWe can solve this problem using Two approaches. (Here I have explained all the possible solutions of this problem).\\n\\n1. Solved using Matrix + Math with Extra space.  TC : O(N^2),  SC : O(N^2).\\n2. Solved using Matrix + Math . In-place.  TC : O(N^2),  SC : O(1).\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\nWe can easily understand the All the approaches by seeing the code which is easy to understand with comments.\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\nTime complexity is given in code comment.\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\nSpace complexity is given in code comment.\\n\\n# Code\\n```\\n/*\\n\\n    Time Complexity : O(N^2), Where N is the number of row and column of matrix. Here two nested loops creates\\n    the time complexity.\\n\\n    Space Complexity : O(N^2), temp matrix space.\\n\\n    Solved using Matrix + Math.\\n\\n*/\\n\\n\\n/***************************************** Approach 1 Code *****************************************/\\n\\nclass Solution {\\npublic:\\n    void rotate(vector<vector<int>>& matrix) {\\n        int n = matrix.size();\\n        int m = matrix[0].size();\\n        vector<vector<int>> temp(n, vector<int>(m, 0));\\n        for(int i=0; i<n; i++){\\n            for(int j=0; j<n; j++){\\n                temp[j][n-1-i] = matrix[i][j];\\n\\n            }\\n        }\\n        for(int i=0; i<n; i++){\\n            for(int j=0; j<m; j++){\\n                matrix[i][j] = temp[i][j];\\n            }\\n        }\\n    }\\n};\\n\\n\\n\\n\\n\\n\\n/*\\n\\n    Time Complexity : O(N^2), Where N is the number of row and column of matrix. Here two nested loops creates\\n    the time complexity.\\n\\n    Space Complexity : O(1), Constant space.\\n\\n    Solved using Matrix + Math.\\n\\n*/\\n\\n\\n/***************************************** Approach 2 Code *****************************************/\\n\\nclass Solution {\\npublic:\\n    void rotate(vector<vector<int>>& matrix) {\\n        int n = matrix.size();\\n        int m = matrix[0].size();\\n        vector<vector<int>> temp(n, vector<int>(m, 0));\\n        for(int i=0; i<n; i++){\\n            for(int j=0; j<i; j++){\\n                swap(matrix[i][j], matrix[j][i]);\\n            }\\n        }\\n        for(int i=0; i<n; i++){\\n            reverse(matrix[i].begin(), matrix[i].end());\\n        }\\n    }\\n};\\n\\n```\\n\\n***IF YOU LIKE THE SOLUTION THEN PLEASE UPVOTE MY SOLUTION BECAUSE IT GIVES ME MOTIVATION TO REGULARLY POST THE SOLUTION.***\\n\\n![WhatsApp Image 2023-02-10 at 19.01.02.jpeg](https://assets.leetcode.com/users/images/0a95fea4-64f4-4502-82aa-41db6d77c05c_1676054939.8270252.jpeg)",
                "solutionTags": [
                    "C++",
                    "Array",
                    "Math",
                    "Matrix"
                ],
                "code": "```\\n/*\\n\\n    Time Complexity : O(N^2), Where N is the number of row and column of matrix. Here two nested loops creates\\n    the time complexity.\\n\\n    Space Complexity : O(N^2), temp matrix space.\\n\\n    Solved using Matrix + Math.\\n\\n*/\\n\\n\\n/***************************************** Approach 1 Code *****************************************/\\n\\nclass Solution {\\npublic:\\n    void rotate(vector<vector<int>>& matrix) {\\n        int n = matrix.size();\\n        int m = matrix[0].size();\\n        vector<vector<int>> temp(n, vector<int>(m, 0));\\n        for(int i=0; i<n; i++){\\n            for(int j=0; j<n; j++){\\n                temp[j][n-1-i] = matrix[i][j];\\n\\n            }\\n        }\\n        for(int i=0; i<n; i++){\\n            for(int j=0; j<m; j++){\\n                matrix[i][j] = temp[i][j];\\n            }\\n        }\\n    }\\n};\\n\\n\\n\\n\\n\\n\\n/*\\n\\n    Time Complexity : O(N^2), Where N is the number of row and column of matrix. Here two nested loops creates\\n    the time complexity.\\n\\n    Space Complexity : O(1), Constant space.\\n\\n    Solved using Matrix + Math.\\n\\n*/\\n\\n\\n/***************************************** Approach 2 Code *****************************************/\\n\\nclass Solution {\\npublic:\\n    void rotate(vector<vector<int>>& matrix) {\\n        int n = matrix.size();\\n        int m = matrix[0].size();\\n        vector<vector<int>> temp(n, vector<int>(m, 0));\\n        for(int i=0; i<n; i++){\\n            for(int j=0; j<i; j++){\\n                swap(matrix[i][j], matrix[j][i]);\\n            }\\n        }\\n        for(int i=0; i<n; i++){\\n            reverse(matrix[i].begin(), matrix[i].end());\\n        }\\n    }\\n};\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 367514,
                "title": "python-beats-96-with-image-helps-u-understand",
                "content": "![image](https://assets.leetcode.com/users/disinuo/image_1566823308.png)\\n\\n\\nSee an image as multiple **layers**\\n* `int((n+1)/2)` layers in total need to be rotated\\n* The outer most Layer is the 0th, then 1st, ...\\n* Layer i, its sideLength is `(n-2*i)`\\n* Each Layer has `4` sides\\n* Layer i\\'s each side has (sideLength-1) nodes (=`( n-2*i-1) `nodes), as ImageB\\n\\t* Each node has 3 \"brothers\" on the other 3 sides\\n* So we go layer by layer,  iteratively update each node with same color in ImageB\\n```\\n    def rotate(self, matrix: List[List[int]]) -> None:\\n        def rotate_pos_clockwise(i,j):\\n            return j,self.n-1-i\\n        \\n        n = len(matrix)\\n        self.n = n\\n        if(n<=1): return\\n        for i in range((n+1)//2):\\n            for j in range(i,n-i-1):\\n                up_val = matrix[i][j]\\n                i_right,j_right = rotate_pos_clockwise(i,j)\\n                i_bottom,j_bottom = rotate_pos_clockwise(i_right,j_right)\\n                i_left,j_left = rotate_pos_clockwise(i_bottom,j_bottom)\\n                matrix[i][j] = matrix[i_left][j_left]\\n                matrix[i_left][j_left] = matrix[i_bottom][j_bottom]\\n                matrix[i_bottom][j_bottom] = matrix[i_right][j_right]\\n                matrix[i_right][j_right] = up_val\\n```",
                "solutionTags": [
                    "Python"
                ],
                "code": "```\\n    def rotate(self, matrix: List[List[int]]) -> None:\\n        def rotate_pos_clockwise(i,j):\\n            return j,self.n-1-i\\n        \\n        n = len(matrix)\\n        self.n = n\\n        if(n<=1): return\\n        for i in range((n+1)//2):\\n            for j in range(i,n-i-1):\\n                up_val = matrix[i][j]\\n                i_right,j_right = rotate_pos_clockwise(i,j)\\n                i_bottom,j_bottom = rotate_pos_clockwise(i_right,j_right)\\n                i_left,j_left = rotate_pos_clockwise(i_bottom,j_bottom)\\n                matrix[i][j] = matrix[i_left][j_left]\\n                matrix[i_left][j_left] = matrix[i_bottom][j_bottom]\\n                matrix[i_bottom][j_bottom] = matrix[i_right][j_right]\\n                matrix[i_right][j_right] = up_val\\n```",
                "codeTag": "Python3"
            },
            {
                "id": 808240,
                "title": "c-100-faster-o-n-2-solution",
                "content": "```\\nclass Solution {\\npublic:\\n    void rotate(vector<vector<int>>& matrix) {\\n        int n = matrix.size();\\n        \\n        //first we take transpose of the matrix\\n        for(int i = 0; i < n; ++i){\\n            for(int j = i; j < n; ++j){\\n                swap(matrix[i][j], matrix[j][i]);\\n            }\\n        }\\n        \\n        //then we take mirror image about the middle vertical line\\n        for(int i = 0; i < n; ++i){\\n            reverse(matrix[i].begin(), matrix[i].end());\\n        }\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "C"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    void rotate(vector<vector<int>>& matrix) {\\n        int n = matrix.size();\\n        \\n        //first we take transpose of the matrix\\n        for(int i = 0; i < n; ++i){\\n            for(int j = i; j < n; ++j){\\n                swap(matrix[i][j], matrix[j][i]);\\n            }\\n        }\\n        \\n        //then we take mirror image about the middle vertical line\\n        for(int i = 0; i < n; ++i){\\n            reverse(matrix[i].begin(), matrix[i].end());\\n        }\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 18965,
                "title": "comprehensible-python-solution",
                "content": "```\\nclass Solution(object):\\n    def rotate(self, matrix):\\n        \"\"\"\\n        :type matrix: List[List[int]]\\n        :rtype: void Do not return anything, modify matrix in-place instead.\\n        \"\"\"\\n        n = len(matrix)\\n        for i in xrange(n):\\n            for j in xrange(n):\\n                if i < j:\\n                    matrix[i][j], matrix[j][i] = matrix[j][i], matrix[i][j]\\n        for l in matrix:\\n            l.reverse()\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution(object):\\n    def rotate(self, matrix):\\n        \"\"\"\\n        :type matrix: List[List[int]]\\n        :rtype: void Do not return anything, modify matrix in-place instead.\\n        \"\"\"\\n        n = len(matrix)\\n        for i in xrange(n):\\n            for j in xrange(n):\\n                if i < j:\\n                    matrix[i][j], matrix[j][i] = matrix[j][i], matrix[i][j]\\n        for l in matrix:\\n            l.reverse()\\n```",
                "codeTag": "Java"
            },
            {
                "id": 18888,
                "title": "1-line-in-python",
                "content": "    class Solution(object):\\n        def rotate(self, matrix):\\n            \"\"\"\\n            :type matrix: List[List[int]]\\n            :rtype: void Do not return anything, modify matrix in-place instead.\\n            \"\"\"\\n            matrix[::] = zip(*matrix[::-1])",
                "solutionTags": [
                    "Python"
                ],
                "code": "    class Solution(object):\\n        def rotate(self, matrix):\\n            \"\"\"\\n            :type matrix: List[List[int]]\\n            :rtype: void Do not return anything, modify matrix in-place instead.\\n            \"\"\"\\n            matrix[::] = zip(*matrix[::-1])",
                "codeTag": "Java"
            },
            {
                "id": 2503184,
                "title": "python-easily-understood-faster-than-99-less-than-99",
                "content": "**Appreciate if you could upvote this solution**\\n\\nMethod: `math`\\n\\nIn this question, we just need to swap the values of selected elements\\n\\nCase 1: len(matrix) is even\\n![image](https://assets.leetcode.com/users/images/5412682f-9466-4ec3-a267-3d737323aa24_1661836267.2469985.png)\\n\\nCase 2: len(matrix) is odd\\n![image](https://assets.leetcode.com/users/images/187731dc-60cb-4ccf-b606-e8c9fb369856_1661836327.3667648.png)\\n\\nThe start element of each round swaping are in red background.\\n<br/>\\nCode:\\n```\\ndef rotate(self, matrix: List[List[int]]) -> None:\\n\\tn = len(matrix)\\n\\tfor row in range(math.ceil(n / 2)):\\n\\t\\tfor col in range(int(n - n / 2)):\\n\\t\\t\\t(\\n\\t\\t\\t\\tmatrix[row][col],\\n\\t\\t\\t\\tmatrix[~col][row],\\n\\t\\t\\t\\tmatrix[~row][~col],\\n\\t\\t\\t\\tmatrix[col][~row],\\n\\t\\t\\t) = (\\n\\t\\t\\t\\tmatrix[~col][row],\\n\\t\\t\\t\\tmatrix[~row][~col],\\n\\t\\t\\t\\tmatrix[col][~row],\\n\\t\\t\\t\\tmatrix[row][col],\\n\\t\\t\\t)\\n\\treturn matrix\\n```\\n\\n**Time Complexity**: `O(n^2)`\\n**Space Complexity**: `O(1)`\\n<br/>\\n\\n\\n",
                "solutionTags": [
                    "Python"
                ],
                "code": "```\\ndef rotate(self, matrix: List[List[int]]) -> None:\\n\\tn = len(matrix)\\n\\tfor row in range(math.ceil(n / 2)):\\n\\t\\tfor col in range(int(n - n / 2)):\\n\\t\\t\\t(\\n\\t\\t\\t\\tmatrix[row][col],\\n\\t\\t\\t\\tmatrix[~col][row],\\n\\t\\t\\t\\tmatrix[~row][~col],\\n\\t\\t\\t\\tmatrix[col][~row],\\n\\t\\t\\t) = (\\n\\t\\t\\t\\tmatrix[~col][row],\\n\\t\\t\\t\\tmatrix[~row][~col],\\n\\t\\t\\t\\tmatrix[col][~row],\\n\\t\\t\\t\\tmatrix[row][col],\\n\\t\\t\\t)\\n\\treturn matrix\\n```",
                "codeTag": "Python3"
            },
            {
                "id": 159431,
                "title": "javascript-solution-with-example",
                "content": "```\\nconst rotate = function(matrix){\\n  matrix = matrix.reverse()\\n  for(let i in matrix)\\n    for(let j =0; j<i; j++) [matrix[i][j], matrix[j][i]] = [matrix[j][i], matrix[i][j]]\\n  return matrix\\n}\\n```\\nHere is the input\\n```\\nlet matrix = \\n[\\n  [1,2,3],\\n  [4,5,6],\\n  [7,8,9]\\n]\\n```\\nFirst we reverse the matrix\\n```\\n[\\n  [7,8,9],\\n  [4,5,6],\\n  [1,2,3]\\n]\\n```\\nAnd then we transpose the matrix, please notice the nested loop, basically we exchange these two parts:\\nPart1\\n```\\n[\\n  [ , , ],\\n  [4, , ],\\n  [1,2, ]\\n]\\n```\\nPart2\\n```\\n[\\n  [ ,8,9],\\n  [ , ,6],\\n  [ , , ]\\n]\\n```\\nAnd here you go\\n```\\n[\\n  [7,4,1]\\n  [8,5,2]\\n  [9,6,3]\\n]\\n```",
                "solutionTags": [],
                "code": "```\\nconst rotate = function(matrix){\\n  matrix = matrix.reverse()\\n  for(let i in matrix)\\n    for(let j =0; j<i; j++) [matrix[i][j], matrix[j][i]] = [matrix[j][i], matrix[i][j]]\\n  return matrix\\n}\\n```\n```\\nlet matrix = \\n[\\n  [1,2,3],\\n  [4,5,6],\\n  [7,8,9]\\n]\\n```\n```\\n[\\n  [7,8,9],\\n  [4,5,6],\\n  [1,2,3]\\n]\\n```\n```\\n[\\n  [ , , ],\\n  [4, , ],\\n  [1,2, ]\\n]\\n```\n```\\n[\\n  [ ,8,9],\\n  [ , ,6],\\n  [ , , ]\\n]\\n```\n```\\n[\\n  [7,4,1]\\n  [8,5,2]\\n  [9,6,3]\\n]\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 643965,
                "title": "javascript",
                "content": "```\\n/**\\n * @param {number[][]} matrix\\n * @return {void} Do not return anything, modify matrix in-place instead.\\n */\\nvar rotate = function(matrix) {\\n  for(let i=0;i<matrix.length;i++){\\n      for(let j=i+1;j<matrix[i].length;j++){\\n          let temp = matrix[i][j]\\n          matrix[i][j] = matrix[j][i]\\n          matrix[j][i] = temp\\n      }\\n  }\\n  for(let i=0;i<matrix.length;i++){\\n      matrix[i].reverse()\\n  }  \\n};\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\n/**\\n * @param {number[][]} matrix\\n * @return {void} Do not return anything, modify matrix in-place instead.\\n */\\nvar rotate = function(matrix) {\\n  for(let i=0;i<matrix.length;i++){\\n      for(let j=i+1;j<matrix[i].length;j++){\\n          let temp = matrix[i][j]\\n          matrix[i][j] = matrix[j][i]\\n          matrix[j][i] = temp\\n      }\\n  }\\n  for(let i=0;i<matrix.length;i++){\\n      matrix[i].reverse()\\n  }  \\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 430066,
                "title": "javascript-solution",
                "content": "### The Idea\\n1. Transpose the matrix\\n2. Reverse each row\\n```javascript\\nvar rotate = function(matrix) {\\n    for (let i=0;i<matrix.length;i++) {\\n        for (let j=i;j<matrix[0].length;j++) {\\n            let temp = matrix[i][j];\\n            matrix[i][j] = matrix[j][i];\\n            matrix[j][i] = temp;\\n        }\\n    }\\n\\n    for (let i=0;i<matrix.length;i++) {\\n        for (let j=0;j<matrix[0].length/2;j++) {\\n            let temp = matrix[i][j];\\n            matrix[i][j] = matrix[i][matrix[0].length-j-1];\\n            matrix[i][matrix[0].length-j-1] = temp;\\n        }\\n    }\\n};\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```javascript\\nvar rotate = function(matrix) {\\n    for (let i=0;i<matrix.length;i++) {\\n        for (let j=i;j<matrix[0].length;j++) {\\n            let temp = matrix[i][j];\\n            matrix[i][j] = matrix[j][i];\\n            matrix[j][i] = temp;\\n        }\\n    }\\n\\n    for (let i=0;i<matrix.length;i++) {\\n        for (let j=0;j<matrix[0].length/2;j++) {\\n            let temp = matrix[i][j];\\n            matrix[i][j] = matrix[i][matrix[0].length-j-1];\\n            matrix[i][matrix[0].length-j-1] = temp;\\n        }\\n    }\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1176736,
                "title": "easy-python-solution-99-runtime",
                "content": "Initially this problem seems easy, then it seems hard, then is seems easy once you figure out the trick. \\n\\nThe trick is...\\n\\n**rotating an image 90 degrees is equal to turning the columns into rows then reversing them**\\n\\n```class Solution:\\n    def rotate(self, matrix: List[List[int]]) -> None:\\n        \"\"\"\\n        Do not return anything, modify matrix in-place instead.\\n        \"\"\"\\n        \\n\\t\\t\\n        n = len(matrix)\\n        \\n\\t\\t# iterate through matrix\\n        for i in range(n):\\n            for j in range(i,n):\\n\\t\\t\\t\\n\\t\\t\\t    # transpose the matrix, turning rows into columns and vice versa\\n                matrix[i][j],matrix[j][i] = matrix[j][i],matrix[i][j]\\n\\t\\t\\t\\n\\t\\t\\t# reverse the resulting rows\\n            matrix[i].reverse()\\n\\n\\n```\\n\\nTop 99% EZ! If you learned something please drop me an upvote and let me know in the comment section if you have any questions.\\n\\nCredits to @shubhamverma2604 for the base soln.\\n",
                "solutionTags": [
                    "Python",
                    "Python3"
                ],
                "code": "```class Solution:\\n    def rotate(self, matrix: List[List[int]]) -> None:\\n        \"\"\"\\n        Do not return anything, modify matrix in-place instead.\\n        \"\"\"\\n        \\n\\t\\t\\n        n = len(matrix)\\n        \\n\\t\\t# iterate through matrix\\n        for i in range(n):\\n            for j in range(i,n):\\n\\t\\t\\t\\n\\t\\t\\t    # transpose the matrix, turning rows into columns and vice versa\\n                matrix[i][j],matrix[j][i] = matrix[j][i],matrix[i][j]\\n\\t\\t\\t\\n\\t\\t\\t# reverse the resulting rows\\n            matrix[i].reverse()\\n\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 19098,
                "title": "a-simple-and-in-place-solution-in-java",
                "content": "    public void rotate(int[][] matrix) {\\n        if (matrix == null || matrix.length <= 1) {\\n            return;\\n        }\\n        int n = matrix.length;\\n        for (int i = 0; i < n; i++) {\\n            for (int j = i; j < n; j++) {\\n                int temp = matrix[i][j];\\n                matrix[i][j] = matrix[j][i];\\n                matrix[j][i] = temp;\\n            }\\n        }\\n        for (int i = 0; i < n; i++) {\\n            int head = 0;\\n            int tail = n - 1;\\n            while (head < tail) {\\n                int temp = matrix[i][head];\\n                matrix[i][head] = matrix[i][tail];\\n                matrix[i][tail] = temp;\\n                head++;\\n                tail--;\\n            }\\n        }\\n    }\\nFor example, if the matrix is:<br>\\n1 2 3<br>\\n4 5 6<br>\\n7 8 9<br>\\nthen after the first for loop, it becomes: <br>\\n1 4 7<br>\\n2 5 8<br>\\n3 6 9<br>\\nthen after the second for loop, it becomes: <br>\\n7 4 1<br>\\n8 5 2<br>\\n9 6 3<br>",
                "solutionTags": [
                    "Java"
                ],
                "code": "    public void rotate(int[][] matrix) {\\n        if (matrix == null || matrix.length <= 1) {\\n            return;\\n        }\\n        int n = matrix.length;\\n        for (int i = 0; i < n; i++) {\\n            for (int j = i; j < n; j++) {\\n                int temp = matrix[i][j];\\n                matrix[i][j] = matrix[j][i];\\n                matrix[j][i] = temp;\\n            }\\n        }\\n        for (int i = 0; i < n; i++) {\\n            int head = 0;\\n            int tail = n - 1;\\n            while (head < tail) {\\n                int temp = matrix[i][head];\\n                matrix[i][head] = matrix[i][tail];\\n                matrix[i][tail] = temp;\\n                head++;\\n                tail--;\\n            }\\n        }\\n    }\\nFor example, if the matrix is:<br>\\n1 2 3<br>\\n4 5 6<br>\\n7 8 9<br>\\nthen after the first for loop, it becomes: <br>\\n1 4 7<br>\\n2 5 8<br>\\n3 6 9<br>\\nthen after the second for loop, it becomes: <br>\\n7 4 1<br>\\n8 5 2<br>\\n9 6 3<br>",
                "codeTag": "Unknown"
            },
            {
                "id": 3476226,
                "title": "beats-100-explanation-2-steps-only",
                "content": "# Intuition\\nBy observation, we see that the first column of the original matrix is the reverse of the first row of the rotated matrix, so that\\u2019s why we transpose the matrix and then reverse each row, and since we are making changes in the matrix itself space complexity gets reduced to O(1).\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n2 Step simple approach\\n\\nStep 1: Transpose the matrix. (transposing means changing columns to rows and rows to columns)\\n\\nStep 2: Reverse each row of the matrix.\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time Complexity: O(N^2) + O(N^2). One O(N*N) is for transposing the matrix and the other is for reversing the matrix.\\n\\n- Space Complexity: O(1).\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\n    public void rotate(int[][] matrix) {\\n            // Step 1 - Find transpose of matrix\\n        for(int i=0;i<matrix.length;i++){\\n            for(int j=i;j<matrix[0].length;j++){\\n                int temp=0;\\n                temp= matrix[i][j];\\n                matrix[i][j]= matrix[j][i];\\n                matrix[j][i]= temp;\\n            }\\n        }\\n        // step 2 - Reverse each row of matrix \\n        for(int i=0;i<matrix.length;i++){\\n            for(int j=0;j<matrix.length/2;j++){\\n                int temp= matrix[i][j];\\n                matrix[i][j]= matrix[i][matrix.length-1-j];\\n                matrix[i][matrix.length-1-j]= temp;\\n\\n            }\\n        }\\n        \\n    }\\n}\\n```\\n![images.jpeg](https://assets.leetcode.com/users/images/4002d75c-7ec2-411c-9c5b-dca797ad8505_1683005885.6359031.jpeg)\\n",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public void rotate(int[][] matrix) {\\n            // Step 1 - Find transpose of matrix\\n        for(int i=0;i<matrix.length;i++){\\n            for(int j=i;j<matrix[0].length;j++){\\n                int temp=0;\\n                temp= matrix[i][j];\\n                matrix[i][j]= matrix[j][i];\\n                matrix[j][i]= temp;\\n            }\\n        }\\n        // step 2 - Reverse each row of matrix \\n        for(int i=0;i<matrix.length;i++){\\n            for(int j=0;j<matrix.length/2;j++){\\n                int temp= matrix[i][j];\\n                matrix[i][j]= matrix[i][matrix.length-1-j];\\n                matrix[i][matrix.length-1-j]= temp;\\n\\n            }\\n        }\\n        \\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 401356,
                "title": "rotate-90-clockwise-anti-clockwise-and-rotate-180-degree",
                "content": "```\\nclass Solution {\\n    //1 + 2 = clockwise rotation\\n    //1 + 3 = anti-clockwise rotation\\n    //2 + 3 = 180 degree rotation\\n    int n;\\n    public void rotate(int[][] matrix) {\\n        n = matrix.length;\\n        transpose(matrix);\\n        reverseColumns(matrix);\\n    }\\n    \\n    //1 transpose\\n    private void transpose(int[][] matrix) {\\n        for (int i = 0; i < n; i++) {\\n            for (int j = i + 1; j < n; j++) {\\n                int temp = matrix[i][j];\\n                matrix[i][j] = matrix[j][i];\\n                matrix[j][i] = temp;\\n            }\\n        }\\n    }\\n    \\n    //2 reverse elements in each row\\n    private void reverseColumns(int[][] matrix) {\\n        for (int i = 0; i < n; i++) {\\n            for (int j = 0; j < n / 2; j++) {\\n                int temp = matrix[i][j];\\n                matrix[i][j] = matrix[i][n - 1 - j];\\n                matrix[i][n - 1 - j] = temp;\\n            }\\n        }\\n    }\\n    \\n    //3 reverse elements in each columns\\n    private void reverseRows(int[][] matrix) {\\n        for (int j = 0; j < n; j++) {\\n            for (int i = 0; i < n / 2; i++) {\\n                int temp = matrix[i][j];\\n                matrix[i][j] = matrix[n - 1 - i][j];\\n                matrix[n - 1 - i][j] = temp;\\n            }\\n        }\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    //1 + 2 = clockwise rotation\\n    //1 + 3 = anti-clockwise rotation\\n    //2 + 3 = 180 degree rotation\\n    int n;\\n    public void rotate(int[][] matrix) {\\n        n = matrix.length;\\n        transpose(matrix);\\n        reverseColumns(matrix);\\n    }\\n    \\n    //1 transpose\\n    private void transpose(int[][] matrix) {\\n        for (int i = 0; i < n; i++) {\\n            for (int j = i + 1; j < n; j++) {\\n                int temp = matrix[i][j];\\n                matrix[i][j] = matrix[j][i];\\n                matrix[j][i] = temp;\\n            }\\n        }\\n    }\\n    \\n    //2 reverse elements in each row\\n    private void reverseColumns(int[][] matrix) {\\n        for (int i = 0; i < n; i++) {\\n            for (int j = 0; j < n / 2; j++) {\\n                int temp = matrix[i][j];\\n                matrix[i][j] = matrix[i][n - 1 - j];\\n                matrix[i][n - 1 - j] = temp;\\n            }\\n        }\\n    }\\n    \\n    //3 reverse elements in each columns\\n    private void reverseRows(int[][] matrix) {\\n        for (int j = 0; j < n; j++) {\\n            for (int i = 0; i < n / 2; i++) {\\n                int temp = matrix[i][j];\\n                matrix[i][j] = matrix[n - 1 - i][j];\\n                matrix[n - 1 - i][j] = temp;\\n            }\\n        }\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 337825,
                "title": "cpp-solution-faster-than-100-solns-better-memory-than-99-95",
                "content": "Transpose the matrix initially, and then reverse rows of the matrix.\\n\\n\\tclass Solution {\\n\\tpublic:\\n\\tvoid rotate(vector<vector<int>>& matrix) \\n    {\\n        int n = matrix.size();\\n        \\n        for(int i=0; i<n; i++)\\n        {\\n            for(int j=i; j<n; j++)\\n            {\\n                int temp = matrix[i][j];\\n                matrix[i][j] = matrix[j][i];\\n                matrix[j][i] = temp;\\n            }\\n        }\\n        \\n        for(int i=0; i<n; i++)\\n        {\\n            reverse(matrix[i].begin(), matrix[i].end());\\n        }\\n    }\\n\\t};",
                "solutionTags": [
                    "C++"
                ],
                "code": "class Solution {\\n\\tpublic:\\n\\tvoid rotate(vector<vector<int>>& matrix) \\n    {\\n        int n = matrix.size();\\n        \\n        for(int i=0; i<n; i++)\\n        {\\n            for(int j=i; j<n; j++)\\n            {\\n                int temp = matrix[i][j];\\n                matrix[i][j] = matrix[j][i];\\n                matrix[j][i] = temp;\\n            }",
                "codeTag": "Java"
            },
            {
                "id": 1175659,
                "title": "short-easy-solutions-w-clear-explanation-diagrams",
                "content": "\\u2714\\uFE0F ***Solution - I (Swap Group of 4s)***\\n\\nWe can observe that after 90\\xB0 rotation, we have essentially swapped each group of 4 cells in clockwise direction. The swapping occurs as -\\n\\n<span><p align=center><img src = https://assets.leetcode.com/users/images/873f1aad-ba3e-4177-b9e8-af30a0809202_1619338999.1282618.png height = 400 /></p></span>\\n\\nNow, we can iterate over each row of matrix. For each first half of the rows, we will have `n / 2` groups of 4 cells which need to be swapped cyclically (Note: not `n` groups which will result in 180\\xB0 rotation). We will swap them cyclically till first half rows of the matrix (not all the rows which wrongly rewrite over previous swaps).\\n\\nThe swap groups would be like these -\\n\\n<p align=center><img src = https://assets.leetcode.com/users/images/d4bb47e5-f9ad-4f9b-b20e-639bb70bb323_1619339168.4737794.png width = 400 /></p>\\n\\nThe colors denote the collection of group of cells from each row. For eg. The first outer iteration would involve the cells - `[ [1,2,3], [7,7,7], [5,6,7], [1,1,1] ]`. In the inner iteration, each of the cell in one of these subarrays would be swapped clockwise with the corresponding cell in the next subarray\\n\\nThe only difficult thing that remains now is manipulating the variables in our loop to swap the correct group of 4 cells. It can be derived by working out a few examples. I would suggest to try it on your own before seeing the solution below.\\n\\n```\\nvoid rotate(vector<vector<int>>& m) {\\n\\tint n = size(m), tmp;\\n\\tfor(int i = 0; i < (n + 1) / 2; i++){\\n\\t\\tfor(int j = 0; j < n / 2; j++){\\n\\t\\t\\ttmp = m[n - 1 - j][i];\\n\\t\\t\\tm[n - 1 - j][i] = m[n - 1 - i][n - 1 - j];\\n\\t\\t\\tm[n - 1 - i][n - 1 - j] = m[j][n - 1 - i];\\n\\t\\t\\tm[j][n - 1 - i] = m[i][j];                \\n\\t\\t\\tm[i][j] = tmp;\\n\\t\\t}\\n\\t}        \\n}\\n```\\n\\n***Time Complexity :*** **`O(N^2)`**\\n***Space Complexity :*** **`O(1)`**\\n\\n---\\n\\n\\u2714\\uFE0F ***Solution - II (Swap Ring-by-Ring)***\\n\\nWe can also choose to swap one ring after another which personally seems more intuitive solution that the first one. Here, we will swap all the cells of outer ring, then the inner ring till the inner-most ring.\\n\\n<p align=center><img src = https://assets.leetcode.com/users/images/e2c3496c-9e15-430b-8614-5d83fe9d8eac_1619344342.7277594.png width = 450 /></p>\\n\\n\\nIn the above image, the color denote different rings being swapped one after another, the subscript **`1.x, 2.x, 3.x...`** (where `1<=x<=4`) denotes a group of 4 cells. Each group of 4 cells will be swapped clockwise one after another starting from outermost ring to innermost ring.\\n\\n```\\nvoid rotate(vector<vector<int>>& m) {\\n\\tint n = size(m), tmp;\\n\\tfor(int i = 0; i < n / 2; i++){\\n\\t\\tfor(int j = i; j < n - 1 - i; j++){\\n\\t\\t\\ttmp = m[i][j];\\n\\t\\t\\tm[i][j] = m[n - 1 - j][i];\\n\\t\\t\\tm[n - 1 - j][i] = m[n - 1 - i][n - 1 - j];\\n\\t\\t\\tm[n - 1 - i][n - 1 - j] = m[j][n - 1 - i];\\n\\t\\t\\tm[j][n - 1 - i] = tmp;\\n\\t\\t}            \\n\\t}\\n}\\n```\\n\\n\\n\\n\\n***Time Complexity :*** **`O(N^2)`**\\n***Space Complexity :*** **`O(1)`**\\n\\n  \\n---\\n---\\n\\n\\uD83D\\uDCBB\\uD83D\\uDC31\\u200D\\uD83D\\uDCBBIf there are any suggestions / questions / mistakes in my post, please do comment below \\uD83D\\uDC47 \\n\\n---\\n---",
                "solutionTags": [
                    "C"
                ],
                "code": "```\\nvoid rotate(vector<vector<int>>& m) {\\n\\tint n = size(m), tmp;\\n\\tfor(int i = 0; i < (n + 1) / 2; i++){\\n\\t\\tfor(int j = 0; j < n / 2; j++){\\n\\t\\t\\ttmp = m[n - 1 - j][i];\\n\\t\\t\\tm[n - 1 - j][i] = m[n - 1 - i][n - 1 - j];\\n\\t\\t\\tm[n - 1 - i][n - 1 - j] = m[j][n - 1 - i];\\n\\t\\t\\tm[j][n - 1 - i] = m[i][j];                \\n\\t\\t\\tm[i][j] = tmp;\\n\\t\\t}\\n\\t}        \\n}\\n```\n```\\nvoid rotate(vector<vector<int>>& m) {\\n\\tint n = size(m), tmp;\\n\\tfor(int i = 0; i < n / 2; i++){\\n\\t\\tfor(int j = i; j < n - 1 - i; j++){\\n\\t\\t\\ttmp = m[i][j];\\n\\t\\t\\tm[i][j] = m[n - 1 - j][i];\\n\\t\\t\\tm[n - 1 - j][i] = m[n - 1 - i][n - 1 - j];\\n\\t\\t\\tm[n - 1 - i][n - 1 - j] = m[j][n - 1 - i];\\n\\t\\t\\tm[j][n - 1 - i] = tmp;\\n\\t\\t}            \\n\\t}\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1355993,
                "title": "solution-swift-rotate-image",
                "content": "```swift\\nclass Solution {\\n    func rotate(_ mat: inout [[Int]]) {\\n        let len = mat.count\\n        for i in 0..<len {\\n            for n in i..<len {\\n                let tmp = mat[i][n]\\n                mat[i][n] = mat[n][i]\\n                mat[n][i] = tmp\\n            }\\n            for n in 0..<(len / 2) {\\n                let tmp = mat[i][n], l = len\\n                mat[i][n] = mat[i][l - 1 - n]\\n                mat[i][l - 1 - n] = tmp\\n            }\\n        }\\n    }\\n}\\n```\\n\\n<hr>\\n\\n<details>\\n<summary><img src=\"https://git.io/JDblm\" height=\"24\"> <b>TEST CASES</b></summary>\\n\\n<pre>\\nResult: Executed 2 tests, with 0 failures (0 unexpected) in 0.012 (0.014) seconds\\n</pre>\\n\\n```swift\\nimport XCTest\\n\\nclass Tests: XCTestCase {\\n    \\n    private let solution = Solution()\\n    \\n    func test0() {\\n        var arr = [[1,2,3],[4,5,6],[7,8,9]]\\n        solution.rotate(&arr)\\n        XCTAssertEqual(arr, [[7,4,1],[8,5,2],[9,6,3]])\\n    }\\n    \\n    func test1() {\\n        var arr = [[5,1,9,11],[2,4,8,10],[13,3,6,7],[15,14,12,16]]\\n        solution.rotate(&arr)\\n        XCTAssertEqual(arr, [[15,13,2,5],[14,3,4,1],[12,6,8,9],[16,7,10,11]])\\n    }\\n}\\n\\nTests.defaultTestSuite.run()\\n```\\n\\n</details>",
                "solutionTags": [
                    "Swift"
                ],
                "code": "```swift\\nclass Solution {\\n    func rotate(_ mat: inout [[Int]]) {\\n        let len = mat.count\\n        for i in 0..<len {\\n            for n in i..<len {\\n                let tmp = mat[i][n]\\n                mat[i][n] = mat[n][i]\\n                mat[n][i] = tmp\\n            }\\n            for n in 0..<(len / 2) {\\n                let tmp = mat[i][n], l = len\\n                mat[i][n] = mat[i][l - 1 - n]\\n                mat[i][l - 1 - n] = tmp\\n            }\\n        }\\n    }\\n}\\n```\n```swift\\nimport XCTest\\n\\nclass Tests: XCTestCase {\\n    \\n    private let solution = Solution()\\n    \\n    func test0() {\\n        var arr = [[1,2,3],[4,5,6],[7,8,9]]\\n        solution.rotate(&arr)\\n        XCTAssertEqual(arr, [[7,4,1],[8,5,2],[9,6,3]])\\n    }\\n    \\n    func test1() {\\n        var arr = [[5,1,9,11],[2,4,8,10],[13,3,6,7],[15,14,12,16]]\\n        solution.rotate(&arr)\\n        XCTAssertEqual(arr, [[15,13,2,5],[14,3,4,1],[12,6,8,9],[16,7,10,11]])\\n    }\\n}\\n\\nTests.defaultTestSuite.run()\\n```",
                "codeTag": "Java"
            },
            {
                "id": 714590,
                "title": "c-easy-to-understand-detailed-explanation",
                "content": "```\\nclass Solution {\\npublic:\\n    /*\\n    Step 1: Swapping through the diagonal\\n    \\n    1 2 3               1 4 7\\n    4 5 6       ----->  2 5 8\\n    7 8 9               3 6 9\\n    \\n    Step 2: Swapping through the mid column\\n        \\n    1 4 7               7 4 1\\n    2 5 8       ----->  8 5 2\\n    7 8 9               9 6 3\\n    \\n    */\\n    void rotate(vector<vector<int>>& matrix) {\\n        int n = matrix.size();\\n        for(int i=0;i<n;i++){\\n            for(int j=0;j<=i;j++){\\n                swap(matrix[i][j],matrix[j][i]);\\n            }\\n        }\\n        for(int i=0;i<n;i++){\\n            for(int j=0;j<(int)n/2;j++){\\n                swap(matrix[i][j], matrix[i][n-j-1]);\\n            }\\n        }\\n    }\\n};\\n```\\nFeel free to ask any doubts in the **comment** section.\\nIf you like this solution, please **UPVOTE**.\\nHappy Coding :)",
                "solutionTags": [
                    "C++",
                    "C"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    /*\\n    Step 1: Swapping through the diagonal\\n    \\n    1 2 3               1 4 7\\n    4 5 6       ----->  2 5 8\\n    7 8 9               3 6 9\\n    \\n    Step 2: Swapping through the mid column\\n        \\n    1 4 7               7 4 1\\n    2 5 8       ----->  8 5 2\\n    7 8 9               9 6 3\\n    \\n    */\\n    void rotate(vector<vector<int>>& matrix) {\\n        int n = matrix.size();\\n        for(int i=0;i<n;i++){\\n            for(int j=0;j<=i;j++){\\n                swap(matrix[i][j],matrix[j][i]);\\n            }\\n        }\\n        for(int i=0;i<n;i++){\\n            for(int j=0;j<(int)n/2;j++){\\n                swap(matrix[i][j], matrix[i][n-j-1]);\\n            }\\n        }\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1540098,
                "title": "multiple-c-solutions",
                "content": "\\n> **If you\\u2019re interested in coding you can join my Discord Server, link in the comment section. Also if you find any mistakes please let me know. Thank you!\\u2764\\uFE0F**\\n> \\n\\n---\\n# Method 01\\n```\\nclass Solution {\\npublic:\\n    void rotate(vector<vector<int>>& matrix) {\\n        int n= matrix.size();\\n        int rs=0, re=n-1, cs=0, ce=n-1, i ,j;\\n        while(rs<re && cs<ce){\\n            for(i=cs; i<ce; i++){\\n                swap(matrix[rs][i],matrix[i][ce]);\\n            }\\n            for(i=re; i>rs; i--){\\n                swap(matrix[ce][i],matrix[i][cs]);\\n            }\\n            for(i=cs,j=ce; i<ce,j>cs; i++,j--){\\n                swap(matrix[rs][i], matrix[re][j]);\\n            }\\n            rs++;re--;cs++;ce--;\\n        }\\n    }\\n};\\n```\\n\\n# Method 02\\n```\\nclass Solution {\\npublic:\\n    void rotate(vector<vector<int>>& M) {\\n        int n = M.size(), depth = n / 2;\\n        for (int i = 0; i < depth; i++) {\\n            int len = n - 2 * i - 1, opp = n - 1 - i;\\n            for (int j = 0; j < len; j++) {\\n                int temp = M[i][i+j];\\n                M[i][i+j] = M[opp-j][i];\\n                M[opp-j][i] = M[opp][opp-j];\\n                M[opp][opp-j] = M[i+j][opp];\\n                M[i+j][opp] = temp;\\n            }\\n        }\\n    }\\n};\\n```\\n\\n# Method 03\\n```\\nclass Solution {\\npublic:\\n    void rotate(vector<vector<int>>& M) {\\n        int n = M.size();\\n        \\n        //First transpose the matrix once!\\n        for (int i = 0; i < n; i++) {\\n            for (int j = 0; j < i; j++) {\\n               swap(M[i][j], M[j][i]);\\n            }\\n        }\\n        \\n        //Reverse every column!\\n        for(int i=0; i<n; i++){\\n            reverse(M[i].begin(), M[i].end());\\n        }\\n    }\\n};\\n```\\n---\\n***Please upvote if you find helpful! Thank you!***",
                "solutionTags": [
                    "C++",
                    "C",
                    "Matrix"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    void rotate(vector<vector<int>>& matrix) {\\n        int n= matrix.size();\\n        int rs=0, re=n-1, cs=0, ce=n-1, i ,j;\\n        while(rs<re && cs<ce){\\n            for(i=cs; i<ce; i++){\\n                swap(matrix[rs][i],matrix[i][ce]);\\n            }\\n            for(i=re; i>rs; i--){\\n                swap(matrix[ce][i],matrix[i][cs]);\\n            }\\n            for(i=cs,j=ce; i<ce,j>cs; i++,j--){\\n                swap(matrix[rs][i], matrix[re][j]);\\n            }\\n            rs++;re--;cs++;ce--;\\n        }\\n    }\\n};\\n```\n```\\nclass Solution {\\npublic:\\n    void rotate(vector<vector<int>>& M) {\\n        int n = M.size(), depth = n / 2;\\n        for (int i = 0; i < depth; i++) {\\n            int len = n - 2 * i - 1, opp = n - 1 - i;\\n            for (int j = 0; j < len; j++) {\\n                int temp = M[i][i+j];\\n                M[i][i+j] = M[opp-j][i];\\n                M[opp-j][i] = M[opp][opp-j];\\n                M[opp][opp-j] = M[i+j][opp];\\n                M[i+j][opp] = temp;\\n            }\\n        }\\n    }\\n};\\n```\n```\\nclass Solution {\\npublic:\\n    void rotate(vector<vector<int>>& M) {\\n        int n = M.size();\\n        \\n        //First transpose the matrix once!\\n        for (int i = 0; i < n; i++) {\\n            for (int j = 0; j < i; j++) {\\n               swap(M[i][j], M[j][i]);\\n            }\\n        }\\n        \\n        //Reverse every column!\\n        for(int i=0; i<n; i++){\\n            reverse(M[i].begin(), M[i].end());\\n        }\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1175498,
                "title": "rotate-image-js-python-java-c-easy-4-way-swap-solution-w-explanation",
                "content": "*(Note: This is part of a series of Leetcode solution explanations. If you like this solution or find it useful,* ***please upvote*** *this post.)*\\n\\n---\\n\\n#### ***Idea:***\\n\\nThe trick here is to realize that cells in our matrix (**M**) can be swapped out in groups of four in a self-contained manner. This will allow us to keep our **space complexity** down to **O(1)**.\\n\\nThe remaining difficulty lies in setting up our **nested for loops** to accomplish the entirety of these four-way swaps. If we consider each ring of data as a larger iteration, we can notice that each successive ring shortens in the length of its side by **2**. This means that we will need to perform this process to a maximum **depth** of **floor(n / 2)** times. We can use floor here because the center cell of an odd-sided matrix will not need to be swapped.\\n\\nFor each ring, we\\'ll need to perform a number of iterations equal to the length of the side minus 1, since we will have already swapped the far corner as our first iteration. As noticed earlier, the length of the side of a ring is shortened by **2** for each layer of depth we\\'ve achieved (**len = n - 2 * i - 1**).\\n\\nInside the nested for loops, we need to perform a four-way swap between the linked cells. In order to save on some processing, we can store the value of the opposite side of **i** (**opp = n - 1 - i**) as that value will be reused many times over.\\n\\n![Visual 1](https://i.imgur.com/LbkYex3.png)\\n\\nOnce the nested loops are finished, **M** has been successfully transformed in-place.\\n\\n - _**Time Complexity: O(N^2)** where N is the length of each side of the matrix_\\n - _**Space Complexity: O(1)**_\\n\\n---\\n\\n#### ***Implementation:***\\n\\nThere are only minor differences between the code of all four languages.\\n\\n---\\n\\n#### ***Javascript Code:***\\n\\nThe best result for the code below is **72ms / 38.4MB** (beats 94% / 92%).\\n```javascript\\nvar rotate = function(M) {\\n    let n = M.length, depth = ~~(n / 2)\\n    for (let i = 0; i < depth; i++) {\\n        let len = n - 2 * i - 1, opp = n - 1 - i\\n        for (let j = 0; j < len; j++) {\\n            let temp = M[i][i+j]\\n            M[i][i+j] = M[opp-j][i]\\n            M[opp-j][i] = M[opp][opp-j]\\n            M[opp][opp-j] = M[i+j][opp]\\n            M[i+j][opp] = temp\\n        }\\n    }\\n};\\n```\\n\\n---\\n\\n#### ***Python Code:***\\n\\nThe best result for the code below is **28ms / 14.2MB** (beats 95% / 84%).\\n```python\\nclass Solution:\\n    def rotate(self, M: List[List[int]]) -> None:\\n        n = len(M)\\n        depth = n // 2\\n        for i in range(depth):\\n            rlen, opp = n - 2 * i - 1, n - 1 - i\\n            for j in range(rlen):\\n                temp = M[i][i+j]\\n                M[i][i+j] = M[opp-j][i]\\n                M[opp-j][i] = M[opp][opp-j]\\n                M[opp][opp-j] = M[i+j][opp]\\n                M[i+j][opp] = temp\\n```\\n\\n---\\n\\n#### ***Java Code:***\\n\\nThe best result for the code below is **0ms / 38.7MB** (beats 100% / 96%).\\n```java\\nclass Solution {\\n    public void rotate(int[][] M) {\\n        int n = M.length, depth = n / 2;\\n        for (int i = 0; i < depth; i++) {\\n            int len = n - 2 * i - 1, opp = n - 1 - i;\\n            for (int j = 0; j < len; j++) {\\n                int temp = M[i][i+j];\\n                M[i][i+j] = M[opp-j][i];\\n                M[opp-j][i] = M[opp][opp-j];\\n                M[opp][opp-j] = M[i+j][opp];\\n                M[i+j][opp] = temp;\\n            }\\n        }\\n    }\\n}\\n```\\n\\n---\\n\\n#### ***C++ Code:***\\n\\nThe best result for the code below is **0ms / 7.0MB** (beats 100% / 68%).\\n```c++\\nclass Solution {\\npublic:\\n    void rotate(vector<vector<int>>& M) {\\n        int n = M.size(), depth = n / 2;\\n        for (int i = 0; i < depth; i++) {\\n            int len = n - 2 * i - 1, opp = n - 1 - i;\\n            for (int j = 0; j < len; j++) {\\n                int temp = M[i][i+j];\\n                M[i][i+j] = M[opp-j][i];\\n                M[opp-j][i] = M[opp][opp-j];\\n                M[opp][opp-j] = M[i+j][opp];\\n                M[i+j][opp] = temp;\\n            }\\n        }\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```javascript\\nvar rotate = function(M) {\\n    let n = M.length, depth = ~~(n / 2)\\n    for (let i = 0; i < depth; i++) {\\n        let len = n - 2 * i - 1, opp = n - 1 - i\\n        for (let j = 0; j < len; j++) {\\n            let temp = M[i][i+j]\\n            M[i][i+j] = M[opp-j][i]\\n            M[opp-j][i] = M[opp][opp-j]\\n            M[opp][opp-j] = M[i+j][opp]\\n            M[i+j][opp] = temp\\n        }\\n    }\\n};\\n```\n```python\\nclass Solution:\\n    def rotate(self, M: List[List[int]]) -> None:\\n        n = len(M)\\n        depth = n // 2\\n        for i in range(depth):\\n            rlen, opp = n - 2 * i - 1, n - 1 - i\\n            for j in range(rlen):\\n                temp = M[i][i+j]\\n                M[i][i+j] = M[opp-j][i]\\n                M[opp-j][i] = M[opp][opp-j]\\n                M[opp][opp-j] = M[i+j][opp]\\n                M[i+j][opp] = temp\\n```\n```java\\nclass Solution {\\n    public void rotate(int[][] M) {\\n        int n = M.length, depth = n / 2;\\n        for (int i = 0; i < depth; i++) {\\n            int len = n - 2 * i - 1, opp = n - 1 - i;\\n            for (int j = 0; j < len; j++) {\\n                int temp = M[i][i+j];\\n                M[i][i+j] = M[opp-j][i];\\n                M[opp-j][i] = M[opp][opp-j];\\n                M[opp][opp-j] = M[i+j][opp];\\n                M[i+j][opp] = temp;\\n            }\\n        }\\n    }\\n}\\n```\n```c++\\nclass Solution {\\npublic:\\n    void rotate(vector<vector<int>>& M) {\\n        int n = M.size(), depth = n / 2;\\n        for (int i = 0; i < depth; i++) {\\n            int len = n - 2 * i - 1, opp = n - 1 - i;\\n            for (int j = 0; j < len; j++) {\\n                int temp = M[i][i+j];\\n                M[i][i+j] = M[opp-j][i];\\n                M[opp-j][i] = M[opp][opp-j];\\n                M[opp][opp-j] = M[i+j][opp];\\n                M[i+j][opp] = temp;\\n            }\\n        }\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1513245,
                "title": "java-tc-o-n-2-sc-o-1-two-optimal-ways-of-solving-this-question",
                "content": "**Rotate the matrix on horizontal axis (swap rows) and then transpose to get the result**\\n\\n```java\\n/**\\n * Rotate the matrix on horizontal axis (swap rows) and then transpose to get\\n * the result.\\n *\\n * Time Complexity:\\n * O(N/2) -> for rotating along horizontal axis (swap rows). Only rows reference will be visited not the whole rows.\\n * O(N*N - N) -> Transpose of the matrix. All elements will be visited once except the diagonal. Diagonal has N elements.\\n * \\n * Total time complexity = O(N/2 + N*N - N) ~ O(N^2)\\n *\\n * Space Complexity: O(1)\\n *\\n * N = Size of matrix.\\n *\\n * Note for anticlockwise, change the order. Transpose first and then rotate on\\n * horizontal axis.\\n */\\nclass Solution {\\n    public void rotate(int[][] matrix) {\\n        if (matrix == null || matrix.length == 0 || matrix[0].length == 0) {\\n            return;\\n        }\\n\\n        int n = matrix.length;\\n\\n        // Rotate the original matrix on horizontal axis. (swap rows)\\n        for (int i = 0; i < n / 2; i++) {\\n            int[] tempRow = matrix[i]; // Only reference will be saved\\n            matrix[i] = matrix[n - i - 1];\\n            matrix[n - i - 1] = tempRow;\\n        }\\n\\n        // Transpose the rotated matrix\\n        for (int i = 0; i < n - 1; i++) { // Selecting a row\\n            for (int j = i + 1; j < n; j++) {\\n                int temp = matrix[i][j];\\n                matrix[i][j] = matrix[j][i];\\n                matrix[j][i] = temp;\\n            }\\n        }\\n    }\\n}\\n```\\n\\n---\\n\\n**In the following solution, find the box starting at the diagonal and then rotate each group of four elements in that box**\\n\\n```java\\n/**\\n * Find the box starting at the diagonal and then rotate each group of four\\n * elements in that box.\\n *\\n * Find each box\\'s boundary. For example:\\n * rowTop,  colRight,   rowBottom,  colLeft\\n * 0,       n-1,        n-1,        0\\n * 1,       n-1-1,      n-1-1,      1\\n * 2,       n-1-2,      n-1-2,      2\\n * ...\\n * i,       n-1-i,      n-1-i,      i\\n *\\n * Now find the indexes and their destination index:\\n * (i, j) will move to (j, n-1-i)\\n * (j, n-1-i) will move to (n-1-i, n-1-j)\\n * (n-1-i, n-1-j) will move to (n-i-j, i)\\n * (n-i-j, i) will move to (i, j)\\n *\\n * Time Complexity: O(N^2) --> All cells are visited once.\\n *\\n * Space Complexity: O(1)\\n *\\n * N = Size of matrix.\\n */\\nclass Solution {\\n    public void rotate(int[][] matrix) {\\n        if (matrix == null || matrix.length == 0 || matrix[0].length == 0) {\\n            return;\\n        }\\n\\n        int n = matrix.length;\\n\\n        for (int i = 0; i < n / 2; i++) {\\n            for (int j = i; j < n - 1 - i; j++) {\\n                int temp = matrix[i][j];\\n                matrix[i][j] = matrix[n - 1 - j][i];\\n                matrix[n - 1 - j][i] = matrix[n - 1 - i][n - 1 - j];\\n                matrix[n - 1 - i][n - 1 - j] = matrix[j][n - 1 - i];\\n                matrix[j][n - 1 - i] = temp;\\n            }\\n        }\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Array",
                    "Math",
                    "Matrix"
                ],
                "code": "```java\\n/**\\n * Rotate the matrix on horizontal axis (swap rows) and then transpose to get\\n * the result.\\n *\\n * Time Complexity:\\n * O(N/2) -> for rotating along horizontal axis (swap rows). Only rows reference will be visited not the whole rows.\\n * O(N*N - N) -> Transpose of the matrix. All elements will be visited once except the diagonal. Diagonal has N elements.\\n * \\n * Total time complexity = O(N/2 + N*N - N) ~ O(N^2)\\n *\\n * Space Complexity: O(1)\\n *\\n * N = Size of matrix.\\n *\\n * Note for anticlockwise, change the order. Transpose first and then rotate on\\n * horizontal axis.\\n */\\nclass Solution {\\n    public void rotate(int[][] matrix) {\\n        if (matrix == null || matrix.length == 0 || matrix[0].length == 0) {\\n            return;\\n        }\\n\\n        int n = matrix.length;\\n\\n        // Rotate the original matrix on horizontal axis. (swap rows)\\n        for (int i = 0; i < n / 2; i++) {\\n            int[] tempRow = matrix[i]; // Only reference will be saved\\n            matrix[i] = matrix[n - i - 1];\\n            matrix[n - i - 1] = tempRow;\\n        }\\n\\n        // Transpose the rotated matrix\\n        for (int i = 0; i < n - 1; i++) { // Selecting a row\\n            for (int j = i + 1; j < n; j++) {\\n                int temp = matrix[i][j];\\n                matrix[i][j] = matrix[j][i];\\n                matrix[j][i] = temp;\\n            }\\n        }\\n    }\\n}\\n```\n```java\\n/**\\n * Find the box starting at the diagonal and then rotate each group of four\\n * elements in that box.\\n *\\n * Find each box\\'s boundary. For example:\\n * rowTop,  colRight,   rowBottom,  colLeft\\n * 0,       n-1,        n-1,        0\\n * 1,       n-1-1,      n-1-1,      1\\n * 2,       n-1-2,      n-1-2,      2\\n * ...\\n * i,       n-1-i,      n-1-i,      i\\n *\\n * Now find the indexes and their destination index:\\n * (i, j) will move to (j, n-1-i)\\n * (j, n-1-i) will move to (n-1-i, n-1-j)\\n * (n-1-i, n-1-j) will move to (n-i-j, i)\\n * (n-i-j, i) will move to (i, j)\\n *\\n * Time Complexity: O(N^2) --> All cells are visited once.\\n *\\n * Space Complexity: O(1)\\n *\\n * N = Size of matrix.\\n */\\nclass Solution {\\n    public void rotate(int[][] matrix) {\\n        if (matrix == null || matrix.length == 0 || matrix[0].length == 0) {\\n            return;\\n        }\\n\\n        int n = matrix.length;\\n\\n        for (int i = 0; i < n / 2; i++) {\\n            for (int j = i; j < n - 1 - i; j++) {\\n                int temp = matrix[i][j];\\n                matrix[i][j] = matrix[n - 1 - j][i];\\n                matrix[n - 1 - j][i] = matrix[n - 1 - i][n - 1 - j];\\n                matrix[n - 1 - i][n - 1 - j] = matrix[j][n - 1 - i];\\n                matrix[j][n - 1 - i] = temp;\\n            }\\n        }\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 591169,
                "title": "explained-javascript-solution-with-examples",
                "content": "```\\n/**\\n * @param {number[][]} matrix\\n * @return {void} Do not return anything, modify matrix in-place instead.\\n */\\nvar rotate = function(matrix) {\\n \\n        let n = matrix.length //this is optional \\n        \\n\\t\\t//[1,2,3],>>>>    [1,4,7]\\n\\t\\t//[4,5,6],>>>>    [2,5,8]\\n\\t\\t//[7,8,9]>>>>     [3,6,9]\\n\\t\\t//rows become columns and columns become rows  Look at above ^^ \\n        for(let i = 0; i<n; i++){\\n            for(let j = i; j< n; j++){\\n                let temp = matrix[i][j]\\n                matrix[i][j] = matrix[j][i]\\n                matrix [j][i] = temp\\n            }\\n        }\\n\\t\\t\\n\\t\\t//[1,4,7],>>>>    [7,4,1]\\n\\t\\t//[2,5,8],>>>>    [8,5,2]\\n\\t\\t//[3,6,9]>>>>     [9,6,2]\\n        //swap first and last ele from each row in this case; we swap 1 and 7 and it becomes 7 and 1 Look Above ^^\\n        for(let i = 0; i< n; i++){\\n           for(let j = 0; j<(n/2); j++){\\n                let temp = matrix[i][j]\\n\\t\\t\\t\\tmatrix[i][j] = matrix[i][n-1-j]\\n\\t\\t\\t    matrix[i][n-1-j] = temp \\n        }\\n    }\\n};\\n\\n\\n//for the second part you can use the reverse method instead of another j loop. \\n//instead of \\n for(let i = 0; i< n; i++){\\n     for(let j = 0; j<(n/2); j++){ // we divide by 2 to get the middle of the array\\n           let temp = matrix[i][j]\\n\\t\\t\\t matrix[i][j] = matrix[i][n-1-j]\\n\\t\\t     matrix[i][n-1-j] = temp \\n        }\\n    }\\n\\n//you can do this:\\nfor(let i = 0; i< n; i++){\\n     matrix[i].reverse() \\n} \\n```\\n\\n\\nTime Complexity : O(n*n), where n is side of array, A single traversal of the matrix is needed.\\n\\n\\n",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\n/**\\n * @param {number[][]} matrix\\n * @return {void} Do not return anything, modify matrix in-place instead.\\n */\\nvar rotate = function(matrix) {\\n \\n        let n = matrix.length //this is optional \\n        \\n\\t\\t//[1,2,3],>>>>    [1,4,7]\\n\\t\\t//[4,5,6],>>>>    [2,5,8]\\n\\t\\t//[7,8,9]>>>>     [3,6,9]\\n\\t\\t//rows become columns and columns become rows  Look at above ^^ \\n        for(let i = 0; i<n; i++){\\n            for(let j = i; j< n; j++){\\n                let temp = matrix[i][j]\\n                matrix[i][j] = matrix[j][i]\\n                matrix [j][i] = temp\\n            }\\n        }\\n\\t\\t\\n\\t\\t//[1,4,7],>>>>    [7,4,1]\\n\\t\\t//[2,5,8],>>>>    [8,5,2]\\n\\t\\t//[3,6,9]>>>>     [9,6,2]\\n        //swap first and last ele from each row in this case; we swap 1 and 7 and it becomes 7 and 1 Look Above ^^\\n        for(let i = 0; i< n; i++){\\n           for(let j = 0; j<(n/2); j++){\\n                let temp = matrix[i][j]\\n\\t\\t\\t\\tmatrix[i][j] = matrix[i][n-1-j]\\n\\t\\t\\t    matrix[i][n-1-j] = temp \\n        }\\n    }\\n};\\n\\n\\n//for the second part you can use the reverse method instead of another j loop. \\n//instead of \\n for(let i = 0; i< n; i++){\\n     for(let j = 0; j<(n/2); j++){ // we divide by 2 to get the middle of the array\\n           let temp = matrix[i][j]\\n\\t\\t\\t matrix[i][j] = matrix[i][n-1-j]\\n\\t\\t     matrix[i][n-1-j] = temp \\n        }\\n    }\\n\\n//you can do this:\\nfor(let i = 0; i< n; i++){\\n     matrix[i].reverse() \\n} \\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1319666,
                "title": "easy-c-solution-o-n-n-time-complexity",
                "content": "1. do inplace transpose on the matrix \\n2. reverse the transposed matrix\\n```\\nclass Solution {\\npublic:\\n    void rotate(vector<vector<int>>& matrix) {\\n        int n= matrix.size();\\n        //transpose of given matrix\\n       for(int i=0;i<n;i++){\\n           for(int j=0;j<i;j++){\\n             swap(matrix[i][j],matrix[j][i]);   \\n           }\\n       }\\n        //reverse of transpose matric\\n        for(int i=0;i<n;i++){\\n            reverse(matrix[i].begin(),matrix[i].end());\\n        }\\n    }\\n};",
                "solutionTags": [
                    "C++",
                    "C"
                ],
                "code": "class Solution {\\npublic:\\n    void rotate(vector<vector<int>>& matrix) {\\n        int n= matrix.size();\\n        //transpose of given matrix\\n       for(int i=0;i<n;i++){\\n           for(int j=0;j<i;j++){\\n             swap(matrix[i][j],matrix[j][i]);   \\n           }",
                "codeTag": "Java"
            },
            {
                "id": 19148,
                "title": "c-2ms-solution-o-1-extra-space",
                "content": "    void rotate(int **matrix, int n) {\\n        for (int i=0; i<n/2; ++i)\\n        {\\n            for (int j=i; j<n-1-i; ++j)\\n            {\\n                int z = matrix[i][j];\\n                matrix[i][j] = matrix[n-j-1][i];\\n                matrix[n-j-1][i] = matrix[n-i-1][n-j-1];\\n                matrix[n-i-1][n-j-1] = matrix[j][n-i-1];\\n                matrix[j][n-i-1] = z;\\n            }\\n        }\\n    }",
                "solutionTags": [],
                "code": "    void rotate(int **matrix, int n) {\\n        for (int i=0; i<n/2; ++i)\\n        {\\n            for (int j=i; j<n-1-i; ++j)\\n            {\\n                int z = matrix[i][j];\\n                matrix[i][j] = matrix[n-j-1][i];\\n                matrix[n-j-1][i] = matrix[n-i-1][n-j-1];\\n                matrix[n-i-1][n-j-1] = matrix[j][n-i-1];\\n                matrix[j][n-i-1] = z;\\n            }\\n        }\\n    }",
                "codeTag": "Unknown"
            },
            {
                "id": 19108,
                "title": "8-lines-java-solution",
                "content": "Hi guys!\\n\\nThe idea is to loop through the top-left quadrant of the matrix (including the middle column for odd N), and for each element make 4-element swap (rotation). Meaning that for example if we have 5x5 M, and the current element is M[1,2] then we memorize M[1,2] into tmp and make: M[1,2] = M[2,1]; M[2,1] = M[3,2]; M[3,2] = M[2,3]; M[2,3] = tmp.\\n\\nHere's a pretty concise code below.\\n\\n----------\\n\\n    public class Solution {\\n        public void rotate(int[][] M) {\\n            for (int i = 0; i < (M.length+1)/2; i++) {\\n                for (int j = 0; j < M.length/2; j++) {\\n                    int tmp = M[i][j];\\n                    M[i][j] = M[M.length-j-1][i];\\n                    M[M.length-j-1][i] = M[M.length-i-1][M.length-j-1];\\n                    M[M.length-i-1][M.length-j-1] = M[j][M.length-i-1];\\n                    M[j][M.length-i-1] = tmp;\\n                }\\n            }\\n        }\\n    }",
                "solutionTags": [
                    "Java"
                ],
                "code": "class Solution {\\n        public void rotate(int[][] M) {\\n            for (int i = 0; i < (M.length+1)/2; i++) {\\n                for (int j = 0; j < M.length/2; j++) {\\n                    int tmp = M[i][j];\\n                    M[i][j] = M[M.length-j-1][i];\\n                    M[M.length-j-1][i] = M[M.length-i-1][M.length-j-1];\\n                    M[M.length-i-1][M.length-j-1] = M[j][M.length-i-1];\\n                    M[j][M.length-i-1] = tmp;\\n                }",
                "codeTag": "Java"
            },
            {
                "id": 2503236,
                "title": "js-javascript-clean-code-with-explanation",
                "content": "```\\n// Reverse on Diagonal and then Reverse Left to Right \\n\\t\\n//\\t1 2 3      1 4 7      7 4 1\\n//\\t4 5 6  =>  2 5 8  =>  8 5 2 \\n//\\t7 8 9      3 6 9      9 6 3\\n\\n// Time complexity: O(n^2)\\n// Space complexity: O(1)\\n\\nvar rotate = function(matrix) {\\n    const n = matrix.length;\\n\\t\\n\\tfunction transpose() {\\n\\t\\tfor(let i = 0; i < n; i++) {\\n\\t\\t\\tfor(let j = i + 1; j < n; j++) {\\n\\t\\t\\t\\tconst temp = matrix[j][i];\\n\\t\\t\\t\\tmatrix[j][i] = matrix[i][j];\\n\\t\\t\\t\\tmatrix[i][j] = temp;\\n\\t\\t\\t}\\n\\t\\t}\\n\\t}\\n\\t\\n\\tfunction rotate() {\\n\\t\\tfor(let i = 0; i < n; i++) {\\n\\t\\t\\tfor(let j = 0; j < n / 2; j++) {\\n\\t\\t\\t\\tconst temp = matrix[i][j];\\n\\t\\t\\t\\tmatrix[i][j] = matrix[i][n - 1 - j];\\n\\t\\t\\t\\tmatrix[i][n - 1 - j] = temp;\\n\\t\\t\\t}\\n\\t\\t}\\n\\t}\\n\\t\\n\\ttranspose(matrix);\\n\\trotate(matrix);\\n};\\n```\\n\\n**If you find this solution useful, please upvote. Happy Coding!**",
                "solutionTags": [
                    "JavaScript",
                    "Matrix"
                ],
                "code": "```\\n// Reverse on Diagonal and then Reverse Left to Right \\n\\t\\n//\\t1 2 3      1 4 7      7 4 1\\n//\\t4 5 6  =>  2 5 8  =>  8 5 2 \\n//\\t7 8 9      3 6 9      9 6 3\\n\\n// Time complexity: O(n^2)\\n// Space complexity: O(1)\\n\\nvar rotate = function(matrix) {\\n    const n = matrix.length;\\n\\t\\n\\tfunction transpose() {\\n\\t\\tfor(let i = 0; i < n; i++) {\\n\\t\\t\\tfor(let j = i + 1; j < n; j++) {\\n\\t\\t\\t\\tconst temp = matrix[j][i];\\n\\t\\t\\t\\tmatrix[j][i] = matrix[i][j];\\n\\t\\t\\t\\tmatrix[i][j] = temp;\\n\\t\\t\\t}\\n\\t\\t}\\n\\t}\\n\\t\\n\\tfunction rotate() {\\n\\t\\tfor(let i = 0; i < n; i++) {\\n\\t\\t\\tfor(let j = 0; j < n / 2; j++) {\\n\\t\\t\\t\\tconst temp = matrix[i][j];\\n\\t\\t\\t\\tmatrix[i][j] = matrix[i][n - 1 - j];\\n\\t\\t\\t\\tmatrix[i][n - 1 - j] = temp;\\n\\t\\t\\t}\\n\\t\\t}\\n\\t}\\n\\t\\n\\ttranspose(matrix);\\n\\trotate(matrix);\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2502471,
                "title": "c-python-explained",
                "content": "**UPVOTE IF HELPFuuL**\\n\\nWe break the problem from rotating the whole matrix to *rotating the outside ring around the matirx*.\\nThen we do the same for innner rings formed.\\n* For each ring/circle, we exchange elements clockwise and after we finish one circle, we can continue processing the next.\\n\\nThe process continues till the last ring has either 0 ```[for even length matrix]``` or 1```[for odd length matrix]``` elements left in centre.\\n![image](https://assets.leetcode.com/users/images/aaa68b08-0530-4cd6-9a09-77c618c92f13_1661824549.8225694.png)\\n\\n\\n**C++**\\n```\\nclass Solution {\\npublic:\\n\\n    void roro(vector<vector<int>>& matrix, int i, int k, int n){\\n        for (int j=0; j<k; j++){\\n            int t = matrix[i][i+j];\\n            matrix[i][i+j] = matrix[n-i-1-j][i];\\n            matrix[n-i-1-j][i] =  matrix[n-i-1][n-i-1-j];\\n            matrix[n-i-1][n-i-1-j] = matrix[i+j][n-i-1];\\n            matrix[i+j][n-i-1] = t;\\n        }\\n    }\\n\\n    void rotate(vector<vector<int>>& matrix) {\\n        int i = 0, n = matrix.size();\\n        int k = n-1;\\n        while (k>0){\\n            roro(matrix,i,k,n);\\n            i++;\\n            k-=2;\\n        }\\n        return;\\n    }\\n};\\n```\\n**PYTHON**\\n```\\nclass Solution:\\n    def rotate(self, matrix: List[List[int]]) -> None:\\n        def roro(i,k):\\n            for j in range(0,k):\\n                t = matrix[i][i+j]\\n                matrix[i][i+j] = matrix[n-i-1-j][i]\\n                matrix[n-i-1-j][i] =  matrix[n-i-1][n-i-1-j]\\n                matrix[n-i-1][n-i-1-j] = matrix[i+j][n-i-1]\\n                matrix[i+j][n-i-1] = t\\n        i=0\\n        n=len(matrix)\\n        k=n-1\\n        while k>0:\\n            roro(i,k)\\n            i+=1\\n            k-=2\\n        return\\n```\\n\\n**UPVOTE IF HELPFuuL**\\n\\n![image](https://assets.leetcode.com/users/images/1f7f95f0-aace-4d52-b7b7-30c6145153b3_1661823856.8571475.jpeg)\\n\\n",
                "solutionTags": [
                    "C++",
                    "Python",
                    "C"
                ],
                "code": "```[for even length matrix]```\n```[for odd length matrix]```\n```\\nclass Solution {\\npublic:\\n\\n    void roro(vector<vector<int>>& matrix, int i, int k, int n){\\n        for (int j=0; j<k; j++){\\n            int t = matrix[i][i+j];\\n            matrix[i][i+j] = matrix[n-i-1-j][i];\\n            matrix[n-i-1-j][i] =  matrix[n-i-1][n-i-1-j];\\n            matrix[n-i-1][n-i-1-j] = matrix[i+j][n-i-1];\\n            matrix[i+j][n-i-1] = t;\\n        }\\n    }\\n\\n    void rotate(vector<vector<int>>& matrix) {\\n        int i = 0, n = matrix.size();\\n        int k = n-1;\\n        while (k>0){\\n            roro(matrix,i,k,n);\\n            i++;\\n            k-=2;\\n        }\\n        return;\\n    }\\n};\\n```\n```\\nclass Solution:\\n    def rotate(self, matrix: List[List[int]]) -> None:\\n        def roro(i,k):\\n            for j in range(0,k):\\n                t = matrix[i][i+j]\\n                matrix[i][i+j] = matrix[n-i-1-j][i]\\n                matrix[n-i-1-j][i] =  matrix[n-i-1][n-i-1-j]\\n                matrix[n-i-1][n-i-1-j] = matrix[i+j][n-i-1]\\n                matrix[i+j][n-i-1] = t\\n        i=0\\n        n=len(matrix)\\n        k=n-1\\n        while k>0:\\n            roro(i,k)\\n            i+=1\\n            k-=2\\n        return\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3763842,
                "title": "best-solution-in-java-beats-100-java-solutions-in-run-time-and-99-66-in-memory",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nLet imagine it like a Square Matrix where we can apply Transpose Theory\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\nat very first reverse the column for clockwise rotation\\n\\nthen simply apply transpose of the matrix\\n\\nExtra\\n(Note :- reverse the row for anti-clockwise rotation)\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n O(n^2)\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n O(1)\\n\\n# Code\\n```\\nclass Solution {\\n    public void rotate(int[][] matrix) {\\n        int n = matrix.length;\\n        \\n        //Column Reverse\\n        for(int i = 0; i < n; i++){\\n            int a = 0;\\n            int b = n-1;\\n            while(a <= b){\\n               int temp = matrix[a][i];\\n                matrix[a][i] = matrix[b][i];\\n                 matrix[b][i] = temp;\\n                 a++;\\n                 b--;\\n            }\\n            \\n        }\\n           \\n        //Transpose\\n        for(int i = 0; i < n; i++){\\n            for(int j =i+1; j< n; j++){\\n                int temp =  matrix[i][j];\\n                 matrix[i][j] =  matrix[j][i];;\\n                 matrix[j][i] = temp;\\n            }\\n        }\\n        \\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public void rotate(int[][] matrix) {\\n        int n = matrix.length;\\n        \\n        //Column Reverse\\n        for(int i = 0; i < n; i++){\\n            int a = 0;\\n            int b = n-1;\\n            while(a <= b){\\n               int temp = matrix[a][i];\\n                matrix[a][i] = matrix[b][i];\\n                 matrix[b][i] = temp;\\n                 a++;\\n                 b--;\\n            }\\n            \\n        }\\n           \\n        //Transpose\\n        for(int i = 0; i < n; i++){\\n            for(int j =i+1; j< n; j++){\\n                int temp =  matrix[i][j];\\n                 matrix[i][j] =  matrix[j][i];;\\n                 matrix[j][i] = temp;\\n            }\\n        }\\n        \\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3519805,
                "title": "c-java-python-javascript-2-approach-brute-and-optimized-fully-explained",
                "content": "# Intuition\\nThe task is to rotate the given matrix by 90 degrees clockwise. We can achieve this by performing two steps: transposing the matrix and then reversing each row of the transposed matrix.\\n\\n# Approach\\n1. Transposing the matrix:\\n   - Iterate over the rows of the matrix from 0 to n-1.\\n   - For each row, iterate over the columns from 0 to i (exclusive).\\n   - Swap the element at position (i, j) with the element at position (j, i). This effectively transposes the matrix in-place.\\n\\n2. Reversing each row of the transposed matrix:\\n   - Iterate over each row of the matrix.\\n   - Use the `reverse` function to reverse the elements in that row. This reverses each row in-place.\\n\\n# Complexity\\n#### 1. Brute Force\\n- Time Complexity: O(n^2), where n is the size of the matrix.\\n- Space Complexity: O(n^2)\\n#### 2. Optimal Approach\\n- Time complexity: O(n^2), where n is the size of the matrix, as we iterate over each element in the matrix twice (once for transposing and once for reversing).\\n- Space complexity: O(1) as we perform the operations in-place without using any additional space.\\n\\n**Brute Force Approach:**\\n\\nC++:\\n```cpp\\nclass Solution {\\npublic:\\n    void rotate(vector<vector<int>>& matrix) {\\n        int n=matrix.size();\\n        vector < vector < int >> rotated(n, vector < int > (n, 0));\\n        for (int i = 0; i < n; i++) {\\n            for (int j = 0; j < n; j++) {\\n            rotated[j][n - i - 1] = matrix[i][j];\\n            }\\n        }\\n        matrix=rotated;\\n    }\\n};\\n```\\nJava:\\n```java\\nclass Solution {\\n    public void rotate(int[][] matrix) {\\n        int n = matrix.length;\\n        int[][] rotated = new int[n][n];\\n        for (int i = 0; i < n; i++) {\\n            for (int j = 0; j < n; j++) {\\n                rotated[j][n - i - 1] = matrix[i][j];\\n            }\\n        }\\n        // Copy rotated matrix back to the original matrix\\n        for (int i = 0; i < n; i++) {\\n            System.arraycopy(rotated[i], 0, matrix[i], 0, n);\\n        }\\n    }\\n}\\n```\\n\\nPython:\\n```python\\nclass Solution(object):\\n    def rotate(self, matrix):\\n        n = len(matrix)\\n        rotated = [[0] * n for _ in range(n)]\\n        for i in range(n):\\n            for j in range(n):\\n                rotated[j][n - i - 1] = matrix[i][j]\\n        # Copy rotated matrix back to the original matrix\\n        for i in range(n):\\n            matrix[i] = rotated[i][:]\\n```\\n\\nJavaScript:\\n```javascript\\nvar rotate = function(matrix) {\\n    const n = matrix.length;\\n    const rotated = Array(n).fill(null).map(() => Array(n).fill(0));\\n    for (let i = 0; i < n; i++) {\\n        for (let j = 0; j < n; j++) {\\n            rotated[j][n - i - 1] = matrix[i][j];\\n        }\\n    }\\n    // Copy rotated matrix back to the original matrix\\n    for (let i = 0; i < n; i++) {\\n        matrix[i] = rotated[i].slice();\\n    }\\n}\\n```\\n\\n**Optimal Approach:**\\n\\nC++:\\n```cpp\\nclass Solution {\\npublic:\\n    void rotate(vector<vector<int>>& matrix) {\\n        int n = matrix.size();\\n        //transposing the matrix\\n        for (int i = 0; i < n; i++) {\\n            for (int j = 0; j < i; j++) {\\n            swap(matrix[i][j], matrix[j][i]);\\n            }\\n        }\\n        //reversing each row of the matrix\\n        for (int i = 0; i < n; i++) {\\n            reverse(matrix[i].begin(), matrix[i].end());\\n        }\\n    }\\n};\\n```\\nJava:\\n```java\\nclass Solution {\\n    public void rotate(int[][] matrix) {\\n        int n = matrix.length;\\n        // Transposing the matrix\\n        for (int i = 0; i < n; i++) {\\n            for (int j = 0; j < i; j++) {\\n                int temp = matrix[i][j];\\n                matrix[i][j] = matrix[j][i];\\n                matrix[j][i] = temp;\\n            }\\n        }\\n        // Reversing each row of the matrix\\n        for (int i = 0; i < n; i++) {\\n            int left = 0;\\n            int right = n - 1;\\n            while (left < right) {\\n                int temp = matrix[i][left];\\n                matrix[i][left] = matrix[i][right];\\n                matrix[i][right] = temp;\\n                left++;\\n                right--;\\n            }\\n        }\\n    }\\n}\\n```\\n\\nPython:\\n```python\\nclass Solution(object):\\n    def rotate(self, matrix):\\n        n = len(matrix)\\n        # Transposing the matrix\\n        for i in range(n):\\n            for j in range(i):\\n                matrix[i][j], matrix[j][i] = matrix[j][i], matrix[i][j]\\n        # Reversing each row of the matrix\\n        for i in range(n):\\n            left = 0\\n            right = n - 1\\n            while left < right:\\n                matrix[i][left], matrix[i][right] = matrix[i][right], matrix[i][left]\\n                left += 1\\n                right -= 1\\n```\\n\\nJavaScript:\\n```javascript\\nvar rotate = function(matrix) {\\n    const n = matrix.length;\\n    \\n    // Transposing the matrix\\n    for (let i = 0; i < n; i++) {\\n        for (let j = 0; j < i; j++) {\\n            [matrix[i][j], matrix[j][i]] = [matrix[j][i], matrix[i][j]];\\n        }\\n    }\\n    \\n    // Reversing each row of the matrix\\n    for (let i = 0; i < n; i++) {\\n        matrix[i].reverse();\\n    }\\n}\\n```\\n",
                "solutionTags": [
                    "C++",
                    "Java",
                    "Python",
                    "JavaScript"
                ],
                "code": "```cpp\\nclass Solution {\\npublic:\\n    void rotate(vector<vector<int>>& matrix) {\\n        int n=matrix.size();\\n        vector < vector < int >> rotated(n, vector < int > (n, 0));\\n        for (int i = 0; i < n; i++) {\\n            for (int j = 0; j < n; j++) {\\n            rotated[j][n - i - 1] = matrix[i][j];\\n            }\\n        }\\n        matrix=rotated;\\n    }\\n};\\n```\n```java\\nclass Solution {\\n    public void rotate(int[][] matrix) {\\n        int n = matrix.length;\\n        int[][] rotated = new int[n][n];\\n        for (int i = 0; i < n; i++) {\\n            for (int j = 0; j < n; j++) {\\n                rotated[j][n - i - 1] = matrix[i][j];\\n            }\\n        }\\n        // Copy rotated matrix back to the original matrix\\n        for (int i = 0; i < n; i++) {\\n            System.arraycopy(rotated[i], 0, matrix[i], 0, n);\\n        }\\n    }\\n}\\n```\n```python\\nclass Solution(object):\\n    def rotate(self, matrix):\\n        n = len(matrix)\\n        rotated = [[0] * n for _ in range(n)]\\n        for i in range(n):\\n            for j in range(n):\\n                rotated[j][n - i - 1] = matrix[i][j]\\n        # Copy rotated matrix back to the original matrix\\n        for i in range(n):\\n            matrix[i] = rotated[i][:]\\n```\n```javascript\\nvar rotate = function(matrix) {\\n    const n = matrix.length;\\n    const rotated = Array(n).fill(null).map(() => Array(n).fill(0));\\n    for (let i = 0; i < n; i++) {\\n        for (let j = 0; j < n; j++) {\\n            rotated[j][n - i - 1] = matrix[i][j];\\n        }\\n    }\\n    // Copy rotated matrix back to the original matrix\\n    for (let i = 0; i < n; i++) {\\n        matrix[i] = rotated[i].slice();\\n    }\\n}\\n```\n```cpp\\nclass Solution {\\npublic:\\n    void rotate(vector<vector<int>>& matrix) {\\n        int n = matrix.size();\\n        //transposing the matrix\\n        for (int i = 0; i < n; i++) {\\n            for (int j = 0; j < i; j++) {\\n            swap(matrix[i][j], matrix[j][i]);\\n            }\\n        }\\n        //reversing each row of the matrix\\n        for (int i = 0; i < n; i++) {\\n            reverse(matrix[i].begin(), matrix[i].end());\\n        }\\n    }\\n};\\n```\n```java\\nclass Solution {\\n    public void rotate(int[][] matrix) {\\n        int n = matrix.length;\\n        // Transposing the matrix\\n        for (int i = 0; i < n; i++) {\\n            for (int j = 0; j < i; j++) {\\n                int temp = matrix[i][j];\\n                matrix[i][j] = matrix[j][i];\\n                matrix[j][i] = temp;\\n            }\\n        }\\n        // Reversing each row of the matrix\\n        for (int i = 0; i < n; i++) {\\n            int left = 0;\\n            int right = n - 1;\\n            while (left < right) {\\n                int temp = matrix[i][left];\\n                matrix[i][left] = matrix[i][right];\\n                matrix[i][right] = temp;\\n                left++;\\n                right--;\\n            }\\n        }\\n    }\\n}\\n```\n```python\\nclass Solution(object):\\n    def rotate(self, matrix):\\n        n = len(matrix)\\n        # Transposing the matrix\\n        for i in range(n):\\n            for j in range(i):\\n                matrix[i][j], matrix[j][i] = matrix[j][i], matrix[i][j]\\n        # Reversing each row of the matrix\\n        for i in range(n):\\n            left = 0\\n            right = n - 1\\n            while left < right:\\n                matrix[i][left], matrix[i][right] = matrix[i][right], matrix[i][left]\\n                left += 1\\n                right -= 1\\n```\n```javascript\\nvar rotate = function(matrix) {\\n    const n = matrix.length;\\n    \\n    // Transposing the matrix\\n    for (let i = 0; i < n; i++) {\\n        for (let j = 0; j < i; j++) {\\n            [matrix[i][j], matrix[j][i]] = [matrix[j][i], matrix[i][j]];\\n        }\\n    }\\n    \\n    // Reversing each row of the matrix\\n    for (let i = 0; i < n; i++) {\\n        matrix[i].reverse();\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2502288,
                "title": "daily-leetcoding-challenge-august-day-30",
                "content": "This problem is the Daily LeetCoding Challenge for August, Day 30.\n\nFeel free to share anything related to this problem here!\n\nYou can ask questions, discuss what you've learned from this problem, or show off how many days of streak you've made!\n\n---\n\nIf you'd like to share a detailed solution to the problem, please create a new post in the discuss section and provide\n- **Detailed Explanations**: Describe the algorithm you used to solve this problem. Include any insights you used to solve this problem.\n- **Images** that help explain the algorithm.\n- **Language and Code** you used to pass the problem.\n- **Time and Space complexity analysis**.\n\n---\n\n  **📌 Do you want to learn the problem thoroughly?**\n  Read [**⭐  LeetCode Official Solution⭐**](https://leetcode.com/problems/rotate-image/solution) to learn the 3 approaches to the problem with detailed explanations to the algorithms, codes, and complexity analysis.\n  <details>\n  <summary> Spoiler Alert! We'll explain these 2 approaches in the official solution</summary>\n\n  \n**Approach 1:** Rotate Groups of Four Cells\n\n  \n**Approach 2:** Reverse on Diagonal and then Reverse Left to Right\n\n  \n</details>\n\n\n\nIf you're new to Daily LeetCoding Challenge, [**check out this post**](https://leetcode.com/discuss/general-discussion/655704/)!\n\n\n---\n\n<br>\n\n<p align=\"center\">\n<a href=\"https://leetcode.com/subscribe/?ref=ex_dc\" target=\"_blank\">\n  <img src=\"https://assets.leetcode.com/static_assets/marketing/daily_leetcoding_banner.png\" width=\"560px\" />\n</a>\n</p>\n\n<br>",
                "solutionTags": [],
                "code": "  Read [**⭐  LeetCode Official Solution⭐**](https://leetcode.com/problems/rotate-image/solution) to learn the 3 approaches to the problem with detailed explanations to the algorithms, codes, and complexity analysis.\nIf you're new to Daily LeetCoding Challenge, [**check out this post**](https://leetcode.com/discuss/general-discussion/655704/)!\n<p align=\"center\">\n<a href=\"https://leetcode.com/subscribe/?ref=ex_dc\" target=\"_blank\">\n  <img src=\"https://assets.leetcode.com/static_assets/marketing/daily_leetcoding_banner.png\" width=\"560px\" />",
                "codeTag": "Unknown"
            },
            {
                "id": 1965396,
                "title": "my-c-solution",
                "content": "So I first drew a 3x3 matrix to see how the elements were shifting as the image was rotated. As I drew, I saw the a pattern where we could first transpose the matrix (swap elements along diagonal) and then just mirror the obtained matrix to get the final matrix. We could apply it in reverse order too, only thing which would change is that instead of swapping across leading diagonal (from top left to bottom right), we would have to first mirror the image and then swap elements along the second diagonal (from top right to bottom left).\\n\\nMy code is as follows:\\n```\\nclass Solution {\\npublic:\\n    void swap(int& a, int& b)\\n    {\\n        int temp = a;\\n        a = b;\\n        b = temp;\\n        return;\\n    }\\n\\n    void rotate(vector<vector<int>>& matrix)\\n    {\\n        if (matrix.size() <= 1)\\n            return;\\n        for (int i = 0; i <= matrix.size() - 2; ++i)\\n        {\\n            for (int j = i+1; j <= matrix.size() - 1; ++j)\\n            {\\n                swap(matrix[i][j], matrix[j][i]);\\n            }\\n        }\\n\\n        for (int i = 0; i < matrix.size(); ++i)\\n        {\\n            int low = 0;\\n            int high = matrix.size() - 1;\\n            while (low < high)\\n            {\\n                swap(matrix[i][low], matrix[i][high]);\\n                ++low;\\n                --high;\\n            }\\n        }\\n        return;\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    void swap(int& a, int& b)\\n    {\\n        int temp = a;\\n        a = b;\\n        b = temp;\\n        return;\\n    }\\n\\n    void rotate(vector<vector<int>>& matrix)\\n    {\\n        if (matrix.size() <= 1)\\n            return;\\n        for (int i = 0; i <= matrix.size() - 2; ++i)\\n        {\\n            for (int j = i+1; j <= matrix.size() - 1; ++j)\\n            {\\n                swap(matrix[i][j], matrix[j][i]);\\n            }\\n        }\\n\\n        for (int i = 0; i < matrix.size(); ++i)\\n        {\\n            int low = 0;\\n            int high = matrix.size() - 1;\\n            while (low < high)\\n            {\\n                swap(matrix[i][low], matrix[i][high]);\\n                ++low;\\n                --high;\\n            }\\n        }\\n        return;\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 298719,
                "title": "a-java-one-pass-solution-with-detailed-explanation",
                "content": "The solution is from:\\n\\nhttps://leetcode.com/problems/rotate-image/discuss/18895/Clear-Java-solution\\n\\nThe basic idea is:\\n\\n1. Separate the matrix to multiple cycles, go through the cycles from outer to inner\\n2. For each cycle (with 4 arrays connected), go through the top array\\n3. For each elements of the array, calculate the new position and move the value. Note that for each element, we need to move the value for 4 times (for the 4 arrays).\\n\\nThe code:\\n\\n```\\nclass Solution {\\n    public void rotate(int[][] matrix) {\\n        if(matrix == null || matrix.length == 0 || matrix[0].length == 0)return;\\n        int n = matrix.length;\\n        for(int i = 0;i < n / 2;i++) {\\n            for(int j = i;j < n - i - 1;j++) {\\n                int tmp = matrix[i][j];\\n                matrix[i][j] = matrix[n - j - 1][i];\\n                matrix[n - j - 1][i] = matrix[n - i - 1][n - j - 1];\\n                matrix[n - i - 1][n - j - 1] = matrix[j][n - i - 1];\\n                matrix[j][n - i - 1] = tmp;\\n            }\\n        }\\n    }\\n}\\n```\\n\\nSome explanations:\\n\\n1. Why do we use (n / 2) as the count of i?\\n\\ni means the count of all the cycles. Since the length of the matrix is n, obviously we have (n / 2) cycles.\\n\\n2. Why do we use i and (n - i - 1) as the range of j?\\n\\nj means the count of the elements of the top array of current cycle. Since the cycle becomes smaller and smaller according to the increasing of i, the start of j is i. Since the cycle is always symmetrical, the end of j is (n - i - 1). Note that we use  (n - i - 1) but not (n - i) because we need to ignore the latest one of each line (which should be handled as first one in next loop).\\n\\n3. How to understand the calculation of the positions in the inner loop?\\n\\nSince the cycle is always symmetrical, the rule is:\\n\\nFor any assignment expression, the positions A[x1][y1] and B[x2][y2] between the \"=\" operator must be:\\n\\n1. **x1 == y2**\\n2. **y1 and x2 are symmetrical**\\n\\ne.g.\\n\\n```\\nmatrix[i][j] = matrix[n - j - 1][i];\\n```\\n\\nBoth x1 and y2 are equal (i), and y1(j) and x2(n - j - 1) are symmetrical. The same for other assignments.",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    public void rotate(int[][] matrix) {\\n        if(matrix == null || matrix.length == 0 || matrix[0].length == 0)return;\\n        int n = matrix.length;\\n        for(int i = 0;i < n / 2;i++) {\\n            for(int j = i;j < n - i - 1;j++) {\\n                int tmp = matrix[i][j];\\n                matrix[i][j] = matrix[n - j - 1][i];\\n                matrix[n - j - 1][i] = matrix[n - i - 1][n - j - 1];\\n                matrix[n - i - 1][n - j - 1] = matrix[j][n - i - 1];\\n                matrix[j][n - i - 1] = tmp;\\n            }\\n        }\\n    }\\n}\\n```\n```\\nmatrix[i][j] = matrix[n - j - 1][i];\\n```",
                "codeTag": "Java"
            },
            {
                "id": 18948,
                "title": "c-code-with-more-detail-explaination",
                "content": "    class Solution {\\n    public:\\n        void rotate(vector<vector<int>>& matrix) {\\n            /**\\n             * clock rotate : rotate[j][n-1-i]=a[i][j]\\n             **/\\n            reverse(matrix.begin(), matrix.end());   /** a[n-1-i][j]=a[i][j] **/\\n            for(int i=0; i<matrix.size(); i++){   /** a[i][j]=a[j][i] **/\\n                for(int j=i+1; j<matrix[i].size(); j++)\\n                    swap(matrix[i][j], matrix[j][i]);\\n            }\\n        }\\n    };",
                "solutionTags": [],
                "code": "class Solution {\\n    public:\\n        void rotate(vector<vector<int>>& matrix) {\\n            /**\\n             * clock rotate : rotate[j][n-1-i]=a[i][j]\\n             **/\\n            reverse(matrix.begin(), matrix.end());   /** a[n-1-i][j]=a[i][j] **/\\n            for(int i=0; i<matrix.size(); i++){   /** a[i][j]=a[j][i] **/\\n                for(int j=i+1; j<matrix[i].size(); j++)\\n                    swap(matrix[i][j], matrix[j][i]);\\n            }",
                "codeTag": "Java"
            },
            {
                "id": 1449492,
                "title": "rotate-matrix-clockwise-or-anti-clockwise-100-faster-c",
                "content": "```\\n\\n// code to rotate the matrix to clock wise 90 degrees.\\n\\nclass Solution {\\npublic:\\n    void rotate(vector<vector<int>>& matrix) {\\n        int n = matrix.size();\\n        \\n        \\n        // transpose\\n        for(int i = 0; i < n; i++){\\n            for(int j = 0; j < i; j++){\\n                swap(matrix[i][j], matrix[j][i]);\\n            }\\n        }  \\n\\t\\t\\n\\t\\t// OR code for transpose\\n\\t\\t//for (int i = 0; i < n; i++)\\n\\t\\t\\t// for (int j = i; j < n; j++)\\n\\t\\t\\t\\t //swap(matrix[i][j], matrix[j][i]);\\n        \\n        // row reverse code below\\n        int k;\\n        for(int i = 0; i < n; i++){\\n            k = n-1;\\n            for(int j = 0; j < k; j++){\\n                swap(matrix[i][j], matrix[i][k]);\\n                k--;\\n            }\\n        }\\n        \\n        // or row reverse code \\n        \\n        // for(int i = 0; i<n; i++){\\n        //     reverse(matrix[i].begin(), matrix[i].end());\\n        // } \\n    }\\n};\\n//  please upvote if u like\\n```\\n\\n```\\n// code to rotate the matrix to anti-clock wise 90 degrees.\\n\\nclass Solution {\\npublic:\\n    void rotate(vector<vector<int>>& matrix) {\\n        int n = matrix.size();\\n        \\n        \\n        // transpose\\n        for(int i = 0; i < n; i++){\\n            for(int j = 0; j < i; j++){\\n                swap(matrix[i][j], matrix[j][i]);\\n            }\\n        }\\n        \\n        // column reverse code below\\n        int k;\\n        for(int i = 0; i < n; i++){\\n            k = n-1;\\n            for(int j = 0; j < k; j++){\\n                swap(matrix[j][i], matrix[k][i]);\\n                k--;\\n            }\\n        }\\n        \\n    }\\n};\\n\\n//  please upvote if u like\\n```\\n",
                "solutionTags": [],
                "code": "```\\n\\n// code to rotate the matrix to clock wise 90 degrees.\\n\\nclass Solution {\\npublic:\\n    void rotate(vector<vector<int>>& matrix) {\\n        int n = matrix.size();\\n        \\n        \\n        // transpose\\n        for(int i = 0; i < n; i++){\\n            for(int j = 0; j < i; j++){\\n                swap(matrix[i][j], matrix[j][i]);\\n            }\\n        }  \\n\\t\\t\\n\\t\\t// OR code for transpose\\n\\t\\t//for (int i = 0; i < n; i++)\\n\\t\\t\\t// for (int j = i; j < n; j++)\\n\\t\\t\\t\\t //swap(matrix[i][j], matrix[j][i]);\\n        \\n        // row reverse code below\\n        int k;\\n        for(int i = 0; i < n; i++){\\n            k = n-1;\\n            for(int j = 0; j < k; j++){\\n                swap(matrix[i][j], matrix[i][k]);\\n                k--;\\n            }\\n        }\\n        \\n        // or row reverse code \\n        \\n        // for(int i = 0; i<n; i++){\\n        //     reverse(matrix[i].begin(), matrix[i].end());\\n        // } \\n    }\\n};\\n//  please upvote if u like\\n```\n```\\n// code to rotate the matrix to anti-clock wise 90 degrees.\\n\\nclass Solution {\\npublic:\\n    void rotate(vector<vector<int>>& matrix) {\\n        int n = matrix.size();\\n        \\n        \\n        // transpose\\n        for(int i = 0; i < n; i++){\\n            for(int j = 0; j < i; j++){\\n                swap(matrix[i][j], matrix[j][i]);\\n            }\\n        }\\n        \\n        // column reverse code below\\n        int k;\\n        for(int i = 0; i < n; i++){\\n            k = n-1;\\n            for(int j = 0; j < k; j++){\\n                swap(matrix[j][i], matrix[k][i]);\\n                k--;\\n            }\\n        }\\n        \\n    }\\n};\\n\\n//  please upvote if u like\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1175596,
                "title": "pyhton-simple-solution-explained",
                "content": "The idea behind if all elements can be divided into groups of `4` and swapped in loops. There are `2` slightly different  cases we need to handle: case of odd `n`, for example:\\n`1,2,3     ->        7,4,1`\\n\\n`4,5,6     ->    8,5,2`\\n\\n`7,8,9     ->    9,6,3`\\n\\nIn this case we need to change groups `1 -> 7 -> 9 - > 3 -> 1`, `2 -> 4 -> 8 -> 6 -> 2` and `5 -> 5`. \\n\\nIn the case of even `n`, for example:\\n\\n`05,01,09,11 -> 15,13,02,05`\\n\\n`02,04,08,10 -> 14,03,04,01`\\n\\n`13,03,06,07 -> 12,06,08,09`\\n\\n`15,14,12,16 -> 16,07,10,11`\\n\\nWe need to change `4` groups of numbers `05 -> 15 -> 16 -> 11 -> 05`, `01 -> 13 -> 12 -> 10 -> 01`, `02 -> 14 -> 07 -> 09 -> 02`, `04 -> 03 -> 06 -> 08 -> 04`.\\n\\nActually, these two cases can be written in one condition if we carefully choose ranges in which we iterate.\\n\\n#### Complexity\\nTime complexity will be `O(n^2)`, space complexity is `O(1)`, because we do not use any additional space.\\n\\n```\\nclass Solution:\\n    def rotate(self, M):\\n        n = len(M) - 1\\n        for i in range((n+2)//2):\\n            for j in range((n+1)//2):\\n                M[i][j], M[j][n-i], M[n-i][n-j], M[n-j][i] = M[n-j][i], M[i][j], M[j][n-i], M[n-i][n-j]\\n```\\n\\nIf you have any questions, feel free to ask. If you like solution and explanations, please **Upvote!**",
                "solutionTags": [],
                "code": "```\\nclass Solution:\\n    def rotate(self, M):\\n        n = len(M) - 1\\n        for i in range((n+2)//2):\\n            for j in range((n+1)//2):\\n                M[i][j], M[j][n-i], M[n-i][n-j], M[n-j][i] = M[n-j][i], M[i][j], M[j][n-i], M[n-i][n-j]\\n```",
                "codeTag": "Java"
            },
            {
                "id": 830030,
                "title": "small-python-solution",
                "content": "For understanding through an analogy, we can this of a point in cartesian co-ordinates (x, y). When this point is rotated by 90 degrees clockwise about the origin, it\\'s new co-ordinates become (y, -x). You can derive this by using the rotation matrix. the interesting is to note is that you can write this rotation matrix ([0 1][-1 0]) as the multiplication of two matrices ([0 1][1 0]) and ([-1 0][0 1]). So, from here you can see that you need to make a mirror of all the points about x axis first and then interchange the co-ordinates for all the points. In matrix terms, the first would be reversing the rows and second would be to do the transpose.\\n\\n```\\nclass Solution:\\n    def rotate(self, matrix: List[List[int]]) -> None:\\n        \"\"\"\\n        Do not return anything, modify matrix in-place instead.\\n        \"\"\"\\n        matrix.reverse()\\n        for i in range(len(matrix)):\\n            for j in range(i, len(matrix)):\\n                matrix[i][j], matrix[j][i] = matrix[j][i], matrix[i][j]\\n```\\t\\t\\t\\t",
                "solutionTags": [
                    "Python",
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def rotate(self, matrix: List[List[int]]) -> None:\\n        \"\"\"\\n        Do not return anything, modify matrix in-place instead.\\n        \"\"\"\\n        matrix.reverse()\\n        for i in range(len(matrix)):\\n            for j in range(i, len(matrix)):\\n                matrix[i][j], matrix[j][i] = matrix[j][i], matrix[i][j]\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2506228,
                "title": "golang-easy-to-understand-faster-than-100",
                "content": "**Approach** :-\\n\\n- Find the transpose of the matrix\\n- Flip the transpose to get the final result\\n\\nfinding the transpose of a square matrix is pretty easy, just swap the value of the i, j with value at j, i and vice verse for every i,j.\\nExample for i = 1 and j = 2\\nmatrix[1][2] and matrix[2][1] will swap their values.\\nIt\\'s like flipping the matrix across it\\'s diagonal.\\nSo something like \\n||||\\n| --- | --- | --- |\\n| 1 | 2 | 3|\\n| 4 | 5 | 6 |\\n| 7 | 8 | 9 |\\n\\nbecomes \\n||||\\n| --- | --- | --- |\\n| 1 | 4 | 7|\\n| 2 | 5 | 8 |\\n| 3 | 6 | 9 |\\n\\nFor flipping the matrix, we can use two pointer technique to was values across each end for every row.\\n|  |  | |\\n| --- | --- | --- |\\n| 7 | 4 | 1|\\n| 8 | 5 | 2 |\\n| 9 | 6 | 3 |\\n\\nWe can combine both the process i.e. for each row, we will first find it\\'s transpose and then flip it instantly.\\n```\\nfunc rotate(matrix [][]int)  {\\n    n, m := len(matrix), len(matrix[0])\\n    for i:= 0; i < n; i++ {\\n        // Transpose of row\\n        for j := i; j < m; j++ {\\n            matrix[i][j], matrix[j][i] = matrix[j][i], matrix[i][j]\\n        }\\n        // flipping the row\\n        for j, k := 0, m-1; j < k; j, k = j+1, k-1{\\n            matrix[i][j], matrix[i][k] = matrix[i][k], matrix[i][j]\\n        }\\n    }\\n}\\n```\\n\\n**Time Complexity** - (n^2)\\n**Space Complexity** - (1)",
                "solutionTags": [
                    "Go"
                ],
                "code": "```\\nfunc rotate(matrix [][]int)  {\\n    n, m := len(matrix), len(matrix[0])\\n    for i:= 0; i < n; i++ {\\n        // Transpose of row\\n        for j := i; j < m; j++ {\\n            matrix[i][j], matrix[j][i] = matrix[j][i], matrix[i][j]\\n        }\\n        // flipping the row\\n        for j, k := 0, m-1; j < k; j, k = j+1, k-1{\\n            matrix[i][j], matrix[i][k] = matrix[i][k], matrix[i][j]\\n        }\\n    }\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2201238,
                "title": "c-simple-explained-beats-100-optimized",
                "content": "**PLEASE UPVOTE IF YOU FIND MY APPROACH HELPFUL, MEANS A LOT \\uD83D\\uDE0A**\\n\\n* Transpose of the matrix => swap row elements to column and vica versa.\\n\\n* Now to the traversed array, reverse each row of the matrix.\\n\\n```\\nclass Solution {\\npublic:\\n    void rotate(vector<vector<int>>& matrix) {\\n        int n = matrix.size();\\n        \\n        // Step1 -> transpose the matrix\\n        for(int i=0;i<n;i++)\\n        {\\n            for(int j=0;j<i;j++)\\n            {\\n                swap(matrix[i][j],matrix[j][i]);\\n            }\\n        }\\n        \\n        // Step2 -> reverse the row\\n        for(int i=0;i<n;i++)\\n        {\\n            reverse(matrix[i].begin(),matrix[i].end());\\n        }\\n    }\\n};\\n```\\nTC -> `O(n^n)`\\nSC -> `O(1)`\\n\\n\\n\\n",
                "solutionTags": [
                    "C++",
                    "C",
                    "Matrix"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    void rotate(vector<vector<int>>& matrix) {\\n        int n = matrix.size();\\n        \\n        // Step1 -> transpose the matrix\\n        for(int i=0;i<n;i++)\\n        {\\n            for(int j=0;j<i;j++)\\n            {\\n                swap(matrix[i][j],matrix[j][i]);\\n            }\\n        }\\n        \\n        // Step2 -> reverse the row\\n        for(int i=0;i<n;i++)\\n        {\\n            reverse(matrix[i].begin(),matrix[i].end());\\n        }\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2503306,
                "title": "c-solution-faster-than-100",
                "content": "```\\n\\nclass Solution {\\npublic:\\n    void rotate(vector<vector<int>>& matrix) {\\n        vector<vector<int>> grid=matrix;\\n        int n=grid.size();\\n        int m=grid[0].size();\\n        for(int i=0;i<n;i++)\\n        {\\n            for(int j=0;j<m;j++)\\n            {\\n              matrix[j][n-1-i]=grid[i][j]; //if u will observe u can see matrix following the pattern  [j][n-1-i]=[i][j]\\n            }\\n        }\\n        \\n    }\\n};\\n// Runtime: 0 ms, faster than 100.00% of C++ online submissions for Rotate Image.\\n// Memory Usage: 7.3 MB, less than 33.50% of C++ online submissions for Rotate Image.\\n\\n\\n\\n// without using extra space\\nclass Solution {\\npublic:\\n    void rotate(vector<vector<int>>& matrix) {\\n       \\n        int n=matrix.size();\\n        for(int i=0;i<n;i++)\\n        {\\n            for(int j=0;j<i;j++)\\n            {\\n                \\n               swap(matrix[i][j],matrix[j][i]);\\n            }\\n        }\\n        for(int i = 0; i < n; ++i){\\n            reverse(matrix[i].begin(), matrix[i].end());\\n        }\\n        \\n    }\\n        \\n};\\n```",
                "solutionTags": [
                    "C++",
                    "C"
                ],
                "code": "```\\n\\nclass Solution {\\npublic:\\n    void rotate(vector<vector<int>>& matrix) {\\n        vector<vector<int>> grid=matrix;\\n        int n=grid.size();\\n        int m=grid[0].size();\\n        for(int i=0;i<n;i++)\\n        {\\n            for(int j=0;j<m;j++)\\n            {\\n              matrix[j][n-1-i]=grid[i][j]; //if u will observe u can see matrix following the pattern  [j][n-1-i]=[i][j]\\n            }\\n        }\\n        \\n    }\\n};\\n// Runtime: 0 ms, faster than 100.00% of C++ online submissions for Rotate Image.\\n// Memory Usage: 7.3 MB, less than 33.50% of C++ online submissions for Rotate Image.\\n\\n\\n\\n// without using extra space\\nclass Solution {\\npublic:\\n    void rotate(vector<vector<int>>& matrix) {\\n       \\n        int n=matrix.size();\\n        for(int i=0;i<n;i++)\\n        {\\n            for(int j=0;j<i;j++)\\n            {\\n                \\n               swap(matrix[i][j],matrix[j][i]);\\n            }\\n        }\\n        for(int i = 0; i < n; ++i){\\n            reverse(matrix[i].begin(), matrix[i].end());\\n        }\\n        \\n    }\\n        \\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2502920,
                "title": "simple-clean-code-c",
                "content": "***Rotation by 90\\' clockwise =  Transpose + reverse every row***\\n\\n```\\n   for(int i =0;i<matrix.size();i++){\\n            for(int j=i;j<matrix.size();j++){      // j starts from i so that positions aren\\'t swapped twice\\n             swap(matrix[i][j],matrix[j][i]);       // we are just traversing the upper matrix and the diagonal\\n            }\\n        }\\n        for(int i =0;i<matrix.size();i++){\\n            reverse(matrix[i].begin(),matrix[i].end());\\n        }\\n```",
                "solutionTags": [
                    "C"
                ],
                "code": "```\\n   for(int i =0;i<matrix.size();i++){\\n            for(int j=i;j<matrix.size();j++){      // j starts from i so that positions aren\\'t swapped twice\\n             swap(matrix[i][j],matrix[j][i]);       // we are just traversing the upper matrix and the diagonal\\n            }\\n        }\\n        for(int i =0;i<matrix.size();i++){\\n            reverse(matrix[i].begin(),matrix[i].end());\\n        }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2502753,
                "title": "clean-and-minimal-python-solution",
                "content": "```python\\nclass Solution:\\n    def rotate(self, arr: List[List[int]]) -> None:\\n        \"\"\"\\n        Do not return anything, modify matrix in-place instead.\\n        \"\"\"\\n        \\n        arr.reverse()\\n        for i in range(len(arr)):\\n            for j in range(i):\\n                arr[i][j], arr[j][i] = arr[j][i], arr[i][j]\\n        \\n```",
                "solutionTags": [
                    "Python"
                ],
                "code": "```python\\nclass Solution:\\n    def rotate(self, arr: List[List[int]]) -> None:\\n        \"\"\"\\n        Do not return anything, modify matrix in-place instead.\\n        \"\"\"\\n        \\n        arr.reverse()\\n        for i in range(len(arr)):\\n            for j in range(i):\\n                arr[i][j], arr[j][i] = arr[j][i], arr[i][j]\\n        \\n```",
                "codeTag": "Java"
            },
            {
                "id": 1909427,
                "title": "100-fastest-swift-solution",
                "content": "```\\nclass Solution {\\n    func rotate(_ matrix: inout [[Int]]) {\\n        let times = matrix.count / 2\\n\\n\\t\\tfor i in 0..<times {\\n\\t\\t\\tfor j in 0..<matrix.count - i * 2 - 1 {\\n\\t\\t\\t\\tlet i1 = i\\n\\t\\t\\t\\tlet i2 = i + j\\n\\t\\t\\t\\tlet i3 = matrix.count - i - 1\\n\\t\\t\\t\\tlet i4 = matrix.count - i - 1 - j\\n\\t\\t\\t\\tlet j1 = i + j\\n\\t\\t\\t\\tlet j2 = matrix.count - i - 1\\n\\t\\t\\t\\tlet j3 = matrix.count - i - 1 - j\\n\\t\\t\\t\\tlet j4 = i\\n\\t\\t\\t\\tlet n1 = matrix[i1][j1]\\n\\t\\t\\t\\tlet n2 = matrix[i2][j2]\\n\\t\\t\\t\\tlet n3 = matrix[i3][j3]\\n\\t\\t\\t\\tlet n4 = matrix[i4][j4]\\n\\t\\t\\t\\tmatrix[i1][j1] = n4\\n\\t\\t\\t\\tmatrix[i2][j2] = n1\\n\\t\\t\\t\\tmatrix[i3][j3] = n2\\n\\t\\t\\t\\tmatrix[i4][j4] = n3\\n\\t\\t\\t}\\t\\n\\t\\t}\\n    }\\n\\n}\\n```\\n\\nLet me know in comments if you have any doubts. I will be happy to answer.\\n\\nPlease upvote if you found the solution useful.",
                "solutionTags": [
                    "Swift"
                ],
                "code": "```\\nclass Solution {\\n    func rotate(_ matrix: inout [[Int]]) {\\n        let times = matrix.count / 2\\n\\n\\t\\tfor i in 0..<times {\\n\\t\\t\\tfor j in 0..<matrix.count - i * 2 - 1 {\\n\\t\\t\\t\\tlet i1 = i\\n\\t\\t\\t\\tlet i2 = i + j\\n\\t\\t\\t\\tlet i3 = matrix.count - i - 1\\n\\t\\t\\t\\tlet i4 = matrix.count - i - 1 - j\\n\\t\\t\\t\\tlet j1 = i + j\\n\\t\\t\\t\\tlet j2 = matrix.count - i - 1\\n\\t\\t\\t\\tlet j3 = matrix.count - i - 1 - j\\n\\t\\t\\t\\tlet j4 = i\\n\\t\\t\\t\\tlet n1 = matrix[i1][j1]\\n\\t\\t\\t\\tlet n2 = matrix[i2][j2]\\n\\t\\t\\t\\tlet n3 = matrix[i3][j3]\\n\\t\\t\\t\\tlet n4 = matrix[i4][j4]\\n\\t\\t\\t\\tmatrix[i1][j1] = n4\\n\\t\\t\\t\\tmatrix[i2][j2] = n1\\n\\t\\t\\t\\tmatrix[i3][j3] = n2\\n\\t\\t\\t\\tmatrix[i4][j4] = n3\\n\\t\\t\\t}\\t\\n\\t\\t}\\n    }\\n\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1737976,
                "title": "python-visual-explanation-complexity-analysis",
                "content": "I hope my graphic helps you to understand how transposing + folding = rotating the matrix :)\\n\\nTime Complexity:\\nO(r * c) (transpose) + O(r * c) (rotate) = 2O(r * c) => **O(r * c)**\\nwhere r is number of row, and c is number of col\\n\\nSpace Complexity:\\n**O(1)** because you are doing in place :)\\n\\n![image](https://assets.leetcode.com/users/images/355c441b-70a6-41ac-bee7-774cf98aee93_1643766894.2391593.png)\\n\\n```\\nclass Solution:\\n    def rotate(self, matrix: List[List[int]]) -> None:\\n        rLen, cLen = len(matrix), len(matrix[0])\\n        \\n        #Transposing\\n        for r in range(rLen):\\n            for c in range(cLen):\\n                if r > c:\\n                    matrix[r][c], matrix[c][r] = matrix[c][r], matrix[r][c]\\n\\n        #Folding\\n        for r in range(rLen):\\n            for c in range(cLen):\\n                center = cLen // 2\\n                if c < center:\\n                    matrix[r][c], matrix[r][cLen - c - 1] = matrix[r][cLen - c - 1], matrix[r][c]\\n        \\n        return matrix\\n```\\n\\n**Please correct me if I am wrong !\\nPlease UPVOTE if you find this solution helpful !\\nHappy algo!**",
                "solutionTags": [
                    "Python"
                ],
                "code": "```\\nclass Solution:\\n    def rotate(self, matrix: List[List[int]]) -> None:\\n        rLen, cLen = len(matrix), len(matrix[0])\\n        \\n        #Transposing\\n        for r in range(rLen):\\n            for c in range(cLen):\\n                if r > c:\\n                    matrix[r][c], matrix[c][r] = matrix[c][r], matrix[r][c]\\n\\n        #Folding\\n        for r in range(rLen):\\n            for c in range(cLen):\\n                center = cLen // 2\\n                if c < center:\\n                    matrix[r][c], matrix[r][cLen - c - 1] = matrix[r][cLen - c - 1], matrix[r][c]\\n        \\n        return matrix\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1674827,
                "title": "c-solution-with-full-explanation",
                "content": "> **If you\\u2019re interested in coding you can join my Discord Server, link in the comment section. Also if you find any mistake please let me know. Thank you!\\u2764\\uFE0F**\\n> \\n\\n---\\n\\n## Explanation:\\n\\n### Solution 01\\n\\n- Here we took 4pointers: ***row start(rs), row end(re), column start(cs), column end(ce).***\\n- Every time while loop runs, it takes the outer border elements to their fixed position.\\n- Then we move to inner borders.\\n- **Time complexity:** O(n^2).\\n\\n### Solution 02\\n\\n- This solution is more simple than the previous one.\\n- Here we transpose the matrix, it will make every row element to column element.\\n- Then we simply reverse every row.\\n- **Time complexity:** O(n^2).\\n\\n---\\n\\n## Code:\\n\\n```cpp\\n//Solution 01:\\n****class Solution {\\npublic:\\n    void rotate(vector<vector<int>>& matrix) {\\n        int n= matrix.size();\\n        int rs=0, re=n-1, cs=0, ce=n-1, i ,j;\\n        while(rs<re && cs<ce){\\n            for(i=cs; i<ce; i++){\\n                swap(matrix[rs][i],matrix[i][ce]);\\n            }\\n            for(i=re; i>rs; i--){\\n                swap(matrix[ce][i],matrix[i][cs]);\\n            }\\n            for(i=cs,j=ce; i<ce,j>cs; i++,j--){\\n                swap(matrix[rs][i], matrix[re][j]);\\n            }\\n            rs++; re--; cs++; ce--;\\n        }\\n    }\\n};\\n\\n//Solution 02:\\nclass Solution {\\npublic:\\n    void rotate(vector<vector<int>>& matrix) {\\n        int n= matrix.size();\\n        \\n        for(int i=0; i<n; i++){\\n            for(int j=0; j<i; j++){\\n                swap(matrix[i][j], matrix[j][i]);\\n            }\\n        }\\n        \\n        for(int i=0; i<n; i++){\\n            reverse(matrix[i].begin(), matrix[i].end());\\n        }\\n    }\\n};\\n```\\n\\n---\\n\\n> **Please upvote this solution**\\n>",
                "solutionTags": [
                    "C++",
                    "C"
                ],
                "code": "```cpp\\n//Solution 01:\\n****class Solution {\\npublic:\\n    void rotate(vector<vector<int>>& matrix) {\\n        int n= matrix.size();\\n        int rs=0, re=n-1, cs=0, ce=n-1, i ,j;\\n        while(rs<re && cs<ce){\\n            for(i=cs; i<ce; i++){\\n                swap(matrix[rs][i],matrix[i][ce]);\\n            }\\n            for(i=re; i>rs; i--){\\n                swap(matrix[ce][i],matrix[i][cs]);\\n            }\\n            for(i=cs,j=ce; i<ce,j>cs; i++,j--){\\n                swap(matrix[rs][i], matrix[re][j]);\\n            }\\n            rs++; re--; cs++; ce--;\\n        }\\n    }\\n};\\n\\n//Solution 02:\\nclass Solution {\\npublic:\\n    void rotate(vector<vector<int>>& matrix) {\\n        int n= matrix.size();\\n        \\n        for(int i=0; i<n; i++){\\n            for(int j=0; j<i; j++){\\n                swap(matrix[i][j], matrix[j][i]);\\n            }\\n        }\\n        \\n        for(int i=0; i<n; i++){\\n            reverse(matrix[i].begin(), matrix[i].end());\\n        }\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1175774,
                "title": "java-easy-transpose-readable-solution",
                "content": "Generally in rotate Question the key thing is to take transpose first.\\n\\nAfter taking transpose\\nIf they have told you to rotate in:\\n1. **Anti Clockwise:** `Reverse the rows`\\n2. **Clockwise :** `Reverse the columns`\\n\\nAlways draw diagram for better clearity after taking transpose how my matrix will look then you will easily able to figure out.\\n```\\nMatrix                       Transpose                            Result\\n1 2 3                          1 4 7                               7  4  1\\n4 5 6                          2 5 8                               8  5  2\\n7 8 9                          3 6 9                               9  6  3\\n```\\n\\n**CODE:**\\n```\\n    public void rotate(int[][] matrix) {\\n        \\n        //1.Transpose\\n        for(int r=0;r<matrix.length;r++){\\n            for(int c=0;c<r;c++){\\n               int temp=martrix[r][c];\\n               matrix[r][c]=matrix[c][r];\\n               matrix[c][r]=temp;\\n            }\\n        }\\n        \\n       \\n        int fc=0; // fc: first column\\n        int lc=matrix[0].length-1; //lc : last column\\n        \\n        while(fc<lc){\\n           //swap first column with last column\\n            for(int r=0;r<matrix.length;r++){\\n                 int temp=matrix[r][fc];\\n                 matrix[r][fc]=matrix[r][lc];\\n                 matrix[r][lc]=temp;\\n            }\\n            \\n            fc++;\\n            lc--;\\n        }\\n    }\\n```\\n\\n**Complexity:**\\n`Time:O(n^2) and Space:O(1)`\\n\\n**Note:** To take Transpose Matrix should be square matrix (n * n). So confirm to your interview that matrix is square before solving. Else you may get Rejection even after solving problem is most optimsed way*\\n#Don\\'t assume anything by yourself in interview\\n\\nPlease **Upvote** if found it helpful and feel free to reach out to me or comment down if you have any doubt.",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nMatrix                       Transpose                            Result\\n1 2 3                          1 4 7                               7  4  1\\n4 5 6                          2 5 8                               8  5  2\\n7 8 9                          3 6 9                               9  6  3\\n```\n```\\n    public void rotate(int[][] matrix) {\\n        \\n        //1.Transpose\\n        for(int r=0;r<matrix.length;r++){\\n            for(int c=0;c<r;c++){\\n               int temp=martrix[r][c];\\n               matrix[r][c]=matrix[c][r];\\n               matrix[c][r]=temp;\\n            }\\n        }\\n        \\n       \\n        int fc=0; // fc: first column\\n        int lc=matrix[0].length-1; //lc : last column\\n        \\n        while(fc<lc){\\n           //swap first column with last column\\n            for(int r=0;r<matrix.length;r++){\\n                 int temp=matrix[r][fc];\\n                 matrix[r][fc]=matrix[r][lc];\\n                 matrix[r][lc]=temp;\\n            }\\n            \\n            fc++;\\n            lc--;\\n        }\\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1175641,
                "title": "rotate-image-easy-solution-w-clear-explanation-diagrams",
                "content": "\\u2714\\uFE0F ***Solution - I (Swap Group of 4s)***\\n\\nWe can observe that after 90\\xB0 rotation, we have essentially swapped each group of 4 cells in clockwise direction. The swapping occurs as -\\n\\n<span><p align=center><img src = https://assets.leetcode.com/users/images/873f1aad-ba3e-4177-b9e8-af30a0809202_1619338999.1282618.png height = 400 /></p></span>\\n\\nNow, we can iterate over each row of matrix. For each first half of the rows, we will have `n / 2` groups of 4 cells which need to be swapped cyclically (Note: not `n` groups which will result in 180\\xB0 rotation). We will swap them cyclically till first half rows of the matrix (not all the rows which wrongly rewrite over previous swaps).\\n\\nThe swap groups would be like these -\\n\\n<p align=center><img src = https://assets.leetcode.com/users/images/d4bb47e5-f9ad-4f9b-b20e-639bb70bb323_1619339168.4737794.png width = 400 /></p>\\n\\nThe colors denote the collection of group of cells from each row. For eg. The first outer iteration would involve the cells - `[ [1,2,3], [7,7,7], [5,6,7], [1,1,1] ]`. In the inner iteration, each of the cell in one of these subarrays would be swapped clockwise with the corresponding cell in the next subarray\\n\\nThe only difficult thing that remains now is manipulating the variables in our loop to swap the correct group of 4 cells. It can be derived by working out a few examples. I would suggest to try it on your own before seeing the solution below.\\n\\n```\\nvoid rotate(vector<vector<int>>& m) {\\n\\tint n = size(m), tmp;\\n\\tfor(int i = 0; i < (n + 1) / 2; i++){\\n\\t\\tfor(int j = 0; j < n / 2; j++){\\n\\t\\t\\ttmp = m[n - 1 - j][i];\\n\\t\\t\\tm[n - 1 - j][i] = m[n - 1 - i][n - 1 - j];\\n\\t\\t\\tm[n - 1 - i][n - 1 - j] = m[j][n - 1 - i];\\n\\t\\t\\tm[j][n - 1 - i] = m[i][j];                \\n\\t\\t\\tm[i][j] = tmp;\\n\\t\\t}\\n\\t}        \\n}\\n```\\n\\n***Time Complexity :*** **`O(N^2)`**\\n***Space Complexity :*** **`O(1)`**\\n\\n---\\n\\n\\u2714\\uFE0F ***Solution - II (Swap Ring-by-Ring)***\\n\\nWe can also choose to swap one ring after another which personally seems more intuitive solution that the first one. Here, we will swap all the cells of outer ring, then the inner ring till the inner-most ring.\\n\\n<p align=center><img src = https://assets.leetcode.com/users/images/e2c3496c-9e15-430b-8614-5d83fe9d8eac_1619344342.7277594.png width = 450 /></p>\\n\\n\\nIn the above image, the color denote different rings being swapped one after another, the subscript **`1.x, 2.x, 3.x...`** (where `1<=x<=4`) denotes a group of 4 cells. Each group of 4 cells will be swapped clockwise one after another starting from outermost ring to innermost ring.\\n\\n```\\nvoid rotate(vector<vector<int>>& m) {\\n\\tint n = size(m), tmp;\\n\\tfor(int i = 0; i < n / 2; i++){\\n\\t\\tfor(int j = i; j < n - 1 - i; j++){\\n\\t\\t\\ttmp = m[i][j];\\n\\t\\t\\tm[i][j] = m[n - 1 - j][i];\\n\\t\\t\\tm[n - 1 - j][i] = m[n - 1 - i][n - 1 - j];\\n\\t\\t\\tm[n - 1 - i][n - 1 - j] = m[j][n - 1 - i];\\n\\t\\t\\tm[j][n - 1 - i] = tmp;\\n\\t\\t}            \\n\\t}\\n}\\n```\\n\\n\\n\\n\\n***Time Complexity :*** **`O(N^2)`**\\n***Space Complexity :*** **`O(1)`**\\n\\n  \\n---\\n---\\n\\n\\uD83D\\uDCBB\\uD83D\\uDC31\\u200D\\uD83D\\uDCBBIf there are any suggestions / questions / mistakes in my post, please do comment below \\uD83D\\uDC47 \\n\\n---\\n---",
                "solutionTags": [
                    "C"
                ],
                "code": "```\\nvoid rotate(vector<vector<int>>& m) {\\n\\tint n = size(m), tmp;\\n\\tfor(int i = 0; i < (n + 1) / 2; i++){\\n\\t\\tfor(int j = 0; j < n / 2; j++){\\n\\t\\t\\ttmp = m[n - 1 - j][i];\\n\\t\\t\\tm[n - 1 - j][i] = m[n - 1 - i][n - 1 - j];\\n\\t\\t\\tm[n - 1 - i][n - 1 - j] = m[j][n - 1 - i];\\n\\t\\t\\tm[j][n - 1 - i] = m[i][j];                \\n\\t\\t\\tm[i][j] = tmp;\\n\\t\\t}\\n\\t}        \\n}\\n```\n```\\nvoid rotate(vector<vector<int>>& m) {\\n\\tint n = size(m), tmp;\\n\\tfor(int i = 0; i < n / 2; i++){\\n\\t\\tfor(int j = i; j < n - 1 - i; j++){\\n\\t\\t\\ttmp = m[i][j];\\n\\t\\t\\tm[i][j] = m[n - 1 - j][i];\\n\\t\\t\\tm[n - 1 - j][i] = m[n - 1 - i][n - 1 - j];\\n\\t\\t\\tm[n - 1 - i][n - 1 - j] = m[j][n - 1 - i];\\n\\t\\t\\tm[j][n - 1 - i] = tmp;\\n\\t\\t}            \\n\\t}\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 303940,
                "title": "c-faster-than-100-00",
                "content": "```\\nvoid rotate(int** matrix, int matrixSize, int* matrixColSize){\\n\\tint c=0;\\n\\tint n=matrixSize-1;\\n\\n\\tfor( c=0 ; c <= n ; c++, n=--) {\\n\\t\\tfor( int i=c, j=n ; i<n; i++, j--) {\\n\\t\\t   \\tint tmp = matrix[c][j];\\n\\t\\t\\tmatrix[c][j] = matrix[i][c];\\n\\t\\t\\tmatrix[i][c] = matrix[n][i];\\n\\t\\t\\tmatrix[n][i] = matrix[j][n];\\n\\t\\t\\tmatrix[j][n] = tmp;\\n     \\t}\\n\\t}\\n}\\n```\\n",
                "solutionTags": [
                    "C"
                ],
                "code": "```\\nvoid rotate(int** matrix, int matrixSize, int* matrixColSize){\\n\\tint c=0;\\n\\tint n=matrixSize-1;\\n\\n\\tfor( c=0 ; c <= n ; c++, n=--) {\\n\\t\\tfor( int i=c, j=n ; i<n; i++, j--) {\\n\\t\\t   \\tint tmp = matrix[c][j];\\n\\t\\t\\tmatrix[c][j] = matrix[i][c];\\n\\t\\t\\tmatrix[i][c] = matrix[n][i];\\n\\t\\t\\tmatrix[n][i] = matrix[j][n];\\n\\t\\t\\tmatrix[j][n] = tmp;\\n     \\t}\\n\\t}\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2838216,
                "title": "very-simple-java-solution-with-explanation-0ms-faster",
                "content": "*Common way to rotate a 2D matrix in 90 degree*\\n1. First transpose the given 2D matrix. **Transpose of a matrix is found by interchanging its rows into columns or columns into rows.**\\n ![image](https://assets.leetcode.com/users/images/03f41759-b146-4ae6-a47e-90f616e29816_1669096889.8690052.png)### [5. Longest Palindromic Substring](https://leetcode.com/problems/longest-palindromic-substring/)\\n2. Now we are simple reversing the each row. \\n\\n\\n\\n```\\nclass Solution {\\n    public void rotate(int[][] matrix) {\\n        // to rotate the matrix = transpose + reverse\\n        \\n        //first we are transposing the 2D array\\n        for(int i=0; i<matrix.length; i++){\\n            for(int j=i; j<matrix[i].length; j++){\\n                int temp = matrix[i][j];\\n                matrix[i][j] = matrix[j][i];\\n                matrix[j][i] = temp;\\n            }\\n        }\\n        \\n        //here we are reversing each row\\n        for(int i=0; i<matrix.length; i++){\\n            for(int j=0; j<matrix.length/2; j++){\\n                int temp = 0;\\n                temp = matrix[i][j];\\n                matrix[i][j] = matrix[i][matrix.length-1-j];\\n                matrix[i][matrix.length-1-j] = temp;\\n            }\\n        }\\n        \\n    }\\n}\\n```\\n\\n**If you like the solution please upvote and comment. If there is any doubt please feel free to ask in the comment section I will respond to it.**",
                "solutionTags": [
                    "Java",
                    "Array"
                ],
                "code": "```\\nclass Solution {\\n    public void rotate(int[][] matrix) {\\n        // to rotate the matrix = transpose + reverse\\n        \\n        //first we are transposing the 2D array\\n        for(int i=0; i<matrix.length; i++){\\n            for(int j=i; j<matrix[i].length; j++){\\n                int temp = matrix[i][j];\\n                matrix[i][j] = matrix[j][i];\\n                matrix[j][i] = temp;\\n            }\\n        }\\n        \\n        //here we are reversing each row\\n        for(int i=0; i<matrix.length; i++){\\n            for(int j=0; j<matrix.length/2; j++){\\n                int temp = 0;\\n                temp = matrix[i][j];\\n                matrix[i][j] = matrix[i][matrix.length-1-j];\\n                matrix[i][matrix.length-1-j] = temp;\\n            }\\n        }\\n        \\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 19168,
                "title": "share-my-inplace-solution",
                "content": "        class Solution {\\n    public:\\n        //fold for the middle, fold for the diagnal\\n        void rotate(vector<vector<int> > &matrix) {\\n            //find middle\\n            int mid = matrix.size()/2;\\n            int n = matrix.size();\\n            //swap, i swap with matrix.size()-1-i\\n            for(int i = 0; i < mid; i++){\\n                for(int j = 0; j < n; j++){\\n                    swap(matrix[i][j], matrix[n-1-i][j]);\\n                }\\n            }\\n            //swap, i,j swap with j,i\\n            for(int i = 0; i < n; i++){\\n                for(int j = i; j < n; j++){\\n                    swap(matrix[i][j], matrix[j][i]);\\n                }\\n            }\\n        }\\n    };\\n\\nFold matrix once to the middle line. Fold matrix one more time along the diagonal line.",
                "solutionTags": [],
                "code": "class Solution {\\n    public:\\n        //fold for the middle, fold for the diagnal\\n        void rotate(vector<vector<int> > &matrix) {\\n            //find middle\\n            int mid = matrix.size()/2;\\n            int n = matrix.size();\\n            //swap, i swap with matrix.size()-1-i\\n            for(int i = 0; i < mid; i++){\\n                for(int j = 0; j < n; j++){\\n                    swap(matrix[i][j], matrix[n-1-i][j]);\\n                }",
                "codeTag": "Java"
            },
            {
                "id": 3913807,
                "title": "1-line-python-code-beats-97-75-34-ms-with-explanation",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nbasically what we are doing is rotating the given array.There are many ways to do it since we are using pytohn i used a function called zip which is an inbuilt python function.\\n\\nzip basically takes multiple arguments and groups together the each of the elemnents from the arguments into a tuple i.e, the first elements of each argument are groped into a tuple then the next and so on.\\n\\nthen we use ```\\'*\\'```a variable argument passing operator(the name might not be acurate).\\nthis operator gives out one argument at a time from a group of arguments(int his case lists from a 2d list).\\n\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\nFirst we need to modify the elements of the array directly i.e, we need to change the data in the location pointed by the array.I am using slicing to do the job for me.\\n\\nThen we pass the lists in given 2d list ```matrix``` to the ```zip``` function in reverse order since we dont want to get a transpose,we want to rotate it clock-wise.\\n\\nLastly the resultant tuple returned by zip is given to ```list()``` function.   \\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution:\\n    def rotate(self, matrix: List[List[int]]) -> None:\\n        \"\"\"\\n        Do not return anything, modify matrix in-place instead.\\n        \"\"\"\\n        matrix[:]=list(zip(*matrix[::-1]))\\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\'*\\'```\n```matrix```\n```zip```\n```list()```\n```\\nclass Solution:\\n    def rotate(self, matrix: List[List[int]]) -> None:\\n        \"\"\"\\n        Do not return anything, modify matrix in-place instead.\\n        \"\"\"\\n        matrix[:]=list(zip(*matrix[::-1]))\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2503830,
                "title": "easy-java-soluion-100-faster",
                "content": "Basic swapping and re-arrangement.. Do a dry run on code to understand the operations!!\\n```\\nclass Solution {\\n    public void rotate(int[][] matrix) {\\n        int n = matrix.length;\\n        for (int i = 0; i < (n + 1) / 2; i ++) {\\n            for (int j = 0; j < n / 2; j++) {\\n                int temp = matrix[n - 1 - j][i];\\n                matrix[n - 1 - j][i] = matrix[n - 1 - i][n - j - 1];\\n                matrix[n - 1 - i][n - j - 1] = matrix[j][n - 1 -i];\\n                matrix[j][n - 1 - i] = matrix[i][j];\\n                matrix[i][j] = temp;\\n            }\\n        }\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public void rotate(int[][] matrix) {\\n        int n = matrix.length;\\n        for (int i = 0; i < (n + 1) / 2; i ++) {\\n            for (int j = 0; j < n / 2; j++) {\\n                int temp = matrix[n - 1 - j][i];\\n                matrix[n - 1 - j][i] = matrix[n - 1 - i][n - j - 1];\\n                matrix[n - 1 - i][n - j - 1] = matrix[j][n - 1 -i];\\n                matrix[j][n - 1 - i] = matrix[i][j];\\n                matrix[i][j] = temp;\\n            }\\n        }\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3852607,
                "title": "easy-solution-using-constant-space-beats-100-c",
                "content": "# Intuition\\nLet\\'s start swapping the elements.\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\nWe will swap the elements 3 times anti-clockwise.\\n\\n1  2  3\\n4  5  6\\n7  8  9\\n\\nswap 1 with 7,\\n\\n7  2  3\\n4  5  6\\n1  8  9\\n\\nswap 1 with 9,\\n\\n7  2  3\\n4  5  6\\n9  8  1\\n\\nswap 1 with 3,\\n\\n7  2  1\\n4  5  6\\n9  8  3\\n\\nWe can see that the corners of this matrix are rotated simiarily we will rotate all other elements.\\n\\n\\n\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n O(n^2)\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\nO(1)\\n\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    void rotate(vector<vector<int>>& matrix) {\\n        // If you like the solution PLS UPVOTE\\n        int s=0;\\n        int e=matrix.size()-1;\\n         while(s<e){\\n            for(int i=0;i<e-s;i++){\\n                swap(matrix[s][s+i],matrix[e-i][s]);\\n                swap(matrix[e-i][s],matrix[e][e-i]);\\n                swap(matrix[e][e-i],matrix[s+i][e]);\\n             }\\n            s++;\\n            e--;\\n  \\n        }\\n        \\n    }\\n};\\n```\\n![image.png](https://assets.leetcode.com/users/images/34c73989-5abd-4c3f-8124-8b74daf153c9_1691247839.2683234.png)\\n",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    void rotate(vector<vector<int>>& matrix) {\\n        // If you like the solution PLS UPVOTE\\n        int s=0;\\n        int e=matrix.size()-1;\\n         while(s<e){\\n            for(int i=0;i<e-s;i++){\\n                swap(matrix[s][s+i],matrix[e-i][s]);\\n                swap(matrix[e-i][s],matrix[e][e-i]);\\n                swap(matrix[e][e-i],matrix[s+i][e]);\\n             }\\n            s++;\\n            e--;\\n  \\n        }\\n        \\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3503263,
                "title": "awesome-logic-with-top-bottom-left-right",
                "content": "# Python3 Solution\\n```\\nclass Solution:\\n    def rotate(self, matrix: List[List[int]]) -> None:\\n        left,right=0,len(matrix)-1\\n        while left<right:\\n            for i in range(right-left):\\n                top,bottom=left,right\\n                topleft=matrix[top][left+i]\\n                matrix[top][left+i]=matrix[bottom-i][left]\\n                matrix[bottom-i][left]=matrix[bottom][right-i]\\n                matrix[bottom][right-i]=matrix[top+i][right]\\n                matrix[top+i][right]=topleft\\n            left+=1\\n            right-=1\\n        return matrix\\n ````\\n # please upvote me it would encourage me alot\\n",
                "solutionTags": [
                    "Python3",
                    "Matrix"
                ],
                "code": "```\\nclass Solution:\\n    def rotate(self, matrix: List[List[int]]) -> None:\\n        left,right=0,len(matrix)-1\\n        while left<right:\\n            for i in range(right-left):\\n                top,bottom=left,right\\n                topleft=matrix[top][left+i]\\n                matrix[top][left+i]=matrix[bottom-i][left]\\n                matrix[bottom-i][left]=matrix[bottom][right-i]\\n                matrix[bottom][right-i]=matrix[top+i][right]\\n                matrix[top+i][right]=topleft\\n            left+=1\\n            right-=1\\n        return matrix\\n ```",
                "codeTag": "Java"
            },
            {
                "id": 3150138,
                "title": "solution-in-java",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n1. We swap the arrays in the matrix.\\n2. Then reverse the matrix.\\n3. We have taken the anti-clockwise approach.\\n\\n# Complexity\\n- Time complexity:**100%**\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n\\n- Space complexity:**94.39%**\\n\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\n    public void rotate(int[][] matrix) {\\n        int n=matrix.length;\\n        int m=matrix[0].length;\\n         int l=0,s=m-1;\\n       while(l<s){\\n          int[] temp2=matrix[l];\\n          matrix[l]=matrix[s];\\n          matrix[s]=temp2;\\n          l++;\\n          s--;\\n       }\\n        for(int i=0;i<n;i++){\\n            for(int j=i+1;j<m;j++){\\n                int temp=  matrix[i][j];\\n                matrix[i][j]=matrix[j][i];\\n                  matrix[j][i]=temp;\\n            }\\n        }\\n      \\n\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Array",
                    "Math"
                ],
                "code": "```\\nclass Solution {\\n    public void rotate(int[][] matrix) {\\n        int n=matrix.length;\\n        int m=matrix[0].length;\\n         int l=0,s=m-1;\\n       while(l<s){\\n          int[] temp2=matrix[l];\\n          matrix[l]=matrix[s];\\n          matrix[s]=temp2;\\n          l++;\\n          s--;\\n       }\\n        for(int i=0;i<n;i++){\\n            for(int j=i+1;j<m;j++){\\n                int temp=  matrix[i][j];\\n                matrix[i][j]=matrix[j][i];\\n                  matrix[j][i]=temp;\\n            }\\n        }\\n      \\n\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2502783,
                "title": "c-java-2-method",
                "content": "**Solution 1: Optimized approach**\\n\\nIntuition: By observation, we see that the first column of the original matrix is the reverse of the first row of the rotated matrix, so that\\u2019s why we transpose the matrix and then reverse each row, and since we are making changes in the matrix itself space complexity gets reduced to O(1).\\n\\nApproach:\\n\\nStep1: Transpose of the matrix. (transposing means changing columns to rows and rows to columns)\\n\\nStep2: Reverse each row of the matrix.\\n\\n**Time Complexity**:` O(N*N) + O(N*N)`.One O(N*N) for transposing the matrix and the other for reversing the matrix.\\n\\n**Space Complexity**: `O(1)`.\\n\\n**C++ Code**\\n```\\nvoid rotate(vector < vector < int >> & matrix) {\\n  int n = matrix.size();\\n  //transposing the matrix\\n  for (int i = 0; i < n; i++) {\\n    for (int j = 0; j < i; j++) {\\n      swap(matrix[i][j], matrix[j][i]);\\n    }\\n  }\\n  //reversing each row of the matrix\\n  for (int i = 0; i < n; i++) {\\n    reverse(matrix[i].begin(), matrix[i].end());\\n  }\\n}\\n```\\n\\n**Java Code:**\\n```\\n static void rotate(int[][] matrix) {\\n        for (int i = 0; i < matrix.length; i++) {\\n            for (int j = i; j < matrix[0].length; j++) {\\n                int temp = 0;\\n                temp = matrix[i][j];\\n                matrix[i][j] = matrix[j][i];\\n                matrix[j][i] = temp;\\n            }\\n        }\\n        for (int i = 0; i < matrix.length; i++) {\\n            for (int j = 0; j < matrix.length / 2; j++) {\\n                int temp = 0;\\n                temp = matrix[i][j];\\n                matrix[i][j] = matrix[i][matrix.length - 1 - j];\\n                matrix[i][matrix.length - 1 - j] = temp;\\n            }\\n        }\\n    }\\n```\\n\\n**Solution 2:Brute force**\\n\\n**Approach:** Take another dummy matrix of n*n, and then take the first row of the matrix and put it in the last column of the dummy matrix, take the second row of the matrix, and put it in the second last column of the matrix and so.\\n\\n**Time Complexity**: `O(N*N) `to linearly iterate and put it into some other matrix.\\n\\n**Space Complexity**: `O(N*N)` to copy it into some other matrix.\\n\\n**C++ Code**\\n```\\nvector < vector < int >> rotate(vector < vector < int >> & matrix) {\\n  int n = matrix.size();\\n  vector < vector < int >> rotated(n, vector < int > (n, 0));\\n  for (int i = 0; i < n; i++) {\\n    for (int j = 0; j < n; j++) {\\n      rotated[j][n - i - 1] = matrix[i][j];\\n    }\\n  }\\n  return rotated;\\n}\\n```\\n\\n**Java Code**\\n```\\nstatic int[][] rotate(int[][] matrix) {\\n        int n = matrix.length;\\n        int rotated[][] = new int[n][n];\\n        for (int i = 0; i < n; i++) {\\n            for (int j = 0; j < n; j++) {\\n                rotated[j][n - i - 1] = matrix[i][j];\\n            }\\n        }\\n        return rotated;\\n    }\\n```\\n\\n",
                "solutionTags": [
                    "Java",
                    "C"
                ],
                "code": "```\\nvoid rotate(vector < vector < int >> & matrix) {\\n  int n = matrix.size();\\n  //transposing the matrix\\n  for (int i = 0; i < n; i++) {\\n    for (int j = 0; j < i; j++) {\\n      swap(matrix[i][j], matrix[j][i]);\\n    }\\n  }\\n  //reversing each row of the matrix\\n  for (int i = 0; i < n; i++) {\\n    reverse(matrix[i].begin(), matrix[i].end());\\n  }\\n}\\n```\n```\\n static void rotate(int[][] matrix) {\\n        for (int i = 0; i < matrix.length; i++) {\\n            for (int j = i; j < matrix[0].length; j++) {\\n                int temp = 0;\\n                temp = matrix[i][j];\\n                matrix[i][j] = matrix[j][i];\\n                matrix[j][i] = temp;\\n            }\\n        }\\n        for (int i = 0; i < matrix.length; i++) {\\n            for (int j = 0; j < matrix.length / 2; j++) {\\n                int temp = 0;\\n                temp = matrix[i][j];\\n                matrix[i][j] = matrix[i][matrix.length - 1 - j];\\n                matrix[i][matrix.length - 1 - j] = temp;\\n            }\\n        }\\n    }\\n```\n```\\nvector < vector < int >> rotate(vector < vector < int >> & matrix) {\\n  int n = matrix.size();\\n  vector < vector < int >> rotated(n, vector < int > (n, 0));\\n  for (int i = 0; i < n; i++) {\\n    for (int j = 0; j < n; j++) {\\n      rotated[j][n - i - 1] = matrix[i][j];\\n    }\\n  }\\n  return rotated;\\n}\\n```\n```\\nstatic int[][] rotate(int[][] matrix) {\\n        int n = matrix.length;\\n        int rotated[][] = new int[n][n];\\n        for (int i = 0; i < n; i++) {\\n            for (int j = 0; j < n; j++) {\\n                rotated[j][n - i - 1] = matrix[i][j];\\n            }\\n        }\\n        return rotated;\\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2021558,
                "title": "c-one-iteration-solution-small-and-easy-code",
                "content": "The digonal elements before the mid element will be swapped in a circular fashion as shown in the image attached. The ordinary approach of transpose and reverse take extra time to reverse but here it\\'s swap which is constant time instrution. So, better time complexity.\\n\\n![image](https://assets.leetcode.com/users/images/458671c2-1f0b-47f1-937c-80ae7c7285d0_1652075441.6591158.png)\\n\\n```\\nclass Solution {\\npublic:\\n    void rotate(vector<vector<int>>& matrix) {\\n        int n=matrix.size();\\n        for(int i=0,j=0; i<n; i++,j++)\\n        {\\n            for(int k=i; k<n-i-1; k++)\\n            {\\n                swap(matrix[i][k], matrix[k][n-i-1]);\\n                swap(matrix[i][k], matrix[n-i-1][n-k-1]);\\n                swap(matrix[i][k], matrix[n-k-1][i]);\\n            }\\n        }\\n    }\\n};\\n```",
                "solutionTags": [
                    "C"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    void rotate(vector<vector<int>>& matrix) {\\n        int n=matrix.size();\\n        for(int i=0,j=0; i<n; i++,j++)\\n        {\\n            for(int k=i; k<n-i-1; k++)\\n            {\\n                swap(matrix[i][k], matrix[k][n-i-1]);\\n                swap(matrix[i][k], matrix[n-i-1][n-k-1]);\\n                swap(matrix[i][k], matrix[n-k-1][i]);\\n            }\\n        }\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 209450,
                "title": "python-solution",
                "content": "Time complexity: `O(n^2)`, space complexity: `O(1)`.\\n\\n```\\nclass Solution:\\n    def rotate(self, matrix):\\n        \"\"\"\\n        :type matrix: List[List[int]]\\n        :rtype: void Do not return anything, modify matrix in-place instead.\\n        \"\"\"\\n        n = len(matrix)\\n        for i in range(n//2):\\n            for j in range((n+1)//2):\\n                matrix[i][j], matrix[j][~i], matrix[~i][~j], matrix[~j][i] = matrix[~j][i], matrix[i][j], matrix[j][~i], matrix[~i][~j]\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution:\\n    def rotate(self, matrix):\\n        \"\"\"\\n        :type matrix: List[List[int]]\\n        :rtype: void Do not return anything, modify matrix in-place instead.\\n        \"\"\"\\n        n = len(matrix)\\n        for i in range(n//2):\\n            for j in range((n+1)//2):\\n                matrix[i][j], matrix[j][~i], matrix[~i][~j], matrix[~j][i] = matrix[~j][i], matrix[i][j], matrix[j][~i], matrix[~i][~j]\\n```",
                "codeTag": "Java"
            },
            {
                "id": 19044,
                "title": "share-my-c-solution-easy-to-understand",
                "content": "    1,2,3    7,8,9    7,4,1\\n    4,5,6 => 4,5,6 => 8,5,2 \\n    7,8,9    1,2,3    9,6,3\\n    (1)swap row i and row n-1-i\\n    (2)swap elements in symmetrical position\\n\\n \\n\\n    class Solution {\\n        public:\\n            void rotate(vector<vector<int>>& matrix) {\\n                int n = matrix.size();\\n                if (n < 2)\\n                    return;\\n                    \\n                int i = 0, j = 0, temp = 0;\\n                int mid = (n - 1) / 2;\\n                \\n                for (i = 0; i <= mid; i++)\\n                {\\n                    for (j = 0; j < n; j++)\\n                    {\\n                        temp = matrix[i][j];\\n                        matrix[i][j] = matrix[n-1-i][j];\\n                        matrix[n-1-i][j] =temp;\\n                    }\\n                }\\n                \\n                for (i = 1; i < n; i++)\\n                {\\n                    for (j = 0; i > j; j++)\\n                    {\\n                        temp = matrix[i][j];\\n                        matrix[i][j] = matrix[j][i];\\n                        matrix[j][i] = temp;\\n                    }\\n                }\\n            }\\n        };",
                "solutionTags": [
                    "C++"
                ],
                "code": "class Solution {\\n        public:\\n            void rotate(vector<vector<int>>& matrix) {\\n                int n = matrix.size();\\n                if (n < 2)\\n                    return;\\n                    \\n                int i = 0, j = 0, temp = 0;\\n                int mid = (n - 1) / 2;\\n                \\n                for (i = 0; i <= mid; i++)\\n                {\\n                    for (j = 0; j < n; j++)\\n                    {\\n                        temp = matrix[i][j];\\n                        matrix[i][j] = matrix[n-1-i][j];\\n                        matrix[n-1-i][j] =temp;\\n                    }",
                "codeTag": "Java"
            },
            {
                "id": 19095,
                "title": "java-python-2-in-place-solutions-direct-rotate-vs-reverse-transpose",
                "content": "Rotate the image directly by definition, just need to figure out the one one relation between the coordinates.\\n\\n**Python**\\n\\n    def rotate(self, matrix):\\n        n = len(matrix)\\n        for l in xrange(n / 2):\\n            r = n - 1 - l\\n            for p in xrange(l, r):\\n                q = n - 1 - p\\n                cache = matrix[l][p]\\n                matrix[l][p] = matrix[q][l]\\n                matrix[q][l] = matrix[r][q]\\n                matrix[r][q] = matrix[p][r]\\n                matrix[p][r] = cache\\n\\n\\n    # 20 / 20 test cases passed.\\n    # Status: Accepted\\n    # Runtime: 44 ms\\n    # 88.46%\\n\\n**Java**\\n\\n    public void rotate(int[][] matrix) {\\n        int n = matrix.length;\\n        for (int i = 0; i < n / 2; ++i) {\\n            int j = n - 1 - i;\\n            for (int p = i; p < j; ++p) {\\n                int q = n - 1 - p;\\n                int cache = matrix[i][p];\\n                matrix[i][p] = matrix[q][i];\\n                matrix[q][i] = matrix[j][q];\\n                matrix[j][q] = matrix[p][j];\\n                matrix[p][j] = cache;\\n            }\\n        }\\n    }\\n    // Runtime: 0ms\\n\\n\\n\\nThe reverse and transpose method needs a little bit of thinking, but once figure out, the code is rather concise.\\n\\n**Python**\\n\\n    def rotate(self, matrix):\\n        n = len(matrix)\\n        matrix.reverse()\\n        for i in xrange(n):\\n            for j in xrange(i + 1, n):\\n                matrix[i][j], matrix[j][i] = matrix[j][i], matrix[i][j]\\n\\n    # 20 / 20 test cases passed.\\n    # Status: Accepted\\n    # Runtime: 48 ms\\n    # 75.44%\\n\\n**Java**\\n\\n    public void rotate(int[][] matrix) {\\n        int n = matrix.length;\\n        // Reverse\\n        for (int i = 0; i < n / 2; ++i) {\\n            int j = n - 1 - i;\\n            int[] cache = matrix[i];\\n            matrix[i] = matrix[j];\\n            matrix[j] = cache;\\n        }\\n        // Transpose\\n        for (int i = 0; i < n; ++i) {\\n            for (int j = i + 1; j < n; ++j) {\\n                int cache = matrix[i][j];\\n                matrix[i][j] = matrix[j][i];\\n                matrix[j][i] = cache;\\n            }\\n        }\\n    }",
                "solutionTags": [
                    "Java",
                    "Python"
                ],
                "code": "Rotate the image directly by definition, just need to figure out the one one relation between the coordinates.\\n\\n**Python**\\n\\n    def rotate(self, matrix):\\n        n = len(matrix)\\n        for l in xrange(n / 2):\\n            r = n - 1 - l\\n            for p in xrange(l, r):\\n                q = n - 1 - p\\n                cache = matrix[l][p]\\n                matrix[l][p] = matrix[q][l]\\n                matrix[q][l] = matrix[r][q]\\n                matrix[r][q] = matrix[p][r]\\n                matrix[p][r] = cache\\n\\n\\n    # 20 / 20 test cases passed.\\n    # Status: Accepted\\n    # Runtime: 44 ms\\n    # 88.46%\\n\\n**Java**\\n\\n    public void rotate(int[][] matrix) {\\n        int n = matrix.length;\\n        for (int i = 0; i < n / 2; ++i) {\\n            int j = n - 1 - i;\\n            for (int p = i; p < j; ++p) {\\n                int q = n - 1 - p;\\n                int cache = matrix[i][p];\\n                matrix[i][p] = matrix[q][i];\\n                matrix[q][i] = matrix[j][q];\\n                matrix[j][q] = matrix[p][j];\\n                matrix[p][j] = cache;\\n            }\\n        }\\n    }\\n    // Runtime: 0ms\\n\\n\\n\\nThe reverse and transpose method needs a little bit of thinking, but once figure out, the code is rather concise.\\n\\n**Python**\\n\\n    def rotate(self, matrix):\\n        n = len(matrix)\\n        matrix.reverse()\\n        for i in xrange(n):\\n            for j in xrange(i + 1, n):\\n                matrix[i][j], matrix[j][i] = matrix[j][i], matrix[i][j]\\n\\n    # 20 / 20 test cases passed.\\n    # Status: Accepted\\n    # Runtime: 48 ms\\n    # 75.44%\\n\\n**Java**\\n\\n    public void rotate(int[][] matrix) {\\n        int n = matrix.length;\\n        // Reverse\\n        for (int i = 0; i < n / 2; ++i) {\\n            int j = n - 1 - i;\\n            int[] cache = matrix[i];\\n            matrix[i] = matrix[j];\\n            matrix[j] = cache;\\n        }\\n        // Transpose\\n        for (int i = 0; i < n; ++i) {\\n            for (int j = i + 1; j < n; ++j) {\\n                int cache = matrix[i][j];\\n                matrix[i][j] = matrix[j][i];\\n                matrix[j][i] = cache;\\n            }\\n        }\\n    }",
                "codeTag": "Python3"
            },
            {
                "id": 2781038,
                "title": "c-0ms-100-beats-6-line-code",
                "content": "\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n1) First take the transpose of the matrix \\n2) Then reverse each row of the matrix  \\n\\n\\n# Code\\n```\\n    void rotate(vector<vector<int>>& m) {\\n        //Taking transpose of the matrix\\n        for(int i=0;i<m.size();i++)   \\n            for(int j = 0 ;j<i ; j++)\\n              swap(m[i][j] , m[j][i]);\\n        \\n        //reversing each row of the matrix\\n        for(int i=0 ; i<m.size();i++)      \\n            reverse(m[i].begin(), m[i].end());\\n        \\n    }\\n```",
                "solutionTags": [
                    "C++",
                    "Java",
                    "C",
                    "Array",
                    "Matrix"
                ],
                "code": "```\\n    void rotate(vector<vector<int>>& m) {\\n        //Taking transpose of the matrix\\n        for(int i=0;i<m.size();i++)   \\n            for(int j = 0 ;j<i ; j++)\\n              swap(m[i][j] , m[j][i]);\\n        \\n        //reversing each row of the matrix\\n        for(int i=0 ; i<m.size();i++)      \\n            reverse(m[i].begin(), m[i].end());\\n        \\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2174994,
                "title": "rotate-matrix-in-c-2-methods-0ms-faster-than-100-simple-short",
                "content": "```\\n// Method - 1\\nvoid rotate(vector<vector<int>>& matrix) {\\n    int n = matrix.size();\\n    \\n    // changing symmetrically from middle row\\n    for(int i = 0; i < n/2; i++) {\\n        for(int j = 0; j < n; j++) {\\n            swap(matrix[i][j], matrix[n-1-i][j]);\\n        }\\n    }\\n    \\n    // taking transpose\\n    for(int i = 0; i < n; i++) {\\n        for(int j = i; j < n; j++) {\\n            swap(matrix[i][j], matrix[j][i]);\\n        }\\n    }\\n}\\n```\\n\\n```\\n// Method - 2\\nvoid rotate(vector<vector<int>>& matrix) {\\n    int n = matrix.size();\\n    for (int i = 0; i < (n + 1) / 2; i ++) {\\n        for (int j = 0; j < n / 2; j++) {\\n            int temp = matrix[n - 1 - j][i];\\n            matrix[n - 1 - j][i] = matrix[n - 1 - i][n - j - 1];\\n            matrix[n - 1 - i][n - j - 1] = matrix[j][n - 1 -i];\\n            matrix[j][n - 1 - i] = matrix[i][j];\\n            matrix[i][j] = temp;\\n        }\\n    }\\n}\\n```",
                "solutionTags": [
                    "C++",
                    "C",
                    "Matrix"
                ],
                "code": "```\\n// Method - 1\\nvoid rotate(vector<vector<int>>& matrix) {\\n    int n = matrix.size();\\n    \\n    // changing symmetrically from middle row\\n    for(int i = 0; i < n/2; i++) {\\n        for(int j = 0; j < n; j++) {\\n            swap(matrix[i][j], matrix[n-1-i][j]);\\n        }\\n    }\\n    \\n    // taking transpose\\n    for(int i = 0; i < n; i++) {\\n        for(int j = i; j < n; j++) {\\n            swap(matrix[i][j], matrix[j][i]);\\n        }\\n    }\\n}\\n```\n```\\n// Method - 2\\nvoid rotate(vector<vector<int>>& matrix) {\\n    int n = matrix.size();\\n    for (int i = 0; i < (n + 1) / 2; i ++) {\\n        for (int j = 0; j < n / 2; j++) {\\n            int temp = matrix[n - 1 - j][i];\\n            matrix[n - 1 - j][i] = matrix[n - 1 - i][n - j - 1];\\n            matrix[n - 1 - i][n - j - 1] = matrix[j][n - 1 -i];\\n            matrix[j][n - 1 - i] = matrix[i][j];\\n            matrix[i][j] = temp;\\n        }\\n    }\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1510692,
                "title": "c-easy-clean-solution-fastest-0ms-all-5-methods-detailed",
                "content": "**NOTE:** We are rotating a matrix by 90 degrees CLOCKWISE.\\n\\n#### Method1: First find Transpose and then Reverse Individual Rows\\n\\n```\\nvoid rotate(vector<vector<int>> &M) {\\n\\tint n = M.size();\\n\\t// first find transpose (inplace)\\n\\tfor (int r = 0; r < n; r++)\\n\\t\\tfor (int c = r; c < n; c++)\\n\\t\\t\\tswap(M[r][c], M[c][r]);\\n\\t// then reverse individual rows (inplace)\\n\\tfor (auto &r : M) reverse(r.begin(), r.end());\\n}\\n```\\n\\n#### Method2: First Reverse matrix and then find Transpose\\n\\n```\\nvoid rotate(vector<vector<int>> &M) {\\n\\tint n = M.size();\\n\\t// first find reverse matrix (inplace)\\n\\treverse(M.begin(), M.end());\\n\\t// then find transpose (inplace)\\n\\tfor (int r = 0; r < n; r++)\\n\\t\\tfor (int c = r; c < n; c++)\\n\\t\\t\\tswap(M[r][c], M[c][r]);\\n}\\n```\\n\\n#### Method3: First Reverse Individual Rows and then find Reverse Transpose\\n\\n```\\nvoid rotate(vector<vector<int>> &M) {\\n\\tint n = M.size();\\n\\t// first reverse individual rows (inplace)\\n\\tfor (auto &r : M) reverse(r.begin(), r.end());\\n\\t// then find reverse transpose (inplace)\\n\\tfor (int r = 0; r < n; r++)\\n\\t\\tfor (int c = n - 1 - r; c >= 0; c--)\\n\\t\\t\\tswap(M[r][c], M[n - 1 - c][n - 1 - r]);\\n}\\n```\\n\\n#### Method4: First find Reverse Transpose then Reverse Matrix\\n\\n```\\nvoid rotate(vector<vector<int>> &M) {\\n\\tint n = M.size();\\n\\t// first find reverse transpose (inplace)\\n\\tfor (int r = 0; r < n; r++)\\n\\t\\tfor (int c = n - 1 - r; c >= 0; c--)\\n\\t\\t\\tswap(M[r][c], M[n - 1 - c][n - 1 - r]);\\n\\t// then find reverse matrix (inplace)\\n\\treverse(M.begin(), M.end());\\n}\\n```\\n\\n#### Method5: Reverse in Group of Four\\n\\n```\\nvoid rotate(vector<vector<int>> &M) {\\n\\t// IDEA: 1st row will become nth column, reverse of nth column will become\\n\\t// nth row, nth row will become 1st column and reverse of 1st column will\\n\\t// become 1st row. This is done for boundary of whole matrix, then keep \\n\\t// repeating above for inner boundaries of matrix.\\n\\tint n = M.size();\\n\\t// p: padding, r: row, c: column\\n\\t// Try to visualise below with a testcase to better understand the algo\\n\\tfor (int p = 0, r = p; r < n - p - 1; r++, p++)\\n\\t\\tfor (int c = p; c < n - p - 1; c++) {\\n\\t\\t\\tswap(M[r][c], M[c][n - 1 - r]);\\n\\t\\t\\tswap(M[r][c], M[n - 1 - r][n - 1 - c]);\\n\\t\\t\\tswap(M[r][c], M[n - 1 - c][r]);\\n\\t\\t}\\n}\\n```\\n\\n##### For detailed explaination/ visualization, see solutions provided by Leetcode OJ.\\n\\n**NOTE:**\\n*If you find this post helpful then please **upvote**. It keeps me **motivated** to post such helpful solutions. Thanks!*\\n\\n**PS:**\\nI have also written posts on:\\n1. All C++ (15+) sorting algorithms in a cleaner way [here](https://leetcode.com/problems/sort-an-array/discuss/1401412/C%2B%2B-Clean-Code-Solution-or-Fastest-or-All-(15%2B)-Sorting-Methods-or-Detailed) on leetcode.\\n2. Kadane\\'s Algorithm and Follow up Questions [C++] in a cleaner way [here](https://leetcode.com/problems/maximum-subarray/discuss/1470547/C++-Easy-and-Clean-Solution-or-Fastest:-0ms-or-All-Methods-or-Follow-Ups-or-Detailed-Explanation) on leetcode.\\n\\n*Do check it out/ bookmark (and upvote :)) to revise those concepts for the interview. Thanks!*",
                "solutionTags": [],
                "code": "```\\nvoid rotate(vector<vector<int>> &M) {\\n\\tint n = M.size();\\n\\t// first find transpose (inplace)\\n\\tfor (int r = 0; r < n; r++)\\n\\t\\tfor (int c = r; c < n; c++)\\n\\t\\t\\tswap(M[r][c], M[c][r]);\\n\\t// then reverse individual rows (inplace)\\n\\tfor (auto &r : M) reverse(r.begin(), r.end());\\n}\\n```\n```\\nvoid rotate(vector<vector<int>> &M) {\\n\\tint n = M.size();\\n\\t// first find reverse matrix (inplace)\\n\\treverse(M.begin(), M.end());\\n\\t// then find transpose (inplace)\\n\\tfor (int r = 0; r < n; r++)\\n\\t\\tfor (int c = r; c < n; c++)\\n\\t\\t\\tswap(M[r][c], M[c][r]);\\n}\\n```\n```\\nvoid rotate(vector<vector<int>> &M) {\\n\\tint n = M.size();\\n\\t// first reverse individual rows (inplace)\\n\\tfor (auto &r : M) reverse(r.begin(), r.end());\\n\\t// then find reverse transpose (inplace)\\n\\tfor (int r = 0; r < n; r++)\\n\\t\\tfor (int c = n - 1 - r; c >= 0; c--)\\n\\t\\t\\tswap(M[r][c], M[n - 1 - c][n - 1 - r]);\\n}\\n```\n```\\nvoid rotate(vector<vector<int>> &M) {\\n\\tint n = M.size();\\n\\t// first find reverse transpose (inplace)\\n\\tfor (int r = 0; r < n; r++)\\n\\t\\tfor (int c = n - 1 - r; c >= 0; c--)\\n\\t\\t\\tswap(M[r][c], M[n - 1 - c][n - 1 - r]);\\n\\t// then find reverse matrix (inplace)\\n\\treverse(M.begin(), M.end());\\n}\\n```\n```\\nvoid rotate(vector<vector<int>> &M) {\\n\\t// IDEA: 1st row will become nth column, reverse of nth column will become\\n\\t// nth row, nth row will become 1st column and reverse of 1st column will\\n\\t// become 1st row. This is done for boundary of whole matrix, then keep \\n\\t// repeating above for inner boundaries of matrix.\\n\\tint n = M.size();\\n\\t// p: padding, r: row, c: column\\n\\t// Try to visualise below with a testcase to better understand the algo\\n\\tfor (int p = 0, r = p; r < n - p - 1; r++, p++)\\n\\t\\tfor (int c = p; c < n - p - 1; c++) {\\n\\t\\t\\tswap(M[r][c], M[c][n - 1 - r]);\\n\\t\\t\\tswap(M[r][c], M[n - 1 - r][n - 1 - c]);\\n\\t\\t\\tswap(M[r][c], M[n - 1 - c][r]);\\n\\t\\t}\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1332466,
                "title": "15-lines-written-explaination",
                "content": "The idea behind this relies on some math but I\\'ll try my best with an ELI5 answer. \\n\\n**TLDR: Solve this by row reversing then transposing the matrix or transpose the matrix then reverse the columns**\\n\\nWhen you perform a 90 degree rotation the \"diagonal\" swaps directions.\\n\\n```\\n[(X), 2, 3]          [7, 4, (X)]\\n[4, (X), 6]    =>    [8, (X), 2]     90 degree rotation\\n[7, 8, (X)]          [(X), 6, 3]\\n```\\nSo to swap the diagonal you must either reverse by row or by column. If you imagine the matrix as a physical paper, swapping the row or column would be like flipping the paper over. So the diagonal is now swapped but the paper is now flipped on its back. So to flip the paper back to the proper face, you must perform a transpose. \\n\\nTo over simplify why you must transpose is because in 2D, a matrix transpose is like a form of geometric translation which is what a rotation is; however, a transpose is not enough to rotate a matrix as the values do not map to the correct positions. Reversing the row or column simply \"corrects\" the rotation. \\n\\n```\\n[(X), 2, 3]          [7, 8, (X)]\\n[4, (X), 6]    =>    [4, (X), 6]     Reverse the rows to swap \"diagonal\" direction\\n[7, 8, (X)]          [(X), 2, 3]\\n```\\n\\n```\\n[(X), 8, 9]          [7, 4, 1]\\n[4, (X), 6]    =>    [8, 5, 2]     Transposing along the diagonal will complete the rotation (assuming you row reversed first)\\n[1, 2, (X)]          [9, 6, 3]\\n```\\n\\nFinally, you must know that: **MATRIX MULTIPLICATION IS NOT COMMUTATIVE!**\\nOrder matters meaning,\\n```\\n(row reverse) x (transpose) =/= (transpose) x (row reverse) \\n\\nBut FYI, these two operations are the same\\n(row reverse) x (transpose) == (transpose) x (column reverse)\\n```\\nSo you can solve this by first reversing rows then transposing or transposing then reverse columns. You can choose however you like.\\n```\\nvar rotate = function(matrix) {\\n    let length = matrix.length\\n    \\n    matrix.reverse()\\n    \\n\\t// transpose\\n    for (let i = 0; i < length; i++) {\\n        for (let j = 0; j < i; j++) {\\n            let temp = matrix[i][j]\\n            matrix[i][j] = matrix[j][i]\\n            matrix[j][i] = temp\\n        }\\n    }\\n    \\n    return matrix\\n};\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\n[(X), 2, 3]          [7, 4, (X)]\\n[4, (X), 6]    =>    [8, (X), 2]     90 degree rotation\\n[7, 8, (X)]          [(X), 6, 3]\\n```\n```\\n[(X), 2, 3]          [7, 8, (X)]\\n[4, (X), 6]    =>    [4, (X), 6]     Reverse the rows to swap \"diagonal\" direction\\n[7, 8, (X)]          [(X), 2, 3]\\n```\n```\\n[(X), 8, 9]          [7, 4, 1]\\n[4, (X), 6]    =>    [8, 5, 2]     Transposing along the diagonal will complete the rotation (assuming you row reversed first)\\n[1, 2, (X)]          [9, 6, 3]\\n```\n```\\n(row reverse) x (transpose) =/= (transpose) x (row reverse) \\n\\nBut FYI, these two operations are the same\\n(row reverse) x (transpose) == (transpose) x (column reverse)\\n```\n```\\nvar rotate = function(matrix) {\\n    let length = matrix.length\\n    \\n    matrix.reverse()\\n    \\n\\t// transpose\\n    for (let i = 0; i < length; i++) {\\n        for (let j = 0; j < i; j++) {\\n            let temp = matrix[i][j]\\n            matrix[i][j] = matrix[j][i]\\n            matrix[j][i] = temp\\n        }\\n    }\\n    \\n    return matrix\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1093828,
                "title": "python-3-recursive-peel-off-the-layers-explained-with-graph",
                "content": "Each recursive call just peels off one matrix layer, and the next call explores the \\'inner\\' matrix layer. For example, visually the matrix looks like the below picture. We work on one layer at a time.\\n\\nIn each recursive all, we refer to the way from the LeetCode approach 1 (Rotate Groups of Four Cells): https://leetcode.com/problems/rotate-image/solution/. And we just need to iterate from the first element through to the second last elment in the first row.\\n\\n\\n![image](https://assets.leetcode.com/users/images/a78a7f44-35f0-47ab-9b29-f4011a11e0f5_1614901732.2911437.png)\\n\\n\\n~~~\\nclass Solution:\\n    def rotate(self, matrix: List[List[int]]) -> None:\\n        \"\"\"\\n        Do not return anything, modify matrix in-place instead.\\n        \"\"\"\\n        def helper(top_left, bottom_right):\\n            if bottom_right <= top_left:\\n                return\\n            for i in range(top_left, bottom_right):\\n                tmp = matrix[top_left][i]\\n                matrix[top_left][i] = matrix[n-i][top_left]\\n                matrix[n-i][top_left] = matrix[n-top_left][n-i]\\n                matrix[n-top_left][n-i] = matrix[n-(n-i)][n-top_left]\\n                matrix[n-(n-i)][n-top_left] = tmp\\n            helper(top_left+1, bottom_right-1)\\n        \\n        n = len(matrix)-1\\n        helper(0, n)\\n~~~\\n\\n#Runtime: 32 ms, faster than 85.71% of Python3 online submissions for Rotate Image.\\n#Memory Usage: 14.1 MB, less than 96.08% of Python3 online submissions for Rotate Image.\\n\\n",
                "solutionTags": [
                    "Python",
                    "Python3",
                    "Graph",
                    "Recursion"
                ],
                "code": "Each recursive call just peels off one matrix layer, and the next call explores the \\'inner\\' matrix layer. For example, visually the matrix looks like the below picture. We work on one layer at a time.\\n\\nIn each recursive all, we refer to the way from the LeetCode approach 1 (Rotate Groups of Four Cells): https://leetcode.com/problems/rotate-image/solution/. And we just need to iterate from the first element through to the second last elment in the first row.\\n\\n\\n![image](https://assets.leetcode.com/users/images/a78a7f44-35f0-47ab-9b29-f4011a11e0f5_1614901732.2911437.png)\\n\\n\\n~~~\\nclass Solution:\\n    def rotate(self, matrix: List[List[int]]) -> None:\\n        \"\"\"\\n        Do not return anything, modify matrix in-place instead.\\n        \"\"\"\\n        def helper(top_left, bottom_right):\\n            if bottom_right <= top_left:\\n                return\\n            for i in range(top_left, bottom_right):\\n                tmp = matrix[top_left][i]\\n                matrix[top_left][i] = matrix[n-i][top_left]\\n                matrix[n-i][top_left] = matrix[n-top_left][n-i]\\n                matrix[n-top_left][n-i] = matrix[n-(n-i)][n-top_left]\\n                matrix[n-(n-i)][n-top_left] = tmp\\n            helper(top_left+1, bottom_right-1)\\n        \\n        n = len(matrix)-1\\n        helper(0, n)\\n~~~\\n\\n#Runtime: 32 ms, faster than 85.71% of Python3 online submissions for Rotate Image.\\n#Memory Usage: 14.1 MB, less than 96.08% of Python3 online submissions for Rotate Image.\\n\\n",
                "codeTag": "Java"
            },
            {
                "id": 904069,
                "title": "simple-c-solution-video-explanation",
                "content": "https://www.youtube.com/watch?v=Pvhjc9bo5s0\\n```\\nclass Solution {\\npublic:\\n    void rotate(vector<vector<int>>& matrix) {\\n        int n=matrix.size();\\n        for(int i=0;i<n;i++){\\n            for(int j=0;j<i;j++){\\n                swap(matrix[i][j],matrix[j][i]);\\n            }\\n        }\\n        //reversal of all rows\\n        for(int i=0;i<n;i++){\\n            for(int j=0;j<n/2;j++){\\n                swap(matrix[i][j],matrix[i][n-1-j]);\\n            }\\n        }\\n    }\\n};\\n```\\nmore videos - https://www.youtube.com/channel/UCUbuXuBGfWonCur5MBAsTdA",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    void rotate(vector<vector<int>>& matrix) {\\n        int n=matrix.size();\\n        for(int i=0;i<n;i++){\\n            for(int j=0;j<i;j++){\\n                swap(matrix[i][j],matrix[j][i]);\\n            }\\n        }\\n        //reversal of all rows\\n        for(int i=0;i<n;i++){\\n            for(int j=0;j<n/2;j++){\\n                swap(matrix[i][j],matrix[i][n-1-j]);\\n            }\\n        }\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 752218,
                "title": "swift-homemade-sweet-sour-solution-100",
                "content": "**Time: O(n), Space: O(1)**\\n```\\nfunc rotate(_ matrix: inout [[Int]]) {\\n\\t// Step 1: Flip vertically\\n\\tmatrix.reverse()\\n\\n\\t// Step 2: Flip diagonally\\n\\tfor i in 0..<matrix.count {\\n\\t\\tfor j in 0..<i {\\n\\t\\t\\tlet temp = matrix[i][j]\\n\\t\\t\\tmatrix[i][j] = matrix[j][i]\\n\\t\\t\\tmatrix[j][i] = temp\\n\\t\\t}\\n\\t}\\n}\\n```",
                "solutionTags": [
                    "Swift"
                ],
                "code": "```\\nfunc rotate(_ matrix: inout [[Int]]) {\\n\\t// Step 1: Flip vertically\\n\\tmatrix.reverse()\\n\\n\\t// Step 2: Flip diagonally\\n\\tfor i in 0..<matrix.count {\\n\\t\\tfor j in 0..<i {\\n\\t\\t\\tlet temp = matrix[i][j]\\n\\t\\t\\tmatrix[i][j] = matrix[j][i]\\n\\t\\t\\tmatrix[j][i] = temp\\n\\t\\t}\\n\\t}\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3678211,
                "title": "easy-cpp-solution-with-crystal-clear-step-wise-explanation-using-handmade-images-with-hint",
                "content": "# Hint 1- You can use transpose of a matrix.\\n# Intuition\\nThe first thought was to make a new 2D vector, but it was mentioned in question to make the changes in the given matrix.\\n\\n# Hint 2- You can use reverse of a matrix by row wise.\\n# Approach\\nApproach is in 2 steps-\\n- First to transpose the matrix.\\n- Second to reverse the matrix row-wise.\\n- boom you got the desired output.\\n![photo6104660841891739043.jpg](https://assets.leetcode.com/users/images/3af79aaf-5de1-4bc5-84a9-d2e1c951171c_1687631454.8280246.jpeg)\\n\\n# Complexity\\n- Time complexity:\\nO(n^2)\\n\\n- Space complexity:\\nO(1)\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    void rotate(vector<vector<int>>& matrix) {\\n        // transpose\\n        for(int i=0;i<matrix.size();i++)\\n        {\\n            for(int j=i+1;j<matrix[0].size();j++)\\n            {\\n                swap(matrix[i][j],matrix[j][i]);\\n            }\\n        }\\n        // now reverse the matrix\\n        for(int i=0;i<matrix.size();i++)\\n        {\\n            int k=0;\\n            int j=matrix.size()-1;\\n            while(k<j)\\n            {\\n                swap(matrix[i][k],matrix[i][j]);\\n                k++;\\n                j--;\\n            }\\n        }\\n        return;\\n    }\\n};\\n```\\n# Please show support by upvoting!!",
                "solutionTags": [
                    "C++",
                    "Math",
                    "Matrix"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    void rotate(vector<vector<int>>& matrix) {\\n        // transpose\\n        for(int i=0;i<matrix.size();i++)\\n        {\\n            for(int j=i+1;j<matrix[0].size();j++)\\n            {\\n                swap(matrix[i][j],matrix[j][i]);\\n            }\\n        }\\n        // now reverse the matrix\\n        for(int i=0;i<matrix.size();i++)\\n        {\\n            int k=0;\\n            int j=matrix.size()-1;\\n            while(k<j)\\n            {\\n                swap(matrix[i][k],matrix[i][j]);\\n                k++;\\n                j--;\\n            }\\n        }\\n        return;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3094147,
                "title": "best-o-n-2-solution",
                "content": "\\n# Approach\\nStep1 :- Transpose of the matrix.\\nStep2 :- Reverse each row of the matrix.\\n\\n# Complexity\\n- Time complexity:\\n$$O(n^2)$$ \\n\\n- Space complexity:\\n$$O(1)$$ \\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    void rotate(vector<vector<int>>& matrix) {\\n        int n = matrix.size();\\n\\n        // Transposing the matrix\\n        for (int i = 0; i < n; i++) \\n            for (int j = i + 1; j < n; j++) \\n                swap(matrix[i][j], matrix[j][i]);\\n\\n        // Reversing each row of the matrix\\n        for (int k = 0; k < n; k++) \\n            reverse(matrix[k].begin(), matrix[k].end());\\n    }\\n};  \\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    void rotate(vector<vector<int>>& matrix) {\\n        int n = matrix.size();\\n\\n        // Transposing the matrix\\n        for (int i = 0; i < n; i++) \\n            for (int j = i + 1; j < n; j++) \\n                swap(matrix[i][j], matrix[j][i]);\\n\\n        // Reversing each row of the matrix\\n        for (int k = 0; k < n; k++) \\n            reverse(matrix[k].begin(), matrix[k].end());\\n    }\\n};  \\n```",
                "codeTag": "Java"
            },
            {
                "id": 2802641,
                "title": "100-faster-than-others-upvote-if-you-like",
                "content": "# Intuition\\nfirst find transpose then reverse each row \\n\\n>\\n\\n# Complexity\\n- Time complexity:\\nO(m*n)\\n\\n- Space complexity:\\nO(1)\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    void rotate(vector<vector<int>>& m) {\\n        int n=m.size();\\n        for(int i=0;i<n;i++)\\n        {\\n            for(int j=0;j<i;j++)\\n            {\\n                swap(m[i][j],m[j][i]);\\n            }\\n        }\\n        for(int i=0;i<n;i++)\\n        {\\n            reverse(m[i].begin(),m[i].end());\\n        }\\n        \\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    void rotate(vector<vector<int>>& m) {\\n        int n=m.size();\\n        for(int i=0;i<n;i++)\\n        {\\n            for(int j=0;j<i;j++)\\n            {\\n                swap(m[i][j],m[j][i]);\\n            }\\n        }\\n        for(int i=0;i<n;i++)\\n        {\\n            reverse(m[i].begin(),m[i].end());\\n        }\\n        \\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2330930,
                "title": "easy-0-ms-100-fully-explained-java-c-js-c-4-different-approaches",
                "content": "# **JAVA SOLUTION (1st Approach) :**\\n```\\nclass Solution {\\n    public void rotate(int[][] matrix) {\\n        // Reverse each row in a for-loop...\\n        for (int row = 0; row < matrix.length/2; row++) {\\n            int[] rotate = matrix[row];\\n            matrix[row] = matrix[matrix.length - row - 1];\\n            matrix[matrix.length - row - 1] = rotate;\\n        }\\n        // Visit each row...\\n        for (int row = 0; row < matrix.length - 1; row++) {\\n            for (int col = row+1; col < matrix.length; col++) {     //Initialize col as row + 1.\\n                // Swap each pair of symmetric elements...\\n                int rotate = matrix[row][col];\\n                matrix[row][col] = matrix[col][row];\\n                matrix[col][row] = rotate;\\n            }\\n        }\\n    }\\n}\\n```\\n\\n# **C++ SOLUTION (2nd Approach) :**\\n```\\nclass Solution {\\npublic:\\n    void rotate(vector<vector<int>>& matrix) {\\n        \\n        // Visit each row...\\n       for(int row = 0; row < matrix.size(); row++)\\n           //Initialize col as row + 1.\\n           for(int col = row +1; col < matrix.size(); col++)\\n               // Swap each pair of symmetric elements...\\n               swap(matrix[row][col], matrix[col][row]);\\n        \\n        // Reverse each row in a for-loop...\\n        for(int row = 0; row < matrix.size(); row++)\\n            reverse(matrix[row].begin(),matrix[row].end());\\n    }\\n};\\n```\\n\\n# **JAVASCRIPT SOLUTION (3rd Approach) :**\\n```\\nvar rotate = function(matrix) {\\n    let rotate = 0;\\n    for(row = 0; row < matrix.length/2; row++){\\n        for(col = row; col < matrix.length - 1 - row; col++){\\n            rotate = matrix[row][col];\\n            matrix[row][col] = matrix[matrix.length - 1 - col][row];\\n            matrix[matrix.length-1-col][row] = matrix[matrix.length-1-row][matrix.length-1-col];\\n            matrix[matrix.length-1-row][matrix.length-1-col] = matrix[col][matrix.length-1-row];\\n            matrix[col][matrix.length-1-row] = rotate;\\n        }\\n    }\\n};\\n```\\n\\n# **C LANGUAGE (4th Approach) :**\\n```\\nvoid rotate(int** matrix, int matrixSize, int* matrixColSize){\\n    // Swap process..\\n    for(int row = 0; row < matrixSize; row++) {\\n        for(int col = row; col < matrixSize; col++) {\\n            int tmp = matrix[row][col];\\n            matrix[row][col] = matrix[col][row];\\n            matrix[col][row] = tmp;\\n        }\\n    }\\n    // Reverse process..\\n    for(int row = 0; row < matrixSize; row++) {\\n        int beg = 0;\\n        int end = matrixSize - 1;\\n        while(beg < end) {\\n            int tmp = matrix[row][beg];\\n            matrix[row][beg] = matrix[row][end];\\n            matrix[row][end] = tmp;\\n            beg++;\\n            end--;\\n        }\\n    }\\n}\\n```\\n**4 different approaches are here and the solutions are 0 ms 100% faster...\\nPlease upvote if you find any help with this code...\\nI am working hard for you guys...**",
                "solutionTags": [
                    "Java",
                    "C",
                    "JavaScript"
                ],
                "code": "```\\nclass Solution {\\n    public void rotate(int[][] matrix) {\\n        // Reverse each row in a for-loop...\\n        for (int row = 0; row < matrix.length/2; row++) {\\n            int[] rotate = matrix[row];\\n            matrix[row] = matrix[matrix.length - row - 1];\\n            matrix[matrix.length - row - 1] = rotate;\\n        }\\n        // Visit each row...\\n        for (int row = 0; row < matrix.length - 1; row++) {\\n            for (int col = row+1; col < matrix.length; col++) {     //Initialize col as row + 1.\\n                // Swap each pair of symmetric elements...\\n                int rotate = matrix[row][col];\\n                matrix[row][col] = matrix[col][row];\\n                matrix[col][row] = rotate;\\n            }\\n        }\\n    }\\n}\\n```\n```\\nclass Solution {\\npublic:\\n    void rotate(vector<vector<int>>& matrix) {\\n        \\n        // Visit each row...\\n       for(int row = 0; row < matrix.size(); row++)\\n           //Initialize col as row + 1.\\n           for(int col = row +1; col < matrix.size(); col++)\\n               // Swap each pair of symmetric elements...\\n               swap(matrix[row][col], matrix[col][row]);\\n        \\n        // Reverse each row in a for-loop...\\n        for(int row = 0; row < matrix.size(); row++)\\n            reverse(matrix[row].begin(),matrix[row].end());\\n    }\\n};\\n```\n```\\nvar rotate = function(matrix) {\\n    let rotate = 0;\\n    for(row = 0; row < matrix.length/2; row++){\\n        for(col = row; col < matrix.length - 1 - row; col++){\\n            rotate = matrix[row][col];\\n            matrix[row][col] = matrix[matrix.length - 1 - col][row];\\n            matrix[matrix.length-1-col][row] = matrix[matrix.length-1-row][matrix.length-1-col];\\n            matrix[matrix.length-1-row][matrix.length-1-col] = matrix[col][matrix.length-1-row];\\n            matrix[col][matrix.length-1-row] = rotate;\\n        }\\n    }\\n};\\n```\n```\\nvoid rotate(int** matrix, int matrixSize, int* matrixColSize){\\n    // Swap process..\\n    for(int row = 0; row < matrixSize; row++) {\\n        for(int col = row; col < matrixSize; col++) {\\n            int tmp = matrix[row][col];\\n            matrix[row][col] = matrix[col][row];\\n            matrix[col][row] = tmp;\\n        }\\n    }\\n    // Reverse process..\\n    for(int row = 0; row < matrixSize; row++) {\\n        int beg = 0;\\n        int end = matrixSize - 1;\\n        while(beg < end) {\\n            int tmp = matrix[row][beg];\\n            matrix[row][beg] = matrix[row][end];\\n            matrix[row][end] = tmp;\\n            beg++;\\n            end--;\\n        }\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1600966,
                "title": "all-matrix-rotations-90-180-270-for-both-square-and-rectangular-matrix",
                "content": "```\\n/*\\nVariant I - Rotate Square matrix by 90 deg clockwise\\n\\n1,2,3           7,4,1\\n4,5,6   =====>  8,5,2\\n7,8,9           9,6,3\\n*/\\n\\nfunction rotateSqMatrixClockWise(matrix) {\\n    // Transpose the matrix\\n    transposeMatrix(matrix);\\n    // reverse matrix columns\\n    reverseMatrixCols(matrix);\\n};\\n\\n/*\\nVariant II - Rotate Square matrix by 90 deg anti-clockwise // 270deg clockwise\\n\\n1,2,3           3,6,9\\n4,5,6   =====>  2,5,8\\n7,8,9           1,4,7\\n*/\\nfunction rotateSqMatrixAntiClockWise(matrix) {\\n    // Transpose the matrix\\n    transposeMatrix(matrix);\\n    // reverse matrix rows\\n    reverseMatrixRows(matrix);\\n};\\n\\n/*\\n\\nVariant III - Rotate Square matrix by 180 deg\\n\\n1,2,3           9,8,7\\n4,5,6   =====>  6,5,4\\n7,8,9           3,2,1\\n\\n*/\\n\\nfunction rotateSqMatrixby180Deg(matrix){\\n    // reverse matrix columns\\n    reverseMatrixCols(matrix);\\n    // reverse matrix rows\\n    reverseMatrixRows(matrix);\\n}\\n\\n/*\\n\\nVariant IV - Rotate Rectangular matrix by by 90 deg clockwise (can\\'t be done in place)\\n\\n 1, 2, 3, 4            9, 5, 1\\n 5, 6, 7, 8   =====>  10, 6, 2\\n 9,10,11,12           11, 7, 3\\n                      12, 8, 4\\n*/\\n\\nfunction roateMatrixClockWise(matrix){\\n    let m = matrix.length, n = matrix[0].length;\\n    // Creating a N X M matrix and initiating each cell to 0.\\n    let rotatedMatrix = new Array(n).fill(0).map(_ => new Array(m).fill(0));\\n\\n    for(let i=0; i < m; i++){\\n        for(let j=0; j < n; j++){\\n            rotatedMatrix[j][m-i-1] = matrix[i][j];\\n        }\\n    }\\n    \\n    return rotatedMatrix;\\n}\\n\\n/*\\n\\nVariant V - Rotate Rectangular matrix by by 90 deg anti-clockwise / 270 deg clockwise (can\\'t be done in place)\\n\\n 1, 2, 3, 4            4, 8,12\\n 5, 6, 7, 8   =====>   3, 7,11\\n 9,10,11,12            2, 6,10\\n                       1, 5, 9\\n*/\\nfunction roateMatrixAntiClockWise(matrix){\\n    let m = matrix.length, n = matrix[0].length;\\n    // Creating a N X M matrix and initiating each cell to 0.\\n    let rotatedMatrix = new Array(n).fill(0).map(_ => new Array(m).fill(0));\\n\\n    for(let i=0; i < m; i++){\\n        for(let j=0; j < n; j++){\\n            rotatedMatrix[n-j-1][i] = matrix[i][j];\\n        }\\n    }\\n    \\n    return rotatedMatrix;\\n}\\n\\n/*\\n\\nVariant VI - Rotate Rectangular matrix by by 180 deg / 270 deg clockwise (can be done in place)\\n\\n 1, 2, 3, 4            12,11,10, 9\\n 5, 6, 7, 8   =====>    8, 7, 6, 5\\n 9,10,11,12             4, 3, 2, 1\\n\\n*/\\nfunction rotateMatrixby180Deg(matrix){\\n    // reverse matrix columns\\n    reverseMatrixCols(matrix);\\n    // reverse matrix rows\\n    reverseMatrixRows(matrix);\\n}\\n\\nfunction transposeMatrix(matrix){\\n    for(let i=0; i < matrix.length; i++){\\n        for(let j=i; j < matrix[0].length; j++){\\n            [matrix[i][j],matrix[j][i]] = [matrix[j][i],matrix[i][j]];\\n        }\\n    }\\n}\\n\\nfunction reverseMatrixCols(matrix){\\n    // reverse matrix columns\\n    let n = matrix[0].length;\\n    for(let i=0; i < matrix.length; i++){\\n        let left = 0, right = n-1;\\n        while(left < right){\\n            [matrix[i][left],matrix[i][right]] = [matrix[i][right],matrix[i][left]];\\n            left++;\\n            right--;\\n        }\\n    }\\n}\\n\\nfunction reverseMatrixRows(matrix){\\n    let top = 0, down = matrix.length-1;\\n    while(top < down){\\n        [matrix[top],matrix[down]] = [matrix[down],matrix[top]];\\n        top++;\\n        down--;\\n    }\\n}\\n```",
                "solutionTags": [
                    "JavaScript",
                    "Matrix"
                ],
                "code": "```\\n/*\\nVariant I - Rotate Square matrix by 90 deg clockwise\\n\\n1,2,3           7,4,1\\n4,5,6   =====>  8,5,2\\n7,8,9           9,6,3\\n*/\\n\\nfunction rotateSqMatrixClockWise(matrix) {\\n    // Transpose the matrix\\n    transposeMatrix(matrix);\\n    // reverse matrix columns\\n    reverseMatrixCols(matrix);\\n};\\n\\n/*\\nVariant II - Rotate Square matrix by 90 deg anti-clockwise // 270deg clockwise\\n\\n1,2,3           3,6,9\\n4,5,6   =====>  2,5,8\\n7,8,9           1,4,7\\n*/\\nfunction rotateSqMatrixAntiClockWise(matrix) {\\n    // Transpose the matrix\\n    transposeMatrix(matrix);\\n    // reverse matrix rows\\n    reverseMatrixRows(matrix);\\n};\\n\\n/*\\n\\nVariant III - Rotate Square matrix by 180 deg\\n\\n1,2,3           9,8,7\\n4,5,6   =====>  6,5,4\\n7,8,9           3,2,1\\n\\n*/\\n\\nfunction rotateSqMatrixby180Deg(matrix){\\n    // reverse matrix columns\\n    reverseMatrixCols(matrix);\\n    // reverse matrix rows\\n    reverseMatrixRows(matrix);\\n}\\n\\n/*\\n\\nVariant IV - Rotate Rectangular matrix by by 90 deg clockwise (can\\'t be done in place)\\n\\n 1, 2, 3, 4            9, 5, 1\\n 5, 6, 7, 8   =====>  10, 6, 2\\n 9,10,11,12           11, 7, 3\\n                      12, 8, 4\\n*/\\n\\nfunction roateMatrixClockWise(matrix){\\n    let m = matrix.length, n = matrix[0].length;\\n    // Creating a N X M matrix and initiating each cell to 0.\\n    let rotatedMatrix = new Array(n).fill(0).map(_ => new Array(m).fill(0));\\n\\n    for(let i=0; i < m; i++){\\n        for(let j=0; j < n; j++){\\n            rotatedMatrix[j][m-i-1] = matrix[i][j];\\n        }\\n    }\\n    \\n    return rotatedMatrix;\\n}\\n\\n/*\\n\\nVariant V - Rotate Rectangular matrix by by 90 deg anti-clockwise / 270 deg clockwise (can\\'t be done in place)\\n\\n 1, 2, 3, 4            4, 8,12\\n 5, 6, 7, 8   =====>   3, 7,11\\n 9,10,11,12            2, 6,10\\n                       1, 5, 9\\n*/\\nfunction roateMatrixAntiClockWise(matrix){\\n    let m = matrix.length, n = matrix[0].length;\\n    // Creating a N X M matrix and initiating each cell to 0.\\n    let rotatedMatrix = new Array(n).fill(0).map(_ => new Array(m).fill(0));\\n\\n    for(let i=0; i < m; i++){\\n        for(let j=0; j < n; j++){\\n            rotatedMatrix[n-j-1][i] = matrix[i][j];\\n        }\\n    }\\n    \\n    return rotatedMatrix;\\n}\\n\\n/*\\n\\nVariant VI - Rotate Rectangular matrix by by 180 deg / 270 deg clockwise (can be done in place)\\n\\n 1, 2, 3, 4            12,11,10, 9\\n 5, 6, 7, 8   =====>    8, 7, 6, 5\\n 9,10,11,12             4, 3, 2, 1\\n\\n*/\\nfunction rotateMatrixby180Deg(matrix){\\n    // reverse matrix columns\\n    reverseMatrixCols(matrix);\\n    // reverse matrix rows\\n    reverseMatrixRows(matrix);\\n}\\n\\nfunction transposeMatrix(matrix){\\n    for(let i=0; i < matrix.length; i++){\\n        for(let j=i; j < matrix[0].length; j++){\\n            [matrix[i][j],matrix[j][i]] = [matrix[j][i],matrix[i][j]];\\n        }\\n    }\\n}\\n\\nfunction reverseMatrixCols(matrix){\\n    // reverse matrix columns\\n    let n = matrix[0].length;\\n    for(let i=0; i < matrix.length; i++){\\n        let left = 0, right = n-1;\\n        while(left < right){\\n            [matrix[i][left],matrix[i][right]] = [matrix[i][right],matrix[i][left]];\\n            left++;\\n            right--;\\n        }\\n    }\\n}\\n\\nfunction reverseMatrixRows(matrix){\\n    let top = 0, down = matrix.length-1;\\n    while(top < down){\\n        [matrix[top],matrix[down]] = [matrix[down],matrix[top]];\\n        top++;\\n        down--;\\n    }\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1399685,
                "title": "c-brute-force-optimal-solution-time-o-n-2-auxiliary-space-o-1",
                "content": "**Brute Force Solution**\\n\\n```\\nclass Solution {\\npublic:\\n    void rotate(vector<vector<int>>& matrix) {\\n\\t    // Brute Force Solution Time O(N^2) & Auxiliary Space O(N^2)\\n        int len=matrix.size();\\n        vector<vector<int>> B;\\n        B=matrix;\\n        for(int i=0;i<len;i++){\\n            for(int j=0;j<len;j++){\\n                B[j][len-i-1]=matrix[i][j];\\n            }\\n        }\\n        matrix=B;  \\n    }     \\n};\\n```\\n**Optimal Solution**\\n\\n```\\nclass Solution {\\npublic:\\n    void rotate(vector<vector<int>>& matrix) {\\n\\t\\t// Optimal Solution Time O(N^2) & Auxiliary Space O(1)\\n        int n=matrix.size();\\n        for(int i=0;i<n;i++){\\n            for(int j=i+1;j<n;j++){\\n                int temp=matrix[i][j];\\n                matrix[i][j]=matrix[j][i];\\n                matrix[j][i]=temp;\\n            }\\n        }\\n        for(int i=0;i<n;i++){\\n            reverse(matrix[i].begin(),matrix[i].end());\\n        }\\n    }\\n};\\n```\\n**All suggestions are welcome. Please upvote if you like it. Thank you for reading the post.**",
                "solutionTags": [
                    "C++",
                    "C",
                    "Matrix"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    void rotate(vector<vector<int>>& matrix) {\\n\\t    // Brute Force Solution Time O(N^2) & Auxiliary Space O(N^2)\\n        int len=matrix.size();\\n        vector<vector<int>> B;\\n        B=matrix;\\n        for(int i=0;i<len;i++){\\n            for(int j=0;j<len;j++){\\n                B[j][len-i-1]=matrix[i][j];\\n            }\\n        }\\n        matrix=B;  \\n    }     \\n};\\n```\n```\\nclass Solution {\\npublic:\\n    void rotate(vector<vector<int>>& matrix) {\\n\\t\\t// Optimal Solution Time O(N^2) & Auxiliary Space O(1)\\n        int n=matrix.size();\\n        for(int i=0;i<n;i++){\\n            for(int j=i+1;j<n;j++){\\n                int temp=matrix[i][j];\\n                matrix[i][j]=matrix[j][i];\\n                matrix[j][i]=temp;\\n            }\\n        }\\n        for(int i=0;i<n;i++){\\n            reverse(matrix[i].begin(),matrix[i].end());\\n        }\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 699959,
                "title": "easy-c-approach-beats-100-clear-explanation-for-each-line",
                "content": "My approach is to find the transpose of the given matrix and then reverse each individual vector with in 2d vector.\\nlet us take one example and be clear.\\nsuppose Given input matrix = \\n[\\n  [1,2,3],\\n  [4,5,6],\\n  [7,8,9]\\n]\\nstep 1: find the transpose of the matrix.\\n after tranposing it looks something like this.\\n [\\n [1,4,7],\\n [2,5,8],\\n [3,6,9]\\n ]\\n step 2: reverse individual vectors with in 2d vector.\\n [\\n [7,4,1],\\n [8,5,2],\\n [9,6,3]\\n ]\\n This is our required answer.. \\n My code is as follows\\n```\\nclass Solution {\\npublic:\\n    void rotate(vector<vector<int>>& matrix) {\\n        for(int i=0;i<matrix.size();i++) //finding the transpose of the matrix\\n        {\\n            for(int j=0;j<matrix[0].size();j++)\\n            {\\n                if(i<j)\\n                {\\n                    int temp=matrix[i][j];\\n                    matrix[i][j]=matrix[j][i];\\n                    matrix[j][i]=temp;\\n                }  \\n            }\\n        }\\n\\t\\t//done with transpose of the matrix\\n\\t\\t//now we need to reverse the individual vector\\n        for(int i=0;i<matrix.size();i++)\\n        {\\n            reverse(matrix[i].begin(),matrix[i].end()); //reverse individual vector using inbuilt reverse function\\n        }\\n    }\\n};```\\nsince it\\'s inplace no need to return array and also return type is void.\\nPlease upvote if you like my approach.\\nIf you have any doubts regarding this approach kindly mention in the comment section.",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    void rotate(vector<vector<int>>& matrix) {\\n        for(int i=0;i<matrix.size();i++) //finding the transpose of the matrix\\n        {\\n            for(int j=0;j<matrix[0].size();j++)\\n            {\\n                if(i<j)\\n                {\\n                    int temp=matrix[i][j];\\n                    matrix[i][j]=matrix[j][i];\\n                    matrix[j][i]=temp;\\n                }  \\n            }\\n        }\\n\\t\\t//done with transpose of the matrix\\n\\t\\t//now we need to reverse the individual vector\\n        for(int i=0;i<matrix.size();i++)\\n        {\\n            reverse(matrix[i].begin(),matrix[i].end()); //reverse individual vector using inbuilt reverse function\\n        }\\n    }\\n};```",
                "codeTag": "Java"
            },
            {
                "id": 3706134,
                "title": "java-striver-easy-understanding",
                "content": "##### 1. Brute Force\\n* **Time Complexity:** O(n^2), where n is the size of the matrix.\\n* **Space Complexity:** O(n^2)\\n\\n```\\nclass Solution {\\n    public void rotate(int[][] matrix) {\\n        int n = matrix.length;\\n        int rotated[][] = new int[n][n];\\n        for (int i = 0; i < n; i++) {\\n            for (int j = 0; j < n; j++) {\\n                rotated[j][n - 1 - i] = matrix[i][j];\\n            }\\n        }\\n        for (int i = 0; i < n; i++) {\\n            System.arraycopy(rotated[i], 0, matrix[i], 0, n);\\n        }\\n    }\\n}\\n```\\n\\n##### 1. Optimal Approach\\n* **Time Complexity:** O(n^2), where n is the size of the matrix.\\n* **Space Complexity:** O(1)\\n```\\nclass Solution {\\n    public void rotate(int[][] matrix) {\\n        int n = matrix.length;\\n        // transpose the matrix\\n        for (int i = 0; i < n; i++) {\\n            for (int j = 0; j < i; j++) {\\n                int temp = matrix[i][j];\\n                matrix[i][j] = matrix[j][i];\\n                matrix[j][i] = temp;\\n            }\\n        }\\n        // reverse each row of the matrix\\n        for (int i = 0; i < n; i++) {\\n            int left = 0;\\n            int right = n - 1;\\n            while (left < right) {\\n                int temp = matrix[i][left];\\n                matrix[i][left] = matrix[i][right];\\n                matrix[i][right] = temp;\\n                left++;\\n                right--;\\n            }\\n        }\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public void rotate(int[][] matrix) {\\n        int n = matrix.length;\\n        int rotated[][] = new int[n][n];\\n        for (int i = 0; i < n; i++) {\\n            for (int j = 0; j < n; j++) {\\n                rotated[j][n - 1 - i] = matrix[i][j];\\n            }\\n        }\\n        for (int i = 0; i < n; i++) {\\n            System.arraycopy(rotated[i], 0, matrix[i], 0, n);\\n        }\\n    }\\n}\\n```\n```\\nclass Solution {\\n    public void rotate(int[][] matrix) {\\n        int n = matrix.length;\\n        // transpose the matrix\\n        for (int i = 0; i < n; i++) {\\n            for (int j = 0; j < i; j++) {\\n                int temp = matrix[i][j];\\n                matrix[i][j] = matrix[j][i];\\n                matrix[j][i] = temp;\\n            }\\n        }\\n        // reverse each row of the matrix\\n        for (int i = 0; i < n; i++) {\\n            int left = 0;\\n            int right = n - 1;\\n            while (left < right) {\\n                int temp = matrix[i][left];\\n                matrix[i][left] = matrix[i][right];\\n                matrix[i][right] = temp;\\n                left++;\\n                right--;\\n            }\\n        }\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3161165,
                "title": "solution",
                "content": "```C++ []\\nclass Solution {\\npublic:\\n    void rotate(vector<vector<int>>& matrix) {\\n        int s = matrix[0].size();\\n        for(int i = 0; i < s; i++){\\n            for(int j = i; j < s-1-i && s-1-i > i; j++){\\n                swap(matrix[i][j],matrix[j][s-1-i]);\\n                swap(matrix[i][j],matrix[s-1-j][i]);\\n                swap(matrix[s-1-j][i],matrix[s-1-i][s-1-j]);\\n            }\\n        }\\n    }\\n};\\n```\\n\\n```Python3 []\\nclass Solution:\\n    def rotate(self, matrix: List[List[int]]) -> None:\\n        n = len(matrix)\\n        for i in range(n):\\n            for j in range(i):\\n                matrix[i][j], matrix[j][i] = matrix[j][i], matrix[i][j]\\n        for i in range(n):\\n            for j in range(n // 2):\\n                matrix[i][j], matrix[i][n - j - 1] = matrix[i][n - j - 1], matrix[i][j]\\n```\\n\\n```Java []\\nclass Solution {\\n    public void rotate(int[][] matrix) {\\n        int l = 0;\\n        int r = matrix.length - 1;\\n        \\n        while ( l < r )\\n        {\\n            for(int i = 0; i < r - l; i++)\\n            {\\n                int top = l;\\n                int bottom = r;\\n                int topLeft = matrix[top][l + i];\\n\\n                matrix[top][l + i] = matrix[bottom - i][l];\\n\\n                matrix[bottom - i][l] = matrix[bottom][r - i];\\n\\n                matrix[bottom][r - i] = matrix[top + i][r];\\n\\n                matrix[top + i][r] = topLeft;\\n                \\n            }\\n            \\n            r -= 1;\\n            l += 1;\\n        }\\n    }\\n}\\n```\\n",
                "solutionTags": [
                    "C++",
                    "Java",
                    "Python3"
                ],
                "code": "```C++ []\\nclass Solution {\\npublic:\\n    void rotate(vector<vector<int>>& matrix) {\\n        int s = matrix[0].size();\\n        for(int i = 0; i < s; i++){\\n            for(int j = i; j < s-1-i && s-1-i > i; j++){\\n                swap(matrix[i][j],matrix[j][s-1-i]);\\n                swap(matrix[i][j],matrix[s-1-j][i]);\\n                swap(matrix[s-1-j][i],matrix[s-1-i][s-1-j]);\\n            }\\n        }\\n    }\\n};\\n```\n```Python3 []\\nclass Solution:\\n    def rotate(self, matrix: List[List[int]]) -> None:\\n        n = len(matrix)\\n        for i in range(n):\\n            for j in range(i):\\n                matrix[i][j], matrix[j][i] = matrix[j][i], matrix[i][j]\\n        for i in range(n):\\n            for j in range(n // 2):\\n                matrix[i][j], matrix[i][n - j - 1] = matrix[i][n - j - 1], matrix[i][j]\\n```\n```Java []\\nclass Solution {\\n    public void rotate(int[][] matrix) {\\n        int l = 0;\\n        int r = matrix.length - 1;\\n        \\n        while ( l < r )\\n        {\\n            for(int i = 0; i < r - l; i++)\\n            {\\n                int top = l;\\n                int bottom = r;\\n                int topLeft = matrix[top][l + i];\\n\\n                matrix[top][l + i] = matrix[bottom - i][l];\\n\\n                matrix[bottom - i][l] = matrix[bottom][r - i];\\n\\n                matrix[bottom][r - i] = matrix[top + i][r];\\n\\n                matrix[top + i][r] = topLeft;\\n                \\n            }\\n            \\n            r -= 1;\\n            l += 1;\\n        }\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2661652,
                "title": "python-3-easy-fast-low-memory",
                "content": "Runtime:` 52 ms`, faster than `63.58%` of Python3 online submissions for Rotate Image.\\nMemory Usage: `13.8 MB`, less than `98.10%` of Python3 online submissions for Rotate Image.\\n```\\nclass Solution:\\n    def rotate(self, a):\\n        \"\"\"\\n        Needed:\\n        \\n        1 2 3\\n        4 5 6\\n        7 8 9\\n        ->\\n        7 4 1\\n        8 5 2\\n        9 6 3\\n\\n        \"\"\"\\n        a.reverse()\\n        for i in range(len(a)):\\n            for j in range(i):\\n                a[i][j], a[j][i] = a[j][i], a[i][j]",
                "solutionTags": [
                    "Python",
                    "Python3"
                ],
                "code": "Runtime:` 52 ms`, faster than `63.58%` of Python3 online submissions for Rotate Image.\\nMemory Usage: `13.8 MB`, less than `98.10%` of Python3 online submissions for Rotate Image.\\n```\\nclass Solution:\\n    def rotate(self, a):\\n        \"\"\"\\n        Needed:\\n        \\n        1 2 3\\n        4 5 6\\n        7 8 9\\n        ->\\n        7 4 1\\n        8 5 2\\n        9 6 3\\n\\n        \"\"\"\\n        a.reverse()\\n        for i in range(len(a)):\\n            for j in range(i):\\n                a[i][j], a[j][i] = a[j][i], a[i][j]",
                "codeTag": "Java"
            },
            {
                "id": 2505735,
                "title": "golang-one-line-swap-solution",
                "content": "The observation is that after a 90 degree rotation, the number from row `r` and column `c` will end up in row `c` and column `n-1-r`. Also rotating the matrix 4 times will result the number to end up in the original place, so the positions create cycles of size 4. Thus, if there is a cycle `a -> b -> c -> d -> a`, in Golang we can swap these values in one line like so `a, b, c, d = b, c, d, a`. \\n\\nAlso we need to make sure we rotate every cycle exactly once, so we need to start rotating the cycles from the upper left quarter of the matrix. If `n` is odd, we need to be careful to skip either middle column or middle row.\\n\\n```\\nfunc rotate(matrix [][]int)  {\\n    n := len(matrix)\\n    for r := 0; r < n/2; r++ {\\n        for c := 0; c < (n+1)/2; c++ {\\n            matrix[r][c], matrix[c][n-1-r], matrix[n-1-r][n-1-c], matrix[n-1-c][r] = \\n                matrix[n-1-c][r], matrix[r][c], matrix[c][n-1-r], matrix[n-1-r][n-1-c]\\n        }\\n    }\\n}\\n```",
                "solutionTags": [
                    "Go"
                ],
                "code": "```\\nfunc rotate(matrix [][]int)  {\\n    n := len(matrix)\\n    for r := 0; r < n/2; r++ {\\n        for c := 0; c < (n+1)/2; c++ {\\n            matrix[r][c], matrix[c][n-1-r], matrix[n-1-r][n-1-c], matrix[n-1-c][r] = \\n                matrix[n-1-c][r], matrix[r][c], matrix[c][n-1-r], matrix[n-1-r][n-1-c]\\n        }\\n    }\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2505342,
                "title": "super-simple-wicked-fast-100",
                "content": "**Logic?**\\n\\n*If we see carefully, we will find that the matrix rotated 90 degrees is equivalent to **transpose of matrix with each elements of the rows reversed.***\\n\\n*Here is a visual representation of the same:*\\n\\n![image](https://assets.leetcode.com/users/images/790783a0-3f56-4673-b2a9-345705a9a383_1661870004.0681448.jpeg)\\n\\n\\n\\n```\\nclass Solution {\\npublic:\\n    void rotate(vector<vector<int>>& matrix) {\\n       \\n        //For any matrix to be rotatable it must be a square matrix\\n        // i.e. no. of rows == no. of cols == size\\n        \\n        int size = matrix.size(); \\n        \\n        //Transposing the matrix\\n        for(int i = 0; i<size; i++){\\n            \\n            for(int j=i; j<size; j++){\\n                \\n                // Simple swapping algorithm\\n                \\n                int temp = matrix[i][j];\\n                \\n                matrix[i][j] = matrix[j][i];\\n                \\n                matrix[j][i] = temp;\\n            }\\n        }\\n        \\n        //Reversing the Matrix\\n        //You can simply use reverse(matrix[i].begin(), matrix[i].end()) inside for loop also\\n        for(int row = 0; row<size; row++){\\n            \\n            int left = 0, right = size-1;\\n            \\n            while(left<right){\\n                \\n                int temp = matrix[row][left];\\n                \\n                matrix[row][left] = matrix[row][right];\\n                \\n                matrix[row][right] = temp;\\n                \\n                left++;\\n                right--;\\n            }\\n        }\\n            \\n    }\\n        \\n};\\n```\\n\\n![image](https://assets.leetcode.com/users/images/684ec26b-4fee-45e0-a1d5-5d06a45aeb36_1661870059.9929965.jpeg)\\n",
                "solutionTags": [
                    "C"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    void rotate(vector<vector<int>>& matrix) {\\n       \\n        //For any matrix to be rotatable it must be a square matrix\\n        // i.e. no. of rows == no. of cols == size\\n        \\n        int size = matrix.size(); \\n        \\n        //Transposing the matrix\\n        for(int i = 0; i<size; i++){\\n            \\n            for(int j=i; j<size; j++){\\n                \\n                // Simple swapping algorithm\\n                \\n                int temp = matrix[i][j];\\n                \\n                matrix[i][j] = matrix[j][i];\\n                \\n                matrix[j][i] = temp;\\n            }\\n        }\\n        \\n        //Reversing the Matrix\\n        //You can simply use reverse(matrix[i].begin(), matrix[i].end()) inside for loop also\\n        for(int row = 0; row<size; row++){\\n            \\n            int left = 0, right = size-1;\\n            \\n            while(left<right){\\n                \\n                int temp = matrix[row][left];\\n                \\n                matrix[row][left] = matrix[row][right];\\n                \\n                matrix[row][right] = temp;\\n                \\n                left++;\\n                right--;\\n            }\\n        }\\n            \\n    }\\n        \\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2239285,
                "title": "100-percent-faster-solution-easiest-approach",
                "content": "![image](https://assets.leetcode.com/users/images/953acdf5-f890-4a19-8467-30f1911d44b6_1656994043.1496904.png)\\n```\\nvoid pop_front(std::vector<int> &v){ //pop function to delete first element in the vector\\n        if(v.size() > 0){\\n        v.erase(v.begin());\\n        }\\n    }\\n    void rotate(vector<vector<int>>& matrix) {\\n        vector<int> kow;\\n        int n = matrix.size();\\n        if(n == 1){\\n            return;\\n        }\\n        for(int i = 0; i < n; i++){\\n            for(int j = 0; j < n; j++){\\n                kow.push_back(matrix[i][j]); //storing all values in a vector\\n            }\\n        }\\n        for(int j = n - 1; j >= 0; j--){\\n            for(int i = 0; i < n; i++){\\n                matrix[i][j] = kow.front(); //start from last column top and go till bottom of last column and then continue this  same procedure of going from top to bottom from last but first column to zeroth column.\\n                pop_front(kow); //delete the first element after every insertion\\n            }\\n        }\\n    }\\n```\\n**Please upvote my Solution!!! Do let me know your doubts through comment section below, I will be happy to reply back!!!**",
                "solutionTags": [
                    "C",
                    "Matrix"
                ],
                "code": "```\\nvoid pop_front(std::vector<int> &v){ //pop function to delete first element in the vector\\n        if(v.size() > 0){\\n        v.erase(v.begin());\\n        }\\n    }\\n    void rotate(vector<vector<int>>& matrix) {\\n        vector<int> kow;\\n        int n = matrix.size();\\n        if(n == 1){\\n            return;\\n        }\\n        for(int i = 0; i < n; i++){\\n            for(int j = 0; j < n; j++){\\n                kow.push_back(matrix[i][j]); //storing all values in a vector\\n            }\\n        }\\n        for(int j = n - 1; j >= 0; j--){\\n            for(int i = 0; i < n; i++){\\n                matrix[i][j] = kow.front(); //start from last column top and go till bottom of last column and then continue this  same procedure of going from top to bottom from last but first column to zeroth column.\\n                pop_front(kow); //delete the first element after every insertion\\n            }\\n        }\\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1563254,
                "title": "python-numpy-one-line-solution",
                "content": "**Python :**\\n\\n```\\ndef rotate(self, matrix: List[List[int]]) -> None:\\n\\tmatrix[:] = np.rot90(matrix, axes=(1, 0))\\n```\\n\\n**Like it ? please upvote !**",
                "solutionTags": [
                    "Python",
                    "Python3"
                ],
                "code": "```\\ndef rotate(self, matrix: List[List[int]]) -> None:\\n\\tmatrix[:] = np.rot90(matrix, axes=(1, 0))\\n```",
                "codeTag": "Python3"
            },
            {
                "id": 1230540,
                "title": "transpose-then-reverse-easy",
                "content": "***Do upvote if you like the solution to keep me motivated*** \\uD83D\\uDE0A\\u270C\\n```\\nclass Solution {\\npublic:\\n    void rotate(vector<vector<int>>& matrix) {\\n        int n = matrix.size();\\n        for(int i = 0 ; i<n ; i++)\\n        {\\n            for(int j = i ; j<n ; j++)\\n            {\\n                swap(matrix[i][j] , matrix[j][i]); // Tanspose the matrix first\\n            }\\n        }\\n        for(int i=0 ; i<n ; i++)\\n        {\\n            reverse(matrix[i].begin() , matrix[i].end()); // Reverse each row now\\n        }\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    void rotate(vector<vector<int>>& matrix) {\\n        int n = matrix.size();\\n        for(int i = 0 ; i<n ; i++)\\n        {\\n            for(int j = i ; j<n ; j++)\\n            {\\n                swap(matrix[i][j] , matrix[j][i]); // Tanspose the matrix first\\n            }\\n        }\\n        for(int i=0 ; i<n ; i++)\\n        {\\n            reverse(matrix[i].begin() , matrix[i].end()); // Reverse each row now\\n        }\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1175497,
                "title": "rotate-image-easy-short-and-simple-explanation",
                "content": "Approach:-\\n![image](https://assets.leetcode.com/users/images/6a92ca14-9a43-4718-863f-dca4c0a6dc40_1619337250.152098.png)\\n\\n```\\nclass Solution {\\npublic:\\n    void rotate(vector<vector<int>>& ar) {\\n        int n=ar.size();\\n        reverse(ar.begin(),ar.end()); //Reversing the matrix from top to bottom\\n        for(int i=0;i<n;i++)\\n        {\\n            for(int j=i+1;j<n;j++) //!NOTE   j=i+1\\n                swap(ar[i][j],ar[j][i]); //Swapping the elements along the symmetry\\n        }\\n    }\\n};\\n```\\n\\n",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    void rotate(vector<vector<int>>& ar) {\\n        int n=ar.size();\\n        reverse(ar.begin(),ar.end()); //Reversing the matrix from top to bottom\\n        for(int i=0;i<n;i++)\\n        {\\n            for(int j=i+1;j<n;j++) //!NOTE   j=i+1\\n                swap(ar[i][j],ar[j][i]); //Swapping the elements along the symmetry\\n        }\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 749742,
                "title": "java-easy-understand-solution-beats-100",
                "content": "```\\nclass Solution {\\npublic void rotate(int[][] matrix) {\\n\\n\\t\\t// transpose the matrix\\n\\t\\tfor(int i=0;i<=matrix.length-1;i++){            \\n\\t\\t\\tfor(int j=i;j<matrix[0].length;j++){\\n\\t\\t\\t\\tint temp=matrix[i][j];\\n\\t\\t\\t\\tmatrix[i][j]=matrix[j][i];\\n\\t\\t\\t\\tmatrix[j][i]=temp;\\n\\t\\t\\t}         \\n\\t\\t}\\n\\n\\t\\t// reverse every row in the matrix \\n\\t\\tfor(int row=0;row<matrix.length;row++){\\n\\n\\t\\t\\tint i=0;\\n\\t\\t\\tint j=matrix[0].length-1;\\n\\n\\t\\t\\twhile(i<j){\\n\\t\\t\\t\\tint temp=matrix[row][i];\\n\\t\\t\\t\\tmatrix[row][i]=matrix[row][j];\\n\\t\\t\\t\\tmatrix[row][j]=temp;\\n\\t\\t\\t\\ti++;\\n\\t\\t\\t\\tj--;\\n\\t\\t\\t}\\n\\t\\t}\\n\\t}\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\npublic void rotate(int[][] matrix) {\\n\\n\\t\\t// transpose the matrix\\n\\t\\tfor(int i=0;i<=matrix.length-1;i++){            \\n\\t\\t\\tfor(int j=i;j<matrix[0].length;j++){\\n\\t\\t\\t\\tint temp=matrix[i][j];\\n\\t\\t\\t\\tmatrix[i][j]=matrix[j][i];\\n\\t\\t\\t\\tmatrix[j][i]=temp;\\n\\t\\t\\t}         \\n\\t\\t}\\n\\n\\t\\t// reverse every row in the matrix \\n\\t\\tfor(int row=0;row<matrix.length;row++){\\n\\n\\t\\t\\tint i=0;\\n\\t\\t\\tint j=matrix[0].length-1;\\n\\n\\t\\t\\twhile(i<j){\\n\\t\\t\\t\\tint temp=matrix[row][i];\\n\\t\\t\\t\\tmatrix[row][i]=matrix[row][j];\\n\\t\\t\\t\\tmatrix[row][j]=temp;\\n\\t\\t\\t\\ti++;\\n\\t\\t\\t\\tj--;\\n\\t\\t\\t}\\n\\t\\t}\\n\\t}\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 19058,
                "title": "an-clean-and-easy-java-code-with-1ms",
                "content": "    public void rotate(int[][] matrix) {\\n        if (matrix == null) {\\n\\t\\t\\treturn;\\n\\t\\t}\\n\\t\\t\\n\\t\\tint row = matrix.length;\\n\\t\\tint col = matrix.length;\\n        \\n\\t\\t//step 1:switch column\\n\\t    int low =0,high = col-1;\\n\\t    while(low < high){\\n\\t    \\tint[] temp = matrix[low];\\n\\t    \\tmatrix[low] = matrix[high];\\n\\t    \\tmatrix[high] = temp;\\n\\t    \\tlow++;\\n\\t    \\thigh--;\\n\\t    }\\n\\t    \\n\\t    //step 2:\\u5bf9\\u79f0\\u5143\\u7d20\\u4ea4\\u6362\\n\\t    for(int i=0; i<row; i++){\\n\\t    \\tfor(int j=0; j<i; j++){\\n\\t    \\t\\tint temp = matrix[i][j];\\n\\t    \\t\\tmatrix[i][j] = matrix[j][i];\\n\\t    \\t\\tmatrix[j][i] = temp;\\n\\t    \\t}\\n\\t    }\\n    }",
                "solutionTags": [],
                "code": "    public void rotate(int[][] matrix) {\\n        if (matrix == null) {\\n\\t\\t\\treturn;\\n\\t\\t}\\n\\t\\t\\n\\t\\tint row = matrix.length;\\n\\t\\tint col = matrix.length;\\n        \\n\\t\\t//step 1:switch column\\n\\t    int low =0,high = col-1;\\n\\t    while(low < high){\\n\\t    \\tint[] temp = matrix[low];\\n\\t    \\tmatrix[low] = matrix[high];\\n\\t    \\tmatrix[high] = temp;\\n\\t    \\tlow++;\\n\\t    \\thigh--;\\n\\t    }\\n\\t    \\n\\t    //step 2:\\u5bf9\\u79f0\\u5143\\u7d20\\u4ea4\\u6362\\n\\t    for(int i=0; i<row; i++){\\n\\t    \\tfor(int j=0; j<i; j++){\\n\\t    \\t\\tint temp = matrix[i][j];\\n\\t    \\t\\tmatrix[i][j] = matrix[j][i];\\n\\t    \\t\\tmatrix[j][i] = temp;\\n\\t    \\t}\\n\\t    }\\n    }",
                "codeTag": "Unknown"
            },
            {
                "id": 19131,
                "title": "short-python-in-place-solution-50ms",
                "content": "    class Solution:\\n        # @param matrix, a list of lists of integers\\n        # @return a list of lists of integers\\n        def rotate(self, matrix):\\n            matrix.reverse()\\n            for i in range(len(matrix)):\\n                for j in range(i):\\n                    matrix[i][j], matrix[j][i] = matrix[j][i], matrix[i][j]",
                "solutionTags": [
                    "Python"
                ],
                "code": "    class Solution:\\n        # @param matrix, a list of lists of integers\\n        # @return a list of lists of integers\\n        def rotate(self, matrix):\\n            matrix.reverse()\\n            for i in range(len(matrix)):\\n                for j in range(i):\\n                    matrix[i][j], matrix[j][i] = matrix[j][i], matrix[i][j]",
                "codeTag": "Java"
            },
            {
                "id": 18966,
                "title": "in-place-solution",
                "content": "The simple solution which requires additional space is :\\n\\n    class Solution {\\n    public:\\n        void rotate(vector<vector<int> > &matrix) {\\n            auto result = matrix;\\n        \\n            for (int i = 0; i < matrix.size(); i++) {\\n                for (int j = 0; j < matrix.size(); j++) {\\n                    result[j][matrix.size() - i - 1] = matrix[i][j];\\n                }\\n            }\\n            matrix = result;\\n        }\\n    };\\n\\nDoes anyone have an in-place solution?",
                "solutionTags": [],
                "code": "class Solution {\\n    public:\\n        void rotate(vector<vector<int> > &matrix) {\\n            auto result = matrix;\\n        \\n            for (int i = 0; i < matrix.size(); i++) {\\n                for (int j = 0; j < matrix.size(); j++) {\\n                    result[j][matrix.size() - i - 1] = matrix[i][j];\\n                }",
                "codeTag": "Java"
            },
            {
                "id": 3404972,
                "title": "rotate-image-c-solution-brute-optimal",
                "content": "\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\nBrute Force : -\\n\\nCreate an answer matrix. Take every element from the matrix and place it in correct position in the answer matrix. \\nConsider the 4*4 matrix filled with integers.\\n[0][0] -> [0][3]\\n[0][1] -> [1][3]\\n[0][2] -> [2][3]\\n[0][3] -> [3][3]\\n[1][0] -> [0][2]\\n[1][1] -> [1][2]\\n[1][2] -> [2][2]\\n[1][3] -> [3][2]\\nsimilary for other rows of the matrix.\\nThe formula that comes out to be is placing i  to n - i - 1\\nTime Complexity : O( n * n) \\nSpace Complexity : O(n * n)\\n\\nOptimized Approach :-\\nObserve Carefully, the first column of the matrix is actually the first row of the matrix but stored in the reverse order. Just transpose the matrix in order to get the desired matrix and then reverse it \\nElements of the diagonals stay as it is but the other element has to be placed\\n\\nTime complexity:- O(n * n)\\nSpace Complexity : O(1)\\n\\n# Code\\n```\\nBrute Force :- \\n\\nclass Solution {\\npublic:\\n    void rotate(vector<vector<int>>& matrix) {\\n        int n = matrix.size();\\n        int m = matrix[0].size();\\n        vector<vector<int>> temp(n, vector<int>(m, 0));\\n        for(int i = 0 ; i < n ; i++){\\n            for(int j = 0 ; j < n ; j++){\\n                temp[j][n - i - 1] = matrix[i][j];\\n            }\\n        }\\n        for(int i = 0 ; i < n ; i++){\\n            for(int j = 0 ; j < m ; j++){\\n                matrix[i][j] = temp[i][j];\\n            }\\n        }\\n    }\\n};\\n\\nOptimized approach :-\\nclass Solution {\\npublic:\\n    void rotate(vector<vector<int>>& matrix) {\\n        int n = matrix.size();\\n        for(int i = 0 ; i < n - 1 ; i++){\\n            for(int j = i + 1; j < n ; j++){\\n                swap(matrix[i][j] , matrix[j][i]);\\n            }\\n        }\\n        for(int i = 0 ; i < n ; i++){\\n            reverse(matrix[i].begin() , matrix[i].end());\\n        }\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nBrute Force :- \\n\\nclass Solution {\\npublic:\\n    void rotate(vector<vector<int>>& matrix) {\\n        int n = matrix.size();\\n        int m = matrix[0].size();\\n        vector<vector<int>> temp(n, vector<int>(m, 0));\\n        for(int i = 0 ; i < n ; i++){\\n            for(int j = 0 ; j < n ; j++){\\n                temp[j][n - i - 1] = matrix[i][j];\\n            }\\n        }\\n        for(int i = 0 ; i < n ; i++){\\n            for(int j = 0 ; j < m ; j++){\\n                matrix[i][j] = temp[i][j];\\n            }\\n        }\\n    }\\n};\\n\\nOptimized approach :-\\nclass Solution {\\npublic:\\n    void rotate(vector<vector<int>>& matrix) {\\n        int n = matrix.size();\\n        for(int i = 0 ; i < n - 1 ; i++){\\n            for(int j = i + 1; j < n ; j++){\\n                swap(matrix[i][j] , matrix[j][i]);\\n            }\\n        }\\n        for(int i = 0 ; i < n ; i++){\\n            reverse(matrix[i].begin() , matrix[i].end());\\n        }\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3400567,
                "title": "java-beats-100-0ms-runtime-o-1-space-easy-to-understand",
                "content": "# Complexity\\n- Time complexity: O(N)\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: O(1)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\n    public void rotate(int[][] matrix) {\\n        int columnLeft = 0;\\n        int columnRight = matrix.length - 1;\\n        int rowTop = 0;\\n        int rowBottom = matrix.length - 1;\\n\\n        while(columnLeft <= columnRight) {\\n            int p1 = columnLeft;\\n            int p2 = rowBottom;\\n            int p3 = columnRight;\\n            int p4 = rowTop;\\n\\n            for(int i = 1; i <= columnRight - columnLeft; i++) {\\n                int temp = matrix[rowTop][p1];\\n                matrix[rowTop][p1] = matrix[p2][columnLeft];\\n                matrix[p2][columnLeft] = temp;\\n\\n                int temp2 = matrix[p2][columnLeft];\\n                matrix[p2][columnLeft] = matrix[rowBottom][p3];\\n                matrix[rowBottom][p3] = temp2; \\n\\n                int temp3 = matrix[rowBottom][p3];\\n                matrix[rowBottom][p3] = matrix[p4][columnRight];\\n                matrix[p4][columnRight] = temp3;\\n\\n                p1++;\\n                p2--;\\n                p3--;\\n                p4++;\\n            }\\n            rowTop++;\\n            rowBottom--;\\n            columnLeft++;\\n            columnRight--;\\n        }\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public void rotate(int[][] matrix) {\\n        int columnLeft = 0;\\n        int columnRight = matrix.length - 1;\\n        int rowTop = 0;\\n        int rowBottom = matrix.length - 1;\\n\\n        while(columnLeft <= columnRight) {\\n            int p1 = columnLeft;\\n            int p2 = rowBottom;\\n            int p3 = columnRight;\\n            int p4 = rowTop;\\n\\n            for(int i = 1; i <= columnRight - columnLeft; i++) {\\n                int temp = matrix[rowTop][p1];\\n                matrix[rowTop][p1] = matrix[p2][columnLeft];\\n                matrix[p2][columnLeft] = temp;\\n\\n                int temp2 = matrix[p2][columnLeft];\\n                matrix[p2][columnLeft] = matrix[rowBottom][p3];\\n                matrix[rowBottom][p3] = temp2; \\n\\n                int temp3 = matrix[rowBottom][p3];\\n                matrix[rowBottom][p3] = matrix[p4][columnRight];\\n                matrix[p4][columnRight] = temp3;\\n\\n                p1++;\\n                p2--;\\n                p3--;\\n                p4++;\\n            }\\n            rowTop++;\\n            rowBottom--;\\n            columnLeft++;\\n            columnRight--;\\n        }\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3146840,
                "title": "easy-python3-solution-beats-94-run-time",
                "content": "# Code\\n```\\nclass Solution:\\n    def rotate(self, matrix: List[List[int]]) -> None:\\n        \"\"\"\\n        Do not return anything, modify matrix in-place instead.\\n        \"\"\"\\n        lst=[]\\n        for i in zip(*matrix):\\n            lst.append(i[::-1])\\n        matrix[:]=lst\\n```",
                "solutionTags": [
                    "Python",
                    "Python3",
                    "Matrix"
                ],
                "code": "```\\nclass Solution:\\n    def rotate(self, matrix: List[List[int]]) -> None:\\n        \"\"\"\\n        Do not return anything, modify matrix in-place instead.\\n        \"\"\"\\n        lst=[]\\n        for i in zip(*matrix):\\n            lst.append(i[::-1])\\n        matrix[:]=lst\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3129882,
                "title": "rotate-image-best-approach-an-interview-question-for-me",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nBefore Solution I would like to tell I got this question in one of my coding interview question\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\nJust transpose and observe the elements and swap the elements accordingly...\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\nO(N*2)\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\nO(1)\\n\\n# Code\\n```\\nclass Solution:\\n    def rotate(self, matrix: List[List[int]]) -> None:\\n        \"\"\"\\n        Do not return anything, modify matrix in-place instead.\\n        \"\"\"\\n        n=len(matrix)\\n        #Transposing the Matrix\\n        for i in range(0,n):\\n            for j in range(i,n):\\n                temp=matrix[i][j]\\n                matrix[i][j]=matrix[j][i]\\n                matrix[j][i]=temp\\n        #shifting the elements accodingly...\\n        for i in range(0,n):\\n            for j in range(0,n//2):\\n                temp=matrix[i][j]\\n                matrix[i][j]=matrix[i][n-1-j]\\n                matrix[i][n-j-1]=temp\\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def rotate(self, matrix: List[List[int]]) -> None:\\n        \"\"\"\\n        Do not return anything, modify matrix in-place instead.\\n        \"\"\"\\n        n=len(matrix)\\n        #Transposing the Matrix\\n        for i in range(0,n):\\n            for j in range(i,n):\\n                temp=matrix[i][j]\\n                matrix[i][j]=matrix[j][i]\\n                matrix[j][i]=temp\\n        #shifting the elements accodingly...\\n        for i in range(0,n):\\n            for j in range(0,n//2):\\n                temp=matrix[i][j]\\n                matrix[i][j]=matrix[i][n-1-j]\\n                matrix[i][n-j-1]=temp\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3117819,
                "title": "easily-understandable-solution-beats-99-30",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nhttps://takeuforward.org/data-structure/rotate-image-by-90-degree/\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    void rotate(vector<vector<int>>& matrix) {\\n        reverse(matrix.begin(), matrix.end());\\n        for(int i=0;i<matrix.size();i++){\\n            for(int j=i+1;j<matrix[0].size();j++){\\n            swap(matrix[i][j],matrix[j][i]);\\n        }\\n        }\\n    }\\n};\\n```\\nPlease upvote to motivate me to write more solutions\\n\\n",
                "solutionTags": [
                    "C++",
                    "Java"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    void rotate(vector<vector<int>>& matrix) {\\n        reverse(matrix.begin(), matrix.end());\\n        for(int i=0;i<matrix.size();i++){\\n            for(int j=i+1;j<matrix[0].size();j++){\\n            swap(matrix[i][j],matrix[j][i]);\\n        }\\n        }\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3107117,
                "title": "0ms-easy-sol-expl",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\nj**ust apply transpose of a matrix\\nthen it\\'s column\\'s element will become just oppostive of required/rotated matrix so..\\n**we just take mirror image of that matrix (ref of middle line)\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    void rotate(vector<vector<int>>& m) {\\n        int n  = m.size();\\n        for(int i = 0; i<n; i++){\\n            for(int j = i; j<n; j++){\\n                swap(m[i][j], m[j][i]);\\n            }\\n        }\\n        for(int i =0; i<n; i++){\\n            reverse(m[i].begin(), m[i].end());\\n        }\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    void rotate(vector<vector<int>>& m) {\\n        int n  = m.size();\\n        for(int i = 0; i<n; i++){\\n            for(int j = i; j<n; j++){\\n                swap(m[i][j], m[j][i]);\\n            }\\n        }\\n        for(int i =0; i<n; i++){\\n            reverse(m[i].begin(), m[i].end());\\n        }\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3056560,
                "title": "8-lines-java-solution-100-fast",
                "content": "\\n# Approach\\nHi guys!\\n\\nThe idea is to loop through the top-left quadrant of the matrix (including the middle column for odd N), and for each element make 4-element swap (rotation). Meaning that for example if we have 5x5 M, and the current element is M[1,2] then we memorize M[1,2] into tmp and make: M[1,2] = M[2,1]; M[2,1] = M[3,2]; M[3,2] = M[2,3]; M[2,3] = tmp.\\n\\nHere\\'s a pretty concise code below.\\n![image.png](https://assets.leetcode.com/users/images/0052bc79-2f43-40c0-b05b-75d86e73bea6_1673831118.5476995.png)\\n\\n# Code\\n```\\npublic class Solution {\\n    public void rotate(int[][] M) {\\n        for (int i = 0; i < (M.length+1)/2; i++) {\\n            for (int j = 0; j < M.length/2; j++) {\\n                int tmp = M[i][j];\\n                M[i][j] = M[M.length-j-1][i];\\n                M[M.length-j-1][i] = M[M.length-i-1][M.length-j-1];\\n                M[M.length-i-1][M.length-j-1] = M[j][M.length-i-1];\\n                M[j][M.length-i-1] = tmp;\\n            }\\n        }\\n    }\\n}\\n```\\nIf you really found my solution helpful please upvote it, as it motivates me to post such kind of codes.\\nLet me know in comment if i can do better.\\nLets connect on [Linkedin](https://www.linkedin.com/in/kailas-rathod/)",
                "solutionTags": [
                    "Java",
                    "Array",
                    "Math",
                    "Matrix"
                ],
                "code": "```\\npublic class Solution {\\n    public void rotate(int[][] M) {\\n        for (int i = 0; i < (M.length+1)/2; i++) {\\n            for (int j = 0; j < M.length/2; j++) {\\n                int tmp = M[i][j];\\n                M[i][j] = M[M.length-j-1][i];\\n                M[M.length-j-1][i] = M[M.length-i-1][M.length-j-1];\\n                M[M.length-i-1][M.length-j-1] = M[j][M.length-i-1];\\n                M[j][M.length-i-1] = tmp;\\n            }\\n        }\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2998901,
                "title": "super-easy-java-sol",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->O(n^2)\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->O(1)\\n\\n# Code\\n```\\nclass Solution {\\n    public void rotate(int[][] matrix) {\\n        for(int i=0;i<matrix.length;i++){\\n            for(int j=i;j<matrix[0].length;j++){\\n                int temp=0;\\n                temp = matrix[i][j];\\n                matrix[i][j] = matrix[j][i];\\n                matrix[j][i] = temp;\\n            }\\n        }\\n        for(int i=0;i<matrix.length;i++){\\n            for(int j=0;j<matrix.length/2;j++){\\n                int temp=0;\\n                temp = matrix[i][j];\\n                matrix[i][j] = matrix[i][matrix.length-1-j];\\n                matrix[i][matrix.length-1-j] = temp;\\n    }\\n}\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public void rotate(int[][] matrix) {\\n        for(int i=0;i<matrix.length;i++){\\n            for(int j=i;j<matrix[0].length;j++){\\n                int temp=0;\\n                temp = matrix[i][j];\\n                matrix[i][j] = matrix[j][i];\\n                matrix[j][i] = temp;\\n            }\\n        }\\n        for(int i=0;i<matrix.length;i++){\\n            for(int j=0;j<matrix.length/2;j++){\\n                int temp=0;\\n                temp = matrix[i][j];\\n                matrix[i][j] = matrix[i][matrix.length-1-j];\\n                matrix[i][matrix.length-1-j] = temp;\\n    }\\n}\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2928296,
                "title": "easy-to-understand-0ms-runtime-100-beat",
                "content": "# Intuition \\nUsing Concept of transpose.\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\nFirst swap across diagonal then swap vertical imaginary mid line\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:O(m*n)\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:O(1)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    void rotate(vector<vector<int>>& m) {\\n        int n=m.size();\\n        for(int i=0;i<m.size();i++){\\n            for(int j=0;j<i;j++){\\n                swap(m[i][j],m[j][i]);\\n            }\\n        }\\n        for(int i=0;i<m.size();i++){\\n            for(int j=0;j<m[0].size()/2;j++){\\n                swap(m[i][n-1-j],m[i][j]);\\n            }\\n        }\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Array",
                    "Math",
                    "Matrix"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    void rotate(vector<vector<int>>& m) {\\n        int n=m.size();\\n        for(int i=0;i<m.size();i++){\\n            for(int j=0;j<i;j++){\\n                swap(m[i][j],m[j][i]);\\n            }\\n        }\\n        for(int i=0;i<m.size();i++){\\n            for(int j=0;j<m[0].size()/2;j++){\\n                swap(m[i][n-1-j],m[i][j]);\\n            }\\n        }\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2617602,
                "title": "easy-to-understand-typescript-solution-with-explanation",
                "content": "Sometimes, the obvious and easy way comes up our mind maybe is not efficient enough for computer. But the most elegant and efficient way for computer is not straightforward and intuitive. Hence, think outside of box. \\n\\nFor computer, the hard part is to transfer row to column, or column to row. But transpose a matrix is fairly easy. Take this as the first step, and try to find the pattern of final result.\\n\\n1. transpose the matrix\\n2. reverse each role\\n3. here comes the result: rotate the image by\\xA090 ****degrees (clockwise)\\n\\n![image](https://assets.leetcode.com/users/images/82e6b6d4-c06f-419c-a434-a0818b11f836_1664014035.099017.png)\\n\\n```ts\\nfunction rotate(matrix: number[][]): void {\\n    for (let i = 0; i < matrix.length; i++) {\\n        for (let j = i; j < matrix.length; j++) {\\n\\t\\t\\t// Transpose\\n            [matrix[i][j], matrix[j][i]] = [matrix[j][i], matrix[i][j]];\\n        }\\n    }\\n    // Reverse\\n    matrix.forEach(arr => arr.reverse());\\n};\\n```\\nWhat if the question ask anticlockwise? Just transpose the matrix by another diagonal.\\n```ts\\nfunction rotate2(matrix: number[][]): void {\\n    for (let i = 0; i < matrix.length; i++) {\\n        for (let j = 0; j < matrix.length - 1; j++) {\\n            [matrix[i][j], matrix[n-j-1][n-i-1]] = [matrix[n-j-1][n-i-1], matrix[i][j]];\\n        }\\n    }\\n    \\n    matrix.forEach(arr => arr.reverse());\\n};\\n```",
                "solutionTags": [
                    "JavaScript",
                    "TypeScript",
                    "Matrix"
                ],
                "code": "```ts\\nfunction rotate(matrix: number[][]): void {\\n    for (let i = 0; i < matrix.length; i++) {\\n        for (let j = i; j < matrix.length; j++) {\\n\\t\\t\\t// Transpose\\n            [matrix[i][j], matrix[j][i]] = [matrix[j][i], matrix[i][j]];\\n        }\\n    }\\n    // Reverse\\n    matrix.forEach(arr => arr.reverse());\\n};\\n```\n```ts\\nfunction rotate2(matrix: number[][]): void {\\n    for (let i = 0; i < matrix.length; i++) {\\n        for (let j = 0; j < matrix.length - 1; j++) {\\n            [matrix[i][j], matrix[n-j-1][n-i-1]] = [matrix[n-j-1][n-i-1], matrix[i][j]];\\n        }\\n    }\\n    \\n    matrix.forEach(arr => arr.reverse());\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2503805,
                "title": "python-concise-and-clean-explained",
                "content": "![image](https://assets.leetcode.com/users/images/75941bf9-ef24-49aa-a34d-297163b40eef_1661845284.5558674.png)\\n\\nWe run over the perimeter and rotate the matrix.\\n\\nWe can make 3 swaps when we are standing on a single cell. For example cell `0,0` (value 1 in picture) will swap first wil `0, 2` (3). \\nThen `0,2` will have the final value - 1.\\nThen we can swap 0,0 with `2,2` (value 9 in picture). The reason is because `0,0` holds 3 now.\\nAnd finally we swap `0,0` which holds 9 now, with `2,0` (Value 7 in the picture).\\n\\nNow the cells `(0,0), (0, 2), (2,2) and (2,0)` are rotated.\\n\\nContinue this procedure for all the cells.\\n\\nNote: we are given `nxn` matrix, and every perimeter has 2 rows and 2 columns. Hence we simply need to run over n/2 perimeters.\\n\\n```\\nclass Solution:\\n    def rotate(self, matrix: List[List[int]]) -> None:\\n        n = len(matrix)\\n        row = 0\\n        col = 0\\n        \\n        for _ in range(n//2):\\n            col_boundary = n - col - 1\\n            while col < col_boundary:\\n                # Swap 4 sides\\n                \\n                # Right side of the rotation\\n                matrix[row][col], matrix[col][n-1-row] = matrix[col][n-1-row], matrix[row][col]\\n                \\n                # Bottom side of the rotation\\n                matrix[row][col], matrix[n-1-row][n-1-col] = matrix[n-1-row][n-1-col], matrix[row][col]\\n                \\n                # Left side of the rotation\\n                matrix[row][col], matrix[n-1-col][row]  = matrix[n-1-col][row], matrix[row][col]\\n                \\n                col += 1\\n            \\n            row += 1\\n            col = row\\n```\\n\\n# Transpose, Reverse\\nYou can also transpose and then reverse the matrix.\\n\\nWhenever we rotate the matrix, rows becomes columns, hence transpose. And the order should be swapped (reversed).\\n\\nThis is a much more elegant solution.\\n\\n```\\nclass Solution:\\n    def rotate(self, matrix: List[List[int]]) -> None:\\n        m, n = len(matrix), len(matrix[0])\\n        \\n        def transpose():\\n            for r in range(m):\\n                for c in range(r + 1, n):\\n                    matrix[r][c], matrix[c][r] = matrix[c][r], matrix[r][c]\\n                    \\n        def reverse():\\n            for r in range(m):\\n                for c in range(n//2):\\n                    matrix[r][c], matrix[r][~c] = matrix[r][~c], matrix[r][c]\\n        \\n        transpose()\\n        reverse()\\n```",
                "solutionTags": [
                    "Python"
                ],
                "code": "```\\nclass Solution:\\n    def rotate(self, matrix: List[List[int]]) -> None:\\n        n = len(matrix)\\n        row = 0\\n        col = 0\\n        \\n        for _ in range(n//2):\\n            col_boundary = n - col - 1\\n            while col < col_boundary:\\n                # Swap 4 sides\\n                \\n                # Right side of the rotation\\n                matrix[row][col], matrix[col][n-1-row] = matrix[col][n-1-row], matrix[row][col]\\n                \\n                # Bottom side of the rotation\\n                matrix[row][col], matrix[n-1-row][n-1-col] = matrix[n-1-row][n-1-col], matrix[row][col]\\n                \\n                # Left side of the rotation\\n                matrix[row][col], matrix[n-1-col][row]  = matrix[n-1-col][row], matrix[row][col]\\n                \\n                col += 1\\n            \\n            row += 1\\n            col = row\\n```\n```\\nclass Solution:\\n    def rotate(self, matrix: List[List[int]]) -> None:\\n        m, n = len(matrix), len(matrix[0])\\n        \\n        def transpose():\\n            for r in range(m):\\n                for c in range(r + 1, n):\\n                    matrix[r][c], matrix[c][r] = matrix[c][r], matrix[r][c]\\n                    \\n        def reverse():\\n            for r in range(m):\\n                for c in range(n//2):\\n                    matrix[r][c], matrix[r][~c] = matrix[r][~c], matrix[r][c]\\n        \\n        transpose()\\n        reverse()\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2503307,
                "title": "c-simple-solution-very-easy-to-understand",
                "content": "TC=O(n^2)\\nSC=O(n^2)\\n```\\nclass Solution {\\npublic:\\n    void rotate(vector<vector<int>>& matrix) {\\n        int n=matrix.size();\\n        vector<vector<int>> v(n,vector<int>(n));\\n        for(int i=n-1,k=0;i>=0,k<n;i--,k++){\\n            for(int j=0;j<n;j++){\\n                v[j][k]=matrix[i][j];\\n            }\\n        }\\n        for(int i=0;i<n;i++){\\n            for(int j=0;j<n;j++){\\n                matrix[i][j]=v[i][j];\\n            }\\n        }\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    void rotate(vector<vector<int>>& matrix) {\\n        int n=matrix.size();\\n        vector<vector<int>> v(n,vector<int>(n));\\n        for(int i=n-1,k=0;i>=0,k<n;i--,k++){\\n            for(int j=0;j<n;j++){\\n                v[j][k]=matrix[i][j];\\n            }\\n        }\\n        for(int i=0;i<n;i++){\\n            for(int j=0;j<n;j++){\\n                matrix[i][j]=v[i][j];\\n            }\\n        }\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2160796,
                "title": "c-both-clockwise-and-anti-clockwise-rotation-easy-approach-reverse-and-swap",
                "content": "**Please Upvote if you found this helpful.**\\n\\nFor Clockwise Rotation\\n\\n```\\nvoid rotate(vector<vector<int>>& matrix) \\n    {\\n        reverse(matrix.begin(), matrix.end());\\n        for(int i=0; i<matrix.size(); i++)\\n        {\\n            for(int j= i+1; j< matrix[i].size(); j++)\\n            {\\n                swap(matrix[i][j], matrix[j][i]);\\n            }\\n        }\\n        return;\\n    }\\n```\\nFor Anti-clockwise Rotation\\n```\\nvoid rotateImage(vector<vector<int>> &matrix)                  \\n{\\n    for(int i=0; i<matrix.size(); i++)\\n    {\\n        reverse(matrix[i].begin(), matrix[i].end());\\n    }\\n    for(int i=0; i<matrix.size(); i++)\\n    {\\n        for(int j= i+1; j< matrix[i].size(); j++)\\n        {\\n            swap(matrix[i][j], matrix[j][i]);\\n        }\\n    }\\n    return;\\n}\\n```",
                "solutionTags": [
                    "C++",
                    "C",
                    "Matrix"
                ],
                "code": "```\\nvoid rotate(vector<vector<int>>& matrix) \\n    {\\n        reverse(matrix.begin(), matrix.end());\\n        for(int i=0; i<matrix.size(); i++)\\n        {\\n            for(int j= i+1; j< matrix[i].size(); j++)\\n            {\\n                swap(matrix[i][j], matrix[j][i]);\\n            }\\n        }\\n        return;\\n    }\\n```\n```\\nvoid rotateImage(vector<vector<int>> &matrix)                  \\n{\\n    for(int i=0; i<matrix.size(); i++)\\n    {\\n        reverse(matrix[i].begin(), matrix[i].end());\\n    }\\n    for(int i=0; i<matrix.size(); i++)\\n    {\\n        for(int j= i+1; j< matrix[i].size(); j++)\\n        {\\n            swap(matrix[i][j], matrix[j][i]);\\n        }\\n    }\\n    return;\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2121639,
                "title": "detailed-step-wise-solution-c-for-o-1-space",
                "content": "```\\nclass Solution {\\npublic:\\n    void rotate(vector<vector<int>>& matrix) {\\n        int n = matrix.size();\\n        \\n        /*  take diagonal from top left to botton right, \\n            * then swap the symmetry \\n            * 1 2 3     1 4 7   \\n            * 4 5 6  => 2 5 8  \\n            * 7 8 9     3 6 9    \\n        */\\n            \\n        for(int i=0; i<n; i++) {\\n            for(int j=i; j<n; j++){\\n                swap(matrix[i][j], matrix[j][i]);\\n            }\\n        }\\n        \\n        /*  now swap 1st element with last of current row. \\n            * repeat till middle of current row.\\n            * 1 4 7     7 4 1 \\n            * 2 5 8  => 8 5 2\\n            * 3 6 9     9 6 3\\n        */\\n        for(int i=0; i<n; i++) {\\n            for(int j=0; j<n/2; j++){\\n                swap(matrix[i][j], matrix[i][n-j-1]);\\n            }\\n        }\\n    }\\n};\\n```",
                "solutionTags": [
                    "C"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    void rotate(vector<vector<int>>& matrix) {\\n        int n = matrix.size();\\n        \\n        /*  take diagonal from top left to botton right, \\n            * then swap the symmetry \\n            * 1 2 3     1 4 7   \\n            * 4 5 6  => 2 5 8  \\n            * 7 8 9     3 6 9    \\n        */\\n            \\n        for(int i=0; i<n; i++) {\\n            for(int j=i; j<n; j++){\\n                swap(matrix[i][j], matrix[j][i]);\\n            }\\n        }\\n        \\n        /*  now swap 1st element with last of current row. \\n            * repeat till middle of current row.\\n            * 1 4 7     7 4 1 \\n            * 2 5 8  => 8 5 2\\n            * 3 6 9     9 6 3\\n        */\\n        for(int i=0; i<n; i++) {\\n            for(int j=0; j<n/2; j++){\\n                swap(matrix[i][j], matrix[i][n-j-1]);\\n            }\\n        }\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1948933,
                "title": "c-0ms-very-easy-to-understand-only-5-6-line-code",
                "content": "class Solution {\\npublic:\\n    void rotate(vector<vector<int>>& matrix) {\\n        \\n          int n=matrix.size();\\n       \\n       for(int i=0;i<n;i++)\\n           for(int j=0;j<i;j++)\\n               swap(matrix[i][j],matrix[j][i]);\\n        \\n        for(int i=0;i<n;i++)\\n            reverse(matrix[i].begin(),matrix[i].end());\\n    }\\n};\\n\\n\\n\\n*please upvote if u feel good to this code*",
                "solutionTags": [
                    "C"
                ],
                "code": "class Solution {\\npublic:\\n    void rotate(vector<vector<int>>& matrix) {\\n        \\n          int n=matrix.size();\\n       \\n       for(int i=0;i<n;i++)\\n           for(int j=0;j<i;j++)\\n               swap(matrix[i][j],matrix[j][i]);\\n        \\n        for(int i=0;i<n;i++)\\n            reverse(matrix[i].begin(),matrix[i].end());\\n    }",
                "codeTag": "Java"
            },
            {
                "id": 1656258,
                "title": "c-easy-approach-transpose-of-matrix",
                "content": "```\\nclass Solution {\\npublic:\\n    void rotate(vector<vector<int>>& matrix) \\n    {\\n        int n = matrix.size();\\n        //Transpose of Matrix(1st row -> 1st column,2nd row -> 2nd Column)\\n        for(int i=0;i<n;i++)\\n        {\\n            for(int j=i;j<n;j++)\\n            {\\n                swap(matrix[i][j],matrix[j][i]);\\n            }\\n        }\\n        \\n        //Reverse the columns to get the matrix with 90 degree rotation\\n        for(int i=0;i<n;i++)\\n        {\\n            for(int j=0;j<n/2;j++)\\n            {\\n                swap(matrix[i][j],matrix[i][n-1-j]);\\n            }\\n        }\\n    }\\n};",
                "solutionTags": [],
                "code": "class Solution {\\npublic:\\n    void rotate(vector<vector<int>>& matrix) \\n    {\\n        int n = matrix.size();\\n        //Transpose of Matrix(1st row -> 1st column,2nd row -> 2nd Column)\\n        for(int i=0;i<n;i++)\\n        {\\n            for(int j=i;j<n;j++)\\n            {\\n                swap(matrix[i][j],matrix[j][i]);\\n            }",
                "codeTag": "Java"
            },
            {
                "id": 1539790,
                "title": "super-easy-solution-python-beats-90-time-85-memory",
                "content": "If we carefully look to input and output, one can observe simple trick:\\nInput: matrix = [[1,2,3],[4,5,6],[7,8,9]] \\nOutput: [[7,4,1],[8,5,2],[9,6,3]]\\nElements from every subarray just appends to all other arrays. Starting from the last we can just append elements to all subarrays and pop current element:\\n[[1,2,3],[4,5,6],[7,8,9]] \\n[[1,2,3,7],[4,5,6],[8,9]] \\n[[1,2,3,7],[4,5,6,8],[9]] \\n[[1,2,3,7,4],[5,6,8],[9]] \\n[[1,2,3,7,4],[6,8,5],[9]] \\n[[2,3,7,4,1],[8,5],[9,6]] \\n[[3,7,4,1],[8,5,2],[9,6]] \\n[[7,4,1],[8,5,2],[9,6,3]] \\nUpvote, please, if this solution was useful and fun!)\\n```\\n        n = len(matrix)\\n        for i in range(n-1,-1,-1):\\n            p = 0\\n            for j in matrix[i][0:n]:\\n                matrix[p].append(j)\\n                matrix[i].pop(0)\\n                p += 1\\n```",
                "solutionTags": [
                    "Python",
                    "Python3"
                ],
                "code": "```\\n        n = len(matrix)\\n        for i in range(n-1,-1,-1):\\n            p = 0\\n            for j in matrix[i][0:n]:\\n                matrix[p].append(j)\\n                matrix[i].pop(0)\\n                p += 1\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1538687,
                "title": "c-100-faster-simple-solution",
                "content": "Entirely logic based solution. The idea is to divide matrix into several parts. \\nFirst we deal with the outermost rows and columns. Then we start moving inwards, thus making the matrix shorter over every step.\\n\\nWe only deal with 2 rows and 2 columns at any given time. \\n\\n3 swaps are required for a 90\\xBA turn. For example,\\nIn a 3x3 matrix (0-indexed) :\\nmatrix[0,0] <-> matrix[2,0]\\nmatrix[2,0] <-> matrix[2,2]\\nmatrix[2,2] <-> matrix[0,2]\\n\\nDoing the above will turn the outer-most rows and columns in a 3x3 matrix by 90\\xBA. The same logic can be generalised and applied for any **n x n** matrix.\\n\\nFor even number of columns, like 2x2, 4x4, 6x6, etc., the matrix can be easily segregated into parts containing 2 rows and 2 columns. For odd number of columns, the inner-most element need not be rotated, and hence, we are again left with a virtually even column matrix.\\n\\n**swapNum** is defined only for fast swapping using pointers. You can do it with library swap function also.\\n\\n**temp** is used to find parts of matrix. For example, in a 4x4 matrix, \\n* first part contains :\\n\\t* rows -> 1 and 4 (all elements)\\n\\t* columns -> 1 and 4 (all elements)\\n* second part contains :\\n\\t* rows -> 2 and 3 (only elements of column 2 and 3)\\n\\t* columns -> 2 and 3 (only elements of rows 2 and 3)\\n\\nComment below if you have any doubts !!!\\n\\n```\\nclass Solution {\\npublic:\\n    void swapNum(int* a, int* b){\\n        *a += *b;\\n        *b = *a - *b;\\n        *a -= *b;\\n    }\\n    \\n    void rotate(vector<vector<int>>& matrix) {\\n        \\n        int i = 0;\\n        int j = matrix.size() - 1;\\n        int k = 0;\\n        \\n        int count = 0;\\n        \\n        int temp = matrix.size()/2;\\n        \\n        while(temp--){\\n            for(int i = count; i < matrix.size()-1-count; i++){\\n                swapNum(&matrix[i][k], &matrix[j-k][i]);\\n                swapNum(&matrix[j-k][i], &matrix[j-i][j-k]);\\n                swapNum(&matrix[j-i][j-k], &matrix[k][j-i]);\\n            }\\n            count++;\\n            k++;\\n        }\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "C"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    void swapNum(int* a, int* b){\\n        *a += *b;\\n        *b = *a - *b;\\n        *a -= *b;\\n    }\\n    \\n    void rotate(vector<vector<int>>& matrix) {\\n        \\n        int i = 0;\\n        int j = matrix.size() - 1;\\n        int k = 0;\\n        \\n        int count = 0;\\n        \\n        int temp = matrix.size()/2;\\n        \\n        while(temp--){\\n            for(int i = count; i < matrix.size()-1-count; i++){\\n                swapNum(&matrix[i][k], &matrix[j-k][i]);\\n                swapNum(&matrix[j-k][i], &matrix[j-i][j-k]);\\n                swapNum(&matrix[j-i][j-k], &matrix[k][j-i]);\\n            }\\n            count++;\\n            k++;\\n        }\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1214233,
                "title": "c-transpose-and-2-pointer-easy-approach-100-faster",
                "content": "class Solution {\\npublic:\\n    \\n    //We can solve this question in just 2 steps.\\n    //1.take the transpose of the matrix \\n    //2.swap every column using 2 pointer approach.\\n    \\n    1 2 3               1 4 7            7 4 1\\n    4 5 6    ==>        2 5 8   ==>      8 5 2\\n    7 8 9               3 6 9            9 6 3\\n    \\n    void rotate(vector<vector<int>>& matrix) {\\n        int row=matrix.size();\\n        int col=matrix[0].size();\\n        int i,j;\\n        \\n        for(i =0;i<row;i++){\\n            for(j=0;j<=i;j++){\\n                swap(matrix[i][j],matrix[j][i]);\\n            }\\n        }\\n        //upper for loop will transpose the matrix.\\n        \\n        for(i=0,j=col-1 ; i<=j ; i++,j--){ //i and j are pointing to first and last column.\\n            for(int k=0;k<row;k++){\\n                swap(matrix[k][i],matrix[k][j]);\\n            }\\n        }\\n        //this for loop will swap the columns\\n    }\\n\\t//Upvote if you find it useful\\n};",
                "solutionTags": [],
                "code": "class Solution {\\npublic:\\n    \\n    //We can solve this question in just 2 steps.\\n    //1.take the transpose of the matrix \\n    //2.swap every column using 2 pointer approach.\\n    \\n    1 2 3               1 4 7            7 4 1\\n    4 5 6    ==>        2 5 8   ==>      8 5 2\\n    7 8 9               3 6 9            9 6 3\\n    \\n    void rotate(vector<vector<int>>& matrix) {\\n        int row=matrix.size();\\n        int col=matrix[0].size();\\n        int i,j;\\n        \\n        for(i =0;i<row;i++){\\n            for(j=0;j<=i;j++){\\n                swap(matrix[i][j],matrix[j][i]);\\n            }",
                "codeTag": "Java"
            },
            {
                "id": 1175448,
                "title": "easy-solution-c",
                "content": "```\\nclass Solution {\\npublic:\\n    void rotate(vector<vector<int>>& image) {\\n\\t\\t// transpose matrix\\n        for (int i = 0; i < image.size(); ++i) {\\n            for (int j = i; j < image.size(); ++j)\\n                swap(image[i][j], image[j][i]);\\n        }\\n\\t\\tfor(int i=0;i<image.size();i++)\\n             reverse(image[i].begin(),image[i].end());\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "C"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    void rotate(vector<vector<int>>& image) {\\n\\t\\t// transpose matrix\\n        for (int i = 0; i < image.size(); ++i) {\\n            for (int j = i; j < image.size(); ++j)\\n                swap(image[i][j], image[j][i]);\\n        }\\n\\t\\tfor(int i=0;i<image.size();i++)\\n             reverse(image[i].begin(),image[i].end());\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1078277,
                "title": "easy-to-understand-java-and-c-solution",
                "content": "1.) using java\\n```\\nclass Solution {\\n    public void transpose(int[][] arr) {\\n        for (int i = 0; i < arr.length; i++) {\\n            for (int j = i + 1; j < arr[0].length; j++) {\\n                arr[i][j] ^= arr[j][i];\\n                arr[j][i] ^= arr[i][j];\\n                arr[i][j] ^= arr[j][i];\\n            }\\n        }\\n    }\\n    \\n    public void swaping(int[][] arr) {\\n        for (int j = 0; j < arr.length / 2; j++) {\\n            for (int i = 0; i < arr[0].length; i++) {\\n                arr[i][j] ^= arr[i][arr.length - j - 1];\\n                arr[i][arr.length - j - 1] ^= arr[i][j];\\n                arr[i][j] ^= arr[i][arr.length - j - 1];\\n            }\\n        }\\n    }\\n    \\n    public void rotate(int[][] matrix) {\\n        transpose(matrix);\\n        swaping(matrix);\\n    }\\n}\\n```\\n2.) another way using java\\n```\\nclass Solution {\\n    public void rotate(int[][] matrix) {\\n        if (matrix.length == 0)\\n            return;\\n        for (int i=0;i<matrix.length;i++)\\n            for (int j=i+1;j<matrix.length;j++)\\n            {\\n                matrix[i][j] = matrix[i][j] + matrix[j][i];\\n                matrix[j][i] = matrix[i][j] - matrix[j][i];\\n                matrix[i][j] = matrix[i][j] - matrix[j][i];\\n            }\\n        \\n        int si = 0, ei = matrix.length-1;\\n        while (si < ei){\\n            for (int i = 0; i < matrix.length; i++)\\n            {\\n                matrix[i][si] = matrix[i][si] + matrix[i][ei];\\n                matrix[i][ei] = matrix[i][si] - matrix[i][ei];\\n                matrix[i][si] = matrix[i][si] - matrix[i][ei];\\n            }\\n            si++;\\n            ei--;\\n        }\\n        return;\\n    }\\n}\\n```\\n3.) similarly using c++\\n```\\nauto SpeeUp = [](){\\n    std::ios_base::sync_with_stdio(false);\\n    cin.tie(NULL);\\n    cout.tie(NULL);\\n    return NULL;\\n}();\\nclass Solution {\\npublic:\\n    void rotate(vector<vector<int>>& matrix) {\\n        int n = matrix.size();\\n        if (n == 0)\\n            return;\\n        for (int i = 0; i < n; i++) {\\n            for (int j = i+1; j < n; j++) {\\n                int temp = matrix[i][j];\\n                matrix[i][j] = matrix[j][i];\\n                matrix[j][i] = temp;\\n            }\\n        }\\n        \\n        int si = 0, ei = n-1;\\n        while (si < ei) {\\n            for (int i = 0; i < n; i++) {\\n                int temp = matrix[i][si];\\n                matrix[i][si] = matrix[i][ei];\\n                matrix[i][ei] = temp;\\n            }\\n            si++;\\n            ei--;\\n        }\\n        return;\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    public void transpose(int[][] arr) {\\n        for (int i = 0; i < arr.length; i++) {\\n            for (int j = i + 1; j < arr[0].length; j++) {\\n                arr[i][j] ^= arr[j][i];\\n                arr[j][i] ^= arr[i][j];\\n                arr[i][j] ^= arr[j][i];\\n            }\\n        }\\n    }\\n    \\n    public void swaping(int[][] arr) {\\n        for (int j = 0; j < arr.length / 2; j++) {\\n            for (int i = 0; i < arr[0].length; i++) {\\n                arr[i][j] ^= arr[i][arr.length - j - 1];\\n                arr[i][arr.length - j - 1] ^= arr[i][j];\\n                arr[i][j] ^= arr[i][arr.length - j - 1];\\n            }\\n        }\\n    }\\n    \\n    public void rotate(int[][] matrix) {\\n        transpose(matrix);\\n        swaping(matrix);\\n    }\\n}\\n```\n```\\nclass Solution {\\n    public void rotate(int[][] matrix) {\\n        if (matrix.length == 0)\\n            return;\\n        for (int i=0;i<matrix.length;i++)\\n            for (int j=i+1;j<matrix.length;j++)\\n            {\\n                matrix[i][j] = matrix[i][j] + matrix[j][i];\\n                matrix[j][i] = matrix[i][j] - matrix[j][i];\\n                matrix[i][j] = matrix[i][j] - matrix[j][i];\\n            }\\n        \\n        int si = 0, ei = matrix.length-1;\\n        while (si < ei){\\n            for (int i = 0; i < matrix.length; i++)\\n            {\\n                matrix[i][si] = matrix[i][si] + matrix[i][ei];\\n                matrix[i][ei] = matrix[i][si] - matrix[i][ei];\\n                matrix[i][si] = matrix[i][si] - matrix[i][ei];\\n            }\\n            si++;\\n            ei--;\\n        }\\n        return;\\n    }\\n}\\n```\n```\\nauto SpeeUp = [](){\\n    std::ios_base::sync_with_stdio(false);\\n    cin.tie(NULL);\\n    cout.tie(NULL);\\n    return NULL;\\n}();\\nclass Solution {\\npublic:\\n    void rotate(vector<vector<int>>& matrix) {\\n        int n = matrix.size();\\n        if (n == 0)\\n            return;\\n        for (int i = 0; i < n; i++) {\\n            for (int j = i+1; j < n; j++) {\\n                int temp = matrix[i][j];\\n                matrix[i][j] = matrix[j][i];\\n                matrix[j][i] = temp;\\n            }\\n        }\\n        \\n        int si = 0, ei = n-1;\\n        while (si < ei) {\\n            for (int i = 0; i < n; i++) {\\n                int temp = matrix[i][si];\\n                matrix[i][si] = matrix[i][ei];\\n                matrix[i][ei] = temp;\\n            }\\n            si++;\\n            ei--;\\n        }\\n        return;\\n    }\\n};\\n```",
                "codeTag": "C++"
            },
            {
                "id": 602304,
                "title": "cpp-unable-to-submit-anything-initial-code-broken",
                "content": "Empty solution code:\\n```\\nclass Solution {\\npublic:\\n    void rotate(vector<vector<int>>& matrix) {\\n        \\n    }\\n};\\n```\\n\\ngenerates compile error\\n```\\nLine 30: Char 17: fatal error: no matching member function for call to \\'resize\\'\\n        param_1.resize();\\n        ~~~~~~~~^~~~~~\\n/usr/bin/../lib/gcc/x86_64-linux-gnu/8/../../../../include/c++/8/bits/stl_vector.h:824:7: note: candidate function not viable: requires single argument \\'__new_size\\', but no arguments were provided\\n      resize(size_type __new_size)\\n      ^\\n/usr/bin/../lib/gcc/x86_64-linux-gnu/8/../../../../include/c++/8/bits/stl_vector.h:844:7: note: candidate function not viable: requires 2 arguments, but 0 were provided\\n      resize(size_type __new_size, const value_type&amp; __x)\\n      ^\\n1 error generated.\\n```\\n\\n**Can someone fix this?**",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    void rotate(vector<vector<int>>& matrix) {\\n        \\n    }\\n};\\n```\n```\\nLine 30: Char 17: fatal error: no matching member function for call to \\'resize\\'\\n        param_1.resize();\\n        ~~~~~~~~^~~~~~\\n/usr/bin/../lib/gcc/x86_64-linux-gnu/8/../../../../include/c++/8/bits/stl_vector.h:824:7: note: candidate function not viable: requires single argument \\'__new_size\\', but no arguments were provided\\n      resize(size_type __new_size)\\n      ^\\n/usr/bin/../lib/gcc/x86_64-linux-gnu/8/../../../../include/c++/8/bits/stl_vector.h:844:7: note: candidate function not viable: requires 2 arguments, but 0 were provided\\n      resize(size_type __new_size, const value_type&amp; __x)\\n      ^\\n1 error generated.\\n```",
                "codeTag": "Java"
            },
            {
                "id": 404955,
                "title": "first-reverse-then-transpose",
                "content": "This is a 2 step solution: first reverse, then transpose. Please keep this in mind since it just illustrates the most simple approach to this problem.\\n\\nReversing a matrix simply means that you need to swap the order of rows. E.g. if you have matrix of 3 row/col, then swap first with last. If you have matrix of 4 rows/cols, then swap first with fourth, second with the third. The idea is simple, it\\'s the same as you reverse an array. Threat your matrix as an array in this case.\\n\\nThe next step is tranposing. Transposing means swaping rows with columns. \\nSo if you have your reversed matrix as \\n  ```\\n  [7, 8, 9],\\n  [4, 5, 6],\\n  [1, 2, 3]\\n  ```\\n  then you need to swap rows with columns, so first row becomes first column, second row becomes second column and so on:\\n  ```\\n  [7, 4, 1],\\n  [8, 5, 2],\\n  [9, 6, 3]\\n  ```\\n  \\nAnd that\\'s it! As simple as that! Took me some time to figure out.\\n\\nsome C# code (can be any other language with slight corrections):\\n```csharp\\n\\tpublic class Solution\\n\\t{\\n\\t\\tpublic void Rotate(int[][] matrix)\\n\\t\\t{\\n\\t\\t\\t// reverse\\n\\t\\t\\tArray.Reverse(matrix);\\n\\n\\t\\t\\t// transpose\\n\\t\\t\\tfor (var i = 0; i < matrix.Length; ++i)\\n\\t\\t\\t{\\n\\t\\t\\t\\tfor (var j = 0; j < i; ++j)\\n\\t\\t\\t\\t{\\n\\t\\t\\t\\t\\tvar tmp = matrix[i][j];\\n\\t\\t\\t\\t\\tmatrix[i][j] = matrix[j][i];\\n\\t\\t\\t\\t\\tmatrix[j][i] = tmp;\\n\\t\\t\\t\\t} \\n\\t\\t\\t}\\n\\t\\t}\\n\\t}\\n```",
                "solutionTags": [],
                "code": "```\\n  [7, 8, 9],\\n  [4, 5, 6],\\n  [1, 2, 3]\\n  ```\n```\\n  [7, 4, 1],\\n  [8, 5, 2],\\n  [9, 6, 3]\\n  ```\n```csharp\\n\\tpublic class Solution\\n\\t{\\n\\t\\tpublic void Rotate(int[][] matrix)\\n\\t\\t{\\n\\t\\t\\t// reverse\\n\\t\\t\\tArray.Reverse(matrix);\\n\\n\\t\\t\\t// transpose\\n\\t\\t\\tfor (var i = 0; i < matrix.Length; ++i)\\n\\t\\t\\t{\\n\\t\\t\\t\\tfor (var j = 0; j < i; ++j)\\n\\t\\t\\t\\t{\\n\\t\\t\\t\\t\\tvar tmp = matrix[i][j];\\n\\t\\t\\t\\t\\tmatrix[i][j] = matrix[j][i];\\n\\t\\t\\t\\t\\tmatrix[j][i] = tmp;\\n\\t\\t\\t\\t} \\n\\t\\t\\t}\\n\\t\\t}\\n\\t}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 271648,
                "title": "solution-runs-in-4ms-with-c-and-a-brief-explanation-of-the-most-voted-solution",
                "content": "The most voted solution [\"A common method to rotate the image\"](https://leetcode.com/problems/rotate-image/discuss/18872/A-common-method-to-rotate-the-image) is really wonderful, but it seems that many people don\\'t know how it works. So I will show my view.\\n\\nBriefly, the action **\"first reverse up to down, then swap the symmetry\"** is same to `matrix[j][n - 1 - i] = matrixOld[i][j]`, where n means the length of the matrix.\\n\\nSo you can even solve this problem like this (run in 4ms with C++):\\n\\n```\\nvoid rotate(vector<vector<int> > & matrix) {\\n\\tvector<vector<int> > matrixOld = matrix; // To save the old matrix.\\n\\tint n = matrix.size();\\n\\tfor(int i = 0; i < n; i++)\\n\\t{\\n\\t\\tfor(int j = 0; j < n; j++)\\n\\t\\t{\\n\\t\\t\\tmatrix[j][n - 1 - i] = matrixOld[i][j];\\n\\t\\t}\\n\\t}\\n}\\n```\\n\\nNow let me show how I get this.\\n\\nFirst we need to know that to rotate an image, we actually rotate each points of this image. \\nFor a given point **x(a, b)**. If we rotate it **\\u03B8** degrees around the coordinate origin **(0, 0)**, we get **x\\'(a\\', b\\')** where **a\\' = a * cos\\u03B8 - b * sin\\u03B8** and **b\\' = a * sin\\u03B8 + b * cos\\u03B8**. You can get this theory easily from [Wikipedia](https://en.wikipedia.org/wiki/Rotation_matrix). In this problem, **\\u03B8 = -90 degrees** so **a\\' = b** and **b\\' = -a** **[1]**.\\n\\nHowever, in this problem, the matrix does not rotate around the coordinate origin, but the point **((n - 1) / 2, (n - 1) / 2)** (index starts from 0). To deal with it, we merge two coordinates and set **offset = (n - 1) / 2** as the figure bellow shows. \\n\\n![image](https://assets.leetcode.com/users/zeroonecode/image_1554810183.png)\\n\\nFor a given point in both coordinates, represented by **x(a, b)** and **x(i, j)**, we get **a = j - offset** and **b = -i + offset** **[2]**.\\n\\nSubstituting **a**, **b**, **a\\'**, **b\\'** in **[1]** by **[2]**, we get:\\n**j\\' - offset = -i + offset** and **-i\\' + offset = -(j - offset)** =>\\n**j\\' = 2 * offset - i** and **i\\' = j**\\n\\nSince **offset = (n - 1) / 2**, substituting **offset** by **n**, we achieve **i\\' = j** and **j\\' = n - 1 - i**.",
                "solutionTags": [],
                "code": "```\\nvoid rotate(vector<vector<int> > & matrix) {\\n\\tvector<vector<int> > matrixOld = matrix; // To save the old matrix.\\n\\tint n = matrix.size();\\n\\tfor(int i = 0; i < n; i++)\\n\\t{\\n\\t\\tfor(int j = 0; j < n; j++)\\n\\t\\t{\\n\\t\\t\\tmatrix[j][n - 1 - i] = matrixOld[i][j];\\n\\t\\t}\\n\\t}\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 18939,
                "title": "python-solution-with-detailed-explanation",
                "content": "**Solution**\\n\\n**Rotate Image** https://leetcode.com/problems/rotate-image/?tab=Description\\n\\n**Transpose and Reverse Rows**\\n1. Take the transpose and then reverse each row. https://discuss.leetcode.com/topic/9744/ac-java-in-place-solution-with-explanation-easy-to-understand\\n2. Reverse the matrix by the order of the rows. Then take a transpose. Check the code to transpose - notice we swap only the upper or lower diagonal. https://discuss.leetcode.com/topic/6796/a-common-method-to-rotate-the-image\\n3. How do we get solutions 1 and 2? Imagine a matrix of 3 by 3 on a table. Then imagine toppling it clockwise.That will tell you that clockwise rotation is really the transpose followed by reversing the order of columns. This is shown in the attached image. The same intuition can be used to derive anti-clockwise rotation. https://goo.gl/photos/yNqeCLumMLFEXBKs6 \\n\\n```\\nclass Solution(object):\\n    def transpose(self, matrix):\\n        M,N = len(matrix), len(matrix[0])\\n        cols = 1\\n        for i in range(M):\\n            for j in range(cols):\\n                matrix[i][j], matrix[j][i] = matrix[j][i], matrix[i][j]\\n            cols += 1\\n        return\\n    \\n    def rotate(self, matrix):\\n        \"\"\"\\n        :type matrix: List[List[int]]\\n        :rtype: void Do not return anything, modify matrix in-place instead.\\n        \"\"\"\\n        if matrix == []:\\n            return matrix\\n        self.transpose(matrix)\\n        for r in matrix:\\n            r.reverse()\\n        return\\n```\\n\\n**Swap four corners**\\n* Last algorithm is where we swap the four corners. The trick to cleanly swap the four corners is to fix [0,0]. Then swap [0,2] with [0,0]. Then swap [2,2] with [0,0]. Then swap [2,0] with [0,0]. Again check the image.",
                "solutionTags": [],
                "code": "```\\nclass Solution(object):\\n    def transpose(self, matrix):\\n        M,N = len(matrix), len(matrix[0])\\n        cols = 1\\n        for i in range(M):\\n            for j in range(cols):\\n                matrix[i][j], matrix[j][i] = matrix[j][i], matrix[i][j]\\n            cols += 1\\n        return\\n    \\n    def rotate(self, matrix):\\n        \"\"\"\\n        :type matrix: List[List[int]]\\n        :rtype: void Do not return anything, modify matrix in-place instead.\\n        \"\"\"\\n        if matrix == []:\\n            return matrix\\n        self.transpose(matrix)\\n        for r in matrix:\\n            r.reverse()\\n        return\\n```",
                "codeTag": "Java"
            },
            {
                "id": 19086,
                "title": "c-5-line-in-place-solution",
                "content": "        \\n    void rotate(vector<vector<int>>& matrix) {\\n        for (unsigned int i=0; i<matrix.size(); i++) // transpose\\n            for (unsigned int j=0; j<i; j++)\\n                swap(matrix[i][j], matrix[j][i]);\\n        for (auto& row: matrix)  // reverse\\n            reverse(row.begin(), row.end());\\n    }",
                "solutionTags": [
                    "C++"
                ],
                "code": "        \\n    void rotate(vector<vector<int>>& matrix) {\\n        for (unsigned int i=0; i<matrix.size(); i++) // transpose\\n            for (unsigned int j=0; j<i; j++)\\n                swap(matrix[i][j], matrix[j][i]);\\n        for (auto& row: matrix)  // reverse\\n            reverse(row.begin(), row.end());\\n    }",
                "codeTag": "Unknown"
            },
            {
                "id": 19160,
                "title": "share-my-java-solution-192ms",
                "content": "public class Solution {\\n\\n    public void rotate(int[][] matrix) {\\n\\n        if(matrix.length == 0 || matrix.length == 1){\\n            return;\\n        }\\n\\n        int temp = 0;\\n        int n = matrix.length - 1;\\n\\n        for(int i = 0; i < matrix.length - 1; i++){\\n            for(int j = 0; j + i < n; j++){\\n                temp = matrix[i][j];\\n                matrix[i][j] = matrix[n-j][n-i];\\n                matrix[n-j][n-i] = temp;\\n            }\\n        }\\n        \\n        for(int i = 0; i< matrix.length / 2; i++){\\n            for(int j = 0; j < matrix[0].length; j++){\\n                temp = matrix[i][j];\\n                matrix[i][j] = matrix[n-i][j];\\n                matrix[n-i][j] = temp;\\n            }\\n        }\\n    }\\n}\\n\\n\\n\\nAlgorithm:   m[i][j]  <->  m[n-j][n-i] \\n //First swap diagonally\\n                   m[i][j]  <->  matrix[n-i][j] \\n//  Second swap vertically",
                "solutionTags": [
                    "Java"
                ],
                "code": "class Solution {\\n\\n    public void rotate(int[][] matrix) {\\n\\n        if(matrix.length == 0 || matrix.length == 1){\\n            return;\\n        }",
                "codeTag": "Java"
            },
            {
                "id": 3157091,
                "title": "easy-c-code-using-reverse-and-swap-function-super-easy",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    void rotate(vector<vector<int>>& matrix) {\\n        int n=matrix.size();\\n    \\n        for(int i=0;i<n;i++){\\n            for(int j=i+1;j<n;j++){\\n                swap(matrix[i][j],matrix[j][i]);\\n            }\\n        }\\n    //   for(int j=0;j<n;j++){\\n    //       for(int i=0;i<n;i++){\\n    //            swap(matrix[j][n-i-1],matrix[j][i]);\\n    //             //  cout<<matrix[i][j]<<\" \";\\n        \\n    //       }\\n    //     }\\n    for(int i = 0; i < n; ++i){\\n            reverse(matrix[i].begin(), matrix[i].end());\\n        }\\n    // swap(matrix[0][0],matrix[0][2]);\\n// for(int i=0;i<n;i++){\\n//     for(int j=0;j<n;j++){\\n//                 cout<<matrix[i][j]<<\" \";\\n//     }\\n//     cout<<endl;\\n// }\\n// for(int i=0;i<n;i++){\\n//     swap(matrix[i][0],matrix[n-i-1][0]);\\n// }\\n\\n        // swap(matrix[i][j],matrix[i][n-j-1]);\\n        \\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    void rotate(vector<vector<int>>& matrix) {\\n        int n=matrix.size();\\n    \\n        for(int i=0;i<n;i++){\\n            for(int j=i+1;j<n;j++){\\n                swap(matrix[i][j],matrix[j][i]);\\n            }\\n        }\\n    //   for(int j=0;j<n;j++){\\n    //       for(int i=0;i<n;i++){\\n    //            swap(matrix[j][n-i-1],matrix[j][i]);\\n    //             //  cout<<matrix[i][j]<<\" \";\\n        \\n    //       }\\n    //     }\\n    for(int i = 0; i < n; ++i){\\n            reverse(matrix[i].begin(), matrix[i].end());\\n        }\\n    // swap(matrix[0][0],matrix[0][2]);\\n// for(int i=0;i<n;i++){\\n//     for(int j=0;j<n;j++){\\n//                 cout<<matrix[i][j]<<\" \";\\n//     }\\n//     cout<<endl;\\n// }\\n// for(int i=0;i<n;i++){\\n//     swap(matrix[i][0],matrix[n-i-1][0]);\\n// }\\n\\n        // swap(matrix[i][j],matrix[i][n-j-1]);\\n        \\n    }\\n};\\n```",
                "codeTag": "C++"
            },
            {
                "id": 3083188,
                "title": "c-4-lines",
                "content": "# Code\\n```\\npublic class Solution {\\n    public void Rotate(int[][] matrix) {\\n        var max = matrix.Length - 1;\\n        for(var i = 0; i < matrix.Length / 2; i++) \\n            for(var j = i; j < max - i; j++)\\n                (matrix[i][j], matrix[max - j][i], matrix[max - i][max - j], matrix[j][max - i]) = (matrix[max - j][i], matrix[max - i][max - j], matrix[j][max - i], matrix[i][j]);\\n    }\\n}\\n```",
                "solutionTags": [
                    "C#"
                ],
                "code": "```\\npublic class Solution {\\n    public void Rotate(int[][] matrix) {\\n        var max = matrix.Length - 1;\\n        for(var i = 0; i < matrix.Length / 2; i++) \\n            for(var j = i; j < max - i; j++)\\n                (matrix[i][j], matrix[max - j][i], matrix[max - i][max - j], matrix[j][max - i]) = (matrix[max - j][i], matrix[max - i][max - j], matrix[j][max - i], matrix[i][j]);\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2807607,
                "title": "c-easy-approach",
                "content": "Here is my c++ code for this problem.\\n\\'\\'\\'\\n\\n\\tclass Solution {\\n\\tpublic:\\n\\t\\tvoid rotate(vector<vector<int>>& matrix) {\\n\\t\\t\\treverse(matrix.begin(), matrix.end());\\n\\t\\t\\tfor(int i=0; i<matrix.size(); i++){\\n\\t\\t\\t\\tfor(int j=i+1; j<matrix[0].size(); j++){\\n\\t\\t\\t\\t\\tswap(matrix[i][j], matrix[j][i]);\\n\\t\\t\\t\\t}\\n\\t\\t\\t}\\n\\t\\t}\\n\\t};\\n,,,",
                "solutionTags": [
                    "C"
                ],
                "code": "class Solution {\\n\\tpublic:\\n\\t\\tvoid rotate(vector<vector<int>>& matrix) {\\n\\t\\t\\treverse(matrix.begin(), matrix.end());\\n\\t\\t\\tfor(int i=0; i<matrix.size(); i++){\\n\\t\\t\\t\\tfor(int j=i+1; j<matrix[0].size(); j++){\\n\\t\\t\\t\\t\\tswap(matrix[i][j], matrix[j][i]);\\n\\t\\t\\t\\t}",
                "codeTag": "Java"
            },
            {
                "id": 2786897,
                "title": "python-reverse-and-swap-symmetry",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n- We can reverse the image clockwise\\n- and then swap it\\'s symmetry\\n\\n```\\n 1 2 3     7 8 9     7 4 1\\n 4 5 6  => 4 5 6  => 8 5 2\\n 7 8 9     1 2 3     9 6 3\\nOriginal   Reverse   Swap\\n```\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n- Reverse the image clockwise by reversing the matrix\\n    - Built-in python **reverse** operator\\n- Swapping image symmetry\\n    - we can do this by looping through the matrix right half triangle\\n    - **7** **8** **9**\\n      4 **5** **6**\\n      1 2 **3** \\n    - and then swapping the inverse of its coordinates\\n    - ```\\n      matrix[0][2], matrix[2][0] = matrix[2][0], matrix[0][2]\\n      ```\\n# Complexity\\n- Time complexity: $$O(h*w)$$ *(area of image)*\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: $$O(1)$$ *(matrix not included)*\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution:\\n    def rotate(self, matrix: List[List[int]]) -> None:\\n        \"\"\"\\n        Do not return anything, modify matrix in-place instead.\\n        \"\"\"\\n        matrix.reverse()\\n        for i in range(len(matrix)):\\n            for j in range(i+1, len(matrix[i])):\\n                matrix[i][j], matrix[j][i] = matrix[j][i], matrix[i][j]\\n```\\nCredits: https://leetcode.com/problems/rotate-image/solutions/18872/a-common-method-to-rotate-the-image/",
                "solutionTags": [
                    "Python3",
                    "Matrix"
                ],
                "code": "```\\n 1 2 3     7 8 9     7 4 1\\n 4 5 6  => 4 5 6  => 8 5 2\\n 7 8 9     1 2 3     9 6 3\\nOriginal   Reverse   Swap\\n```\n```\\n      matrix[0][2], matrix[2][0] = matrix[2][0], matrix[0][2]\\n      ```\n```\\nclass Solution:\\n    def rotate(self, matrix: List[List[int]]) -> None:\\n        \"\"\"\\n        Do not return anything, modify matrix in-place instead.\\n        \"\"\"\\n        matrix.reverse()\\n        for i in range(len(matrix)):\\n            for j in range(i+1, len(matrix[i])):\\n                matrix[i][j], matrix[j][i] = matrix[j][i], matrix[i][j]\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2687641,
                "title": "c-easy-fast-solution",
                "content": "**please upvote if it\\'s helpful**\\n```\\nclass Solution {\\npublic:\\n    void rotate(vector<vector<int>>& matrix) {\\n        for(int i=0;i<matrix.size();i++){\\n            for(int j=i;j<matrix.size();j++){\\n                swap(matrix[i][j],matrix[j][i]);\\n            }\\n        }\\n        for(int i=0;i<matrix.size();i++){\\n            reverse(matrix[i].begin(),matrix[i].end());\\n        }\\n    }\\n};\\n\\n```",
                "solutionTags": [
                    "C"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    void rotate(vector<vector<int>>& matrix) {\\n        for(int i=0;i<matrix.size();i++){\\n            for(int j=i;j<matrix.size();j++){\\n                swap(matrix[i][j],matrix[j][i]);\\n            }\\n        }\\n        for(int i=0;i<matrix.size();i++){\\n            reverse(matrix[i].begin(),matrix[i].end());\\n        }\\n    }\\n};\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2683680,
                "title": "c-transpose-reverse-with-step-by-step-explanation",
                "content": "```\\nclass Solution {\\npublic:\\n    void rotate(vector<vector<int>>& matrix) {\\n        /*\\n\\t\\t//exampe 1\\n\\t\\t1 2 3\\n\\t\\t4 5 6\\n\\t\\t7 8 9 \\n\\t\\t\\n        //transpose\\n        1 4 7\\n        2 5 8\\n        3 6 9\\n            \\n        //reverse\\n        7 4 1 \\n        8 5 2\\n        9 6 3\\n        */\\n\\t\\t\\n        int n = matrix.size();\\n\\t\\t\\n\\t\\t//transpose\\n        for (int r = 0; r < n; ++r) {\\n            for (int c = r; c < n; ++c) {\\n                swap(matrix[r][c], matrix[c][r]);\\n            }\\n        }\\n        //reverse\\n        for (int r = 0; r < n; ++r) {\\n            reverse(matrix[r].begin(), matrix[r].end());\\n        }\\n        \\n        return;\\n    }\\n};\\n\\n/*\\nif (you like this) {\\n\\tplease upvote;\\n}\\n*/\\n\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    void rotate(vector<vector<int>>& matrix) {\\n        /*\\n\\t\\t//exampe 1\\n\\t\\t1 2 3\\n\\t\\t4 5 6\\n\\t\\t7 8 9 \\n\\t\\t\\n        //transpose\\n        1 4 7\\n        2 5 8\\n        3 6 9\\n            \\n        //reverse\\n        7 4 1 \\n        8 5 2\\n        9 6 3\\n        */\\n\\t\\t\\n        int n = matrix.size();\\n\\t\\t\\n\\t\\t//transpose\\n        for (int r = 0; r < n; ++r) {\\n            for (int c = r; c < n; ++c) {\\n                swap(matrix[r][c], matrix[c][r]);\\n            }\\n        }\\n        //reverse\\n        for (int r = 0; r < n; ++r) {\\n            reverse(matrix[r].begin(), matrix[r].end());\\n        }\\n        \\n        return;\\n    }\\n};\\n\\n/*\\nif (you like this) {\\n\\tplease upvote;\\n}\\n*/\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2506123,
                "title": "0-ms-simple-java-code",
                "content": "```\\nclass Solution {\\n  public void rotate(int[][] matrix) {\\n    for (int i = 0, j = matrix.length - 1; i < j; ++i, --j) {\\n      int[] temp = matrix[i];\\n      matrix[i] = matrix[j];\\n      matrix[j] = temp;\\n    }\\n\\n    for (int i = 0; i < matrix.length; ++i)\\n      for (int j = i + 1; j < matrix.length; ++j) {\\n        final int temp = matrix[i][j];\\n        matrix[i][j] = matrix[j][i];\\n        matrix[j][i] = temp;\\n      }\\n  }\\n}\\n\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n  public void rotate(int[][] matrix) {\\n    for (int i = 0, j = matrix.length - 1; i < j; ++i, --j) {\\n      int[] temp = matrix[i];\\n      matrix[i] = matrix[j];\\n      matrix[j] = temp;\\n    }\\n\\n    for (int i = 0; i < matrix.length; ++i)\\n      for (int j = i + 1; j < matrix.length; ++j) {\\n        final int temp = matrix[i][j];\\n        matrix[i][j] = matrix[j][i];\\n        matrix[j][i] = temp;\\n      }\\n  }\\n}\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2504047,
                "title": "rust-three-solutions-with-comments",
                "content": "There are several different pairs of transformations that result in a 90 degree rotation of the matrix. One is mirroring vertically, and then transposing:\\n\\n```\\nimpl Solution {\\n    pub fn rotate(matrix: &mut Vec<Vec<i32>>) {\\n        matrix.reverse();\\n        for i in 1..matrix.len() {\\n            for j in 0..i {\\n                let t = matrix[i][j];\\n                matrix[i][j] = matrix[j][i];\\n                matrix[j][i] = t;\\n            }\\n        }\\n    }\\n}\\n```\\n\\nwhich I think is the most elegant and efficient, since the `.reverse()` operation is just n / 2 swaps of fat pointers. Another method is transposing and then mirroring horizontally:\\n\\n```\\nimpl Solution {\\n    pub fn rotate(matrix: &mut Vec<Vec<i32>>) {\\n        for i in 1..matrix.len() {\\n            for j in 0..i {\\n                let t = matrix[i][j];\\n                matrix[i][j] = matrix[j][i];\\n                matrix[j][i] = t;\\n            }\\n        }\\n        matrix.iter_mut().for_each(|row| row.reverse());\\n    }\\n}\\n```\\n\\nwhich is less efficient since we have to do n * n / 2 swaps in the mirroring operation. And as an exercise, I also did the variation with horizontal mirroring followed by mirroring over the anti-diagonal, and I did it with functional-style Rust. Not at all as clean as the solutions above, but the idea here was to create chained iterators with the endpoints of all the relevant diagonals (corners do not need to be reversed), and then walk toward the middle of each diagonal, swapping elements as we go. Nice to use chained iterators and `successors`. :)\\n\\n```\\nimpl Solution {\\n    pub fn rotate(matrix: &mut Vec<Vec<i32>>) {\\n        matrix.iter_mut().for_each(|row| row.reverse());\\n        let m = matrix.len();\\n        (1..m - 1)\\n            .map(|i| ((i, 0), (m - 1, m - i - 1)))\\n            .chain((0..m - 1).map(|j| ((0, j), (m - j - 1, m - 1))))\\n            .for_each(|coords| {\\n                std::iter::successors(Some(coords), |((r1, c1), (r2, c2))| {\\n                    Some(((*r1 + 1, *c1 + 1), (r2.wrapping_sub(1), c2.wrapping_sub(1))))\\n                })\\n                .take_while(|((r1, _), (r2, _))| *r1 < *r2)\\n                .for_each(|((r1, c1), (r2, c2))| {\\n                    let t = matrix[r1][c1];\\n                    matrix[r1][c1] = matrix[r2][c2];\\n                    matrix[r2][c2] = t;\\n                })\\n            })\\n    }\\n}\\n```",
                "solutionTags": [
                    "Rust"
                ],
                "code": "```\\nimpl Solution {\\n    pub fn rotate(matrix: &mut Vec<Vec<i32>>) {\\n        matrix.reverse();\\n        for i in 1..matrix.len() {\\n            for j in 0..i {\\n                let t = matrix[i][j];\\n                matrix[i][j] = matrix[j][i];\\n                matrix[j][i] = t;\\n            }\\n        }\\n    }\\n}\\n```\n```\\nimpl Solution {\\n    pub fn rotate(matrix: &mut Vec<Vec<i32>>) {\\n        for i in 1..matrix.len() {\\n            for j in 0..i {\\n                let t = matrix[i][j];\\n                matrix[i][j] = matrix[j][i];\\n                matrix[j][i] = t;\\n            }\\n        }\\n        matrix.iter_mut().for_each(|row| row.reverse());\\n    }\\n}\\n```\n```\\nimpl Solution {\\n    pub fn rotate(matrix: &mut Vec<Vec<i32>>) {\\n        matrix.iter_mut().for_each(|row| row.reverse());\\n        let m = matrix.len();\\n        (1..m - 1)\\n            .map(|i| ((i, 0), (m - 1, m - i - 1)))\\n            .chain((0..m - 1).map(|j| ((0, j), (m - j - 1, m - 1))))\\n            .for_each(|coords| {\\n                std::iter::successors(Some(coords), |((r1, c1), (r2, c2))| {\\n                    Some(((*r1 + 1, *c1 + 1), (r2.wrapping_sub(1), c2.wrapping_sub(1))))\\n                })\\n                .take_while(|((r1, _), (r2, _))| *r1 < *r2)\\n                .for_each(|((r1, c1), (r2, c2))| {\\n                    let t = matrix[r1][c1];\\n                    matrix[r1][c1] = matrix[r2][c2];\\n                    matrix[r2][c2] = t;\\n                })\\n            })\\n    }\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2503386,
                "title": "simplest-0ms",
                "content": "Simply make transpose of matrix and then swap the first n/2 columns of matrix with last n/2 columns.\\n```\\nclass Solution {\\n    public void rotate(int[][] matrix) {\\n        \\n        transpose(matrix);\\n\\n        swap(matrix);\\n        \\n    }\\n    \\n    private static void swap(int[][] arr){\\n        int n = arr.length;\\n        int times = (n / 2) - 1;\\n\\n        for(int i=0; i<=n-1; i++){\\n            for(int j=0; j<=times; j++){\\n                int temp = arr[i][j];\\n                arr[i][j] = arr[i][n-1-j];\\n                arr[i][n-1-j] = temp;\\n            }\\n        }\\n    }\\n\\n    private static void transpose(int[][] arr){\\n        for(int i=0; i<=arr.length-1; i++){\\n            for(int j=i+1; j<=arr[i].length-1; j++){\\n                int temp = arr[i][j];\\n                arr[i][j] = arr[j][i];\\n                arr[j][i] = temp;\\n            }\\n        }\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public void rotate(int[][] matrix) {\\n        \\n        transpose(matrix);\\n\\n        swap(matrix);\\n        \\n    }\\n    \\n    private static void swap(int[][] arr){\\n        int n = arr.length;\\n        int times = (n / 2) - 1;\\n\\n        for(int i=0; i<=n-1; i++){\\n            for(int j=0; j<=times; j++){\\n                int temp = arr[i][j];\\n                arr[i][j] = arr[i][n-1-j];\\n                arr[i][n-1-j] = temp;\\n            }\\n        }\\n    }\\n\\n    private static void transpose(int[][] arr){\\n        for(int i=0; i<=arr.length-1; i++){\\n            for(int j=i+1; j<=arr[i].length-1; j++){\\n                int temp = arr[i][j];\\n                arr[i][j] = arr[j][i];\\n                arr[j][i] = temp;\\n            }\\n        }\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2503281,
                "title": "explained-and-easy-code-100-faster",
                "content": "please upvote if you like\\n```\\nclass Solution {\\n    public void rotate(int[][] matrix) {\\n        //we are finding transpose of the matrix i.e.,changing rows to column and column to rows\\n        //[1 2 3]   [1 4 7]\\n        //[4 5 6] = [2 5 8]\\n        //[7 8 9]   [3 6 9]\\n        int n=matrix.length;\\n        for(int i=0;i<n;i++){\\n            for(int j=i;j<n;j++){\\n               int temp=matrix[i][j];\\n                matrix[i][j]=matrix[j][i];\\n                matrix[j][i]=temp;\\n                \\n            }\\n            \\n        }\\n        //now if we observe properly we only need to interchange columns i.e., first col interchnge with last \\n        //col....and so on until mid of the matrix\\n        \\n        \\n        for(int i=0;i<n;i++){\\n            for(int j=0;j<n/2;j++){\\n                int temp=matrix[i][j];\\n                matrix[i][j]=matrix[i][n-1-j];\\n                matrix[i][n-1-j]=temp;\\n            }\\n        }\\n        //yipeee!! we rotated the matrix by 90 degree\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Matrix"
                ],
                "code": "```\\nclass Solution {\\n    public void rotate(int[][] matrix) {\\n        //we are finding transpose of the matrix i.e.,changing rows to column and column to rows\\n        //[1 2 3]   [1 4 7]\\n        //[4 5 6] = [2 5 8]\\n        //[7 8 9]   [3 6 9]\\n        int n=matrix.length;\\n        for(int i=0;i<n;i++){\\n            for(int j=i;j<n;j++){\\n               int temp=matrix[i][j];\\n                matrix[i][j]=matrix[j][i];\\n                matrix[j][i]=temp;\\n                \\n            }\\n            \\n        }\\n        //now if we observe properly we only need to interchange columns i.e., first col interchnge with last \\n        //col....and so on until mid of the matrix\\n        \\n        \\n        for(int i=0;i<n;i++){\\n            for(int j=0;j<n/2;j++){\\n                int temp=matrix[i][j];\\n                matrix[i][j]=matrix[i][n-1-j];\\n                matrix[i][n-1-j]=temp;\\n            }\\n        }\\n        //yipeee!! we rotated the matrix by 90 degree\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2502986,
                "title": "20-ms-python-solution-mixed-nesting-algo",
                "content": "```\\nclass Solution:\\n    def rotate(self, matrix: List[List[int]]) -> None:\\n        \"\"\"\\n        Do not return anything, modify matrix in-place instead.\\n        \"\"\"\\n        matrix.reverse()\\n        n = len(matrix)\\n        for i in range(1,n):\\n            for j in range(i):\\n                matrix[i][j], matrix[j][i] = matrix[j][i], matrix[i][j]\\n        return matrix\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution:\\n    def rotate(self, matrix: List[List[int]]) -> None:\\n        \"\"\"\\n        Do not return anything, modify matrix in-place instead.\\n        \"\"\"\\n        matrix.reverse()\\n        n = len(matrix)\\n        for i in range(1,n):\\n            for j in range(i):\\n                matrix[i][j], matrix[j][i] = matrix[j][i], matrix[i][j]\\n        return matrix\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2502646,
                "title": "java-simple-and-easy-solution-100-faster-code",
                "content": "\\tPLEASE UPVOTE IF YOU LIKE.\\n```\\nclass Solution {\\n    \\n    public static void transpose(int [][]arr){\\n        \\n       for(int i=0;i<arr.length;i++){\\n           for(int j=0;j<i;j++){\\n               int temp=arr[i][j];\\n               arr[i][j]=arr[j][i];\\n               arr[j][i]=temp;\\n           }\\n       } \\n        \\n    }\\n      public static void reverse(int [][]arr){\\n       \\n       for(int r=0;r<arr.length;r++){\\n           int l=0,right=arr.length-1;\\n          while(l<right){\\n             int temp=arr[r][l];\\n              arr[r][l]=arr[r][right];\\n              arr[r][right]=temp;\\n              l++;\\n              right--;\\n              \\n          } \\n           \\n       }   \\n          \\n}\\n    public void rotate(int[][] matrix) {\\n        \\n        \\n       transpose(matrix);\\n        reverse(matrix);\\n        \\n        \\n        \\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    \\n    public static void transpose(int [][]arr){\\n        \\n       for(int i=0;i<arr.length;i++){\\n           for(int j=0;j<i;j++){\\n               int temp=arr[i][j];\\n               arr[i][j]=arr[j][i];\\n               arr[j][i]=temp;\\n           }\\n       } \\n        \\n    }\\n      public static void reverse(int [][]arr){\\n       \\n       for(int r=0;r<arr.length;r++){\\n           int l=0,right=arr.length-1;\\n          while(l<right){\\n             int temp=arr[r][l];\\n              arr[r][l]=arr[r][right];\\n              arr[r][right]=temp;\\n              l++;\\n              right--;\\n              \\n          } \\n           \\n       }   \\n          \\n}\\n    public void rotate(int[][] matrix) {\\n        \\n        \\n       transpose(matrix);\\n        reverse(matrix);\\n        \\n        \\n        \\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2420546,
                "title": "just-in-two-steps-detailed-explanation-c-easy-approach",
                "content": "We Will Do It Just in two steps\\n**if you want to rotate the matrix 90**\\n\\t  **first -> transpose the matrix**(switch the row and column indices of the matrix )\\n\\t  **second ->reverse the columns of the matrix**(the first column will be the last on and so..)\\n \\t\\n```\\nclass Solution {\\npublic:\\n    void rotate(vector<vector<int>>& matrix) {\\n    //first transpose the matrix\\n    for(int i=0; i<matrix.size(); i++){\\n        for(int j=i; j<matrix[0].size(); j++){\\n            swap(matrix[i][j],matrix[j][i]);\\n        }\\n    }\\n    //second switch columns\\n    int i , j , k;\\n    for(i=0; i<matrix.size();i++){\\n        k = matrix[0].size()-1;\\n        for(j=0; j<matrix[0].size()/2;j++){\\n            swap(matrix[i][j],matrix[i][k--]);\\n        }\\n    }\\n}\\n//UPVOTE if it useful \\n};",
                "solutionTags": [
                    "C"
                ],
                "code": "class Solution {\\npublic:\\n    void rotate(vector<vector<int>>& matrix) {\\n    //first transpose the matrix\\n    for(int i=0; i<matrix.size(); i++){\\n        for(int j=i; j<matrix[0].size(); j++){\\n            swap(matrix[i][j],matrix[j][i]);\\n        }",
                "codeTag": "Java"
            },
            {
                "id": 2183110,
                "title": "o-n-2-t-c-o-1-s-c-python-easy",
                "content": "**Please do upvote if you find this useful and don\\'t forget to comment if you have any doubts or suggestions**\\nSo we have to rotate each element by 90deg , so generally what we have to do is\\n topleft-> top right, \\n topright->bottom right,\\n bottom right-> bottomleft\\n bottom left -> top left\\n So basically we will maintain 4 pointers top,right,left,bottom to solve this.\\n And swap them accordingly .\\n We will start l from 0 and r from last element,\\n similarly with t and b.\\n \\n ```\\n class Solution:\\n    def rotate(self, matrix: List[List[int]]) -> None:\\n        \"\"\"\\n        Do not return anything, modify matrix in-place instead.\\n        \"\"\"\\n        l,r=0,len(matrix)-1\\n        while l<r:\\n            for i in range(r-l):\\n                t,b=l,r\\n                temp=matrix[t][l+i]\\n                matrix[t][l+i]=matrix[b-i][l]\\n                matrix[b-i][l]=matrix[b][r-i]\\n                matrix[b][r-i]=matrix[t+i][r]\\n                matrix[t+i][r]=temp\\n            l+=1\\n            r-=1\\n```\\n",
                "solutionTags": [
                    "Two Pointers"
                ],
                "code": "```\\n class Solution:\\n    def rotate(self, matrix: List[List[int]]) -> None:\\n        \"\"\"\\n        Do not return anything, modify matrix in-place instead.\\n        \"\"\"\\n        l,r=0,len(matrix)-1\\n        while l<r:\\n            for i in range(r-l):\\n                t,b=l,r\\n                temp=matrix[t][l+i]\\n                matrix[t][l+i]=matrix[b-i][l]\\n                matrix[b-i][l]=matrix[b][r-i]\\n                matrix[b][r-i]=matrix[t+i][r]\\n                matrix[t+i][r]=temp\\n            l+=1\\n            r-=1\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2049385,
                "title": "c-100-simple-solution-using-just-2-flips-step-by-step-visualization",
                "content": "- The keypoint is to understand how image rotation can be decomposed into simple operations like **vertical flip, horizontal flip and diagonal flips.**\\n- For this problem, we want to rotate image clock-wise by 90 degree. I approach this problem by first tracing each element and observe where they will be ended at.\\n<img src=\"https://assets.leetcode.com/users/images/6460e971-88f9-4ba5-88f5-571e67cce49a_1652831756.4832702.png\" alt=\"drawing\" width=\"400\"/> \\n\\n- Then I figure out rotating 90-deg clockwise is same as:\\n    - First, **diagonally flip** (transpose) image along upper-left and lower-right diagonal.\\n    - Second, **horizontally flip** (mirror flip) along central.\\n <img src=\"https://assets.leetcode.com/users/images/2463e3a8-c726-482a-85d4-e03cae89d728_1652831552.283336.png\" alt=\"drawing\" width=\"600\"/> \\n\\n**Solution:**\\n```\\nvoid rotate(vector<vector<int>>& matrix) {\\n        int height = matrix.size();\\n        int width = matrix[0].size();\\n        int temp;\\n        \\n        // flip diagonally (upper-left -> lower-right)\\n        for (int i = 0; i < height; ++i) {\\n            for (int j = i+1; j < width; ++j) {\\n                // swap element\\n                temp = matrix[i][j];\\n                matrix[i][j] = matrix[j][i];\\n                matrix[j][i] = temp;\\n            }\\n        }\\n                \\n        // flip horizontally\\n        for (int i = 0; i < height; ++i) {\\n            for (int j = 0; j < width/2; ++j) {\\n                // swap element\\n                temp = matrix[i][j];\\n                matrix[i][j] = matrix[i][width-1-j];\\n                matrix[i][width-1-j] = temp;\\n            }\\n        }\\n    }\\n```\\n",
                "solutionTags": [
                    "C",
                    "Array",
                    "Matrix"
                ],
                "code": "```\\nvoid rotate(vector<vector<int>>& matrix) {\\n        int height = matrix.size();\\n        int width = matrix[0].size();\\n        int temp;\\n        \\n        // flip diagonally (upper-left -> lower-right)\\n        for (int i = 0; i < height; ++i) {\\n            for (int j = i+1; j < width; ++j) {\\n                // swap element\\n                temp = matrix[i][j];\\n                matrix[i][j] = matrix[j][i];\\n                matrix[j][i] = temp;\\n            }\\n        }\\n                \\n        // flip horizontally\\n        for (int i = 0; i < height; ++i) {\\n            for (int j = 0; j < width/2; ++j) {\\n                // swap element\\n                temp = matrix[i][j];\\n                matrix[i][j] = matrix[i][width-1-j];\\n                matrix[i][width-1-j] = temp;\\n            }\\n        }\\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1990884,
                "title": "java-c-python-javascript-kotlin-swift-o-n-time-beats-99-97-memory-speed-0ms-april-2022",
                "content": "```\\n```\\n\\n(Note: This is part of a series of Leetcode solution explanations. If you like this solution or find it useful, ***please upvote*** this post.)\\n***Take care brother, peace, love!***\\n\\n```\\n```\\n\\n```\\n```\\n\\n```\\n```\\n\\nThe best result for the code below is ***0ms / 38.2MB*** (beats 92.04% / 24.00%).\\n* ***Java***\\n```\\nclass Solution {\\n    public void rotate(int[][] M) {\\n        int n = M.length, depth = n / 2;\\n        for (int i = 0; i < depth; i++) {\\n            int len = n - 2 * i - 1, opp = n - 1 - i;\\n            for (int j = 0; j < len; j++) {\\n                int temp = M[i][i+j];\\n                M[i][i+j] = M[opp-j][i];\\n                M[opp-j][i] = M[opp][opp-j];\\n                M[opp][opp-j] = M[i+j][opp];\\n                M[i+j][opp] = temp;\\n            }\\n        }\\n    }\\n}\\n```\\n\\n```\\n```\\n\\n```\\n```\\n\\nThe best result for the code below is ***0ms / 7.0MB*** (beats 100.00% / 100.00%).\\n* ***C++***\\n```\\nclass Solution {\\npublic:\\n    void rotate(vector<vector<int>>& M) {\\n        int n = M.size(), depth = n / 2;\\n        for (int i = 0; i < depth; i++) {\\n            int len = n - 2 * i - 1, opp = n - 1 - i;\\n            for (int j = 0; j < len; j++) {\\n                int temp = M[i][i+j];\\n                M[i][i+j] = M[opp-j][i];\\n                M[opp-j][i] = M[opp][opp-j];\\n                M[opp][opp-j] = M[i+j][opp];\\n                M[i+j][opp] = temp;\\n            }\\n        }\\n    }\\n};\\n```\\n\\n```\\n```\\n\\n```\\n```\\n\\n\\nThe best result for the code below is ***26ms / 12.2MB*** (beats 95.42% / 82.32%).\\n* ***Python***\\n```\\nclass Solution:\\n    def rotate(self, M: List[List[int]]) -> None:\\n        n = len(M)\\n        depth = n // 2\\n        for i in range(depth):\\n            rlen, opp = n - 2 * i - 1, n - 1 - i\\n            for j in range(rlen):\\n                temp = M[i][i+j]\\n                M[i][i+j] = M[opp-j][i]\\n                M[opp-j][i] = M[opp][opp-j]\\n                M[opp][opp-j] = M[i+j][opp]\\n                M[i+j][opp] = temp\\n```\\n\\n```\\n```\\n\\n```\\n```\\n\\nThe best result for the code below is ***51ms / 34.2MB*** (beats 100.00% / 84.12%).\\n* ***JavaScript***\\n```\\nvar rotate = function(M) {\\n    let n = M.length, depth = ~~(n / 2)\\n    for (let i = 0; i < depth; i++) {\\n        let len = n - 2 * i - 1, opp = n - 1 - i\\n        for (let j = 0; j < len; j++) {\\n            let temp = M[i][i+j]\\n            M[i][i+j] = M[opp-j][i]\\n            M[opp-j][i] = M[opp][opp-j]\\n            M[opp][opp-j] = M[i+j][opp]\\n            M[i+j][opp] = temp\\n        }\\n    }\\n};\\n```\\n\\n```\\n```\\n\\n```\\n```\\n\\nThe best result for the code below is ***68ms / 44.2MB*** (beats 100.00% / 45.25%).\\n* ***Kotlin***\\n```\\nclass Solution {\\nfun rotate(matrix: Array): Unit {\\nvar vik=Array(matrix.size){IntArray(matrix.size)}\\nfor(i in 0..matrix.size-1)\\n{\\nvar x=matrix.size-1\\nfor(j in 0..matrix.size-1)\\n{\\nvik[i][j]=matrix[x][i]\\nx--\\n}\\n}\\nfor(i in 0..matrix.size-1)\\n{\\n\\n        for(j in 0..matrix.size-1)\\n        {\\n            matrix[i][j]=vik[i][j]\\n        }\\n    }\\n    \\n}\\n}\\n```\\n\\n```\\n```\\n\\n```\\n```\\n\\nThe best result for the code below is ***12ms / 32.2MB*** (beats 95% / 84%).\\n* ***Swift***\\n```\\nclass Solution {\\n    func rotate(_ matrix: inout [[Int]]) {\\n        let times = matrix.count / 2\\n\\n\\t\\tfor i in 0..<times {\\n\\t\\t\\tfor j in 0..<matrix.count - i * 2 - 1 {\\n\\t\\t\\t\\tlet i1 = i\\n\\t\\t\\t\\tlet i2 = i + j\\n\\t\\t\\t\\tlet i3 = matrix.count - i - 1\\n\\t\\t\\t\\tlet i4 = matrix.count - i - 1 - j\\n\\t\\t\\t\\tlet j1 = i + j\\n\\t\\t\\t\\tlet j2 = matrix.count - i - 1\\n\\t\\t\\t\\tlet j3 = matrix.count - i - 1 - j\\n\\t\\t\\t\\tlet j4 = i\\n\\t\\t\\t\\tlet n1 = matrix[i1][j1]\\n\\t\\t\\t\\tlet n2 = matrix[i2][j2]\\n\\t\\t\\t\\tlet n3 = matrix[i3][j3]\\n\\t\\t\\t\\tlet n4 = matrix[i4][j4]\\n\\t\\t\\t\\tmatrix[i1][j1] = n4\\n\\t\\t\\t\\tmatrix[i2][j2] = n1\\n\\t\\t\\t\\tmatrix[i3][j3] = n2\\n\\t\\t\\t\\tmatrix[i4][j4] = n3\\n\\t\\t\\t}\\t\\n\\t\\t}\\n    }\\n\\n}\\n```\\n\\n```\\n```\\n\\n```\\n```\\n\\n***\"Open your eyes. Expect us.\" - \\uD835\\uDCD0\\uD835\\uDCF7\\uD835\\uDCF8\\uD835\\uDCF7\\uD835\\uDD02\\uD835\\uDCF6\\uD835\\uDCF8\\uD835\\uDCFE\\uD835\\uDCFC***",
                "solutionTags": [
                    "C++",
                    "Java",
                    "Python",
                    "Python3",
                    "C",
                    "JavaScript",
                    "Swift",
                    "Kotlin"
                ],
                "code": "```\\n```\n```\\n```\n```\\n```\n```\\n```\n```\\nclass Solution {\\n    public void rotate(int[][] M) {\\n        int n = M.length, depth = n / 2;\\n        for (int i = 0; i < depth; i++) {\\n            int len = n - 2 * i - 1, opp = n - 1 - i;\\n            for (int j = 0; j < len; j++) {\\n                int temp = M[i][i+j];\\n                M[i][i+j] = M[opp-j][i];\\n                M[opp-j][i] = M[opp][opp-j];\\n                M[opp][opp-j] = M[i+j][opp];\\n                M[i+j][opp] = temp;\\n            }\\n        }\\n    }\\n}\\n```\n```\\n```\n```\\n```\n```\\nclass Solution {\\npublic:\\n    void rotate(vector<vector<int>>& M) {\\n        int n = M.size(), depth = n / 2;\\n        for (int i = 0; i < depth; i++) {\\n            int len = n - 2 * i - 1, opp = n - 1 - i;\\n            for (int j = 0; j < len; j++) {\\n                int temp = M[i][i+j];\\n                M[i][i+j] = M[opp-j][i];\\n                M[opp-j][i] = M[opp][opp-j];\\n                M[opp][opp-j] = M[i+j][opp];\\n                M[i+j][opp] = temp;\\n            }\\n        }\\n    }\\n};\\n```\n```\\n```\n```\\n```\n```\\nclass Solution:\\n    def rotate(self, M: List[List[int]]) -> None:\\n        n = len(M)\\n        depth = n // 2\\n        for i in range(depth):\\n            rlen, opp = n - 2 * i - 1, n - 1 - i\\n            for j in range(rlen):\\n                temp = M[i][i+j]\\n                M[i][i+j] = M[opp-j][i]\\n                M[opp-j][i] = M[opp][opp-j]\\n                M[opp][opp-j] = M[i+j][opp]\\n                M[i+j][opp] = temp\\n```\n```\\n```\n```\\n```\n```\\nvar rotate = function(M) {\\n    let n = M.length, depth = ~~(n / 2)\\n    for (let i = 0; i < depth; i++) {\\n        let len = n - 2 * i - 1, opp = n - 1 - i\\n        for (let j = 0; j < len; j++) {\\n            let temp = M[i][i+j]\\n            M[i][i+j] = M[opp-j][i]\\n            M[opp-j][i] = M[opp][opp-j]\\n            M[opp][opp-j] = M[i+j][opp]\\n            M[i+j][opp] = temp\\n        }\\n    }\\n};\\n```\n```\\n```\n```\\n```\n```\\nclass Solution {\\nfun rotate(matrix: Array): Unit {\\nvar vik=Array(matrix.size){IntArray(matrix.size)}\\nfor(i in 0..matrix.size-1)\\n{\\nvar x=matrix.size-1\\nfor(j in 0..matrix.size-1)\\n{\\nvik[i][j]=matrix[x][i]\\nx--\\n}\\n}\\nfor(i in 0..matrix.size-1)\\n{\\n\\n        for(j in 0..matrix.size-1)\\n        {\\n            matrix[i][j]=vik[i][j]\\n        }\\n    }\\n    \\n}\\n}\\n```\n```\\n```\n```\\n```\n```\\nclass Solution {\\n    func rotate(_ matrix: inout [[Int]]) {\\n        let times = matrix.count / 2\\n\\n\\t\\tfor i in 0..<times {\\n\\t\\t\\tfor j in 0..<matrix.count - i * 2 - 1 {\\n\\t\\t\\t\\tlet i1 = i\\n\\t\\t\\t\\tlet i2 = i + j\\n\\t\\t\\t\\tlet i3 = matrix.count - i - 1\\n\\t\\t\\t\\tlet i4 = matrix.count - i - 1 - j\\n\\t\\t\\t\\tlet j1 = i + j\\n\\t\\t\\t\\tlet j2 = matrix.count - i - 1\\n\\t\\t\\t\\tlet j3 = matrix.count - i - 1 - j\\n\\t\\t\\t\\tlet j4 = i\\n\\t\\t\\t\\tlet n1 = matrix[i1][j1]\\n\\t\\t\\t\\tlet n2 = matrix[i2][j2]\\n\\t\\t\\t\\tlet n3 = matrix[i3][j3]\\n\\t\\t\\t\\tlet n4 = matrix[i4][j4]\\n\\t\\t\\t\\tmatrix[i1][j1] = n4\\n\\t\\t\\t\\tmatrix[i2][j2] = n1\\n\\t\\t\\t\\tmatrix[i3][j3] = n2\\n\\t\\t\\t\\tmatrix[i4][j4] = n3\\n\\t\\t\\t}\\t\\n\\t\\t}\\n    }\\n\\n}\\n```\n```\\n```\n```\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1862584,
                "title": "python-easy-solution",
                "content": "```\\n    def rotate(self, matrix: List[List[int]]) -> None:\\n        \"\"\"\\n        Do not return anything, modify matrix in-place instead.\\n        \"\"\"\\n        matrix.reverse()\\n        for i in range(len(matrix)):\\n            \\n            for j in range(i+1 , len(matrix[i])):\\n                \\n                matrix[i][j] , matrix[j][i] = matrix[j][i] , matrix[i][j] \\n```",
                "solutionTags": [
                    "Python"
                ],
                "code": "```\\n    def rotate(self, matrix: List[List[int]]) -> None:\\n        \"\"\"\\n        Do not return anything, modify matrix in-place instead.\\n        \"\"\"\\n        matrix.reverse()\\n        for i in range(len(matrix)):\\n            \\n            for j in range(i+1 , len(matrix[i])):\\n                \\n                matrix[i][j] , matrix[j][i] = matrix[j][i] , matrix[i][j] \\n```",
                "codeTag": "Python3"
            },
            {
                "id": 1668284,
                "title": "c-0ms-runtime-100-faster",
                "content": "```\\nclass Solution {\\npublic:\\n    void rotate(vector<vector<int>>& matrix) {\\n        int i,j,n=matrix.size();\\n        // Transposing first\\n        for(i=0; i<n; i++) {\\n            for(j=i; j<n; j++) {\\n                swap(matrix[i][j], matrix[j][i]);\\n            }\\n        }\\n\\t\\t// Reverse each row\\n        for(int i=0; i<n;i++) {\\n            reverse(matrix[i].begin(), matrix[i].end());\\n        }\\n    }\\n};\\n```\\n**If you like the solution, please upvote**\\n**For queries, pls comment**",
                "solutionTags": [
                    "Matrix"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    void rotate(vector<vector<int>>& matrix) {\\n        int i,j,n=matrix.size();\\n        // Transposing first\\n        for(i=0; i<n; i++) {\\n            for(j=i; j<n; j++) {\\n                swap(matrix[i][j], matrix[j][i]);\\n            }\\n        }\\n\\t\\t// Reverse each row\\n        for(int i=0; i<n;i++) {\\n            reverse(matrix[i].begin(), matrix[i].end());\\n        }\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1620798,
                "title": "simple-python-solution-with-explanation-96-15",
                "content": "\\tdef rotate(self, matrix: List[List[int]]) -> None:\\n        \"\"\"\\n        Do not return anything, modify matrix in-place instead.\\n        \"\"\"\\n        self.transpose(matrix)\\n        self.reflect(matrix)\\n####     Made a function for transposing the matrix.\\n####     Here one thing to note is that the matrix will always be n x n\\n####     Will loop first through the length of the matrix\\n####    Then will start the loop from i+1 to the lenght because the i,i element will remain the same in transpose. So we don\\'t need that we need i,j element so that we can transpose it to j,i\\n\\tdef transpose(self, matrix):\\n         for i in range(len(matrix)):\\n                for j in range(i+1, len(matrix)):\\n                    matrix[i][j], matrix[j][i] = matrix[j][i], matrix[i][j]\\n    \\n    # Now we need to reverse the elements in each row i.e relecting the matrix.\\n    def reflect(self,matrix):\\n        \\n        for i in range(len(matrix)): # Looping through the length of the matrix i.e row in our case\\n            for j in range(len(matrix) // 2): # This line is the heart of the code. Because here I won\\'t be iterating through the length. We just need to interchange the element except the middle element.\\n\\t\\t\\t\\tmatrix[i][j],  matrix[i][-j-1] = matrix[i][-j-1], matrix[i][j]\\n#### Let us say that the matrix is of 5 x 5 then for this loop the interation will just go for j<2. Why just 2 iterations?\\n#### Because here we just need to replace the element at the first and second index to the element at the last and the second last index respectively.\\n#### Same will happen with matrix of any number of length.\\n   ![image](https://assets.leetcode.com/users/images/838e8f04-5442-4922-ac7d-6173891834cb_1639107696.2475529.png)\\n\\n                    \\n",
                "solutionTags": [
                    "Python"
                ],
                "code": "\\tdef rotate(self, matrix: List[List[int]]) -> None:\\n        \"\"\"\\n        Do not return anything, modify matrix in-place instead.\\n        \"\"\"\\n        self.transpose(matrix)\\n        self.reflect(matrix)\\n####     Made a function for transposing the matrix.\\n####     Here one thing to note is that the matrix will always be n x n\\n####     Will loop first through the length of the matrix\\n####    Then will start the loop from i+1 to the lenght because the i,i element will remain the same in transpose. So we don\\'t need that we need i,j element so that we can transpose it to j,i\\n\\tdef transpose(self, matrix):\\n         for i in range(len(matrix)):\\n                for j in range(i+1, len(matrix)):\\n                    matrix[i][j], matrix[j][i] = matrix[j][i], matrix[i][j]\\n    \\n    # Now we need to reverse the elements in each row i.e relecting the matrix.\\n    def reflect(self,matrix):\\n        \\n        for i in range(len(matrix)): # Looping through the length of the matrix i.e row in our case\\n            for j in range(len(matrix) // 2): # This line is the heart of the code. Because here I won\\'t be iterating through the length. We just need to interchange the element except the middle element.\\n\\t\\t\\t\\tmatrix[i][j],  matrix[i][-j-1] = matrix[i][-j-1], matrix[i][j]\\n#### Let us say that the matrix is of 5 x 5 then for this loop the interation will just go for j<2. Why just 2 iterations?\\n#### Because here we just need to replace the element at the first and second index to the element at the last and the second last index respectively.\\n#### Same will happen with matrix of any number of length.\\n   ![image](https://assets.leetcode.com/users/images/838e8f04-5442-4922-ac7d-6173891834cb_1639107696.2475529.png)\\n\\n                    \\n",
                "codeTag": "Python3"
            },
            {
                "id": 1610865,
                "title": "java-easy-solution-100-0ms",
                "content": "```\\nclass Solution {\\n    public void rotate(int[][] matrix) {\\n        for(int i =0;i<matrix.length;i++){\\n            for(int j =i+1;j<matrix.length;j++){\\n                swap(matrix,i,j);\\n            }\\n        }\\n        \\n        for(int i =0;i<matrix.length;i++){\\n            for(int  j=0;j<matrix.length/2;j++){\\n                swap1(matrix,i,j,matrix.length-1-j);\\n            }\\n        }\\n    }\\n    //for swapping rows\\n    public static void swap(int [][] arr,int i ,int j){\\n        int temp=arr[i][j];\\n        arr[i][j]=arr[j][i];\\n        arr[j][i]=temp;\\n    }\\n    //for swapping coloumns\\n    public static void swap1(int arr[][],int i ,int j,int k){\\n        int temp=arr[i][j];\\n        arr[i][j]=arr[i][k];\\n        arr[i][k]=temp;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Array"
                ],
                "code": "```\\nclass Solution {\\n    public void rotate(int[][] matrix) {\\n        for(int i =0;i<matrix.length;i++){\\n            for(int j =i+1;j<matrix.length;j++){\\n                swap(matrix,i,j);\\n            }\\n        }\\n        \\n        for(int i =0;i<matrix.length;i++){\\n            for(int  j=0;j<matrix.length/2;j++){\\n                swap1(matrix,i,j,matrix.length-1-j);\\n            }\\n        }\\n    }\\n    //for swapping rows\\n    public static void swap(int [][] arr,int i ,int j){\\n        int temp=arr[i][j];\\n        arr[i][j]=arr[j][i];\\n        arr[j][i]=temp;\\n    }\\n    //for swapping coloumns\\n    public static void swap1(int arr[][],int i ,int j,int k){\\n        int temp=arr[i][j];\\n        arr[i][j]=arr[i][k];\\n        arr[i][k]=temp;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1598546,
                "title": "javascript-short-simple-two-loops",
                "content": "```\\nvar rotate = function(matrix) {\\n    matrix.reverse();\\n\\n    for (let i = 1; i < matrix.length; i++) {\\n        for (let j = 0; j < i; j++) {\\n            //console.log((JSON.stringify(matrix)).split(\"],[\").join(\"]\\\\n[\")); //helps to visualize matrix in console\\n            [matrix[i][j], matrix[j][i]] = [matrix[j][i], matrix[i][j]];\\n        }\\n    }\\n    \\n    return matrix\\n};\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\nvar rotate = function(matrix) {\\n    matrix.reverse();\\n\\n    for (let i = 1; i < matrix.length; i++) {\\n        for (let j = 0; j < i; j++) {\\n            //console.log((JSON.stringify(matrix)).split(\"],[\").join(\"]\\\\n[\")); //helps to visualize matrix in console\\n            [matrix[i][j], matrix[j][i]] = [matrix[j][i], matrix[i][j]];\\n        }\\n    }\\n    \\n    return matrix\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1513571,
                "title": "easy-java-solution",
                "content": "\\n``` java []\\nclass Solution {\\n    public void rotate(int[][] matrix) {\\n       for(int i=0; i<matrix.length; i++){\\n           for(int j=i; j<matrix[0].length; j++){\\n               int temp = matrix[i][j];\\n               matrix[i][j] = matrix[j][i];\\n               matrix[j][i] = temp;\\n           }\\n       }\\n        for(int i=0; i<matrix.length; i++){\\n            for(int j=0; j<matrix.length/2; j++){\\n                int temp = matrix[i][j];\\n                matrix[i][j] = matrix[i][matrix.length - 1 - j];\\n                matrix[i][matrix.length - 1 - j] = temp;\\n            }\\n        }\\n    }\\n}\\n```\\n\\n```javascript []\\nvar rotate = function(matrix) {\\n    for(var i=0; i<matrix.length; i++){\\n        for(var j=i; j<matrix[0].length; j++){\\n            let temp = matrix[i][j];\\n            matrix[i][j] = matrix[j][i];\\n            matrix[j][i] = temp;\\n        }\\n    }\\n    for(var i=0; i<matrix.length; i++){\\n        for(var j=0; j<matrix[0].length/2; j++){\\n            let temp = matrix[i][j];\\n            matrix[i][j] = matrix[i][matrix[0].length-j-1];\\n            matrix[i][matrix[0].length-j-1] = temp;\\n        }\\n    }\\n};\\n```\\n",
                "solutionTags": [
                    "Java",
                    "JavaScript"
                ],
                "code": "``` java []\\nclass Solution {\\n    public void rotate(int[][] matrix) {\\n       for(int i=0; i<matrix.length; i++){\\n           for(int j=i; j<matrix[0].length; j++){\\n               int temp = matrix[i][j];\\n               matrix[i][j] = matrix[j][i];\\n               matrix[j][i] = temp;\\n           }\\n       }\\n        for(int i=0; i<matrix.length; i++){\\n            for(int j=0; j<matrix.length/2; j++){\\n                int temp = matrix[i][j];\\n                matrix[i][j] = matrix[i][matrix.length - 1 - j];\\n                matrix[i][matrix.length - 1 - j] = temp;\\n            }\\n        }\\n    }\\n}\\n```\n```javascript []\\nvar rotate = function(matrix) {\\n    for(var i=0; i<matrix.length; i++){\\n        for(var j=i; j<matrix[0].length; j++){\\n            let temp = matrix[i][j];\\n            matrix[i][j] = matrix[j][i];\\n            matrix[j][i] = temp;\\n        }\\n    }\\n    for(var i=0; i<matrix.length; i++){\\n        for(var j=0; j<matrix[0].length/2; j++){\\n            let temp = matrix[i][j];\\n            matrix[i][j] = matrix[i][matrix[0].length-j-1];\\n            matrix[i][matrix[0].length-j-1] = temp;\\n        }\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1418320,
                "title": "transpose-and-reverse-two-pointers-python-97-faster",
                "content": "\\n```\\nclass Solution:\\n    def rotate(self, matrix: List[List[int]]) -> None:\\n        \"\"\"\\n        Do not return anything, modify matrix in-place instead.\\n        \"\"\"\\n        for row in range(len(matrix)):\\n            for col in range(row, len(matrix)):\\n                matrix[row][col], matrix[col][row] = matrix[col][row], matrix[row][col]\\n\\n        for i in range(len(matrix)):\\n            pt_a, pt_b = 0, len(matrix)-1\\n            while pt_a <= pt_b:\\n                matrix[i][pt_a], matrix[i][pt_b] = matrix[i][pt_b], matrix[i][pt_a]\\n                pt_a += 1\\n                pt_b -= 1\\n        \\n```\\n\\nComplexity: O(M) + O(1) \\n",
                "solutionTags": [],
                "code": "```\\nclass Solution:\\n    def rotate(self, matrix: List[List[int]]) -> None:\\n        \"\"\"\\n        Do not return anything, modify matrix in-place instead.\\n        \"\"\"\\n        for row in range(len(matrix)):\\n            for col in range(row, len(matrix)):\\n                matrix[row][col], matrix[col][row] = matrix[col][row], matrix[row][col]\\n\\n        for i in range(len(matrix)):\\n            pt_a, pt_b = 0, len(matrix)-1\\n            while pt_a <= pt_b:\\n                matrix[i][pt_a], matrix[i][pt_b] = matrix[i][pt_b], matrix[i][pt_a]\\n                pt_a += 1\\n                pt_b -= 1\\n        \\n```",
                "codeTag": "Java"
            },
            {
                "id": 1400011,
                "title": "c-faster-than-100-runtime-0ms",
                "content": "```\\nvoid rotate(vector<vector<int>>& matrix) {\\n        int n= matrix.size();\\n     for(int i=0;i<n;i++){\\n         for(int j=0;j<i;j++){\\n             swap(matrix[i][j],matrix[j][i]);\\n         }\\n     }  \\n        \\n        for(int i=0;i<n;i++){\\n            reverse(matrix[i].begin(),matrix[i].end());\\n        }\\n    }\\n```",
                "solutionTags": [
                    "C++",
                    "C"
                ],
                "code": "```\\nvoid rotate(vector<vector<int>>& matrix) {\\n        int n= matrix.size();\\n     for(int i=0;i<n;i++){\\n         for(int j=0;j<i;j++){\\n             swap(matrix[i][j],matrix[j][i]);\\n         }\\n     }  \\n        \\n        for(int i=0;i<n;i++){\\n            reverse(matrix[i].begin(),matrix[i].end());\\n        }\\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1238431,
                "title": "simple-java-solution-with-explanation",
                "content": "```\\nclass Solution {\\n    public void rotate(int[][] matrix) {\\n        \\n        int n = matrix.length;\\n        \\n\\t\\t/* What below loop does is - gets transpose of the matrix - \\n\\t\\tmeans rows value are interchanged with column values .\\n\\t\\t1 2 3        1 4 7\\n\\t\\t4 5 6  -->   2 5 8\\n\\t\\t7 8 9        3 6 9\\n\\t\\t*/\\n        for(int i=0;i<n;i++){\\n            for(int j=0;j<=i;j++){ // j<=i - this statement here is imp - otherwise you will end up with the original matrix\\n                int temp = matrix[i][j];\\n                matrix[i][j] = matrix[j][i];\\n                matrix[j][i] = temp;\\n                \\n            }\\n        }\\n        /* Now our matrix is transposed -\\n\\t\\tso we will reverse each row individually\\n\\t\\t1 4 7           7 4 1\\n\\t\\t2 5 8    -->    8 5 2\\n\\t\\t3 6 9           9 6 3\\n\\t\\t*/\\n        for(int i=0;i<n;i++){\\n            for(int j=0;j<n/2;j++){  // j<n/2 otherwise while reversing we will end up with the original row - so reverse till half of the row\\n                int temp = matrix[i][j];\\n                matrix[i][j] = matrix[i][n-1-j];\\n                matrix[i][n-1-j] = temp;\\n            }\\n        }\\n        \\n    }\\n}\\n```\\n\\nThanks for reading - do give it a thumbs up if you like the answer. :)",
                "solutionTags": [
                    "Java",
                    "Matrix"
                ],
                "code": "```\\nclass Solution {\\n    public void rotate(int[][] matrix) {\\n        \\n        int n = matrix.length;\\n        \\n\\t\\t/* What below loop does is - gets transpose of the matrix - \\n\\t\\tmeans rows value are interchanged with column values .\\n\\t\\t1 2 3        1 4 7\\n\\t\\t4 5 6  -->   2 5 8\\n\\t\\t7 8 9        3 6 9\\n\\t\\t*/\\n        for(int i=0;i<n;i++){\\n            for(int j=0;j<=i;j++){ // j<=i - this statement here is imp - otherwise you will end up with the original matrix\\n                int temp = matrix[i][j];\\n                matrix[i][j] = matrix[j][i];\\n                matrix[j][i] = temp;\\n                \\n            }\\n        }\\n        /* Now our matrix is transposed -\\n\\t\\tso we will reverse each row individually\\n\\t\\t1 4 7           7 4 1\\n\\t\\t2 5 8    -->    8 5 2\\n\\t\\t3 6 9           9 6 3\\n\\t\\t*/\\n        for(int i=0;i<n;i++){\\n            for(int j=0;j<n/2;j++){  // j<n/2 otherwise while reversing we will end up with the original row - so reverse till half of the row\\n                int temp = matrix[i][j];\\n                matrix[i][j] = matrix[i][n-1-j];\\n                matrix[i][n-1-j] = temp;\\n            }\\n        }\\n        \\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1175516,
                "title": "c-the-simplest-easiest-4-line-solution-0-ms-faster-than-100",
                "content": "**My original solution:**\\n```\\nclass Solution {\\npublic:\\n    void rotate(vector<vector<int>>& matrix) {\\n        reverse(matrix.begin(), matrix.end());\\n        for(int i = 0; i < matrix.size(); i++)\\n        {\\n            vector<int> row = matrix[i];\\n            for(int j = i; j < matrix.size(); j++)\\n            {\\n                matrix[i][j] = matrix[j][i];\\n                matrix[j][i] = row[j];\\n            }\\n        }\\n    }\\n};\\n```\\n**Fix - This solution can be reduced to only four lines:**\\n```\\nclass Solution {\\npublic:\\n    void rotate(vector<vector<int>>& matrix) {\\n        reverse(matrix.begin(), matrix.end());\\n        for(int i = 0; i<matrix.size();i++)\\n            for(int j=i; j<matrix.size();j++)\\n                swap(matrix[i][j], matrix[j][i]);\\n    }\\n};\\n```\\n**Like it? please upvote!**",
                "solutionTags": [
                    "C"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    void rotate(vector<vector<int>>& matrix) {\\n        reverse(matrix.begin(), matrix.end());\\n        for(int i = 0; i < matrix.size(); i++)\\n        {\\n            vector<int> row = matrix[i];\\n            for(int j = i; j < matrix.size(); j++)\\n            {\\n                matrix[i][j] = matrix[j][i];\\n                matrix[j][i] = row[j];\\n            }\\n        }\\n    }\\n};\\n```\n```\\nclass Solution {\\npublic:\\n    void rotate(vector<vector<int>>& matrix) {\\n        reverse(matrix.begin(), matrix.end());\\n        for(int i = 0; i<matrix.size();i++)\\n            for(int j=i; j<matrix.size();j++)\\n                swap(matrix[i][j], matrix[j][i]);\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 818138,
                "title": "fast-python-solution",
                "content": "```\\nclass Solution:\\n    def rotate(self, matrix: list) -> None:\\n        l = len(matrix)\\n        for i in range(len(matrix) // 2):\\n            for j in range(i, len(matrix[i]) - i - 1):\\n                temp = matrix[i][j]\\n                matrix[i][j] = matrix[l - 1 - j][i]\\n                matrix[l - 1 - j][i] = matrix[l - 1 - i][l - 1 - j]\\n                matrix[l - 1 - i][l - 1 - j] = matrix[j][l - 1 - i]\\n                matrix[j][l - 1 - i] = temp\\n\\n```\\n![image](https://assets.leetcode.com/users/images/e1b453a2-96c1-4a26-b9ce-1cb67b8924b8_1598700034.229171.png)\\n",
                "solutionTags": [
                    "Python",
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def rotate(self, matrix: list) -> None:\\n        l = len(matrix)\\n        for i in range(len(matrix) // 2):\\n            for j in range(i, len(matrix[i]) - i - 1):\\n                temp = matrix[i][j]\\n                matrix[i][j] = matrix[l - 1 - j][i]\\n                matrix[l - 1 - j][i] = matrix[l - 1 - i][l - 1 - j]\\n                matrix[l - 1 - i][l - 1 - j] = matrix[j][l - 1 - i]\\n                matrix[j][l - 1 - i] = temp\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 758295,
                "title": "java-100-fast-explanation",
                "content": "If you found the solution helpful, kindly upvote or like. :)\\n\\n**MAIN IDEA**\\n1. Take the transpose of the matrix\\n2. Flip the matrix horizontally (using 2 pointer approach)\\n\\n```\\nclass Solution {\\n    public void rotate(int[][] matrix) {\\n        int n= matrix.length;\\n\\t\\tfor(int i=0; i<n; i++)\\n\\t\\t{\\n\\t\\t\\tfor(int j=i; j<n; j++)\\n\\t\\t\\t{\\n\\t\\t\\t\\t//Swapping along the diagonal\\n\\t\\t\\t\\tint temp = matrix[i][j];\\n\\t\\t\\t\\tmatrix[i][j]= matrix[j][i];\\n\\t\\t\\t\\t matrix[j][i]= temp; \\n\\t\\t\\t}\\n\\t\\t}\\n\\t\\t//Now we will flip horizontally\\n\\t\\tfor(int i=0; i<n; i++)\\n\\t\\t{\\n\\t\\t\\tfor(int j=0; j<n/2 ;j++)\\n\\t\\t\\t{\\n\\t\\t\\t\\t//We need to swap the first and the last elements\\n\\t\\t\\t\\tint temp= matrix[i][j];\\n\\t\\t\\t\\t matrix[i][j]= matrix[i][n-j-1];\\n\\t\\t\\t\\t matrix[i][n-j-1]=temp;\\n\\t\\t\\t}\\n\\t\\t}\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    public void rotate(int[][] matrix) {\\n        int n= matrix.length;\\n\\t\\tfor(int i=0; i<n; i++)\\n\\t\\t{\\n\\t\\t\\tfor(int j=i; j<n; j++)\\n\\t\\t\\t{\\n\\t\\t\\t\\t//Swapping along the diagonal\\n\\t\\t\\t\\tint temp = matrix[i][j];\\n\\t\\t\\t\\tmatrix[i][j]= matrix[j][i];\\n\\t\\t\\t\\t matrix[j][i]= temp; \\n\\t\\t\\t}\\n\\t\\t}\\n\\t\\t//Now we will flip horizontally\\n\\t\\tfor(int i=0; i<n; i++)\\n\\t\\t{\\n\\t\\t\\tfor(int j=0; j<n/2 ;j++)\\n\\t\\t\\t{\\n\\t\\t\\t\\t//We need to swap the first and the last elements\\n\\t\\t\\t\\tint temp= matrix[i][j];\\n\\t\\t\\t\\t matrix[i][j]= matrix[i][n-j-1];\\n\\t\\t\\t\\t matrix[i][n-j-1]=temp;\\n\\t\\t\\t}\\n\\t\\t}\\n    }\\n}\\n```",
                "codeTag": "Java"
            }
        ],
        "discussions": [
            {
                "id": 1570087,
                "content": [
                    {
                        "username": "LazyBanda",
                        "content": "I was asked this problem in Amazon for SDE III. I had hardly 25 mins to solve. Since in online interview, first 10 mins went into setup because my interviewer wasnt getting signals. next 25 mins for behavioural. and then this question. Its a tricky problem, nort sure what a company will check with this question. Probably my memorization technique."
                    },
                    {
                        "username": "rquant",
                        "content": "This is a hard problem to solve on the fly. Either you\\'re a genius or you practiced this problem on LeetCode enough I guess."
                    },
                    {
                        "username": "aldogg",
                        "content": "I know your pain. It took me 2 hours to solve it today without looking for the solution :("
                    },
                    {
                        "username": "chiranthanmirle",
                        "content": "![image](https://assets.leetcode.com/users/images/88356185-85ab-4f53-afcb-d7512abc311e_1607548471.039209.png)\\nSorry for the bad images. I am terrible at it.\\n\\nTranspose: Basically run a line from top left to bottom right as shown. Flip the 2 parts around the line.\\n\\nReverse: Flip the whole image around a line to the left or right."
                    },
                    {
                        "username": "wtfcoder",
                        "content": "[@satyamS_71](/satyamS_71)  Reversing every row and transpose is gonna do it "
                    },
                    {
                        "username": "shakthisri",
                        "content": "it totally gave me a different view! thank you"
                    },
                    {
                        "username": "Msey",
                        "content": "[@satyamS_71](/satyamS_71) easiest way to use this trick is to present -90 degree as +270, 270 is a 90 degree three times etc"
                    },
                    {
                        "username": "satyamS_71",
                        "content": "Thanks it helped me a lot , but what if the question asks to rotate the image counter clockwise , then how should I approach the problem?"
                    },
                    {
                        "username": "HarshitGupta_02",
                        "content": "class Solution {\\npublic:\\n    void rotate(vector<vector<int>>& matrix) {\\n        int n=matrix.size();\\n        for(int i=0;i<n;i++){\\n            for(int j=0;j<=i;j++){\\n                swap(matrix[i][j],matrix[j][i]);\\n            }\\n        }\\n        for(int i=0;i<n;i++){\\n            int j=0;\\n            int k=n-1;\\n            while(j<=n/2 && k>=n/2){\\n                swap(matrix[i][j],matrix[i][k]);\\n                j++;\\n                k--;\\n            }\\n        }\\n    }\\n};"
                    },
                    {
                        "username": "Bobzero",
                        "content": "I\\'m always having fun reading the discussions \\uD83D\\uDE03"
                    },
                    {
                        "username": "charlesxiao2",
                        "content": "This post is for rotating the matrix anticlockwise. Sorry, when I post it I didn\\'t notice it. But please read it, because I guarantee you can understand the thought process and came up with your solution for clockwise rotation.\\n\\nSo, we are required to rotate it in place. \\n\\nGive a matrix, there are several operations can be done in matrix in place:\\n\\ntranslation, and swap symmetrically(mirror against diagnal), and probaly some unexpected in place operations.\\n\\nWe are trying to break the rotation operation into these operations that are know to carry on easily in place.\\n\\nFor swap symmetrically, given coordinate (a,b), it will be swapped to (b,a) if following the upper left and buttom right diagnal as mirror.\\nFor translation, given coordinate (a, b), we are able to traslate it to (a, whatever) or (whatever, b) with ease.\\n\\nIf rotated anticlockwise, element at (a,b) will be transfered to the new coordinate of (s-b-1 ,a) with s being the length or width of the matrix.\\nWe are trying to find out the in place operations needed in order to transform the coordinate from (a, b) to (s-b-1, a), with some fundumantal operations\\' coordinate transformation characteristics in mind.\\n\\nwe are trying to fill in the logic path between (a, b) to (s-b-1, a) using the fundamental operations.\\n\\nLet\\'s try to fill the logic break reversely:\\nto get to (s-b-1, a) from (a, b), notice a is swapped, we guess the last operation may be mirror against diagnal. so the path now becomes:\\n(a,b) -> (a, s-b-1) -> (s-b-1, a)//the last mirror can be easily done in place\\n\\nNow we try, how to get to (a, s-b-1) from (a, b) using fundamental in place operations? Well, draw a matrix, and you find out that this is not translation, but some swapping too. Don\\'t worry, you see the operations does not change the row coordinate, so it can be done in place with ease. And you know at this point you design the algorithm for this problem.\\n\\nThis is how the logic flows trying to design the in place algorithm to rotate n*n matrix.\\nBasically, we are trying to break down the operations into easy atomic in place operations. How to break down? Analyze the coordinate characteristics with some basic patterns in mind.\\n\\n"
                    },
                    {
                        "username": "UmerZia",
                        "content": "What If we do not have the diagonal, Just thinking about more dynamic solution!"
                    },
                    {
                        "username": "k3000001",
                        "content": "What exactly does it help measure? That the candidate can remember the trick of swapping rows?"
                    },
                    {
                        "username": "MiliMakwana",
                        "content": "[@Nandhini-Techie](/Nandhini-Techie)  Extra space bro\\n"
                    },
                    {
                        "username": "Nandhini-Techie",
                        "content": "  for (int i = 0; i < matrix.length; i++) {\\n      List<int> subList = [];\\n      for (int j = matrix.length - 1; j >= 0; j--) {\\n        subList.add(matrix[j][i]);\\n      }\\n      output.add(subList);\\n    }"
                    },
                    {
                        "username": "betrayy",
                        "content": "Was thinking the same.. this question is pretty much free if you just memorize it"
                    },
                    {
                        "username": "dkode",
                        "content": "Diagram:\\n\\n![image](https://assets.leetcode.com/users/images/95016c57-f112-4e79-8be7-0f21c814c800_1630583198.7966883.png)\\n\\n# M[i,j] --> M\\'[j,N-1-i]\\n\\nWe know that transpose relation is \\n#### M[i,j]= M[j,i]\\n#### \\n\\nBut the relation we got is slightly differernt\\n\\nThink how to convert\\nM[i,j] to M[N-1-i,j]\\n\\nThis is equivalent to flipping the matrix horizontally.\\n\\nM[i,j] to M[N-1-i,j]\\n\\nTranspose (M[N-1-i,j]) --> M\\'[j,N-1-i]\\n\\nTranspose and flipping are linear operation\\n\\nSimilary you can solve other cases like 90 degree, 180 degree, 270 degree etc\\n\\n\\n"
                    },
                    {
                        "username": "paras178a",
                        "content": "[@user7617Dm](/user7617Dm) If i is zero, then index will you be at for N+1-i ?"
                    },
                    {
                        "username": "user7617Dm",
                        "content": "why is it N-1-i not N+1-i? If N is 4 for a 4x4 matric"
                    },
                    {
                        "username": "StefanPochmann",
                        "content": "    def rotate(matrix)\\n      matrix.replace(matrix.reverse.transpose)\\n    end\\n\\nI like Ruby's wordy style."
                    },
                    {
                        "username": "cbertake",
                        "content": "when will you stop posting solution in discussion?\\n"
                    },
                    {
                        "username": "deadsec",
                        "content": "\\uD83D\\uDE02 Amazon Recruiter => You have been hired."
                    },
                    {
                        "username": "UmerZia",
                        "content": "[@Brut_all](/Brut_all) Definitely Not! "
                    },
                    {
                        "username": "Brut_all",
                        "content": "But the interviwer might not like \\uD83E\\uDD10"
                    },
                    {
                        "username": "chris3109692",
                        "content": "The complexity analyses in the solution is incorrect. For a NxN matrix, the complexity is O(N^2), but our data size is N^2 by itself, hence the proper way to denote complexity should be O(n). Note big O is always measured against the data size, not the dimension size."
                    },
                    {
                        "username": "Triquetra",
                        "content": "Complexity is an equivalence class of functions, it can be expressed as a function of any variable."
                    },
                    {
                        "username": "WilmerKrisp",
                        "content": "# solution 1\\n\\n![image](https://assets.leetcode.com/users/images/e112c117-97a6-431c-99e9-c2b2ca3b84c5_1597576604.2278848.png)\\n\\n![image](https://assets.leetcode.com/users/images/18ce4afa-3e8d-4943-856c-a59d781def40_1597576610.36345.png)\\n\\n\\n# solution 2 (inplace modification)\\n![image](https://assets.leetcode.com/users/images/9f7d86fb-cde6-4760-8088-b683bb52160f_1597580296.4229963.png)\\n\\n![image](https://assets.leetcode.com/users/images/58888c0c-c0b7-4fee-9f8d-537ef2681f0a_1597580313.7932537.png)\\n"
                    },
                    {
                        "username": "Ayush_PY",
                        "content": "Using a second matrix is not allowed"
                    },
                    {
                        "username": "bnuzhanyu",
                        "content": "I had been asked this question in an interview:\\n\\ngiven an R x C  matrix,  rotate 90 degree clockwise **in place** (with constant extra space).\\n**The matrix is given as an array**, you should do this within the array.\\nExample: \\u3002\\ninput: R = 3, C = 4, array = 1 2 3 4 5 6 7 8 9 10 11 12\\noutput: R = 4, C = 3, array = 9 5 1 10 6 2 11 7 3 12 8 4\\n\\nexplaination:\\nthe input matrix is:\\n1 2 3 4\\n5 6 7 8\\n9 10 11 12\\nthe output matrix is:\\n9 5 1\\n10 6 2\\n11 7 3\\n12 8 4\\n\\nThough I have got an idea of solving this problem, but the time complexity is not O(RxC)\\u3002\\nCan anyone got an O(RxC) solution with O(1) space?\\n\\n\\n"
                    },
                    {
                        "username": "mawhadmd",
                        "content": "That\\'s possible to do in place?"
                    },
                    {
                        "username": "anmol_soniii",
                        "content": "T.C = O( R*C )\\nS.C = O(1) [ in place ]\\nsolution:\\nclass Solution {\\npublic:\\n    void rotate(vector<vector<int>>& matrix) {\\n        int row = matrix.size();\\n        int col = matrix[0].size();\\n\\n        for(int i = 0; i<row ;i++){\\n            int j = 0;\\n            while( j<i ){\\n                swap(matrix[i][j],matrix[j][i]);\\n                j++;\\n            }\\n        }\\n\\n        for(int i = 0 ; i < row ; i++){\\n            int n = 0;\\n            int m = col-1;\\n            while(n<m){\\n                swap(matrix[i][n],matrix[i][m]);\\n                n++;\\n                m--;\\n            }\\n        }\\n    }\\n};"
                    },
                    {
                        "username": "chinnamsaireddy1369",
                        "content": "how can u do this without space, this question itself asking to alter given m x n matrix to n x m matrix, then without using new matrix how will you insert n x m into m x n"
                    },
                    {
                        "username": "him_Sarma619",
                        "content": "This is actually a pretty good question.... I\\'m not able to think of a solution for this, if you don\\'t mind can you please provide the solution for the same ?"
                    }
                ]
            },
            {
                "id": 1574669,
                "content": [
                    {
                        "username": "LazyBanda",
                        "content": "I was asked this problem in Amazon for SDE III. I had hardly 25 mins to solve. Since in online interview, first 10 mins went into setup because my interviewer wasnt getting signals. next 25 mins for behavioural. and then this question. Its a tricky problem, nort sure what a company will check with this question. Probably my memorization technique."
                    },
                    {
                        "username": "rquant",
                        "content": "This is a hard problem to solve on the fly. Either you\\'re a genius or you practiced this problem on LeetCode enough I guess."
                    },
                    {
                        "username": "aldogg",
                        "content": "I know your pain. It took me 2 hours to solve it today without looking for the solution :("
                    },
                    {
                        "username": "chiranthanmirle",
                        "content": "![image](https://assets.leetcode.com/users/images/88356185-85ab-4f53-afcb-d7512abc311e_1607548471.039209.png)\\nSorry for the bad images. I am terrible at it.\\n\\nTranspose: Basically run a line from top left to bottom right as shown. Flip the 2 parts around the line.\\n\\nReverse: Flip the whole image around a line to the left or right."
                    },
                    {
                        "username": "wtfcoder",
                        "content": "[@satyamS_71](/satyamS_71)  Reversing every row and transpose is gonna do it "
                    },
                    {
                        "username": "shakthisri",
                        "content": "it totally gave me a different view! thank you"
                    },
                    {
                        "username": "Msey",
                        "content": "[@satyamS_71](/satyamS_71) easiest way to use this trick is to present -90 degree as +270, 270 is a 90 degree three times etc"
                    },
                    {
                        "username": "satyamS_71",
                        "content": "Thanks it helped me a lot , but what if the question asks to rotate the image counter clockwise , then how should I approach the problem?"
                    },
                    {
                        "username": "HarshitGupta_02",
                        "content": "class Solution {\\npublic:\\n    void rotate(vector<vector<int>>& matrix) {\\n        int n=matrix.size();\\n        for(int i=0;i<n;i++){\\n            for(int j=0;j<=i;j++){\\n                swap(matrix[i][j],matrix[j][i]);\\n            }\\n        }\\n        for(int i=0;i<n;i++){\\n            int j=0;\\n            int k=n-1;\\n            while(j<=n/2 && k>=n/2){\\n                swap(matrix[i][j],matrix[i][k]);\\n                j++;\\n                k--;\\n            }\\n        }\\n    }\\n};"
                    },
                    {
                        "username": "Bobzero",
                        "content": "I\\'m always having fun reading the discussions \\uD83D\\uDE03"
                    },
                    {
                        "username": "charlesxiao2",
                        "content": "This post is for rotating the matrix anticlockwise. Sorry, when I post it I didn\\'t notice it. But please read it, because I guarantee you can understand the thought process and came up with your solution for clockwise rotation.\\n\\nSo, we are required to rotate it in place. \\n\\nGive a matrix, there are several operations can be done in matrix in place:\\n\\ntranslation, and swap symmetrically(mirror against diagnal), and probaly some unexpected in place operations.\\n\\nWe are trying to break the rotation operation into these operations that are know to carry on easily in place.\\n\\nFor swap symmetrically, given coordinate (a,b), it will be swapped to (b,a) if following the upper left and buttom right diagnal as mirror.\\nFor translation, given coordinate (a, b), we are able to traslate it to (a, whatever) or (whatever, b) with ease.\\n\\nIf rotated anticlockwise, element at (a,b) will be transfered to the new coordinate of (s-b-1 ,a) with s being the length or width of the matrix.\\nWe are trying to find out the in place operations needed in order to transform the coordinate from (a, b) to (s-b-1, a), with some fundumantal operations\\' coordinate transformation characteristics in mind.\\n\\nwe are trying to fill in the logic path between (a, b) to (s-b-1, a) using the fundamental operations.\\n\\nLet\\'s try to fill the logic break reversely:\\nto get to (s-b-1, a) from (a, b), notice a is swapped, we guess the last operation may be mirror against diagnal. so the path now becomes:\\n(a,b) -> (a, s-b-1) -> (s-b-1, a)//the last mirror can be easily done in place\\n\\nNow we try, how to get to (a, s-b-1) from (a, b) using fundamental in place operations? Well, draw a matrix, and you find out that this is not translation, but some swapping too. Don\\'t worry, you see the operations does not change the row coordinate, so it can be done in place with ease. And you know at this point you design the algorithm for this problem.\\n\\nThis is how the logic flows trying to design the in place algorithm to rotate n*n matrix.\\nBasically, we are trying to break down the operations into easy atomic in place operations. How to break down? Analyze the coordinate characteristics with some basic patterns in mind.\\n\\n"
                    },
                    {
                        "username": "UmerZia",
                        "content": "What If we do not have the diagonal, Just thinking about more dynamic solution!"
                    },
                    {
                        "username": "k3000001",
                        "content": "What exactly does it help measure? That the candidate can remember the trick of swapping rows?"
                    },
                    {
                        "username": "MiliMakwana",
                        "content": "[@Nandhini-Techie](/Nandhini-Techie)  Extra space bro\\n"
                    },
                    {
                        "username": "Nandhini-Techie",
                        "content": "  for (int i = 0; i < matrix.length; i++) {\\n      List<int> subList = [];\\n      for (int j = matrix.length - 1; j >= 0; j--) {\\n        subList.add(matrix[j][i]);\\n      }\\n      output.add(subList);\\n    }"
                    },
                    {
                        "username": "betrayy",
                        "content": "Was thinking the same.. this question is pretty much free if you just memorize it"
                    },
                    {
                        "username": "dkode",
                        "content": "Diagram:\\n\\n![image](https://assets.leetcode.com/users/images/95016c57-f112-4e79-8be7-0f21c814c800_1630583198.7966883.png)\\n\\n# M[i,j] --> M\\'[j,N-1-i]\\n\\nWe know that transpose relation is \\n#### M[i,j]= M[j,i]\\n#### \\n\\nBut the relation we got is slightly differernt\\n\\nThink how to convert\\nM[i,j] to M[N-1-i,j]\\n\\nThis is equivalent to flipping the matrix horizontally.\\n\\nM[i,j] to M[N-1-i,j]\\n\\nTranspose (M[N-1-i,j]) --> M\\'[j,N-1-i]\\n\\nTranspose and flipping are linear operation\\n\\nSimilary you can solve other cases like 90 degree, 180 degree, 270 degree etc\\n\\n\\n"
                    },
                    {
                        "username": "paras178a",
                        "content": "[@user7617Dm](/user7617Dm) If i is zero, then index will you be at for N+1-i ?"
                    },
                    {
                        "username": "user7617Dm",
                        "content": "why is it N-1-i not N+1-i? If N is 4 for a 4x4 matric"
                    },
                    {
                        "username": "StefanPochmann",
                        "content": "    def rotate(matrix)\\n      matrix.replace(matrix.reverse.transpose)\\n    end\\n\\nI like Ruby's wordy style."
                    },
                    {
                        "username": "cbertake",
                        "content": "when will you stop posting solution in discussion?\\n"
                    },
                    {
                        "username": "deadsec",
                        "content": "\\uD83D\\uDE02 Amazon Recruiter => You have been hired."
                    },
                    {
                        "username": "UmerZia",
                        "content": "[@Brut_all](/Brut_all) Definitely Not! "
                    },
                    {
                        "username": "Brut_all",
                        "content": "But the interviwer might not like \\uD83E\\uDD10"
                    },
                    {
                        "username": "chris3109692",
                        "content": "The complexity analyses in the solution is incorrect. For a NxN matrix, the complexity is O(N^2), but our data size is N^2 by itself, hence the proper way to denote complexity should be O(n). Note big O is always measured against the data size, not the dimension size."
                    },
                    {
                        "username": "Triquetra",
                        "content": "Complexity is an equivalence class of functions, it can be expressed as a function of any variable."
                    },
                    {
                        "username": "WilmerKrisp",
                        "content": "# solution 1\\n\\n![image](https://assets.leetcode.com/users/images/e112c117-97a6-431c-99e9-c2b2ca3b84c5_1597576604.2278848.png)\\n\\n![image](https://assets.leetcode.com/users/images/18ce4afa-3e8d-4943-856c-a59d781def40_1597576610.36345.png)\\n\\n\\n# solution 2 (inplace modification)\\n![image](https://assets.leetcode.com/users/images/9f7d86fb-cde6-4760-8088-b683bb52160f_1597580296.4229963.png)\\n\\n![image](https://assets.leetcode.com/users/images/58888c0c-c0b7-4fee-9f8d-537ef2681f0a_1597580313.7932537.png)\\n"
                    },
                    {
                        "username": "Ayush_PY",
                        "content": "Using a second matrix is not allowed"
                    },
                    {
                        "username": "bnuzhanyu",
                        "content": "I had been asked this question in an interview:\\n\\ngiven an R x C  matrix,  rotate 90 degree clockwise **in place** (with constant extra space).\\n**The matrix is given as an array**, you should do this within the array.\\nExample: \\u3002\\ninput: R = 3, C = 4, array = 1 2 3 4 5 6 7 8 9 10 11 12\\noutput: R = 4, C = 3, array = 9 5 1 10 6 2 11 7 3 12 8 4\\n\\nexplaination:\\nthe input matrix is:\\n1 2 3 4\\n5 6 7 8\\n9 10 11 12\\nthe output matrix is:\\n9 5 1\\n10 6 2\\n11 7 3\\n12 8 4\\n\\nThough I have got an idea of solving this problem, but the time complexity is not O(RxC)\\u3002\\nCan anyone got an O(RxC) solution with O(1) space?\\n\\n\\n"
                    },
                    {
                        "username": "mawhadmd",
                        "content": "That\\'s possible to do in place?"
                    },
                    {
                        "username": "anmol_soniii",
                        "content": "T.C = O( R*C )\\nS.C = O(1) [ in place ]\\nsolution:\\nclass Solution {\\npublic:\\n    void rotate(vector<vector<int>>& matrix) {\\n        int row = matrix.size();\\n        int col = matrix[0].size();\\n\\n        for(int i = 0; i<row ;i++){\\n            int j = 0;\\n            while( j<i ){\\n                swap(matrix[i][j],matrix[j][i]);\\n                j++;\\n            }\\n        }\\n\\n        for(int i = 0 ; i < row ; i++){\\n            int n = 0;\\n            int m = col-1;\\n            while(n<m){\\n                swap(matrix[i][n],matrix[i][m]);\\n                n++;\\n                m--;\\n            }\\n        }\\n    }\\n};"
                    },
                    {
                        "username": "chinnamsaireddy1369",
                        "content": "how can u do this without space, this question itself asking to alter given m x n matrix to n x m matrix, then without using new matrix how will you insert n x m into m x n"
                    },
                    {
                        "username": "him_Sarma619",
                        "content": "This is actually a pretty good question.... I\\'m not able to think of a solution for this, if you don\\'t mind can you please provide the solution for the same ?"
                    }
                ]
            },
            {
                "id": 1698940,
                "content": [
                    {
                        "username": "LazyBanda",
                        "content": "I was asked this problem in Amazon for SDE III. I had hardly 25 mins to solve. Since in online interview, first 10 mins went into setup because my interviewer wasnt getting signals. next 25 mins for behavioural. and then this question. Its a tricky problem, nort sure what a company will check with this question. Probably my memorization technique."
                    },
                    {
                        "username": "rquant",
                        "content": "This is a hard problem to solve on the fly. Either you\\'re a genius or you practiced this problem on LeetCode enough I guess."
                    },
                    {
                        "username": "aldogg",
                        "content": "I know your pain. It took me 2 hours to solve it today without looking for the solution :("
                    },
                    {
                        "username": "chiranthanmirle",
                        "content": "![image](https://assets.leetcode.com/users/images/88356185-85ab-4f53-afcb-d7512abc311e_1607548471.039209.png)\\nSorry for the bad images. I am terrible at it.\\n\\nTranspose: Basically run a line from top left to bottom right as shown. Flip the 2 parts around the line.\\n\\nReverse: Flip the whole image around a line to the left or right."
                    },
                    {
                        "username": "wtfcoder",
                        "content": "[@satyamS_71](/satyamS_71)  Reversing every row and transpose is gonna do it "
                    },
                    {
                        "username": "shakthisri",
                        "content": "it totally gave me a different view! thank you"
                    },
                    {
                        "username": "Msey",
                        "content": "[@satyamS_71](/satyamS_71) easiest way to use this trick is to present -90 degree as +270, 270 is a 90 degree three times etc"
                    },
                    {
                        "username": "satyamS_71",
                        "content": "Thanks it helped me a lot , but what if the question asks to rotate the image counter clockwise , then how should I approach the problem?"
                    },
                    {
                        "username": "HarshitGupta_02",
                        "content": "class Solution {\\npublic:\\n    void rotate(vector<vector<int>>& matrix) {\\n        int n=matrix.size();\\n        for(int i=0;i<n;i++){\\n            for(int j=0;j<=i;j++){\\n                swap(matrix[i][j],matrix[j][i]);\\n            }\\n        }\\n        for(int i=0;i<n;i++){\\n            int j=0;\\n            int k=n-1;\\n            while(j<=n/2 && k>=n/2){\\n                swap(matrix[i][j],matrix[i][k]);\\n                j++;\\n                k--;\\n            }\\n        }\\n    }\\n};"
                    },
                    {
                        "username": "Bobzero",
                        "content": "I\\'m always having fun reading the discussions \\uD83D\\uDE03"
                    },
                    {
                        "username": "charlesxiao2",
                        "content": "This post is for rotating the matrix anticlockwise. Sorry, when I post it I didn\\'t notice it. But please read it, because I guarantee you can understand the thought process and came up with your solution for clockwise rotation.\\n\\nSo, we are required to rotate it in place. \\n\\nGive a matrix, there are several operations can be done in matrix in place:\\n\\ntranslation, and swap symmetrically(mirror against diagnal), and probaly some unexpected in place operations.\\n\\nWe are trying to break the rotation operation into these operations that are know to carry on easily in place.\\n\\nFor swap symmetrically, given coordinate (a,b), it will be swapped to (b,a) if following the upper left and buttom right diagnal as mirror.\\nFor translation, given coordinate (a, b), we are able to traslate it to (a, whatever) or (whatever, b) with ease.\\n\\nIf rotated anticlockwise, element at (a,b) will be transfered to the new coordinate of (s-b-1 ,a) with s being the length or width of the matrix.\\nWe are trying to find out the in place operations needed in order to transform the coordinate from (a, b) to (s-b-1, a), with some fundumantal operations\\' coordinate transformation characteristics in mind.\\n\\nwe are trying to fill in the logic path between (a, b) to (s-b-1, a) using the fundamental operations.\\n\\nLet\\'s try to fill the logic break reversely:\\nto get to (s-b-1, a) from (a, b), notice a is swapped, we guess the last operation may be mirror against diagnal. so the path now becomes:\\n(a,b) -> (a, s-b-1) -> (s-b-1, a)//the last mirror can be easily done in place\\n\\nNow we try, how to get to (a, s-b-1) from (a, b) using fundamental in place operations? Well, draw a matrix, and you find out that this is not translation, but some swapping too. Don\\'t worry, you see the operations does not change the row coordinate, so it can be done in place with ease. And you know at this point you design the algorithm for this problem.\\n\\nThis is how the logic flows trying to design the in place algorithm to rotate n*n matrix.\\nBasically, we are trying to break down the operations into easy atomic in place operations. How to break down? Analyze the coordinate characteristics with some basic patterns in mind.\\n\\n"
                    },
                    {
                        "username": "UmerZia",
                        "content": "What If we do not have the diagonal, Just thinking about more dynamic solution!"
                    },
                    {
                        "username": "k3000001",
                        "content": "What exactly does it help measure? That the candidate can remember the trick of swapping rows?"
                    },
                    {
                        "username": "MiliMakwana",
                        "content": "[@Nandhini-Techie](/Nandhini-Techie)  Extra space bro\\n"
                    },
                    {
                        "username": "Nandhini-Techie",
                        "content": "  for (int i = 0; i < matrix.length; i++) {\\n      List<int> subList = [];\\n      for (int j = matrix.length - 1; j >= 0; j--) {\\n        subList.add(matrix[j][i]);\\n      }\\n      output.add(subList);\\n    }"
                    },
                    {
                        "username": "betrayy",
                        "content": "Was thinking the same.. this question is pretty much free if you just memorize it"
                    },
                    {
                        "username": "dkode",
                        "content": "Diagram:\\n\\n![image](https://assets.leetcode.com/users/images/95016c57-f112-4e79-8be7-0f21c814c800_1630583198.7966883.png)\\n\\n# M[i,j] --> M\\'[j,N-1-i]\\n\\nWe know that transpose relation is \\n#### M[i,j]= M[j,i]\\n#### \\n\\nBut the relation we got is slightly differernt\\n\\nThink how to convert\\nM[i,j] to M[N-1-i,j]\\n\\nThis is equivalent to flipping the matrix horizontally.\\n\\nM[i,j] to M[N-1-i,j]\\n\\nTranspose (M[N-1-i,j]) --> M\\'[j,N-1-i]\\n\\nTranspose and flipping are linear operation\\n\\nSimilary you can solve other cases like 90 degree, 180 degree, 270 degree etc\\n\\n\\n"
                    },
                    {
                        "username": "paras178a",
                        "content": "[@user7617Dm](/user7617Dm) If i is zero, then index will you be at for N+1-i ?"
                    },
                    {
                        "username": "user7617Dm",
                        "content": "why is it N-1-i not N+1-i? If N is 4 for a 4x4 matric"
                    },
                    {
                        "username": "StefanPochmann",
                        "content": "    def rotate(matrix)\\n      matrix.replace(matrix.reverse.transpose)\\n    end\\n\\nI like Ruby's wordy style."
                    },
                    {
                        "username": "cbertake",
                        "content": "when will you stop posting solution in discussion?\\n"
                    },
                    {
                        "username": "deadsec",
                        "content": "\\uD83D\\uDE02 Amazon Recruiter => You have been hired."
                    },
                    {
                        "username": "UmerZia",
                        "content": "[@Brut_all](/Brut_all) Definitely Not! "
                    },
                    {
                        "username": "Brut_all",
                        "content": "But the interviwer might not like \\uD83E\\uDD10"
                    },
                    {
                        "username": "chris3109692",
                        "content": "The complexity analyses in the solution is incorrect. For a NxN matrix, the complexity is O(N^2), but our data size is N^2 by itself, hence the proper way to denote complexity should be O(n). Note big O is always measured against the data size, not the dimension size."
                    },
                    {
                        "username": "Triquetra",
                        "content": "Complexity is an equivalence class of functions, it can be expressed as a function of any variable."
                    },
                    {
                        "username": "WilmerKrisp",
                        "content": "# solution 1\\n\\n![image](https://assets.leetcode.com/users/images/e112c117-97a6-431c-99e9-c2b2ca3b84c5_1597576604.2278848.png)\\n\\n![image](https://assets.leetcode.com/users/images/18ce4afa-3e8d-4943-856c-a59d781def40_1597576610.36345.png)\\n\\n\\n# solution 2 (inplace modification)\\n![image](https://assets.leetcode.com/users/images/9f7d86fb-cde6-4760-8088-b683bb52160f_1597580296.4229963.png)\\n\\n![image](https://assets.leetcode.com/users/images/58888c0c-c0b7-4fee-9f8d-537ef2681f0a_1597580313.7932537.png)\\n"
                    },
                    {
                        "username": "Ayush_PY",
                        "content": "Using a second matrix is not allowed"
                    },
                    {
                        "username": "bnuzhanyu",
                        "content": "I had been asked this question in an interview:\\n\\ngiven an R x C  matrix,  rotate 90 degree clockwise **in place** (with constant extra space).\\n**The matrix is given as an array**, you should do this within the array.\\nExample: \\u3002\\ninput: R = 3, C = 4, array = 1 2 3 4 5 6 7 8 9 10 11 12\\noutput: R = 4, C = 3, array = 9 5 1 10 6 2 11 7 3 12 8 4\\n\\nexplaination:\\nthe input matrix is:\\n1 2 3 4\\n5 6 7 8\\n9 10 11 12\\nthe output matrix is:\\n9 5 1\\n10 6 2\\n11 7 3\\n12 8 4\\n\\nThough I have got an idea of solving this problem, but the time complexity is not O(RxC)\\u3002\\nCan anyone got an O(RxC) solution with O(1) space?\\n\\n\\n"
                    },
                    {
                        "username": "mawhadmd",
                        "content": "That\\'s possible to do in place?"
                    },
                    {
                        "username": "anmol_soniii",
                        "content": "T.C = O( R*C )\\nS.C = O(1) [ in place ]\\nsolution:\\nclass Solution {\\npublic:\\n    void rotate(vector<vector<int>>& matrix) {\\n        int row = matrix.size();\\n        int col = matrix[0].size();\\n\\n        for(int i = 0; i<row ;i++){\\n            int j = 0;\\n            while( j<i ){\\n                swap(matrix[i][j],matrix[j][i]);\\n                j++;\\n            }\\n        }\\n\\n        for(int i = 0 ; i < row ; i++){\\n            int n = 0;\\n            int m = col-1;\\n            while(n<m){\\n                swap(matrix[i][n],matrix[i][m]);\\n                n++;\\n                m--;\\n            }\\n        }\\n    }\\n};"
                    },
                    {
                        "username": "chinnamsaireddy1369",
                        "content": "how can u do this without space, this question itself asking to alter given m x n matrix to n x m matrix, then without using new matrix how will you insert n x m into m x n"
                    },
                    {
                        "username": "him_Sarma619",
                        "content": "This is actually a pretty good question.... I\\'m not able to think of a solution for this, if you don\\'t mind can you please provide the solution for the same ?"
                    }
                ]
            },
            {
                "id": 1566321,
                "content": [
                    {
                        "username": "LazyBanda",
                        "content": "I was asked this problem in Amazon for SDE III. I had hardly 25 mins to solve. Since in online interview, first 10 mins went into setup because my interviewer wasnt getting signals. next 25 mins for behavioural. and then this question. Its a tricky problem, nort sure what a company will check with this question. Probably my memorization technique."
                    },
                    {
                        "username": "rquant",
                        "content": "This is a hard problem to solve on the fly. Either you\\'re a genius or you practiced this problem on LeetCode enough I guess."
                    },
                    {
                        "username": "aldogg",
                        "content": "I know your pain. It took me 2 hours to solve it today without looking for the solution :("
                    },
                    {
                        "username": "chiranthanmirle",
                        "content": "![image](https://assets.leetcode.com/users/images/88356185-85ab-4f53-afcb-d7512abc311e_1607548471.039209.png)\\nSorry for the bad images. I am terrible at it.\\n\\nTranspose: Basically run a line from top left to bottom right as shown. Flip the 2 parts around the line.\\n\\nReverse: Flip the whole image around a line to the left or right."
                    },
                    {
                        "username": "wtfcoder",
                        "content": "[@satyamS_71](/satyamS_71)  Reversing every row and transpose is gonna do it "
                    },
                    {
                        "username": "shakthisri",
                        "content": "it totally gave me a different view! thank you"
                    },
                    {
                        "username": "Msey",
                        "content": "[@satyamS_71](/satyamS_71) easiest way to use this trick is to present -90 degree as +270, 270 is a 90 degree three times etc"
                    },
                    {
                        "username": "satyamS_71",
                        "content": "Thanks it helped me a lot , but what if the question asks to rotate the image counter clockwise , then how should I approach the problem?"
                    },
                    {
                        "username": "HarshitGupta_02",
                        "content": "class Solution {\\npublic:\\n    void rotate(vector<vector<int>>& matrix) {\\n        int n=matrix.size();\\n        for(int i=0;i<n;i++){\\n            for(int j=0;j<=i;j++){\\n                swap(matrix[i][j],matrix[j][i]);\\n            }\\n        }\\n        for(int i=0;i<n;i++){\\n            int j=0;\\n            int k=n-1;\\n            while(j<=n/2 && k>=n/2){\\n                swap(matrix[i][j],matrix[i][k]);\\n                j++;\\n                k--;\\n            }\\n        }\\n    }\\n};"
                    },
                    {
                        "username": "Bobzero",
                        "content": "I\\'m always having fun reading the discussions \\uD83D\\uDE03"
                    },
                    {
                        "username": "charlesxiao2",
                        "content": "This post is for rotating the matrix anticlockwise. Sorry, when I post it I didn\\'t notice it. But please read it, because I guarantee you can understand the thought process and came up with your solution for clockwise rotation.\\n\\nSo, we are required to rotate it in place. \\n\\nGive a matrix, there are several operations can be done in matrix in place:\\n\\ntranslation, and swap symmetrically(mirror against diagnal), and probaly some unexpected in place operations.\\n\\nWe are trying to break the rotation operation into these operations that are know to carry on easily in place.\\n\\nFor swap symmetrically, given coordinate (a,b), it will be swapped to (b,a) if following the upper left and buttom right diagnal as mirror.\\nFor translation, given coordinate (a, b), we are able to traslate it to (a, whatever) or (whatever, b) with ease.\\n\\nIf rotated anticlockwise, element at (a,b) will be transfered to the new coordinate of (s-b-1 ,a) with s being the length or width of the matrix.\\nWe are trying to find out the in place operations needed in order to transform the coordinate from (a, b) to (s-b-1, a), with some fundumantal operations\\' coordinate transformation characteristics in mind.\\n\\nwe are trying to fill in the logic path between (a, b) to (s-b-1, a) using the fundamental operations.\\n\\nLet\\'s try to fill the logic break reversely:\\nto get to (s-b-1, a) from (a, b), notice a is swapped, we guess the last operation may be mirror against diagnal. so the path now becomes:\\n(a,b) -> (a, s-b-1) -> (s-b-1, a)//the last mirror can be easily done in place\\n\\nNow we try, how to get to (a, s-b-1) from (a, b) using fundamental in place operations? Well, draw a matrix, and you find out that this is not translation, but some swapping too. Don\\'t worry, you see the operations does not change the row coordinate, so it can be done in place with ease. And you know at this point you design the algorithm for this problem.\\n\\nThis is how the logic flows trying to design the in place algorithm to rotate n*n matrix.\\nBasically, we are trying to break down the operations into easy atomic in place operations. How to break down? Analyze the coordinate characteristics with some basic patterns in mind.\\n\\n"
                    },
                    {
                        "username": "UmerZia",
                        "content": "What If we do not have the diagonal, Just thinking about more dynamic solution!"
                    },
                    {
                        "username": "k3000001",
                        "content": "What exactly does it help measure? That the candidate can remember the trick of swapping rows?"
                    },
                    {
                        "username": "MiliMakwana",
                        "content": "[@Nandhini-Techie](/Nandhini-Techie)  Extra space bro\\n"
                    },
                    {
                        "username": "Nandhini-Techie",
                        "content": "  for (int i = 0; i < matrix.length; i++) {\\n      List<int> subList = [];\\n      for (int j = matrix.length - 1; j >= 0; j--) {\\n        subList.add(matrix[j][i]);\\n      }\\n      output.add(subList);\\n    }"
                    },
                    {
                        "username": "betrayy",
                        "content": "Was thinking the same.. this question is pretty much free if you just memorize it"
                    },
                    {
                        "username": "dkode",
                        "content": "Diagram:\\n\\n![image](https://assets.leetcode.com/users/images/95016c57-f112-4e79-8be7-0f21c814c800_1630583198.7966883.png)\\n\\n# M[i,j] --> M\\'[j,N-1-i]\\n\\nWe know that transpose relation is \\n#### M[i,j]= M[j,i]\\n#### \\n\\nBut the relation we got is slightly differernt\\n\\nThink how to convert\\nM[i,j] to M[N-1-i,j]\\n\\nThis is equivalent to flipping the matrix horizontally.\\n\\nM[i,j] to M[N-1-i,j]\\n\\nTranspose (M[N-1-i,j]) --> M\\'[j,N-1-i]\\n\\nTranspose and flipping are linear operation\\n\\nSimilary you can solve other cases like 90 degree, 180 degree, 270 degree etc\\n\\n\\n"
                    },
                    {
                        "username": "paras178a",
                        "content": "[@user7617Dm](/user7617Dm) If i is zero, then index will you be at for N+1-i ?"
                    },
                    {
                        "username": "user7617Dm",
                        "content": "why is it N-1-i not N+1-i? If N is 4 for a 4x4 matric"
                    },
                    {
                        "username": "StefanPochmann",
                        "content": "    def rotate(matrix)\\n      matrix.replace(matrix.reverse.transpose)\\n    end\\n\\nI like Ruby's wordy style."
                    },
                    {
                        "username": "cbertake",
                        "content": "when will you stop posting solution in discussion?\\n"
                    },
                    {
                        "username": "deadsec",
                        "content": "\\uD83D\\uDE02 Amazon Recruiter => You have been hired."
                    },
                    {
                        "username": "UmerZia",
                        "content": "[@Brut_all](/Brut_all) Definitely Not! "
                    },
                    {
                        "username": "Brut_all",
                        "content": "But the interviwer might not like \\uD83E\\uDD10"
                    },
                    {
                        "username": "chris3109692",
                        "content": "The complexity analyses in the solution is incorrect. For a NxN matrix, the complexity is O(N^2), but our data size is N^2 by itself, hence the proper way to denote complexity should be O(n). Note big O is always measured against the data size, not the dimension size."
                    },
                    {
                        "username": "Triquetra",
                        "content": "Complexity is an equivalence class of functions, it can be expressed as a function of any variable."
                    },
                    {
                        "username": "WilmerKrisp",
                        "content": "# solution 1\\n\\n![image](https://assets.leetcode.com/users/images/e112c117-97a6-431c-99e9-c2b2ca3b84c5_1597576604.2278848.png)\\n\\n![image](https://assets.leetcode.com/users/images/18ce4afa-3e8d-4943-856c-a59d781def40_1597576610.36345.png)\\n\\n\\n# solution 2 (inplace modification)\\n![image](https://assets.leetcode.com/users/images/9f7d86fb-cde6-4760-8088-b683bb52160f_1597580296.4229963.png)\\n\\n![image](https://assets.leetcode.com/users/images/58888c0c-c0b7-4fee-9f8d-537ef2681f0a_1597580313.7932537.png)\\n"
                    },
                    {
                        "username": "Ayush_PY",
                        "content": "Using a second matrix is not allowed"
                    },
                    {
                        "username": "bnuzhanyu",
                        "content": "I had been asked this question in an interview:\\n\\ngiven an R x C  matrix,  rotate 90 degree clockwise **in place** (with constant extra space).\\n**The matrix is given as an array**, you should do this within the array.\\nExample: \\u3002\\ninput: R = 3, C = 4, array = 1 2 3 4 5 6 7 8 9 10 11 12\\noutput: R = 4, C = 3, array = 9 5 1 10 6 2 11 7 3 12 8 4\\n\\nexplaination:\\nthe input matrix is:\\n1 2 3 4\\n5 6 7 8\\n9 10 11 12\\nthe output matrix is:\\n9 5 1\\n10 6 2\\n11 7 3\\n12 8 4\\n\\nThough I have got an idea of solving this problem, but the time complexity is not O(RxC)\\u3002\\nCan anyone got an O(RxC) solution with O(1) space?\\n\\n\\n"
                    },
                    {
                        "username": "mawhadmd",
                        "content": "That\\'s possible to do in place?"
                    },
                    {
                        "username": "anmol_soniii",
                        "content": "T.C = O( R*C )\\nS.C = O(1) [ in place ]\\nsolution:\\nclass Solution {\\npublic:\\n    void rotate(vector<vector<int>>& matrix) {\\n        int row = matrix.size();\\n        int col = matrix[0].size();\\n\\n        for(int i = 0; i<row ;i++){\\n            int j = 0;\\n            while( j<i ){\\n                swap(matrix[i][j],matrix[j][i]);\\n                j++;\\n            }\\n        }\\n\\n        for(int i = 0 ; i < row ; i++){\\n            int n = 0;\\n            int m = col-1;\\n            while(n<m){\\n                swap(matrix[i][n],matrix[i][m]);\\n                n++;\\n                m--;\\n            }\\n        }\\n    }\\n};"
                    },
                    {
                        "username": "chinnamsaireddy1369",
                        "content": "how can u do this without space, this question itself asking to alter given m x n matrix to n x m matrix, then without using new matrix how will you insert n x m into m x n"
                    },
                    {
                        "username": "him_Sarma619",
                        "content": "This is actually a pretty good question.... I\\'m not able to think of a solution for this, if you don\\'t mind can you please provide the solution for the same ?"
                    }
                ]
            },
            {
                "id": 1573752,
                "content": [
                    {
                        "username": "LazyBanda",
                        "content": "I was asked this problem in Amazon for SDE III. I had hardly 25 mins to solve. Since in online interview, first 10 mins went into setup because my interviewer wasnt getting signals. next 25 mins for behavioural. and then this question. Its a tricky problem, nort sure what a company will check with this question. Probably my memorization technique."
                    },
                    {
                        "username": "rquant",
                        "content": "This is a hard problem to solve on the fly. Either you\\'re a genius or you practiced this problem on LeetCode enough I guess."
                    },
                    {
                        "username": "aldogg",
                        "content": "I know your pain. It took me 2 hours to solve it today without looking for the solution :("
                    },
                    {
                        "username": "chiranthanmirle",
                        "content": "![image](https://assets.leetcode.com/users/images/88356185-85ab-4f53-afcb-d7512abc311e_1607548471.039209.png)\\nSorry for the bad images. I am terrible at it.\\n\\nTranspose: Basically run a line from top left to bottom right as shown. Flip the 2 parts around the line.\\n\\nReverse: Flip the whole image around a line to the left or right."
                    },
                    {
                        "username": "wtfcoder",
                        "content": "[@satyamS_71](/satyamS_71)  Reversing every row and transpose is gonna do it "
                    },
                    {
                        "username": "shakthisri",
                        "content": "it totally gave me a different view! thank you"
                    },
                    {
                        "username": "Msey",
                        "content": "[@satyamS_71](/satyamS_71) easiest way to use this trick is to present -90 degree as +270, 270 is a 90 degree three times etc"
                    },
                    {
                        "username": "satyamS_71",
                        "content": "Thanks it helped me a lot , but what if the question asks to rotate the image counter clockwise , then how should I approach the problem?"
                    },
                    {
                        "username": "HarshitGupta_02",
                        "content": "class Solution {\\npublic:\\n    void rotate(vector<vector<int>>& matrix) {\\n        int n=matrix.size();\\n        for(int i=0;i<n;i++){\\n            for(int j=0;j<=i;j++){\\n                swap(matrix[i][j],matrix[j][i]);\\n            }\\n        }\\n        for(int i=0;i<n;i++){\\n            int j=0;\\n            int k=n-1;\\n            while(j<=n/2 && k>=n/2){\\n                swap(matrix[i][j],matrix[i][k]);\\n                j++;\\n                k--;\\n            }\\n        }\\n    }\\n};"
                    },
                    {
                        "username": "Bobzero",
                        "content": "I\\'m always having fun reading the discussions \\uD83D\\uDE03"
                    },
                    {
                        "username": "charlesxiao2",
                        "content": "This post is for rotating the matrix anticlockwise. Sorry, when I post it I didn\\'t notice it. But please read it, because I guarantee you can understand the thought process and came up with your solution for clockwise rotation.\\n\\nSo, we are required to rotate it in place. \\n\\nGive a matrix, there are several operations can be done in matrix in place:\\n\\ntranslation, and swap symmetrically(mirror against diagnal), and probaly some unexpected in place operations.\\n\\nWe are trying to break the rotation operation into these operations that are know to carry on easily in place.\\n\\nFor swap symmetrically, given coordinate (a,b), it will be swapped to (b,a) if following the upper left and buttom right diagnal as mirror.\\nFor translation, given coordinate (a, b), we are able to traslate it to (a, whatever) or (whatever, b) with ease.\\n\\nIf rotated anticlockwise, element at (a,b) will be transfered to the new coordinate of (s-b-1 ,a) with s being the length or width of the matrix.\\nWe are trying to find out the in place operations needed in order to transform the coordinate from (a, b) to (s-b-1, a), with some fundumantal operations\\' coordinate transformation characteristics in mind.\\n\\nwe are trying to fill in the logic path between (a, b) to (s-b-1, a) using the fundamental operations.\\n\\nLet\\'s try to fill the logic break reversely:\\nto get to (s-b-1, a) from (a, b), notice a is swapped, we guess the last operation may be mirror against diagnal. so the path now becomes:\\n(a,b) -> (a, s-b-1) -> (s-b-1, a)//the last mirror can be easily done in place\\n\\nNow we try, how to get to (a, s-b-1) from (a, b) using fundamental in place operations? Well, draw a matrix, and you find out that this is not translation, but some swapping too. Don\\'t worry, you see the operations does not change the row coordinate, so it can be done in place with ease. And you know at this point you design the algorithm for this problem.\\n\\nThis is how the logic flows trying to design the in place algorithm to rotate n*n matrix.\\nBasically, we are trying to break down the operations into easy atomic in place operations. How to break down? Analyze the coordinate characteristics with some basic patterns in mind.\\n\\n"
                    },
                    {
                        "username": "UmerZia",
                        "content": "What If we do not have the diagonal, Just thinking about more dynamic solution!"
                    },
                    {
                        "username": "k3000001",
                        "content": "What exactly does it help measure? That the candidate can remember the trick of swapping rows?"
                    },
                    {
                        "username": "MiliMakwana",
                        "content": "[@Nandhini-Techie](/Nandhini-Techie)  Extra space bro\\n"
                    },
                    {
                        "username": "Nandhini-Techie",
                        "content": "  for (int i = 0; i < matrix.length; i++) {\\n      List<int> subList = [];\\n      for (int j = matrix.length - 1; j >= 0; j--) {\\n        subList.add(matrix[j][i]);\\n      }\\n      output.add(subList);\\n    }"
                    },
                    {
                        "username": "betrayy",
                        "content": "Was thinking the same.. this question is pretty much free if you just memorize it"
                    },
                    {
                        "username": "dkode",
                        "content": "Diagram:\\n\\n![image](https://assets.leetcode.com/users/images/95016c57-f112-4e79-8be7-0f21c814c800_1630583198.7966883.png)\\n\\n# M[i,j] --> M\\'[j,N-1-i]\\n\\nWe know that transpose relation is \\n#### M[i,j]= M[j,i]\\n#### \\n\\nBut the relation we got is slightly differernt\\n\\nThink how to convert\\nM[i,j] to M[N-1-i,j]\\n\\nThis is equivalent to flipping the matrix horizontally.\\n\\nM[i,j] to M[N-1-i,j]\\n\\nTranspose (M[N-1-i,j]) --> M\\'[j,N-1-i]\\n\\nTranspose and flipping are linear operation\\n\\nSimilary you can solve other cases like 90 degree, 180 degree, 270 degree etc\\n\\n\\n"
                    },
                    {
                        "username": "paras178a",
                        "content": "[@user7617Dm](/user7617Dm) If i is zero, then index will you be at for N+1-i ?"
                    },
                    {
                        "username": "user7617Dm",
                        "content": "why is it N-1-i not N+1-i? If N is 4 for a 4x4 matric"
                    },
                    {
                        "username": "StefanPochmann",
                        "content": "    def rotate(matrix)\\n      matrix.replace(matrix.reverse.transpose)\\n    end\\n\\nI like Ruby's wordy style."
                    },
                    {
                        "username": "cbertake",
                        "content": "when will you stop posting solution in discussion?\\n"
                    },
                    {
                        "username": "deadsec",
                        "content": "\\uD83D\\uDE02 Amazon Recruiter => You have been hired."
                    },
                    {
                        "username": "UmerZia",
                        "content": "[@Brut_all](/Brut_all) Definitely Not! "
                    },
                    {
                        "username": "Brut_all",
                        "content": "But the interviwer might not like \\uD83E\\uDD10"
                    },
                    {
                        "username": "chris3109692",
                        "content": "The complexity analyses in the solution is incorrect. For a NxN matrix, the complexity is O(N^2), but our data size is N^2 by itself, hence the proper way to denote complexity should be O(n). Note big O is always measured against the data size, not the dimension size."
                    },
                    {
                        "username": "Triquetra",
                        "content": "Complexity is an equivalence class of functions, it can be expressed as a function of any variable."
                    },
                    {
                        "username": "WilmerKrisp",
                        "content": "# solution 1\\n\\n![image](https://assets.leetcode.com/users/images/e112c117-97a6-431c-99e9-c2b2ca3b84c5_1597576604.2278848.png)\\n\\n![image](https://assets.leetcode.com/users/images/18ce4afa-3e8d-4943-856c-a59d781def40_1597576610.36345.png)\\n\\n\\n# solution 2 (inplace modification)\\n![image](https://assets.leetcode.com/users/images/9f7d86fb-cde6-4760-8088-b683bb52160f_1597580296.4229963.png)\\n\\n![image](https://assets.leetcode.com/users/images/58888c0c-c0b7-4fee-9f8d-537ef2681f0a_1597580313.7932537.png)\\n"
                    },
                    {
                        "username": "Ayush_PY",
                        "content": "Using a second matrix is not allowed"
                    },
                    {
                        "username": "bnuzhanyu",
                        "content": "I had been asked this question in an interview:\\n\\ngiven an R x C  matrix,  rotate 90 degree clockwise **in place** (with constant extra space).\\n**The matrix is given as an array**, you should do this within the array.\\nExample: \\u3002\\ninput: R = 3, C = 4, array = 1 2 3 4 5 6 7 8 9 10 11 12\\noutput: R = 4, C = 3, array = 9 5 1 10 6 2 11 7 3 12 8 4\\n\\nexplaination:\\nthe input matrix is:\\n1 2 3 4\\n5 6 7 8\\n9 10 11 12\\nthe output matrix is:\\n9 5 1\\n10 6 2\\n11 7 3\\n12 8 4\\n\\nThough I have got an idea of solving this problem, but the time complexity is not O(RxC)\\u3002\\nCan anyone got an O(RxC) solution with O(1) space?\\n\\n\\n"
                    },
                    {
                        "username": "mawhadmd",
                        "content": "That\\'s possible to do in place?"
                    },
                    {
                        "username": "anmol_soniii",
                        "content": "T.C = O( R*C )\\nS.C = O(1) [ in place ]\\nsolution:\\nclass Solution {\\npublic:\\n    void rotate(vector<vector<int>>& matrix) {\\n        int row = matrix.size();\\n        int col = matrix[0].size();\\n\\n        for(int i = 0; i<row ;i++){\\n            int j = 0;\\n            while( j<i ){\\n                swap(matrix[i][j],matrix[j][i]);\\n                j++;\\n            }\\n        }\\n\\n        for(int i = 0 ; i < row ; i++){\\n            int n = 0;\\n            int m = col-1;\\n            while(n<m){\\n                swap(matrix[i][n],matrix[i][m]);\\n                n++;\\n                m--;\\n            }\\n        }\\n    }\\n};"
                    },
                    {
                        "username": "chinnamsaireddy1369",
                        "content": "how can u do this without space, this question itself asking to alter given m x n matrix to n x m matrix, then without using new matrix how will you insert n x m into m x n"
                    },
                    {
                        "username": "him_Sarma619",
                        "content": "This is actually a pretty good question.... I\\'m not able to think of a solution for this, if you don\\'t mind can you please provide the solution for the same ?"
                    }
                ]
            },
            {
                "id": 1575708,
                "content": [
                    {
                        "username": "LazyBanda",
                        "content": "I was asked this problem in Amazon for SDE III. I had hardly 25 mins to solve. Since in online interview, first 10 mins went into setup because my interviewer wasnt getting signals. next 25 mins for behavioural. and then this question. Its a tricky problem, nort sure what a company will check with this question. Probably my memorization technique."
                    },
                    {
                        "username": "rquant",
                        "content": "This is a hard problem to solve on the fly. Either you\\'re a genius or you practiced this problem on LeetCode enough I guess."
                    },
                    {
                        "username": "aldogg",
                        "content": "I know your pain. It took me 2 hours to solve it today without looking for the solution :("
                    },
                    {
                        "username": "chiranthanmirle",
                        "content": "![image](https://assets.leetcode.com/users/images/88356185-85ab-4f53-afcb-d7512abc311e_1607548471.039209.png)\\nSorry for the bad images. I am terrible at it.\\n\\nTranspose: Basically run a line from top left to bottom right as shown. Flip the 2 parts around the line.\\n\\nReverse: Flip the whole image around a line to the left or right."
                    },
                    {
                        "username": "wtfcoder",
                        "content": "[@satyamS_71](/satyamS_71)  Reversing every row and transpose is gonna do it "
                    },
                    {
                        "username": "shakthisri",
                        "content": "it totally gave me a different view! thank you"
                    },
                    {
                        "username": "Msey",
                        "content": "[@satyamS_71](/satyamS_71) easiest way to use this trick is to present -90 degree as +270, 270 is a 90 degree three times etc"
                    },
                    {
                        "username": "satyamS_71",
                        "content": "Thanks it helped me a lot , but what if the question asks to rotate the image counter clockwise , then how should I approach the problem?"
                    },
                    {
                        "username": "HarshitGupta_02",
                        "content": "class Solution {\\npublic:\\n    void rotate(vector<vector<int>>& matrix) {\\n        int n=matrix.size();\\n        for(int i=0;i<n;i++){\\n            for(int j=0;j<=i;j++){\\n                swap(matrix[i][j],matrix[j][i]);\\n            }\\n        }\\n        for(int i=0;i<n;i++){\\n            int j=0;\\n            int k=n-1;\\n            while(j<=n/2 && k>=n/2){\\n                swap(matrix[i][j],matrix[i][k]);\\n                j++;\\n                k--;\\n            }\\n        }\\n    }\\n};"
                    },
                    {
                        "username": "Bobzero",
                        "content": "I\\'m always having fun reading the discussions \\uD83D\\uDE03"
                    },
                    {
                        "username": "charlesxiao2",
                        "content": "This post is for rotating the matrix anticlockwise. Sorry, when I post it I didn\\'t notice it. But please read it, because I guarantee you can understand the thought process and came up with your solution for clockwise rotation.\\n\\nSo, we are required to rotate it in place. \\n\\nGive a matrix, there are several operations can be done in matrix in place:\\n\\ntranslation, and swap symmetrically(mirror against diagnal), and probaly some unexpected in place operations.\\n\\nWe are trying to break the rotation operation into these operations that are know to carry on easily in place.\\n\\nFor swap symmetrically, given coordinate (a,b), it will be swapped to (b,a) if following the upper left and buttom right diagnal as mirror.\\nFor translation, given coordinate (a, b), we are able to traslate it to (a, whatever) or (whatever, b) with ease.\\n\\nIf rotated anticlockwise, element at (a,b) will be transfered to the new coordinate of (s-b-1 ,a) with s being the length or width of the matrix.\\nWe are trying to find out the in place operations needed in order to transform the coordinate from (a, b) to (s-b-1, a), with some fundumantal operations\\' coordinate transformation characteristics in mind.\\n\\nwe are trying to fill in the logic path between (a, b) to (s-b-1, a) using the fundamental operations.\\n\\nLet\\'s try to fill the logic break reversely:\\nto get to (s-b-1, a) from (a, b), notice a is swapped, we guess the last operation may be mirror against diagnal. so the path now becomes:\\n(a,b) -> (a, s-b-1) -> (s-b-1, a)//the last mirror can be easily done in place\\n\\nNow we try, how to get to (a, s-b-1) from (a, b) using fundamental in place operations? Well, draw a matrix, and you find out that this is not translation, but some swapping too. Don\\'t worry, you see the operations does not change the row coordinate, so it can be done in place with ease. And you know at this point you design the algorithm for this problem.\\n\\nThis is how the logic flows trying to design the in place algorithm to rotate n*n matrix.\\nBasically, we are trying to break down the operations into easy atomic in place operations. How to break down? Analyze the coordinate characteristics with some basic patterns in mind.\\n\\n"
                    },
                    {
                        "username": "UmerZia",
                        "content": "What If we do not have the diagonal, Just thinking about more dynamic solution!"
                    },
                    {
                        "username": "k3000001",
                        "content": "What exactly does it help measure? That the candidate can remember the trick of swapping rows?"
                    },
                    {
                        "username": "MiliMakwana",
                        "content": "[@Nandhini-Techie](/Nandhini-Techie)  Extra space bro\\n"
                    },
                    {
                        "username": "Nandhini-Techie",
                        "content": "  for (int i = 0; i < matrix.length; i++) {\\n      List<int> subList = [];\\n      for (int j = matrix.length - 1; j >= 0; j--) {\\n        subList.add(matrix[j][i]);\\n      }\\n      output.add(subList);\\n    }"
                    },
                    {
                        "username": "betrayy",
                        "content": "Was thinking the same.. this question is pretty much free if you just memorize it"
                    },
                    {
                        "username": "dkode",
                        "content": "Diagram:\\n\\n![image](https://assets.leetcode.com/users/images/95016c57-f112-4e79-8be7-0f21c814c800_1630583198.7966883.png)\\n\\n# M[i,j] --> M\\'[j,N-1-i]\\n\\nWe know that transpose relation is \\n#### M[i,j]= M[j,i]\\n#### \\n\\nBut the relation we got is slightly differernt\\n\\nThink how to convert\\nM[i,j] to M[N-1-i,j]\\n\\nThis is equivalent to flipping the matrix horizontally.\\n\\nM[i,j] to M[N-1-i,j]\\n\\nTranspose (M[N-1-i,j]) --> M\\'[j,N-1-i]\\n\\nTranspose and flipping are linear operation\\n\\nSimilary you can solve other cases like 90 degree, 180 degree, 270 degree etc\\n\\n\\n"
                    },
                    {
                        "username": "paras178a",
                        "content": "[@user7617Dm](/user7617Dm) If i is zero, then index will you be at for N+1-i ?"
                    },
                    {
                        "username": "user7617Dm",
                        "content": "why is it N-1-i not N+1-i? If N is 4 for a 4x4 matric"
                    },
                    {
                        "username": "StefanPochmann",
                        "content": "    def rotate(matrix)\\n      matrix.replace(matrix.reverse.transpose)\\n    end\\n\\nI like Ruby's wordy style."
                    },
                    {
                        "username": "cbertake",
                        "content": "when will you stop posting solution in discussion?\\n"
                    },
                    {
                        "username": "deadsec",
                        "content": "\\uD83D\\uDE02 Amazon Recruiter => You have been hired."
                    },
                    {
                        "username": "UmerZia",
                        "content": "[@Brut_all](/Brut_all) Definitely Not! "
                    },
                    {
                        "username": "Brut_all",
                        "content": "But the interviwer might not like \\uD83E\\uDD10"
                    },
                    {
                        "username": "chris3109692",
                        "content": "The complexity analyses in the solution is incorrect. For a NxN matrix, the complexity is O(N^2), but our data size is N^2 by itself, hence the proper way to denote complexity should be O(n). Note big O is always measured against the data size, not the dimension size."
                    },
                    {
                        "username": "Triquetra",
                        "content": "Complexity is an equivalence class of functions, it can be expressed as a function of any variable."
                    },
                    {
                        "username": "WilmerKrisp",
                        "content": "# solution 1\\n\\n![image](https://assets.leetcode.com/users/images/e112c117-97a6-431c-99e9-c2b2ca3b84c5_1597576604.2278848.png)\\n\\n![image](https://assets.leetcode.com/users/images/18ce4afa-3e8d-4943-856c-a59d781def40_1597576610.36345.png)\\n\\n\\n# solution 2 (inplace modification)\\n![image](https://assets.leetcode.com/users/images/9f7d86fb-cde6-4760-8088-b683bb52160f_1597580296.4229963.png)\\n\\n![image](https://assets.leetcode.com/users/images/58888c0c-c0b7-4fee-9f8d-537ef2681f0a_1597580313.7932537.png)\\n"
                    },
                    {
                        "username": "Ayush_PY",
                        "content": "Using a second matrix is not allowed"
                    },
                    {
                        "username": "bnuzhanyu",
                        "content": "I had been asked this question in an interview:\\n\\ngiven an R x C  matrix,  rotate 90 degree clockwise **in place** (with constant extra space).\\n**The matrix is given as an array**, you should do this within the array.\\nExample: \\u3002\\ninput: R = 3, C = 4, array = 1 2 3 4 5 6 7 8 9 10 11 12\\noutput: R = 4, C = 3, array = 9 5 1 10 6 2 11 7 3 12 8 4\\n\\nexplaination:\\nthe input matrix is:\\n1 2 3 4\\n5 6 7 8\\n9 10 11 12\\nthe output matrix is:\\n9 5 1\\n10 6 2\\n11 7 3\\n12 8 4\\n\\nThough I have got an idea of solving this problem, but the time complexity is not O(RxC)\\u3002\\nCan anyone got an O(RxC) solution with O(1) space?\\n\\n\\n"
                    },
                    {
                        "username": "mawhadmd",
                        "content": "That\\'s possible to do in place?"
                    },
                    {
                        "username": "anmol_soniii",
                        "content": "T.C = O( R*C )\\nS.C = O(1) [ in place ]\\nsolution:\\nclass Solution {\\npublic:\\n    void rotate(vector<vector<int>>& matrix) {\\n        int row = matrix.size();\\n        int col = matrix[0].size();\\n\\n        for(int i = 0; i<row ;i++){\\n            int j = 0;\\n            while( j<i ){\\n                swap(matrix[i][j],matrix[j][i]);\\n                j++;\\n            }\\n        }\\n\\n        for(int i = 0 ; i < row ; i++){\\n            int n = 0;\\n            int m = col-1;\\n            while(n<m){\\n                swap(matrix[i][n],matrix[i][m]);\\n                n++;\\n                m--;\\n            }\\n        }\\n    }\\n};"
                    },
                    {
                        "username": "chinnamsaireddy1369",
                        "content": "how can u do this without space, this question itself asking to alter given m x n matrix to n x m matrix, then without using new matrix how will you insert n x m into m x n"
                    },
                    {
                        "username": "him_Sarma619",
                        "content": "This is actually a pretty good question.... I\\'m not able to think of a solution for this, if you don\\'t mind can you please provide the solution for the same ?"
                    }
                ]
            },
            {
                "id": 1565939,
                "content": [
                    {
                        "username": "LazyBanda",
                        "content": "I was asked this problem in Amazon for SDE III. I had hardly 25 mins to solve. Since in online interview, first 10 mins went into setup because my interviewer wasnt getting signals. next 25 mins for behavioural. and then this question. Its a tricky problem, nort sure what a company will check with this question. Probably my memorization technique."
                    },
                    {
                        "username": "rquant",
                        "content": "This is a hard problem to solve on the fly. Either you\\'re a genius or you practiced this problem on LeetCode enough I guess."
                    },
                    {
                        "username": "aldogg",
                        "content": "I know your pain. It took me 2 hours to solve it today without looking for the solution :("
                    },
                    {
                        "username": "chiranthanmirle",
                        "content": "![image](https://assets.leetcode.com/users/images/88356185-85ab-4f53-afcb-d7512abc311e_1607548471.039209.png)\\nSorry for the bad images. I am terrible at it.\\n\\nTranspose: Basically run a line from top left to bottom right as shown. Flip the 2 parts around the line.\\n\\nReverse: Flip the whole image around a line to the left or right."
                    },
                    {
                        "username": "wtfcoder",
                        "content": "[@satyamS_71](/satyamS_71)  Reversing every row and transpose is gonna do it "
                    },
                    {
                        "username": "shakthisri",
                        "content": "it totally gave me a different view! thank you"
                    },
                    {
                        "username": "Msey",
                        "content": "[@satyamS_71](/satyamS_71) easiest way to use this trick is to present -90 degree as +270, 270 is a 90 degree three times etc"
                    },
                    {
                        "username": "satyamS_71",
                        "content": "Thanks it helped me a lot , but what if the question asks to rotate the image counter clockwise , then how should I approach the problem?"
                    },
                    {
                        "username": "HarshitGupta_02",
                        "content": "class Solution {\\npublic:\\n    void rotate(vector<vector<int>>& matrix) {\\n        int n=matrix.size();\\n        for(int i=0;i<n;i++){\\n            for(int j=0;j<=i;j++){\\n                swap(matrix[i][j],matrix[j][i]);\\n            }\\n        }\\n        for(int i=0;i<n;i++){\\n            int j=0;\\n            int k=n-1;\\n            while(j<=n/2 && k>=n/2){\\n                swap(matrix[i][j],matrix[i][k]);\\n                j++;\\n                k--;\\n            }\\n        }\\n    }\\n};"
                    },
                    {
                        "username": "Bobzero",
                        "content": "I\\'m always having fun reading the discussions \\uD83D\\uDE03"
                    },
                    {
                        "username": "charlesxiao2",
                        "content": "This post is for rotating the matrix anticlockwise. Sorry, when I post it I didn\\'t notice it. But please read it, because I guarantee you can understand the thought process and came up with your solution for clockwise rotation.\\n\\nSo, we are required to rotate it in place. \\n\\nGive a matrix, there are several operations can be done in matrix in place:\\n\\ntranslation, and swap symmetrically(mirror against diagnal), and probaly some unexpected in place operations.\\n\\nWe are trying to break the rotation operation into these operations that are know to carry on easily in place.\\n\\nFor swap symmetrically, given coordinate (a,b), it will be swapped to (b,a) if following the upper left and buttom right diagnal as mirror.\\nFor translation, given coordinate (a, b), we are able to traslate it to (a, whatever) or (whatever, b) with ease.\\n\\nIf rotated anticlockwise, element at (a,b) will be transfered to the new coordinate of (s-b-1 ,a) with s being the length or width of the matrix.\\nWe are trying to find out the in place operations needed in order to transform the coordinate from (a, b) to (s-b-1, a), with some fundumantal operations\\' coordinate transformation characteristics in mind.\\n\\nwe are trying to fill in the logic path between (a, b) to (s-b-1, a) using the fundamental operations.\\n\\nLet\\'s try to fill the logic break reversely:\\nto get to (s-b-1, a) from (a, b), notice a is swapped, we guess the last operation may be mirror against diagnal. so the path now becomes:\\n(a,b) -> (a, s-b-1) -> (s-b-1, a)//the last mirror can be easily done in place\\n\\nNow we try, how to get to (a, s-b-1) from (a, b) using fundamental in place operations? Well, draw a matrix, and you find out that this is not translation, but some swapping too. Don\\'t worry, you see the operations does not change the row coordinate, so it can be done in place with ease. And you know at this point you design the algorithm for this problem.\\n\\nThis is how the logic flows trying to design the in place algorithm to rotate n*n matrix.\\nBasically, we are trying to break down the operations into easy atomic in place operations. How to break down? Analyze the coordinate characteristics with some basic patterns in mind.\\n\\n"
                    },
                    {
                        "username": "UmerZia",
                        "content": "What If we do not have the diagonal, Just thinking about more dynamic solution!"
                    },
                    {
                        "username": "k3000001",
                        "content": "What exactly does it help measure? That the candidate can remember the trick of swapping rows?"
                    },
                    {
                        "username": "MiliMakwana",
                        "content": "[@Nandhini-Techie](/Nandhini-Techie)  Extra space bro\\n"
                    },
                    {
                        "username": "Nandhini-Techie",
                        "content": "  for (int i = 0; i < matrix.length; i++) {\\n      List<int> subList = [];\\n      for (int j = matrix.length - 1; j >= 0; j--) {\\n        subList.add(matrix[j][i]);\\n      }\\n      output.add(subList);\\n    }"
                    },
                    {
                        "username": "betrayy",
                        "content": "Was thinking the same.. this question is pretty much free if you just memorize it"
                    },
                    {
                        "username": "dkode",
                        "content": "Diagram:\\n\\n![image](https://assets.leetcode.com/users/images/95016c57-f112-4e79-8be7-0f21c814c800_1630583198.7966883.png)\\n\\n# M[i,j] --> M\\'[j,N-1-i]\\n\\nWe know that transpose relation is \\n#### M[i,j]= M[j,i]\\n#### \\n\\nBut the relation we got is slightly differernt\\n\\nThink how to convert\\nM[i,j] to M[N-1-i,j]\\n\\nThis is equivalent to flipping the matrix horizontally.\\n\\nM[i,j] to M[N-1-i,j]\\n\\nTranspose (M[N-1-i,j]) --> M\\'[j,N-1-i]\\n\\nTranspose and flipping are linear operation\\n\\nSimilary you can solve other cases like 90 degree, 180 degree, 270 degree etc\\n\\n\\n"
                    },
                    {
                        "username": "paras178a",
                        "content": "[@user7617Dm](/user7617Dm) If i is zero, then index will you be at for N+1-i ?"
                    },
                    {
                        "username": "user7617Dm",
                        "content": "why is it N-1-i not N+1-i? If N is 4 for a 4x4 matric"
                    },
                    {
                        "username": "StefanPochmann",
                        "content": "    def rotate(matrix)\\n      matrix.replace(matrix.reverse.transpose)\\n    end\\n\\nI like Ruby's wordy style."
                    },
                    {
                        "username": "cbertake",
                        "content": "when will you stop posting solution in discussion?\\n"
                    },
                    {
                        "username": "deadsec",
                        "content": "\\uD83D\\uDE02 Amazon Recruiter => You have been hired."
                    },
                    {
                        "username": "UmerZia",
                        "content": "[@Brut_all](/Brut_all) Definitely Not! "
                    },
                    {
                        "username": "Brut_all",
                        "content": "But the interviwer might not like \\uD83E\\uDD10"
                    },
                    {
                        "username": "chris3109692",
                        "content": "The complexity analyses in the solution is incorrect. For a NxN matrix, the complexity is O(N^2), but our data size is N^2 by itself, hence the proper way to denote complexity should be O(n). Note big O is always measured against the data size, not the dimension size."
                    },
                    {
                        "username": "Triquetra",
                        "content": "Complexity is an equivalence class of functions, it can be expressed as a function of any variable."
                    },
                    {
                        "username": "WilmerKrisp",
                        "content": "# solution 1\\n\\n![image](https://assets.leetcode.com/users/images/e112c117-97a6-431c-99e9-c2b2ca3b84c5_1597576604.2278848.png)\\n\\n![image](https://assets.leetcode.com/users/images/18ce4afa-3e8d-4943-856c-a59d781def40_1597576610.36345.png)\\n\\n\\n# solution 2 (inplace modification)\\n![image](https://assets.leetcode.com/users/images/9f7d86fb-cde6-4760-8088-b683bb52160f_1597580296.4229963.png)\\n\\n![image](https://assets.leetcode.com/users/images/58888c0c-c0b7-4fee-9f8d-537ef2681f0a_1597580313.7932537.png)\\n"
                    },
                    {
                        "username": "Ayush_PY",
                        "content": "Using a second matrix is not allowed"
                    },
                    {
                        "username": "bnuzhanyu",
                        "content": "I had been asked this question in an interview:\\n\\ngiven an R x C  matrix,  rotate 90 degree clockwise **in place** (with constant extra space).\\n**The matrix is given as an array**, you should do this within the array.\\nExample: \\u3002\\ninput: R = 3, C = 4, array = 1 2 3 4 5 6 7 8 9 10 11 12\\noutput: R = 4, C = 3, array = 9 5 1 10 6 2 11 7 3 12 8 4\\n\\nexplaination:\\nthe input matrix is:\\n1 2 3 4\\n5 6 7 8\\n9 10 11 12\\nthe output matrix is:\\n9 5 1\\n10 6 2\\n11 7 3\\n12 8 4\\n\\nThough I have got an idea of solving this problem, but the time complexity is not O(RxC)\\u3002\\nCan anyone got an O(RxC) solution with O(1) space?\\n\\n\\n"
                    },
                    {
                        "username": "mawhadmd",
                        "content": "That\\'s possible to do in place?"
                    },
                    {
                        "username": "anmol_soniii",
                        "content": "T.C = O( R*C )\\nS.C = O(1) [ in place ]\\nsolution:\\nclass Solution {\\npublic:\\n    void rotate(vector<vector<int>>& matrix) {\\n        int row = matrix.size();\\n        int col = matrix[0].size();\\n\\n        for(int i = 0; i<row ;i++){\\n            int j = 0;\\n            while( j<i ){\\n                swap(matrix[i][j],matrix[j][i]);\\n                j++;\\n            }\\n        }\\n\\n        for(int i = 0 ; i < row ; i++){\\n            int n = 0;\\n            int m = col-1;\\n            while(n<m){\\n                swap(matrix[i][n],matrix[i][m]);\\n                n++;\\n                m--;\\n            }\\n        }\\n    }\\n};"
                    },
                    {
                        "username": "chinnamsaireddy1369",
                        "content": "how can u do this without space, this question itself asking to alter given m x n matrix to n x m matrix, then without using new matrix how will you insert n x m into m x n"
                    },
                    {
                        "username": "him_Sarma619",
                        "content": "This is actually a pretty good question.... I\\'m not able to think of a solution for this, if you don\\'t mind can you please provide the solution for the same ?"
                    }
                ]
            },
            {
                "id": 1567522,
                "content": [
                    {
                        "username": "LazyBanda",
                        "content": "I was asked this problem in Amazon for SDE III. I had hardly 25 mins to solve. Since in online interview, first 10 mins went into setup because my interviewer wasnt getting signals. next 25 mins for behavioural. and then this question. Its a tricky problem, nort sure what a company will check with this question. Probably my memorization technique."
                    },
                    {
                        "username": "rquant",
                        "content": "This is a hard problem to solve on the fly. Either you\\'re a genius or you practiced this problem on LeetCode enough I guess."
                    },
                    {
                        "username": "aldogg",
                        "content": "I know your pain. It took me 2 hours to solve it today without looking for the solution :("
                    },
                    {
                        "username": "chiranthanmirle",
                        "content": "![image](https://assets.leetcode.com/users/images/88356185-85ab-4f53-afcb-d7512abc311e_1607548471.039209.png)\\nSorry for the bad images. I am terrible at it.\\n\\nTranspose: Basically run a line from top left to bottom right as shown. Flip the 2 parts around the line.\\n\\nReverse: Flip the whole image around a line to the left or right."
                    },
                    {
                        "username": "wtfcoder",
                        "content": "[@satyamS_71](/satyamS_71)  Reversing every row and transpose is gonna do it "
                    },
                    {
                        "username": "shakthisri",
                        "content": "it totally gave me a different view! thank you"
                    },
                    {
                        "username": "Msey",
                        "content": "[@satyamS_71](/satyamS_71) easiest way to use this trick is to present -90 degree as +270, 270 is a 90 degree three times etc"
                    },
                    {
                        "username": "satyamS_71",
                        "content": "Thanks it helped me a lot , but what if the question asks to rotate the image counter clockwise , then how should I approach the problem?"
                    },
                    {
                        "username": "HarshitGupta_02",
                        "content": "class Solution {\\npublic:\\n    void rotate(vector<vector<int>>& matrix) {\\n        int n=matrix.size();\\n        for(int i=0;i<n;i++){\\n            for(int j=0;j<=i;j++){\\n                swap(matrix[i][j],matrix[j][i]);\\n            }\\n        }\\n        for(int i=0;i<n;i++){\\n            int j=0;\\n            int k=n-1;\\n            while(j<=n/2 && k>=n/2){\\n                swap(matrix[i][j],matrix[i][k]);\\n                j++;\\n                k--;\\n            }\\n        }\\n    }\\n};"
                    },
                    {
                        "username": "Bobzero",
                        "content": "I\\'m always having fun reading the discussions \\uD83D\\uDE03"
                    },
                    {
                        "username": "charlesxiao2",
                        "content": "This post is for rotating the matrix anticlockwise. Sorry, when I post it I didn\\'t notice it. But please read it, because I guarantee you can understand the thought process and came up with your solution for clockwise rotation.\\n\\nSo, we are required to rotate it in place. \\n\\nGive a matrix, there are several operations can be done in matrix in place:\\n\\ntranslation, and swap symmetrically(mirror against diagnal), and probaly some unexpected in place operations.\\n\\nWe are trying to break the rotation operation into these operations that are know to carry on easily in place.\\n\\nFor swap symmetrically, given coordinate (a,b), it will be swapped to (b,a) if following the upper left and buttom right diagnal as mirror.\\nFor translation, given coordinate (a, b), we are able to traslate it to (a, whatever) or (whatever, b) with ease.\\n\\nIf rotated anticlockwise, element at (a,b) will be transfered to the new coordinate of (s-b-1 ,a) with s being the length or width of the matrix.\\nWe are trying to find out the in place operations needed in order to transform the coordinate from (a, b) to (s-b-1, a), with some fundumantal operations\\' coordinate transformation characteristics in mind.\\n\\nwe are trying to fill in the logic path between (a, b) to (s-b-1, a) using the fundamental operations.\\n\\nLet\\'s try to fill the logic break reversely:\\nto get to (s-b-1, a) from (a, b), notice a is swapped, we guess the last operation may be mirror against diagnal. so the path now becomes:\\n(a,b) -> (a, s-b-1) -> (s-b-1, a)//the last mirror can be easily done in place\\n\\nNow we try, how to get to (a, s-b-1) from (a, b) using fundamental in place operations? Well, draw a matrix, and you find out that this is not translation, but some swapping too. Don\\'t worry, you see the operations does not change the row coordinate, so it can be done in place with ease. And you know at this point you design the algorithm for this problem.\\n\\nThis is how the logic flows trying to design the in place algorithm to rotate n*n matrix.\\nBasically, we are trying to break down the operations into easy atomic in place operations. How to break down? Analyze the coordinate characteristics with some basic patterns in mind.\\n\\n"
                    },
                    {
                        "username": "UmerZia",
                        "content": "What If we do not have the diagonal, Just thinking about more dynamic solution!"
                    },
                    {
                        "username": "k3000001",
                        "content": "What exactly does it help measure? That the candidate can remember the trick of swapping rows?"
                    },
                    {
                        "username": "MiliMakwana",
                        "content": "[@Nandhini-Techie](/Nandhini-Techie)  Extra space bro\\n"
                    },
                    {
                        "username": "Nandhini-Techie",
                        "content": "  for (int i = 0; i < matrix.length; i++) {\\n      List<int> subList = [];\\n      for (int j = matrix.length - 1; j >= 0; j--) {\\n        subList.add(matrix[j][i]);\\n      }\\n      output.add(subList);\\n    }"
                    },
                    {
                        "username": "betrayy",
                        "content": "Was thinking the same.. this question is pretty much free if you just memorize it"
                    },
                    {
                        "username": "dkode",
                        "content": "Diagram:\\n\\n![image](https://assets.leetcode.com/users/images/95016c57-f112-4e79-8be7-0f21c814c800_1630583198.7966883.png)\\n\\n# M[i,j] --> M\\'[j,N-1-i]\\n\\nWe know that transpose relation is \\n#### M[i,j]= M[j,i]\\n#### \\n\\nBut the relation we got is slightly differernt\\n\\nThink how to convert\\nM[i,j] to M[N-1-i,j]\\n\\nThis is equivalent to flipping the matrix horizontally.\\n\\nM[i,j] to M[N-1-i,j]\\n\\nTranspose (M[N-1-i,j]) --> M\\'[j,N-1-i]\\n\\nTranspose and flipping are linear operation\\n\\nSimilary you can solve other cases like 90 degree, 180 degree, 270 degree etc\\n\\n\\n"
                    },
                    {
                        "username": "paras178a",
                        "content": "[@user7617Dm](/user7617Dm) If i is zero, then index will you be at for N+1-i ?"
                    },
                    {
                        "username": "user7617Dm",
                        "content": "why is it N-1-i not N+1-i? If N is 4 for a 4x4 matric"
                    },
                    {
                        "username": "StefanPochmann",
                        "content": "    def rotate(matrix)\\n      matrix.replace(matrix.reverse.transpose)\\n    end\\n\\nI like Ruby's wordy style."
                    },
                    {
                        "username": "cbertake",
                        "content": "when will you stop posting solution in discussion?\\n"
                    },
                    {
                        "username": "deadsec",
                        "content": "\\uD83D\\uDE02 Amazon Recruiter => You have been hired."
                    },
                    {
                        "username": "UmerZia",
                        "content": "[@Brut_all](/Brut_all) Definitely Not! "
                    },
                    {
                        "username": "Brut_all",
                        "content": "But the interviwer might not like \\uD83E\\uDD10"
                    },
                    {
                        "username": "chris3109692",
                        "content": "The complexity analyses in the solution is incorrect. For a NxN matrix, the complexity is O(N^2), but our data size is N^2 by itself, hence the proper way to denote complexity should be O(n). Note big O is always measured against the data size, not the dimension size."
                    },
                    {
                        "username": "Triquetra",
                        "content": "Complexity is an equivalence class of functions, it can be expressed as a function of any variable."
                    },
                    {
                        "username": "WilmerKrisp",
                        "content": "# solution 1\\n\\n![image](https://assets.leetcode.com/users/images/e112c117-97a6-431c-99e9-c2b2ca3b84c5_1597576604.2278848.png)\\n\\n![image](https://assets.leetcode.com/users/images/18ce4afa-3e8d-4943-856c-a59d781def40_1597576610.36345.png)\\n\\n\\n# solution 2 (inplace modification)\\n![image](https://assets.leetcode.com/users/images/9f7d86fb-cde6-4760-8088-b683bb52160f_1597580296.4229963.png)\\n\\n![image](https://assets.leetcode.com/users/images/58888c0c-c0b7-4fee-9f8d-537ef2681f0a_1597580313.7932537.png)\\n"
                    },
                    {
                        "username": "Ayush_PY",
                        "content": "Using a second matrix is not allowed"
                    },
                    {
                        "username": "bnuzhanyu",
                        "content": "I had been asked this question in an interview:\\n\\ngiven an R x C  matrix,  rotate 90 degree clockwise **in place** (with constant extra space).\\n**The matrix is given as an array**, you should do this within the array.\\nExample: \\u3002\\ninput: R = 3, C = 4, array = 1 2 3 4 5 6 7 8 9 10 11 12\\noutput: R = 4, C = 3, array = 9 5 1 10 6 2 11 7 3 12 8 4\\n\\nexplaination:\\nthe input matrix is:\\n1 2 3 4\\n5 6 7 8\\n9 10 11 12\\nthe output matrix is:\\n9 5 1\\n10 6 2\\n11 7 3\\n12 8 4\\n\\nThough I have got an idea of solving this problem, but the time complexity is not O(RxC)\\u3002\\nCan anyone got an O(RxC) solution with O(1) space?\\n\\n\\n"
                    },
                    {
                        "username": "mawhadmd",
                        "content": "That\\'s possible to do in place?"
                    },
                    {
                        "username": "anmol_soniii",
                        "content": "T.C = O( R*C )\\nS.C = O(1) [ in place ]\\nsolution:\\nclass Solution {\\npublic:\\n    void rotate(vector<vector<int>>& matrix) {\\n        int row = matrix.size();\\n        int col = matrix[0].size();\\n\\n        for(int i = 0; i<row ;i++){\\n            int j = 0;\\n            while( j<i ){\\n                swap(matrix[i][j],matrix[j][i]);\\n                j++;\\n            }\\n        }\\n\\n        for(int i = 0 ; i < row ; i++){\\n            int n = 0;\\n            int m = col-1;\\n            while(n<m){\\n                swap(matrix[i][n],matrix[i][m]);\\n                n++;\\n                m--;\\n            }\\n        }\\n    }\\n};"
                    },
                    {
                        "username": "chinnamsaireddy1369",
                        "content": "how can u do this without space, this question itself asking to alter given m x n matrix to n x m matrix, then without using new matrix how will you insert n x m into m x n"
                    },
                    {
                        "username": "him_Sarma619",
                        "content": "This is actually a pretty good question.... I\\'m not able to think of a solution for this, if you don\\'t mind can you please provide the solution for the same ?"
                    }
                ]
            },
            {
                "id": 1570119,
                "content": [
                    {
                        "username": "LazyBanda",
                        "content": "I was asked this problem in Amazon for SDE III. I had hardly 25 mins to solve. Since in online interview, first 10 mins went into setup because my interviewer wasnt getting signals. next 25 mins for behavioural. and then this question. Its a tricky problem, nort sure what a company will check with this question. Probably my memorization technique."
                    },
                    {
                        "username": "rquant",
                        "content": "This is a hard problem to solve on the fly. Either you\\'re a genius or you practiced this problem on LeetCode enough I guess."
                    },
                    {
                        "username": "aldogg",
                        "content": "I know your pain. It took me 2 hours to solve it today without looking for the solution :("
                    },
                    {
                        "username": "chiranthanmirle",
                        "content": "![image](https://assets.leetcode.com/users/images/88356185-85ab-4f53-afcb-d7512abc311e_1607548471.039209.png)\\nSorry for the bad images. I am terrible at it.\\n\\nTranspose: Basically run a line from top left to bottom right as shown. Flip the 2 parts around the line.\\n\\nReverse: Flip the whole image around a line to the left or right."
                    },
                    {
                        "username": "wtfcoder",
                        "content": "[@satyamS_71](/satyamS_71)  Reversing every row and transpose is gonna do it "
                    },
                    {
                        "username": "shakthisri",
                        "content": "it totally gave me a different view! thank you"
                    },
                    {
                        "username": "Msey",
                        "content": "[@satyamS_71](/satyamS_71) easiest way to use this trick is to present -90 degree as +270, 270 is a 90 degree three times etc"
                    },
                    {
                        "username": "satyamS_71",
                        "content": "Thanks it helped me a lot , but what if the question asks to rotate the image counter clockwise , then how should I approach the problem?"
                    },
                    {
                        "username": "HarshitGupta_02",
                        "content": "class Solution {\\npublic:\\n    void rotate(vector<vector<int>>& matrix) {\\n        int n=matrix.size();\\n        for(int i=0;i<n;i++){\\n            for(int j=0;j<=i;j++){\\n                swap(matrix[i][j],matrix[j][i]);\\n            }\\n        }\\n        for(int i=0;i<n;i++){\\n            int j=0;\\n            int k=n-1;\\n            while(j<=n/2 && k>=n/2){\\n                swap(matrix[i][j],matrix[i][k]);\\n                j++;\\n                k--;\\n            }\\n        }\\n    }\\n};"
                    },
                    {
                        "username": "Bobzero",
                        "content": "I\\'m always having fun reading the discussions \\uD83D\\uDE03"
                    },
                    {
                        "username": "charlesxiao2",
                        "content": "This post is for rotating the matrix anticlockwise. Sorry, when I post it I didn\\'t notice it. But please read it, because I guarantee you can understand the thought process and came up with your solution for clockwise rotation.\\n\\nSo, we are required to rotate it in place. \\n\\nGive a matrix, there are several operations can be done in matrix in place:\\n\\ntranslation, and swap symmetrically(mirror against diagnal), and probaly some unexpected in place operations.\\n\\nWe are trying to break the rotation operation into these operations that are know to carry on easily in place.\\n\\nFor swap symmetrically, given coordinate (a,b), it will be swapped to (b,a) if following the upper left and buttom right diagnal as mirror.\\nFor translation, given coordinate (a, b), we are able to traslate it to (a, whatever) or (whatever, b) with ease.\\n\\nIf rotated anticlockwise, element at (a,b) will be transfered to the new coordinate of (s-b-1 ,a) with s being the length or width of the matrix.\\nWe are trying to find out the in place operations needed in order to transform the coordinate from (a, b) to (s-b-1, a), with some fundumantal operations\\' coordinate transformation characteristics in mind.\\n\\nwe are trying to fill in the logic path between (a, b) to (s-b-1, a) using the fundamental operations.\\n\\nLet\\'s try to fill the logic break reversely:\\nto get to (s-b-1, a) from (a, b), notice a is swapped, we guess the last operation may be mirror against diagnal. so the path now becomes:\\n(a,b) -> (a, s-b-1) -> (s-b-1, a)//the last mirror can be easily done in place\\n\\nNow we try, how to get to (a, s-b-1) from (a, b) using fundamental in place operations? Well, draw a matrix, and you find out that this is not translation, but some swapping too. Don\\'t worry, you see the operations does not change the row coordinate, so it can be done in place with ease. And you know at this point you design the algorithm for this problem.\\n\\nThis is how the logic flows trying to design the in place algorithm to rotate n*n matrix.\\nBasically, we are trying to break down the operations into easy atomic in place operations. How to break down? Analyze the coordinate characteristics with some basic patterns in mind.\\n\\n"
                    },
                    {
                        "username": "UmerZia",
                        "content": "What If we do not have the diagonal, Just thinking about more dynamic solution!"
                    },
                    {
                        "username": "k3000001",
                        "content": "What exactly does it help measure? That the candidate can remember the trick of swapping rows?"
                    },
                    {
                        "username": "MiliMakwana",
                        "content": "[@Nandhini-Techie](/Nandhini-Techie)  Extra space bro\\n"
                    },
                    {
                        "username": "Nandhini-Techie",
                        "content": "  for (int i = 0; i < matrix.length; i++) {\\n      List<int> subList = [];\\n      for (int j = matrix.length - 1; j >= 0; j--) {\\n        subList.add(matrix[j][i]);\\n      }\\n      output.add(subList);\\n    }"
                    },
                    {
                        "username": "betrayy",
                        "content": "Was thinking the same.. this question is pretty much free if you just memorize it"
                    },
                    {
                        "username": "dkode",
                        "content": "Diagram:\\n\\n![image](https://assets.leetcode.com/users/images/95016c57-f112-4e79-8be7-0f21c814c800_1630583198.7966883.png)\\n\\n# M[i,j] --> M\\'[j,N-1-i]\\n\\nWe know that transpose relation is \\n#### M[i,j]= M[j,i]\\n#### \\n\\nBut the relation we got is slightly differernt\\n\\nThink how to convert\\nM[i,j] to M[N-1-i,j]\\n\\nThis is equivalent to flipping the matrix horizontally.\\n\\nM[i,j] to M[N-1-i,j]\\n\\nTranspose (M[N-1-i,j]) --> M\\'[j,N-1-i]\\n\\nTranspose and flipping are linear operation\\n\\nSimilary you can solve other cases like 90 degree, 180 degree, 270 degree etc\\n\\n\\n"
                    },
                    {
                        "username": "paras178a",
                        "content": "[@user7617Dm](/user7617Dm) If i is zero, then index will you be at for N+1-i ?"
                    },
                    {
                        "username": "user7617Dm",
                        "content": "why is it N-1-i not N+1-i? If N is 4 for a 4x4 matric"
                    },
                    {
                        "username": "StefanPochmann",
                        "content": "    def rotate(matrix)\\n      matrix.replace(matrix.reverse.transpose)\\n    end\\n\\nI like Ruby's wordy style."
                    },
                    {
                        "username": "cbertake",
                        "content": "when will you stop posting solution in discussion?\\n"
                    },
                    {
                        "username": "deadsec",
                        "content": "\\uD83D\\uDE02 Amazon Recruiter => You have been hired."
                    },
                    {
                        "username": "UmerZia",
                        "content": "[@Brut_all](/Brut_all) Definitely Not! "
                    },
                    {
                        "username": "Brut_all",
                        "content": "But the interviwer might not like \\uD83E\\uDD10"
                    },
                    {
                        "username": "chris3109692",
                        "content": "The complexity analyses in the solution is incorrect. For a NxN matrix, the complexity is O(N^2), but our data size is N^2 by itself, hence the proper way to denote complexity should be O(n). Note big O is always measured against the data size, not the dimension size."
                    },
                    {
                        "username": "Triquetra",
                        "content": "Complexity is an equivalence class of functions, it can be expressed as a function of any variable."
                    },
                    {
                        "username": "WilmerKrisp",
                        "content": "# solution 1\\n\\n![image](https://assets.leetcode.com/users/images/e112c117-97a6-431c-99e9-c2b2ca3b84c5_1597576604.2278848.png)\\n\\n![image](https://assets.leetcode.com/users/images/18ce4afa-3e8d-4943-856c-a59d781def40_1597576610.36345.png)\\n\\n\\n# solution 2 (inplace modification)\\n![image](https://assets.leetcode.com/users/images/9f7d86fb-cde6-4760-8088-b683bb52160f_1597580296.4229963.png)\\n\\n![image](https://assets.leetcode.com/users/images/58888c0c-c0b7-4fee-9f8d-537ef2681f0a_1597580313.7932537.png)\\n"
                    },
                    {
                        "username": "Ayush_PY",
                        "content": "Using a second matrix is not allowed"
                    },
                    {
                        "username": "bnuzhanyu",
                        "content": "I had been asked this question in an interview:\\n\\ngiven an R x C  matrix,  rotate 90 degree clockwise **in place** (with constant extra space).\\n**The matrix is given as an array**, you should do this within the array.\\nExample: \\u3002\\ninput: R = 3, C = 4, array = 1 2 3 4 5 6 7 8 9 10 11 12\\noutput: R = 4, C = 3, array = 9 5 1 10 6 2 11 7 3 12 8 4\\n\\nexplaination:\\nthe input matrix is:\\n1 2 3 4\\n5 6 7 8\\n9 10 11 12\\nthe output matrix is:\\n9 5 1\\n10 6 2\\n11 7 3\\n12 8 4\\n\\nThough I have got an idea of solving this problem, but the time complexity is not O(RxC)\\u3002\\nCan anyone got an O(RxC) solution with O(1) space?\\n\\n\\n"
                    },
                    {
                        "username": "mawhadmd",
                        "content": "That\\'s possible to do in place?"
                    },
                    {
                        "username": "anmol_soniii",
                        "content": "T.C = O( R*C )\\nS.C = O(1) [ in place ]\\nsolution:\\nclass Solution {\\npublic:\\n    void rotate(vector<vector<int>>& matrix) {\\n        int row = matrix.size();\\n        int col = matrix[0].size();\\n\\n        for(int i = 0; i<row ;i++){\\n            int j = 0;\\n            while( j<i ){\\n                swap(matrix[i][j],matrix[j][i]);\\n                j++;\\n            }\\n        }\\n\\n        for(int i = 0 ; i < row ; i++){\\n            int n = 0;\\n            int m = col-1;\\n            while(n<m){\\n                swap(matrix[i][n],matrix[i][m]);\\n                n++;\\n                m--;\\n            }\\n        }\\n    }\\n};"
                    },
                    {
                        "username": "chinnamsaireddy1369",
                        "content": "how can u do this without space, this question itself asking to alter given m x n matrix to n x m matrix, then without using new matrix how will you insert n x m into m x n"
                    },
                    {
                        "username": "him_Sarma619",
                        "content": "This is actually a pretty good question.... I\\'m not able to think of a solution for this, if you don\\'t mind can you please provide the solution for the same ?"
                    }
                ]
            },
            {
                "id": 1569197,
                "content": [
                    {
                        "username": "LazyBanda",
                        "content": "I was asked this problem in Amazon for SDE III. I had hardly 25 mins to solve. Since in online interview, first 10 mins went into setup because my interviewer wasnt getting signals. next 25 mins for behavioural. and then this question. Its a tricky problem, nort sure what a company will check with this question. Probably my memorization technique."
                    },
                    {
                        "username": "rquant",
                        "content": "This is a hard problem to solve on the fly. Either you\\'re a genius or you practiced this problem on LeetCode enough I guess."
                    },
                    {
                        "username": "aldogg",
                        "content": "I know your pain. It took me 2 hours to solve it today without looking for the solution :("
                    },
                    {
                        "username": "chiranthanmirle",
                        "content": "![image](https://assets.leetcode.com/users/images/88356185-85ab-4f53-afcb-d7512abc311e_1607548471.039209.png)\\nSorry for the bad images. I am terrible at it.\\n\\nTranspose: Basically run a line from top left to bottom right as shown. Flip the 2 parts around the line.\\n\\nReverse: Flip the whole image around a line to the left or right."
                    },
                    {
                        "username": "wtfcoder",
                        "content": "[@satyamS_71](/satyamS_71)  Reversing every row and transpose is gonna do it "
                    },
                    {
                        "username": "shakthisri",
                        "content": "it totally gave me a different view! thank you"
                    },
                    {
                        "username": "Msey",
                        "content": "[@satyamS_71](/satyamS_71) easiest way to use this trick is to present -90 degree as +270, 270 is a 90 degree three times etc"
                    },
                    {
                        "username": "satyamS_71",
                        "content": "Thanks it helped me a lot , but what if the question asks to rotate the image counter clockwise , then how should I approach the problem?"
                    },
                    {
                        "username": "HarshitGupta_02",
                        "content": "class Solution {\\npublic:\\n    void rotate(vector<vector<int>>& matrix) {\\n        int n=matrix.size();\\n        for(int i=0;i<n;i++){\\n            for(int j=0;j<=i;j++){\\n                swap(matrix[i][j],matrix[j][i]);\\n            }\\n        }\\n        for(int i=0;i<n;i++){\\n            int j=0;\\n            int k=n-1;\\n            while(j<=n/2 && k>=n/2){\\n                swap(matrix[i][j],matrix[i][k]);\\n                j++;\\n                k--;\\n            }\\n        }\\n    }\\n};"
                    },
                    {
                        "username": "Bobzero",
                        "content": "I\\'m always having fun reading the discussions \\uD83D\\uDE03"
                    },
                    {
                        "username": "charlesxiao2",
                        "content": "This post is for rotating the matrix anticlockwise. Sorry, when I post it I didn\\'t notice it. But please read it, because I guarantee you can understand the thought process and came up with your solution for clockwise rotation.\\n\\nSo, we are required to rotate it in place. \\n\\nGive a matrix, there are several operations can be done in matrix in place:\\n\\ntranslation, and swap symmetrically(mirror against diagnal), and probaly some unexpected in place operations.\\n\\nWe are trying to break the rotation operation into these operations that are know to carry on easily in place.\\n\\nFor swap symmetrically, given coordinate (a,b), it will be swapped to (b,a) if following the upper left and buttom right diagnal as mirror.\\nFor translation, given coordinate (a, b), we are able to traslate it to (a, whatever) or (whatever, b) with ease.\\n\\nIf rotated anticlockwise, element at (a,b) will be transfered to the new coordinate of (s-b-1 ,a) with s being the length or width of the matrix.\\nWe are trying to find out the in place operations needed in order to transform the coordinate from (a, b) to (s-b-1, a), with some fundumantal operations\\' coordinate transformation characteristics in mind.\\n\\nwe are trying to fill in the logic path between (a, b) to (s-b-1, a) using the fundamental operations.\\n\\nLet\\'s try to fill the logic break reversely:\\nto get to (s-b-1, a) from (a, b), notice a is swapped, we guess the last operation may be mirror against diagnal. so the path now becomes:\\n(a,b) -> (a, s-b-1) -> (s-b-1, a)//the last mirror can be easily done in place\\n\\nNow we try, how to get to (a, s-b-1) from (a, b) using fundamental in place operations? Well, draw a matrix, and you find out that this is not translation, but some swapping too. Don\\'t worry, you see the operations does not change the row coordinate, so it can be done in place with ease. And you know at this point you design the algorithm for this problem.\\n\\nThis is how the logic flows trying to design the in place algorithm to rotate n*n matrix.\\nBasically, we are trying to break down the operations into easy atomic in place operations. How to break down? Analyze the coordinate characteristics with some basic patterns in mind.\\n\\n"
                    },
                    {
                        "username": "UmerZia",
                        "content": "What If we do not have the diagonal, Just thinking about more dynamic solution!"
                    },
                    {
                        "username": "k3000001",
                        "content": "What exactly does it help measure? That the candidate can remember the trick of swapping rows?"
                    },
                    {
                        "username": "MiliMakwana",
                        "content": "[@Nandhini-Techie](/Nandhini-Techie)  Extra space bro\\n"
                    },
                    {
                        "username": "Nandhini-Techie",
                        "content": "  for (int i = 0; i < matrix.length; i++) {\\n      List<int> subList = [];\\n      for (int j = matrix.length - 1; j >= 0; j--) {\\n        subList.add(matrix[j][i]);\\n      }\\n      output.add(subList);\\n    }"
                    },
                    {
                        "username": "betrayy",
                        "content": "Was thinking the same.. this question is pretty much free if you just memorize it"
                    },
                    {
                        "username": "dkode",
                        "content": "Diagram:\\n\\n![image](https://assets.leetcode.com/users/images/95016c57-f112-4e79-8be7-0f21c814c800_1630583198.7966883.png)\\n\\n# M[i,j] --> M\\'[j,N-1-i]\\n\\nWe know that transpose relation is \\n#### M[i,j]= M[j,i]\\n#### \\n\\nBut the relation we got is slightly differernt\\n\\nThink how to convert\\nM[i,j] to M[N-1-i,j]\\n\\nThis is equivalent to flipping the matrix horizontally.\\n\\nM[i,j] to M[N-1-i,j]\\n\\nTranspose (M[N-1-i,j]) --> M\\'[j,N-1-i]\\n\\nTranspose and flipping are linear operation\\n\\nSimilary you can solve other cases like 90 degree, 180 degree, 270 degree etc\\n\\n\\n"
                    },
                    {
                        "username": "paras178a",
                        "content": "[@user7617Dm](/user7617Dm) If i is zero, then index will you be at for N+1-i ?"
                    },
                    {
                        "username": "user7617Dm",
                        "content": "why is it N-1-i not N+1-i? If N is 4 for a 4x4 matric"
                    },
                    {
                        "username": "StefanPochmann",
                        "content": "    def rotate(matrix)\\n      matrix.replace(matrix.reverse.transpose)\\n    end\\n\\nI like Ruby's wordy style."
                    },
                    {
                        "username": "cbertake",
                        "content": "when will you stop posting solution in discussion?\\n"
                    },
                    {
                        "username": "deadsec",
                        "content": "\\uD83D\\uDE02 Amazon Recruiter => You have been hired."
                    },
                    {
                        "username": "UmerZia",
                        "content": "[@Brut_all](/Brut_all) Definitely Not! "
                    },
                    {
                        "username": "Brut_all",
                        "content": "But the interviwer might not like \\uD83E\\uDD10"
                    },
                    {
                        "username": "chris3109692",
                        "content": "The complexity analyses in the solution is incorrect. For a NxN matrix, the complexity is O(N^2), but our data size is N^2 by itself, hence the proper way to denote complexity should be O(n). Note big O is always measured against the data size, not the dimension size."
                    },
                    {
                        "username": "Triquetra",
                        "content": "Complexity is an equivalence class of functions, it can be expressed as a function of any variable."
                    },
                    {
                        "username": "WilmerKrisp",
                        "content": "# solution 1\\n\\n![image](https://assets.leetcode.com/users/images/e112c117-97a6-431c-99e9-c2b2ca3b84c5_1597576604.2278848.png)\\n\\n![image](https://assets.leetcode.com/users/images/18ce4afa-3e8d-4943-856c-a59d781def40_1597576610.36345.png)\\n\\n\\n# solution 2 (inplace modification)\\n![image](https://assets.leetcode.com/users/images/9f7d86fb-cde6-4760-8088-b683bb52160f_1597580296.4229963.png)\\n\\n![image](https://assets.leetcode.com/users/images/58888c0c-c0b7-4fee-9f8d-537ef2681f0a_1597580313.7932537.png)\\n"
                    },
                    {
                        "username": "Ayush_PY",
                        "content": "Using a second matrix is not allowed"
                    },
                    {
                        "username": "bnuzhanyu",
                        "content": "I had been asked this question in an interview:\\n\\ngiven an R x C  matrix,  rotate 90 degree clockwise **in place** (with constant extra space).\\n**The matrix is given as an array**, you should do this within the array.\\nExample: \\u3002\\ninput: R = 3, C = 4, array = 1 2 3 4 5 6 7 8 9 10 11 12\\noutput: R = 4, C = 3, array = 9 5 1 10 6 2 11 7 3 12 8 4\\n\\nexplaination:\\nthe input matrix is:\\n1 2 3 4\\n5 6 7 8\\n9 10 11 12\\nthe output matrix is:\\n9 5 1\\n10 6 2\\n11 7 3\\n12 8 4\\n\\nThough I have got an idea of solving this problem, but the time complexity is not O(RxC)\\u3002\\nCan anyone got an O(RxC) solution with O(1) space?\\n\\n\\n"
                    },
                    {
                        "username": "mawhadmd",
                        "content": "That\\'s possible to do in place?"
                    },
                    {
                        "username": "anmol_soniii",
                        "content": "T.C = O( R*C )\\nS.C = O(1) [ in place ]\\nsolution:\\nclass Solution {\\npublic:\\n    void rotate(vector<vector<int>>& matrix) {\\n        int row = matrix.size();\\n        int col = matrix[0].size();\\n\\n        for(int i = 0; i<row ;i++){\\n            int j = 0;\\n            while( j<i ){\\n                swap(matrix[i][j],matrix[j][i]);\\n                j++;\\n            }\\n        }\\n\\n        for(int i = 0 ; i < row ; i++){\\n            int n = 0;\\n            int m = col-1;\\n            while(n<m){\\n                swap(matrix[i][n],matrix[i][m]);\\n                n++;\\n                m--;\\n            }\\n        }\\n    }\\n};"
                    },
                    {
                        "username": "chinnamsaireddy1369",
                        "content": "how can u do this without space, this question itself asking to alter given m x n matrix to n x m matrix, then without using new matrix how will you insert n x m into m x n"
                    },
                    {
                        "username": "him_Sarma619",
                        "content": "This is actually a pretty good question.... I\\'m not able to think of a solution for this, if you don\\'t mind can you please provide the solution for the same ?"
                    }
                ]
            },
            {
                "id": 1570087,
                "content": [
                    {
                        "username": "LazyBanda",
                        "content": "I was asked this problem in Amazon for SDE III. I had hardly 25 mins to solve. Since in online interview, first 10 mins went into setup because my interviewer wasnt getting signals. next 25 mins for behavioural. and then this question. Its a tricky problem, nort sure what a company will check with this question. Probably my memorization technique."
                    },
                    {
                        "username": "rquant",
                        "content": "This is a hard problem to solve on the fly. Either you\\'re a genius or you practiced this problem on LeetCode enough I guess."
                    },
                    {
                        "username": "aldogg",
                        "content": "I know your pain. It took me 2 hours to solve it today without looking for the solution :("
                    },
                    {
                        "username": "chiranthanmirle",
                        "content": "![image](https://assets.leetcode.com/users/images/88356185-85ab-4f53-afcb-d7512abc311e_1607548471.039209.png)\\nSorry for the bad images. I am terrible at it.\\n\\nTranspose: Basically run a line from top left to bottom right as shown. Flip the 2 parts around the line.\\n\\nReverse: Flip the whole image around a line to the left or right."
                    },
                    {
                        "username": "wtfcoder",
                        "content": "[@satyamS_71](/satyamS_71)  Reversing every row and transpose is gonna do it "
                    },
                    {
                        "username": "shakthisri",
                        "content": "it totally gave me a different view! thank you"
                    },
                    {
                        "username": "Msey",
                        "content": "[@satyamS_71](/satyamS_71) easiest way to use this trick is to present -90 degree as +270, 270 is a 90 degree three times etc"
                    },
                    {
                        "username": "satyamS_71",
                        "content": "Thanks it helped me a lot , but what if the question asks to rotate the image counter clockwise , then how should I approach the problem?"
                    },
                    {
                        "username": "HarshitGupta_02",
                        "content": "class Solution {\\npublic:\\n    void rotate(vector<vector<int>>& matrix) {\\n        int n=matrix.size();\\n        for(int i=0;i<n;i++){\\n            for(int j=0;j<=i;j++){\\n                swap(matrix[i][j],matrix[j][i]);\\n            }\\n        }\\n        for(int i=0;i<n;i++){\\n            int j=0;\\n            int k=n-1;\\n            while(j<=n/2 && k>=n/2){\\n                swap(matrix[i][j],matrix[i][k]);\\n                j++;\\n                k--;\\n            }\\n        }\\n    }\\n};"
                    },
                    {
                        "username": "Bobzero",
                        "content": "I\\'m always having fun reading the discussions \\uD83D\\uDE03"
                    },
                    {
                        "username": "charlesxiao2",
                        "content": "This post is for rotating the matrix anticlockwise. Sorry, when I post it I didn\\'t notice it. But please read it, because I guarantee you can understand the thought process and came up with your solution for clockwise rotation.\\n\\nSo, we are required to rotate it in place. \\n\\nGive a matrix, there are several operations can be done in matrix in place:\\n\\ntranslation, and swap symmetrically(mirror against diagnal), and probaly some unexpected in place operations.\\n\\nWe are trying to break the rotation operation into these operations that are know to carry on easily in place.\\n\\nFor swap symmetrically, given coordinate (a,b), it will be swapped to (b,a) if following the upper left and buttom right diagnal as mirror.\\nFor translation, given coordinate (a, b), we are able to traslate it to (a, whatever) or (whatever, b) with ease.\\n\\nIf rotated anticlockwise, element at (a,b) will be transfered to the new coordinate of (s-b-1 ,a) with s being the length or width of the matrix.\\nWe are trying to find out the in place operations needed in order to transform the coordinate from (a, b) to (s-b-1, a), with some fundumantal operations\\' coordinate transformation characteristics in mind.\\n\\nwe are trying to fill in the logic path between (a, b) to (s-b-1, a) using the fundamental operations.\\n\\nLet\\'s try to fill the logic break reversely:\\nto get to (s-b-1, a) from (a, b), notice a is swapped, we guess the last operation may be mirror against diagnal. so the path now becomes:\\n(a,b) -> (a, s-b-1) -> (s-b-1, a)//the last mirror can be easily done in place\\n\\nNow we try, how to get to (a, s-b-1) from (a, b) using fundamental in place operations? Well, draw a matrix, and you find out that this is not translation, but some swapping too. Don\\'t worry, you see the operations does not change the row coordinate, so it can be done in place with ease. And you know at this point you design the algorithm for this problem.\\n\\nThis is how the logic flows trying to design the in place algorithm to rotate n*n matrix.\\nBasically, we are trying to break down the operations into easy atomic in place operations. How to break down? Analyze the coordinate characteristics with some basic patterns in mind.\\n\\n"
                    },
                    {
                        "username": "UmerZia",
                        "content": "What If we do not have the diagonal, Just thinking about more dynamic solution!"
                    },
                    {
                        "username": "k3000001",
                        "content": "What exactly does it help measure? That the candidate can remember the trick of swapping rows?"
                    },
                    {
                        "username": "MiliMakwana",
                        "content": "[@Nandhini-Techie](/Nandhini-Techie)  Extra space bro\\n"
                    },
                    {
                        "username": "Nandhini-Techie",
                        "content": "  for (int i = 0; i < matrix.length; i++) {\\n      List<int> subList = [];\\n      for (int j = matrix.length - 1; j >= 0; j--) {\\n        subList.add(matrix[j][i]);\\n      }\\n      output.add(subList);\\n    }"
                    },
                    {
                        "username": "betrayy",
                        "content": "Was thinking the same.. this question is pretty much free if you just memorize it"
                    },
                    {
                        "username": "dkode",
                        "content": "Diagram:\\n\\n![image](https://assets.leetcode.com/users/images/95016c57-f112-4e79-8be7-0f21c814c800_1630583198.7966883.png)\\n\\n# M[i,j] --> M\\'[j,N-1-i]\\n\\nWe know that transpose relation is \\n#### M[i,j]= M[j,i]\\n#### \\n\\nBut the relation we got is slightly differernt\\n\\nThink how to convert\\nM[i,j] to M[N-1-i,j]\\n\\nThis is equivalent to flipping the matrix horizontally.\\n\\nM[i,j] to M[N-1-i,j]\\n\\nTranspose (M[N-1-i,j]) --> M\\'[j,N-1-i]\\n\\nTranspose and flipping are linear operation\\n\\nSimilary you can solve other cases like 90 degree, 180 degree, 270 degree etc\\n\\n\\n"
                    },
                    {
                        "username": "paras178a",
                        "content": "[@user7617Dm](/user7617Dm) If i is zero, then index will you be at for N+1-i ?"
                    },
                    {
                        "username": "user7617Dm",
                        "content": "why is it N-1-i not N+1-i? If N is 4 for a 4x4 matric"
                    },
                    {
                        "username": "StefanPochmann",
                        "content": "    def rotate(matrix)\\n      matrix.replace(matrix.reverse.transpose)\\n    end\\n\\nI like Ruby's wordy style."
                    },
                    {
                        "username": "cbertake",
                        "content": "when will you stop posting solution in discussion?\\n"
                    },
                    {
                        "username": "deadsec",
                        "content": "\\uD83D\\uDE02 Amazon Recruiter => You have been hired."
                    },
                    {
                        "username": "UmerZia",
                        "content": "[@Brut_all](/Brut_all) Definitely Not! "
                    },
                    {
                        "username": "Brut_all",
                        "content": "But the interviwer might not like \\uD83E\\uDD10"
                    },
                    {
                        "username": "chris3109692",
                        "content": "The complexity analyses in the solution is incorrect. For a NxN matrix, the complexity is O(N^2), but our data size is N^2 by itself, hence the proper way to denote complexity should be O(n). Note big O is always measured against the data size, not the dimension size."
                    },
                    {
                        "username": "Triquetra",
                        "content": "Complexity is an equivalence class of functions, it can be expressed as a function of any variable."
                    },
                    {
                        "username": "WilmerKrisp",
                        "content": "# solution 1\\n\\n![image](https://assets.leetcode.com/users/images/e112c117-97a6-431c-99e9-c2b2ca3b84c5_1597576604.2278848.png)\\n\\n![image](https://assets.leetcode.com/users/images/18ce4afa-3e8d-4943-856c-a59d781def40_1597576610.36345.png)\\n\\n\\n# solution 2 (inplace modification)\\n![image](https://assets.leetcode.com/users/images/9f7d86fb-cde6-4760-8088-b683bb52160f_1597580296.4229963.png)\\n\\n![image](https://assets.leetcode.com/users/images/58888c0c-c0b7-4fee-9f8d-537ef2681f0a_1597580313.7932537.png)\\n"
                    },
                    {
                        "username": "Ayush_PY",
                        "content": "Using a second matrix is not allowed"
                    },
                    {
                        "username": "bnuzhanyu",
                        "content": "I had been asked this question in an interview:\\n\\ngiven an R x C  matrix,  rotate 90 degree clockwise **in place** (with constant extra space).\\n**The matrix is given as an array**, you should do this within the array.\\nExample: \\u3002\\ninput: R = 3, C = 4, array = 1 2 3 4 5 6 7 8 9 10 11 12\\noutput: R = 4, C = 3, array = 9 5 1 10 6 2 11 7 3 12 8 4\\n\\nexplaination:\\nthe input matrix is:\\n1 2 3 4\\n5 6 7 8\\n9 10 11 12\\nthe output matrix is:\\n9 5 1\\n10 6 2\\n11 7 3\\n12 8 4\\n\\nThough I have got an idea of solving this problem, but the time complexity is not O(RxC)\\u3002\\nCan anyone got an O(RxC) solution with O(1) space?\\n\\n\\n"
                    },
                    {
                        "username": "mawhadmd",
                        "content": "That\\'s possible to do in place?"
                    },
                    {
                        "username": "anmol_soniii",
                        "content": "T.C = O( R*C )\\nS.C = O(1) [ in place ]\\nsolution:\\nclass Solution {\\npublic:\\n    void rotate(vector<vector<int>>& matrix) {\\n        int row = matrix.size();\\n        int col = matrix[0].size();\\n\\n        for(int i = 0; i<row ;i++){\\n            int j = 0;\\n            while( j<i ){\\n                swap(matrix[i][j],matrix[j][i]);\\n                j++;\\n            }\\n        }\\n\\n        for(int i = 0 ; i < row ; i++){\\n            int n = 0;\\n            int m = col-1;\\n            while(n<m){\\n                swap(matrix[i][n],matrix[i][m]);\\n                n++;\\n                m--;\\n            }\\n        }\\n    }\\n};"
                    },
                    {
                        "username": "chinnamsaireddy1369",
                        "content": "how can u do this without space, this question itself asking to alter given m x n matrix to n x m matrix, then without using new matrix how will you insert n x m into m x n"
                    },
                    {
                        "username": "him_Sarma619",
                        "content": "This is actually a pretty good question.... I\\'m not able to think of a solution for this, if you don\\'t mind can you please provide the solution for the same ?"
                    }
                ]
            },
            {
                "id": 1574669,
                "content": [
                    {
                        "username": "LazyBanda",
                        "content": "I was asked this problem in Amazon for SDE III. I had hardly 25 mins to solve. Since in online interview, first 10 mins went into setup because my interviewer wasnt getting signals. next 25 mins for behavioural. and then this question. Its a tricky problem, nort sure what a company will check with this question. Probably my memorization technique."
                    },
                    {
                        "username": "rquant",
                        "content": "This is a hard problem to solve on the fly. Either you\\'re a genius or you practiced this problem on LeetCode enough I guess."
                    },
                    {
                        "username": "aldogg",
                        "content": "I know your pain. It took me 2 hours to solve it today without looking for the solution :("
                    },
                    {
                        "username": "chiranthanmirle",
                        "content": "![image](https://assets.leetcode.com/users/images/88356185-85ab-4f53-afcb-d7512abc311e_1607548471.039209.png)\\nSorry for the bad images. I am terrible at it.\\n\\nTranspose: Basically run a line from top left to bottom right as shown. Flip the 2 parts around the line.\\n\\nReverse: Flip the whole image around a line to the left or right."
                    },
                    {
                        "username": "wtfcoder",
                        "content": "[@satyamS_71](/satyamS_71)  Reversing every row and transpose is gonna do it "
                    },
                    {
                        "username": "shakthisri",
                        "content": "it totally gave me a different view! thank you"
                    },
                    {
                        "username": "Msey",
                        "content": "[@satyamS_71](/satyamS_71) easiest way to use this trick is to present -90 degree as +270, 270 is a 90 degree three times etc"
                    },
                    {
                        "username": "satyamS_71",
                        "content": "Thanks it helped me a lot , but what if the question asks to rotate the image counter clockwise , then how should I approach the problem?"
                    },
                    {
                        "username": "HarshitGupta_02",
                        "content": "class Solution {\\npublic:\\n    void rotate(vector<vector<int>>& matrix) {\\n        int n=matrix.size();\\n        for(int i=0;i<n;i++){\\n            for(int j=0;j<=i;j++){\\n                swap(matrix[i][j],matrix[j][i]);\\n            }\\n        }\\n        for(int i=0;i<n;i++){\\n            int j=0;\\n            int k=n-1;\\n            while(j<=n/2 && k>=n/2){\\n                swap(matrix[i][j],matrix[i][k]);\\n                j++;\\n                k--;\\n            }\\n        }\\n    }\\n};"
                    },
                    {
                        "username": "Bobzero",
                        "content": "I\\'m always having fun reading the discussions \\uD83D\\uDE03"
                    },
                    {
                        "username": "charlesxiao2",
                        "content": "This post is for rotating the matrix anticlockwise. Sorry, when I post it I didn\\'t notice it. But please read it, because I guarantee you can understand the thought process and came up with your solution for clockwise rotation.\\n\\nSo, we are required to rotate it in place. \\n\\nGive a matrix, there are several operations can be done in matrix in place:\\n\\ntranslation, and swap symmetrically(mirror against diagnal), and probaly some unexpected in place operations.\\n\\nWe are trying to break the rotation operation into these operations that are know to carry on easily in place.\\n\\nFor swap symmetrically, given coordinate (a,b), it will be swapped to (b,a) if following the upper left and buttom right diagnal as mirror.\\nFor translation, given coordinate (a, b), we are able to traslate it to (a, whatever) or (whatever, b) with ease.\\n\\nIf rotated anticlockwise, element at (a,b) will be transfered to the new coordinate of (s-b-1 ,a) with s being the length or width of the matrix.\\nWe are trying to find out the in place operations needed in order to transform the coordinate from (a, b) to (s-b-1, a), with some fundumantal operations\\' coordinate transformation characteristics in mind.\\n\\nwe are trying to fill in the logic path between (a, b) to (s-b-1, a) using the fundamental operations.\\n\\nLet\\'s try to fill the logic break reversely:\\nto get to (s-b-1, a) from (a, b), notice a is swapped, we guess the last operation may be mirror against diagnal. so the path now becomes:\\n(a,b) -> (a, s-b-1) -> (s-b-1, a)//the last mirror can be easily done in place\\n\\nNow we try, how to get to (a, s-b-1) from (a, b) using fundamental in place operations? Well, draw a matrix, and you find out that this is not translation, but some swapping too. Don\\'t worry, you see the operations does not change the row coordinate, so it can be done in place with ease. And you know at this point you design the algorithm for this problem.\\n\\nThis is how the logic flows trying to design the in place algorithm to rotate n*n matrix.\\nBasically, we are trying to break down the operations into easy atomic in place operations. How to break down? Analyze the coordinate characteristics with some basic patterns in mind.\\n\\n"
                    },
                    {
                        "username": "UmerZia",
                        "content": "What If we do not have the diagonal, Just thinking about more dynamic solution!"
                    },
                    {
                        "username": "k3000001",
                        "content": "What exactly does it help measure? That the candidate can remember the trick of swapping rows?"
                    },
                    {
                        "username": "MiliMakwana",
                        "content": "[@Nandhini-Techie](/Nandhini-Techie)  Extra space bro\\n"
                    },
                    {
                        "username": "Nandhini-Techie",
                        "content": "  for (int i = 0; i < matrix.length; i++) {\\n      List<int> subList = [];\\n      for (int j = matrix.length - 1; j >= 0; j--) {\\n        subList.add(matrix[j][i]);\\n      }\\n      output.add(subList);\\n    }"
                    },
                    {
                        "username": "betrayy",
                        "content": "Was thinking the same.. this question is pretty much free if you just memorize it"
                    },
                    {
                        "username": "dkode",
                        "content": "Diagram:\\n\\n![image](https://assets.leetcode.com/users/images/95016c57-f112-4e79-8be7-0f21c814c800_1630583198.7966883.png)\\n\\n# M[i,j] --> M\\'[j,N-1-i]\\n\\nWe know that transpose relation is \\n#### M[i,j]= M[j,i]\\n#### \\n\\nBut the relation we got is slightly differernt\\n\\nThink how to convert\\nM[i,j] to M[N-1-i,j]\\n\\nThis is equivalent to flipping the matrix horizontally.\\n\\nM[i,j] to M[N-1-i,j]\\n\\nTranspose (M[N-1-i,j]) --> M\\'[j,N-1-i]\\n\\nTranspose and flipping are linear operation\\n\\nSimilary you can solve other cases like 90 degree, 180 degree, 270 degree etc\\n\\n\\n"
                    },
                    {
                        "username": "paras178a",
                        "content": "[@user7617Dm](/user7617Dm) If i is zero, then index will you be at for N+1-i ?"
                    },
                    {
                        "username": "user7617Dm",
                        "content": "why is it N-1-i not N+1-i? If N is 4 for a 4x4 matric"
                    },
                    {
                        "username": "StefanPochmann",
                        "content": "    def rotate(matrix)\\n      matrix.replace(matrix.reverse.transpose)\\n    end\\n\\nI like Ruby's wordy style."
                    },
                    {
                        "username": "cbertake",
                        "content": "when will you stop posting solution in discussion?\\n"
                    },
                    {
                        "username": "deadsec",
                        "content": "\\uD83D\\uDE02 Amazon Recruiter => You have been hired."
                    },
                    {
                        "username": "UmerZia",
                        "content": "[@Brut_all](/Brut_all) Definitely Not! "
                    },
                    {
                        "username": "Brut_all",
                        "content": "But the interviwer might not like \\uD83E\\uDD10"
                    },
                    {
                        "username": "chris3109692",
                        "content": "The complexity analyses in the solution is incorrect. For a NxN matrix, the complexity is O(N^2), but our data size is N^2 by itself, hence the proper way to denote complexity should be O(n). Note big O is always measured against the data size, not the dimension size."
                    },
                    {
                        "username": "Triquetra",
                        "content": "Complexity is an equivalence class of functions, it can be expressed as a function of any variable."
                    },
                    {
                        "username": "WilmerKrisp",
                        "content": "# solution 1\\n\\n![image](https://assets.leetcode.com/users/images/e112c117-97a6-431c-99e9-c2b2ca3b84c5_1597576604.2278848.png)\\n\\n![image](https://assets.leetcode.com/users/images/18ce4afa-3e8d-4943-856c-a59d781def40_1597576610.36345.png)\\n\\n\\n# solution 2 (inplace modification)\\n![image](https://assets.leetcode.com/users/images/9f7d86fb-cde6-4760-8088-b683bb52160f_1597580296.4229963.png)\\n\\n![image](https://assets.leetcode.com/users/images/58888c0c-c0b7-4fee-9f8d-537ef2681f0a_1597580313.7932537.png)\\n"
                    },
                    {
                        "username": "Ayush_PY",
                        "content": "Using a second matrix is not allowed"
                    },
                    {
                        "username": "bnuzhanyu",
                        "content": "I had been asked this question in an interview:\\n\\ngiven an R x C  matrix,  rotate 90 degree clockwise **in place** (with constant extra space).\\n**The matrix is given as an array**, you should do this within the array.\\nExample: \\u3002\\ninput: R = 3, C = 4, array = 1 2 3 4 5 6 7 8 9 10 11 12\\noutput: R = 4, C = 3, array = 9 5 1 10 6 2 11 7 3 12 8 4\\n\\nexplaination:\\nthe input matrix is:\\n1 2 3 4\\n5 6 7 8\\n9 10 11 12\\nthe output matrix is:\\n9 5 1\\n10 6 2\\n11 7 3\\n12 8 4\\n\\nThough I have got an idea of solving this problem, but the time complexity is not O(RxC)\\u3002\\nCan anyone got an O(RxC) solution with O(1) space?\\n\\n\\n"
                    },
                    {
                        "username": "mawhadmd",
                        "content": "That\\'s possible to do in place?"
                    },
                    {
                        "username": "anmol_soniii",
                        "content": "T.C = O( R*C )\\nS.C = O(1) [ in place ]\\nsolution:\\nclass Solution {\\npublic:\\n    void rotate(vector<vector<int>>& matrix) {\\n        int row = matrix.size();\\n        int col = matrix[0].size();\\n\\n        for(int i = 0; i<row ;i++){\\n            int j = 0;\\n            while( j<i ){\\n                swap(matrix[i][j],matrix[j][i]);\\n                j++;\\n            }\\n        }\\n\\n        for(int i = 0 ; i < row ; i++){\\n            int n = 0;\\n            int m = col-1;\\n            while(n<m){\\n                swap(matrix[i][n],matrix[i][m]);\\n                n++;\\n                m--;\\n            }\\n        }\\n    }\\n};"
                    },
                    {
                        "username": "chinnamsaireddy1369",
                        "content": "how can u do this without space, this question itself asking to alter given m x n matrix to n x m matrix, then without using new matrix how will you insert n x m into m x n"
                    },
                    {
                        "username": "him_Sarma619",
                        "content": "This is actually a pretty good question.... I\\'m not able to think of a solution for this, if you don\\'t mind can you please provide the solution for the same ?"
                    }
                ]
            },
            {
                "id": 1698940,
                "content": [
                    {
                        "username": "LazyBanda",
                        "content": "I was asked this problem in Amazon for SDE III. I had hardly 25 mins to solve. Since in online interview, first 10 mins went into setup because my interviewer wasnt getting signals. next 25 mins for behavioural. and then this question. Its a tricky problem, nort sure what a company will check with this question. Probably my memorization technique."
                    },
                    {
                        "username": "rquant",
                        "content": "This is a hard problem to solve on the fly. Either you\\'re a genius or you practiced this problem on LeetCode enough I guess."
                    },
                    {
                        "username": "aldogg",
                        "content": "I know your pain. It took me 2 hours to solve it today without looking for the solution :("
                    },
                    {
                        "username": "chiranthanmirle",
                        "content": "![image](https://assets.leetcode.com/users/images/88356185-85ab-4f53-afcb-d7512abc311e_1607548471.039209.png)\\nSorry for the bad images. I am terrible at it.\\n\\nTranspose: Basically run a line from top left to bottom right as shown. Flip the 2 parts around the line.\\n\\nReverse: Flip the whole image around a line to the left or right."
                    },
                    {
                        "username": "wtfcoder",
                        "content": "[@satyamS_71](/satyamS_71)  Reversing every row and transpose is gonna do it "
                    },
                    {
                        "username": "shakthisri",
                        "content": "it totally gave me a different view! thank you"
                    },
                    {
                        "username": "Msey",
                        "content": "[@satyamS_71](/satyamS_71) easiest way to use this trick is to present -90 degree as +270, 270 is a 90 degree three times etc"
                    },
                    {
                        "username": "satyamS_71",
                        "content": "Thanks it helped me a lot , but what if the question asks to rotate the image counter clockwise , then how should I approach the problem?"
                    },
                    {
                        "username": "HarshitGupta_02",
                        "content": "class Solution {\\npublic:\\n    void rotate(vector<vector<int>>& matrix) {\\n        int n=matrix.size();\\n        for(int i=0;i<n;i++){\\n            for(int j=0;j<=i;j++){\\n                swap(matrix[i][j],matrix[j][i]);\\n            }\\n        }\\n        for(int i=0;i<n;i++){\\n            int j=0;\\n            int k=n-1;\\n            while(j<=n/2 && k>=n/2){\\n                swap(matrix[i][j],matrix[i][k]);\\n                j++;\\n                k--;\\n            }\\n        }\\n    }\\n};"
                    },
                    {
                        "username": "Bobzero",
                        "content": "I\\'m always having fun reading the discussions \\uD83D\\uDE03"
                    },
                    {
                        "username": "charlesxiao2",
                        "content": "This post is for rotating the matrix anticlockwise. Sorry, when I post it I didn\\'t notice it. But please read it, because I guarantee you can understand the thought process and came up with your solution for clockwise rotation.\\n\\nSo, we are required to rotate it in place. \\n\\nGive a matrix, there are several operations can be done in matrix in place:\\n\\ntranslation, and swap symmetrically(mirror against diagnal), and probaly some unexpected in place operations.\\n\\nWe are trying to break the rotation operation into these operations that are know to carry on easily in place.\\n\\nFor swap symmetrically, given coordinate (a,b), it will be swapped to (b,a) if following the upper left and buttom right diagnal as mirror.\\nFor translation, given coordinate (a, b), we are able to traslate it to (a, whatever) or (whatever, b) with ease.\\n\\nIf rotated anticlockwise, element at (a,b) will be transfered to the new coordinate of (s-b-1 ,a) with s being the length or width of the matrix.\\nWe are trying to find out the in place operations needed in order to transform the coordinate from (a, b) to (s-b-1, a), with some fundumantal operations\\' coordinate transformation characteristics in mind.\\n\\nwe are trying to fill in the logic path between (a, b) to (s-b-1, a) using the fundamental operations.\\n\\nLet\\'s try to fill the logic break reversely:\\nto get to (s-b-1, a) from (a, b), notice a is swapped, we guess the last operation may be mirror against diagnal. so the path now becomes:\\n(a,b) -> (a, s-b-1) -> (s-b-1, a)//the last mirror can be easily done in place\\n\\nNow we try, how to get to (a, s-b-1) from (a, b) using fundamental in place operations? Well, draw a matrix, and you find out that this is not translation, but some swapping too. Don\\'t worry, you see the operations does not change the row coordinate, so it can be done in place with ease. And you know at this point you design the algorithm for this problem.\\n\\nThis is how the logic flows trying to design the in place algorithm to rotate n*n matrix.\\nBasically, we are trying to break down the operations into easy atomic in place operations. How to break down? Analyze the coordinate characteristics with some basic patterns in mind.\\n\\n"
                    },
                    {
                        "username": "UmerZia",
                        "content": "What If we do not have the diagonal, Just thinking about more dynamic solution!"
                    },
                    {
                        "username": "k3000001",
                        "content": "What exactly does it help measure? That the candidate can remember the trick of swapping rows?"
                    },
                    {
                        "username": "MiliMakwana",
                        "content": "[@Nandhini-Techie](/Nandhini-Techie)  Extra space bro\\n"
                    },
                    {
                        "username": "Nandhini-Techie",
                        "content": "  for (int i = 0; i < matrix.length; i++) {\\n      List<int> subList = [];\\n      for (int j = matrix.length - 1; j >= 0; j--) {\\n        subList.add(matrix[j][i]);\\n      }\\n      output.add(subList);\\n    }"
                    },
                    {
                        "username": "betrayy",
                        "content": "Was thinking the same.. this question is pretty much free if you just memorize it"
                    },
                    {
                        "username": "dkode",
                        "content": "Diagram:\\n\\n![image](https://assets.leetcode.com/users/images/95016c57-f112-4e79-8be7-0f21c814c800_1630583198.7966883.png)\\n\\n# M[i,j] --> M\\'[j,N-1-i]\\n\\nWe know that transpose relation is \\n#### M[i,j]= M[j,i]\\n#### \\n\\nBut the relation we got is slightly differernt\\n\\nThink how to convert\\nM[i,j] to M[N-1-i,j]\\n\\nThis is equivalent to flipping the matrix horizontally.\\n\\nM[i,j] to M[N-1-i,j]\\n\\nTranspose (M[N-1-i,j]) --> M\\'[j,N-1-i]\\n\\nTranspose and flipping are linear operation\\n\\nSimilary you can solve other cases like 90 degree, 180 degree, 270 degree etc\\n\\n\\n"
                    },
                    {
                        "username": "paras178a",
                        "content": "[@user7617Dm](/user7617Dm) If i is zero, then index will you be at for N+1-i ?"
                    },
                    {
                        "username": "user7617Dm",
                        "content": "why is it N-1-i not N+1-i? If N is 4 for a 4x4 matric"
                    },
                    {
                        "username": "StefanPochmann",
                        "content": "    def rotate(matrix)\\n      matrix.replace(matrix.reverse.transpose)\\n    end\\n\\nI like Ruby's wordy style."
                    },
                    {
                        "username": "cbertake",
                        "content": "when will you stop posting solution in discussion?\\n"
                    },
                    {
                        "username": "deadsec",
                        "content": "\\uD83D\\uDE02 Amazon Recruiter => You have been hired."
                    },
                    {
                        "username": "UmerZia",
                        "content": "[@Brut_all](/Brut_all) Definitely Not! "
                    },
                    {
                        "username": "Brut_all",
                        "content": "But the interviwer might not like \\uD83E\\uDD10"
                    },
                    {
                        "username": "chris3109692",
                        "content": "The complexity analyses in the solution is incorrect. For a NxN matrix, the complexity is O(N^2), but our data size is N^2 by itself, hence the proper way to denote complexity should be O(n). Note big O is always measured against the data size, not the dimension size."
                    },
                    {
                        "username": "Triquetra",
                        "content": "Complexity is an equivalence class of functions, it can be expressed as a function of any variable."
                    },
                    {
                        "username": "WilmerKrisp",
                        "content": "# solution 1\\n\\n![image](https://assets.leetcode.com/users/images/e112c117-97a6-431c-99e9-c2b2ca3b84c5_1597576604.2278848.png)\\n\\n![image](https://assets.leetcode.com/users/images/18ce4afa-3e8d-4943-856c-a59d781def40_1597576610.36345.png)\\n\\n\\n# solution 2 (inplace modification)\\n![image](https://assets.leetcode.com/users/images/9f7d86fb-cde6-4760-8088-b683bb52160f_1597580296.4229963.png)\\n\\n![image](https://assets.leetcode.com/users/images/58888c0c-c0b7-4fee-9f8d-537ef2681f0a_1597580313.7932537.png)\\n"
                    },
                    {
                        "username": "Ayush_PY",
                        "content": "Using a second matrix is not allowed"
                    },
                    {
                        "username": "bnuzhanyu",
                        "content": "I had been asked this question in an interview:\\n\\ngiven an R x C  matrix,  rotate 90 degree clockwise **in place** (with constant extra space).\\n**The matrix is given as an array**, you should do this within the array.\\nExample: \\u3002\\ninput: R = 3, C = 4, array = 1 2 3 4 5 6 7 8 9 10 11 12\\noutput: R = 4, C = 3, array = 9 5 1 10 6 2 11 7 3 12 8 4\\n\\nexplaination:\\nthe input matrix is:\\n1 2 3 4\\n5 6 7 8\\n9 10 11 12\\nthe output matrix is:\\n9 5 1\\n10 6 2\\n11 7 3\\n12 8 4\\n\\nThough I have got an idea of solving this problem, but the time complexity is not O(RxC)\\u3002\\nCan anyone got an O(RxC) solution with O(1) space?\\n\\n\\n"
                    },
                    {
                        "username": "mawhadmd",
                        "content": "That\\'s possible to do in place?"
                    },
                    {
                        "username": "anmol_soniii",
                        "content": "T.C = O( R*C )\\nS.C = O(1) [ in place ]\\nsolution:\\nclass Solution {\\npublic:\\n    void rotate(vector<vector<int>>& matrix) {\\n        int row = matrix.size();\\n        int col = matrix[0].size();\\n\\n        for(int i = 0; i<row ;i++){\\n            int j = 0;\\n            while( j<i ){\\n                swap(matrix[i][j],matrix[j][i]);\\n                j++;\\n            }\\n        }\\n\\n        for(int i = 0 ; i < row ; i++){\\n            int n = 0;\\n            int m = col-1;\\n            while(n<m){\\n                swap(matrix[i][n],matrix[i][m]);\\n                n++;\\n                m--;\\n            }\\n        }\\n    }\\n};"
                    },
                    {
                        "username": "chinnamsaireddy1369",
                        "content": "how can u do this without space, this question itself asking to alter given m x n matrix to n x m matrix, then without using new matrix how will you insert n x m into m x n"
                    },
                    {
                        "username": "him_Sarma619",
                        "content": "This is actually a pretty good question.... I\\'m not able to think of a solution for this, if you don\\'t mind can you please provide the solution for the same ?"
                    }
                ]
            },
            {
                "id": 1566321,
                "content": [
                    {
                        "username": "LazyBanda",
                        "content": "I was asked this problem in Amazon for SDE III. I had hardly 25 mins to solve. Since in online interview, first 10 mins went into setup because my interviewer wasnt getting signals. next 25 mins for behavioural. and then this question. Its a tricky problem, nort sure what a company will check with this question. Probably my memorization technique."
                    },
                    {
                        "username": "rquant",
                        "content": "This is a hard problem to solve on the fly. Either you\\'re a genius or you practiced this problem on LeetCode enough I guess."
                    },
                    {
                        "username": "aldogg",
                        "content": "I know your pain. It took me 2 hours to solve it today without looking for the solution :("
                    },
                    {
                        "username": "chiranthanmirle",
                        "content": "![image](https://assets.leetcode.com/users/images/88356185-85ab-4f53-afcb-d7512abc311e_1607548471.039209.png)\\nSorry for the bad images. I am terrible at it.\\n\\nTranspose: Basically run a line from top left to bottom right as shown. Flip the 2 parts around the line.\\n\\nReverse: Flip the whole image around a line to the left or right."
                    },
                    {
                        "username": "wtfcoder",
                        "content": "[@satyamS_71](/satyamS_71)  Reversing every row and transpose is gonna do it "
                    },
                    {
                        "username": "shakthisri",
                        "content": "it totally gave me a different view! thank you"
                    },
                    {
                        "username": "Msey",
                        "content": "[@satyamS_71](/satyamS_71) easiest way to use this trick is to present -90 degree as +270, 270 is a 90 degree three times etc"
                    },
                    {
                        "username": "satyamS_71",
                        "content": "Thanks it helped me a lot , but what if the question asks to rotate the image counter clockwise , then how should I approach the problem?"
                    },
                    {
                        "username": "HarshitGupta_02",
                        "content": "class Solution {\\npublic:\\n    void rotate(vector<vector<int>>& matrix) {\\n        int n=matrix.size();\\n        for(int i=0;i<n;i++){\\n            for(int j=0;j<=i;j++){\\n                swap(matrix[i][j],matrix[j][i]);\\n            }\\n        }\\n        for(int i=0;i<n;i++){\\n            int j=0;\\n            int k=n-1;\\n            while(j<=n/2 && k>=n/2){\\n                swap(matrix[i][j],matrix[i][k]);\\n                j++;\\n                k--;\\n            }\\n        }\\n    }\\n};"
                    },
                    {
                        "username": "Bobzero",
                        "content": "I\\'m always having fun reading the discussions \\uD83D\\uDE03"
                    },
                    {
                        "username": "charlesxiao2",
                        "content": "This post is for rotating the matrix anticlockwise. Sorry, when I post it I didn\\'t notice it. But please read it, because I guarantee you can understand the thought process and came up with your solution for clockwise rotation.\\n\\nSo, we are required to rotate it in place. \\n\\nGive a matrix, there are several operations can be done in matrix in place:\\n\\ntranslation, and swap symmetrically(mirror against diagnal), and probaly some unexpected in place operations.\\n\\nWe are trying to break the rotation operation into these operations that are know to carry on easily in place.\\n\\nFor swap symmetrically, given coordinate (a,b), it will be swapped to (b,a) if following the upper left and buttom right diagnal as mirror.\\nFor translation, given coordinate (a, b), we are able to traslate it to (a, whatever) or (whatever, b) with ease.\\n\\nIf rotated anticlockwise, element at (a,b) will be transfered to the new coordinate of (s-b-1 ,a) with s being the length or width of the matrix.\\nWe are trying to find out the in place operations needed in order to transform the coordinate from (a, b) to (s-b-1, a), with some fundumantal operations\\' coordinate transformation characteristics in mind.\\n\\nwe are trying to fill in the logic path between (a, b) to (s-b-1, a) using the fundamental operations.\\n\\nLet\\'s try to fill the logic break reversely:\\nto get to (s-b-1, a) from (a, b), notice a is swapped, we guess the last operation may be mirror against diagnal. so the path now becomes:\\n(a,b) -> (a, s-b-1) -> (s-b-1, a)//the last mirror can be easily done in place\\n\\nNow we try, how to get to (a, s-b-1) from (a, b) using fundamental in place operations? Well, draw a matrix, and you find out that this is not translation, but some swapping too. Don\\'t worry, you see the operations does not change the row coordinate, so it can be done in place with ease. And you know at this point you design the algorithm for this problem.\\n\\nThis is how the logic flows trying to design the in place algorithm to rotate n*n matrix.\\nBasically, we are trying to break down the operations into easy atomic in place operations. How to break down? Analyze the coordinate characteristics with some basic patterns in mind.\\n\\n"
                    },
                    {
                        "username": "UmerZia",
                        "content": "What If we do not have the diagonal, Just thinking about more dynamic solution!"
                    },
                    {
                        "username": "k3000001",
                        "content": "What exactly does it help measure? That the candidate can remember the trick of swapping rows?"
                    },
                    {
                        "username": "MiliMakwana",
                        "content": "[@Nandhini-Techie](/Nandhini-Techie)  Extra space bro\\n"
                    },
                    {
                        "username": "Nandhini-Techie",
                        "content": "  for (int i = 0; i < matrix.length; i++) {\\n      List<int> subList = [];\\n      for (int j = matrix.length - 1; j >= 0; j--) {\\n        subList.add(matrix[j][i]);\\n      }\\n      output.add(subList);\\n    }"
                    },
                    {
                        "username": "betrayy",
                        "content": "Was thinking the same.. this question is pretty much free if you just memorize it"
                    },
                    {
                        "username": "dkode",
                        "content": "Diagram:\\n\\n![image](https://assets.leetcode.com/users/images/95016c57-f112-4e79-8be7-0f21c814c800_1630583198.7966883.png)\\n\\n# M[i,j] --> M\\'[j,N-1-i]\\n\\nWe know that transpose relation is \\n#### M[i,j]= M[j,i]\\n#### \\n\\nBut the relation we got is slightly differernt\\n\\nThink how to convert\\nM[i,j] to M[N-1-i,j]\\n\\nThis is equivalent to flipping the matrix horizontally.\\n\\nM[i,j] to M[N-1-i,j]\\n\\nTranspose (M[N-1-i,j]) --> M\\'[j,N-1-i]\\n\\nTranspose and flipping are linear operation\\n\\nSimilary you can solve other cases like 90 degree, 180 degree, 270 degree etc\\n\\n\\n"
                    },
                    {
                        "username": "paras178a",
                        "content": "[@user7617Dm](/user7617Dm) If i is zero, then index will you be at for N+1-i ?"
                    },
                    {
                        "username": "user7617Dm",
                        "content": "why is it N-1-i not N+1-i? If N is 4 for a 4x4 matric"
                    },
                    {
                        "username": "StefanPochmann",
                        "content": "    def rotate(matrix)\\n      matrix.replace(matrix.reverse.transpose)\\n    end\\n\\nI like Ruby's wordy style."
                    },
                    {
                        "username": "cbertake",
                        "content": "when will you stop posting solution in discussion?\\n"
                    },
                    {
                        "username": "deadsec",
                        "content": "\\uD83D\\uDE02 Amazon Recruiter => You have been hired."
                    },
                    {
                        "username": "UmerZia",
                        "content": "[@Brut_all](/Brut_all) Definitely Not! "
                    },
                    {
                        "username": "Brut_all",
                        "content": "But the interviwer might not like \\uD83E\\uDD10"
                    },
                    {
                        "username": "chris3109692",
                        "content": "The complexity analyses in the solution is incorrect. For a NxN matrix, the complexity is O(N^2), but our data size is N^2 by itself, hence the proper way to denote complexity should be O(n). Note big O is always measured against the data size, not the dimension size."
                    },
                    {
                        "username": "Triquetra",
                        "content": "Complexity is an equivalence class of functions, it can be expressed as a function of any variable."
                    },
                    {
                        "username": "WilmerKrisp",
                        "content": "# solution 1\\n\\n![image](https://assets.leetcode.com/users/images/e112c117-97a6-431c-99e9-c2b2ca3b84c5_1597576604.2278848.png)\\n\\n![image](https://assets.leetcode.com/users/images/18ce4afa-3e8d-4943-856c-a59d781def40_1597576610.36345.png)\\n\\n\\n# solution 2 (inplace modification)\\n![image](https://assets.leetcode.com/users/images/9f7d86fb-cde6-4760-8088-b683bb52160f_1597580296.4229963.png)\\n\\n![image](https://assets.leetcode.com/users/images/58888c0c-c0b7-4fee-9f8d-537ef2681f0a_1597580313.7932537.png)\\n"
                    },
                    {
                        "username": "Ayush_PY",
                        "content": "Using a second matrix is not allowed"
                    },
                    {
                        "username": "bnuzhanyu",
                        "content": "I had been asked this question in an interview:\\n\\ngiven an R x C  matrix,  rotate 90 degree clockwise **in place** (with constant extra space).\\n**The matrix is given as an array**, you should do this within the array.\\nExample: \\u3002\\ninput: R = 3, C = 4, array = 1 2 3 4 5 6 7 8 9 10 11 12\\noutput: R = 4, C = 3, array = 9 5 1 10 6 2 11 7 3 12 8 4\\n\\nexplaination:\\nthe input matrix is:\\n1 2 3 4\\n5 6 7 8\\n9 10 11 12\\nthe output matrix is:\\n9 5 1\\n10 6 2\\n11 7 3\\n12 8 4\\n\\nThough I have got an idea of solving this problem, but the time complexity is not O(RxC)\\u3002\\nCan anyone got an O(RxC) solution with O(1) space?\\n\\n\\n"
                    },
                    {
                        "username": "mawhadmd",
                        "content": "That\\'s possible to do in place?"
                    },
                    {
                        "username": "anmol_soniii",
                        "content": "T.C = O( R*C )\\nS.C = O(1) [ in place ]\\nsolution:\\nclass Solution {\\npublic:\\n    void rotate(vector<vector<int>>& matrix) {\\n        int row = matrix.size();\\n        int col = matrix[0].size();\\n\\n        for(int i = 0; i<row ;i++){\\n            int j = 0;\\n            while( j<i ){\\n                swap(matrix[i][j],matrix[j][i]);\\n                j++;\\n            }\\n        }\\n\\n        for(int i = 0 ; i < row ; i++){\\n            int n = 0;\\n            int m = col-1;\\n            while(n<m){\\n                swap(matrix[i][n],matrix[i][m]);\\n                n++;\\n                m--;\\n            }\\n        }\\n    }\\n};"
                    },
                    {
                        "username": "chinnamsaireddy1369",
                        "content": "how can u do this without space, this question itself asking to alter given m x n matrix to n x m matrix, then without using new matrix how will you insert n x m into m x n"
                    },
                    {
                        "username": "him_Sarma619",
                        "content": "This is actually a pretty good question.... I\\'m not able to think of a solution for this, if you don\\'t mind can you please provide the solution for the same ?"
                    }
                ]
            },
            {
                "id": 1573752,
                "content": [
                    {
                        "username": "LazyBanda",
                        "content": "I was asked this problem in Amazon for SDE III. I had hardly 25 mins to solve. Since in online interview, first 10 mins went into setup because my interviewer wasnt getting signals. next 25 mins for behavioural. and then this question. Its a tricky problem, nort sure what a company will check with this question. Probably my memorization technique."
                    },
                    {
                        "username": "rquant",
                        "content": "This is a hard problem to solve on the fly. Either you\\'re a genius or you practiced this problem on LeetCode enough I guess."
                    },
                    {
                        "username": "aldogg",
                        "content": "I know your pain. It took me 2 hours to solve it today without looking for the solution :("
                    },
                    {
                        "username": "chiranthanmirle",
                        "content": "![image](https://assets.leetcode.com/users/images/88356185-85ab-4f53-afcb-d7512abc311e_1607548471.039209.png)\\nSorry for the bad images. I am terrible at it.\\n\\nTranspose: Basically run a line from top left to bottom right as shown. Flip the 2 parts around the line.\\n\\nReverse: Flip the whole image around a line to the left or right."
                    },
                    {
                        "username": "wtfcoder",
                        "content": "[@satyamS_71](/satyamS_71)  Reversing every row and transpose is gonna do it "
                    },
                    {
                        "username": "shakthisri",
                        "content": "it totally gave me a different view! thank you"
                    },
                    {
                        "username": "Msey",
                        "content": "[@satyamS_71](/satyamS_71) easiest way to use this trick is to present -90 degree as +270, 270 is a 90 degree three times etc"
                    },
                    {
                        "username": "satyamS_71",
                        "content": "Thanks it helped me a lot , but what if the question asks to rotate the image counter clockwise , then how should I approach the problem?"
                    },
                    {
                        "username": "HarshitGupta_02",
                        "content": "class Solution {\\npublic:\\n    void rotate(vector<vector<int>>& matrix) {\\n        int n=matrix.size();\\n        for(int i=0;i<n;i++){\\n            for(int j=0;j<=i;j++){\\n                swap(matrix[i][j],matrix[j][i]);\\n            }\\n        }\\n        for(int i=0;i<n;i++){\\n            int j=0;\\n            int k=n-1;\\n            while(j<=n/2 && k>=n/2){\\n                swap(matrix[i][j],matrix[i][k]);\\n                j++;\\n                k--;\\n            }\\n        }\\n    }\\n};"
                    },
                    {
                        "username": "Bobzero",
                        "content": "I\\'m always having fun reading the discussions \\uD83D\\uDE03"
                    },
                    {
                        "username": "charlesxiao2",
                        "content": "This post is for rotating the matrix anticlockwise. Sorry, when I post it I didn\\'t notice it. But please read it, because I guarantee you can understand the thought process and came up with your solution for clockwise rotation.\\n\\nSo, we are required to rotate it in place. \\n\\nGive a matrix, there are several operations can be done in matrix in place:\\n\\ntranslation, and swap symmetrically(mirror against diagnal), and probaly some unexpected in place operations.\\n\\nWe are trying to break the rotation operation into these operations that are know to carry on easily in place.\\n\\nFor swap symmetrically, given coordinate (a,b), it will be swapped to (b,a) if following the upper left and buttom right diagnal as mirror.\\nFor translation, given coordinate (a, b), we are able to traslate it to (a, whatever) or (whatever, b) with ease.\\n\\nIf rotated anticlockwise, element at (a,b) will be transfered to the new coordinate of (s-b-1 ,a) with s being the length or width of the matrix.\\nWe are trying to find out the in place operations needed in order to transform the coordinate from (a, b) to (s-b-1, a), with some fundumantal operations\\' coordinate transformation characteristics in mind.\\n\\nwe are trying to fill in the logic path between (a, b) to (s-b-1, a) using the fundamental operations.\\n\\nLet\\'s try to fill the logic break reversely:\\nto get to (s-b-1, a) from (a, b), notice a is swapped, we guess the last operation may be mirror against diagnal. so the path now becomes:\\n(a,b) -> (a, s-b-1) -> (s-b-1, a)//the last mirror can be easily done in place\\n\\nNow we try, how to get to (a, s-b-1) from (a, b) using fundamental in place operations? Well, draw a matrix, and you find out that this is not translation, but some swapping too. Don\\'t worry, you see the operations does not change the row coordinate, so it can be done in place with ease. And you know at this point you design the algorithm for this problem.\\n\\nThis is how the logic flows trying to design the in place algorithm to rotate n*n matrix.\\nBasically, we are trying to break down the operations into easy atomic in place operations. How to break down? Analyze the coordinate characteristics with some basic patterns in mind.\\n\\n"
                    },
                    {
                        "username": "UmerZia",
                        "content": "What If we do not have the diagonal, Just thinking about more dynamic solution!"
                    },
                    {
                        "username": "k3000001",
                        "content": "What exactly does it help measure? That the candidate can remember the trick of swapping rows?"
                    },
                    {
                        "username": "MiliMakwana",
                        "content": "[@Nandhini-Techie](/Nandhini-Techie)  Extra space bro\\n"
                    },
                    {
                        "username": "Nandhini-Techie",
                        "content": "  for (int i = 0; i < matrix.length; i++) {\\n      List<int> subList = [];\\n      for (int j = matrix.length - 1; j >= 0; j--) {\\n        subList.add(matrix[j][i]);\\n      }\\n      output.add(subList);\\n    }"
                    },
                    {
                        "username": "betrayy",
                        "content": "Was thinking the same.. this question is pretty much free if you just memorize it"
                    },
                    {
                        "username": "dkode",
                        "content": "Diagram:\\n\\n![image](https://assets.leetcode.com/users/images/95016c57-f112-4e79-8be7-0f21c814c800_1630583198.7966883.png)\\n\\n# M[i,j] --> M\\'[j,N-1-i]\\n\\nWe know that transpose relation is \\n#### M[i,j]= M[j,i]\\n#### \\n\\nBut the relation we got is slightly differernt\\n\\nThink how to convert\\nM[i,j] to M[N-1-i,j]\\n\\nThis is equivalent to flipping the matrix horizontally.\\n\\nM[i,j] to M[N-1-i,j]\\n\\nTranspose (M[N-1-i,j]) --> M\\'[j,N-1-i]\\n\\nTranspose and flipping are linear operation\\n\\nSimilary you can solve other cases like 90 degree, 180 degree, 270 degree etc\\n\\n\\n"
                    },
                    {
                        "username": "paras178a",
                        "content": "[@user7617Dm](/user7617Dm) If i is zero, then index will you be at for N+1-i ?"
                    },
                    {
                        "username": "user7617Dm",
                        "content": "why is it N-1-i not N+1-i? If N is 4 for a 4x4 matric"
                    },
                    {
                        "username": "StefanPochmann",
                        "content": "    def rotate(matrix)\\n      matrix.replace(matrix.reverse.transpose)\\n    end\\n\\nI like Ruby's wordy style."
                    },
                    {
                        "username": "cbertake",
                        "content": "when will you stop posting solution in discussion?\\n"
                    },
                    {
                        "username": "deadsec",
                        "content": "\\uD83D\\uDE02 Amazon Recruiter => You have been hired."
                    },
                    {
                        "username": "UmerZia",
                        "content": "[@Brut_all](/Brut_all) Definitely Not! "
                    },
                    {
                        "username": "Brut_all",
                        "content": "But the interviwer might not like \\uD83E\\uDD10"
                    },
                    {
                        "username": "chris3109692",
                        "content": "The complexity analyses in the solution is incorrect. For a NxN matrix, the complexity is O(N^2), but our data size is N^2 by itself, hence the proper way to denote complexity should be O(n). Note big O is always measured against the data size, not the dimension size."
                    },
                    {
                        "username": "Triquetra",
                        "content": "Complexity is an equivalence class of functions, it can be expressed as a function of any variable."
                    },
                    {
                        "username": "WilmerKrisp",
                        "content": "# solution 1\\n\\n![image](https://assets.leetcode.com/users/images/e112c117-97a6-431c-99e9-c2b2ca3b84c5_1597576604.2278848.png)\\n\\n![image](https://assets.leetcode.com/users/images/18ce4afa-3e8d-4943-856c-a59d781def40_1597576610.36345.png)\\n\\n\\n# solution 2 (inplace modification)\\n![image](https://assets.leetcode.com/users/images/9f7d86fb-cde6-4760-8088-b683bb52160f_1597580296.4229963.png)\\n\\n![image](https://assets.leetcode.com/users/images/58888c0c-c0b7-4fee-9f8d-537ef2681f0a_1597580313.7932537.png)\\n"
                    },
                    {
                        "username": "Ayush_PY",
                        "content": "Using a second matrix is not allowed"
                    },
                    {
                        "username": "bnuzhanyu",
                        "content": "I had been asked this question in an interview:\\n\\ngiven an R x C  matrix,  rotate 90 degree clockwise **in place** (with constant extra space).\\n**The matrix is given as an array**, you should do this within the array.\\nExample: \\u3002\\ninput: R = 3, C = 4, array = 1 2 3 4 5 6 7 8 9 10 11 12\\noutput: R = 4, C = 3, array = 9 5 1 10 6 2 11 7 3 12 8 4\\n\\nexplaination:\\nthe input matrix is:\\n1 2 3 4\\n5 6 7 8\\n9 10 11 12\\nthe output matrix is:\\n9 5 1\\n10 6 2\\n11 7 3\\n12 8 4\\n\\nThough I have got an idea of solving this problem, but the time complexity is not O(RxC)\\u3002\\nCan anyone got an O(RxC) solution with O(1) space?\\n\\n\\n"
                    },
                    {
                        "username": "mawhadmd",
                        "content": "That\\'s possible to do in place?"
                    },
                    {
                        "username": "anmol_soniii",
                        "content": "T.C = O( R*C )\\nS.C = O(1) [ in place ]\\nsolution:\\nclass Solution {\\npublic:\\n    void rotate(vector<vector<int>>& matrix) {\\n        int row = matrix.size();\\n        int col = matrix[0].size();\\n\\n        for(int i = 0; i<row ;i++){\\n            int j = 0;\\n            while( j<i ){\\n                swap(matrix[i][j],matrix[j][i]);\\n                j++;\\n            }\\n        }\\n\\n        for(int i = 0 ; i < row ; i++){\\n            int n = 0;\\n            int m = col-1;\\n            while(n<m){\\n                swap(matrix[i][n],matrix[i][m]);\\n                n++;\\n                m--;\\n            }\\n        }\\n    }\\n};"
                    },
                    {
                        "username": "chinnamsaireddy1369",
                        "content": "how can u do this without space, this question itself asking to alter given m x n matrix to n x m matrix, then without using new matrix how will you insert n x m into m x n"
                    },
                    {
                        "username": "him_Sarma619",
                        "content": "This is actually a pretty good question.... I\\'m not able to think of a solution for this, if you don\\'t mind can you please provide the solution for the same ?"
                    }
                ]
            },
            {
                "id": 1575708,
                "content": [
                    {
                        "username": "LazyBanda",
                        "content": "I was asked this problem in Amazon for SDE III. I had hardly 25 mins to solve. Since in online interview, first 10 mins went into setup because my interviewer wasnt getting signals. next 25 mins for behavioural. and then this question. Its a tricky problem, nort sure what a company will check with this question. Probably my memorization technique."
                    },
                    {
                        "username": "rquant",
                        "content": "This is a hard problem to solve on the fly. Either you\\'re a genius or you practiced this problem on LeetCode enough I guess."
                    },
                    {
                        "username": "aldogg",
                        "content": "I know your pain. It took me 2 hours to solve it today without looking for the solution :("
                    },
                    {
                        "username": "chiranthanmirle",
                        "content": "![image](https://assets.leetcode.com/users/images/88356185-85ab-4f53-afcb-d7512abc311e_1607548471.039209.png)\\nSorry for the bad images. I am terrible at it.\\n\\nTranspose: Basically run a line from top left to bottom right as shown. Flip the 2 parts around the line.\\n\\nReverse: Flip the whole image around a line to the left or right."
                    },
                    {
                        "username": "wtfcoder",
                        "content": "[@satyamS_71](/satyamS_71)  Reversing every row and transpose is gonna do it "
                    },
                    {
                        "username": "shakthisri",
                        "content": "it totally gave me a different view! thank you"
                    },
                    {
                        "username": "Msey",
                        "content": "[@satyamS_71](/satyamS_71) easiest way to use this trick is to present -90 degree as +270, 270 is a 90 degree three times etc"
                    },
                    {
                        "username": "satyamS_71",
                        "content": "Thanks it helped me a lot , but what if the question asks to rotate the image counter clockwise , then how should I approach the problem?"
                    },
                    {
                        "username": "HarshitGupta_02",
                        "content": "class Solution {\\npublic:\\n    void rotate(vector<vector<int>>& matrix) {\\n        int n=matrix.size();\\n        for(int i=0;i<n;i++){\\n            for(int j=0;j<=i;j++){\\n                swap(matrix[i][j],matrix[j][i]);\\n            }\\n        }\\n        for(int i=0;i<n;i++){\\n            int j=0;\\n            int k=n-1;\\n            while(j<=n/2 && k>=n/2){\\n                swap(matrix[i][j],matrix[i][k]);\\n                j++;\\n                k--;\\n            }\\n        }\\n    }\\n};"
                    },
                    {
                        "username": "Bobzero",
                        "content": "I\\'m always having fun reading the discussions \\uD83D\\uDE03"
                    },
                    {
                        "username": "charlesxiao2",
                        "content": "This post is for rotating the matrix anticlockwise. Sorry, when I post it I didn\\'t notice it. But please read it, because I guarantee you can understand the thought process and came up with your solution for clockwise rotation.\\n\\nSo, we are required to rotate it in place. \\n\\nGive a matrix, there are several operations can be done in matrix in place:\\n\\ntranslation, and swap symmetrically(mirror against diagnal), and probaly some unexpected in place operations.\\n\\nWe are trying to break the rotation operation into these operations that are know to carry on easily in place.\\n\\nFor swap symmetrically, given coordinate (a,b), it will be swapped to (b,a) if following the upper left and buttom right diagnal as mirror.\\nFor translation, given coordinate (a, b), we are able to traslate it to (a, whatever) or (whatever, b) with ease.\\n\\nIf rotated anticlockwise, element at (a,b) will be transfered to the new coordinate of (s-b-1 ,a) with s being the length or width of the matrix.\\nWe are trying to find out the in place operations needed in order to transform the coordinate from (a, b) to (s-b-1, a), with some fundumantal operations\\' coordinate transformation characteristics in mind.\\n\\nwe are trying to fill in the logic path between (a, b) to (s-b-1, a) using the fundamental operations.\\n\\nLet\\'s try to fill the logic break reversely:\\nto get to (s-b-1, a) from (a, b), notice a is swapped, we guess the last operation may be mirror against diagnal. so the path now becomes:\\n(a,b) -> (a, s-b-1) -> (s-b-1, a)//the last mirror can be easily done in place\\n\\nNow we try, how to get to (a, s-b-1) from (a, b) using fundamental in place operations? Well, draw a matrix, and you find out that this is not translation, but some swapping too. Don\\'t worry, you see the operations does not change the row coordinate, so it can be done in place with ease. And you know at this point you design the algorithm for this problem.\\n\\nThis is how the logic flows trying to design the in place algorithm to rotate n*n matrix.\\nBasically, we are trying to break down the operations into easy atomic in place operations. How to break down? Analyze the coordinate characteristics with some basic patterns in mind.\\n\\n"
                    },
                    {
                        "username": "UmerZia",
                        "content": "What If we do not have the diagonal, Just thinking about more dynamic solution!"
                    },
                    {
                        "username": "k3000001",
                        "content": "What exactly does it help measure? That the candidate can remember the trick of swapping rows?"
                    },
                    {
                        "username": "MiliMakwana",
                        "content": "[@Nandhini-Techie](/Nandhini-Techie)  Extra space bro\\n"
                    },
                    {
                        "username": "Nandhini-Techie",
                        "content": "  for (int i = 0; i < matrix.length; i++) {\\n      List<int> subList = [];\\n      for (int j = matrix.length - 1; j >= 0; j--) {\\n        subList.add(matrix[j][i]);\\n      }\\n      output.add(subList);\\n    }"
                    },
                    {
                        "username": "betrayy",
                        "content": "Was thinking the same.. this question is pretty much free if you just memorize it"
                    },
                    {
                        "username": "dkode",
                        "content": "Diagram:\\n\\n![image](https://assets.leetcode.com/users/images/95016c57-f112-4e79-8be7-0f21c814c800_1630583198.7966883.png)\\n\\n# M[i,j] --> M\\'[j,N-1-i]\\n\\nWe know that transpose relation is \\n#### M[i,j]= M[j,i]\\n#### \\n\\nBut the relation we got is slightly differernt\\n\\nThink how to convert\\nM[i,j] to M[N-1-i,j]\\n\\nThis is equivalent to flipping the matrix horizontally.\\n\\nM[i,j] to M[N-1-i,j]\\n\\nTranspose (M[N-1-i,j]) --> M\\'[j,N-1-i]\\n\\nTranspose and flipping are linear operation\\n\\nSimilary you can solve other cases like 90 degree, 180 degree, 270 degree etc\\n\\n\\n"
                    },
                    {
                        "username": "paras178a",
                        "content": "[@user7617Dm](/user7617Dm) If i is zero, then index will you be at for N+1-i ?"
                    },
                    {
                        "username": "user7617Dm",
                        "content": "why is it N-1-i not N+1-i? If N is 4 for a 4x4 matric"
                    },
                    {
                        "username": "StefanPochmann",
                        "content": "    def rotate(matrix)\\n      matrix.replace(matrix.reverse.transpose)\\n    end\\n\\nI like Ruby's wordy style."
                    },
                    {
                        "username": "cbertake",
                        "content": "when will you stop posting solution in discussion?\\n"
                    },
                    {
                        "username": "deadsec",
                        "content": "\\uD83D\\uDE02 Amazon Recruiter => You have been hired."
                    },
                    {
                        "username": "UmerZia",
                        "content": "[@Brut_all](/Brut_all) Definitely Not! "
                    },
                    {
                        "username": "Brut_all",
                        "content": "But the interviwer might not like \\uD83E\\uDD10"
                    },
                    {
                        "username": "chris3109692",
                        "content": "The complexity analyses in the solution is incorrect. For a NxN matrix, the complexity is O(N^2), but our data size is N^2 by itself, hence the proper way to denote complexity should be O(n). Note big O is always measured against the data size, not the dimension size."
                    },
                    {
                        "username": "Triquetra",
                        "content": "Complexity is an equivalence class of functions, it can be expressed as a function of any variable."
                    },
                    {
                        "username": "WilmerKrisp",
                        "content": "# solution 1\\n\\n![image](https://assets.leetcode.com/users/images/e112c117-97a6-431c-99e9-c2b2ca3b84c5_1597576604.2278848.png)\\n\\n![image](https://assets.leetcode.com/users/images/18ce4afa-3e8d-4943-856c-a59d781def40_1597576610.36345.png)\\n\\n\\n# solution 2 (inplace modification)\\n![image](https://assets.leetcode.com/users/images/9f7d86fb-cde6-4760-8088-b683bb52160f_1597580296.4229963.png)\\n\\n![image](https://assets.leetcode.com/users/images/58888c0c-c0b7-4fee-9f8d-537ef2681f0a_1597580313.7932537.png)\\n"
                    },
                    {
                        "username": "Ayush_PY",
                        "content": "Using a second matrix is not allowed"
                    },
                    {
                        "username": "bnuzhanyu",
                        "content": "I had been asked this question in an interview:\\n\\ngiven an R x C  matrix,  rotate 90 degree clockwise **in place** (with constant extra space).\\n**The matrix is given as an array**, you should do this within the array.\\nExample: \\u3002\\ninput: R = 3, C = 4, array = 1 2 3 4 5 6 7 8 9 10 11 12\\noutput: R = 4, C = 3, array = 9 5 1 10 6 2 11 7 3 12 8 4\\n\\nexplaination:\\nthe input matrix is:\\n1 2 3 4\\n5 6 7 8\\n9 10 11 12\\nthe output matrix is:\\n9 5 1\\n10 6 2\\n11 7 3\\n12 8 4\\n\\nThough I have got an idea of solving this problem, but the time complexity is not O(RxC)\\u3002\\nCan anyone got an O(RxC) solution with O(1) space?\\n\\n\\n"
                    },
                    {
                        "username": "mawhadmd",
                        "content": "That\\'s possible to do in place?"
                    },
                    {
                        "username": "anmol_soniii",
                        "content": "T.C = O( R*C )\\nS.C = O(1) [ in place ]\\nsolution:\\nclass Solution {\\npublic:\\n    void rotate(vector<vector<int>>& matrix) {\\n        int row = matrix.size();\\n        int col = matrix[0].size();\\n\\n        for(int i = 0; i<row ;i++){\\n            int j = 0;\\n            while( j<i ){\\n                swap(matrix[i][j],matrix[j][i]);\\n                j++;\\n            }\\n        }\\n\\n        for(int i = 0 ; i < row ; i++){\\n            int n = 0;\\n            int m = col-1;\\n            while(n<m){\\n                swap(matrix[i][n],matrix[i][m]);\\n                n++;\\n                m--;\\n            }\\n        }\\n    }\\n};"
                    },
                    {
                        "username": "chinnamsaireddy1369",
                        "content": "how can u do this without space, this question itself asking to alter given m x n matrix to n x m matrix, then without using new matrix how will you insert n x m into m x n"
                    },
                    {
                        "username": "him_Sarma619",
                        "content": "This is actually a pretty good question.... I\\'m not able to think of a solution for this, if you don\\'t mind can you please provide the solution for the same ?"
                    }
                ]
            },
            {
                "id": 1565939,
                "content": [
                    {
                        "username": "LazyBanda",
                        "content": "I was asked this problem in Amazon for SDE III. I had hardly 25 mins to solve. Since in online interview, first 10 mins went into setup because my interviewer wasnt getting signals. next 25 mins for behavioural. and then this question. Its a tricky problem, nort sure what a company will check with this question. Probably my memorization technique."
                    },
                    {
                        "username": "rquant",
                        "content": "This is a hard problem to solve on the fly. Either you\\'re a genius or you practiced this problem on LeetCode enough I guess."
                    },
                    {
                        "username": "aldogg",
                        "content": "I know your pain. It took me 2 hours to solve it today without looking for the solution :("
                    },
                    {
                        "username": "chiranthanmirle",
                        "content": "![image](https://assets.leetcode.com/users/images/88356185-85ab-4f53-afcb-d7512abc311e_1607548471.039209.png)\\nSorry for the bad images. I am terrible at it.\\n\\nTranspose: Basically run a line from top left to bottom right as shown. Flip the 2 parts around the line.\\n\\nReverse: Flip the whole image around a line to the left or right."
                    },
                    {
                        "username": "wtfcoder",
                        "content": "[@satyamS_71](/satyamS_71)  Reversing every row and transpose is gonna do it "
                    },
                    {
                        "username": "shakthisri",
                        "content": "it totally gave me a different view! thank you"
                    },
                    {
                        "username": "Msey",
                        "content": "[@satyamS_71](/satyamS_71) easiest way to use this trick is to present -90 degree as +270, 270 is a 90 degree three times etc"
                    },
                    {
                        "username": "satyamS_71",
                        "content": "Thanks it helped me a lot , but what if the question asks to rotate the image counter clockwise , then how should I approach the problem?"
                    },
                    {
                        "username": "HarshitGupta_02",
                        "content": "class Solution {\\npublic:\\n    void rotate(vector<vector<int>>& matrix) {\\n        int n=matrix.size();\\n        for(int i=0;i<n;i++){\\n            for(int j=0;j<=i;j++){\\n                swap(matrix[i][j],matrix[j][i]);\\n            }\\n        }\\n        for(int i=0;i<n;i++){\\n            int j=0;\\n            int k=n-1;\\n            while(j<=n/2 && k>=n/2){\\n                swap(matrix[i][j],matrix[i][k]);\\n                j++;\\n                k--;\\n            }\\n        }\\n    }\\n};"
                    },
                    {
                        "username": "Bobzero",
                        "content": "I\\'m always having fun reading the discussions \\uD83D\\uDE03"
                    },
                    {
                        "username": "charlesxiao2",
                        "content": "This post is for rotating the matrix anticlockwise. Sorry, when I post it I didn\\'t notice it. But please read it, because I guarantee you can understand the thought process and came up with your solution for clockwise rotation.\\n\\nSo, we are required to rotate it in place. \\n\\nGive a matrix, there are several operations can be done in matrix in place:\\n\\ntranslation, and swap symmetrically(mirror against diagnal), and probaly some unexpected in place operations.\\n\\nWe are trying to break the rotation operation into these operations that are know to carry on easily in place.\\n\\nFor swap symmetrically, given coordinate (a,b), it will be swapped to (b,a) if following the upper left and buttom right diagnal as mirror.\\nFor translation, given coordinate (a, b), we are able to traslate it to (a, whatever) or (whatever, b) with ease.\\n\\nIf rotated anticlockwise, element at (a,b) will be transfered to the new coordinate of (s-b-1 ,a) with s being the length or width of the matrix.\\nWe are trying to find out the in place operations needed in order to transform the coordinate from (a, b) to (s-b-1, a), with some fundumantal operations\\' coordinate transformation characteristics in mind.\\n\\nwe are trying to fill in the logic path between (a, b) to (s-b-1, a) using the fundamental operations.\\n\\nLet\\'s try to fill the logic break reversely:\\nto get to (s-b-1, a) from (a, b), notice a is swapped, we guess the last operation may be mirror against diagnal. so the path now becomes:\\n(a,b) -> (a, s-b-1) -> (s-b-1, a)//the last mirror can be easily done in place\\n\\nNow we try, how to get to (a, s-b-1) from (a, b) using fundamental in place operations? Well, draw a matrix, and you find out that this is not translation, but some swapping too. Don\\'t worry, you see the operations does not change the row coordinate, so it can be done in place with ease. And you know at this point you design the algorithm for this problem.\\n\\nThis is how the logic flows trying to design the in place algorithm to rotate n*n matrix.\\nBasically, we are trying to break down the operations into easy atomic in place operations. How to break down? Analyze the coordinate characteristics with some basic patterns in mind.\\n\\n"
                    },
                    {
                        "username": "UmerZia",
                        "content": "What If we do not have the diagonal, Just thinking about more dynamic solution!"
                    },
                    {
                        "username": "k3000001",
                        "content": "What exactly does it help measure? That the candidate can remember the trick of swapping rows?"
                    },
                    {
                        "username": "MiliMakwana",
                        "content": "[@Nandhini-Techie](/Nandhini-Techie)  Extra space bro\\n"
                    },
                    {
                        "username": "Nandhini-Techie",
                        "content": "  for (int i = 0; i < matrix.length; i++) {\\n      List<int> subList = [];\\n      for (int j = matrix.length - 1; j >= 0; j--) {\\n        subList.add(matrix[j][i]);\\n      }\\n      output.add(subList);\\n    }"
                    },
                    {
                        "username": "betrayy",
                        "content": "Was thinking the same.. this question is pretty much free if you just memorize it"
                    },
                    {
                        "username": "dkode",
                        "content": "Diagram:\\n\\n![image](https://assets.leetcode.com/users/images/95016c57-f112-4e79-8be7-0f21c814c800_1630583198.7966883.png)\\n\\n# M[i,j] --> M\\'[j,N-1-i]\\n\\nWe know that transpose relation is \\n#### M[i,j]= M[j,i]\\n#### \\n\\nBut the relation we got is slightly differernt\\n\\nThink how to convert\\nM[i,j] to M[N-1-i,j]\\n\\nThis is equivalent to flipping the matrix horizontally.\\n\\nM[i,j] to M[N-1-i,j]\\n\\nTranspose (M[N-1-i,j]) --> M\\'[j,N-1-i]\\n\\nTranspose and flipping are linear operation\\n\\nSimilary you can solve other cases like 90 degree, 180 degree, 270 degree etc\\n\\n\\n"
                    },
                    {
                        "username": "paras178a",
                        "content": "[@user7617Dm](/user7617Dm) If i is zero, then index will you be at for N+1-i ?"
                    },
                    {
                        "username": "user7617Dm",
                        "content": "why is it N-1-i not N+1-i? If N is 4 for a 4x4 matric"
                    },
                    {
                        "username": "StefanPochmann",
                        "content": "    def rotate(matrix)\\n      matrix.replace(matrix.reverse.transpose)\\n    end\\n\\nI like Ruby's wordy style."
                    },
                    {
                        "username": "cbertake",
                        "content": "when will you stop posting solution in discussion?\\n"
                    },
                    {
                        "username": "deadsec",
                        "content": "\\uD83D\\uDE02 Amazon Recruiter => You have been hired."
                    },
                    {
                        "username": "UmerZia",
                        "content": "[@Brut_all](/Brut_all) Definitely Not! "
                    },
                    {
                        "username": "Brut_all",
                        "content": "But the interviwer might not like \\uD83E\\uDD10"
                    },
                    {
                        "username": "chris3109692",
                        "content": "The complexity analyses in the solution is incorrect. For a NxN matrix, the complexity is O(N^2), but our data size is N^2 by itself, hence the proper way to denote complexity should be O(n). Note big O is always measured against the data size, not the dimension size."
                    },
                    {
                        "username": "Triquetra",
                        "content": "Complexity is an equivalence class of functions, it can be expressed as a function of any variable."
                    },
                    {
                        "username": "WilmerKrisp",
                        "content": "# solution 1\\n\\n![image](https://assets.leetcode.com/users/images/e112c117-97a6-431c-99e9-c2b2ca3b84c5_1597576604.2278848.png)\\n\\n![image](https://assets.leetcode.com/users/images/18ce4afa-3e8d-4943-856c-a59d781def40_1597576610.36345.png)\\n\\n\\n# solution 2 (inplace modification)\\n![image](https://assets.leetcode.com/users/images/9f7d86fb-cde6-4760-8088-b683bb52160f_1597580296.4229963.png)\\n\\n![image](https://assets.leetcode.com/users/images/58888c0c-c0b7-4fee-9f8d-537ef2681f0a_1597580313.7932537.png)\\n"
                    },
                    {
                        "username": "Ayush_PY",
                        "content": "Using a second matrix is not allowed"
                    },
                    {
                        "username": "bnuzhanyu",
                        "content": "I had been asked this question in an interview:\\n\\ngiven an R x C  matrix,  rotate 90 degree clockwise **in place** (with constant extra space).\\n**The matrix is given as an array**, you should do this within the array.\\nExample: \\u3002\\ninput: R = 3, C = 4, array = 1 2 3 4 5 6 7 8 9 10 11 12\\noutput: R = 4, C = 3, array = 9 5 1 10 6 2 11 7 3 12 8 4\\n\\nexplaination:\\nthe input matrix is:\\n1 2 3 4\\n5 6 7 8\\n9 10 11 12\\nthe output matrix is:\\n9 5 1\\n10 6 2\\n11 7 3\\n12 8 4\\n\\nThough I have got an idea of solving this problem, but the time complexity is not O(RxC)\\u3002\\nCan anyone got an O(RxC) solution with O(1) space?\\n\\n\\n"
                    },
                    {
                        "username": "mawhadmd",
                        "content": "That\\'s possible to do in place?"
                    },
                    {
                        "username": "anmol_soniii",
                        "content": "T.C = O( R*C )\\nS.C = O(1) [ in place ]\\nsolution:\\nclass Solution {\\npublic:\\n    void rotate(vector<vector<int>>& matrix) {\\n        int row = matrix.size();\\n        int col = matrix[0].size();\\n\\n        for(int i = 0; i<row ;i++){\\n            int j = 0;\\n            while( j<i ){\\n                swap(matrix[i][j],matrix[j][i]);\\n                j++;\\n            }\\n        }\\n\\n        for(int i = 0 ; i < row ; i++){\\n            int n = 0;\\n            int m = col-1;\\n            while(n<m){\\n                swap(matrix[i][n],matrix[i][m]);\\n                n++;\\n                m--;\\n            }\\n        }\\n    }\\n};"
                    },
                    {
                        "username": "chinnamsaireddy1369",
                        "content": "how can u do this without space, this question itself asking to alter given m x n matrix to n x m matrix, then without using new matrix how will you insert n x m into m x n"
                    },
                    {
                        "username": "him_Sarma619",
                        "content": "This is actually a pretty good question.... I\\'m not able to think of a solution for this, if you don\\'t mind can you please provide the solution for the same ?"
                    }
                ]
            },
            {
                "id": 1567522,
                "content": [
                    {
                        "username": "LazyBanda",
                        "content": "I was asked this problem in Amazon for SDE III. I had hardly 25 mins to solve. Since in online interview, first 10 mins went into setup because my interviewer wasnt getting signals. next 25 mins for behavioural. and then this question. Its a tricky problem, nort sure what a company will check with this question. Probably my memorization technique."
                    },
                    {
                        "username": "rquant",
                        "content": "This is a hard problem to solve on the fly. Either you\\'re a genius or you practiced this problem on LeetCode enough I guess."
                    },
                    {
                        "username": "aldogg",
                        "content": "I know your pain. It took me 2 hours to solve it today without looking for the solution :("
                    },
                    {
                        "username": "chiranthanmirle",
                        "content": "![image](https://assets.leetcode.com/users/images/88356185-85ab-4f53-afcb-d7512abc311e_1607548471.039209.png)\\nSorry for the bad images. I am terrible at it.\\n\\nTranspose: Basically run a line from top left to bottom right as shown. Flip the 2 parts around the line.\\n\\nReverse: Flip the whole image around a line to the left or right."
                    },
                    {
                        "username": "wtfcoder",
                        "content": "[@satyamS_71](/satyamS_71)  Reversing every row and transpose is gonna do it "
                    },
                    {
                        "username": "shakthisri",
                        "content": "it totally gave me a different view! thank you"
                    },
                    {
                        "username": "Msey",
                        "content": "[@satyamS_71](/satyamS_71) easiest way to use this trick is to present -90 degree as +270, 270 is a 90 degree three times etc"
                    },
                    {
                        "username": "satyamS_71",
                        "content": "Thanks it helped me a lot , but what if the question asks to rotate the image counter clockwise , then how should I approach the problem?"
                    },
                    {
                        "username": "HarshitGupta_02",
                        "content": "class Solution {\\npublic:\\n    void rotate(vector<vector<int>>& matrix) {\\n        int n=matrix.size();\\n        for(int i=0;i<n;i++){\\n            for(int j=0;j<=i;j++){\\n                swap(matrix[i][j],matrix[j][i]);\\n            }\\n        }\\n        for(int i=0;i<n;i++){\\n            int j=0;\\n            int k=n-1;\\n            while(j<=n/2 && k>=n/2){\\n                swap(matrix[i][j],matrix[i][k]);\\n                j++;\\n                k--;\\n            }\\n        }\\n    }\\n};"
                    },
                    {
                        "username": "Bobzero",
                        "content": "I\\'m always having fun reading the discussions \\uD83D\\uDE03"
                    },
                    {
                        "username": "charlesxiao2",
                        "content": "This post is for rotating the matrix anticlockwise. Sorry, when I post it I didn\\'t notice it. But please read it, because I guarantee you can understand the thought process and came up with your solution for clockwise rotation.\\n\\nSo, we are required to rotate it in place. \\n\\nGive a matrix, there are several operations can be done in matrix in place:\\n\\ntranslation, and swap symmetrically(mirror against diagnal), and probaly some unexpected in place operations.\\n\\nWe are trying to break the rotation operation into these operations that are know to carry on easily in place.\\n\\nFor swap symmetrically, given coordinate (a,b), it will be swapped to (b,a) if following the upper left and buttom right diagnal as mirror.\\nFor translation, given coordinate (a, b), we are able to traslate it to (a, whatever) or (whatever, b) with ease.\\n\\nIf rotated anticlockwise, element at (a,b) will be transfered to the new coordinate of (s-b-1 ,a) with s being the length or width of the matrix.\\nWe are trying to find out the in place operations needed in order to transform the coordinate from (a, b) to (s-b-1, a), with some fundumantal operations\\' coordinate transformation characteristics in mind.\\n\\nwe are trying to fill in the logic path between (a, b) to (s-b-1, a) using the fundamental operations.\\n\\nLet\\'s try to fill the logic break reversely:\\nto get to (s-b-1, a) from (a, b), notice a is swapped, we guess the last operation may be mirror against diagnal. so the path now becomes:\\n(a,b) -> (a, s-b-1) -> (s-b-1, a)//the last mirror can be easily done in place\\n\\nNow we try, how to get to (a, s-b-1) from (a, b) using fundamental in place operations? Well, draw a matrix, and you find out that this is not translation, but some swapping too. Don\\'t worry, you see the operations does not change the row coordinate, so it can be done in place with ease. And you know at this point you design the algorithm for this problem.\\n\\nThis is how the logic flows trying to design the in place algorithm to rotate n*n matrix.\\nBasically, we are trying to break down the operations into easy atomic in place operations. How to break down? Analyze the coordinate characteristics with some basic patterns in mind.\\n\\n"
                    },
                    {
                        "username": "UmerZia",
                        "content": "What If we do not have the diagonal, Just thinking about more dynamic solution!"
                    },
                    {
                        "username": "k3000001",
                        "content": "What exactly does it help measure? That the candidate can remember the trick of swapping rows?"
                    },
                    {
                        "username": "MiliMakwana",
                        "content": "[@Nandhini-Techie](/Nandhini-Techie)  Extra space bro\\n"
                    },
                    {
                        "username": "Nandhini-Techie",
                        "content": "  for (int i = 0; i < matrix.length; i++) {\\n      List<int> subList = [];\\n      for (int j = matrix.length - 1; j >= 0; j--) {\\n        subList.add(matrix[j][i]);\\n      }\\n      output.add(subList);\\n    }"
                    },
                    {
                        "username": "betrayy",
                        "content": "Was thinking the same.. this question is pretty much free if you just memorize it"
                    },
                    {
                        "username": "dkode",
                        "content": "Diagram:\\n\\n![image](https://assets.leetcode.com/users/images/95016c57-f112-4e79-8be7-0f21c814c800_1630583198.7966883.png)\\n\\n# M[i,j] --> M\\'[j,N-1-i]\\n\\nWe know that transpose relation is \\n#### M[i,j]= M[j,i]\\n#### \\n\\nBut the relation we got is slightly differernt\\n\\nThink how to convert\\nM[i,j] to M[N-1-i,j]\\n\\nThis is equivalent to flipping the matrix horizontally.\\n\\nM[i,j] to M[N-1-i,j]\\n\\nTranspose (M[N-1-i,j]) --> M\\'[j,N-1-i]\\n\\nTranspose and flipping are linear operation\\n\\nSimilary you can solve other cases like 90 degree, 180 degree, 270 degree etc\\n\\n\\n"
                    },
                    {
                        "username": "paras178a",
                        "content": "[@user7617Dm](/user7617Dm) If i is zero, then index will you be at for N+1-i ?"
                    },
                    {
                        "username": "user7617Dm",
                        "content": "why is it N-1-i not N+1-i? If N is 4 for a 4x4 matric"
                    },
                    {
                        "username": "StefanPochmann",
                        "content": "    def rotate(matrix)\\n      matrix.replace(matrix.reverse.transpose)\\n    end\\n\\nI like Ruby's wordy style."
                    },
                    {
                        "username": "cbertake",
                        "content": "when will you stop posting solution in discussion?\\n"
                    },
                    {
                        "username": "deadsec",
                        "content": "\\uD83D\\uDE02 Amazon Recruiter => You have been hired."
                    },
                    {
                        "username": "UmerZia",
                        "content": "[@Brut_all](/Brut_all) Definitely Not! "
                    },
                    {
                        "username": "Brut_all",
                        "content": "But the interviwer might not like \\uD83E\\uDD10"
                    },
                    {
                        "username": "chris3109692",
                        "content": "The complexity analyses in the solution is incorrect. For a NxN matrix, the complexity is O(N^2), but our data size is N^2 by itself, hence the proper way to denote complexity should be O(n). Note big O is always measured against the data size, not the dimension size."
                    },
                    {
                        "username": "Triquetra",
                        "content": "Complexity is an equivalence class of functions, it can be expressed as a function of any variable."
                    },
                    {
                        "username": "WilmerKrisp",
                        "content": "# solution 1\\n\\n![image](https://assets.leetcode.com/users/images/e112c117-97a6-431c-99e9-c2b2ca3b84c5_1597576604.2278848.png)\\n\\n![image](https://assets.leetcode.com/users/images/18ce4afa-3e8d-4943-856c-a59d781def40_1597576610.36345.png)\\n\\n\\n# solution 2 (inplace modification)\\n![image](https://assets.leetcode.com/users/images/9f7d86fb-cde6-4760-8088-b683bb52160f_1597580296.4229963.png)\\n\\n![image](https://assets.leetcode.com/users/images/58888c0c-c0b7-4fee-9f8d-537ef2681f0a_1597580313.7932537.png)\\n"
                    },
                    {
                        "username": "Ayush_PY",
                        "content": "Using a second matrix is not allowed"
                    },
                    {
                        "username": "bnuzhanyu",
                        "content": "I had been asked this question in an interview:\\n\\ngiven an R x C  matrix,  rotate 90 degree clockwise **in place** (with constant extra space).\\n**The matrix is given as an array**, you should do this within the array.\\nExample: \\u3002\\ninput: R = 3, C = 4, array = 1 2 3 4 5 6 7 8 9 10 11 12\\noutput: R = 4, C = 3, array = 9 5 1 10 6 2 11 7 3 12 8 4\\n\\nexplaination:\\nthe input matrix is:\\n1 2 3 4\\n5 6 7 8\\n9 10 11 12\\nthe output matrix is:\\n9 5 1\\n10 6 2\\n11 7 3\\n12 8 4\\n\\nThough I have got an idea of solving this problem, but the time complexity is not O(RxC)\\u3002\\nCan anyone got an O(RxC) solution with O(1) space?\\n\\n\\n"
                    },
                    {
                        "username": "mawhadmd",
                        "content": "That\\'s possible to do in place?"
                    },
                    {
                        "username": "anmol_soniii",
                        "content": "T.C = O( R*C )\\nS.C = O(1) [ in place ]\\nsolution:\\nclass Solution {\\npublic:\\n    void rotate(vector<vector<int>>& matrix) {\\n        int row = matrix.size();\\n        int col = matrix[0].size();\\n\\n        for(int i = 0; i<row ;i++){\\n            int j = 0;\\n            while( j<i ){\\n                swap(matrix[i][j],matrix[j][i]);\\n                j++;\\n            }\\n        }\\n\\n        for(int i = 0 ; i < row ; i++){\\n            int n = 0;\\n            int m = col-1;\\n            while(n<m){\\n                swap(matrix[i][n],matrix[i][m]);\\n                n++;\\n                m--;\\n            }\\n        }\\n    }\\n};"
                    },
                    {
                        "username": "chinnamsaireddy1369",
                        "content": "how can u do this without space, this question itself asking to alter given m x n matrix to n x m matrix, then without using new matrix how will you insert n x m into m x n"
                    },
                    {
                        "username": "him_Sarma619",
                        "content": "This is actually a pretty good question.... I\\'m not able to think of a solution for this, if you don\\'t mind can you please provide the solution for the same ?"
                    }
                ]
            },
            {
                "id": 1570119,
                "content": [
                    {
                        "username": "LazyBanda",
                        "content": "I was asked this problem in Amazon for SDE III. I had hardly 25 mins to solve. Since in online interview, first 10 mins went into setup because my interviewer wasnt getting signals. next 25 mins for behavioural. and then this question. Its a tricky problem, nort sure what a company will check with this question. Probably my memorization technique."
                    },
                    {
                        "username": "rquant",
                        "content": "This is a hard problem to solve on the fly. Either you\\'re a genius or you practiced this problem on LeetCode enough I guess."
                    },
                    {
                        "username": "aldogg",
                        "content": "I know your pain. It took me 2 hours to solve it today without looking for the solution :("
                    },
                    {
                        "username": "chiranthanmirle",
                        "content": "![image](https://assets.leetcode.com/users/images/88356185-85ab-4f53-afcb-d7512abc311e_1607548471.039209.png)\\nSorry for the bad images. I am terrible at it.\\n\\nTranspose: Basically run a line from top left to bottom right as shown. Flip the 2 parts around the line.\\n\\nReverse: Flip the whole image around a line to the left or right."
                    },
                    {
                        "username": "wtfcoder",
                        "content": "[@satyamS_71](/satyamS_71)  Reversing every row and transpose is gonna do it "
                    },
                    {
                        "username": "shakthisri",
                        "content": "it totally gave me a different view! thank you"
                    },
                    {
                        "username": "Msey",
                        "content": "[@satyamS_71](/satyamS_71) easiest way to use this trick is to present -90 degree as +270, 270 is a 90 degree three times etc"
                    },
                    {
                        "username": "satyamS_71",
                        "content": "Thanks it helped me a lot , but what if the question asks to rotate the image counter clockwise , then how should I approach the problem?"
                    },
                    {
                        "username": "HarshitGupta_02",
                        "content": "class Solution {\\npublic:\\n    void rotate(vector<vector<int>>& matrix) {\\n        int n=matrix.size();\\n        for(int i=0;i<n;i++){\\n            for(int j=0;j<=i;j++){\\n                swap(matrix[i][j],matrix[j][i]);\\n            }\\n        }\\n        for(int i=0;i<n;i++){\\n            int j=0;\\n            int k=n-1;\\n            while(j<=n/2 && k>=n/2){\\n                swap(matrix[i][j],matrix[i][k]);\\n                j++;\\n                k--;\\n            }\\n        }\\n    }\\n};"
                    },
                    {
                        "username": "Bobzero",
                        "content": "I\\'m always having fun reading the discussions \\uD83D\\uDE03"
                    },
                    {
                        "username": "charlesxiao2",
                        "content": "This post is for rotating the matrix anticlockwise. Sorry, when I post it I didn\\'t notice it. But please read it, because I guarantee you can understand the thought process and came up with your solution for clockwise rotation.\\n\\nSo, we are required to rotate it in place. \\n\\nGive a matrix, there are several operations can be done in matrix in place:\\n\\ntranslation, and swap symmetrically(mirror against diagnal), and probaly some unexpected in place operations.\\n\\nWe are trying to break the rotation operation into these operations that are know to carry on easily in place.\\n\\nFor swap symmetrically, given coordinate (a,b), it will be swapped to (b,a) if following the upper left and buttom right diagnal as mirror.\\nFor translation, given coordinate (a, b), we are able to traslate it to (a, whatever) or (whatever, b) with ease.\\n\\nIf rotated anticlockwise, element at (a,b) will be transfered to the new coordinate of (s-b-1 ,a) with s being the length or width of the matrix.\\nWe are trying to find out the in place operations needed in order to transform the coordinate from (a, b) to (s-b-1, a), with some fundumantal operations\\' coordinate transformation characteristics in mind.\\n\\nwe are trying to fill in the logic path between (a, b) to (s-b-1, a) using the fundamental operations.\\n\\nLet\\'s try to fill the logic break reversely:\\nto get to (s-b-1, a) from (a, b), notice a is swapped, we guess the last operation may be mirror against diagnal. so the path now becomes:\\n(a,b) -> (a, s-b-1) -> (s-b-1, a)//the last mirror can be easily done in place\\n\\nNow we try, how to get to (a, s-b-1) from (a, b) using fundamental in place operations? Well, draw a matrix, and you find out that this is not translation, but some swapping too. Don\\'t worry, you see the operations does not change the row coordinate, so it can be done in place with ease. And you know at this point you design the algorithm for this problem.\\n\\nThis is how the logic flows trying to design the in place algorithm to rotate n*n matrix.\\nBasically, we are trying to break down the operations into easy atomic in place operations. How to break down? Analyze the coordinate characteristics with some basic patterns in mind.\\n\\n"
                    },
                    {
                        "username": "UmerZia",
                        "content": "What If we do not have the diagonal, Just thinking about more dynamic solution!"
                    },
                    {
                        "username": "k3000001",
                        "content": "What exactly does it help measure? That the candidate can remember the trick of swapping rows?"
                    },
                    {
                        "username": "MiliMakwana",
                        "content": "[@Nandhini-Techie](/Nandhini-Techie)  Extra space bro\\n"
                    },
                    {
                        "username": "Nandhini-Techie",
                        "content": "  for (int i = 0; i < matrix.length; i++) {\\n      List<int> subList = [];\\n      for (int j = matrix.length - 1; j >= 0; j--) {\\n        subList.add(matrix[j][i]);\\n      }\\n      output.add(subList);\\n    }"
                    },
                    {
                        "username": "betrayy",
                        "content": "Was thinking the same.. this question is pretty much free if you just memorize it"
                    },
                    {
                        "username": "dkode",
                        "content": "Diagram:\\n\\n![image](https://assets.leetcode.com/users/images/95016c57-f112-4e79-8be7-0f21c814c800_1630583198.7966883.png)\\n\\n# M[i,j] --> M\\'[j,N-1-i]\\n\\nWe know that transpose relation is \\n#### M[i,j]= M[j,i]\\n#### \\n\\nBut the relation we got is slightly differernt\\n\\nThink how to convert\\nM[i,j] to M[N-1-i,j]\\n\\nThis is equivalent to flipping the matrix horizontally.\\n\\nM[i,j] to M[N-1-i,j]\\n\\nTranspose (M[N-1-i,j]) --> M\\'[j,N-1-i]\\n\\nTranspose and flipping are linear operation\\n\\nSimilary you can solve other cases like 90 degree, 180 degree, 270 degree etc\\n\\n\\n"
                    },
                    {
                        "username": "paras178a",
                        "content": "[@user7617Dm](/user7617Dm) If i is zero, then index will you be at for N+1-i ?"
                    },
                    {
                        "username": "user7617Dm",
                        "content": "why is it N-1-i not N+1-i? If N is 4 for a 4x4 matric"
                    },
                    {
                        "username": "StefanPochmann",
                        "content": "    def rotate(matrix)\\n      matrix.replace(matrix.reverse.transpose)\\n    end\\n\\nI like Ruby's wordy style."
                    },
                    {
                        "username": "cbertake",
                        "content": "when will you stop posting solution in discussion?\\n"
                    },
                    {
                        "username": "deadsec",
                        "content": "\\uD83D\\uDE02 Amazon Recruiter => You have been hired."
                    },
                    {
                        "username": "UmerZia",
                        "content": "[@Brut_all](/Brut_all) Definitely Not! "
                    },
                    {
                        "username": "Brut_all",
                        "content": "But the interviwer might not like \\uD83E\\uDD10"
                    },
                    {
                        "username": "chris3109692",
                        "content": "The complexity analyses in the solution is incorrect. For a NxN matrix, the complexity is O(N^2), but our data size is N^2 by itself, hence the proper way to denote complexity should be O(n). Note big O is always measured against the data size, not the dimension size."
                    },
                    {
                        "username": "Triquetra",
                        "content": "Complexity is an equivalence class of functions, it can be expressed as a function of any variable."
                    },
                    {
                        "username": "WilmerKrisp",
                        "content": "# solution 1\\n\\n![image](https://assets.leetcode.com/users/images/e112c117-97a6-431c-99e9-c2b2ca3b84c5_1597576604.2278848.png)\\n\\n![image](https://assets.leetcode.com/users/images/18ce4afa-3e8d-4943-856c-a59d781def40_1597576610.36345.png)\\n\\n\\n# solution 2 (inplace modification)\\n![image](https://assets.leetcode.com/users/images/9f7d86fb-cde6-4760-8088-b683bb52160f_1597580296.4229963.png)\\n\\n![image](https://assets.leetcode.com/users/images/58888c0c-c0b7-4fee-9f8d-537ef2681f0a_1597580313.7932537.png)\\n"
                    },
                    {
                        "username": "Ayush_PY",
                        "content": "Using a second matrix is not allowed"
                    },
                    {
                        "username": "bnuzhanyu",
                        "content": "I had been asked this question in an interview:\\n\\ngiven an R x C  matrix,  rotate 90 degree clockwise **in place** (with constant extra space).\\n**The matrix is given as an array**, you should do this within the array.\\nExample: \\u3002\\ninput: R = 3, C = 4, array = 1 2 3 4 5 6 7 8 9 10 11 12\\noutput: R = 4, C = 3, array = 9 5 1 10 6 2 11 7 3 12 8 4\\n\\nexplaination:\\nthe input matrix is:\\n1 2 3 4\\n5 6 7 8\\n9 10 11 12\\nthe output matrix is:\\n9 5 1\\n10 6 2\\n11 7 3\\n12 8 4\\n\\nThough I have got an idea of solving this problem, but the time complexity is not O(RxC)\\u3002\\nCan anyone got an O(RxC) solution with O(1) space?\\n\\n\\n"
                    },
                    {
                        "username": "mawhadmd",
                        "content": "That\\'s possible to do in place?"
                    },
                    {
                        "username": "anmol_soniii",
                        "content": "T.C = O( R*C )\\nS.C = O(1) [ in place ]\\nsolution:\\nclass Solution {\\npublic:\\n    void rotate(vector<vector<int>>& matrix) {\\n        int row = matrix.size();\\n        int col = matrix[0].size();\\n\\n        for(int i = 0; i<row ;i++){\\n            int j = 0;\\n            while( j<i ){\\n                swap(matrix[i][j],matrix[j][i]);\\n                j++;\\n            }\\n        }\\n\\n        for(int i = 0 ; i < row ; i++){\\n            int n = 0;\\n            int m = col-1;\\n            while(n<m){\\n                swap(matrix[i][n],matrix[i][m]);\\n                n++;\\n                m--;\\n            }\\n        }\\n    }\\n};"
                    },
                    {
                        "username": "chinnamsaireddy1369",
                        "content": "how can u do this without space, this question itself asking to alter given m x n matrix to n x m matrix, then without using new matrix how will you insert n x m into m x n"
                    },
                    {
                        "username": "him_Sarma619",
                        "content": "This is actually a pretty good question.... I\\'m not able to think of a solution for this, if you don\\'t mind can you please provide the solution for the same ?"
                    }
                ]
            },
            {
                "id": 1569197,
                "content": [
                    {
                        "username": "LazyBanda",
                        "content": "I was asked this problem in Amazon for SDE III. I had hardly 25 mins to solve. Since in online interview, first 10 mins went into setup because my interviewer wasnt getting signals. next 25 mins for behavioural. and then this question. Its a tricky problem, nort sure what a company will check with this question. Probably my memorization technique."
                    },
                    {
                        "username": "rquant",
                        "content": "This is a hard problem to solve on the fly. Either you\\'re a genius or you practiced this problem on LeetCode enough I guess."
                    },
                    {
                        "username": "aldogg",
                        "content": "I know your pain. It took me 2 hours to solve it today without looking for the solution :("
                    },
                    {
                        "username": "chiranthanmirle",
                        "content": "![image](https://assets.leetcode.com/users/images/88356185-85ab-4f53-afcb-d7512abc311e_1607548471.039209.png)\\nSorry for the bad images. I am terrible at it.\\n\\nTranspose: Basically run a line from top left to bottom right as shown. Flip the 2 parts around the line.\\n\\nReverse: Flip the whole image around a line to the left or right."
                    },
                    {
                        "username": "wtfcoder",
                        "content": "[@satyamS_71](/satyamS_71)  Reversing every row and transpose is gonna do it "
                    },
                    {
                        "username": "shakthisri",
                        "content": "it totally gave me a different view! thank you"
                    },
                    {
                        "username": "Msey",
                        "content": "[@satyamS_71](/satyamS_71) easiest way to use this trick is to present -90 degree as +270, 270 is a 90 degree three times etc"
                    },
                    {
                        "username": "satyamS_71",
                        "content": "Thanks it helped me a lot , but what if the question asks to rotate the image counter clockwise , then how should I approach the problem?"
                    },
                    {
                        "username": "HarshitGupta_02",
                        "content": "class Solution {\\npublic:\\n    void rotate(vector<vector<int>>& matrix) {\\n        int n=matrix.size();\\n        for(int i=0;i<n;i++){\\n            for(int j=0;j<=i;j++){\\n                swap(matrix[i][j],matrix[j][i]);\\n            }\\n        }\\n        for(int i=0;i<n;i++){\\n            int j=0;\\n            int k=n-1;\\n            while(j<=n/2 && k>=n/2){\\n                swap(matrix[i][j],matrix[i][k]);\\n                j++;\\n                k--;\\n            }\\n        }\\n    }\\n};"
                    },
                    {
                        "username": "Bobzero",
                        "content": "I\\'m always having fun reading the discussions \\uD83D\\uDE03"
                    },
                    {
                        "username": "charlesxiao2",
                        "content": "This post is for rotating the matrix anticlockwise. Sorry, when I post it I didn\\'t notice it. But please read it, because I guarantee you can understand the thought process and came up with your solution for clockwise rotation.\\n\\nSo, we are required to rotate it in place. \\n\\nGive a matrix, there are several operations can be done in matrix in place:\\n\\ntranslation, and swap symmetrically(mirror against diagnal), and probaly some unexpected in place operations.\\n\\nWe are trying to break the rotation operation into these operations that are know to carry on easily in place.\\n\\nFor swap symmetrically, given coordinate (a,b), it will be swapped to (b,a) if following the upper left and buttom right diagnal as mirror.\\nFor translation, given coordinate (a, b), we are able to traslate it to (a, whatever) or (whatever, b) with ease.\\n\\nIf rotated anticlockwise, element at (a,b) will be transfered to the new coordinate of (s-b-1 ,a) with s being the length or width of the matrix.\\nWe are trying to find out the in place operations needed in order to transform the coordinate from (a, b) to (s-b-1, a), with some fundumantal operations\\' coordinate transformation characteristics in mind.\\n\\nwe are trying to fill in the logic path between (a, b) to (s-b-1, a) using the fundamental operations.\\n\\nLet\\'s try to fill the logic break reversely:\\nto get to (s-b-1, a) from (a, b), notice a is swapped, we guess the last operation may be mirror against diagnal. so the path now becomes:\\n(a,b) -> (a, s-b-1) -> (s-b-1, a)//the last mirror can be easily done in place\\n\\nNow we try, how to get to (a, s-b-1) from (a, b) using fundamental in place operations? Well, draw a matrix, and you find out that this is not translation, but some swapping too. Don\\'t worry, you see the operations does not change the row coordinate, so it can be done in place with ease. And you know at this point you design the algorithm for this problem.\\n\\nThis is how the logic flows trying to design the in place algorithm to rotate n*n matrix.\\nBasically, we are trying to break down the operations into easy atomic in place operations. How to break down? Analyze the coordinate characteristics with some basic patterns in mind.\\n\\n"
                    },
                    {
                        "username": "UmerZia",
                        "content": "What If we do not have the diagonal, Just thinking about more dynamic solution!"
                    },
                    {
                        "username": "k3000001",
                        "content": "What exactly does it help measure? That the candidate can remember the trick of swapping rows?"
                    },
                    {
                        "username": "MiliMakwana",
                        "content": "[@Nandhini-Techie](/Nandhini-Techie)  Extra space bro\\n"
                    },
                    {
                        "username": "Nandhini-Techie",
                        "content": "  for (int i = 0; i < matrix.length; i++) {\\n      List<int> subList = [];\\n      for (int j = matrix.length - 1; j >= 0; j--) {\\n        subList.add(matrix[j][i]);\\n      }\\n      output.add(subList);\\n    }"
                    },
                    {
                        "username": "betrayy",
                        "content": "Was thinking the same.. this question is pretty much free if you just memorize it"
                    },
                    {
                        "username": "dkode",
                        "content": "Diagram:\\n\\n![image](https://assets.leetcode.com/users/images/95016c57-f112-4e79-8be7-0f21c814c800_1630583198.7966883.png)\\n\\n# M[i,j] --> M\\'[j,N-1-i]\\n\\nWe know that transpose relation is \\n#### M[i,j]= M[j,i]\\n#### \\n\\nBut the relation we got is slightly differernt\\n\\nThink how to convert\\nM[i,j] to M[N-1-i,j]\\n\\nThis is equivalent to flipping the matrix horizontally.\\n\\nM[i,j] to M[N-1-i,j]\\n\\nTranspose (M[N-1-i,j]) --> M\\'[j,N-1-i]\\n\\nTranspose and flipping are linear operation\\n\\nSimilary you can solve other cases like 90 degree, 180 degree, 270 degree etc\\n\\n\\n"
                    },
                    {
                        "username": "paras178a",
                        "content": "[@user7617Dm](/user7617Dm) If i is zero, then index will you be at for N+1-i ?"
                    },
                    {
                        "username": "user7617Dm",
                        "content": "why is it N-1-i not N+1-i? If N is 4 for a 4x4 matric"
                    },
                    {
                        "username": "StefanPochmann",
                        "content": "    def rotate(matrix)\\n      matrix.replace(matrix.reverse.transpose)\\n    end\\n\\nI like Ruby's wordy style."
                    },
                    {
                        "username": "cbertake",
                        "content": "when will you stop posting solution in discussion?\\n"
                    },
                    {
                        "username": "deadsec",
                        "content": "\\uD83D\\uDE02 Amazon Recruiter => You have been hired."
                    },
                    {
                        "username": "UmerZia",
                        "content": "[@Brut_all](/Brut_all) Definitely Not! "
                    },
                    {
                        "username": "Brut_all",
                        "content": "But the interviwer might not like \\uD83E\\uDD10"
                    },
                    {
                        "username": "chris3109692",
                        "content": "The complexity analyses in the solution is incorrect. For a NxN matrix, the complexity is O(N^2), but our data size is N^2 by itself, hence the proper way to denote complexity should be O(n). Note big O is always measured against the data size, not the dimension size."
                    },
                    {
                        "username": "Triquetra",
                        "content": "Complexity is an equivalence class of functions, it can be expressed as a function of any variable."
                    },
                    {
                        "username": "WilmerKrisp",
                        "content": "# solution 1\\n\\n![image](https://assets.leetcode.com/users/images/e112c117-97a6-431c-99e9-c2b2ca3b84c5_1597576604.2278848.png)\\n\\n![image](https://assets.leetcode.com/users/images/18ce4afa-3e8d-4943-856c-a59d781def40_1597576610.36345.png)\\n\\n\\n# solution 2 (inplace modification)\\n![image](https://assets.leetcode.com/users/images/9f7d86fb-cde6-4760-8088-b683bb52160f_1597580296.4229963.png)\\n\\n![image](https://assets.leetcode.com/users/images/58888c0c-c0b7-4fee-9f8d-537ef2681f0a_1597580313.7932537.png)\\n"
                    },
                    {
                        "username": "Ayush_PY",
                        "content": "Using a second matrix is not allowed"
                    },
                    {
                        "username": "bnuzhanyu",
                        "content": "I had been asked this question in an interview:\\n\\ngiven an R x C  matrix,  rotate 90 degree clockwise **in place** (with constant extra space).\\n**The matrix is given as an array**, you should do this within the array.\\nExample: \\u3002\\ninput: R = 3, C = 4, array = 1 2 3 4 5 6 7 8 9 10 11 12\\noutput: R = 4, C = 3, array = 9 5 1 10 6 2 11 7 3 12 8 4\\n\\nexplaination:\\nthe input matrix is:\\n1 2 3 4\\n5 6 7 8\\n9 10 11 12\\nthe output matrix is:\\n9 5 1\\n10 6 2\\n11 7 3\\n12 8 4\\n\\nThough I have got an idea of solving this problem, but the time complexity is not O(RxC)\\u3002\\nCan anyone got an O(RxC) solution with O(1) space?\\n\\n\\n"
                    },
                    {
                        "username": "mawhadmd",
                        "content": "That\\'s possible to do in place?"
                    },
                    {
                        "username": "anmol_soniii",
                        "content": "T.C = O( R*C )\\nS.C = O(1) [ in place ]\\nsolution:\\nclass Solution {\\npublic:\\n    void rotate(vector<vector<int>>& matrix) {\\n        int row = matrix.size();\\n        int col = matrix[0].size();\\n\\n        for(int i = 0; i<row ;i++){\\n            int j = 0;\\n            while( j<i ){\\n                swap(matrix[i][j],matrix[j][i]);\\n                j++;\\n            }\\n        }\\n\\n        for(int i = 0 ; i < row ; i++){\\n            int n = 0;\\n            int m = col-1;\\n            while(n<m){\\n                swap(matrix[i][n],matrix[i][m]);\\n                n++;\\n                m--;\\n            }\\n        }\\n    }\\n};"
                    },
                    {
                        "username": "chinnamsaireddy1369",
                        "content": "how can u do this without space, this question itself asking to alter given m x n matrix to n x m matrix, then without using new matrix how will you insert n x m into m x n"
                    },
                    {
                        "username": "him_Sarma619",
                        "content": "This is actually a pretty good question.... I\\'m not able to think of a solution for this, if you don\\'t mind can you please provide the solution for the same ?"
                    }
                ]
            },
            {
                "id": 1932668,
                "content": [
                    {
                        "username": "SaurabhKapade",
                        "content": "In this question only two things to do-\\n1. Find the transpose of the matrix\\n2. Reverse the rows of the matrix "
                    },
                    {
                        "username": "Harsh_Balwani",
                        "content": "Want Hint??\\nHere you go \\n# Hint 1\\n - You need to transpose the matrix.\\n# Hint 2 \\n- You need to reverse the matrix row wise after transpose.\\nWant complete solution?\\nhttps://leetcode.com/problems/rotate-image/solutions/3678211/easy-cpp-solution-with-crystal-clear-step-wise-explanation-using-handmade-images-with-hint/"
                    },
                    {
                        "username": "mdarif77630",
                        "content": "ROTATE MATRIX BY 90 DEGREE IN CLOCK-WISE DIRECTION\\n\\nclass Solution {\\npublic:\\n    void rotate(vector<vector<int>>& matrix) {\\n\\n        int row = matrix.size();\\n\\n        for(int i = 0; i<row; i++)\\n\\n            for(int j = 0; j < i; j++)\\n            \\n                swap(matrix[i][j] , matrix[j][i]);\\n            \\n            for(int i = 0; i<row; i++)\\n\\n                reverse(matrix[i].begin() , matrix[i].end());\\n        \\n    }\\n};"
                    },
                    {
                        "username": "georgezakharov",
                        "content": "Great!\\nBut lets read the rules together.\\n\\n\\uD83D\\uDCA1 Discussion Rules\\n1. Please don\\'t post any solutions in this discussion.\\n\\n2. The problem discussion is for asking questions about the problem or for sharing tips - anything except for solutions.\\n\\n3. If you\\'d like to share your solution for feedback and ideas, please head to the solutions tab and post it there."
                    },
                    {
                        "username": "pahwagautam786",
                        "content": "I Have done it with runtime 0ms and beats 100%"
                    },
                    {
                        "username": "Msey",
                        "content": "King"
                    },
                    {
                        "username": "prathishgm14",
                        "content": "Note:\nBefore Solving this question, Solve this:  [1886. Determine Whether Matrix Can Be Obtained By Rotation\n](https://leetcode.com/problems/determine-whether-matrix-can-be-obtained-by-rotation/)\n\nThen This question is cakewalk for You.\n\nHint:\n\n1. First Transpose the matrix\n2. Flip / interchange/ swap first and last columns"
                    },
                    {
                        "username": "eddytal",
                        "content": "for a,i in enumerate(zip(*matrix)):\\n            matrix[a]=list(i[::-1])"
                    },
                    {
                        "username": "Sudipta_1999",
                        "content": "       Java Solution \\n        //transpose the matrix\\n        int row=matrix.length;\\n        int col=matrix[0].length;\\n\\n        for(int i=0;i<row;i++){\\n            for(int j=i;j<col;j++){\\n                int temp=0;\\n                temp=matrix[i][j];\\n                matrix[i][j]=matrix[j][i];\\n                matrix[j][i]=temp;\\n            }\\n        }\\n\\n        for(int i=0;i<row;i++){\\n            for(int j=0;j<col/2;j++){\\n                int temp=matrix[i][j];\\n                matrix[i][j]=matrix[i][col-1-j];\\n                matrix[i][col-1-j]=temp;\\n            }\\n        }\\n"
                    },
                    {
                        "username": "georgezakharov",
                        "content": "Great!\\nBut lets read the rules together.\\n\\n\\uD83D\\uDCA1 Discussion Rules\\n1. Please don\\'t post any solutions in this discussion.\\n\\n2. The problem discussion is for asking questions about the problem or for sharing tips - anything except for solutions.\\n\\n3. If you\\'d like to share your solution for feedback and ideas, please head to the solutions tab and post it there."
                    },
                    {
                        "username": "ka6rias",
                        "content": "It's joke or what? Stdout - correct, output incorrect?!\n![image](https://user-images.githubusercontent.com/101060979/236068672-a445ca61-e4e6-4e86-950c-fa3f914ba186.png)"
                    },
                    {
                        "username": "user9092To",
                        "content": "Not entirely sure, so don\\'t quote me... but, i think the issue is that you\\'re not modifying the global variable \"matrix\" but a local variable by the same name. Or something like that."
                    },
                    {
                        "username": "Harshsharma12",
                        "content": "\\uD83D\\uDE02\\uD83D\\uDE02"
                    },
                    {
                        "username": "divyanshaarora",
                        "content": "That wasn\\'t pretty intuitive . The fact that it has been asked many times in MAANG interviews , leaves me surprised . "
                    },
                    {
                        "username": "mochiball",
                        "content": "Same. No idea how people can solve this question in an interview without having seen the trick to it "
                    },
                    {
                        "username": "saeed0x1",
                        "content": "python 3 \\uD83D\\uDC80\\n```python3\\n matrix[:] = list(zip(*matrix[::-1]))\\n```"
                    }
                ]
            },
            {
                "id": 1942813,
                "content": [
                    {
                        "username": "SaurabhKapade",
                        "content": "In this question only two things to do-\\n1. Find the transpose of the matrix\\n2. Reverse the rows of the matrix "
                    },
                    {
                        "username": "Harsh_Balwani",
                        "content": "Want Hint??\\nHere you go \\n# Hint 1\\n - You need to transpose the matrix.\\n# Hint 2 \\n- You need to reverse the matrix row wise after transpose.\\nWant complete solution?\\nhttps://leetcode.com/problems/rotate-image/solutions/3678211/easy-cpp-solution-with-crystal-clear-step-wise-explanation-using-handmade-images-with-hint/"
                    },
                    {
                        "username": "mdarif77630",
                        "content": "ROTATE MATRIX BY 90 DEGREE IN CLOCK-WISE DIRECTION\\n\\nclass Solution {\\npublic:\\n    void rotate(vector<vector<int>>& matrix) {\\n\\n        int row = matrix.size();\\n\\n        for(int i = 0; i<row; i++)\\n\\n            for(int j = 0; j < i; j++)\\n            \\n                swap(matrix[i][j] , matrix[j][i]);\\n            \\n            for(int i = 0; i<row; i++)\\n\\n                reverse(matrix[i].begin() , matrix[i].end());\\n        \\n    }\\n};"
                    },
                    {
                        "username": "georgezakharov",
                        "content": "Great!\\nBut lets read the rules together.\\n\\n\\uD83D\\uDCA1 Discussion Rules\\n1. Please don\\'t post any solutions in this discussion.\\n\\n2. The problem discussion is for asking questions about the problem or for sharing tips - anything except for solutions.\\n\\n3. If you\\'d like to share your solution for feedback and ideas, please head to the solutions tab and post it there."
                    },
                    {
                        "username": "pahwagautam786",
                        "content": "I Have done it with runtime 0ms and beats 100%"
                    },
                    {
                        "username": "Msey",
                        "content": "King"
                    },
                    {
                        "username": "prathishgm14",
                        "content": "Note:\nBefore Solving this question, Solve this:  [1886. Determine Whether Matrix Can Be Obtained By Rotation\n](https://leetcode.com/problems/determine-whether-matrix-can-be-obtained-by-rotation/)\n\nThen This question is cakewalk for You.\n\nHint:\n\n1. First Transpose the matrix\n2. Flip / interchange/ swap first and last columns"
                    },
                    {
                        "username": "eddytal",
                        "content": "for a,i in enumerate(zip(*matrix)):\\n            matrix[a]=list(i[::-1])"
                    },
                    {
                        "username": "Sudipta_1999",
                        "content": "       Java Solution \\n        //transpose the matrix\\n        int row=matrix.length;\\n        int col=matrix[0].length;\\n\\n        for(int i=0;i<row;i++){\\n            for(int j=i;j<col;j++){\\n                int temp=0;\\n                temp=matrix[i][j];\\n                matrix[i][j]=matrix[j][i];\\n                matrix[j][i]=temp;\\n            }\\n        }\\n\\n        for(int i=0;i<row;i++){\\n            for(int j=0;j<col/2;j++){\\n                int temp=matrix[i][j];\\n                matrix[i][j]=matrix[i][col-1-j];\\n                matrix[i][col-1-j]=temp;\\n            }\\n        }\\n"
                    },
                    {
                        "username": "georgezakharov",
                        "content": "Great!\\nBut lets read the rules together.\\n\\n\\uD83D\\uDCA1 Discussion Rules\\n1. Please don\\'t post any solutions in this discussion.\\n\\n2. The problem discussion is for asking questions about the problem or for sharing tips - anything except for solutions.\\n\\n3. If you\\'d like to share your solution for feedback and ideas, please head to the solutions tab and post it there."
                    },
                    {
                        "username": "ka6rias",
                        "content": "It's joke or what? Stdout - correct, output incorrect?!\n![image](https://user-images.githubusercontent.com/101060979/236068672-a445ca61-e4e6-4e86-950c-fa3f914ba186.png)"
                    },
                    {
                        "username": "user9092To",
                        "content": "Not entirely sure, so don\\'t quote me... but, i think the issue is that you\\'re not modifying the global variable \"matrix\" but a local variable by the same name. Or something like that."
                    },
                    {
                        "username": "Harshsharma12",
                        "content": "\\uD83D\\uDE02\\uD83D\\uDE02"
                    },
                    {
                        "username": "divyanshaarora",
                        "content": "That wasn\\'t pretty intuitive . The fact that it has been asked many times in MAANG interviews , leaves me surprised . "
                    },
                    {
                        "username": "mochiball",
                        "content": "Same. No idea how people can solve this question in an interview without having seen the trick to it "
                    },
                    {
                        "username": "saeed0x1",
                        "content": "python 3 \\uD83D\\uDC80\\n```python3\\n matrix[:] = list(zip(*matrix[::-1]))\\n```"
                    }
                ]
            },
            {
                "id": 1723264,
                "content": [
                    {
                        "username": "SaurabhKapade",
                        "content": "In this question only two things to do-\\n1. Find the transpose of the matrix\\n2. Reverse the rows of the matrix "
                    },
                    {
                        "username": "Harsh_Balwani",
                        "content": "Want Hint??\\nHere you go \\n# Hint 1\\n - You need to transpose the matrix.\\n# Hint 2 \\n- You need to reverse the matrix row wise after transpose.\\nWant complete solution?\\nhttps://leetcode.com/problems/rotate-image/solutions/3678211/easy-cpp-solution-with-crystal-clear-step-wise-explanation-using-handmade-images-with-hint/"
                    },
                    {
                        "username": "mdarif77630",
                        "content": "ROTATE MATRIX BY 90 DEGREE IN CLOCK-WISE DIRECTION\\n\\nclass Solution {\\npublic:\\n    void rotate(vector<vector<int>>& matrix) {\\n\\n        int row = matrix.size();\\n\\n        for(int i = 0; i<row; i++)\\n\\n            for(int j = 0; j < i; j++)\\n            \\n                swap(matrix[i][j] , matrix[j][i]);\\n            \\n            for(int i = 0; i<row; i++)\\n\\n                reverse(matrix[i].begin() , matrix[i].end());\\n        \\n    }\\n};"
                    },
                    {
                        "username": "georgezakharov",
                        "content": "Great!\\nBut lets read the rules together.\\n\\n\\uD83D\\uDCA1 Discussion Rules\\n1. Please don\\'t post any solutions in this discussion.\\n\\n2. The problem discussion is for asking questions about the problem or for sharing tips - anything except for solutions.\\n\\n3. If you\\'d like to share your solution for feedback and ideas, please head to the solutions tab and post it there."
                    },
                    {
                        "username": "pahwagautam786",
                        "content": "I Have done it with runtime 0ms and beats 100%"
                    },
                    {
                        "username": "Msey",
                        "content": "King"
                    },
                    {
                        "username": "prathishgm14",
                        "content": "Note:\nBefore Solving this question, Solve this:  [1886. Determine Whether Matrix Can Be Obtained By Rotation\n](https://leetcode.com/problems/determine-whether-matrix-can-be-obtained-by-rotation/)\n\nThen This question is cakewalk for You.\n\nHint:\n\n1. First Transpose the matrix\n2. Flip / interchange/ swap first and last columns"
                    },
                    {
                        "username": "eddytal",
                        "content": "for a,i in enumerate(zip(*matrix)):\\n            matrix[a]=list(i[::-1])"
                    },
                    {
                        "username": "Sudipta_1999",
                        "content": "       Java Solution \\n        //transpose the matrix\\n        int row=matrix.length;\\n        int col=matrix[0].length;\\n\\n        for(int i=0;i<row;i++){\\n            for(int j=i;j<col;j++){\\n                int temp=0;\\n                temp=matrix[i][j];\\n                matrix[i][j]=matrix[j][i];\\n                matrix[j][i]=temp;\\n            }\\n        }\\n\\n        for(int i=0;i<row;i++){\\n            for(int j=0;j<col/2;j++){\\n                int temp=matrix[i][j];\\n                matrix[i][j]=matrix[i][col-1-j];\\n                matrix[i][col-1-j]=temp;\\n            }\\n        }\\n"
                    },
                    {
                        "username": "georgezakharov",
                        "content": "Great!\\nBut lets read the rules together.\\n\\n\\uD83D\\uDCA1 Discussion Rules\\n1. Please don\\'t post any solutions in this discussion.\\n\\n2. The problem discussion is for asking questions about the problem or for sharing tips - anything except for solutions.\\n\\n3. If you\\'d like to share your solution for feedback and ideas, please head to the solutions tab and post it there."
                    },
                    {
                        "username": "ka6rias",
                        "content": "It's joke or what? Stdout - correct, output incorrect?!\n![image](https://user-images.githubusercontent.com/101060979/236068672-a445ca61-e4e6-4e86-950c-fa3f914ba186.png)"
                    },
                    {
                        "username": "user9092To",
                        "content": "Not entirely sure, so don\\'t quote me... but, i think the issue is that you\\'re not modifying the global variable \"matrix\" but a local variable by the same name. Or something like that."
                    },
                    {
                        "username": "Harshsharma12",
                        "content": "\\uD83D\\uDE02\\uD83D\\uDE02"
                    },
                    {
                        "username": "divyanshaarora",
                        "content": "That wasn\\'t pretty intuitive . The fact that it has been asked many times in MAANG interviews , leaves me surprised . "
                    },
                    {
                        "username": "mochiball",
                        "content": "Same. No idea how people can solve this question in an interview without having seen the trick to it "
                    },
                    {
                        "username": "saeed0x1",
                        "content": "python 3 \\uD83D\\uDC80\\n```python3\\n matrix[:] = list(zip(*matrix[::-1]))\\n```"
                    }
                ]
            },
            {
                "id": 1710940,
                "content": [
                    {
                        "username": "SaurabhKapade",
                        "content": "In this question only two things to do-\\n1. Find the transpose of the matrix\\n2. Reverse the rows of the matrix "
                    },
                    {
                        "username": "Harsh_Balwani",
                        "content": "Want Hint??\\nHere you go \\n# Hint 1\\n - You need to transpose the matrix.\\n# Hint 2 \\n- You need to reverse the matrix row wise after transpose.\\nWant complete solution?\\nhttps://leetcode.com/problems/rotate-image/solutions/3678211/easy-cpp-solution-with-crystal-clear-step-wise-explanation-using-handmade-images-with-hint/"
                    },
                    {
                        "username": "mdarif77630",
                        "content": "ROTATE MATRIX BY 90 DEGREE IN CLOCK-WISE DIRECTION\\n\\nclass Solution {\\npublic:\\n    void rotate(vector<vector<int>>& matrix) {\\n\\n        int row = matrix.size();\\n\\n        for(int i = 0; i<row; i++)\\n\\n            for(int j = 0; j < i; j++)\\n            \\n                swap(matrix[i][j] , matrix[j][i]);\\n            \\n            for(int i = 0; i<row; i++)\\n\\n                reverse(matrix[i].begin() , matrix[i].end());\\n        \\n    }\\n};"
                    },
                    {
                        "username": "georgezakharov",
                        "content": "Great!\\nBut lets read the rules together.\\n\\n\\uD83D\\uDCA1 Discussion Rules\\n1. Please don\\'t post any solutions in this discussion.\\n\\n2. The problem discussion is for asking questions about the problem or for sharing tips - anything except for solutions.\\n\\n3. If you\\'d like to share your solution for feedback and ideas, please head to the solutions tab and post it there."
                    },
                    {
                        "username": "pahwagautam786",
                        "content": "I Have done it with runtime 0ms and beats 100%"
                    },
                    {
                        "username": "Msey",
                        "content": "King"
                    },
                    {
                        "username": "prathishgm14",
                        "content": "Note:\nBefore Solving this question, Solve this:  [1886. Determine Whether Matrix Can Be Obtained By Rotation\n](https://leetcode.com/problems/determine-whether-matrix-can-be-obtained-by-rotation/)\n\nThen This question is cakewalk for You.\n\nHint:\n\n1. First Transpose the matrix\n2. Flip / interchange/ swap first and last columns"
                    },
                    {
                        "username": "eddytal",
                        "content": "for a,i in enumerate(zip(*matrix)):\\n            matrix[a]=list(i[::-1])"
                    },
                    {
                        "username": "Sudipta_1999",
                        "content": "       Java Solution \\n        //transpose the matrix\\n        int row=matrix.length;\\n        int col=matrix[0].length;\\n\\n        for(int i=0;i<row;i++){\\n            for(int j=i;j<col;j++){\\n                int temp=0;\\n                temp=matrix[i][j];\\n                matrix[i][j]=matrix[j][i];\\n                matrix[j][i]=temp;\\n            }\\n        }\\n\\n        for(int i=0;i<row;i++){\\n            for(int j=0;j<col/2;j++){\\n                int temp=matrix[i][j];\\n                matrix[i][j]=matrix[i][col-1-j];\\n                matrix[i][col-1-j]=temp;\\n            }\\n        }\\n"
                    },
                    {
                        "username": "georgezakharov",
                        "content": "Great!\\nBut lets read the rules together.\\n\\n\\uD83D\\uDCA1 Discussion Rules\\n1. Please don\\'t post any solutions in this discussion.\\n\\n2. The problem discussion is for asking questions about the problem or for sharing tips - anything except for solutions.\\n\\n3. If you\\'d like to share your solution for feedback and ideas, please head to the solutions tab and post it there."
                    },
                    {
                        "username": "ka6rias",
                        "content": "It's joke or what? Stdout - correct, output incorrect?!\n![image](https://user-images.githubusercontent.com/101060979/236068672-a445ca61-e4e6-4e86-950c-fa3f914ba186.png)"
                    },
                    {
                        "username": "user9092To",
                        "content": "Not entirely sure, so don\\'t quote me... but, i think the issue is that you\\'re not modifying the global variable \"matrix\" but a local variable by the same name. Or something like that."
                    },
                    {
                        "username": "Harshsharma12",
                        "content": "\\uD83D\\uDE02\\uD83D\\uDE02"
                    },
                    {
                        "username": "divyanshaarora",
                        "content": "That wasn\\'t pretty intuitive . The fact that it has been asked many times in MAANG interviews , leaves me surprised . "
                    },
                    {
                        "username": "mochiball",
                        "content": "Same. No idea how people can solve this question in an interview without having seen the trick to it "
                    },
                    {
                        "username": "saeed0x1",
                        "content": "python 3 \\uD83D\\uDC80\\n```python3\\n matrix[:] = list(zip(*matrix[::-1]))\\n```"
                    }
                ]
            },
            {
                "id": 1852123,
                "content": [
                    {
                        "username": "SaurabhKapade",
                        "content": "In this question only two things to do-\\n1. Find the transpose of the matrix\\n2. Reverse the rows of the matrix "
                    },
                    {
                        "username": "Harsh_Balwani",
                        "content": "Want Hint??\\nHere you go \\n# Hint 1\\n - You need to transpose the matrix.\\n# Hint 2 \\n- You need to reverse the matrix row wise after transpose.\\nWant complete solution?\\nhttps://leetcode.com/problems/rotate-image/solutions/3678211/easy-cpp-solution-with-crystal-clear-step-wise-explanation-using-handmade-images-with-hint/"
                    },
                    {
                        "username": "mdarif77630",
                        "content": "ROTATE MATRIX BY 90 DEGREE IN CLOCK-WISE DIRECTION\\n\\nclass Solution {\\npublic:\\n    void rotate(vector<vector<int>>& matrix) {\\n\\n        int row = matrix.size();\\n\\n        for(int i = 0; i<row; i++)\\n\\n            for(int j = 0; j < i; j++)\\n            \\n                swap(matrix[i][j] , matrix[j][i]);\\n            \\n            for(int i = 0; i<row; i++)\\n\\n                reverse(matrix[i].begin() , matrix[i].end());\\n        \\n    }\\n};"
                    },
                    {
                        "username": "georgezakharov",
                        "content": "Great!\\nBut lets read the rules together.\\n\\n\\uD83D\\uDCA1 Discussion Rules\\n1. Please don\\'t post any solutions in this discussion.\\n\\n2. The problem discussion is for asking questions about the problem or for sharing tips - anything except for solutions.\\n\\n3. If you\\'d like to share your solution for feedback and ideas, please head to the solutions tab and post it there."
                    },
                    {
                        "username": "pahwagautam786",
                        "content": "I Have done it with runtime 0ms and beats 100%"
                    },
                    {
                        "username": "Msey",
                        "content": "King"
                    },
                    {
                        "username": "prathishgm14",
                        "content": "Note:\nBefore Solving this question, Solve this:  [1886. Determine Whether Matrix Can Be Obtained By Rotation\n](https://leetcode.com/problems/determine-whether-matrix-can-be-obtained-by-rotation/)\n\nThen This question is cakewalk for You.\n\nHint:\n\n1. First Transpose the matrix\n2. Flip / interchange/ swap first and last columns"
                    },
                    {
                        "username": "eddytal",
                        "content": "for a,i in enumerate(zip(*matrix)):\\n            matrix[a]=list(i[::-1])"
                    },
                    {
                        "username": "Sudipta_1999",
                        "content": "       Java Solution \\n        //transpose the matrix\\n        int row=matrix.length;\\n        int col=matrix[0].length;\\n\\n        for(int i=0;i<row;i++){\\n            for(int j=i;j<col;j++){\\n                int temp=0;\\n                temp=matrix[i][j];\\n                matrix[i][j]=matrix[j][i];\\n                matrix[j][i]=temp;\\n            }\\n        }\\n\\n        for(int i=0;i<row;i++){\\n            for(int j=0;j<col/2;j++){\\n                int temp=matrix[i][j];\\n                matrix[i][j]=matrix[i][col-1-j];\\n                matrix[i][col-1-j]=temp;\\n            }\\n        }\\n"
                    },
                    {
                        "username": "georgezakharov",
                        "content": "Great!\\nBut lets read the rules together.\\n\\n\\uD83D\\uDCA1 Discussion Rules\\n1. Please don\\'t post any solutions in this discussion.\\n\\n2. The problem discussion is for asking questions about the problem or for sharing tips - anything except for solutions.\\n\\n3. If you\\'d like to share your solution for feedback and ideas, please head to the solutions tab and post it there."
                    },
                    {
                        "username": "ka6rias",
                        "content": "It's joke or what? Stdout - correct, output incorrect?!\n![image](https://user-images.githubusercontent.com/101060979/236068672-a445ca61-e4e6-4e86-950c-fa3f914ba186.png)"
                    },
                    {
                        "username": "user9092To",
                        "content": "Not entirely sure, so don\\'t quote me... but, i think the issue is that you\\'re not modifying the global variable \"matrix\" but a local variable by the same name. Or something like that."
                    },
                    {
                        "username": "Harshsharma12",
                        "content": "\\uD83D\\uDE02\\uD83D\\uDE02"
                    },
                    {
                        "username": "divyanshaarora",
                        "content": "That wasn\\'t pretty intuitive . The fact that it has been asked many times in MAANG interviews , leaves me surprised . "
                    },
                    {
                        "username": "mochiball",
                        "content": "Same. No idea how people can solve this question in an interview without having seen the trick to it "
                    },
                    {
                        "username": "saeed0x1",
                        "content": "python 3 \\uD83D\\uDC80\\n```python3\\n matrix[:] = list(zip(*matrix[::-1]))\\n```"
                    }
                ]
            },
            {
                "id": 1573988,
                "content": [
                    {
                        "username": "SaurabhKapade",
                        "content": "In this question only two things to do-\\n1. Find the transpose of the matrix\\n2. Reverse the rows of the matrix "
                    },
                    {
                        "username": "Harsh_Balwani",
                        "content": "Want Hint??\\nHere you go \\n# Hint 1\\n - You need to transpose the matrix.\\n# Hint 2 \\n- You need to reverse the matrix row wise after transpose.\\nWant complete solution?\\nhttps://leetcode.com/problems/rotate-image/solutions/3678211/easy-cpp-solution-with-crystal-clear-step-wise-explanation-using-handmade-images-with-hint/"
                    },
                    {
                        "username": "mdarif77630",
                        "content": "ROTATE MATRIX BY 90 DEGREE IN CLOCK-WISE DIRECTION\\n\\nclass Solution {\\npublic:\\n    void rotate(vector<vector<int>>& matrix) {\\n\\n        int row = matrix.size();\\n\\n        for(int i = 0; i<row; i++)\\n\\n            for(int j = 0; j < i; j++)\\n            \\n                swap(matrix[i][j] , matrix[j][i]);\\n            \\n            for(int i = 0; i<row; i++)\\n\\n                reverse(matrix[i].begin() , matrix[i].end());\\n        \\n    }\\n};"
                    },
                    {
                        "username": "georgezakharov",
                        "content": "Great!\\nBut lets read the rules together.\\n\\n\\uD83D\\uDCA1 Discussion Rules\\n1. Please don\\'t post any solutions in this discussion.\\n\\n2. The problem discussion is for asking questions about the problem or for sharing tips - anything except for solutions.\\n\\n3. If you\\'d like to share your solution for feedback and ideas, please head to the solutions tab and post it there."
                    },
                    {
                        "username": "pahwagautam786",
                        "content": "I Have done it with runtime 0ms and beats 100%"
                    },
                    {
                        "username": "Msey",
                        "content": "King"
                    },
                    {
                        "username": "prathishgm14",
                        "content": "Note:\nBefore Solving this question, Solve this:  [1886. Determine Whether Matrix Can Be Obtained By Rotation\n](https://leetcode.com/problems/determine-whether-matrix-can-be-obtained-by-rotation/)\n\nThen This question is cakewalk for You.\n\nHint:\n\n1. First Transpose the matrix\n2. Flip / interchange/ swap first and last columns"
                    },
                    {
                        "username": "eddytal",
                        "content": "for a,i in enumerate(zip(*matrix)):\\n            matrix[a]=list(i[::-1])"
                    },
                    {
                        "username": "Sudipta_1999",
                        "content": "       Java Solution \\n        //transpose the matrix\\n        int row=matrix.length;\\n        int col=matrix[0].length;\\n\\n        for(int i=0;i<row;i++){\\n            for(int j=i;j<col;j++){\\n                int temp=0;\\n                temp=matrix[i][j];\\n                matrix[i][j]=matrix[j][i];\\n                matrix[j][i]=temp;\\n            }\\n        }\\n\\n        for(int i=0;i<row;i++){\\n            for(int j=0;j<col/2;j++){\\n                int temp=matrix[i][j];\\n                matrix[i][j]=matrix[i][col-1-j];\\n                matrix[i][col-1-j]=temp;\\n            }\\n        }\\n"
                    },
                    {
                        "username": "georgezakharov",
                        "content": "Great!\\nBut lets read the rules together.\\n\\n\\uD83D\\uDCA1 Discussion Rules\\n1. Please don\\'t post any solutions in this discussion.\\n\\n2. The problem discussion is for asking questions about the problem or for sharing tips - anything except for solutions.\\n\\n3. If you\\'d like to share your solution for feedback and ideas, please head to the solutions tab and post it there."
                    },
                    {
                        "username": "ka6rias",
                        "content": "It's joke or what? Stdout - correct, output incorrect?!\n![image](https://user-images.githubusercontent.com/101060979/236068672-a445ca61-e4e6-4e86-950c-fa3f914ba186.png)"
                    },
                    {
                        "username": "user9092To",
                        "content": "Not entirely sure, so don\\'t quote me... but, i think the issue is that you\\'re not modifying the global variable \"matrix\" but a local variable by the same name. Or something like that."
                    },
                    {
                        "username": "Harshsharma12",
                        "content": "\\uD83D\\uDE02\\uD83D\\uDE02"
                    },
                    {
                        "username": "divyanshaarora",
                        "content": "That wasn\\'t pretty intuitive . The fact that it has been asked many times in MAANG interviews , leaves me surprised . "
                    },
                    {
                        "username": "mochiball",
                        "content": "Same. No idea how people can solve this question in an interview without having seen the trick to it "
                    },
                    {
                        "username": "saeed0x1",
                        "content": "python 3 \\uD83D\\uDC80\\n```python3\\n matrix[:] = list(zip(*matrix[::-1]))\\n```"
                    }
                ]
            },
            {
                "id": 1885991,
                "content": [
                    {
                        "username": "SaurabhKapade",
                        "content": "In this question only two things to do-\\n1. Find the transpose of the matrix\\n2. Reverse the rows of the matrix "
                    },
                    {
                        "username": "Harsh_Balwani",
                        "content": "Want Hint??\\nHere you go \\n# Hint 1\\n - You need to transpose the matrix.\\n# Hint 2 \\n- You need to reverse the matrix row wise after transpose.\\nWant complete solution?\\nhttps://leetcode.com/problems/rotate-image/solutions/3678211/easy-cpp-solution-with-crystal-clear-step-wise-explanation-using-handmade-images-with-hint/"
                    },
                    {
                        "username": "mdarif77630",
                        "content": "ROTATE MATRIX BY 90 DEGREE IN CLOCK-WISE DIRECTION\\n\\nclass Solution {\\npublic:\\n    void rotate(vector<vector<int>>& matrix) {\\n\\n        int row = matrix.size();\\n\\n        for(int i = 0; i<row; i++)\\n\\n            for(int j = 0; j < i; j++)\\n            \\n                swap(matrix[i][j] , matrix[j][i]);\\n            \\n            for(int i = 0; i<row; i++)\\n\\n                reverse(matrix[i].begin() , matrix[i].end());\\n        \\n    }\\n};"
                    },
                    {
                        "username": "georgezakharov",
                        "content": "Great!\\nBut lets read the rules together.\\n\\n\\uD83D\\uDCA1 Discussion Rules\\n1. Please don\\'t post any solutions in this discussion.\\n\\n2. The problem discussion is for asking questions about the problem or for sharing tips - anything except for solutions.\\n\\n3. If you\\'d like to share your solution for feedback and ideas, please head to the solutions tab and post it there."
                    },
                    {
                        "username": "pahwagautam786",
                        "content": "I Have done it with runtime 0ms and beats 100%"
                    },
                    {
                        "username": "Msey",
                        "content": "King"
                    },
                    {
                        "username": "prathishgm14",
                        "content": "Note:\nBefore Solving this question, Solve this:  [1886. Determine Whether Matrix Can Be Obtained By Rotation\n](https://leetcode.com/problems/determine-whether-matrix-can-be-obtained-by-rotation/)\n\nThen This question is cakewalk for You.\n\nHint:\n\n1. First Transpose the matrix\n2. Flip / interchange/ swap first and last columns"
                    },
                    {
                        "username": "eddytal",
                        "content": "for a,i in enumerate(zip(*matrix)):\\n            matrix[a]=list(i[::-1])"
                    },
                    {
                        "username": "Sudipta_1999",
                        "content": "       Java Solution \\n        //transpose the matrix\\n        int row=matrix.length;\\n        int col=matrix[0].length;\\n\\n        for(int i=0;i<row;i++){\\n            for(int j=i;j<col;j++){\\n                int temp=0;\\n                temp=matrix[i][j];\\n                matrix[i][j]=matrix[j][i];\\n                matrix[j][i]=temp;\\n            }\\n        }\\n\\n        for(int i=0;i<row;i++){\\n            for(int j=0;j<col/2;j++){\\n                int temp=matrix[i][j];\\n                matrix[i][j]=matrix[i][col-1-j];\\n                matrix[i][col-1-j]=temp;\\n            }\\n        }\\n"
                    },
                    {
                        "username": "georgezakharov",
                        "content": "Great!\\nBut lets read the rules together.\\n\\n\\uD83D\\uDCA1 Discussion Rules\\n1. Please don\\'t post any solutions in this discussion.\\n\\n2. The problem discussion is for asking questions about the problem or for sharing tips - anything except for solutions.\\n\\n3. If you\\'d like to share your solution for feedback and ideas, please head to the solutions tab and post it there."
                    },
                    {
                        "username": "ka6rias",
                        "content": "It's joke or what? Stdout - correct, output incorrect?!\n![image](https://user-images.githubusercontent.com/101060979/236068672-a445ca61-e4e6-4e86-950c-fa3f914ba186.png)"
                    },
                    {
                        "username": "user9092To",
                        "content": "Not entirely sure, so don\\'t quote me... but, i think the issue is that you\\'re not modifying the global variable \"matrix\" but a local variable by the same name. Or something like that."
                    },
                    {
                        "username": "Harshsharma12",
                        "content": "\\uD83D\\uDE02\\uD83D\\uDE02"
                    },
                    {
                        "username": "divyanshaarora",
                        "content": "That wasn\\'t pretty intuitive . The fact that it has been asked many times in MAANG interviews , leaves me surprised . "
                    },
                    {
                        "username": "mochiball",
                        "content": "Same. No idea how people can solve this question in an interview without having seen the trick to it "
                    },
                    {
                        "username": "saeed0x1",
                        "content": "python 3 \\uD83D\\uDC80\\n```python3\\n matrix[:] = list(zip(*matrix[::-1]))\\n```"
                    }
                ]
            },
            {
                "id": 1881597,
                "content": [
                    {
                        "username": "SaurabhKapade",
                        "content": "In this question only two things to do-\\n1. Find the transpose of the matrix\\n2. Reverse the rows of the matrix "
                    },
                    {
                        "username": "Harsh_Balwani",
                        "content": "Want Hint??\\nHere you go \\n# Hint 1\\n - You need to transpose the matrix.\\n# Hint 2 \\n- You need to reverse the matrix row wise after transpose.\\nWant complete solution?\\nhttps://leetcode.com/problems/rotate-image/solutions/3678211/easy-cpp-solution-with-crystal-clear-step-wise-explanation-using-handmade-images-with-hint/"
                    },
                    {
                        "username": "mdarif77630",
                        "content": "ROTATE MATRIX BY 90 DEGREE IN CLOCK-WISE DIRECTION\\n\\nclass Solution {\\npublic:\\n    void rotate(vector<vector<int>>& matrix) {\\n\\n        int row = matrix.size();\\n\\n        for(int i = 0; i<row; i++)\\n\\n            for(int j = 0; j < i; j++)\\n            \\n                swap(matrix[i][j] , matrix[j][i]);\\n            \\n            for(int i = 0; i<row; i++)\\n\\n                reverse(matrix[i].begin() , matrix[i].end());\\n        \\n    }\\n};"
                    },
                    {
                        "username": "georgezakharov",
                        "content": "Great!\\nBut lets read the rules together.\\n\\n\\uD83D\\uDCA1 Discussion Rules\\n1. Please don\\'t post any solutions in this discussion.\\n\\n2. The problem discussion is for asking questions about the problem or for sharing tips - anything except for solutions.\\n\\n3. If you\\'d like to share your solution for feedback and ideas, please head to the solutions tab and post it there."
                    },
                    {
                        "username": "pahwagautam786",
                        "content": "I Have done it with runtime 0ms and beats 100%"
                    },
                    {
                        "username": "Msey",
                        "content": "King"
                    },
                    {
                        "username": "prathishgm14",
                        "content": "Note:\nBefore Solving this question, Solve this:  [1886. Determine Whether Matrix Can Be Obtained By Rotation\n](https://leetcode.com/problems/determine-whether-matrix-can-be-obtained-by-rotation/)\n\nThen This question is cakewalk for You.\n\nHint:\n\n1. First Transpose the matrix\n2. Flip / interchange/ swap first and last columns"
                    },
                    {
                        "username": "eddytal",
                        "content": "for a,i in enumerate(zip(*matrix)):\\n            matrix[a]=list(i[::-1])"
                    },
                    {
                        "username": "Sudipta_1999",
                        "content": "       Java Solution \\n        //transpose the matrix\\n        int row=matrix.length;\\n        int col=matrix[0].length;\\n\\n        for(int i=0;i<row;i++){\\n            for(int j=i;j<col;j++){\\n                int temp=0;\\n                temp=matrix[i][j];\\n                matrix[i][j]=matrix[j][i];\\n                matrix[j][i]=temp;\\n            }\\n        }\\n\\n        for(int i=0;i<row;i++){\\n            for(int j=0;j<col/2;j++){\\n                int temp=matrix[i][j];\\n                matrix[i][j]=matrix[i][col-1-j];\\n                matrix[i][col-1-j]=temp;\\n            }\\n        }\\n"
                    },
                    {
                        "username": "georgezakharov",
                        "content": "Great!\\nBut lets read the rules together.\\n\\n\\uD83D\\uDCA1 Discussion Rules\\n1. Please don\\'t post any solutions in this discussion.\\n\\n2. The problem discussion is for asking questions about the problem or for sharing tips - anything except for solutions.\\n\\n3. If you\\'d like to share your solution for feedback and ideas, please head to the solutions tab and post it there."
                    },
                    {
                        "username": "ka6rias",
                        "content": "It's joke or what? Stdout - correct, output incorrect?!\n![image](https://user-images.githubusercontent.com/101060979/236068672-a445ca61-e4e6-4e86-950c-fa3f914ba186.png)"
                    },
                    {
                        "username": "user9092To",
                        "content": "Not entirely sure, so don\\'t quote me... but, i think the issue is that you\\'re not modifying the global variable \"matrix\" but a local variable by the same name. Or something like that."
                    },
                    {
                        "username": "Harshsharma12",
                        "content": "\\uD83D\\uDE02\\uD83D\\uDE02"
                    },
                    {
                        "username": "divyanshaarora",
                        "content": "That wasn\\'t pretty intuitive . The fact that it has been asked many times in MAANG interviews , leaves me surprised . "
                    },
                    {
                        "username": "mochiball",
                        "content": "Same. No idea how people can solve this question in an interview without having seen the trick to it "
                    },
                    {
                        "username": "saeed0x1",
                        "content": "python 3 \\uD83D\\uDC80\\n```python3\\n matrix[:] = list(zip(*matrix[::-1]))\\n```"
                    }
                ]
            },
            {
                "id": 1878170,
                "content": [
                    {
                        "username": "SaurabhKapade",
                        "content": "In this question only two things to do-\\n1. Find the transpose of the matrix\\n2. Reverse the rows of the matrix "
                    },
                    {
                        "username": "Harsh_Balwani",
                        "content": "Want Hint??\\nHere you go \\n# Hint 1\\n - You need to transpose the matrix.\\n# Hint 2 \\n- You need to reverse the matrix row wise after transpose.\\nWant complete solution?\\nhttps://leetcode.com/problems/rotate-image/solutions/3678211/easy-cpp-solution-with-crystal-clear-step-wise-explanation-using-handmade-images-with-hint/"
                    },
                    {
                        "username": "mdarif77630",
                        "content": "ROTATE MATRIX BY 90 DEGREE IN CLOCK-WISE DIRECTION\\n\\nclass Solution {\\npublic:\\n    void rotate(vector<vector<int>>& matrix) {\\n\\n        int row = matrix.size();\\n\\n        for(int i = 0; i<row; i++)\\n\\n            for(int j = 0; j < i; j++)\\n            \\n                swap(matrix[i][j] , matrix[j][i]);\\n            \\n            for(int i = 0; i<row; i++)\\n\\n                reverse(matrix[i].begin() , matrix[i].end());\\n        \\n    }\\n};"
                    },
                    {
                        "username": "georgezakharov",
                        "content": "Great!\\nBut lets read the rules together.\\n\\n\\uD83D\\uDCA1 Discussion Rules\\n1. Please don\\'t post any solutions in this discussion.\\n\\n2. The problem discussion is for asking questions about the problem or for sharing tips - anything except for solutions.\\n\\n3. If you\\'d like to share your solution for feedback and ideas, please head to the solutions tab and post it there."
                    },
                    {
                        "username": "pahwagautam786",
                        "content": "I Have done it with runtime 0ms and beats 100%"
                    },
                    {
                        "username": "Msey",
                        "content": "King"
                    },
                    {
                        "username": "prathishgm14",
                        "content": "Note:\nBefore Solving this question, Solve this:  [1886. Determine Whether Matrix Can Be Obtained By Rotation\n](https://leetcode.com/problems/determine-whether-matrix-can-be-obtained-by-rotation/)\n\nThen This question is cakewalk for You.\n\nHint:\n\n1. First Transpose the matrix\n2. Flip / interchange/ swap first and last columns"
                    },
                    {
                        "username": "eddytal",
                        "content": "for a,i in enumerate(zip(*matrix)):\\n            matrix[a]=list(i[::-1])"
                    },
                    {
                        "username": "Sudipta_1999",
                        "content": "       Java Solution \\n        //transpose the matrix\\n        int row=matrix.length;\\n        int col=matrix[0].length;\\n\\n        for(int i=0;i<row;i++){\\n            for(int j=i;j<col;j++){\\n                int temp=0;\\n                temp=matrix[i][j];\\n                matrix[i][j]=matrix[j][i];\\n                matrix[j][i]=temp;\\n            }\\n        }\\n\\n        for(int i=0;i<row;i++){\\n            for(int j=0;j<col/2;j++){\\n                int temp=matrix[i][j];\\n                matrix[i][j]=matrix[i][col-1-j];\\n                matrix[i][col-1-j]=temp;\\n            }\\n        }\\n"
                    },
                    {
                        "username": "georgezakharov",
                        "content": "Great!\\nBut lets read the rules together.\\n\\n\\uD83D\\uDCA1 Discussion Rules\\n1. Please don\\'t post any solutions in this discussion.\\n\\n2. The problem discussion is for asking questions about the problem or for sharing tips - anything except for solutions.\\n\\n3. If you\\'d like to share your solution for feedback and ideas, please head to the solutions tab and post it there."
                    },
                    {
                        "username": "ka6rias",
                        "content": "It's joke or what? Stdout - correct, output incorrect?!\n![image](https://user-images.githubusercontent.com/101060979/236068672-a445ca61-e4e6-4e86-950c-fa3f914ba186.png)"
                    },
                    {
                        "username": "user9092To",
                        "content": "Not entirely sure, so don\\'t quote me... but, i think the issue is that you\\'re not modifying the global variable \"matrix\" but a local variable by the same name. Or something like that."
                    },
                    {
                        "username": "Harshsharma12",
                        "content": "\\uD83D\\uDE02\\uD83D\\uDE02"
                    },
                    {
                        "username": "divyanshaarora",
                        "content": "That wasn\\'t pretty intuitive . The fact that it has been asked many times in MAANG interviews , leaves me surprised . "
                    },
                    {
                        "username": "mochiball",
                        "content": "Same. No idea how people can solve this question in an interview without having seen the trick to it "
                    },
                    {
                        "username": "saeed0x1",
                        "content": "python 3 \\uD83D\\uDC80\\n```python3\\n matrix[:] = list(zip(*matrix[::-1]))\\n```"
                    }
                ]
            },
            {
                "id": 1859951,
                "content": [
                    {
                        "username": "SaurabhKapade",
                        "content": "In this question only two things to do-\\n1. Find the transpose of the matrix\\n2. Reverse the rows of the matrix "
                    },
                    {
                        "username": "Harsh_Balwani",
                        "content": "Want Hint??\\nHere you go \\n# Hint 1\\n - You need to transpose the matrix.\\n# Hint 2 \\n- You need to reverse the matrix row wise after transpose.\\nWant complete solution?\\nhttps://leetcode.com/problems/rotate-image/solutions/3678211/easy-cpp-solution-with-crystal-clear-step-wise-explanation-using-handmade-images-with-hint/"
                    },
                    {
                        "username": "mdarif77630",
                        "content": "ROTATE MATRIX BY 90 DEGREE IN CLOCK-WISE DIRECTION\\n\\nclass Solution {\\npublic:\\n    void rotate(vector<vector<int>>& matrix) {\\n\\n        int row = matrix.size();\\n\\n        for(int i = 0; i<row; i++)\\n\\n            for(int j = 0; j < i; j++)\\n            \\n                swap(matrix[i][j] , matrix[j][i]);\\n            \\n            for(int i = 0; i<row; i++)\\n\\n                reverse(matrix[i].begin() , matrix[i].end());\\n        \\n    }\\n};"
                    },
                    {
                        "username": "georgezakharov",
                        "content": "Great!\\nBut lets read the rules together.\\n\\n\\uD83D\\uDCA1 Discussion Rules\\n1. Please don\\'t post any solutions in this discussion.\\n\\n2. The problem discussion is for asking questions about the problem or for sharing tips - anything except for solutions.\\n\\n3. If you\\'d like to share your solution for feedback and ideas, please head to the solutions tab and post it there."
                    },
                    {
                        "username": "pahwagautam786",
                        "content": "I Have done it with runtime 0ms and beats 100%"
                    },
                    {
                        "username": "Msey",
                        "content": "King"
                    },
                    {
                        "username": "prathishgm14",
                        "content": "Note:\nBefore Solving this question, Solve this:  [1886. Determine Whether Matrix Can Be Obtained By Rotation\n](https://leetcode.com/problems/determine-whether-matrix-can-be-obtained-by-rotation/)\n\nThen This question is cakewalk for You.\n\nHint:\n\n1. First Transpose the matrix\n2. Flip / interchange/ swap first and last columns"
                    },
                    {
                        "username": "eddytal",
                        "content": "for a,i in enumerate(zip(*matrix)):\\n            matrix[a]=list(i[::-1])"
                    },
                    {
                        "username": "Sudipta_1999",
                        "content": "       Java Solution \\n        //transpose the matrix\\n        int row=matrix.length;\\n        int col=matrix[0].length;\\n\\n        for(int i=0;i<row;i++){\\n            for(int j=i;j<col;j++){\\n                int temp=0;\\n                temp=matrix[i][j];\\n                matrix[i][j]=matrix[j][i];\\n                matrix[j][i]=temp;\\n            }\\n        }\\n\\n        for(int i=0;i<row;i++){\\n            for(int j=0;j<col/2;j++){\\n                int temp=matrix[i][j];\\n                matrix[i][j]=matrix[i][col-1-j];\\n                matrix[i][col-1-j]=temp;\\n            }\\n        }\\n"
                    },
                    {
                        "username": "georgezakharov",
                        "content": "Great!\\nBut lets read the rules together.\\n\\n\\uD83D\\uDCA1 Discussion Rules\\n1. Please don\\'t post any solutions in this discussion.\\n\\n2. The problem discussion is for asking questions about the problem or for sharing tips - anything except for solutions.\\n\\n3. If you\\'d like to share your solution for feedback and ideas, please head to the solutions tab and post it there."
                    },
                    {
                        "username": "ka6rias",
                        "content": "It's joke or what? Stdout - correct, output incorrect?!\n![image](https://user-images.githubusercontent.com/101060979/236068672-a445ca61-e4e6-4e86-950c-fa3f914ba186.png)"
                    },
                    {
                        "username": "user9092To",
                        "content": "Not entirely sure, so don\\'t quote me... but, i think the issue is that you\\'re not modifying the global variable \"matrix\" but a local variable by the same name. Or something like that."
                    },
                    {
                        "username": "Harshsharma12",
                        "content": "\\uD83D\\uDE02\\uD83D\\uDE02"
                    },
                    {
                        "username": "divyanshaarora",
                        "content": "That wasn\\'t pretty intuitive . The fact that it has been asked many times in MAANG interviews , leaves me surprised . "
                    },
                    {
                        "username": "mochiball",
                        "content": "Same. No idea how people can solve this question in an interview without having seen the trick to it "
                    },
                    {
                        "username": "saeed0x1",
                        "content": "python 3 \\uD83D\\uDC80\\n```python3\\n matrix[:] = list(zip(*matrix[::-1]))\\n```"
                    }
                ]
            },
            {
                "id": 1804263,
                "content": [
                    {
                        "username": "Batraaaaaa",
                        "content": "The idea behind the algorithm is to first transpose the matrix (i.e., swap elements across the diagonal), and then reverse each row of the matrix. This has the effect of rotating the matrix by 90 degrees clockwise.\n\nTo implement this algorithm, we first get the size of the matrix n. We then use two nested loops to traverse the matrix and swap elements across the diagonal. Specifically, for each element matrix[i][j], we swap it with matrix[j][i], where i and j are the row and column indices, respectively. After this step, the matrix is transposed.\n\nWe then use another loop to reverse each row of the matrix. Specifically, for each row matrix[i], we use the reverse() function from the algorithm library to reverse the elements in that row.\n\nThe resulting matrix is the rotated matrix.\n\nNote that this algorithm modifies the input matrix in-place, and does not use any additional space.\n\nKindly Upvote ❤️"
                    },
                    {
                        "username": "mars_999",
                        "content": "https://www.youtube.com/watch?v=fMSJSS7eO1w&ab_channel=NeetCode\\nNeetcode explains in a better way to code!! I spent 4 hours to convert the logic to code. But got confused and irritated. Finally Neetcode to rescue."
                    },
                    {
                        "username": "aniketkalawat88",
                        "content": "thank you mars_999"
                    },
                    {
                        "username": "ayushprakash1912",
                        "content": "For those who are not sure as to how to approach this, let me share a matrix property which may be helpful. Do try to code on your own though. Steps to rotate a matrix:\\n1. Transpose the matrix.\\n2. Take the reflection along a vertical line passing through middle.\\n\\nThis will rotate a square matrix my 90 degree."
                    },
                    {
                        "username": "rbethamcharla",
                        "content": "All my 2d array submissions are failing with following error.  the same code executed in visual studio. \\nDo I need to change anyhting on leetcode account. Please suggest\\n`Line 21: Char 31: error CS1503: Argument 1: cannot convert from \\'int[][]\\' to \\'int[*,*]\\' (in __Driver__.cs)`"
                    },
                    {
                        "username": "askairon1",
                        "content": "Does anybody know how rotate non square images inplace?"
                    },
                    {
                        "username": "ranbir7",
                        "content": "u can use zip function in python to implement that , probably its not gonna work is what my gut says but I used zip function here , It did the work wonderfully."
                    },
                    {
                        "username": "pyqt",
                        "content": "matrix[:] = [list(reversed([matrix[i][j] for i in range(len(matrix))])) for j in range(len(matrix))]"
                    },
                    {
                        "username": "sannu2613",
                        "content": "https://whitegreyhorse.wordpress.com/2021/03/10/48-rotate-image/"
                    },
                    {
                        "username": "beastlyx",
                        "content": "Completed without reversing or transposing the matrix.. Only thing is that I used another 2D array to keep track of which cells I visited, since im still modifying matrix in place, I think my solution doesn\\'t violate the requirements\\n\\nhttps://leetcode.com/problems/rotate-image/solutions/4103489/java-solution-without-reversing-or-transposing-matrix/"
                    },
                    {
                        "username": "d_k_singh",
                        "content": "We need to rotate the array 90degrees to clockwise:  \n1) that is we need to make a column wise output of the matrix.\n2)observe the output and you'll see that column is printed row-wise opposite.\n3) So, just reverse the i loop or the row loop.\n4) Now the row will go from n to 0.\n5) You have got your answer.\n                    [HIT AND TRIAL BY ME]"
                    },
                    {
                        "username": "AbhishekNegi123",
                        "content": "to solve this problem\\nstep->1-  Transpose the all matrix by swapping.\\nstep->2- reverse the all row of 2D matrix by using the reverse utility function or by make your own reverse function."
                    }
                ]
            },
            {
                "id": 1763899,
                "content": [
                    {
                        "username": "Batraaaaaa",
                        "content": "The idea behind the algorithm is to first transpose the matrix (i.e., swap elements across the diagonal), and then reverse each row of the matrix. This has the effect of rotating the matrix by 90 degrees clockwise.\n\nTo implement this algorithm, we first get the size of the matrix n. We then use two nested loops to traverse the matrix and swap elements across the diagonal. Specifically, for each element matrix[i][j], we swap it with matrix[j][i], where i and j are the row and column indices, respectively. After this step, the matrix is transposed.\n\nWe then use another loop to reverse each row of the matrix. Specifically, for each row matrix[i], we use the reverse() function from the algorithm library to reverse the elements in that row.\n\nThe resulting matrix is the rotated matrix.\n\nNote that this algorithm modifies the input matrix in-place, and does not use any additional space.\n\nKindly Upvote ❤️"
                    },
                    {
                        "username": "mars_999",
                        "content": "https://www.youtube.com/watch?v=fMSJSS7eO1w&ab_channel=NeetCode\\nNeetcode explains in a better way to code!! I spent 4 hours to convert the logic to code. But got confused and irritated. Finally Neetcode to rescue."
                    },
                    {
                        "username": "aniketkalawat88",
                        "content": "thank you mars_999"
                    },
                    {
                        "username": "ayushprakash1912",
                        "content": "For those who are not sure as to how to approach this, let me share a matrix property which may be helpful. Do try to code on your own though. Steps to rotate a matrix:\\n1. Transpose the matrix.\\n2. Take the reflection along a vertical line passing through middle.\\n\\nThis will rotate a square matrix my 90 degree."
                    },
                    {
                        "username": "rbethamcharla",
                        "content": "All my 2d array submissions are failing with following error.  the same code executed in visual studio. \\nDo I need to change anyhting on leetcode account. Please suggest\\n`Line 21: Char 31: error CS1503: Argument 1: cannot convert from \\'int[][]\\' to \\'int[*,*]\\' (in __Driver__.cs)`"
                    },
                    {
                        "username": "askairon1",
                        "content": "Does anybody know how rotate non square images inplace?"
                    },
                    {
                        "username": "ranbir7",
                        "content": "u can use zip function in python to implement that , probably its not gonna work is what my gut says but I used zip function here , It did the work wonderfully."
                    },
                    {
                        "username": "pyqt",
                        "content": "matrix[:] = [list(reversed([matrix[i][j] for i in range(len(matrix))])) for j in range(len(matrix))]"
                    },
                    {
                        "username": "sannu2613",
                        "content": "https://whitegreyhorse.wordpress.com/2021/03/10/48-rotate-image/"
                    },
                    {
                        "username": "beastlyx",
                        "content": "Completed without reversing or transposing the matrix.. Only thing is that I used another 2D array to keep track of which cells I visited, since im still modifying matrix in place, I think my solution doesn\\'t violate the requirements\\n\\nhttps://leetcode.com/problems/rotate-image/solutions/4103489/java-solution-without-reversing-or-transposing-matrix/"
                    },
                    {
                        "username": "d_k_singh",
                        "content": "We need to rotate the array 90degrees to clockwise:  \n1) that is we need to make a column wise output of the matrix.\n2)observe the output and you'll see that column is printed row-wise opposite.\n3) So, just reverse the i loop or the row loop.\n4) Now the row will go from n to 0.\n5) You have got your answer.\n                    [HIT AND TRIAL BY ME]"
                    },
                    {
                        "username": "AbhishekNegi123",
                        "content": "to solve this problem\\nstep->1-  Transpose the all matrix by swapping.\\nstep->2- reverse the all row of 2D matrix by using the reverse utility function or by make your own reverse function."
                    }
                ]
            },
            {
                "id": 1735337,
                "content": [
                    {
                        "username": "Batraaaaaa",
                        "content": "The idea behind the algorithm is to first transpose the matrix (i.e., swap elements across the diagonal), and then reverse each row of the matrix. This has the effect of rotating the matrix by 90 degrees clockwise.\n\nTo implement this algorithm, we first get the size of the matrix n. We then use two nested loops to traverse the matrix and swap elements across the diagonal. Specifically, for each element matrix[i][j], we swap it with matrix[j][i], where i and j are the row and column indices, respectively. After this step, the matrix is transposed.\n\nWe then use another loop to reverse each row of the matrix. Specifically, for each row matrix[i], we use the reverse() function from the algorithm library to reverse the elements in that row.\n\nThe resulting matrix is the rotated matrix.\n\nNote that this algorithm modifies the input matrix in-place, and does not use any additional space.\n\nKindly Upvote ❤️"
                    },
                    {
                        "username": "mars_999",
                        "content": "https://www.youtube.com/watch?v=fMSJSS7eO1w&ab_channel=NeetCode\\nNeetcode explains in a better way to code!! I spent 4 hours to convert the logic to code. But got confused and irritated. Finally Neetcode to rescue."
                    },
                    {
                        "username": "aniketkalawat88",
                        "content": "thank you mars_999"
                    },
                    {
                        "username": "ayushprakash1912",
                        "content": "For those who are not sure as to how to approach this, let me share a matrix property which may be helpful. Do try to code on your own though. Steps to rotate a matrix:\\n1. Transpose the matrix.\\n2. Take the reflection along a vertical line passing through middle.\\n\\nThis will rotate a square matrix my 90 degree."
                    },
                    {
                        "username": "rbethamcharla",
                        "content": "All my 2d array submissions are failing with following error.  the same code executed in visual studio. \\nDo I need to change anyhting on leetcode account. Please suggest\\n`Line 21: Char 31: error CS1503: Argument 1: cannot convert from \\'int[][]\\' to \\'int[*,*]\\' (in __Driver__.cs)`"
                    },
                    {
                        "username": "askairon1",
                        "content": "Does anybody know how rotate non square images inplace?"
                    },
                    {
                        "username": "ranbir7",
                        "content": "u can use zip function in python to implement that , probably its not gonna work is what my gut says but I used zip function here , It did the work wonderfully."
                    },
                    {
                        "username": "pyqt",
                        "content": "matrix[:] = [list(reversed([matrix[i][j] for i in range(len(matrix))])) for j in range(len(matrix))]"
                    },
                    {
                        "username": "sannu2613",
                        "content": "https://whitegreyhorse.wordpress.com/2021/03/10/48-rotate-image/"
                    },
                    {
                        "username": "beastlyx",
                        "content": "Completed without reversing or transposing the matrix.. Only thing is that I used another 2D array to keep track of which cells I visited, since im still modifying matrix in place, I think my solution doesn\\'t violate the requirements\\n\\nhttps://leetcode.com/problems/rotate-image/solutions/4103489/java-solution-without-reversing-or-transposing-matrix/"
                    },
                    {
                        "username": "d_k_singh",
                        "content": "We need to rotate the array 90degrees to clockwise:  \n1) that is we need to make a column wise output of the matrix.\n2)observe the output and you'll see that column is printed row-wise opposite.\n3) So, just reverse the i loop or the row loop.\n4) Now the row will go from n to 0.\n5) You have got your answer.\n                    [HIT AND TRIAL BY ME]"
                    },
                    {
                        "username": "AbhishekNegi123",
                        "content": "to solve this problem\\nstep->1-  Transpose the all matrix by swapping.\\nstep->2- reverse the all row of 2D matrix by using the reverse utility function or by make your own reverse function."
                    }
                ]
            },
            {
                "id": 1573171,
                "content": [
                    {
                        "username": "Batraaaaaa",
                        "content": "The idea behind the algorithm is to first transpose the matrix (i.e., swap elements across the diagonal), and then reverse each row of the matrix. This has the effect of rotating the matrix by 90 degrees clockwise.\n\nTo implement this algorithm, we first get the size of the matrix n. We then use two nested loops to traverse the matrix and swap elements across the diagonal. Specifically, for each element matrix[i][j], we swap it with matrix[j][i], where i and j are the row and column indices, respectively. After this step, the matrix is transposed.\n\nWe then use another loop to reverse each row of the matrix. Specifically, for each row matrix[i], we use the reverse() function from the algorithm library to reverse the elements in that row.\n\nThe resulting matrix is the rotated matrix.\n\nNote that this algorithm modifies the input matrix in-place, and does not use any additional space.\n\nKindly Upvote ❤️"
                    },
                    {
                        "username": "mars_999",
                        "content": "https://www.youtube.com/watch?v=fMSJSS7eO1w&ab_channel=NeetCode\\nNeetcode explains in a better way to code!! I spent 4 hours to convert the logic to code. But got confused and irritated. Finally Neetcode to rescue."
                    },
                    {
                        "username": "aniketkalawat88",
                        "content": "thank you mars_999"
                    },
                    {
                        "username": "ayushprakash1912",
                        "content": "For those who are not sure as to how to approach this, let me share a matrix property which may be helpful. Do try to code on your own though. Steps to rotate a matrix:\\n1. Transpose the matrix.\\n2. Take the reflection along a vertical line passing through middle.\\n\\nThis will rotate a square matrix my 90 degree."
                    },
                    {
                        "username": "rbethamcharla",
                        "content": "All my 2d array submissions are failing with following error.  the same code executed in visual studio. \\nDo I need to change anyhting on leetcode account. Please suggest\\n`Line 21: Char 31: error CS1503: Argument 1: cannot convert from \\'int[][]\\' to \\'int[*,*]\\' (in __Driver__.cs)`"
                    },
                    {
                        "username": "askairon1",
                        "content": "Does anybody know how rotate non square images inplace?"
                    },
                    {
                        "username": "ranbir7",
                        "content": "u can use zip function in python to implement that , probably its not gonna work is what my gut says but I used zip function here , It did the work wonderfully."
                    },
                    {
                        "username": "pyqt",
                        "content": "matrix[:] = [list(reversed([matrix[i][j] for i in range(len(matrix))])) for j in range(len(matrix))]"
                    },
                    {
                        "username": "sannu2613",
                        "content": "https://whitegreyhorse.wordpress.com/2021/03/10/48-rotate-image/"
                    },
                    {
                        "username": "beastlyx",
                        "content": "Completed without reversing or transposing the matrix.. Only thing is that I used another 2D array to keep track of which cells I visited, since im still modifying matrix in place, I think my solution doesn\\'t violate the requirements\\n\\nhttps://leetcode.com/problems/rotate-image/solutions/4103489/java-solution-without-reversing-or-transposing-matrix/"
                    },
                    {
                        "username": "d_k_singh",
                        "content": "We need to rotate the array 90degrees to clockwise:  \n1) that is we need to make a column wise output of the matrix.\n2)observe the output and you'll see that column is printed row-wise opposite.\n3) So, just reverse the i loop or the row loop.\n4) Now the row will go from n to 0.\n5) You have got your answer.\n                    [HIT AND TRIAL BY ME]"
                    },
                    {
                        "username": "AbhishekNegi123",
                        "content": "to solve this problem\\nstep->1-  Transpose the all matrix by swapping.\\nstep->2- reverse the all row of 2D matrix by using the reverse utility function or by make your own reverse function."
                    }
                ]
            },
            {
                "id": 1571116,
                "content": [
                    {
                        "username": "Batraaaaaa",
                        "content": "The idea behind the algorithm is to first transpose the matrix (i.e., swap elements across the diagonal), and then reverse each row of the matrix. This has the effect of rotating the matrix by 90 degrees clockwise.\n\nTo implement this algorithm, we first get the size of the matrix n. We then use two nested loops to traverse the matrix and swap elements across the diagonal. Specifically, for each element matrix[i][j], we swap it with matrix[j][i], where i and j are the row and column indices, respectively. After this step, the matrix is transposed.\n\nWe then use another loop to reverse each row of the matrix. Specifically, for each row matrix[i], we use the reverse() function from the algorithm library to reverse the elements in that row.\n\nThe resulting matrix is the rotated matrix.\n\nNote that this algorithm modifies the input matrix in-place, and does not use any additional space.\n\nKindly Upvote ❤️"
                    },
                    {
                        "username": "mars_999",
                        "content": "https://www.youtube.com/watch?v=fMSJSS7eO1w&ab_channel=NeetCode\\nNeetcode explains in a better way to code!! I spent 4 hours to convert the logic to code. But got confused and irritated. Finally Neetcode to rescue."
                    },
                    {
                        "username": "aniketkalawat88",
                        "content": "thank you mars_999"
                    },
                    {
                        "username": "ayushprakash1912",
                        "content": "For those who are not sure as to how to approach this, let me share a matrix property which may be helpful. Do try to code on your own though. Steps to rotate a matrix:\\n1. Transpose the matrix.\\n2. Take the reflection along a vertical line passing through middle.\\n\\nThis will rotate a square matrix my 90 degree."
                    },
                    {
                        "username": "rbethamcharla",
                        "content": "All my 2d array submissions are failing with following error.  the same code executed in visual studio. \\nDo I need to change anyhting on leetcode account. Please suggest\\n`Line 21: Char 31: error CS1503: Argument 1: cannot convert from \\'int[][]\\' to \\'int[*,*]\\' (in __Driver__.cs)`"
                    },
                    {
                        "username": "askairon1",
                        "content": "Does anybody know how rotate non square images inplace?"
                    },
                    {
                        "username": "ranbir7",
                        "content": "u can use zip function in python to implement that , probably its not gonna work is what my gut says but I used zip function here , It did the work wonderfully."
                    },
                    {
                        "username": "pyqt",
                        "content": "matrix[:] = [list(reversed([matrix[i][j] for i in range(len(matrix))])) for j in range(len(matrix))]"
                    },
                    {
                        "username": "sannu2613",
                        "content": "https://whitegreyhorse.wordpress.com/2021/03/10/48-rotate-image/"
                    },
                    {
                        "username": "beastlyx",
                        "content": "Completed without reversing or transposing the matrix.. Only thing is that I used another 2D array to keep track of which cells I visited, since im still modifying matrix in place, I think my solution doesn\\'t violate the requirements\\n\\nhttps://leetcode.com/problems/rotate-image/solutions/4103489/java-solution-without-reversing-or-transposing-matrix/"
                    },
                    {
                        "username": "d_k_singh",
                        "content": "We need to rotate the array 90degrees to clockwise:  \n1) that is we need to make a column wise output of the matrix.\n2)observe the output and you'll see that column is printed row-wise opposite.\n3) So, just reverse the i loop or the row loop.\n4) Now the row will go from n to 0.\n5) You have got your answer.\n                    [HIT AND TRIAL BY ME]"
                    },
                    {
                        "username": "AbhishekNegi123",
                        "content": "to solve this problem\\nstep->1-  Transpose the all matrix by swapping.\\nstep->2- reverse the all row of 2D matrix by using the reverse utility function or by make your own reverse function."
                    }
                ]
            },
            {
                "id": 1571117,
                "content": [
                    {
                        "username": "Batraaaaaa",
                        "content": "The idea behind the algorithm is to first transpose the matrix (i.e., swap elements across the diagonal), and then reverse each row of the matrix. This has the effect of rotating the matrix by 90 degrees clockwise.\n\nTo implement this algorithm, we first get the size of the matrix n. We then use two nested loops to traverse the matrix and swap elements across the diagonal. Specifically, for each element matrix[i][j], we swap it with matrix[j][i], where i and j are the row and column indices, respectively. After this step, the matrix is transposed.\n\nWe then use another loop to reverse each row of the matrix. Specifically, for each row matrix[i], we use the reverse() function from the algorithm library to reverse the elements in that row.\n\nThe resulting matrix is the rotated matrix.\n\nNote that this algorithm modifies the input matrix in-place, and does not use any additional space.\n\nKindly Upvote ❤️"
                    },
                    {
                        "username": "mars_999",
                        "content": "https://www.youtube.com/watch?v=fMSJSS7eO1w&ab_channel=NeetCode\\nNeetcode explains in a better way to code!! I spent 4 hours to convert the logic to code. But got confused and irritated. Finally Neetcode to rescue."
                    },
                    {
                        "username": "aniketkalawat88",
                        "content": "thank you mars_999"
                    },
                    {
                        "username": "ayushprakash1912",
                        "content": "For those who are not sure as to how to approach this, let me share a matrix property which may be helpful. Do try to code on your own though. Steps to rotate a matrix:\\n1. Transpose the matrix.\\n2. Take the reflection along a vertical line passing through middle.\\n\\nThis will rotate a square matrix my 90 degree."
                    },
                    {
                        "username": "rbethamcharla",
                        "content": "All my 2d array submissions are failing with following error.  the same code executed in visual studio. \\nDo I need to change anyhting on leetcode account. Please suggest\\n`Line 21: Char 31: error CS1503: Argument 1: cannot convert from \\'int[][]\\' to \\'int[*,*]\\' (in __Driver__.cs)`"
                    },
                    {
                        "username": "askairon1",
                        "content": "Does anybody know how rotate non square images inplace?"
                    },
                    {
                        "username": "ranbir7",
                        "content": "u can use zip function in python to implement that , probably its not gonna work is what my gut says but I used zip function here , It did the work wonderfully."
                    },
                    {
                        "username": "pyqt",
                        "content": "matrix[:] = [list(reversed([matrix[i][j] for i in range(len(matrix))])) for j in range(len(matrix))]"
                    },
                    {
                        "username": "sannu2613",
                        "content": "https://whitegreyhorse.wordpress.com/2021/03/10/48-rotate-image/"
                    },
                    {
                        "username": "beastlyx",
                        "content": "Completed without reversing or transposing the matrix.. Only thing is that I used another 2D array to keep track of which cells I visited, since im still modifying matrix in place, I think my solution doesn\\'t violate the requirements\\n\\nhttps://leetcode.com/problems/rotate-image/solutions/4103489/java-solution-without-reversing-or-transposing-matrix/"
                    },
                    {
                        "username": "d_k_singh",
                        "content": "We need to rotate the array 90degrees to clockwise:  \n1) that is we need to make a column wise output of the matrix.\n2)observe the output and you'll see that column is printed row-wise opposite.\n3) So, just reverse the i loop or the row loop.\n4) Now the row will go from n to 0.\n5) You have got your answer.\n                    [HIT AND TRIAL BY ME]"
                    },
                    {
                        "username": "AbhishekNegi123",
                        "content": "to solve this problem\\nstep->1-  Transpose the all matrix by swapping.\\nstep->2- reverse the all row of 2D matrix by using the reverse utility function or by make your own reverse function."
                    }
                ]
            },
            {
                "id": 1575018,
                "content": [
                    {
                        "username": "Batraaaaaa",
                        "content": "The idea behind the algorithm is to first transpose the matrix (i.e., swap elements across the diagonal), and then reverse each row of the matrix. This has the effect of rotating the matrix by 90 degrees clockwise.\n\nTo implement this algorithm, we first get the size of the matrix n. We then use two nested loops to traverse the matrix and swap elements across the diagonal. Specifically, for each element matrix[i][j], we swap it with matrix[j][i], where i and j are the row and column indices, respectively. After this step, the matrix is transposed.\n\nWe then use another loop to reverse each row of the matrix. Specifically, for each row matrix[i], we use the reverse() function from the algorithm library to reverse the elements in that row.\n\nThe resulting matrix is the rotated matrix.\n\nNote that this algorithm modifies the input matrix in-place, and does not use any additional space.\n\nKindly Upvote ❤️"
                    },
                    {
                        "username": "mars_999",
                        "content": "https://www.youtube.com/watch?v=fMSJSS7eO1w&ab_channel=NeetCode\\nNeetcode explains in a better way to code!! I spent 4 hours to convert the logic to code. But got confused and irritated. Finally Neetcode to rescue."
                    },
                    {
                        "username": "aniketkalawat88",
                        "content": "thank you mars_999"
                    },
                    {
                        "username": "ayushprakash1912",
                        "content": "For those who are not sure as to how to approach this, let me share a matrix property which may be helpful. Do try to code on your own though. Steps to rotate a matrix:\\n1. Transpose the matrix.\\n2. Take the reflection along a vertical line passing through middle.\\n\\nThis will rotate a square matrix my 90 degree."
                    },
                    {
                        "username": "rbethamcharla",
                        "content": "All my 2d array submissions are failing with following error.  the same code executed in visual studio. \\nDo I need to change anyhting on leetcode account. Please suggest\\n`Line 21: Char 31: error CS1503: Argument 1: cannot convert from \\'int[][]\\' to \\'int[*,*]\\' (in __Driver__.cs)`"
                    },
                    {
                        "username": "askairon1",
                        "content": "Does anybody know how rotate non square images inplace?"
                    },
                    {
                        "username": "ranbir7",
                        "content": "u can use zip function in python to implement that , probably its not gonna work is what my gut says but I used zip function here , It did the work wonderfully."
                    },
                    {
                        "username": "pyqt",
                        "content": "matrix[:] = [list(reversed([matrix[i][j] for i in range(len(matrix))])) for j in range(len(matrix))]"
                    },
                    {
                        "username": "sannu2613",
                        "content": "https://whitegreyhorse.wordpress.com/2021/03/10/48-rotate-image/"
                    },
                    {
                        "username": "beastlyx",
                        "content": "Completed without reversing or transposing the matrix.. Only thing is that I used another 2D array to keep track of which cells I visited, since im still modifying matrix in place, I think my solution doesn\\'t violate the requirements\\n\\nhttps://leetcode.com/problems/rotate-image/solutions/4103489/java-solution-without-reversing-or-transposing-matrix/"
                    },
                    {
                        "username": "d_k_singh",
                        "content": "We need to rotate the array 90degrees to clockwise:  \n1) that is we need to make a column wise output of the matrix.\n2)observe the output and you'll see that column is printed row-wise opposite.\n3) So, just reverse the i loop or the row loop.\n4) Now the row will go from n to 0.\n5) You have got your answer.\n                    [HIT AND TRIAL BY ME]"
                    },
                    {
                        "username": "AbhishekNegi123",
                        "content": "to solve this problem\\nstep->1-  Transpose the all matrix by swapping.\\nstep->2- reverse the all row of 2D matrix by using the reverse utility function or by make your own reverse function."
                    }
                ]
            },
            {
                "id": 2076529,
                "content": [
                    {
                        "username": "Batraaaaaa",
                        "content": "The idea behind the algorithm is to first transpose the matrix (i.e., swap elements across the diagonal), and then reverse each row of the matrix. This has the effect of rotating the matrix by 90 degrees clockwise.\n\nTo implement this algorithm, we first get the size of the matrix n. We then use two nested loops to traverse the matrix and swap elements across the diagonal. Specifically, for each element matrix[i][j], we swap it with matrix[j][i], where i and j are the row and column indices, respectively. After this step, the matrix is transposed.\n\nWe then use another loop to reverse each row of the matrix. Specifically, for each row matrix[i], we use the reverse() function from the algorithm library to reverse the elements in that row.\n\nThe resulting matrix is the rotated matrix.\n\nNote that this algorithm modifies the input matrix in-place, and does not use any additional space.\n\nKindly Upvote ❤️"
                    },
                    {
                        "username": "mars_999",
                        "content": "https://www.youtube.com/watch?v=fMSJSS7eO1w&ab_channel=NeetCode\\nNeetcode explains in a better way to code!! I spent 4 hours to convert the logic to code. But got confused and irritated. Finally Neetcode to rescue."
                    },
                    {
                        "username": "aniketkalawat88",
                        "content": "thank you mars_999"
                    },
                    {
                        "username": "ayushprakash1912",
                        "content": "For those who are not sure as to how to approach this, let me share a matrix property which may be helpful. Do try to code on your own though. Steps to rotate a matrix:\\n1. Transpose the matrix.\\n2. Take the reflection along a vertical line passing through middle.\\n\\nThis will rotate a square matrix my 90 degree."
                    },
                    {
                        "username": "rbethamcharla",
                        "content": "All my 2d array submissions are failing with following error.  the same code executed in visual studio. \\nDo I need to change anyhting on leetcode account. Please suggest\\n`Line 21: Char 31: error CS1503: Argument 1: cannot convert from \\'int[][]\\' to \\'int[*,*]\\' (in __Driver__.cs)`"
                    },
                    {
                        "username": "askairon1",
                        "content": "Does anybody know how rotate non square images inplace?"
                    },
                    {
                        "username": "ranbir7",
                        "content": "u can use zip function in python to implement that , probably its not gonna work is what my gut says but I used zip function here , It did the work wonderfully."
                    },
                    {
                        "username": "pyqt",
                        "content": "matrix[:] = [list(reversed([matrix[i][j] for i in range(len(matrix))])) for j in range(len(matrix))]"
                    },
                    {
                        "username": "sannu2613",
                        "content": "https://whitegreyhorse.wordpress.com/2021/03/10/48-rotate-image/"
                    },
                    {
                        "username": "beastlyx",
                        "content": "Completed without reversing or transposing the matrix.. Only thing is that I used another 2D array to keep track of which cells I visited, since im still modifying matrix in place, I think my solution doesn\\'t violate the requirements\\n\\nhttps://leetcode.com/problems/rotate-image/solutions/4103489/java-solution-without-reversing-or-transposing-matrix/"
                    },
                    {
                        "username": "d_k_singh",
                        "content": "We need to rotate the array 90degrees to clockwise:  \n1) that is we need to make a column wise output of the matrix.\n2)observe the output and you'll see that column is printed row-wise opposite.\n3) So, just reverse the i loop or the row loop.\n4) Now the row will go from n to 0.\n5) You have got your answer.\n                    [HIT AND TRIAL BY ME]"
                    },
                    {
                        "username": "AbhishekNegi123",
                        "content": "to solve this problem\\nstep->1-  Transpose the all matrix by swapping.\\nstep->2- reverse the all row of 2D matrix by using the reverse utility function or by make your own reverse function."
                    }
                ]
            },
            {
                "id": 2068058,
                "content": [
                    {
                        "username": "Batraaaaaa",
                        "content": "The idea behind the algorithm is to first transpose the matrix (i.e., swap elements across the diagonal), and then reverse each row of the matrix. This has the effect of rotating the matrix by 90 degrees clockwise.\n\nTo implement this algorithm, we first get the size of the matrix n. We then use two nested loops to traverse the matrix and swap elements across the diagonal. Specifically, for each element matrix[i][j], we swap it with matrix[j][i], where i and j are the row and column indices, respectively. After this step, the matrix is transposed.\n\nWe then use another loop to reverse each row of the matrix. Specifically, for each row matrix[i], we use the reverse() function from the algorithm library to reverse the elements in that row.\n\nThe resulting matrix is the rotated matrix.\n\nNote that this algorithm modifies the input matrix in-place, and does not use any additional space.\n\nKindly Upvote ❤️"
                    },
                    {
                        "username": "mars_999",
                        "content": "https://www.youtube.com/watch?v=fMSJSS7eO1w&ab_channel=NeetCode\\nNeetcode explains in a better way to code!! I spent 4 hours to convert the logic to code. But got confused and irritated. Finally Neetcode to rescue."
                    },
                    {
                        "username": "aniketkalawat88",
                        "content": "thank you mars_999"
                    },
                    {
                        "username": "ayushprakash1912",
                        "content": "For those who are not sure as to how to approach this, let me share a matrix property which may be helpful. Do try to code on your own though. Steps to rotate a matrix:\\n1. Transpose the matrix.\\n2. Take the reflection along a vertical line passing through middle.\\n\\nThis will rotate a square matrix my 90 degree."
                    },
                    {
                        "username": "rbethamcharla",
                        "content": "All my 2d array submissions are failing with following error.  the same code executed in visual studio. \\nDo I need to change anyhting on leetcode account. Please suggest\\n`Line 21: Char 31: error CS1503: Argument 1: cannot convert from \\'int[][]\\' to \\'int[*,*]\\' (in __Driver__.cs)`"
                    },
                    {
                        "username": "askairon1",
                        "content": "Does anybody know how rotate non square images inplace?"
                    },
                    {
                        "username": "ranbir7",
                        "content": "u can use zip function in python to implement that , probably its not gonna work is what my gut says but I used zip function here , It did the work wonderfully."
                    },
                    {
                        "username": "pyqt",
                        "content": "matrix[:] = [list(reversed([matrix[i][j] for i in range(len(matrix))])) for j in range(len(matrix))]"
                    },
                    {
                        "username": "sannu2613",
                        "content": "https://whitegreyhorse.wordpress.com/2021/03/10/48-rotate-image/"
                    },
                    {
                        "username": "beastlyx",
                        "content": "Completed without reversing or transposing the matrix.. Only thing is that I used another 2D array to keep track of which cells I visited, since im still modifying matrix in place, I think my solution doesn\\'t violate the requirements\\n\\nhttps://leetcode.com/problems/rotate-image/solutions/4103489/java-solution-without-reversing-or-transposing-matrix/"
                    },
                    {
                        "username": "d_k_singh",
                        "content": "We need to rotate the array 90degrees to clockwise:  \n1) that is we need to make a column wise output of the matrix.\n2)observe the output and you'll see that column is printed row-wise opposite.\n3) So, just reverse the i loop or the row loop.\n4) Now the row will go from n to 0.\n5) You have got your answer.\n                    [HIT AND TRIAL BY ME]"
                    },
                    {
                        "username": "AbhishekNegi123",
                        "content": "to solve this problem\\nstep->1-  Transpose the all matrix by swapping.\\nstep->2- reverse the all row of 2D matrix by using the reverse utility function or by make your own reverse function."
                    }
                ]
            },
            {
                "id": 2067082,
                "content": [
                    {
                        "username": "Batraaaaaa",
                        "content": "The idea behind the algorithm is to first transpose the matrix (i.e., swap elements across the diagonal), and then reverse each row of the matrix. This has the effect of rotating the matrix by 90 degrees clockwise.\n\nTo implement this algorithm, we first get the size of the matrix n. We then use two nested loops to traverse the matrix and swap elements across the diagonal. Specifically, for each element matrix[i][j], we swap it with matrix[j][i], where i and j are the row and column indices, respectively. After this step, the matrix is transposed.\n\nWe then use another loop to reverse each row of the matrix. Specifically, for each row matrix[i], we use the reverse() function from the algorithm library to reverse the elements in that row.\n\nThe resulting matrix is the rotated matrix.\n\nNote that this algorithm modifies the input matrix in-place, and does not use any additional space.\n\nKindly Upvote ❤️"
                    },
                    {
                        "username": "mars_999",
                        "content": "https://www.youtube.com/watch?v=fMSJSS7eO1w&ab_channel=NeetCode\\nNeetcode explains in a better way to code!! I spent 4 hours to convert the logic to code. But got confused and irritated. Finally Neetcode to rescue."
                    },
                    {
                        "username": "aniketkalawat88",
                        "content": "thank you mars_999"
                    },
                    {
                        "username": "ayushprakash1912",
                        "content": "For those who are not sure as to how to approach this, let me share a matrix property which may be helpful. Do try to code on your own though. Steps to rotate a matrix:\\n1. Transpose the matrix.\\n2. Take the reflection along a vertical line passing through middle.\\n\\nThis will rotate a square matrix my 90 degree."
                    },
                    {
                        "username": "rbethamcharla",
                        "content": "All my 2d array submissions are failing with following error.  the same code executed in visual studio. \\nDo I need to change anyhting on leetcode account. Please suggest\\n`Line 21: Char 31: error CS1503: Argument 1: cannot convert from \\'int[][]\\' to \\'int[*,*]\\' (in __Driver__.cs)`"
                    },
                    {
                        "username": "askairon1",
                        "content": "Does anybody know how rotate non square images inplace?"
                    },
                    {
                        "username": "ranbir7",
                        "content": "u can use zip function in python to implement that , probably its not gonna work is what my gut says but I used zip function here , It did the work wonderfully."
                    },
                    {
                        "username": "pyqt",
                        "content": "matrix[:] = [list(reversed([matrix[i][j] for i in range(len(matrix))])) for j in range(len(matrix))]"
                    },
                    {
                        "username": "sannu2613",
                        "content": "https://whitegreyhorse.wordpress.com/2021/03/10/48-rotate-image/"
                    },
                    {
                        "username": "beastlyx",
                        "content": "Completed without reversing or transposing the matrix.. Only thing is that I used another 2D array to keep track of which cells I visited, since im still modifying matrix in place, I think my solution doesn\\'t violate the requirements\\n\\nhttps://leetcode.com/problems/rotate-image/solutions/4103489/java-solution-without-reversing-or-transposing-matrix/"
                    },
                    {
                        "username": "d_k_singh",
                        "content": "We need to rotate the array 90degrees to clockwise:  \n1) that is we need to make a column wise output of the matrix.\n2)observe the output and you'll see that column is printed row-wise opposite.\n3) So, just reverse the i loop or the row loop.\n4) Now the row will go from n to 0.\n5) You have got your answer.\n                    [HIT AND TRIAL BY ME]"
                    },
                    {
                        "username": "AbhishekNegi123",
                        "content": "to solve this problem\\nstep->1-  Transpose the all matrix by swapping.\\nstep->2- reverse the all row of 2D matrix by using the reverse utility function or by make your own reverse function."
                    }
                ]
            },
            {
                "id": 2066350,
                "content": [
                    {
                        "username": "zeyaurrahman",
                        "content": "class Solution {\\npublic:\\n    void rotate(vector<vector<int>>& matrix) {\\n         int n = matrix.size();\\n        // transpose\\n        for(int i=0;i<n;i++){\\n            for(int j=i+1;j<n;j++){\\n                // swap i,j and j,i\\n                int temp = matrix[i][j];\\n                matrix[i][j] = matrix[j][i];\\n                matrix[j][i] = temp;\\n            }\\n        }\\n        // reverse each row\\n        for(int k=0;k<n;k++){ // traversing each row\\n            int i = 0;\\n            int j = n-1;\\n            while(i<=j){  // swapping k,i and k,j\\n                int temp = matrix[k][i];\\n                matrix[k][i] = matrix[k][j];\\n                matrix[k][j] = temp;\\n                i++;\\n                j++;\\n            }\\n        }\\n        return;\\n    }\\n};\\n\\nWhy Runtime Error"
                    },
                    {
                        "username": "aykhan_eng",
                        "content": "no way somebody can solve it on his own if he havent seen this problem before"
                    },
                    {
                        "username": "gtoal",
                        "content": "Sorry but that is nonsense.  Like any problem you can work it out from first principles.  Break it down. Look at just the outer ring of the square matrix.  Rotate that. Then remove that ring and look at the smaller square sub-matrix that it contained.  Whatever you did for the outer ring, do it again... until you get to the center and there are no rings left, or just one single item which you can leave.  Then ask yourself how do you rotate just a ring of data.  Well, break that down into four sides.  How do you rotate a side at a time?  Too hard? - well break it down to a smaller problem - how do you rotate the first element in a side?  OK, that one is doable.  You have 4 elements, one on each side, that you want rotated.  Just do it manually - it\\'s like the code for a simple swap: tmp = A; A = B; B = tmp; - except for 4 items, not two.  Then look at the next element in that side.  Same thing - just repeat until you get to the end of that side (being careful not to include the first element of the next side - avoid a \\'fence post\\' error.  Remember, whenever working on a range of data, it\\'s usually \"lowest item inclusive, highest item exclusive\". So by this point you\\'ve rotated the corners, you\\'re rotated each element in a side, you\\'ve rotated the outer ring, and you\\'ve rotated the entire square.   The whole problem reduced to \\'how do you rotate the four elements at the corner of a square matrix\\', which isn\\'t a difficult problem.  Actually the only difficult bit of the code is working out the x,y coordinates of the items making up the nested rings."
                    },
                    {
                        "username": "karnadurgesh70",
                        "content": "this is one of the bruteforce approach and doesnt meets any term from the above question. but you may can get a little approach from it.\\nmain(){\\n    int i=0,j=0;\\n    int row,col;\\n    printf(\"\\\\nEnter the no. of row you want?\");\\n    scanf(\"%d\",&row);\\n    printf(\"\\\\nEnter the no. of column you want?\");\\n    scanf(\"%d\",&col);\\n    int arr[row][col];\\n    for(int k=0;k<row;k++){\\n        for(int l=0;l<col;l++){\\n            scanf(\"%d\",&arr[k][l]);\\n        }\\n    }\\n    printf(\"\\\\nbefore rotating\\\\n\");\\n    for(int k=0;k<row;k++){\\n        for(int l=0;l<col;l++){\\n            printf(\"%d\\\\t\",arr[k][l]);\\n        }\\n        printf(\"\\\\n\");\\n    }\\n    printf(\"\\\\nAfter rotating\\\\n\");\\n    for(int k=0;k<row;k++){\\n        for(int l=row-1;l!=-1;l--){\\n            printf(\"%d\\\\t\",arr[l][k]);\\n        }\\n        printf(\"\\\\n\");\\n    }\\n    return 0;\\n}"
                    },
                    {
                        "username": "haseebh",
                        "content": "Guys, I found an ***interesting solution*** to this problem which does not use any in-built functions like *swap*. Rather, I used a method that can ***store 2 numbers at one cell of a matrix*** using modular arithmetic. \\n[Explanation Link](https://leetcode.com/problems/rotate-image/solutions/4026575/interesting-in-place-solution-o-1-space-complexity/)"
                    },
                    {
                        "username": "BogdanJava",
                        "content": "why is it so hard "
                    },
                    {
                        "username": "debankumarsahu",
                        "content": "class Solution:\\n    def rotate(self, matrix: List[List[int]]) -> None:\\n        \"\"\"\\n        Do not return anything, modify matrix in-place instead.\\n        \"\"\"\\n        matrix.reverse()\\n        j = 0\\n        while j < len(matrix[0]):\\n\\n            for i in range(0,len(matrix)):\\n                matrix[j][i] = matrix[i][j]\\n                \\n            j += 1\\n\\nwhat is erroe in this python3 code\\nplz help"
                    },
                    {
                        "username": "minhphamduy",
                        "content": "Maybe you have seen it on somewhere online, solution is just need two loop with assign 4 corners restropective , first from i=0-> len/2, second from j=i; j< len-1-i"
                    },
                    {
                        "username": "adityaraj79",
                        "content": "Find transpose of the matrix and reverse all the ray of the transpose.\nUpvote it if you liked the approach..."
                    },
                    {
                        "username": "xnoname0000",
                        "content": "Transpose then rotate. Be careful to not modify columns that has been transposed before"
                    },
                    {
                        "username": "gtoal",
                        "content": "It would be nice for automated tester to make 1000X more tests so that the same submission doesn\\'t return in 0ms or 3ms depending on the load on the testing machine."
                    }
                ]
            },
            {
                "id": 2060526,
                "content": [
                    {
                        "username": "zeyaurrahman",
                        "content": "class Solution {\\npublic:\\n    void rotate(vector<vector<int>>& matrix) {\\n         int n = matrix.size();\\n        // transpose\\n        for(int i=0;i<n;i++){\\n            for(int j=i+1;j<n;j++){\\n                // swap i,j and j,i\\n                int temp = matrix[i][j];\\n                matrix[i][j] = matrix[j][i];\\n                matrix[j][i] = temp;\\n            }\\n        }\\n        // reverse each row\\n        for(int k=0;k<n;k++){ // traversing each row\\n            int i = 0;\\n            int j = n-1;\\n            while(i<=j){  // swapping k,i and k,j\\n                int temp = matrix[k][i];\\n                matrix[k][i] = matrix[k][j];\\n                matrix[k][j] = temp;\\n                i++;\\n                j++;\\n            }\\n        }\\n        return;\\n    }\\n};\\n\\nWhy Runtime Error"
                    },
                    {
                        "username": "aykhan_eng",
                        "content": "no way somebody can solve it on his own if he havent seen this problem before"
                    },
                    {
                        "username": "gtoal",
                        "content": "Sorry but that is nonsense.  Like any problem you can work it out from first principles.  Break it down. Look at just the outer ring of the square matrix.  Rotate that. Then remove that ring and look at the smaller square sub-matrix that it contained.  Whatever you did for the outer ring, do it again... until you get to the center and there are no rings left, or just one single item which you can leave.  Then ask yourself how do you rotate just a ring of data.  Well, break that down into four sides.  How do you rotate a side at a time?  Too hard? - well break it down to a smaller problem - how do you rotate the first element in a side?  OK, that one is doable.  You have 4 elements, one on each side, that you want rotated.  Just do it manually - it\\'s like the code for a simple swap: tmp = A; A = B; B = tmp; - except for 4 items, not two.  Then look at the next element in that side.  Same thing - just repeat until you get to the end of that side (being careful not to include the first element of the next side - avoid a \\'fence post\\' error.  Remember, whenever working on a range of data, it\\'s usually \"lowest item inclusive, highest item exclusive\". So by this point you\\'ve rotated the corners, you\\'re rotated each element in a side, you\\'ve rotated the outer ring, and you\\'ve rotated the entire square.   The whole problem reduced to \\'how do you rotate the four elements at the corner of a square matrix\\', which isn\\'t a difficult problem.  Actually the only difficult bit of the code is working out the x,y coordinates of the items making up the nested rings."
                    },
                    {
                        "username": "karnadurgesh70",
                        "content": "this is one of the bruteforce approach and doesnt meets any term from the above question. but you may can get a little approach from it.\\nmain(){\\n    int i=0,j=0;\\n    int row,col;\\n    printf(\"\\\\nEnter the no. of row you want?\");\\n    scanf(\"%d\",&row);\\n    printf(\"\\\\nEnter the no. of column you want?\");\\n    scanf(\"%d\",&col);\\n    int arr[row][col];\\n    for(int k=0;k<row;k++){\\n        for(int l=0;l<col;l++){\\n            scanf(\"%d\",&arr[k][l]);\\n        }\\n    }\\n    printf(\"\\\\nbefore rotating\\\\n\");\\n    for(int k=0;k<row;k++){\\n        for(int l=0;l<col;l++){\\n            printf(\"%d\\\\t\",arr[k][l]);\\n        }\\n        printf(\"\\\\n\");\\n    }\\n    printf(\"\\\\nAfter rotating\\\\n\");\\n    for(int k=0;k<row;k++){\\n        for(int l=row-1;l!=-1;l--){\\n            printf(\"%d\\\\t\",arr[l][k]);\\n        }\\n        printf(\"\\\\n\");\\n    }\\n    return 0;\\n}"
                    },
                    {
                        "username": "haseebh",
                        "content": "Guys, I found an ***interesting solution*** to this problem which does not use any in-built functions like *swap*. Rather, I used a method that can ***store 2 numbers at one cell of a matrix*** using modular arithmetic. \\n[Explanation Link](https://leetcode.com/problems/rotate-image/solutions/4026575/interesting-in-place-solution-o-1-space-complexity/)"
                    },
                    {
                        "username": "BogdanJava",
                        "content": "why is it so hard "
                    },
                    {
                        "username": "debankumarsahu",
                        "content": "class Solution:\\n    def rotate(self, matrix: List[List[int]]) -> None:\\n        \"\"\"\\n        Do not return anything, modify matrix in-place instead.\\n        \"\"\"\\n        matrix.reverse()\\n        j = 0\\n        while j < len(matrix[0]):\\n\\n            for i in range(0,len(matrix)):\\n                matrix[j][i] = matrix[i][j]\\n                \\n            j += 1\\n\\nwhat is erroe in this python3 code\\nplz help"
                    },
                    {
                        "username": "minhphamduy",
                        "content": "Maybe you have seen it on somewhere online, solution is just need two loop with assign 4 corners restropective , first from i=0-> len/2, second from j=i; j< len-1-i"
                    },
                    {
                        "username": "adityaraj79",
                        "content": "Find transpose of the matrix and reverse all the ray of the transpose.\nUpvote it if you liked the approach..."
                    },
                    {
                        "username": "xnoname0000",
                        "content": "Transpose then rotate. Be careful to not modify columns that has been transposed before"
                    },
                    {
                        "username": "gtoal",
                        "content": "It would be nice for automated tester to make 1000X more tests so that the same submission doesn\\'t return in 0ms or 3ms depending on the load on the testing machine."
                    }
                ]
            },
            {
                "id": 2058753,
                "content": [
                    {
                        "username": "zeyaurrahman",
                        "content": "class Solution {\\npublic:\\n    void rotate(vector<vector<int>>& matrix) {\\n         int n = matrix.size();\\n        // transpose\\n        for(int i=0;i<n;i++){\\n            for(int j=i+1;j<n;j++){\\n                // swap i,j and j,i\\n                int temp = matrix[i][j];\\n                matrix[i][j] = matrix[j][i];\\n                matrix[j][i] = temp;\\n            }\\n        }\\n        // reverse each row\\n        for(int k=0;k<n;k++){ // traversing each row\\n            int i = 0;\\n            int j = n-1;\\n            while(i<=j){  // swapping k,i and k,j\\n                int temp = matrix[k][i];\\n                matrix[k][i] = matrix[k][j];\\n                matrix[k][j] = temp;\\n                i++;\\n                j++;\\n            }\\n        }\\n        return;\\n    }\\n};\\n\\nWhy Runtime Error"
                    },
                    {
                        "username": "aykhan_eng",
                        "content": "no way somebody can solve it on his own if he havent seen this problem before"
                    },
                    {
                        "username": "gtoal",
                        "content": "Sorry but that is nonsense.  Like any problem you can work it out from first principles.  Break it down. Look at just the outer ring of the square matrix.  Rotate that. Then remove that ring and look at the smaller square sub-matrix that it contained.  Whatever you did for the outer ring, do it again... until you get to the center and there are no rings left, or just one single item which you can leave.  Then ask yourself how do you rotate just a ring of data.  Well, break that down into four sides.  How do you rotate a side at a time?  Too hard? - well break it down to a smaller problem - how do you rotate the first element in a side?  OK, that one is doable.  You have 4 elements, one on each side, that you want rotated.  Just do it manually - it\\'s like the code for a simple swap: tmp = A; A = B; B = tmp; - except for 4 items, not two.  Then look at the next element in that side.  Same thing - just repeat until you get to the end of that side (being careful not to include the first element of the next side - avoid a \\'fence post\\' error.  Remember, whenever working on a range of data, it\\'s usually \"lowest item inclusive, highest item exclusive\". So by this point you\\'ve rotated the corners, you\\'re rotated each element in a side, you\\'ve rotated the outer ring, and you\\'ve rotated the entire square.   The whole problem reduced to \\'how do you rotate the four elements at the corner of a square matrix\\', which isn\\'t a difficult problem.  Actually the only difficult bit of the code is working out the x,y coordinates of the items making up the nested rings."
                    },
                    {
                        "username": "karnadurgesh70",
                        "content": "this is one of the bruteforce approach and doesnt meets any term from the above question. but you may can get a little approach from it.\\nmain(){\\n    int i=0,j=0;\\n    int row,col;\\n    printf(\"\\\\nEnter the no. of row you want?\");\\n    scanf(\"%d\",&row);\\n    printf(\"\\\\nEnter the no. of column you want?\");\\n    scanf(\"%d\",&col);\\n    int arr[row][col];\\n    for(int k=0;k<row;k++){\\n        for(int l=0;l<col;l++){\\n            scanf(\"%d\",&arr[k][l]);\\n        }\\n    }\\n    printf(\"\\\\nbefore rotating\\\\n\");\\n    for(int k=0;k<row;k++){\\n        for(int l=0;l<col;l++){\\n            printf(\"%d\\\\t\",arr[k][l]);\\n        }\\n        printf(\"\\\\n\");\\n    }\\n    printf(\"\\\\nAfter rotating\\\\n\");\\n    for(int k=0;k<row;k++){\\n        for(int l=row-1;l!=-1;l--){\\n            printf(\"%d\\\\t\",arr[l][k]);\\n        }\\n        printf(\"\\\\n\");\\n    }\\n    return 0;\\n}"
                    },
                    {
                        "username": "haseebh",
                        "content": "Guys, I found an ***interesting solution*** to this problem which does not use any in-built functions like *swap*. Rather, I used a method that can ***store 2 numbers at one cell of a matrix*** using modular arithmetic. \\n[Explanation Link](https://leetcode.com/problems/rotate-image/solutions/4026575/interesting-in-place-solution-o-1-space-complexity/)"
                    },
                    {
                        "username": "BogdanJava",
                        "content": "why is it so hard "
                    },
                    {
                        "username": "debankumarsahu",
                        "content": "class Solution:\\n    def rotate(self, matrix: List[List[int]]) -> None:\\n        \"\"\"\\n        Do not return anything, modify matrix in-place instead.\\n        \"\"\"\\n        matrix.reverse()\\n        j = 0\\n        while j < len(matrix[0]):\\n\\n            for i in range(0,len(matrix)):\\n                matrix[j][i] = matrix[i][j]\\n                \\n            j += 1\\n\\nwhat is erroe in this python3 code\\nplz help"
                    },
                    {
                        "username": "minhphamduy",
                        "content": "Maybe you have seen it on somewhere online, solution is just need two loop with assign 4 corners restropective , first from i=0-> len/2, second from j=i; j< len-1-i"
                    },
                    {
                        "username": "adityaraj79",
                        "content": "Find transpose of the matrix and reverse all the ray of the transpose.\nUpvote it if you liked the approach..."
                    },
                    {
                        "username": "xnoname0000",
                        "content": "Transpose then rotate. Be careful to not modify columns that has been transposed before"
                    },
                    {
                        "username": "gtoal",
                        "content": "It would be nice for automated tester to make 1000X more tests so that the same submission doesn\\'t return in 0ms or 3ms depending on the load on the testing machine."
                    }
                ]
            },
            {
                "id": 2051921,
                "content": [
                    {
                        "username": "zeyaurrahman",
                        "content": "class Solution {\\npublic:\\n    void rotate(vector<vector<int>>& matrix) {\\n         int n = matrix.size();\\n        // transpose\\n        for(int i=0;i<n;i++){\\n            for(int j=i+1;j<n;j++){\\n                // swap i,j and j,i\\n                int temp = matrix[i][j];\\n                matrix[i][j] = matrix[j][i];\\n                matrix[j][i] = temp;\\n            }\\n        }\\n        // reverse each row\\n        for(int k=0;k<n;k++){ // traversing each row\\n            int i = 0;\\n            int j = n-1;\\n            while(i<=j){  // swapping k,i and k,j\\n                int temp = matrix[k][i];\\n                matrix[k][i] = matrix[k][j];\\n                matrix[k][j] = temp;\\n                i++;\\n                j++;\\n            }\\n        }\\n        return;\\n    }\\n};\\n\\nWhy Runtime Error"
                    },
                    {
                        "username": "aykhan_eng",
                        "content": "no way somebody can solve it on his own if he havent seen this problem before"
                    },
                    {
                        "username": "gtoal",
                        "content": "Sorry but that is nonsense.  Like any problem you can work it out from first principles.  Break it down. Look at just the outer ring of the square matrix.  Rotate that. Then remove that ring and look at the smaller square sub-matrix that it contained.  Whatever you did for the outer ring, do it again... until you get to the center and there are no rings left, or just one single item which you can leave.  Then ask yourself how do you rotate just a ring of data.  Well, break that down into four sides.  How do you rotate a side at a time?  Too hard? - well break it down to a smaller problem - how do you rotate the first element in a side?  OK, that one is doable.  You have 4 elements, one on each side, that you want rotated.  Just do it manually - it\\'s like the code for a simple swap: tmp = A; A = B; B = tmp; - except for 4 items, not two.  Then look at the next element in that side.  Same thing - just repeat until you get to the end of that side (being careful not to include the first element of the next side - avoid a \\'fence post\\' error.  Remember, whenever working on a range of data, it\\'s usually \"lowest item inclusive, highest item exclusive\". So by this point you\\'ve rotated the corners, you\\'re rotated each element in a side, you\\'ve rotated the outer ring, and you\\'ve rotated the entire square.   The whole problem reduced to \\'how do you rotate the four elements at the corner of a square matrix\\', which isn\\'t a difficult problem.  Actually the only difficult bit of the code is working out the x,y coordinates of the items making up the nested rings."
                    },
                    {
                        "username": "karnadurgesh70",
                        "content": "this is one of the bruteforce approach and doesnt meets any term from the above question. but you may can get a little approach from it.\\nmain(){\\n    int i=0,j=0;\\n    int row,col;\\n    printf(\"\\\\nEnter the no. of row you want?\");\\n    scanf(\"%d\",&row);\\n    printf(\"\\\\nEnter the no. of column you want?\");\\n    scanf(\"%d\",&col);\\n    int arr[row][col];\\n    for(int k=0;k<row;k++){\\n        for(int l=0;l<col;l++){\\n            scanf(\"%d\",&arr[k][l]);\\n        }\\n    }\\n    printf(\"\\\\nbefore rotating\\\\n\");\\n    for(int k=0;k<row;k++){\\n        for(int l=0;l<col;l++){\\n            printf(\"%d\\\\t\",arr[k][l]);\\n        }\\n        printf(\"\\\\n\");\\n    }\\n    printf(\"\\\\nAfter rotating\\\\n\");\\n    for(int k=0;k<row;k++){\\n        for(int l=row-1;l!=-1;l--){\\n            printf(\"%d\\\\t\",arr[l][k]);\\n        }\\n        printf(\"\\\\n\");\\n    }\\n    return 0;\\n}"
                    },
                    {
                        "username": "haseebh",
                        "content": "Guys, I found an ***interesting solution*** to this problem which does not use any in-built functions like *swap*. Rather, I used a method that can ***store 2 numbers at one cell of a matrix*** using modular arithmetic. \\n[Explanation Link](https://leetcode.com/problems/rotate-image/solutions/4026575/interesting-in-place-solution-o-1-space-complexity/)"
                    },
                    {
                        "username": "BogdanJava",
                        "content": "why is it so hard "
                    },
                    {
                        "username": "debankumarsahu",
                        "content": "class Solution:\\n    def rotate(self, matrix: List[List[int]]) -> None:\\n        \"\"\"\\n        Do not return anything, modify matrix in-place instead.\\n        \"\"\"\\n        matrix.reverse()\\n        j = 0\\n        while j < len(matrix[0]):\\n\\n            for i in range(0,len(matrix)):\\n                matrix[j][i] = matrix[i][j]\\n                \\n            j += 1\\n\\nwhat is erroe in this python3 code\\nplz help"
                    },
                    {
                        "username": "minhphamduy",
                        "content": "Maybe you have seen it on somewhere online, solution is just need two loop with assign 4 corners restropective , first from i=0-> len/2, second from j=i; j< len-1-i"
                    },
                    {
                        "username": "adityaraj79",
                        "content": "Find transpose of the matrix and reverse all the ray of the transpose.\nUpvote it if you liked the approach..."
                    },
                    {
                        "username": "xnoname0000",
                        "content": "Transpose then rotate. Be careful to not modify columns that has been transposed before"
                    },
                    {
                        "username": "gtoal",
                        "content": "It would be nice for automated tester to make 1000X more tests so that the same submission doesn\\'t return in 0ms or 3ms depending on the load on the testing machine."
                    }
                ]
            },
            {
                "id": 2051704,
                "content": [
                    {
                        "username": "zeyaurrahman",
                        "content": "class Solution {\\npublic:\\n    void rotate(vector<vector<int>>& matrix) {\\n         int n = matrix.size();\\n        // transpose\\n        for(int i=0;i<n;i++){\\n            for(int j=i+1;j<n;j++){\\n                // swap i,j and j,i\\n                int temp = matrix[i][j];\\n                matrix[i][j] = matrix[j][i];\\n                matrix[j][i] = temp;\\n            }\\n        }\\n        // reverse each row\\n        for(int k=0;k<n;k++){ // traversing each row\\n            int i = 0;\\n            int j = n-1;\\n            while(i<=j){  // swapping k,i and k,j\\n                int temp = matrix[k][i];\\n                matrix[k][i] = matrix[k][j];\\n                matrix[k][j] = temp;\\n                i++;\\n                j++;\\n            }\\n        }\\n        return;\\n    }\\n};\\n\\nWhy Runtime Error"
                    },
                    {
                        "username": "aykhan_eng",
                        "content": "no way somebody can solve it on his own if he havent seen this problem before"
                    },
                    {
                        "username": "gtoal",
                        "content": "Sorry but that is nonsense.  Like any problem you can work it out from first principles.  Break it down. Look at just the outer ring of the square matrix.  Rotate that. Then remove that ring and look at the smaller square sub-matrix that it contained.  Whatever you did for the outer ring, do it again... until you get to the center and there are no rings left, or just one single item which you can leave.  Then ask yourself how do you rotate just a ring of data.  Well, break that down into four sides.  How do you rotate a side at a time?  Too hard? - well break it down to a smaller problem - how do you rotate the first element in a side?  OK, that one is doable.  You have 4 elements, one on each side, that you want rotated.  Just do it manually - it\\'s like the code for a simple swap: tmp = A; A = B; B = tmp; - except for 4 items, not two.  Then look at the next element in that side.  Same thing - just repeat until you get to the end of that side (being careful not to include the first element of the next side - avoid a \\'fence post\\' error.  Remember, whenever working on a range of data, it\\'s usually \"lowest item inclusive, highest item exclusive\". So by this point you\\'ve rotated the corners, you\\'re rotated each element in a side, you\\'ve rotated the outer ring, and you\\'ve rotated the entire square.   The whole problem reduced to \\'how do you rotate the four elements at the corner of a square matrix\\', which isn\\'t a difficult problem.  Actually the only difficult bit of the code is working out the x,y coordinates of the items making up the nested rings."
                    },
                    {
                        "username": "karnadurgesh70",
                        "content": "this is one of the bruteforce approach and doesnt meets any term from the above question. but you may can get a little approach from it.\\nmain(){\\n    int i=0,j=0;\\n    int row,col;\\n    printf(\"\\\\nEnter the no. of row you want?\");\\n    scanf(\"%d\",&row);\\n    printf(\"\\\\nEnter the no. of column you want?\");\\n    scanf(\"%d\",&col);\\n    int arr[row][col];\\n    for(int k=0;k<row;k++){\\n        for(int l=0;l<col;l++){\\n            scanf(\"%d\",&arr[k][l]);\\n        }\\n    }\\n    printf(\"\\\\nbefore rotating\\\\n\");\\n    for(int k=0;k<row;k++){\\n        for(int l=0;l<col;l++){\\n            printf(\"%d\\\\t\",arr[k][l]);\\n        }\\n        printf(\"\\\\n\");\\n    }\\n    printf(\"\\\\nAfter rotating\\\\n\");\\n    for(int k=0;k<row;k++){\\n        for(int l=row-1;l!=-1;l--){\\n            printf(\"%d\\\\t\",arr[l][k]);\\n        }\\n        printf(\"\\\\n\");\\n    }\\n    return 0;\\n}"
                    },
                    {
                        "username": "haseebh",
                        "content": "Guys, I found an ***interesting solution*** to this problem which does not use any in-built functions like *swap*. Rather, I used a method that can ***store 2 numbers at one cell of a matrix*** using modular arithmetic. \\n[Explanation Link](https://leetcode.com/problems/rotate-image/solutions/4026575/interesting-in-place-solution-o-1-space-complexity/)"
                    },
                    {
                        "username": "BogdanJava",
                        "content": "why is it so hard "
                    },
                    {
                        "username": "debankumarsahu",
                        "content": "class Solution:\\n    def rotate(self, matrix: List[List[int]]) -> None:\\n        \"\"\"\\n        Do not return anything, modify matrix in-place instead.\\n        \"\"\"\\n        matrix.reverse()\\n        j = 0\\n        while j < len(matrix[0]):\\n\\n            for i in range(0,len(matrix)):\\n                matrix[j][i] = matrix[i][j]\\n                \\n            j += 1\\n\\nwhat is erroe in this python3 code\\nplz help"
                    },
                    {
                        "username": "minhphamduy",
                        "content": "Maybe you have seen it on somewhere online, solution is just need two loop with assign 4 corners restropective , first from i=0-> len/2, second from j=i; j< len-1-i"
                    },
                    {
                        "username": "adityaraj79",
                        "content": "Find transpose of the matrix and reverse all the ray of the transpose.\nUpvote it if you liked the approach..."
                    },
                    {
                        "username": "xnoname0000",
                        "content": "Transpose then rotate. Be careful to not modify columns that has been transposed before"
                    },
                    {
                        "username": "gtoal",
                        "content": "It would be nice for automated tester to make 1000X more tests so that the same submission doesn\\'t return in 0ms or 3ms depending on the load on the testing machine."
                    }
                ]
            },
            {
                "id": 2046428,
                "content": [
                    {
                        "username": "zeyaurrahman",
                        "content": "class Solution {\\npublic:\\n    void rotate(vector<vector<int>>& matrix) {\\n         int n = matrix.size();\\n        // transpose\\n        for(int i=0;i<n;i++){\\n            for(int j=i+1;j<n;j++){\\n                // swap i,j and j,i\\n                int temp = matrix[i][j];\\n                matrix[i][j] = matrix[j][i];\\n                matrix[j][i] = temp;\\n            }\\n        }\\n        // reverse each row\\n        for(int k=0;k<n;k++){ // traversing each row\\n            int i = 0;\\n            int j = n-1;\\n            while(i<=j){  // swapping k,i and k,j\\n                int temp = matrix[k][i];\\n                matrix[k][i] = matrix[k][j];\\n                matrix[k][j] = temp;\\n                i++;\\n                j++;\\n            }\\n        }\\n        return;\\n    }\\n};\\n\\nWhy Runtime Error"
                    },
                    {
                        "username": "aykhan_eng",
                        "content": "no way somebody can solve it on his own if he havent seen this problem before"
                    },
                    {
                        "username": "gtoal",
                        "content": "Sorry but that is nonsense.  Like any problem you can work it out from first principles.  Break it down. Look at just the outer ring of the square matrix.  Rotate that. Then remove that ring and look at the smaller square sub-matrix that it contained.  Whatever you did for the outer ring, do it again... until you get to the center and there are no rings left, or just one single item which you can leave.  Then ask yourself how do you rotate just a ring of data.  Well, break that down into four sides.  How do you rotate a side at a time?  Too hard? - well break it down to a smaller problem - how do you rotate the first element in a side?  OK, that one is doable.  You have 4 elements, one on each side, that you want rotated.  Just do it manually - it\\'s like the code for a simple swap: tmp = A; A = B; B = tmp; - except for 4 items, not two.  Then look at the next element in that side.  Same thing - just repeat until you get to the end of that side (being careful not to include the first element of the next side - avoid a \\'fence post\\' error.  Remember, whenever working on a range of data, it\\'s usually \"lowest item inclusive, highest item exclusive\". So by this point you\\'ve rotated the corners, you\\'re rotated each element in a side, you\\'ve rotated the outer ring, and you\\'ve rotated the entire square.   The whole problem reduced to \\'how do you rotate the four elements at the corner of a square matrix\\', which isn\\'t a difficult problem.  Actually the only difficult bit of the code is working out the x,y coordinates of the items making up the nested rings."
                    },
                    {
                        "username": "karnadurgesh70",
                        "content": "this is one of the bruteforce approach and doesnt meets any term from the above question. but you may can get a little approach from it.\\nmain(){\\n    int i=0,j=0;\\n    int row,col;\\n    printf(\"\\\\nEnter the no. of row you want?\");\\n    scanf(\"%d\",&row);\\n    printf(\"\\\\nEnter the no. of column you want?\");\\n    scanf(\"%d\",&col);\\n    int arr[row][col];\\n    for(int k=0;k<row;k++){\\n        for(int l=0;l<col;l++){\\n            scanf(\"%d\",&arr[k][l]);\\n        }\\n    }\\n    printf(\"\\\\nbefore rotating\\\\n\");\\n    for(int k=0;k<row;k++){\\n        for(int l=0;l<col;l++){\\n            printf(\"%d\\\\t\",arr[k][l]);\\n        }\\n        printf(\"\\\\n\");\\n    }\\n    printf(\"\\\\nAfter rotating\\\\n\");\\n    for(int k=0;k<row;k++){\\n        for(int l=row-1;l!=-1;l--){\\n            printf(\"%d\\\\t\",arr[l][k]);\\n        }\\n        printf(\"\\\\n\");\\n    }\\n    return 0;\\n}"
                    },
                    {
                        "username": "haseebh",
                        "content": "Guys, I found an ***interesting solution*** to this problem which does not use any in-built functions like *swap*. Rather, I used a method that can ***store 2 numbers at one cell of a matrix*** using modular arithmetic. \\n[Explanation Link](https://leetcode.com/problems/rotate-image/solutions/4026575/interesting-in-place-solution-o-1-space-complexity/)"
                    },
                    {
                        "username": "BogdanJava",
                        "content": "why is it so hard "
                    },
                    {
                        "username": "debankumarsahu",
                        "content": "class Solution:\\n    def rotate(self, matrix: List[List[int]]) -> None:\\n        \"\"\"\\n        Do not return anything, modify matrix in-place instead.\\n        \"\"\"\\n        matrix.reverse()\\n        j = 0\\n        while j < len(matrix[0]):\\n\\n            for i in range(0,len(matrix)):\\n                matrix[j][i] = matrix[i][j]\\n                \\n            j += 1\\n\\nwhat is erroe in this python3 code\\nplz help"
                    },
                    {
                        "username": "minhphamduy",
                        "content": "Maybe you have seen it on somewhere online, solution is just need two loop with assign 4 corners restropective , first from i=0-> len/2, second from j=i; j< len-1-i"
                    },
                    {
                        "username": "adityaraj79",
                        "content": "Find transpose of the matrix and reverse all the ray of the transpose.\nUpvote it if you liked the approach..."
                    },
                    {
                        "username": "xnoname0000",
                        "content": "Transpose then rotate. Be careful to not modify columns that has been transposed before"
                    },
                    {
                        "username": "gtoal",
                        "content": "It would be nice for automated tester to make 1000X more tests so that the same submission doesn\\'t return in 0ms or 3ms depending on the load on the testing machine."
                    }
                ]
            },
            {
                "id": 2045329,
                "content": [
                    {
                        "username": "zeyaurrahman",
                        "content": "class Solution {\\npublic:\\n    void rotate(vector<vector<int>>& matrix) {\\n         int n = matrix.size();\\n        // transpose\\n        for(int i=0;i<n;i++){\\n            for(int j=i+1;j<n;j++){\\n                // swap i,j and j,i\\n                int temp = matrix[i][j];\\n                matrix[i][j] = matrix[j][i];\\n                matrix[j][i] = temp;\\n            }\\n        }\\n        // reverse each row\\n        for(int k=0;k<n;k++){ // traversing each row\\n            int i = 0;\\n            int j = n-1;\\n            while(i<=j){  // swapping k,i and k,j\\n                int temp = matrix[k][i];\\n                matrix[k][i] = matrix[k][j];\\n                matrix[k][j] = temp;\\n                i++;\\n                j++;\\n            }\\n        }\\n        return;\\n    }\\n};\\n\\nWhy Runtime Error"
                    },
                    {
                        "username": "aykhan_eng",
                        "content": "no way somebody can solve it on his own if he havent seen this problem before"
                    },
                    {
                        "username": "gtoal",
                        "content": "Sorry but that is nonsense.  Like any problem you can work it out from first principles.  Break it down. Look at just the outer ring of the square matrix.  Rotate that. Then remove that ring and look at the smaller square sub-matrix that it contained.  Whatever you did for the outer ring, do it again... until you get to the center and there are no rings left, or just one single item which you can leave.  Then ask yourself how do you rotate just a ring of data.  Well, break that down into four sides.  How do you rotate a side at a time?  Too hard? - well break it down to a smaller problem - how do you rotate the first element in a side?  OK, that one is doable.  You have 4 elements, one on each side, that you want rotated.  Just do it manually - it\\'s like the code for a simple swap: tmp = A; A = B; B = tmp; - except for 4 items, not two.  Then look at the next element in that side.  Same thing - just repeat until you get to the end of that side (being careful not to include the first element of the next side - avoid a \\'fence post\\' error.  Remember, whenever working on a range of data, it\\'s usually \"lowest item inclusive, highest item exclusive\". So by this point you\\'ve rotated the corners, you\\'re rotated each element in a side, you\\'ve rotated the outer ring, and you\\'ve rotated the entire square.   The whole problem reduced to \\'how do you rotate the four elements at the corner of a square matrix\\', which isn\\'t a difficult problem.  Actually the only difficult bit of the code is working out the x,y coordinates of the items making up the nested rings."
                    },
                    {
                        "username": "karnadurgesh70",
                        "content": "this is one of the bruteforce approach and doesnt meets any term from the above question. but you may can get a little approach from it.\\nmain(){\\n    int i=0,j=0;\\n    int row,col;\\n    printf(\"\\\\nEnter the no. of row you want?\");\\n    scanf(\"%d\",&row);\\n    printf(\"\\\\nEnter the no. of column you want?\");\\n    scanf(\"%d\",&col);\\n    int arr[row][col];\\n    for(int k=0;k<row;k++){\\n        for(int l=0;l<col;l++){\\n            scanf(\"%d\",&arr[k][l]);\\n        }\\n    }\\n    printf(\"\\\\nbefore rotating\\\\n\");\\n    for(int k=0;k<row;k++){\\n        for(int l=0;l<col;l++){\\n            printf(\"%d\\\\t\",arr[k][l]);\\n        }\\n        printf(\"\\\\n\");\\n    }\\n    printf(\"\\\\nAfter rotating\\\\n\");\\n    for(int k=0;k<row;k++){\\n        for(int l=row-1;l!=-1;l--){\\n            printf(\"%d\\\\t\",arr[l][k]);\\n        }\\n        printf(\"\\\\n\");\\n    }\\n    return 0;\\n}"
                    },
                    {
                        "username": "haseebh",
                        "content": "Guys, I found an ***interesting solution*** to this problem which does not use any in-built functions like *swap*. Rather, I used a method that can ***store 2 numbers at one cell of a matrix*** using modular arithmetic. \\n[Explanation Link](https://leetcode.com/problems/rotate-image/solutions/4026575/interesting-in-place-solution-o-1-space-complexity/)"
                    },
                    {
                        "username": "BogdanJava",
                        "content": "why is it so hard "
                    },
                    {
                        "username": "debankumarsahu",
                        "content": "class Solution:\\n    def rotate(self, matrix: List[List[int]]) -> None:\\n        \"\"\"\\n        Do not return anything, modify matrix in-place instead.\\n        \"\"\"\\n        matrix.reverse()\\n        j = 0\\n        while j < len(matrix[0]):\\n\\n            for i in range(0,len(matrix)):\\n                matrix[j][i] = matrix[i][j]\\n                \\n            j += 1\\n\\nwhat is erroe in this python3 code\\nplz help"
                    },
                    {
                        "username": "minhphamduy",
                        "content": "Maybe you have seen it on somewhere online, solution is just need two loop with assign 4 corners restropective , first from i=0-> len/2, second from j=i; j< len-1-i"
                    },
                    {
                        "username": "adityaraj79",
                        "content": "Find transpose of the matrix and reverse all the ray of the transpose.\nUpvote it if you liked the approach..."
                    },
                    {
                        "username": "xnoname0000",
                        "content": "Transpose then rotate. Be careful to not modify columns that has been transposed before"
                    },
                    {
                        "username": "gtoal",
                        "content": "It would be nice for automated tester to make 1000X more tests so that the same submission doesn\\'t return in 0ms or 3ms depending on the load on the testing machine."
                    }
                ]
            },
            {
                "id": 2033440,
                "content": [
                    {
                        "username": "zeyaurrahman",
                        "content": "class Solution {\\npublic:\\n    void rotate(vector<vector<int>>& matrix) {\\n         int n = matrix.size();\\n        // transpose\\n        for(int i=0;i<n;i++){\\n            for(int j=i+1;j<n;j++){\\n                // swap i,j and j,i\\n                int temp = matrix[i][j];\\n                matrix[i][j] = matrix[j][i];\\n                matrix[j][i] = temp;\\n            }\\n        }\\n        // reverse each row\\n        for(int k=0;k<n;k++){ // traversing each row\\n            int i = 0;\\n            int j = n-1;\\n            while(i<=j){  // swapping k,i and k,j\\n                int temp = matrix[k][i];\\n                matrix[k][i] = matrix[k][j];\\n                matrix[k][j] = temp;\\n                i++;\\n                j++;\\n            }\\n        }\\n        return;\\n    }\\n};\\n\\nWhy Runtime Error"
                    },
                    {
                        "username": "aykhan_eng",
                        "content": "no way somebody can solve it on his own if he havent seen this problem before"
                    },
                    {
                        "username": "gtoal",
                        "content": "Sorry but that is nonsense.  Like any problem you can work it out from first principles.  Break it down. Look at just the outer ring of the square matrix.  Rotate that. Then remove that ring and look at the smaller square sub-matrix that it contained.  Whatever you did for the outer ring, do it again... until you get to the center and there are no rings left, or just one single item which you can leave.  Then ask yourself how do you rotate just a ring of data.  Well, break that down into four sides.  How do you rotate a side at a time?  Too hard? - well break it down to a smaller problem - how do you rotate the first element in a side?  OK, that one is doable.  You have 4 elements, one on each side, that you want rotated.  Just do it manually - it\\'s like the code for a simple swap: tmp = A; A = B; B = tmp; - except for 4 items, not two.  Then look at the next element in that side.  Same thing - just repeat until you get to the end of that side (being careful not to include the first element of the next side - avoid a \\'fence post\\' error.  Remember, whenever working on a range of data, it\\'s usually \"lowest item inclusive, highest item exclusive\". So by this point you\\'ve rotated the corners, you\\'re rotated each element in a side, you\\'ve rotated the outer ring, and you\\'ve rotated the entire square.   The whole problem reduced to \\'how do you rotate the four elements at the corner of a square matrix\\', which isn\\'t a difficult problem.  Actually the only difficult bit of the code is working out the x,y coordinates of the items making up the nested rings."
                    },
                    {
                        "username": "karnadurgesh70",
                        "content": "this is one of the bruteforce approach and doesnt meets any term from the above question. but you may can get a little approach from it.\\nmain(){\\n    int i=0,j=0;\\n    int row,col;\\n    printf(\"\\\\nEnter the no. of row you want?\");\\n    scanf(\"%d\",&row);\\n    printf(\"\\\\nEnter the no. of column you want?\");\\n    scanf(\"%d\",&col);\\n    int arr[row][col];\\n    for(int k=0;k<row;k++){\\n        for(int l=0;l<col;l++){\\n            scanf(\"%d\",&arr[k][l]);\\n        }\\n    }\\n    printf(\"\\\\nbefore rotating\\\\n\");\\n    for(int k=0;k<row;k++){\\n        for(int l=0;l<col;l++){\\n            printf(\"%d\\\\t\",arr[k][l]);\\n        }\\n        printf(\"\\\\n\");\\n    }\\n    printf(\"\\\\nAfter rotating\\\\n\");\\n    for(int k=0;k<row;k++){\\n        for(int l=row-1;l!=-1;l--){\\n            printf(\"%d\\\\t\",arr[l][k]);\\n        }\\n        printf(\"\\\\n\");\\n    }\\n    return 0;\\n}"
                    },
                    {
                        "username": "haseebh",
                        "content": "Guys, I found an ***interesting solution*** to this problem which does not use any in-built functions like *swap*. Rather, I used a method that can ***store 2 numbers at one cell of a matrix*** using modular arithmetic. \\n[Explanation Link](https://leetcode.com/problems/rotate-image/solutions/4026575/interesting-in-place-solution-o-1-space-complexity/)"
                    },
                    {
                        "username": "BogdanJava",
                        "content": "why is it so hard "
                    },
                    {
                        "username": "debankumarsahu",
                        "content": "class Solution:\\n    def rotate(self, matrix: List[List[int]]) -> None:\\n        \"\"\"\\n        Do not return anything, modify matrix in-place instead.\\n        \"\"\"\\n        matrix.reverse()\\n        j = 0\\n        while j < len(matrix[0]):\\n\\n            for i in range(0,len(matrix)):\\n                matrix[j][i] = matrix[i][j]\\n                \\n            j += 1\\n\\nwhat is erroe in this python3 code\\nplz help"
                    },
                    {
                        "username": "minhphamduy",
                        "content": "Maybe you have seen it on somewhere online, solution is just need two loop with assign 4 corners restropective , first from i=0-> len/2, second from j=i; j< len-1-i"
                    },
                    {
                        "username": "adityaraj79",
                        "content": "Find transpose of the matrix and reverse all the ray of the transpose.\nUpvote it if you liked the approach..."
                    },
                    {
                        "username": "xnoname0000",
                        "content": "Transpose then rotate. Be careful to not modify columns that has been transposed before"
                    },
                    {
                        "username": "gtoal",
                        "content": "It would be nice for automated tester to make 1000X more tests so that the same submission doesn\\'t return in 0ms or 3ms depending on the load on the testing machine."
                    }
                ]
            },
            {
                "id": 2031322,
                "content": [
                    {
                        "username": "zeyaurrahman",
                        "content": "class Solution {\\npublic:\\n    void rotate(vector<vector<int>>& matrix) {\\n         int n = matrix.size();\\n        // transpose\\n        for(int i=0;i<n;i++){\\n            for(int j=i+1;j<n;j++){\\n                // swap i,j and j,i\\n                int temp = matrix[i][j];\\n                matrix[i][j] = matrix[j][i];\\n                matrix[j][i] = temp;\\n            }\\n        }\\n        // reverse each row\\n        for(int k=0;k<n;k++){ // traversing each row\\n            int i = 0;\\n            int j = n-1;\\n            while(i<=j){  // swapping k,i and k,j\\n                int temp = matrix[k][i];\\n                matrix[k][i] = matrix[k][j];\\n                matrix[k][j] = temp;\\n                i++;\\n                j++;\\n            }\\n        }\\n        return;\\n    }\\n};\\n\\nWhy Runtime Error"
                    },
                    {
                        "username": "aykhan_eng",
                        "content": "no way somebody can solve it on his own if he havent seen this problem before"
                    },
                    {
                        "username": "gtoal",
                        "content": "Sorry but that is nonsense.  Like any problem you can work it out from first principles.  Break it down. Look at just the outer ring of the square matrix.  Rotate that. Then remove that ring and look at the smaller square sub-matrix that it contained.  Whatever you did for the outer ring, do it again... until you get to the center and there are no rings left, or just one single item which you can leave.  Then ask yourself how do you rotate just a ring of data.  Well, break that down into four sides.  How do you rotate a side at a time?  Too hard? - well break it down to a smaller problem - how do you rotate the first element in a side?  OK, that one is doable.  You have 4 elements, one on each side, that you want rotated.  Just do it manually - it\\'s like the code for a simple swap: tmp = A; A = B; B = tmp; - except for 4 items, not two.  Then look at the next element in that side.  Same thing - just repeat until you get to the end of that side (being careful not to include the first element of the next side - avoid a \\'fence post\\' error.  Remember, whenever working on a range of data, it\\'s usually \"lowest item inclusive, highest item exclusive\". So by this point you\\'ve rotated the corners, you\\'re rotated each element in a side, you\\'ve rotated the outer ring, and you\\'ve rotated the entire square.   The whole problem reduced to \\'how do you rotate the four elements at the corner of a square matrix\\', which isn\\'t a difficult problem.  Actually the only difficult bit of the code is working out the x,y coordinates of the items making up the nested rings."
                    },
                    {
                        "username": "karnadurgesh70",
                        "content": "this is one of the bruteforce approach and doesnt meets any term from the above question. but you may can get a little approach from it.\\nmain(){\\n    int i=0,j=0;\\n    int row,col;\\n    printf(\"\\\\nEnter the no. of row you want?\");\\n    scanf(\"%d\",&row);\\n    printf(\"\\\\nEnter the no. of column you want?\");\\n    scanf(\"%d\",&col);\\n    int arr[row][col];\\n    for(int k=0;k<row;k++){\\n        for(int l=0;l<col;l++){\\n            scanf(\"%d\",&arr[k][l]);\\n        }\\n    }\\n    printf(\"\\\\nbefore rotating\\\\n\");\\n    for(int k=0;k<row;k++){\\n        for(int l=0;l<col;l++){\\n            printf(\"%d\\\\t\",arr[k][l]);\\n        }\\n        printf(\"\\\\n\");\\n    }\\n    printf(\"\\\\nAfter rotating\\\\n\");\\n    for(int k=0;k<row;k++){\\n        for(int l=row-1;l!=-1;l--){\\n            printf(\"%d\\\\t\",arr[l][k]);\\n        }\\n        printf(\"\\\\n\");\\n    }\\n    return 0;\\n}"
                    },
                    {
                        "username": "haseebh",
                        "content": "Guys, I found an ***interesting solution*** to this problem which does not use any in-built functions like *swap*. Rather, I used a method that can ***store 2 numbers at one cell of a matrix*** using modular arithmetic. \\n[Explanation Link](https://leetcode.com/problems/rotate-image/solutions/4026575/interesting-in-place-solution-o-1-space-complexity/)"
                    },
                    {
                        "username": "BogdanJava",
                        "content": "why is it so hard "
                    },
                    {
                        "username": "debankumarsahu",
                        "content": "class Solution:\\n    def rotate(self, matrix: List[List[int]]) -> None:\\n        \"\"\"\\n        Do not return anything, modify matrix in-place instead.\\n        \"\"\"\\n        matrix.reverse()\\n        j = 0\\n        while j < len(matrix[0]):\\n\\n            for i in range(0,len(matrix)):\\n                matrix[j][i] = matrix[i][j]\\n                \\n            j += 1\\n\\nwhat is erroe in this python3 code\\nplz help"
                    },
                    {
                        "username": "minhphamduy",
                        "content": "Maybe you have seen it on somewhere online, solution is just need two loop with assign 4 corners restropective , first from i=0-> len/2, second from j=i; j< len-1-i"
                    },
                    {
                        "username": "adityaraj79",
                        "content": "Find transpose of the matrix and reverse all the ray of the transpose.\nUpvote it if you liked the approach..."
                    },
                    {
                        "username": "xnoname0000",
                        "content": "Transpose then rotate. Be careful to not modify columns that has been transposed before"
                    },
                    {
                        "username": "gtoal",
                        "content": "It would be nice for automated tester to make 1000X more tests so that the same submission doesn\\'t return in 0ms or 3ms depending on the load on the testing machine."
                    }
                ]
            },
            {
                "id": 2019878,
                "content": [
                    {
                        "username": "zeyaurrahman",
                        "content": "class Solution {\\npublic:\\n    void rotate(vector<vector<int>>& matrix) {\\n         int n = matrix.size();\\n        // transpose\\n        for(int i=0;i<n;i++){\\n            for(int j=i+1;j<n;j++){\\n                // swap i,j and j,i\\n                int temp = matrix[i][j];\\n                matrix[i][j] = matrix[j][i];\\n                matrix[j][i] = temp;\\n            }\\n        }\\n        // reverse each row\\n        for(int k=0;k<n;k++){ // traversing each row\\n            int i = 0;\\n            int j = n-1;\\n            while(i<=j){  // swapping k,i and k,j\\n                int temp = matrix[k][i];\\n                matrix[k][i] = matrix[k][j];\\n                matrix[k][j] = temp;\\n                i++;\\n                j++;\\n            }\\n        }\\n        return;\\n    }\\n};\\n\\nWhy Runtime Error"
                    },
                    {
                        "username": "aykhan_eng",
                        "content": "no way somebody can solve it on his own if he havent seen this problem before"
                    },
                    {
                        "username": "gtoal",
                        "content": "Sorry but that is nonsense.  Like any problem you can work it out from first principles.  Break it down. Look at just the outer ring of the square matrix.  Rotate that. Then remove that ring and look at the smaller square sub-matrix that it contained.  Whatever you did for the outer ring, do it again... until you get to the center and there are no rings left, or just one single item which you can leave.  Then ask yourself how do you rotate just a ring of data.  Well, break that down into four sides.  How do you rotate a side at a time?  Too hard? - well break it down to a smaller problem - how do you rotate the first element in a side?  OK, that one is doable.  You have 4 elements, one on each side, that you want rotated.  Just do it manually - it\\'s like the code for a simple swap: tmp = A; A = B; B = tmp; - except for 4 items, not two.  Then look at the next element in that side.  Same thing - just repeat until you get to the end of that side (being careful not to include the first element of the next side - avoid a \\'fence post\\' error.  Remember, whenever working on a range of data, it\\'s usually \"lowest item inclusive, highest item exclusive\". So by this point you\\'ve rotated the corners, you\\'re rotated each element in a side, you\\'ve rotated the outer ring, and you\\'ve rotated the entire square.   The whole problem reduced to \\'how do you rotate the four elements at the corner of a square matrix\\', which isn\\'t a difficult problem.  Actually the only difficult bit of the code is working out the x,y coordinates of the items making up the nested rings."
                    },
                    {
                        "username": "karnadurgesh70",
                        "content": "this is one of the bruteforce approach and doesnt meets any term from the above question. but you may can get a little approach from it.\\nmain(){\\n    int i=0,j=0;\\n    int row,col;\\n    printf(\"\\\\nEnter the no. of row you want?\");\\n    scanf(\"%d\",&row);\\n    printf(\"\\\\nEnter the no. of column you want?\");\\n    scanf(\"%d\",&col);\\n    int arr[row][col];\\n    for(int k=0;k<row;k++){\\n        for(int l=0;l<col;l++){\\n            scanf(\"%d\",&arr[k][l]);\\n        }\\n    }\\n    printf(\"\\\\nbefore rotating\\\\n\");\\n    for(int k=0;k<row;k++){\\n        for(int l=0;l<col;l++){\\n            printf(\"%d\\\\t\",arr[k][l]);\\n        }\\n        printf(\"\\\\n\");\\n    }\\n    printf(\"\\\\nAfter rotating\\\\n\");\\n    for(int k=0;k<row;k++){\\n        for(int l=row-1;l!=-1;l--){\\n            printf(\"%d\\\\t\",arr[l][k]);\\n        }\\n        printf(\"\\\\n\");\\n    }\\n    return 0;\\n}"
                    },
                    {
                        "username": "haseebh",
                        "content": "Guys, I found an ***interesting solution*** to this problem which does not use any in-built functions like *swap*. Rather, I used a method that can ***store 2 numbers at one cell of a matrix*** using modular arithmetic. \\n[Explanation Link](https://leetcode.com/problems/rotate-image/solutions/4026575/interesting-in-place-solution-o-1-space-complexity/)"
                    },
                    {
                        "username": "BogdanJava",
                        "content": "why is it so hard "
                    },
                    {
                        "username": "debankumarsahu",
                        "content": "class Solution:\\n    def rotate(self, matrix: List[List[int]]) -> None:\\n        \"\"\"\\n        Do not return anything, modify matrix in-place instead.\\n        \"\"\"\\n        matrix.reverse()\\n        j = 0\\n        while j < len(matrix[0]):\\n\\n            for i in range(0,len(matrix)):\\n                matrix[j][i] = matrix[i][j]\\n                \\n            j += 1\\n\\nwhat is erroe in this python3 code\\nplz help"
                    },
                    {
                        "username": "minhphamduy",
                        "content": "Maybe you have seen it on somewhere online, solution is just need two loop with assign 4 corners restropective , first from i=0-> len/2, second from j=i; j< len-1-i"
                    },
                    {
                        "username": "adityaraj79",
                        "content": "Find transpose of the matrix and reverse all the ray of the transpose.\nUpvote it if you liked the approach..."
                    },
                    {
                        "username": "xnoname0000",
                        "content": "Transpose then rotate. Be careful to not modify columns that has been transposed before"
                    },
                    {
                        "username": "gtoal",
                        "content": "It would be nice for automated tester to make 1000X more tests so that the same submission doesn\\'t return in 0ms or 3ms depending on the load on the testing machine."
                    }
                ]
            },
            {
                "id": 2005086,
                "content": [
                    {
                        "username": "Aaryan_0001",
                        "content": "APPROACH  | |   100% BEATS\\n\\n1. Find transpose of the matrix . Note to make this effiecient just swap the elements above the diagonal of the matrix to elements lower to the diagonal. keep in mind that diagonal elements remains untouched so set the loop carefully.\\n\\n2. Reverse the elements of the matrix, to do this efficiently just reverse the elements of each row only. i.e for row =0 reverse all elements inside row=0, for row =1 reverse all elements inside row=1, for row =2 reverse all elements inside row=2 and so on.......\\n\\nAND YOU ARE DONE. | | HIT A LIKE BUDDIES"
                    },
                    {
                        "username": "Pendelbus",
                        "content": "Why it give me an error?\\nclass Solution:\\n        for i in range(len(matrix[0])//2):\\n            for counter in range(i, len(matrix[0])-1-i):\\n                matrix[i][i+counter], \\n                matrix[counter+i][len(matrix[0]) - 1-i], \\n                matrix[len(matrix[0]) - 1-i][len(matrix[0]) - 1 - counter-i], \\n                matrix[len(matrix[0]) - 1 - counter-i][i]=\\\\\\n                matrix[len(matrix[0]) - 1 - counter-i][i], \\n                matrix[i][i+counter], \\n                matrix[counter+i][len(matrix[0]) - 1-i], \\n                matrix[len(matrix[0]) - 1-i][len(matrix[0]) - 1 - counter-i],"
                    },
                    {
                        "username": "kartikay5849",
                        "content": "class Solution {\\npublic:\\n    void rotate(vector<vector<int>>& matrix) {\\n        int n=matrix.size();\\n            for(int i=0 ; i<n;i++)\\n            {\\n                for(int j=0 ; j<i ; j++)\\n                {\\n                    swap(matrix[i][j],matrix[j][i]);\\n                }\\n               \\n            }\\n             for(int i=0 ; i<n ; i++)\\n                {\\n                    reverse(matrix[i].begin(),matrix[i].end());\\n                }\\n    }\\n};"
                    },
                    {
                        "username": "georgezakharov",
                        "content": "Great!\\nBut lets read the rules together.\\n\\n\\uD83D\\uDCA1 Discussion Rules\\n1. Please don\\'t post any solutions in this discussion.\\n\\n2. The problem discussion is for asking questions about the problem or for sharing tips - anything except for solutions.\\n\\n3. If you\\'d like to share your solution for feedback and ideas, please head to the solutions tab and post it there."
                    },
                    {
                        "username": "dandu_akhil_reddy",
                        "content": "class Solution {\\npublic:\\n    void rotate(vector<vector<int>>& matrix) {\\n        int n=matrix.size();\\n        int tlr,tlc,blc,trr=0;\\n        int trc,blr,brr,brc=n-1;\\n        int temp1,temp2,temp3,temp4=0;\\n        while(tlr<blr&&tlc<trc){\\n            for(int i=0;i<n-1-tlr;i++){\\n                temp1=matrix[tlr][tlc+i];\\n                temp2=matrix[trr+i][trc];\\n                temp3=matrix[brr][brc-i];\\n                temp4=matrix[blr-i][blc];\\n                matrix[tlr][tlc+i]=temp4;\\n                matrix[trr+i][trc]=temp1;\\n                matrix[brr][brc-i]=temp2;\\n                matrix[blr-i][blc]=temp3;\\n\\n            }\\n            tlr++;\\n            tlc++;\\n            trr++;\\n            trc--;\\n            blr--;\\n            blc++;\\n            brr--;\\n            brc--;\\n        }\\n        for(int i=0;i<n;i++){\\n            for(int j=0;j<n;j++){\\n                cout<<matrix[i][j]<<\" \";\\n            }\\n        }\\n    }\\n}; getting output as input for this method can anyone explain , even getting correct output for dry run"
                    },
                    {
                        "username": "mochiball",
                        "content": "Yeah. Your code is super confusing"
                    },
                    {
                        "username": "mochiball",
                        "content": "Who will be able to solve this in an interview without having seen it before.. ? "
                    },
                    {
                        "username": "palakgupta1712",
                        "content": "simplest  approach please?\\n"
                    },
                    {
                        "username": "Harsh_Balwani",
                        "content": "Yep sure!!\\nApproach is in 2 steps-\\nFirst to transpose the matrix.\\nSecond to reverse the matrix row-wise.\\n\\nif you still want detailed explanation, you can see this, \\nhttps://leetcode.com/problems/rotate-image/solutions/3678211/easy-cpp-solution-with-crystal-clear-step-wise-explanation-using-handmade-images-with-hint/\\n"
                    },
                    {
                        "username": "amartyasen895",
                        "content": "   int n = mat.size();\\n        int m = mat[0].size();\\n\\n        for(int i = 0 ; i < n-1 ; i++)\\n        {\\n            for(int j = 1 ; j < m ; j++)\\n            {\\n                swap(mat[i][j] , mat[j][i]);\\n            }\\n        }\\n\\n        for(int i = 0 ; i < n ; i++)\\n        {\\n            reverse(mat[i].begin() , mat[i].end());\\n        }\\n    }\\nWhy this is not working can anyone explain."
                    },
                    {
                        "username": "yash_giradkar",
                        "content": "The question says donot return anything,\\nI am able to to print the expected output but what is wrong with the result\\n `class Solution(object):\\n    def rotate(self, matrix):\\n        \"\"\"\\n        :type matrix: List[List[int]]\\n        :rtype: None Do not return anything, modify matrix in-place instead.\\n        \"\"\"\\n        matrix=matrix[::-1]\\n        print(matrix)\\n         \\n        for i in range(len(matrix)):\\n            for j in range(i):\\n                 \\n                temp=matrix[i][j]\\n                matrix[i][j]=matrix[j][i]\\n                matrix[j][i]=temp\\n                 \\n        print(\"last print\",matrix) ` \\n\\ntestcase-[[1,2,3],[4,5,6],[7,8,9]]\\nmy print-(\\'last print\\', [[7, 4, 1], [8, 5, 2], [9, 6, 3]])\\nOutput-[[9,6,3],[8,5,2],[7,4,1]]\\nExpected-[[7,4,1],[8,5,2],[9,6,3]]"
                    },
                    {
                        "username": "ehtasham2901",
                        "content": "is this a correct approach , i am getting stuck inside the matrix after shrinking matrix.. can anyone look into it and find the way to correct it  \\n\\n\\n`your inline code...`\\n\\n`class Solution {\\npublic:\\n    void rotate(vector<vector<int>>& matrix) {\\n\\n    int n = matrix.size() ;\\n    int row = n-1 , col = n-1 ;\\n    int i = 0, j = 0, count = 0 , k, m = 0, l = 0 ;\\n    while(i < row && j < col)\\n    {\\n        while(j < col )\\n        {   \\n            m = j ;\\n            l = i ;\\n            count = 0 ;\\n            while(count < 3 )\\n            {\\n                swap(matrix[l][m], matrix[col-m][l]) ;\\n                k = l ;\\n                l = col - m ;\\n                m = k ;\\n                count++ ;\\n            }\\n            j++ ;\\n        }\\n        // for removing boundries \\n        i = i + 1 ;\\n        j = i ;\\n        row = row - 1 ;\\n        col = col - 1 ;\\n    }\\n        \\n    }\\n};\\n\\nyour inline code..."
                    },
                    {
                        "username": "karan371",
                        "content": "Can anyone tell me how to improve this solution:\\n int n=matrix.size();\\n        for(int i=0;i<n/2;i++){\\n            for(int j=i+1;j<=(n-2*i);j++){\\n                int temp=matrix[n-j-1][i];\\n                matrix[n-j-1][i]=matrix[n-i-1][n-j-1];\\n                matrix[n-i-1][n-j-1]=matrix[j][n-i-1];\\n                matrix[j][n-i-1]=matrix[i][j];\\n                matrix[i][j]=temp;\\n            }\\n        }"
                    }
                ]
            },
            {
                "id": 1988601,
                "content": [
                    {
                        "username": "Aaryan_0001",
                        "content": "APPROACH  | |   100% BEATS\\n\\n1. Find transpose of the matrix . Note to make this effiecient just swap the elements above the diagonal of the matrix to elements lower to the diagonal. keep in mind that diagonal elements remains untouched so set the loop carefully.\\n\\n2. Reverse the elements of the matrix, to do this efficiently just reverse the elements of each row only. i.e for row =0 reverse all elements inside row=0, for row =1 reverse all elements inside row=1, for row =2 reverse all elements inside row=2 and so on.......\\n\\nAND YOU ARE DONE. | | HIT A LIKE BUDDIES"
                    },
                    {
                        "username": "Pendelbus",
                        "content": "Why it give me an error?\\nclass Solution:\\n        for i in range(len(matrix[0])//2):\\n            for counter in range(i, len(matrix[0])-1-i):\\n                matrix[i][i+counter], \\n                matrix[counter+i][len(matrix[0]) - 1-i], \\n                matrix[len(matrix[0]) - 1-i][len(matrix[0]) - 1 - counter-i], \\n                matrix[len(matrix[0]) - 1 - counter-i][i]=\\\\\\n                matrix[len(matrix[0]) - 1 - counter-i][i], \\n                matrix[i][i+counter], \\n                matrix[counter+i][len(matrix[0]) - 1-i], \\n                matrix[len(matrix[0]) - 1-i][len(matrix[0]) - 1 - counter-i],"
                    },
                    {
                        "username": "kartikay5849",
                        "content": "class Solution {\\npublic:\\n    void rotate(vector<vector<int>>& matrix) {\\n        int n=matrix.size();\\n            for(int i=0 ; i<n;i++)\\n            {\\n                for(int j=0 ; j<i ; j++)\\n                {\\n                    swap(matrix[i][j],matrix[j][i]);\\n                }\\n               \\n            }\\n             for(int i=0 ; i<n ; i++)\\n                {\\n                    reverse(matrix[i].begin(),matrix[i].end());\\n                }\\n    }\\n};"
                    },
                    {
                        "username": "georgezakharov",
                        "content": "Great!\\nBut lets read the rules together.\\n\\n\\uD83D\\uDCA1 Discussion Rules\\n1. Please don\\'t post any solutions in this discussion.\\n\\n2. The problem discussion is for asking questions about the problem or for sharing tips - anything except for solutions.\\n\\n3. If you\\'d like to share your solution for feedback and ideas, please head to the solutions tab and post it there."
                    },
                    {
                        "username": "dandu_akhil_reddy",
                        "content": "class Solution {\\npublic:\\n    void rotate(vector<vector<int>>& matrix) {\\n        int n=matrix.size();\\n        int tlr,tlc,blc,trr=0;\\n        int trc,blr,brr,brc=n-1;\\n        int temp1,temp2,temp3,temp4=0;\\n        while(tlr<blr&&tlc<trc){\\n            for(int i=0;i<n-1-tlr;i++){\\n                temp1=matrix[tlr][tlc+i];\\n                temp2=matrix[trr+i][trc];\\n                temp3=matrix[brr][brc-i];\\n                temp4=matrix[blr-i][blc];\\n                matrix[tlr][tlc+i]=temp4;\\n                matrix[trr+i][trc]=temp1;\\n                matrix[brr][brc-i]=temp2;\\n                matrix[blr-i][blc]=temp3;\\n\\n            }\\n            tlr++;\\n            tlc++;\\n            trr++;\\n            trc--;\\n            blr--;\\n            blc++;\\n            brr--;\\n            brc--;\\n        }\\n        for(int i=0;i<n;i++){\\n            for(int j=0;j<n;j++){\\n                cout<<matrix[i][j]<<\" \";\\n            }\\n        }\\n    }\\n}; getting output as input for this method can anyone explain , even getting correct output for dry run"
                    },
                    {
                        "username": "mochiball",
                        "content": "Yeah. Your code is super confusing"
                    },
                    {
                        "username": "mochiball",
                        "content": "Who will be able to solve this in an interview without having seen it before.. ? "
                    },
                    {
                        "username": "palakgupta1712",
                        "content": "simplest  approach please?\\n"
                    },
                    {
                        "username": "Harsh_Balwani",
                        "content": "Yep sure!!\\nApproach is in 2 steps-\\nFirst to transpose the matrix.\\nSecond to reverse the matrix row-wise.\\n\\nif you still want detailed explanation, you can see this, \\nhttps://leetcode.com/problems/rotate-image/solutions/3678211/easy-cpp-solution-with-crystal-clear-step-wise-explanation-using-handmade-images-with-hint/\\n"
                    },
                    {
                        "username": "amartyasen895",
                        "content": "   int n = mat.size();\\n        int m = mat[0].size();\\n\\n        for(int i = 0 ; i < n-1 ; i++)\\n        {\\n            for(int j = 1 ; j < m ; j++)\\n            {\\n                swap(mat[i][j] , mat[j][i]);\\n            }\\n        }\\n\\n        for(int i = 0 ; i < n ; i++)\\n        {\\n            reverse(mat[i].begin() , mat[i].end());\\n        }\\n    }\\nWhy this is not working can anyone explain."
                    },
                    {
                        "username": "yash_giradkar",
                        "content": "The question says donot return anything,\\nI am able to to print the expected output but what is wrong with the result\\n `class Solution(object):\\n    def rotate(self, matrix):\\n        \"\"\"\\n        :type matrix: List[List[int]]\\n        :rtype: None Do not return anything, modify matrix in-place instead.\\n        \"\"\"\\n        matrix=matrix[::-1]\\n        print(matrix)\\n         \\n        for i in range(len(matrix)):\\n            for j in range(i):\\n                 \\n                temp=matrix[i][j]\\n                matrix[i][j]=matrix[j][i]\\n                matrix[j][i]=temp\\n                 \\n        print(\"last print\",matrix) ` \\n\\ntestcase-[[1,2,3],[4,5,6],[7,8,9]]\\nmy print-(\\'last print\\', [[7, 4, 1], [8, 5, 2], [9, 6, 3]])\\nOutput-[[9,6,3],[8,5,2],[7,4,1]]\\nExpected-[[7,4,1],[8,5,2],[9,6,3]]"
                    },
                    {
                        "username": "ehtasham2901",
                        "content": "is this a correct approach , i am getting stuck inside the matrix after shrinking matrix.. can anyone look into it and find the way to correct it  \\n\\n\\n`your inline code...`\\n\\n`class Solution {\\npublic:\\n    void rotate(vector<vector<int>>& matrix) {\\n\\n    int n = matrix.size() ;\\n    int row = n-1 , col = n-1 ;\\n    int i = 0, j = 0, count = 0 , k, m = 0, l = 0 ;\\n    while(i < row && j < col)\\n    {\\n        while(j < col )\\n        {   \\n            m = j ;\\n            l = i ;\\n            count = 0 ;\\n            while(count < 3 )\\n            {\\n                swap(matrix[l][m], matrix[col-m][l]) ;\\n                k = l ;\\n                l = col - m ;\\n                m = k ;\\n                count++ ;\\n            }\\n            j++ ;\\n        }\\n        // for removing boundries \\n        i = i + 1 ;\\n        j = i ;\\n        row = row - 1 ;\\n        col = col - 1 ;\\n    }\\n        \\n    }\\n};\\n\\nyour inline code..."
                    },
                    {
                        "username": "karan371",
                        "content": "Can anyone tell me how to improve this solution:\\n int n=matrix.size();\\n        for(int i=0;i<n/2;i++){\\n            for(int j=i+1;j<=(n-2*i);j++){\\n                int temp=matrix[n-j-1][i];\\n                matrix[n-j-1][i]=matrix[n-i-1][n-j-1];\\n                matrix[n-i-1][n-j-1]=matrix[j][n-i-1];\\n                matrix[j][n-i-1]=matrix[i][j];\\n                matrix[i][j]=temp;\\n            }\\n        }"
                    }
                ]
            },
            {
                "id": 1987609,
                "content": [
                    {
                        "username": "Aaryan_0001",
                        "content": "APPROACH  | |   100% BEATS\\n\\n1. Find transpose of the matrix . Note to make this effiecient just swap the elements above the diagonal of the matrix to elements lower to the diagonal. keep in mind that diagonal elements remains untouched so set the loop carefully.\\n\\n2. Reverse the elements of the matrix, to do this efficiently just reverse the elements of each row only. i.e for row =0 reverse all elements inside row=0, for row =1 reverse all elements inside row=1, for row =2 reverse all elements inside row=2 and so on.......\\n\\nAND YOU ARE DONE. | | HIT A LIKE BUDDIES"
                    },
                    {
                        "username": "Pendelbus",
                        "content": "Why it give me an error?\\nclass Solution:\\n        for i in range(len(matrix[0])//2):\\n            for counter in range(i, len(matrix[0])-1-i):\\n                matrix[i][i+counter], \\n                matrix[counter+i][len(matrix[0]) - 1-i], \\n                matrix[len(matrix[0]) - 1-i][len(matrix[0]) - 1 - counter-i], \\n                matrix[len(matrix[0]) - 1 - counter-i][i]=\\\\\\n                matrix[len(matrix[0]) - 1 - counter-i][i], \\n                matrix[i][i+counter], \\n                matrix[counter+i][len(matrix[0]) - 1-i], \\n                matrix[len(matrix[0]) - 1-i][len(matrix[0]) - 1 - counter-i],"
                    },
                    {
                        "username": "kartikay5849",
                        "content": "class Solution {\\npublic:\\n    void rotate(vector<vector<int>>& matrix) {\\n        int n=matrix.size();\\n            for(int i=0 ; i<n;i++)\\n            {\\n                for(int j=0 ; j<i ; j++)\\n                {\\n                    swap(matrix[i][j],matrix[j][i]);\\n                }\\n               \\n            }\\n             for(int i=0 ; i<n ; i++)\\n                {\\n                    reverse(matrix[i].begin(),matrix[i].end());\\n                }\\n    }\\n};"
                    },
                    {
                        "username": "georgezakharov",
                        "content": "Great!\\nBut lets read the rules together.\\n\\n\\uD83D\\uDCA1 Discussion Rules\\n1. Please don\\'t post any solutions in this discussion.\\n\\n2. The problem discussion is for asking questions about the problem or for sharing tips - anything except for solutions.\\n\\n3. If you\\'d like to share your solution for feedback and ideas, please head to the solutions tab and post it there."
                    },
                    {
                        "username": "dandu_akhil_reddy",
                        "content": "class Solution {\\npublic:\\n    void rotate(vector<vector<int>>& matrix) {\\n        int n=matrix.size();\\n        int tlr,tlc,blc,trr=0;\\n        int trc,blr,brr,brc=n-1;\\n        int temp1,temp2,temp3,temp4=0;\\n        while(tlr<blr&&tlc<trc){\\n            for(int i=0;i<n-1-tlr;i++){\\n                temp1=matrix[tlr][tlc+i];\\n                temp2=matrix[trr+i][trc];\\n                temp3=matrix[brr][brc-i];\\n                temp4=matrix[blr-i][blc];\\n                matrix[tlr][tlc+i]=temp4;\\n                matrix[trr+i][trc]=temp1;\\n                matrix[brr][brc-i]=temp2;\\n                matrix[blr-i][blc]=temp3;\\n\\n            }\\n            tlr++;\\n            tlc++;\\n            trr++;\\n            trc--;\\n            blr--;\\n            blc++;\\n            brr--;\\n            brc--;\\n        }\\n        for(int i=0;i<n;i++){\\n            for(int j=0;j<n;j++){\\n                cout<<matrix[i][j]<<\" \";\\n            }\\n        }\\n    }\\n}; getting output as input for this method can anyone explain , even getting correct output for dry run"
                    },
                    {
                        "username": "mochiball",
                        "content": "Yeah. Your code is super confusing"
                    },
                    {
                        "username": "mochiball",
                        "content": "Who will be able to solve this in an interview without having seen it before.. ? "
                    },
                    {
                        "username": "palakgupta1712",
                        "content": "simplest  approach please?\\n"
                    },
                    {
                        "username": "Harsh_Balwani",
                        "content": "Yep sure!!\\nApproach is in 2 steps-\\nFirst to transpose the matrix.\\nSecond to reverse the matrix row-wise.\\n\\nif you still want detailed explanation, you can see this, \\nhttps://leetcode.com/problems/rotate-image/solutions/3678211/easy-cpp-solution-with-crystal-clear-step-wise-explanation-using-handmade-images-with-hint/\\n"
                    },
                    {
                        "username": "amartyasen895",
                        "content": "   int n = mat.size();\\n        int m = mat[0].size();\\n\\n        for(int i = 0 ; i < n-1 ; i++)\\n        {\\n            for(int j = 1 ; j < m ; j++)\\n            {\\n                swap(mat[i][j] , mat[j][i]);\\n            }\\n        }\\n\\n        for(int i = 0 ; i < n ; i++)\\n        {\\n            reverse(mat[i].begin() , mat[i].end());\\n        }\\n    }\\nWhy this is not working can anyone explain."
                    },
                    {
                        "username": "yash_giradkar",
                        "content": "The question says donot return anything,\\nI am able to to print the expected output but what is wrong with the result\\n `class Solution(object):\\n    def rotate(self, matrix):\\n        \"\"\"\\n        :type matrix: List[List[int]]\\n        :rtype: None Do not return anything, modify matrix in-place instead.\\n        \"\"\"\\n        matrix=matrix[::-1]\\n        print(matrix)\\n         \\n        for i in range(len(matrix)):\\n            for j in range(i):\\n                 \\n                temp=matrix[i][j]\\n                matrix[i][j]=matrix[j][i]\\n                matrix[j][i]=temp\\n                 \\n        print(\"last print\",matrix) ` \\n\\ntestcase-[[1,2,3],[4,5,6],[7,8,9]]\\nmy print-(\\'last print\\', [[7, 4, 1], [8, 5, 2], [9, 6, 3]])\\nOutput-[[9,6,3],[8,5,2],[7,4,1]]\\nExpected-[[7,4,1],[8,5,2],[9,6,3]]"
                    },
                    {
                        "username": "ehtasham2901",
                        "content": "is this a correct approach , i am getting stuck inside the matrix after shrinking matrix.. can anyone look into it and find the way to correct it  \\n\\n\\n`your inline code...`\\n\\n`class Solution {\\npublic:\\n    void rotate(vector<vector<int>>& matrix) {\\n\\n    int n = matrix.size() ;\\n    int row = n-1 , col = n-1 ;\\n    int i = 0, j = 0, count = 0 , k, m = 0, l = 0 ;\\n    while(i < row && j < col)\\n    {\\n        while(j < col )\\n        {   \\n            m = j ;\\n            l = i ;\\n            count = 0 ;\\n            while(count < 3 )\\n            {\\n                swap(matrix[l][m], matrix[col-m][l]) ;\\n                k = l ;\\n                l = col - m ;\\n                m = k ;\\n                count++ ;\\n            }\\n            j++ ;\\n        }\\n        // for removing boundries \\n        i = i + 1 ;\\n        j = i ;\\n        row = row - 1 ;\\n        col = col - 1 ;\\n    }\\n        \\n    }\\n};\\n\\nyour inline code..."
                    },
                    {
                        "username": "karan371",
                        "content": "Can anyone tell me how to improve this solution:\\n int n=matrix.size();\\n        for(int i=0;i<n/2;i++){\\n            for(int j=i+1;j<=(n-2*i);j++){\\n                int temp=matrix[n-j-1][i];\\n                matrix[n-j-1][i]=matrix[n-i-1][n-j-1];\\n                matrix[n-i-1][n-j-1]=matrix[j][n-i-1];\\n                matrix[j][n-i-1]=matrix[i][j];\\n                matrix[i][j]=temp;\\n            }\\n        }"
                    }
                ]
            },
            {
                "id": 1986431,
                "content": [
                    {
                        "username": "Aaryan_0001",
                        "content": "APPROACH  | |   100% BEATS\\n\\n1. Find transpose of the matrix . Note to make this effiecient just swap the elements above the diagonal of the matrix to elements lower to the diagonal. keep in mind that diagonal elements remains untouched so set the loop carefully.\\n\\n2. Reverse the elements of the matrix, to do this efficiently just reverse the elements of each row only. i.e for row =0 reverse all elements inside row=0, for row =1 reverse all elements inside row=1, for row =2 reverse all elements inside row=2 and so on.......\\n\\nAND YOU ARE DONE. | | HIT A LIKE BUDDIES"
                    },
                    {
                        "username": "Pendelbus",
                        "content": "Why it give me an error?\\nclass Solution:\\n        for i in range(len(matrix[0])//2):\\n            for counter in range(i, len(matrix[0])-1-i):\\n                matrix[i][i+counter], \\n                matrix[counter+i][len(matrix[0]) - 1-i], \\n                matrix[len(matrix[0]) - 1-i][len(matrix[0]) - 1 - counter-i], \\n                matrix[len(matrix[0]) - 1 - counter-i][i]=\\\\\\n                matrix[len(matrix[0]) - 1 - counter-i][i], \\n                matrix[i][i+counter], \\n                matrix[counter+i][len(matrix[0]) - 1-i], \\n                matrix[len(matrix[0]) - 1-i][len(matrix[0]) - 1 - counter-i],"
                    },
                    {
                        "username": "kartikay5849",
                        "content": "class Solution {\\npublic:\\n    void rotate(vector<vector<int>>& matrix) {\\n        int n=matrix.size();\\n            for(int i=0 ; i<n;i++)\\n            {\\n                for(int j=0 ; j<i ; j++)\\n                {\\n                    swap(matrix[i][j],matrix[j][i]);\\n                }\\n               \\n            }\\n             for(int i=0 ; i<n ; i++)\\n                {\\n                    reverse(matrix[i].begin(),matrix[i].end());\\n                }\\n    }\\n};"
                    },
                    {
                        "username": "georgezakharov",
                        "content": "Great!\\nBut lets read the rules together.\\n\\n\\uD83D\\uDCA1 Discussion Rules\\n1. Please don\\'t post any solutions in this discussion.\\n\\n2. The problem discussion is for asking questions about the problem or for sharing tips - anything except for solutions.\\n\\n3. If you\\'d like to share your solution for feedback and ideas, please head to the solutions tab and post it there."
                    },
                    {
                        "username": "dandu_akhil_reddy",
                        "content": "class Solution {\\npublic:\\n    void rotate(vector<vector<int>>& matrix) {\\n        int n=matrix.size();\\n        int tlr,tlc,blc,trr=0;\\n        int trc,blr,brr,brc=n-1;\\n        int temp1,temp2,temp3,temp4=0;\\n        while(tlr<blr&&tlc<trc){\\n            for(int i=0;i<n-1-tlr;i++){\\n                temp1=matrix[tlr][tlc+i];\\n                temp2=matrix[trr+i][trc];\\n                temp3=matrix[brr][brc-i];\\n                temp4=matrix[blr-i][blc];\\n                matrix[tlr][tlc+i]=temp4;\\n                matrix[trr+i][trc]=temp1;\\n                matrix[brr][brc-i]=temp2;\\n                matrix[blr-i][blc]=temp3;\\n\\n            }\\n            tlr++;\\n            tlc++;\\n            trr++;\\n            trc--;\\n            blr--;\\n            blc++;\\n            brr--;\\n            brc--;\\n        }\\n        for(int i=0;i<n;i++){\\n            for(int j=0;j<n;j++){\\n                cout<<matrix[i][j]<<\" \";\\n            }\\n        }\\n    }\\n}; getting output as input for this method can anyone explain , even getting correct output for dry run"
                    },
                    {
                        "username": "mochiball",
                        "content": "Yeah. Your code is super confusing"
                    },
                    {
                        "username": "mochiball",
                        "content": "Who will be able to solve this in an interview without having seen it before.. ? "
                    },
                    {
                        "username": "palakgupta1712",
                        "content": "simplest  approach please?\\n"
                    },
                    {
                        "username": "Harsh_Balwani",
                        "content": "Yep sure!!\\nApproach is in 2 steps-\\nFirst to transpose the matrix.\\nSecond to reverse the matrix row-wise.\\n\\nif you still want detailed explanation, you can see this, \\nhttps://leetcode.com/problems/rotate-image/solutions/3678211/easy-cpp-solution-with-crystal-clear-step-wise-explanation-using-handmade-images-with-hint/\\n"
                    },
                    {
                        "username": "amartyasen895",
                        "content": "   int n = mat.size();\\n        int m = mat[0].size();\\n\\n        for(int i = 0 ; i < n-1 ; i++)\\n        {\\n            for(int j = 1 ; j < m ; j++)\\n            {\\n                swap(mat[i][j] , mat[j][i]);\\n            }\\n        }\\n\\n        for(int i = 0 ; i < n ; i++)\\n        {\\n            reverse(mat[i].begin() , mat[i].end());\\n        }\\n    }\\nWhy this is not working can anyone explain."
                    },
                    {
                        "username": "yash_giradkar",
                        "content": "The question says donot return anything,\\nI am able to to print the expected output but what is wrong with the result\\n `class Solution(object):\\n    def rotate(self, matrix):\\n        \"\"\"\\n        :type matrix: List[List[int]]\\n        :rtype: None Do not return anything, modify matrix in-place instead.\\n        \"\"\"\\n        matrix=matrix[::-1]\\n        print(matrix)\\n         \\n        for i in range(len(matrix)):\\n            for j in range(i):\\n                 \\n                temp=matrix[i][j]\\n                matrix[i][j]=matrix[j][i]\\n                matrix[j][i]=temp\\n                 \\n        print(\"last print\",matrix) ` \\n\\ntestcase-[[1,2,3],[4,5,6],[7,8,9]]\\nmy print-(\\'last print\\', [[7, 4, 1], [8, 5, 2], [9, 6, 3]])\\nOutput-[[9,6,3],[8,5,2],[7,4,1]]\\nExpected-[[7,4,1],[8,5,2],[9,6,3]]"
                    },
                    {
                        "username": "ehtasham2901",
                        "content": "is this a correct approach , i am getting stuck inside the matrix after shrinking matrix.. can anyone look into it and find the way to correct it  \\n\\n\\n`your inline code...`\\n\\n`class Solution {\\npublic:\\n    void rotate(vector<vector<int>>& matrix) {\\n\\n    int n = matrix.size() ;\\n    int row = n-1 , col = n-1 ;\\n    int i = 0, j = 0, count = 0 , k, m = 0, l = 0 ;\\n    while(i < row && j < col)\\n    {\\n        while(j < col )\\n        {   \\n            m = j ;\\n            l = i ;\\n            count = 0 ;\\n            while(count < 3 )\\n            {\\n                swap(matrix[l][m], matrix[col-m][l]) ;\\n                k = l ;\\n                l = col - m ;\\n                m = k ;\\n                count++ ;\\n            }\\n            j++ ;\\n        }\\n        // for removing boundries \\n        i = i + 1 ;\\n        j = i ;\\n        row = row - 1 ;\\n        col = col - 1 ;\\n    }\\n        \\n    }\\n};\\n\\nyour inline code..."
                    },
                    {
                        "username": "karan371",
                        "content": "Can anyone tell me how to improve this solution:\\n int n=matrix.size();\\n        for(int i=0;i<n/2;i++){\\n            for(int j=i+1;j<=(n-2*i);j++){\\n                int temp=matrix[n-j-1][i];\\n                matrix[n-j-1][i]=matrix[n-i-1][n-j-1];\\n                matrix[n-i-1][n-j-1]=matrix[j][n-i-1];\\n                matrix[j][n-i-1]=matrix[i][j];\\n                matrix[i][j]=temp;\\n            }\\n        }"
                    }
                ]
            },
            {
                "id": 1986230,
                "content": [
                    {
                        "username": "Aaryan_0001",
                        "content": "APPROACH  | |   100% BEATS\\n\\n1. Find transpose of the matrix . Note to make this effiecient just swap the elements above the diagonal of the matrix to elements lower to the diagonal. keep in mind that diagonal elements remains untouched so set the loop carefully.\\n\\n2. Reverse the elements of the matrix, to do this efficiently just reverse the elements of each row only. i.e for row =0 reverse all elements inside row=0, for row =1 reverse all elements inside row=1, for row =2 reverse all elements inside row=2 and so on.......\\n\\nAND YOU ARE DONE. | | HIT A LIKE BUDDIES"
                    },
                    {
                        "username": "Pendelbus",
                        "content": "Why it give me an error?\\nclass Solution:\\n        for i in range(len(matrix[0])//2):\\n            for counter in range(i, len(matrix[0])-1-i):\\n                matrix[i][i+counter], \\n                matrix[counter+i][len(matrix[0]) - 1-i], \\n                matrix[len(matrix[0]) - 1-i][len(matrix[0]) - 1 - counter-i], \\n                matrix[len(matrix[0]) - 1 - counter-i][i]=\\\\\\n                matrix[len(matrix[0]) - 1 - counter-i][i], \\n                matrix[i][i+counter], \\n                matrix[counter+i][len(matrix[0]) - 1-i], \\n                matrix[len(matrix[0]) - 1-i][len(matrix[0]) - 1 - counter-i],"
                    },
                    {
                        "username": "kartikay5849",
                        "content": "class Solution {\\npublic:\\n    void rotate(vector<vector<int>>& matrix) {\\n        int n=matrix.size();\\n            for(int i=0 ; i<n;i++)\\n            {\\n                for(int j=0 ; j<i ; j++)\\n                {\\n                    swap(matrix[i][j],matrix[j][i]);\\n                }\\n               \\n            }\\n             for(int i=0 ; i<n ; i++)\\n                {\\n                    reverse(matrix[i].begin(),matrix[i].end());\\n                }\\n    }\\n};"
                    },
                    {
                        "username": "georgezakharov",
                        "content": "Great!\\nBut lets read the rules together.\\n\\n\\uD83D\\uDCA1 Discussion Rules\\n1. Please don\\'t post any solutions in this discussion.\\n\\n2. The problem discussion is for asking questions about the problem or for sharing tips - anything except for solutions.\\n\\n3. If you\\'d like to share your solution for feedback and ideas, please head to the solutions tab and post it there."
                    },
                    {
                        "username": "dandu_akhil_reddy",
                        "content": "class Solution {\\npublic:\\n    void rotate(vector<vector<int>>& matrix) {\\n        int n=matrix.size();\\n        int tlr,tlc,blc,trr=0;\\n        int trc,blr,brr,brc=n-1;\\n        int temp1,temp2,temp3,temp4=0;\\n        while(tlr<blr&&tlc<trc){\\n            for(int i=0;i<n-1-tlr;i++){\\n                temp1=matrix[tlr][tlc+i];\\n                temp2=matrix[trr+i][trc];\\n                temp3=matrix[brr][brc-i];\\n                temp4=matrix[blr-i][blc];\\n                matrix[tlr][tlc+i]=temp4;\\n                matrix[trr+i][trc]=temp1;\\n                matrix[brr][brc-i]=temp2;\\n                matrix[blr-i][blc]=temp3;\\n\\n            }\\n            tlr++;\\n            tlc++;\\n            trr++;\\n            trc--;\\n            blr--;\\n            blc++;\\n            brr--;\\n            brc--;\\n        }\\n        for(int i=0;i<n;i++){\\n            for(int j=0;j<n;j++){\\n                cout<<matrix[i][j]<<\" \";\\n            }\\n        }\\n    }\\n}; getting output as input for this method can anyone explain , even getting correct output for dry run"
                    },
                    {
                        "username": "mochiball",
                        "content": "Yeah. Your code is super confusing"
                    },
                    {
                        "username": "mochiball",
                        "content": "Who will be able to solve this in an interview without having seen it before.. ? "
                    },
                    {
                        "username": "palakgupta1712",
                        "content": "simplest  approach please?\\n"
                    },
                    {
                        "username": "Harsh_Balwani",
                        "content": "Yep sure!!\\nApproach is in 2 steps-\\nFirst to transpose the matrix.\\nSecond to reverse the matrix row-wise.\\n\\nif you still want detailed explanation, you can see this, \\nhttps://leetcode.com/problems/rotate-image/solutions/3678211/easy-cpp-solution-with-crystal-clear-step-wise-explanation-using-handmade-images-with-hint/\\n"
                    },
                    {
                        "username": "amartyasen895",
                        "content": "   int n = mat.size();\\n        int m = mat[0].size();\\n\\n        for(int i = 0 ; i < n-1 ; i++)\\n        {\\n            for(int j = 1 ; j < m ; j++)\\n            {\\n                swap(mat[i][j] , mat[j][i]);\\n            }\\n        }\\n\\n        for(int i = 0 ; i < n ; i++)\\n        {\\n            reverse(mat[i].begin() , mat[i].end());\\n        }\\n    }\\nWhy this is not working can anyone explain."
                    },
                    {
                        "username": "yash_giradkar",
                        "content": "The question says donot return anything,\\nI am able to to print the expected output but what is wrong with the result\\n `class Solution(object):\\n    def rotate(self, matrix):\\n        \"\"\"\\n        :type matrix: List[List[int]]\\n        :rtype: None Do not return anything, modify matrix in-place instead.\\n        \"\"\"\\n        matrix=matrix[::-1]\\n        print(matrix)\\n         \\n        for i in range(len(matrix)):\\n            for j in range(i):\\n                 \\n                temp=matrix[i][j]\\n                matrix[i][j]=matrix[j][i]\\n                matrix[j][i]=temp\\n                 \\n        print(\"last print\",matrix) ` \\n\\ntestcase-[[1,2,3],[4,5,6],[7,8,9]]\\nmy print-(\\'last print\\', [[7, 4, 1], [8, 5, 2], [9, 6, 3]])\\nOutput-[[9,6,3],[8,5,2],[7,4,1]]\\nExpected-[[7,4,1],[8,5,2],[9,6,3]]"
                    },
                    {
                        "username": "ehtasham2901",
                        "content": "is this a correct approach , i am getting stuck inside the matrix after shrinking matrix.. can anyone look into it and find the way to correct it  \\n\\n\\n`your inline code...`\\n\\n`class Solution {\\npublic:\\n    void rotate(vector<vector<int>>& matrix) {\\n\\n    int n = matrix.size() ;\\n    int row = n-1 , col = n-1 ;\\n    int i = 0, j = 0, count = 0 , k, m = 0, l = 0 ;\\n    while(i < row && j < col)\\n    {\\n        while(j < col )\\n        {   \\n            m = j ;\\n            l = i ;\\n            count = 0 ;\\n            while(count < 3 )\\n            {\\n                swap(matrix[l][m], matrix[col-m][l]) ;\\n                k = l ;\\n                l = col - m ;\\n                m = k ;\\n                count++ ;\\n            }\\n            j++ ;\\n        }\\n        // for removing boundries \\n        i = i + 1 ;\\n        j = i ;\\n        row = row - 1 ;\\n        col = col - 1 ;\\n    }\\n        \\n    }\\n};\\n\\nyour inline code..."
                    },
                    {
                        "username": "karan371",
                        "content": "Can anyone tell me how to improve this solution:\\n int n=matrix.size();\\n        for(int i=0;i<n/2;i++){\\n            for(int j=i+1;j<=(n-2*i);j++){\\n                int temp=matrix[n-j-1][i];\\n                matrix[n-j-1][i]=matrix[n-i-1][n-j-1];\\n                matrix[n-i-1][n-j-1]=matrix[j][n-i-1];\\n                matrix[j][n-i-1]=matrix[i][j];\\n                matrix[i][j]=temp;\\n            }\\n        }"
                    }
                ]
            },
            {
                "id": 1961027,
                "content": [
                    {
                        "username": "Aaryan_0001",
                        "content": "APPROACH  | |   100% BEATS\\n\\n1. Find transpose of the matrix . Note to make this effiecient just swap the elements above the diagonal of the matrix to elements lower to the diagonal. keep in mind that diagonal elements remains untouched so set the loop carefully.\\n\\n2. Reverse the elements of the matrix, to do this efficiently just reverse the elements of each row only. i.e for row =0 reverse all elements inside row=0, for row =1 reverse all elements inside row=1, for row =2 reverse all elements inside row=2 and so on.......\\n\\nAND YOU ARE DONE. | | HIT A LIKE BUDDIES"
                    },
                    {
                        "username": "Pendelbus",
                        "content": "Why it give me an error?\\nclass Solution:\\n        for i in range(len(matrix[0])//2):\\n            for counter in range(i, len(matrix[0])-1-i):\\n                matrix[i][i+counter], \\n                matrix[counter+i][len(matrix[0]) - 1-i], \\n                matrix[len(matrix[0]) - 1-i][len(matrix[0]) - 1 - counter-i], \\n                matrix[len(matrix[0]) - 1 - counter-i][i]=\\\\\\n                matrix[len(matrix[0]) - 1 - counter-i][i], \\n                matrix[i][i+counter], \\n                matrix[counter+i][len(matrix[0]) - 1-i], \\n                matrix[len(matrix[0]) - 1-i][len(matrix[0]) - 1 - counter-i],"
                    },
                    {
                        "username": "kartikay5849",
                        "content": "class Solution {\\npublic:\\n    void rotate(vector<vector<int>>& matrix) {\\n        int n=matrix.size();\\n            for(int i=0 ; i<n;i++)\\n            {\\n                for(int j=0 ; j<i ; j++)\\n                {\\n                    swap(matrix[i][j],matrix[j][i]);\\n                }\\n               \\n            }\\n             for(int i=0 ; i<n ; i++)\\n                {\\n                    reverse(matrix[i].begin(),matrix[i].end());\\n                }\\n    }\\n};"
                    },
                    {
                        "username": "georgezakharov",
                        "content": "Great!\\nBut lets read the rules together.\\n\\n\\uD83D\\uDCA1 Discussion Rules\\n1. Please don\\'t post any solutions in this discussion.\\n\\n2. The problem discussion is for asking questions about the problem or for sharing tips - anything except for solutions.\\n\\n3. If you\\'d like to share your solution for feedback and ideas, please head to the solutions tab and post it there."
                    },
                    {
                        "username": "dandu_akhil_reddy",
                        "content": "class Solution {\\npublic:\\n    void rotate(vector<vector<int>>& matrix) {\\n        int n=matrix.size();\\n        int tlr,tlc,blc,trr=0;\\n        int trc,blr,brr,brc=n-1;\\n        int temp1,temp2,temp3,temp4=0;\\n        while(tlr<blr&&tlc<trc){\\n            for(int i=0;i<n-1-tlr;i++){\\n                temp1=matrix[tlr][tlc+i];\\n                temp2=matrix[trr+i][trc];\\n                temp3=matrix[brr][brc-i];\\n                temp4=matrix[blr-i][blc];\\n                matrix[tlr][tlc+i]=temp4;\\n                matrix[trr+i][trc]=temp1;\\n                matrix[brr][brc-i]=temp2;\\n                matrix[blr-i][blc]=temp3;\\n\\n            }\\n            tlr++;\\n            tlc++;\\n            trr++;\\n            trc--;\\n            blr--;\\n            blc++;\\n            brr--;\\n            brc--;\\n        }\\n        for(int i=0;i<n;i++){\\n            for(int j=0;j<n;j++){\\n                cout<<matrix[i][j]<<\" \";\\n            }\\n        }\\n    }\\n}; getting output as input for this method can anyone explain , even getting correct output for dry run"
                    },
                    {
                        "username": "mochiball",
                        "content": "Yeah. Your code is super confusing"
                    },
                    {
                        "username": "mochiball",
                        "content": "Who will be able to solve this in an interview without having seen it before.. ? "
                    },
                    {
                        "username": "palakgupta1712",
                        "content": "simplest  approach please?\\n"
                    },
                    {
                        "username": "Harsh_Balwani",
                        "content": "Yep sure!!\\nApproach is in 2 steps-\\nFirst to transpose the matrix.\\nSecond to reverse the matrix row-wise.\\n\\nif you still want detailed explanation, you can see this, \\nhttps://leetcode.com/problems/rotate-image/solutions/3678211/easy-cpp-solution-with-crystal-clear-step-wise-explanation-using-handmade-images-with-hint/\\n"
                    },
                    {
                        "username": "amartyasen895",
                        "content": "   int n = mat.size();\\n        int m = mat[0].size();\\n\\n        for(int i = 0 ; i < n-1 ; i++)\\n        {\\n            for(int j = 1 ; j < m ; j++)\\n            {\\n                swap(mat[i][j] , mat[j][i]);\\n            }\\n        }\\n\\n        for(int i = 0 ; i < n ; i++)\\n        {\\n            reverse(mat[i].begin() , mat[i].end());\\n        }\\n    }\\nWhy this is not working can anyone explain."
                    },
                    {
                        "username": "yash_giradkar",
                        "content": "The question says donot return anything,\\nI am able to to print the expected output but what is wrong with the result\\n `class Solution(object):\\n    def rotate(self, matrix):\\n        \"\"\"\\n        :type matrix: List[List[int]]\\n        :rtype: None Do not return anything, modify matrix in-place instead.\\n        \"\"\"\\n        matrix=matrix[::-1]\\n        print(matrix)\\n         \\n        for i in range(len(matrix)):\\n            for j in range(i):\\n                 \\n                temp=matrix[i][j]\\n                matrix[i][j]=matrix[j][i]\\n                matrix[j][i]=temp\\n                 \\n        print(\"last print\",matrix) ` \\n\\ntestcase-[[1,2,3],[4,5,6],[7,8,9]]\\nmy print-(\\'last print\\', [[7, 4, 1], [8, 5, 2], [9, 6, 3]])\\nOutput-[[9,6,3],[8,5,2],[7,4,1]]\\nExpected-[[7,4,1],[8,5,2],[9,6,3]]"
                    },
                    {
                        "username": "ehtasham2901",
                        "content": "is this a correct approach , i am getting stuck inside the matrix after shrinking matrix.. can anyone look into it and find the way to correct it  \\n\\n\\n`your inline code...`\\n\\n`class Solution {\\npublic:\\n    void rotate(vector<vector<int>>& matrix) {\\n\\n    int n = matrix.size() ;\\n    int row = n-1 , col = n-1 ;\\n    int i = 0, j = 0, count = 0 , k, m = 0, l = 0 ;\\n    while(i < row && j < col)\\n    {\\n        while(j < col )\\n        {   \\n            m = j ;\\n            l = i ;\\n            count = 0 ;\\n            while(count < 3 )\\n            {\\n                swap(matrix[l][m], matrix[col-m][l]) ;\\n                k = l ;\\n                l = col - m ;\\n                m = k ;\\n                count++ ;\\n            }\\n            j++ ;\\n        }\\n        // for removing boundries \\n        i = i + 1 ;\\n        j = i ;\\n        row = row - 1 ;\\n        col = col - 1 ;\\n    }\\n        \\n    }\\n};\\n\\nyour inline code..."
                    },
                    {
                        "username": "karan371",
                        "content": "Can anyone tell me how to improve this solution:\\n int n=matrix.size();\\n        for(int i=0;i<n/2;i++){\\n            for(int j=i+1;j<=(n-2*i);j++){\\n                int temp=matrix[n-j-1][i];\\n                matrix[n-j-1][i]=matrix[n-i-1][n-j-1];\\n                matrix[n-i-1][n-j-1]=matrix[j][n-i-1];\\n                matrix[j][n-i-1]=matrix[i][j];\\n                matrix[i][j]=temp;\\n            }\\n        }"
                    }
                ]
            },
            {
                "id": 1940169,
                "content": [
                    {
                        "username": "Aaryan_0001",
                        "content": "APPROACH  | |   100% BEATS\\n\\n1. Find transpose of the matrix . Note to make this effiecient just swap the elements above the diagonal of the matrix to elements lower to the diagonal. keep in mind that diagonal elements remains untouched so set the loop carefully.\\n\\n2. Reverse the elements of the matrix, to do this efficiently just reverse the elements of each row only. i.e for row =0 reverse all elements inside row=0, for row =1 reverse all elements inside row=1, for row =2 reverse all elements inside row=2 and so on.......\\n\\nAND YOU ARE DONE. | | HIT A LIKE BUDDIES"
                    },
                    {
                        "username": "Pendelbus",
                        "content": "Why it give me an error?\\nclass Solution:\\n        for i in range(len(matrix[0])//2):\\n            for counter in range(i, len(matrix[0])-1-i):\\n                matrix[i][i+counter], \\n                matrix[counter+i][len(matrix[0]) - 1-i], \\n                matrix[len(matrix[0]) - 1-i][len(matrix[0]) - 1 - counter-i], \\n                matrix[len(matrix[0]) - 1 - counter-i][i]=\\\\\\n                matrix[len(matrix[0]) - 1 - counter-i][i], \\n                matrix[i][i+counter], \\n                matrix[counter+i][len(matrix[0]) - 1-i], \\n                matrix[len(matrix[0]) - 1-i][len(matrix[0]) - 1 - counter-i],"
                    },
                    {
                        "username": "kartikay5849",
                        "content": "class Solution {\\npublic:\\n    void rotate(vector<vector<int>>& matrix) {\\n        int n=matrix.size();\\n            for(int i=0 ; i<n;i++)\\n            {\\n                for(int j=0 ; j<i ; j++)\\n                {\\n                    swap(matrix[i][j],matrix[j][i]);\\n                }\\n               \\n            }\\n             for(int i=0 ; i<n ; i++)\\n                {\\n                    reverse(matrix[i].begin(),matrix[i].end());\\n                }\\n    }\\n};"
                    },
                    {
                        "username": "georgezakharov",
                        "content": "Great!\\nBut lets read the rules together.\\n\\n\\uD83D\\uDCA1 Discussion Rules\\n1. Please don\\'t post any solutions in this discussion.\\n\\n2. The problem discussion is for asking questions about the problem or for sharing tips - anything except for solutions.\\n\\n3. If you\\'d like to share your solution for feedback and ideas, please head to the solutions tab and post it there."
                    },
                    {
                        "username": "dandu_akhil_reddy",
                        "content": "class Solution {\\npublic:\\n    void rotate(vector<vector<int>>& matrix) {\\n        int n=matrix.size();\\n        int tlr,tlc,blc,trr=0;\\n        int trc,blr,brr,brc=n-1;\\n        int temp1,temp2,temp3,temp4=0;\\n        while(tlr<blr&&tlc<trc){\\n            for(int i=0;i<n-1-tlr;i++){\\n                temp1=matrix[tlr][tlc+i];\\n                temp2=matrix[trr+i][trc];\\n                temp3=matrix[brr][brc-i];\\n                temp4=matrix[blr-i][blc];\\n                matrix[tlr][tlc+i]=temp4;\\n                matrix[trr+i][trc]=temp1;\\n                matrix[brr][brc-i]=temp2;\\n                matrix[blr-i][blc]=temp3;\\n\\n            }\\n            tlr++;\\n            tlc++;\\n            trr++;\\n            trc--;\\n            blr--;\\n            blc++;\\n            brr--;\\n            brc--;\\n        }\\n        for(int i=0;i<n;i++){\\n            for(int j=0;j<n;j++){\\n                cout<<matrix[i][j]<<\" \";\\n            }\\n        }\\n    }\\n}; getting output as input for this method can anyone explain , even getting correct output for dry run"
                    },
                    {
                        "username": "mochiball",
                        "content": "Yeah. Your code is super confusing"
                    },
                    {
                        "username": "mochiball",
                        "content": "Who will be able to solve this in an interview without having seen it before.. ? "
                    },
                    {
                        "username": "palakgupta1712",
                        "content": "simplest  approach please?\\n"
                    },
                    {
                        "username": "Harsh_Balwani",
                        "content": "Yep sure!!\\nApproach is in 2 steps-\\nFirst to transpose the matrix.\\nSecond to reverse the matrix row-wise.\\n\\nif you still want detailed explanation, you can see this, \\nhttps://leetcode.com/problems/rotate-image/solutions/3678211/easy-cpp-solution-with-crystal-clear-step-wise-explanation-using-handmade-images-with-hint/\\n"
                    },
                    {
                        "username": "amartyasen895",
                        "content": "   int n = mat.size();\\n        int m = mat[0].size();\\n\\n        for(int i = 0 ; i < n-1 ; i++)\\n        {\\n            for(int j = 1 ; j < m ; j++)\\n            {\\n                swap(mat[i][j] , mat[j][i]);\\n            }\\n        }\\n\\n        for(int i = 0 ; i < n ; i++)\\n        {\\n            reverse(mat[i].begin() , mat[i].end());\\n        }\\n    }\\nWhy this is not working can anyone explain."
                    },
                    {
                        "username": "yash_giradkar",
                        "content": "The question says donot return anything,\\nI am able to to print the expected output but what is wrong with the result\\n `class Solution(object):\\n    def rotate(self, matrix):\\n        \"\"\"\\n        :type matrix: List[List[int]]\\n        :rtype: None Do not return anything, modify matrix in-place instead.\\n        \"\"\"\\n        matrix=matrix[::-1]\\n        print(matrix)\\n         \\n        for i in range(len(matrix)):\\n            for j in range(i):\\n                 \\n                temp=matrix[i][j]\\n                matrix[i][j]=matrix[j][i]\\n                matrix[j][i]=temp\\n                 \\n        print(\"last print\",matrix) ` \\n\\ntestcase-[[1,2,3],[4,5,6],[7,8,9]]\\nmy print-(\\'last print\\', [[7, 4, 1], [8, 5, 2], [9, 6, 3]])\\nOutput-[[9,6,3],[8,5,2],[7,4,1]]\\nExpected-[[7,4,1],[8,5,2],[9,6,3]]"
                    },
                    {
                        "username": "ehtasham2901",
                        "content": "is this a correct approach , i am getting stuck inside the matrix after shrinking matrix.. can anyone look into it and find the way to correct it  \\n\\n\\n`your inline code...`\\n\\n`class Solution {\\npublic:\\n    void rotate(vector<vector<int>>& matrix) {\\n\\n    int n = matrix.size() ;\\n    int row = n-1 , col = n-1 ;\\n    int i = 0, j = 0, count = 0 , k, m = 0, l = 0 ;\\n    while(i < row && j < col)\\n    {\\n        while(j < col )\\n        {   \\n            m = j ;\\n            l = i ;\\n            count = 0 ;\\n            while(count < 3 )\\n            {\\n                swap(matrix[l][m], matrix[col-m][l]) ;\\n                k = l ;\\n                l = col - m ;\\n                m = k ;\\n                count++ ;\\n            }\\n            j++ ;\\n        }\\n        // for removing boundries \\n        i = i + 1 ;\\n        j = i ;\\n        row = row - 1 ;\\n        col = col - 1 ;\\n    }\\n        \\n    }\\n};\\n\\nyour inline code..."
                    },
                    {
                        "username": "karan371",
                        "content": "Can anyone tell me how to improve this solution:\\n int n=matrix.size();\\n        for(int i=0;i<n/2;i++){\\n            for(int j=i+1;j<=(n-2*i);j++){\\n                int temp=matrix[n-j-1][i];\\n                matrix[n-j-1][i]=matrix[n-i-1][n-j-1];\\n                matrix[n-i-1][n-j-1]=matrix[j][n-i-1];\\n                matrix[j][n-i-1]=matrix[i][j];\\n                matrix[i][j]=temp;\\n            }\\n        }"
                    }
                ]
            },
            {
                "id": 1935825,
                "content": [
                    {
                        "username": "Aaryan_0001",
                        "content": "APPROACH  | |   100% BEATS\\n\\n1. Find transpose of the matrix . Note to make this effiecient just swap the elements above the diagonal of the matrix to elements lower to the diagonal. keep in mind that diagonal elements remains untouched so set the loop carefully.\\n\\n2. Reverse the elements of the matrix, to do this efficiently just reverse the elements of each row only. i.e for row =0 reverse all elements inside row=0, for row =1 reverse all elements inside row=1, for row =2 reverse all elements inside row=2 and so on.......\\n\\nAND YOU ARE DONE. | | HIT A LIKE BUDDIES"
                    },
                    {
                        "username": "Pendelbus",
                        "content": "Why it give me an error?\\nclass Solution:\\n        for i in range(len(matrix[0])//2):\\n            for counter in range(i, len(matrix[0])-1-i):\\n                matrix[i][i+counter], \\n                matrix[counter+i][len(matrix[0]) - 1-i], \\n                matrix[len(matrix[0]) - 1-i][len(matrix[0]) - 1 - counter-i], \\n                matrix[len(matrix[0]) - 1 - counter-i][i]=\\\\\\n                matrix[len(matrix[0]) - 1 - counter-i][i], \\n                matrix[i][i+counter], \\n                matrix[counter+i][len(matrix[0]) - 1-i], \\n                matrix[len(matrix[0]) - 1-i][len(matrix[0]) - 1 - counter-i],"
                    },
                    {
                        "username": "kartikay5849",
                        "content": "class Solution {\\npublic:\\n    void rotate(vector<vector<int>>& matrix) {\\n        int n=matrix.size();\\n            for(int i=0 ; i<n;i++)\\n            {\\n                for(int j=0 ; j<i ; j++)\\n                {\\n                    swap(matrix[i][j],matrix[j][i]);\\n                }\\n               \\n            }\\n             for(int i=0 ; i<n ; i++)\\n                {\\n                    reverse(matrix[i].begin(),matrix[i].end());\\n                }\\n    }\\n};"
                    },
                    {
                        "username": "georgezakharov",
                        "content": "Great!\\nBut lets read the rules together.\\n\\n\\uD83D\\uDCA1 Discussion Rules\\n1. Please don\\'t post any solutions in this discussion.\\n\\n2. The problem discussion is for asking questions about the problem or for sharing tips - anything except for solutions.\\n\\n3. If you\\'d like to share your solution for feedback and ideas, please head to the solutions tab and post it there."
                    },
                    {
                        "username": "dandu_akhil_reddy",
                        "content": "class Solution {\\npublic:\\n    void rotate(vector<vector<int>>& matrix) {\\n        int n=matrix.size();\\n        int tlr,tlc,blc,trr=0;\\n        int trc,blr,brr,brc=n-1;\\n        int temp1,temp2,temp3,temp4=0;\\n        while(tlr<blr&&tlc<trc){\\n            for(int i=0;i<n-1-tlr;i++){\\n                temp1=matrix[tlr][tlc+i];\\n                temp2=matrix[trr+i][trc];\\n                temp3=matrix[brr][brc-i];\\n                temp4=matrix[blr-i][blc];\\n                matrix[tlr][tlc+i]=temp4;\\n                matrix[trr+i][trc]=temp1;\\n                matrix[brr][brc-i]=temp2;\\n                matrix[blr-i][blc]=temp3;\\n\\n            }\\n            tlr++;\\n            tlc++;\\n            trr++;\\n            trc--;\\n            blr--;\\n            blc++;\\n            brr--;\\n            brc--;\\n        }\\n        for(int i=0;i<n;i++){\\n            for(int j=0;j<n;j++){\\n                cout<<matrix[i][j]<<\" \";\\n            }\\n        }\\n    }\\n}; getting output as input for this method can anyone explain , even getting correct output for dry run"
                    },
                    {
                        "username": "mochiball",
                        "content": "Yeah. Your code is super confusing"
                    },
                    {
                        "username": "mochiball",
                        "content": "Who will be able to solve this in an interview without having seen it before.. ? "
                    },
                    {
                        "username": "palakgupta1712",
                        "content": "simplest  approach please?\\n"
                    },
                    {
                        "username": "Harsh_Balwani",
                        "content": "Yep sure!!\\nApproach is in 2 steps-\\nFirst to transpose the matrix.\\nSecond to reverse the matrix row-wise.\\n\\nif you still want detailed explanation, you can see this, \\nhttps://leetcode.com/problems/rotate-image/solutions/3678211/easy-cpp-solution-with-crystal-clear-step-wise-explanation-using-handmade-images-with-hint/\\n"
                    },
                    {
                        "username": "amartyasen895",
                        "content": "   int n = mat.size();\\n        int m = mat[0].size();\\n\\n        for(int i = 0 ; i < n-1 ; i++)\\n        {\\n            for(int j = 1 ; j < m ; j++)\\n            {\\n                swap(mat[i][j] , mat[j][i]);\\n            }\\n        }\\n\\n        for(int i = 0 ; i < n ; i++)\\n        {\\n            reverse(mat[i].begin() , mat[i].end());\\n        }\\n    }\\nWhy this is not working can anyone explain."
                    },
                    {
                        "username": "yash_giradkar",
                        "content": "The question says donot return anything,\\nI am able to to print the expected output but what is wrong with the result\\n `class Solution(object):\\n    def rotate(self, matrix):\\n        \"\"\"\\n        :type matrix: List[List[int]]\\n        :rtype: None Do not return anything, modify matrix in-place instead.\\n        \"\"\"\\n        matrix=matrix[::-1]\\n        print(matrix)\\n         \\n        for i in range(len(matrix)):\\n            for j in range(i):\\n                 \\n                temp=matrix[i][j]\\n                matrix[i][j]=matrix[j][i]\\n                matrix[j][i]=temp\\n                 \\n        print(\"last print\",matrix) ` \\n\\ntestcase-[[1,2,3],[4,5,6],[7,8,9]]\\nmy print-(\\'last print\\', [[7, 4, 1], [8, 5, 2], [9, 6, 3]])\\nOutput-[[9,6,3],[8,5,2],[7,4,1]]\\nExpected-[[7,4,1],[8,5,2],[9,6,3]]"
                    },
                    {
                        "username": "ehtasham2901",
                        "content": "is this a correct approach , i am getting stuck inside the matrix after shrinking matrix.. can anyone look into it and find the way to correct it  \\n\\n\\n`your inline code...`\\n\\n`class Solution {\\npublic:\\n    void rotate(vector<vector<int>>& matrix) {\\n\\n    int n = matrix.size() ;\\n    int row = n-1 , col = n-1 ;\\n    int i = 0, j = 0, count = 0 , k, m = 0, l = 0 ;\\n    while(i < row && j < col)\\n    {\\n        while(j < col )\\n        {   \\n            m = j ;\\n            l = i ;\\n            count = 0 ;\\n            while(count < 3 )\\n            {\\n                swap(matrix[l][m], matrix[col-m][l]) ;\\n                k = l ;\\n                l = col - m ;\\n                m = k ;\\n                count++ ;\\n            }\\n            j++ ;\\n        }\\n        // for removing boundries \\n        i = i + 1 ;\\n        j = i ;\\n        row = row - 1 ;\\n        col = col - 1 ;\\n    }\\n        \\n    }\\n};\\n\\nyour inline code..."
                    },
                    {
                        "username": "karan371",
                        "content": "Can anyone tell me how to improve this solution:\\n int n=matrix.size();\\n        for(int i=0;i<n/2;i++){\\n            for(int j=i+1;j<=(n-2*i);j++){\\n                int temp=matrix[n-j-1][i];\\n                matrix[n-j-1][i]=matrix[n-i-1][n-j-1];\\n                matrix[n-i-1][n-j-1]=matrix[j][n-i-1];\\n                matrix[j][n-i-1]=matrix[i][j];\\n                matrix[i][j]=temp;\\n            }\\n        }"
                    }
                ]
            },
            {
                "id": 1935574,
                "content": [
                    {
                        "username": "Aaryan_0001",
                        "content": "APPROACH  | |   100% BEATS\\n\\n1. Find transpose of the matrix . Note to make this effiecient just swap the elements above the diagonal of the matrix to elements lower to the diagonal. keep in mind that diagonal elements remains untouched so set the loop carefully.\\n\\n2. Reverse the elements of the matrix, to do this efficiently just reverse the elements of each row only. i.e for row =0 reverse all elements inside row=0, for row =1 reverse all elements inside row=1, for row =2 reverse all elements inside row=2 and so on.......\\n\\nAND YOU ARE DONE. | | HIT A LIKE BUDDIES"
                    },
                    {
                        "username": "Pendelbus",
                        "content": "Why it give me an error?\\nclass Solution:\\n        for i in range(len(matrix[0])//2):\\n            for counter in range(i, len(matrix[0])-1-i):\\n                matrix[i][i+counter], \\n                matrix[counter+i][len(matrix[0]) - 1-i], \\n                matrix[len(matrix[0]) - 1-i][len(matrix[0]) - 1 - counter-i], \\n                matrix[len(matrix[0]) - 1 - counter-i][i]=\\\\\\n                matrix[len(matrix[0]) - 1 - counter-i][i], \\n                matrix[i][i+counter], \\n                matrix[counter+i][len(matrix[0]) - 1-i], \\n                matrix[len(matrix[0]) - 1-i][len(matrix[0]) - 1 - counter-i],"
                    },
                    {
                        "username": "kartikay5849",
                        "content": "class Solution {\\npublic:\\n    void rotate(vector<vector<int>>& matrix) {\\n        int n=matrix.size();\\n            for(int i=0 ; i<n;i++)\\n            {\\n                for(int j=0 ; j<i ; j++)\\n                {\\n                    swap(matrix[i][j],matrix[j][i]);\\n                }\\n               \\n            }\\n             for(int i=0 ; i<n ; i++)\\n                {\\n                    reverse(matrix[i].begin(),matrix[i].end());\\n                }\\n    }\\n};"
                    },
                    {
                        "username": "georgezakharov",
                        "content": "Great!\\nBut lets read the rules together.\\n\\n\\uD83D\\uDCA1 Discussion Rules\\n1. Please don\\'t post any solutions in this discussion.\\n\\n2. The problem discussion is for asking questions about the problem or for sharing tips - anything except for solutions.\\n\\n3. If you\\'d like to share your solution for feedback and ideas, please head to the solutions tab and post it there."
                    },
                    {
                        "username": "dandu_akhil_reddy",
                        "content": "class Solution {\\npublic:\\n    void rotate(vector<vector<int>>& matrix) {\\n        int n=matrix.size();\\n        int tlr,tlc,blc,trr=0;\\n        int trc,blr,brr,brc=n-1;\\n        int temp1,temp2,temp3,temp4=0;\\n        while(tlr<blr&&tlc<trc){\\n            for(int i=0;i<n-1-tlr;i++){\\n                temp1=matrix[tlr][tlc+i];\\n                temp2=matrix[trr+i][trc];\\n                temp3=matrix[brr][brc-i];\\n                temp4=matrix[blr-i][blc];\\n                matrix[tlr][tlc+i]=temp4;\\n                matrix[trr+i][trc]=temp1;\\n                matrix[brr][brc-i]=temp2;\\n                matrix[blr-i][blc]=temp3;\\n\\n            }\\n            tlr++;\\n            tlc++;\\n            trr++;\\n            trc--;\\n            blr--;\\n            blc++;\\n            brr--;\\n            brc--;\\n        }\\n        for(int i=0;i<n;i++){\\n            for(int j=0;j<n;j++){\\n                cout<<matrix[i][j]<<\" \";\\n            }\\n        }\\n    }\\n}; getting output as input for this method can anyone explain , even getting correct output for dry run"
                    },
                    {
                        "username": "mochiball",
                        "content": "Yeah. Your code is super confusing"
                    },
                    {
                        "username": "mochiball",
                        "content": "Who will be able to solve this in an interview without having seen it before.. ? "
                    },
                    {
                        "username": "palakgupta1712",
                        "content": "simplest  approach please?\\n"
                    },
                    {
                        "username": "Harsh_Balwani",
                        "content": "Yep sure!!\\nApproach is in 2 steps-\\nFirst to transpose the matrix.\\nSecond to reverse the matrix row-wise.\\n\\nif you still want detailed explanation, you can see this, \\nhttps://leetcode.com/problems/rotate-image/solutions/3678211/easy-cpp-solution-with-crystal-clear-step-wise-explanation-using-handmade-images-with-hint/\\n"
                    },
                    {
                        "username": "amartyasen895",
                        "content": "   int n = mat.size();\\n        int m = mat[0].size();\\n\\n        for(int i = 0 ; i < n-1 ; i++)\\n        {\\n            for(int j = 1 ; j < m ; j++)\\n            {\\n                swap(mat[i][j] , mat[j][i]);\\n            }\\n        }\\n\\n        for(int i = 0 ; i < n ; i++)\\n        {\\n            reverse(mat[i].begin() , mat[i].end());\\n        }\\n    }\\nWhy this is not working can anyone explain."
                    },
                    {
                        "username": "yash_giradkar",
                        "content": "The question says donot return anything,\\nI am able to to print the expected output but what is wrong with the result\\n `class Solution(object):\\n    def rotate(self, matrix):\\n        \"\"\"\\n        :type matrix: List[List[int]]\\n        :rtype: None Do not return anything, modify matrix in-place instead.\\n        \"\"\"\\n        matrix=matrix[::-1]\\n        print(matrix)\\n         \\n        for i in range(len(matrix)):\\n            for j in range(i):\\n                 \\n                temp=matrix[i][j]\\n                matrix[i][j]=matrix[j][i]\\n                matrix[j][i]=temp\\n                 \\n        print(\"last print\",matrix) ` \\n\\ntestcase-[[1,2,3],[4,5,6],[7,8,9]]\\nmy print-(\\'last print\\', [[7, 4, 1], [8, 5, 2], [9, 6, 3]])\\nOutput-[[9,6,3],[8,5,2],[7,4,1]]\\nExpected-[[7,4,1],[8,5,2],[9,6,3]]"
                    },
                    {
                        "username": "ehtasham2901",
                        "content": "is this a correct approach , i am getting stuck inside the matrix after shrinking matrix.. can anyone look into it and find the way to correct it  \\n\\n\\n`your inline code...`\\n\\n`class Solution {\\npublic:\\n    void rotate(vector<vector<int>>& matrix) {\\n\\n    int n = matrix.size() ;\\n    int row = n-1 , col = n-1 ;\\n    int i = 0, j = 0, count = 0 , k, m = 0, l = 0 ;\\n    while(i < row && j < col)\\n    {\\n        while(j < col )\\n        {   \\n            m = j ;\\n            l = i ;\\n            count = 0 ;\\n            while(count < 3 )\\n            {\\n                swap(matrix[l][m], matrix[col-m][l]) ;\\n                k = l ;\\n                l = col - m ;\\n                m = k ;\\n                count++ ;\\n            }\\n            j++ ;\\n        }\\n        // for removing boundries \\n        i = i + 1 ;\\n        j = i ;\\n        row = row - 1 ;\\n        col = col - 1 ;\\n    }\\n        \\n    }\\n};\\n\\nyour inline code..."
                    },
                    {
                        "username": "karan371",
                        "content": "Can anyone tell me how to improve this solution:\\n int n=matrix.size();\\n        for(int i=0;i<n/2;i++){\\n            for(int j=i+1;j<=(n-2*i);j++){\\n                int temp=matrix[n-j-1][i];\\n                matrix[n-j-1][i]=matrix[n-i-1][n-j-1];\\n                matrix[n-i-1][n-j-1]=matrix[j][n-i-1];\\n                matrix[j][n-i-1]=matrix[i][j];\\n                matrix[i][j]=temp;\\n            }\\n        }"
                    }
                ]
            },
            {
                "id": 1934566,
                "content": [
                    {
                        "username": "Aaryan_0001",
                        "content": "APPROACH  | |   100% BEATS\\n\\n1. Find transpose of the matrix . Note to make this effiecient just swap the elements above the diagonal of the matrix to elements lower to the diagonal. keep in mind that diagonal elements remains untouched so set the loop carefully.\\n\\n2. Reverse the elements of the matrix, to do this efficiently just reverse the elements of each row only. i.e for row =0 reverse all elements inside row=0, for row =1 reverse all elements inside row=1, for row =2 reverse all elements inside row=2 and so on.......\\n\\nAND YOU ARE DONE. | | HIT A LIKE BUDDIES"
                    },
                    {
                        "username": "Pendelbus",
                        "content": "Why it give me an error?\\nclass Solution:\\n        for i in range(len(matrix[0])//2):\\n            for counter in range(i, len(matrix[0])-1-i):\\n                matrix[i][i+counter], \\n                matrix[counter+i][len(matrix[0]) - 1-i], \\n                matrix[len(matrix[0]) - 1-i][len(matrix[0]) - 1 - counter-i], \\n                matrix[len(matrix[0]) - 1 - counter-i][i]=\\\\\\n                matrix[len(matrix[0]) - 1 - counter-i][i], \\n                matrix[i][i+counter], \\n                matrix[counter+i][len(matrix[0]) - 1-i], \\n                matrix[len(matrix[0]) - 1-i][len(matrix[0]) - 1 - counter-i],"
                    },
                    {
                        "username": "kartikay5849",
                        "content": "class Solution {\\npublic:\\n    void rotate(vector<vector<int>>& matrix) {\\n        int n=matrix.size();\\n            for(int i=0 ; i<n;i++)\\n            {\\n                for(int j=0 ; j<i ; j++)\\n                {\\n                    swap(matrix[i][j],matrix[j][i]);\\n                }\\n               \\n            }\\n             for(int i=0 ; i<n ; i++)\\n                {\\n                    reverse(matrix[i].begin(),matrix[i].end());\\n                }\\n    }\\n};"
                    },
                    {
                        "username": "georgezakharov",
                        "content": "Great!\\nBut lets read the rules together.\\n\\n\\uD83D\\uDCA1 Discussion Rules\\n1. Please don\\'t post any solutions in this discussion.\\n\\n2. The problem discussion is for asking questions about the problem or for sharing tips - anything except for solutions.\\n\\n3. If you\\'d like to share your solution for feedback and ideas, please head to the solutions tab and post it there."
                    },
                    {
                        "username": "dandu_akhil_reddy",
                        "content": "class Solution {\\npublic:\\n    void rotate(vector<vector<int>>& matrix) {\\n        int n=matrix.size();\\n        int tlr,tlc,blc,trr=0;\\n        int trc,blr,brr,brc=n-1;\\n        int temp1,temp2,temp3,temp4=0;\\n        while(tlr<blr&&tlc<trc){\\n            for(int i=0;i<n-1-tlr;i++){\\n                temp1=matrix[tlr][tlc+i];\\n                temp2=matrix[trr+i][trc];\\n                temp3=matrix[brr][brc-i];\\n                temp4=matrix[blr-i][blc];\\n                matrix[tlr][tlc+i]=temp4;\\n                matrix[trr+i][trc]=temp1;\\n                matrix[brr][brc-i]=temp2;\\n                matrix[blr-i][blc]=temp3;\\n\\n            }\\n            tlr++;\\n            tlc++;\\n            trr++;\\n            trc--;\\n            blr--;\\n            blc++;\\n            brr--;\\n            brc--;\\n        }\\n        for(int i=0;i<n;i++){\\n            for(int j=0;j<n;j++){\\n                cout<<matrix[i][j]<<\" \";\\n            }\\n        }\\n    }\\n}; getting output as input for this method can anyone explain , even getting correct output for dry run"
                    },
                    {
                        "username": "mochiball",
                        "content": "Yeah. Your code is super confusing"
                    },
                    {
                        "username": "mochiball",
                        "content": "Who will be able to solve this in an interview without having seen it before.. ? "
                    },
                    {
                        "username": "palakgupta1712",
                        "content": "simplest  approach please?\\n"
                    },
                    {
                        "username": "Harsh_Balwani",
                        "content": "Yep sure!!\\nApproach is in 2 steps-\\nFirst to transpose the matrix.\\nSecond to reverse the matrix row-wise.\\n\\nif you still want detailed explanation, you can see this, \\nhttps://leetcode.com/problems/rotate-image/solutions/3678211/easy-cpp-solution-with-crystal-clear-step-wise-explanation-using-handmade-images-with-hint/\\n"
                    },
                    {
                        "username": "amartyasen895",
                        "content": "   int n = mat.size();\\n        int m = mat[0].size();\\n\\n        for(int i = 0 ; i < n-1 ; i++)\\n        {\\n            for(int j = 1 ; j < m ; j++)\\n            {\\n                swap(mat[i][j] , mat[j][i]);\\n            }\\n        }\\n\\n        for(int i = 0 ; i < n ; i++)\\n        {\\n            reverse(mat[i].begin() , mat[i].end());\\n        }\\n    }\\nWhy this is not working can anyone explain."
                    },
                    {
                        "username": "yash_giradkar",
                        "content": "The question says donot return anything,\\nI am able to to print the expected output but what is wrong with the result\\n `class Solution(object):\\n    def rotate(self, matrix):\\n        \"\"\"\\n        :type matrix: List[List[int]]\\n        :rtype: None Do not return anything, modify matrix in-place instead.\\n        \"\"\"\\n        matrix=matrix[::-1]\\n        print(matrix)\\n         \\n        for i in range(len(matrix)):\\n            for j in range(i):\\n                 \\n                temp=matrix[i][j]\\n                matrix[i][j]=matrix[j][i]\\n                matrix[j][i]=temp\\n                 \\n        print(\"last print\",matrix) ` \\n\\ntestcase-[[1,2,3],[4,5,6],[7,8,9]]\\nmy print-(\\'last print\\', [[7, 4, 1], [8, 5, 2], [9, 6, 3]])\\nOutput-[[9,6,3],[8,5,2],[7,4,1]]\\nExpected-[[7,4,1],[8,5,2],[9,6,3]]"
                    },
                    {
                        "username": "ehtasham2901",
                        "content": "is this a correct approach , i am getting stuck inside the matrix after shrinking matrix.. can anyone look into it and find the way to correct it  \\n\\n\\n`your inline code...`\\n\\n`class Solution {\\npublic:\\n    void rotate(vector<vector<int>>& matrix) {\\n\\n    int n = matrix.size() ;\\n    int row = n-1 , col = n-1 ;\\n    int i = 0, j = 0, count = 0 , k, m = 0, l = 0 ;\\n    while(i < row && j < col)\\n    {\\n        while(j < col )\\n        {   \\n            m = j ;\\n            l = i ;\\n            count = 0 ;\\n            while(count < 3 )\\n            {\\n                swap(matrix[l][m], matrix[col-m][l]) ;\\n                k = l ;\\n                l = col - m ;\\n                m = k ;\\n                count++ ;\\n            }\\n            j++ ;\\n        }\\n        // for removing boundries \\n        i = i + 1 ;\\n        j = i ;\\n        row = row - 1 ;\\n        col = col - 1 ;\\n    }\\n        \\n    }\\n};\\n\\nyour inline code..."
                    },
                    {
                        "username": "karan371",
                        "content": "Can anyone tell me how to improve this solution:\\n int n=matrix.size();\\n        for(int i=0;i<n/2;i++){\\n            for(int j=i+1;j<=(n-2*i);j++){\\n                int temp=matrix[n-j-1][i];\\n                matrix[n-j-1][i]=matrix[n-i-1][n-j-1];\\n                matrix[n-i-1][n-j-1]=matrix[j][n-i-1];\\n                matrix[j][n-i-1]=matrix[i][j];\\n                matrix[i][j]=temp;\\n            }\\n        }"
                    }
                ]
            },
            {
                "id": 1902983,
                "content": [
                    {
                        "username": "ranbir7",
                        "content": "I used Zip function in python to do it all,\\nsome years ago I had a huge difficulty solving this\\nbut these graph problems let me down this rabbit hole where I found the use of zip function.\\nIt really helped though."
                    },
                    {
                        "username": "rajat_sharma2809",
                        "content": "I try to transpose the matrix first by using the transpose( ) of numpy library then convert the numpy array to list. But in my final output the matrix is same as it is in the given input. Can anyone help!\\nimport numpy as np\\nmatrix = np.array(matrix)\\nmatrix = np.transpose(matrix)\\nmatrix = list(matrix)"
                    },
                    {
                        "username": "ranbir7",
                        "content": "we can use zip() of python to do it all in just 3 lines."
                    },
                    {
                        "username": "swati_dubey",
                        "content": "\\uD83D\\uDCAFTwo step to resolve this problem --->\\n1) take transpose of matrix and \\n2) reverse columns, row by row."
                    },
                    {
                        "username": "ashwanisharma72002",
                        "content": "the message say not to return anything but to update the existing \"matrix\"\\ni did this what is the issue here?? \\n\\nclass Solution:\\n    def rotate(self, matrix: List[List[int]]) -> None:\\n        \"\"\"\\n        Do not return anything, modify matrix in-place instead.\\n        \"\"\"\\n        # a=[[1,2,3,4],[5,6,7,8],[9,10,11,12],[13,14,15,16]]\\n        newlis=[]\\n        finlis=[]\\n        for j in range(len(matrix[0])):\\n            for i in range(len(matrix)-1,-1,-1):\\n                newlis.append(matrix[i][j])\\n        for i in range(len(matrix)):\\n            finlis.append ( newlis[0:len(matrix) ] )\\n            del(newlis[:len(matrix)])\\n        matrix=finlis"
                    },
                    {
                        "username": "miha4406",
                        "content": "My approach is: don't think there to put next element, think which element should be moved in this place. It's: matrix[i][j] = matrix[l-j][i];  \n// l = matrix.GetLength(0)-1;\nThen use recursion to replace 4 linked elements. \nStart recursion for all start elements, which are in case of Example 2 is: 5 1 9 4. This will rotate all the other elements linked to them."
                    },
                    {
                        "username": "zenfred",
                        "content": "The first solution I could think of uses _O(n)_ (or `n - 1`) extra storage. Will that pass in an interview? Remember, the description only disallows \"another 2D matrix\", which is _O(n^2)_ space."
                    },
                    {
                        "username": "Glory_Killer",
                        "content": "Very easy solution using below two concept\\n1. First transpose the matrix.\\ne.g;\\n[1,2,3]  --->[1,4,7]\\n[4,5,6]  --->[2,5,8]\\n[7,8,9]  --->[3,6,9]\\n\\n2. Then reverse the matrix.\\ne.g;\\n[1,4,7]  --->[7,4,1]\\n[2,5,8]  --->[8,5,2]\\n[3,6,9]  --->[9,6,3]"
                    },
                    {
                        "username": "Ankita_Rawat30",
                        "content": "So, I basically transposed the matrix and reversed each row. When I print the final matrix, it is the same as the expected output. But my actual output just shows the transposed version (which is wrong). What am I missing?\\n\\n `class Solution {\\npublic:\\n    void rotate(vector<vector<int>>& matrix) {\\n\\n        int n = matrix.size();\\n        vector<vector<int>> temp2 = matrix;\\n        for(int i=0; i<n; i++)\\n        {\\n            for(int j =n-1; j>=0; j--)\\n            {\\n                matrix[i][j]=temp2[j][i];\\n            }\\n        }\\n\\n\\n        for(int i=0; i<n; i++)\\n        {\\n            for(int j =n-1; j>=0; j--)\\n            {\\n                cout<<matrix[i][j]<<\" \";\\n            }\\n        }\\n\\n\\n    }\\n};` "
                    },
                    {
                        "username": "kenhaley",
                        "content": "I thought this was pretty simple.  Find every set of 4 pixels that need to be rotated and rotate them. (temp <- pixel1 <- pixel2 <-  pixel3 <- pixel4 <- temp.)  Then construct an outer loop that finds all the 4-pixel sets without duplication.  One of the few problems I got right on the first try."
                    },
                    {
                        "username": "YASH_SHARMA001",
                        "content": "matrixcolsize means?"
                    }
                ]
            },
            {
                "id": 1899218,
                "content": [
                    {
                        "username": "ranbir7",
                        "content": "I used Zip function in python to do it all,\\nsome years ago I had a huge difficulty solving this\\nbut these graph problems let me down this rabbit hole where I found the use of zip function.\\nIt really helped though."
                    },
                    {
                        "username": "rajat_sharma2809",
                        "content": "I try to transpose the matrix first by using the transpose( ) of numpy library then convert the numpy array to list. But in my final output the matrix is same as it is in the given input. Can anyone help!\\nimport numpy as np\\nmatrix = np.array(matrix)\\nmatrix = np.transpose(matrix)\\nmatrix = list(matrix)"
                    },
                    {
                        "username": "ranbir7",
                        "content": "we can use zip() of python to do it all in just 3 lines."
                    },
                    {
                        "username": "swati_dubey",
                        "content": "\\uD83D\\uDCAFTwo step to resolve this problem --->\\n1) take transpose of matrix and \\n2) reverse columns, row by row."
                    },
                    {
                        "username": "ashwanisharma72002",
                        "content": "the message say not to return anything but to update the existing \"matrix\"\\ni did this what is the issue here?? \\n\\nclass Solution:\\n    def rotate(self, matrix: List[List[int]]) -> None:\\n        \"\"\"\\n        Do not return anything, modify matrix in-place instead.\\n        \"\"\"\\n        # a=[[1,2,3,4],[5,6,7,8],[9,10,11,12],[13,14,15,16]]\\n        newlis=[]\\n        finlis=[]\\n        for j in range(len(matrix[0])):\\n            for i in range(len(matrix)-1,-1,-1):\\n                newlis.append(matrix[i][j])\\n        for i in range(len(matrix)):\\n            finlis.append ( newlis[0:len(matrix) ] )\\n            del(newlis[:len(matrix)])\\n        matrix=finlis"
                    },
                    {
                        "username": "miha4406",
                        "content": "My approach is: don't think there to put next element, think which element should be moved in this place. It's: matrix[i][j] = matrix[l-j][i];  \n// l = matrix.GetLength(0)-1;\nThen use recursion to replace 4 linked elements. \nStart recursion for all start elements, which are in case of Example 2 is: 5 1 9 4. This will rotate all the other elements linked to them."
                    },
                    {
                        "username": "zenfred",
                        "content": "The first solution I could think of uses _O(n)_ (or `n - 1`) extra storage. Will that pass in an interview? Remember, the description only disallows \"another 2D matrix\", which is _O(n^2)_ space."
                    },
                    {
                        "username": "Glory_Killer",
                        "content": "Very easy solution using below two concept\\n1. First transpose the matrix.\\ne.g;\\n[1,2,3]  --->[1,4,7]\\n[4,5,6]  --->[2,5,8]\\n[7,8,9]  --->[3,6,9]\\n\\n2. Then reverse the matrix.\\ne.g;\\n[1,4,7]  --->[7,4,1]\\n[2,5,8]  --->[8,5,2]\\n[3,6,9]  --->[9,6,3]"
                    },
                    {
                        "username": "Ankita_Rawat30",
                        "content": "So, I basically transposed the matrix and reversed each row. When I print the final matrix, it is the same as the expected output. But my actual output just shows the transposed version (which is wrong). What am I missing?\\n\\n `class Solution {\\npublic:\\n    void rotate(vector<vector<int>>& matrix) {\\n\\n        int n = matrix.size();\\n        vector<vector<int>> temp2 = matrix;\\n        for(int i=0; i<n; i++)\\n        {\\n            for(int j =n-1; j>=0; j--)\\n            {\\n                matrix[i][j]=temp2[j][i];\\n            }\\n        }\\n\\n\\n        for(int i=0; i<n; i++)\\n        {\\n            for(int j =n-1; j>=0; j--)\\n            {\\n                cout<<matrix[i][j]<<\" \";\\n            }\\n        }\\n\\n\\n    }\\n};` "
                    },
                    {
                        "username": "kenhaley",
                        "content": "I thought this was pretty simple.  Find every set of 4 pixels that need to be rotated and rotate them. (temp <- pixel1 <- pixel2 <-  pixel3 <- pixel4 <- temp.)  Then construct an outer loop that finds all the 4-pixel sets without duplication.  One of the few problems I got right on the first try."
                    },
                    {
                        "username": "YASH_SHARMA001",
                        "content": "matrixcolsize means?"
                    }
                ]
            },
            {
                "id": 1889231,
                "content": [
                    {
                        "username": "ranbir7",
                        "content": "I used Zip function in python to do it all,\\nsome years ago I had a huge difficulty solving this\\nbut these graph problems let me down this rabbit hole where I found the use of zip function.\\nIt really helped though."
                    },
                    {
                        "username": "rajat_sharma2809",
                        "content": "I try to transpose the matrix first by using the transpose( ) of numpy library then convert the numpy array to list. But in my final output the matrix is same as it is in the given input. Can anyone help!\\nimport numpy as np\\nmatrix = np.array(matrix)\\nmatrix = np.transpose(matrix)\\nmatrix = list(matrix)"
                    },
                    {
                        "username": "ranbir7",
                        "content": "we can use zip() of python to do it all in just 3 lines."
                    },
                    {
                        "username": "swati_dubey",
                        "content": "\\uD83D\\uDCAFTwo step to resolve this problem --->\\n1) take transpose of matrix and \\n2) reverse columns, row by row."
                    },
                    {
                        "username": "ashwanisharma72002",
                        "content": "the message say not to return anything but to update the existing \"matrix\"\\ni did this what is the issue here?? \\n\\nclass Solution:\\n    def rotate(self, matrix: List[List[int]]) -> None:\\n        \"\"\"\\n        Do not return anything, modify matrix in-place instead.\\n        \"\"\"\\n        # a=[[1,2,3,4],[5,6,7,8],[9,10,11,12],[13,14,15,16]]\\n        newlis=[]\\n        finlis=[]\\n        for j in range(len(matrix[0])):\\n            for i in range(len(matrix)-1,-1,-1):\\n                newlis.append(matrix[i][j])\\n        for i in range(len(matrix)):\\n            finlis.append ( newlis[0:len(matrix) ] )\\n            del(newlis[:len(matrix)])\\n        matrix=finlis"
                    },
                    {
                        "username": "miha4406",
                        "content": "My approach is: don't think there to put next element, think which element should be moved in this place. It's: matrix[i][j] = matrix[l-j][i];  \n// l = matrix.GetLength(0)-1;\nThen use recursion to replace 4 linked elements. \nStart recursion for all start elements, which are in case of Example 2 is: 5 1 9 4. This will rotate all the other elements linked to them."
                    },
                    {
                        "username": "zenfred",
                        "content": "The first solution I could think of uses _O(n)_ (or `n - 1`) extra storage. Will that pass in an interview? Remember, the description only disallows \"another 2D matrix\", which is _O(n^2)_ space."
                    },
                    {
                        "username": "Glory_Killer",
                        "content": "Very easy solution using below two concept\\n1. First transpose the matrix.\\ne.g;\\n[1,2,3]  --->[1,4,7]\\n[4,5,6]  --->[2,5,8]\\n[7,8,9]  --->[3,6,9]\\n\\n2. Then reverse the matrix.\\ne.g;\\n[1,4,7]  --->[7,4,1]\\n[2,5,8]  --->[8,5,2]\\n[3,6,9]  --->[9,6,3]"
                    },
                    {
                        "username": "Ankita_Rawat30",
                        "content": "So, I basically transposed the matrix and reversed each row. When I print the final matrix, it is the same as the expected output. But my actual output just shows the transposed version (which is wrong). What am I missing?\\n\\n `class Solution {\\npublic:\\n    void rotate(vector<vector<int>>& matrix) {\\n\\n        int n = matrix.size();\\n        vector<vector<int>> temp2 = matrix;\\n        for(int i=0; i<n; i++)\\n        {\\n            for(int j =n-1; j>=0; j--)\\n            {\\n                matrix[i][j]=temp2[j][i];\\n            }\\n        }\\n\\n\\n        for(int i=0; i<n; i++)\\n        {\\n            for(int j =n-1; j>=0; j--)\\n            {\\n                cout<<matrix[i][j]<<\" \";\\n            }\\n        }\\n\\n\\n    }\\n};` "
                    },
                    {
                        "username": "kenhaley",
                        "content": "I thought this was pretty simple.  Find every set of 4 pixels that need to be rotated and rotate them. (temp <- pixel1 <- pixel2 <-  pixel3 <- pixel4 <- temp.)  Then construct an outer loop that finds all the 4-pixel sets without duplication.  One of the few problems I got right on the first try."
                    },
                    {
                        "username": "YASH_SHARMA001",
                        "content": "matrixcolsize means?"
                    }
                ]
            },
            {
                "id": 1876738,
                "content": [
                    {
                        "username": "ranbir7",
                        "content": "I used Zip function in python to do it all,\\nsome years ago I had a huge difficulty solving this\\nbut these graph problems let me down this rabbit hole where I found the use of zip function.\\nIt really helped though."
                    },
                    {
                        "username": "rajat_sharma2809",
                        "content": "I try to transpose the matrix first by using the transpose( ) of numpy library then convert the numpy array to list. But in my final output the matrix is same as it is in the given input. Can anyone help!\\nimport numpy as np\\nmatrix = np.array(matrix)\\nmatrix = np.transpose(matrix)\\nmatrix = list(matrix)"
                    },
                    {
                        "username": "ranbir7",
                        "content": "we can use zip() of python to do it all in just 3 lines."
                    },
                    {
                        "username": "swati_dubey",
                        "content": "\\uD83D\\uDCAFTwo step to resolve this problem --->\\n1) take transpose of matrix and \\n2) reverse columns, row by row."
                    },
                    {
                        "username": "ashwanisharma72002",
                        "content": "the message say not to return anything but to update the existing \"matrix\"\\ni did this what is the issue here?? \\n\\nclass Solution:\\n    def rotate(self, matrix: List[List[int]]) -> None:\\n        \"\"\"\\n        Do not return anything, modify matrix in-place instead.\\n        \"\"\"\\n        # a=[[1,2,3,4],[5,6,7,8],[9,10,11,12],[13,14,15,16]]\\n        newlis=[]\\n        finlis=[]\\n        for j in range(len(matrix[0])):\\n            for i in range(len(matrix)-1,-1,-1):\\n                newlis.append(matrix[i][j])\\n        for i in range(len(matrix)):\\n            finlis.append ( newlis[0:len(matrix) ] )\\n            del(newlis[:len(matrix)])\\n        matrix=finlis"
                    },
                    {
                        "username": "miha4406",
                        "content": "My approach is: don't think there to put next element, think which element should be moved in this place. It's: matrix[i][j] = matrix[l-j][i];  \n// l = matrix.GetLength(0)-1;\nThen use recursion to replace 4 linked elements. \nStart recursion for all start elements, which are in case of Example 2 is: 5 1 9 4. This will rotate all the other elements linked to them."
                    },
                    {
                        "username": "zenfred",
                        "content": "The first solution I could think of uses _O(n)_ (or `n - 1`) extra storage. Will that pass in an interview? Remember, the description only disallows \"another 2D matrix\", which is _O(n^2)_ space."
                    },
                    {
                        "username": "Glory_Killer",
                        "content": "Very easy solution using below two concept\\n1. First transpose the matrix.\\ne.g;\\n[1,2,3]  --->[1,4,7]\\n[4,5,6]  --->[2,5,8]\\n[7,8,9]  --->[3,6,9]\\n\\n2. Then reverse the matrix.\\ne.g;\\n[1,4,7]  --->[7,4,1]\\n[2,5,8]  --->[8,5,2]\\n[3,6,9]  --->[9,6,3]"
                    },
                    {
                        "username": "Ankita_Rawat30",
                        "content": "So, I basically transposed the matrix and reversed each row. When I print the final matrix, it is the same as the expected output. But my actual output just shows the transposed version (which is wrong). What am I missing?\\n\\n `class Solution {\\npublic:\\n    void rotate(vector<vector<int>>& matrix) {\\n\\n        int n = matrix.size();\\n        vector<vector<int>> temp2 = matrix;\\n        for(int i=0; i<n; i++)\\n        {\\n            for(int j =n-1; j>=0; j--)\\n            {\\n                matrix[i][j]=temp2[j][i];\\n            }\\n        }\\n\\n\\n        for(int i=0; i<n; i++)\\n        {\\n            for(int j =n-1; j>=0; j--)\\n            {\\n                cout<<matrix[i][j]<<\" \";\\n            }\\n        }\\n\\n\\n    }\\n};` "
                    },
                    {
                        "username": "kenhaley",
                        "content": "I thought this was pretty simple.  Find every set of 4 pixels that need to be rotated and rotate them. (temp <- pixel1 <- pixel2 <-  pixel3 <- pixel4 <- temp.)  Then construct an outer loop that finds all the 4-pixel sets without duplication.  One of the few problems I got right on the first try."
                    },
                    {
                        "username": "YASH_SHARMA001",
                        "content": "matrixcolsize means?"
                    }
                ]
            },
            {
                "id": 1869698,
                "content": [
                    {
                        "username": "ranbir7",
                        "content": "I used Zip function in python to do it all,\\nsome years ago I had a huge difficulty solving this\\nbut these graph problems let me down this rabbit hole where I found the use of zip function.\\nIt really helped though."
                    },
                    {
                        "username": "rajat_sharma2809",
                        "content": "I try to transpose the matrix first by using the transpose( ) of numpy library then convert the numpy array to list. But in my final output the matrix is same as it is in the given input. Can anyone help!\\nimport numpy as np\\nmatrix = np.array(matrix)\\nmatrix = np.transpose(matrix)\\nmatrix = list(matrix)"
                    },
                    {
                        "username": "ranbir7",
                        "content": "we can use zip() of python to do it all in just 3 lines."
                    },
                    {
                        "username": "swati_dubey",
                        "content": "\\uD83D\\uDCAFTwo step to resolve this problem --->\\n1) take transpose of matrix and \\n2) reverse columns, row by row."
                    },
                    {
                        "username": "ashwanisharma72002",
                        "content": "the message say not to return anything but to update the existing \"matrix\"\\ni did this what is the issue here?? \\n\\nclass Solution:\\n    def rotate(self, matrix: List[List[int]]) -> None:\\n        \"\"\"\\n        Do not return anything, modify matrix in-place instead.\\n        \"\"\"\\n        # a=[[1,2,3,4],[5,6,7,8],[9,10,11,12],[13,14,15,16]]\\n        newlis=[]\\n        finlis=[]\\n        for j in range(len(matrix[0])):\\n            for i in range(len(matrix)-1,-1,-1):\\n                newlis.append(matrix[i][j])\\n        for i in range(len(matrix)):\\n            finlis.append ( newlis[0:len(matrix) ] )\\n            del(newlis[:len(matrix)])\\n        matrix=finlis"
                    },
                    {
                        "username": "miha4406",
                        "content": "My approach is: don't think there to put next element, think which element should be moved in this place. It's: matrix[i][j] = matrix[l-j][i];  \n// l = matrix.GetLength(0)-1;\nThen use recursion to replace 4 linked elements. \nStart recursion for all start elements, which are in case of Example 2 is: 5 1 9 4. This will rotate all the other elements linked to them."
                    },
                    {
                        "username": "zenfred",
                        "content": "The first solution I could think of uses _O(n)_ (or `n - 1`) extra storage. Will that pass in an interview? Remember, the description only disallows \"another 2D matrix\", which is _O(n^2)_ space."
                    },
                    {
                        "username": "Glory_Killer",
                        "content": "Very easy solution using below two concept\\n1. First transpose the matrix.\\ne.g;\\n[1,2,3]  --->[1,4,7]\\n[4,5,6]  --->[2,5,8]\\n[7,8,9]  --->[3,6,9]\\n\\n2. Then reverse the matrix.\\ne.g;\\n[1,4,7]  --->[7,4,1]\\n[2,5,8]  --->[8,5,2]\\n[3,6,9]  --->[9,6,3]"
                    },
                    {
                        "username": "Ankita_Rawat30",
                        "content": "So, I basically transposed the matrix and reversed each row. When I print the final matrix, it is the same as the expected output. But my actual output just shows the transposed version (which is wrong). What am I missing?\\n\\n `class Solution {\\npublic:\\n    void rotate(vector<vector<int>>& matrix) {\\n\\n        int n = matrix.size();\\n        vector<vector<int>> temp2 = matrix;\\n        for(int i=0; i<n; i++)\\n        {\\n            for(int j =n-1; j>=0; j--)\\n            {\\n                matrix[i][j]=temp2[j][i];\\n            }\\n        }\\n\\n\\n        for(int i=0; i<n; i++)\\n        {\\n            for(int j =n-1; j>=0; j--)\\n            {\\n                cout<<matrix[i][j]<<\" \";\\n            }\\n        }\\n\\n\\n    }\\n};` "
                    },
                    {
                        "username": "kenhaley",
                        "content": "I thought this was pretty simple.  Find every set of 4 pixels that need to be rotated and rotate them. (temp <- pixel1 <- pixel2 <-  pixel3 <- pixel4 <- temp.)  Then construct an outer loop that finds all the 4-pixel sets without duplication.  One of the few problems I got right on the first try."
                    },
                    {
                        "username": "YASH_SHARMA001",
                        "content": "matrixcolsize means?"
                    }
                ]
            },
            {
                "id": 1853670,
                "content": [
                    {
                        "username": "ranbir7",
                        "content": "I used Zip function in python to do it all,\\nsome years ago I had a huge difficulty solving this\\nbut these graph problems let me down this rabbit hole where I found the use of zip function.\\nIt really helped though."
                    },
                    {
                        "username": "rajat_sharma2809",
                        "content": "I try to transpose the matrix first by using the transpose( ) of numpy library then convert the numpy array to list. But in my final output the matrix is same as it is in the given input. Can anyone help!\\nimport numpy as np\\nmatrix = np.array(matrix)\\nmatrix = np.transpose(matrix)\\nmatrix = list(matrix)"
                    },
                    {
                        "username": "ranbir7",
                        "content": "we can use zip() of python to do it all in just 3 lines."
                    },
                    {
                        "username": "swati_dubey",
                        "content": "\\uD83D\\uDCAFTwo step to resolve this problem --->\\n1) take transpose of matrix and \\n2) reverse columns, row by row."
                    },
                    {
                        "username": "ashwanisharma72002",
                        "content": "the message say not to return anything but to update the existing \"matrix\"\\ni did this what is the issue here?? \\n\\nclass Solution:\\n    def rotate(self, matrix: List[List[int]]) -> None:\\n        \"\"\"\\n        Do not return anything, modify matrix in-place instead.\\n        \"\"\"\\n        # a=[[1,2,3,4],[5,6,7,8],[9,10,11,12],[13,14,15,16]]\\n        newlis=[]\\n        finlis=[]\\n        for j in range(len(matrix[0])):\\n            for i in range(len(matrix)-1,-1,-1):\\n                newlis.append(matrix[i][j])\\n        for i in range(len(matrix)):\\n            finlis.append ( newlis[0:len(matrix) ] )\\n            del(newlis[:len(matrix)])\\n        matrix=finlis"
                    },
                    {
                        "username": "miha4406",
                        "content": "My approach is: don't think there to put next element, think which element should be moved in this place. It's: matrix[i][j] = matrix[l-j][i];  \n// l = matrix.GetLength(0)-1;\nThen use recursion to replace 4 linked elements. \nStart recursion for all start elements, which are in case of Example 2 is: 5 1 9 4. This will rotate all the other elements linked to them."
                    },
                    {
                        "username": "zenfred",
                        "content": "The first solution I could think of uses _O(n)_ (or `n - 1`) extra storage. Will that pass in an interview? Remember, the description only disallows \"another 2D matrix\", which is _O(n^2)_ space."
                    },
                    {
                        "username": "Glory_Killer",
                        "content": "Very easy solution using below two concept\\n1. First transpose the matrix.\\ne.g;\\n[1,2,3]  --->[1,4,7]\\n[4,5,6]  --->[2,5,8]\\n[7,8,9]  --->[3,6,9]\\n\\n2. Then reverse the matrix.\\ne.g;\\n[1,4,7]  --->[7,4,1]\\n[2,5,8]  --->[8,5,2]\\n[3,6,9]  --->[9,6,3]"
                    },
                    {
                        "username": "Ankita_Rawat30",
                        "content": "So, I basically transposed the matrix and reversed each row. When I print the final matrix, it is the same as the expected output. But my actual output just shows the transposed version (which is wrong). What am I missing?\\n\\n `class Solution {\\npublic:\\n    void rotate(vector<vector<int>>& matrix) {\\n\\n        int n = matrix.size();\\n        vector<vector<int>> temp2 = matrix;\\n        for(int i=0; i<n; i++)\\n        {\\n            for(int j =n-1; j>=0; j--)\\n            {\\n                matrix[i][j]=temp2[j][i];\\n            }\\n        }\\n\\n\\n        for(int i=0; i<n; i++)\\n        {\\n            for(int j =n-1; j>=0; j--)\\n            {\\n                cout<<matrix[i][j]<<\" \";\\n            }\\n        }\\n\\n\\n    }\\n};` "
                    },
                    {
                        "username": "kenhaley",
                        "content": "I thought this was pretty simple.  Find every set of 4 pixels that need to be rotated and rotate them. (temp <- pixel1 <- pixel2 <-  pixel3 <- pixel4 <- temp.)  Then construct an outer loop that finds all the 4-pixel sets without duplication.  One of the few problems I got right on the first try."
                    },
                    {
                        "username": "YASH_SHARMA001",
                        "content": "matrixcolsize means?"
                    }
                ]
            },
            {
                "id": 1848988,
                "content": [
                    {
                        "username": "ranbir7",
                        "content": "I used Zip function in python to do it all,\\nsome years ago I had a huge difficulty solving this\\nbut these graph problems let me down this rabbit hole where I found the use of zip function.\\nIt really helped though."
                    },
                    {
                        "username": "rajat_sharma2809",
                        "content": "I try to transpose the matrix first by using the transpose( ) of numpy library then convert the numpy array to list. But in my final output the matrix is same as it is in the given input. Can anyone help!\\nimport numpy as np\\nmatrix = np.array(matrix)\\nmatrix = np.transpose(matrix)\\nmatrix = list(matrix)"
                    },
                    {
                        "username": "ranbir7",
                        "content": "we can use zip() of python to do it all in just 3 lines."
                    },
                    {
                        "username": "swati_dubey",
                        "content": "\\uD83D\\uDCAFTwo step to resolve this problem --->\\n1) take transpose of matrix and \\n2) reverse columns, row by row."
                    },
                    {
                        "username": "ashwanisharma72002",
                        "content": "the message say not to return anything but to update the existing \"matrix\"\\ni did this what is the issue here?? \\n\\nclass Solution:\\n    def rotate(self, matrix: List[List[int]]) -> None:\\n        \"\"\"\\n        Do not return anything, modify matrix in-place instead.\\n        \"\"\"\\n        # a=[[1,2,3,4],[5,6,7,8],[9,10,11,12],[13,14,15,16]]\\n        newlis=[]\\n        finlis=[]\\n        for j in range(len(matrix[0])):\\n            for i in range(len(matrix)-1,-1,-1):\\n                newlis.append(matrix[i][j])\\n        for i in range(len(matrix)):\\n            finlis.append ( newlis[0:len(matrix) ] )\\n            del(newlis[:len(matrix)])\\n        matrix=finlis"
                    },
                    {
                        "username": "miha4406",
                        "content": "My approach is: don't think there to put next element, think which element should be moved in this place. It's: matrix[i][j] = matrix[l-j][i];  \n// l = matrix.GetLength(0)-1;\nThen use recursion to replace 4 linked elements. \nStart recursion for all start elements, which are in case of Example 2 is: 5 1 9 4. This will rotate all the other elements linked to them."
                    },
                    {
                        "username": "zenfred",
                        "content": "The first solution I could think of uses _O(n)_ (or `n - 1`) extra storage. Will that pass in an interview? Remember, the description only disallows \"another 2D matrix\", which is _O(n^2)_ space."
                    },
                    {
                        "username": "Glory_Killer",
                        "content": "Very easy solution using below two concept\\n1. First transpose the matrix.\\ne.g;\\n[1,2,3]  --->[1,4,7]\\n[4,5,6]  --->[2,5,8]\\n[7,8,9]  --->[3,6,9]\\n\\n2. Then reverse the matrix.\\ne.g;\\n[1,4,7]  --->[7,4,1]\\n[2,5,8]  --->[8,5,2]\\n[3,6,9]  --->[9,6,3]"
                    },
                    {
                        "username": "Ankita_Rawat30",
                        "content": "So, I basically transposed the matrix and reversed each row. When I print the final matrix, it is the same as the expected output. But my actual output just shows the transposed version (which is wrong). What am I missing?\\n\\n `class Solution {\\npublic:\\n    void rotate(vector<vector<int>>& matrix) {\\n\\n        int n = matrix.size();\\n        vector<vector<int>> temp2 = matrix;\\n        for(int i=0; i<n; i++)\\n        {\\n            for(int j =n-1; j>=0; j--)\\n            {\\n                matrix[i][j]=temp2[j][i];\\n            }\\n        }\\n\\n\\n        for(int i=0; i<n; i++)\\n        {\\n            for(int j =n-1; j>=0; j--)\\n            {\\n                cout<<matrix[i][j]<<\" \";\\n            }\\n        }\\n\\n\\n    }\\n};` "
                    },
                    {
                        "username": "kenhaley",
                        "content": "I thought this was pretty simple.  Find every set of 4 pixels that need to be rotated and rotate them. (temp <- pixel1 <- pixel2 <-  pixel3 <- pixel4 <- temp.)  Then construct an outer loop that finds all the 4-pixel sets without duplication.  One of the few problems I got right on the first try."
                    },
                    {
                        "username": "YASH_SHARMA001",
                        "content": "matrixcolsize means?"
                    }
                ]
            },
            {
                "id": 1834477,
                "content": [
                    {
                        "username": "ranbir7",
                        "content": "I used Zip function in python to do it all,\\nsome years ago I had a huge difficulty solving this\\nbut these graph problems let me down this rabbit hole where I found the use of zip function.\\nIt really helped though."
                    },
                    {
                        "username": "rajat_sharma2809",
                        "content": "I try to transpose the matrix first by using the transpose( ) of numpy library then convert the numpy array to list. But in my final output the matrix is same as it is in the given input. Can anyone help!\\nimport numpy as np\\nmatrix = np.array(matrix)\\nmatrix = np.transpose(matrix)\\nmatrix = list(matrix)"
                    },
                    {
                        "username": "ranbir7",
                        "content": "we can use zip() of python to do it all in just 3 lines."
                    },
                    {
                        "username": "swati_dubey",
                        "content": "\\uD83D\\uDCAFTwo step to resolve this problem --->\\n1) take transpose of matrix and \\n2) reverse columns, row by row."
                    },
                    {
                        "username": "ashwanisharma72002",
                        "content": "the message say not to return anything but to update the existing \"matrix\"\\ni did this what is the issue here?? \\n\\nclass Solution:\\n    def rotate(self, matrix: List[List[int]]) -> None:\\n        \"\"\"\\n        Do not return anything, modify matrix in-place instead.\\n        \"\"\"\\n        # a=[[1,2,3,4],[5,6,7,8],[9,10,11,12],[13,14,15,16]]\\n        newlis=[]\\n        finlis=[]\\n        for j in range(len(matrix[0])):\\n            for i in range(len(matrix)-1,-1,-1):\\n                newlis.append(matrix[i][j])\\n        for i in range(len(matrix)):\\n            finlis.append ( newlis[0:len(matrix) ] )\\n            del(newlis[:len(matrix)])\\n        matrix=finlis"
                    },
                    {
                        "username": "miha4406",
                        "content": "My approach is: don't think there to put next element, think which element should be moved in this place. It's: matrix[i][j] = matrix[l-j][i];  \n// l = matrix.GetLength(0)-1;\nThen use recursion to replace 4 linked elements. \nStart recursion for all start elements, which are in case of Example 2 is: 5 1 9 4. This will rotate all the other elements linked to them."
                    },
                    {
                        "username": "zenfred",
                        "content": "The first solution I could think of uses _O(n)_ (or `n - 1`) extra storage. Will that pass in an interview? Remember, the description only disallows \"another 2D matrix\", which is _O(n^2)_ space."
                    },
                    {
                        "username": "Glory_Killer",
                        "content": "Very easy solution using below two concept\\n1. First transpose the matrix.\\ne.g;\\n[1,2,3]  --->[1,4,7]\\n[4,5,6]  --->[2,5,8]\\n[7,8,9]  --->[3,6,9]\\n\\n2. Then reverse the matrix.\\ne.g;\\n[1,4,7]  --->[7,4,1]\\n[2,5,8]  --->[8,5,2]\\n[3,6,9]  --->[9,6,3]"
                    },
                    {
                        "username": "Ankita_Rawat30",
                        "content": "So, I basically transposed the matrix and reversed each row. When I print the final matrix, it is the same as the expected output. But my actual output just shows the transposed version (which is wrong). What am I missing?\\n\\n `class Solution {\\npublic:\\n    void rotate(vector<vector<int>>& matrix) {\\n\\n        int n = matrix.size();\\n        vector<vector<int>> temp2 = matrix;\\n        for(int i=0; i<n; i++)\\n        {\\n            for(int j =n-1; j>=0; j--)\\n            {\\n                matrix[i][j]=temp2[j][i];\\n            }\\n        }\\n\\n\\n        for(int i=0; i<n; i++)\\n        {\\n            for(int j =n-1; j>=0; j--)\\n            {\\n                cout<<matrix[i][j]<<\" \";\\n            }\\n        }\\n\\n\\n    }\\n};` "
                    },
                    {
                        "username": "kenhaley",
                        "content": "I thought this was pretty simple.  Find every set of 4 pixels that need to be rotated and rotate them. (temp <- pixel1 <- pixel2 <-  pixel3 <- pixel4 <- temp.)  Then construct an outer loop that finds all the 4-pixel sets without duplication.  One of the few problems I got right on the first try."
                    },
                    {
                        "username": "YASH_SHARMA001",
                        "content": "matrixcolsize means?"
                    }
                ]
            },
            {
                "id": 1829524,
                "content": [
                    {
                        "username": "ranbir7",
                        "content": "I used Zip function in python to do it all,\\nsome years ago I had a huge difficulty solving this\\nbut these graph problems let me down this rabbit hole where I found the use of zip function.\\nIt really helped though."
                    },
                    {
                        "username": "rajat_sharma2809",
                        "content": "I try to transpose the matrix first by using the transpose( ) of numpy library then convert the numpy array to list. But in my final output the matrix is same as it is in the given input. Can anyone help!\\nimport numpy as np\\nmatrix = np.array(matrix)\\nmatrix = np.transpose(matrix)\\nmatrix = list(matrix)"
                    },
                    {
                        "username": "ranbir7",
                        "content": "we can use zip() of python to do it all in just 3 lines."
                    },
                    {
                        "username": "swati_dubey",
                        "content": "\\uD83D\\uDCAFTwo step to resolve this problem --->\\n1) take transpose of matrix and \\n2) reverse columns, row by row."
                    },
                    {
                        "username": "ashwanisharma72002",
                        "content": "the message say not to return anything but to update the existing \"matrix\"\\ni did this what is the issue here?? \\n\\nclass Solution:\\n    def rotate(self, matrix: List[List[int]]) -> None:\\n        \"\"\"\\n        Do not return anything, modify matrix in-place instead.\\n        \"\"\"\\n        # a=[[1,2,3,4],[5,6,7,8],[9,10,11,12],[13,14,15,16]]\\n        newlis=[]\\n        finlis=[]\\n        for j in range(len(matrix[0])):\\n            for i in range(len(matrix)-1,-1,-1):\\n                newlis.append(matrix[i][j])\\n        for i in range(len(matrix)):\\n            finlis.append ( newlis[0:len(matrix) ] )\\n            del(newlis[:len(matrix)])\\n        matrix=finlis"
                    },
                    {
                        "username": "miha4406",
                        "content": "My approach is: don't think there to put next element, think which element should be moved in this place. It's: matrix[i][j] = matrix[l-j][i];  \n// l = matrix.GetLength(0)-1;\nThen use recursion to replace 4 linked elements. \nStart recursion for all start elements, which are in case of Example 2 is: 5 1 9 4. This will rotate all the other elements linked to them."
                    },
                    {
                        "username": "zenfred",
                        "content": "The first solution I could think of uses _O(n)_ (or `n - 1`) extra storage. Will that pass in an interview? Remember, the description only disallows \"another 2D matrix\", which is _O(n^2)_ space."
                    },
                    {
                        "username": "Glory_Killer",
                        "content": "Very easy solution using below two concept\\n1. First transpose the matrix.\\ne.g;\\n[1,2,3]  --->[1,4,7]\\n[4,5,6]  --->[2,5,8]\\n[7,8,9]  --->[3,6,9]\\n\\n2. Then reverse the matrix.\\ne.g;\\n[1,4,7]  --->[7,4,1]\\n[2,5,8]  --->[8,5,2]\\n[3,6,9]  --->[9,6,3]"
                    },
                    {
                        "username": "Ankita_Rawat30",
                        "content": "So, I basically transposed the matrix and reversed each row. When I print the final matrix, it is the same as the expected output. But my actual output just shows the transposed version (which is wrong). What am I missing?\\n\\n `class Solution {\\npublic:\\n    void rotate(vector<vector<int>>& matrix) {\\n\\n        int n = matrix.size();\\n        vector<vector<int>> temp2 = matrix;\\n        for(int i=0; i<n; i++)\\n        {\\n            for(int j =n-1; j>=0; j--)\\n            {\\n                matrix[i][j]=temp2[j][i];\\n            }\\n        }\\n\\n\\n        for(int i=0; i<n; i++)\\n        {\\n            for(int j =n-1; j>=0; j--)\\n            {\\n                cout<<matrix[i][j]<<\" \";\\n            }\\n        }\\n\\n\\n    }\\n};` "
                    },
                    {
                        "username": "kenhaley",
                        "content": "I thought this was pretty simple.  Find every set of 4 pixels that need to be rotated and rotate them. (temp <- pixel1 <- pixel2 <-  pixel3 <- pixel4 <- temp.)  Then construct an outer loop that finds all the 4-pixel sets without duplication.  One of the few problems I got right on the first try."
                    },
                    {
                        "username": "YASH_SHARMA001",
                        "content": "matrixcolsize means?"
                    }
                ]
            },
            {
                "id": 1820118,
                "content": [
                    {
                        "username": "ranbir7",
                        "content": "I used Zip function in python to do it all,\\nsome years ago I had a huge difficulty solving this\\nbut these graph problems let me down this rabbit hole where I found the use of zip function.\\nIt really helped though."
                    },
                    {
                        "username": "rajat_sharma2809",
                        "content": "I try to transpose the matrix first by using the transpose( ) of numpy library then convert the numpy array to list. But in my final output the matrix is same as it is in the given input. Can anyone help!\\nimport numpy as np\\nmatrix = np.array(matrix)\\nmatrix = np.transpose(matrix)\\nmatrix = list(matrix)"
                    },
                    {
                        "username": "ranbir7",
                        "content": "we can use zip() of python to do it all in just 3 lines."
                    },
                    {
                        "username": "swati_dubey",
                        "content": "\\uD83D\\uDCAFTwo step to resolve this problem --->\\n1) take transpose of matrix and \\n2) reverse columns, row by row."
                    },
                    {
                        "username": "ashwanisharma72002",
                        "content": "the message say not to return anything but to update the existing \"matrix\"\\ni did this what is the issue here?? \\n\\nclass Solution:\\n    def rotate(self, matrix: List[List[int]]) -> None:\\n        \"\"\"\\n        Do not return anything, modify matrix in-place instead.\\n        \"\"\"\\n        # a=[[1,2,3,4],[5,6,7,8],[9,10,11,12],[13,14,15,16]]\\n        newlis=[]\\n        finlis=[]\\n        for j in range(len(matrix[0])):\\n            for i in range(len(matrix)-1,-1,-1):\\n                newlis.append(matrix[i][j])\\n        for i in range(len(matrix)):\\n            finlis.append ( newlis[0:len(matrix) ] )\\n            del(newlis[:len(matrix)])\\n        matrix=finlis"
                    },
                    {
                        "username": "miha4406",
                        "content": "My approach is: don't think there to put next element, think which element should be moved in this place. It's: matrix[i][j] = matrix[l-j][i];  \n// l = matrix.GetLength(0)-1;\nThen use recursion to replace 4 linked elements. \nStart recursion for all start elements, which are in case of Example 2 is: 5 1 9 4. This will rotate all the other elements linked to them."
                    },
                    {
                        "username": "zenfred",
                        "content": "The first solution I could think of uses _O(n)_ (or `n - 1`) extra storage. Will that pass in an interview? Remember, the description only disallows \"another 2D matrix\", which is _O(n^2)_ space."
                    },
                    {
                        "username": "Glory_Killer",
                        "content": "Very easy solution using below two concept\\n1. First transpose the matrix.\\ne.g;\\n[1,2,3]  --->[1,4,7]\\n[4,5,6]  --->[2,5,8]\\n[7,8,9]  --->[3,6,9]\\n\\n2. Then reverse the matrix.\\ne.g;\\n[1,4,7]  --->[7,4,1]\\n[2,5,8]  --->[8,5,2]\\n[3,6,9]  --->[9,6,3]"
                    },
                    {
                        "username": "Ankita_Rawat30",
                        "content": "So, I basically transposed the matrix and reversed each row. When I print the final matrix, it is the same as the expected output. But my actual output just shows the transposed version (which is wrong). What am I missing?\\n\\n `class Solution {\\npublic:\\n    void rotate(vector<vector<int>>& matrix) {\\n\\n        int n = matrix.size();\\n        vector<vector<int>> temp2 = matrix;\\n        for(int i=0; i<n; i++)\\n        {\\n            for(int j =n-1; j>=0; j--)\\n            {\\n                matrix[i][j]=temp2[j][i];\\n            }\\n        }\\n\\n\\n        for(int i=0; i<n; i++)\\n        {\\n            for(int j =n-1; j>=0; j--)\\n            {\\n                cout<<matrix[i][j]<<\" \";\\n            }\\n        }\\n\\n\\n    }\\n};` "
                    },
                    {
                        "username": "kenhaley",
                        "content": "I thought this was pretty simple.  Find every set of 4 pixels that need to be rotated and rotate them. (temp <- pixel1 <- pixel2 <-  pixel3 <- pixel4 <- temp.)  Then construct an outer loop that finds all the 4-pixel sets without duplication.  One of the few problems I got right on the first try."
                    },
                    {
                        "username": "YASH_SHARMA001",
                        "content": "matrixcolsize means?"
                    }
                ]
            },
            {
                "id": 1811982,
                "content": [
                    {
                        "username": "GovindSheshadri",
                        "content": "can we call this transpose of a matrix i am confused about this ? can anyone please telll?\\n"
                    },
                    {
                        "username": "benjsmyth",
                        "content": "`for row, col in enumerate(zip(*matrix)): matrix[row] = list(reversed(col))`\n\nbeats 98% in both time and space."
                    },
                    {
                        "username": "myyjx",
                        "content": "You only need to scan through the dataset with single pass and constant space, consider the following:\\nImage the matrix like an onion, with N layer of \"rings\", \\n1. for each layer, locate four points at the corner, and and interchange the values of these four points;\\n2. move on to the points clockwise to them and do the same;; \\n3. now you have reduced 1 layer and can move on to the next layer\\n4. recursively to solve the matrix with (n-2) dimension\\n* attached is the rust code\\n\\n ```\\n        let ml = matrix.len();\\n        let mut l_start = 0;\\n        let mut l_end = matrix.len() - 1;\\n        let mut n = matrix.len();\\n\\n        while n > 1 {\\n            for offset in l_start..l_end {\\n                // i-th point starting from top left to right\\n                let a = matrix[l_start][offset];\\n                // i-th point starting from top right to bottom right\\n                let b = matrix[offset][l_end];\\n                // i-th point starting from bottom right to bottom left\\n                let c = matrix[l_end][(ml - 1) - offset];\\n                // i-th point starting from bottom left to upper left\\n                let d = matrix[(ml - 1) - offset][l_start];\\n\\n                // swap the value\\n                matrix[l_start][offset] = d;\\n                matrix[offset][l_end] = a;\\n                matrix[l_end][ml - 1 - offset] = b;\\n                matrix[ml - 1 - offset][l_start] = c;\\n            }\\n            // decrement the dimension counter\\n            n -= 2;\\n            l_start += 1;\\n            l_end -= 1;\\n        }\\n```"
                    },
                    {
                        "username": "s1ttu",
                        "content": "just python thing \\n```\\ndef rotate(self, matrix: List[List[int]]) -> None:\\n    matrix[:] = [i[::-1] for i in zip(*matrix)]\\n```\\none line solution "
                    },
                    {
                        "username": "pr1524",
                        "content": "beats 100%\\n\\nvoid rotate(vector<vector<int>>& matrix) {\\n        int n = matrix.size();\\n        //transpose \\n        for(int i=0;i<n;i++){\\n            for(int j=0;j<i;j++){\\n                swap(matrix[i][j],matrix[j][i]);\\n            }\\n        }\\n        //reverse the column of each row\\n        for(int i=0;i<n;i++){\\n            for(int j=0;j<n/2;j++){\\n                swap(matrix[i][j],matrix[i][n-1-j]);\\n            }\\n        }\\n\\n\\n    }"
                    },
                    {
                        "username": "nitheeshtangellapally4",
                        "content": "class Solution {\\npublic:\\n    void rotate(vector<vector<int>>& a) {\\n        int n= a.size();\\n        for(int i=0;i<n;i++){\\n            for(int j=0;j<n;j++){\\n                swap(a[i][j],a[j][i]);\\n            }\\n        }\\n        for(int i=0;i<n/2;i++){\\n            for(int j=0;j<n;j++){\\n                swap(a[j][i],a[j][n-i-1]);\\n            }\\n        }\\n    }\\n};\\ncan someone explain why does this solution doesn\\'t work"
                    },
                    {
                        "username": "ComradeAndrew",
                        "content": "Here is the explanation in 3 steps to create an algorithm in 3 methods\n\n### 1. Rotate index by 90 degrees\nTo rotate an index by 90 degrees, we can transform a problem into linear algebra and treating indices as vector dimensions.\nIn order to rotate a vector around middle of the matrix (n/2, n/2) coordinates, we can use the following formula:\n```\n# First consider rotation around 0,0 coordinates\ntheta = deg2rad(angle);\n\ncs = cos(theta);\nsn = sin(theta);\n\nx = x * cs - y * sn; // now x is something different than original vector x\ny = x * sn + y * cs;\n# In short form cs and sn for 90 degrees would simplify as\nx = -y\ny = x\n# But y is inverted for matrix, thus we need to rotate the other direction (-90 degrees)\nx = y\ny = -x\n```\nNow we need to shift the coordinates, so rotation will happen around (n/2,n/2) index.\n```\nx' = y\ny' = int(-(x-mid)+mid)   # and shift the coordinates back\n```\nMiddle index would be shifted by -1 since we start indexing from 0. Thus `(n-1)/2 = n/2 - .5`\n\nWe implement this in `rotate_index90` method.\n\n### 2. Traverse rotation path\nBy following the path of rotation from index (0,0) we can see that it does a full turn after 4 rotations (90deg*4=360deg). The traversed path creates a cyclic graph: `(0,0) -> (0,n) -> (n,n) -> (n,0) -> (0,0) [cycle]`.\n*Also, note as we start from any of the indices from the path - we will traverse the whole path. Thus we only need one index from any given path to traverse the whole matrix.*\n\nInside `rotate_path` method we traverse the whole cycle and replace the value with a previous matrix value from the path, thus rotating 90 degrees all elements of the matrix laying on the path.\n\n### 3. Traversing paths from quoter of the matrix\nAs we traverse the path of the rotation, we go make a turn 4 times, thus all paths will have 4 nodes within the path. Since we need only the starting element we will need to consider only a quoter of the matrix. As we can see by the example of the matrix below, which shows all starting indexes from the first quoter of the matrix, we only need elements with a triangle of from top to middle of the matrix.\n```\n—————————————————————————————————————————\n|0,9|1,9|2,9|3,9|4,9|5,9|6,9|7,9|8,9|   |\n—————————————————————————————————————————\n|   |1,8|2,8|3,8|4,8|5,8|6,8|7,8|   |   |\n—————————————————————————————————————————\n|   |   |2,7|3,7|4,7|5,7|6,7|   |   |   |\n—————————————————————————————————————————\n|   |   |   |3,6|4,6|5,6|   |   |   |   |\n—————————————————————————————————————————\n|   |   |   |   |4,5|   |   |   |   |   |\n—————————————————————————————————————————\n|   |   |   |   |   |   |   |   |   |   |\n—————————————————————————————————————————\n|   |   |   |   |   |   |   |   |   |   |\n—————————————————————————————————————————\n|   |   |   |   |   |   |   |   |   |   |\n—————————————————————————————————————————\n|   |   |   |   |   |   |   |   |   |   |\n—————————————————————————————————————————\n|   |   |   |   |   |   |   |   |   |   |\n—————————————————————————————————————————\n```\nThe following traversing is implemented in `rotate` method.\n\nI hope that helps :)"
                    },
                    {
                        "username": "biniyamT",
                        "content": "it is all about reverse matrix and transpose it by swapping row and columns."
                    },
                    {
                        "username": "ankush920",
                        "content": "Beat 100% in  T.C. ???  ,Very easy and readable code .\\n\\nclass Solution {\\npublic:\\n    void rotate(vector<vector<int>>& matrix) {\\n        int n = matrix.size(); \\n       \\n         \\n         for( int i = 0 ;i<n ;i++)\\n         {\\n              for( int j=0 ; j<n ;j++)\\n              {\\n                   if( i>j)\\n                   {\\n                        swap( matrix[i][j], matrix[j][i]);\\n\\n                   }\\n\\n\\n              }\\n         }\\n        \\n\\n        for( int i = 0 ; i<n ;i++)\\n        {\\n             reverse(matrix[i].begin(), matrix[i].end());\\n        }\\n    }\\n};"
                    },
                    {
                        "username": "mk2122",
                        "content": "what is issue if traversing one matrix and storing the indices of places where value is zero(o(mn) )and again traversing matrix and making 0 in the row and column at that indexs (o(m+n)) "
                    }
                ]
            },
            {
                "id": 1811208,
                "content": [
                    {
                        "username": "GovindSheshadri",
                        "content": "can we call this transpose of a matrix i am confused about this ? can anyone please telll?\\n"
                    },
                    {
                        "username": "benjsmyth",
                        "content": "`for row, col in enumerate(zip(*matrix)): matrix[row] = list(reversed(col))`\n\nbeats 98% in both time and space."
                    },
                    {
                        "username": "myyjx",
                        "content": "You only need to scan through the dataset with single pass and constant space, consider the following:\\nImage the matrix like an onion, with N layer of \"rings\", \\n1. for each layer, locate four points at the corner, and and interchange the values of these four points;\\n2. move on to the points clockwise to them and do the same;; \\n3. now you have reduced 1 layer and can move on to the next layer\\n4. recursively to solve the matrix with (n-2) dimension\\n* attached is the rust code\\n\\n ```\\n        let ml = matrix.len();\\n        let mut l_start = 0;\\n        let mut l_end = matrix.len() - 1;\\n        let mut n = matrix.len();\\n\\n        while n > 1 {\\n            for offset in l_start..l_end {\\n                // i-th point starting from top left to right\\n                let a = matrix[l_start][offset];\\n                // i-th point starting from top right to bottom right\\n                let b = matrix[offset][l_end];\\n                // i-th point starting from bottom right to bottom left\\n                let c = matrix[l_end][(ml - 1) - offset];\\n                // i-th point starting from bottom left to upper left\\n                let d = matrix[(ml - 1) - offset][l_start];\\n\\n                // swap the value\\n                matrix[l_start][offset] = d;\\n                matrix[offset][l_end] = a;\\n                matrix[l_end][ml - 1 - offset] = b;\\n                matrix[ml - 1 - offset][l_start] = c;\\n            }\\n            // decrement the dimension counter\\n            n -= 2;\\n            l_start += 1;\\n            l_end -= 1;\\n        }\\n```"
                    },
                    {
                        "username": "s1ttu",
                        "content": "just python thing \\n```\\ndef rotate(self, matrix: List[List[int]]) -> None:\\n    matrix[:] = [i[::-1] for i in zip(*matrix)]\\n```\\none line solution "
                    },
                    {
                        "username": "pr1524",
                        "content": "beats 100%\\n\\nvoid rotate(vector<vector<int>>& matrix) {\\n        int n = matrix.size();\\n        //transpose \\n        for(int i=0;i<n;i++){\\n            for(int j=0;j<i;j++){\\n                swap(matrix[i][j],matrix[j][i]);\\n            }\\n        }\\n        //reverse the column of each row\\n        for(int i=0;i<n;i++){\\n            for(int j=0;j<n/2;j++){\\n                swap(matrix[i][j],matrix[i][n-1-j]);\\n            }\\n        }\\n\\n\\n    }"
                    },
                    {
                        "username": "nitheeshtangellapally4",
                        "content": "class Solution {\\npublic:\\n    void rotate(vector<vector<int>>& a) {\\n        int n= a.size();\\n        for(int i=0;i<n;i++){\\n            for(int j=0;j<n;j++){\\n                swap(a[i][j],a[j][i]);\\n            }\\n        }\\n        for(int i=0;i<n/2;i++){\\n            for(int j=0;j<n;j++){\\n                swap(a[j][i],a[j][n-i-1]);\\n            }\\n        }\\n    }\\n};\\ncan someone explain why does this solution doesn\\'t work"
                    },
                    {
                        "username": "ComradeAndrew",
                        "content": "Here is the explanation in 3 steps to create an algorithm in 3 methods\n\n### 1. Rotate index by 90 degrees\nTo rotate an index by 90 degrees, we can transform a problem into linear algebra and treating indices as vector dimensions.\nIn order to rotate a vector around middle of the matrix (n/2, n/2) coordinates, we can use the following formula:\n```\n# First consider rotation around 0,0 coordinates\ntheta = deg2rad(angle);\n\ncs = cos(theta);\nsn = sin(theta);\n\nx = x * cs - y * sn; // now x is something different than original vector x\ny = x * sn + y * cs;\n# In short form cs and sn for 90 degrees would simplify as\nx = -y\ny = x\n# But y is inverted for matrix, thus we need to rotate the other direction (-90 degrees)\nx = y\ny = -x\n```\nNow we need to shift the coordinates, so rotation will happen around (n/2,n/2) index.\n```\nx' = y\ny' = int(-(x-mid)+mid)   # and shift the coordinates back\n```\nMiddle index would be shifted by -1 since we start indexing from 0. Thus `(n-1)/2 = n/2 - .5`\n\nWe implement this in `rotate_index90` method.\n\n### 2. Traverse rotation path\nBy following the path of rotation from index (0,0) we can see that it does a full turn after 4 rotations (90deg*4=360deg). The traversed path creates a cyclic graph: `(0,0) -> (0,n) -> (n,n) -> (n,0) -> (0,0) [cycle]`.\n*Also, note as we start from any of the indices from the path - we will traverse the whole path. Thus we only need one index from any given path to traverse the whole matrix.*\n\nInside `rotate_path` method we traverse the whole cycle and replace the value with a previous matrix value from the path, thus rotating 90 degrees all elements of the matrix laying on the path.\n\n### 3. Traversing paths from quoter of the matrix\nAs we traverse the path of the rotation, we go make a turn 4 times, thus all paths will have 4 nodes within the path. Since we need only the starting element we will need to consider only a quoter of the matrix. As we can see by the example of the matrix below, which shows all starting indexes from the first quoter of the matrix, we only need elements with a triangle of from top to middle of the matrix.\n```\n—————————————————————————————————————————\n|0,9|1,9|2,9|3,9|4,9|5,9|6,9|7,9|8,9|   |\n—————————————————————————————————————————\n|   |1,8|2,8|3,8|4,8|5,8|6,8|7,8|   |   |\n—————————————————————————————————————————\n|   |   |2,7|3,7|4,7|5,7|6,7|   |   |   |\n—————————————————————————————————————————\n|   |   |   |3,6|4,6|5,6|   |   |   |   |\n—————————————————————————————————————————\n|   |   |   |   |4,5|   |   |   |   |   |\n—————————————————————————————————————————\n|   |   |   |   |   |   |   |   |   |   |\n—————————————————————————————————————————\n|   |   |   |   |   |   |   |   |   |   |\n—————————————————————————————————————————\n|   |   |   |   |   |   |   |   |   |   |\n—————————————————————————————————————————\n|   |   |   |   |   |   |   |   |   |   |\n—————————————————————————————————————————\n|   |   |   |   |   |   |   |   |   |   |\n—————————————————————————————————————————\n```\nThe following traversing is implemented in `rotate` method.\n\nI hope that helps :)"
                    },
                    {
                        "username": "biniyamT",
                        "content": "it is all about reverse matrix and transpose it by swapping row and columns."
                    },
                    {
                        "username": "ankush920",
                        "content": "Beat 100% in  T.C. ???  ,Very easy and readable code .\\n\\nclass Solution {\\npublic:\\n    void rotate(vector<vector<int>>& matrix) {\\n        int n = matrix.size(); \\n       \\n         \\n         for( int i = 0 ;i<n ;i++)\\n         {\\n              for( int j=0 ; j<n ;j++)\\n              {\\n                   if( i>j)\\n                   {\\n                        swap( matrix[i][j], matrix[j][i]);\\n\\n                   }\\n\\n\\n              }\\n         }\\n        \\n\\n        for( int i = 0 ; i<n ;i++)\\n        {\\n             reverse(matrix[i].begin(), matrix[i].end());\\n        }\\n    }\\n};"
                    },
                    {
                        "username": "mk2122",
                        "content": "what is issue if traversing one matrix and storing the indices of places where value is zero(o(mn) )and again traversing matrix and making 0 in the row and column at that indexs (o(m+n)) "
                    }
                ]
            },
            {
                "id": 1804563,
                "content": [
                    {
                        "username": "GovindSheshadri",
                        "content": "can we call this transpose of a matrix i am confused about this ? can anyone please telll?\\n"
                    },
                    {
                        "username": "benjsmyth",
                        "content": "`for row, col in enumerate(zip(*matrix)): matrix[row] = list(reversed(col))`\n\nbeats 98% in both time and space."
                    },
                    {
                        "username": "myyjx",
                        "content": "You only need to scan through the dataset with single pass and constant space, consider the following:\\nImage the matrix like an onion, with N layer of \"rings\", \\n1. for each layer, locate four points at the corner, and and interchange the values of these four points;\\n2. move on to the points clockwise to them and do the same;; \\n3. now you have reduced 1 layer and can move on to the next layer\\n4. recursively to solve the matrix with (n-2) dimension\\n* attached is the rust code\\n\\n ```\\n        let ml = matrix.len();\\n        let mut l_start = 0;\\n        let mut l_end = matrix.len() - 1;\\n        let mut n = matrix.len();\\n\\n        while n > 1 {\\n            for offset in l_start..l_end {\\n                // i-th point starting from top left to right\\n                let a = matrix[l_start][offset];\\n                // i-th point starting from top right to bottom right\\n                let b = matrix[offset][l_end];\\n                // i-th point starting from bottom right to bottom left\\n                let c = matrix[l_end][(ml - 1) - offset];\\n                // i-th point starting from bottom left to upper left\\n                let d = matrix[(ml - 1) - offset][l_start];\\n\\n                // swap the value\\n                matrix[l_start][offset] = d;\\n                matrix[offset][l_end] = a;\\n                matrix[l_end][ml - 1 - offset] = b;\\n                matrix[ml - 1 - offset][l_start] = c;\\n            }\\n            // decrement the dimension counter\\n            n -= 2;\\n            l_start += 1;\\n            l_end -= 1;\\n        }\\n```"
                    },
                    {
                        "username": "s1ttu",
                        "content": "just python thing \\n```\\ndef rotate(self, matrix: List[List[int]]) -> None:\\n    matrix[:] = [i[::-1] for i in zip(*matrix)]\\n```\\none line solution "
                    },
                    {
                        "username": "pr1524",
                        "content": "beats 100%\\n\\nvoid rotate(vector<vector<int>>& matrix) {\\n        int n = matrix.size();\\n        //transpose \\n        for(int i=0;i<n;i++){\\n            for(int j=0;j<i;j++){\\n                swap(matrix[i][j],matrix[j][i]);\\n            }\\n        }\\n        //reverse the column of each row\\n        for(int i=0;i<n;i++){\\n            for(int j=0;j<n/2;j++){\\n                swap(matrix[i][j],matrix[i][n-1-j]);\\n            }\\n        }\\n\\n\\n    }"
                    },
                    {
                        "username": "nitheeshtangellapally4",
                        "content": "class Solution {\\npublic:\\n    void rotate(vector<vector<int>>& a) {\\n        int n= a.size();\\n        for(int i=0;i<n;i++){\\n            for(int j=0;j<n;j++){\\n                swap(a[i][j],a[j][i]);\\n            }\\n        }\\n        for(int i=0;i<n/2;i++){\\n            for(int j=0;j<n;j++){\\n                swap(a[j][i],a[j][n-i-1]);\\n            }\\n        }\\n    }\\n};\\ncan someone explain why does this solution doesn\\'t work"
                    },
                    {
                        "username": "ComradeAndrew",
                        "content": "Here is the explanation in 3 steps to create an algorithm in 3 methods\n\n### 1. Rotate index by 90 degrees\nTo rotate an index by 90 degrees, we can transform a problem into linear algebra and treating indices as vector dimensions.\nIn order to rotate a vector around middle of the matrix (n/2, n/2) coordinates, we can use the following formula:\n```\n# First consider rotation around 0,0 coordinates\ntheta = deg2rad(angle);\n\ncs = cos(theta);\nsn = sin(theta);\n\nx = x * cs - y * sn; // now x is something different than original vector x\ny = x * sn + y * cs;\n# In short form cs and sn for 90 degrees would simplify as\nx = -y\ny = x\n# But y is inverted for matrix, thus we need to rotate the other direction (-90 degrees)\nx = y\ny = -x\n```\nNow we need to shift the coordinates, so rotation will happen around (n/2,n/2) index.\n```\nx' = y\ny' = int(-(x-mid)+mid)   # and shift the coordinates back\n```\nMiddle index would be shifted by -1 since we start indexing from 0. Thus `(n-1)/2 = n/2 - .5`\n\nWe implement this in `rotate_index90` method.\n\n### 2. Traverse rotation path\nBy following the path of rotation from index (0,0) we can see that it does a full turn after 4 rotations (90deg*4=360deg). The traversed path creates a cyclic graph: `(0,0) -> (0,n) -> (n,n) -> (n,0) -> (0,0) [cycle]`.\n*Also, note as we start from any of the indices from the path - we will traverse the whole path. Thus we only need one index from any given path to traverse the whole matrix.*\n\nInside `rotate_path` method we traverse the whole cycle and replace the value with a previous matrix value from the path, thus rotating 90 degrees all elements of the matrix laying on the path.\n\n### 3. Traversing paths from quoter of the matrix\nAs we traverse the path of the rotation, we go make a turn 4 times, thus all paths will have 4 nodes within the path. Since we need only the starting element we will need to consider only a quoter of the matrix. As we can see by the example of the matrix below, which shows all starting indexes from the first quoter of the matrix, we only need elements with a triangle of from top to middle of the matrix.\n```\n—————————————————————————————————————————\n|0,9|1,9|2,9|3,9|4,9|5,9|6,9|7,9|8,9|   |\n—————————————————————————————————————————\n|   |1,8|2,8|3,8|4,8|5,8|6,8|7,8|   |   |\n—————————————————————————————————————————\n|   |   |2,7|3,7|4,7|5,7|6,7|   |   |   |\n—————————————————————————————————————————\n|   |   |   |3,6|4,6|5,6|   |   |   |   |\n—————————————————————————————————————————\n|   |   |   |   |4,5|   |   |   |   |   |\n—————————————————————————————————————————\n|   |   |   |   |   |   |   |   |   |   |\n—————————————————————————————————————————\n|   |   |   |   |   |   |   |   |   |   |\n—————————————————————————————————————————\n|   |   |   |   |   |   |   |   |   |   |\n—————————————————————————————————————————\n|   |   |   |   |   |   |   |   |   |   |\n—————————————————————————————————————————\n|   |   |   |   |   |   |   |   |   |   |\n—————————————————————————————————————————\n```\nThe following traversing is implemented in `rotate` method.\n\nI hope that helps :)"
                    },
                    {
                        "username": "biniyamT",
                        "content": "it is all about reverse matrix and transpose it by swapping row and columns."
                    },
                    {
                        "username": "ankush920",
                        "content": "Beat 100% in  T.C. ???  ,Very easy and readable code .\\n\\nclass Solution {\\npublic:\\n    void rotate(vector<vector<int>>& matrix) {\\n        int n = matrix.size(); \\n       \\n         \\n         for( int i = 0 ;i<n ;i++)\\n         {\\n              for( int j=0 ; j<n ;j++)\\n              {\\n                   if( i>j)\\n                   {\\n                        swap( matrix[i][j], matrix[j][i]);\\n\\n                   }\\n\\n\\n              }\\n         }\\n        \\n\\n        for( int i = 0 ; i<n ;i++)\\n        {\\n             reverse(matrix[i].begin(), matrix[i].end());\\n        }\\n    }\\n};"
                    },
                    {
                        "username": "mk2122",
                        "content": "what is issue if traversing one matrix and storing the indices of places where value is zero(o(mn) )and again traversing matrix and making 0 in the row and column at that indexs (o(m+n)) "
                    }
                ]
            },
            {
                "id": 1804441,
                "content": [
                    {
                        "username": "GovindSheshadri",
                        "content": "can we call this transpose of a matrix i am confused about this ? can anyone please telll?\\n"
                    },
                    {
                        "username": "benjsmyth",
                        "content": "`for row, col in enumerate(zip(*matrix)): matrix[row] = list(reversed(col))`\n\nbeats 98% in both time and space."
                    },
                    {
                        "username": "myyjx",
                        "content": "You only need to scan through the dataset with single pass and constant space, consider the following:\\nImage the matrix like an onion, with N layer of \"rings\", \\n1. for each layer, locate four points at the corner, and and interchange the values of these four points;\\n2. move on to the points clockwise to them and do the same;; \\n3. now you have reduced 1 layer and can move on to the next layer\\n4. recursively to solve the matrix with (n-2) dimension\\n* attached is the rust code\\n\\n ```\\n        let ml = matrix.len();\\n        let mut l_start = 0;\\n        let mut l_end = matrix.len() - 1;\\n        let mut n = matrix.len();\\n\\n        while n > 1 {\\n            for offset in l_start..l_end {\\n                // i-th point starting from top left to right\\n                let a = matrix[l_start][offset];\\n                // i-th point starting from top right to bottom right\\n                let b = matrix[offset][l_end];\\n                // i-th point starting from bottom right to bottom left\\n                let c = matrix[l_end][(ml - 1) - offset];\\n                // i-th point starting from bottom left to upper left\\n                let d = matrix[(ml - 1) - offset][l_start];\\n\\n                // swap the value\\n                matrix[l_start][offset] = d;\\n                matrix[offset][l_end] = a;\\n                matrix[l_end][ml - 1 - offset] = b;\\n                matrix[ml - 1 - offset][l_start] = c;\\n            }\\n            // decrement the dimension counter\\n            n -= 2;\\n            l_start += 1;\\n            l_end -= 1;\\n        }\\n```"
                    },
                    {
                        "username": "s1ttu",
                        "content": "just python thing \\n```\\ndef rotate(self, matrix: List[List[int]]) -> None:\\n    matrix[:] = [i[::-1] for i in zip(*matrix)]\\n```\\none line solution "
                    },
                    {
                        "username": "pr1524",
                        "content": "beats 100%\\n\\nvoid rotate(vector<vector<int>>& matrix) {\\n        int n = matrix.size();\\n        //transpose \\n        for(int i=0;i<n;i++){\\n            for(int j=0;j<i;j++){\\n                swap(matrix[i][j],matrix[j][i]);\\n            }\\n        }\\n        //reverse the column of each row\\n        for(int i=0;i<n;i++){\\n            for(int j=0;j<n/2;j++){\\n                swap(matrix[i][j],matrix[i][n-1-j]);\\n            }\\n        }\\n\\n\\n    }"
                    },
                    {
                        "username": "nitheeshtangellapally4",
                        "content": "class Solution {\\npublic:\\n    void rotate(vector<vector<int>>& a) {\\n        int n= a.size();\\n        for(int i=0;i<n;i++){\\n            for(int j=0;j<n;j++){\\n                swap(a[i][j],a[j][i]);\\n            }\\n        }\\n        for(int i=0;i<n/2;i++){\\n            for(int j=0;j<n;j++){\\n                swap(a[j][i],a[j][n-i-1]);\\n            }\\n        }\\n    }\\n};\\ncan someone explain why does this solution doesn\\'t work"
                    },
                    {
                        "username": "ComradeAndrew",
                        "content": "Here is the explanation in 3 steps to create an algorithm in 3 methods\n\n### 1. Rotate index by 90 degrees\nTo rotate an index by 90 degrees, we can transform a problem into linear algebra and treating indices as vector dimensions.\nIn order to rotate a vector around middle of the matrix (n/2, n/2) coordinates, we can use the following formula:\n```\n# First consider rotation around 0,0 coordinates\ntheta = deg2rad(angle);\n\ncs = cos(theta);\nsn = sin(theta);\n\nx = x * cs - y * sn; // now x is something different than original vector x\ny = x * sn + y * cs;\n# In short form cs and sn for 90 degrees would simplify as\nx = -y\ny = x\n# But y is inverted for matrix, thus we need to rotate the other direction (-90 degrees)\nx = y\ny = -x\n```\nNow we need to shift the coordinates, so rotation will happen around (n/2,n/2) index.\n```\nx' = y\ny' = int(-(x-mid)+mid)   # and shift the coordinates back\n```\nMiddle index would be shifted by -1 since we start indexing from 0. Thus `(n-1)/2 = n/2 - .5`\n\nWe implement this in `rotate_index90` method.\n\n### 2. Traverse rotation path\nBy following the path of rotation from index (0,0) we can see that it does a full turn after 4 rotations (90deg*4=360deg). The traversed path creates a cyclic graph: `(0,0) -> (0,n) -> (n,n) -> (n,0) -> (0,0) [cycle]`.\n*Also, note as we start from any of the indices from the path - we will traverse the whole path. Thus we only need one index from any given path to traverse the whole matrix.*\n\nInside `rotate_path` method we traverse the whole cycle and replace the value with a previous matrix value from the path, thus rotating 90 degrees all elements of the matrix laying on the path.\n\n### 3. Traversing paths from quoter of the matrix\nAs we traverse the path of the rotation, we go make a turn 4 times, thus all paths will have 4 nodes within the path. Since we need only the starting element we will need to consider only a quoter of the matrix. As we can see by the example of the matrix below, which shows all starting indexes from the first quoter of the matrix, we only need elements with a triangle of from top to middle of the matrix.\n```\n—————————————————————————————————————————\n|0,9|1,9|2,9|3,9|4,9|5,9|6,9|7,9|8,9|   |\n—————————————————————————————————————————\n|   |1,8|2,8|3,8|4,8|5,8|6,8|7,8|   |   |\n—————————————————————————————————————————\n|   |   |2,7|3,7|4,7|5,7|6,7|   |   |   |\n—————————————————————————————————————————\n|   |   |   |3,6|4,6|5,6|   |   |   |   |\n—————————————————————————————————————————\n|   |   |   |   |4,5|   |   |   |   |   |\n—————————————————————————————————————————\n|   |   |   |   |   |   |   |   |   |   |\n—————————————————————————————————————————\n|   |   |   |   |   |   |   |   |   |   |\n—————————————————————————————————————————\n|   |   |   |   |   |   |   |   |   |   |\n—————————————————————————————————————————\n|   |   |   |   |   |   |   |   |   |   |\n—————————————————————————————————————————\n|   |   |   |   |   |   |   |   |   |   |\n—————————————————————————————————————————\n```\nThe following traversing is implemented in `rotate` method.\n\nI hope that helps :)"
                    },
                    {
                        "username": "biniyamT",
                        "content": "it is all about reverse matrix and transpose it by swapping row and columns."
                    },
                    {
                        "username": "ankush920",
                        "content": "Beat 100% in  T.C. ???  ,Very easy and readable code .\\n\\nclass Solution {\\npublic:\\n    void rotate(vector<vector<int>>& matrix) {\\n        int n = matrix.size(); \\n       \\n         \\n         for( int i = 0 ;i<n ;i++)\\n         {\\n              for( int j=0 ; j<n ;j++)\\n              {\\n                   if( i>j)\\n                   {\\n                        swap( matrix[i][j], matrix[j][i]);\\n\\n                   }\\n\\n\\n              }\\n         }\\n        \\n\\n        for( int i = 0 ; i<n ;i++)\\n        {\\n             reverse(matrix[i].begin(), matrix[i].end());\\n        }\\n    }\\n};"
                    },
                    {
                        "username": "mk2122",
                        "content": "what is issue if traversing one matrix and storing the indices of places where value is zero(o(mn) )and again traversing matrix and making 0 in the row and column at that indexs (o(m+n)) "
                    }
                ]
            },
            {
                "id": 1799393,
                "content": [
                    {
                        "username": "GovindSheshadri",
                        "content": "can we call this transpose of a matrix i am confused about this ? can anyone please telll?\\n"
                    },
                    {
                        "username": "benjsmyth",
                        "content": "`for row, col in enumerate(zip(*matrix)): matrix[row] = list(reversed(col))`\n\nbeats 98% in both time and space."
                    },
                    {
                        "username": "myyjx",
                        "content": "You only need to scan through the dataset with single pass and constant space, consider the following:\\nImage the matrix like an onion, with N layer of \"rings\", \\n1. for each layer, locate four points at the corner, and and interchange the values of these four points;\\n2. move on to the points clockwise to them and do the same;; \\n3. now you have reduced 1 layer and can move on to the next layer\\n4. recursively to solve the matrix with (n-2) dimension\\n* attached is the rust code\\n\\n ```\\n        let ml = matrix.len();\\n        let mut l_start = 0;\\n        let mut l_end = matrix.len() - 1;\\n        let mut n = matrix.len();\\n\\n        while n > 1 {\\n            for offset in l_start..l_end {\\n                // i-th point starting from top left to right\\n                let a = matrix[l_start][offset];\\n                // i-th point starting from top right to bottom right\\n                let b = matrix[offset][l_end];\\n                // i-th point starting from bottom right to bottom left\\n                let c = matrix[l_end][(ml - 1) - offset];\\n                // i-th point starting from bottom left to upper left\\n                let d = matrix[(ml - 1) - offset][l_start];\\n\\n                // swap the value\\n                matrix[l_start][offset] = d;\\n                matrix[offset][l_end] = a;\\n                matrix[l_end][ml - 1 - offset] = b;\\n                matrix[ml - 1 - offset][l_start] = c;\\n            }\\n            // decrement the dimension counter\\n            n -= 2;\\n            l_start += 1;\\n            l_end -= 1;\\n        }\\n```"
                    },
                    {
                        "username": "s1ttu",
                        "content": "just python thing \\n```\\ndef rotate(self, matrix: List[List[int]]) -> None:\\n    matrix[:] = [i[::-1] for i in zip(*matrix)]\\n```\\none line solution "
                    },
                    {
                        "username": "pr1524",
                        "content": "beats 100%\\n\\nvoid rotate(vector<vector<int>>& matrix) {\\n        int n = matrix.size();\\n        //transpose \\n        for(int i=0;i<n;i++){\\n            for(int j=0;j<i;j++){\\n                swap(matrix[i][j],matrix[j][i]);\\n            }\\n        }\\n        //reverse the column of each row\\n        for(int i=0;i<n;i++){\\n            for(int j=0;j<n/2;j++){\\n                swap(matrix[i][j],matrix[i][n-1-j]);\\n            }\\n        }\\n\\n\\n    }"
                    },
                    {
                        "username": "nitheeshtangellapally4",
                        "content": "class Solution {\\npublic:\\n    void rotate(vector<vector<int>>& a) {\\n        int n= a.size();\\n        for(int i=0;i<n;i++){\\n            for(int j=0;j<n;j++){\\n                swap(a[i][j],a[j][i]);\\n            }\\n        }\\n        for(int i=0;i<n/2;i++){\\n            for(int j=0;j<n;j++){\\n                swap(a[j][i],a[j][n-i-1]);\\n            }\\n        }\\n    }\\n};\\ncan someone explain why does this solution doesn\\'t work"
                    },
                    {
                        "username": "ComradeAndrew",
                        "content": "Here is the explanation in 3 steps to create an algorithm in 3 methods\n\n### 1. Rotate index by 90 degrees\nTo rotate an index by 90 degrees, we can transform a problem into linear algebra and treating indices as vector dimensions.\nIn order to rotate a vector around middle of the matrix (n/2, n/2) coordinates, we can use the following formula:\n```\n# First consider rotation around 0,0 coordinates\ntheta = deg2rad(angle);\n\ncs = cos(theta);\nsn = sin(theta);\n\nx = x * cs - y * sn; // now x is something different than original vector x\ny = x * sn + y * cs;\n# In short form cs and sn for 90 degrees would simplify as\nx = -y\ny = x\n# But y is inverted for matrix, thus we need to rotate the other direction (-90 degrees)\nx = y\ny = -x\n```\nNow we need to shift the coordinates, so rotation will happen around (n/2,n/2) index.\n```\nx' = y\ny' = int(-(x-mid)+mid)   # and shift the coordinates back\n```\nMiddle index would be shifted by -1 since we start indexing from 0. Thus `(n-1)/2 = n/2 - .5`\n\nWe implement this in `rotate_index90` method.\n\n### 2. Traverse rotation path\nBy following the path of rotation from index (0,0) we can see that it does a full turn after 4 rotations (90deg*4=360deg). The traversed path creates a cyclic graph: `(0,0) -> (0,n) -> (n,n) -> (n,0) -> (0,0) [cycle]`.\n*Also, note as we start from any of the indices from the path - we will traverse the whole path. Thus we only need one index from any given path to traverse the whole matrix.*\n\nInside `rotate_path` method we traverse the whole cycle and replace the value with a previous matrix value from the path, thus rotating 90 degrees all elements of the matrix laying on the path.\n\n### 3. Traversing paths from quoter of the matrix\nAs we traverse the path of the rotation, we go make a turn 4 times, thus all paths will have 4 nodes within the path. Since we need only the starting element we will need to consider only a quoter of the matrix. As we can see by the example of the matrix below, which shows all starting indexes from the first quoter of the matrix, we only need elements with a triangle of from top to middle of the matrix.\n```\n—————————————————————————————————————————\n|0,9|1,9|2,9|3,9|4,9|5,9|6,9|7,9|8,9|   |\n—————————————————————————————————————————\n|   |1,8|2,8|3,8|4,8|5,8|6,8|7,8|   |   |\n—————————————————————————————————————————\n|   |   |2,7|3,7|4,7|5,7|6,7|   |   |   |\n—————————————————————————————————————————\n|   |   |   |3,6|4,6|5,6|   |   |   |   |\n—————————————————————————————————————————\n|   |   |   |   |4,5|   |   |   |   |   |\n—————————————————————————————————————————\n|   |   |   |   |   |   |   |   |   |   |\n—————————————————————————————————————————\n|   |   |   |   |   |   |   |   |   |   |\n—————————————————————————————————————————\n|   |   |   |   |   |   |   |   |   |   |\n—————————————————————————————————————————\n|   |   |   |   |   |   |   |   |   |   |\n—————————————————————————————————————————\n|   |   |   |   |   |   |   |   |   |   |\n—————————————————————————————————————————\n```\nThe following traversing is implemented in `rotate` method.\n\nI hope that helps :)"
                    },
                    {
                        "username": "biniyamT",
                        "content": "it is all about reverse matrix and transpose it by swapping row and columns."
                    },
                    {
                        "username": "ankush920",
                        "content": "Beat 100% in  T.C. ???  ,Very easy and readable code .\\n\\nclass Solution {\\npublic:\\n    void rotate(vector<vector<int>>& matrix) {\\n        int n = matrix.size(); \\n       \\n         \\n         for( int i = 0 ;i<n ;i++)\\n         {\\n              for( int j=0 ; j<n ;j++)\\n              {\\n                   if( i>j)\\n                   {\\n                        swap( matrix[i][j], matrix[j][i]);\\n\\n                   }\\n\\n\\n              }\\n         }\\n        \\n\\n        for( int i = 0 ; i<n ;i++)\\n        {\\n             reverse(matrix[i].begin(), matrix[i].end());\\n        }\\n    }\\n};"
                    },
                    {
                        "username": "mk2122",
                        "content": "what is issue if traversing one matrix and storing the indices of places where value is zero(o(mn) )and again traversing matrix and making 0 in the row and column at that indexs (o(m+n)) "
                    }
                ]
            },
            {
                "id": 1795661,
                "content": [
                    {
                        "username": "GovindSheshadri",
                        "content": "can we call this transpose of a matrix i am confused about this ? can anyone please telll?\\n"
                    },
                    {
                        "username": "benjsmyth",
                        "content": "`for row, col in enumerate(zip(*matrix)): matrix[row] = list(reversed(col))`\n\nbeats 98% in both time and space."
                    },
                    {
                        "username": "myyjx",
                        "content": "You only need to scan through the dataset with single pass and constant space, consider the following:\\nImage the matrix like an onion, with N layer of \"rings\", \\n1. for each layer, locate four points at the corner, and and interchange the values of these four points;\\n2. move on to the points clockwise to them and do the same;; \\n3. now you have reduced 1 layer and can move on to the next layer\\n4. recursively to solve the matrix with (n-2) dimension\\n* attached is the rust code\\n\\n ```\\n        let ml = matrix.len();\\n        let mut l_start = 0;\\n        let mut l_end = matrix.len() - 1;\\n        let mut n = matrix.len();\\n\\n        while n > 1 {\\n            for offset in l_start..l_end {\\n                // i-th point starting from top left to right\\n                let a = matrix[l_start][offset];\\n                // i-th point starting from top right to bottom right\\n                let b = matrix[offset][l_end];\\n                // i-th point starting from bottom right to bottom left\\n                let c = matrix[l_end][(ml - 1) - offset];\\n                // i-th point starting from bottom left to upper left\\n                let d = matrix[(ml - 1) - offset][l_start];\\n\\n                // swap the value\\n                matrix[l_start][offset] = d;\\n                matrix[offset][l_end] = a;\\n                matrix[l_end][ml - 1 - offset] = b;\\n                matrix[ml - 1 - offset][l_start] = c;\\n            }\\n            // decrement the dimension counter\\n            n -= 2;\\n            l_start += 1;\\n            l_end -= 1;\\n        }\\n```"
                    },
                    {
                        "username": "s1ttu",
                        "content": "just python thing \\n```\\ndef rotate(self, matrix: List[List[int]]) -> None:\\n    matrix[:] = [i[::-1] for i in zip(*matrix)]\\n```\\none line solution "
                    },
                    {
                        "username": "pr1524",
                        "content": "beats 100%\\n\\nvoid rotate(vector<vector<int>>& matrix) {\\n        int n = matrix.size();\\n        //transpose \\n        for(int i=0;i<n;i++){\\n            for(int j=0;j<i;j++){\\n                swap(matrix[i][j],matrix[j][i]);\\n            }\\n        }\\n        //reverse the column of each row\\n        for(int i=0;i<n;i++){\\n            for(int j=0;j<n/2;j++){\\n                swap(matrix[i][j],matrix[i][n-1-j]);\\n            }\\n        }\\n\\n\\n    }"
                    },
                    {
                        "username": "nitheeshtangellapally4",
                        "content": "class Solution {\\npublic:\\n    void rotate(vector<vector<int>>& a) {\\n        int n= a.size();\\n        for(int i=0;i<n;i++){\\n            for(int j=0;j<n;j++){\\n                swap(a[i][j],a[j][i]);\\n            }\\n        }\\n        for(int i=0;i<n/2;i++){\\n            for(int j=0;j<n;j++){\\n                swap(a[j][i],a[j][n-i-1]);\\n            }\\n        }\\n    }\\n};\\ncan someone explain why does this solution doesn\\'t work"
                    },
                    {
                        "username": "ComradeAndrew",
                        "content": "Here is the explanation in 3 steps to create an algorithm in 3 methods\n\n### 1. Rotate index by 90 degrees\nTo rotate an index by 90 degrees, we can transform a problem into linear algebra and treating indices as vector dimensions.\nIn order to rotate a vector around middle of the matrix (n/2, n/2) coordinates, we can use the following formula:\n```\n# First consider rotation around 0,0 coordinates\ntheta = deg2rad(angle);\n\ncs = cos(theta);\nsn = sin(theta);\n\nx = x * cs - y * sn; // now x is something different than original vector x\ny = x * sn + y * cs;\n# In short form cs and sn for 90 degrees would simplify as\nx = -y\ny = x\n# But y is inverted for matrix, thus we need to rotate the other direction (-90 degrees)\nx = y\ny = -x\n```\nNow we need to shift the coordinates, so rotation will happen around (n/2,n/2) index.\n```\nx' = y\ny' = int(-(x-mid)+mid)   # and shift the coordinates back\n```\nMiddle index would be shifted by -1 since we start indexing from 0. Thus `(n-1)/2 = n/2 - .5`\n\nWe implement this in `rotate_index90` method.\n\n### 2. Traverse rotation path\nBy following the path of rotation from index (0,0) we can see that it does a full turn after 4 rotations (90deg*4=360deg). The traversed path creates a cyclic graph: `(0,0) -> (0,n) -> (n,n) -> (n,0) -> (0,0) [cycle]`.\n*Also, note as we start from any of the indices from the path - we will traverse the whole path. Thus we only need one index from any given path to traverse the whole matrix.*\n\nInside `rotate_path` method we traverse the whole cycle and replace the value with a previous matrix value from the path, thus rotating 90 degrees all elements of the matrix laying on the path.\n\n### 3. Traversing paths from quoter of the matrix\nAs we traverse the path of the rotation, we go make a turn 4 times, thus all paths will have 4 nodes within the path. Since we need only the starting element we will need to consider only a quoter of the matrix. As we can see by the example of the matrix below, which shows all starting indexes from the first quoter of the matrix, we only need elements with a triangle of from top to middle of the matrix.\n```\n—————————————————————————————————————————\n|0,9|1,9|2,9|3,9|4,9|5,9|6,9|7,9|8,9|   |\n—————————————————————————————————————————\n|   |1,8|2,8|3,8|4,8|5,8|6,8|7,8|   |   |\n—————————————————————————————————————————\n|   |   |2,7|3,7|4,7|5,7|6,7|   |   |   |\n—————————————————————————————————————————\n|   |   |   |3,6|4,6|5,6|   |   |   |   |\n—————————————————————————————————————————\n|   |   |   |   |4,5|   |   |   |   |   |\n—————————————————————————————————————————\n|   |   |   |   |   |   |   |   |   |   |\n—————————————————————————————————————————\n|   |   |   |   |   |   |   |   |   |   |\n—————————————————————————————————————————\n|   |   |   |   |   |   |   |   |   |   |\n—————————————————————————————————————————\n|   |   |   |   |   |   |   |   |   |   |\n—————————————————————————————————————————\n|   |   |   |   |   |   |   |   |   |   |\n—————————————————————————————————————————\n```\nThe following traversing is implemented in `rotate` method.\n\nI hope that helps :)"
                    },
                    {
                        "username": "biniyamT",
                        "content": "it is all about reverse matrix and transpose it by swapping row and columns."
                    },
                    {
                        "username": "ankush920",
                        "content": "Beat 100% in  T.C. ???  ,Very easy and readable code .\\n\\nclass Solution {\\npublic:\\n    void rotate(vector<vector<int>>& matrix) {\\n        int n = matrix.size(); \\n       \\n         \\n         for( int i = 0 ;i<n ;i++)\\n         {\\n              for( int j=0 ; j<n ;j++)\\n              {\\n                   if( i>j)\\n                   {\\n                        swap( matrix[i][j], matrix[j][i]);\\n\\n                   }\\n\\n\\n              }\\n         }\\n        \\n\\n        for( int i = 0 ; i<n ;i++)\\n        {\\n             reverse(matrix[i].begin(), matrix[i].end());\\n        }\\n    }\\n};"
                    },
                    {
                        "username": "mk2122",
                        "content": "what is issue if traversing one matrix and storing the indices of places where value is zero(o(mn) )and again traversing matrix and making 0 in the row and column at that indexs (o(m+n)) "
                    }
                ]
            },
            {
                "id": 1794789,
                "content": [
                    {
                        "username": "GovindSheshadri",
                        "content": "can we call this transpose of a matrix i am confused about this ? can anyone please telll?\\n"
                    },
                    {
                        "username": "benjsmyth",
                        "content": "`for row, col in enumerate(zip(*matrix)): matrix[row] = list(reversed(col))`\n\nbeats 98% in both time and space."
                    },
                    {
                        "username": "myyjx",
                        "content": "You only need to scan through the dataset with single pass and constant space, consider the following:\\nImage the matrix like an onion, with N layer of \"rings\", \\n1. for each layer, locate four points at the corner, and and interchange the values of these four points;\\n2. move on to the points clockwise to them and do the same;; \\n3. now you have reduced 1 layer and can move on to the next layer\\n4. recursively to solve the matrix with (n-2) dimension\\n* attached is the rust code\\n\\n ```\\n        let ml = matrix.len();\\n        let mut l_start = 0;\\n        let mut l_end = matrix.len() - 1;\\n        let mut n = matrix.len();\\n\\n        while n > 1 {\\n            for offset in l_start..l_end {\\n                // i-th point starting from top left to right\\n                let a = matrix[l_start][offset];\\n                // i-th point starting from top right to bottom right\\n                let b = matrix[offset][l_end];\\n                // i-th point starting from bottom right to bottom left\\n                let c = matrix[l_end][(ml - 1) - offset];\\n                // i-th point starting from bottom left to upper left\\n                let d = matrix[(ml - 1) - offset][l_start];\\n\\n                // swap the value\\n                matrix[l_start][offset] = d;\\n                matrix[offset][l_end] = a;\\n                matrix[l_end][ml - 1 - offset] = b;\\n                matrix[ml - 1 - offset][l_start] = c;\\n            }\\n            // decrement the dimension counter\\n            n -= 2;\\n            l_start += 1;\\n            l_end -= 1;\\n        }\\n```"
                    },
                    {
                        "username": "s1ttu",
                        "content": "just python thing \\n```\\ndef rotate(self, matrix: List[List[int]]) -> None:\\n    matrix[:] = [i[::-1] for i in zip(*matrix)]\\n```\\none line solution "
                    },
                    {
                        "username": "pr1524",
                        "content": "beats 100%\\n\\nvoid rotate(vector<vector<int>>& matrix) {\\n        int n = matrix.size();\\n        //transpose \\n        for(int i=0;i<n;i++){\\n            for(int j=0;j<i;j++){\\n                swap(matrix[i][j],matrix[j][i]);\\n            }\\n        }\\n        //reverse the column of each row\\n        for(int i=0;i<n;i++){\\n            for(int j=0;j<n/2;j++){\\n                swap(matrix[i][j],matrix[i][n-1-j]);\\n            }\\n        }\\n\\n\\n    }"
                    },
                    {
                        "username": "nitheeshtangellapally4",
                        "content": "class Solution {\\npublic:\\n    void rotate(vector<vector<int>>& a) {\\n        int n= a.size();\\n        for(int i=0;i<n;i++){\\n            for(int j=0;j<n;j++){\\n                swap(a[i][j],a[j][i]);\\n            }\\n        }\\n        for(int i=0;i<n/2;i++){\\n            for(int j=0;j<n;j++){\\n                swap(a[j][i],a[j][n-i-1]);\\n            }\\n        }\\n    }\\n};\\ncan someone explain why does this solution doesn\\'t work"
                    },
                    {
                        "username": "ComradeAndrew",
                        "content": "Here is the explanation in 3 steps to create an algorithm in 3 methods\n\n### 1. Rotate index by 90 degrees\nTo rotate an index by 90 degrees, we can transform a problem into linear algebra and treating indices as vector dimensions.\nIn order to rotate a vector around middle of the matrix (n/2, n/2) coordinates, we can use the following formula:\n```\n# First consider rotation around 0,0 coordinates\ntheta = deg2rad(angle);\n\ncs = cos(theta);\nsn = sin(theta);\n\nx = x * cs - y * sn; // now x is something different than original vector x\ny = x * sn + y * cs;\n# In short form cs and sn for 90 degrees would simplify as\nx = -y\ny = x\n# But y is inverted for matrix, thus we need to rotate the other direction (-90 degrees)\nx = y\ny = -x\n```\nNow we need to shift the coordinates, so rotation will happen around (n/2,n/2) index.\n```\nx' = y\ny' = int(-(x-mid)+mid)   # and shift the coordinates back\n```\nMiddle index would be shifted by -1 since we start indexing from 0. Thus `(n-1)/2 = n/2 - .5`\n\nWe implement this in `rotate_index90` method.\n\n### 2. Traverse rotation path\nBy following the path of rotation from index (0,0) we can see that it does a full turn after 4 rotations (90deg*4=360deg). The traversed path creates a cyclic graph: `(0,0) -> (0,n) -> (n,n) -> (n,0) -> (0,0) [cycle]`.\n*Also, note as we start from any of the indices from the path - we will traverse the whole path. Thus we only need one index from any given path to traverse the whole matrix.*\n\nInside `rotate_path` method we traverse the whole cycle and replace the value with a previous matrix value from the path, thus rotating 90 degrees all elements of the matrix laying on the path.\n\n### 3. Traversing paths from quoter of the matrix\nAs we traverse the path of the rotation, we go make a turn 4 times, thus all paths will have 4 nodes within the path. Since we need only the starting element we will need to consider only a quoter of the matrix. As we can see by the example of the matrix below, which shows all starting indexes from the first quoter of the matrix, we only need elements with a triangle of from top to middle of the matrix.\n```\n—————————————————————————————————————————\n|0,9|1,9|2,9|3,9|4,9|5,9|6,9|7,9|8,9|   |\n—————————————————————————————————————————\n|   |1,8|2,8|3,8|4,8|5,8|6,8|7,8|   |   |\n—————————————————————————————————————————\n|   |   |2,7|3,7|4,7|5,7|6,7|   |   |   |\n—————————————————————————————————————————\n|   |   |   |3,6|4,6|5,6|   |   |   |   |\n—————————————————————————————————————————\n|   |   |   |   |4,5|   |   |   |   |   |\n—————————————————————————————————————————\n|   |   |   |   |   |   |   |   |   |   |\n—————————————————————————————————————————\n|   |   |   |   |   |   |   |   |   |   |\n—————————————————————————————————————————\n|   |   |   |   |   |   |   |   |   |   |\n—————————————————————————————————————————\n|   |   |   |   |   |   |   |   |   |   |\n—————————————————————————————————————————\n|   |   |   |   |   |   |   |   |   |   |\n—————————————————————————————————————————\n```\nThe following traversing is implemented in `rotate` method.\n\nI hope that helps :)"
                    },
                    {
                        "username": "biniyamT",
                        "content": "it is all about reverse matrix and transpose it by swapping row and columns."
                    },
                    {
                        "username": "ankush920",
                        "content": "Beat 100% in  T.C. ???  ,Very easy and readable code .\\n\\nclass Solution {\\npublic:\\n    void rotate(vector<vector<int>>& matrix) {\\n        int n = matrix.size(); \\n       \\n         \\n         for( int i = 0 ;i<n ;i++)\\n         {\\n              for( int j=0 ; j<n ;j++)\\n              {\\n                   if( i>j)\\n                   {\\n                        swap( matrix[i][j], matrix[j][i]);\\n\\n                   }\\n\\n\\n              }\\n         }\\n        \\n\\n        for( int i = 0 ; i<n ;i++)\\n        {\\n             reverse(matrix[i].begin(), matrix[i].end());\\n        }\\n    }\\n};"
                    },
                    {
                        "username": "mk2122",
                        "content": "what is issue if traversing one matrix and storing the indices of places where value is zero(o(mn) )and again traversing matrix and making 0 in the row and column at that indexs (o(m+n)) "
                    }
                ]
            },
            {
                "id": 1778106,
                "content": [
                    {
                        "username": "GovindSheshadri",
                        "content": "can we call this transpose of a matrix i am confused about this ? can anyone please telll?\\n"
                    },
                    {
                        "username": "benjsmyth",
                        "content": "`for row, col in enumerate(zip(*matrix)): matrix[row] = list(reversed(col))`\n\nbeats 98% in both time and space."
                    },
                    {
                        "username": "myyjx",
                        "content": "You only need to scan through the dataset with single pass and constant space, consider the following:\\nImage the matrix like an onion, with N layer of \"rings\", \\n1. for each layer, locate four points at the corner, and and interchange the values of these four points;\\n2. move on to the points clockwise to them and do the same;; \\n3. now you have reduced 1 layer and can move on to the next layer\\n4. recursively to solve the matrix with (n-2) dimension\\n* attached is the rust code\\n\\n ```\\n        let ml = matrix.len();\\n        let mut l_start = 0;\\n        let mut l_end = matrix.len() - 1;\\n        let mut n = matrix.len();\\n\\n        while n > 1 {\\n            for offset in l_start..l_end {\\n                // i-th point starting from top left to right\\n                let a = matrix[l_start][offset];\\n                // i-th point starting from top right to bottom right\\n                let b = matrix[offset][l_end];\\n                // i-th point starting from bottom right to bottom left\\n                let c = matrix[l_end][(ml - 1) - offset];\\n                // i-th point starting from bottom left to upper left\\n                let d = matrix[(ml - 1) - offset][l_start];\\n\\n                // swap the value\\n                matrix[l_start][offset] = d;\\n                matrix[offset][l_end] = a;\\n                matrix[l_end][ml - 1 - offset] = b;\\n                matrix[ml - 1 - offset][l_start] = c;\\n            }\\n            // decrement the dimension counter\\n            n -= 2;\\n            l_start += 1;\\n            l_end -= 1;\\n        }\\n```"
                    },
                    {
                        "username": "s1ttu",
                        "content": "just python thing \\n```\\ndef rotate(self, matrix: List[List[int]]) -> None:\\n    matrix[:] = [i[::-1] for i in zip(*matrix)]\\n```\\none line solution "
                    },
                    {
                        "username": "pr1524",
                        "content": "beats 100%\\n\\nvoid rotate(vector<vector<int>>& matrix) {\\n        int n = matrix.size();\\n        //transpose \\n        for(int i=0;i<n;i++){\\n            for(int j=0;j<i;j++){\\n                swap(matrix[i][j],matrix[j][i]);\\n            }\\n        }\\n        //reverse the column of each row\\n        for(int i=0;i<n;i++){\\n            for(int j=0;j<n/2;j++){\\n                swap(matrix[i][j],matrix[i][n-1-j]);\\n            }\\n        }\\n\\n\\n    }"
                    },
                    {
                        "username": "nitheeshtangellapally4",
                        "content": "class Solution {\\npublic:\\n    void rotate(vector<vector<int>>& a) {\\n        int n= a.size();\\n        for(int i=0;i<n;i++){\\n            for(int j=0;j<n;j++){\\n                swap(a[i][j],a[j][i]);\\n            }\\n        }\\n        for(int i=0;i<n/2;i++){\\n            for(int j=0;j<n;j++){\\n                swap(a[j][i],a[j][n-i-1]);\\n            }\\n        }\\n    }\\n};\\ncan someone explain why does this solution doesn\\'t work"
                    },
                    {
                        "username": "ComradeAndrew",
                        "content": "Here is the explanation in 3 steps to create an algorithm in 3 methods\n\n### 1. Rotate index by 90 degrees\nTo rotate an index by 90 degrees, we can transform a problem into linear algebra and treating indices as vector dimensions.\nIn order to rotate a vector around middle of the matrix (n/2, n/2) coordinates, we can use the following formula:\n```\n# First consider rotation around 0,0 coordinates\ntheta = deg2rad(angle);\n\ncs = cos(theta);\nsn = sin(theta);\n\nx = x * cs - y * sn; // now x is something different than original vector x\ny = x * sn + y * cs;\n# In short form cs and sn for 90 degrees would simplify as\nx = -y\ny = x\n# But y is inverted for matrix, thus we need to rotate the other direction (-90 degrees)\nx = y\ny = -x\n```\nNow we need to shift the coordinates, so rotation will happen around (n/2,n/2) index.\n```\nx' = y\ny' = int(-(x-mid)+mid)   # and shift the coordinates back\n```\nMiddle index would be shifted by -1 since we start indexing from 0. Thus `(n-1)/2 = n/2 - .5`\n\nWe implement this in `rotate_index90` method.\n\n### 2. Traverse rotation path\nBy following the path of rotation from index (0,0) we can see that it does a full turn after 4 rotations (90deg*4=360deg). The traversed path creates a cyclic graph: `(0,0) -> (0,n) -> (n,n) -> (n,0) -> (0,0) [cycle]`.\n*Also, note as we start from any of the indices from the path - we will traverse the whole path. Thus we only need one index from any given path to traverse the whole matrix.*\n\nInside `rotate_path` method we traverse the whole cycle and replace the value with a previous matrix value from the path, thus rotating 90 degrees all elements of the matrix laying on the path.\n\n### 3. Traversing paths from quoter of the matrix\nAs we traverse the path of the rotation, we go make a turn 4 times, thus all paths will have 4 nodes within the path. Since we need only the starting element we will need to consider only a quoter of the matrix. As we can see by the example of the matrix below, which shows all starting indexes from the first quoter of the matrix, we only need elements with a triangle of from top to middle of the matrix.\n```\n—————————————————————————————————————————\n|0,9|1,9|2,9|3,9|4,9|5,9|6,9|7,9|8,9|   |\n—————————————————————————————————————————\n|   |1,8|2,8|3,8|4,8|5,8|6,8|7,8|   |   |\n—————————————————————————————————————————\n|   |   |2,7|3,7|4,7|5,7|6,7|   |   |   |\n—————————————————————————————————————————\n|   |   |   |3,6|4,6|5,6|   |   |   |   |\n—————————————————————————————————————————\n|   |   |   |   |4,5|   |   |   |   |   |\n—————————————————————————————————————————\n|   |   |   |   |   |   |   |   |   |   |\n—————————————————————————————————————————\n|   |   |   |   |   |   |   |   |   |   |\n—————————————————————————————————————————\n|   |   |   |   |   |   |   |   |   |   |\n—————————————————————————————————————————\n|   |   |   |   |   |   |   |   |   |   |\n—————————————————————————————————————————\n|   |   |   |   |   |   |   |   |   |   |\n—————————————————————————————————————————\n```\nThe following traversing is implemented in `rotate` method.\n\nI hope that helps :)"
                    },
                    {
                        "username": "biniyamT",
                        "content": "it is all about reverse matrix and transpose it by swapping row and columns."
                    },
                    {
                        "username": "ankush920",
                        "content": "Beat 100% in  T.C. ???  ,Very easy and readable code .\\n\\nclass Solution {\\npublic:\\n    void rotate(vector<vector<int>>& matrix) {\\n        int n = matrix.size(); \\n       \\n         \\n         for( int i = 0 ;i<n ;i++)\\n         {\\n              for( int j=0 ; j<n ;j++)\\n              {\\n                   if( i>j)\\n                   {\\n                        swap( matrix[i][j], matrix[j][i]);\\n\\n                   }\\n\\n\\n              }\\n         }\\n        \\n\\n        for( int i = 0 ; i<n ;i++)\\n        {\\n             reverse(matrix[i].begin(), matrix[i].end());\\n        }\\n    }\\n};"
                    },
                    {
                        "username": "mk2122",
                        "content": "what is issue if traversing one matrix and storing the indices of places where value is zero(o(mn) )and again traversing matrix and making 0 in the row and column at that indexs (o(m+n)) "
                    }
                ]
            },
            {
                "id": 1776376,
                "content": [
                    {
                        "username": "GovindSheshadri",
                        "content": "can we call this transpose of a matrix i am confused about this ? can anyone please telll?\\n"
                    },
                    {
                        "username": "benjsmyth",
                        "content": "`for row, col in enumerate(zip(*matrix)): matrix[row] = list(reversed(col))`\n\nbeats 98% in both time and space."
                    },
                    {
                        "username": "myyjx",
                        "content": "You only need to scan through the dataset with single pass and constant space, consider the following:\\nImage the matrix like an onion, with N layer of \"rings\", \\n1. for each layer, locate four points at the corner, and and interchange the values of these four points;\\n2. move on to the points clockwise to them and do the same;; \\n3. now you have reduced 1 layer and can move on to the next layer\\n4. recursively to solve the matrix with (n-2) dimension\\n* attached is the rust code\\n\\n ```\\n        let ml = matrix.len();\\n        let mut l_start = 0;\\n        let mut l_end = matrix.len() - 1;\\n        let mut n = matrix.len();\\n\\n        while n > 1 {\\n            for offset in l_start..l_end {\\n                // i-th point starting from top left to right\\n                let a = matrix[l_start][offset];\\n                // i-th point starting from top right to bottom right\\n                let b = matrix[offset][l_end];\\n                // i-th point starting from bottom right to bottom left\\n                let c = matrix[l_end][(ml - 1) - offset];\\n                // i-th point starting from bottom left to upper left\\n                let d = matrix[(ml - 1) - offset][l_start];\\n\\n                // swap the value\\n                matrix[l_start][offset] = d;\\n                matrix[offset][l_end] = a;\\n                matrix[l_end][ml - 1 - offset] = b;\\n                matrix[ml - 1 - offset][l_start] = c;\\n            }\\n            // decrement the dimension counter\\n            n -= 2;\\n            l_start += 1;\\n            l_end -= 1;\\n        }\\n```"
                    },
                    {
                        "username": "s1ttu",
                        "content": "just python thing \\n```\\ndef rotate(self, matrix: List[List[int]]) -> None:\\n    matrix[:] = [i[::-1] for i in zip(*matrix)]\\n```\\none line solution "
                    },
                    {
                        "username": "pr1524",
                        "content": "beats 100%\\n\\nvoid rotate(vector<vector<int>>& matrix) {\\n        int n = matrix.size();\\n        //transpose \\n        for(int i=0;i<n;i++){\\n            for(int j=0;j<i;j++){\\n                swap(matrix[i][j],matrix[j][i]);\\n            }\\n        }\\n        //reverse the column of each row\\n        for(int i=0;i<n;i++){\\n            for(int j=0;j<n/2;j++){\\n                swap(matrix[i][j],matrix[i][n-1-j]);\\n            }\\n        }\\n\\n\\n    }"
                    },
                    {
                        "username": "nitheeshtangellapally4",
                        "content": "class Solution {\\npublic:\\n    void rotate(vector<vector<int>>& a) {\\n        int n= a.size();\\n        for(int i=0;i<n;i++){\\n            for(int j=0;j<n;j++){\\n                swap(a[i][j],a[j][i]);\\n            }\\n        }\\n        for(int i=0;i<n/2;i++){\\n            for(int j=0;j<n;j++){\\n                swap(a[j][i],a[j][n-i-1]);\\n            }\\n        }\\n    }\\n};\\ncan someone explain why does this solution doesn\\'t work"
                    },
                    {
                        "username": "ComradeAndrew",
                        "content": "Here is the explanation in 3 steps to create an algorithm in 3 methods\n\n### 1. Rotate index by 90 degrees\nTo rotate an index by 90 degrees, we can transform a problem into linear algebra and treating indices as vector dimensions.\nIn order to rotate a vector around middle of the matrix (n/2, n/2) coordinates, we can use the following formula:\n```\n# First consider rotation around 0,0 coordinates\ntheta = deg2rad(angle);\n\ncs = cos(theta);\nsn = sin(theta);\n\nx = x * cs - y * sn; // now x is something different than original vector x\ny = x * sn + y * cs;\n# In short form cs and sn for 90 degrees would simplify as\nx = -y\ny = x\n# But y is inverted for matrix, thus we need to rotate the other direction (-90 degrees)\nx = y\ny = -x\n```\nNow we need to shift the coordinates, so rotation will happen around (n/2,n/2) index.\n```\nx' = y\ny' = int(-(x-mid)+mid)   # and shift the coordinates back\n```\nMiddle index would be shifted by -1 since we start indexing from 0. Thus `(n-1)/2 = n/2 - .5`\n\nWe implement this in `rotate_index90` method.\n\n### 2. Traverse rotation path\nBy following the path of rotation from index (0,0) we can see that it does a full turn after 4 rotations (90deg*4=360deg). The traversed path creates a cyclic graph: `(0,0) -> (0,n) -> (n,n) -> (n,0) -> (0,0) [cycle]`.\n*Also, note as we start from any of the indices from the path - we will traverse the whole path. Thus we only need one index from any given path to traverse the whole matrix.*\n\nInside `rotate_path` method we traverse the whole cycle and replace the value with a previous matrix value from the path, thus rotating 90 degrees all elements of the matrix laying on the path.\n\n### 3. Traversing paths from quoter of the matrix\nAs we traverse the path of the rotation, we go make a turn 4 times, thus all paths will have 4 nodes within the path. Since we need only the starting element we will need to consider only a quoter of the matrix. As we can see by the example of the matrix below, which shows all starting indexes from the first quoter of the matrix, we only need elements with a triangle of from top to middle of the matrix.\n```\n—————————————————————————————————————————\n|0,9|1,9|2,9|3,9|4,9|5,9|6,9|7,9|8,9|   |\n—————————————————————————————————————————\n|   |1,8|2,8|3,8|4,8|5,8|6,8|7,8|   |   |\n—————————————————————————————————————————\n|   |   |2,7|3,7|4,7|5,7|6,7|   |   |   |\n—————————————————————————————————————————\n|   |   |   |3,6|4,6|5,6|   |   |   |   |\n—————————————————————————————————————————\n|   |   |   |   |4,5|   |   |   |   |   |\n—————————————————————————————————————————\n|   |   |   |   |   |   |   |   |   |   |\n—————————————————————————————————————————\n|   |   |   |   |   |   |   |   |   |   |\n—————————————————————————————————————————\n|   |   |   |   |   |   |   |   |   |   |\n—————————————————————————————————————————\n|   |   |   |   |   |   |   |   |   |   |\n—————————————————————————————————————————\n|   |   |   |   |   |   |   |   |   |   |\n—————————————————————————————————————————\n```\nThe following traversing is implemented in `rotate` method.\n\nI hope that helps :)"
                    },
                    {
                        "username": "biniyamT",
                        "content": "it is all about reverse matrix and transpose it by swapping row and columns."
                    },
                    {
                        "username": "ankush920",
                        "content": "Beat 100% in  T.C. ???  ,Very easy and readable code .\\n\\nclass Solution {\\npublic:\\n    void rotate(vector<vector<int>>& matrix) {\\n        int n = matrix.size(); \\n       \\n         \\n         for( int i = 0 ;i<n ;i++)\\n         {\\n              for( int j=0 ; j<n ;j++)\\n              {\\n                   if( i>j)\\n                   {\\n                        swap( matrix[i][j], matrix[j][i]);\\n\\n                   }\\n\\n\\n              }\\n         }\\n        \\n\\n        for( int i = 0 ; i<n ;i++)\\n        {\\n             reverse(matrix[i].begin(), matrix[i].end());\\n        }\\n    }\\n};"
                    },
                    {
                        "username": "mk2122",
                        "content": "what is issue if traversing one matrix and storing the indices of places where value is zero(o(mn) )and again traversing matrix and making 0 in the row and column at that indexs (o(m+n)) "
                    }
                ]
            },
            {
                "id": 1775182,
                "content": [
                    {
                        "username": "GovindSheshadri",
                        "content": "can we call this transpose of a matrix i am confused about this ? can anyone please telll?\\n"
                    },
                    {
                        "username": "benjsmyth",
                        "content": "`for row, col in enumerate(zip(*matrix)): matrix[row] = list(reversed(col))`\n\nbeats 98% in both time and space."
                    },
                    {
                        "username": "myyjx",
                        "content": "You only need to scan through the dataset with single pass and constant space, consider the following:\\nImage the matrix like an onion, with N layer of \"rings\", \\n1. for each layer, locate four points at the corner, and and interchange the values of these four points;\\n2. move on to the points clockwise to them and do the same;; \\n3. now you have reduced 1 layer and can move on to the next layer\\n4. recursively to solve the matrix with (n-2) dimension\\n* attached is the rust code\\n\\n ```\\n        let ml = matrix.len();\\n        let mut l_start = 0;\\n        let mut l_end = matrix.len() - 1;\\n        let mut n = matrix.len();\\n\\n        while n > 1 {\\n            for offset in l_start..l_end {\\n                // i-th point starting from top left to right\\n                let a = matrix[l_start][offset];\\n                // i-th point starting from top right to bottom right\\n                let b = matrix[offset][l_end];\\n                // i-th point starting from bottom right to bottom left\\n                let c = matrix[l_end][(ml - 1) - offset];\\n                // i-th point starting from bottom left to upper left\\n                let d = matrix[(ml - 1) - offset][l_start];\\n\\n                // swap the value\\n                matrix[l_start][offset] = d;\\n                matrix[offset][l_end] = a;\\n                matrix[l_end][ml - 1 - offset] = b;\\n                matrix[ml - 1 - offset][l_start] = c;\\n            }\\n            // decrement the dimension counter\\n            n -= 2;\\n            l_start += 1;\\n            l_end -= 1;\\n        }\\n```"
                    },
                    {
                        "username": "s1ttu",
                        "content": "just python thing \\n```\\ndef rotate(self, matrix: List[List[int]]) -> None:\\n    matrix[:] = [i[::-1] for i in zip(*matrix)]\\n```\\none line solution "
                    },
                    {
                        "username": "pr1524",
                        "content": "beats 100%\\n\\nvoid rotate(vector<vector<int>>& matrix) {\\n        int n = matrix.size();\\n        //transpose \\n        for(int i=0;i<n;i++){\\n            for(int j=0;j<i;j++){\\n                swap(matrix[i][j],matrix[j][i]);\\n            }\\n        }\\n        //reverse the column of each row\\n        for(int i=0;i<n;i++){\\n            for(int j=0;j<n/2;j++){\\n                swap(matrix[i][j],matrix[i][n-1-j]);\\n            }\\n        }\\n\\n\\n    }"
                    },
                    {
                        "username": "nitheeshtangellapally4",
                        "content": "class Solution {\\npublic:\\n    void rotate(vector<vector<int>>& a) {\\n        int n= a.size();\\n        for(int i=0;i<n;i++){\\n            for(int j=0;j<n;j++){\\n                swap(a[i][j],a[j][i]);\\n            }\\n        }\\n        for(int i=0;i<n/2;i++){\\n            for(int j=0;j<n;j++){\\n                swap(a[j][i],a[j][n-i-1]);\\n            }\\n        }\\n    }\\n};\\ncan someone explain why does this solution doesn\\'t work"
                    },
                    {
                        "username": "ComradeAndrew",
                        "content": "Here is the explanation in 3 steps to create an algorithm in 3 methods\n\n### 1. Rotate index by 90 degrees\nTo rotate an index by 90 degrees, we can transform a problem into linear algebra and treating indices as vector dimensions.\nIn order to rotate a vector around middle of the matrix (n/2, n/2) coordinates, we can use the following formula:\n```\n# First consider rotation around 0,0 coordinates\ntheta = deg2rad(angle);\n\ncs = cos(theta);\nsn = sin(theta);\n\nx = x * cs - y * sn; // now x is something different than original vector x\ny = x * sn + y * cs;\n# In short form cs and sn for 90 degrees would simplify as\nx = -y\ny = x\n# But y is inverted for matrix, thus we need to rotate the other direction (-90 degrees)\nx = y\ny = -x\n```\nNow we need to shift the coordinates, so rotation will happen around (n/2,n/2) index.\n```\nx' = y\ny' = int(-(x-mid)+mid)   # and shift the coordinates back\n```\nMiddle index would be shifted by -1 since we start indexing from 0. Thus `(n-1)/2 = n/2 - .5`\n\nWe implement this in `rotate_index90` method.\n\n### 2. Traverse rotation path\nBy following the path of rotation from index (0,0) we can see that it does a full turn after 4 rotations (90deg*4=360deg). The traversed path creates a cyclic graph: `(0,0) -> (0,n) -> (n,n) -> (n,0) -> (0,0) [cycle]`.\n*Also, note as we start from any of the indices from the path - we will traverse the whole path. Thus we only need one index from any given path to traverse the whole matrix.*\n\nInside `rotate_path` method we traverse the whole cycle and replace the value with a previous matrix value from the path, thus rotating 90 degrees all elements of the matrix laying on the path.\n\n### 3. Traversing paths from quoter of the matrix\nAs we traverse the path of the rotation, we go make a turn 4 times, thus all paths will have 4 nodes within the path. Since we need only the starting element we will need to consider only a quoter of the matrix. As we can see by the example of the matrix below, which shows all starting indexes from the first quoter of the matrix, we only need elements with a triangle of from top to middle of the matrix.\n```\n—————————————————————————————————————————\n|0,9|1,9|2,9|3,9|4,9|5,9|6,9|7,9|8,9|   |\n—————————————————————————————————————————\n|   |1,8|2,8|3,8|4,8|5,8|6,8|7,8|   |   |\n—————————————————————————————————————————\n|   |   |2,7|3,7|4,7|5,7|6,7|   |   |   |\n—————————————————————————————————————————\n|   |   |   |3,6|4,6|5,6|   |   |   |   |\n—————————————————————————————————————————\n|   |   |   |   |4,5|   |   |   |   |   |\n—————————————————————————————————————————\n|   |   |   |   |   |   |   |   |   |   |\n—————————————————————————————————————————\n|   |   |   |   |   |   |   |   |   |   |\n—————————————————————————————————————————\n|   |   |   |   |   |   |   |   |   |   |\n—————————————————————————————————————————\n|   |   |   |   |   |   |   |   |   |   |\n—————————————————————————————————————————\n|   |   |   |   |   |   |   |   |   |   |\n—————————————————————————————————————————\n```\nThe following traversing is implemented in `rotate` method.\n\nI hope that helps :)"
                    },
                    {
                        "username": "biniyamT",
                        "content": "it is all about reverse matrix and transpose it by swapping row and columns."
                    },
                    {
                        "username": "ankush920",
                        "content": "Beat 100% in  T.C. ???  ,Very easy and readable code .\\n\\nclass Solution {\\npublic:\\n    void rotate(vector<vector<int>>& matrix) {\\n        int n = matrix.size(); \\n       \\n         \\n         for( int i = 0 ;i<n ;i++)\\n         {\\n              for( int j=0 ; j<n ;j++)\\n              {\\n                   if( i>j)\\n                   {\\n                        swap( matrix[i][j], matrix[j][i]);\\n\\n                   }\\n\\n\\n              }\\n         }\\n        \\n\\n        for( int i = 0 ; i<n ;i++)\\n        {\\n             reverse(matrix[i].begin(), matrix[i].end());\\n        }\\n    }\\n};"
                    },
                    {
                        "username": "mk2122",
                        "content": "what is issue if traversing one matrix and storing the indices of places where value is zero(o(mn) )and again traversing matrix and making 0 in the row and column at that indexs (o(m+n)) "
                    }
                ]
            },
            {
                "id": 1773692,
                "content": [
                    {
                        "username": "AnkushR10",
                        "content": "https://github.com/AnkushRawat10601/Leetcode/blob/main/48_rotate_img.cpp"
                    },
                    {
                        "username": "cheukhin1024",
                        "content": "If we can create a new array instead of O(1) space complexity, this following code can work.\\n\\n        #Create transposed matrix        \\n\\n        R, C = len(matrix), len(matrix[0])\\n        transposed_matrix = [[None] * R for _ in xrange(C)]\\n        for r, row in enumerate(matrix):\\n            for c, val in enumerate(row):\\n                transposed_matrix[c][r] = val\\n\\n        left = 0\\n        right =len(transposed_matrix)-1\\n\\n        #Swap elements of transposed matrix\\n\\n        for i in range(len(transposed_matrix)):\\n            while right > left:\\n                transposed_matrix[i][left], transposed_matrix[i][right] = transposed_matrix[i][right], transposed_matrix[i][left]\\n                left+=1\\n                right-=1\\n            else:\\n                left = 0\\n                right = len(transposed_matrix)-1\\n\\n        print transposed_matrix\\n        return transposed_matrix"
                    },
                    {
                        "username": "nakulkhandelwal836",
                        "content": "class Solution {\\npublic:\\n    void rotate(vector<vector<int>>& matrix) {\\n\\n        int n = matrix.size();\\n        \\n        for(int i = 0; i<n; i++) { // transposing the matric \\n\\n            for(int j = 0; j<i; j++) {\\n\\n                swap(matrix[i][j], matrix[j][i]);\\n\\n            }\\n\\n        }\\n\\n\\n        for(int i = 0; i<n; i++) { // reversing the row\\n\\n            reverse(matrix[i].begin(), matrix[i].end());\\n\\n        }\\n\\n\\n    }\\n};\\n\\nRuntime: 5ms Memory: 7.2\\xA0MB"
                    },
                    {
                        "username": "mohamed_waseela",
                        "content": "https://youtu.be/-Qpk2XJ5XJQ"
                    },
                    {
                        "username": "SrollLet",
                        "content": "I hate this kind of problems!\n\nHi guys, I can only think of the solution like picking an onion, rotating layer by layer when I first saw this question. But it took me nearly 1 hour to set up all the indices and the loop range correctly . Although I passed  this problem I'm upset. :(\n\nCan anyone tell me how to set the rotated indices and loop range quickly and correctly? what's the trick?\n\nFor another solution using transposing  and reversing, how do you guys get this idea? \n\n```\ndef rotate(self, matrix: List[List[int]]) -> None:\n        \"\"\"\n        Do not return anything, modify matrix in-place instead.\n        \"\"\"\n        rows, cols = len(matrix), len(matrix[0]) + 1\n        for i in range(rows // 2):\n            cols -= 1\n            for j in range(i, cols - 1):\n                temp = matrix[i][j]\n                matrix[i][j] = matrix[rows - j - 1][i]\n                matrix[rows - j - 1][i] = matrix[rows - i - 1][rows - j - 1]\n                matrix[rows - i - 1][rows - j - 1] = matrix[j][rows - i - 1]\n                matrix[j][rows - i - 1] = temp\n                \n```"
                    },
                    {
                        "username": "Wajih_Ul_Hasan_0104",
                        "content": "Could anyone tell me what\\'s wrong with my code?                                                                                     \\n class RotateMatrix\\n{\\n    public void rotate(int [][] matrix)\\n    {\\n        int row,col ;\\n        System.out.print(\"[\");\\n\\n        for(row = 0 ; row < matrix.length; row++)\\n        {\\n            System.out.print(\"[\");\\n\\n            for(col = matrix.length - 1; col >= 0; col--)\\n            {\\n                System.out.print(matrix[col][row]+\",\");\\n            }\\n                System.out.print(\"]\");\\n\\n        }\\n                System.out.println(\"]\");\\n    }\\n}\\n\\nMy-output: [ [7,4,1,] [8,5,2] [9,6,3] ]"
                    },
                    {
                        "username": "bhruti1",
                        "content": "Just posting my observation \n - > for any integer in the matrix we can see that the element matrix[i][j] will got to a perticular position after the 90 degree clockwise rotation. Try to find the pattern or relation between the initial (i,j) value and the (i,j) value after rotation.\nTry it yourself its easy. \n\nIf you need help refer my soln post  [DETAILED SOLUTION](https://leetcode.com/problems/rotate-image/solutions/2902287/simple-pattern-solution-c/)"
                    },
                    {
                        "username": "Jatin101",
                        "content": "void rotate(vector<vector<int>>& matrix)\\n{\\n    int i=0,j=matrix.size()-1;\\n    while(i<j){swap(matrix[i],matrix[j]);i++;j--;}\\n\\n    for(int i=0;i<matrix.size();i++)\\n    {\\n        for(int j=0;j<i;j++)\\n        {\\n            swap(matrix[i][j],matrix[j][i]);\\n        }\\n    }\\n\\n}"
                    },
                    {
                        "username": "Azmankhan",
                        "content": "In first loop we will swap the  matrix like  i to j ;\\nin the other loop we will swap the row ; "
                    },
                    {
                        "username": "spakash182",
                        "content": "# 0ms runtime solution\n\n```java\nclass Solution {\n    public void rotate(int[][] matrix) {\n        int n = matrix.length;\n        int temp;\n        for(int i=0;i<n;i++){\n            for(int j=0;j<i;j++){\n                temp = matrix[i][j];\n                matrix[i][j] = matrix[j][i];\n                matrix[j][i] = temp;\n            }\n        }\n        for(int i=0;i<n;i++){\n            for(int j=0;j<n/2;j++){\n                temp = matrix[i][j];\n                matrix[i][j] = matrix[i][n-j-1];\n                matrix[i][n-j-1] = temp;\n            }\n        }\n    }\n}\n```"
                    }
                ]
            },
            {
                "id": 1766237,
                "content": [
                    {
                        "username": "AnkushR10",
                        "content": "https://github.com/AnkushRawat10601/Leetcode/blob/main/48_rotate_img.cpp"
                    },
                    {
                        "username": "cheukhin1024",
                        "content": "If we can create a new array instead of O(1) space complexity, this following code can work.\\n\\n        #Create transposed matrix        \\n\\n        R, C = len(matrix), len(matrix[0])\\n        transposed_matrix = [[None] * R for _ in xrange(C)]\\n        for r, row in enumerate(matrix):\\n            for c, val in enumerate(row):\\n                transposed_matrix[c][r] = val\\n\\n        left = 0\\n        right =len(transposed_matrix)-1\\n\\n        #Swap elements of transposed matrix\\n\\n        for i in range(len(transposed_matrix)):\\n            while right > left:\\n                transposed_matrix[i][left], transposed_matrix[i][right] = transposed_matrix[i][right], transposed_matrix[i][left]\\n                left+=1\\n                right-=1\\n            else:\\n                left = 0\\n                right = len(transposed_matrix)-1\\n\\n        print transposed_matrix\\n        return transposed_matrix"
                    },
                    {
                        "username": "nakulkhandelwal836",
                        "content": "class Solution {\\npublic:\\n    void rotate(vector<vector<int>>& matrix) {\\n\\n        int n = matrix.size();\\n        \\n        for(int i = 0; i<n; i++) { // transposing the matric \\n\\n            for(int j = 0; j<i; j++) {\\n\\n                swap(matrix[i][j], matrix[j][i]);\\n\\n            }\\n\\n        }\\n\\n\\n        for(int i = 0; i<n; i++) { // reversing the row\\n\\n            reverse(matrix[i].begin(), matrix[i].end());\\n\\n        }\\n\\n\\n    }\\n};\\n\\nRuntime: 5ms Memory: 7.2\\xA0MB"
                    },
                    {
                        "username": "mohamed_waseela",
                        "content": "https://youtu.be/-Qpk2XJ5XJQ"
                    },
                    {
                        "username": "SrollLet",
                        "content": "I hate this kind of problems!\n\nHi guys, I can only think of the solution like picking an onion, rotating layer by layer when I first saw this question. But it took me nearly 1 hour to set up all the indices and the loop range correctly . Although I passed  this problem I'm upset. :(\n\nCan anyone tell me how to set the rotated indices and loop range quickly and correctly? what's the trick?\n\nFor another solution using transposing  and reversing, how do you guys get this idea? \n\n```\ndef rotate(self, matrix: List[List[int]]) -> None:\n        \"\"\"\n        Do not return anything, modify matrix in-place instead.\n        \"\"\"\n        rows, cols = len(matrix), len(matrix[0]) + 1\n        for i in range(rows // 2):\n            cols -= 1\n            for j in range(i, cols - 1):\n                temp = matrix[i][j]\n                matrix[i][j] = matrix[rows - j - 1][i]\n                matrix[rows - j - 1][i] = matrix[rows - i - 1][rows - j - 1]\n                matrix[rows - i - 1][rows - j - 1] = matrix[j][rows - i - 1]\n                matrix[j][rows - i - 1] = temp\n                \n```"
                    },
                    {
                        "username": "Wajih_Ul_Hasan_0104",
                        "content": "Could anyone tell me what\\'s wrong with my code?                                                                                     \\n class RotateMatrix\\n{\\n    public void rotate(int [][] matrix)\\n    {\\n        int row,col ;\\n        System.out.print(\"[\");\\n\\n        for(row = 0 ; row < matrix.length; row++)\\n        {\\n            System.out.print(\"[\");\\n\\n            for(col = matrix.length - 1; col >= 0; col--)\\n            {\\n                System.out.print(matrix[col][row]+\",\");\\n            }\\n                System.out.print(\"]\");\\n\\n        }\\n                System.out.println(\"]\");\\n    }\\n}\\n\\nMy-output: [ [7,4,1,] [8,5,2] [9,6,3] ]"
                    },
                    {
                        "username": "bhruti1",
                        "content": "Just posting my observation \n - > for any integer in the matrix we can see that the element matrix[i][j] will got to a perticular position after the 90 degree clockwise rotation. Try to find the pattern or relation between the initial (i,j) value and the (i,j) value after rotation.\nTry it yourself its easy. \n\nIf you need help refer my soln post  [DETAILED SOLUTION](https://leetcode.com/problems/rotate-image/solutions/2902287/simple-pattern-solution-c/)"
                    },
                    {
                        "username": "Jatin101",
                        "content": "void rotate(vector<vector<int>>& matrix)\\n{\\n    int i=0,j=matrix.size()-1;\\n    while(i<j){swap(matrix[i],matrix[j]);i++;j--;}\\n\\n    for(int i=0;i<matrix.size();i++)\\n    {\\n        for(int j=0;j<i;j++)\\n        {\\n            swap(matrix[i][j],matrix[j][i]);\\n        }\\n    }\\n\\n}"
                    },
                    {
                        "username": "Azmankhan",
                        "content": "In first loop we will swap the  matrix like  i to j ;\\nin the other loop we will swap the row ; "
                    },
                    {
                        "username": "spakash182",
                        "content": "# 0ms runtime solution\n\n```java\nclass Solution {\n    public void rotate(int[][] matrix) {\n        int n = matrix.length;\n        int temp;\n        for(int i=0;i<n;i++){\n            for(int j=0;j<i;j++){\n                temp = matrix[i][j];\n                matrix[i][j] = matrix[j][i];\n                matrix[j][i] = temp;\n            }\n        }\n        for(int i=0;i<n;i++){\n            for(int j=0;j<n/2;j++){\n                temp = matrix[i][j];\n                matrix[i][j] = matrix[i][n-j-1];\n                matrix[i][n-j-1] = temp;\n            }\n        }\n    }\n}\n```"
                    }
                ]
            },
            {
                "id": 1761685,
                "content": [
                    {
                        "username": "AnkushR10",
                        "content": "https://github.com/AnkushRawat10601/Leetcode/blob/main/48_rotate_img.cpp"
                    },
                    {
                        "username": "cheukhin1024",
                        "content": "If we can create a new array instead of O(1) space complexity, this following code can work.\\n\\n        #Create transposed matrix        \\n\\n        R, C = len(matrix), len(matrix[0])\\n        transposed_matrix = [[None] * R for _ in xrange(C)]\\n        for r, row in enumerate(matrix):\\n            for c, val in enumerate(row):\\n                transposed_matrix[c][r] = val\\n\\n        left = 0\\n        right =len(transposed_matrix)-1\\n\\n        #Swap elements of transposed matrix\\n\\n        for i in range(len(transposed_matrix)):\\n            while right > left:\\n                transposed_matrix[i][left], transposed_matrix[i][right] = transposed_matrix[i][right], transposed_matrix[i][left]\\n                left+=1\\n                right-=1\\n            else:\\n                left = 0\\n                right = len(transposed_matrix)-1\\n\\n        print transposed_matrix\\n        return transposed_matrix"
                    },
                    {
                        "username": "nakulkhandelwal836",
                        "content": "class Solution {\\npublic:\\n    void rotate(vector<vector<int>>& matrix) {\\n\\n        int n = matrix.size();\\n        \\n        for(int i = 0; i<n; i++) { // transposing the matric \\n\\n            for(int j = 0; j<i; j++) {\\n\\n                swap(matrix[i][j], matrix[j][i]);\\n\\n            }\\n\\n        }\\n\\n\\n        for(int i = 0; i<n; i++) { // reversing the row\\n\\n            reverse(matrix[i].begin(), matrix[i].end());\\n\\n        }\\n\\n\\n    }\\n};\\n\\nRuntime: 5ms Memory: 7.2\\xA0MB"
                    },
                    {
                        "username": "mohamed_waseela",
                        "content": "https://youtu.be/-Qpk2XJ5XJQ"
                    },
                    {
                        "username": "SrollLet",
                        "content": "I hate this kind of problems!\n\nHi guys, I can only think of the solution like picking an onion, rotating layer by layer when I first saw this question. But it took me nearly 1 hour to set up all the indices and the loop range correctly . Although I passed  this problem I'm upset. :(\n\nCan anyone tell me how to set the rotated indices and loop range quickly and correctly? what's the trick?\n\nFor another solution using transposing  and reversing, how do you guys get this idea? \n\n```\ndef rotate(self, matrix: List[List[int]]) -> None:\n        \"\"\"\n        Do not return anything, modify matrix in-place instead.\n        \"\"\"\n        rows, cols = len(matrix), len(matrix[0]) + 1\n        for i in range(rows // 2):\n            cols -= 1\n            for j in range(i, cols - 1):\n                temp = matrix[i][j]\n                matrix[i][j] = matrix[rows - j - 1][i]\n                matrix[rows - j - 1][i] = matrix[rows - i - 1][rows - j - 1]\n                matrix[rows - i - 1][rows - j - 1] = matrix[j][rows - i - 1]\n                matrix[j][rows - i - 1] = temp\n                \n```"
                    },
                    {
                        "username": "Wajih_Ul_Hasan_0104",
                        "content": "Could anyone tell me what\\'s wrong with my code?                                                                                     \\n class RotateMatrix\\n{\\n    public void rotate(int [][] matrix)\\n    {\\n        int row,col ;\\n        System.out.print(\"[\");\\n\\n        for(row = 0 ; row < matrix.length; row++)\\n        {\\n            System.out.print(\"[\");\\n\\n            for(col = matrix.length - 1; col >= 0; col--)\\n            {\\n                System.out.print(matrix[col][row]+\",\");\\n            }\\n                System.out.print(\"]\");\\n\\n        }\\n                System.out.println(\"]\");\\n    }\\n}\\n\\nMy-output: [ [7,4,1,] [8,5,2] [9,6,3] ]"
                    },
                    {
                        "username": "bhruti1",
                        "content": "Just posting my observation \n - > for any integer in the matrix we can see that the element matrix[i][j] will got to a perticular position after the 90 degree clockwise rotation. Try to find the pattern or relation between the initial (i,j) value and the (i,j) value after rotation.\nTry it yourself its easy. \n\nIf you need help refer my soln post  [DETAILED SOLUTION](https://leetcode.com/problems/rotate-image/solutions/2902287/simple-pattern-solution-c/)"
                    },
                    {
                        "username": "Jatin101",
                        "content": "void rotate(vector<vector<int>>& matrix)\\n{\\n    int i=0,j=matrix.size()-1;\\n    while(i<j){swap(matrix[i],matrix[j]);i++;j--;}\\n\\n    for(int i=0;i<matrix.size();i++)\\n    {\\n        for(int j=0;j<i;j++)\\n        {\\n            swap(matrix[i][j],matrix[j][i]);\\n        }\\n    }\\n\\n}"
                    },
                    {
                        "username": "Azmankhan",
                        "content": "In first loop we will swap the  matrix like  i to j ;\\nin the other loop we will swap the row ; "
                    },
                    {
                        "username": "spakash182",
                        "content": "# 0ms runtime solution\n\n```java\nclass Solution {\n    public void rotate(int[][] matrix) {\n        int n = matrix.length;\n        int temp;\n        for(int i=0;i<n;i++){\n            for(int j=0;j<i;j++){\n                temp = matrix[i][j];\n                matrix[i][j] = matrix[j][i];\n                matrix[j][i] = temp;\n            }\n        }\n        for(int i=0;i<n;i++){\n            for(int j=0;j<n/2;j++){\n                temp = matrix[i][j];\n                matrix[i][j] = matrix[i][n-j-1];\n                matrix[i][n-j-1] = temp;\n            }\n        }\n    }\n}\n```"
                    }
                ]
            },
            {
                "id": 1752631,
                "content": [
                    {
                        "username": "AnkushR10",
                        "content": "https://github.com/AnkushRawat10601/Leetcode/blob/main/48_rotate_img.cpp"
                    },
                    {
                        "username": "cheukhin1024",
                        "content": "If we can create a new array instead of O(1) space complexity, this following code can work.\\n\\n        #Create transposed matrix        \\n\\n        R, C = len(matrix), len(matrix[0])\\n        transposed_matrix = [[None] * R for _ in xrange(C)]\\n        for r, row in enumerate(matrix):\\n            for c, val in enumerate(row):\\n                transposed_matrix[c][r] = val\\n\\n        left = 0\\n        right =len(transposed_matrix)-1\\n\\n        #Swap elements of transposed matrix\\n\\n        for i in range(len(transposed_matrix)):\\n            while right > left:\\n                transposed_matrix[i][left], transposed_matrix[i][right] = transposed_matrix[i][right], transposed_matrix[i][left]\\n                left+=1\\n                right-=1\\n            else:\\n                left = 0\\n                right = len(transposed_matrix)-1\\n\\n        print transposed_matrix\\n        return transposed_matrix"
                    },
                    {
                        "username": "nakulkhandelwal836",
                        "content": "class Solution {\\npublic:\\n    void rotate(vector<vector<int>>& matrix) {\\n\\n        int n = matrix.size();\\n        \\n        for(int i = 0; i<n; i++) { // transposing the matric \\n\\n            for(int j = 0; j<i; j++) {\\n\\n                swap(matrix[i][j], matrix[j][i]);\\n\\n            }\\n\\n        }\\n\\n\\n        for(int i = 0; i<n; i++) { // reversing the row\\n\\n            reverse(matrix[i].begin(), matrix[i].end());\\n\\n        }\\n\\n\\n    }\\n};\\n\\nRuntime: 5ms Memory: 7.2\\xA0MB"
                    },
                    {
                        "username": "mohamed_waseela",
                        "content": "https://youtu.be/-Qpk2XJ5XJQ"
                    },
                    {
                        "username": "SrollLet",
                        "content": "I hate this kind of problems!\n\nHi guys, I can only think of the solution like picking an onion, rotating layer by layer when I first saw this question. But it took me nearly 1 hour to set up all the indices and the loop range correctly . Although I passed  this problem I'm upset. :(\n\nCan anyone tell me how to set the rotated indices and loop range quickly and correctly? what's the trick?\n\nFor another solution using transposing  and reversing, how do you guys get this idea? \n\n```\ndef rotate(self, matrix: List[List[int]]) -> None:\n        \"\"\"\n        Do not return anything, modify matrix in-place instead.\n        \"\"\"\n        rows, cols = len(matrix), len(matrix[0]) + 1\n        for i in range(rows // 2):\n            cols -= 1\n            for j in range(i, cols - 1):\n                temp = matrix[i][j]\n                matrix[i][j] = matrix[rows - j - 1][i]\n                matrix[rows - j - 1][i] = matrix[rows - i - 1][rows - j - 1]\n                matrix[rows - i - 1][rows - j - 1] = matrix[j][rows - i - 1]\n                matrix[j][rows - i - 1] = temp\n                \n```"
                    },
                    {
                        "username": "Wajih_Ul_Hasan_0104",
                        "content": "Could anyone tell me what\\'s wrong with my code?                                                                                     \\n class RotateMatrix\\n{\\n    public void rotate(int [][] matrix)\\n    {\\n        int row,col ;\\n        System.out.print(\"[\");\\n\\n        for(row = 0 ; row < matrix.length; row++)\\n        {\\n            System.out.print(\"[\");\\n\\n            for(col = matrix.length - 1; col >= 0; col--)\\n            {\\n                System.out.print(matrix[col][row]+\",\");\\n            }\\n                System.out.print(\"]\");\\n\\n        }\\n                System.out.println(\"]\");\\n    }\\n}\\n\\nMy-output: [ [7,4,1,] [8,5,2] [9,6,3] ]"
                    },
                    {
                        "username": "bhruti1",
                        "content": "Just posting my observation \n - > for any integer in the matrix we can see that the element matrix[i][j] will got to a perticular position after the 90 degree clockwise rotation. Try to find the pattern or relation between the initial (i,j) value and the (i,j) value after rotation.\nTry it yourself its easy. \n\nIf you need help refer my soln post  [DETAILED SOLUTION](https://leetcode.com/problems/rotate-image/solutions/2902287/simple-pattern-solution-c/)"
                    },
                    {
                        "username": "Jatin101",
                        "content": "void rotate(vector<vector<int>>& matrix)\\n{\\n    int i=0,j=matrix.size()-1;\\n    while(i<j){swap(matrix[i],matrix[j]);i++;j--;}\\n\\n    for(int i=0;i<matrix.size();i++)\\n    {\\n        for(int j=0;j<i;j++)\\n        {\\n            swap(matrix[i][j],matrix[j][i]);\\n        }\\n    }\\n\\n}"
                    },
                    {
                        "username": "Azmankhan",
                        "content": "In first loop we will swap the  matrix like  i to j ;\\nin the other loop we will swap the row ; "
                    },
                    {
                        "username": "spakash182",
                        "content": "# 0ms runtime solution\n\n```java\nclass Solution {\n    public void rotate(int[][] matrix) {\n        int n = matrix.length;\n        int temp;\n        for(int i=0;i<n;i++){\n            for(int j=0;j<i;j++){\n                temp = matrix[i][j];\n                matrix[i][j] = matrix[j][i];\n                matrix[j][i] = temp;\n            }\n        }\n        for(int i=0;i<n;i++){\n            for(int j=0;j<n/2;j++){\n                temp = matrix[i][j];\n                matrix[i][j] = matrix[i][n-j-1];\n                matrix[i][n-j-1] = temp;\n            }\n        }\n    }\n}\n```"
                    }
                ]
            },
            {
                "id": 1745521,
                "content": [
                    {
                        "username": "AnkushR10",
                        "content": "https://github.com/AnkushRawat10601/Leetcode/blob/main/48_rotate_img.cpp"
                    },
                    {
                        "username": "cheukhin1024",
                        "content": "If we can create a new array instead of O(1) space complexity, this following code can work.\\n\\n        #Create transposed matrix        \\n\\n        R, C = len(matrix), len(matrix[0])\\n        transposed_matrix = [[None] * R for _ in xrange(C)]\\n        for r, row in enumerate(matrix):\\n            for c, val in enumerate(row):\\n                transposed_matrix[c][r] = val\\n\\n        left = 0\\n        right =len(transposed_matrix)-1\\n\\n        #Swap elements of transposed matrix\\n\\n        for i in range(len(transposed_matrix)):\\n            while right > left:\\n                transposed_matrix[i][left], transposed_matrix[i][right] = transposed_matrix[i][right], transposed_matrix[i][left]\\n                left+=1\\n                right-=1\\n            else:\\n                left = 0\\n                right = len(transposed_matrix)-1\\n\\n        print transposed_matrix\\n        return transposed_matrix"
                    },
                    {
                        "username": "nakulkhandelwal836",
                        "content": "class Solution {\\npublic:\\n    void rotate(vector<vector<int>>& matrix) {\\n\\n        int n = matrix.size();\\n        \\n        for(int i = 0; i<n; i++) { // transposing the matric \\n\\n            for(int j = 0; j<i; j++) {\\n\\n                swap(matrix[i][j], matrix[j][i]);\\n\\n            }\\n\\n        }\\n\\n\\n        for(int i = 0; i<n; i++) { // reversing the row\\n\\n            reverse(matrix[i].begin(), matrix[i].end());\\n\\n        }\\n\\n\\n    }\\n};\\n\\nRuntime: 5ms Memory: 7.2\\xA0MB"
                    },
                    {
                        "username": "mohamed_waseela",
                        "content": "https://youtu.be/-Qpk2XJ5XJQ"
                    },
                    {
                        "username": "SrollLet",
                        "content": "I hate this kind of problems!\n\nHi guys, I can only think of the solution like picking an onion, rotating layer by layer when I first saw this question. But it took me nearly 1 hour to set up all the indices and the loop range correctly . Although I passed  this problem I'm upset. :(\n\nCan anyone tell me how to set the rotated indices and loop range quickly and correctly? what's the trick?\n\nFor another solution using transposing  and reversing, how do you guys get this idea? \n\n```\ndef rotate(self, matrix: List[List[int]]) -> None:\n        \"\"\"\n        Do not return anything, modify matrix in-place instead.\n        \"\"\"\n        rows, cols = len(matrix), len(matrix[0]) + 1\n        for i in range(rows // 2):\n            cols -= 1\n            for j in range(i, cols - 1):\n                temp = matrix[i][j]\n                matrix[i][j] = matrix[rows - j - 1][i]\n                matrix[rows - j - 1][i] = matrix[rows - i - 1][rows - j - 1]\n                matrix[rows - i - 1][rows - j - 1] = matrix[j][rows - i - 1]\n                matrix[j][rows - i - 1] = temp\n                \n```"
                    },
                    {
                        "username": "Wajih_Ul_Hasan_0104",
                        "content": "Could anyone tell me what\\'s wrong with my code?                                                                                     \\n class RotateMatrix\\n{\\n    public void rotate(int [][] matrix)\\n    {\\n        int row,col ;\\n        System.out.print(\"[\");\\n\\n        for(row = 0 ; row < matrix.length; row++)\\n        {\\n            System.out.print(\"[\");\\n\\n            for(col = matrix.length - 1; col >= 0; col--)\\n            {\\n                System.out.print(matrix[col][row]+\",\");\\n            }\\n                System.out.print(\"]\");\\n\\n        }\\n                System.out.println(\"]\");\\n    }\\n}\\n\\nMy-output: [ [7,4,1,] [8,5,2] [9,6,3] ]"
                    },
                    {
                        "username": "bhruti1",
                        "content": "Just posting my observation \n - > for any integer in the matrix we can see that the element matrix[i][j] will got to a perticular position after the 90 degree clockwise rotation. Try to find the pattern or relation between the initial (i,j) value and the (i,j) value after rotation.\nTry it yourself its easy. \n\nIf you need help refer my soln post  [DETAILED SOLUTION](https://leetcode.com/problems/rotate-image/solutions/2902287/simple-pattern-solution-c/)"
                    },
                    {
                        "username": "Jatin101",
                        "content": "void rotate(vector<vector<int>>& matrix)\\n{\\n    int i=0,j=matrix.size()-1;\\n    while(i<j){swap(matrix[i],matrix[j]);i++;j--;}\\n\\n    for(int i=0;i<matrix.size();i++)\\n    {\\n        for(int j=0;j<i;j++)\\n        {\\n            swap(matrix[i][j],matrix[j][i]);\\n        }\\n    }\\n\\n}"
                    },
                    {
                        "username": "Azmankhan",
                        "content": "In first loop we will swap the  matrix like  i to j ;\\nin the other loop we will swap the row ; "
                    },
                    {
                        "username": "spakash182",
                        "content": "# 0ms runtime solution\n\n```java\nclass Solution {\n    public void rotate(int[][] matrix) {\n        int n = matrix.length;\n        int temp;\n        for(int i=0;i<n;i++){\n            for(int j=0;j<i;j++){\n                temp = matrix[i][j];\n                matrix[i][j] = matrix[j][i];\n                matrix[j][i] = temp;\n            }\n        }\n        for(int i=0;i<n;i++){\n            for(int j=0;j<n/2;j++){\n                temp = matrix[i][j];\n                matrix[i][j] = matrix[i][n-j-1];\n                matrix[i][n-j-1] = temp;\n            }\n        }\n    }\n}\n```"
                    }
                ]
            },
            {
                "id": 1733352,
                "content": [
                    {
                        "username": "AnkushR10",
                        "content": "https://github.com/AnkushRawat10601/Leetcode/blob/main/48_rotate_img.cpp"
                    },
                    {
                        "username": "cheukhin1024",
                        "content": "If we can create a new array instead of O(1) space complexity, this following code can work.\\n\\n        #Create transposed matrix        \\n\\n        R, C = len(matrix), len(matrix[0])\\n        transposed_matrix = [[None] * R for _ in xrange(C)]\\n        for r, row in enumerate(matrix):\\n            for c, val in enumerate(row):\\n                transposed_matrix[c][r] = val\\n\\n        left = 0\\n        right =len(transposed_matrix)-1\\n\\n        #Swap elements of transposed matrix\\n\\n        for i in range(len(transposed_matrix)):\\n            while right > left:\\n                transposed_matrix[i][left], transposed_matrix[i][right] = transposed_matrix[i][right], transposed_matrix[i][left]\\n                left+=1\\n                right-=1\\n            else:\\n                left = 0\\n                right = len(transposed_matrix)-1\\n\\n        print transposed_matrix\\n        return transposed_matrix"
                    },
                    {
                        "username": "nakulkhandelwal836",
                        "content": "class Solution {\\npublic:\\n    void rotate(vector<vector<int>>& matrix) {\\n\\n        int n = matrix.size();\\n        \\n        for(int i = 0; i<n; i++) { // transposing the matric \\n\\n            for(int j = 0; j<i; j++) {\\n\\n                swap(matrix[i][j], matrix[j][i]);\\n\\n            }\\n\\n        }\\n\\n\\n        for(int i = 0; i<n; i++) { // reversing the row\\n\\n            reverse(matrix[i].begin(), matrix[i].end());\\n\\n        }\\n\\n\\n    }\\n};\\n\\nRuntime: 5ms Memory: 7.2\\xA0MB"
                    },
                    {
                        "username": "mohamed_waseela",
                        "content": "https://youtu.be/-Qpk2XJ5XJQ"
                    },
                    {
                        "username": "SrollLet",
                        "content": "I hate this kind of problems!\n\nHi guys, I can only think of the solution like picking an onion, rotating layer by layer when I first saw this question. But it took me nearly 1 hour to set up all the indices and the loop range correctly . Although I passed  this problem I'm upset. :(\n\nCan anyone tell me how to set the rotated indices and loop range quickly and correctly? what's the trick?\n\nFor another solution using transposing  and reversing, how do you guys get this idea? \n\n```\ndef rotate(self, matrix: List[List[int]]) -> None:\n        \"\"\"\n        Do not return anything, modify matrix in-place instead.\n        \"\"\"\n        rows, cols = len(matrix), len(matrix[0]) + 1\n        for i in range(rows // 2):\n            cols -= 1\n            for j in range(i, cols - 1):\n                temp = matrix[i][j]\n                matrix[i][j] = matrix[rows - j - 1][i]\n                matrix[rows - j - 1][i] = matrix[rows - i - 1][rows - j - 1]\n                matrix[rows - i - 1][rows - j - 1] = matrix[j][rows - i - 1]\n                matrix[j][rows - i - 1] = temp\n                \n```"
                    },
                    {
                        "username": "Wajih_Ul_Hasan_0104",
                        "content": "Could anyone tell me what\\'s wrong with my code?                                                                                     \\n class RotateMatrix\\n{\\n    public void rotate(int [][] matrix)\\n    {\\n        int row,col ;\\n        System.out.print(\"[\");\\n\\n        for(row = 0 ; row < matrix.length; row++)\\n        {\\n            System.out.print(\"[\");\\n\\n            for(col = matrix.length - 1; col >= 0; col--)\\n            {\\n                System.out.print(matrix[col][row]+\",\");\\n            }\\n                System.out.print(\"]\");\\n\\n        }\\n                System.out.println(\"]\");\\n    }\\n}\\n\\nMy-output: [ [7,4,1,] [8,5,2] [9,6,3] ]"
                    },
                    {
                        "username": "bhruti1",
                        "content": "Just posting my observation \n - > for any integer in the matrix we can see that the element matrix[i][j] will got to a perticular position after the 90 degree clockwise rotation. Try to find the pattern or relation between the initial (i,j) value and the (i,j) value after rotation.\nTry it yourself its easy. \n\nIf you need help refer my soln post  [DETAILED SOLUTION](https://leetcode.com/problems/rotate-image/solutions/2902287/simple-pattern-solution-c/)"
                    },
                    {
                        "username": "Jatin101",
                        "content": "void rotate(vector<vector<int>>& matrix)\\n{\\n    int i=0,j=matrix.size()-1;\\n    while(i<j){swap(matrix[i],matrix[j]);i++;j--;}\\n\\n    for(int i=0;i<matrix.size();i++)\\n    {\\n        for(int j=0;j<i;j++)\\n        {\\n            swap(matrix[i][j],matrix[j][i]);\\n        }\\n    }\\n\\n}"
                    },
                    {
                        "username": "Azmankhan",
                        "content": "In first loop we will swap the  matrix like  i to j ;\\nin the other loop we will swap the row ; "
                    },
                    {
                        "username": "spakash182",
                        "content": "# 0ms runtime solution\n\n```java\nclass Solution {\n    public void rotate(int[][] matrix) {\n        int n = matrix.length;\n        int temp;\n        for(int i=0;i<n;i++){\n            for(int j=0;j<i;j++){\n                temp = matrix[i][j];\n                matrix[i][j] = matrix[j][i];\n                matrix[j][i] = temp;\n            }\n        }\n        for(int i=0;i<n;i++){\n            for(int j=0;j<n/2;j++){\n                temp = matrix[i][j];\n                matrix[i][j] = matrix[i][n-j-1];\n                matrix[i][n-j-1] = temp;\n            }\n        }\n    }\n}\n```"
                    }
                ]
            },
            {
                "id": 1713584,
                "content": [
                    {
                        "username": "AnkushR10",
                        "content": "https://github.com/AnkushRawat10601/Leetcode/blob/main/48_rotate_img.cpp"
                    },
                    {
                        "username": "cheukhin1024",
                        "content": "If we can create a new array instead of O(1) space complexity, this following code can work.\\n\\n        #Create transposed matrix        \\n\\n        R, C = len(matrix), len(matrix[0])\\n        transposed_matrix = [[None] * R for _ in xrange(C)]\\n        for r, row in enumerate(matrix):\\n            for c, val in enumerate(row):\\n                transposed_matrix[c][r] = val\\n\\n        left = 0\\n        right =len(transposed_matrix)-1\\n\\n        #Swap elements of transposed matrix\\n\\n        for i in range(len(transposed_matrix)):\\n            while right > left:\\n                transposed_matrix[i][left], transposed_matrix[i][right] = transposed_matrix[i][right], transposed_matrix[i][left]\\n                left+=1\\n                right-=1\\n            else:\\n                left = 0\\n                right = len(transposed_matrix)-1\\n\\n        print transposed_matrix\\n        return transposed_matrix"
                    },
                    {
                        "username": "nakulkhandelwal836",
                        "content": "class Solution {\\npublic:\\n    void rotate(vector<vector<int>>& matrix) {\\n\\n        int n = matrix.size();\\n        \\n        for(int i = 0; i<n; i++) { // transposing the matric \\n\\n            for(int j = 0; j<i; j++) {\\n\\n                swap(matrix[i][j], matrix[j][i]);\\n\\n            }\\n\\n        }\\n\\n\\n        for(int i = 0; i<n; i++) { // reversing the row\\n\\n            reverse(matrix[i].begin(), matrix[i].end());\\n\\n        }\\n\\n\\n    }\\n};\\n\\nRuntime: 5ms Memory: 7.2\\xA0MB"
                    },
                    {
                        "username": "mohamed_waseela",
                        "content": "https://youtu.be/-Qpk2XJ5XJQ"
                    },
                    {
                        "username": "SrollLet",
                        "content": "I hate this kind of problems!\n\nHi guys, I can only think of the solution like picking an onion, rotating layer by layer when I first saw this question. But it took me nearly 1 hour to set up all the indices and the loop range correctly . Although I passed  this problem I'm upset. :(\n\nCan anyone tell me how to set the rotated indices and loop range quickly and correctly? what's the trick?\n\nFor another solution using transposing  and reversing, how do you guys get this idea? \n\n```\ndef rotate(self, matrix: List[List[int]]) -> None:\n        \"\"\"\n        Do not return anything, modify matrix in-place instead.\n        \"\"\"\n        rows, cols = len(matrix), len(matrix[0]) + 1\n        for i in range(rows // 2):\n            cols -= 1\n            for j in range(i, cols - 1):\n                temp = matrix[i][j]\n                matrix[i][j] = matrix[rows - j - 1][i]\n                matrix[rows - j - 1][i] = matrix[rows - i - 1][rows - j - 1]\n                matrix[rows - i - 1][rows - j - 1] = matrix[j][rows - i - 1]\n                matrix[j][rows - i - 1] = temp\n                \n```"
                    },
                    {
                        "username": "Wajih_Ul_Hasan_0104",
                        "content": "Could anyone tell me what\\'s wrong with my code?                                                                                     \\n class RotateMatrix\\n{\\n    public void rotate(int [][] matrix)\\n    {\\n        int row,col ;\\n        System.out.print(\"[\");\\n\\n        for(row = 0 ; row < matrix.length; row++)\\n        {\\n            System.out.print(\"[\");\\n\\n            for(col = matrix.length - 1; col >= 0; col--)\\n            {\\n                System.out.print(matrix[col][row]+\",\");\\n            }\\n                System.out.print(\"]\");\\n\\n        }\\n                System.out.println(\"]\");\\n    }\\n}\\n\\nMy-output: [ [7,4,1,] [8,5,2] [9,6,3] ]"
                    },
                    {
                        "username": "bhruti1",
                        "content": "Just posting my observation \n - > for any integer in the matrix we can see that the element matrix[i][j] will got to a perticular position after the 90 degree clockwise rotation. Try to find the pattern or relation between the initial (i,j) value and the (i,j) value after rotation.\nTry it yourself its easy. \n\nIf you need help refer my soln post  [DETAILED SOLUTION](https://leetcode.com/problems/rotate-image/solutions/2902287/simple-pattern-solution-c/)"
                    },
                    {
                        "username": "Jatin101",
                        "content": "void rotate(vector<vector<int>>& matrix)\\n{\\n    int i=0,j=matrix.size()-1;\\n    while(i<j){swap(matrix[i],matrix[j]);i++;j--;}\\n\\n    for(int i=0;i<matrix.size();i++)\\n    {\\n        for(int j=0;j<i;j++)\\n        {\\n            swap(matrix[i][j],matrix[j][i]);\\n        }\\n    }\\n\\n}"
                    },
                    {
                        "username": "Azmankhan",
                        "content": "In first loop we will swap the  matrix like  i to j ;\\nin the other loop we will swap the row ; "
                    },
                    {
                        "username": "spakash182",
                        "content": "# 0ms runtime solution\n\n```java\nclass Solution {\n    public void rotate(int[][] matrix) {\n        int n = matrix.length;\n        int temp;\n        for(int i=0;i<n;i++){\n            for(int j=0;j<i;j++){\n                temp = matrix[i][j];\n                matrix[i][j] = matrix[j][i];\n                matrix[j][i] = temp;\n            }\n        }\n        for(int i=0;i<n;i++){\n            for(int j=0;j<n/2;j++){\n                temp = matrix[i][j];\n                matrix[i][j] = matrix[i][n-j-1];\n                matrix[i][n-j-1] = temp;\n            }\n        }\n    }\n}\n```"
                    }
                ]
            },
            {
                "id": 1709996,
                "content": [
                    {
                        "username": "AnkushR10",
                        "content": "https://github.com/AnkushRawat10601/Leetcode/blob/main/48_rotate_img.cpp"
                    },
                    {
                        "username": "cheukhin1024",
                        "content": "If we can create a new array instead of O(1) space complexity, this following code can work.\\n\\n        #Create transposed matrix        \\n\\n        R, C = len(matrix), len(matrix[0])\\n        transposed_matrix = [[None] * R for _ in xrange(C)]\\n        for r, row in enumerate(matrix):\\n            for c, val in enumerate(row):\\n                transposed_matrix[c][r] = val\\n\\n        left = 0\\n        right =len(transposed_matrix)-1\\n\\n        #Swap elements of transposed matrix\\n\\n        for i in range(len(transposed_matrix)):\\n            while right > left:\\n                transposed_matrix[i][left], transposed_matrix[i][right] = transposed_matrix[i][right], transposed_matrix[i][left]\\n                left+=1\\n                right-=1\\n            else:\\n                left = 0\\n                right = len(transposed_matrix)-1\\n\\n        print transposed_matrix\\n        return transposed_matrix"
                    },
                    {
                        "username": "nakulkhandelwal836",
                        "content": "class Solution {\\npublic:\\n    void rotate(vector<vector<int>>& matrix) {\\n\\n        int n = matrix.size();\\n        \\n        for(int i = 0; i<n; i++) { // transposing the matric \\n\\n            for(int j = 0; j<i; j++) {\\n\\n                swap(matrix[i][j], matrix[j][i]);\\n\\n            }\\n\\n        }\\n\\n\\n        for(int i = 0; i<n; i++) { // reversing the row\\n\\n            reverse(matrix[i].begin(), matrix[i].end());\\n\\n        }\\n\\n\\n    }\\n};\\n\\nRuntime: 5ms Memory: 7.2\\xA0MB"
                    },
                    {
                        "username": "mohamed_waseela",
                        "content": "https://youtu.be/-Qpk2XJ5XJQ"
                    },
                    {
                        "username": "SrollLet",
                        "content": "I hate this kind of problems!\n\nHi guys, I can only think of the solution like picking an onion, rotating layer by layer when I first saw this question. But it took me nearly 1 hour to set up all the indices and the loop range correctly . Although I passed  this problem I'm upset. :(\n\nCan anyone tell me how to set the rotated indices and loop range quickly and correctly? what's the trick?\n\nFor another solution using transposing  and reversing, how do you guys get this idea? \n\n```\ndef rotate(self, matrix: List[List[int]]) -> None:\n        \"\"\"\n        Do not return anything, modify matrix in-place instead.\n        \"\"\"\n        rows, cols = len(matrix), len(matrix[0]) + 1\n        for i in range(rows // 2):\n            cols -= 1\n            for j in range(i, cols - 1):\n                temp = matrix[i][j]\n                matrix[i][j] = matrix[rows - j - 1][i]\n                matrix[rows - j - 1][i] = matrix[rows - i - 1][rows - j - 1]\n                matrix[rows - i - 1][rows - j - 1] = matrix[j][rows - i - 1]\n                matrix[j][rows - i - 1] = temp\n                \n```"
                    },
                    {
                        "username": "Wajih_Ul_Hasan_0104",
                        "content": "Could anyone tell me what\\'s wrong with my code?                                                                                     \\n class RotateMatrix\\n{\\n    public void rotate(int [][] matrix)\\n    {\\n        int row,col ;\\n        System.out.print(\"[\");\\n\\n        for(row = 0 ; row < matrix.length; row++)\\n        {\\n            System.out.print(\"[\");\\n\\n            for(col = matrix.length - 1; col >= 0; col--)\\n            {\\n                System.out.print(matrix[col][row]+\",\");\\n            }\\n                System.out.print(\"]\");\\n\\n        }\\n                System.out.println(\"]\");\\n    }\\n}\\n\\nMy-output: [ [7,4,1,] [8,5,2] [9,6,3] ]"
                    },
                    {
                        "username": "bhruti1",
                        "content": "Just posting my observation \n - > for any integer in the matrix we can see that the element matrix[i][j] will got to a perticular position after the 90 degree clockwise rotation. Try to find the pattern or relation between the initial (i,j) value and the (i,j) value after rotation.\nTry it yourself its easy. \n\nIf you need help refer my soln post  [DETAILED SOLUTION](https://leetcode.com/problems/rotate-image/solutions/2902287/simple-pattern-solution-c/)"
                    },
                    {
                        "username": "Jatin101",
                        "content": "void rotate(vector<vector<int>>& matrix)\\n{\\n    int i=0,j=matrix.size()-1;\\n    while(i<j){swap(matrix[i],matrix[j]);i++;j--;}\\n\\n    for(int i=0;i<matrix.size();i++)\\n    {\\n        for(int j=0;j<i;j++)\\n        {\\n            swap(matrix[i][j],matrix[j][i]);\\n        }\\n    }\\n\\n}"
                    },
                    {
                        "username": "Azmankhan",
                        "content": "In first loop we will swap the  matrix like  i to j ;\\nin the other loop we will swap the row ; "
                    },
                    {
                        "username": "spakash182",
                        "content": "# 0ms runtime solution\n\n```java\nclass Solution {\n    public void rotate(int[][] matrix) {\n        int n = matrix.length;\n        int temp;\n        for(int i=0;i<n;i++){\n            for(int j=0;j<i;j++){\n                temp = matrix[i][j];\n                matrix[i][j] = matrix[j][i];\n                matrix[j][i] = temp;\n            }\n        }\n        for(int i=0;i<n;i++){\n            for(int j=0;j<n/2;j++){\n                temp = matrix[i][j];\n                matrix[i][j] = matrix[i][n-j-1];\n                matrix[i][n-j-1] = temp;\n            }\n        }\n    }\n}\n```"
                    }
                ]
            },
            {
                "id": 1703028,
                "content": [
                    {
                        "username": "AnkushR10",
                        "content": "https://github.com/AnkushRawat10601/Leetcode/blob/main/48_rotate_img.cpp"
                    },
                    {
                        "username": "cheukhin1024",
                        "content": "If we can create a new array instead of O(1) space complexity, this following code can work.\\n\\n        #Create transposed matrix        \\n\\n        R, C = len(matrix), len(matrix[0])\\n        transposed_matrix = [[None] * R for _ in xrange(C)]\\n        for r, row in enumerate(matrix):\\n            for c, val in enumerate(row):\\n                transposed_matrix[c][r] = val\\n\\n        left = 0\\n        right =len(transposed_matrix)-1\\n\\n        #Swap elements of transposed matrix\\n\\n        for i in range(len(transposed_matrix)):\\n            while right > left:\\n                transposed_matrix[i][left], transposed_matrix[i][right] = transposed_matrix[i][right], transposed_matrix[i][left]\\n                left+=1\\n                right-=1\\n            else:\\n                left = 0\\n                right = len(transposed_matrix)-1\\n\\n        print transposed_matrix\\n        return transposed_matrix"
                    },
                    {
                        "username": "nakulkhandelwal836",
                        "content": "class Solution {\\npublic:\\n    void rotate(vector<vector<int>>& matrix) {\\n\\n        int n = matrix.size();\\n        \\n        for(int i = 0; i<n; i++) { // transposing the matric \\n\\n            for(int j = 0; j<i; j++) {\\n\\n                swap(matrix[i][j], matrix[j][i]);\\n\\n            }\\n\\n        }\\n\\n\\n        for(int i = 0; i<n; i++) { // reversing the row\\n\\n            reverse(matrix[i].begin(), matrix[i].end());\\n\\n        }\\n\\n\\n    }\\n};\\n\\nRuntime: 5ms Memory: 7.2\\xA0MB"
                    },
                    {
                        "username": "mohamed_waseela",
                        "content": "https://youtu.be/-Qpk2XJ5XJQ"
                    },
                    {
                        "username": "SrollLet",
                        "content": "I hate this kind of problems!\n\nHi guys, I can only think of the solution like picking an onion, rotating layer by layer when I first saw this question. But it took me nearly 1 hour to set up all the indices and the loop range correctly . Although I passed  this problem I'm upset. :(\n\nCan anyone tell me how to set the rotated indices and loop range quickly and correctly? what's the trick?\n\nFor another solution using transposing  and reversing, how do you guys get this idea? \n\n```\ndef rotate(self, matrix: List[List[int]]) -> None:\n        \"\"\"\n        Do not return anything, modify matrix in-place instead.\n        \"\"\"\n        rows, cols = len(matrix), len(matrix[0]) + 1\n        for i in range(rows // 2):\n            cols -= 1\n            for j in range(i, cols - 1):\n                temp = matrix[i][j]\n                matrix[i][j] = matrix[rows - j - 1][i]\n                matrix[rows - j - 1][i] = matrix[rows - i - 1][rows - j - 1]\n                matrix[rows - i - 1][rows - j - 1] = matrix[j][rows - i - 1]\n                matrix[j][rows - i - 1] = temp\n                \n```"
                    },
                    {
                        "username": "Wajih_Ul_Hasan_0104",
                        "content": "Could anyone tell me what\\'s wrong with my code?                                                                                     \\n class RotateMatrix\\n{\\n    public void rotate(int [][] matrix)\\n    {\\n        int row,col ;\\n        System.out.print(\"[\");\\n\\n        for(row = 0 ; row < matrix.length; row++)\\n        {\\n            System.out.print(\"[\");\\n\\n            for(col = matrix.length - 1; col >= 0; col--)\\n            {\\n                System.out.print(matrix[col][row]+\",\");\\n            }\\n                System.out.print(\"]\");\\n\\n        }\\n                System.out.println(\"]\");\\n    }\\n}\\n\\nMy-output: [ [7,4,1,] [8,5,2] [9,6,3] ]"
                    },
                    {
                        "username": "bhruti1",
                        "content": "Just posting my observation \n - > for any integer in the matrix we can see that the element matrix[i][j] will got to a perticular position after the 90 degree clockwise rotation. Try to find the pattern or relation between the initial (i,j) value and the (i,j) value after rotation.\nTry it yourself its easy. \n\nIf you need help refer my soln post  [DETAILED SOLUTION](https://leetcode.com/problems/rotate-image/solutions/2902287/simple-pattern-solution-c/)"
                    },
                    {
                        "username": "Jatin101",
                        "content": "void rotate(vector<vector<int>>& matrix)\\n{\\n    int i=0,j=matrix.size()-1;\\n    while(i<j){swap(matrix[i],matrix[j]);i++;j--;}\\n\\n    for(int i=0;i<matrix.size();i++)\\n    {\\n        for(int j=0;j<i;j++)\\n        {\\n            swap(matrix[i][j],matrix[j][i]);\\n        }\\n    }\\n\\n}"
                    },
                    {
                        "username": "Azmankhan",
                        "content": "In first loop we will swap the  matrix like  i to j ;\\nin the other loop we will swap the row ; "
                    },
                    {
                        "username": "spakash182",
                        "content": "# 0ms runtime solution\n\n```java\nclass Solution {\n    public void rotate(int[][] matrix) {\n        int n = matrix.length;\n        int temp;\n        for(int i=0;i<n;i++){\n            for(int j=0;j<i;j++){\n                temp = matrix[i][j];\n                matrix[i][j] = matrix[j][i];\n                matrix[j][i] = temp;\n            }\n        }\n        for(int i=0;i<n;i++){\n            for(int j=0;j<n/2;j++){\n                temp = matrix[i][j];\n                matrix[i][j] = matrix[i][n-j-1];\n                matrix[i][n-j-1] = temp;\n            }\n        }\n    }\n}\n```"
                    }
                ]
            },
            {
                "id": 1699491,
                "content": [
                    {
                        "username": "AnkushR10",
                        "content": "https://github.com/AnkushRawat10601/Leetcode/blob/main/48_rotate_img.cpp"
                    },
                    {
                        "username": "cheukhin1024",
                        "content": "If we can create a new array instead of O(1) space complexity, this following code can work.\\n\\n        #Create transposed matrix        \\n\\n        R, C = len(matrix), len(matrix[0])\\n        transposed_matrix = [[None] * R for _ in xrange(C)]\\n        for r, row in enumerate(matrix):\\n            for c, val in enumerate(row):\\n                transposed_matrix[c][r] = val\\n\\n        left = 0\\n        right =len(transposed_matrix)-1\\n\\n        #Swap elements of transposed matrix\\n\\n        for i in range(len(transposed_matrix)):\\n            while right > left:\\n                transposed_matrix[i][left], transposed_matrix[i][right] = transposed_matrix[i][right], transposed_matrix[i][left]\\n                left+=1\\n                right-=1\\n            else:\\n                left = 0\\n                right = len(transposed_matrix)-1\\n\\n        print transposed_matrix\\n        return transposed_matrix"
                    },
                    {
                        "username": "nakulkhandelwal836",
                        "content": "class Solution {\\npublic:\\n    void rotate(vector<vector<int>>& matrix) {\\n\\n        int n = matrix.size();\\n        \\n        for(int i = 0; i<n; i++) { // transposing the matric \\n\\n            for(int j = 0; j<i; j++) {\\n\\n                swap(matrix[i][j], matrix[j][i]);\\n\\n            }\\n\\n        }\\n\\n\\n        for(int i = 0; i<n; i++) { // reversing the row\\n\\n            reverse(matrix[i].begin(), matrix[i].end());\\n\\n        }\\n\\n\\n    }\\n};\\n\\nRuntime: 5ms Memory: 7.2\\xA0MB"
                    },
                    {
                        "username": "mohamed_waseela",
                        "content": "https://youtu.be/-Qpk2XJ5XJQ"
                    },
                    {
                        "username": "SrollLet",
                        "content": "I hate this kind of problems!\n\nHi guys, I can only think of the solution like picking an onion, rotating layer by layer when I first saw this question. But it took me nearly 1 hour to set up all the indices and the loop range correctly . Although I passed  this problem I'm upset. :(\n\nCan anyone tell me how to set the rotated indices and loop range quickly and correctly? what's the trick?\n\nFor another solution using transposing  and reversing, how do you guys get this idea? \n\n```\ndef rotate(self, matrix: List[List[int]]) -> None:\n        \"\"\"\n        Do not return anything, modify matrix in-place instead.\n        \"\"\"\n        rows, cols = len(matrix), len(matrix[0]) + 1\n        for i in range(rows // 2):\n            cols -= 1\n            for j in range(i, cols - 1):\n                temp = matrix[i][j]\n                matrix[i][j] = matrix[rows - j - 1][i]\n                matrix[rows - j - 1][i] = matrix[rows - i - 1][rows - j - 1]\n                matrix[rows - i - 1][rows - j - 1] = matrix[j][rows - i - 1]\n                matrix[j][rows - i - 1] = temp\n                \n```"
                    },
                    {
                        "username": "Wajih_Ul_Hasan_0104",
                        "content": "Could anyone tell me what\\'s wrong with my code?                                                                                     \\n class RotateMatrix\\n{\\n    public void rotate(int [][] matrix)\\n    {\\n        int row,col ;\\n        System.out.print(\"[\");\\n\\n        for(row = 0 ; row < matrix.length; row++)\\n        {\\n            System.out.print(\"[\");\\n\\n            for(col = matrix.length - 1; col >= 0; col--)\\n            {\\n                System.out.print(matrix[col][row]+\",\");\\n            }\\n                System.out.print(\"]\");\\n\\n        }\\n                System.out.println(\"]\");\\n    }\\n}\\n\\nMy-output: [ [7,4,1,] [8,5,2] [9,6,3] ]"
                    },
                    {
                        "username": "bhruti1",
                        "content": "Just posting my observation \n - > for any integer in the matrix we can see that the element matrix[i][j] will got to a perticular position after the 90 degree clockwise rotation. Try to find the pattern or relation between the initial (i,j) value and the (i,j) value after rotation.\nTry it yourself its easy. \n\nIf you need help refer my soln post  [DETAILED SOLUTION](https://leetcode.com/problems/rotate-image/solutions/2902287/simple-pattern-solution-c/)"
                    },
                    {
                        "username": "Jatin101",
                        "content": "void rotate(vector<vector<int>>& matrix)\\n{\\n    int i=0,j=matrix.size()-1;\\n    while(i<j){swap(matrix[i],matrix[j]);i++;j--;}\\n\\n    for(int i=0;i<matrix.size();i++)\\n    {\\n        for(int j=0;j<i;j++)\\n        {\\n            swap(matrix[i][j],matrix[j][i]);\\n        }\\n    }\\n\\n}"
                    },
                    {
                        "username": "Azmankhan",
                        "content": "In first loop we will swap the  matrix like  i to j ;\\nin the other loop we will swap the row ; "
                    },
                    {
                        "username": "spakash182",
                        "content": "# 0ms runtime solution\n\n```java\nclass Solution {\n    public void rotate(int[][] matrix) {\n        int n = matrix.length;\n        int temp;\n        for(int i=0;i<n;i++){\n            for(int j=0;j<i;j++){\n                temp = matrix[i][j];\n                matrix[i][j] = matrix[j][i];\n                matrix[j][i] = temp;\n            }\n        }\n        for(int i=0;i<n;i++){\n            for(int j=0;j<n/2;j++){\n                temp = matrix[i][j];\n                matrix[i][j] = matrix[i][n-j-1];\n                matrix[i][n-j-1] = temp;\n            }\n        }\n    }\n}\n```"
                    }
                ]
            }
        ]
    }
]