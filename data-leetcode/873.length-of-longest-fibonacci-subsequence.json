[
    {
        "title": "Length of Longest Fibonacci Subsequence",
        "question_content": "A sequence x1, x2, ..., xn is Fibonacci-like if:\n\n\tn >= 3\n\txi + xi+1 == xi+2 for all i + 2 <= n\n\nGiven a strictly increasing array arr of positive integers forming a sequence, return the length of the longest Fibonacci-like subsequence of arr. If one does not exist, return 0.\nA subsequence is derived from another sequence arr by deleting any number of elements (including none) from arr, without changing the order of the remaining elements. For example, [3, 5, 8] is a subsequence of [3, 4, 5, 6, 7, 8].\n&nbsp;\nExample 1:\n\nInput: arr = [1,2,3,4,5,6,7,8]\nOutput: 5\nExplanation: The longest subsequence that is fibonacci-like: [1,2,3,5,8].\nExample 2:\n\nInput: arr = [1,3,7,11,12,14,18]\nOutput: 3\nExplanation: The longest subsequence that is fibonacci-like: [1,11,12], [3,11,14] or [7,11,18].\n&nbsp;\nConstraints:\n\n\t3 <= arr.length <= 1000\n\t1 <= arr[i] < arr[i + 1] <= 109",
        "solutions": [
            {
                "id": 152343,
                "title": "c-java-python-check-pair",
                "content": "# Solution 1\\nSave array `A` to a hash set `s`.\\nStart from base (A[i], A[j]) as the first two element in the sequence,\\nwe try to find the Fibonacci like subsequence as long as possible,\\n\\nInitial `(a, b) = (A[i], A[j])`\\nWhile the set `s` contains `a + b`, we update `(a, b) = (b, a + b)`.\\nIn the end we update the longest length we find.\\n\\n**Time Complexity**:\\n`O(N^2logM)`, where `M` is the `max(A)`.\\n\\nQuote from @renato4:\\nJust clarifying a little bit more.\\nSince the values grow exponentially,\\nthe amount of numbers needed to accommodate a sequence\\nthat ends in a number `M` is at most `log(M)`.\\n\\n**C++:**\\n```\\n    int lenLongestFibSubseq(vector<int>& A) {\\n        unordered_set<int> s(A.begin(), A.end());\\n        int res = 0;\\n        for (int i = 0; i < A.size(); ++i) {\\n            for (int j = i + 1; j < A.size(); ++j) {\\n                int  a = A[i], b = A[j], l = 2;\\n                while (s.count(a + b))\\n                    b = a + b, a = b - a, l++;\\n                res = max(res, l);\\n            }\\n        }\\n        return res > 2 ? res : 0;\\n    }\\n```\\n\\n**Java:**\\n```\\n    public int lenLongestFibSubseq(int[] A) {\\n        Set<Integer> s = new HashSet<Integer>();\\n        for (int x : A) s.add(x);\\n        int res = 2;\\n        for (int i = 0; i < A.length; ++i)\\n            for (int j = i + 1; j < A.length; ++j) {\\n                int a = A[i], b = A[j], l = 2;\\n                while (s.contains(a + b)) {\\n                    b = a + b;\\n                    a = b - a;\\n                    l++;\\n                }\\n                res = Math.max(res, l);\\n            }\\n        return res > 2 ? res : 0;\\n    }\\n```\\n**Python:**\\n```\\n    def lenLongestFibSubseq(self, A):\\n        s = set(A)\\n        res = 2\\n        for i in range(len(A)):\\n            for j in range(i + 1, len(A)):\\n                a, b, l = A[i], A[j], 2\\n                while a + b in s:\\n                    a, b, l = b, a + b, l + 1\\n                res = max(res, l)\\n        return res if res > 2 else 0\\n```\\n\\n<br>\\n\\n## Solution 2\\nAnother solution is kind of dp.\\n`dp[a, b]` represents the length of fibo sequence ends up with `(a, b)`\\nThen we have `dp[a, b] = (dp[b - a, a] + 1 ) or 2`\\nThe complexity reduce to `O(N^2)`.\\nIn C++/Java, I use 2D dp and index as key.\\nIn Python, I use value as key.\\n\\n**Time Complexity**:\\n`O(N^2)`\\n\\n**C++**\\n```\\n    int lenLongestFibSubseq(vector<int>& A) {\\n        unordered_map<int, int> m;\\n        int N = A.size(), res = 0;\\n        int dp[N][N];\\n        for (int j = 0; j < N; ++j) {\\n            m[A[j]] = j;\\n            for (int i = 0; i < j; ++i) {\\n                int k = m.find(A[j] - A[i]) == m.end() ? -1 : m[A[j] - A[i]];\\n                dp[i][j] = (A[j] - A[i] < A[i] && k >= 0) ? dp[k][i] + 1 : 2;\\n                res = max(res, dp[i][j]);\\n            }\\n        }\\n        return res > 2 ? res : 0;\\n    }\\n```\\n\\n**Java**\\n```\\n    public int lenLongestFibSubseq(int[] A) {\\n        int res = 0;\\n        int[][] dp = new int[A.length][A.length];\\n        Map<Integer, Integer> index = new HashMap<>();\\n        for (int j = 0; j < A.length; j++) {\\n            index.put(A[j], j);\\n            for (int i = 0; i < j; i++) {\\n                int k = index.getOrDefault(A[j] - A[i], -1);\\n                dp[i][j] = (A[j] - A[i] < A[i] && k >= 0) ? dp[k][i] + 1 : 2;\\n                res = Math.max(res, dp[i][j]);\\n            }\\n        }\\n        return res > 2 ? res : 0;\\n    }\\n```\\n\\n**Python**\\n```\\n    def lenLongestFibSubseq(self, A):\\n        dp = collections.defaultdict(int)\\n        s = set(A)\\n        for j in xrange(len(A)):\\n            for i in xrange(j):\\n                if A[j] - A[i] < A[i] and A[j] - A[i] in s:\\n                    dp[A[i], A[j]] = dp.get((A[j] - A[i], A[i]), 2) + 1\\n        return max(dp.values() or [0])\\n```",
                "solutionTags": [],
                "code": "```\\n    int lenLongestFibSubseq(vector<int>& A) {\\n        unordered_set<int> s(A.begin(), A.end());\\n        int res = 0;\\n        for (int i = 0; i < A.size(); ++i) {\\n            for (int j = i + 1; j < A.size(); ++j) {\\n                int  a = A[i], b = A[j], l = 2;\\n                while (s.count(a + b))\\n                    b = a + b, a = b - a, l++;\\n                res = max(res, l);\\n            }\\n        }\\n        return res > 2 ? res : 0;\\n    }\\n```\n```\\n    public int lenLongestFibSubseq(int[] A) {\\n        Set<Integer> s = new HashSet<Integer>();\\n        for (int x : A) s.add(x);\\n        int res = 2;\\n        for (int i = 0; i < A.length; ++i)\\n            for (int j = i + 1; j < A.length; ++j) {\\n                int a = A[i], b = A[j], l = 2;\\n                while (s.contains(a + b)) {\\n                    b = a + b;\\n                    a = b - a;\\n                    l++;\\n                }\\n                res = Math.max(res, l);\\n            }\\n        return res > 2 ? res : 0;\\n    }\\n```\n```\\n    def lenLongestFibSubseq(self, A):\\n        s = set(A)\\n        res = 2\\n        for i in range(len(A)):\\n            for j in range(i + 1, len(A)):\\n                a, b, l = A[i], A[j], 2\\n                while a + b in s:\\n                    a, b, l = b, a + b, l + 1\\n                res = max(res, l)\\n        return res if res > 2 else 0\\n```\n```\\n    int lenLongestFibSubseq(vector<int>& A) {\\n        unordered_map<int, int> m;\\n        int N = A.size(), res = 0;\\n        int dp[N][N];\\n        for (int j = 0; j < N; ++j) {\\n            m[A[j]] = j;\\n            for (int i = 0; i < j; ++i) {\\n                int k = m.find(A[j] - A[i]) == m.end() ? -1 : m[A[j] - A[i]];\\n                dp[i][j] = (A[j] - A[i] < A[i] && k >= 0) ? dp[k][i] + 1 : 2;\\n                res = max(res, dp[i][j]);\\n            }\\n        }\\n        return res > 2 ? res : 0;\\n    }\\n```\n```\\n    public int lenLongestFibSubseq(int[] A) {\\n        int res = 0;\\n        int[][] dp = new int[A.length][A.length];\\n        Map<Integer, Integer> index = new HashMap<>();\\n        for (int j = 0; j < A.length; j++) {\\n            index.put(A[j], j);\\n            for (int i = 0; i < j; i++) {\\n                int k = index.getOrDefault(A[j] - A[i], -1);\\n                dp[i][j] = (A[j] - A[i] < A[i] && k >= 0) ? dp[k][i] + 1 : 2;\\n                res = Math.max(res, dp[i][j]);\\n            }\\n        }\\n        return res > 2 ? res : 0;\\n    }\\n```\n```\\n    def lenLongestFibSubseq(self, A):\\n        dp = collections.defaultdict(int)\\n        s = set(A)\\n        for j in xrange(len(A)):\\n            for i in xrange(j):\\n                if A[j] - A[i] < A[i] and A[j] - A[i] in s:\\n                    dp[A[i], A[j]] = dp.get((A[j] - A[i], A[i]), 2) + 1\\n        return max(dp.values() or [0])\\n```",
                "codeTag": "Python3"
            },
            {
                "id": 165330,
                "title": "java-beat-98-dp-2sum",
                "content": "For each A[i] find previous 2 elements sum up to A[i], \\nthen it\\'s a classical follow up problem for Two Sum \\n`167. Two Sum II - Input array is sorted`\\nif 2 elements A[l] and A[r] sum up to A[i]\\n`dp[r][i]`: length of longest fibonacchi sequence end with A[r], A[i]\\n `dp[r][i] = dp[l][r] + 1`\\nreturn the max(all posible dp[r][i])\\n```\\n    public int lenLongestFibSubseq(int[] A) {\\n        int n = A.length;\\n        int max = 0;\\n        int[][] dp = new int[n][n];\\n        for (int i = 2; i < n; i++) {\\n            int l = 0, r = i - 1;\\n\\t        while (l < r) {\\n                int sum = A[l] + A[r];\\n                if (sum > A[i]) {\\n                    r--;  \\n                } else if (sum < A[i]) {\\n                    l++;\\n                } else {\\n                    dp[r][i] = dp[l][r] + 1;\\n                    max = Math.max(max, dp[r][i]);\\n                    r--;\\n                    l++;\\n                }\\n            }\\n        }\\n        return max == 0 ? 0 : max + 2;\\n    }\\n```\\nTime Complexity: `O(N^2)`\\nSpace Complexity: `O(N^2)`",
                "solutionTags": [],
                "code": "```\\n    public int lenLongestFibSubseq(int[] A) {\\n        int n = A.length;\\n        int max = 0;\\n        int[][] dp = new int[n][n];\\n        for (int i = 2; i < n; i++) {\\n            int l = 0, r = i - 1;\\n\\t        while (l < r) {\\n                int sum = A[l] + A[r];\\n                if (sum > A[i]) {\\n                    r--;  \\n                } else if (sum < A[i]) {\\n                    l++;\\n                } else {\\n                    dp[r][i] = dp[l][r] + 1;\\n                    max = Math.max(max, dp[r][i]);\\n                    r--;\\n                    l++;\\n                }\\n            }\\n        }\\n        return max == 0 ? 0 : max + 2;\\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 152332,
                "title": "java-clean-dp-o-n-2-time-o-n-2-space",
                "content": "`dp[i][j]` represents the length of longest sequence which ends with `A[i]` and `A[j]`.\\n\\n```\\nclass Solution {\\n    public int lenLongestFibSubseq(int[] A) {\\n        int n = A.length;\\n        int[][] dp = new int[n][n];\\n        Map<Integer, Integer> pos = new HashMap<>();\\n        for (int i = 0; i < n; i++) {\\n            pos.put(A[i], i);\\n            for (int j = i; j < n; j++) {\\n                dp[i][j] = 2;\\n            }\\n        }\\n        for (int j = 2; j < n; j++) {\\n            for (int i = j - 1; i > 0; i--) {\\n                int prev = A[j] - A[i];\\n                if (prev >= A[i]) {\\n                    break;\\n                }\\n                if (!pos.containsKey(prev)) {\\n                    continue;\\n                }\\n                dp[i][j] = dp[pos.get(prev)][i] + 1;\\n            }\\n        }\\n        int result = 0;\\n        for (int j = 2; j < n; j++) {\\n            for (int i = 1; i < n - 1; i++) {\\n                if (dp[i][j] > 2) {\\n                    result = Math.max(result, dp[i][j]);\\n                }\\n            }\\n        }\\n        return result;\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    public int lenLongestFibSubseq(int[] A) {\\n        int n = A.length;\\n        int[][] dp = new int[n][n];\\n        Map<Integer, Integer> pos = new HashMap<>();\\n        for (int i = 0; i < n; i++) {\\n            pos.put(A[i], i);\\n            for (int j = i; j < n; j++) {\\n                dp[i][j] = 2;\\n            }\\n        }\\n        for (int j = 2; j < n; j++) {\\n            for (int i = j - 1; i > 0; i--) {\\n                int prev = A[j] - A[i];\\n                if (prev >= A[i]) {\\n                    break;\\n                }\\n                if (!pos.containsKey(prev)) {\\n                    continue;\\n                }\\n                dp[i][j] = dp[pos.get(prev)][i] + 1;\\n            }\\n        }\\n        int result = 0;\\n        for (int j = 2; j < n; j++) {\\n            for (int i = 1; i < n - 1; i++) {\\n                if (dp[i][j] > 2) {\\n                    result = Math.max(result, dp[i][j]);\\n                }\\n            }\\n        }\\n        return result;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 152537,
                "title": "c-dp-solution",
                "content": "Denote by dp[i][j], the length of longest fibonacci subsequence with last two terms A[i] and A[j].\\nInitially dp[i][j] = 2 for any i < j.\\ndp[i][j] = max(dp[i][j], dp[k][i] + 1 if A[j] - A[i] == A[k] and k < i). for any i < j.\\nGiven the value v, we can use hashmap to quickly find the right index k that A[k] = v;\\nHere is the code.\\n```\\nclass Solution {\\npublic:\\n    int lenLongestFibSubseq(vector<int>& A) {\\n        int n = A.size();\\n        map<int, int> m; \\n        for (int i = 0; i < n; i++) m[A[i]] = i;\\n        vector<vector<int>> dp(n, vector<int>(n, 2));\\n    \\tfor (int j = 1; j < n; j++)\\n    \\t\\tfor (int i = 0; i < j; i++)\\n    \\t\\t\\tif (m.find(A[j]-A[i]) != m.end() and m[A[j] - A[i]] < i)\\n    \\t\\t\\t\\tdp[i][j] = max(dp[i][j], dp[m[A[j] - A[i]]][i] + 1);\\n    \\tint ans = 0;\\n    \\tfor (int i = 0; i < n; i++)\\n    \\t\\tfor (int j = i+1; j < n; j++)\\n    \\t\\t\\tans = max(ans, dp[i][j]);\\n    \\t\\n    \\treturn (ans==2)?0:ans;\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    int lenLongestFibSubseq(vector<int>& A) {\\n        int n = A.size();\\n        map<int, int> m; \\n        for (int i = 0; i < n; i++) m[A[i]] = i;\\n        vector<vector<int>> dp(n, vector<int>(n, 2));\\n    \\tfor (int j = 1; j < n; j++)\\n    \\t\\tfor (int i = 0; i < j; i++)\\n    \\t\\t\\tif (m.find(A[j]-A[i]) != m.end() and m[A[j] - A[i]] < i)\\n    \\t\\t\\t\\tdp[i][j] = max(dp[i][j], dp[m[A[j] - A[i]]][i] + 1);\\n    \\tint ans = 0;\\n    \\tfor (int i = 0; i < n; i++)\\n    \\t\\tfor (int j = i+1; j < n; j++)\\n    \\t\\t\\tans = max(ans, dp[i][j]);\\n    \\t\\n    \\treturn (ans==2)?0:ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 995368,
                "title": "hashmap-c",
                "content": "```\\nclass Solution {\\npublic:\\n    int lenLongestFibSubseq(vector<int>& arr) {\\n        unordered_set<int> set;\\n        for(int i=0;i<arr.size();i++){\\n            set.insert(arr[i]);\\n        }\\n        int cnt=0;\\n        int maxi=INT_MIN;\\n        for(int i=0;i<arr.size();i++){\\n            for(int j=i+1;j<arr.size();j++){\\n                int a=arr[i],b=arr[j];\\n                int c=a+b;\\n                cnt=2;\\n              while(set.find(c)!=set.end()){\\n                  cnt++;\\n                  a=b;\\n                  b=c;\\n                  c=a+b;\\n              }\\n              maxi=max(maxi,cnt);\\n            }\\n        }\\n        return maxi>2?maxi:0;\\n    }\\n};\\n```\\n**Feel free to ask any question in the comment section.**\\nI hope that you\\'ve found the solution useful.\\nIn that case, **please do upvote and encourage me** to on my quest to document all leetcode problems\\uD83D\\uDE03\\nHappy Coding :)\\n",
                "solutionTags": [
                    "C++",
                    "C"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int lenLongestFibSubseq(vector<int>& arr) {\\n        unordered_set<int> set;\\n        for(int i=0;i<arr.size();i++){\\n            set.insert(arr[i]);\\n        }\\n        int cnt=0;\\n        int maxi=INT_MIN;\\n        for(int i=0;i<arr.size();i++){\\n            for(int j=i+1;j<arr.size();j++){\\n                int a=arr[i],b=arr[j];\\n                int c=a+b;\\n                cnt=2;\\n              while(set.find(c)!=set.end()){\\n                  cnt++;\\n                  a=b;\\n                  b=c;\\n                  c=a+b;\\n              }\\n              maxi=max(maxi,cnt);\\n            }\\n        }\\n        return maxi>2?maxi:0;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 233537,
                "title": "python-detailed-explanation-evolution-from-o-n-3-to-o-n-2-dp",
                "content": "The DP formula is straight forward. `dp[i][j]` represents the LFS ending at i and j, where i < j.\\nfor `j=[0..n]`, `i=[0..j-1]`, `dp[i][j] = max(dp[i][j], 1+dp[k][i])`, where `k=[0..i-1]` if `A[k]+A[i]=A[j]`. \\n\\nCode:\\n\\n```\\nclass Solution:\\n    def lenLongestFibSubseq(self, A: \\'List[int]\\') -> \\'int\\':\\n        n = len(A)\\n        dp = [[2 for _ in range(n+1)] for _ in range(n+1)]\\n        for j in range(n):\\n            for i in range(j):\\n                for k in range(i):\\n                    if A[k]+A[i] == A[j]:\\n                        dp[i][j] = max(dp[i][j], 1+dp[k][i])\\n        ans = max([max(n) for n in dp])\\n        return 0 if ans <= 2 else ans\\n```\\n\\nSince we don\\'t know where the LFS ends, we will take the maximum of all `dp[i][j]` in the DP array. The above solution is `O(n^3)` and gives us TLE. \\n\\nOur states are defined by `i and j`, so there at most `i*j` calculations to be done. So, If we can get rid of the last for loop, then we can optomize our solution to the best possible `O(n^2)` for this formula.\\n\\nWell if you think about it, we iterate from `j=[0, n]`, and `i=[0,j-1]`. And then, we iterate from `k=[0, i-1]`. But why do we iterate for `k`? We already covered that range when we iterated for `i`. \\n\\nWell, the whole point is to find a value `k` such that `A[k]+A[i]=A[j]`, and `k < i`. So for each `i` and each `j`, we have to iterate\\n\\nIf we re-arrange the formula, `A[j]-A[i]=A[k]`. So in other words, we want to find a element in the array that equals `A[j]-A[i]`. If there is an element in the array that equals this, we have to make sure it exists `before i`. \\n\\nThis can be done in O(1). First, store all the `{value:index}` for all elements in the array in a hash table. Then, for each `i`, simply check if `A[j]-A[i]` is in the hash table, and if it exists before i. If it does, then we can say `k = map[A[j]-A[i]]`, and our formula stays the same. Since the array is strictly increasing, we don\\'t have to worry about duplicate values. Thus, we are able to get rid of the last loop and turn it into a constant time operation, which means our solution is now `O(n^2)`.\\n\\nUpdated solution:\\n\\n```\\nclass Solution:\\n    def lenLongestFibSubseq(self, A: \\'List[int]\\') -> \\'int\\':\\n\\n        map = collections.defaultdict(int)\\n        for i, v in enumerate(A):\\n            map[v]=i\\n        n = len(A)\\n        dp = [[2 for _ in range(n+1)] for _ in range(n+1)]\\n        for j in range(n):\\n            for i in range(j):\\n                diff = A[j]-A[i]\\n                if diff in map and map[diff] < i:\\n                    k = map[diff]\\n                    dp[i][j] = max(dp[i][j], 1+dp[k][i])\\n        ans = max([max(n) for n in dp])\\n        return 0 if ans <= 2 else ans\\n```\\n\\n",
                "solutionTags": [],
                "code": "```\\nclass Solution:\\n    def lenLongestFibSubseq(self, A: \\'List[int]\\') -> \\'int\\':\\n        n = len(A)\\n        dp = [[2 for _ in range(n+1)] for _ in range(n+1)]\\n        for j in range(n):\\n            for i in range(j):\\n                for k in range(i):\\n                    if A[k]+A[i] == A[j]:\\n                        dp[i][j] = max(dp[i][j], 1+dp[k][i])\\n        ans = max([max(n) for n in dp])\\n        return 0 if ans <= 2 else ans\\n```\n```\\nclass Solution:\\n    def lenLongestFibSubseq(self, A: \\'List[int]\\') -> \\'int\\':\\n\\n        map = collections.defaultdict(int)\\n        for i, v in enumerate(A):\\n            map[v]=i\\n        n = len(A)\\n        dp = [[2 for _ in range(n+1)] for _ in range(n+1)]\\n        for j in range(n):\\n            for i in range(j):\\n                diff = A[j]-A[i]\\n                if diff in map and map[diff] < i:\\n                    k = map[diff]\\n                    dp[i][j] = max(dp[i][j], 1+dp[k][i])\\n        ans = max([max(n) for n in dp])\\n        return 0 if ans <= 2 else ans\\n```",
                "codeTag": "Java"
            },
            {
                "id": 152334,
                "title": "java-hashmap-straightforward",
                "content": "Use map to save num and idx.\\nThen brute force all Fibonacci sequences\\n\\n```\\n    public int lenLongestFibSubseq(int[] A) {\\n        if(A == null || A.length == 0)\\n            return 0;\\n        Map<Integer,Integer> map = new HashMap<>();\\n        for(int i=0; i<A.length; ++i)\\n            map.put(A[i],i);\\n        int maxLen = 0;\\n        for(int i=0; i<A.length; ++i){\\n            for(int j=i+1; j<A.length; ++j){\\n                int left = i, right = j, count = 0;\\n                while(map.containsKey(A[left] + A[right])){\\n                    int temp = right;\\n                    right = map.get(A[left] + A[right]);\\n                    left = temp;\\n                    count ++;\\n                }\\n                // if exists a sequence, add first 2 nums\\n                if(count != 0){\\n                    count += 2;\\n                    maxLen = Math.max(maxLen,count);\\n                }\\n            }\\n        }\\n        return maxLen;\\n    }\\n```",
                "solutionTags": [],
                "code": "```\\n    public int lenLongestFibSubseq(int[] A) {\\n        if(A == null || A.length == 0)\\n            return 0;\\n        Map<Integer,Integer> map = new HashMap<>();\\n        for(int i=0; i<A.length; ++i)\\n            map.put(A[i],i);\\n        int maxLen = 0;\\n        for(int i=0; i<A.length; ++i){\\n            for(int j=i+1; j<A.length; ++j){\\n                int left = i, right = j, count = 0;\\n                while(map.containsKey(A[left] + A[right])){\\n                    int temp = right;\\n                    right = map.get(A[left] + A[right]);\\n                    left = temp;\\n                    count ++;\\n                }\\n                // if exists a sequence, add first 2 nums\\n                if(count != 0){\\n                    count += 2;\\n                    maxLen = Math.max(maxLen,count);\\n                }\\n            }\\n        }\\n        return maxLen;\\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 152373,
                "title": "leetcode-weekly-contest-94-screencast",
                "content": "https://www.youtube.com/watch?v=y7vN4ODhqHo&t=19s\\n\\nHope it\\'s helpful.",
                "solutionTags": [],
                "code": "https://www.youtube.com/watch?v=y7vN4ODhqHo&t=19s\\n\\nHope it\\'s helpful.",
                "codeTag": "Unknown"
            },
            {
                "id": 845040,
                "title": "c-dp-solution-explained-in-details",
                "content": "Runtime: 448 ms, faster than 38.34% of C++ online submissions for Length of Longest Fibonacci Subsequence.\\nMemory Usage: 61.9 MB, less than 16.58% of C++ online submissions for Length of Longest Fibonacci Subsequence.\\n\\n```\\nclass Solution {\\npublic:\\n    int getIndex(unordered_map<int,int> &track, int key)\\n    {\\n        if(track.find(key)==track.end())return -1;\\n        else return track[key];\\n    }\\n    \\n    int lenLongestFibSubseq(vector<int>& A) {\\n        \\n        int n = A.size();\\n        \\n        //2D DP memory for ignoring ambiguous value overlapping \\n        vector<vector<int>>dp(n,vector<int>(n,0));\\n        \\n        // Map for tracking the index of any value in the array\\n        unordered_map<int,int> track;\\n        \\n        // Populating track map for values to index \\n        for(int i=0;i<A.size();i++)\\n            track[A[i]] = i;\\n                    \\n        // Max length of the fibonacci sequence\\n        int maxL = 0;\\n        \\n        // Double loop for checking every pair of values\\n        for(int i=0;i<A.size()-1;i++)\\n        {\\n            for(int j=i+1;j<A.size();j++)\\n            {\\n                // Get the difference \"Key\" between two value A[j] and A[i] such that Key + A[i] = A[j] and j > i\\n                // Here given array is strictly increasing and so A[i] < A[j] always\\n                // We check if the Key exists in the given array and also check if the index of \"Key\" is less than\\n                // the index \"i\" cause the smaller value should be in the \\n                //left of the ith value as the array is strictly increasing\\n                \\n                int key = A[j] - A[i];\\n                \\n                // Returns index of the Key if exsists in array, otherwise returns -1\\n                int index = getIndex(track,key);\\n                if(index>-1 && index< i)\\n                {\\n                    // We Populate dp[i][j] by comparing with dp[index][i] + 1 and \\n                    //previous dp[i][j] value as  A[index] + A[i] = A[j] \\n                    \\n                    dp[i][j] = max(dp[i][j], dp[index][i]+ 1);\\n                    if(maxL<dp[i][j])maxL=dp[i][j];\\n                }\\n            }\\n        }\\n        \\n        // If the max Length is 0 we return 0 or max length + 2\\n        return (maxL==0)?0:(maxL+2);        \\n        \\n    }\\n};\\n```",
                "solutionTags": [
                    "C",
                    "Dynamic Programming"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int getIndex(unordered_map<int,int> &track, int key)\\n    {\\n        if(track.find(key)==track.end())return -1;\\n        else return track[key];\\n    }\\n    \\n    int lenLongestFibSubseq(vector<int>& A) {\\n        \\n        int n = A.size();\\n        \\n        //2D DP memory for ignoring ambiguous value overlapping \\n        vector<vector<int>>dp(n,vector<int>(n,0));\\n        \\n        // Map for tracking the index of any value in the array\\n        unordered_map<int,int> track;\\n        \\n        // Populating track map for values to index \\n        for(int i=0;i<A.size();i++)\\n            track[A[i]] = i;\\n                    \\n        // Max length of the fibonacci sequence\\n        int maxL = 0;\\n        \\n        // Double loop for checking every pair of values\\n        for(int i=0;i<A.size()-1;i++)\\n        {\\n            for(int j=i+1;j<A.size();j++)\\n            {\\n                // Get the difference \"Key\" between two value A[j] and A[i] such that Key + A[i] = A[j] and j > i\\n                // Here given array is strictly increasing and so A[i] < A[j] always\\n                // We check if the Key exists in the given array and also check if the index of \"Key\" is less than\\n                // the index \"i\" cause the smaller value should be in the \\n                //left of the ith value as the array is strictly increasing\\n                \\n                int key = A[j] - A[i];\\n                \\n                // Returns index of the Key if exsists in array, otherwise returns -1\\n                int index = getIndex(track,key);\\n                if(index>-1 && index< i)\\n                {\\n                    // We Populate dp[i][j] by comparing with dp[index][i] + 1 and \\n                    //previous dp[i][j] value as  A[index] + A[i] = A[j] \\n                    \\n                    dp[i][j] = max(dp[i][j], dp[index][i]+ 1);\\n                    if(maxL<dp[i][j])maxL=dp[i][j];\\n                }\\n            }\\n        }\\n        \\n        // If the max Length is 0 we return 0 or max length + 2\\n        return (maxL==0)?0:(maxL+2);        \\n        \\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 328037,
                "title": "top-down-memoization",
                "content": "```\\nclass Solution {\\n    private int[] v;\\n    private Integer[][] memo;\\n    private Map<Integer, Integer> map;\\n\\n    public int solve(int i, int j){\\n        if(!map.containsKey(v[i]+v[j]))\\n            return 0;\\n        \\n        if(memo[i][j] != null)\\n            return memo[i][j];\\n        \\n        return memo[i][j] = 1 + solve(j, map.get(v[i]+v[j]));\\n    }\\n\\n\\n    public int lenLongestFibSubseq(int[] v) {\\n        this.v = v;\\n        if(v.length <= 2)\\n            return v.length;\\n        \\n        map = new HashMap<>();\\n        for(int i=0; i<v.length; i++)\\n            map.put(v[i], i);\\n        memo = new Integer[v.length][v.length];\\n\\n        int ans = 0;\\n        for(int i=0; i<v.length-2; i++)\\n            for(int j=i+1; j<v.length-1; j++)\\n                ans = Math.max(ans, solve(i, j));\\n        \\n        return ans >= 1 ? ans + 2 : 0;\\n        \\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    private int[] v;\\n    private Integer[][] memo;\\n    private Map<Integer, Integer> map;\\n\\n    public int solve(int i, int j){\\n        if(!map.containsKey(v[i]+v[j]))\\n            return 0;\\n        \\n        if(memo[i][j] != null)\\n            return memo[i][j];\\n        \\n        return memo[i][j] = 1 + solve(j, map.get(v[i]+v[j]));\\n    }\\n\\n\\n    public int lenLongestFibSubseq(int[] v) {\\n        this.v = v;\\n        if(v.length <= 2)\\n            return v.length;\\n        \\n        map = new HashMap<>();\\n        for(int i=0; i<v.length; i++)\\n            map.put(v[i], i);\\n        memo = new Integer[v.length][v.length];\\n\\n        int ans = 0;\\n        for(int i=0; i<v.length-2; i++)\\n            for(int j=i+1; j<v.length-1; j++)\\n                ans = Math.max(ans, solve(i, j));\\n        \\n        return ans >= 1 ? ans + 2 : 0;\\n        \\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1661208,
                "title": "c-solution-using-unordered-set",
                "content": "\\n```\\nclass Solution {\\npublic:\\n    int lenLongestFibSubseq(vector<int>& arr) {\\n        unordered_set<int>st;\\n        for(int i = 0; i < arr.size(); i++){\\n            st.insert(arr[i]);\\n        }\\n        int temp = 0;\\n        int ans = INT_MIN;\\n        for(int i = 0; i < arr.size(); i++){\\n            for(int j = i+1; j < arr.size(); j++){\\n                int x = arr[i];\\n                int y = arr[j];\\n                int z = x+y;\\n                temp = 2;\\n                while(st.find(z) != st.end()){\\n                    temp++;\\n                    x = y;\\n                    y = z;\\n                    z = x+y;\\n                }\\n                ans = max(ans, temp);\\n            }\\n        }\\n        if(ans <= 2){\\n            return 0;\\n        }\\n        return ans;\\n    }\\n};",
                "solutionTags": [
                    "C++"
                ],
                "code": "class Solution {\\npublic:\\n    int lenLongestFibSubseq(vector<int>& arr) {\\n        unordered_set<int>st;\\n        for(int i = 0; i < arr.size(); i++){\\n            st.insert(arr[i]);\\n        }",
                "codeTag": "Java"
            },
            {
                "id": 180262,
                "title": "python-99-beat-simple-dp-soltion",
                "content": "`DP[i][j]` means the result of index from (0, ... i, j)\n\nThe default value of `DP` is 2 because the case of subarray `[i, j]`. (of course 2 is invalid answer, we should update the result only if the length of subsequence is greater then 2)\n\nWe should check every pair `(i, j)` such that `0<i<j<length(A)` to find `DP[i][j]`.\n\nLet's find the `DP[i][j]` as following.\n\n`DP[i][j]` should be the result of `DP[k][i]+1`,  such `k` is Array index of `X` that satisfies the following condition.\n- `(X < A[i]),  (X in A)  and  (X + A[i] = A[j])`\n\nand, both to check that `X` is in `A` and find the array index of `X`, we can store the value-index by using dictionary, only if index is less then `i` (because `X < A[i]`). this is `idx` dict.\n\nTime complexity : `O(N^2)`\nSpace complexity : `O(N)` ( we store only if `(i,j)` satisfy the condition. Simply, think about that fix the `i` and if there are `M` pair `(i, j)` combinations to store, then there are also `M` number of another value `k` in `A`, so `M` is included in `N`)  \n```\nclass Solution(object):\n    def lenLongestFibSubseq(self, A):\n        dp = collections.defaultdict(lambda : 2)\n        ret, idx = 0, { A[0] : 0 }\n        for i in xrange(1, len(A)-1):\n            idx[A[i]] = i\n            for j in xrange(i+1, len(A)):\n                x = A[j] - A[i]\n                if x >= A[i] : break\n                elif x not in idx: continue\n                dp[i,j] = dp[idx[x], i] + 1\n                ret = max(ret, dp[i,j])\n        return ret \n```",
                "solutionTags": [],
                "code": "```\nclass Solution(object):\n    def lenLongestFibSubseq(self, A):\n        dp = collections.defaultdict(lambda : 2)\n        ret, idx = 0, { A[0] : 0 }\n        for i in xrange(1, len(A)-1):\n            idx[A[i]] = i\n            for j in xrange(i+1, len(A)):\n                x = A[j] - A[i]\n                if x >= A[i] : break\n                elif x not in idx: continue\n                dp[i,j] = dp[idx[x], i] + 1\n                ret = max(ret, dp[i,j])\n        return ret \n```",
                "codeTag": "Java"
            },
            {
                "id": 1821672,
                "title": "c-memoization-with-inuition",
                "content": "```\\n************\\nclass Solution {\\npublic:\\n    \\n    // Intuition : Checking between all possible pairs of indexes and returning maximum among them\\n    \\n    // Why dp beacause we may calculate some pairs already in previous iterations of recursive call\\n    \\n    int dp[1001][1001];\\n    int recur(vector<int>&v,int i,int j,unordered_map<int,int>&m){\\n        if(m.find(v[i]+v[j])==m.end()) return 0;\\n        if(dp[i][j]!=-1) return dp[i][j];\\n        return dp[i][j]=1+recur(v,j,m[v[i]+v[j]],m);  // Moving i to j and j m[v[i]+v[j]];\\n    }\\n    int lenLongestFibSubseq(vector<int>& a) {\\n        unordered_map<int,int>m;\\n        for(int i=0;i<a.size();i++){\\n            m[a[i]]=i;   \\n        }\\n        int MAXI=0;\\n        memset(dp,-1,sizeof(dp));\\n        for(int i=0;i<a.size()-2;i++){\\n            for(int j=i+1;j<a.size()-1;j++){\\n                if(m.find(a[i]+a[j])==m.end())  // v[i]+v[j] is not present no need to call function                                                    for current pair\\n                    continue;\\n                MAXI=max(recur(a,i,j,m),MAXI);\\n            }\\n        }\\n        return MAXI>0?MAXI+2:0;\\n    }\\n};\\n```",
                "solutionTags": [
                    "Dynamic Programming",
                    "Memoization"
                ],
                "code": "```\\n************\\nclass Solution {\\npublic:\\n    \\n    // Intuition : Checking between all possible pairs of indexes and returning maximum among them\\n    \\n    // Why dp beacause we may calculate some pairs already in previous iterations of recursive call\\n    \\n    int dp[1001][1001];\\n    int recur(vector<int>&v,int i,int j,unordered_map<int,int>&m){\\n        if(m.find(v[i]+v[j])==m.end()) return 0;\\n        if(dp[i][j]!=-1) return dp[i][j];\\n        return dp[i][j]=1+recur(v,j,m[v[i]+v[j]],m);  // Moving i to j and j m[v[i]+v[j]];\\n    }\\n    int lenLongestFibSubseq(vector<int>& a) {\\n        unordered_map<int,int>m;\\n        for(int i=0;i<a.size();i++){\\n            m[a[i]]=i;   \\n        }\\n        int MAXI=0;\\n        memset(dp,-1,sizeof(dp));\\n        for(int i=0;i<a.size()-2;i++){\\n            for(int j=i+1;j<a.size()-1;j++){\\n                if(m.find(a[i]+a[j])==m.end())  // v[i]+v[j] is not present no need to call function                                                    for current pair\\n                    continue;\\n                MAXI=max(recur(a,i,j,m),MAXI);\\n            }\\n        }\\n        return MAXI>0?MAXI+2:0;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 970567,
                "title": "js-map-100",
                "content": "```\\nvar lenLongestFibSubseq = function(A) {\\n    var map = new Map();\\n    \\n    for(var a of A){\\n        map.set(a, true);\\n    }\\n    \\n    A.sort((a,b)=>a-b);\\n    \\n    var len = 0;\\n    \\n    for(var i=0; i<A.length; i++){\\n        for(var j=i+1; j<A.length; j++){\\n            var left = A[i];\\n            var right = A[j];\\n            var tempLen = 0;\\n            while(map.has(left+right)){\\n                tempLen++;\\n                var temp = left+right;\\n                left = right;\\n                right = temp;\\n            }\\n            len = Math.max(len, tempLen+2);\\n        }\\n    }\\n    \\n    return len>2?len:0;\\n};\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\nvar lenLongestFibSubseq = function(A) {\\n    var map = new Map();\\n    \\n    for(var a of A){\\n        map.set(a, true);\\n    }\\n    \\n    A.sort((a,b)=>a-b);\\n    \\n    var len = 0;\\n    \\n    for(var i=0; i<A.length; i++){\\n        for(var j=i+1; j<A.length; j++){\\n            var left = A[i];\\n            var right = A[j];\\n            var tempLen = 0;\\n            while(map.has(left+right)){\\n                tempLen++;\\n                var temp = left+right;\\n                left = right;\\n                right = temp;\\n            }\\n            len = Math.max(len, tempLen+2);\\n        }\\n    }\\n    \\n    return len>2?len:0;\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 742164,
                "title": "java-dp",
                "content": "**DP with 2 sum**\\n```java\\nclass Solution {\\n    /*\\n    * dp[i][j] is the max length of fibbonacci series whose last two elements\\n    * are A[i] & A[j]\\n    * for any integer A[k] we need to find two number A[i] & A[j] such that\\n    * i < j < k and A[i] + A[j] == A[k], we can find such pairs in O(n) time\\n    * complexity.\\n    * if there exist i,j,k such that i < j < k and A[i] + A[j] == A[k] then\\n    * dp[k][j] = dp[i][j] + 1 (A[k], A[j] are last two elements of fibbonacc series)\\n    */\\n    public int lenLongestFibSubseq(int[] A) {\\n        int n = A.length;\\n        int[][] dp = new int[n][n];\\n        int result = 0;\\n        for (int k = 2; k < n; k++) {\\n            int i = 0, j = k-1;\\n            while(i < j) {\\n                int sum = A[i] + A[j] - A[k];\\n                if (sum < 0) {\\n                    i++;\\n                } else if (sum > 0) {\\n                    j--;\\n                } else {\\n                    // ith, jth kth element are fibbonaci sequence\\n                    dp[j][k] = dp[i][j] + 1; // since numbers are unique\\n                    result = Math.max(result, dp[j][k]);\\n                    i++;\\n                    j--;\\n                }\\n            }\\n        }\\n        return result + 2 >= 3? result + 2: 0;\\n    }\\n}\\n```\\n\\n**Another DP solution (Time limit exceeded)**\\n```java\\nclass Solution {\\n    public int lenLongestFibSubseq(int[] A) {\\n        for (int i = 0; i < A.length; i++) {\\n            fb[i] = new HashMap<>();\\n            for (int j = i-1; j >= 0; j--) {\\n                int lastval = A[i] - A[j];\\n                if (lastval <= 0) {\\n                    break;\\n                }\\n                fb[i].put(A[j], fb[j].getOrDefault(lastval, 1) + 1);\\n                result = Math.max(fb[i].get(A[j]), result);\\n            }\\n        }\\n        return result >= 3? result: 0;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```java\\nclass Solution {\\n    /*\\n    * dp[i][j] is the max length of fibbonacci series whose last two elements\\n    * are A[i] & A[j]\\n    * for any integer A[k] we need to find two number A[i] & A[j] such that\\n    * i < j < k and A[i] + A[j] == A[k], we can find such pairs in O(n) time\\n    * complexity.\\n    * if there exist i,j,k such that i < j < k and A[i] + A[j] == A[k] then\\n    * dp[k][j] = dp[i][j] + 1 (A[k], A[j] are last two elements of fibbonacc series)\\n    */\\n    public int lenLongestFibSubseq(int[] A) {\\n        int n = A.length;\\n        int[][] dp = new int[n][n];\\n        int result = 0;\\n        for (int k = 2; k < n; k++) {\\n            int i = 0, j = k-1;\\n            while(i < j) {\\n                int sum = A[i] + A[j] - A[k];\\n                if (sum < 0) {\\n                    i++;\\n                } else if (sum > 0) {\\n                    j--;\\n                } else {\\n                    // ith, jth kth element are fibbonaci sequence\\n                    dp[j][k] = dp[i][j] + 1; // since numbers are unique\\n                    result = Math.max(result, dp[j][k]);\\n                    i++;\\n                    j--;\\n                }\\n            }\\n        }\\n        return result + 2 >= 3? result + 2: 0;\\n    }\\n}\\n```\n```java\\nclass Solution {\\n    public int lenLongestFibSubseq(int[] A) {\\n        for (int i = 0; i < A.length; i++) {\\n            fb[i] = new HashMap<>();\\n            for (int j = i-1; j >= 0; j--) {\\n                int lastval = A[i] - A[j];\\n                if (lastval <= 0) {\\n                    break;\\n                }\\n                fb[i].put(A[j], fb[j].getOrDefault(lastval, 1) + 1);\\n                result = Math.max(fb[i].get(A[j]), result);\\n            }\\n        }\\n        return result >= 3? result: 0;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 164126,
                "title": "python-dp-very-easy-to-understand",
                "content": "```\\nclass Solution:\\n    # DP\\n    # Fibonacci sequence: X_1,X_2, ..., X_n, n >= 3, where X_i + X_i+1 = X_i+2, i+2 <= n\\n    # dp[j][i] is the length of the fibonacci sequence that ending with A[j] and A[i]\\n    # dp[j][i] = dp[k][j] + 1, if existing A[k] == A[i] - A[j]\\n    #          = 2, otherwise\\n    def lenLongestFibSubseq(self, A):\\n        \"\"\"\\n        :type A: List[int]\\n        :rtype: int\\n        \"\"\"\\n        n = len(A)\\n        dp = [[2 for _ in range(n)] for _ in range(n)]\\n        s = {}\\n\\n        for i, v in enumerate(A):\\n            s[v] = i\\n    \\n        res = 2\\n        for i in range(2, n):\\n            for j in range(i):\\n                k = s.get(A[i] - A[j], -1)\\n                if 0 <= k < j:\\n                    dp[j][i] = dp[k][j] + 1\\n                    res = max(res, dp[j][i])\\n        \\n        return res if res > 2 else 0\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution:\\n    # DP\\n    # Fibonacci sequence: X_1,X_2, ..., X_n, n >= 3, where X_i + X_i+1 = X_i+2, i+2 <= n\\n    # dp[j][i] is the length of the fibonacci sequence that ending with A[j] and A[i]\\n    # dp[j][i] = dp[k][j] + 1, if existing A[k] == A[i] - A[j]\\n    #          = 2, otherwise\\n    def lenLongestFibSubseq(self, A):\\n        \"\"\"\\n        :type A: List[int]\\n        :rtype: int\\n        \"\"\"\\n        n = len(A)\\n        dp = [[2 for _ in range(n)] for _ in range(n)]\\n        s = {}\\n\\n        for i, v in enumerate(A):\\n            s[v] = i\\n    \\n        res = 2\\n        for i in range(2, n):\\n            for j in range(i):\\n                k = s.get(A[i] - A[j], -1)\\n                if 0 <= k < j:\\n                    dp[j][i] = dp[k][j] + 1\\n                    res = max(res, dp[j][i])\\n        \\n        return res if res > 2 else 0\\n```",
                "codeTag": "Java"
            },
            {
                "id": 152393,
                "title": "python-o-n-2-straightforward-solution-w-hash-table",
                "content": "```\\nclass Solution:\\n    def lenLongestFibSubseq(self, A):\\n        n, pair, res, back = len(A), {}, 0, set()\\n        for i in range(n):\\n            back.add(A[i])\\n            j = i + 1\\n            mx = 2 * A[i]\\n            while j < n and A[j] < mx:\\n                if (A[j] - A[i], A[i]) in pair:\\n                    pair[(A[i], A[j])] = pair[(A[j] - A[i], A[i])] + 1\\n                else:\\n                    pair[(A[i], A[j])] = A[j] - A[i] in back and 3 or 2\\n                res = max(res, pair[(A[i], A[j])])\\n                j += 1\\n        return res > 2 and res or 0\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution:\\n    def lenLongestFibSubseq(self, A):\\n        n, pair, res, back = len(A), {}, 0, set()\\n        for i in range(n):\\n            back.add(A[i])\\n            j = i + 1\\n            mx = 2 * A[i]\\n            while j < n and A[j] < mx:\\n                if (A[j] - A[i], A[i]) in pair:\\n                    pair[(A[i], A[j])] = pair[(A[j] - A[i], A[i])] + 1\\n                else:\\n                    pair[(A[i], A[j])] = A[j] - A[i] in back and 3 or 2\\n                res = max(res, pair[(A[i], A[j])])\\n                j += 1\\n        return res > 2 and res or 0\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3372119,
                "title": "python-elegant-short",
                "content": "# Complexity\\n- Time complexity: $$O(n^{2})$$\\n- Space complexity: $$O(n)$$\\n\\n# Code\\n```\\nclass Solution:\\n    def lenLongestFibSubseq(self, arr: List[int]) -> int:\\n        nums = set(arr)\\n        longest = 0\\n\\n        for i in range(len(arr)):\\n            for j in range(i + 1, len(arr)):\\n                a, b = arr[i], arr[j]\\n                length = 2\\n\\n                while a + b in nums:\\n                    a, b = b, a + b\\n                    length += 1\\n\\n                if length > 2 and length > longest:\\n                    longest = length\\n\\n        return longest\\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def lenLongestFibSubseq(self, arr: List[int]) -> int:\\n        nums = set(arr)\\n        longest = 0\\n\\n        for i in range(len(arr)):\\n            for j in range(i + 1, len(arr)):\\n                a, b = arr[i], arr[j]\\n                length = 2\\n\\n                while a + b in nums:\\n                    a, b = b, a + b\\n                    length += 1\\n\\n                if length > 2 and length > longest:\\n                    longest = length\\n\\n        return longest\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2865849,
                "title": "c-dp-memoization-map-recursion-easy-to-understand",
                "content": "```\\nclass Solution {\\npublic:\\n    unordered_map<int ,int> mp;\\n    vector<vector<int>> dp;\\n    int solve(vector<int>& arr,int i,int j)\\n    {\\n        if(mp.find(arr[i]+arr[j])==mp.end())\\n            return 0;\\n        if(dp[i][j]!=-1)\\n            return dp[i][j];\\n        return dp[i][j]=1+solve(arr,j,mp[arr[i]+arr[j]]);\\n    }\\n    int lenLongestFibSubseq(vector<int>& arr) \\n    {\\n        int n=arr.size();\\n        dp.resize(n,vector<int>(n,-1));\\n        for(int i=0;i<arr.size();i++)\\n        {\\n            mp[arr[i]]=i;\\n        }\\n        int ans=0;\\n        for(int i=0;i<n-ans+1;i++)\\n        {\\n            for(int j=i+1;j<n-ans+1;j++)\\n            {\\n                int mx=2+solve(arr,i,j);\\n                ans=max(ans,mx);\\n            }\\n        }\\n        return ans<3?0:ans;\\n    }\\n};\\n//if you like the solution plz upvote.",
                "solutionTags": [
                    "C",
                    "Dynamic Programming",
                    "Recursion",
                    "Memoization"
                ],
                "code": "class Solution {\\npublic:\\n    unordered_map<int ,int> mp;\\n    vector<vector<int>> dp;\\n    int solve(vector<int>& arr,int i,int j)\\n    {\\n        if(mp.find(arr[i]+arr[j])==mp.end())\\n            return 0;\\n        if(dp[i][j]!=-1)\\n            return dp[i][j];\\n        return dp[i][j]=1+solve(arr,j,mp[arr[i]+arr[j]]);\\n    }",
                "codeTag": "Java"
            },
            {
                "id": 2676551,
                "title": "easy-c-solution-using-set-in-o-n-2-log-n",
                "content": "```\\nclass Solution {\\npublic:\\n    // this question has two solutions....\\n    // first solution is by using the logic of fibonacci series and finding the next number of the series in O(log n)by using hashset\\n    // second solution is by using LIS(DP)\\n    int lenLongestFibSubseq(vector<int>& arr) {\\n        int n = arr.size();\\n        //storing every element in set;\\n        set<int>st;\\n        for(int i = 0; i < n; i++){\\n            st.insert(arr[i]);\\n        }\\n        \\n        //Now finding the length of the subsequence by fixing the first two numbers of the series and finding the next numbers in the series using set.\\n        int maxLen = 0;\\n        for(int i = 0; i < n-1; i++){\\n            for(int j = i+1; j < n; j++){\\n                int a = arr[i], b = arr[j];\\n                int len = 2;\\n                while(st.find(a+b) != st.end()){\\n                    int c = a+b;\\n                    a = b;\\n                    b = c;\\n                    len++;\\n                    if(len >= 3)maxLen = max(maxLen, len);\\n                }\\n            }\\n        }\\n        \\n        return maxLen;\\n        \\n    }\\n};\\n```",
                "solutionTags": [
                    "Ordered Set"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    // this question has two solutions....\\n    // first solution is by using the logic of fibonacci series and finding the next number of the series in O(log n)by using hashset\\n    // second solution is by using LIS(DP)\\n    int lenLongestFibSubseq(vector<int>& arr) {\\n        int n = arr.size();\\n        //storing every element in set;\\n        set<int>st;\\n        for(int i = 0; i < n; i++){\\n            st.insert(arr[i]);\\n        }\\n        \\n        //Now finding the length of the subsequence by fixing the first two numbers of the series and finding the next numbers in the series using set.\\n        int maxLen = 0;\\n        for(int i = 0; i < n-1; i++){\\n            for(int j = i+1; j < n; j++){\\n                int a = arr[i], b = arr[j];\\n                int len = 2;\\n                while(st.find(a+b) != st.end()){\\n                    int c = a+b;\\n                    a = b;\\n                    b = c;\\n                    len++;\\n                    if(len >= 3)maxLen = max(maxLen, len);\\n                }\\n            }\\n        }\\n        \\n        return maxLen;\\n        \\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1404636,
                "title": "c-dp-solution",
                "content": "```\\nint lenLongestFibSubseq(vector<int>& arr) {\\n  // dp[i, j] means length of Fibonacci ended by arr[i], arr[j]\\n  // dp[a, b] = (dp[b - a, a] + 1 ) or 2\\n  // notice that b - a must sumaller than a\\n  if (arr.size() <= 2) {\\n\\treturn 0;\\n  }\\n  int result = 0;\\n  int n = arr.size();\\n  unordered_map<int, int> map;\\n  vector<vector<int>> dp(n, vector<int>(n, 0));\\n  for (int j = 0; j < n; ++ j) {\\n\\tmap[arr[j]] = j;\\n\\tfor (int i = 0; i < j; ++ i) {\\n\\t  auto it = map.find(arr[j] - arr[i]);\\n\\t  int k = (it == map.end()) ? -1 : it->second;\\n\\t  dp[i][j] = (arr[j] - arr[i] < arr[i] && k != -1) ? (dp[k][i] + 1) : 2;\\n\\t  result = max(result, dp[i][j]);\\n\\t}\\n  }\\n  return result > 2 ? result : 0;\\n} \\n```",
                "solutionTags": [],
                "code": "```\\nint lenLongestFibSubseq(vector<int>& arr) {\\n  // dp[i, j] means length of Fibonacci ended by arr[i], arr[j]\\n  // dp[a, b] = (dp[b - a, a] + 1 ) or 2\\n  // notice that b - a must sumaller than a\\n  if (arr.size() <= 2) {\\n\\treturn 0;\\n  }\\n  int result = 0;\\n  int n = arr.size();\\n  unordered_map<int, int> map;\\n  vector<vector<int>> dp(n, vector<int>(n, 0));\\n  for (int j = 0; j < n; ++ j) {\\n\\tmap[arr[j]] = j;\\n\\tfor (int i = 0; i < j; ++ i) {\\n\\t  auto it = map.find(arr[j] - arr[i]);\\n\\t  int k = (it == map.end()) ? -1 : it->second;\\n\\t  dp[i][j] = (arr[j] - arr[i] < arr[i] && k != -1) ? (dp[k][i] + 1) : 2;\\n\\t  result = max(result, dp[i][j]);\\n\\t}\\n  }\\n  return result > 2 ? result : 0;\\n} \\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1274783,
                "title": "c-short-solution",
                "content": "```\\nclass Solution {\\npublic:\\n    int lenLongestFibSubseq(vector<int>& arr) {\\n        //we will store in the array of index for what wee are searching for\\n        vector<vector<int>> dp(arr.size(),vector<int>(1000,1));\\n        //map to store the index of the element\\n        unordered_map<int,int> mp;\\n        for(int i=0;i<arr.size();i++)\\n            mp[arr[i]]=i;\\n        int res=0;\\n        for(int i=1;i<arr.size();i++)\\n        {\\n            for(int j=i-1;j>=0;j--)\\n            {\\n                res=max(res,dp[j][i]+1);\\n                int need=arr[j]+arr[i];\\n                if(mp.find(need)!=mp.end())\\n                    dp[i][mp[need]]=dp[j][i]+1;\\n            }\\n        }\\n        return res>2 ? res : 0;\\n            \\n    }\\n};\\n```\\n**Do Upvote if this helps you :)**",
                "solutionTags": [
                    "C"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int lenLongestFibSubseq(vector<int>& arr) {\\n        //we will store in the array of index for what wee are searching for\\n        vector<vector<int>> dp(arr.size(),vector<int>(1000,1));\\n        //map to store the index of the element\\n        unordered_map<int,int> mp;\\n        for(int i=0;i<arr.size();i++)\\n            mp[arr[i]]=i;\\n        int res=0;\\n        for(int i=1;i<arr.size();i++)\\n        {\\n            for(int j=i-1;j>=0;j--)\\n            {\\n                res=max(res,dp[j][i]+1);\\n                int need=arr[j]+arr[i];\\n                if(mp.find(need)!=mp.end())\\n                    dp[i][mp[need]]=dp[j][i]+1;\\n            }\\n        }\\n        return res>2 ? res : 0;\\n            \\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1153755,
                "title": "recursive-python-solution",
                "content": "```\\nclass Solution:\\n    solution = 0\\n    def lenLongestFibSubseq(self, arr: List[int]) -> int:\\n        value_mapping = {value: idx for idx, value in enumerate(arr)}\\n        def search(first, second):\\n            if second == len(arr):\\n                return 0\\n            \\n            next_sum = arr[first] + arr[second]\\n            third = value_mapping.get(next_sum, None)\\n            if third is None:\\n                return 0\\n            \\n            dp = 1 + search(second, third)\\n            self.solution = max(dp, self.solution)\\n            return dp\\n        \\n        for i in range(len(arr)):\\n            for j in range(i+1, len(arr)):\\n                search(i, j)\\n        return self.solution + 2 if self.solution > 0 else 0\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution:\\n    solution = 0\\n    def lenLongestFibSubseq(self, arr: List[int]) -> int:\\n        value_mapping = {value: idx for idx, value in enumerate(arr)}\\n        def search(first, second):\\n            if second == len(arr):\\n                return 0\\n            \\n            next_sum = arr[first] + arr[second]\\n            third = value_mapping.get(next_sum, None)\\n            if third is None:\\n                return 0\\n            \\n            dp = 1 + search(second, third)\\n            self.solution = max(dp, self.solution)\\n            return dp\\n        \\n        for i in range(len(arr)):\\n            for j in range(i+1, len(arr)):\\n                search(i, j)\\n        return self.solution + 2 if self.solution > 0 else 0\\n```",
                "codeTag": "Java"
            },
            {
                "id": 826173,
                "title": "c-2d-dp-dfs-mem",
                "content": "```\\nclass Solution {\\npublic:\\n    vector<vector<int>> length;\\n    unordered_map<int, int> idx;\\n    \\n    int dfs(vector<int>& nums, int i, int j)\\n    {\\n        if(length[i][j] != -1)\\n        \\treturn length[i][j];\\n        else if(idx.count(nums[i] + nums[j]) == 0)\\n            return length[i][j] = 0;\\n        else\\n            return length[i][j] = max(length[i][j], 1 + dfs(nums, j, idx[nums[i] + nums[j]]));\\n    }\\n    \\n    int lenLongestFibSubseq(vector<int>& nums) \\n    {\\n    \\tif(nums.size() < 3)\\n    \\t\\treturn 0;\\n\\n    \\tfor(int i = 0; i < nums.size(); i++)\\n    \\t\\tidx[nums[i]] = i;\\n\\n    \\tint res = 0;\\n    \\tlength = vector<vector<int>>(nums.size(), vector<int>(nums.size(), -1));\\n        for(int i = 0; i + 1 < nums.size(); i++)\\n            for(int j = i + 1; nums[i] + nums[j] <= nums.back(); j++)\\n                res = max(res, dfs(nums, i, j));\\n\\n        return res == 0 ? res : res + 2;\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<vector<int>> length;\\n    unordered_map<int, int> idx;\\n    \\n    int dfs(vector<int>& nums, int i, int j)\\n    {\\n        if(length[i][j] != -1)\\n        \\treturn length[i][j];\\n        else if(idx.count(nums[i] + nums[j]) == 0)\\n            return length[i][j] = 0;\\n        else\\n            return length[i][j] = max(length[i][j], 1 + dfs(nums, j, idx[nums[i] + nums[j]]));\\n    }\\n    \\n    int lenLongestFibSubseq(vector<int>& nums) \\n    {\\n    \\tif(nums.size() < 3)\\n    \\t\\treturn 0;\\n\\n    \\tfor(int i = 0; i < nums.size(); i++)\\n    \\t\\tidx[nums[i]] = i;\\n\\n    \\tint res = 0;\\n    \\tlength = vector<vector<int>>(nums.size(), vector<int>(nums.size(), -1));\\n        for(int i = 0; i + 1 < nums.size(); i++)\\n            for(int j = i + 1; nums[i] + nums[j] <= nums.back(); j++)\\n                res = max(res, dfs(nums, i, j));\\n\\n        return res == 0 ? res : res + 2;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 702418,
                "title": "python",
                "content": "```\\nclass Solution:\\n    def lenLongestFibSubseq(self, A: List[int]) -> int:\\n        n = len(A)\\n        lookup = {}\\n        for i in range(len(A)):\\n            lookup[A[i]] = i\\n        longest = collections.defaultdict(lambda: 2)\\n        maxLength = 2\\n        for i in range(len(A)):\\n            a = A[i]\\n            for j in range(i + 1, len(A)):\\n                b = A[j]\\n                c = a + b\\n                if c in lookup:\\n                    longest[(j, lookup[c])] = longest[(i, j)] + 1\\n                    maxLength = max(longest[(j, lookup[c])], maxLength)\\n        return maxLength if maxLength != 2 else 0\\n```",
                "solutionTags": [
                    "Python",
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def lenLongestFibSubseq(self, A: List[int]) -> int:\\n        n = len(A)\\n        lookup = {}\\n        for i in range(len(A)):\\n            lookup[A[i]] = i\\n        longest = collections.defaultdict(lambda: 2)\\n        maxLength = 2\\n        for i in range(len(A)):\\n            a = A[i]\\n            for j in range(i + 1, len(A)):\\n                b = A[j]\\n                c = a + b\\n                if c in lookup:\\n                    longest[(j, lookup[c])] = longest[(i, j)] + 1\\n                    maxLength = max(longest[(j, lookup[c])], maxLength)\\n        return maxLength if maxLength != 2 else 0\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3086201,
                "title": "c-easy-to-get-kindly-upvote",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int lenLongestFibSubseq(vector<int>& arr) {\\n        int n=arr.size();\\n        unordered_map<int,int>m;\\n        for(int i=0;i<n;i++){\\n            m[arr[i]]++;\\n        }\\n        int an=0;\\n        for(int i=0;i<n;i++){\\n           \\n            for(int j=i+1;j<n;j++){\\n              int a=arr[i];\\n              int b=arr[j];\\n              int ans=2;\\n              while(m.find(a+b)!=m.end()){\\n                     ans++;\\n                     b=a+b;\\n                     a=b-a;\\n              }\\n              an=max(an,ans);\\n\\n            }\\n        }\\n        if(an<=2){\\n            return 0;\\n        }\\n        return an;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int lenLongestFibSubseq(vector<int>& arr) {\\n        int n=arr.size();\\n        unordered_map<int,int>m;\\n        for(int i=0;i<n;i++){\\n            m[arr[i]]++;\\n        }\\n        int an=0;\\n        for(int i=0;i<n;i++){\\n           \\n            for(int j=i+1;j<n;j++){\\n              int a=arr[i];\\n              int b=arr[j];\\n              int ans=2;\\n              while(m.find(a+b)!=m.end()){\\n                     ans++;\\n                     b=a+b;\\n                     a=b-a;\\n              }\\n              an=max(an,ans);\\n\\n            }\\n        }\\n        if(an<=2){\\n            return 0;\\n        }\\n        return an;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2592989,
                "title": "c-recursion-binary-search-intuitive",
                "content": "![image](https://assets.leetcode.com/users/images/d0c3f423-2014-41e8-af5c-50148a060ce2_1663506427.8616195.png)\\n\\n**k==Depth of Recursion Tree\\nT->O(n^2 X (logn)^k) && S->O(1)**\\n\\n\\t\\tclass Solution {\\n\\t\\tpublic:\\n\\t\\t\\tint f(int curr,int prev,vector<int>& nums,int n){\\n\\t\\t\\t\\tint t=nums[curr]+nums[prev];\\n\\t\\t\\t\\tint i=lower_bound(nums.begin(),nums.end(),t)-nums.begin();\\n\\t\\t\\t\\tif(i<n && nums[i]==t) return 1+f(i,curr,nums,n);\\n\\t\\t\\t\\treturn 1;\\n\\t\\t\\t}\\n\\n\\t\\t\\tint lenLongestFibSubseq(vector<int>& nums) {\\n\\t\\t\\t\\tint n=nums.size();\\n\\t\\t\\t\\tint maxi=0;\\n\\t\\t\\t\\tfor(int prev2=0;prev2<n;prev2++){\\n\\t\\t\\t\\t\\tfor(int prev1=prev2+1;prev1<n;prev1++){\\n\\t\\t\\t\\t\\t\\tint temp=nums[prev1]+nums[prev2];\\n\\t\\t\\t\\t\\t\\tint ind=lower_bound(nums.begin(),nums.end(),temp)-nums.begin();\\n\\t\\t\\t\\t\\t\\tif(ind<n && nums[ind]==temp) maxi=max(maxi,2+f(ind,prev1,nums,n));\\n\\t\\t\\t\\t\\t}\\n\\t\\t\\t\\t}\\n\\t\\t\\t\\treturn maxi;\\n\\t\\t\\t}\\n\\t\\t};",
                "solutionTags": [
                    "C++",
                    "C",
                    "Binary Search",
                    "Recursion"
                ],
                "code": "class Solution {\\n\\t\\tpublic:\\n\\t\\t\\tint f(int curr,int prev,vector<int>& nums,int n){\\n\\t\\t\\t\\tint t=nums[curr]+nums[prev];\\n\\t\\t\\t\\tint i=lower_bound(nums.begin(),nums.end(),t)-nums.begin();\\n\\t\\t\\t\\tif(i<n && nums[i]==t) return 1+f(i,curr,nums,n);\\n\\t\\t\\t\\treturn 1;\\n\\t\\t\\t}",
                "codeTag": "Java"
            },
            {
                "id": 2249123,
                "title": "c-easy-to-understand-simple-solution-using-hashmap",
                "content": "```\\nclass Solution {\\npublic:\\n    int lenLongestFibSubseq(vector<int>& arr) {\\n        int n=arr.size();\\n        int ans=0;\\n        unordered_map<int,int> mp;\\n        for(int i=0;i<n;i++)\\n        {\\n            mp[arr[i]]=i;\\n        }\\n        for(int i=0;i<n;i++)\\n        {\\n            for(int j=i+1;j<n;j++)\\n            {\\n                int count=2;\\n                int lastlast=arr[i];\\n                int last=arr[j];\\n                while(true)\\n                {\\n                    if(mp.find(lastlast+last)!=mp.end())\\n                    {\\n                        count++;\\n                        int z=last+lastlast;\\n                        lastlast=last;\\n                        last=z;\\n                    }\\n                    else\\n                    break;\\n                }\\n                ans=max(ans,count);\\n            }\\n        }\\n        if(ans==2)\\n        return 0;\\n        \\n        return ans;\\n    }\\n};\\n```\\n**Please upvote to motivate me in my quest of documenting all leetcode solutions. HAPPY CODING:)\\nAny suggestions and improvements are always welcome**\\n",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    int lenLongestFibSubseq(vector<int>& arr) {\\n        int n=arr.size();\\n        int ans=0;\\n        unordered_map<int,int> mp;\\n        for(int i=0;i<n;i++)\\n        {\\n            mp[arr[i]]=i;\\n        }\\n        for(int i=0;i<n;i++)\\n        {\\n            for(int j=i+1;j<n;j++)\\n            {\\n                int count=2;\\n                int lastlast=arr[i];\\n                int last=arr[j];\\n                while(true)\\n                {\\n                    if(mp.find(lastlast+last)!=mp.end())\\n                    {\\n                        count++;\\n                        int z=last+lastlast;\\n                        lastlast=last;\\n                        last=z;\\n                    }\\n                    else\\n                    break;\\n                }\\n                ans=max(ans,count);\\n            }\\n        }\\n        if(ans==2)\\n        return 0;\\n        \\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2245267,
                "title": "c-using-maps",
                "content": "```\\nclass Solution {\\npublic:\\n    int lenLongestFibSubseq(vector<int>& nums) {\\n        int n=nums.size();\\n        unordered_map<int,int> index;\\n        unordered_map<string,int> longest;\\n        for(int i=0; i<n; i++) index[nums[i]]=i;\\n        int ans=0;\\n        for(int i=0; i<n; i++) {\\n            for(int j=0; j<i; j++) {\\n                if(nums[i]-nums[j]<nums[j]&&index.count(nums[i]-nums[j])) {\\n                    int k=index[nums[i]-nums[j]];\\n                    string a=to_string(j)+\"@\"+to_string(i);\\n                    string b=to_string(k)+\"@\"+to_string(j);\\n                    longest[a]=longest[b]+1;\\n                    ans=max(ans,longest[a]+2);\\n                }\\n            }\\n        }\\n        return ans<3?0:ans;\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    int lenLongestFibSubseq(vector<int>& nums) {\\n        int n=nums.size();\\n        unordered_map<int,int> index;\\n        unordered_map<string,int> longest;\\n        for(int i=0; i<n; i++) index[nums[i]]=i;\\n        int ans=0;\\n        for(int i=0; i<n; i++) {\\n            for(int j=0; j<i; j++) {\\n                if(nums[i]-nums[j]<nums[j]&&index.count(nums[i]-nums[j])) {\\n                    int k=index[nums[i]-nums[j]];\\n                    string a=to_string(j)+\"@\"+to_string(i);\\n                    string b=to_string(k)+\"@\"+to_string(j);\\n                    longest[a]=longest[b]+1;\\n                    ans=max(ans,longest[a]+2);\\n                }\\n            }\\n        }\\n        return ans<3?0:ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2128965,
                "title": "c-simplest-solution-dynamic-programming-bottom-up-approach",
                "content": "We need to find the length of the longest Fibonacci sequence in the given array.\\n\\nA naive approach would be use a to determine  whether the next term of Fibonacci sequence is present in the array or not.\\nFor each pair a[i], a[j];  we maintain the next expected value sum = a[i] + a[j]. If sum is in the array, then we update these values, otherwise we stop and return the length.\\n\\n**DP APPROACH:**\\n\\nWe can use dp instead, where dp[i][j] stores the length of the fibonnaci sequence ending with i, j. We  update it to dp[j-i, i] + 1.\\n\\n* We traverse the array from index 2 till the last index. \\n\\n* At each index, we initiate ```l = 0``` and ```r = i-1``` --> to check if we can find ```a[l] + a[r] = a[i]```. \\n\\n* If the sum ```a[l] + a[r]``` is greater than ```a[i]```, we decrement ```r``` (Since the array is sorted in ascending order).\\n\\n* If it\\'s less than ```a[i]```, we increment ```l```.\\n\\n* If we find that ```sum = a[i]```, that means we found a fibonacci sequence ending with indices ```r``` and ```i```.\\n\\n* We update ```dp[r][i]``` to ```dp[l][r] + 1```.\\n\\n* We keep doing this until ```l < r``` -> To find the maximum length sequence ending at index ```i```.\\n\\n* Finally, we return ```maxLength + 2``` (If it\\'s not equal to 0).\\n\\n**Code:**\\n```\\nclass Solution {\\npublic:\\n    int lenLongestFibSubseq(vector<int>& a) {\\n        int n = a.size();\\n        vector<vector<int>> dp(n, vector<int>(n, 0));\\n        int maxi = 0;\\n        \\n        for(int i=2; i<n; i++) {\\n            int l = 0, r = i-1;\\n            \\n            while(l < r) {\\n                int sum = a[l] + a[r];\\n                if(sum > a[i]) r--;\\n                else if(sum < a[i]) l++;\\n                else {\\n                    dp[r][i] = dp[l][r] + 1;\\n                    maxi = max(maxi, dp[r][i]);\\n                    l++;\\n                    r--;\\n                }\\n            }\\n        }\\n        \\n        return maxi == 0 ? 0 : maxi+2;\\n    }\\n};\\n```\\n\\n\\n\\n\\n",
                "solutionTags": [
                    "C++",
                    "C",
                    "Dynamic Programming"
                ],
                "code": "```l = 0```\n```r = i-1```\n```a[l] + a[r] = a[i]```\n```a[l] + a[r]```\n```a[i]```\n```r```\n```a[i]```\n```l```\n```sum = a[i]```\n```r```\n```i```\n```dp[r][i]```\n```dp[l][r] + 1```\n```l < r```\n```i```\n```maxLength + 2```\n```\\nclass Solution {\\npublic:\\n    int lenLongestFibSubseq(vector<int>& a) {\\n        int n = a.size();\\n        vector<vector<int>> dp(n, vector<int>(n, 0));\\n        int maxi = 0;\\n        \\n        for(int i=2; i<n; i++) {\\n            int l = 0, r = i-1;\\n            \\n            while(l < r) {\\n                int sum = a[l] + a[r];\\n                if(sum > a[i]) r--;\\n                else if(sum < a[i]) l++;\\n                else {\\n                    dp[r][i] = dp[l][r] + 1;\\n                    maxi = max(maxi, dp[r][i]);\\n                    l++;\\n                    r--;\\n                }\\n            }\\n        }\\n        \\n        return maxi == 0 ? 0 : maxi+2;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2110611,
                "title": "java-solution",
                "content": "```\\n// Length of Longest Fibonacci Subsequence\\n// Leetcode: https://leetcode.com/problems/longest-fibonacci-subsequence/\\n\\nclass Solution {\\n    public int lenLongestFibSubseq(int[] arr) {\\n        int n = arr.length;\\n        int max = 0;\\n        Map<Integer, Integer> map = new HashMap<>();\\n        for (int i = 0; i < n; i++) {\\n            map.put(arr[i], i);\\n        }\\n        for (int i = 0; i < n; i++) {\\n            for (int j = i + 1; j < n; j++) {\\n                int a = arr[i];\\n                int b = arr[j];\\n                int k = 2;\\n                while (map.containsKey(a + b)) {\\n                    int c = a + b;\\n                    a = b;\\n                    b = c;\\n                    k++;\\n                }\\n                max = Math.max(max, k);\\n            }\\n        }\\n        return max == 2 ? 0 : max;       \\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\n// Length of Longest Fibonacci Subsequence\\n// Leetcode: https://leetcode.com/problems/longest-fibonacci-subsequence/\\n\\nclass Solution {\\n    public int lenLongestFibSubseq(int[] arr) {\\n        int n = arr.length;\\n        int max = 0;\\n        Map<Integer, Integer> map = new HashMap<>();\\n        for (int i = 0; i < n; i++) {\\n            map.put(arr[i], i);\\n        }\\n        for (int i = 0; i < n; i++) {\\n            for (int j = i + 1; j < n; j++) {\\n                int a = arr[i];\\n                int b = arr[j];\\n                int k = 2;\\n                while (map.containsKey(a + b)) {\\n                    int c = a + b;\\n                    a = b;\\n                    b = c;\\n                    k++;\\n                }\\n                max = Math.max(max, k);\\n            }\\n        }\\n        return max == 2 ? 0 : max;       \\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2099534,
                "title": "no-dp-java-hashset-solution-easy-to-understand-o-n2",
                "content": "\\tclass Solution {\\n\\t\\tpublic int lenLongestFibSubseq(int[] arr) {\\n\\n\\t\\t\\tHashSet<Integer> hs = new HashSet<>();\\n\\t\\t\\tfor(int i=0; i<arr.length; i++){\\n\\t\\t\\t\\ths.add(arr[i]);\\n\\t\\t\\t}\\n\\n\\t\\t\\tint count = 0;\\n\\t\\t\\tint max = 0;\\n\\n\\t\\t\\tfor(int i=0; i<arr.length; i++){\\n\\n\\t\\t\\t\\tfor(int j=i+1; j<arr.length; j++){\\n\\t\\t\\t\\t\\tint a = arr[i];\\n\\t\\t\\t\\t\\tint b = arr[j];\\n\\t\\t\\t\\t\\tint c = arr[i] + arr[j];\\n\\n\\t\\t\\t\\t\\tif(hs.contains(c))\\n\\t\\t\\t\\t\\t\\tcount = 2;\\n\\n\\t\\t\\t\\t\\twhile(hs.contains(c)){\\n\\t\\t\\t\\t\\t\\tcount++;\\n\\t\\t\\t\\t\\t\\ta = b;\\n\\t\\t\\t\\t\\t\\tb = c;\\n\\t\\t\\t\\t\\t\\tc = a+b;\\n\\t\\t\\t\\t\\t}\\n\\n\\t\\t\\t\\t\\tmax = Math.max(count , max);\\n\\n\\t\\t\\t\\t}\\n\\t\\t\\t}\\n\\n\\t\\t\\treturn max;\\n\\t\\t}\\n\\t}",
                "solutionTags": [
                    "Java"
                ],
                "code": "class Solution {\\n\\t\\tpublic int lenLongestFibSubseq(int[] arr) {\\n\\n\\t\\t\\tHashSet<Integer> hs = new HashSet<>();\\n\\t\\t\\tfor(int i=0; i<arr.length; i++){\\n\\t\\t\\t\\ths.add(arr[i]);\\n\\t\\t\\t}",
                "codeTag": "Java"
            },
            {
                "id": 1461894,
                "title": "dp-solution-o-n-2",
                "content": "```\\nclass Solution {\\npublic:\\n    int lenLongestFibSubseq(vector<int>& a) {\\n        int i,j,n=a.size(),ans=0;\\n        int dp[n+1][n+1];\\n        unordered_map<int,int> v2ind;\\n    \\n        for(i=0;i<n;i++)\\n            v2ind[a[i]]=i;\\n        \\n        for(i=0;i<n;i++)\\n            for(j=0;j<i;j++){\\n                dp[i][j]=2;  // minimum possible length of Fibonacci sequence that ends with a[j], a[i]\\n                if(a[i]-a[j]<a[j]){\\n                    auto it=v2ind.find(a[i]-a[j]);\\n                    if(it!=v2ind.end()){\\n                        dp[i][j]=max(dp[i][j],1+dp[j][it->second]);\\n                        ans=max(ans,dp[i][j]);\\n                    }\\n                }\\n            }\\n        \\n        if(ans<3)\\n            return 0;\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "C",
                    "Dynamic Programming"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int lenLongestFibSubseq(vector<int>& a) {\\n        int i,j,n=a.size(),ans=0;\\n        int dp[n+1][n+1];\\n        unordered_map<int,int> v2ind;\\n    \\n        for(i=0;i<n;i++)\\n            v2ind[a[i]]=i;\\n        \\n        for(i=0;i<n;i++)\\n            for(j=0;j<i;j++){\\n                dp[i][j]=2;  // minimum possible length of Fibonacci sequence that ends with a[j], a[i]\\n                if(a[i]-a[j]<a[j]){\\n                    auto it=v2ind.find(a[i]-a[j]);\\n                    if(it!=v2ind.end()){\\n                        dp[i][j]=max(dp[i][j],1+dp[j][it->second]);\\n                        ans=max(ans,dp[i][j]);\\n                    }\\n                }\\n            }\\n        \\n        if(ans<3)\\n            return 0;\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1157231,
                "title": "java-dp-brute-force-solution-20ms-99-75-73ms-43-47",
                "content": "DP Approach: [20ms,99.75%; 47.5MB,24.44%]\\n\\n```\\npublic int lenLongestFibSubseq(int[] arr) {\\n\\tint len = arr.length;\\n\\tint max = 0;\\n\\tint[][] dp = new int[len][len];\\n\\tfor (int i = 2; i < len; i++) {  // at least start from 2\\n\\t\\tint lo = 0, hi = i-1;\\n\\t\\twhile (lo < hi) {\\n\\t\\t\\tint sum = arr[lo] + arr[hi];\\n\\t\\t\\tif (sum < arr[i]) {\\n\\t\\t\\t\\tlo++;\\n\\t\\t\\t} else if (sum > arr[i]) {\\n\\t\\t\\t\\thi--;\\n\\t\\t\\t} else { //sum == arr[i]\\n\\t\\t\\t\\tdp[hi][i] = dp[lo][hi] + 1;\\n\\t\\t\\t\\tmax = Math.max(max, dp[hi][i]);\\n\\t\\t\\t\\tlo++;\\n\\t\\t\\t\\thi--;\\n\\t\\t\\t}\\n\\t\\t}\\n\\t}\\n\\treturn max > 0 ? max+2 : 0; // count the started 2 num in\\n}\\n```\\n\\n\\nBrute Force: [73ms,43.47%; 39MB,73.09%]\\n\\n```\\npublic int lenLongestFibSubseq(int[] arr) {\\n\\tSet<Integer> set = new HashSet<>();\\n\\tfor (int n : arr) set.add(n);\\n\\tint len = arr.length;\\n\\tint max = 0;\\n\\tfor (int i = 0; i < len-2; i++) { // `i` stand for the minimum index for a group fib\\n\\t\\tfor (int j = i+1; j < len-1; j++) { // `j` followed `i`\\n\\t\\t\\tint cnt = 2;\\n\\t\\t\\tint a = arr[i], b = arr[j];\\n\\t\\t\\twhile (set.contains(a+b)) {\\n\\t\\t\\t\\tint c = b;\\n\\t\\t\\t\\tb += a;\\n\\t\\t\\t\\ta = c;\\n\\t\\t\\t\\tcnt++;\\n\\t\\t\\t}\\n\\t\\t\\tif (cnt > 2) max = Math.max(max, cnt);\\n\\t\\t}\\n\\t}\\n\\treturn max;\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Dynamic Programming"
                ],
                "code": "```\\npublic int lenLongestFibSubseq(int[] arr) {\\n\\tint len = arr.length;\\n\\tint max = 0;\\n\\tint[][] dp = new int[len][len];\\n\\tfor (int i = 2; i < len; i++) {  // at least start from 2\\n\\t\\tint lo = 0, hi = i-1;\\n\\t\\twhile (lo < hi) {\\n\\t\\t\\tint sum = arr[lo] + arr[hi];\\n\\t\\t\\tif (sum < arr[i]) {\\n\\t\\t\\t\\tlo++;\\n\\t\\t\\t} else if (sum > arr[i]) {\\n\\t\\t\\t\\thi--;\\n\\t\\t\\t} else { //sum == arr[i]\\n\\t\\t\\t\\tdp[hi][i] = dp[lo][hi] + 1;\\n\\t\\t\\t\\tmax = Math.max(max, dp[hi][i]);\\n\\t\\t\\t\\tlo++;\\n\\t\\t\\t\\thi--;\\n\\t\\t\\t}\\n\\t\\t}\\n\\t}\\n\\treturn max > 0 ? max+2 : 0; // count the started 2 num in\\n}\\n```\n```\\npublic int lenLongestFibSubseq(int[] arr) {\\n\\tSet<Integer> set = new HashSet<>();\\n\\tfor (int n : arr) set.add(n);\\n\\tint len = arr.length;\\n\\tint max = 0;\\n\\tfor (int i = 0; i < len-2; i++) { // `i` stand for the minimum index for a group fib\\n\\t\\tfor (int j = i+1; j < len-1; j++) { // `j` followed `i`\\n\\t\\t\\tint cnt = 2;\\n\\t\\t\\tint a = arr[i], b = arr[j];\\n\\t\\t\\twhile (set.contains(a+b)) {\\n\\t\\t\\t\\tint c = b;\\n\\t\\t\\t\\tb += a;\\n\\t\\t\\t\\ta = c;\\n\\t\\t\\t\\tcnt++;\\n\\t\\t\\t}\\n\\t\\t\\tif (cnt > 2) max = Math.max(max, cnt);\\n\\t\\t}\\n\\t}\\n\\treturn max;\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 675162,
                "title": "java-100-do-not-need-more-math-max",
                "content": "\\n        if (A == null || A.length < 3) {\\n            return 0;\\n        }\\n        \\n        int len = A.length;\\n        int[][] dp = new int[len][len];\\n        int ans = 0;\\n        \\n        for (int i = 2; i < len; i++) {\\n            int left = 0; \\n            int right = i - 1;\\n            \\n            while (left < right) {\\n                if (A[left] + A[right] < A[i]) {\\n                    left++;\\n                } else if (A[left] + A[right] > A[i]) {\\n                    right--;\\n                } else {\\n\\t\\t\\t\\t\\t// dp[right][i] = Math.max(dp[right][i], dp[left][right] + 1);\\n                    dp[right][i] = dp[left][right] + 1;\\n                    ans = Math.max(ans, dp[right][i]);\\n                    left++;\\n                    right--;\\n                }\\n            }\\n        }        \\n        return ans > 0 ? ans + 2 : 0;",
                "solutionTags": [],
                "code": "\\n        if (A == null || A.length < 3) {\\n            return 0;\\n        }\\n        \\n        int len = A.length;\\n        int[][] dp = new int[len][len];\\n        int ans = 0;\\n        \\n        for (int i = 2; i < len; i++) {\\n            int left = 0; \\n            int right = i - 1;\\n            \\n            while (left < right) {\\n                if (A[left] + A[right] < A[i]) {\\n                    left++;\\n                } else if (A[left] + A[right] > A[i]) {\\n                    right--;\\n                } else {\\n\\t\\t\\t\\t\\t// dp[right][i] = Math.max(dp[right][i], dp[left][right] + 1);\\n                    dp[right][i] = dp[left][right] + 1;\\n                    ans = Math.max(ans, dp[right][i]);\\n                    left++;\\n                    right--;\\n                }\\n            }\\n        }        \\n        return ans > 0 ? ans + 2 : 0;",
                "codeTag": "Unknown"
            },
            {
                "id": 641862,
                "title": "easy-dp-soln-similar-to-lis",
                "content": "```\\nclass Solution {\\npublic:\\n    int lenLongestFibSubseq(vector<int>& A) {\\n        \\n        int n=A.size();\\n        int dp=[n][n]; // longest fibannacci sequence with last two elements as a[i] and a[j]\\n        unordered_map<int,int>m; //index-value pairs\\n       \\n        //Fill the map with value-index pairs\\n\\n        for(int i=0;i<n;i++)\\n        {\\n            m[A[i]]=i;\\n\\n            for(int j=i+1;j<n;j++)\\n            {\\n            \\tdp[i][j]=2;\\n            }\\n        }\\n\\n        // Find the element in map and update count in dp array corresponding to the index where it is found\\n\\n        for(int i=0;i<n;i++)\\n        {\\n        \\tfor(int j=i+1;j<n;j++)\\n        \\t{\\n        \\t\\tint search=A[i]+A[j];\\n\\n        \\t\\tif(m.find(search)!=m.end())\\n        \\t\\t{\\n        \\t\\t\\tdp[j][m[search]]=dp[i][j]+1;\\n        \\t\\t}\\n        \\t}\\n        }\\n\\n        // Find the longest sequence\\n\\n        int maxx=0;\\n\\n        for(int i=0;i<n;i++)\\n        {\\n        \\tfor(int j=i+1;j<n;j++)\\n        \\t{\\n        \\t\\tmaxx=max(maxx,dp[i][j]);\\n        \\t}\\n        }\\n         \\n        //If 2 no sequence is found as min lenght of a fib sequence has to be at least 3\\n\\n        if(maxx==2)\\n        {\\n        \\treturn 0; \\n        }\\n\\n        return maxx;\\n    }\\n};",
                "solutionTags": [
                    "C++",
                    "Dynamic Programming"
                ],
                "code": "class Solution {\\npublic:\\n    int lenLongestFibSubseq(vector<int>& A) {\\n        \\n        int n=A.size();\\n        int dp=[n][n]; // longest fibannacci sequence with last two elements as a[i] and a[j]\\n        unordered_map<int,int>m; //index-value pairs\\n       \\n        //Fill the map with value-index pairs\\n\\n        for(int i=0;i<n;i++)\\n        {\\n            m[A[i]]=i;\\n\\n            for(int j=i+1;j<n;j++)\\n            {\\n            \\tdp[i][j]=2;\\n            }",
                "codeTag": "Java"
            },
            {
                "id": 504804,
                "title": "c-dp-from-tle-to-optimization-with-hash-map",
                "content": "I used simple DP to solve this question first but it resulted in TLE. So I moved on to think some potential optimization methods. After checking the official solution, I find out that this question has one hidden hypothesis:\\n\\n> Each number only exists once in the array.\\n\\nSo I shared my code from simple DP to the optimized one to display my thinking process. Hope this can help you to understand this question.\\n\\n```c++\\nclass Solution {\\npublic:\\n    int lenLongestFibSubseq(vector<int>& A) {\\n        int n = A.size();\\n        if (n < 3) {\\n            return 0;\\n        }\\n        \\n        vector<vector<int>> dp(n, vector<int>(n, 2));\\n        \\n        // optimize\\n        unordered_map<int, int> idx_map;\\n        for(int i = 0; i < n; i++)\\n            idx_map[A[i]] = i;\\n        \\n        int ans = 1;\\n        \\n        for(int j = 0; j < n; j++){\\n             for(int i = 0; i < j; i++){\\n\\t\\t\\t\\t // simple DP\\n                // for(int k = 0; k < i; k++){\\n                //     if(A[k] + A[i] == A[j])\\n                //         dp[i][j] = max(dp[i][j], dp[k][i]+1);\\n                // }\\n                 \\n                // use hash map\\n                 int target = A[j] - A[i];\\n                 if(idx_map.count(target) > 0){\\n                     int k = idx_map[target];\\n                     if(k < i){\\n                         dp[i][j] = max(dp[i][j], dp[k][i] + 1);\\n                         ans = max(ans, dp[i][j]);\\n                     }\\n                 }\\n            }\\n        }\\n        \\n        return ans < 3 ? 0 : ans;\\n    }\\n};\\n\\n```\\n",
                "solutionTags": [],
                "code": "```c++\\nclass Solution {\\npublic:\\n    int lenLongestFibSubseq(vector<int>& A) {\\n        int n = A.size();\\n        if (n < 3) {\\n            return 0;\\n        }\\n        \\n        vector<vector<int>> dp(n, vector<int>(n, 2));\\n        \\n        // optimize\\n        unordered_map<int, int> idx_map;\\n        for(int i = 0; i < n; i++)\\n            idx_map[A[i]] = i;\\n        \\n        int ans = 1;\\n        \\n        for(int j = 0; j < n; j++){\\n             for(int i = 0; i < j; i++){\\n\\t\\t\\t\\t // simple DP\\n                // for(int k = 0; k < i; k++){\\n                //     if(A[k] + A[i] == A[j])\\n                //         dp[i][j] = max(dp[i][j], dp[k][i]+1);\\n                // }\\n                 \\n                // use hash map\\n                 int target = A[j] - A[i];\\n                 if(idx_map.count(target) > 0){\\n                     int k = idx_map[target];\\n                     if(k < i){\\n                         dp[i][j] = max(dp[i][j], dp[k][i] + 1);\\n                         ans = max(ans, dp[i][j]);\\n                     }\\n                 }\\n            }\\n        }\\n        \\n        return ans < 3 ? 0 : ans;\\n    }\\n};\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 406546,
                "title": "python-720ms-to-108ms-with-optimization",
                "content": "```\\nif num2 * (longest - 2) >= nums[-1]: \\n\\tbreak\\n```\\nThis line takes it from ~700ms to ~110ms the logic is that the last number in the given array has to be less than num2 * (current length of longest Fibonacci subsequence found - 2) or else there would be no point in checking num1, num2 the sequence that starts with num1, num2 has a length that is shorter than the current longest subsequence so we break out of the loop to avoid unnecessary computation.\\n\\n```\\nclass Solution:\\n    def lenLongestFibSubseq(self, nums: List[int]) -> int:\\n        longest = 0\\n        dictionary = set(nums)\\n        \\n        for i in range(len(nums) - 1):\\n            for j in range(i + 1, len(nums)):\\n                \\n                num1, num2 = nums[i], nums[j]\\n                streak = 0\\n                \\n                if num2 * (longest - 2) >= nums[-1]:\\n                    break\\n                \\n                while num1 + num2 in dictionary:\\n                    if not streak:\\n                        streak = 3\\n                    else:\\n                        streak += 1\\n                        \\n                    num1, num2 = num2, num1 + num2\\n                    \\n                if streak > longest:\\n                    longest = streak\\n                \\n        return longest\\n```",
                "solutionTags": [],
                "code": "```\\nif num2 * (longest - 2) >= nums[-1]: \\n\\tbreak\\n```\n```\\nclass Solution:\\n    def lenLongestFibSubseq(self, nums: List[int]) -> int:\\n        longest = 0\\n        dictionary = set(nums)\\n        \\n        for i in range(len(nums) - 1):\\n            for j in range(i + 1, len(nums)):\\n                \\n                num1, num2 = nums[i], nums[j]\\n                streak = 0\\n                \\n                if num2 * (longest - 2) >= nums[-1]:\\n                    break\\n                \\n                while num1 + num2 in dictionary:\\n                    if not streak:\\n                        streak = 3\\n                    else:\\n                        streak += 1\\n                        \\n                    num1, num2 = num2, num1 + num2\\n                    \\n                if streak > longest:\\n                    longest = streak\\n                \\n        return longest\\n```",
                "codeTag": "Java"
            },
            {
                "id": 365410,
                "title": "why-dp-is-faster",
                "content": "This is not necessarily a dp problem since distinct fibonacci-like sequences won\\'t share any subproblem. So doing dp is just like find the initial state(x1, x2) and add 1 to the length every time when x1 +  x2 exists. \\n```\\n\\n    def lenLongestFibSubseq(self, A: List[int]) -> int:\\n        s = set(A)\\n        seen = set()\\n        max_len = 2\\n        for i in range(len(A) - 1):\\n            for j in range(i + 1, len(A) - max_len + 2):\\n                \\n                cur_len = 2\\n                state = (A[i], A[j])\\n                if state in seen:\\n                    continue\\n                while sum(state) in s:\\n                    cur_len += 1\\n                    state = (state[1], sum(state))\\n                    seen.add(state)\\n                # print(cur_len, seen)\\n                max_len = cur_len if cur_len > max_len else max_len\\n        return max_len if max_len > 2 else 0\\n                    \\n```\\n\\nI tried a non-dp approach, using a set to memorize the seen pairs (x1, x2) to eliminate duplicated caculations. IMO it should finish in a comparable time as the dp approach but it\\'s two times slower.\\n\\nAny thoughts why?",
                "solutionTags": [],
                "code": "```\\n\\n    def lenLongestFibSubseq(self, A: List[int]) -> int:\\n        s = set(A)\\n        seen = set()\\n        max_len = 2\\n        for i in range(len(A) - 1):\\n            for j in range(i + 1, len(A) - max_len + 2):\\n                \\n                cur_len = 2\\n                state = (A[i], A[j])\\n                if state in seen:\\n                    continue\\n                while sum(state) in s:\\n                    cur_len += 1\\n                    state = (state[1], sum(state))\\n                    seen.add(state)\\n                # print(cur_len, seen)\\n                max_len = cur_len if cur_len > max_len else max_len\\n        return max_len if max_len > 2 else 0\\n                    \\n```",
                "codeTag": "Python3"
            },
            {
                "id": 300856,
                "title": "java-different-approach",
                "content": "Not fast, just for fun.\\n\\n```\\npublic static int lenLongestFibSubseq(int[] A) {\\n    int longestFibSubseq = 0;\\n    Set<Integer> set = new HashSet<>();\\n    for (int val : A) {\\n      set.add(val);\\n    }\\n    for (int i = 0; i < A.length; i++) {\\n      for (int j = i + 1; j < A.length; j++) {\\n        int first = A[i];\\n        int second = A[j];\\n        int count = 2;\\n        while (set.contains(first + second)) {\\n          count++;\\n          int tmp = first;\\n          first = second;\\n          second = tmp + first;\\n        }\\n        if (count > 2 && longestFibSubseq < count) {\\n          longestFibSubseq = count;\\n        }\\n      }\\n    }\\n    return longestFibSubseq;\\n  }\\n```\\n\\nRuntime: 60 ms, faster than 76.73% of Java online submissions for Length of Longest Fibonacci Subsequence.\\nMemory Usage: 38.3 MB, less than 96.23% of Java online submissions for Length of Longest Fibonacci Subsequence.",
                "solutionTags": [],
                "code": "```\\npublic static int lenLongestFibSubseq(int[] A) {\\n    int longestFibSubseq = 0;\\n    Set<Integer> set = new HashSet<>();\\n    for (int val : A) {\\n      set.add(val);\\n    }\\n    for (int i = 0; i < A.length; i++) {\\n      for (int j = i + 1; j < A.length; j++) {\\n        int first = A[i];\\n        int second = A[j];\\n        int count = 2;\\n        while (set.contains(first + second)) {\\n          count++;\\n          int tmp = first;\\n          first = second;\\n          second = tmp + first;\\n        }\\n        if (count > 2 && longestFibSubseq < count) {\\n          longestFibSubseq = count;\\n        }\\n      }\\n    }\\n    return longestFibSubseq;\\n  }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 175756,
                "title": "c-solution-dp-with-very-detailed-comments",
                "content": "```\\nclass Solution {\\npublic:\\n    int lenLongestFibSubseq(vector<int>& A) {\\n        int size = A.size();\\n\\t\\t\\t\\t\\n        //our result\\n        int longest = 0;\\n        unordered_map<int,int> reverseIndex;\\n        \\n        //create a reverse index between A[i] -> i\\n        for(int i = 0; i < size; ++i){\\n            reverseIndex[A[i]] = i;\\n        }\\n      \\n        //the dp table dp[i][k] means the longest fib sequence ending with indexes k and i (i being the end)\\n        vector<vector<int>> dp(size,vector<int>(size,0));\\n       \\n        for(int i = 0; i < size; ++i){\\n            for(int k = i; k >= 0; k--){\\n                \\n                //if i == k we only have one element\\n                if(i == k){\\n                    dp[i][k] = 1;\\n                    continue;\\n                }\\n\\n                //for each pair (k,i) we have a minimum size of 2 (its a pair after all)\\n                dp[i][k] = 2;\\n                \\n                //the previous number in the sequence\\n                int n = A[i] - A[k];                \\n                \\n                //find the number in our reverseIndex\\n                if(reverseIndex.find(n) != reverseIndex.end()){      \\n                    int revi = reverseIndex[n];\\n                    \\n                    //if the index of that number is less than k we know that we have a winner\\n                    if(revi < k){         \\n                        \\n                        //update the max for this pair\\n                        dp[i][k] = max(dp[i][k],dp[k][revi] + 1);\\n                    }\\n                }\\n            \\n                //update our global result\\n                longest = max(longest,dp[i][k]);\\n            }\\n        }\\n        \\n        //the rule is that the sequence has to be of length >= 3\\n        return longest < 3 ? 0 : longest;\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    int lenLongestFibSubseq(vector<int>& A) {\\n        int size = A.size();\\n\\t\\t\\t\\t\\n        //our result\\n        int longest = 0;\\n        unordered_map<int,int> reverseIndex;\\n        \\n        //create a reverse index between A[i] -> i\\n        for(int i = 0; i < size; ++i){\\n            reverseIndex[A[i]] = i;\\n        }\\n      \\n        //the dp table dp[i][k] means the longest fib sequence ending with indexes k and i (i being the end)\\n        vector<vector<int>> dp(size,vector<int>(size,0));\\n       \\n        for(int i = 0; i < size; ++i){\\n            for(int k = i; k >= 0; k--){\\n                \\n                //if i == k we only have one element\\n                if(i == k){\\n                    dp[i][k] = 1;\\n                    continue;\\n                }\\n\\n                //for each pair (k,i) we have a minimum size of 2 (its a pair after all)\\n                dp[i][k] = 2;\\n                \\n                //the previous number in the sequence\\n                int n = A[i] - A[k];                \\n                \\n                //find the number in our reverseIndex\\n                if(reverseIndex.find(n) != reverseIndex.end()){      \\n                    int revi = reverseIndex[n];\\n                    \\n                    //if the index of that number is less than k we know that we have a winner\\n                    if(revi < k){         \\n                        \\n                        //update the max for this pair\\n                        dp[i][k] = max(dp[i][k],dp[k][revi] + 1);\\n                    }\\n                }\\n            \\n                //update our global result\\n                longest = max(longest,dp[i][k]);\\n            }\\n        }\\n        \\n        //the rule is that the sequence has to be of length >= 3\\n        return longest < 3 ? 0 : longest;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 152743,
                "title": "easy-java-with-comments-global-set-variable-start-pair-check-approach",
                "content": "```\\nclass Solution {\\n    \\n    Set<Integer> set = new HashSet<> ();\\n    int end;\\n    public int lenLongestFibSubseq(int[] nums) {\\n        for (int num : nums) set.add(num);\\n        int maxLen = Integer.MIN_VALUE;\\n        end = nums[nums.length-1];\\n        for (int i=0;i<nums.length;i++) {\\n            for (int j=i+1;j<nums.length-1;j++) {\\n                // here nums[i] and nums[j] will be all the possible ocmbinations of first two elements of the fibo\\n                // we should run the j loop till nums.length -1 because the array is STRICTLY increasing\\n                /// and thus the sum will definitely be out of bound\\n                maxLen = Math.max(maxLen , checkFiboCount(nums[i], nums[j]));\\n            }\\n        }\\n        if (maxLen > 2) return maxLen;\\n        else return 0;\\n    }\\n    \\n    public int checkFiboCount (int a, int b) {\\n        int len = 2;\\n        \\n        // two exit conditions\\n        // 1. if the array does not have next fibo element\\n        // 2. if the sum goes beyonf the array\\n        while (set.contains(a+b) && (a+b) <= end) {\\n            b = a+b;\\n            a = b-a;\\n            len++;\\n        }\\n        \\n        return len;\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    \\n    Set<Integer> set = new HashSet<> ();\\n    int end;\\n    public int lenLongestFibSubseq(int[] nums) {\\n        for (int num : nums) set.add(num);\\n        int maxLen = Integer.MIN_VALUE;\\n        end = nums[nums.length-1];\\n        for (int i=0;i<nums.length;i++) {\\n            for (int j=i+1;j<nums.length-1;j++) {\\n                // here nums[i] and nums[j] will be all the possible ocmbinations of first two elements of the fibo\\n                // we should run the j loop till nums.length -1 because the array is STRICTLY increasing\\n                /// and thus the sum will definitely be out of bound\\n                maxLen = Math.max(maxLen , checkFiboCount(nums[i], nums[j]));\\n            }\\n        }\\n        if (maxLen > 2) return maxLen;\\n        else return 0;\\n    }\\n    \\n    public int checkFiboCount (int a, int b) {\\n        int len = 2;\\n        \\n        // two exit conditions\\n        // 1. if the array does not have next fibo element\\n        // 2. if the sum goes beyonf the array\\n        while (set.contains(a+b) && (a+b) <= end) {\\n            b = a+b;\\n            a = b-a;\\n            len++;\\n        }\\n        \\n        return len;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 152400,
                "title": "javascript-dp-solution",
                "content": "Copy the idea from https://leetcode.com/problems/length-of-longest-fibonacci-subsequence/discuss/152332/Java-clean-DP-O(n2)-time-O(n2)-space\\n\\n```js\\nfunction lenLongestFibSubseq(A) {\\n  const map = {};\\n  const N = A.length;\\n  const dp = [...Array(N)].map(r => Array(N).fill(2));\\n  \\n  let max = 0;\\n  for (let i = 0; i < N; i++) {\\n    map[A[i]] = i;\\n    for (let j = 0; j < i; j++) {\\n      if (A[i]-A[j] < A[j] && A[i]-A[j] in map) {\\n        dp[j][i] = Math.max(dp[j][i], 1 + dp[map[A[i]-A[j]]][j]);\\n      }\\n      max = Math.max(max, dp[j][i]);\\n    }\\n  }\\n  return max === 2 ? 0 : max;\\n}\\n```",
                "solutionTags": [],
                "code": "```js\\nfunction lenLongestFibSubseq(A) {\\n  const map = {};\\n  const N = A.length;\\n  const dp = [...Array(N)].map(r => Array(N).fill(2));\\n  \\n  let max = 0;\\n  for (let i = 0; i < N; i++) {\\n    map[A[i]] = i;\\n    for (let j = 0; j < i; j++) {\\n      if (A[i]-A[j] < A[j] && A[i]-A[j] in map) {\\n        dp[j][i] = Math.max(dp[j][i], 1 + dp[map[A[i]-A[j]]][j]);\\n      }\\n      max = Math.max(max, dp[j][i]);\\n    }\\n  }\\n  return max === 2 ? 0 : max;\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3994048,
                "title": "unordered-set-c-killer-solution-clean",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int lenLongestFibSubseq(vector<int>& arr) \\n    {\\n        int n=arr.size();\\n        int maxi=INT_MIN;\\n        int count=0;\\n        unordered_set<int> st;\\n        for(auto i:arr)\\n        {\\n            st.insert(i);\\n        }\\n        for(int i=0;i<n;i++)\\n        {\\n            for(int j=i+1;j<n;j++)\\n            {\\n                int var=arr[i];\\n                int var2=arr[j];\\n                int sum=var+var2;\\n                count=2;\\n                while(st.find(sum)!=st.end())\\n                {\\n                    count++;\\n                    var=var2;\\n                    var2=sum;\\n                    sum=var+var2;\\n                }\\n                maxi=max(maxi,count);\\n            }\\n        }\\n        if(maxi>2)\\n        return maxi;\\n        else\\n        return 0;\\n\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int lenLongestFibSubseq(vector<int>& arr) \\n    {\\n        int n=arr.size();\\n        int maxi=INT_MIN;\\n        int count=0;\\n        unordered_set<int> st;\\n        for(auto i:arr)\\n        {\\n            st.insert(i);\\n        }\\n        for(int i=0;i<n;i++)\\n        {\\n            for(int j=i+1;j<n;j++)\\n            {\\n                int var=arr[i];\\n                int var2=arr[j];\\n                int sum=var+var2;\\n                count=2;\\n                while(st.find(sum)!=st.end())\\n                {\\n                    count++;\\n                    var=var2;\\n                    var2=sum;\\n                    sum=var+var2;\\n                }\\n                maxi=max(maxi,count);\\n            }\\n        }\\n        if(maxi>2)\\n        return maxi;\\n        else\\n        return 0;\\n\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3794453,
                "title": "dp-binary-search-hashmap-c",
                "content": "```\\nclass Solution {\\npublic:\\n    int solv(int i,int j,vector<int>&arr, vector<vector<int>>&dp)\\n    {\\n        if(j>=arr.size() || i>j)\\n            return 0;\\n        if(dp[i][j]!=-1)\\n            return dp[i][j];\\n        int x=0;\\n        int l=j+1,r=arr.size()-1;\\n        while(l<=r)\\n        {\\n            int mid=(l+r)/2;\\n            if(arr[mid]==arr[j]+arr[i])\\n            {\\n                x=1+solv(j,mid,arr,dp);\\n                break;\\n            }\\n            else if(arr[mid]>arr[j]+arr[i])\\n            {\\n                r=mid-1;\\n            }\\n            else\\n                l=mid+1;\\n        }\\n        return dp[i][j]=x;\\n    }\\n    int lenLongestFibSubseq(vector<int>& arr) {\\n        int n=arr.size();\\n        vector<vector<int>>dp(n,vector<int>(n,-1));\\n        int ans=0;\\n        unordered_map<int,int>m;\\n        for(int i=0;i<arr.size();i++){\\n            m[arr[i]]=i;   \\n        }\\n        for(int i=0;i<n;i++)\\n        {\\n            for(int j=i+1;j<n;j++)\\n            {\\n                if(m.find(arr[i]+arr[j])!=m.end())\\n                    ans=max(ans,2+solv(i,j,arr,dp));\\n            }\\n        }\\n        return ans>=3?ans:0;\\n    }\\n};",
                "solutionTags": [
                    "C",
                    "Binary Search",
                    "Dynamic Programming"
                ],
                "code": "class Solution {\\npublic:\\n    int solv(int i,int j,vector<int>&arr, vector<vector<int>>&dp)\\n    {\\n        if(j>=arr.size() || i>j)\\n            return 0;\\n        if(dp[i][j]!=-1)\\n            return dp[i][j];\\n        int x=0;\\n        int l=j+1,r=arr.size()-1;\\n        while(l<=r)\\n        {\\n            int mid=(l+r)/2;\\n            if(arr[mid]==arr[j]+arr[i])\\n            {\\n                x=1+solv(j,mid,arr,dp);\\n                break;\\n            }",
                "codeTag": "Java"
            },
            {
                "id": 3684258,
                "title": "fix-first-2-positions",
                "content": "```\\nclass Solution:\\n    def lenLongestFibSubseq(self, arr: List[int]) -> int:\\n        n = len(arr)\\n        exists = set(arr)\\n        res = 0\\n        for i in range(n):\\n            for j in range(i + 1, n):\\n                a = arr[i]\\n                b = arr[j]\\n                l = 2\\n                while a + b in exists:\\n                    a, b = b, a + b\\n                    l += 1\\n                if l > 2:\\n                    res = max(res, l)\\n        return res\\n```",
                "solutionTags": [
                    "Python"
                ],
                "code": "```\\nclass Solution:\\n    def lenLongestFibSubseq(self, arr: List[int]) -> int:\\n        n = len(arr)\\n        exists = set(arr)\\n        res = 0\\n        for i in range(n):\\n            for j in range(i + 1, n):\\n                a = arr[i]\\n                b = arr[j]\\n                l = 2\\n                while a + b in exists:\\n                    a, b = b, a + b\\n                    l += 1\\n                if l > 2:\\n                    res = max(res, l)\\n        return res\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3503828,
                "title": "solution",
                "content": "```C++ []\\nclass Solution {\\npublic:\\n    int lenLongestFibSubseq(vector<int>& arr) {\\n        int n = arr.size();\\n        map<pair<int,int>,int>indexes;\\n\\n        for(int i = 2 ;i < n;i++) {\\n            int start = 0;\\n            int end = i-1;\\n            long long reqSum = arr[i];\\n            long long sum;\\n            while(start != end) {\\n                sum = arr[start] + (long long)arr[end];\\n                if(sum == reqSum) {\\n                    indexes[{start,end}] = i;\\n                    start++;\\n                }\\n                else if(sum < reqSum) start++;\\n                else end--;\\n            }\\n        }\\n        int count = 0;\\n        int maxCount = 0;\\n        for(auto &it : indexes) {\\n            count = 2;\\n            int i=it.first.first,j=it.first.second,k=it.second;\\n            while((long long)arr[i]+arr[j] == (long long)arr[k]) {\\n                count++;\\n                i = j;\\n                j = k;\\n                k = indexes[{i,j}];\\n            }\\n            if(count > maxCount)maxCount = count;\\n        }\\n        return maxCount;\\n    }\\n};\\n```\\n\\n```Python3 []\\nclass Solution:\\n  def lenLongestFibSubseq(self, arr: list[int]) -> int:\\n    longest_subsequence = 0\\n    index_from_value_table = {x: i for i, x in enumerate(arr)}\\n    subsequence_length_dict = defaultdict(lambda: 2)\\n    for k, k_val in enumerate(arr):\\n      jlo = bisect_right(arr, k_val // 2, hi=k)\\n      for j_val in arr[jlo:k]:\\n        j = index_from_value_table[j_val]\\n        i = index_from_value_table.get(k_val - j_val, None)\\n        if i is None: continue\\n        seq = subsequence_length_dict[i, j] + 1\\n        subsequence_length_dict[j, k] = seq\\n        longest_subsequence = max(longest_subsequence, seq)\\n    return longest_subsequence\\n```\\n\\n```Java []\\nclass Solution {\\n\\tpublic int lenLongestFibSubseq(int[] arr) {\\n\\t\\tint length = arr.length;\\n\\t\\tint[][] dp = new int[length][length];\\n\\t\\tint result = 0;\\n\\t\\tfor (int i = 2; i < length; i++) {\\n\\t\\t\\tint left = 0;\\n\\t\\t\\tint right = i - 1;\\n\\t\\t\\twhile (left < right) {\\n\\t\\t\\t\\tint val = arr[left] + arr[right] - arr[i];\\n\\t\\t\\t\\tif (val < 0) {\\n\\t\\t\\t\\t\\tleft++;\\n\\t\\t\\t\\t} else if (val > 0) {\\n\\t\\t\\t\\t\\tright--;\\n\\t\\t\\t\\t} else {\\n\\t\\t\\t\\t\\tdp[right][i] = dp[left][right] + 1;\\n\\t\\t\\t\\t\\tresult = Math.max(result, dp[right][i]);\\n\\t\\t\\t\\t\\tleft++;\\n\\t\\t\\t\\t\\tright--;\\n\\t\\t\\t\\t}\\n\\t\\t\\t}\\n\\t\\t}\\n\\t\\treturn result == 0 ? 0 : result + 2;\\n\\t}\\n}\\n```\\n",
                "solutionTags": [
                    "C++",
                    "Java",
                    "Python3"
                ],
                "code": "```C++ []\\nclass Solution {\\npublic:\\n    int lenLongestFibSubseq(vector<int>& arr) {\\n        int n = arr.size();\\n        map<pair<int,int>,int>indexes;\\n\\n        for(int i = 2 ;i < n;i++) {\\n            int start = 0;\\n            int end = i-1;\\n            long long reqSum = arr[i];\\n            long long sum;\\n            while(start != end) {\\n                sum = arr[start] + (long long)arr[end];\\n                if(sum == reqSum) {\\n                    indexes[{start,end}] = i;\\n                    start++;\\n                }\\n                else if(sum < reqSum) start++;\\n                else end--;\\n            }\\n        }\\n        int count = 0;\\n        int maxCount = 0;\\n        for(auto &it : indexes) {\\n            count = 2;\\n            int i=it.first.first,j=it.first.second,k=it.second;\\n            while((long long)arr[i]+arr[j] == (long long)arr[k]) {\\n                count++;\\n                i = j;\\n                j = k;\\n                k = indexes[{i,j}];\\n            }\\n            if(count > maxCount)maxCount = count;\\n        }\\n        return maxCount;\\n    }\\n};\\n```\n```Python3 []\\nclass Solution:\\n  def lenLongestFibSubseq(self, arr: list[int]) -> int:\\n    longest_subsequence = 0\\n    index_from_value_table = {x: i for i, x in enumerate(arr)}\\n    subsequence_length_dict = defaultdict(lambda: 2)\\n    for k, k_val in enumerate(arr):\\n      jlo = bisect_right(arr, k_val // 2, hi=k)\\n      for j_val in arr[jlo:k]:\\n        j = index_from_value_table[j_val]\\n        i = index_from_value_table.get(k_val - j_val, None)\\n        if i is None: continue\\n        seq = subsequence_length_dict[i, j] + 1\\n        subsequence_length_dict[j, k] = seq\\n        longest_subsequence = max(longest_subsequence, seq)\\n    return longest_subsequence\\n```\n```Java []\\nclass Solution {\\n\\tpublic int lenLongestFibSubseq(int[] arr) {\\n\\t\\tint length = arr.length;\\n\\t\\tint[][] dp = new int[length][length];\\n\\t\\tint result = 0;\\n\\t\\tfor (int i = 2; i < length; i++) {\\n\\t\\t\\tint left = 0;\\n\\t\\t\\tint right = i - 1;\\n\\t\\t\\twhile (left < right) {\\n\\t\\t\\t\\tint val = arr[left] + arr[right] - arr[i];\\n\\t\\t\\t\\tif (val < 0) {\\n\\t\\t\\t\\t\\tleft++;\\n\\t\\t\\t\\t} else if (val > 0) {\\n\\t\\t\\t\\t\\tright--;\\n\\t\\t\\t\\t} else {\\n\\t\\t\\t\\t\\tdp[right][i] = dp[left][right] + 1;\\n\\t\\t\\t\\t\\tresult = Math.max(result, dp[right][i]);\\n\\t\\t\\t\\t\\tleft++;\\n\\t\\t\\t\\t\\tright--;\\n\\t\\t\\t\\t}\\n\\t\\t\\t}\\n\\t\\t}\\n\\t\\treturn result == 0 ? 0 : result + 2;\\n\\t}\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3415878,
                "title": "easy-python-solution-using-dp",
                "content": "# Code\\n```\\nclass Solution(object):\\n    def lenLongestFibSubseq(self, arr):\\n        \"\"\"\\n        :type arr: List[int]\\n        :rtype: int\\n        \"\"\"\\n        dic={}\\n        mx=0\\n        ln=len(arr)\\n        for i in range(ln):\\n            dic[arr[i]]=i\\n        dp=[[0]*(ln) for j in range(ln)]\\n        for i in range(0,ln):\\n            for j in range(i+1,ln):\\n                a=i\\n                b=j\\n                while b<ln:\\n                    sm=arr[a]+arr[b]\\n                    if sm in dic:\\n                        a=b\\n                        b=dic[sm]\\n                        dp[a][b]+=1\\n                        mx=max(dp[a][b],mx)\\n                    else:break\\n        return mx+2 if mx!=0 else 0\\n```",
                "solutionTags": [
                    "Python",
                    "Hash Table",
                    "Dynamic Programming"
                ],
                "code": "```\\nclass Solution(object):\\n    def lenLongestFibSubseq(self, arr):\\n        \"\"\"\\n        :type arr: List[int]\\n        :rtype: int\\n        \"\"\"\\n        dic={}\\n        mx=0\\n        ln=len(arr)\\n        for i in range(ln):\\n            dic[arr[i]]=i\\n        dp=[[0]*(ln) for j in range(ln)]\\n        for i in range(0,ln):\\n            for j in range(i+1,ln):\\n                a=i\\n                b=j\\n                while b<ln:\\n                    sm=arr[a]+arr[b]\\n                    if sm in dic:\\n                        a=b\\n                        b=dic[sm]\\n                        dp[a][b]+=1\\n                        mx=max(dp[a][b],mx)\\n                    else:break\\n        return mx+2 if mx!=0 else 0\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2920747,
                "title": "if-you-struggle-to-understand-other-solutions-try-this-one-easy-to-understand",
                "content": "# Intuition & Approach\\nWas already solved [here]( https://leetcode.com/problems/length-of-longest-fibonacci-subsequence/solutions/152343/c-java-python-check-pair/?q=java&orderBy=most_relevant). That\\'s just one more way to get it.\\n\\n\\nFor every pair we would calculate the length of the sequence that ends `A[i]`, `A[j]`. We do it by increasing the lenght of the secuence of `A[k]`, `A[i]` by one, if exists `A[k]`, such `A[k] + A[i] = A[j]`. Finding `A[k]` is easy, `A[k] = A[j] - A[i]` and `k < i < j.`\\n\\nIn the case such `A[k]` doesnt\\' exists, `A[i][j] = 2`\\n\\n# Complexity\\n- Time complexity:\\nN^2\\n\\n- Space complexity:\\nN^2\\n\\n# Code\\n```\\n    public int lenLongestFibSubseq(int[] A) {\\n        int res = 0;\\n\\n        // stores the length of the sequence that ends ..., A[i], A[j]\\n        int[][] dp = new int[A.length][A.length];\\n\\n        Map<Integer, Integer> index = new HashMap<>();\\n        for (int i = 0; i < A.length; i++) {\\n            index.put(A[i], i);\\n            for (int j = i + 1; j < A.length; j++) {\\n                int previous = A[j] - A[i];\\n                if (index.containsKey(previous) && previous < A[i]) {\\n                    int positionOfPrevious = index.get(previous);\\n                    dp[i][j] = dp[positionOfPrevious][i] + 1;\\n                } else {\\n                    dp[i][j] = 2;\\n                }\\n                res = Math.max(res, dp[i][j]);\\n            }\\n        }\\n        return res > 2 ? res : 0;\\n    }\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\n    public int lenLongestFibSubseq(int[] A) {\\n        int res = 0;\\n\\n        // stores the length of the sequence that ends ..., A[i], A[j]\\n        int[][] dp = new int[A.length][A.length];\\n\\n        Map<Integer, Integer> index = new HashMap<>();\\n        for (int i = 0; i < A.length; i++) {\\n            index.put(A[i], i);\\n            for (int j = i + 1; j < A.length; j++) {\\n                int previous = A[j] - A[i];\\n                if (index.containsKey(previous) && previous < A[i]) {\\n                    int positionOfPrevious = index.get(previous);\\n                    dp[i][j] = dp[positionOfPrevious][i] + 1;\\n                } else {\\n                    dp[i][j] = 2;\\n                }\\n                res = Math.max(res, dp[i][j]);\\n            }\\n        }\\n        return res > 2 ? res : 0;\\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2783406,
                "title": "c-easy-short",
                "content": "\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n  int f(int curr,int prev,vector<int>& nums,int n){\\n\\t\\t\\tint t=nums[curr]+nums[prev];\\n\\t\\t\\tint i=lower_bound(nums.begin(),nums.end(),t)-nums.begin();\\n\\t\\t\\tif(i<n && nums[i]==t) return 1+f(i,curr,nums,n);\\n\\t\\t\\treturn 1;\\n\\t\\t}\\n\\n\\t\\tint lenLongestFibSubseq(vector<int>& nums) {\\n\\t\\t\\tint n=nums.size();\\n\\t\\t\\tint maxi=0;\\n\\t\\t\\tfor(int prev2=0;prev2<n;prev2++){\\n\\t\\t\\t\\tfor(int prev1=prev2+1;prev1<n;prev1++){\\n\\t\\t\\t\\t\\tint temp=nums[prev1]+nums[prev2];\\n\\t\\t\\t\\t\\tint ind=lower_bound(nums.begin(),nums.end(),temp)-nums.begin();\\n\\t\\t\\t\\t\\tif(ind<n && nums[ind]==temp) maxi=max(maxi,2+f(ind,prev1,nums,n));\\n\\t\\t\\t\\t}\\n\\t\\t\\t}\\n\\t\\t\\treturn maxi;\\n\\t\\t}\\n\\t};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n  int f(int curr,int prev,vector<int>& nums,int n){\\n\\t\\t\\tint t=nums[curr]+nums[prev];\\n\\t\\t\\tint i=lower_bound(nums.begin(),nums.end(),t)-nums.begin();\\n\\t\\t\\tif(i<n && nums[i]==t) return 1+f(i,curr,nums,n);\\n\\t\\t\\treturn 1;\\n\\t\\t}\\n\\n\\t\\tint lenLongestFibSubseq(vector<int>& nums) {\\n\\t\\t\\tint n=nums.size();\\n\\t\\t\\tint maxi=0;\\n\\t\\t\\tfor(int prev2=0;prev2<n;prev2++){\\n\\t\\t\\t\\tfor(int prev1=prev2+1;prev1<n;prev1++){\\n\\t\\t\\t\\t\\tint temp=nums[prev1]+nums[prev2];\\n\\t\\t\\t\\t\\tint ind=lower_bound(nums.begin(),nums.end(),temp)-nums.begin();\\n\\t\\t\\t\\t\\tif(ind<n && nums[ind]==temp) maxi=max(maxi,2+f(ind,prev1,nums,n));\\n\\t\\t\\t\\t}\\n\\t\\t\\t}\\n\\t\\t\\treturn maxi;\\n\\t\\t}\\n\\t};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2656705,
                "title": "pathetic-binary-search-won-t-work-here-use-set-in-python",
                "content": "\\tclass Solution(object):\\n\\t\\tdef lenLongestFibSubseq(self, arr):\\n\\t\\t\\t#-----------------------------------------\\n\\t\\t\\tn = len(arr)\\n\\t\\t\\tres = 0\\n\\t\\t\\ts = set(arr)\\n\\t\\t\\t#------------------------------------------\\n\\t\\t\\tdef binarySearch(array,key,start,end):\\n\\t\\t\\t\\tif(start>end) : return -1\\n\\t\\t\\t\\tmid = (start+end)//2\\n\\t\\t\\t\\tif key==array[mid] : return mid\\n\\t\\t\\t\\telif key<array[mid] : return binarySearch(array,key,start,mid-1);\\n\\t\\t\\t\\telse : return binarySearch(array,key,mid+1,end)\\n\\t\\t\\t#----------------------------------------\\n\\t\\t\\tdef compute(array,first,second,s):\\n\\t\\t\\t\\tkey = first + second\\n\\n\\t\\t\\t\\tif key in s:\\n\\t\\t\\t\\t\\tthird = second + first\\n\\t\\t\\t\\t\\treturn 1 + compute(array,second,third,s)\\n\\t\\t\\t\\telse:\\n\\t\\t\\t\\t\\treturn 0\\n\\t\\t\\t#----------------------------------------\\n\\t\\t\\tfor i in range(n):\\n\\t\\t\\t\\tfor j in range(i+1,n):\\n\\t\\t\\t\\t\\tfirst = arr[i]\\n\\t\\t\\t\\t\\tsecond= arr[j]\\n\\t\\t\\t\\t\\t# self.v=[first,second]\\n\\t\\t\\t\\t\\tvalue = compute(arr,first,second,s)\\n\\t\\t\\t\\t\\tif value==0:continue\\n\\t\\t\\t\\t\\tres = max(res,value+2)\\n\\t\\t\\t#-----------------------------------------\\n\\t\\t\\treturn res",
                "solutionTags": [
                    "Ordered Set"
                ],
                "code": "\\tclass Solution(object):\\n\\t\\tdef lenLongestFibSubseq(self, arr):\\n\\t\\t\\t#-----------------------------------------\\n\\t\\t\\tn = len(arr)\\n\\t\\t\\tres = 0\\n\\t\\t\\ts = set(arr)\\n\\t\\t\\t#------------------------------------------\\n\\t\\t\\tdef binarySearch(array,key,start,end):\\n\\t\\t\\t\\tif(start>end) : return -1\\n\\t\\t\\t\\tmid = (start+end)//2\\n\\t\\t\\t\\tif key==array[mid] : return mid\\n\\t\\t\\t\\telif key<array[mid] : return binarySearch(array,key,start,mid-1);\\n\\t\\t\\t\\telse : return binarySearch(array,key,mid+1,end)\\n\\t\\t\\t#----------------------------------------\\n\\t\\t\\tdef compute(array,first,second,s):\\n\\t\\t\\t\\tkey = first + second\\n\\n\\t\\t\\t\\tif key in s:\\n\\t\\t\\t\\t\\tthird = second + first\\n\\t\\t\\t\\t\\treturn 1 + compute(array,second,third,s)\\n\\t\\t\\t\\telse:\\n\\t\\t\\t\\t\\treturn 0\\n\\t\\t\\t#----------------------------------------\\n\\t\\t\\tfor i in range(n):\\n\\t\\t\\t\\tfor j in range(i+1,n):\\n\\t\\t\\t\\t\\tfirst = arr[i]\\n\\t\\t\\t\\t\\tsecond= arr[j]\\n\\t\\t\\t\\t\\t# self.v=[first,second]\\n\\t\\t\\t\\t\\tvalue = compute(arr,first,second,s)\\n\\t\\t\\t\\t\\tif value==0:continue\\n\\t\\t\\t\\t\\tres = max(res,value+2)\\n\\t\\t\\t#-----------------------------------------\\n\\t\\t\\treturn res",
                "codeTag": "Java"
            },
            {
                "id": 2638117,
                "title": "c-70-beats-space-simple-using-set",
                "content": "```\\nclass Solution {\\npublic:\\n    int lenLongestFibSubseq(vector<int>& arr) {\\n        set<int> s;\\n        int i,j,n = arr.size(),l,ans = 0,x,y,z;\\n        for(auto &i: arr){\\n            s.insert(i);\\n        }\\n        for(i = 0; i < n; i++){\\n            for(j = i+1; j < n-1; j++){\\n                x = arr[i], y = arr[j],l = 2;\\n                while(s.count(x+y)){\\n                    l++;\\n                    z = x+y;\\n                    x = y;\\n                    y = z;\\n                }\\n                ans = max(ans,l);\\n            }\\n        }\\n        return ans>2?ans:0;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "C",
                    "Ordered Set"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int lenLongestFibSubseq(vector<int>& arr) {\\n        set<int> s;\\n        int i,j,n = arr.size(),l,ans = 0,x,y,z;\\n        for(auto &i: arr){\\n            s.insert(i);\\n        }\\n        for(i = 0; i < n; i++){\\n            for(j = i+1; j < n-1; j++){\\n                x = arr[i], y = arr[j],l = 2;\\n                while(s.count(x+y)){\\n                    l++;\\n                    z = x+y;\\n                    x = y;\\n                    y = z;\\n                }\\n                ans = max(ans,l);\\n            }\\n        }\\n        return ans>2?ans:0;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2507423,
                "title": "c-dp-faster-than-99",
                "content": "```\\nclass Solution {\\npublic:\\n    int lenLongestFibSubseq(vector<int>& arr) {\\n        int n = arr.size();\\n\\n        unordered_map<int, int> mp;\\n        for(int i=0; i<n; ++i) {\\n            mp[arr[i]] = i;\\n        }\\n      \\n        vector<vector<int>> dp(n, vector<int>(n, 2));\\n        int ans = 0;\\n        for(int i=2; i<n; ++i) {\\n            for(int j=i-1; j>=1; --j) {\\n                int rem = arr[i] - arr[j];\\n                if(rem >= arr[j]) break;\\n                if(mp.count(rem)) {\\n                    dp[j][i] = max(dp[j][i], dp[mp[rem]][j] + 1);\\n                    ans = max(ans, dp[j][i]);\\n                }\\n            }\\n        }\\n        \\n        return ans > 2 ? ans : 0;\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    int lenLongestFibSubseq(vector<int>& arr) {\\n        int n = arr.size();\\n\\n        unordered_map<int, int> mp;\\n        for(int i=0; i<n; ++i) {\\n            mp[arr[i]] = i;\\n        }\\n      \\n        vector<vector<int>> dp(n, vector<int>(n, 2));\\n        int ans = 0;\\n        for(int i=2; i<n; ++i) {\\n            for(int j=i-1; j>=1; --j) {\\n                int rem = arr[i] - arr[j];\\n                if(rem >= arr[j]) break;\\n                if(mp.count(rem)) {\\n                    dp[j][i] = max(dp[j][i], dp[mp[rem]][j] + 1);\\n                    ans = max(ans, dp[j][i]);\\n                }\\n            }\\n        }\\n        \\n        return ans > 2 ? ans : 0;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2309229,
                "title": "c-commented-solution-dp-tabulation-clean-code",
                "content": "```\\n  int lenLongestFibSubseq(vector<int>& nums) {\\n        \\n        int n=nums.size();\\n        \\n        unordered_map<int , int> mp;\\n        \\n        for(int i=0;i<n;i++)\\n        {\\n            mp[nums[i]]=i;\\n        }\\n        \\n        vector<vector<int>> dp(n+1 , vector<int>(n+1 , 2));\\n        \\n        int max_ele=0;\\n        \\n        for(int i=0;i<n-1;i++)\\n        {\\n            for(int j=i+1;j<n;j++)\\n            {\\n                // we are taking it as ith & jth elements as last elements\\n                \\n                // now we will take he sum of ith & jth one , \\n                \\n                // find tht its sum is avaolable in mp , update that index = k , \\n                \\n                // corresponding tothat sum if present in map\\n                \\n                // dp[j][k]=dp[i][j]+1 , update it if value of dp[j][k] is less than 1 + \\n                //dp[i][j]\\n                \\n                int sum=nums[i]+nums[j];\\n                \\n                if(mp.find(sum)!=mp.end())\\n                {\\n                    int sum_idx=mp[sum];\\n                    \\n                    if(dp[j][sum_idx]<1+dp[i][j])\\n                    {\\n                        dp[j][sum_idx]=1+dp[i][j];\\n                        max_ele=max(max_ele , dp[j][sum_idx]);\\n                    }\\n                }\\n            }\\n        }\\n        \\n        \\n        return max_ele;\\n        \\n        \\n    }\\n```",
                "solutionTags": [
                    "C++",
                    "C",
                    "Dynamic Programming"
                ],
                "code": "```\\n  int lenLongestFibSubseq(vector<int>& nums) {\\n        \\n        int n=nums.size();\\n        \\n        unordered_map<int , int> mp;\\n        \\n        for(int i=0;i<n;i++)\\n        {\\n            mp[nums[i]]=i;\\n        }\\n        \\n        vector<vector<int>> dp(n+1 , vector<int>(n+1 , 2));\\n        \\n        int max_ele=0;\\n        \\n        for(int i=0;i<n-1;i++)\\n        {\\n            for(int j=i+1;j<n;j++)\\n            {\\n                // we are taking it as ith & jth elements as last elements\\n                \\n                // now we will take he sum of ith & jth one , \\n                \\n                // find tht its sum is avaolable in mp , update that index = k , \\n                \\n                // corresponding tothat sum if present in map\\n                \\n                // dp[j][k]=dp[i][j]+1 , update it if value of dp[j][k] is less than 1 + \\n                //dp[i][j]\\n                \\n                int sum=nums[i]+nums[j];\\n                \\n                if(mp.find(sum)!=mp.end())\\n                {\\n                    int sum_idx=mp[sum];\\n                    \\n                    if(dp[j][sum_idx]<1+dp[i][j])\\n                    {\\n                        dp[j][sum_idx]=1+dp[i][j];\\n                        max_ele=max(max_ele , dp[j][sum_idx]);\\n                    }\\n                }\\n            }\\n        }\\n        \\n        \\n        return max_ele;\\n        \\n        \\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2265569,
                "title": "java-time-o-n-2-space-o-n-2-recursion-top-down",
                "content": "```\\n//thought process is at the bottom.\\n\\n\\nclass Solution {\\n    int[][] memo;\\n    Map<Integer,Integer> map;\\n    int[] arr;\\n    public int lenLongestFibSubseq(int[] arr) {\\n        this.memo = new int[arr.length][arr.length];\\n        this.arr = arr;\\n     \\n        map = new HashMap<>();\\n        for(int i=0;i<arr.length;i++)\\n            map.put(arr[i],i);\\n        \\n        int max = 0;\\n        for(int i=0;i<arr.length;i++){\\n            for(int j=i+1;j<arr.length;j++){\\n                max = Math.max(max,dfs(i,j));\\n            }\\n        }\\n        return max==2?0:max;\\n    }\\n    \\n    private int dfs(int i, int j){\\n        if(memo[i][j]!=0)\\n            return memo[i][j];\\n        \\n        int ans = 0;\\n        if(!map.containsKey(arr[i]+arr[j])){\\n            ans = 2;\\n        }else{\\n            ans = 1 + dfs(j,map.get(arr[i]+arr[j])); \\n        }\\n        memo[i][j] = ans;\\n        return ans;\\n    }\\n}\\n\\n\\n// 0, 1, => 2                      -> 5 \\n//      1, 2, => 3                 -> 4\\n//          2, 3, => 6             -> 3\\n//              3, 6, ? => nothing -> 2\\n\\n\\n\\n// 0 1 2 3 4 5 6 7\\n//[1,2,3,4,5,6,7,8]\\n\\n//[0,6] -> 3\\n\\n//2d dp\\n\\n//0,1,2 : 1,2,3,5,8     1,2,3 : 2,3,5,8     2,3,6 : 3,4,7   3,6,? => 0\\n//0,2,3 : 1,3,4,7       2,3,6 : 3,4,7       3,6,? => 0\\n//0,3,4 : 1,4,5         3,4,? : 4,5 => 0\\n//0,4,5 : 1,5,6         4,5,? : 5,6 => 0\\n//\\n\\n\\n//dp[1][2] = dp[2][4] + 1\\n//\\n//0,1,2 [1,2,3,5,8] => 5 \\n//0,2 [1,3,4,7] => 4\\n//0,3 [1,4,5] => 3\\n//0,4 [1,5,6] => 3\\n//0,5 [1,6,7] => 3\\n//0,6 [1,7,8] => 3\\n//0,7 [1,8] => 0\\n//1,2 [2,3,5,8] => 4    \\n//1,3 [2,4,6] => 3\\n//1,4 [2,5,7] => 3\\n//1,5 [2,6,8] => 3\\n//1,6 [2,7] => 0\\n//1,7 [2,8] => 0\\n//2,3 [3,4,7] => 3\\n//2,4 [3,5,8] => 3\\n//2,5 [3,6] => 0\\n//2,6 [3,7] => 0\\n//2,7 [3,8] => 0\\n//3,4 [4,5] => 0\\n//3,5 [4,6] => 0\\n//3,6 [4,7] => 0\\n//3,7 [4,8] => 0\\n//4,5 [5,6] => 0\\n//4,6 [5,7] => 0\\n//4,7 [5,8] => 0\\n//5,6 [6,7] => 0\\n//5,7 [6,8] => 0\\n//6,7 [7,8] => 0\\n```",
                "solutionTags": [
                    "Recursion"
                ],
                "code": "```\\n//thought process is at the bottom.\\n\\n\\nclass Solution {\\n    int[][] memo;\\n    Map<Integer,Integer> map;\\n    int[] arr;\\n    public int lenLongestFibSubseq(int[] arr) {\\n        this.memo = new int[arr.length][arr.length];\\n        this.arr = arr;\\n     \\n        map = new HashMap<>();\\n        for(int i=0;i<arr.length;i++)\\n            map.put(arr[i],i);\\n        \\n        int max = 0;\\n        for(int i=0;i<arr.length;i++){\\n            for(int j=i+1;j<arr.length;j++){\\n                max = Math.max(max,dfs(i,j));\\n            }\\n        }\\n        return max==2?0:max;\\n    }\\n    \\n    private int dfs(int i, int j){\\n        if(memo[i][j]!=0)\\n            return memo[i][j];\\n        \\n        int ans = 0;\\n        if(!map.containsKey(arr[i]+arr[j])){\\n            ans = 2;\\n        }else{\\n            ans = 1 + dfs(j,map.get(arr[i]+arr[j])); \\n        }\\n        memo[i][j] = ans;\\n        return ans;\\n    }\\n}\\n\\n\\n// 0, 1, => 2                      -> 5 \\n//      1, 2, => 3                 -> 4\\n//          2, 3, => 6             -> 3\\n//              3, 6, ? => nothing -> 2\\n\\n\\n\\n// 0 1 2 3 4 5 6 7\\n//[1,2,3,4,5,6,7,8]\\n\\n//[0,6] -> 3\\n\\n//2d dp\\n\\n//0,1,2 : 1,2,3,5,8     1,2,3 : 2,3,5,8     2,3,6 : 3,4,7   3,6,? => 0\\n//0,2,3 : 1,3,4,7       2,3,6 : 3,4,7       3,6,? => 0\\n//0,3,4 : 1,4,5         3,4,? : 4,5 => 0\\n//0,4,5 : 1,5,6         4,5,? : 5,6 => 0\\n//\\n\\n\\n//dp[1][2] = dp[2][4] + 1\\n//\\n//0,1,2 [1,2,3,5,8] => 5 \\n//0,2 [1,3,4,7] => 4\\n//0,3 [1,4,5] => 3\\n//0,4 [1,5,6] => 3\\n//0,5 [1,6,7] => 3\\n//0,6 [1,7,8] => 3\\n//0,7 [1,8] => 0\\n//1,2 [2,3,5,8] => 4    \\n//1,3 [2,4,6] => 3\\n//1,4 [2,5,7] => 3\\n//1,5 [2,6,8] => 3\\n//1,6 [2,7] => 0\\n//1,7 [2,8] => 0\\n//2,3 [3,4,7] => 3\\n//2,4 [3,5,8] => 3\\n//2,5 [3,6] => 0\\n//2,6 [3,7] => 0\\n//2,7 [3,8] => 0\\n//3,4 [4,5] => 0\\n//3,5 [4,6] => 0\\n//3,6 [4,7] => 0\\n//3,7 [4,8] => 0\\n//4,5 [5,6] => 0\\n//4,6 [5,7] => 0\\n//4,7 [5,8] => 0\\n//5,6 [6,7] => 0\\n//5,7 [6,8] => 0\\n//6,7 [7,8] => 0\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2247526,
                "title": "c-hash-map-dp-memorization",
                "content": "Please Upvote :)\\n\\n```\\nclass Solution {\\npublic:\\n    unordered_map<int,int> m;\\n    int dp[1002][1002];\\n    int lenLongestFibSubseq(vector<int>& arr) {\\n        memset(dp,-1,sizeof(dp));\\n        for(int i=0;i<arr.size();i++)\\n            m[arr[i]]=i;\\n        int res=fun(arr,0,-1)+1;\\n        if(res<3)\\n            return 0;\\n        return res;\\n    }\\n    int fun(vector<int>& v,int ind,int num)\\n    {\\n        if(ind>=v.size())\\n            return 0;\\n        \\n        if(dp[ind+1][num+1]!=-1)\\n            return dp[ind+1][num+1];\\n        int t=0;\\n        if(num==-1) //  first number about to be choosen\\n        {\\n            t=max(t,fun(v,ind+1,num));\\n            for(int i=ind+1;i<v.size()-1;i++)\\n                t=max(t,1+fun(v,i,ind));\\n        }\\n        else\\n        {\\n            int x=v[num]+v[ind];\\n            if(m.find(x)!=m.end())\\n            {\\n                t=1+fun(v,m[x],ind);\\n            }\\n        }\\n        return dp[ind+1][num+1]=t;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C",
                    "Dynamic Programming",
                    "Memoization"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    unordered_map<int,int> m;\\n    int dp[1002][1002];\\n    int lenLongestFibSubseq(vector<int>& arr) {\\n        memset(dp,-1,sizeof(dp));\\n        for(int i=0;i<arr.size();i++)\\n            m[arr[i]]=i;\\n        int res=fun(arr,0,-1)+1;\\n        if(res<3)\\n            return 0;\\n        return res;\\n    }\\n    int fun(vector<int>& v,int ind,int num)\\n    {\\n        if(ind>=v.size())\\n            return 0;\\n        \\n        if(dp[ind+1][num+1]!=-1)\\n            return dp[ind+1][num+1];\\n        int t=0;\\n        if(num==-1) //  first number about to be choosen\\n        {\\n            t=max(t,fun(v,ind+1,num));\\n            for(int i=ind+1;i<v.size()-1;i++)\\n                t=max(t,1+fun(v,i,ind));\\n        }\\n        else\\n        {\\n            int x=v[num]+v[ind];\\n            if(m.find(x)!=m.end())\\n            {\\n                t=1+fun(v,m[x],ind);\\n            }\\n        }\\n        return dp[ind+1][num+1]=t;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2105700,
                "title": "simple-explanation-via-comments-c-code-video-link",
                "content": "\\nhttps://www.youtube.com/watch?v=0SphC-SnJ0E\\nif you find any trouble in dp intuition, then definitely you need to watch this \\nshort video to understand the concept completely. \\n```\\nclass Solution {\\npublic:\\n    \\n    int lenLongestFibSubseq(vector<int>& arr) \\n    {\\n        int n=arr.size();\\n        // store values and their indexes\\n        unordered_map<int,int>mp; // {value, indexes}\\n        for(int i=0;i<n;i++)\\n            mp[arr[i]] = i;\\n        \\n        int dp[1001][1001]; // max length of the array\\n        memset(dp, 0, sizeof(dp));\\n        \\n        // check pairs : initialization\\n        /*\\n          (0,1), (0,2), (0,3), (0,4)\\n                 (1,2), (1,3), (1,4)\\n                        (2,3), (2,4)\\n                               (3,4)\\n        */\\n        for(int i=0;i<n;i++){\\n            for(int j=i+1;j<n;j++){\\n                dp[i][j] = 2; // Two elements always in a Fibonacci, so for all pairs , put length of Fibonacci = 2\\n            }\\n        }\\n        \\n        int ans=0;\\n        for(int i=0;i<n;i++)\\n        {\\n            for(int j=i+1;j<n;j++)\\n            {\\n                int val = arr[i]+arr[j];\\n                if(mp.find(val)!=mp.end())\\n                {\\n                    int idx1 = mp[arr[j]];\\n                    int idx2 = mp[val];\\n                    dp[idx1][idx2] = dp[i][j]+1;\\n                    \\n                    // Simultaneously check for max value of answer, there is no need to iterate \\n                    // whole dp array to find out maximum value.\\n                    ans = max(ans, dp[idx1][idx2]); \\n                }\\n            }\\n        }\\n        \\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "C",
                    "Dynamic Programming"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    \\n    int lenLongestFibSubseq(vector<int>& arr) \\n    {\\n        int n=arr.size();\\n        // store values and their indexes\\n        unordered_map<int,int>mp; // {value, indexes}\\n        for(int i=0;i<n;i++)\\n            mp[arr[i]] = i;\\n        \\n        int dp[1001][1001]; // max length of the array\\n        memset(dp, 0, sizeof(dp));\\n        \\n        // check pairs : initialization\\n        /*\\n          (0,1), (0,2), (0,3), (0,4)\\n                 (1,2), (1,3), (1,4)\\n                        (2,3), (2,4)\\n                               (3,4)\\n        */\\n        for(int i=0;i<n;i++){\\n            for(int j=i+1;j<n;j++){\\n                dp[i][j] = 2; // Two elements always in a Fibonacci, so for all pairs , put length of Fibonacci = 2\\n            }\\n        }\\n        \\n        int ans=0;\\n        for(int i=0;i<n;i++)\\n        {\\n            for(int j=i+1;j<n;j++)\\n            {\\n                int val = arr[i]+arr[j];\\n                if(mp.find(val)!=mp.end())\\n                {\\n                    int idx1 = mp[arr[j]];\\n                    int idx2 = mp[val];\\n                    dp[idx1][idx2] = dp[i][j]+1;\\n                    \\n                    // Simultaneously check for max value of answer, there is no need to iterate \\n                    // whole dp array to find out maximum value.\\n                    ans = max(ans, dp[idx1][idx2]); \\n                }\\n            }\\n        }\\n        \\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1663397,
                "title": "simple-python-hashing-solution",
                "content": "```\\nclass Solution:\\n    def lenLongestFibSubseq(self, arr: List[int]) -> int:\\n        mat=[]\\n        for i in range(len(arr)):\\n            mat.append({})\\n        result=0\\n        for i in range(len(arr)):\\n            for j in range(i):\\n                if arr[i] in mat[j].keys():\\n                    mat[i][arr[i]+arr[j]]=(mat[j][arr[i]]+1)\\n                else:\\n                    mat[i][arr[i]+arr[j]]=2\\n                result=max(mat[i][arr[i]+arr[j]],result)\\n        if result<3:\\n            return 0\\n        return result\\n        \\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution:\\n    def lenLongestFibSubseq(self, arr: List[int]) -> int:\\n        mat=[]\\n        for i in range(len(arr)):\\n            mat.append({})\\n        result=0\\n        for i in range(len(arr)):\\n            for j in range(i):\\n                if arr[i] in mat[j].keys():\\n                    mat[i][arr[i]+arr[j]]=(mat[j][arr[i]]+1)\\n                else:\\n                    mat[i][arr[i]+arr[j]]=2\\n                result=max(mat[i][arr[i]+arr[j]],result)\\n        if result<3:\\n            return 0\\n        return result\\n        \\n```",
                "codeTag": "Java"
            },
            {
                "id": 1638521,
                "title": "python-find-all-subseqs-end-at-index-beats-98-runtime-and-50-space",
                "content": "Given `arr` is a **strictly increasing** array, which means:\\n1. For index `i`, for all index `j < i`, we know `arr[j] < arr[i]`\\n2. No duplicate value exists in `arr`\\n\\t2.1. This means subsequences like _2, 2, 4_ do not exist\\n\\n\\nWith the two situation in mind, we can find all fibonacci subsequences ending at a given index.\\nWe first identify a fibonacci subsequence `a_1, a_2, ..., a_n-1, a_n` with the last two elements: `(a_n-1, a_n)`.\\nThis identifier tells us two things:\\n1. The last value of this subsequence: `a_n`\\n2. The number before `a_n-1` is `a_n - a_n-1`\\n\\nSo I have a super simple algorithm:\\n* For number `arr[i]`, I try every number smaller than it, say `arr[j]`, then I can induct the number before `arr[j]` is `arr[i] - arr[j]`. Let\\'s call this number `arr[k]`.\\n* If there exists a subsequence with identifier `(arr[k], arr[j])`, then we get a new subsequence `(arr[i], arr[j])` by appending `arr[i]` to the end. The length will be `1 + length((arr[k], arr[j]))`\\n* If there does not exist such subsequence, but number `arr[k]` exists, then we can create a new subsequence using `arr[k]` as the first number. The length will be `3`\\n\\nRemember the two things we learnt from `arr is strictly increasing`? From the two things, we have:\\n1. `j` is just any index that is smaller than `i`. \\n2.  We can stop searching for `j` once we find `arr[j] <= arr[i] / 2`\\n\\nHere is the code:\\n```python\\nclass Solution:\\n    def lenLongestFibSubseq(self, arr: List[int]) -> int:\\n        fib_length = {} # keeps length of subsequence\\n        existing_num = set() # number appeared\\n        for end, num in enumerate(arr):\\n            for prev in range(end - 1, -1, -1):\\n                prev_num = arr[prev]\\n                if prev_num * 2 <= num: break\\n                if (num - prev_num, prev_num) in fib_length:\\n                    fib_length[prev_num, num] = 1 + fib_length[num-prev_num, prev_num]\\n                elif num - prev_num in existing_num:\\n                    fib_length[prev_num, num] = 3\\n            existing_num.add(num)\\n        return max(fib_length.values(), default=0)\\n```",
                "solutionTags": [],
                "code": "```python\\nclass Solution:\\n    def lenLongestFibSubseq(self, arr: List[int]) -> int:\\n        fib_length = {} # keeps length of subsequence\\n        existing_num = set() # number appeared\\n        for end, num in enumerate(arr):\\n            for prev in range(end - 1, -1, -1):\\n                prev_num = arr[prev]\\n                if prev_num * 2 <= num: break\\n                if (num - prev_num, prev_num) in fib_length:\\n                    fib_length[prev_num, num] = 1 + fib_length[num-prev_num, prev_num]\\n                elif num - prev_num in existing_num:\\n                    fib_length[prev_num, num] = 3\\n            existing_num.add(num)\\n        return max(fib_length.values(), default=0)\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1332715,
                "title": "simple-c-solution",
                "content": "First we will map all of the elements in a map and after all we check pairwise\\n```\\nclass Solution {\\npublic:\\n    int lenLongestFibSubseq(vector<int>& arr) {\\n        unordered_map<int,int> mp;\\n        for(int i=0;i<arr.size();i++)\\n        {\\n            mp[arr[i]]=1;\\n        }\\n        int count=0;\\n        for(int i=0;i<arr.size();i++)\\n        {\\n            for(int j=i+1;j<arr.size();j++)\\n            {\\n                int h=2;\\n                int y = arr[i];\\n                int x = arr[j];\\n                while(mp.find(y+x)!=mp.end())\\n                {\\n                    h++;\\n                    int k = x+y;\\n                    y=x;\\n                    x=k;\\n                }\\n                count=max(count,h);\\n            }\\n        }\\n        if(count==2) return 0;\\n        return count;\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    int lenLongestFibSubseq(vector<int>& arr) {\\n        unordered_map<int,int> mp;\\n        for(int i=0;i<arr.size();i++)\\n        {\\n            mp[arr[i]]=1;\\n        }\\n        int count=0;\\n        for(int i=0;i<arr.size();i++)\\n        {\\n            for(int j=i+1;j<arr.size();j++)\\n            {\\n                int h=2;\\n                int y = arr[i];\\n                int x = arr[j];\\n                while(mp.find(y+x)!=mp.end())\\n                {\\n                    h++;\\n                    int k = x+y;\\n                    y=x;\\n                    x=k;\\n                }\\n                count=max(count,h);\\n            }\\n        }\\n        if(count==2) return 0;\\n        return count;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1220229,
                "title": "dp-c",
                "content": "```\\nclass Solution {\\npublic:\\n    int lenLongestFibSubseq(vector<int>& arr) {\\n        if(arr.size() == 0)\\n            return 0;\\n       int n = arr.size();\\n       int dp[n][n];\\n       map<int,int>interim;\\n        for(int i = 0;i<n;i++)\\n        {\\n            interim[arr[i]] = i;\\n            for(int j = i+1;j<n;j++)\\n            dp[i][j] = 2;\\n        }\\n        for(int i = 0;i<n;i++)\\n        {\\n            for(int j = i+1;j<n;j++)\\n            {\\n                int val = arr[i]+arr[j];\\n                if(interim.find(val)!= interim.end())\\n                {\\n                    int index = interim[val];\\n                    dp[j][index] = dp[i][j]+1;\\n                }\\n            }\\n        }\\n        int result = 0;\\n        for(int i = 0;i<n;i++)\\n        {\\n            for(int j = i+1;j<n;j++)\\n                result = max(result,dp[i][j]);\\n            \\n        }\\n        if(result == 2)\\n            return 0;\\n        return result;\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    int lenLongestFibSubseq(vector<int>& arr) {\\n        if(arr.size() == 0)\\n            return 0;\\n       int n = arr.size();\\n       int dp[n][n];\\n       map<int,int>interim;\\n        for(int i = 0;i<n;i++)\\n        {\\n            interim[arr[i]] = i;\\n            for(int j = i+1;j<n;j++)\\n            dp[i][j] = 2;\\n        }\\n        for(int i = 0;i<n;i++)\\n        {\\n            for(int j = i+1;j<n;j++)\\n            {\\n                int val = arr[i]+arr[j];\\n                if(interim.find(val)!= interim.end())\\n                {\\n                    int index = interim[val];\\n                    dp[j][index] = dp[i][j]+1;\\n                }\\n            }\\n        }\\n        int result = 0;\\n        for(int i = 0;i<n;i++)\\n        {\\n            for(int j = i+1;j<n;j++)\\n                result = max(result,dp[i][j]);\\n            \\n        }\\n        if(result == 2)\\n            return 0;\\n        return result;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1170229,
                "title": "why-map-gives-tle-but-set-get-ac",
                "content": "Using set:\\n```\\nclass Solution {\\npublic:\\n    int lenLongestFibSubseq(vector<int>& arr) {\\n        unordered_set<int >mm(arr.begin(),arr.end());\\n         \\n        int ans=0;\\n        for(int i=0;i<arr.size();i++)\\n        {\\n            for(int j=i+1;j<arr.size();j++)\\n            {\\n                int x=arr[i]+arr[j];\\n                int y = arr[j],z,c=2;\\n                while(mm.find(x) != mm.end())\\n                {\\n                    c++;\\n                    z = x+y;\\n                    y=x;\\n                    x=z;\\n                    \\n                }\\n                ans=max(ans,c);\\n            }\\n        }\\n        return ans>=3 ? ans : 0;\\n    }\\n};\\n```\\n\\nUsing Map:\\n```\\nclass Solution {\\npublic:\\n    int lenLongestFibSubseq(vector<int>& arr) {\\n        unordered_map<int,int>mm;\\n        for(int i=0;i<arr.size();i++)\\n            mm[arr[i]]=i+1;\\n        int ans=0;\\n        for(int i=0;i<arr.size();i++)\\n        {\\n            for(int j=i+1;j<arr.size();j++)\\n            {\\n                int x=arr[i]+arr[j];\\n                int y = arr[j],k=j,c=2,z;\\n                int cur=mm[x]-1;\\n                while(cur>k)\\n                {\\n                    c++;\\n                    z=x+y;\\n                    y=x;\\n                    x=z;\\n                     \\n                    cur=mm[x]-1;\\n                }\\n                ans=max(ans,c);\\n            }\\n        }\\n        return ans>=3 ? ans : 0;\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    int lenLongestFibSubseq(vector<int>& arr) {\\n        unordered_set<int >mm(arr.begin(),arr.end());\\n         \\n        int ans=0;\\n        for(int i=0;i<arr.size();i++)\\n        {\\n            for(int j=i+1;j<arr.size();j++)\\n            {\\n                int x=arr[i]+arr[j];\\n                int y = arr[j],z,c=2;\\n                while(mm.find(x) != mm.end())\\n                {\\n                    c++;\\n                    z = x+y;\\n                    y=x;\\n                    x=z;\\n                    \\n                }\\n                ans=max(ans,c);\\n            }\\n        }\\n        return ans>=3 ? ans : 0;\\n    }\\n};\\n```\n```\\nclass Solution {\\npublic:\\n    int lenLongestFibSubseq(vector<int>& arr) {\\n        unordered_map<int,int>mm;\\n        for(int i=0;i<arr.size();i++)\\n            mm[arr[i]]=i+1;\\n        int ans=0;\\n        for(int i=0;i<arr.size();i++)\\n        {\\n            for(int j=i+1;j<arr.size();j++)\\n            {\\n                int x=arr[i]+arr[j];\\n                int y = arr[j],k=j,c=2,z;\\n                int cur=mm[x]-1;\\n                while(cur>k)\\n                {\\n                    c++;\\n                    z=x+y;\\n                    y=x;\\n                    x=z;\\n                     \\n                    cur=mm[x]-1;\\n                }\\n                ans=max(ans,c);\\n            }\\n        }\\n        return ans>=3 ? ans : 0;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1156343,
                "title": "java-o-n-2-log-n-ans",
                "content": "Select i<j<n and set a = arr[i],  b = arr[j],  count = 2  &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; a is first term, b is second term of fibonacci like series.\\nbinary search arr for a+b\\nif found update count = count + 1\\nupdate a = b,  b = a+b\\ncountinue while found\\nmax count produced will be the answer.\\nanswer will always be less than 45, because  in fibonacci series 1,1,2,3,5,...  &nbsp;&nbsp; 45th term is greater than 10^9.\\nAny other fibonacci like sequence will increase faster than this and hence will have less than 45 terms.\\n```\\nclass Solution\\n{\\n    int search(int[] arr, int x, int l, int r)\\n    {\\n        while(l<=r)\\n        {\\n            int m = (l+r)/2;\\n            if(arr[m]==x)\\n            {\\n                return m;\\n            }\\n            else if(arr[m]>x)\\n            {\\n                r = m-1;\\n            }\\n            else\\n            {\\n                l = m+1;\\n            }\\n        }\\n        return -1;\\n    }\\n    public int lenLongestFibSubseq(int[] arr)\\n    {\\n        int n = arr.length, ans = 0;\\n        for(int i=0; i<n; i++)\\n        {\\n            for(int j=i+1; j<n; j++)\\n            {\\n                int m = -1, a = arr[i], b = arr[j], c=2;\\n                do\\n                {\\n                    int x = a+b;\\n                    m = search(arr,x,j+1,n-1);\\n                    if(m!=-1)\\n                    {\\n                        a = b;\\n                        b = x;\\n                        c++;\\n                    }\\n                }while(m!=-1);\\n                if(c>2 && c>ans)\\n                {\\n                    ans = c;\\n                }\\n            }\\n        }\\n        return ans;\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution\\n{\\n    int search(int[] arr, int x, int l, int r)\\n    {\\n        while(l<=r)\\n        {\\n            int m = (l+r)/2;\\n            if(arr[m]==x)\\n            {\\n                return m;\\n            }\\n            else if(arr[m]>x)\\n            {\\n                r = m-1;\\n            }\\n            else\\n            {\\n                l = m+1;\\n            }\\n        }\\n        return -1;\\n    }\\n    public int lenLongestFibSubseq(int[] arr)\\n    {\\n        int n = arr.length, ans = 0;\\n        for(int i=0; i<n; i++)\\n        {\\n            for(int j=i+1; j<n; j++)\\n            {\\n                int m = -1, a = arr[i], b = arr[j], c=2;\\n                do\\n                {\\n                    int x = a+b;\\n                    m = search(arr,x,j+1,n-1);\\n                    if(m!=-1)\\n                    {\\n                        a = b;\\n                        b = x;\\n                        c++;\\n                    }\\n                }while(m!=-1);\\n                if(c>2 && c>ans)\\n                {\\n                    ans = c;\\n                }\\n            }\\n        }\\n        return ans;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1023086,
                "title": "o-n-2-approach-using-2-d-dp-java",
                "content": "\\'\\'\\'\\nclass Solution {\\n    public int lenLongestFibSubseq(int[] arr) {\\n        HashMap<Integer,Integer> map=new HashMap<>();\\n        for(int i=0;i<arr.length;i++){\\n            map.put(arr[i],i);\\n        }\\n        int n=arr.length;\\n        int[][] dp=new int[n][n];\\n        for(int[] ar:dp){\\n            Arrays.fill(ar,-1);\\n        }\\n        int ans=-1;\\n        for(int i=0;i<n;i++){\\n            for(int j=i+1;j<n;j++){\\n                int a=arr[j]-arr[i];\\n                int b=arr[i];\\n\\n                if(a>=b) dp[i][j]=2;\\n                else{\\n                    if(map.containsKey(a) && map.containsKey(b)){\\n                        int i1=map.get(a);\\n                        int j1=map.get(b);\\n                        dp[i][j]=1+dp[i1][j1];\\n                    }\\n                    else{\\n                        dp[i][j]=2;\\n                    }\\n                }\\n                ans=Math.max(ans,dp[i][j]);\\n            }            \\n        }/*\\n        for(int[] a:dp){\\n            for(int i:a){\\n                System.out.print(i+\" \");\\n            }\\n            System.out.println();\\n        }*/\\n        if(ans==2) return 0;\\n        return ans;\\n    }\\n}\\n\\'\\'\\'",
                "solutionTags": [],
                "code": "class Solution {\\n    public int lenLongestFibSubseq(int[] arr) {\\n        HashMap<Integer,Integer> map=new HashMap<>();\\n        for(int i=0;i<arr.length;i++){\\n            map.put(arr[i],i);\\n        }",
                "codeTag": "Java"
            },
            {
                "id": 891324,
                "title": "c-simple-set-solution",
                "content": "```\\nclass Solution {\\npublic:\\n    int lenLongestFibSubseq(vector<int>& A) {\\n        int ans=0;\\n        unordered_set<int>s(A.begin(),A.end());\\n        for(int i=0;i<A.size();i++){\\n            for(int j=i+1;j<A.size();j++){\\n                int a=A[i],b=A[j];\\n                int l=2;\\n                int c=a+b;\\n                while(s.find(c)!=s.end()){\\n                    a=b;\\n                    b=c;\\n                    c=a+b;\\n                    l++;\\n                }\\n                ans=max(ans,l);\\n            }\\n        }\\n        return ans>2?ans:0;\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    int lenLongestFibSubseq(vector<int>& A) {\\n        int ans=0;\\n        unordered_set<int>s(A.begin(),A.end());\\n        for(int i=0;i<A.size();i++){\\n            for(int j=i+1;j<A.size();j++){\\n                int a=A[i],b=A[j];\\n                int l=2;\\n                int c=a+b;\\n                while(s.find(c)!=s.end()){\\n                    a=b;\\n                    b=c;\\n                    c=a+b;\\n                    l++;\\n                }\\n                ans=max(ans,l);\\n            }\\n        }\\n        return ans>2?ans:0;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 792648,
                "title": "clean-python-ultra-fast-100-speed",
                "content": "**Clean Python | Ultra Fast | 100% Speed**\\n\\n```\\nclass Solution:\\n    def lenLongestFibSubseq(self, A):\\n        sA   = set(A)\\n        last = A[-1]\\n        B    = Counter()\\n        best = 0\\n        for i in reversed(range(len(A))):\\n            a = A[i]\\n            for b in A[i+1:]:\\n                c = a+b\\n                if c in sA:\\n                    B[a,b]  = 1 + B[b,c]\\n                    best    = max(best , B[a,b]+2)\\n                elif c>last:\\n                    break\\n        return best\\n```",
                "solutionTags": [
                    "Python",
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def lenLongestFibSubseq(self, A):\\n        sA   = set(A)\\n        last = A[-1]\\n        B    = Counter()\\n        best = 0\\n        for i in reversed(range(len(A))):\\n            a = A[i]\\n            for b in A[i+1:]:\\n                c = a+b\\n                if c in sA:\\n                    B[a,b]  = 1 + B[b,c]\\n                    best    = max(best , B[a,b]+2)\\n                elif c>last:\\n                    break\\n        return best\\n```",
                "codeTag": "Java"
            },
            {
                "id": 688882,
                "title": "easy-dp-solution-c",
                "content": "\\tint n = A.size();\\n\\tunordered_map<int, int>um;\\n\\tint dp[n][n];\\n\\tint third;\\n\\tint ans = 0;\\n\\tfor(int i = n - 1; i > -1; i--)\\n\\t{\\n\\t\\tfor(int j = i + 1; j < n; j++)\\n\\t\\t{\\n\\t\\t\\tdp[i][j] = 2;\\n\\t\\t\\tthird = A[i] + A[j];\\n\\t\\t\\tif(um.count(third))\\n\\t\\t\\t\\tdp[i][j] = dp[j][um[third]] + 1;\\n\\t\\t\\tans = max(ans, dp[i][j]);\\n\\t\\t}\\n\\t\\tum[A[i]] = i;\\n\\t}\\n\\tif(ans <= 2)\\n\\t\\treturn 0;\\n\\treturn ans;\\n\\n\\t\\n\\t  \\n\\thttps://leetcode.com/problems/longest-arithmetic-sequence/ \\n\\tthis question used a similar concept (atleast i did it in a similar way)",
                "solutionTags": [],
                "code": "\\tint n = A.size();\\n\\tunordered_map<int, int>um;\\n\\tint dp[n][n];\\n\\tint third;\\n\\tint ans = 0;\\n\\tfor(int i = n - 1; i > -1; i--)\\n\\t{\\n\\t\\tfor(int j = i + 1; j < n; j++)\\n\\t\\t{\\n\\t\\t\\tdp[i][j] = 2;\\n\\t\\t\\tthird = A[i] + A[j];\\n\\t\\t\\tif(um.count(third))\\n\\t\\t\\t\\tdp[i][j] = dp[j][um[third]] + 1;\\n\\t\\t\\tans = max(ans, dp[i][j]);\\n\\t\\t}\\n\\t\\tum[A[i]] = i;\\n\\t}\\n\\tif(ans <= 2)\\n\\t\\treturn 0;\\n\\treturn ans;\\n\\n\\t\\n\\t  \\n\\thttps://leetcode.com/problems/longest-arithmetic-sequence/ \\n\\tthis question used a similar concept (atleast i did it in a similar way)",
                "codeTag": "Unknown"
            },
            {
                "id": 533016,
                "title": "java-o-n-2-dp-solution",
                "content": "```\\nclass Solution {\\n    int dp[][];\\n    public int lenLongestFibSubseq(int[] nums) {\\n        dp=new int[nums.length][nums.length];\\n        for(int r=0;r<dp.length;r++){\\n            for(int c=0;c<dp[0].length;c++)dp[r][c]=2;\\n        }\\n        int res=0;\\n        Map<Integer,Integer>map=new HashMap<>();\\n        for(int i=0;i<nums.length;i++)map.put(nums[i],i); //position\\n        \\n        ////(1,2)->(2,3)->(3,5)->(5,8)\\n        for(int i=2;i<nums.length;i++){\\n            int n=nums[i];\\n            for(int j=i-1;j>=0;j--){\\n                int diff=n-nums[j];\\n                if(map.containsKey(diff)&&diff<nums[j]){\\n                    dp[j][i]=1+dp[map.get(diff)][j];\\n                }\\n            }\\n        }\\n        \\n        for(int r=0;r<dp.length;r++){\\n            for(int c=0;c<dp[0].length;c++){\\n                if(dp[r][c]>=3)res=Math.max(res,dp[r][c]);\\n            }\\n        }\\n        return res;\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    int dp[][];\\n    public int lenLongestFibSubseq(int[] nums) {\\n        dp=new int[nums.length][nums.length];\\n        for(int r=0;r<dp.length;r++){\\n            for(int c=0;c<dp[0].length;c++)dp[r][c]=2;\\n        }\\n        int res=0;\\n        Map<Integer,Integer>map=new HashMap<>();\\n        for(int i=0;i<nums.length;i++)map.put(nums[i],i); //position\\n        \\n        ////(1,2)->(2,3)->(3,5)->(5,8)\\n        for(int i=2;i<nums.length;i++){\\n            int n=nums[i];\\n            for(int j=i-1;j>=0;j--){\\n                int diff=n-nums[j];\\n                if(map.containsKey(diff)&&diff<nums[j]){\\n                    dp[j][i]=1+dp[map.get(diff)][j];\\n                }\\n            }\\n        }\\n        \\n        for(int r=0;r<dp.length;r++){\\n            for(int c=0;c<dp[0].length;c++){\\n                if(dp[r][c]>=3)res=Math.max(res,dp[r][c]);\\n            }\\n        }\\n        return res;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 479751,
                "title": "java-dp",
                "content": "```\\n    public int lenLongestFibSubseq(int[] A) {\\n        if (A == null || A.length == 0) {\\n            return 0;\\n        }\\n        //dp[i][j] is the Length of Longest Fibonacci Subsequence with the two ending elements A[i] and A[j]\\n        int len = A.length;\\n        int[][] dp = new int[len][len];\\n        Map<Integer, Integer> m = new HashMap<>();\\n        for (int i = 0; i < len; i++) {\\n            m.put(A[i], i);\\n            for (int j = i + 1; j < len; j++) {\\n                dp[i][j] = 2;\\n            }\\n        }\\n        for (int i = 0; i < len; i++) {\\n            for (int j = i + 1; j < len; j++) {\\n                if (A[j] > A[i]) {\\n                    int k = A[j] + A[i];\\n                    if (m.containsKey(k)) {\\n                        int index = m.get(k);\\n                        dp[j][index] = dp[i][j] + 1;\\n                    }\\n                }\\n            }\\n        }\\n        int res = 0;\\n        for (int i = 0; i < len; i++) {\\n            for (int j = i + 1; j < len; j++) {\\n                res = Math.max(res, dp[i][j]);\\n            }\\n        }\\n        return res == 2 ? 0: res;\\n    }\\n```",
                "solutionTags": [],
                "code": "```\\n    public int lenLongestFibSubseq(int[] A) {\\n        if (A == null || A.length == 0) {\\n            return 0;\\n        }\\n        //dp[i][j] is the Length of Longest Fibonacci Subsequence with the two ending elements A[i] and A[j]\\n        int len = A.length;\\n        int[][] dp = new int[len][len];\\n        Map<Integer, Integer> m = new HashMap<>();\\n        for (int i = 0; i < len; i++) {\\n            m.put(A[i], i);\\n            for (int j = i + 1; j < len; j++) {\\n                dp[i][j] = 2;\\n            }\\n        }\\n        for (int i = 0; i < len; i++) {\\n            for (int j = i + 1; j < len; j++) {\\n                if (A[j] > A[i]) {\\n                    int k = A[j] + A[i];\\n                    if (m.containsKey(k)) {\\n                        int index = m.get(k);\\n                        dp[j][index] = dp[i][j] + 1;\\n                    }\\n                }\\n            }\\n        }\\n        int res = 0;\\n        for (int i = 0; i < len; i++) {\\n            for (int j = i + 1; j < len; j++) {\\n                res = Math.max(res, dp[i][j]);\\n            }\\n        }\\n        return res == 2 ? 0: res;\\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 469864,
                "title": "solution-using-2-approaches-bfs-dp-in-c",
                "content": "Approach 1 using BFS :\\n\\n```\\nclass Solution {\\npublic:\\n    int lenLongestFibSubseq(vector<int>& A) {\\n        queue < pair<pair<int,int>, pair<int, int> > > q;\\n        unordered_map <int, int> m;\\n        int mx = -1;\\n        \\n        for(int i=0;i<A.size();i++) {\\n            m[A[i]] = i;\\n            q.push({ { 0, 1 }, { A[i], i } });\\n            mx = max(mx, A[i]);\\n        }\\n    \\n        int ans = -1;\\n        \\n        while(!q.empty()) {\\n            int prev = q.front().first.first, depth = q.front().first.second;\\n            int node = q.front().second.first, idx = q.front().second.second;\\n\\n            q.pop();\\n            \\n            if(m.find(prev + node) == m.end()) ans = max(ans, depth);\\n            \\n            \\n            if(depth == 1) {\\n                for(int i=idx+1;i<A.size();i++) {\\n                    q.push({ { node, depth + 1 }, { A[i], i } });\\n                }\\n            }\\n            else {\\n                if(m.find(prev + node) != m.end()) {\\n                    int i = m[prev + node];\\n                    if(i > idx && prev + node <= mx)\\n                        q.push({ { node, depth + 1 }, { prev + node, i } });\\n                } \\n            }\\n        }\\n        return ans >= 3 ? ans : 0;   \\n    }\\n};\\n```\\n\\nApproach 2 using DP :\\n\\n```\\nclass Solution {\\npublic:\\n    int lenLongestFibSubseq(vector<int>& A) {\\n        vector < vector<int> > dp(A.size()+1, vector<int>(A.size()+1, 2));\\n        unordered_map <int, int> m;\\n        int ans = 0;\\n        \\n        for(int i=0;i<A.size();i++) m[A[i]] = i;\\n        \\n        for(int i=2;i<A.size();i++) {\\n            for(int j=i-1;j>=0;j--) {\\n                if(m.find(A[i] - A[j]) != m.end()) {\\n                    int k = m[A[i] - A[j]];\\n                    if(k < j) {\\n                        dp[i][j] = max(dp[i][j], dp[j][k] + 1);\\n                    }\\n                    ans = max(ans, dp[i][j]);\\n                }\\n            }\\n        }\\n        \\n        return ans >= 3 ? ans : 0;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C",
                    "Dynamic Programming",
                    "Breadth-First Search"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int lenLongestFibSubseq(vector<int>& A) {\\n        queue < pair<pair<int,int>, pair<int, int> > > q;\\n        unordered_map <int, int> m;\\n        int mx = -1;\\n        \\n        for(int i=0;i<A.size();i++) {\\n            m[A[i]] = i;\\n            q.push({ { 0, 1 }, { A[i], i } });\\n            mx = max(mx, A[i]);\\n        }\\n    \\n        int ans = -1;\\n        \\n        while(!q.empty()) {\\n            int prev = q.front().first.first, depth = q.front().first.second;\\n            int node = q.front().second.first, idx = q.front().second.second;\\n\\n            q.pop();\\n            \\n            if(m.find(prev + node) == m.end()) ans = max(ans, depth);\\n            \\n            \\n            if(depth == 1) {\\n                for(int i=idx+1;i<A.size();i++) {\\n                    q.push({ { node, depth + 1 }, { A[i], i } });\\n                }\\n            }\\n            else {\\n                if(m.find(prev + node) != m.end()) {\\n                    int i = m[prev + node];\\n                    if(i > idx && prev + node <= mx)\\n                        q.push({ { node, depth + 1 }, { prev + node, i } });\\n                } \\n            }\\n        }\\n        return ans >= 3 ? ans : 0;   \\n    }\\n};\\n```\n```\\nclass Solution {\\npublic:\\n    int lenLongestFibSubseq(vector<int>& A) {\\n        vector < vector<int> > dp(A.size()+1, vector<int>(A.size()+1, 2));\\n        unordered_map <int, int> m;\\n        int ans = 0;\\n        \\n        for(int i=0;i<A.size();i++) m[A[i]] = i;\\n        \\n        for(int i=2;i<A.size();i++) {\\n            for(int j=i-1;j>=0;j--) {\\n                if(m.find(A[i] - A[j]) != m.end()) {\\n                    int k = m[A[i] - A[j]];\\n                    if(k < j) {\\n                        dp[i][j] = max(dp[i][j], dp[j][k] + 1);\\n                    }\\n                    ans = max(ans, dp[i][j]);\\n                }\\n            }\\n        }\\n        \\n        return ans >= 3 ? ans : 0;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 442805,
                "title": "need-help-getting-tle",
                "content": "I am not sure why I am getting TLE. Please help me in this.\\n\\n```\\nclass Solution {\\n    public int lenLongestFibSubseq(int[] A) {\\n        \\n        Map<Integer, Integer> seen = new HashMap<>();\\n        Map<String, Integer> memo=new HashMap<>();\\n        seen.put(A[0],0);\\n        \\n        int result = 2;\\n        for(int j=1;j<A.length;j++){\\n            seen.put(A[j],j);\\n            for(int i = j-1;i>=0;i--){\\n                String key = j+\"-\"+i;\\n                //System.out.println(key);\\n                int k = A[j]-A[i];\\n                if(seen.containsKey(k) && k < A[i] ){\\n                    int temp = memo.get(i+\"-\"+seen.get(k))+1;\\n                    memo.put(key, temp);\\n                    result = Math.max(result, temp);\\n                }else{\\n                    memo.put(key, 2);\\n                }\\n            }\\n        }\\n        \\n        return result==2?0:result;\\n        \\n    }\\n    \\n}\\n```\\n",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    public int lenLongestFibSubseq(int[] A) {\\n        \\n        Map<Integer, Integer> seen = new HashMap<>();\\n        Map<String, Integer> memo=new HashMap<>();\\n        seen.put(A[0],0);\\n        \\n        int result = 2;\\n        for(int j=1;j<A.length;j++){\\n            seen.put(A[j],j);\\n            for(int i = j-1;i>=0;i--){\\n                String key = j+\"-\"+i;\\n                //System.out.println(key);\\n                int k = A[j]-A[i];\\n                if(seen.containsKey(k) && k < A[i] ){\\n                    int temp = memo.get(i+\"-\"+seen.get(k))+1;\\n                    memo.put(key, temp);\\n                    result = Math.max(result, temp);\\n                }else{\\n                    memo.put(key, 2);\\n                }\\n            }\\n        }\\n        \\n        return result==2?0:result;\\n        \\n    }\\n    \\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 381716,
                "title": "c-clean-dp-o-n-2-time-and-o-n-2-space",
                "content": "dp[i][j] - Max Length Fibonacci Subsequence ending with A[i] and A[j]\\n\\nFor every \"i\" solve the 2 Sum Problem and update result\\n\\n\\t- for every i start with s = 0 and e = i - 1 \\n\\t- dp[i][e] = max(dp[i][e], dp[s][e] + 1)  => for A[i] == A[s] + A[e] \\n\\t\\n\\tint lenLongestFibSubseq(vector<int>& A) {\\n        \\n        int res = 0;\\n        vector<vector<int>> dp(A.size());\\n        \\n        for (int i = 0; i < A.size(); i++) {\\n            dp[i] = vector<int>(A.size());\\n            for (int j = i + 1; j < A.size(); j++) {\\n                dp[i][j] = 2;\\n            }\\n        }\\n            \\n        for (int i = 0; i < A.size(); i++) {\\n            int s = 0;\\n            int e = i - 1;\\n            \\n            while (s < e) {\\n                \\n                if (A[s] + A[e] == A[i]) {\\n                    \\n                    dp[e][i] = max(dp[e][i], dp[s][e] + 1);\\n                    res = max(res, dp[e][i]);\\n                    s++; e--;\\n                    \\n                } else if (A[s] + A[e] < A[i])\\n                    s++;\\n                else \\n                    e--;\\n            }\\n            \\n        }\\n        \\n        if (res < 3)\\n            return 0;\\n        \\n        return res;\\n\\t}\\n",
                "solutionTags": [
                    "Dynamic Programming"
                ],
                "code": "dp[i][j] - Max Length Fibonacci Subsequence ending with A[i] and A[j]\\n\\nFor every \"i\" solve the 2 Sum Problem and update result\\n\\n\\t- for every i start with s = 0 and e = i - 1 \\n\\t- dp[i][e] = max(dp[i][e], dp[s][e] + 1)  => for A[i] == A[s] + A[e] \\n\\t\\n\\tint lenLongestFibSubseq(vector<int>& A) {\\n        \\n        int res = 0;\\n        vector<vector<int>> dp(A.size());\\n        \\n        for (int i = 0; i < A.size(); i++) {\\n            dp[i] = vector<int>(A.size());\\n            for (int j = i + 1; j < A.size(); j++) {\\n                dp[i][j] = 2;\\n            }\\n        }\\n            \\n        for (int i = 0; i < A.size(); i++) {\\n            int s = 0;\\n            int e = i - 1;\\n            \\n            while (s < e) {\\n                \\n                if (A[s] + A[e] == A[i]) {\\n                    \\n                    dp[e][i] = max(dp[e][i], dp[s][e] + 1);\\n                    res = max(res, dp[e][i]);\\n                    s++; e--;\\n                    \\n                } else if (A[s] + A[e] < A[i])\\n                    s++;\\n                else \\n                    e--;\\n            }\\n            \\n        }\\n        \\n        if (res < 3)\\n            return 0;\\n        \\n        return res;\\n\\t}\\n",
                "codeTag": "Unknown"
            },
            {
                "id": 347880,
                "title": "c-bottom-up-dp",
                "content": "class Solution {\\npublic:\\n    int lenLongestFibSubseq(vector<int>& A) {\\n        int n = A.size();\\n        \\n        // vector<vector<long long int> > dp(n, vector<long long int>(n,0));\\n        long long int dp[n][n];\\n        for (int i=0; i<n; ++i)\\n            for (int j=0; j<n; ++j)\\n                dp[i][j] = 0;\\n        \\n        bool exist;\\n        long long int val;\\n        \\n        int i,j,l,r,m,k;\\n        \\n        long long int ans = INT_MIN;\\n        \\n        dp[0][0] = 0;\\n        \\n        for (i=2; i<n; ++i) {\\n            for (j=i-1; j>0; --j) {\\n                \\n                val = A[i]-A[j];\\n                exist = false;\\n                \\n                l = 0;\\n                r = j-1;\\n                \\n                while (l<=r) {\\n                    m = l + (r-l)/2;\\n                    \\n                    if (A[m] == val) {\\n                        k = m;\\n                        exist = true;\\n                        break;\\n                    }\\n                    else if (A[m] > val) r = m-1;\\n                    else l = m+1;\\n                }\\n                \\n                if (exist) dp[i][j] = 1 + dp[j][k];\\n                \\n                ans = max(ans, dp[i][j]);\\n            }\\n        }\\n        \\n        if (ans > 0) return ans+2;\\n        else return ans;\\n    }\\n};",
                "solutionTags": [],
                "code": "class Solution {\\npublic:\\n    int lenLongestFibSubseq(vector<int>& A) {\\n        int n = A.size();\\n        \\n        // vector<vector<long long int> > dp(n, vector<long long int>(n,0));\\n        long long int dp[n][n];\\n        for (int i=0; i<n; ++i)\\n            for (int j=0; j<n; ++j)\\n                dp[i][j] = 0;\\n        \\n        bool exist;\\n        long long int val;\\n        \\n        int i,j,l,r,m,k;\\n        \\n        long long int ans = INT_MIN;\\n        \\n        dp[0][0] = 0;\\n        \\n        for (i=2; i<n; ++i) {\\n            for (j=i-1; j>0; --j) {\\n                \\n                val = A[i]-A[j];\\n                exist = false;\\n                \\n                l = 0;\\n                r = j-1;\\n                \\n                while (l<=r) {\\n                    m = l + (r-l)/2;\\n                    \\n                    if (A[m] == val) {\\n                        k = m;\\n                        exist = true;\\n                        break;\\n                    }",
                "codeTag": "Java"
            },
            {
                "id": 335335,
                "title": "javascript-solution-faster-than-94-12-memory-less-than-76-47-comments-in-code",
                "content": "```\\nvar lenLongestFibSubseq = function(A) {\\n    \\n    const map = new Map();\\n    A.forEach((val) => map.set(val, 1)); // filling the map with existing numbers of the array you also use (indexOf).\\n    \\n    let count = 0; // this will keep track the count of the current subsequence fib.\\n    let max = Number.MIN_SAFE_INTEGER; // this will keep track of the maximum number of sub-fib.\\n    \\n    for(let i = 0; i < A.length - 1; i++){ // this for loop is to evaluate one index and compare it with the subsequent ones.\\n        for(let h = i + 1; h < A.length; h++){ // this for loop is to allow the sum of the different combinations of elements.\\n            let sum = A[i] + A[h]; // Add the two elements\\n            let prev = A[h]; // store what is the previous element (previous as in the perspective of the next element, h+1)\\n            let isPresent = map.has(sum); // checks whether the number exists in the map.\\n            if(isPresent){ // if it is present then we know that two numbers (for now) is present on the sub-fib\\n                count += 2;\\n            }\\n            while(isPresent){\\n                count++; // here we increment the count one more because [1,2,3...]; at least 3 elements fo make a sub-fib\\n                const newPrev = sum; // here we backup the sum because after we update the sum the previous sum is the previous number\\n                sum += prev; // here we updated the sum, for example: 1 + 2 = 3, now sum is 3 + 2 = 5;\\n                prev = newPrev; // here we put the value of the backed up sum, which is the new prev number, which is 3.\\n                \\n                isPresent = map.has(sum);\\n            }\\n            max = Math.max(max, count);\\n            count = 0;\\n        }\\n    }\\n    return max;\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nvar lenLongestFibSubseq = function(A) {\\n    \\n    const map = new Map();\\n    A.forEach((val) => map.set(val, 1)); // filling the map with existing numbers of the array you also use (indexOf).\\n    \\n    let count = 0; // this will keep track the count of the current subsequence fib.\\n    let max = Number.MIN_SAFE_INTEGER; // this will keep track of the maximum number of sub-fib.\\n    \\n    for(let i = 0; i < A.length - 1; i++){ // this for loop is to evaluate one index and compare it with the subsequent ones.\\n        for(let h = i + 1; h < A.length; h++){ // this for loop is to allow the sum of the different combinations of elements.\\n            let sum = A[i] + A[h]; // Add the two elements\\n            let prev = A[h]; // store what is the previous element (previous as in the perspective of the next element, h+1)\\n            let isPresent = map.has(sum); // checks whether the number exists in the map.\\n            if(isPresent){ // if it is present then we know that two numbers (for now) is present on the sub-fib\\n                count += 2;\\n            }\\n            while(isPresent){\\n                count++; // here we increment the count one more because [1,2,3...]; at least 3 elements fo make a sub-fib\\n                const newPrev = sum; // here we backup the sum because after we update the sum the previous sum is the previous number\\n                sum += prev; // here we updated the sum, for example: 1 + 2 = 3, now sum is 3 + 2 = 5;\\n                prev = newPrev; // here we put the value of the backed up sum, which is the new prev number, which is 3.\\n                \\n                isPresent = map.has(sum);\\n            }\\n            max = Math.max(max, count);\\n            count = 0;\\n        }\\n    }\\n    return max;\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 324500,
                "title": "java-easy-understanding-solution",
                "content": "\\tclass Solution {\\n\\t\\tpublic int lenLongestFibSubseq(int[] A) {\\n\\t\\t\\tSet<Integer> s=new HashSet<Integer>();\\n\\t\\t\\tfor(int i : A){\\n\\t\\t\\t\\ts.add(i);\\n\\t\\t\\t}\\n\\t\\t\\tint res=0;\\n\\t\\t\\tint n=A.length;\\n\\t\\t\\tfor(int i=0;i<n-1;i++){\\n\\t\\t\\t\\tfor(int j=i+1;j<n;j++){\\n\\t\\t\\t\\t\\tint a=A[i];\\n\\t\\t\\t\\t\\tint b=A[j];\\n\\t\\t\\t\\t\\tint c=a+b;\\n\\t\\t\\t\\t\\tint count=2;\\n\\t\\t\\t\\t\\twhile(s.contains(c)){\\n\\t\\t\\t\\t\\t\\tcount++;\\n\\t\\t\\t\\t\\t\\tres=Math.max(res,count);\\n\\t\\t\\t\\t\\t\\ta=b;\\n\\t\\t\\t\\t\\t\\tb=c;\\n\\t\\t\\t\\t\\t\\tc=a+b;\\n\\t\\t\\t\\t\\t}\\n\\t\\t\\t\\t}\\n\\t\\t\\t}\\n\\t\\t\\tif(res>2){\\n\\t\\t\\t\\treturn res;\\n\\t\\t\\t}else{\\n\\t\\t\\t\\treturn 0;\\n\\t\\t\\t}\\n\\t\\t}\\n\\t}",
                "solutionTags": [
                    "Java"
                ],
                "code": "class Solution {\\n\\t\\tpublic int lenLongestFibSubseq(int[] A) {\\n\\t\\t\\tSet<Integer> s=new HashSet<Integer>();\\n\\t\\t\\tfor(int i : A){\\n\\t\\t\\t\\ts.add(i);\\n\\t\\t\\t}",
                "codeTag": "Java"
            },
            {
                "id": 274232,
                "title": "dfs-with-binarysearch-solution",
                "content": "Here is my DFS with BinarySearch Solution, faster than 50.09%:\\n```\\n    int maxlen = 0;\\n    \\n    public int lenLongestFibSubseq(int[] A) {\\n        dfs(A, 0, 0, 0, 0);\\n        return maxlen >= 3 ? maxlen : 0;\\n    }\\n    \\n    private void dfs(int[] A, int start, int x1, int x2, int len){\\n        if(len > maxlen) maxlen = len;\\n        if(len < 2){\\n            for(int i = start; i<A.length; i++)\\n                dfs(A, i + 1, x2, A[i], len + 1);\\n        }else{\\n            int i;\\n            if((i=Arrays.binarySearch(A, start, A.length, x1 + x2)) >= 0)\\n                dfs(A, i + 1, x2, A[i], len + 1);\\n        }\\n    }\\n```\\n\\nAnd this is my DFS + HashMap Solution, faster than 87.27%:\\n```\\n    int maxlen = 0;\\n    Map<Integer, Integer> index = new HashMap<>();\\n    \\n    public int lenLongestFibSubseq(int[] A) {\\n        for(int i=0; i<A.length; i++) index.put(A[i], i);\\n        dfs(A, 0, 0, 0, 0);\\n        return maxlen >= 3 ? maxlen : 0;\\n    }\\n    \\n    private void dfs(int[] A, int start, int x1, int x2, int len){\\n        if(len > maxlen) maxlen = len;\\n        if(len < 2){\\n            for(int i = start; i<A.length; i++)\\n                dfs(A, i + 1, x2, A[i], len + 1);\\n        }else{\\n            Integer idx = index.get(x1 + x2);\\n            if(idx != null && idx >= start)\\n                dfs(A, idx + 1, x2, A[idx], len + 1);\\n        }\\n    }\\n```",
                "solutionTags": [],
                "code": "```\\n    int maxlen = 0;\\n    \\n    public int lenLongestFibSubseq(int[] A) {\\n        dfs(A, 0, 0, 0, 0);\\n        return maxlen >= 3 ? maxlen : 0;\\n    }\\n    \\n    private void dfs(int[] A, int start, int x1, int x2, int len){\\n        if(len > maxlen) maxlen = len;\\n        if(len < 2){\\n            for(int i = start; i<A.length; i++)\\n                dfs(A, i + 1, x2, A[i], len + 1);\\n        }else{\\n            int i;\\n            if((i=Arrays.binarySearch(A, start, A.length, x1 + x2)) >= 0)\\n                dfs(A, i + 1, x2, A[i], len + 1);\\n        }\\n    }\\n```\n```\\n    int maxlen = 0;\\n    Map<Integer, Integer> index = new HashMap<>();\\n    \\n    public int lenLongestFibSubseq(int[] A) {\\n        for(int i=0; i<A.length; i++) index.put(A[i], i);\\n        dfs(A, 0, 0, 0, 0);\\n        return maxlen >= 3 ? maxlen : 0;\\n    }\\n    \\n    private void dfs(int[] A, int start, int x1, int x2, int len){\\n        if(len > maxlen) maxlen = len;\\n        if(len < 2){\\n            for(int i = start; i<A.length; i++)\\n                dfs(A, i + 1, x2, A[i], len + 1);\\n        }else{\\n            Integer idx = index.get(x1 + x2);\\n            if(idx != null && idx >= start)\\n                dfs(A, idx + 1, x2, A[idx], len + 1);\\n        }\\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 258418,
                "title": "python-dp-o-n2-easy-to-understand",
                "content": "```\\nclass Solution(object):\\n\\tdef lenLongestFibSubseq(self, A):\\n\\t\\tseen, ma = set(), 0\\n\\t\\tdd = {num: index for index, num in enumerate(A)}\\n\\n\\t\\tfor i in xrange(len(A)):\\n\\t\\t\\tfor j in xrange(i+1, len(A)):\\n\\t\\t\\t\\tif (i,j) not in seen:\\n\\t\\t\\t\\t\\tfirst, second, count = A[i], A[j], 2\\n\\t\\t\\t\\t\\twhile first + second in dd:\\n\\t\\t\\t\\t\\t\\tcount += 1\\n\\t\\t\\t\\t\\t\\tfirst, second = second, first + second\\n\\t\\t\\t\\t\\t\\tseen.add((dd[first], dd[second]))\\n\\n\\t\\t\\t\\t\\tif count >= 3 and count > ma:\\n\\t\\t\\t\\t\\t\\tma = count\\n\\n\\t\\t\\tif len(A) - i <= ma:\\n\\t\\t\\t\\tbreak\\n\\t\\treturn ma",
                "solutionTags": [],
                "code": "class Solution(object):\\n\\tdef lenLongestFibSubseq(self, A):\\n\\t\\tseen, ma = set(), 0\\n\\t\\tdd = {num: index for index, num in enumerate(A)}",
                "codeTag": "Java"
            },
            {
                "id": 210391,
                "title": "java-o-n-3-time-o-n-space-solution",
                "content": "Time complexity is O(n^3) and space complexity O(n). It can be optimized to O(n^2) using cache to store matched pairs.\\n```\\nclass Solution {\\n    public int lenLongestFibSubseq(int[] A) {\\n        int res = 0;\\n        Set<Integer> set = new HashSet<>();\\n        for (int num : A) set.add(num);\\n        for (int i = 0; i < A.length - 2; i++) {\\n            for (int j = i + 1; j < A.length - 1; j++) {\\n                int x0 = A[i], x1 = A[j];\\n                int len = 2;\\n                while (set.contains(x0 + x1)) {\\n                    len++;\\n                    res = Math.max(res, len);\\n                    int tmp = x0;\\n                    x0 = x1;\\n                    x1 = tmp + x1;\\n                }\\n            }\\n        }\\n        return res < 3 ? 0 : res;\\n    }\\n}\\n```\\n\\nDP solution, time complexity O(n^2) and space complexity O(n^2)\\n```\\nclass Solution {\\n    public int lenLongestFibSubseq(int[] A) {\\n        int res = 0;\\n        int n = A.length;\\n        int[][] dp = new int[n][n];\\n        Map<Integer, Integer> map = new HashMap<>();\\n        for (int i = 0; i < A.length; i++) {\\n            map.put(A[i], i);\\n        }\\n        for (int i = 0; i < A.length - 1; i++) {\\n            for (int j = i + 1; j < A.length; j++) {\\n                int prev = A[j] - A[i];\\n                if (map.containsKey(prev) && map.get(prev) < i) {\\n                    dp[i][j] = 1 + dp[map.get(prev)][i];\\n                } else {\\n                    dp[i][j] = 2;\\n                }\\n                res = Math.max(res, dp[i][j]);\\n            }\\n        }\\n        return res < 3 ? 0 : res;\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    public int lenLongestFibSubseq(int[] A) {\\n        int res = 0;\\n        Set<Integer> set = new HashSet<>();\\n        for (int num : A) set.add(num);\\n        for (int i = 0; i < A.length - 2; i++) {\\n            for (int j = i + 1; j < A.length - 1; j++) {\\n                int x0 = A[i], x1 = A[j];\\n                int len = 2;\\n                while (set.contains(x0 + x1)) {\\n                    len++;\\n                    res = Math.max(res, len);\\n                    int tmp = x0;\\n                    x0 = x1;\\n                    x1 = tmp + x1;\\n                }\\n            }\\n        }\\n        return res < 3 ? 0 : res;\\n    }\\n}\\n```\n```\\nclass Solution {\\n    public int lenLongestFibSubseq(int[] A) {\\n        int res = 0;\\n        int n = A.length;\\n        int[][] dp = new int[n][n];\\n        Map<Integer, Integer> map = new HashMap<>();\\n        for (int i = 0; i < A.length; i++) {\\n            map.put(A[i], i);\\n        }\\n        for (int i = 0; i < A.length - 1; i++) {\\n            for (int j = i + 1; j < A.length; j++) {\\n                int prev = A[j] - A[i];\\n                if (map.containsKey(prev) && map.get(prev) < i) {\\n                    dp[i][j] = 1 + dp[map.get(prev)][i];\\n                } else {\\n                    dp[i][j] = 2;\\n                }\\n                res = Math.max(res, dp[i][j]);\\n            }\\n        }\\n        return res < 3 ? 0 : res;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 209724,
                "title": "a-simple-c-solution-beats-100-00-accepted-runtime-80-ms",
                "content": "```\\n#define SIZE 1000    \\nstruct HashArray\\n{\\n    int key;\\n    int count;\\n    struct HashArray* next;\\n}Hash[SIZE];       \\nvoid addHash(int num)     \\n{\\n    int temp=abs(num%SIZE);     \\n    if(Hash[temp].key==0)\\n    {\\n        Hash[temp].key=num;\\n        Hash[temp].count++;\\n    }else if(Hash[temp].key==num)\\n    {\\n        Hash[temp].count++;     \\n    }else\\n    {\\n        struct HashArray *p=&Hash[temp]; \\n        while(p->key!=num&&p->next!=NULL)    \\n        {p=p->next;}\\n        if(p->key==num)\\n        {p->count++;}\\n        else\\n        {\\n            p->next=(struct HashArray*)malloc(sizeof(struct HashArray));\\n            p=p->next;\\n            p->key=num;\\n            p->count=1;\\n            p->next=NULL;\\n        }\\n    }   \\n}\\nint findHash(int num){\\n    int temp=abs(num%SIZE);     \\n    if(Hash[temp].key==0||Hash[temp].count==0)\\n    {\\n        return 0;\\n    }else if(Hash[temp].key==num)\\n    {\\n        return 1;\\n    }else\\n    {\\n        struct HashArray *p=&Hash[temp]; \\n        while(p->key!=num&&p->next!=NULL)    \\n        {p=p->next;}\\n        if(p->key==num)\\n        {return 1;}\\n        else\\n        {return 0;}\\n    } \\n}\\nint lenLongestFibSubseq(int* A, int ASize) {\\n    for(int i=0;i<SIZE;i++){\\n        Hash[i].key=0;\\n        Hash[i].count=0;\\n        Hash[i].next=NULL;\\n    }\\n    int ret=0;\\n    for(int i=0;i<ASize;i++){\\n        addHash(A[i]);\\n    }\\n    for(int i=0;i<ASize-2;i++){\\n       for(int j=i+1;j<ASize-1;j++){\\n           int temp1=A[i];\\n           int temp2=A[j];\\n           int count=2;\\n           while(findHash(temp1+temp2)){\\n               int temp=temp1+temp2;\\n               temp1=temp2;\\n               temp2=temp;\\n               count++;\\n           }\\n           if(count>ret){\\n               ret=count;\\n           }\\n       } \\n    }\\n    return ret>2?ret:0;\\n}\\n```",
                "solutionTags": [],
                "code": "```\\n#define SIZE 1000    \\nstruct HashArray\\n{\\n    int key;\\n    int count;\\n    struct HashArray* next;\\n}Hash[SIZE];       \\nvoid addHash(int num)     \\n{\\n    int temp=abs(num%SIZE);     \\n    if(Hash[temp].key==0)\\n    {\\n        Hash[temp].key=num;\\n        Hash[temp].count++;\\n    }else if(Hash[temp].key==num)\\n    {\\n        Hash[temp].count++;     \\n    }else\\n    {\\n        struct HashArray *p=&Hash[temp]; \\n        while(p->key!=num&&p->next!=NULL)    \\n        {p=p->next;}\\n        if(p->key==num)\\n        {p->count++;}\\n        else\\n        {\\n            p->next=(struct HashArray*)malloc(sizeof(struct HashArray));\\n            p=p->next;\\n            p->key=num;\\n            p->count=1;\\n            p->next=NULL;\\n        }\\n    }   \\n}\\nint findHash(int num){\\n    int temp=abs(num%SIZE);     \\n    if(Hash[temp].key==0||Hash[temp].count==0)\\n    {\\n        return 0;\\n    }else if(Hash[temp].key==num)\\n    {\\n        return 1;\\n    }else\\n    {\\n        struct HashArray *p=&Hash[temp]; \\n        while(p->key!=num&&p->next!=NULL)    \\n        {p=p->next;}\\n        if(p->key==num)\\n        {return 1;}\\n        else\\n        {return 0;}\\n    } \\n}\\nint lenLongestFibSubseq(int* A, int ASize) {\\n    for(int i=0;i<SIZE;i++){\\n        Hash[i].key=0;\\n        Hash[i].count=0;\\n        Hash[i].next=NULL;\\n    }\\n    int ret=0;\\n    for(int i=0;i<ASize;i++){\\n        addHash(A[i]);\\n    }\\n    for(int i=0;i<ASize-2;i++){\\n       for(int j=i+1;j<ASize-1;j++){\\n           int temp1=A[i];\\n           int temp2=A[j];\\n           int count=2;\\n           while(findHash(temp1+temp2)){\\n               int temp=temp1+temp2;\\n               temp1=temp2;\\n               temp2=temp;\\n               count++;\\n           }\\n           if(count>ret){\\n               ret=count;\\n           }\\n       } \\n    }\\n    return ret>2?ret:0;\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 152497,
                "title": "non-dp-straightforward-solution-o-n-2-time-complexity",
                "content": "The fact is that a pair of two adjacent numbers uniquely identify a fibonacci-like sequence (proof by induction). So for all possible fibonacci-like sequences, `(i, j)` can appear as adjacent numbers in at most one fibonacci-like sequence. ((`i, j)` might not be able to used as adjacent numbers in any fibonacci-like sequence at all).\\nThus we check all possible starting pairs `(i, j)`,  and ignore the one that\\'s been `seen`,  which gives us a O(n^2) solution.\\n\\n```\\nclass Solution {\\n    public int lenLongestFibSubseq(int[] A) {\\n        int N = A.length;\\n        \\n        Map<Integer, Integer> index = new HashMap<>();\\n        for (int i = 0; i < N; i++) {\\n            index.put(A[i], i);\\n        }\\n        \\n        boolean[][] seen = new boolean[N][N];\\n        int max = 0;\\n        for (int i = 0; i < A.length; i++) {\\n            for (int j = i+1; j < A.length; j++) {\\n                if (seen[i][j]) {\\n                    continue;\\n                }\\n                seen[i][j] = true;\\n                \\n                int count = 2;\\n                int a = i;\\n                int b = j;\\n                while (index.containsKey(A[a]+A[b])) {\\n                    int k = index.get(A[a]+A[b]);\\n                    a = b;\\n                    b = k;\\n                    seen[a][b] = true;\\n                    count++;\\n                }\\n                if (count > 2) {\\n                    max = Math.max(max, count);\\n                }\\n            }\\n        }\\n        \\n        return max;\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    public int lenLongestFibSubseq(int[] A) {\\n        int N = A.length;\\n        \\n        Map<Integer, Integer> index = new HashMap<>();\\n        for (int i = 0; i < N; i++) {\\n            index.put(A[i], i);\\n        }\\n        \\n        boolean[][] seen = new boolean[N][N];\\n        int max = 0;\\n        for (int i = 0; i < A.length; i++) {\\n            for (int j = i+1; j < A.length; j++) {\\n                if (seen[i][j]) {\\n                    continue;\\n                }\\n                seen[i][j] = true;\\n                \\n                int count = 2;\\n                int a = i;\\n                int b = j;\\n                while (index.containsKey(A[a]+A[b])) {\\n                    int k = index.get(A[a]+A[b]);\\n                    a = b;\\n                    b = k;\\n                    seen[a][b] = true;\\n                    count++;\\n                }\\n                if (count > 2) {\\n                    max = Math.max(max, count);\\n                }\\n            }\\n        }\\n        \\n        return max;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 152386,
                "title": "c-backtrack-binary-search",
                "content": "```\\nclass Solution {\\npublic:\\n    int lenLongestFibSubseq(vector<int>& A) {\\n        // backtrack + binary search ; could be improved to use hash table to store values in A\\n        int mx=0;\\n        \\n        for( int i=0; i<A.size()-2; i++){\\n            for( int j=i+1; j<A.size()-1; j++){\\n                backTrack( i, j, A, mx);\\n            }\\n        }\\n        \\n        return mx;\\n    }\\n    \\n    void backTrack( int i, int j, vector<int>& A, int& mx){\\n        int len=2, t;\\n        \\n        while( j+1<A.size() ){\\n            //cout<<A[i]+A[j]<<\" \";\\n            t=binarySearch( j+1, A[i]+A[j], A);\\n            if(t==-1)   break ;\\n            i=j;\\n            j=t;\\n            len++;\\n        }\\n        \\n        if(len!=2)  mx=mx<len?len:mx;\\n        \\n        return ;\\n    }\\n    \\n    int binarySearch( int k, int target, vector<int>& A){// [k, A.size())\\n        int b=k, e=A.size(), mid;\\n        \\n        while(b<e-1){\\n            mid=b+(e-b)/2;\\n            if(target<A[mid])   e=mid;\\n            else    b=mid;\\n        }\\n        \\n        return A[b]!=target?-1:b;\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    int lenLongestFibSubseq(vector<int>& A) {\\n        // backtrack + binary search ; could be improved to use hash table to store values in A\\n        int mx=0;\\n        \\n        for( int i=0; i<A.size()-2; i++){\\n            for( int j=i+1; j<A.size()-1; j++){\\n                backTrack( i, j, A, mx);\\n            }\\n        }\\n        \\n        return mx;\\n    }\\n    \\n    void backTrack( int i, int j, vector<int>& A, int& mx){\\n        int len=2, t;\\n        \\n        while( j+1<A.size() ){\\n            //cout<<A[i]+A[j]<<\" \";\\n            t=binarySearch( j+1, A[i]+A[j], A);\\n            if(t==-1)   break ;\\n            i=j;\\n            j=t;\\n            len++;\\n        }\\n        \\n        if(len!=2)  mx=mx<len?len:mx;\\n        \\n        return ;\\n    }\\n    \\n    int binarySearch( int k, int target, vector<int>& A){// [k, A.size())\\n        int b=k, e=A.size(), mid;\\n        \\n        while(b<e-1){\\n            mid=b+(e-b)/2;\\n            if(target<A[mid])   e=mid;\\n            else    b=mid;\\n        }\\n        \\n        return A[b]!=target?-1:b;\\n    }\\n};\\n```",
                "codeTag": "C++"
            },
            {
                "id": 152368,
                "title": "simplest-easiest-java-brute-force",
                "content": "```\\nclass Solution {\\n    public int lenLongestFibSubseq(int[] A) {\\n        HashMap<Integer,Integer> hm=new HashMap<Integer,Integer>();\\n        int i=0,j=0, max=0,temp=0;\\n        for(i=0;i<A.length;i++)\\n        {\\n            hm.put(A[i],i);\\n        }\\n        boolean flag=true;              \\n        for(i=0;i<A.length-1;i++)\\n        {            \\n            for(j=i+1;j<A.length;j++)\\n            {\\n                int prev=A[i];\\n                int next=A[j];\\n                int count=2;\\n                flag=true;\\n                while(flag)\\n               {\\n                if(hm.containsKey(prev+next))\\n                {                    \\n                    temp=prev+next;\\n                    prev=next;\\n                    next=temp;\\n                    count++;\\n                    max=Math.max(max,count);\\n                }\\n                    else\\n                        flag=false;\\n              }\\n            }            \\n        }        \\n        return max;\\n    }\\n}",
                "solutionTags": [],
                "code": "class Solution {\\n    public int lenLongestFibSubseq(int[] A) {\\n        HashMap<Integer,Integer> hm=new HashMap<Integer,Integer>();\\n        int i=0,j=0, max=0,temp=0;\\n        for(i=0;i<A.length;i++)\\n        {\\n            hm.put(A[i],i);\\n        }",
                "codeTag": "Java"
            },
            {
                "id": 152348,
                "title": "why-is-this-question-classified-as-medium",
                "content": "Seems like brutal force is acceptable. Any admin can share some details about how the difficulty of a problem is determined?",
                "solutionTags": [],
                "code": "",
                "codeTag": "Unknown"
            },
            {
                "id": 152344,
                "title": "simple-java-solution-using-hashmap-with-explanation",
                "content": "The solution is simple as follows;\\n1- Records all the values of the array including their indexes into a HashMap\\n2- Then find the first 2 integers (A & B) which has the third integer in the array as A+B=C\\n3- Do the recursion to find the rest of the sequence.\\n```\\n\\t int res=0;\\n\\t public int lenLongestFibSubseq(int[] A) {\\n\\t     int len = A.length;\\n\\t     HashMap<Integer,Integer> map = new HashMap<>();\\n\\t     for(int i=0; i<len; i++) map.put(A[i], i); \\n\\t     for(int i=0; i<len; i++){\\n\\t\\t\\t for(int j=i+1; j<len; j++){\\n\\t\\t\\t\\t if(!map.containsKey(A[i]+A[j]) || map.get(A[i]+A[j])<=j) continue; \\n\\t\\t\\t\\t helper(map.get(A[i]+A[j]),len,A,map,A[j],3); \\n\\t\\t\\t }\\n\\t     }\\n\\t     return res;\\n\\t    }\\n\\t void helper(int start, int len, int[] A, HashMap<Integer,Integer> map, int prev, int count){ \\n\\t\\t res=Math.max(count, res); \\n\\t\\t  if(!map.containsKey(A[start]+prev) || map.get(A[start]+prev)<=start) return;\\t\\t\\t \\n\\t\\t\\thelper( map.get(A[start]+prev), len, A, map, A[start], count+1); \\n\\t }\\n```",
                "solutionTags": [],
                "code": "```\\n\\t int res=0;\\n\\t public int lenLongestFibSubseq(int[] A) {\\n\\t     int len = A.length;\\n\\t     HashMap<Integer,Integer> map = new HashMap<>();\\n\\t     for(int i=0; i<len; i++) map.put(A[i], i); \\n\\t     for(int i=0; i<len; i++){\\n\\t\\t\\t for(int j=i+1; j<len; j++){\\n\\t\\t\\t\\t if(!map.containsKey(A[i]+A[j]) || map.get(A[i]+A[j])<=j) continue; \\n\\t\\t\\t\\t helper(map.get(A[i]+A[j]),len,A,map,A[j],3); \\n\\t\\t\\t }\\n\\t     }\\n\\t     return res;\\n\\t    }\\n\\t void helper(int start, int len, int[] A, HashMap<Integer,Integer> map, int prev, int count){ \\n\\t\\t res=Math.max(count, res); \\n\\t\\t  if(!map.containsKey(A[start]+prev) || map.get(A[start]+prev)<=start) return;\\t\\t\\t \\n\\t\\t\\thelper( map.get(A[start]+prev), len, A, map, A[start], count+1); \\n\\t }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 152315,
                "title": "concise-c-solution-using-set",
                "content": "```\\nclass Solution {\\npublic:\\n    int lenLongestFibSubseq(vector<int>& A) {\\n        set<int>s(A.begin(),A.end());\\n        int res=0;\\n        for(int i=0;i<(int)A.size()-res;i++){\\n            for(int j=i+1;j<(int)A.size();j++){\\n                int a=A[i],b=A[j];\\n                if(s.find(a+b)!=s.end()){\\n                    res=max(res,check(a,b,2,s));\\n                }\\n            }\\n        }\\n        return res;\\n    }\\nprivate:\\n    int check(int a,int b,int counter,set<int>&s){\\n        int c=a+b;\\n        while(s.find(c)!=s.end()){\\n            counter++;\\n            a=b;b=c;\\n            c=a+b;\\n        }\\n        return counter;\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    int lenLongestFibSubseq(vector<int>& A) {\\n        set<int>s(A.begin(),A.end());\\n        int res=0;\\n        for(int i=0;i<(int)A.size()-res;i++){\\n            for(int j=i+1;j<(int)A.size();j++){\\n                int a=A[i],b=A[j];\\n                if(s.find(a+b)!=s.end()){\\n                    res=max(res,check(a,b,2,s));\\n                }\\n            }\\n        }\\n        return res;\\n    }\\nprivate:\\n    int check(int a,int b,int counter,set<int>&s){\\n        int c=a+b;\\n        while(s.find(c)!=s.end()){\\n            counter++;\\n            a=b;b=c;\\n            c=a+b;\\n        }\\n        return counter;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 4087083,
                "title": "make-every-possible-pair-and-check",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    \\n    unordered_set<int>st;\\n    int check(int pre,int curr)\\n    {\\n        int cnt=2;\\n        while(st.find(pre+curr)!=st.end())\\n        {   \\n            int k=curr+pre;\\n            pre=curr;\\n            curr=k;\\n            cnt++;\\n        }\\n        return cnt;\\n    }\\n    int lenLongestFibSubseq(vector<int>& arr) {\\n        int ans=0;\\n       \\n       \\n        for(auto it:arr)\\n        {\\n            st.insert(it);\\n        }\\n        for(int i=0;i<arr.size();i++)\\n        {\\n            for(int j=i+1;j<arr.size();j++)\\n            {   \\n                \\n                ans=max(ans,check(arr[i],arr[j]));\\n            }\\n        }\\n        if(ans<=2)\\n        return 0;\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Ordered Set"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    \\n    unordered_set<int>st;\\n    int check(int pre,int curr)\\n    {\\n        int cnt=2;\\n        while(st.find(pre+curr)!=st.end())\\n        {   \\n            int k=curr+pre;\\n            pre=curr;\\n            curr=k;\\n            cnt++;\\n        }\\n        return cnt;\\n    }\\n    int lenLongestFibSubseq(vector<int>& arr) {\\n        int ans=0;\\n       \\n       \\n        for(auto it:arr)\\n        {\\n            st.insert(it);\\n        }\\n        for(int i=0;i<arr.size();i++)\\n        {\\n            for(int j=i+1;j<arr.size();j++)\\n            {   \\n                \\n                ans=max(ans,check(arr[i],arr[j]));\\n            }\\n        }\\n        if(ans<=2)\\n        return 0;\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 4060487,
                "title": "easiest-solution",
                "content": "\\n\\n# Code\\n```java []\\nclass Solution {\\n    public int lenLongestFibSubseq(int[] a) {\\n        int ans=0,n=a.length;\\n        Map<Integer,Integer> m=new HashMap<Integer,Integer>();\\n        for(int i=0;i<n;i++) m.put(a[i],i);\\n        for(int i=0;i<n-1;i++){\\n            for(int j=i+1;j<n;j++){\\n                int y=a[j],x=a[i],k=2;\\n                while(true){\\n                    if(m.containsKey(x+y)){\\n                        int t=x+y;\\n                        x=y;\\n                        y=t;\\n                        k++;\\n                    }\\n                    else break;\\n                }\\n                if(k>=3) ans=Math.max(ans,k);\\n            }\\n        }\\n        return ans;\\n    }\\n}\\n```\\n```c++ []\\nclass Solution {\\npublic:\\n    int lenLongestFibSubseq(vector<int>& arr) {\\n        unordered_set<int>st;\\n        for(int i = 0; i < arr.size(); i++){\\n            st.insert(arr[i]);\\n        }\\n        int temp = 0;\\n        int ans = INT_MIN;\\n        for(int i = 0; i < arr.size(); i++){\\n            for(int j = i+1; j < arr.size(); j++){\\n                int x = arr[i];\\n                int y = arr[j];\\n                int z = x+y;\\n                temp = 2;\\n                while(st.find(z) != st.end()){\\n                    temp++;\\n                    x = y;\\n                    y = z;\\n                    z = x+y;\\n                }\\n                ans = max(ans, temp);\\n            }\\n        }\\n        if(ans <= 2){\\n            return 0;\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Java"
                ],
                "code": "```java []\\nclass Solution {\\n    public int lenLongestFibSubseq(int[] a) {\\n        int ans=0,n=a.length;\\n        Map<Integer,Integer> m=new HashMap<Integer,Integer>();\\n        for(int i=0;i<n;i++) m.put(a[i],i);\\n        for(int i=0;i<n-1;i++){\\n            for(int j=i+1;j<n;j++){\\n                int y=a[j],x=a[i],k=2;\\n                while(true){\\n                    if(m.containsKey(x+y)){\\n                        int t=x+y;\\n                        x=y;\\n                        y=t;\\n                        k++;\\n                    }\\n                    else break;\\n                }\\n                if(k>=3) ans=Math.max(ans,k);\\n            }\\n        }\\n        return ans;\\n    }\\n}\\n```\n```c++ []\\nclass Solution {\\npublic:\\n    int lenLongestFibSubseq(vector<int>& arr) {\\n        unordered_set<int>st;\\n        for(int i = 0; i < arr.size(); i++){\\n            st.insert(arr[i]);\\n        }\\n        int temp = 0;\\n        int ans = INT_MIN;\\n        for(int i = 0; i < arr.size(); i++){\\n            for(int j = i+1; j < arr.size(); j++){\\n                int x = arr[i];\\n                int y = arr[j];\\n                int z = x+y;\\n                temp = 2;\\n                while(st.find(z) != st.end()){\\n                    temp++;\\n                    x = y;\\n                    y = z;\\n                    z = x+y;\\n                }\\n                ans = max(ans, temp);\\n            }\\n        }\\n        if(ans <= 2){\\n            return 0;\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3912118,
                "title": "c-using-two-pointers-easy-explained-with-comments",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n***please upvote***\\n1. running loop for 1st element\\n2. running loop for 2nd element corresponding to 1 element\\n3. running loop and checking if previous 2 pointer is having sum equal to it else break.\\n4. continue this process.\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n1. running loop for 1st element\\n2. running loop for 2nd element corresponding to 1 element\\n3. running loop and checking if previous 2 pointer is having sum equal to it else break.\\n4. continue this process.\\n# Complexity\\n- Time complexity: O(N2)\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:O(1)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int lenLongestFibSubseq(vector<int>& arr) {\\n      int n=arr.size();     //SIZE of arr\\n      int len=2;\\n      int maxi=len;\\n      int m=n;\\n       if(n>100) m/=2;\\n        for(int i=0;i<n-1;i++){      //loop for 1st pointer\\n          for(int j=i+1;j<m;j++){    //loop for 2nd pointer w.r.t 1st pointer\\n          len=2;  \\n        int prev1=arr[j];\\n        int prev2=arr[i];\\n        for(int i=j+1;i<n;i++){    //loop for checking sum of last 2 pointer is equal to current pointer or not\\n          if(arr[i]==prev1+prev2){\\n            prev2=prev1;\\n            prev1=arr[i];\\n            len++;\\n          }\\n          else if(arr[i]>prev1+prev2){  // sum is greater then break\\n            break;\\n          }\\n        }\\n        maxi=max(len,maxi);     //finding len of longest subsequence\\n        }\\n        }\\n        if(maxi==2) return 0;\\n        else return maxi;     //returning value\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Two Pointers",
                    "Dynamic Programming",
                    "Greedy"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int lenLongestFibSubseq(vector<int>& arr) {\\n      int n=arr.size();     //SIZE of arr\\n      int len=2;\\n      int maxi=len;\\n      int m=n;\\n       if(n>100) m/=2;\\n        for(int i=0;i<n-1;i++){      //loop for 1st pointer\\n          for(int j=i+1;j<m;j++){    //loop for 2nd pointer w.r.t 1st pointer\\n          len=2;  \\n        int prev1=arr[j];\\n        int prev2=arr[i];\\n        for(int i=j+1;i<n;i++){    //loop for checking sum of last 2 pointer is equal to current pointer or not\\n          if(arr[i]==prev1+prev2){\\n            prev2=prev1;\\n            prev1=arr[i];\\n            len++;\\n          }\\n          else if(arr[i]>prev1+prev2){  // sum is greater then break\\n            break;\\n          }\\n        }\\n        maxi=max(len,maxi);     //finding len of longest subsequence\\n        }\\n        }\\n        if(maxi==2) return 0;\\n        else return maxi;     //returning value\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3894199,
                "title": "c-python-dynamic-programming-solution-with-explanation",
                "content": "```dp[i][j]``` is max length of sequence whose last two numbers are arr[i] and arr[j].\\n\\nuse a hash map to record each value\\'s index.\\n\\nAt first, last 2 number of seq = (a, b), check if (b-a, a) exists,\\nif so, lengh of  (a, b) is length of (b-a, a) + 1 if b - a < a \\ne.g. (a, b) = (3, 6), prev = 6 - 3 = 3, because of strict increasing, 6 - 3 >= 3, (3,3,6) not existt.\\n\\ntc is O(n^2), sc is O(n^2).\\n### python\\n```python\\nclass Solution:\\n    def lenLongestFibSubseq(self, arr: List[int]) -> int:\\n        size = len(arr)\\n        dp = [[2] * size for _ in range(size)]\\n        mapping = {v: i for i, v in enumerate(arr)}\\n        ans = 2\\n        for i in range(size):\\n            for j in range(i+1, size):\\n                prev = arr[j] - arr[i]\\n                if prev >= arr[i]: break\\n                elif prev in mapping:\\n                    dp[i][j] = dp[mapping[prev]][i] + 1\\n                ans = ans if ans > dp[i][j] else dp[i][j]\\n        return 0 if ans == 2 else ans\\n```\\n### c++\\n```cpp\\nclass Solution {\\npublic:\\n    int lenLongestFibSubseq(vector<int>& arr) {\\n        int size = arr.size();\\n        vector<vector<int>> dp (size, vector<int> (size, 2));\\n        unordered_map<int, int> mapping;\\n        int ans = 2;\\n        for (int i = 0; i < size; i+=1) mapping.emplace(arr[i], i);\\n        for (int i = 0; i < size; i+=1) {\\n            for (int j = i + 1, prev; j < size; j+=1) {\\n                prev = arr[j] - arr[i];\\n                if (prev >= arr[i]) break;\\n                else if (mapping.count(prev)) dp[i][j] = dp[mapping[prev]][i] + 1;\\n                ans = ans > dp[i][j]? ans: dp[i][j];\\n            }\\n        }\\n        return ans == 2? 0: ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "Python",
                    "C",
                    "Dynamic Programming"
                ],
                "code": "```dp[i][j]```\n```python\\nclass Solution:\\n    def lenLongestFibSubseq(self, arr: List[int]) -> int:\\n        size = len(arr)\\n        dp = [[2] * size for _ in range(size)]\\n        mapping = {v: i for i, v in enumerate(arr)}\\n        ans = 2\\n        for i in range(size):\\n            for j in range(i+1, size):\\n                prev = arr[j] - arr[i]\\n                if prev >= arr[i]: break\\n                elif prev in mapping:\\n                    dp[i][j] = dp[mapping[prev]][i] + 1\\n                ans = ans if ans > dp[i][j] else dp[i][j]\\n        return 0 if ans == 2 else ans\\n```\n```cpp\\nclass Solution {\\npublic:\\n    int lenLongestFibSubseq(vector<int>& arr) {\\n        int size = arr.size();\\n        vector<vector<int>> dp (size, vector<int> (size, 2));\\n        unordered_map<int, int> mapping;\\n        int ans = 2;\\n        for (int i = 0; i < size; i+=1) mapping.emplace(arr[i], i);\\n        for (int i = 0; i < size; i+=1) {\\n            for (int j = i + 1, prev; j < size; j+=1) {\\n                prev = arr[j] - arr[i];\\n                if (prev >= arr[i]) break;\\n                else if (mapping.count(prev)) dp[i][j] = dp[mapping[prev]][i] + 1;\\n                ans = ans > dp[i][j]? ans: dp[i][j];\\n            }\\n        }\\n        return ans == 2? 0: ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3830957,
                "title": "a-c-solution",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\npublic class Solution {\\n    public int LenLongestFibSubseq(int[] arr) {\\n        int res = 0;\\n        for (int i = 0; i < arr.Length - 2; i++)\\n        {\\n            for (int j = i + 1; j < arr.Length - 1; j++)\\n            {\\n                if (arr.Length - j + 1 < res) break;\\n                var count = 2; \\n                int first = arr[i], second = arr[j], third = first + second;\\n                while (arr.Contains(third))\\n                {\\n                    first = second; second = third;\\n                    count++;\\n                    third = first + second;\\n                }\\n                if (count > res) res = count;\\n            }\\n        }\\n        return res == 2 ? 0 : res;;\\n    }\\n}\\n```",
                "solutionTags": [
                    "C#"
                ],
                "code": "```\\npublic class Solution {\\n    public int LenLongestFibSubseq(int[] arr) {\\n        int res = 0;\\n        for (int i = 0; i < arr.Length - 2; i++)\\n        {\\n            for (int j = i + 1; j < arr.Length - 1; j++)\\n            {\\n                if (arr.Length - j + 1 < res) break;\\n                var count = 2; \\n                int first = arr[i], second = arr[j], third = first + second;\\n                while (arr.Contains(third))\\n                {\\n                    first = second; second = third;\\n                    count++;\\n                    third = first + second;\\n                }\\n                if (count > res) res = count;\\n            }\\n        }\\n        return res == 2 ? 0 : res;;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3824548,
                "title": "c-dp-hashmap-tc-o-n-2-112ms-beats-100-codes-with-explanations",
                "content": "# Complexity\\n- Time complexity: $$O(N^2)$$\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: $$O(N^2)$$\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int lenLongestFibSubseq(vector<int>& arr) {\\n        unordered_map<int, int> mp; // mp[Value] = position\\n        int size = arr.size();\\n        // dp[a][b]: the longest length of the fibonacci subsequence ends with {arr[a], arr[b]}\\n        int dp[size][size];\\n        memset(dp, 0, sizeof(dp));\\n        int res = 0;\\n        mp[arr[0]] = 0;\\n        mp[arr[1]] = 1;\\n        for (int pos = 2; pos < size; pos++) {\\n            mp[arr[pos]] = pos;\\n            for (int i = pos - 1; i > 0; i--) {\\n                int preVal = arr[pos] - arr[i];\\n                // the last 3 numbers in the f. subseq. should be {preVal, arr[i], arr[pos]}\\n                // not {arr[i], preVal, arr[pos]}\\n                if (preVal >= arr[i])\\n                    break;\\n                // if the subseq. {..., preVal, arr[i]} was found\\n                if (mp.find(preVal) != mp.end()) {\\n                    // extend the length by 1 and the tail is {..., arr[i], arr[pos]} now;\\n                    dp[i][pos] = dp[mp[preVal]][i] + 1;\\n                    res = max(res, dp[i][pos]);\\n                }\\n            }\\n        }\\n        // res + 2: We haven\\'t put the first two numbers in the result\\n        return res ? (res + 2) : 0;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Hash Table",
                    "Dynamic Programming"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int lenLongestFibSubseq(vector<int>& arr) {\\n        unordered_map<int, int> mp; // mp[Value] = position\\n        int size = arr.size();\\n        // dp[a][b]: the longest length of the fibonacci subsequence ends with {arr[a], arr[b]}\\n        int dp[size][size];\\n        memset(dp, 0, sizeof(dp));\\n        int res = 0;\\n        mp[arr[0]] = 0;\\n        mp[arr[1]] = 1;\\n        for (int pos = 2; pos < size; pos++) {\\n            mp[arr[pos]] = pos;\\n            for (int i = pos - 1; i > 0; i--) {\\n                int preVal = arr[pos] - arr[i];\\n                // the last 3 numbers in the f. subseq. should be {preVal, arr[i], arr[pos]}\\n                // not {arr[i], preVal, arr[pos]}\\n                if (preVal >= arr[i])\\n                    break;\\n                // if the subseq. {..., preVal, arr[i]} was found\\n                if (mp.find(preVal) != mp.end()) {\\n                    // extend the length by 1 and the tail is {..., arr[i], arr[pos]} now;\\n                    dp[i][pos] = dp[mp[preVal]][i] + 1;\\n                    res = max(res, dp[i][pos]);\\n                }\\n            }\\n        }\\n        // res + 2: We haven\\'t put the first two numbers in the result\\n        return res ? (res + 2) : 0;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3821433,
                "title": "o-n-2-time-o-n-2-mem",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int lenLongestFibSubseq(vector<int>& arr) {\\n        vector<vector<int>> dp(arr.size(), vector<int>(arr.size(), 1));\\n        int ans = 0;\\n        map<int, int> hash;\\n        for (int i = 0; i < arr.size(); ++i) {\\n            hash[arr[i]] = i;\\n        }\\n        for (int i = 0; i < dp.size(); ++i) {\\n            for (int j = i + 1; j < dp.size(); ++j) {\\n                if (hash.find(arr[i] + arr[j]) != hash.end()) {\\n                    dp[j][hash[arr[i] + arr[j]]] = dp[i][j] + 1;\\n                    ans = max(ans, dp[j][hash[arr[i] + arr[j]]] + 1);\\n                }\\n            }\\n        }\\n        return ans >= 3 ? ans : 0;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int lenLongestFibSubseq(vector<int>& arr) {\\n        vector<vector<int>> dp(arr.size(), vector<int>(arr.size(), 1));\\n        int ans = 0;\\n        map<int, int> hash;\\n        for (int i = 0; i < arr.size(); ++i) {\\n            hash[arr[i]] = i;\\n        }\\n        for (int i = 0; i < dp.size(); ++i) {\\n            for (int j = i + 1; j < dp.size(); ++j) {\\n                if (hash.find(arr[i] + arr[j]) != hash.end()) {\\n                    dp[j][hash[arr[i] + arr[j]]] = dp[i][j] + 1;\\n                    ans = max(ans, dp[j][hash[arr[i] + arr[j]]] + 1);\\n                }\\n            }\\n        }\\n        return ans >= 3 ? ans : 0;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3763334,
                "title": "non-overlapping-cases-4-lines-of-recursion",
                "content": "\\n# Complexity\\n- Time complexity: Can\\'t Find, pls help\\n- Space complexity: O(n)\\n# Code\\n```\\nclass Solution {\\n    HashMap<Integer , Integer> map = new HashMap<>() ; \\n    public int lenLongestFibSubseq(int[] arr) {\\n        int n = arr.length ; \\n        int max = 0 ; \\n        for(int i=0 ; i<n ; i++) map.put(arr[i] , i) ; \\n        for(int i=0;i<n-2 ; i++){\\n            for(int j=i+1 ; j<n-1; j++){\\n                max = Math.max(max , f(i,j,arr)) ; \\n            }\\n        }\\n        if(max == 0) return max ; \\n        return 2+ max ; \\n    }\\n    private int f(int i, int j, int[] arr){\\n        int nxt = arr[i]+arr[j] ; \\n        int k = map.getOrDefault(nxt, -1) ; \\n        if(k==-1) return 0 ; \\n\\n        return 1 + f(j,k,arr) ; \\n\\n\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Recursion"
                ],
                "code": "```\\nclass Solution {\\n    HashMap<Integer , Integer> map = new HashMap<>() ; \\n    public int lenLongestFibSubseq(int[] arr) {\\n        int n = arr.length ; \\n        int max = 0 ; \\n        for(int i=0 ; i<n ; i++) map.put(arr[i] , i) ; \\n        for(int i=0;i<n-2 ; i++){\\n            for(int j=i+1 ; j<n-1; j++){\\n                max = Math.max(max , f(i,j,arr)) ; \\n            }\\n        }\\n        if(max == 0) return max ; \\n        return 2+ max ; \\n    }\\n    private int f(int i, int j, int[] arr){\\n        int nxt = arr[i]+arr[j] ; \\n        int k = map.getOrDefault(nxt, -1) ; \\n        if(k==-1) return 0 ; \\n\\n        return 1 + f(j,k,arr) ; \\n\\n\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3746284,
                "title": "simple-easy-solution-c-brute-force-with-explanation",
                "content": "# Explanation \\nwe simply check at each point if that could be the starting point of the longest fib like subsequence, however one might think it would lead to tle but no in the worst case my starting point could be 1 and next value could be 2 since it is given in the question the array is strictly increasing so the number of times the inner most loop will be max 30-40 so total time complexity of the code would be O(n*n*30) which will work fine.\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int lenLongestFibSubseq(vector<int>& arr) {\\n        int n = arr.size();\\n        int ans = 2; \\n\\n        unordered_map<int, int> mp; \\n\\n        for(int i = 0; i < n; i++) mp[arr[i]]++; \\n\\n        for(int i = 0; i < n; i++) {\\n            for(int j = i+1; j < n; j++) {\\n                int cnt = 2; \\n                int curr = arr[j];\\n                int prev = arr[i]; \\n                while(mp.find(curr+prev) != mp.end()) {\\n                    int temp = curr+prev; \\n                    prev = curr;\\n                    curr = temp; \\n                    cnt++;\\n                }\\n                ans = max(ans, cnt); \\n            }\\n        }\\n        return ans < 3 ? 0 : ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int lenLongestFibSubseq(vector<int>& arr) {\\n        int n = arr.size();\\n        int ans = 2; \\n\\n        unordered_map<int, int> mp; \\n\\n        for(int i = 0; i < n; i++) mp[arr[i]]++; \\n\\n        for(int i = 0; i < n; i++) {\\n            for(int j = i+1; j < n; j++) {\\n                int cnt = 2; \\n                int curr = arr[j];\\n                int prev = arr[i]; \\n                while(mp.find(curr+prev) != mp.end()) {\\n                    int temp = curr+prev; \\n                    prev = curr;\\n                    curr = temp; \\n                    cnt++;\\n                }\\n                ans = max(ans, cnt); \\n            }\\n        }\\n        return ans < 3 ? 0 : ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3688862,
                "title": "what-do-you-guys-think-about-this-solution",
                "content": "# Intuition\\nSequence is strictly increasing and x1+x2 is x3\\n\\n\\n# Approach\\n\\nx1+x2 is x3 so what if I map the sum of x1 and x2 to length of the current subsequence (initially it will be 2) at dp[i]\\n\\nI will traverse the array i = 1 to n-1\\nunder each ith iteration traverse from start of the array to i applying the logic of x1+x2 = x3\\n\\n# Complexity\\n- Time complexity:\\nO(n^2)\\n\\n- Space complexity:\\nO(n^2)\\n\\n# Code\\n```\\nclass Solution:\\n    def lenLongestFibSubseq(self, arr: List[int]) -> int:\\n        n = len(arr)\\n        dp = [{} for i in range(n)]\\n        maxLen = 0 \\n        for i in range(1,n):\\n            for j in range(i):\\n                nextRequired = arr[i]+arr[j]\\n                if(arr[i] in dp[j]):\\n                    dp[i][nextRequired] = dp[j][arr[i]]+1\\n                    maxLen = max(maxLen,dp[i][nextRequired])\\n                else:\\n                    dp[i][nextRequired] = 2 \\n        return maxLen\\n                \\n\\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def lenLongestFibSubseq(self, arr: List[int]) -> int:\\n        n = len(arr)\\n        dp = [{} for i in range(n)]\\n        maxLen = 0 \\n        for i in range(1,n):\\n            for j in range(i):\\n                nextRequired = arr[i]+arr[j]\\n                if(arr[i] in dp[j]):\\n                    dp[i][nextRequired] = dp[j][arr[i]]+1\\n                    maxLen = max(maxLen,dp[i][nextRequired])\\n                else:\\n                    dp[i][nextRequired] = 2 \\n        return maxLen\\n                \\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3659771,
                "title": "c-brute-force-to-bottom-up-dp-solution-clean-concise-code",
                "content": "> ***Actually the approach of the question is same as [1027. Longest Arithmetic Subsequence](https://leetcode.com/problems/longest-arithmetic-subsequence/)***\\n\\n# Approach 1: Brute Force approach\\n# Complexity\\n- Time complexity: $$O(n^3)$$\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: $$O(1)$$\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int lenLongestFibSubseq(vector<int>& v) {\\n        int n=v.size();\\n        int ans=0;\\n        for(int i=0;i<n;i++){\\n            for(int j=i+1;j<n;j++){\\n                int first=v[i],second=v[j];\\n                int len=2;\\n                for(int k=j+1;k<n;k++){\\n                    if(v[k]==first+second){\\n                        first=second;\\n                        second=v[k];\\n                        len++;\\n                    }\\n                }\\n                ans=max(ans,len);\\n            }\\n        }\\n        return ans<=2?0:ans;\\n    }\\n};\\n```\\n\\n# Approach 2: Dynamic Programming + hashmap\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity: $$O(n^2)$$\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: $$O(n^2)$$\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int lenLongestFibSubseq(vector<int>& v) {\\n        int n=v.size();\\n        vector<vector<int>>dp(n,vector<int>(n,0));\\n        unordered_map<int,int>mp;\\n        for(int i=0;i<n;i++){\\n            for(int j=i+1;j<n;j++){\\n                dp[i][j]=2;\\n                int third_last=v[j]-v[i];\\n                if(mp.count(third_last)){\\n                    dp[i][j]=max(dp[i][j],dp[mp[third_last]][i]+1);\\n                }\\n            }\\n            mp[v[i]]=i;\\n        }\\n        int ans=0;\\n        for(int i=0;i<n;i++){\\n            for(int j=0;j<n;j++){\\n                ans=max(ans,dp[i][j]);\\n            }\\n        }\\n        return ans<=2?0:ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int lenLongestFibSubseq(vector<int>& v) {\\n        int n=v.size();\\n        int ans=0;\\n        for(int i=0;i<n;i++){\\n            for(int j=i+1;j<n;j++){\\n                int first=v[i],second=v[j];\\n                int len=2;\\n                for(int k=j+1;k<n;k++){\\n                    if(v[k]==first+second){\\n                        first=second;\\n                        second=v[k];\\n                        len++;\\n                    }\\n                }\\n                ans=max(ans,len);\\n            }\\n        }\\n        return ans<=2?0:ans;\\n    }\\n};\\n```\n```\\nclass Solution {\\npublic:\\n    int lenLongestFibSubseq(vector<int>& v) {\\n        int n=v.size();\\n        vector<vector<int>>dp(n,vector<int>(n,0));\\n        unordered_map<int,int>mp;\\n        for(int i=0;i<n;i++){\\n            for(int j=i+1;j<n;j++){\\n                dp[i][j]=2;\\n                int third_last=v[j]-v[i];\\n                if(mp.count(third_last)){\\n                    dp[i][j]=max(dp[i][j],dp[mp[third_last]][i]+1);\\n                }\\n            }\\n            mp[v[i]]=i;\\n        }\\n        int ans=0;\\n        for(int i=0;i<n;i++){\\n            for(int j=0;j<n;j++){\\n                ans=max(ans,dp[i][j]);\\n            }\\n        }\\n        return ans<=2?0:ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3642111,
                "title": "cpp-solution",
                "content": "\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int lenLongestFibSubseq(vector<int>& arr) {\\n        map<int,int>mp;\\n        for(int i=0;i<arr.size();i++){\\n            mp[arr[i]]=i;\\n        }\\n        int ans=0;\\n        for(int i=0;i<arr.size();i++){\\n            for(int j=i+1;j<arr.size();j++){\\n                long long x=arr[i];\\n                long long y=arr[j];\\n                int count=2;\\n                while(mp.count(x+y)){\\n                    long long temp=x+y;\\n                    x=y;\\n                    y=temp;   \\n                    count++;\\n                }\\n                if(count!=2)ans=max(count,ans);\\n            }\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Ordered Map"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int lenLongestFibSubseq(vector<int>& arr) {\\n        map<int,int>mp;\\n        for(int i=0;i<arr.size();i++){\\n            mp[arr[i]]=i;\\n        }\\n        int ans=0;\\n        for(int i=0;i<arr.size();i++){\\n            for(int j=i+1;j<arr.size();j++){\\n                long long x=arr[i];\\n                long long y=arr[j];\\n                int count=2;\\n                while(mp.count(x+y)){\\n                    long long temp=x+y;\\n                    x=y;\\n                    y=temp;   \\n                    count++;\\n                }\\n                if(count!=2)ans=max(count,ans);\\n            }\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3636211,
                "title": "easy-dp-solution-tc-o-n-2-sc-o-n-2",
                "content": "```\\nclass Solution {\\npublic:\\n    int lenLongestFibSubseq(vector<int>& a) {\\n        int n = a.size();\\n        unordered_map<int, int> mp;\\n        for(int i=0; i<n; i++){\\n            mp[a[i]] = i;\\n        }\\n        int dp[n][n];\\n        int ans = 0;\\n        for(int i=n-1; i>=0; i--){\\n            for(int j=n-1; j>=i+1; j--){\\n                int x = a[i], y = a[j];\\n                if(mp.find(x+y) == mp.end()){\\n                    dp[i][j] = 2;\\n                }\\n                else{\\n                    dp[i][j] = 1 + dp[j][mp[x+y]];\\n                }\\n                if(dp[i][j] > 2) ans = max(ans, dp[i][j]);\\n            }\\n        }\\n        return ans;\\n    }\\n};",
                "solutionTags": [],
                "code": "class Solution {\\npublic:\\n    int lenLongestFibSubseq(vector<int>& a) {\\n        int n = a.size();\\n        unordered_map<int, int> mp;\\n        for(int i=0; i<n; i++){\\n            mp[a[i]] = i;\\n        }",
                "codeTag": "Java"
            },
            {
                "id": 3586207,
                "title": "c-easy-to-understand-lis-approach-self-explanatory-code",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n//dp[i][j] = length of longest fibonacci like subsequence when sequence 1st element is nums[i] and second is nums[j]\\ni.e. x1 = nums[i] && x2 = nums[j]\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\nsimple LIS like approach try problem\\nleetcode problem 1027. Longest Arithmetic Subsequence.\\n\\n\\n# Complexity\\n- Time complexity:\\nO(N*N)\\n\\n- Space complexity:\\n- O(N*N) for DP \\n- O(N) to store index in map\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int n;\\n    int lenLongestFibSubseq(vector<int>& nums) {\\n        n = nums.size();\\n        vector<vector<int>>dp(n+1, vector<int>(n+1));\\n        unordered_map<int,int>mp;\\n        int ans=0;\\n        for(int i=n-1;i>=0;i--){\\n\\n            for(int j = i+1;j<n;j++){\\n                long long int x3 = nums[i] + nums[j];\\n                if(mp.count(x3) && mp[x3]>j){\\n                    int ind = mp[x3];\\n                    dp[i][j] = max(dp[i][j], dp[j][ind]+1);\\n                }\\n                ans = max(ans, dp[i][j]);\\n            }\\n            mp[nums[i]]=i; // doesnt effect our calculation if previous index are lost in case of same value as nums[i] is repeated \\n        }\\n\\n        return (ans?ans+2:0);\\n\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int n;\\n    int lenLongestFibSubseq(vector<int>& nums) {\\n        n = nums.size();\\n        vector<vector<int>>dp(n+1, vector<int>(n+1));\\n        unordered_map<int,int>mp;\\n        int ans=0;\\n        for(int i=n-1;i>=0;i--){\\n\\n            for(int j = i+1;j<n;j++){\\n                long long int x3 = nums[i] + nums[j];\\n                if(mp.count(x3) && mp[x3]>j){\\n                    int ind = mp[x3];\\n                    dp[i][j] = max(dp[i][j], dp[j][ind]+1);\\n                }\\n                ans = max(ans, dp[i][j]);\\n            }\\n            mp[nums[i]]=i; // doesnt effect our calculation if previous index are lost in case of same value as nums[i] is repeated \\n        }\\n\\n        return (ans?ans+2:0);\\n\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3559736,
                "title": "python-dp-recursive",
                "content": "```\\nclass Solution:\\n    def lenLongestFibSubseq(self, arr: List[int]) -> int:\\n        \\n        n = len(arr)\\n        hashmap = {arr[i]:i for i in range(n)}\\n        \\n        memo = [[0]*n for _ in range(n)]\\n        \\n        def dp(i, j):\\n            if memo[i][j] != 0:\\n                return memo[i][j]\\n            if arr[i]+arr[j] in hashmap:\\n                memo[i][j] = max(1+dp(j, hashmap[arr[i]+arr[j]]), memo[i][j])\\n            return memo[i][j]\\n        \\n        ans = 0\\n        for i in range(n):\\n            for j in range(i+1, n):\\n                ans = max(ans, dp(i, j))\\n                \\n        return ans+2 if ans else 0\\n                \\n```",
                "solutionTags": [
                    "Python",
                    "Dynamic Programming"
                ],
                "code": "```\\nclass Solution:\\n    def lenLongestFibSubseq(self, arr: List[int]) -> int:\\n        \\n        n = len(arr)\\n        hashmap = {arr[i]:i for i in range(n)}\\n        \\n        memo = [[0]*n for _ in range(n)]\\n        \\n        def dp(i, j):\\n            if memo[i][j] != 0:\\n                return memo[i][j]\\n            if arr[i]+arr[j] in hashmap:\\n                memo[i][j] = max(1+dp(j, hashmap[arr[i]+arr[j]]), memo[i][j])\\n            return memo[i][j]\\n        \\n        ans = 0\\n        for i in range(n):\\n            for j in range(i+1, n):\\n                ans = max(ans, dp(i, j))\\n                \\n        return ans+2 if ans else 0\\n                \\n```",
                "codeTag": "Java"
            },
            {
                "id": 3551831,
                "title": "c-easy-understandable-binary-search",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complex -->o(n2logn)\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int lenLongestFibSubseq(vector<int>& nums) {\\n        unordered_map<int,unordered_map<int,int>>m;\\n        int ans=0;\\n        int n=nums.size();\\n        for(int i=0;i<n;i++)\\n        {\\n            for(int j=0;j<i;j++)\\n            {\\n                int count=2;\\n                int x=j;\\n                int prev=nums[j];\\n                int cur=nums[i]-nums[j];\\n                while(binary_search(nums.begin(),nums.begin()+x,cur))\\n                { \\n                       x=lower_bound(nums.begin(),nums.begin()+x,cur)-nums.begin();\\n                    count++;\\n                  //  cout<<cur<<\" \";\\n                    int tem=cur;\\n                    cur=prev-cur;\\n                    prev=tem;\\n\\n                }\\n                ans=max(ans,count);\\n                //cout<<endl;\\n            }\\n        }\\n       return ans<3?0:ans;\\n        \\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int lenLongestFibSubseq(vector<int>& nums) {\\n        unordered_map<int,unordered_map<int,int>>m;\\n        int ans=0;\\n        int n=nums.size();\\n        for(int i=0;i<n;i++)\\n        {\\n            for(int j=0;j<i;j++)\\n            {\\n                int count=2;\\n                int x=j;\\n                int prev=nums[j];\\n                int cur=nums[i]-nums[j];\\n                while(binary_search(nums.begin(),nums.begin()+x,cur))\\n                { \\n                       x=lower_bound(nums.begin(),nums.begin()+x,cur)-nums.begin();\\n                    count++;\\n                  //  cout<<cur<<\" \";\\n                    int tem=cur;\\n                    cur=prev-cur;\\n                    prev=tem;\\n\\n                }\\n                ans=max(ans,count);\\n                //cout<<endl;\\n            }\\n        }\\n       return ans<3?0:ans;\\n        \\n    }\\n};\\n```",
                "codeTag": "C++"
            },
            {
                "id": 3544838,
                "title": "c-recursion-memoization-dp",
                "content": "When we are able to find a pair of integers whose sum gives us an alement in our map, then we go further looking for other element sin the same seires beign followed..\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int dp[1001][1001];\\n    int ans(vector<int>&arr,unordered_map<int,int>&mp,int i,int j){\\n        if(mp.find(arr[i]+arr[j])==mp.end()){\\n            return 0;\\n        }\\n        if(dp[i][j]!=-1)return dp[i][j];\\n        return dp[i][j]=1+ans(arr,mp,j,mp[arr[i]+arr[j]]);\\n    }\\n    int lenLongestFibSubseq(vector<int>& arr) {\\n        int n=arr.size();\\n        unordered_map<int,int> mp;\\n        for(int i=0;i<n;i++){\\n            mp[arr[i]]=i;\\n        }\\n        int MAX=0;\\n        memset(dp,-1,sizeof(dp));\\n        for(int i=0;i<n-2;i++){\\n            for(int j=i+1;j<n-1;j++){\\n                if(mp.find(arr[i]+arr[j])==mp.end())\\n                    continue;\\n                MAX=max(MAX,ans(arr,mp,i,j)+2);\\n            }\\n        }\\n        return MAX;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int dp[1001][1001];\\n    int ans(vector<int>&arr,unordered_map<int,int>&mp,int i,int j){\\n        if(mp.find(arr[i]+arr[j])==mp.end()){\\n            return 0;\\n        }\\n        if(dp[i][j]!=-1)return dp[i][j];\\n        return dp[i][j]=1+ans(arr,mp,j,mp[arr[i]+arr[j]]);\\n    }\\n    int lenLongestFibSubseq(vector<int>& arr) {\\n        int n=arr.size();\\n        unordered_map<int,int> mp;\\n        for(int i=0;i<n;i++){\\n            mp[arr[i]]=i;\\n        }\\n        int MAX=0;\\n        memset(dp,-1,sizeof(dp));\\n        for(int i=0;i<n-2;i++){\\n            for(int j=i+1;j<n-1;j++){\\n                if(mp.find(arr[i]+arr[j])==mp.end())\\n                    continue;\\n                MAX=max(MAX,ans(arr,mp,i,j)+2);\\n            }\\n        }\\n        return MAX;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3531892,
                "title": "java-simple",
                "content": "\\n\\n# Code\\n```\\nclass Solution {\\n    public int lenLongestFibSubseq(int[] arr) {\\n        //dp[i][j] = dp[j][index of (Ni+Nj)] + 1 \\n        int n= arr.length , max= 0;\\n        Map<Integer,Integer> map = new HashMap();\\n        for (int i=0;i<arr.length;i++) map.put(arr[i],i);\\n        int dp[][] = new int[n][n];\\n        for (int i=n-1;i>=1;i--){\\n            for (int j=i-1;j>=0;j--){\\n                dp[j][i] = 2;\\n                if (map.containsKey(arr[i]+arr[j])){\\n                    dp[j][i] = 1 + dp[i][map.get(arr[i]+arr[j])];\\n                } \\n                max = Math.max (max, dp[j][i]);\\n            }\\n        }\\n        return (max<3)?0:max;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int lenLongestFibSubseq(int[] arr) {\\n        //dp[i][j] = dp[j][index of (Ni+Nj)] + 1 \\n        int n= arr.length , max= 0;\\n        Map<Integer,Integer> map = new HashMap();\\n        for (int i=0;i<arr.length;i++) map.put(arr[i],i);\\n        int dp[][] = new int[n][n];\\n        for (int i=n-1;i>=1;i--){\\n            for (int j=i-1;j>=0;j--){\\n                dp[j][i] = 2;\\n                if (map.containsKey(arr[i]+arr[j])){\\n                    dp[j][i] = 1 + dp[i][map.get(arr[i]+arr[j])];\\n                } \\n                max = Math.max (max, dp[j][i]);\\n            }\\n        }\\n        return (max<3)?0:max;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3469079,
                "title": "recursive-memoization-dictionary-hashmap",
                "content": "# Code\\n```\\nclass Solution {\\n    func lenLongestFibSubseq(_ arr: [Int]) -> Int {\\n        var memo: [[Int]] = Array(\\n            repeating: Array(repeating: -1, count: arr.count + 1),\\n            count: arr.count + 1\\n        )\\n\\n        var map: [Int: Int] = [:]\\n        for i in stride(from: 0, to: arr.count, by: 1) {\\n            map[arr[i]] = i\\n        }\\n\\n        func solve(_ index: Int, _ prev: Int) -> Int {\\n            if memo[index][prev] != -1 {\\n                return memo[index][prev]\\n            }\\n\\n            guard let nextIndex = map[arr[index] + arr[prev]] else {\\n                memo[index][prev] = 0\\n                return 0\\n            }\\n\\n            memo[index][prev] = solve(nextIndex, index) + 1\\n\\n            return memo[index][prev]\\n        }\\n\\n        var res = 0\\n        for i in stride(from: 0, to: arr.count - 2, by: 1) {\\n            for j in stride(from: i + 1, to: arr.count - 1, by: 1) {\\n                var tmp = solve(j, i)\\n                if tmp > 0 { tmp += 2 }\\n\\n                res = max(res, tmp)\\n            }\\n        }\\n\\n        return res\\n    }\\n}\\n```",
                "solutionTags": [
                    "Swift",
                    "Memoization"
                ],
                "code": "```\\nclass Solution {\\n    func lenLongestFibSubseq(_ arr: [Int]) -> Int {\\n        var memo: [[Int]] = Array(\\n            repeating: Array(repeating: -1, count: arr.count + 1),\\n            count: arr.count + 1\\n        )\\n\\n        var map: [Int: Int] = [:]\\n        for i in stride(from: 0, to: arr.count, by: 1) {\\n            map[arr[i]] = i\\n        }\\n\\n        func solve(_ index: Int, _ prev: Int) -> Int {\\n            if memo[index][prev] != -1 {\\n                return memo[index][prev]\\n            }\\n\\n            guard let nextIndex = map[arr[index] + arr[prev]] else {\\n                memo[index][prev] = 0\\n                return 0\\n            }\\n\\n            memo[index][prev] = solve(nextIndex, index) + 1\\n\\n            return memo[index][prev]\\n        }\\n\\n        var res = 0\\n        for i in stride(from: 0, to: arr.count - 2, by: 1) {\\n            for j in stride(from: i + 1, to: arr.count - 1, by: 1) {\\n                var tmp = solve(j, i)\\n                if tmp > 0 { tmp += 2 }\\n\\n                res = max(res, tmp)\\n            }\\n        }\\n\\n        return res\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3423906,
                "title": "length-of-longest-fibonacci-subsequence",
                "content": "------------------ Easy C++ Solution ------------------\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int lenLongestFibSubseq(vector<int>& arr) {\\n         set<int> s;\\n        int max_length=2;\\n        for(int i=0;i<arr.size();i++){\\n            s.insert(arr[i]);\\n        }\\n        \\n        for(int i=0;i<arr.size()-1;i++){\\n            for(int j=i+1;j<arr.size();j++){\\n                int length=2,x,y,z;\\n                x=arr[i];\\n                y=arr[j];\\n                z=arr[i]+arr[j];\\n                while(s.find(z)!=s.end()){\\n                    length++;\\n                    x=y;\\n                    y=z;\\n                    z=x+y;\\n                }\\n                if(length>max_length){\\n                    max_length=length;\\n                }\\n            }\\n        }\\n        if(max_length>2){\\n        return max_length;\\n        }else{\\n            return 0;\\n        }\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int lenLongestFibSubseq(vector<int>& arr) {\\n         set<int> s;\\n        int max_length=2;\\n        for(int i=0;i<arr.size();i++){\\n            s.insert(arr[i]);\\n        }\\n        \\n        for(int i=0;i<arr.size()-1;i++){\\n            for(int j=i+1;j<arr.size();j++){\\n                int length=2,x,y,z;\\n                x=arr[i];\\n                y=arr[j];\\n                z=arr[i]+arr[j];\\n                while(s.find(z)!=s.end()){\\n                    length++;\\n                    x=y;\\n                    y=z;\\n                    z=x+y;\\n                }\\n                if(length>max_length){\\n                    max_length=length;\\n                }\\n            }\\n        }\\n        if(max_length>2){\\n        return max_length;\\n        }else{\\n            return 0;\\n        }\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3408381,
                "title": "rust-solution",
                "content": "\\n\\n# Code\\n```\\nuse std::collections::*;\\n\\nimpl Solution {\\n  pub fn len_longest_fib_subseq(arr: Vec<i32>) -> i32 {\\n    let n = arr.len();\\n    let mut result = 0;\\n    let mut set = HashSet::new();\\n    for i in 0..n {\\n      set.insert(arr[i]);\\n    }\\n\\n    for i in 0..n {\\n      let bv1 = arr[i];\\n      for j in i+1..n {\\n        let mut v1 = bv1;\\n        let mut v2 = arr[j];\\n        let mut count = 0;\\n        while set.contains(&(v1+v2)) {\\n          count += 1;\\n          let nv = v1+v2;\\n          v1 = v2;\\n          v2 = nv;\\n        }\\n        \\n        if 0 < count {\\n          result = result.max(count+2);\\n        }\\n      }\\n    }\\n    result     \\n  }\\n}\\n```",
                "solutionTags": [
                    "Rust"
                ],
                "code": "```\\nuse std::collections::*;\\n\\nimpl Solution {\\n  pub fn len_longest_fib_subseq(arr: Vec<i32>) -> i32 {\\n    let n = arr.len();\\n    let mut result = 0;\\n    let mut set = HashSet::new();\\n    for i in 0..n {\\n      set.insert(arr[i]);\\n    }\\n\\n    for i in 0..n {\\n      let bv1 = arr[i];\\n      for j in i+1..n {\\n        let mut v1 = bv1;\\n        let mut v2 = arr[j];\\n        let mut count = 0;\\n        while set.contains(&(v1+v2)) {\\n          count += 1;\\n          let nv = v1+v2;\\n          v1 = v2;\\n          v2 = nv;\\n        }\\n        \\n        if 0 < count {\\n          result = result.max(count+2);\\n        }\\n      }\\n    }\\n    result     \\n  }\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3408234,
                "title": "simple-c-solution-using-binary-search",
                "content": "# Code\\n```\\nclass Solution {\\npublic:\\n    int lenLongestFibSubseq(vector<int>& arr) {\\n        int n = arr.size();\\n        int maxx = 0;\\n\\n        for(int i=0 ; i<n ; i++){\\n            for(int j=i+1; j<n ; j++){\\n                int a = arr[i];\\n                int b = arr[j];\\n                int ct = 2;\\n                int val;\\n                while(lower_bound(arr.begin() , arr.end() , a+b)!=arr.end()){\\n                    if((*lower_bound(arr.begin() , arr.end() , a+b))!=a+b)break;\\n                    else val = *lower_bound(arr.begin() , arr.end() , a+b);\\n                    a = b;\\n                    b = val;\\n                    ct++;\\n                }\\n                maxx = ct >2 ?  max(maxx , ct) : maxx;\\n            }\\n        }\\n\\n\\n        return maxx;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Array",
                    "Binary Search"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int lenLongestFibSubseq(vector<int>& arr) {\\n        int n = arr.size();\\n        int maxx = 0;\\n\\n        for(int i=0 ; i<n ; i++){\\n            for(int j=i+1; j<n ; j++){\\n                int a = arr[i];\\n                int b = arr[j];\\n                int ct = 2;\\n                int val;\\n                while(lower_bound(arr.begin() , arr.end() , a+b)!=arr.end()){\\n                    if((*lower_bound(arr.begin() , arr.end() , a+b))!=a+b)break;\\n                    else val = *lower_bound(arr.begin() , arr.end() , a+b);\\n                    a = b;\\n                    b = val;\\n                    ct++;\\n                }\\n                maxx = ct >2 ?  max(maxx , ct) : maxx;\\n            }\\n        }\\n\\n\\n        return maxx;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3404165,
                "title": "beats-99-42-simple-2-sum-approach-c",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nFind all the two pairs, and then \\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\nFound all the two pair sums, and then iterate over them to find (i,j,k).\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\nO(n^2 log(n))\\n\\nWhen iterating over the the sum array the maximum length of the subsequence is log(n).\\n\\n- Space complexity:\\nO(n^2)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int lenLongestFibSubseq(vector<int>& arr) {\\n        int n = arr.size();\\n        map<pair<int,int>,int>indexes;\\n\\n        for(int i = 2 ;i < n;i++) {\\n            int start = 0;\\n            int end = i-1;\\n            long long reqSum = arr[i];\\n            long long sum;\\n            while(start != end) {\\n                sum = arr[start] + (long long)arr[end];\\n                if(sum == reqSum) {\\n                    indexes[{start,end}] = i;\\n                    // cout<<start<<\" \"<<end<<\" \"<<i<<endl;\\n                    start++;\\n                }\\n                else if(sum < reqSum) start++;\\n                else end--;\\n            }\\n        }\\n        int count = 0;\\n        int maxCount = 0;\\n        for(auto &it : indexes) {\\n            count = 2;\\n            int i=it.first.first,j=it.first.second,k=it.second;\\n            while((long long)arr[i]+arr[j] == (long long)arr[k]) {\\n                count++;\\n                i = j;\\n                j = k;\\n                k = indexes[{i,j}];\\n            }\\n            if(count > maxCount)maxCount = count;\\n        }\\n        return maxCount;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int lenLongestFibSubseq(vector<int>& arr) {\\n        int n = arr.size();\\n        map<pair<int,int>,int>indexes;\\n\\n        for(int i = 2 ;i < n;i++) {\\n            int start = 0;\\n            int end = i-1;\\n            long long reqSum = arr[i];\\n            long long sum;\\n            while(start != end) {\\n                sum = arr[start] + (long long)arr[end];\\n                if(sum == reqSum) {\\n                    indexes[{start,end}] = i;\\n                    // cout<<start<<\" \"<<end<<\" \"<<i<<endl;\\n                    start++;\\n                }\\n                else if(sum < reqSum) start++;\\n                else end--;\\n            }\\n        }\\n        int count = 0;\\n        int maxCount = 0;\\n        for(auto &it : indexes) {\\n            count = 2;\\n            int i=it.first.first,j=it.first.second,k=it.second;\\n            while((long long)arr[i]+arr[j] == (long long)arr[k]) {\\n                count++;\\n                i = j;\\n                j = k;\\n                k = indexes[{i,j}];\\n            }\\n            if(count > maxCount)maxCount = count;\\n        }\\n        return maxCount;\\n    }\\n};\\n```",
                "codeTag": "C++"
            },
            {
                "id": 3383018,
                "title": "beats-89-dp-iterative-c",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n**$$dp[i][j] = $$** len of longest fibb. subseq. with last two elements arr[i], arr[j]\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n\\n    // It Works: taking dp[i][j] as length of longest fibb. subseq. with last two elements arr[j] and arr[i] and we look for next element in the subseq.\\n    // int lenLongestFibSubseq(vector<int>& arr)\\n    // {\\n    //     int n = arr.size();\\n    //     vector<vector<int>>dp(n, vector<int>(n, 2));\\n    //     unordered_map<int, int>mp;\\n    //     for(int i = 0; i<n; i++)mp[arr[i]] = i;\\n    //     int ans = 0;\\n    //     for(int i = 0; i<n; i++)\\n    //     {\\n    //         for(int j = i+1; j<n; j++)\\n    //         {\\n    //             int next = arr[i] + arr[j];\\n    //             if(mp.find(next) != mp.end())\\n    //             {\\n    //                 dp[j][mp[next]] = max(dp[j][mp[next]], dp[i][j]+1);\\n    //             }\\n    //             ans = max(ans, dp[i][j]);\\n    //         }\\n    //     }\\n    //     return ans==2?0:ans;\\n    // }\\n\\n\\n // It Works: taking dp[i][j] as length of longest fibb. subseq. with last two elements arr[j] and arr[i] and we look for previous elements in the subseq.\\n    int lenLongestFibSubseq(vector<int>& arr)\\n    {\\n        int n = arr.size();\\n        vector<vector<int>>dp(n, vector<int>(n, 2));\\n        unordered_map<int, int>mp;\\n        for(int i = 0; i<n; i++)mp[arr[i]] = i;\\n        \\n        int ans = 0;\\n\\n        for(int i = 2; i<n; i++)\\n        {\\n            for(int j = i-1; j>=1; j--)\\n            {\\n                int pprev = arr[i] - arr[j];//trying to get a number before arr[j] assuming arr[j] and arr[i] are the last two elements. so in that case pprev should be less than arr[j]\\n                if(pprev>=arr[j])continue;\\n                if(mp.find(pprev) != mp.end())\\n                {\\n                    dp[j][i] = max(dp[j][i], dp[mp[pprev]][j]+1);\\n                }\\n                ans = max(ans, dp[j][i]);\\n            }\\n        }\\n        return ans==2?0:ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n\\n    // It Works: taking dp[i][j] as length of longest fibb. subseq. with last two elements arr[j] and arr[i] and we look for next element in the subseq.\\n    // int lenLongestFibSubseq(vector<int>& arr)\\n    // {\\n    //     int n = arr.size();\\n    //     vector<vector<int>>dp(n, vector<int>(n, 2));\\n    //     unordered_map<int, int>mp;\\n    //     for(int i = 0; i<n; i++)mp[arr[i]] = i;\\n    //     int ans = 0;\\n    //     for(int i = 0; i<n; i++)\\n    //     {\\n    //         for(int j = i+1; j<n; j++)\\n    //         {\\n    //             int next = arr[i] + arr[j];\\n    //             if(mp.find(next) != mp.end())\\n    //             {\\n    //                 dp[j][mp[next]] = max(dp[j][mp[next]], dp[i][j]+1);\\n    //             }\\n    //             ans = max(ans, dp[i][j]);\\n    //         }\\n    //     }\\n    //     return ans==2?0:ans;\\n    // }\\n\\n\\n // It Works: taking dp[i][j] as length of longest fibb. subseq. with last two elements arr[j] and arr[i] and we look for previous elements in the subseq.\\n    int lenLongestFibSubseq(vector<int>& arr)\\n    {\\n        int n = arr.size();\\n        vector<vector<int>>dp(n, vector<int>(n, 2));\\n        unordered_map<int, int>mp;\\n        for(int i = 0; i<n; i++)mp[arr[i]] = i;\\n        \\n        int ans = 0;\\n\\n        for(int i = 2; i<n; i++)\\n        {\\n            for(int j = i-1; j>=1; j--)\\n            {\\n                int pprev = arr[i] - arr[j];//trying to get a number before arr[j] assuming arr[j] and arr[i] are the last two elements. so in that case pprev should be less than arr[j]\\n                if(pprev>=arr[j])continue;\\n                if(mp.find(pprev) != mp.end())\\n                {\\n                    dp[j][i] = max(dp[j][i], dp[mp[pprev]][j]+1);\\n                }\\n                ans = max(ans, dp[j][i]);\\n            }\\n        }\\n        return ans==2?0:ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3373210,
                "title": "c-o-n-3-o-n-2",
                "content": "```\\n// TLE : O(N^3)\\nclass Solution {\\npublic:\\n    int lenLongestFibSubseq(vector<int>& nums) {\\n        int n=nums.size();\\n        int len=0;\\n        vector<vector<int>> dp(n+1,vector<int>(n+1,0));\\n        for(int i=0;i<n;i++){\\n            for(int j=0;j<n;j++){\\n                dp[i][j]=2;\\n            }\\n        }\\n        for(int j=0;j<n;j++){\\n            for(int i=0;i<j;i++){\\n                for(int k=0;k<i;k++){\\n                    if(nums[i]+nums[k]==nums[j]){\\n                        dp[i][j]=max(dp[i][j],1+dp[k][i]);\\n                        len=max(len,dp[i][j]);\\n                    }\\n                }\\n            }\\n        }\\n        \\n        \\n        return len;\\n    }\\n};\\n/* AC: Using map to eleminate the inside loop for searching nums[k]\\nas nums[k]+nums[i]=nums[j]\\n=> nums[k]=nums[j]-nums[i]= diff\\nso if we can find an element equals to diff that have index <i we can add that to our dp\\nhere we use map to find diff in o(1) time\\n*/\\nclass Solution {\\npublic:\\n    int lenLongestFibSubseq(vector<int>& nums) {\\n        int n=nums.size();\\n        int len=0;\\n        unordered_map<int,int> mp;\\n        for(int i=0;i<n;i++){\\n            mp[nums[i]]=i;\\n        }\\n        vector<vector<int>> dp(n+1,vector<int>(n+1,0));\\n        for(int i=0;i<n;i++){\\n            for(int j=0;j<n;j++){\\n                dp[i][j]=2;\\n            }\\n        }\\n        for(int j=0;j<n;j++){\\n            for(int i=0;i<j;i++){\\n                int d=nums[j]-nums[i];\\n                if(mp.find(d)!=mp.end() && mp[d]<i){\\n                    int k=mp[d];\\n                    dp[i][j]=max(dp[i][j],1+dp[k][i]);\\n                    len=max(len,dp[i][j]);\\n                }\\n            }\\n        }\\n        \\n        \\n        return len;\\n    }\\n};\\n```",
                "solutionTags": [
                    "Dynamic Programming"
                ],
                "code": "```\\n// TLE : O(N^3)\\nclass Solution {\\npublic:\\n    int lenLongestFibSubseq(vector<int>& nums) {\\n        int n=nums.size();\\n        int len=0;\\n        vector<vector<int>> dp(n+1,vector<int>(n+1,0));\\n        for(int i=0;i<n;i++){\\n            for(int j=0;j<n;j++){\\n                dp[i][j]=2;\\n            }\\n        }\\n        for(int j=0;j<n;j++){\\n            for(int i=0;i<j;i++){\\n                for(int k=0;k<i;k++){\\n                    if(nums[i]+nums[k]==nums[j]){\\n                        dp[i][j]=max(dp[i][j],1+dp[k][i]);\\n                        len=max(len,dp[i][j]);\\n                    }\\n                }\\n            }\\n        }\\n        \\n        \\n        return len;\\n    }\\n};\\n/* AC: Using map to eleminate the inside loop for searching nums[k]\\nas nums[k]+nums[i]=nums[j]\\n=> nums[k]=nums[j]-nums[i]= diff\\nso if we can find an element equals to diff that have index <i we can add that to our dp\\nhere we use map to find diff in o(1) time\\n*/\\nclass Solution {\\npublic:\\n    int lenLongestFibSubseq(vector<int>& nums) {\\n        int n=nums.size();\\n        int len=0;\\n        unordered_map<int,int> mp;\\n        for(int i=0;i<n;i++){\\n            mp[nums[i]]=i;\\n        }\\n        vector<vector<int>> dp(n+1,vector<int>(n+1,0));\\n        for(int i=0;i<n;i++){\\n            for(int j=0;j<n;j++){\\n                dp[i][j]=2;\\n            }\\n        }\\n        for(int j=0;j<n;j++){\\n            for(int i=0;i<j;i++){\\n                int d=nums[j]-nums[i];\\n                if(mp.find(d)!=mp.end() && mp[d]<i){\\n                    int k=mp[d];\\n                    dp[i][j]=max(dp[i][j],1+dp[k][i]);\\n                    len=max(len,dp[i][j]);\\n                }\\n            }\\n        }\\n        \\n        \\n        return len;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3350657,
                "title": "c",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n  int f(int curr,int prev,vector<int>& nums,int n){\\n\\t\\t\\tint t=nums[curr]+nums[prev];\\n\\t\\t\\tint i=lower_bound(nums.begin(),nums.end(),t)-nums.begin();\\n\\t\\t\\tif(i<n && nums[i]==t) return 1+f(i,curr,nums,n);\\n\\t\\t\\treturn 1;\\n\\t\\t}\\n\\n\\t\\tint lenLongestFibSubseq(vector<int>& nums) {\\n\\t\\t\\tint n=nums.size();\\n\\t\\t\\tint maxi=0;\\n\\t\\t\\tfor(int prev2=0;prev2<n;prev2++){\\n\\t\\t\\t\\tfor(int prev1=prev2+1;prev1<n;prev1++){\\n\\t\\t\\t\\t\\tint temp=nums[prev1]+nums[prev2];\\n\\t\\t\\t\\t\\tint ind=lower_bound(nums.begin(),nums.end(),temp)-nums.begin();\\n\\t\\t\\t\\t\\tif(ind<n && nums[ind]==temp) maxi=max(maxi,2+f(ind,prev1,nums,n));\\n\\t\\t\\t\\t}\\n\\t\\t\\t}\\n\\t\\t\\treturn maxi;\\n\\t\\t}\\n\\t};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n  int f(int curr,int prev,vector<int>& nums,int n){\\n\\t\\t\\tint t=nums[curr]+nums[prev];\\n\\t\\t\\tint i=lower_bound(nums.begin(),nums.end(),t)-nums.begin();\\n\\t\\t\\tif(i<n && nums[i]==t) return 1+f(i,curr,nums,n);\\n\\t\\t\\treturn 1;\\n\\t\\t}\\n\\n\\t\\tint lenLongestFibSubseq(vector<int>& nums) {\\n\\t\\t\\tint n=nums.size();\\n\\t\\t\\tint maxi=0;\\n\\t\\t\\tfor(int prev2=0;prev2<n;prev2++){\\n\\t\\t\\t\\tfor(int prev1=prev2+1;prev1<n;prev1++){\\n\\t\\t\\t\\t\\tint temp=nums[prev1]+nums[prev2];\\n\\t\\t\\t\\t\\tint ind=lower_bound(nums.begin(),nums.end(),temp)-nums.begin();\\n\\t\\t\\t\\t\\tif(ind<n && nums[ind]==temp) maxi=max(maxi,2+f(ind,prev1,nums,n));\\n\\t\\t\\t\\t}\\n\\t\\t\\t}\\n\\t\\t\\treturn maxi;\\n\\t\\t}\\n\\t};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3339344,
                "title": "jebz-solution",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\n    public int lenLongestFibSubseq(int[] arr) {\\n        HashSet<Integer> set =new HashSet<Integer>();\\n        int l=arr.length;\\n        for(int i=0;i<l;i++)\\n        {\\n            set.add(arr[i]);\\n        }\\n        int c=0,max=0;\\n        for(int i=0;i<l;i++)\\n        {\\n            for(int j=i+1;j<l;j++)\\n            {\\n                int a=arr[i];\\n                int b=arr[j];\\n               int  sum=arr[i]+arr[j];\\n                if(set.contains(sum))\\n                  c=c+2;\\n\\n                while(set.contains(sum))\\n                {\\n                    c++;\\n                    a=b;\\n                    b=sum;\\n                    sum=a+b;\\n                }\\n                max=Math.max(c,max);\\n                c=0;\\n            }\\n        }\\n        return max;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int lenLongestFibSubseq(int[] arr) {\\n        HashSet<Integer> set =new HashSet<Integer>();\\n        int l=arr.length;\\n        for(int i=0;i<l;i++)\\n        {\\n            set.add(arr[i]);\\n        }\\n        int c=0,max=0;\\n        for(int i=0;i<l;i++)\\n        {\\n            for(int j=i+1;j<l;j++)\\n            {\\n                int a=arr[i];\\n                int b=arr[j];\\n               int  sum=arr[i]+arr[j];\\n                if(set.contains(sum))\\n                  c=c+2;\\n\\n                while(set.contains(sum))\\n                {\\n                    c++;\\n                    a=b;\\n                    b=sum;\\n                    sum=a+b;\\n                }\\n                max=Math.max(c,max);\\n                c=0;\\n            }\\n        }\\n        return max;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3316924,
                "title": "legth-of-lonest-fibonacci-python",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution:\\n    def lenLongestFibSubseq(self, arr: List[int]) -> int:\\n        seti=set(arr)\\n        def rec(val,last):\\n            if val not in seti:\\n                return 0\\n            return 1+rec(val+last,val)   \\n        arr.sort()    \\n        maxi=0\\n        n=len(arr)  \\n        for i in range(n):\\n            for j in range(i+1,n):\\n                maxi=max(maxi,2+rec(arr[i]+arr[j],arr[j]))\\n        if maxi>2:\\n            return maxi\\n        return 0              \\n\\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def lenLongestFibSubseq(self, arr: List[int]) -> int:\\n        seti=set(arr)\\n        def rec(val,last):\\n            if val not in seti:\\n                return 0\\n            return 1+rec(val+last,val)   \\n        arr.sort()    \\n        maxi=0\\n        n=len(arr)  \\n        for i in range(n):\\n            for j in range(i+1,n):\\n                maxi=max(maxi,2+rec(arr[i]+arr[j],arr[j]))\\n        if maxi>2:\\n            return maxi\\n        return 0              \\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3301302,
                "title": "c-easy-solution-using-set-with-explanation",
                "content": "# EXPLANATION\\nWe created a set to store all integres in **\"s\"**.\\nOn this question we made an observation that:-\\nWe only need 2 numbers to find the solution.\\nWe took **\"i\"** pointer and **\"j\"** pointer to traverse through vector.\\nWe checked if sum of **\"i\"** and **\"j\"** pointer is present in vector or not, then updated **a** and **b** and then checked the presence of **a+b** and simultaneously updated the count too.\\nAt every combinations we stored the maximum count in **\"ans\"** and finally returned the answer.\\nTo reduce time complexity we made two terminating conditions:-\\n1. If sum is greater than last interger of vector.\\n2. If the numbers of integers present after the **\"j\"** position  is less than **\"ans\"**.\\n# SOLUTION\\n```\\nclass Solution {\\npublic:\\n    int lenLongestFibSubseq(vector<int>& arr) {\\n        set<int> s;\\n        int ans=0,n=arr.size();\\n        for(auto x:arr)  \\n            s.insert(x);\\n        for(int i=0;i<n-2;i++){\\n            for(int j=i+1;j<n-1;j++){\\n                int a=arr[i],b=arr[j],c=a+b,cnt=2;\\n                while(s.find(c)!=s.end()){\\n                    a=b,b=c,c=a+b;\\n                    cnt++;\\n                    ans=max(ans,cnt);\\n                }\\n                if(c>arr[n-1] || (n-j+1)<=ans)\\n                    break;\\n            }\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Array",
                    "Hash Table",
                    "Dynamic Programming"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int lenLongestFibSubseq(vector<int>& arr) {\\n        set<int> s;\\n        int ans=0,n=arr.size();\\n        for(auto x:arr)  \\n            s.insert(x);\\n        for(int i=0;i<n-2;i++){\\n            for(int j=i+1;j<n-1;j++){\\n                int a=arr[i],b=arr[j],c=a+b,cnt=2;\\n                while(s.find(c)!=s.end()){\\n                    a=b,b=c,c=a+b;\\n                    cnt++;\\n                    ans=max(ans,cnt);\\n                }\\n                if(c>arr[n-1] || (n-j+1)<=ans)\\n                    break;\\n            }\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3288897,
                "title": "non-dp",
                "content": "```ruby\\ndef len_longest_fib_subseq a\\n    r, s = 2, a.to_set\\n    for i in 0..(z = a.size) - 2\\n        x = a[i]\\n        for j in i + 1...z\\n            c, d, l = (y = a[j]), x + y, 2\\n            c, d, l = d, c + d, l + 1 while s === d\\n            r = l if l > r\\n        end\\n    end\\n    r > 2 ? r : 0\\nend\\n```",
                "solutionTags": [
                    "Ruby"
                ],
                "code": "```ruby\\ndef len_longest_fib_subseq a\\n    r, s = 2, a.to_set\\n    for i in 0..(z = a.size) - 2\\n        x = a[i]\\n        for j in i + 1...z\\n            c, d, l = (y = a[j]), x + y, 2\\n            c, d, l = d, c + d, l + 1 while s === d\\n            r = l if l > r\\n        end\\n    end\\n    r > 2 ? r : 0\\nend\\n```",
                "codeTag": "Python3"
            },
            {
                "id": 3266444,
                "title": "using-dp-with-two-sum-with-two-pointers-time-o-n-2-and-space-o-n-2",
                "content": "# Code\\n```\\npublic class Solution {\\n    public int LenLongestFibSubseq(int[] arr) {\\n        int len = arr.Length;\\n        int[][] dp = new int[len][];\\n        for(int i = 0; i < len; i++) {\\n            dp[i] = new int[len];\\n        }\\n        int maxLen = 0;\\n        for(int i = 2; i < len; i++) {\\n            int l = 0, r = i - 1;\\n            while(l < r) {\\n                int sum = arr[l] + arr[r];\\n                if(sum > arr[i]) {\\n                    r--;\\n                } else if(sum < arr[i]) {\\n                    l++;\\n                } else {\\n                    dp[r][i] = dp[l][r] + 1;\\n                    maxLen = Math.Max(maxLen, dp[r][i]);\\n                    r--;\\n                    l++;\\n                }\\n            }\\n        }\\n\\n        return maxLen == 0 ? 0 : maxLen + 2;\\n    }\\n    \\n    public int LenLongestFibSubseqBF(int[] arr) {  //TLE\\n        HashSet<int> numset = new HashSet<int>(arr); \\n        int maxLen = 0;\\n        for(int i = 0; i < arr.Length; i++) {\\n            for(int j = i + 1; j < arr.Length; j++) {\\n                int curItem = arr[i], nextItem = arr[i] + arr[j];  \\n                int len = 2;  \\n                while(arr.Contains(nextItem)) {\\n                    len++;\\n                    curItem = nextItem - curItem;\\n                    nextItem = curItem + nextItem; \\n                } \\n                maxLen = Math.Max(maxLen, len);\\n            }\\n        }\\n    \\n        return maxLen == 2 ? 0 : maxLen;\\n    }\\n}\\n```",
                "solutionTags": [
                    "C#"
                ],
                "code": "```\\npublic class Solution {\\n    public int LenLongestFibSubseq(int[] arr) {\\n        int len = arr.Length;\\n        int[][] dp = new int[len][];\\n        for(int i = 0; i < len; i++) {\\n            dp[i] = new int[len];\\n        }\\n        int maxLen = 0;\\n        for(int i = 2; i < len; i++) {\\n            int l = 0, r = i - 1;\\n            while(l < r) {\\n                int sum = arr[l] + arr[r];\\n                if(sum > arr[i]) {\\n                    r--;\\n                } else if(sum < arr[i]) {\\n                    l++;\\n                } else {\\n                    dp[r][i] = dp[l][r] + 1;\\n                    maxLen = Math.Max(maxLen, dp[r][i]);\\n                    r--;\\n                    l++;\\n                }\\n            }\\n        }\\n\\n        return maxLen == 0 ? 0 : maxLen + 2;\\n    }\\n    \\n    public int LenLongestFibSubseqBF(int[] arr) {  //TLE\\n        HashSet<int> numset = new HashSet<int>(arr); \\n        int maxLen = 0;\\n        for(int i = 0; i < arr.Length; i++) {\\n            for(int j = i + 1; j < arr.Length; j++) {\\n                int curItem = arr[i], nextItem = arr[i] + arr[j];  \\n                int len = 2;  \\n                while(arr.Contains(nextItem)) {\\n                    len++;\\n                    curItem = nextItem - curItem;\\n                    nextItem = curItem + nextItem; \\n                } \\n                maxLen = Math.Max(maxLen, len);\\n            }\\n        }\\n    \\n        return maxLen == 2 ? 0 : maxLen;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3255674,
                "title": "fastest-solution",
                "content": "# Intuition\\nIterator\\n\\n# Approach\\nIterator\\n\\n# Complexity\\n- Time complexity: 500ms\\n\\n- Space complexity: 20mb\\n\\n# Code\\n```\\nclass Solution {\\n\\n    /**\\n     * @param Integer[] $arr\\n     * @return Integer\\n     */\\n    function lenLongestFibSubseq($arr) {\\n        $output = 0;\\n        $max = 0;\\n        $map = array_combine($arr, $arr);\\n\\n        foreach ($map as $val) {\\n            foreach ($map as $newVal) {\\n                if ($newVal <= $val) {\\n                    continue;\\n                }\\n\\n                $firstIndex = $val;\\n                $lastIndex = $newVal;\\n\\n                while (true) {\\n                    if (!array_key_exists($firstIndex + $lastIndex, $map)) {\\n                        if ($output > $max) {\\n                            $max = $output;\\n                        }\\n\\n                        $output = 0;\\n                        break;\\n                    }\\n\\n                    $output++;\\n                    [$firstIndex, $lastIndex] = [$lastIndex, $lastIndex + $firstIndex];\\n                }\\n            }\\n        }\\n\\n        return $max > 0 ? $max + 2 : 0;\\n    }\\n}\\n```",
                "solutionTags": [
                    "PHP"
                ],
                "code": "```\\nclass Solution {\\n\\n    /**\\n     * @param Integer[] $arr\\n     * @return Integer\\n     */\\n    function lenLongestFibSubseq($arr) {\\n        $output = 0;\\n        $max = 0;\\n        $map = array_combine($arr, $arr);\\n\\n        foreach ($map as $val) {\\n            foreach ($map as $newVal) {\\n                if ($newVal <= $val) {\\n                    continue;\\n                }\\n\\n                $firstIndex = $val;\\n                $lastIndex = $newVal;\\n\\n                while (true) {\\n                    if (!array_key_exists($firstIndex + $lastIndex, $map)) {\\n                        if ($output > $max) {\\n                            $max = $output;\\n                        }\\n\\n                        $output = 0;\\n                        break;\\n                    }\\n\\n                    $output++;\\n                    [$firstIndex, $lastIndex] = [$lastIndex, $lastIndex + $firstIndex];\\n                }\\n            }\\n        }\\n\\n        return $max > 0 ? $max + 2 : 0;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3245598,
                "title": "python-3-dp-solution-w-reduced-lookup-table-beats-99-5",
                "content": "# Intuition\\nIf $$i+j=k$$ and $$i<j$$, the second loop we can search for $$i$$ from $$j$$ to $$k$$ where $$j > k/2$$.   \\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n For each `k`, and each `j` preceding `k` where `arr[j] > arr[k]/2`, if an `i` exists such that: `arr[i] + arr[j] = arr[k]`\\n- Set subsequence length `(j, k)` to subsequence length `(i, j) + 1`\\n- Update the longest subsequence if necessary.\\n\\nNote: Subsequence Length Dictionary `(..., i, j, k)`, stored as `[j, k]: length` with a default value of `2`, so we can `+1` when first found, making it a valid `3`.\\n\\n# Complexity\\nWhile the time complexity is still $$O(n^2)$$, we can guarantee the second $$n$$ term to be approaching $$n/2$$ \\n\\n# Code\\n```\\nclass Solution:\\n  def lenLongestFibSubseq(self, arr: list[int]) -> int:\\n    longest_subsequence = 0\\n    index_from_value_table = {x: i for i, x in enumerate(arr)}\\n    subsequence_length_dict = defaultdict(lambda: 2)\\n    for k, k_val in enumerate(arr):\\n      jlo = bisect_right(arr, k_val // 2, hi=k)  # arr[j] > arr[k]/2\\n      for j_val in arr[jlo:k]:\\n        j = index_from_value_table[j_val]\\n        i = index_from_value_table.get(k_val - j_val, None)\\n        if i is None: continue\\n        seq = subsequence_length_dict[i, j] + 1\\n        subsequence_length_dict[j, k] = seq\\n        longest_subsequence = max(longest_subsequence, seq)\\n    return longest_subsequence\\n\\n```",
                "solutionTags": [
                    "Python",
                    "Python3",
                    "Dynamic Programming"
                ],
                "code": "```\\nclass Solution:\\n  def lenLongestFibSubseq(self, arr: list[int]) -> int:\\n    longest_subsequence = 0\\n    index_from_value_table = {x: i for i, x in enumerate(arr)}\\n    subsequence_length_dict = defaultdict(lambda: 2)\\n    for k, k_val in enumerate(arr):\\n      jlo = bisect_right(arr, k_val // 2, hi=k)  # arr[j] > arr[k]/2\\n      for j_val in arr[jlo:k]:\\n        j = index_from_value_table[j_val]\\n        i = index_from_value_table.get(k_val - j_val, None)\\n        if i is None: continue\\n        seq = subsequence_length_dict[i, j] + 1\\n        subsequence_length_dict[j, k] = seq\\n        longest_subsequence = max(longest_subsequence, seq)\\n    return longest_subsequence\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3236382,
                "title": "dynamic-programming",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int lenLongestFibSubseq(vector<int>& a) {\\n    int n = a.size(), maxF = 0;\\n    map<int,int> mp;\\n    int  F[n+1][n+1];\\n    for (int i=0; i<n; i++) {\\n        mp[a[i]] = i;\\n    }\\n    memset(F, 0, sizeof(F));\\n    for (int i=2; i<n; i++) {\\n        for (int j=i-1; j>=1; j--) {\\n            int k = a[i] - a[j];\\n            if(mp.count(k) && k < a[j]) {\\n                int x = mp[k];\\n                if(F[j][x] == 0) F[i][j] = 2;\\n                else F[i][j] = F[j][x] + 1;\\n            }\\n        }\\n    }\\n    for (int i=0; i<n; i++) {\\n        for (int j=0; j<n; j++) {\\n            if(F[i][j] > maxF) maxF = F[i][j];\\n        }\\n    }\\n    if(maxF == 0) return 0;\\n    else return (maxF + 1);\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int lenLongestFibSubseq(vector<int>& a) {\\n    int n = a.size(), maxF = 0;\\n    map<int,int> mp;\\n    int  F[n+1][n+1];\\n    for (int i=0; i<n; i++) {\\n        mp[a[i]] = i;\\n    }\\n    memset(F, 0, sizeof(F));\\n    for (int i=2; i<n; i++) {\\n        for (int j=i-1; j>=1; j--) {\\n            int k = a[i] - a[j];\\n            if(mp.count(k) && k < a[j]) {\\n                int x = mp[k];\\n                if(F[j][x] == 0) F[i][j] = 2;\\n                else F[i][j] = F[j][x] + 1;\\n            }\\n        }\\n    }\\n    for (int i=0; i<n; i++) {\\n        for (int j=0; j<n; j++) {\\n            if(F[i][j] > maxF) maxF = F[i][j];\\n        }\\n    }\\n    if(maxF == 0) return 0;\\n    else return (maxF + 1);\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3228258,
                "title": "c",
                "content": "```\\nclass Solution {\\npublic:\\n    int lenLongestFibSubseq(vector<int>& arr) {\\n        unordered_set<int> t(arr.begin(), arr.end());\\n        int ans = 0;\\n        for (int i = 0; i < arr.size(); ++i){\\n            for (int y = i + 1; y < arr.size(); ++y){\\n                int f = arr[i], s = arr[y];\\n                int count = 2;\\n                while (t.find(f + s) != t.end()){\\n                        ans = max(ans, ++count);\\n                        int sum = f + s;\\n                        f = s;\\n                        s = sum;\\n                    }\\n            }\\n        } \\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    int lenLongestFibSubseq(vector<int>& arr) {\\n        unordered_set<int> t(arr.begin(), arr.end());\\n        int ans = 0;\\n        for (int i = 0; i < arr.size(); ++i){\\n            for (int y = i + 1; y < arr.size(); ++y){\\n                int f = arr[i], s = arr[y];\\n                int count = 2;\\n                while (t.find(f + s) != t.end()){\\n                        ans = max(ans, ++count);\\n                        int sum = f + s;\\n                        f = s;\\n                        s = sum;\\n                    }\\n            }\\n        } \\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3223643,
                "title": "1014ms",
                "content": "# Complexity\\n- Time complexity:\\nO(n*(n+1)/2) \\n\\n- Space complexity:\\nO(n)\\n\\n# Code\\n```\\nclass Solution(object):\\n    def lenLongestFibSubseq(self, arr):\\n        hashmap = set(arr)\\n        max_lenght = 0\\n        for pos, num in enumerate(arr):\\n            temp = num\\n            for num2 in arr[pos+1:]:\\n                lenght = 0\\n                while num + num2 in hashmap:\\n                    num2 += num\\n                    num = num2 - num\\n                    lenght += 1\\n                num = temp   \\n                if lenght:\\n                    max_lenght = max(max_lenght, lenght+2)\\n        return max_lenght\\n```",
                "solutionTags": [
                    "Python"
                ],
                "code": "```\\nclass Solution(object):\\n    def lenLongestFibSubseq(self, arr):\\n        hashmap = set(arr)\\n        max_lenght = 0\\n        for pos, num in enumerate(arr):\\n            temp = num\\n            for num2 in arr[pos+1:]:\\n                lenght = 0\\n                while num + num2 in hashmap:\\n                    num2 += num\\n                    num = num2 - num\\n                    lenght += 1\\n                num = temp   \\n                if lenght:\\n                    max_lenght = max(max_lenght, lenght+2)\\n        return max_lenght\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3202699,
                "title": "java-set-and-search-clear-explanations",
                "content": "# Approach\\n1. Traverse and add all numbers to a set.\\n2. Traverse arr with i from 0 to n-1 and j from i+1 to n.\\n3. For each pair i,j check if set contains i+j, if yes, then check if set contains j + (i+2) (their fibonacci sum)\\nStop when the set does not contain their sum anymore\\n4. Keep track of the longest fibonacci sequence.\\n    - !Note: starting with 1, fib(42) > 10^9. Ideally, you would NOT want to check the same sequence again\\n    - eg: 1,3,4,7,11,18\\n    - i = 0;  1+4 = 4. Found 4. 3+4 -> found 7 ... the max chain is 6.\\n    - i = 1:  3+4 = 7. Found 7. 4+7 -> found 11. You are repeating and walking the previous chain. \\nHowever, is is only max 40 steps. Keeping track of chains would actually slow down.  \\n\\n# Complexity\\n- Time complexity:$$O(n + n*n)$$\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:$$O(n)$$\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\n    public int lenLongestFibSubseq(int[] arr) {\\n        int maxFibonacci = 0;\\n        Set<Integer> nums = new HashSet<>();\\n        for (int num : arr) {\\n            nums.add(num);\\n        }\\n        for (int i = 0; i < arr.length -1; i++) {\\n            for (int j = i+1; j < arr.length; j++) {\\n               maxFibonacci = Math.max(maxFibonacci, searchForFibonacci(arr[i], arr[j], nums)); \\n            }\\n        }\\n        return maxFibonacci;\\n    }\\n\\n    private int searchForFibonacci(int num1, int num2, Set<Integer> nums) {\\n        int sequence = 0;\\n        while(nums.contains(num1 + num2)) {\\n            num2 += num1;\\n            num1 = num2 - num1;\\n            if (sequence == 0) {\\n                sequence = 2;\\n            }\\n            sequence++;\\n        }\\n        return sequence;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int lenLongestFibSubseq(int[] arr) {\\n        int maxFibonacci = 0;\\n        Set<Integer> nums = new HashSet<>();\\n        for (int num : arr) {\\n            nums.add(num);\\n        }\\n        for (int i = 0; i < arr.length -1; i++) {\\n            for (int j = i+1; j < arr.length; j++) {\\n               maxFibonacci = Math.max(maxFibonacci, searchForFibonacci(arr[i], arr[j], nums)); \\n            }\\n        }\\n        return maxFibonacci;\\n    }\\n\\n    private int searchForFibonacci(int num1, int num2, Set<Integer> nums) {\\n        int sequence = 0;\\n        while(nums.contains(num1 + num2)) {\\n            num2 += num1;\\n            num1 = num2 - num1;\\n            if (sequence == 0) {\\n                sequence = 2;\\n            }\\n            sequence++;\\n        }\\n        return sequence;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3196968,
                "title": "best-explanation-go-solution-bottom-up-most-intuitive-solution-with-proper-explanation",
                "content": "# Intuition\\n    Following is our induction hypothesis:\\n        If we know the length of longest fib seq ending with (a, b)\\n        then we can find the length of the longest fib seq for (b, a + b)\\n\\n# Approach\\n    Implementation:\\n        We start from first two pairs for which answer would be 2 by definition of fibonacci sequences\\n        Then for subsequent pairs i, j we have the answer for j - i, j\\n        Such that the extended sequence is (...j - i, i, j) \\n        if j - i exists in the array then we add the length the sequence ending with the pair (j - i, i) to the sequence ending with i, j otherwise its just 2\\n\\n# Complexity\\n- Time complexity:\\nO(n*n)\\n\\n\\n# Code\\n```\\nimport (\\n    \"fmt\"\\n)\\n\\nfunc lenLongestFibSubseq(arr []int) int {\\n\\n    // need this to check if seq with pair i, j extends backwards with j - i\\n    // so the sequence could have been j - i, i , j\\n    indexOf := make(map[int]int, 0)\\n    for i, num := range arr {\\n        indexOf[num] = i\\n    }\\n\\n    // represents length of longest fib with ending with (i, j)\\n    longestFibSubAt := make([][]int, len(arr))\\n    maxLen := 0\\n\\n    for i := 0; i < len(arr); i += 1 {\\n        longestFibSubAt[i] = make([]int, len(arr))\\n        for j := i + 1; j < len(arr); j += 1 {\\n            // idx < i for obvious reasons since we are calculating for sequences from idx i onwards so at any index i we currently dont have answers for sequences > i\\n            if idx, prs := indexOf[arr[j] - arr[i]]; (idx < i) && prs {\\n                longestFibSubAt[i][j] = longestFibSubAt[idx][i] + 1\\n            } else {\\n                // cant extend because previous element in the fib seq ..., arr[i], arr[j] not found \\n                longestFibSubAt[i][j] = 2\\n            }\\n            // storing the max length so far\\n            if maxLen < longestFibSubAt[i][j] {\\n                maxLen = longestFibSubAt[i][j]\\n            }\\n        }\\n    }\\n\\n    if maxLen < 3 {\\n        return 0\\n    }\\n    return maxLen\\n}\\n```",
                "solutionTags": [
                    "Go",
                    "Array",
                    "Hash Table",
                    "Dynamic Programming"
                ],
                "code": "```\\nimport (\\n    \"fmt\"\\n)\\n\\nfunc lenLongestFibSubseq(arr []int) int {\\n\\n    // need this to check if seq with pair i, j extends backwards with j - i\\n    // so the sequence could have been j - i, i , j\\n    indexOf := make(map[int]int, 0)\\n    for i, num := range arr {\\n        indexOf[num] = i\\n    }\\n\\n    // represents length of longest fib with ending with (i, j)\\n    longestFibSubAt := make([][]int, len(arr))\\n    maxLen := 0\\n\\n    for i := 0; i < len(arr); i += 1 {\\n        longestFibSubAt[i] = make([]int, len(arr))\\n        for j := i + 1; j < len(arr); j += 1 {\\n            // idx < i for obvious reasons since we are calculating for sequences from idx i onwards so at any index i we currently dont have answers for sequences > i\\n            if idx, prs := indexOf[arr[j] - arr[i]]; (idx < i) && prs {\\n                longestFibSubAt[i][j] = longestFibSubAt[idx][i] + 1\\n            } else {\\n                // cant extend because previous element in the fib seq ..., arr[i], arr[j] not found \\n                longestFibSubAt[i][j] = 2\\n            }\\n            // storing the max length so far\\n            if maxLen < longestFibSubAt[i][j] {\\n                maxLen = longestFibSubAt[i][j]\\n            }\\n        }\\n    }\\n\\n    if maxLen < 3 {\\n        return 0\\n    }\\n    return maxLen\\n}\\n```",
                "codeTag": "Python3"
            },
            {
                "id": 3165746,
                "title": "python3-o-n-2-easy-solution-beats-80",
                "content": "# Complexity\\n- Time complexity:\\n$$O(n^2)$$\\n\\n- Space complexity:\\n$$O(n)$$\\n\\n# Code\\n```\\nclass Solution:\\n    def lenLongestFibSubseq(self, arr: List[int]) -> int:\\n\\n        index = set(arr)    # lookups in set is O(1), where in list is O(n)\\n        longest = defaultdict(int)\\n        max_len = 0\\n\\n        for i in range(len(arr)):\\n            for j in range(i + 1, len(arr)):\\n                a, b = arr[i] , arr[j]\\n                # Check if [a, b, a+b] is a fibonacci-like subsequence\\n                if a + b in index:\\n                    # Check if [b-a, a, b] was a fibonacci-like subsequence\\n                    if (b - a, a) in longest:\\n                        length = longest[b - a, a] + 1\\n                    else:\\n                        length = 3\\n                    longest[a, b] = length\\n                    max_len = max(max_len, length)\\n        \\n        return max_len\\n\\n\\n```",
                "solutionTags": [
                    "Python",
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def lenLongestFibSubseq(self, arr: List[int]) -> int:\\n\\n        index = set(arr)    # lookups in set is O(1), where in list is O(n)\\n        longest = defaultdict(int)\\n        max_len = 0\\n\\n        for i in range(len(arr)):\\n            for j in range(i + 1, len(arr)):\\n                a, b = arr[i] , arr[j]\\n                # Check if [a, b, a+b] is a fibonacci-like subsequence\\n                if a + b in index:\\n                    # Check if [b-a, a, b] was a fibonacci-like subsequence\\n                    if (b - a, a) in longest:\\n                        length = longest[b - a, a] + 1\\n                    else:\\n                        length = 3\\n                    longest[a, b] = length\\n                    max_len = max(max_len, length)\\n        \\n        return max_len\\n\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3110561,
                "title": "easy-to-understand-recursion-c",
                "content": "# Code\\n```\\nclass Solution \\n{\\npublic:\\n    int f(int a, int b, set<int> &s)\\n    {\\n        if(s.find(a+b)!=s.end()) return 1+f(b,a+b,s);\\n        return 0;\\n    }\\n    int lenLongestFibSubseq(vector<int>& arr) \\n    {\\n        int n=arr.size();\\n        set<int> s;\\n        for(auto it: arr) s.insert(it);\\n        int ans=0;\\n        for(int x=0; x<n-2; x++)\\n        {\\n            for(int y=x+1; y<n-1; y++)\\n            {\\n                if(s.find(arr[x]+arr[y])!=s.end())\\n                ans=max(ans,2+f(arr[x],arr[y],s));\\n            }\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution \\n{\\npublic:\\n    int f(int a, int b, set<int> &s)\\n    {\\n        if(s.find(a+b)!=s.end()) return 1+f(b,a+b,s);\\n        return 0;\\n    }\\n    int lenLongestFibSubseq(vector<int>& arr) \\n    {\\n        int n=arr.size();\\n        set<int> s;\\n        for(auto it: arr) s.insert(it);\\n        int ans=0;\\n        for(int x=0; x<n-2; x++)\\n        {\\n            for(int y=x+1; y<n-1; y++)\\n            {\\n                if(s.find(arr[x]+arr[y])!=s.end())\\n                ans=max(ans,2+f(arr[x],arr[y],s));\\n            }\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3068085,
                "title": "java-easy-to-understand-using-set",
                "content": "```\\nclass Solution {\\n    public int lenLongestFibSubseq(int[] arr) {\\n        int res = 0;\\n        Set<Integer> set = new HashSet<>();\\n        for(int i: arr) set.add(i);\\n        for(int i = 0; i < arr.length; i++){\\n            for(int j = i + 1; j < arr.length; j++){\\n                int next = arr[i] + arr[j], temp = 0, prev = arr[j];\\n                while(set.contains(next)){\\n                    temp ++;\\n                    int x = next;\\n                    next = next + prev;\\n                    prev = x;\\n                }\\n                res = Math.max(res, 2 + temp);\\n            }\\n        }\\n        return res >= 3 ? res : 0;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int lenLongestFibSubseq(int[] arr) {\\n        int res = 0;\\n        Set<Integer> set = new HashSet<>();\\n        for(int i: arr) set.add(i);\\n        for(int i = 0; i < arr.length; i++){\\n            for(int j = i + 1; j < arr.length; j++){\\n                int next = arr[i] + arr[j], temp = 0, prev = arr[j];\\n                while(set.contains(next)){\\n                    temp ++;\\n                    int x = next;\\n                    next = next + prev;\\n                    prev = x;\\n                }\\n                res = Math.max(res, 2 + temp);\\n            }\\n        }\\n        return res >= 3 ? res : 0;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2967003,
                "title": "java-easy-hashset",
                "content": "# Complexity\\n- Time complexity:O(n^2)\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: O(n)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\n    public int lenLongestFibSubseq(int[] arr) {\\n        HashSet<Integer> hm=new HashSet<>();\\n        // same question like longest consecutive number\\n        for(int x: arr)\\n        hm.add(x);\\n        int c=0;\\n        for(int i=0;i<arr.length;i++)\\n        {\\n            for(int j=i+1;j<arr.length;j++)\\n            {\\n                int x=arr[i];\\n                int y=arr[j];\\n                int b=0;\\n            while(hm.contains(x+y))\\n            {\\n                y=x+y;\\n                x=y-x;\\n                b++;\\n\\n            }\\n            c=Math.max(c,b);\\n            }\\n        }\\n        // we count the next combination but not counting the starting pair\\n        // if c==0 that means we never hit starting pair\\n        // but c!=0 that means starting pair hit\\n        // that 2 count needed to add in c\\n        if(c!=0) return c+=2;\\n        return c;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int lenLongestFibSubseq(int[] arr) {\\n        HashSet<Integer> hm=new HashSet<>();\\n        // same question like longest consecutive number\\n        for(int x: arr)\\n        hm.add(x);\\n        int c=0;\\n        for(int i=0;i<arr.length;i++)\\n        {\\n            for(int j=i+1;j<arr.length;j++)\\n            {\\n                int x=arr[i];\\n                int y=arr[j];\\n                int b=0;\\n            while(hm.contains(x+y))\\n            {\\n                y=x+y;\\n                x=y-x;\\n                b++;\\n\\n            }\\n            c=Math.max(c,b);\\n            }\\n        }\\n        // we count the next combination but not counting the starting pair\\n        // if c==0 that means we never hit starting pair\\n        // but c!=0 that means starting pair hit\\n        // that 2 count needed to add in c\\n        if(c!=0) return c+=2;\\n        return c;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2965420,
                "title": "just-a-runnable-solution",
                "content": "# Code\\n```\\nimpl Solution {\\n    pub fn len_longest_fib_subseq(arr: Vec<i32>) -> i32 {\\n        let n = arr.len();\\n        let mut mp = std::collections::HashMap::new();\\n        for (i, &v) in arr.iter().enumerate() {\\n            mp.insert(v, i);\\n        }\\n        let mut temp = 0;\\n        for i in 0..n - 2 {\\n            for j in i + 1..n - 1 {\\n                let mut sum = 2;\\n                let mut first = arr[i];\\n                let mut second = arr[j];\\n                while mp.contains_key(&(first + second)) {\\n                    sum += 1;\\n                    let third = first + second;\\n                    first = second;\\n                    second = third;\\n                }\\n                temp = std::cmp::max(temp, sum);\\n            }\\n        }\\n        if temp >= 3 {\\n            temp\\n        } else {\\n            0\\n        }\\n    }\\n}\\n```",
                "solutionTags": [
                    "Rust"
                ],
                "code": "```\\nimpl Solution {\\n    pub fn len_longest_fib_subseq(arr: Vec<i32>) -> i32 {\\n        let n = arr.len();\\n        let mut mp = std::collections::HashMap::new();\\n        for (i, &v) in arr.iter().enumerate() {\\n            mp.insert(v, i);\\n        }\\n        let mut temp = 0;\\n        for i in 0..n - 2 {\\n            for j in i + 1..n - 1 {\\n                let mut sum = 2;\\n                let mut first = arr[i];\\n                let mut second = arr[j];\\n                while mp.contains_key(&(first + second)) {\\n                    sum += 1;\\n                    let third = first + second;\\n                    first = second;\\n                    second = third;\\n                }\\n                temp = std::cmp::max(temp, sum);\\n            }\\n        }\\n        if temp >= 3 {\\n            temp\\n        } else {\\n            0\\n        }\\n    }\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2950558,
                "title": "python3-concise-solution-beats-99",
                "content": "# Code\\n```\\nclass Solution:\\n    def lenLongestFibSubseq(self, A):\\n        sA   = set(A)\\n        last = A[-1]\\n        B    = Counter()\\n        best = 0\\n        for i in reversed(range(len(A))):\\n            a = A[i]\\n            for b in A[i+1:]:\\n                c = a+b\\n                if c in sA:\\n                    B[a,b]  = 1 + B[b,c]\\n                    best    = max(best , B[a,b]+2)\\n                elif c>last:\\n                    break\\n        return best\\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def lenLongestFibSubseq(self, A):\\n        sA   = set(A)\\n        last = A[-1]\\n        B    = Counter()\\n        best = 0\\n        for i in reversed(range(len(A))):\\n            a = A[i]\\n            for b in A[i+1:]:\\n                c = a+b\\n                if c in sA:\\n                    B[a,b]  = 1 + B[b,c]\\n                    best    = max(best , B[a,b]+2)\\n                elif c>last:\\n                    break\\n        return best\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2941103,
                "title": "javascript-solution",
                "content": "\\n# Code\\n```\\n/**\\n * @param {number[]} arr\\n * @return {number}\\n */\\nvar lenLongestFibSubseq = function(arr) {\\n    let n=arr.length;\\n    let dp=new Array(n),m=new Map(),ans=2;\\n    for(let i=0;i<n;i++)\\n    {\\n        dp[i]=new Array(n);\\n        for(let j=i+1;j<n;j++)\\n        {\\n                dp[i][j]=2;\\n        }\\n    }\\n    for(let i=0;i<n;i++)\\n    {\\n        m.set(arr[i],i);\\n    }\\n    for(let i=0;i<n;i++)\\n    {\\n        for(let j=i+1;j<n;j++)\\n        {\\n                if(m.has(arr[i]+arr[j]))\\n                {\\n                    dp[j][m.get(arr[i]+arr[j])]=dp[i][j]+1;\\n                }\\n                ans=Math.max(dp[i][j],ans);\\n        }\\n    }\\n    if(ans<=2)\\n    {\\n        return 0;\\n    }\\n    return ans;\\n};\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\n/**\\n * @param {number[]} arr\\n * @return {number}\\n */\\nvar lenLongestFibSubseq = function(arr) {\\n    let n=arr.length;\\n    let dp=new Array(n),m=new Map(),ans=2;\\n    for(let i=0;i<n;i++)\\n    {\\n        dp[i]=new Array(n);\\n        for(let j=i+1;j<n;j++)\\n        {\\n                dp[i][j]=2;\\n        }\\n    }\\n    for(let i=0;i<n;i++)\\n    {\\n        m.set(arr[i],i);\\n    }\\n    for(let i=0;i<n;i++)\\n    {\\n        for(let j=i+1;j<n;j++)\\n        {\\n                if(m.has(arr[i]+arr[j]))\\n                {\\n                    dp[j][m.get(arr[i]+arr[j])]=dp[i][j]+1;\\n                }\\n                ans=Math.max(dp[i][j],ans);\\n        }\\n    }\\n    if(ans<=2)\\n    {\\n        return 0;\\n    }\\n    return ans;\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2932129,
                "title": "java-solution-using-hashmap",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach \\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:O(N^2)\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:O(N)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\n    public int lenLongestFibSubseq(int[] arr) {\\n        int count=0;\\n        int n=arr.length;\\n        HashMap<Integer,Integer> mp=new HashMap<>();\\n        for(int i=0;i<arr.length;i++){\\n            mp.put(arr[i],i);\\n        }int temp=0;\\n        for(int i=0;i<n-2;i++){\\n           for(int j=i+1;j<n-1;j++){\\n            int sum=2;\\n            int first=arr[i];\\n            int second=arr[j];\\n            while(mp.containsKey(first+second)){\\n                     sum++;\\n                     int third=first+second;\\n                     first=second;\\n                     second=third;\\n                    \\n                }temp=Math.max(temp,sum);\\n            }\\n        }\\n        return temp>=3?temp:0;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int lenLongestFibSubseq(int[] arr) {\\n        int count=0;\\n        int n=arr.length;\\n        HashMap<Integer,Integer> mp=new HashMap<>();\\n        for(int i=0;i<arr.length;i++){\\n            mp.put(arr[i],i);\\n        }int temp=0;\\n        for(int i=0;i<n-2;i++){\\n           for(int j=i+1;j<n-1;j++){\\n            int sum=2;\\n            int first=arr[i];\\n            int second=arr[j];\\n            while(mp.containsKey(first+second)){\\n                     sum++;\\n                     int third=first+second;\\n                     first=second;\\n                     second=third;\\n                    \\n                }temp=Math.max(temp,sum);\\n            }\\n        }\\n        return temp>=3?temp:0;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2895836,
                "title": "clean-solution-easy-two-dimensions-dp",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nclean solution - two dimensions dp\\npython 3\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\nO(n2)\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\nO(n2)\\n# Code\\n```\\nclass Solution:\\n    def lenLongestFibSubseq(self, arr: List[int]) -> int:\\n        n = len(arr)\\n        dic = {}\\n        for i in range(n):\\n            dic[arr[i]] = i\\n        res = 0\\n        dp =[[2 for i in range(n)] for i in range(n)]\\n        for i in range(2,n):\\n            for j in range(i):\\n                cha = arr[i]-arr[j]\\n                if cha in dic and dic[cha]<j:\\n                    dp[i][j] = dp[j][dic[cha]]+1\\n                    res = max(res, dp[i][j])\\n        return res\\n\\n\\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def lenLongestFibSubseq(self, arr: List[int]) -> int:\\n        n = len(arr)\\n        dic = {}\\n        for i in range(n):\\n            dic[arr[i]] = i\\n        res = 0\\n        dp =[[2 for i in range(n)] for i in range(n)]\\n        for i in range(2,n):\\n            for j in range(i):\\n                cha = arr[i]-arr[j]\\n                if cha in dic and dic[cha]<j:\\n                    dp[i][j] = dp[j][dic[cha]]+1\\n                    res = max(res, dp[i][j])\\n        return res\\n\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2893435,
                "title": "longest-fibonacci",
                "content": "# Intuition\\nfirst I wanted to flip the array. but then I showed that it does not make sense and decided to saddle the old fashioned way.\\n\\n\\n# Approach\\nI noticed that the code does not stop when it explicitly finds the maximum length, so I included a condition that stops the code when f1 + f2 == the last number.\\n\\n# Complexity\\n- Time complexity:\\n- Space complexity:\\n# Code\\n```\\nclass Solution:\\n    def lenLongestFibSubseq(self, arr: List[int]) -> int:\\n        all = set(arr)\\n        len_arr = len(arr)-1\\n        i, j, max_range = 0, 1, 0\\n        while i < len_arr:\\n            f1, f2 = arr[i], arr[j]\\n            if (f1 + f2) in all:\\n                s = 3\\n                while True:\\n                    f1, f2 = f2, f1 + f2\\n                    if f1 + f2 not in all:\\n                        max_range = max(max_range, s)\\n                        if f2 == arr[len_arr]:\\n                            return max_range\\n                        break\\n                    s += 1\\n            j += 1 \\n            if j > len_arr:\\n                i += 1\\n                j = i + 1\\n        return max_range\\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def lenLongestFibSubseq(self, arr: List[int]) -> int:\\n        all = set(arr)\\n        len_arr = len(arr)-1\\n        i, j, max_range = 0, 1, 0\\n        while i < len_arr:\\n            f1, f2 = arr[i], arr[j]\\n            if (f1 + f2) in all:\\n                s = 3\\n                while True:\\n                    f1, f2 = f2, f1 + f2\\n                    if f1 + f2 not in all:\\n                        max_range = max(max_range, s)\\n                        if f2 == arr[len_arr]:\\n                            return max_range\\n                        break\\n                    s += 1\\n            j += 1 \\n            if j > len_arr:\\n                i += 1\\n                j = i + 1\\n        return max_range\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2891595,
                "title": "kotlin-using-hashset",
                "content": "# Approach\\nAll item are positive so adding two items makes greater number and also the array is sorted so the order will no change.\\n\\n# Complexity\\n- Time complexity:O(n^2)\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:O(n)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\n    fun lenLongestFibSubseq(arr: IntArray): Int {\\n    var length = 0\\n    val set = arr.toHashSet()\\n    for (i in 0 until arr.size - 2) {\\n        for (j in i + 1 until arr.size - 1) {\\n            val temp = helper(arr[i], arr[j], set)\\n            if (temp > length) length = temp\\n        }\\n    }\\n    return if (length < 3) 0 else length\\n}\\n\\nprivate fun helper(first: Int, second: Int, set: Set<Int>): Int {\\n    var f = first\\n    var s = second\\n    var count = 2\\n    while ((f + s) in set) {\\n        val t = f\\n        f = s\\n        s += t\\n        count++\\n    }\\n    return count\\n}\\n}\\n```",
                "solutionTags": [
                    "Kotlin"
                ],
                "code": "```\\nclass Solution {\\n    fun lenLongestFibSubseq(arr: IntArray): Int {\\n    var length = 0\\n    val set = arr.toHashSet()\\n    for (i in 0 until arr.size - 2) {\\n        for (j in i + 1 until arr.size - 1) {\\n            val temp = helper(arr[i], arr[j], set)\\n            if (temp > length) length = temp\\n        }\\n    }\\n    return if (length < 3) 0 else length\\n}\\n\\nprivate fun helper(first: Int, second: Int, set: Set<Int>): Int {\\n    var f = first\\n    var s = second\\n    var count = 2\\n    while ((f + s) in set) {\\n        val t = f\\n        f = s\\n        s += t\\n        count++\\n    }\\n    return count\\n}\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2891580,
                "title": "java-solution-o-n-n",
                "content": "# Complexity\\n- Time complexity: O(nxn)\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: O(n)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\n    public int lenLongestFibSubseq(int[] a) {\\n        int ans=0,n=a.length;\\n        Map<Integer,Integer> m=new HashMap<Integer,Integer>();\\n        for(int i=0;i<n;i++) m.put(a[i],i);\\n        for(int i=0;i<n-1;i++){\\n            for(int j=i+1;j<n;j++){\\n                int y=a[j],x=a[i],k=2;\\n                while(true){\\n                    if(m.containsKey(x+y)){\\n                        int t=x+y;\\n                        x=y;\\n                        y=t;\\n                        k++;\\n                    }\\n                    else break;\\n                }\\n                if(k>=3) ans=Math.max(ans,k);\\n            }\\n        }\\n        return ans;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int lenLongestFibSubseq(int[] a) {\\n        int ans=0,n=a.length;\\n        Map<Integer,Integer> m=new HashMap<Integer,Integer>();\\n        for(int i=0;i<n;i++) m.put(a[i],i);\\n        for(int i=0;i<n-1;i++){\\n            for(int j=i+1;j<n;j++){\\n                int y=a[j],x=a[i],k=2;\\n                while(true){\\n                    if(m.containsKey(x+y)){\\n                        int t=x+y;\\n                        x=y;\\n                        y=t;\\n                        k++;\\n                    }\\n                    else break;\\n                }\\n                if(k>=3) ans=Math.max(ans,k);\\n            }\\n        }\\n        return ans;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2891579,
                "title": "java-solution-o-n-n",
                "content": "# Complexity\\n- Time complexity: O(nxn)\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: O(n)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\n    public int lenLongestFibSubseq(int[] a) {\\n        int ans=0,n=a.length;\\n        Map<Integer,Integer> m=new HashMap<Integer,Integer>();\\n        for(int i=0;i<n;i++) m.put(a[i],i);\\n        for(int i=0;i<n-1;i++){\\n            for(int j=i+1;j<n;j++){\\n                int y=a[j],x=a[i],k=2;\\n                while(true){\\n                    if(m.containsKey(x+y)){\\n                        int t=x+y;\\n                        x=y;\\n                        y=t;\\n                        k++;\\n                    }\\n                    else break;\\n                }\\n                if(k>=3) ans=Math.max(ans,k);\\n            }\\n        }\\n        return ans;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int lenLongestFibSubseq(int[] a) {\\n        int ans=0,n=a.length;\\n        Map<Integer,Integer> m=new HashMap<Integer,Integer>();\\n        for(int i=0;i<n;i++) m.put(a[i],i);\\n        for(int i=0;i<n-1;i++){\\n            for(int j=i+1;j<n;j++){\\n                int y=a[j],x=a[i],k=2;\\n                while(true){\\n                    if(m.containsKey(x+y)){\\n                        int t=x+y;\\n                        x=y;\\n                        y=t;\\n                        k++;\\n                    }\\n                    else break;\\n                }\\n                if(k>=3) ans=Math.max(ans,k);\\n            }\\n        }\\n        return ans;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2891577,
                "title": "java-solution-o-n-n",
                "content": "# Complexity\\n- Time complexity: O(nxn)\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: O(n)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\n    public int lenLongestFibSubseq(int[] a) {\\n        int ans=0,n=a.length;\\n        Map<Integer,Integer> m=new HashMap<Integer,Integer>();\\n        for(int i=0;i<n;i++) m.put(a[i],i);\\n        for(int i=0;i<n-1;i++){\\n            for(int j=i+1;j<n;j++){\\n                int y=a[j],x=a[i],k=2;\\n                while(true){\\n                    if(m.containsKey(x+y)){\\n                        int t=x+y;\\n                        x=y;\\n                        y=t;\\n                        k++;\\n                    }\\n                    else break;\\n                }\\n                if(k>=3) ans=Math.max(ans,k);\\n            }\\n        }\\n        return ans;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int lenLongestFibSubseq(int[] a) {\\n        int ans=0,n=a.length;\\n        Map<Integer,Integer> m=new HashMap<Integer,Integer>();\\n        for(int i=0;i<n;i++) m.put(a[i],i);\\n        for(int i=0;i<n-1;i++){\\n            for(int j=i+1;j<n;j++){\\n                int y=a[j],x=a[i],k=2;\\n                while(true){\\n                    if(m.containsKey(x+y)){\\n                        int t=x+y;\\n                        x=y;\\n                        y=t;\\n                        k++;\\n                    }\\n                    else break;\\n                }\\n                if(k>=3) ans=Math.max(ans,k);\\n            }\\n        }\\n        return ans;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2891132,
                "title": "easy-faster-efficient-java-soln",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\n    public int lenLongestFibSubseq(int[] arr) {\\n        int n = arr.length;\\n        if(arr == null || n == 0){\\n            return 0;\\n        }\\n        HashMap<Integer, Integer> map = new HashMap<>();\\n        int [][] dp = new int[n][n];\\n\\n        for(int i = 0; i < arr.length; i++){\\n            map.put(arr[i], i);\\n            for(int j = i + 1; j < n; j++){\\n                dp[i][j] = 2;\\n            }\\n        }\\n        \\n        int res = 0;\\n        for(int i = 0; i < n; i++){\\n            for(int j = i + 1; j < n; j++){\\n                int k = arr[j] + arr[i];\\n                if(map.containsKey(k)){\\n                    int idx = map.get(k);\\n                    dp[j][idx] = dp[i][j] + 1;\\n                    res = Math.max(res, dp[j][idx]);\\n                }\\n            }\\n        }\\n        return res;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int lenLongestFibSubseq(int[] arr) {\\n        int n = arr.length;\\n        if(arr == null || n == 0){\\n            return 0;\\n        }\\n        HashMap<Integer, Integer> map = new HashMap<>();\\n        int [][] dp = new int[n][n];\\n\\n        for(int i = 0; i < arr.length; i++){\\n            map.put(arr[i], i);\\n            for(int j = i + 1; j < n; j++){\\n                dp[i][j] = 2;\\n            }\\n        }\\n        \\n        int res = 0;\\n        for(int i = 0; i < n; i++){\\n            for(int j = i + 1; j < n; j++){\\n                int k = arr[j] + arr[i];\\n                if(map.containsKey(k)){\\n                    int idx = map.get(k);\\n                    dp[j][idx] = dp[i][j] + 1;\\n                    res = Math.max(res, dp[j][idx]);\\n                }\\n            }\\n        }\\n        return res;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2889491,
                "title": "c-solution-using-hashset",
                "content": "# Intuition\\nStore elements in the HashSet. Use pair of numbers and use this pair to find the next element and check if this is available in the HashSet of not. If it exist, increase the length and continue.\\n\\n# Complexity\\n- Time complexity: O(n^3)\\n\\n- Space complexity: O(n)\\n\\n# Code\\n```\\npublic class Solution {\\n    public int LenLongestFibSubseq(int[] arr) {\\n        HashSet<int> arrHash = new HashSet<int>(arr);\\n        int maxLength = 0;\\n\\n        for(int i=0; i<arr.Length; i++){\\n            for(int j=i+1; j<arr.Length; j++){\\n                int prevItem = arr[j];\\n                int nextItem = arr[j]+arr[i];\\n                int len=2;\\n\\n                while(arrHash.Contains(nextItem)){\\n                    (nextItem, prevItem) = (nextItem + prevItem, nextItem);\\n                    len++;\\n                }\\n\\n                maxLength = Math.Max(len, maxLength);\\n            }\\n        }\\n        \\n        return maxLength == 2 ? 0 : maxLength;\\n    }\\n}\\n```",
                "solutionTags": [
                    "C#",
                    "Array",
                    "Hash Table"
                ],
                "code": "```\\npublic class Solution {\\n    public int LenLongestFibSubseq(int[] arr) {\\n        HashSet<int> arrHash = new HashSet<int>(arr);\\n        int maxLength = 0;\\n\\n        for(int i=0; i<arr.Length; i++){\\n            for(int j=i+1; j<arr.Length; j++){\\n                int prevItem = arr[j];\\n                int nextItem = arr[j]+arr[i];\\n                int len=2;\\n\\n                while(arrHash.Contains(nextItem)){\\n                    (nextItem, prevItem) = (nextItem + prevItem, nextItem);\\n                    len++;\\n                }\\n\\n                maxLength = Math.Max(len, maxLength);\\n            }\\n        }\\n        \\n        return maxLength == 2 ? 0 : maxLength;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2889343,
                "title": "java-straightforward-solution",
                "content": "\\n# Code\\n```\\nclass Solution {\\n    public int lenLongestFibSubseq(int[] arr) {\\n        Set<Integer> set = new HashSet<>();\\n        for(int a : arr){\\n            set.add(a);\\n        }\\n        int n = arr.length;\\n        int res =2;\\n        for(int i=0;i<n;i++){            \\n            for(int j=i+1;j<n;j++){                \\n                int b = arr[j];\\n                int a = arr[i];\\n                int cnt= 2;\\n                while(set.contains(a+b)){\\n                    cnt++;\\n                    int temp =b;\\n                    b=a+b;\\n                    a = temp;\\n                }\\n                if(res<cnt)\\n                    res = cnt;\\n            }\\n           \\n        }\\n        res= res>2?res:0;\\n        return res;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int lenLongestFibSubseq(int[] arr) {\\n        Set<Integer> set = new HashSet<>();\\n        for(int a : arr){\\n            set.add(a);\\n        }\\n        int n = arr.length;\\n        int res =2;\\n        for(int i=0;i<n;i++){            \\n            for(int j=i+1;j<n;j++){                \\n                int b = arr[j];\\n                int a = arr[i];\\n                int cnt= 2;\\n                while(set.contains(a+b)){\\n                    cnt++;\\n                    int temp =b;\\n                    b=a+b;\\n                    a = temp;\\n                }\\n                if(res<cnt)\\n                    res = cnt;\\n            }\\n           \\n        }\\n        res= res>2?res:0;\\n        return res;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2889156,
                "title": "c-solution",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nTo add item x into a fibonacci sequence $$a$$,\\n$$a_{|a|-1}+a_{|a|} = x$$ , where $$|a|$$ is the length of the sequence\\n\\nTherefore, the suffix of fibonacci sequence can be uniquely determined by 2 numbers, $$a_{|a|-1}$$ and $$a_{|a|}$$.\\n\\nLet $$dp[i,j]$$ = max length of a fib sequence a where  \\n$$arr[i]$$ is the second last number and $$arr[j]$$ is the last number.\\n\\nTransition:\\n$$dp[j,k] = dp[i,j]+1$$ if $$k>j$$ && $$arr[k] = arr[i] + arr[j]$$\\n\\nThere are many ways for finding $$k$$ given $$i$$ and $$j$$. The code below uses the binary search (This works because the array is sorted, and all values are unique.). \\n\\nHashmaps and sets (storing pairs storing {value,position} ) are also efficient to find k. They are also applicable where the array is not sorted and contains duplicate values. \\n\\n\\n\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int lenLongestFibSubseq(vector<int>& arr) {\\n        int n = arr.size(),ans = 0;\\n        vector<vector<int>>dp(n,vector<int>(n,2));\\n        for(int j = 1;j<n-1;j++){\\n            for(int i = 0;i<j;i++){\\n\\n                int l = j+1,r = n-1,pos = -1,sum = arr[i]+arr[j];\\n                while(l<=r){\\n                    int mid = (l+r)/2;\\n                    if(arr[mid]<=sum){\\n                        pos = mid;\\n                        l = mid+1;\\n                    }\\n                    else r = mid-1;\\n                }\\n                if(pos>=0 && pos<n && arr[pos]==sum){\\n                    dp[j][pos] = max(dp[i][j]+1,dp[j][pos]);\\n                    if(dp[j][pos]>2)ans = max(ans,dp[j][pos]);\\n                }\\n\\n            }\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int lenLongestFibSubseq(vector<int>& arr) {\\n        int n = arr.size(),ans = 0;\\n        vector<vector<int>>dp(n,vector<int>(n,2));\\n        for(int j = 1;j<n-1;j++){\\n            for(int i = 0;i<j;i++){\\n\\n                int l = j+1,r = n-1,pos = -1,sum = arr[i]+arr[j];\\n                while(l<=r){\\n                    int mid = (l+r)/2;\\n                    if(arr[mid]<=sum){\\n                        pos = mid;\\n                        l = mid+1;\\n                    }\\n                    else r = mid-1;\\n                }\\n                if(pos>=0 && pos<n && arr[pos]==sum){\\n                    dp[j][pos] = max(dp[i][j]+1,dp[j][pos]);\\n                    if(dp[j][pos]>2)ans = max(ans,dp[j][pos]);\\n                }\\n\\n            }\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2832245,
                "title": "cpp-beginner-friendly-t-c-o-n-2logn-sp-o-1",
                "content": "\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int lenLongestFibSubseq(vector<int>& arr) {\\n        int i,j,k,ans=0,sum,pre,tmp;\\n        for(i=0;i<arr.size();i++){\\n            for(j=i+1;j<arr.size();j++){\\n                pre = arr[j];\\n                sum = arr[i]+arr[j];\\n                tmp=2;\\n                while(binary_search(arr.begin()+j+1,arr.end(),sum)){\\n                    tmp++;\\n                    k = sum;\\n                    sum = pre+sum;\\n                    pre = k;\\n                }\\n                ans = max(ans,tmp);\\n            }\\n        }\\n        if(ans<3){return 0;}\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Binary Search"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int lenLongestFibSubseq(vector<int>& arr) {\\n        int i,j,k,ans=0,sum,pre,tmp;\\n        for(i=0;i<arr.size();i++){\\n            for(j=i+1;j<arr.size();j++){\\n                pre = arr[j];\\n                sum = arr[i]+arr[j];\\n                tmp=2;\\n                while(binary_search(arr.begin()+j+1,arr.end(),sum)){\\n                    tmp++;\\n                    k = sum;\\n                    sum = pre+sum;\\n                    pre = k;\\n                }\\n                ans = max(ans,tmp);\\n            }\\n        }\\n        if(ans<3){return 0;}\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2780199,
                "title": "javascript-simple-20-lines-of-code",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nsimplely rember the last two number and count by keep a dic like this \\n\\n```\\n// dic[current][prev]=count\\n```\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n```\\nloop 1 for current number\\n    loop 2 for prev number\\n        if(found prev has a `prev prev` == current - prev){\\n            dic[current][prev] = dic[prev][prev prev]+1\\n            update max with dic[current][prev]\\n        }else{\\n            dic[current][prev] = 2\\n        }\\n        \\n```\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n$$O(n*n)$$\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n$$O(n*n)$$\\n\\n# Code\\n```\\n/**\\n * @param {number[]} arr\\n * @return {number}\\n */\\nvar lenLongestFibSubseq = function (arr) {\\n  // dic[current][prev]=count\\n  let max = 0, dic = new Map()\\n  for (let i = 0; i < arr.length; i++) {\\n    let val = arr[i], curMap = new Map\\n    dic.set(val, curMap)\\n    for (let j = 0; j < i; j++) {\\n      let prev = arr[j]\\n      let pp = val - prev\\n      if (dic.has(prev) && dic.get(prev).has(pp)) {\\n        let prevMap = dic.get(prev)\\n        let cnt = prevMap.get(pp) + 1\\n        max = Math.max(cnt, max)\\n        prevMap.delete(pp)\\n        curMap.set(prev, cnt)\\n      } else {\\n        curMap.set(prev, 2)\\n      }\\n    }\\n  }\\n  return max >= 3 ? max : 0\\n};\\n\\n// console.log(lenLongestFibSubseq([1, 2, 3, 4, 5, 6, 7, 8])) // 5\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\n// dic[current][prev]=count\\n```\n```\\nloop 1 for current number\\n    loop 2 for prev number\\n        if(found prev has a `prev prev` == current - prev){\\n            dic[current][prev] = dic[prev][prev prev]+1\\n            update max with dic[current][prev]\\n        }else{\\n            dic[current][prev] = 2\\n        }\\n        \\n```\n```\\n/**\\n * @param {number[]} arr\\n * @return {number}\\n */\\nvar lenLongestFibSubseq = function (arr) {\\n  // dic[current][prev]=count\\n  let max = 0, dic = new Map()\\n  for (let i = 0; i < arr.length; i++) {\\n    let val = arr[i], curMap = new Map\\n    dic.set(val, curMap)\\n    for (let j = 0; j < i; j++) {\\n      let prev = arr[j]\\n      let pp = val - prev\\n      if (dic.has(prev) && dic.get(prev).has(pp)) {\\n        let prevMap = dic.get(prev)\\n        let cnt = prevMap.get(pp) + 1\\n        max = Math.max(cnt, max)\\n        prevMap.delete(pp)\\n        curMap.set(prev, cnt)\\n      } else {\\n        curMap.set(prev, 2)\\n      }\\n    }\\n  }\\n  return max >= 3 ? max : 0\\n};\\n\\n// console.log(lenLongestFibSubseq([1, 2, 3, 4, 5, 6, 7, 8])) // 5\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2779674,
                "title": "solution-using-hashset-without-dp-o-n3-time-complexity",
                "content": "\\tclass Solution {\\n\\t\\tpublic int lenLongestFibSubseq(int[] A) {\\n\\t\\t\\t int n=A.length;\\n\\t\\t\\tHashSet<Integer> S = new HashSet<>();\\n\\t\\t\\tfor (int t : A) {\\n\\t\\t\\t\\tS.add(t);\\n\\t\\t\\t}\\n\\t\\t\\tint maxLen = 0, x, y;\\n\\n\\t\\t\\tfor (int i = 0; i < n; ++i) {\\n\\t\\t\\t\\tfor (int j = i + 1; j < n; ++j) {\\n\\n\\t\\t\\t\\t\\tx = A[i];\\n\\t\\t\\t\\t\\ty = A[j];\\n\\t\\t\\t\\t\\tint length = 2;\\n\\n\\n\\t\\t\\t\\t\\twhile (S.contains(x+y)) {\\n\\t\\t\\t\\t\\t\\tint z = x + y;\\n\\t\\t\\t\\t\\t\\tx = y;\\n\\t\\t\\t\\t\\t\\ty = z;\\n\\t\\t\\t\\t\\t\\tmaxLen = Math.max(maxLen, ++length);\\n\\t\\t\\t\\t\\t}\\n\\t\\t\\t\\t}\\n\\t\\t\\t}\\n\\t\\t\\treturn maxLen >= 3 ? maxLen : 0;\\n\\t\\t}\\n\\t}",
                "solutionTags": [
                    "Java"
                ],
                "code": "class Solution {\\n\\t\\tpublic int lenLongestFibSubseq(int[] A) {\\n\\t\\t\\t int n=A.length;\\n\\t\\t\\tHashSet<Integer> S = new HashSet<>();\\n\\t\\t\\tfor (int t : A) {\\n\\t\\t\\t\\tS.add(t);\\n\\t\\t\\t}",
                "codeTag": "Java"
            },
            {
                "id": 2764928,
                "title": "javascript-o-n-2-97-faster-set",
                "content": "```\\nvar lenLongestFibSubseq = function(arr) {\\n    var i, j;\\n    var maxcount = 0, maxtrack=0, count, tracker;\\n    let pos = new Set();\\n    var last;\\n    \\n    for( i=arr.length-1; i>=0; i-- ) {\\n        pos.add( arr[i] );\\n    }\\n    \\n    for( i=0; i<arr.length-maxtrack; i++ ) {\\n        for( j=i+1; j<arr.length-maxtrack; j++ ) {\\n            count = 2;\\n            tracker = arr[i] + arr[j];\\n            last = arr[j];\\n            while( pos.has(tracker) ) {\\n               [tracker,last] = [tracker+last,tracker];\\n               count++;\\n            }\\n            \\n            if( count > 2 ) {\\n                maxcount = Math.max(count, maxcount);\\n                maxtrack = Math.max(maxcount-1, 0);\\n            }\\n        }\\n    }\\n    \\n    return maxcount;\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nvar lenLongestFibSubseq = function(arr) {\\n    var i, j;\\n    var maxcount = 0, maxtrack=0, count, tracker;\\n    let pos = new Set();\\n    var last;\\n    \\n    for( i=arr.length-1; i>=0; i-- ) {\\n        pos.add( arr[i] );\\n    }\\n    \\n    for( i=0; i<arr.length-maxtrack; i++ ) {\\n        for( j=i+1; j<arr.length-maxtrack; j++ ) {\\n            count = 2;\\n            tracker = arr[i] + arr[j];\\n            last = arr[j];\\n            while( pos.has(tracker) ) {\\n               [tracker,last] = [tracker+last,tracker];\\n               count++;\\n            }\\n            \\n            if( count > 2 ) {\\n                maxcount = Math.max(count, maxcount);\\n                maxtrack = Math.max(maxcount-1, 0);\\n            }\\n        }\\n    }\\n    \\n    return maxcount;\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2754925,
                "title": "easy-to-understand-javascript-solution-dp",
                "content": "\\tvar lenLongestFibSubseq = function(arr) {\\n\\t\\tconst { length } = arr;\\n\\t\\tconst dp = Array(length).fill(\\'\\').map(_ => Array(length).fill(0));\\n\\t\\tconst arrMap = arr.reduce((map, num, index) => map.set(num, index), new Map());\\n\\t\\tlet result = 0;\\n\\n\\t\\tfor (let a = 0; a < length; a++) {\\n\\t\\t\\tfor (let b = 0; b < a; b++) {\\n\\t\\t\\t\\tconst c = arrMap.get(arr[a] - arr[b]);\\n\\n\\t\\t\\t\\tdp[a][b] = c !== void 0 && arr[a] - arr[b] < arr[b]\\n\\t\\t\\t\\t\\t? dp[b][c] + 1\\n\\t\\t\\t\\t\\t: 2;\\n\\t\\t\\t\\tresult = Math.max(dp[a][b], result);\\n\\t\\t\\t}\\n\\t\\t}\\n\\t\\treturn result > 2 ? result : 0;\\n\\t};",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "\\tvar lenLongestFibSubseq = function(arr) {\\n\\t\\tconst { length } = arr;\\n\\t\\tconst dp = Array(length).fill(\\'\\').map(_ => Array(length).fill(0));\\n\\t\\tconst arrMap = arr.reduce((map, num, index) => map.set(num, index), new Map());\\n\\t\\tlet result = 0;\\n\\n\\t\\tfor (let a = 0; a < length; a++) {\\n\\t\\t\\tfor (let b = 0; b < a; b++) {\\n\\t\\t\\t\\tconst c = arrMap.get(arr[a] - arr[b]);\\n\\n\\t\\t\\t\\tdp[a][b] = c !== void 0 && arr[a] - arr[b] < arr[b]\\n\\t\\t\\t\\t\\t? dp[b][c] + 1\\n\\t\\t\\t\\t\\t: 2;\\n\\t\\t\\t\\tresult = Math.max(dp[a][b], result);\\n\\t\\t\\t}\\n\\t\\t}\\n\\t\\treturn result > 2 ? result : 0;\\n\\t};",
                "codeTag": "Unknown"
            },
            {
                "id": 2742170,
                "title": "python-o-n-2-time-o-n-2-space-solution-dynamic-programming-hashmap-commented",
                "content": "```\\nclass Solution:\\n    def lenLongestFibSubseq(self, arr: List[int]) -> int:\\n        # pos hashmap will contain the position(indices) of elements\\n        sz, pos, result = len(arr), {}, 0\\n        # dp[i][j] will contain length of the subsequence whose 2nd last element is\\n        # arr[i] and last element is arr[j]\\n        dp = [[0] * sz for _ in range(sz)]\\n        for i in range(sz):\\n            pos[arr[i]] = i\\n            # Set all dp[i][j] = 2 where j > i because minimum length subsequence we can\\n            # have is of length 2\\n            for j in range(i, sz):\\n                dp[i][j] = 2\\n        # Iterate through indices of the last element\\n        for j in range(2, sz):\\n            # Iterate through the indices of 2nd last element\\n            for i in range(j - 1, 0, -1):\\n                # the previous element should be arr[j] - arr[i]\\n                prev = arr[j] - arr[i]\\n                # previous element cannot be greater than 2nd last\\n                if prev >= arr[i]:\\n                    break\\n                # Check if the previous element is present in the array\\n                if prev not in pos:\\n                    continue\\n                # If the previous element is present in the array,\\n                # Include that into the subsequence containing arr[i] and arr[j]\\n                # Increment whatever the length of the subsequence was by 1\\n                dp[i][j] = dp[pos[prev]][i] + 1\\n        # Check for all the valid subsequences(the ones with length >= 3)\\n        for j in range(2, sz):\\n            for i in range(1, sz - 1):\\n                # Update result to the length of longest subsequence\\n                if dp[i][j] > 2:\\n                    result = max(result, dp[i][j])\\n        return result\\n```",
                "solutionTags": [
                    "Python",
                    "Dynamic Programming"
                ],
                "code": "```\\nclass Solution:\\n    def lenLongestFibSubseq(self, arr: List[int]) -> int:\\n        # pos hashmap will contain the position(indices) of elements\\n        sz, pos, result = len(arr), {}, 0\\n        # dp[i][j] will contain length of the subsequence whose 2nd last element is\\n        # arr[i] and last element is arr[j]\\n        dp = [[0] * sz for _ in range(sz)]\\n        for i in range(sz):\\n            pos[arr[i]] = i\\n            # Set all dp[i][j] = 2 where j > i because minimum length subsequence we can\\n            # have is of length 2\\n            for j in range(i, sz):\\n                dp[i][j] = 2\\n        # Iterate through indices of the last element\\n        for j in range(2, sz):\\n            # Iterate through the indices of 2nd last element\\n            for i in range(j - 1, 0, -1):\\n                # the previous element should be arr[j] - arr[i]\\n                prev = arr[j] - arr[i]\\n                # previous element cannot be greater than 2nd last\\n                if prev >= arr[i]:\\n                    break\\n                # Check if the previous element is present in the array\\n                if prev not in pos:\\n                    continue\\n                # If the previous element is present in the array,\\n                # Include that into the subsequence containing arr[i] and arr[j]\\n                # Increment whatever the length of the subsequence was by 1\\n                dp[i][j] = dp[pos[prev]][i] + 1\\n        # Check for all the valid subsequences(the ones with length >= 3)\\n        for j in range(2, sz):\\n            for i in range(1, sz - 1):\\n                # Update result to the length of longest subsequence\\n                if dp[i][j] > 2:\\n                    result = max(result, dp[i][j])\\n        return result\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2739053,
                "title": "not-dp-o-n-2-set",
                "content": "Using Set to avoid duplicate efforts\\n\\n\\t\\tclass Solution:\\n\\t\\t\\tdef lenLongestFibSubseq(self, a: List[int]) -> int:\\n\\t\\t\\t\\ts = set(a)\\n\\t\\t\\t\\tn = len(a)\\n\\t\\t\\t\\tseen = set()\\n\\t\\t\\t\\tres = 0\\n\\n\\t\\t\\t\\tfor i in range(n-1):\\n\\t\\t\\t\\t\\tfor j in range(i+1,n):  \\n\\t\\t\\t\\t\\t\\tx,y = a[i],a[j] \\n\\t\\t\\t\\t\\t\\tans = 2 \\n\\t\\t\\t\\t\\t\\twhile (x,y) not in seen and x+y in s: \\n\\t\\t\\t\\t\\t\\t\\tseen.add((x,y))\\n\\t\\t\\t\\t\\t\\t\\tt = x \\n\\t\\t\\t\\t\\t\\t\\tx = y\\n\\t\\t\\t\\t\\t\\t\\ty = y+t\\n\\t\\t\\t\\t\\t\\t\\tans+=1 \\n\\t\\t\\t\\t\\t\\tres = max(ans,res)\\n\\n\\t\\t\\t\\treturn res if res>2 else 0",
                "solutionTags": [],
                "code": "Using Set to avoid duplicate efforts\\n\\n\\t\\tclass Solution:\\n\\t\\t\\tdef lenLongestFibSubseq(self, a: List[int]) -> int:\\n\\t\\t\\t\\ts = set(a)\\n\\t\\t\\t\\tn = len(a)\\n\\t\\t\\t\\tseen = set()\\n\\t\\t\\t\\tres = 0\\n\\n\\t\\t\\t\\tfor i in range(n-1):\\n\\t\\t\\t\\t\\tfor j in range(i+1,n):  \\n\\t\\t\\t\\t\\t\\tx,y = a[i],a[j] \\n\\t\\t\\t\\t\\t\\tans = 2 \\n\\t\\t\\t\\t\\t\\twhile (x,y) not in seen and x+y in s: \\n\\t\\t\\t\\t\\t\\t\\tseen.add((x,y))\\n\\t\\t\\t\\t\\t\\t\\tt = x \\n\\t\\t\\t\\t\\t\\t\\tx = y\\n\\t\\t\\t\\t\\t\\t\\ty = y+t\\n\\t\\t\\t\\t\\t\\t\\tans+=1 \\n\\t\\t\\t\\t\\t\\tres = max(ans,res)\\n\\n\\t\\t\\t\\treturn res if res>2 else 0",
                "codeTag": "Java"
            },
            {
                "id": 2732493,
                "title": "python-simple-solution-faster",
                "content": "*Italic*# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution:\\n    def lenLongestFibSubseq(self, arr: List[int]) -> int:\\n        arrset=set(arr)\\n        res=0\\n        for i in range(len(arr)):\\n            for j in range(i+1,len(arr)):\\n                a,b,l=arr[i],arr[j],2\\n                while(a+b in arrset):\\n                    a,b,l=b,a+b,l+1\\n                res=max(res,l)\\n        return res if res>=3 else 0\\n\\n                    \\n    \\n        \\n```",
                "solutionTags": [
                    "Python",
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def lenLongestFibSubseq(self, arr: List[int]) -> int:\\n        arrset=set(arr)\\n        res=0\\n        for i in range(len(arr)):\\n            for j in range(i+1,len(arr)):\\n                a,b,l=arr[i],arr[j],2\\n                while(a+b in arrset):\\n                    a,b,l=b,a+b,l+1\\n                res=max(res,l)\\n        return res if res>=3 else 0\\n\\n                    \\n    \\n        \\n```",
                "codeTag": "Java"
            },
            {
                "id": 2731850,
                "title": "easy-c-solution-using-set",
                "content": "```\\nclass Solution {\\npublic:\\n    int ans=0;\\n    int lenLongestFibSubseq(vector<int>& arr) \\n    {\\n       unordered_set<int>st(arr.begin(),arr.end());        \\n     \\n       vector<int>temp;\\n\\n       for(int i=0;i<arr.size();i++)\\n       {\\n         temp.clear();\\n         temp.push_back(arr[i]);\\n     \\n         for(int j=i+1;j<(arr.size());j++)\\n         {\\n            temp.push_back(arr[j]);\\n            int len=2;\\n            fun(st,temp,len,temp.size());\\n            if(len>2 and len>ans)\\n            {\\n                ans=len;\\n            }\\n            temp.pop_back();\\n         }\\n       }\\n       return ans;\\n    }\\n    void fun(unordered_set<int>&st,vector<int>&temp,int& len,int size)\\n    {\\n        while(st.find(temp[temp.size()-1]+temp[temp.size()-2])!=st.end())\\n        {\\n            len++;\\n            temp.push_back(temp[temp.size()-1]+temp[temp.size()-2]);\\n        }\\n        while(temp.size()>size)\\n        {\\n            temp.pop_back();\\n        }\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "C",
                    "Ordered Set"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int ans=0;\\n    int lenLongestFibSubseq(vector<int>& arr) \\n    {\\n       unordered_set<int>st(arr.begin(),arr.end());        \\n     \\n       vector<int>temp;\\n\\n       for(int i=0;i<arr.size();i++)\\n       {\\n         temp.clear();\\n         temp.push_back(arr[i]);\\n     \\n         for(int j=i+1;j<(arr.size());j++)\\n         {\\n            temp.push_back(arr[j]);\\n            int len=2;\\n            fun(st,temp,len,temp.size());\\n            if(len>2 and len>ans)\\n            {\\n                ans=len;\\n            }\\n            temp.pop_back();\\n         }\\n       }\\n       return ans;\\n    }\\n    void fun(unordered_set<int>&st,vector<int>&temp,int& len,int size)\\n    {\\n        while(st.find(temp[temp.size()-1]+temp[temp.size()-2])!=st.end())\\n        {\\n            len++;\\n            temp.push_back(temp[temp.size()-1]+temp[temp.size()-2]);\\n        }\\n        while(temp.size()>size)\\n        {\\n            temp.pop_back();\\n        }\\n    }\\n};\\n```",
                "codeTag": "Java"
            }
        ],
        "discussions": [
            {
                "id": 1573340,
                "content": [
                    {
                        "username": "stwe",
                        "content": "Hi everyone,\\n\\nmy code fails on the [2,4,7,8,9,10,14,15,18,23,32,50] testcase. It outputs 4 instead of the expected 5.\\nMy code finds the sequence 7, 8, 15, 23 as well as 14, 18, 32, 50. But I can\\'t find a sequence of length 5, not even by hand...\\n\\nOr did I not understand the task correctly?\\n\\nBest regards,\\nStefan"
                    },
                    {
                        "username": "harsha335",
                        "content": "[@as_97z2f](/as_97z2f) Thanks bro i figure out my problem . here is my solution of O(N^2*K) K-longest subsequence.\\n```class Solution {\\n    public int lenLongestFibSubseq(int[] arr) {\\n        int n=arr.length;\\n        HashMap<Integer,Integer> map=new HashMap<>();//(ele,index)\\n        for(int i=0;i<n;i++)\\n        {\\n            map.put(arr[i],i);\\n        }\\n        int output=0;\\n        for(int i=0;i<n;i++)\\n        {\\n            int pre1=arr[i];\\n            for(int j=i+1;j<n;j++)\\n            {\\n                int pre2=arr[j];\\n                int count=2;\\n                while(map.containsKey(pre1+pre2))\\n                {\\n                    count++;\\n                    int temp=pre1;\\n                    pre1=pre2;\\n                    pre2=temp+pre2;\\n                }\\n                pre1=arr[i];    //I MISSIED UPDATING PRE1 VALUE\\n                output=Math.max(output,count);\\n            }\\n        }\\n        return output==2?0:output;\\n    }\\n}```"
                    },
                    {
                        "username": "as_97z2f",
                        "content": "The 5 length sequence is `[4, 14, 18, 32, 50]` \\u2013 I\\'m stuck on the same case."
                    },
                    {
                        "username": "munishgoyal1",
                        "content": "This definitely should have been a hard problem"
                    },
                    {
                        "username": "gadmo",
                        "content": "if this is hard almost every single dp problem have to be hard. the whole solution is just one line of dp logic plus 2-sum mapping. "
                    },
                    {
                        "username": "r4dx",
                        "content": "I\\'ve came across this while debugging my solution (which is incorrect nonetheless :))"
                    },
                    {
                        "username": "wilderfield",
                        "content": "This one is hard right?\\n\\nHad to stare at the solution for a looooong time..."
                    },
                    {
                        "username": "bupt_wc",
                        "content": "https://buptwc.github.io/2018/07/22/Leetcode-873-Length-of-Longest-Fibonacci-Subsequence/\\nHope helpful!"
                    },
                    {
                        "username": "analoglife",
                        "content": "I have solved about 30-40 DP questions so far. i\\'m still having trouble with questions like these. what am i doing wrong? will i ever get better at these?"
                    },
                    {
                        "username": "gadmo",
                        "content": "It takes practice, it came to me about after this amount of problems where now i can solve this type consistently , there is a lot of BS out there, everyone telling you you only need a small amount of problems to master every topic. dp is not easy and doing 40+ of them makes sense. if its worth your time is a different question.\nmake sure to understand the solution and recreate it on your own, also try to find someone who is clear and not using m,n,k,r as variables names."
                    },
                    {
                        "username": "kamalkumar717",
                        "content": "class Solution {\\npublic:\\n    int lenLongestFibSubseq(vector<int>& arr) {\\n        \\n        int n = arr.size();\\n\\n        unordered_map<int, int> mp;\\n        vector<vector<int>> dp(n, vector<int>(n, 2));\\n\\n        for(int i=0; i<n; ++i) {\\n            mp[arr[i]] = i;\\n        }\\n\\n        int ans = 0;\\n        for(int right=2;right<n;right++)\\n        {\\n            for(int left =1;left<right;left++)\\n            {\\n                int diff = arr[right]- arr[left];\\n\\n                if(mp.count(diff))\\n                {\\n                    \\n                    dp[left][right] = max(dp[left][right],dp[mp[diff]][left] +1);\\n                    ans = max(ans,dp[left][right]);\\n                }\\n            }\\n        }\\n        return ans>2?ans:0;\\n    }\\n};\\n\\n\\n\\n\\nwhy not accepted???"
                    },
                    {
                        "username": "coder42032",
                        "content": "can you please convert this code into dp\\nclass Solution {\\npublic:\\n    int len = 0;\\n    void recur(vector<int>&arr,int i,int j,int k,int p){\\n        len = max(len,p);\\n        if(k>=arr.size()){\\n            return;\\n        }\\n        if(i+j==arr[k] || (i==0)){\\n            recur(arr,j,arr[k],k+1,p+1);\\n        }\\n        recur(arr,i,j,k+1,p);\\n    }\\n    int lenLongestFibSubseq(vector<int>& arr) {\\n        int n = arr.size();\\n        recur(arr,0,0,0,0);\\n        if(len<3)return 0;\\n        return len;\\n    }\\n};"
                    },
                    {
                        "username": "ymgcksge",
                        "content": "I think this code\\'s time complexity is o(n^2), but it causes TLE. Could anyone examine and explain? \\nsorry I don\\'t know how to embed the code here. I would like to know how to put code here as well. \\nThank you.\\n\\nclass Solution {\\npublic:\\n    int lenLongestFibSubseq(vector<int>& arr) {\\n        int n=arr.size();\\n        vector<vector<int>> dp(n,vector<int>(n,2));\\n        map<int,int> ind;\\n        for(int i=0;i<n;i++){\\n            ind[arr[i]]=i+1;\\n        }\\n        int ret=0;\\n        for(int i=0;i<n;i++){\\n            int now=arr[i];\\n            for(int j=0;j<i;j++){\\n                int k=ind[now-arr[j]];\\n                if(!k)continue;\\n                if(k-1<=j)break;\\n                dp[k-1][i]=dp[j][k-1]+1;\\n                ret=max(ret,dp[k-1][i]);\\n            }\\n        }\\n        return (ret>=3)?ret:0;\\n    }\\n};"
                    },
                    {
                        "username": "ymgcksge",
                        "content": "I think this code\\'s time complexity is O(n^2), but it causes TLE. Could anyone explain why?\\n\\nclass Solution {\\npublic:\\n    int lenLongestFibSubseq(vector<int>& arr) {\\n        int n=arr.size();\\n        vector<vector<int>> dp(n,vector<int>(n));\\n        map<int,int> ind;\\n        for(int i=0;i<n;i++){\\n            ind[arr[i]]=i+1;\\n            for(int j=0;j<n;j++){\\n                if(i==j)dp[i][j]=-1;\\n                else dp[i][j]=2;\\n            }\\n        }\\n        int ret=0;\\n        for(int i=0;i<n;i++){\\n            int now=arr[i];\\n            for(int j=0;j<i;j++){\\n                int k=ind[now-arr[j]];\\n                if(k&&k-1!=j)dp[max(k-1,j)][i]=dp[min(k-1,j)][max(k-1,j)]+1;\\n                ret=max(ret,dp[max(k-1,j)][i]);\\n            }\\n        }\\n        return (ret>=3)?ret:0;\\n    }\\n};"
                    },
                    {
                        "username": "Sas3y",
                        "content": "you embed your code with ``` (three backticks) at the start and end of your code, so 6 in total.\nalso your code doesnt compile for me, because you didnt include vector template parameter or size type, I guess you wanted to use vector\\<int\\>.\nbut going to your main question, I believe it is O(n^2) time, but you did use map instead of unordered_map, which is slower (just changing that bumped me 10 extra test cases for submission); you also used O(n^2) memory (your dp is n*n) and thus recorded more operations such as assignment\nbut then again, I'm not great at this thing, just decided to post my first comment :)"
                    }
                ]
            },
            {
                "id": 1574460,
                "content": [
                    {
                        "username": "stwe",
                        "content": "Hi everyone,\\n\\nmy code fails on the [2,4,7,8,9,10,14,15,18,23,32,50] testcase. It outputs 4 instead of the expected 5.\\nMy code finds the sequence 7, 8, 15, 23 as well as 14, 18, 32, 50. But I can\\'t find a sequence of length 5, not even by hand...\\n\\nOr did I not understand the task correctly?\\n\\nBest regards,\\nStefan"
                    },
                    {
                        "username": "harsha335",
                        "content": "[@as_97z2f](/as_97z2f) Thanks bro i figure out my problem . here is my solution of O(N^2*K) K-longest subsequence.\\n```class Solution {\\n    public int lenLongestFibSubseq(int[] arr) {\\n        int n=arr.length;\\n        HashMap<Integer,Integer> map=new HashMap<>();//(ele,index)\\n        for(int i=0;i<n;i++)\\n        {\\n            map.put(arr[i],i);\\n        }\\n        int output=0;\\n        for(int i=0;i<n;i++)\\n        {\\n            int pre1=arr[i];\\n            for(int j=i+1;j<n;j++)\\n            {\\n                int pre2=arr[j];\\n                int count=2;\\n                while(map.containsKey(pre1+pre2))\\n                {\\n                    count++;\\n                    int temp=pre1;\\n                    pre1=pre2;\\n                    pre2=temp+pre2;\\n                }\\n                pre1=arr[i];    //I MISSIED UPDATING PRE1 VALUE\\n                output=Math.max(output,count);\\n            }\\n        }\\n        return output==2?0:output;\\n    }\\n}```"
                    },
                    {
                        "username": "as_97z2f",
                        "content": "The 5 length sequence is `[4, 14, 18, 32, 50]` \\u2013 I\\'m stuck on the same case."
                    },
                    {
                        "username": "munishgoyal1",
                        "content": "This definitely should have been a hard problem"
                    },
                    {
                        "username": "gadmo",
                        "content": "if this is hard almost every single dp problem have to be hard. the whole solution is just one line of dp logic plus 2-sum mapping. "
                    },
                    {
                        "username": "r4dx",
                        "content": "I\\'ve came across this while debugging my solution (which is incorrect nonetheless :))"
                    },
                    {
                        "username": "wilderfield",
                        "content": "This one is hard right?\\n\\nHad to stare at the solution for a looooong time..."
                    },
                    {
                        "username": "bupt_wc",
                        "content": "https://buptwc.github.io/2018/07/22/Leetcode-873-Length-of-Longest-Fibonacci-Subsequence/\\nHope helpful!"
                    },
                    {
                        "username": "analoglife",
                        "content": "I have solved about 30-40 DP questions so far. i\\'m still having trouble with questions like these. what am i doing wrong? will i ever get better at these?"
                    },
                    {
                        "username": "gadmo",
                        "content": "It takes practice, it came to me about after this amount of problems where now i can solve this type consistently , there is a lot of BS out there, everyone telling you you only need a small amount of problems to master every topic. dp is not easy and doing 40+ of them makes sense. if its worth your time is a different question.\nmake sure to understand the solution and recreate it on your own, also try to find someone who is clear and not using m,n,k,r as variables names."
                    },
                    {
                        "username": "kamalkumar717",
                        "content": "class Solution {\\npublic:\\n    int lenLongestFibSubseq(vector<int>& arr) {\\n        \\n        int n = arr.size();\\n\\n        unordered_map<int, int> mp;\\n        vector<vector<int>> dp(n, vector<int>(n, 2));\\n\\n        for(int i=0; i<n; ++i) {\\n            mp[arr[i]] = i;\\n        }\\n\\n        int ans = 0;\\n        for(int right=2;right<n;right++)\\n        {\\n            for(int left =1;left<right;left++)\\n            {\\n                int diff = arr[right]- arr[left];\\n\\n                if(mp.count(diff))\\n                {\\n                    \\n                    dp[left][right] = max(dp[left][right],dp[mp[diff]][left] +1);\\n                    ans = max(ans,dp[left][right]);\\n                }\\n            }\\n        }\\n        return ans>2?ans:0;\\n    }\\n};\\n\\n\\n\\n\\nwhy not accepted???"
                    },
                    {
                        "username": "coder42032",
                        "content": "can you please convert this code into dp\\nclass Solution {\\npublic:\\n    int len = 0;\\n    void recur(vector<int>&arr,int i,int j,int k,int p){\\n        len = max(len,p);\\n        if(k>=arr.size()){\\n            return;\\n        }\\n        if(i+j==arr[k] || (i==0)){\\n            recur(arr,j,arr[k],k+1,p+1);\\n        }\\n        recur(arr,i,j,k+1,p);\\n    }\\n    int lenLongestFibSubseq(vector<int>& arr) {\\n        int n = arr.size();\\n        recur(arr,0,0,0,0);\\n        if(len<3)return 0;\\n        return len;\\n    }\\n};"
                    },
                    {
                        "username": "ymgcksge",
                        "content": "I think this code\\'s time complexity is o(n^2), but it causes TLE. Could anyone examine and explain? \\nsorry I don\\'t know how to embed the code here. I would like to know how to put code here as well. \\nThank you.\\n\\nclass Solution {\\npublic:\\n    int lenLongestFibSubseq(vector<int>& arr) {\\n        int n=arr.size();\\n        vector<vector<int>> dp(n,vector<int>(n,2));\\n        map<int,int> ind;\\n        for(int i=0;i<n;i++){\\n            ind[arr[i]]=i+1;\\n        }\\n        int ret=0;\\n        for(int i=0;i<n;i++){\\n            int now=arr[i];\\n            for(int j=0;j<i;j++){\\n                int k=ind[now-arr[j]];\\n                if(!k)continue;\\n                if(k-1<=j)break;\\n                dp[k-1][i]=dp[j][k-1]+1;\\n                ret=max(ret,dp[k-1][i]);\\n            }\\n        }\\n        return (ret>=3)?ret:0;\\n    }\\n};"
                    },
                    {
                        "username": "ymgcksge",
                        "content": "I think this code\\'s time complexity is O(n^2), but it causes TLE. Could anyone explain why?\\n\\nclass Solution {\\npublic:\\n    int lenLongestFibSubseq(vector<int>& arr) {\\n        int n=arr.size();\\n        vector<vector<int>> dp(n,vector<int>(n));\\n        map<int,int> ind;\\n        for(int i=0;i<n;i++){\\n            ind[arr[i]]=i+1;\\n            for(int j=0;j<n;j++){\\n                if(i==j)dp[i][j]=-1;\\n                else dp[i][j]=2;\\n            }\\n        }\\n        int ret=0;\\n        for(int i=0;i<n;i++){\\n            int now=arr[i];\\n            for(int j=0;j<i;j++){\\n                int k=ind[now-arr[j]];\\n                if(k&&k-1!=j)dp[max(k-1,j)][i]=dp[min(k-1,j)][max(k-1,j)]+1;\\n                ret=max(ret,dp[max(k-1,j)][i]);\\n            }\\n        }\\n        return (ret>=3)?ret:0;\\n    }\\n};"
                    },
                    {
                        "username": "Sas3y",
                        "content": "you embed your code with ``` (three backticks) at the start and end of your code, so 6 in total.\nalso your code doesnt compile for me, because you didnt include vector template parameter or size type, I guess you wanted to use vector\\<int\\>.\nbut going to your main question, I believe it is O(n^2) time, but you did use map instead of unordered_map, which is slower (just changing that bumped me 10 extra test cases for submission); you also used O(n^2) memory (your dp is n*n) and thus recorded more operations such as assignment\nbut then again, I'm not great at this thing, just decided to post my first comment :)"
                    }
                ]
            },
            {
                "id": 1573212,
                "content": [
                    {
                        "username": "stwe",
                        "content": "Hi everyone,\\n\\nmy code fails on the [2,4,7,8,9,10,14,15,18,23,32,50] testcase. It outputs 4 instead of the expected 5.\\nMy code finds the sequence 7, 8, 15, 23 as well as 14, 18, 32, 50. But I can\\'t find a sequence of length 5, not even by hand...\\n\\nOr did I not understand the task correctly?\\n\\nBest regards,\\nStefan"
                    },
                    {
                        "username": "harsha335",
                        "content": "[@as_97z2f](/as_97z2f) Thanks bro i figure out my problem . here is my solution of O(N^2*K) K-longest subsequence.\\n```class Solution {\\n    public int lenLongestFibSubseq(int[] arr) {\\n        int n=arr.length;\\n        HashMap<Integer,Integer> map=new HashMap<>();//(ele,index)\\n        for(int i=0;i<n;i++)\\n        {\\n            map.put(arr[i],i);\\n        }\\n        int output=0;\\n        for(int i=0;i<n;i++)\\n        {\\n            int pre1=arr[i];\\n            for(int j=i+1;j<n;j++)\\n            {\\n                int pre2=arr[j];\\n                int count=2;\\n                while(map.containsKey(pre1+pre2))\\n                {\\n                    count++;\\n                    int temp=pre1;\\n                    pre1=pre2;\\n                    pre2=temp+pre2;\\n                }\\n                pre1=arr[i];    //I MISSIED UPDATING PRE1 VALUE\\n                output=Math.max(output,count);\\n            }\\n        }\\n        return output==2?0:output;\\n    }\\n}```"
                    },
                    {
                        "username": "as_97z2f",
                        "content": "The 5 length sequence is `[4, 14, 18, 32, 50]` \\u2013 I\\'m stuck on the same case."
                    },
                    {
                        "username": "munishgoyal1",
                        "content": "This definitely should have been a hard problem"
                    },
                    {
                        "username": "gadmo",
                        "content": "if this is hard almost every single dp problem have to be hard. the whole solution is just one line of dp logic plus 2-sum mapping. "
                    },
                    {
                        "username": "r4dx",
                        "content": "I\\'ve came across this while debugging my solution (which is incorrect nonetheless :))"
                    },
                    {
                        "username": "wilderfield",
                        "content": "This one is hard right?\\n\\nHad to stare at the solution for a looooong time..."
                    },
                    {
                        "username": "bupt_wc",
                        "content": "https://buptwc.github.io/2018/07/22/Leetcode-873-Length-of-Longest-Fibonacci-Subsequence/\\nHope helpful!"
                    },
                    {
                        "username": "analoglife",
                        "content": "I have solved about 30-40 DP questions so far. i\\'m still having trouble with questions like these. what am i doing wrong? will i ever get better at these?"
                    },
                    {
                        "username": "gadmo",
                        "content": "It takes practice, it came to me about after this amount of problems where now i can solve this type consistently , there is a lot of BS out there, everyone telling you you only need a small amount of problems to master every topic. dp is not easy and doing 40+ of them makes sense. if its worth your time is a different question.\nmake sure to understand the solution and recreate it on your own, also try to find someone who is clear and not using m,n,k,r as variables names."
                    },
                    {
                        "username": "kamalkumar717",
                        "content": "class Solution {\\npublic:\\n    int lenLongestFibSubseq(vector<int>& arr) {\\n        \\n        int n = arr.size();\\n\\n        unordered_map<int, int> mp;\\n        vector<vector<int>> dp(n, vector<int>(n, 2));\\n\\n        for(int i=0; i<n; ++i) {\\n            mp[arr[i]] = i;\\n        }\\n\\n        int ans = 0;\\n        for(int right=2;right<n;right++)\\n        {\\n            for(int left =1;left<right;left++)\\n            {\\n                int diff = arr[right]- arr[left];\\n\\n                if(mp.count(diff))\\n                {\\n                    \\n                    dp[left][right] = max(dp[left][right],dp[mp[diff]][left] +1);\\n                    ans = max(ans,dp[left][right]);\\n                }\\n            }\\n        }\\n        return ans>2?ans:0;\\n    }\\n};\\n\\n\\n\\n\\nwhy not accepted???"
                    },
                    {
                        "username": "coder42032",
                        "content": "can you please convert this code into dp\\nclass Solution {\\npublic:\\n    int len = 0;\\n    void recur(vector<int>&arr,int i,int j,int k,int p){\\n        len = max(len,p);\\n        if(k>=arr.size()){\\n            return;\\n        }\\n        if(i+j==arr[k] || (i==0)){\\n            recur(arr,j,arr[k],k+1,p+1);\\n        }\\n        recur(arr,i,j,k+1,p);\\n    }\\n    int lenLongestFibSubseq(vector<int>& arr) {\\n        int n = arr.size();\\n        recur(arr,0,0,0,0);\\n        if(len<3)return 0;\\n        return len;\\n    }\\n};"
                    },
                    {
                        "username": "ymgcksge",
                        "content": "I think this code\\'s time complexity is o(n^2), but it causes TLE. Could anyone examine and explain? \\nsorry I don\\'t know how to embed the code here. I would like to know how to put code here as well. \\nThank you.\\n\\nclass Solution {\\npublic:\\n    int lenLongestFibSubseq(vector<int>& arr) {\\n        int n=arr.size();\\n        vector<vector<int>> dp(n,vector<int>(n,2));\\n        map<int,int> ind;\\n        for(int i=0;i<n;i++){\\n            ind[arr[i]]=i+1;\\n        }\\n        int ret=0;\\n        for(int i=0;i<n;i++){\\n            int now=arr[i];\\n            for(int j=0;j<i;j++){\\n                int k=ind[now-arr[j]];\\n                if(!k)continue;\\n                if(k-1<=j)break;\\n                dp[k-1][i]=dp[j][k-1]+1;\\n                ret=max(ret,dp[k-1][i]);\\n            }\\n        }\\n        return (ret>=3)?ret:0;\\n    }\\n};"
                    },
                    {
                        "username": "ymgcksge",
                        "content": "I think this code\\'s time complexity is O(n^2), but it causes TLE. Could anyone explain why?\\n\\nclass Solution {\\npublic:\\n    int lenLongestFibSubseq(vector<int>& arr) {\\n        int n=arr.size();\\n        vector<vector<int>> dp(n,vector<int>(n));\\n        map<int,int> ind;\\n        for(int i=0;i<n;i++){\\n            ind[arr[i]]=i+1;\\n            for(int j=0;j<n;j++){\\n                if(i==j)dp[i][j]=-1;\\n                else dp[i][j]=2;\\n            }\\n        }\\n        int ret=0;\\n        for(int i=0;i<n;i++){\\n            int now=arr[i];\\n            for(int j=0;j<i;j++){\\n                int k=ind[now-arr[j]];\\n                if(k&&k-1!=j)dp[max(k-1,j)][i]=dp[min(k-1,j)][max(k-1,j)]+1;\\n                ret=max(ret,dp[max(k-1,j)][i]);\\n            }\\n        }\\n        return (ret>=3)?ret:0;\\n    }\\n};"
                    },
                    {
                        "username": "Sas3y",
                        "content": "you embed your code with ``` (three backticks) at the start and end of your code, so 6 in total.\nalso your code doesnt compile for me, because you didnt include vector template parameter or size type, I guess you wanted to use vector\\<int\\>.\nbut going to your main question, I believe it is O(n^2) time, but you did use map instead of unordered_map, which is slower (just changing that bumped me 10 extra test cases for submission); you also used O(n^2) memory (your dp is n*n) and thus recorded more operations such as assignment\nbut then again, I'm not great at this thing, just decided to post my first comment :)"
                    }
                ]
            },
            {
                "id": 1575284,
                "content": [
                    {
                        "username": "stwe",
                        "content": "Hi everyone,\\n\\nmy code fails on the [2,4,7,8,9,10,14,15,18,23,32,50] testcase. It outputs 4 instead of the expected 5.\\nMy code finds the sequence 7, 8, 15, 23 as well as 14, 18, 32, 50. But I can\\'t find a sequence of length 5, not even by hand...\\n\\nOr did I not understand the task correctly?\\n\\nBest regards,\\nStefan"
                    },
                    {
                        "username": "harsha335",
                        "content": "[@as_97z2f](/as_97z2f) Thanks bro i figure out my problem . here is my solution of O(N^2*K) K-longest subsequence.\\n```class Solution {\\n    public int lenLongestFibSubseq(int[] arr) {\\n        int n=arr.length;\\n        HashMap<Integer,Integer> map=new HashMap<>();//(ele,index)\\n        for(int i=0;i<n;i++)\\n        {\\n            map.put(arr[i],i);\\n        }\\n        int output=0;\\n        for(int i=0;i<n;i++)\\n        {\\n            int pre1=arr[i];\\n            for(int j=i+1;j<n;j++)\\n            {\\n                int pre2=arr[j];\\n                int count=2;\\n                while(map.containsKey(pre1+pre2))\\n                {\\n                    count++;\\n                    int temp=pre1;\\n                    pre1=pre2;\\n                    pre2=temp+pre2;\\n                }\\n                pre1=arr[i];    //I MISSIED UPDATING PRE1 VALUE\\n                output=Math.max(output,count);\\n            }\\n        }\\n        return output==2?0:output;\\n    }\\n}```"
                    },
                    {
                        "username": "as_97z2f",
                        "content": "The 5 length sequence is `[4, 14, 18, 32, 50]` \\u2013 I\\'m stuck on the same case."
                    },
                    {
                        "username": "munishgoyal1",
                        "content": "This definitely should have been a hard problem"
                    },
                    {
                        "username": "gadmo",
                        "content": "if this is hard almost every single dp problem have to be hard. the whole solution is just one line of dp logic plus 2-sum mapping. "
                    },
                    {
                        "username": "r4dx",
                        "content": "I\\'ve came across this while debugging my solution (which is incorrect nonetheless :))"
                    },
                    {
                        "username": "wilderfield",
                        "content": "This one is hard right?\\n\\nHad to stare at the solution for a looooong time..."
                    },
                    {
                        "username": "bupt_wc",
                        "content": "https://buptwc.github.io/2018/07/22/Leetcode-873-Length-of-Longest-Fibonacci-Subsequence/\\nHope helpful!"
                    },
                    {
                        "username": "analoglife",
                        "content": "I have solved about 30-40 DP questions so far. i\\'m still having trouble with questions like these. what am i doing wrong? will i ever get better at these?"
                    },
                    {
                        "username": "gadmo",
                        "content": "It takes practice, it came to me about after this amount of problems where now i can solve this type consistently , there is a lot of BS out there, everyone telling you you only need a small amount of problems to master every topic. dp is not easy and doing 40+ of them makes sense. if its worth your time is a different question.\nmake sure to understand the solution and recreate it on your own, also try to find someone who is clear and not using m,n,k,r as variables names."
                    },
                    {
                        "username": "kamalkumar717",
                        "content": "class Solution {\\npublic:\\n    int lenLongestFibSubseq(vector<int>& arr) {\\n        \\n        int n = arr.size();\\n\\n        unordered_map<int, int> mp;\\n        vector<vector<int>> dp(n, vector<int>(n, 2));\\n\\n        for(int i=0; i<n; ++i) {\\n            mp[arr[i]] = i;\\n        }\\n\\n        int ans = 0;\\n        for(int right=2;right<n;right++)\\n        {\\n            for(int left =1;left<right;left++)\\n            {\\n                int diff = arr[right]- arr[left];\\n\\n                if(mp.count(diff))\\n                {\\n                    \\n                    dp[left][right] = max(dp[left][right],dp[mp[diff]][left] +1);\\n                    ans = max(ans,dp[left][right]);\\n                }\\n            }\\n        }\\n        return ans>2?ans:0;\\n    }\\n};\\n\\n\\n\\n\\nwhy not accepted???"
                    },
                    {
                        "username": "coder42032",
                        "content": "can you please convert this code into dp\\nclass Solution {\\npublic:\\n    int len = 0;\\n    void recur(vector<int>&arr,int i,int j,int k,int p){\\n        len = max(len,p);\\n        if(k>=arr.size()){\\n            return;\\n        }\\n        if(i+j==arr[k] || (i==0)){\\n            recur(arr,j,arr[k],k+1,p+1);\\n        }\\n        recur(arr,i,j,k+1,p);\\n    }\\n    int lenLongestFibSubseq(vector<int>& arr) {\\n        int n = arr.size();\\n        recur(arr,0,0,0,0);\\n        if(len<3)return 0;\\n        return len;\\n    }\\n};"
                    },
                    {
                        "username": "ymgcksge",
                        "content": "I think this code\\'s time complexity is o(n^2), but it causes TLE. Could anyone examine and explain? \\nsorry I don\\'t know how to embed the code here. I would like to know how to put code here as well. \\nThank you.\\n\\nclass Solution {\\npublic:\\n    int lenLongestFibSubseq(vector<int>& arr) {\\n        int n=arr.size();\\n        vector<vector<int>> dp(n,vector<int>(n,2));\\n        map<int,int> ind;\\n        for(int i=0;i<n;i++){\\n            ind[arr[i]]=i+1;\\n        }\\n        int ret=0;\\n        for(int i=0;i<n;i++){\\n            int now=arr[i];\\n            for(int j=0;j<i;j++){\\n                int k=ind[now-arr[j]];\\n                if(!k)continue;\\n                if(k-1<=j)break;\\n                dp[k-1][i]=dp[j][k-1]+1;\\n                ret=max(ret,dp[k-1][i]);\\n            }\\n        }\\n        return (ret>=3)?ret:0;\\n    }\\n};"
                    },
                    {
                        "username": "ymgcksge",
                        "content": "I think this code\\'s time complexity is O(n^2), but it causes TLE. Could anyone explain why?\\n\\nclass Solution {\\npublic:\\n    int lenLongestFibSubseq(vector<int>& arr) {\\n        int n=arr.size();\\n        vector<vector<int>> dp(n,vector<int>(n));\\n        map<int,int> ind;\\n        for(int i=0;i<n;i++){\\n            ind[arr[i]]=i+1;\\n            for(int j=0;j<n;j++){\\n                if(i==j)dp[i][j]=-1;\\n                else dp[i][j]=2;\\n            }\\n        }\\n        int ret=0;\\n        for(int i=0;i<n;i++){\\n            int now=arr[i];\\n            for(int j=0;j<i;j++){\\n                int k=ind[now-arr[j]];\\n                if(k&&k-1!=j)dp[max(k-1,j)][i]=dp[min(k-1,j)][max(k-1,j)]+1;\\n                ret=max(ret,dp[max(k-1,j)][i]);\\n            }\\n        }\\n        return (ret>=3)?ret:0;\\n    }\\n};"
                    },
                    {
                        "username": "Sas3y",
                        "content": "you embed your code with ``` (three backticks) at the start and end of your code, so 6 in total.\nalso your code doesnt compile for me, because you didnt include vector template parameter or size type, I guess you wanted to use vector\\<int\\>.\nbut going to your main question, I believe it is O(n^2) time, but you did use map instead of unordered_map, which is slower (just changing that bumped me 10 extra test cases for submission); you also used O(n^2) memory (your dp is n*n) and thus recorded more operations such as assignment\nbut then again, I'm not great at this thing, just decided to post my first comment :)"
                    }
                ]
            },
            {
                "id": 1569259,
                "content": [
                    {
                        "username": "stwe",
                        "content": "Hi everyone,\\n\\nmy code fails on the [2,4,7,8,9,10,14,15,18,23,32,50] testcase. It outputs 4 instead of the expected 5.\\nMy code finds the sequence 7, 8, 15, 23 as well as 14, 18, 32, 50. But I can\\'t find a sequence of length 5, not even by hand...\\n\\nOr did I not understand the task correctly?\\n\\nBest regards,\\nStefan"
                    },
                    {
                        "username": "harsha335",
                        "content": "[@as_97z2f](/as_97z2f) Thanks bro i figure out my problem . here is my solution of O(N^2*K) K-longest subsequence.\\n```class Solution {\\n    public int lenLongestFibSubseq(int[] arr) {\\n        int n=arr.length;\\n        HashMap<Integer,Integer> map=new HashMap<>();//(ele,index)\\n        for(int i=0;i<n;i++)\\n        {\\n            map.put(arr[i],i);\\n        }\\n        int output=0;\\n        for(int i=0;i<n;i++)\\n        {\\n            int pre1=arr[i];\\n            for(int j=i+1;j<n;j++)\\n            {\\n                int pre2=arr[j];\\n                int count=2;\\n                while(map.containsKey(pre1+pre2))\\n                {\\n                    count++;\\n                    int temp=pre1;\\n                    pre1=pre2;\\n                    pre2=temp+pre2;\\n                }\\n                pre1=arr[i];    //I MISSIED UPDATING PRE1 VALUE\\n                output=Math.max(output,count);\\n            }\\n        }\\n        return output==2?0:output;\\n    }\\n}```"
                    },
                    {
                        "username": "as_97z2f",
                        "content": "The 5 length sequence is `[4, 14, 18, 32, 50]` \\u2013 I\\'m stuck on the same case."
                    },
                    {
                        "username": "munishgoyal1",
                        "content": "This definitely should have been a hard problem"
                    },
                    {
                        "username": "gadmo",
                        "content": "if this is hard almost every single dp problem have to be hard. the whole solution is just one line of dp logic plus 2-sum mapping. "
                    },
                    {
                        "username": "r4dx",
                        "content": "I\\'ve came across this while debugging my solution (which is incorrect nonetheless :))"
                    },
                    {
                        "username": "wilderfield",
                        "content": "This one is hard right?\\n\\nHad to stare at the solution for a looooong time..."
                    },
                    {
                        "username": "bupt_wc",
                        "content": "https://buptwc.github.io/2018/07/22/Leetcode-873-Length-of-Longest-Fibonacci-Subsequence/\\nHope helpful!"
                    },
                    {
                        "username": "analoglife",
                        "content": "I have solved about 30-40 DP questions so far. i\\'m still having trouble with questions like these. what am i doing wrong? will i ever get better at these?"
                    },
                    {
                        "username": "gadmo",
                        "content": "It takes practice, it came to me about after this amount of problems where now i can solve this type consistently , there is a lot of BS out there, everyone telling you you only need a small amount of problems to master every topic. dp is not easy and doing 40+ of them makes sense. if its worth your time is a different question.\nmake sure to understand the solution and recreate it on your own, also try to find someone who is clear and not using m,n,k,r as variables names."
                    },
                    {
                        "username": "kamalkumar717",
                        "content": "class Solution {\\npublic:\\n    int lenLongestFibSubseq(vector<int>& arr) {\\n        \\n        int n = arr.size();\\n\\n        unordered_map<int, int> mp;\\n        vector<vector<int>> dp(n, vector<int>(n, 2));\\n\\n        for(int i=0; i<n; ++i) {\\n            mp[arr[i]] = i;\\n        }\\n\\n        int ans = 0;\\n        for(int right=2;right<n;right++)\\n        {\\n            for(int left =1;left<right;left++)\\n            {\\n                int diff = arr[right]- arr[left];\\n\\n                if(mp.count(diff))\\n                {\\n                    \\n                    dp[left][right] = max(dp[left][right],dp[mp[diff]][left] +1);\\n                    ans = max(ans,dp[left][right]);\\n                }\\n            }\\n        }\\n        return ans>2?ans:0;\\n    }\\n};\\n\\n\\n\\n\\nwhy not accepted???"
                    },
                    {
                        "username": "coder42032",
                        "content": "can you please convert this code into dp\\nclass Solution {\\npublic:\\n    int len = 0;\\n    void recur(vector<int>&arr,int i,int j,int k,int p){\\n        len = max(len,p);\\n        if(k>=arr.size()){\\n            return;\\n        }\\n        if(i+j==arr[k] || (i==0)){\\n            recur(arr,j,arr[k],k+1,p+1);\\n        }\\n        recur(arr,i,j,k+1,p);\\n    }\\n    int lenLongestFibSubseq(vector<int>& arr) {\\n        int n = arr.size();\\n        recur(arr,0,0,0,0);\\n        if(len<3)return 0;\\n        return len;\\n    }\\n};"
                    },
                    {
                        "username": "ymgcksge",
                        "content": "I think this code\\'s time complexity is o(n^2), but it causes TLE. Could anyone examine and explain? \\nsorry I don\\'t know how to embed the code here. I would like to know how to put code here as well. \\nThank you.\\n\\nclass Solution {\\npublic:\\n    int lenLongestFibSubseq(vector<int>& arr) {\\n        int n=arr.size();\\n        vector<vector<int>> dp(n,vector<int>(n,2));\\n        map<int,int> ind;\\n        for(int i=0;i<n;i++){\\n            ind[arr[i]]=i+1;\\n        }\\n        int ret=0;\\n        for(int i=0;i<n;i++){\\n            int now=arr[i];\\n            for(int j=0;j<i;j++){\\n                int k=ind[now-arr[j]];\\n                if(!k)continue;\\n                if(k-1<=j)break;\\n                dp[k-1][i]=dp[j][k-1]+1;\\n                ret=max(ret,dp[k-1][i]);\\n            }\\n        }\\n        return (ret>=3)?ret:0;\\n    }\\n};"
                    },
                    {
                        "username": "ymgcksge",
                        "content": "I think this code\\'s time complexity is O(n^2), but it causes TLE. Could anyone explain why?\\n\\nclass Solution {\\npublic:\\n    int lenLongestFibSubseq(vector<int>& arr) {\\n        int n=arr.size();\\n        vector<vector<int>> dp(n,vector<int>(n));\\n        map<int,int> ind;\\n        for(int i=0;i<n;i++){\\n            ind[arr[i]]=i+1;\\n            for(int j=0;j<n;j++){\\n                if(i==j)dp[i][j]=-1;\\n                else dp[i][j]=2;\\n            }\\n        }\\n        int ret=0;\\n        for(int i=0;i<n;i++){\\n            int now=arr[i];\\n            for(int j=0;j<i;j++){\\n                int k=ind[now-arr[j]];\\n                if(k&&k-1!=j)dp[max(k-1,j)][i]=dp[min(k-1,j)][max(k-1,j)]+1;\\n                ret=max(ret,dp[max(k-1,j)][i]);\\n            }\\n        }\\n        return (ret>=3)?ret:0;\\n    }\\n};"
                    },
                    {
                        "username": "Sas3y",
                        "content": "you embed your code with ``` (three backticks) at the start and end of your code, so 6 in total.\nalso your code doesnt compile for me, because you didnt include vector template parameter or size type, I guess you wanted to use vector\\<int\\>.\nbut going to your main question, I believe it is O(n^2) time, but you did use map instead of unordered_map, which is slower (just changing that bumped me 10 extra test cases for submission); you also used O(n^2) memory (your dp is n*n) and thus recorded more operations such as assignment\nbut then again, I'm not great at this thing, just decided to post my first comment :)"
                    }
                ]
            },
            {
                "id": 1574296,
                "content": [
                    {
                        "username": "stwe",
                        "content": "Hi everyone,\\n\\nmy code fails on the [2,4,7,8,9,10,14,15,18,23,32,50] testcase. It outputs 4 instead of the expected 5.\\nMy code finds the sequence 7, 8, 15, 23 as well as 14, 18, 32, 50. But I can\\'t find a sequence of length 5, not even by hand...\\n\\nOr did I not understand the task correctly?\\n\\nBest regards,\\nStefan"
                    },
                    {
                        "username": "harsha335",
                        "content": "[@as_97z2f](/as_97z2f) Thanks bro i figure out my problem . here is my solution of O(N^2*K) K-longest subsequence.\\n```class Solution {\\n    public int lenLongestFibSubseq(int[] arr) {\\n        int n=arr.length;\\n        HashMap<Integer,Integer> map=new HashMap<>();//(ele,index)\\n        for(int i=0;i<n;i++)\\n        {\\n            map.put(arr[i],i);\\n        }\\n        int output=0;\\n        for(int i=0;i<n;i++)\\n        {\\n            int pre1=arr[i];\\n            for(int j=i+1;j<n;j++)\\n            {\\n                int pre2=arr[j];\\n                int count=2;\\n                while(map.containsKey(pre1+pre2))\\n                {\\n                    count++;\\n                    int temp=pre1;\\n                    pre1=pre2;\\n                    pre2=temp+pre2;\\n                }\\n                pre1=arr[i];    //I MISSIED UPDATING PRE1 VALUE\\n                output=Math.max(output,count);\\n            }\\n        }\\n        return output==2?0:output;\\n    }\\n}```"
                    },
                    {
                        "username": "as_97z2f",
                        "content": "The 5 length sequence is `[4, 14, 18, 32, 50]` \\u2013 I\\'m stuck on the same case."
                    },
                    {
                        "username": "munishgoyal1",
                        "content": "This definitely should have been a hard problem"
                    },
                    {
                        "username": "gadmo",
                        "content": "if this is hard almost every single dp problem have to be hard. the whole solution is just one line of dp logic plus 2-sum mapping. "
                    },
                    {
                        "username": "r4dx",
                        "content": "I\\'ve came across this while debugging my solution (which is incorrect nonetheless :))"
                    },
                    {
                        "username": "wilderfield",
                        "content": "This one is hard right?\\n\\nHad to stare at the solution for a looooong time..."
                    },
                    {
                        "username": "bupt_wc",
                        "content": "https://buptwc.github.io/2018/07/22/Leetcode-873-Length-of-Longest-Fibonacci-Subsequence/\\nHope helpful!"
                    },
                    {
                        "username": "analoglife",
                        "content": "I have solved about 30-40 DP questions so far. i\\'m still having trouble with questions like these. what am i doing wrong? will i ever get better at these?"
                    },
                    {
                        "username": "gadmo",
                        "content": "It takes practice, it came to me about after this amount of problems where now i can solve this type consistently , there is a lot of BS out there, everyone telling you you only need a small amount of problems to master every topic. dp is not easy and doing 40+ of them makes sense. if its worth your time is a different question.\nmake sure to understand the solution and recreate it on your own, also try to find someone who is clear and not using m,n,k,r as variables names."
                    },
                    {
                        "username": "kamalkumar717",
                        "content": "class Solution {\\npublic:\\n    int lenLongestFibSubseq(vector<int>& arr) {\\n        \\n        int n = arr.size();\\n\\n        unordered_map<int, int> mp;\\n        vector<vector<int>> dp(n, vector<int>(n, 2));\\n\\n        for(int i=0; i<n; ++i) {\\n            mp[arr[i]] = i;\\n        }\\n\\n        int ans = 0;\\n        for(int right=2;right<n;right++)\\n        {\\n            for(int left =1;left<right;left++)\\n            {\\n                int diff = arr[right]- arr[left];\\n\\n                if(mp.count(diff))\\n                {\\n                    \\n                    dp[left][right] = max(dp[left][right],dp[mp[diff]][left] +1);\\n                    ans = max(ans,dp[left][right]);\\n                }\\n            }\\n        }\\n        return ans>2?ans:0;\\n    }\\n};\\n\\n\\n\\n\\nwhy not accepted???"
                    },
                    {
                        "username": "coder42032",
                        "content": "can you please convert this code into dp\\nclass Solution {\\npublic:\\n    int len = 0;\\n    void recur(vector<int>&arr,int i,int j,int k,int p){\\n        len = max(len,p);\\n        if(k>=arr.size()){\\n            return;\\n        }\\n        if(i+j==arr[k] || (i==0)){\\n            recur(arr,j,arr[k],k+1,p+1);\\n        }\\n        recur(arr,i,j,k+1,p);\\n    }\\n    int lenLongestFibSubseq(vector<int>& arr) {\\n        int n = arr.size();\\n        recur(arr,0,0,0,0);\\n        if(len<3)return 0;\\n        return len;\\n    }\\n};"
                    },
                    {
                        "username": "ymgcksge",
                        "content": "I think this code\\'s time complexity is o(n^2), but it causes TLE. Could anyone examine and explain? \\nsorry I don\\'t know how to embed the code here. I would like to know how to put code here as well. \\nThank you.\\n\\nclass Solution {\\npublic:\\n    int lenLongestFibSubseq(vector<int>& arr) {\\n        int n=arr.size();\\n        vector<vector<int>> dp(n,vector<int>(n,2));\\n        map<int,int> ind;\\n        for(int i=0;i<n;i++){\\n            ind[arr[i]]=i+1;\\n        }\\n        int ret=0;\\n        for(int i=0;i<n;i++){\\n            int now=arr[i];\\n            for(int j=0;j<i;j++){\\n                int k=ind[now-arr[j]];\\n                if(!k)continue;\\n                if(k-1<=j)break;\\n                dp[k-1][i]=dp[j][k-1]+1;\\n                ret=max(ret,dp[k-1][i]);\\n            }\\n        }\\n        return (ret>=3)?ret:0;\\n    }\\n};"
                    },
                    {
                        "username": "ymgcksge",
                        "content": "I think this code\\'s time complexity is O(n^2), but it causes TLE. Could anyone explain why?\\n\\nclass Solution {\\npublic:\\n    int lenLongestFibSubseq(vector<int>& arr) {\\n        int n=arr.size();\\n        vector<vector<int>> dp(n,vector<int>(n));\\n        map<int,int> ind;\\n        for(int i=0;i<n;i++){\\n            ind[arr[i]]=i+1;\\n            for(int j=0;j<n;j++){\\n                if(i==j)dp[i][j]=-1;\\n                else dp[i][j]=2;\\n            }\\n        }\\n        int ret=0;\\n        for(int i=0;i<n;i++){\\n            int now=arr[i];\\n            for(int j=0;j<i;j++){\\n                int k=ind[now-arr[j]];\\n                if(k&&k-1!=j)dp[max(k-1,j)][i]=dp[min(k-1,j)][max(k-1,j)]+1;\\n                ret=max(ret,dp[max(k-1,j)][i]);\\n            }\\n        }\\n        return (ret>=3)?ret:0;\\n    }\\n};"
                    },
                    {
                        "username": "Sas3y",
                        "content": "you embed your code with ``` (three backticks) at the start and end of your code, so 6 in total.\nalso your code doesnt compile for me, because you didnt include vector template parameter or size type, I guess you wanted to use vector\\<int\\>.\nbut going to your main question, I believe it is O(n^2) time, but you did use map instead of unordered_map, which is slower (just changing that bumped me 10 extra test cases for submission); you also used O(n^2) memory (your dp is n*n) and thus recorded more operations such as assignment\nbut then again, I'm not great at this thing, just decided to post my first comment :)"
                    }
                ]
            },
            {
                "id": 1945978,
                "content": [
                    {
                        "username": "stwe",
                        "content": "Hi everyone,\\n\\nmy code fails on the [2,4,7,8,9,10,14,15,18,23,32,50] testcase. It outputs 4 instead of the expected 5.\\nMy code finds the sequence 7, 8, 15, 23 as well as 14, 18, 32, 50. But I can\\'t find a sequence of length 5, not even by hand...\\n\\nOr did I not understand the task correctly?\\n\\nBest regards,\\nStefan"
                    },
                    {
                        "username": "harsha335",
                        "content": "[@as_97z2f](/as_97z2f) Thanks bro i figure out my problem . here is my solution of O(N^2*K) K-longest subsequence.\\n```class Solution {\\n    public int lenLongestFibSubseq(int[] arr) {\\n        int n=arr.length;\\n        HashMap<Integer,Integer> map=new HashMap<>();//(ele,index)\\n        for(int i=0;i<n;i++)\\n        {\\n            map.put(arr[i],i);\\n        }\\n        int output=0;\\n        for(int i=0;i<n;i++)\\n        {\\n            int pre1=arr[i];\\n            for(int j=i+1;j<n;j++)\\n            {\\n                int pre2=arr[j];\\n                int count=2;\\n                while(map.containsKey(pre1+pre2))\\n                {\\n                    count++;\\n                    int temp=pre1;\\n                    pre1=pre2;\\n                    pre2=temp+pre2;\\n                }\\n                pre1=arr[i];    //I MISSIED UPDATING PRE1 VALUE\\n                output=Math.max(output,count);\\n            }\\n        }\\n        return output==2?0:output;\\n    }\\n}```"
                    },
                    {
                        "username": "as_97z2f",
                        "content": "The 5 length sequence is `[4, 14, 18, 32, 50]` \\u2013 I\\'m stuck on the same case."
                    },
                    {
                        "username": "munishgoyal1",
                        "content": "This definitely should have been a hard problem"
                    },
                    {
                        "username": "gadmo",
                        "content": "if this is hard almost every single dp problem have to be hard. the whole solution is just one line of dp logic plus 2-sum mapping. "
                    },
                    {
                        "username": "r4dx",
                        "content": "I\\'ve came across this while debugging my solution (which is incorrect nonetheless :))"
                    },
                    {
                        "username": "wilderfield",
                        "content": "This one is hard right?\\n\\nHad to stare at the solution for a looooong time..."
                    },
                    {
                        "username": "bupt_wc",
                        "content": "https://buptwc.github.io/2018/07/22/Leetcode-873-Length-of-Longest-Fibonacci-Subsequence/\\nHope helpful!"
                    },
                    {
                        "username": "analoglife",
                        "content": "I have solved about 30-40 DP questions so far. i\\'m still having trouble with questions like these. what am i doing wrong? will i ever get better at these?"
                    },
                    {
                        "username": "gadmo",
                        "content": "It takes practice, it came to me about after this amount of problems where now i can solve this type consistently , there is a lot of BS out there, everyone telling you you only need a small amount of problems to master every topic. dp is not easy and doing 40+ of them makes sense. if its worth your time is a different question.\nmake sure to understand the solution and recreate it on your own, also try to find someone who is clear and not using m,n,k,r as variables names."
                    },
                    {
                        "username": "kamalkumar717",
                        "content": "class Solution {\\npublic:\\n    int lenLongestFibSubseq(vector<int>& arr) {\\n        \\n        int n = arr.size();\\n\\n        unordered_map<int, int> mp;\\n        vector<vector<int>> dp(n, vector<int>(n, 2));\\n\\n        for(int i=0; i<n; ++i) {\\n            mp[arr[i]] = i;\\n        }\\n\\n        int ans = 0;\\n        for(int right=2;right<n;right++)\\n        {\\n            for(int left =1;left<right;left++)\\n            {\\n                int diff = arr[right]- arr[left];\\n\\n                if(mp.count(diff))\\n                {\\n                    \\n                    dp[left][right] = max(dp[left][right],dp[mp[diff]][left] +1);\\n                    ans = max(ans,dp[left][right]);\\n                }\\n            }\\n        }\\n        return ans>2?ans:0;\\n    }\\n};\\n\\n\\n\\n\\nwhy not accepted???"
                    },
                    {
                        "username": "coder42032",
                        "content": "can you please convert this code into dp\\nclass Solution {\\npublic:\\n    int len = 0;\\n    void recur(vector<int>&arr,int i,int j,int k,int p){\\n        len = max(len,p);\\n        if(k>=arr.size()){\\n            return;\\n        }\\n        if(i+j==arr[k] || (i==0)){\\n            recur(arr,j,arr[k],k+1,p+1);\\n        }\\n        recur(arr,i,j,k+1,p);\\n    }\\n    int lenLongestFibSubseq(vector<int>& arr) {\\n        int n = arr.size();\\n        recur(arr,0,0,0,0);\\n        if(len<3)return 0;\\n        return len;\\n    }\\n};"
                    },
                    {
                        "username": "ymgcksge",
                        "content": "I think this code\\'s time complexity is o(n^2), but it causes TLE. Could anyone examine and explain? \\nsorry I don\\'t know how to embed the code here. I would like to know how to put code here as well. \\nThank you.\\n\\nclass Solution {\\npublic:\\n    int lenLongestFibSubseq(vector<int>& arr) {\\n        int n=arr.size();\\n        vector<vector<int>> dp(n,vector<int>(n,2));\\n        map<int,int> ind;\\n        for(int i=0;i<n;i++){\\n            ind[arr[i]]=i+1;\\n        }\\n        int ret=0;\\n        for(int i=0;i<n;i++){\\n            int now=arr[i];\\n            for(int j=0;j<i;j++){\\n                int k=ind[now-arr[j]];\\n                if(!k)continue;\\n                if(k-1<=j)break;\\n                dp[k-1][i]=dp[j][k-1]+1;\\n                ret=max(ret,dp[k-1][i]);\\n            }\\n        }\\n        return (ret>=3)?ret:0;\\n    }\\n};"
                    },
                    {
                        "username": "ymgcksge",
                        "content": "I think this code\\'s time complexity is O(n^2), but it causes TLE. Could anyone explain why?\\n\\nclass Solution {\\npublic:\\n    int lenLongestFibSubseq(vector<int>& arr) {\\n        int n=arr.size();\\n        vector<vector<int>> dp(n,vector<int>(n));\\n        map<int,int> ind;\\n        for(int i=0;i<n;i++){\\n            ind[arr[i]]=i+1;\\n            for(int j=0;j<n;j++){\\n                if(i==j)dp[i][j]=-1;\\n                else dp[i][j]=2;\\n            }\\n        }\\n        int ret=0;\\n        for(int i=0;i<n;i++){\\n            int now=arr[i];\\n            for(int j=0;j<i;j++){\\n                int k=ind[now-arr[j]];\\n                if(k&&k-1!=j)dp[max(k-1,j)][i]=dp[min(k-1,j)][max(k-1,j)]+1;\\n                ret=max(ret,dp[max(k-1,j)][i]);\\n            }\\n        }\\n        return (ret>=3)?ret:0;\\n    }\\n};"
                    },
                    {
                        "username": "Sas3y",
                        "content": "you embed your code with ``` (three backticks) at the start and end of your code, so 6 in total.\nalso your code doesnt compile for me, because you didnt include vector template parameter or size type, I guess you wanted to use vector\\<int\\>.\nbut going to your main question, I believe it is O(n^2) time, but you did use map instead of unordered_map, which is slower (just changing that bumped me 10 extra test cases for submission); you also used O(n^2) memory (your dp is n*n) and thus recorded more operations such as assignment\nbut then again, I'm not great at this thing, just decided to post my first comment :)"
                    }
                ]
            },
            {
                "id": 1870436,
                "content": [
                    {
                        "username": "stwe",
                        "content": "Hi everyone,\\n\\nmy code fails on the [2,4,7,8,9,10,14,15,18,23,32,50] testcase. It outputs 4 instead of the expected 5.\\nMy code finds the sequence 7, 8, 15, 23 as well as 14, 18, 32, 50. But I can\\'t find a sequence of length 5, not even by hand...\\n\\nOr did I not understand the task correctly?\\n\\nBest regards,\\nStefan"
                    },
                    {
                        "username": "harsha335",
                        "content": "[@as_97z2f](/as_97z2f) Thanks bro i figure out my problem . here is my solution of O(N^2*K) K-longest subsequence.\\n```class Solution {\\n    public int lenLongestFibSubseq(int[] arr) {\\n        int n=arr.length;\\n        HashMap<Integer,Integer> map=new HashMap<>();//(ele,index)\\n        for(int i=0;i<n;i++)\\n        {\\n            map.put(arr[i],i);\\n        }\\n        int output=0;\\n        for(int i=0;i<n;i++)\\n        {\\n            int pre1=arr[i];\\n            for(int j=i+1;j<n;j++)\\n            {\\n                int pre2=arr[j];\\n                int count=2;\\n                while(map.containsKey(pre1+pre2))\\n                {\\n                    count++;\\n                    int temp=pre1;\\n                    pre1=pre2;\\n                    pre2=temp+pre2;\\n                }\\n                pre1=arr[i];    //I MISSIED UPDATING PRE1 VALUE\\n                output=Math.max(output,count);\\n            }\\n        }\\n        return output==2?0:output;\\n    }\\n}```"
                    },
                    {
                        "username": "as_97z2f",
                        "content": "The 5 length sequence is `[4, 14, 18, 32, 50]` \\u2013 I\\'m stuck on the same case."
                    },
                    {
                        "username": "munishgoyal1",
                        "content": "This definitely should have been a hard problem"
                    },
                    {
                        "username": "gadmo",
                        "content": "if this is hard almost every single dp problem have to be hard. the whole solution is just one line of dp logic plus 2-sum mapping. "
                    },
                    {
                        "username": "r4dx",
                        "content": "I\\'ve came across this while debugging my solution (which is incorrect nonetheless :))"
                    },
                    {
                        "username": "wilderfield",
                        "content": "This one is hard right?\\n\\nHad to stare at the solution for a looooong time..."
                    },
                    {
                        "username": "bupt_wc",
                        "content": "https://buptwc.github.io/2018/07/22/Leetcode-873-Length-of-Longest-Fibonacci-Subsequence/\\nHope helpful!"
                    },
                    {
                        "username": "analoglife",
                        "content": "I have solved about 30-40 DP questions so far. i\\'m still having trouble with questions like these. what am i doing wrong? will i ever get better at these?"
                    },
                    {
                        "username": "gadmo",
                        "content": "It takes practice, it came to me about after this amount of problems where now i can solve this type consistently , there is a lot of BS out there, everyone telling you you only need a small amount of problems to master every topic. dp is not easy and doing 40+ of them makes sense. if its worth your time is a different question.\nmake sure to understand the solution and recreate it on your own, also try to find someone who is clear and not using m,n,k,r as variables names."
                    },
                    {
                        "username": "kamalkumar717",
                        "content": "class Solution {\\npublic:\\n    int lenLongestFibSubseq(vector<int>& arr) {\\n        \\n        int n = arr.size();\\n\\n        unordered_map<int, int> mp;\\n        vector<vector<int>> dp(n, vector<int>(n, 2));\\n\\n        for(int i=0; i<n; ++i) {\\n            mp[arr[i]] = i;\\n        }\\n\\n        int ans = 0;\\n        for(int right=2;right<n;right++)\\n        {\\n            for(int left =1;left<right;left++)\\n            {\\n                int diff = arr[right]- arr[left];\\n\\n                if(mp.count(diff))\\n                {\\n                    \\n                    dp[left][right] = max(dp[left][right],dp[mp[diff]][left] +1);\\n                    ans = max(ans,dp[left][right]);\\n                }\\n            }\\n        }\\n        return ans>2?ans:0;\\n    }\\n};\\n\\n\\n\\n\\nwhy not accepted???"
                    },
                    {
                        "username": "coder42032",
                        "content": "can you please convert this code into dp\\nclass Solution {\\npublic:\\n    int len = 0;\\n    void recur(vector<int>&arr,int i,int j,int k,int p){\\n        len = max(len,p);\\n        if(k>=arr.size()){\\n            return;\\n        }\\n        if(i+j==arr[k] || (i==0)){\\n            recur(arr,j,arr[k],k+1,p+1);\\n        }\\n        recur(arr,i,j,k+1,p);\\n    }\\n    int lenLongestFibSubseq(vector<int>& arr) {\\n        int n = arr.size();\\n        recur(arr,0,0,0,0);\\n        if(len<3)return 0;\\n        return len;\\n    }\\n};"
                    },
                    {
                        "username": "ymgcksge",
                        "content": "I think this code\\'s time complexity is o(n^2), but it causes TLE. Could anyone examine and explain? \\nsorry I don\\'t know how to embed the code here. I would like to know how to put code here as well. \\nThank you.\\n\\nclass Solution {\\npublic:\\n    int lenLongestFibSubseq(vector<int>& arr) {\\n        int n=arr.size();\\n        vector<vector<int>> dp(n,vector<int>(n,2));\\n        map<int,int> ind;\\n        for(int i=0;i<n;i++){\\n            ind[arr[i]]=i+1;\\n        }\\n        int ret=0;\\n        for(int i=0;i<n;i++){\\n            int now=arr[i];\\n            for(int j=0;j<i;j++){\\n                int k=ind[now-arr[j]];\\n                if(!k)continue;\\n                if(k-1<=j)break;\\n                dp[k-1][i]=dp[j][k-1]+1;\\n                ret=max(ret,dp[k-1][i]);\\n            }\\n        }\\n        return (ret>=3)?ret:0;\\n    }\\n};"
                    },
                    {
                        "username": "ymgcksge",
                        "content": "I think this code\\'s time complexity is O(n^2), but it causes TLE. Could anyone explain why?\\n\\nclass Solution {\\npublic:\\n    int lenLongestFibSubseq(vector<int>& arr) {\\n        int n=arr.size();\\n        vector<vector<int>> dp(n,vector<int>(n));\\n        map<int,int> ind;\\n        for(int i=0;i<n;i++){\\n            ind[arr[i]]=i+1;\\n            for(int j=0;j<n;j++){\\n                if(i==j)dp[i][j]=-1;\\n                else dp[i][j]=2;\\n            }\\n        }\\n        int ret=0;\\n        for(int i=0;i<n;i++){\\n            int now=arr[i];\\n            for(int j=0;j<i;j++){\\n                int k=ind[now-arr[j]];\\n                if(k&&k-1!=j)dp[max(k-1,j)][i]=dp[min(k-1,j)][max(k-1,j)]+1;\\n                ret=max(ret,dp[max(k-1,j)][i]);\\n            }\\n        }\\n        return (ret>=3)?ret:0;\\n    }\\n};"
                    },
                    {
                        "username": "Sas3y",
                        "content": "you embed your code with ``` (three backticks) at the start and end of your code, so 6 in total.\nalso your code doesnt compile for me, because you didnt include vector template parameter or size type, I guess you wanted to use vector\\<int\\>.\nbut going to your main question, I believe it is O(n^2) time, but you did use map instead of unordered_map, which is slower (just changing that bumped me 10 extra test cases for submission); you also used O(n^2) memory (your dp is n*n) and thus recorded more operations such as assignment\nbut then again, I'm not great at this thing, just decided to post my first comment :)"
                    }
                ]
            },
            {
                "id": 1739445,
                "content": [
                    {
                        "username": "stwe",
                        "content": "Hi everyone,\\n\\nmy code fails on the [2,4,7,8,9,10,14,15,18,23,32,50] testcase. It outputs 4 instead of the expected 5.\\nMy code finds the sequence 7, 8, 15, 23 as well as 14, 18, 32, 50. But I can\\'t find a sequence of length 5, not even by hand...\\n\\nOr did I not understand the task correctly?\\n\\nBest regards,\\nStefan"
                    },
                    {
                        "username": "harsha335",
                        "content": "[@as_97z2f](/as_97z2f) Thanks bro i figure out my problem . here is my solution of O(N^2*K) K-longest subsequence.\\n```class Solution {\\n    public int lenLongestFibSubseq(int[] arr) {\\n        int n=arr.length;\\n        HashMap<Integer,Integer> map=new HashMap<>();//(ele,index)\\n        for(int i=0;i<n;i++)\\n        {\\n            map.put(arr[i],i);\\n        }\\n        int output=0;\\n        for(int i=0;i<n;i++)\\n        {\\n            int pre1=arr[i];\\n            for(int j=i+1;j<n;j++)\\n            {\\n                int pre2=arr[j];\\n                int count=2;\\n                while(map.containsKey(pre1+pre2))\\n                {\\n                    count++;\\n                    int temp=pre1;\\n                    pre1=pre2;\\n                    pre2=temp+pre2;\\n                }\\n                pre1=arr[i];    //I MISSIED UPDATING PRE1 VALUE\\n                output=Math.max(output,count);\\n            }\\n        }\\n        return output==2?0:output;\\n    }\\n}```"
                    },
                    {
                        "username": "as_97z2f",
                        "content": "The 5 length sequence is `[4, 14, 18, 32, 50]` \\u2013 I\\'m stuck on the same case."
                    },
                    {
                        "username": "munishgoyal1",
                        "content": "This definitely should have been a hard problem"
                    },
                    {
                        "username": "gadmo",
                        "content": "if this is hard almost every single dp problem have to be hard. the whole solution is just one line of dp logic plus 2-sum mapping. "
                    },
                    {
                        "username": "r4dx",
                        "content": "I\\'ve came across this while debugging my solution (which is incorrect nonetheless :))"
                    },
                    {
                        "username": "wilderfield",
                        "content": "This one is hard right?\\n\\nHad to stare at the solution for a looooong time..."
                    },
                    {
                        "username": "bupt_wc",
                        "content": "https://buptwc.github.io/2018/07/22/Leetcode-873-Length-of-Longest-Fibonacci-Subsequence/\\nHope helpful!"
                    },
                    {
                        "username": "analoglife",
                        "content": "I have solved about 30-40 DP questions so far. i\\'m still having trouble with questions like these. what am i doing wrong? will i ever get better at these?"
                    },
                    {
                        "username": "gadmo",
                        "content": "It takes practice, it came to me about after this amount of problems where now i can solve this type consistently , there is a lot of BS out there, everyone telling you you only need a small amount of problems to master every topic. dp is not easy and doing 40+ of them makes sense. if its worth your time is a different question.\nmake sure to understand the solution and recreate it on your own, also try to find someone who is clear and not using m,n,k,r as variables names."
                    },
                    {
                        "username": "kamalkumar717",
                        "content": "class Solution {\\npublic:\\n    int lenLongestFibSubseq(vector<int>& arr) {\\n        \\n        int n = arr.size();\\n\\n        unordered_map<int, int> mp;\\n        vector<vector<int>> dp(n, vector<int>(n, 2));\\n\\n        for(int i=0; i<n; ++i) {\\n            mp[arr[i]] = i;\\n        }\\n\\n        int ans = 0;\\n        for(int right=2;right<n;right++)\\n        {\\n            for(int left =1;left<right;left++)\\n            {\\n                int diff = arr[right]- arr[left];\\n\\n                if(mp.count(diff))\\n                {\\n                    \\n                    dp[left][right] = max(dp[left][right],dp[mp[diff]][left] +1);\\n                    ans = max(ans,dp[left][right]);\\n                }\\n            }\\n        }\\n        return ans>2?ans:0;\\n    }\\n};\\n\\n\\n\\n\\nwhy not accepted???"
                    },
                    {
                        "username": "coder42032",
                        "content": "can you please convert this code into dp\\nclass Solution {\\npublic:\\n    int len = 0;\\n    void recur(vector<int>&arr,int i,int j,int k,int p){\\n        len = max(len,p);\\n        if(k>=arr.size()){\\n            return;\\n        }\\n        if(i+j==arr[k] || (i==0)){\\n            recur(arr,j,arr[k],k+1,p+1);\\n        }\\n        recur(arr,i,j,k+1,p);\\n    }\\n    int lenLongestFibSubseq(vector<int>& arr) {\\n        int n = arr.size();\\n        recur(arr,0,0,0,0);\\n        if(len<3)return 0;\\n        return len;\\n    }\\n};"
                    },
                    {
                        "username": "ymgcksge",
                        "content": "I think this code\\'s time complexity is o(n^2), but it causes TLE. Could anyone examine and explain? \\nsorry I don\\'t know how to embed the code here. I would like to know how to put code here as well. \\nThank you.\\n\\nclass Solution {\\npublic:\\n    int lenLongestFibSubseq(vector<int>& arr) {\\n        int n=arr.size();\\n        vector<vector<int>> dp(n,vector<int>(n,2));\\n        map<int,int> ind;\\n        for(int i=0;i<n;i++){\\n            ind[arr[i]]=i+1;\\n        }\\n        int ret=0;\\n        for(int i=0;i<n;i++){\\n            int now=arr[i];\\n            for(int j=0;j<i;j++){\\n                int k=ind[now-arr[j]];\\n                if(!k)continue;\\n                if(k-1<=j)break;\\n                dp[k-1][i]=dp[j][k-1]+1;\\n                ret=max(ret,dp[k-1][i]);\\n            }\\n        }\\n        return (ret>=3)?ret:0;\\n    }\\n};"
                    },
                    {
                        "username": "ymgcksge",
                        "content": "I think this code\\'s time complexity is O(n^2), but it causes TLE. Could anyone explain why?\\n\\nclass Solution {\\npublic:\\n    int lenLongestFibSubseq(vector<int>& arr) {\\n        int n=arr.size();\\n        vector<vector<int>> dp(n,vector<int>(n));\\n        map<int,int> ind;\\n        for(int i=0;i<n;i++){\\n            ind[arr[i]]=i+1;\\n            for(int j=0;j<n;j++){\\n                if(i==j)dp[i][j]=-1;\\n                else dp[i][j]=2;\\n            }\\n        }\\n        int ret=0;\\n        for(int i=0;i<n;i++){\\n            int now=arr[i];\\n            for(int j=0;j<i;j++){\\n                int k=ind[now-arr[j]];\\n                if(k&&k-1!=j)dp[max(k-1,j)][i]=dp[min(k-1,j)][max(k-1,j)]+1;\\n                ret=max(ret,dp[max(k-1,j)][i]);\\n            }\\n        }\\n        return (ret>=3)?ret:0;\\n    }\\n};"
                    },
                    {
                        "username": "Sas3y",
                        "content": "you embed your code with ``` (three backticks) at the start and end of your code, so 6 in total.\nalso your code doesnt compile for me, because you didnt include vector template parameter or size type, I guess you wanted to use vector\\<int\\>.\nbut going to your main question, I believe it is O(n^2) time, but you did use map instead of unordered_map, which is slower (just changing that bumped me 10 extra test cases for submission); you also used O(n^2) memory (your dp is n*n) and thus recorded more operations such as assignment\nbut then again, I'm not great at this thing, just decided to post my first comment :)"
                    }
                ]
            },
            {
                "id": 1739420,
                "content": [
                    {
                        "username": "stwe",
                        "content": "Hi everyone,\\n\\nmy code fails on the [2,4,7,8,9,10,14,15,18,23,32,50] testcase. It outputs 4 instead of the expected 5.\\nMy code finds the sequence 7, 8, 15, 23 as well as 14, 18, 32, 50. But I can\\'t find a sequence of length 5, not even by hand...\\n\\nOr did I not understand the task correctly?\\n\\nBest regards,\\nStefan"
                    },
                    {
                        "username": "harsha335",
                        "content": "[@as_97z2f](/as_97z2f) Thanks bro i figure out my problem . here is my solution of O(N^2*K) K-longest subsequence.\\n```class Solution {\\n    public int lenLongestFibSubseq(int[] arr) {\\n        int n=arr.length;\\n        HashMap<Integer,Integer> map=new HashMap<>();//(ele,index)\\n        for(int i=0;i<n;i++)\\n        {\\n            map.put(arr[i],i);\\n        }\\n        int output=0;\\n        for(int i=0;i<n;i++)\\n        {\\n            int pre1=arr[i];\\n            for(int j=i+1;j<n;j++)\\n            {\\n                int pre2=arr[j];\\n                int count=2;\\n                while(map.containsKey(pre1+pre2))\\n                {\\n                    count++;\\n                    int temp=pre1;\\n                    pre1=pre2;\\n                    pre2=temp+pre2;\\n                }\\n                pre1=arr[i];    //I MISSIED UPDATING PRE1 VALUE\\n                output=Math.max(output,count);\\n            }\\n        }\\n        return output==2?0:output;\\n    }\\n}```"
                    },
                    {
                        "username": "as_97z2f",
                        "content": "The 5 length sequence is `[4, 14, 18, 32, 50]` \\u2013 I\\'m stuck on the same case."
                    },
                    {
                        "username": "munishgoyal1",
                        "content": "This definitely should have been a hard problem"
                    },
                    {
                        "username": "gadmo",
                        "content": "if this is hard almost every single dp problem have to be hard. the whole solution is just one line of dp logic plus 2-sum mapping. "
                    },
                    {
                        "username": "r4dx",
                        "content": "I\\'ve came across this while debugging my solution (which is incorrect nonetheless :))"
                    },
                    {
                        "username": "wilderfield",
                        "content": "This one is hard right?\\n\\nHad to stare at the solution for a looooong time..."
                    },
                    {
                        "username": "bupt_wc",
                        "content": "https://buptwc.github.io/2018/07/22/Leetcode-873-Length-of-Longest-Fibonacci-Subsequence/\\nHope helpful!"
                    },
                    {
                        "username": "analoglife",
                        "content": "I have solved about 30-40 DP questions so far. i\\'m still having trouble with questions like these. what am i doing wrong? will i ever get better at these?"
                    },
                    {
                        "username": "gadmo",
                        "content": "It takes practice, it came to me about after this amount of problems where now i can solve this type consistently , there is a lot of BS out there, everyone telling you you only need a small amount of problems to master every topic. dp is not easy and doing 40+ of them makes sense. if its worth your time is a different question.\nmake sure to understand the solution and recreate it on your own, also try to find someone who is clear and not using m,n,k,r as variables names."
                    },
                    {
                        "username": "kamalkumar717",
                        "content": "class Solution {\\npublic:\\n    int lenLongestFibSubseq(vector<int>& arr) {\\n        \\n        int n = arr.size();\\n\\n        unordered_map<int, int> mp;\\n        vector<vector<int>> dp(n, vector<int>(n, 2));\\n\\n        for(int i=0; i<n; ++i) {\\n            mp[arr[i]] = i;\\n        }\\n\\n        int ans = 0;\\n        for(int right=2;right<n;right++)\\n        {\\n            for(int left =1;left<right;left++)\\n            {\\n                int diff = arr[right]- arr[left];\\n\\n                if(mp.count(diff))\\n                {\\n                    \\n                    dp[left][right] = max(dp[left][right],dp[mp[diff]][left] +1);\\n                    ans = max(ans,dp[left][right]);\\n                }\\n            }\\n        }\\n        return ans>2?ans:0;\\n    }\\n};\\n\\n\\n\\n\\nwhy not accepted???"
                    },
                    {
                        "username": "coder42032",
                        "content": "can you please convert this code into dp\\nclass Solution {\\npublic:\\n    int len = 0;\\n    void recur(vector<int>&arr,int i,int j,int k,int p){\\n        len = max(len,p);\\n        if(k>=arr.size()){\\n            return;\\n        }\\n        if(i+j==arr[k] || (i==0)){\\n            recur(arr,j,arr[k],k+1,p+1);\\n        }\\n        recur(arr,i,j,k+1,p);\\n    }\\n    int lenLongestFibSubseq(vector<int>& arr) {\\n        int n = arr.size();\\n        recur(arr,0,0,0,0);\\n        if(len<3)return 0;\\n        return len;\\n    }\\n};"
                    },
                    {
                        "username": "ymgcksge",
                        "content": "I think this code\\'s time complexity is o(n^2), but it causes TLE. Could anyone examine and explain? \\nsorry I don\\'t know how to embed the code here. I would like to know how to put code here as well. \\nThank you.\\n\\nclass Solution {\\npublic:\\n    int lenLongestFibSubseq(vector<int>& arr) {\\n        int n=arr.size();\\n        vector<vector<int>> dp(n,vector<int>(n,2));\\n        map<int,int> ind;\\n        for(int i=0;i<n;i++){\\n            ind[arr[i]]=i+1;\\n        }\\n        int ret=0;\\n        for(int i=0;i<n;i++){\\n            int now=arr[i];\\n            for(int j=0;j<i;j++){\\n                int k=ind[now-arr[j]];\\n                if(!k)continue;\\n                if(k-1<=j)break;\\n                dp[k-1][i]=dp[j][k-1]+1;\\n                ret=max(ret,dp[k-1][i]);\\n            }\\n        }\\n        return (ret>=3)?ret:0;\\n    }\\n};"
                    },
                    {
                        "username": "ymgcksge",
                        "content": "I think this code\\'s time complexity is O(n^2), but it causes TLE. Could anyone explain why?\\n\\nclass Solution {\\npublic:\\n    int lenLongestFibSubseq(vector<int>& arr) {\\n        int n=arr.size();\\n        vector<vector<int>> dp(n,vector<int>(n));\\n        map<int,int> ind;\\n        for(int i=0;i<n;i++){\\n            ind[arr[i]]=i+1;\\n            for(int j=0;j<n;j++){\\n                if(i==j)dp[i][j]=-1;\\n                else dp[i][j]=2;\\n            }\\n        }\\n        int ret=0;\\n        for(int i=0;i<n;i++){\\n            int now=arr[i];\\n            for(int j=0;j<i;j++){\\n                int k=ind[now-arr[j]];\\n                if(k&&k-1!=j)dp[max(k-1,j)][i]=dp[min(k-1,j)][max(k-1,j)]+1;\\n                ret=max(ret,dp[max(k-1,j)][i]);\\n            }\\n        }\\n        return (ret>=3)?ret:0;\\n    }\\n};"
                    },
                    {
                        "username": "Sas3y",
                        "content": "you embed your code with ``` (three backticks) at the start and end of your code, so 6 in total.\nalso your code doesnt compile for me, because you didnt include vector template parameter or size type, I guess you wanted to use vector\\<int\\>.\nbut going to your main question, I believe it is O(n^2) time, but you did use map instead of unordered_map, which is slower (just changing that bumped me 10 extra test cases for submission); you also used O(n^2) memory (your dp is n*n) and thus recorded more operations such as assignment\nbut then again, I'm not great at this thing, just decided to post my first comment :)"
                    }
                ]
            },
            {
                "id": 1573340,
                "content": [
                    {
                        "username": "stwe",
                        "content": "Hi everyone,\\n\\nmy code fails on the [2,4,7,8,9,10,14,15,18,23,32,50] testcase. It outputs 4 instead of the expected 5.\\nMy code finds the sequence 7, 8, 15, 23 as well as 14, 18, 32, 50. But I can\\'t find a sequence of length 5, not even by hand...\\n\\nOr did I not understand the task correctly?\\n\\nBest regards,\\nStefan"
                    },
                    {
                        "username": "harsha335",
                        "content": "[@as_97z2f](/as_97z2f) Thanks bro i figure out my problem . here is my solution of O(N^2*K) K-longest subsequence.\\n```class Solution {\\n    public int lenLongestFibSubseq(int[] arr) {\\n        int n=arr.length;\\n        HashMap<Integer,Integer> map=new HashMap<>();//(ele,index)\\n        for(int i=0;i<n;i++)\\n        {\\n            map.put(arr[i],i);\\n        }\\n        int output=0;\\n        for(int i=0;i<n;i++)\\n        {\\n            int pre1=arr[i];\\n            for(int j=i+1;j<n;j++)\\n            {\\n                int pre2=arr[j];\\n                int count=2;\\n                while(map.containsKey(pre1+pre2))\\n                {\\n                    count++;\\n                    int temp=pre1;\\n                    pre1=pre2;\\n                    pre2=temp+pre2;\\n                }\\n                pre1=arr[i];    //I MISSIED UPDATING PRE1 VALUE\\n                output=Math.max(output,count);\\n            }\\n        }\\n        return output==2?0:output;\\n    }\\n}```"
                    },
                    {
                        "username": "as_97z2f",
                        "content": "The 5 length sequence is `[4, 14, 18, 32, 50]` \\u2013 I\\'m stuck on the same case."
                    },
                    {
                        "username": "munishgoyal1",
                        "content": "This definitely should have been a hard problem"
                    },
                    {
                        "username": "gadmo",
                        "content": "if this is hard almost every single dp problem have to be hard. the whole solution is just one line of dp logic plus 2-sum mapping. "
                    },
                    {
                        "username": "r4dx",
                        "content": "I\\'ve came across this while debugging my solution (which is incorrect nonetheless :))"
                    },
                    {
                        "username": "wilderfield",
                        "content": "This one is hard right?\\n\\nHad to stare at the solution for a looooong time..."
                    },
                    {
                        "username": "bupt_wc",
                        "content": "https://buptwc.github.io/2018/07/22/Leetcode-873-Length-of-Longest-Fibonacci-Subsequence/\\nHope helpful!"
                    },
                    {
                        "username": "analoglife",
                        "content": "I have solved about 30-40 DP questions so far. i\\'m still having trouble with questions like these. what am i doing wrong? will i ever get better at these?"
                    },
                    {
                        "username": "gadmo",
                        "content": "It takes practice, it came to me about after this amount of problems where now i can solve this type consistently , there is a lot of BS out there, everyone telling you you only need a small amount of problems to master every topic. dp is not easy and doing 40+ of them makes sense. if its worth your time is a different question.\nmake sure to understand the solution and recreate it on your own, also try to find someone who is clear and not using m,n,k,r as variables names."
                    },
                    {
                        "username": "kamalkumar717",
                        "content": "class Solution {\\npublic:\\n    int lenLongestFibSubseq(vector<int>& arr) {\\n        \\n        int n = arr.size();\\n\\n        unordered_map<int, int> mp;\\n        vector<vector<int>> dp(n, vector<int>(n, 2));\\n\\n        for(int i=0; i<n; ++i) {\\n            mp[arr[i]] = i;\\n        }\\n\\n        int ans = 0;\\n        for(int right=2;right<n;right++)\\n        {\\n            for(int left =1;left<right;left++)\\n            {\\n                int diff = arr[right]- arr[left];\\n\\n                if(mp.count(diff))\\n                {\\n                    \\n                    dp[left][right] = max(dp[left][right],dp[mp[diff]][left] +1);\\n                    ans = max(ans,dp[left][right]);\\n                }\\n            }\\n        }\\n        return ans>2?ans:0;\\n    }\\n};\\n\\n\\n\\n\\nwhy not accepted???"
                    },
                    {
                        "username": "coder42032",
                        "content": "can you please convert this code into dp\\nclass Solution {\\npublic:\\n    int len = 0;\\n    void recur(vector<int>&arr,int i,int j,int k,int p){\\n        len = max(len,p);\\n        if(k>=arr.size()){\\n            return;\\n        }\\n        if(i+j==arr[k] || (i==0)){\\n            recur(arr,j,arr[k],k+1,p+1);\\n        }\\n        recur(arr,i,j,k+1,p);\\n    }\\n    int lenLongestFibSubseq(vector<int>& arr) {\\n        int n = arr.size();\\n        recur(arr,0,0,0,0);\\n        if(len<3)return 0;\\n        return len;\\n    }\\n};"
                    },
                    {
                        "username": "ymgcksge",
                        "content": "I think this code\\'s time complexity is o(n^2), but it causes TLE. Could anyone examine and explain? \\nsorry I don\\'t know how to embed the code here. I would like to know how to put code here as well. \\nThank you.\\n\\nclass Solution {\\npublic:\\n    int lenLongestFibSubseq(vector<int>& arr) {\\n        int n=arr.size();\\n        vector<vector<int>> dp(n,vector<int>(n,2));\\n        map<int,int> ind;\\n        for(int i=0;i<n;i++){\\n            ind[arr[i]]=i+1;\\n        }\\n        int ret=0;\\n        for(int i=0;i<n;i++){\\n            int now=arr[i];\\n            for(int j=0;j<i;j++){\\n                int k=ind[now-arr[j]];\\n                if(!k)continue;\\n                if(k-1<=j)break;\\n                dp[k-1][i]=dp[j][k-1]+1;\\n                ret=max(ret,dp[k-1][i]);\\n            }\\n        }\\n        return (ret>=3)?ret:0;\\n    }\\n};"
                    },
                    {
                        "username": "ymgcksge",
                        "content": "I think this code\\'s time complexity is O(n^2), but it causes TLE. Could anyone explain why?\\n\\nclass Solution {\\npublic:\\n    int lenLongestFibSubseq(vector<int>& arr) {\\n        int n=arr.size();\\n        vector<vector<int>> dp(n,vector<int>(n));\\n        map<int,int> ind;\\n        for(int i=0;i<n;i++){\\n            ind[arr[i]]=i+1;\\n            for(int j=0;j<n;j++){\\n                if(i==j)dp[i][j]=-1;\\n                else dp[i][j]=2;\\n            }\\n        }\\n        int ret=0;\\n        for(int i=0;i<n;i++){\\n            int now=arr[i];\\n            for(int j=0;j<i;j++){\\n                int k=ind[now-arr[j]];\\n                if(k&&k-1!=j)dp[max(k-1,j)][i]=dp[min(k-1,j)][max(k-1,j)]+1;\\n                ret=max(ret,dp[max(k-1,j)][i]);\\n            }\\n        }\\n        return (ret>=3)?ret:0;\\n    }\\n};"
                    },
                    {
                        "username": "Sas3y",
                        "content": "you embed your code with ``` (three backticks) at the start and end of your code, so 6 in total.\nalso your code doesnt compile for me, because you didnt include vector template parameter or size type, I guess you wanted to use vector\\<int\\>.\nbut going to your main question, I believe it is O(n^2) time, but you did use map instead of unordered_map, which is slower (just changing that bumped me 10 extra test cases for submission); you also used O(n^2) memory (your dp is n*n) and thus recorded more operations such as assignment\nbut then again, I'm not great at this thing, just decided to post my first comment :)"
                    }
                ]
            },
            {
                "id": 1574460,
                "content": [
                    {
                        "username": "stwe",
                        "content": "Hi everyone,\\n\\nmy code fails on the [2,4,7,8,9,10,14,15,18,23,32,50] testcase. It outputs 4 instead of the expected 5.\\nMy code finds the sequence 7, 8, 15, 23 as well as 14, 18, 32, 50. But I can\\'t find a sequence of length 5, not even by hand...\\n\\nOr did I not understand the task correctly?\\n\\nBest regards,\\nStefan"
                    },
                    {
                        "username": "harsha335",
                        "content": "[@as_97z2f](/as_97z2f) Thanks bro i figure out my problem . here is my solution of O(N^2*K) K-longest subsequence.\\n```class Solution {\\n    public int lenLongestFibSubseq(int[] arr) {\\n        int n=arr.length;\\n        HashMap<Integer,Integer> map=new HashMap<>();//(ele,index)\\n        for(int i=0;i<n;i++)\\n        {\\n            map.put(arr[i],i);\\n        }\\n        int output=0;\\n        for(int i=0;i<n;i++)\\n        {\\n            int pre1=arr[i];\\n            for(int j=i+1;j<n;j++)\\n            {\\n                int pre2=arr[j];\\n                int count=2;\\n                while(map.containsKey(pre1+pre2))\\n                {\\n                    count++;\\n                    int temp=pre1;\\n                    pre1=pre2;\\n                    pre2=temp+pre2;\\n                }\\n                pre1=arr[i];    //I MISSIED UPDATING PRE1 VALUE\\n                output=Math.max(output,count);\\n            }\\n        }\\n        return output==2?0:output;\\n    }\\n}```"
                    },
                    {
                        "username": "as_97z2f",
                        "content": "The 5 length sequence is `[4, 14, 18, 32, 50]` \\u2013 I\\'m stuck on the same case."
                    },
                    {
                        "username": "munishgoyal1",
                        "content": "This definitely should have been a hard problem"
                    },
                    {
                        "username": "gadmo",
                        "content": "if this is hard almost every single dp problem have to be hard. the whole solution is just one line of dp logic plus 2-sum mapping. "
                    },
                    {
                        "username": "r4dx",
                        "content": "I\\'ve came across this while debugging my solution (which is incorrect nonetheless :))"
                    },
                    {
                        "username": "wilderfield",
                        "content": "This one is hard right?\\n\\nHad to stare at the solution for a looooong time..."
                    },
                    {
                        "username": "bupt_wc",
                        "content": "https://buptwc.github.io/2018/07/22/Leetcode-873-Length-of-Longest-Fibonacci-Subsequence/\\nHope helpful!"
                    },
                    {
                        "username": "analoglife",
                        "content": "I have solved about 30-40 DP questions so far. i\\'m still having trouble with questions like these. what am i doing wrong? will i ever get better at these?"
                    },
                    {
                        "username": "gadmo",
                        "content": "It takes practice, it came to me about after this amount of problems where now i can solve this type consistently , there is a lot of BS out there, everyone telling you you only need a small amount of problems to master every topic. dp is not easy and doing 40+ of them makes sense. if its worth your time is a different question.\nmake sure to understand the solution and recreate it on your own, also try to find someone who is clear and not using m,n,k,r as variables names."
                    },
                    {
                        "username": "kamalkumar717",
                        "content": "class Solution {\\npublic:\\n    int lenLongestFibSubseq(vector<int>& arr) {\\n        \\n        int n = arr.size();\\n\\n        unordered_map<int, int> mp;\\n        vector<vector<int>> dp(n, vector<int>(n, 2));\\n\\n        for(int i=0; i<n; ++i) {\\n            mp[arr[i]] = i;\\n        }\\n\\n        int ans = 0;\\n        for(int right=2;right<n;right++)\\n        {\\n            for(int left =1;left<right;left++)\\n            {\\n                int diff = arr[right]- arr[left];\\n\\n                if(mp.count(diff))\\n                {\\n                    \\n                    dp[left][right] = max(dp[left][right],dp[mp[diff]][left] +1);\\n                    ans = max(ans,dp[left][right]);\\n                }\\n            }\\n        }\\n        return ans>2?ans:0;\\n    }\\n};\\n\\n\\n\\n\\nwhy not accepted???"
                    },
                    {
                        "username": "coder42032",
                        "content": "can you please convert this code into dp\\nclass Solution {\\npublic:\\n    int len = 0;\\n    void recur(vector<int>&arr,int i,int j,int k,int p){\\n        len = max(len,p);\\n        if(k>=arr.size()){\\n            return;\\n        }\\n        if(i+j==arr[k] || (i==0)){\\n            recur(arr,j,arr[k],k+1,p+1);\\n        }\\n        recur(arr,i,j,k+1,p);\\n    }\\n    int lenLongestFibSubseq(vector<int>& arr) {\\n        int n = arr.size();\\n        recur(arr,0,0,0,0);\\n        if(len<3)return 0;\\n        return len;\\n    }\\n};"
                    },
                    {
                        "username": "ymgcksge",
                        "content": "I think this code\\'s time complexity is o(n^2), but it causes TLE. Could anyone examine and explain? \\nsorry I don\\'t know how to embed the code here. I would like to know how to put code here as well. \\nThank you.\\n\\nclass Solution {\\npublic:\\n    int lenLongestFibSubseq(vector<int>& arr) {\\n        int n=arr.size();\\n        vector<vector<int>> dp(n,vector<int>(n,2));\\n        map<int,int> ind;\\n        for(int i=0;i<n;i++){\\n            ind[arr[i]]=i+1;\\n        }\\n        int ret=0;\\n        for(int i=0;i<n;i++){\\n            int now=arr[i];\\n            for(int j=0;j<i;j++){\\n                int k=ind[now-arr[j]];\\n                if(!k)continue;\\n                if(k-1<=j)break;\\n                dp[k-1][i]=dp[j][k-1]+1;\\n                ret=max(ret,dp[k-1][i]);\\n            }\\n        }\\n        return (ret>=3)?ret:0;\\n    }\\n};"
                    },
                    {
                        "username": "ymgcksge",
                        "content": "I think this code\\'s time complexity is O(n^2), but it causes TLE. Could anyone explain why?\\n\\nclass Solution {\\npublic:\\n    int lenLongestFibSubseq(vector<int>& arr) {\\n        int n=arr.size();\\n        vector<vector<int>> dp(n,vector<int>(n));\\n        map<int,int> ind;\\n        for(int i=0;i<n;i++){\\n            ind[arr[i]]=i+1;\\n            for(int j=0;j<n;j++){\\n                if(i==j)dp[i][j]=-1;\\n                else dp[i][j]=2;\\n            }\\n        }\\n        int ret=0;\\n        for(int i=0;i<n;i++){\\n            int now=arr[i];\\n            for(int j=0;j<i;j++){\\n                int k=ind[now-arr[j]];\\n                if(k&&k-1!=j)dp[max(k-1,j)][i]=dp[min(k-1,j)][max(k-1,j)]+1;\\n                ret=max(ret,dp[max(k-1,j)][i]);\\n            }\\n        }\\n        return (ret>=3)?ret:0;\\n    }\\n};"
                    },
                    {
                        "username": "Sas3y",
                        "content": "you embed your code with ``` (three backticks) at the start and end of your code, so 6 in total.\nalso your code doesnt compile for me, because you didnt include vector template parameter or size type, I guess you wanted to use vector\\<int\\>.\nbut going to your main question, I believe it is O(n^2) time, but you did use map instead of unordered_map, which is slower (just changing that bumped me 10 extra test cases for submission); you also used O(n^2) memory (your dp is n*n) and thus recorded more operations such as assignment\nbut then again, I'm not great at this thing, just decided to post my first comment :)"
                    }
                ]
            },
            {
                "id": 1573212,
                "content": [
                    {
                        "username": "stwe",
                        "content": "Hi everyone,\\n\\nmy code fails on the [2,4,7,8,9,10,14,15,18,23,32,50] testcase. It outputs 4 instead of the expected 5.\\nMy code finds the sequence 7, 8, 15, 23 as well as 14, 18, 32, 50. But I can\\'t find a sequence of length 5, not even by hand...\\n\\nOr did I not understand the task correctly?\\n\\nBest regards,\\nStefan"
                    },
                    {
                        "username": "harsha335",
                        "content": "[@as_97z2f](/as_97z2f) Thanks bro i figure out my problem . here is my solution of O(N^2*K) K-longest subsequence.\\n```class Solution {\\n    public int lenLongestFibSubseq(int[] arr) {\\n        int n=arr.length;\\n        HashMap<Integer,Integer> map=new HashMap<>();//(ele,index)\\n        for(int i=0;i<n;i++)\\n        {\\n            map.put(arr[i],i);\\n        }\\n        int output=0;\\n        for(int i=0;i<n;i++)\\n        {\\n            int pre1=arr[i];\\n            for(int j=i+1;j<n;j++)\\n            {\\n                int pre2=arr[j];\\n                int count=2;\\n                while(map.containsKey(pre1+pre2))\\n                {\\n                    count++;\\n                    int temp=pre1;\\n                    pre1=pre2;\\n                    pre2=temp+pre2;\\n                }\\n                pre1=arr[i];    //I MISSIED UPDATING PRE1 VALUE\\n                output=Math.max(output,count);\\n            }\\n        }\\n        return output==2?0:output;\\n    }\\n}```"
                    },
                    {
                        "username": "as_97z2f",
                        "content": "The 5 length sequence is `[4, 14, 18, 32, 50]` \\u2013 I\\'m stuck on the same case."
                    },
                    {
                        "username": "munishgoyal1",
                        "content": "This definitely should have been a hard problem"
                    },
                    {
                        "username": "gadmo",
                        "content": "if this is hard almost every single dp problem have to be hard. the whole solution is just one line of dp logic plus 2-sum mapping. "
                    },
                    {
                        "username": "r4dx",
                        "content": "I\\'ve came across this while debugging my solution (which is incorrect nonetheless :))"
                    },
                    {
                        "username": "wilderfield",
                        "content": "This one is hard right?\\n\\nHad to stare at the solution for a looooong time..."
                    },
                    {
                        "username": "bupt_wc",
                        "content": "https://buptwc.github.io/2018/07/22/Leetcode-873-Length-of-Longest-Fibonacci-Subsequence/\\nHope helpful!"
                    },
                    {
                        "username": "analoglife",
                        "content": "I have solved about 30-40 DP questions so far. i\\'m still having trouble with questions like these. what am i doing wrong? will i ever get better at these?"
                    },
                    {
                        "username": "gadmo",
                        "content": "It takes practice, it came to me about after this amount of problems where now i can solve this type consistently , there is a lot of BS out there, everyone telling you you only need a small amount of problems to master every topic. dp is not easy and doing 40+ of them makes sense. if its worth your time is a different question.\nmake sure to understand the solution and recreate it on your own, also try to find someone who is clear and not using m,n,k,r as variables names."
                    },
                    {
                        "username": "kamalkumar717",
                        "content": "class Solution {\\npublic:\\n    int lenLongestFibSubseq(vector<int>& arr) {\\n        \\n        int n = arr.size();\\n\\n        unordered_map<int, int> mp;\\n        vector<vector<int>> dp(n, vector<int>(n, 2));\\n\\n        for(int i=0; i<n; ++i) {\\n            mp[arr[i]] = i;\\n        }\\n\\n        int ans = 0;\\n        for(int right=2;right<n;right++)\\n        {\\n            for(int left =1;left<right;left++)\\n            {\\n                int diff = arr[right]- arr[left];\\n\\n                if(mp.count(diff))\\n                {\\n                    \\n                    dp[left][right] = max(dp[left][right],dp[mp[diff]][left] +1);\\n                    ans = max(ans,dp[left][right]);\\n                }\\n            }\\n        }\\n        return ans>2?ans:0;\\n    }\\n};\\n\\n\\n\\n\\nwhy not accepted???"
                    },
                    {
                        "username": "coder42032",
                        "content": "can you please convert this code into dp\\nclass Solution {\\npublic:\\n    int len = 0;\\n    void recur(vector<int>&arr,int i,int j,int k,int p){\\n        len = max(len,p);\\n        if(k>=arr.size()){\\n            return;\\n        }\\n        if(i+j==arr[k] || (i==0)){\\n            recur(arr,j,arr[k],k+1,p+1);\\n        }\\n        recur(arr,i,j,k+1,p);\\n    }\\n    int lenLongestFibSubseq(vector<int>& arr) {\\n        int n = arr.size();\\n        recur(arr,0,0,0,0);\\n        if(len<3)return 0;\\n        return len;\\n    }\\n};"
                    },
                    {
                        "username": "ymgcksge",
                        "content": "I think this code\\'s time complexity is o(n^2), but it causes TLE. Could anyone examine and explain? \\nsorry I don\\'t know how to embed the code here. I would like to know how to put code here as well. \\nThank you.\\n\\nclass Solution {\\npublic:\\n    int lenLongestFibSubseq(vector<int>& arr) {\\n        int n=arr.size();\\n        vector<vector<int>> dp(n,vector<int>(n,2));\\n        map<int,int> ind;\\n        for(int i=0;i<n;i++){\\n            ind[arr[i]]=i+1;\\n        }\\n        int ret=0;\\n        for(int i=0;i<n;i++){\\n            int now=arr[i];\\n            for(int j=0;j<i;j++){\\n                int k=ind[now-arr[j]];\\n                if(!k)continue;\\n                if(k-1<=j)break;\\n                dp[k-1][i]=dp[j][k-1]+1;\\n                ret=max(ret,dp[k-1][i]);\\n            }\\n        }\\n        return (ret>=3)?ret:0;\\n    }\\n};"
                    },
                    {
                        "username": "ymgcksge",
                        "content": "I think this code\\'s time complexity is O(n^2), but it causes TLE. Could anyone explain why?\\n\\nclass Solution {\\npublic:\\n    int lenLongestFibSubseq(vector<int>& arr) {\\n        int n=arr.size();\\n        vector<vector<int>> dp(n,vector<int>(n));\\n        map<int,int> ind;\\n        for(int i=0;i<n;i++){\\n            ind[arr[i]]=i+1;\\n            for(int j=0;j<n;j++){\\n                if(i==j)dp[i][j]=-1;\\n                else dp[i][j]=2;\\n            }\\n        }\\n        int ret=0;\\n        for(int i=0;i<n;i++){\\n            int now=arr[i];\\n            for(int j=0;j<i;j++){\\n                int k=ind[now-arr[j]];\\n                if(k&&k-1!=j)dp[max(k-1,j)][i]=dp[min(k-1,j)][max(k-1,j)]+1;\\n                ret=max(ret,dp[max(k-1,j)][i]);\\n            }\\n        }\\n        return (ret>=3)?ret:0;\\n    }\\n};"
                    },
                    {
                        "username": "Sas3y",
                        "content": "you embed your code with ``` (three backticks) at the start and end of your code, so 6 in total.\nalso your code doesnt compile for me, because you didnt include vector template parameter or size type, I guess you wanted to use vector\\<int\\>.\nbut going to your main question, I believe it is O(n^2) time, but you did use map instead of unordered_map, which is slower (just changing that bumped me 10 extra test cases for submission); you also used O(n^2) memory (your dp is n*n) and thus recorded more operations such as assignment\nbut then again, I'm not great at this thing, just decided to post my first comment :)"
                    }
                ]
            },
            {
                "id": 1575284,
                "content": [
                    {
                        "username": "stwe",
                        "content": "Hi everyone,\\n\\nmy code fails on the [2,4,7,8,9,10,14,15,18,23,32,50] testcase. It outputs 4 instead of the expected 5.\\nMy code finds the sequence 7, 8, 15, 23 as well as 14, 18, 32, 50. But I can\\'t find a sequence of length 5, not even by hand...\\n\\nOr did I not understand the task correctly?\\n\\nBest regards,\\nStefan"
                    },
                    {
                        "username": "harsha335",
                        "content": "[@as_97z2f](/as_97z2f) Thanks bro i figure out my problem . here is my solution of O(N^2*K) K-longest subsequence.\\n```class Solution {\\n    public int lenLongestFibSubseq(int[] arr) {\\n        int n=arr.length;\\n        HashMap<Integer,Integer> map=new HashMap<>();//(ele,index)\\n        for(int i=0;i<n;i++)\\n        {\\n            map.put(arr[i],i);\\n        }\\n        int output=0;\\n        for(int i=0;i<n;i++)\\n        {\\n            int pre1=arr[i];\\n            for(int j=i+1;j<n;j++)\\n            {\\n                int pre2=arr[j];\\n                int count=2;\\n                while(map.containsKey(pre1+pre2))\\n                {\\n                    count++;\\n                    int temp=pre1;\\n                    pre1=pre2;\\n                    pre2=temp+pre2;\\n                }\\n                pre1=arr[i];    //I MISSIED UPDATING PRE1 VALUE\\n                output=Math.max(output,count);\\n            }\\n        }\\n        return output==2?0:output;\\n    }\\n}```"
                    },
                    {
                        "username": "as_97z2f",
                        "content": "The 5 length sequence is `[4, 14, 18, 32, 50]` \\u2013 I\\'m stuck on the same case."
                    },
                    {
                        "username": "munishgoyal1",
                        "content": "This definitely should have been a hard problem"
                    },
                    {
                        "username": "gadmo",
                        "content": "if this is hard almost every single dp problem have to be hard. the whole solution is just one line of dp logic plus 2-sum mapping. "
                    },
                    {
                        "username": "r4dx",
                        "content": "I\\'ve came across this while debugging my solution (which is incorrect nonetheless :))"
                    },
                    {
                        "username": "wilderfield",
                        "content": "This one is hard right?\\n\\nHad to stare at the solution for a looooong time..."
                    },
                    {
                        "username": "bupt_wc",
                        "content": "https://buptwc.github.io/2018/07/22/Leetcode-873-Length-of-Longest-Fibonacci-Subsequence/\\nHope helpful!"
                    },
                    {
                        "username": "analoglife",
                        "content": "I have solved about 30-40 DP questions so far. i\\'m still having trouble with questions like these. what am i doing wrong? will i ever get better at these?"
                    },
                    {
                        "username": "gadmo",
                        "content": "It takes practice, it came to me about after this amount of problems where now i can solve this type consistently , there is a lot of BS out there, everyone telling you you only need a small amount of problems to master every topic. dp is not easy and doing 40+ of them makes sense. if its worth your time is a different question.\nmake sure to understand the solution and recreate it on your own, also try to find someone who is clear and not using m,n,k,r as variables names."
                    },
                    {
                        "username": "kamalkumar717",
                        "content": "class Solution {\\npublic:\\n    int lenLongestFibSubseq(vector<int>& arr) {\\n        \\n        int n = arr.size();\\n\\n        unordered_map<int, int> mp;\\n        vector<vector<int>> dp(n, vector<int>(n, 2));\\n\\n        for(int i=0; i<n; ++i) {\\n            mp[arr[i]] = i;\\n        }\\n\\n        int ans = 0;\\n        for(int right=2;right<n;right++)\\n        {\\n            for(int left =1;left<right;left++)\\n            {\\n                int diff = arr[right]- arr[left];\\n\\n                if(mp.count(diff))\\n                {\\n                    \\n                    dp[left][right] = max(dp[left][right],dp[mp[diff]][left] +1);\\n                    ans = max(ans,dp[left][right]);\\n                }\\n            }\\n        }\\n        return ans>2?ans:0;\\n    }\\n};\\n\\n\\n\\n\\nwhy not accepted???"
                    },
                    {
                        "username": "coder42032",
                        "content": "can you please convert this code into dp\\nclass Solution {\\npublic:\\n    int len = 0;\\n    void recur(vector<int>&arr,int i,int j,int k,int p){\\n        len = max(len,p);\\n        if(k>=arr.size()){\\n            return;\\n        }\\n        if(i+j==arr[k] || (i==0)){\\n            recur(arr,j,arr[k],k+1,p+1);\\n        }\\n        recur(arr,i,j,k+1,p);\\n    }\\n    int lenLongestFibSubseq(vector<int>& arr) {\\n        int n = arr.size();\\n        recur(arr,0,0,0,0);\\n        if(len<3)return 0;\\n        return len;\\n    }\\n};"
                    },
                    {
                        "username": "ymgcksge",
                        "content": "I think this code\\'s time complexity is o(n^2), but it causes TLE. Could anyone examine and explain? \\nsorry I don\\'t know how to embed the code here. I would like to know how to put code here as well. \\nThank you.\\n\\nclass Solution {\\npublic:\\n    int lenLongestFibSubseq(vector<int>& arr) {\\n        int n=arr.size();\\n        vector<vector<int>> dp(n,vector<int>(n,2));\\n        map<int,int> ind;\\n        for(int i=0;i<n;i++){\\n            ind[arr[i]]=i+1;\\n        }\\n        int ret=0;\\n        for(int i=0;i<n;i++){\\n            int now=arr[i];\\n            for(int j=0;j<i;j++){\\n                int k=ind[now-arr[j]];\\n                if(!k)continue;\\n                if(k-1<=j)break;\\n                dp[k-1][i]=dp[j][k-1]+1;\\n                ret=max(ret,dp[k-1][i]);\\n            }\\n        }\\n        return (ret>=3)?ret:0;\\n    }\\n};"
                    },
                    {
                        "username": "ymgcksge",
                        "content": "I think this code\\'s time complexity is O(n^2), but it causes TLE. Could anyone explain why?\\n\\nclass Solution {\\npublic:\\n    int lenLongestFibSubseq(vector<int>& arr) {\\n        int n=arr.size();\\n        vector<vector<int>> dp(n,vector<int>(n));\\n        map<int,int> ind;\\n        for(int i=0;i<n;i++){\\n            ind[arr[i]]=i+1;\\n            for(int j=0;j<n;j++){\\n                if(i==j)dp[i][j]=-1;\\n                else dp[i][j]=2;\\n            }\\n        }\\n        int ret=0;\\n        for(int i=0;i<n;i++){\\n            int now=arr[i];\\n            for(int j=0;j<i;j++){\\n                int k=ind[now-arr[j]];\\n                if(k&&k-1!=j)dp[max(k-1,j)][i]=dp[min(k-1,j)][max(k-1,j)]+1;\\n                ret=max(ret,dp[max(k-1,j)][i]);\\n            }\\n        }\\n        return (ret>=3)?ret:0;\\n    }\\n};"
                    },
                    {
                        "username": "Sas3y",
                        "content": "you embed your code with ``` (three backticks) at the start and end of your code, so 6 in total.\nalso your code doesnt compile for me, because you didnt include vector template parameter or size type, I guess you wanted to use vector\\<int\\>.\nbut going to your main question, I believe it is O(n^2) time, but you did use map instead of unordered_map, which is slower (just changing that bumped me 10 extra test cases for submission); you also used O(n^2) memory (your dp is n*n) and thus recorded more operations such as assignment\nbut then again, I'm not great at this thing, just decided to post my first comment :)"
                    }
                ]
            },
            {
                "id": 1569259,
                "content": [
                    {
                        "username": "stwe",
                        "content": "Hi everyone,\\n\\nmy code fails on the [2,4,7,8,9,10,14,15,18,23,32,50] testcase. It outputs 4 instead of the expected 5.\\nMy code finds the sequence 7, 8, 15, 23 as well as 14, 18, 32, 50. But I can\\'t find a sequence of length 5, not even by hand...\\n\\nOr did I not understand the task correctly?\\n\\nBest regards,\\nStefan"
                    },
                    {
                        "username": "harsha335",
                        "content": "[@as_97z2f](/as_97z2f) Thanks bro i figure out my problem . here is my solution of O(N^2*K) K-longest subsequence.\\n```class Solution {\\n    public int lenLongestFibSubseq(int[] arr) {\\n        int n=arr.length;\\n        HashMap<Integer,Integer> map=new HashMap<>();//(ele,index)\\n        for(int i=0;i<n;i++)\\n        {\\n            map.put(arr[i],i);\\n        }\\n        int output=0;\\n        for(int i=0;i<n;i++)\\n        {\\n            int pre1=arr[i];\\n            for(int j=i+1;j<n;j++)\\n            {\\n                int pre2=arr[j];\\n                int count=2;\\n                while(map.containsKey(pre1+pre2))\\n                {\\n                    count++;\\n                    int temp=pre1;\\n                    pre1=pre2;\\n                    pre2=temp+pre2;\\n                }\\n                pre1=arr[i];    //I MISSIED UPDATING PRE1 VALUE\\n                output=Math.max(output,count);\\n            }\\n        }\\n        return output==2?0:output;\\n    }\\n}```"
                    },
                    {
                        "username": "as_97z2f",
                        "content": "The 5 length sequence is `[4, 14, 18, 32, 50]` \\u2013 I\\'m stuck on the same case."
                    },
                    {
                        "username": "munishgoyal1",
                        "content": "This definitely should have been a hard problem"
                    },
                    {
                        "username": "gadmo",
                        "content": "if this is hard almost every single dp problem have to be hard. the whole solution is just one line of dp logic plus 2-sum mapping. "
                    },
                    {
                        "username": "r4dx",
                        "content": "I\\'ve came across this while debugging my solution (which is incorrect nonetheless :))"
                    },
                    {
                        "username": "wilderfield",
                        "content": "This one is hard right?\\n\\nHad to stare at the solution for a looooong time..."
                    },
                    {
                        "username": "bupt_wc",
                        "content": "https://buptwc.github.io/2018/07/22/Leetcode-873-Length-of-Longest-Fibonacci-Subsequence/\\nHope helpful!"
                    },
                    {
                        "username": "analoglife",
                        "content": "I have solved about 30-40 DP questions so far. i\\'m still having trouble with questions like these. what am i doing wrong? will i ever get better at these?"
                    },
                    {
                        "username": "gadmo",
                        "content": "It takes practice, it came to me about after this amount of problems where now i can solve this type consistently , there is a lot of BS out there, everyone telling you you only need a small amount of problems to master every topic. dp is not easy and doing 40+ of them makes sense. if its worth your time is a different question.\nmake sure to understand the solution and recreate it on your own, also try to find someone who is clear and not using m,n,k,r as variables names."
                    },
                    {
                        "username": "kamalkumar717",
                        "content": "class Solution {\\npublic:\\n    int lenLongestFibSubseq(vector<int>& arr) {\\n        \\n        int n = arr.size();\\n\\n        unordered_map<int, int> mp;\\n        vector<vector<int>> dp(n, vector<int>(n, 2));\\n\\n        for(int i=0; i<n; ++i) {\\n            mp[arr[i]] = i;\\n        }\\n\\n        int ans = 0;\\n        for(int right=2;right<n;right++)\\n        {\\n            for(int left =1;left<right;left++)\\n            {\\n                int diff = arr[right]- arr[left];\\n\\n                if(mp.count(diff))\\n                {\\n                    \\n                    dp[left][right] = max(dp[left][right],dp[mp[diff]][left] +1);\\n                    ans = max(ans,dp[left][right]);\\n                }\\n            }\\n        }\\n        return ans>2?ans:0;\\n    }\\n};\\n\\n\\n\\n\\nwhy not accepted???"
                    },
                    {
                        "username": "coder42032",
                        "content": "can you please convert this code into dp\\nclass Solution {\\npublic:\\n    int len = 0;\\n    void recur(vector<int>&arr,int i,int j,int k,int p){\\n        len = max(len,p);\\n        if(k>=arr.size()){\\n            return;\\n        }\\n        if(i+j==arr[k] || (i==0)){\\n            recur(arr,j,arr[k],k+1,p+1);\\n        }\\n        recur(arr,i,j,k+1,p);\\n    }\\n    int lenLongestFibSubseq(vector<int>& arr) {\\n        int n = arr.size();\\n        recur(arr,0,0,0,0);\\n        if(len<3)return 0;\\n        return len;\\n    }\\n};"
                    },
                    {
                        "username": "ymgcksge",
                        "content": "I think this code\\'s time complexity is o(n^2), but it causes TLE. Could anyone examine and explain? \\nsorry I don\\'t know how to embed the code here. I would like to know how to put code here as well. \\nThank you.\\n\\nclass Solution {\\npublic:\\n    int lenLongestFibSubseq(vector<int>& arr) {\\n        int n=arr.size();\\n        vector<vector<int>> dp(n,vector<int>(n,2));\\n        map<int,int> ind;\\n        for(int i=0;i<n;i++){\\n            ind[arr[i]]=i+1;\\n        }\\n        int ret=0;\\n        for(int i=0;i<n;i++){\\n            int now=arr[i];\\n            for(int j=0;j<i;j++){\\n                int k=ind[now-arr[j]];\\n                if(!k)continue;\\n                if(k-1<=j)break;\\n                dp[k-1][i]=dp[j][k-1]+1;\\n                ret=max(ret,dp[k-1][i]);\\n            }\\n        }\\n        return (ret>=3)?ret:0;\\n    }\\n};"
                    },
                    {
                        "username": "ymgcksge",
                        "content": "I think this code\\'s time complexity is O(n^2), but it causes TLE. Could anyone explain why?\\n\\nclass Solution {\\npublic:\\n    int lenLongestFibSubseq(vector<int>& arr) {\\n        int n=arr.size();\\n        vector<vector<int>> dp(n,vector<int>(n));\\n        map<int,int> ind;\\n        for(int i=0;i<n;i++){\\n            ind[arr[i]]=i+1;\\n            for(int j=0;j<n;j++){\\n                if(i==j)dp[i][j]=-1;\\n                else dp[i][j]=2;\\n            }\\n        }\\n        int ret=0;\\n        for(int i=0;i<n;i++){\\n            int now=arr[i];\\n            for(int j=0;j<i;j++){\\n                int k=ind[now-arr[j]];\\n                if(k&&k-1!=j)dp[max(k-1,j)][i]=dp[min(k-1,j)][max(k-1,j)]+1;\\n                ret=max(ret,dp[max(k-1,j)][i]);\\n            }\\n        }\\n        return (ret>=3)?ret:0;\\n    }\\n};"
                    },
                    {
                        "username": "Sas3y",
                        "content": "you embed your code with ``` (three backticks) at the start and end of your code, so 6 in total.\nalso your code doesnt compile for me, because you didnt include vector template parameter or size type, I guess you wanted to use vector\\<int\\>.\nbut going to your main question, I believe it is O(n^2) time, but you did use map instead of unordered_map, which is slower (just changing that bumped me 10 extra test cases for submission); you also used O(n^2) memory (your dp is n*n) and thus recorded more operations such as assignment\nbut then again, I'm not great at this thing, just decided to post my first comment :)"
                    }
                ]
            },
            {
                "id": 1574296,
                "content": [
                    {
                        "username": "stwe",
                        "content": "Hi everyone,\\n\\nmy code fails on the [2,4,7,8,9,10,14,15,18,23,32,50] testcase. It outputs 4 instead of the expected 5.\\nMy code finds the sequence 7, 8, 15, 23 as well as 14, 18, 32, 50. But I can\\'t find a sequence of length 5, not even by hand...\\n\\nOr did I not understand the task correctly?\\n\\nBest regards,\\nStefan"
                    },
                    {
                        "username": "harsha335",
                        "content": "[@as_97z2f](/as_97z2f) Thanks bro i figure out my problem . here is my solution of O(N^2*K) K-longest subsequence.\\n```class Solution {\\n    public int lenLongestFibSubseq(int[] arr) {\\n        int n=arr.length;\\n        HashMap<Integer,Integer> map=new HashMap<>();//(ele,index)\\n        for(int i=0;i<n;i++)\\n        {\\n            map.put(arr[i],i);\\n        }\\n        int output=0;\\n        for(int i=0;i<n;i++)\\n        {\\n            int pre1=arr[i];\\n            for(int j=i+1;j<n;j++)\\n            {\\n                int pre2=arr[j];\\n                int count=2;\\n                while(map.containsKey(pre1+pre2))\\n                {\\n                    count++;\\n                    int temp=pre1;\\n                    pre1=pre2;\\n                    pre2=temp+pre2;\\n                }\\n                pre1=arr[i];    //I MISSIED UPDATING PRE1 VALUE\\n                output=Math.max(output,count);\\n            }\\n        }\\n        return output==2?0:output;\\n    }\\n}```"
                    },
                    {
                        "username": "as_97z2f",
                        "content": "The 5 length sequence is `[4, 14, 18, 32, 50]` \\u2013 I\\'m stuck on the same case."
                    },
                    {
                        "username": "munishgoyal1",
                        "content": "This definitely should have been a hard problem"
                    },
                    {
                        "username": "gadmo",
                        "content": "if this is hard almost every single dp problem have to be hard. the whole solution is just one line of dp logic plus 2-sum mapping. "
                    },
                    {
                        "username": "r4dx",
                        "content": "I\\'ve came across this while debugging my solution (which is incorrect nonetheless :))"
                    },
                    {
                        "username": "wilderfield",
                        "content": "This one is hard right?\\n\\nHad to stare at the solution for a looooong time..."
                    },
                    {
                        "username": "bupt_wc",
                        "content": "https://buptwc.github.io/2018/07/22/Leetcode-873-Length-of-Longest-Fibonacci-Subsequence/\\nHope helpful!"
                    },
                    {
                        "username": "analoglife",
                        "content": "I have solved about 30-40 DP questions so far. i\\'m still having trouble with questions like these. what am i doing wrong? will i ever get better at these?"
                    },
                    {
                        "username": "gadmo",
                        "content": "It takes practice, it came to me about after this amount of problems where now i can solve this type consistently , there is a lot of BS out there, everyone telling you you only need a small amount of problems to master every topic. dp is not easy and doing 40+ of them makes sense. if its worth your time is a different question.\nmake sure to understand the solution and recreate it on your own, also try to find someone who is clear and not using m,n,k,r as variables names."
                    },
                    {
                        "username": "kamalkumar717",
                        "content": "class Solution {\\npublic:\\n    int lenLongestFibSubseq(vector<int>& arr) {\\n        \\n        int n = arr.size();\\n\\n        unordered_map<int, int> mp;\\n        vector<vector<int>> dp(n, vector<int>(n, 2));\\n\\n        for(int i=0; i<n; ++i) {\\n            mp[arr[i]] = i;\\n        }\\n\\n        int ans = 0;\\n        for(int right=2;right<n;right++)\\n        {\\n            for(int left =1;left<right;left++)\\n            {\\n                int diff = arr[right]- arr[left];\\n\\n                if(mp.count(diff))\\n                {\\n                    \\n                    dp[left][right] = max(dp[left][right],dp[mp[diff]][left] +1);\\n                    ans = max(ans,dp[left][right]);\\n                }\\n            }\\n        }\\n        return ans>2?ans:0;\\n    }\\n};\\n\\n\\n\\n\\nwhy not accepted???"
                    },
                    {
                        "username": "coder42032",
                        "content": "can you please convert this code into dp\\nclass Solution {\\npublic:\\n    int len = 0;\\n    void recur(vector<int>&arr,int i,int j,int k,int p){\\n        len = max(len,p);\\n        if(k>=arr.size()){\\n            return;\\n        }\\n        if(i+j==arr[k] || (i==0)){\\n            recur(arr,j,arr[k],k+1,p+1);\\n        }\\n        recur(arr,i,j,k+1,p);\\n    }\\n    int lenLongestFibSubseq(vector<int>& arr) {\\n        int n = arr.size();\\n        recur(arr,0,0,0,0);\\n        if(len<3)return 0;\\n        return len;\\n    }\\n};"
                    },
                    {
                        "username": "ymgcksge",
                        "content": "I think this code\\'s time complexity is o(n^2), but it causes TLE. Could anyone examine and explain? \\nsorry I don\\'t know how to embed the code here. I would like to know how to put code here as well. \\nThank you.\\n\\nclass Solution {\\npublic:\\n    int lenLongestFibSubseq(vector<int>& arr) {\\n        int n=arr.size();\\n        vector<vector<int>> dp(n,vector<int>(n,2));\\n        map<int,int> ind;\\n        for(int i=0;i<n;i++){\\n            ind[arr[i]]=i+1;\\n        }\\n        int ret=0;\\n        for(int i=0;i<n;i++){\\n            int now=arr[i];\\n            for(int j=0;j<i;j++){\\n                int k=ind[now-arr[j]];\\n                if(!k)continue;\\n                if(k-1<=j)break;\\n                dp[k-1][i]=dp[j][k-1]+1;\\n                ret=max(ret,dp[k-1][i]);\\n            }\\n        }\\n        return (ret>=3)?ret:0;\\n    }\\n};"
                    },
                    {
                        "username": "ymgcksge",
                        "content": "I think this code\\'s time complexity is O(n^2), but it causes TLE. Could anyone explain why?\\n\\nclass Solution {\\npublic:\\n    int lenLongestFibSubseq(vector<int>& arr) {\\n        int n=arr.size();\\n        vector<vector<int>> dp(n,vector<int>(n));\\n        map<int,int> ind;\\n        for(int i=0;i<n;i++){\\n            ind[arr[i]]=i+1;\\n            for(int j=0;j<n;j++){\\n                if(i==j)dp[i][j]=-1;\\n                else dp[i][j]=2;\\n            }\\n        }\\n        int ret=0;\\n        for(int i=0;i<n;i++){\\n            int now=arr[i];\\n            for(int j=0;j<i;j++){\\n                int k=ind[now-arr[j]];\\n                if(k&&k-1!=j)dp[max(k-1,j)][i]=dp[min(k-1,j)][max(k-1,j)]+1;\\n                ret=max(ret,dp[max(k-1,j)][i]);\\n            }\\n        }\\n        return (ret>=3)?ret:0;\\n    }\\n};"
                    },
                    {
                        "username": "Sas3y",
                        "content": "you embed your code with ``` (three backticks) at the start and end of your code, so 6 in total.\nalso your code doesnt compile for me, because you didnt include vector template parameter or size type, I guess you wanted to use vector\\<int\\>.\nbut going to your main question, I believe it is O(n^2) time, but you did use map instead of unordered_map, which is slower (just changing that bumped me 10 extra test cases for submission); you also used O(n^2) memory (your dp is n*n) and thus recorded more operations such as assignment\nbut then again, I'm not great at this thing, just decided to post my first comment :)"
                    }
                ]
            },
            {
                "id": 1945978,
                "content": [
                    {
                        "username": "stwe",
                        "content": "Hi everyone,\\n\\nmy code fails on the [2,4,7,8,9,10,14,15,18,23,32,50] testcase. It outputs 4 instead of the expected 5.\\nMy code finds the sequence 7, 8, 15, 23 as well as 14, 18, 32, 50. But I can\\'t find a sequence of length 5, not even by hand...\\n\\nOr did I not understand the task correctly?\\n\\nBest regards,\\nStefan"
                    },
                    {
                        "username": "harsha335",
                        "content": "[@as_97z2f](/as_97z2f) Thanks bro i figure out my problem . here is my solution of O(N^2*K) K-longest subsequence.\\n```class Solution {\\n    public int lenLongestFibSubseq(int[] arr) {\\n        int n=arr.length;\\n        HashMap<Integer,Integer> map=new HashMap<>();//(ele,index)\\n        for(int i=0;i<n;i++)\\n        {\\n            map.put(arr[i],i);\\n        }\\n        int output=0;\\n        for(int i=0;i<n;i++)\\n        {\\n            int pre1=arr[i];\\n            for(int j=i+1;j<n;j++)\\n            {\\n                int pre2=arr[j];\\n                int count=2;\\n                while(map.containsKey(pre1+pre2))\\n                {\\n                    count++;\\n                    int temp=pre1;\\n                    pre1=pre2;\\n                    pre2=temp+pre2;\\n                }\\n                pre1=arr[i];    //I MISSIED UPDATING PRE1 VALUE\\n                output=Math.max(output,count);\\n            }\\n        }\\n        return output==2?0:output;\\n    }\\n}```"
                    },
                    {
                        "username": "as_97z2f",
                        "content": "The 5 length sequence is `[4, 14, 18, 32, 50]` \\u2013 I\\'m stuck on the same case."
                    },
                    {
                        "username": "munishgoyal1",
                        "content": "This definitely should have been a hard problem"
                    },
                    {
                        "username": "gadmo",
                        "content": "if this is hard almost every single dp problem have to be hard. the whole solution is just one line of dp logic plus 2-sum mapping. "
                    },
                    {
                        "username": "r4dx",
                        "content": "I\\'ve came across this while debugging my solution (which is incorrect nonetheless :))"
                    },
                    {
                        "username": "wilderfield",
                        "content": "This one is hard right?\\n\\nHad to stare at the solution for a looooong time..."
                    },
                    {
                        "username": "bupt_wc",
                        "content": "https://buptwc.github.io/2018/07/22/Leetcode-873-Length-of-Longest-Fibonacci-Subsequence/\\nHope helpful!"
                    },
                    {
                        "username": "analoglife",
                        "content": "I have solved about 30-40 DP questions so far. i\\'m still having trouble with questions like these. what am i doing wrong? will i ever get better at these?"
                    },
                    {
                        "username": "gadmo",
                        "content": "It takes practice, it came to me about after this amount of problems where now i can solve this type consistently , there is a lot of BS out there, everyone telling you you only need a small amount of problems to master every topic. dp is not easy and doing 40+ of them makes sense. if its worth your time is a different question.\nmake sure to understand the solution and recreate it on your own, also try to find someone who is clear and not using m,n,k,r as variables names."
                    },
                    {
                        "username": "kamalkumar717",
                        "content": "class Solution {\\npublic:\\n    int lenLongestFibSubseq(vector<int>& arr) {\\n        \\n        int n = arr.size();\\n\\n        unordered_map<int, int> mp;\\n        vector<vector<int>> dp(n, vector<int>(n, 2));\\n\\n        for(int i=0; i<n; ++i) {\\n            mp[arr[i]] = i;\\n        }\\n\\n        int ans = 0;\\n        for(int right=2;right<n;right++)\\n        {\\n            for(int left =1;left<right;left++)\\n            {\\n                int diff = arr[right]- arr[left];\\n\\n                if(mp.count(diff))\\n                {\\n                    \\n                    dp[left][right] = max(dp[left][right],dp[mp[diff]][left] +1);\\n                    ans = max(ans,dp[left][right]);\\n                }\\n            }\\n        }\\n        return ans>2?ans:0;\\n    }\\n};\\n\\n\\n\\n\\nwhy not accepted???"
                    },
                    {
                        "username": "coder42032",
                        "content": "can you please convert this code into dp\\nclass Solution {\\npublic:\\n    int len = 0;\\n    void recur(vector<int>&arr,int i,int j,int k,int p){\\n        len = max(len,p);\\n        if(k>=arr.size()){\\n            return;\\n        }\\n        if(i+j==arr[k] || (i==0)){\\n            recur(arr,j,arr[k],k+1,p+1);\\n        }\\n        recur(arr,i,j,k+1,p);\\n    }\\n    int lenLongestFibSubseq(vector<int>& arr) {\\n        int n = arr.size();\\n        recur(arr,0,0,0,0);\\n        if(len<3)return 0;\\n        return len;\\n    }\\n};"
                    },
                    {
                        "username": "ymgcksge",
                        "content": "I think this code\\'s time complexity is o(n^2), but it causes TLE. Could anyone examine and explain? \\nsorry I don\\'t know how to embed the code here. I would like to know how to put code here as well. \\nThank you.\\n\\nclass Solution {\\npublic:\\n    int lenLongestFibSubseq(vector<int>& arr) {\\n        int n=arr.size();\\n        vector<vector<int>> dp(n,vector<int>(n,2));\\n        map<int,int> ind;\\n        for(int i=0;i<n;i++){\\n            ind[arr[i]]=i+1;\\n        }\\n        int ret=0;\\n        for(int i=0;i<n;i++){\\n            int now=arr[i];\\n            for(int j=0;j<i;j++){\\n                int k=ind[now-arr[j]];\\n                if(!k)continue;\\n                if(k-1<=j)break;\\n                dp[k-1][i]=dp[j][k-1]+1;\\n                ret=max(ret,dp[k-1][i]);\\n            }\\n        }\\n        return (ret>=3)?ret:0;\\n    }\\n};"
                    },
                    {
                        "username": "ymgcksge",
                        "content": "I think this code\\'s time complexity is O(n^2), but it causes TLE. Could anyone explain why?\\n\\nclass Solution {\\npublic:\\n    int lenLongestFibSubseq(vector<int>& arr) {\\n        int n=arr.size();\\n        vector<vector<int>> dp(n,vector<int>(n));\\n        map<int,int> ind;\\n        for(int i=0;i<n;i++){\\n            ind[arr[i]]=i+1;\\n            for(int j=0;j<n;j++){\\n                if(i==j)dp[i][j]=-1;\\n                else dp[i][j]=2;\\n            }\\n        }\\n        int ret=0;\\n        for(int i=0;i<n;i++){\\n            int now=arr[i];\\n            for(int j=0;j<i;j++){\\n                int k=ind[now-arr[j]];\\n                if(k&&k-1!=j)dp[max(k-1,j)][i]=dp[min(k-1,j)][max(k-1,j)]+1;\\n                ret=max(ret,dp[max(k-1,j)][i]);\\n            }\\n        }\\n        return (ret>=3)?ret:0;\\n    }\\n};"
                    },
                    {
                        "username": "Sas3y",
                        "content": "you embed your code with ``` (three backticks) at the start and end of your code, so 6 in total.\nalso your code doesnt compile for me, because you didnt include vector template parameter or size type, I guess you wanted to use vector\\<int\\>.\nbut going to your main question, I believe it is O(n^2) time, but you did use map instead of unordered_map, which is slower (just changing that bumped me 10 extra test cases for submission); you also used O(n^2) memory (your dp is n*n) and thus recorded more operations such as assignment\nbut then again, I'm not great at this thing, just decided to post my first comment :)"
                    }
                ]
            },
            {
                "id": 1870436,
                "content": [
                    {
                        "username": "stwe",
                        "content": "Hi everyone,\\n\\nmy code fails on the [2,4,7,8,9,10,14,15,18,23,32,50] testcase. It outputs 4 instead of the expected 5.\\nMy code finds the sequence 7, 8, 15, 23 as well as 14, 18, 32, 50. But I can\\'t find a sequence of length 5, not even by hand...\\n\\nOr did I not understand the task correctly?\\n\\nBest regards,\\nStefan"
                    },
                    {
                        "username": "harsha335",
                        "content": "[@as_97z2f](/as_97z2f) Thanks bro i figure out my problem . here is my solution of O(N^2*K) K-longest subsequence.\\n```class Solution {\\n    public int lenLongestFibSubseq(int[] arr) {\\n        int n=arr.length;\\n        HashMap<Integer,Integer> map=new HashMap<>();//(ele,index)\\n        for(int i=0;i<n;i++)\\n        {\\n            map.put(arr[i],i);\\n        }\\n        int output=0;\\n        for(int i=0;i<n;i++)\\n        {\\n            int pre1=arr[i];\\n            for(int j=i+1;j<n;j++)\\n            {\\n                int pre2=arr[j];\\n                int count=2;\\n                while(map.containsKey(pre1+pre2))\\n                {\\n                    count++;\\n                    int temp=pre1;\\n                    pre1=pre2;\\n                    pre2=temp+pre2;\\n                }\\n                pre1=arr[i];    //I MISSIED UPDATING PRE1 VALUE\\n                output=Math.max(output,count);\\n            }\\n        }\\n        return output==2?0:output;\\n    }\\n}```"
                    },
                    {
                        "username": "as_97z2f",
                        "content": "The 5 length sequence is `[4, 14, 18, 32, 50]` \\u2013 I\\'m stuck on the same case."
                    },
                    {
                        "username": "munishgoyal1",
                        "content": "This definitely should have been a hard problem"
                    },
                    {
                        "username": "gadmo",
                        "content": "if this is hard almost every single dp problem have to be hard. the whole solution is just one line of dp logic plus 2-sum mapping. "
                    },
                    {
                        "username": "r4dx",
                        "content": "I\\'ve came across this while debugging my solution (which is incorrect nonetheless :))"
                    },
                    {
                        "username": "wilderfield",
                        "content": "This one is hard right?\\n\\nHad to stare at the solution for a looooong time..."
                    },
                    {
                        "username": "bupt_wc",
                        "content": "https://buptwc.github.io/2018/07/22/Leetcode-873-Length-of-Longest-Fibonacci-Subsequence/\\nHope helpful!"
                    },
                    {
                        "username": "analoglife",
                        "content": "I have solved about 30-40 DP questions so far. i\\'m still having trouble with questions like these. what am i doing wrong? will i ever get better at these?"
                    },
                    {
                        "username": "gadmo",
                        "content": "It takes practice, it came to me about after this amount of problems where now i can solve this type consistently , there is a lot of BS out there, everyone telling you you only need a small amount of problems to master every topic. dp is not easy and doing 40+ of them makes sense. if its worth your time is a different question.\nmake sure to understand the solution and recreate it on your own, also try to find someone who is clear and not using m,n,k,r as variables names."
                    },
                    {
                        "username": "kamalkumar717",
                        "content": "class Solution {\\npublic:\\n    int lenLongestFibSubseq(vector<int>& arr) {\\n        \\n        int n = arr.size();\\n\\n        unordered_map<int, int> mp;\\n        vector<vector<int>> dp(n, vector<int>(n, 2));\\n\\n        for(int i=0; i<n; ++i) {\\n            mp[arr[i]] = i;\\n        }\\n\\n        int ans = 0;\\n        for(int right=2;right<n;right++)\\n        {\\n            for(int left =1;left<right;left++)\\n            {\\n                int diff = arr[right]- arr[left];\\n\\n                if(mp.count(diff))\\n                {\\n                    \\n                    dp[left][right] = max(dp[left][right],dp[mp[diff]][left] +1);\\n                    ans = max(ans,dp[left][right]);\\n                }\\n            }\\n        }\\n        return ans>2?ans:0;\\n    }\\n};\\n\\n\\n\\n\\nwhy not accepted???"
                    },
                    {
                        "username": "coder42032",
                        "content": "can you please convert this code into dp\\nclass Solution {\\npublic:\\n    int len = 0;\\n    void recur(vector<int>&arr,int i,int j,int k,int p){\\n        len = max(len,p);\\n        if(k>=arr.size()){\\n            return;\\n        }\\n        if(i+j==arr[k] || (i==0)){\\n            recur(arr,j,arr[k],k+1,p+1);\\n        }\\n        recur(arr,i,j,k+1,p);\\n    }\\n    int lenLongestFibSubseq(vector<int>& arr) {\\n        int n = arr.size();\\n        recur(arr,0,0,0,0);\\n        if(len<3)return 0;\\n        return len;\\n    }\\n};"
                    },
                    {
                        "username": "ymgcksge",
                        "content": "I think this code\\'s time complexity is o(n^2), but it causes TLE. Could anyone examine and explain? \\nsorry I don\\'t know how to embed the code here. I would like to know how to put code here as well. \\nThank you.\\n\\nclass Solution {\\npublic:\\n    int lenLongestFibSubseq(vector<int>& arr) {\\n        int n=arr.size();\\n        vector<vector<int>> dp(n,vector<int>(n,2));\\n        map<int,int> ind;\\n        for(int i=0;i<n;i++){\\n            ind[arr[i]]=i+1;\\n        }\\n        int ret=0;\\n        for(int i=0;i<n;i++){\\n            int now=arr[i];\\n            for(int j=0;j<i;j++){\\n                int k=ind[now-arr[j]];\\n                if(!k)continue;\\n                if(k-1<=j)break;\\n                dp[k-1][i]=dp[j][k-1]+1;\\n                ret=max(ret,dp[k-1][i]);\\n            }\\n        }\\n        return (ret>=3)?ret:0;\\n    }\\n};"
                    },
                    {
                        "username": "ymgcksge",
                        "content": "I think this code\\'s time complexity is O(n^2), but it causes TLE. Could anyone explain why?\\n\\nclass Solution {\\npublic:\\n    int lenLongestFibSubseq(vector<int>& arr) {\\n        int n=arr.size();\\n        vector<vector<int>> dp(n,vector<int>(n));\\n        map<int,int> ind;\\n        for(int i=0;i<n;i++){\\n            ind[arr[i]]=i+1;\\n            for(int j=0;j<n;j++){\\n                if(i==j)dp[i][j]=-1;\\n                else dp[i][j]=2;\\n            }\\n        }\\n        int ret=0;\\n        for(int i=0;i<n;i++){\\n            int now=arr[i];\\n            for(int j=0;j<i;j++){\\n                int k=ind[now-arr[j]];\\n                if(k&&k-1!=j)dp[max(k-1,j)][i]=dp[min(k-1,j)][max(k-1,j)]+1;\\n                ret=max(ret,dp[max(k-1,j)][i]);\\n            }\\n        }\\n        return (ret>=3)?ret:0;\\n    }\\n};"
                    },
                    {
                        "username": "Sas3y",
                        "content": "you embed your code with ``` (three backticks) at the start and end of your code, so 6 in total.\nalso your code doesnt compile for me, because you didnt include vector template parameter or size type, I guess you wanted to use vector\\<int\\>.\nbut going to your main question, I believe it is O(n^2) time, but you did use map instead of unordered_map, which is slower (just changing that bumped me 10 extra test cases for submission); you also used O(n^2) memory (your dp is n*n) and thus recorded more operations such as assignment\nbut then again, I'm not great at this thing, just decided to post my first comment :)"
                    }
                ]
            },
            {
                "id": 1739445,
                "content": [
                    {
                        "username": "stwe",
                        "content": "Hi everyone,\\n\\nmy code fails on the [2,4,7,8,9,10,14,15,18,23,32,50] testcase. It outputs 4 instead of the expected 5.\\nMy code finds the sequence 7, 8, 15, 23 as well as 14, 18, 32, 50. But I can\\'t find a sequence of length 5, not even by hand...\\n\\nOr did I not understand the task correctly?\\n\\nBest regards,\\nStefan"
                    },
                    {
                        "username": "harsha335",
                        "content": "[@as_97z2f](/as_97z2f) Thanks bro i figure out my problem . here is my solution of O(N^2*K) K-longest subsequence.\\n```class Solution {\\n    public int lenLongestFibSubseq(int[] arr) {\\n        int n=arr.length;\\n        HashMap<Integer,Integer> map=new HashMap<>();//(ele,index)\\n        for(int i=0;i<n;i++)\\n        {\\n            map.put(arr[i],i);\\n        }\\n        int output=0;\\n        for(int i=0;i<n;i++)\\n        {\\n            int pre1=arr[i];\\n            for(int j=i+1;j<n;j++)\\n            {\\n                int pre2=arr[j];\\n                int count=2;\\n                while(map.containsKey(pre1+pre2))\\n                {\\n                    count++;\\n                    int temp=pre1;\\n                    pre1=pre2;\\n                    pre2=temp+pre2;\\n                }\\n                pre1=arr[i];    //I MISSIED UPDATING PRE1 VALUE\\n                output=Math.max(output,count);\\n            }\\n        }\\n        return output==2?0:output;\\n    }\\n}```"
                    },
                    {
                        "username": "as_97z2f",
                        "content": "The 5 length sequence is `[4, 14, 18, 32, 50]` \\u2013 I\\'m stuck on the same case."
                    },
                    {
                        "username": "munishgoyal1",
                        "content": "This definitely should have been a hard problem"
                    },
                    {
                        "username": "gadmo",
                        "content": "if this is hard almost every single dp problem have to be hard. the whole solution is just one line of dp logic plus 2-sum mapping. "
                    },
                    {
                        "username": "r4dx",
                        "content": "I\\'ve came across this while debugging my solution (which is incorrect nonetheless :))"
                    },
                    {
                        "username": "wilderfield",
                        "content": "This one is hard right?\\n\\nHad to stare at the solution for a looooong time..."
                    },
                    {
                        "username": "bupt_wc",
                        "content": "https://buptwc.github.io/2018/07/22/Leetcode-873-Length-of-Longest-Fibonacci-Subsequence/\\nHope helpful!"
                    },
                    {
                        "username": "analoglife",
                        "content": "I have solved about 30-40 DP questions so far. i\\'m still having trouble with questions like these. what am i doing wrong? will i ever get better at these?"
                    },
                    {
                        "username": "gadmo",
                        "content": "It takes practice, it came to me about after this amount of problems where now i can solve this type consistently , there is a lot of BS out there, everyone telling you you only need a small amount of problems to master every topic. dp is not easy and doing 40+ of them makes sense. if its worth your time is a different question.\nmake sure to understand the solution and recreate it on your own, also try to find someone who is clear and not using m,n,k,r as variables names."
                    },
                    {
                        "username": "kamalkumar717",
                        "content": "class Solution {\\npublic:\\n    int lenLongestFibSubseq(vector<int>& arr) {\\n        \\n        int n = arr.size();\\n\\n        unordered_map<int, int> mp;\\n        vector<vector<int>> dp(n, vector<int>(n, 2));\\n\\n        for(int i=0; i<n; ++i) {\\n            mp[arr[i]] = i;\\n        }\\n\\n        int ans = 0;\\n        for(int right=2;right<n;right++)\\n        {\\n            for(int left =1;left<right;left++)\\n            {\\n                int diff = arr[right]- arr[left];\\n\\n                if(mp.count(diff))\\n                {\\n                    \\n                    dp[left][right] = max(dp[left][right],dp[mp[diff]][left] +1);\\n                    ans = max(ans,dp[left][right]);\\n                }\\n            }\\n        }\\n        return ans>2?ans:0;\\n    }\\n};\\n\\n\\n\\n\\nwhy not accepted???"
                    },
                    {
                        "username": "coder42032",
                        "content": "can you please convert this code into dp\\nclass Solution {\\npublic:\\n    int len = 0;\\n    void recur(vector<int>&arr,int i,int j,int k,int p){\\n        len = max(len,p);\\n        if(k>=arr.size()){\\n            return;\\n        }\\n        if(i+j==arr[k] || (i==0)){\\n            recur(arr,j,arr[k],k+1,p+1);\\n        }\\n        recur(arr,i,j,k+1,p);\\n    }\\n    int lenLongestFibSubseq(vector<int>& arr) {\\n        int n = arr.size();\\n        recur(arr,0,0,0,0);\\n        if(len<3)return 0;\\n        return len;\\n    }\\n};"
                    },
                    {
                        "username": "ymgcksge",
                        "content": "I think this code\\'s time complexity is o(n^2), but it causes TLE. Could anyone examine and explain? \\nsorry I don\\'t know how to embed the code here. I would like to know how to put code here as well. \\nThank you.\\n\\nclass Solution {\\npublic:\\n    int lenLongestFibSubseq(vector<int>& arr) {\\n        int n=arr.size();\\n        vector<vector<int>> dp(n,vector<int>(n,2));\\n        map<int,int> ind;\\n        for(int i=0;i<n;i++){\\n            ind[arr[i]]=i+1;\\n        }\\n        int ret=0;\\n        for(int i=0;i<n;i++){\\n            int now=arr[i];\\n            for(int j=0;j<i;j++){\\n                int k=ind[now-arr[j]];\\n                if(!k)continue;\\n                if(k-1<=j)break;\\n                dp[k-1][i]=dp[j][k-1]+1;\\n                ret=max(ret,dp[k-1][i]);\\n            }\\n        }\\n        return (ret>=3)?ret:0;\\n    }\\n};"
                    },
                    {
                        "username": "ymgcksge",
                        "content": "I think this code\\'s time complexity is O(n^2), but it causes TLE. Could anyone explain why?\\n\\nclass Solution {\\npublic:\\n    int lenLongestFibSubseq(vector<int>& arr) {\\n        int n=arr.size();\\n        vector<vector<int>> dp(n,vector<int>(n));\\n        map<int,int> ind;\\n        for(int i=0;i<n;i++){\\n            ind[arr[i]]=i+1;\\n            for(int j=0;j<n;j++){\\n                if(i==j)dp[i][j]=-1;\\n                else dp[i][j]=2;\\n            }\\n        }\\n        int ret=0;\\n        for(int i=0;i<n;i++){\\n            int now=arr[i];\\n            for(int j=0;j<i;j++){\\n                int k=ind[now-arr[j]];\\n                if(k&&k-1!=j)dp[max(k-1,j)][i]=dp[min(k-1,j)][max(k-1,j)]+1;\\n                ret=max(ret,dp[max(k-1,j)][i]);\\n            }\\n        }\\n        return (ret>=3)?ret:0;\\n    }\\n};"
                    },
                    {
                        "username": "Sas3y",
                        "content": "you embed your code with ``` (three backticks) at the start and end of your code, so 6 in total.\nalso your code doesnt compile for me, because you didnt include vector template parameter or size type, I guess you wanted to use vector\\<int\\>.\nbut going to your main question, I believe it is O(n^2) time, but you did use map instead of unordered_map, which is slower (just changing that bumped me 10 extra test cases for submission); you also used O(n^2) memory (your dp is n*n) and thus recorded more operations such as assignment\nbut then again, I'm not great at this thing, just decided to post my first comment :)"
                    }
                ]
            },
            {
                "id": 1739420,
                "content": [
                    {
                        "username": "stwe",
                        "content": "Hi everyone,\\n\\nmy code fails on the [2,4,7,8,9,10,14,15,18,23,32,50] testcase. It outputs 4 instead of the expected 5.\\nMy code finds the sequence 7, 8, 15, 23 as well as 14, 18, 32, 50. But I can\\'t find a sequence of length 5, not even by hand...\\n\\nOr did I not understand the task correctly?\\n\\nBest regards,\\nStefan"
                    },
                    {
                        "username": "harsha335",
                        "content": "[@as_97z2f](/as_97z2f) Thanks bro i figure out my problem . here is my solution of O(N^2*K) K-longest subsequence.\\n```class Solution {\\n    public int lenLongestFibSubseq(int[] arr) {\\n        int n=arr.length;\\n        HashMap<Integer,Integer> map=new HashMap<>();//(ele,index)\\n        for(int i=0;i<n;i++)\\n        {\\n            map.put(arr[i],i);\\n        }\\n        int output=0;\\n        for(int i=0;i<n;i++)\\n        {\\n            int pre1=arr[i];\\n            for(int j=i+1;j<n;j++)\\n            {\\n                int pre2=arr[j];\\n                int count=2;\\n                while(map.containsKey(pre1+pre2))\\n                {\\n                    count++;\\n                    int temp=pre1;\\n                    pre1=pre2;\\n                    pre2=temp+pre2;\\n                }\\n                pre1=arr[i];    //I MISSIED UPDATING PRE1 VALUE\\n                output=Math.max(output,count);\\n            }\\n        }\\n        return output==2?0:output;\\n    }\\n}```"
                    },
                    {
                        "username": "as_97z2f",
                        "content": "The 5 length sequence is `[4, 14, 18, 32, 50]` \\u2013 I\\'m stuck on the same case."
                    },
                    {
                        "username": "munishgoyal1",
                        "content": "This definitely should have been a hard problem"
                    },
                    {
                        "username": "gadmo",
                        "content": "if this is hard almost every single dp problem have to be hard. the whole solution is just one line of dp logic plus 2-sum mapping. "
                    },
                    {
                        "username": "r4dx",
                        "content": "I\\'ve came across this while debugging my solution (which is incorrect nonetheless :))"
                    },
                    {
                        "username": "wilderfield",
                        "content": "This one is hard right?\\n\\nHad to stare at the solution for a looooong time..."
                    },
                    {
                        "username": "bupt_wc",
                        "content": "https://buptwc.github.io/2018/07/22/Leetcode-873-Length-of-Longest-Fibonacci-Subsequence/\\nHope helpful!"
                    },
                    {
                        "username": "analoglife",
                        "content": "I have solved about 30-40 DP questions so far. i\\'m still having trouble with questions like these. what am i doing wrong? will i ever get better at these?"
                    },
                    {
                        "username": "gadmo",
                        "content": "It takes practice, it came to me about after this amount of problems where now i can solve this type consistently , there is a lot of BS out there, everyone telling you you only need a small amount of problems to master every topic. dp is not easy and doing 40+ of them makes sense. if its worth your time is a different question.\nmake sure to understand the solution and recreate it on your own, also try to find someone who is clear and not using m,n,k,r as variables names."
                    },
                    {
                        "username": "kamalkumar717",
                        "content": "class Solution {\\npublic:\\n    int lenLongestFibSubseq(vector<int>& arr) {\\n        \\n        int n = arr.size();\\n\\n        unordered_map<int, int> mp;\\n        vector<vector<int>> dp(n, vector<int>(n, 2));\\n\\n        for(int i=0; i<n; ++i) {\\n            mp[arr[i]] = i;\\n        }\\n\\n        int ans = 0;\\n        for(int right=2;right<n;right++)\\n        {\\n            for(int left =1;left<right;left++)\\n            {\\n                int diff = arr[right]- arr[left];\\n\\n                if(mp.count(diff))\\n                {\\n                    \\n                    dp[left][right] = max(dp[left][right],dp[mp[diff]][left] +1);\\n                    ans = max(ans,dp[left][right]);\\n                }\\n            }\\n        }\\n        return ans>2?ans:0;\\n    }\\n};\\n\\n\\n\\n\\nwhy not accepted???"
                    },
                    {
                        "username": "coder42032",
                        "content": "can you please convert this code into dp\\nclass Solution {\\npublic:\\n    int len = 0;\\n    void recur(vector<int>&arr,int i,int j,int k,int p){\\n        len = max(len,p);\\n        if(k>=arr.size()){\\n            return;\\n        }\\n        if(i+j==arr[k] || (i==0)){\\n            recur(arr,j,arr[k],k+1,p+1);\\n        }\\n        recur(arr,i,j,k+1,p);\\n    }\\n    int lenLongestFibSubseq(vector<int>& arr) {\\n        int n = arr.size();\\n        recur(arr,0,0,0,0);\\n        if(len<3)return 0;\\n        return len;\\n    }\\n};"
                    },
                    {
                        "username": "ymgcksge",
                        "content": "I think this code\\'s time complexity is o(n^2), but it causes TLE. Could anyone examine and explain? \\nsorry I don\\'t know how to embed the code here. I would like to know how to put code here as well. \\nThank you.\\n\\nclass Solution {\\npublic:\\n    int lenLongestFibSubseq(vector<int>& arr) {\\n        int n=arr.size();\\n        vector<vector<int>> dp(n,vector<int>(n,2));\\n        map<int,int> ind;\\n        for(int i=0;i<n;i++){\\n            ind[arr[i]]=i+1;\\n        }\\n        int ret=0;\\n        for(int i=0;i<n;i++){\\n            int now=arr[i];\\n            for(int j=0;j<i;j++){\\n                int k=ind[now-arr[j]];\\n                if(!k)continue;\\n                if(k-1<=j)break;\\n                dp[k-1][i]=dp[j][k-1]+1;\\n                ret=max(ret,dp[k-1][i]);\\n            }\\n        }\\n        return (ret>=3)?ret:0;\\n    }\\n};"
                    },
                    {
                        "username": "ymgcksge",
                        "content": "I think this code\\'s time complexity is O(n^2), but it causes TLE. Could anyone explain why?\\n\\nclass Solution {\\npublic:\\n    int lenLongestFibSubseq(vector<int>& arr) {\\n        int n=arr.size();\\n        vector<vector<int>> dp(n,vector<int>(n));\\n        map<int,int> ind;\\n        for(int i=0;i<n;i++){\\n            ind[arr[i]]=i+1;\\n            for(int j=0;j<n;j++){\\n                if(i==j)dp[i][j]=-1;\\n                else dp[i][j]=2;\\n            }\\n        }\\n        int ret=0;\\n        for(int i=0;i<n;i++){\\n            int now=arr[i];\\n            for(int j=0;j<i;j++){\\n                int k=ind[now-arr[j]];\\n                if(k&&k-1!=j)dp[max(k-1,j)][i]=dp[min(k-1,j)][max(k-1,j)]+1;\\n                ret=max(ret,dp[max(k-1,j)][i]);\\n            }\\n        }\\n        return (ret>=3)?ret:0;\\n    }\\n};"
                    },
                    {
                        "username": "Sas3y",
                        "content": "you embed your code with ``` (three backticks) at the start and end of your code, so 6 in total.\nalso your code doesnt compile for me, because you didnt include vector template parameter or size type, I guess you wanted to use vector\\<int\\>.\nbut going to your main question, I believe it is O(n^2) time, but you did use map instead of unordered_map, which is slower (just changing that bumped me 10 extra test cases for submission); you also used O(n^2) memory (your dp is n*n) and thus recorded more operations such as assignment\nbut then again, I'm not great at this thing, just decided to post my first comment :)"
                    }
                ]
            }
        ]
    }
]