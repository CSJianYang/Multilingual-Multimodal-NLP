[
    {
        "title": "Minimum Path Sum",
        "question_content": "Given a m x n grid filled with non-negative numbers, find a path from top left to bottom right, which minimizes the sum of all numbers along its path.\nNote: You can only move either down or right at any point in time.\n&nbsp;\nExample 1:\n\nInput: grid = [[1,3,1],[1,5,1],[4,2,1]]\nOutput: 7\nExplanation: Because the path 1 &rarr; 3 &rarr; 1 &rarr; 1 &rarr; 1 minimizes the sum.\n\nExample 2:\n\nInput: grid = [[1,2,3],[4,5,6]]\nOutput: 12\n\n&nbsp;\nConstraints:\n\n\tm == grid.length\n\tn == grid[i].length\n\t1 <= m, n <= 200\n\t0 <= grid[i][j] <= 200",
        "solutions": [
            {
                "id": 23457,
                "title": "c-dp",
                "content": "This is a typical DP problem. Suppose the minimum path sum of arriving at point `(i, j)` is `S[i][j]`, then the state equation is `S[i][j] = min(S[i - 1][j], S[i][j - 1]) + grid[i][j]`.\\n\\nWell, some boundary conditions need to be handled. The boundary conditions happen on the topmost row (`S[i - 1][j]` does not exist) and the leftmost column (`S[i][j - 1]` does not exist). Suppose `grid` is like `[1, 1, 1, 1]`, then the minimum sum to arrive at each point is simply an accumulation of previous points and the result is `[1, 2, 3, 4]`.\\n\\nNow we can write down the following (unoptimized) code.\\n\\n    class Solution {\\n    public:\\n        int minPathSum(vector<vector<int>>& grid) {\\n            int m = grid.size();\\n            int n = grid[0].size(); \\n            vector<vector<int> > sum(m, vector<int>(n, grid[0][0]));\\n            for (int i = 1; i < m; i++)\\n                sum[i][0] = sum[i - 1][0] + grid[i][0];\\n            for (int j = 1; j < n; j++)\\n                sum[0][j] = sum[0][j - 1] + grid[0][j];\\n            for (int i = 1; i < m; i++)\\n                for (int j = 1; j < n; j++)\\n                    sum[i][j]  = min(sum[i - 1][j], sum[i][j - 1]) + grid[i][j];\\n            return sum[m - 1][n - 1];\\n        }\\n    };\\n\\nAs can be seen, each time when we update `sum[i][j]`, we only need `sum[i - 1][j]` (at the current column) and `sum[i][j - 1]` (at the left column). So we need not maintain the full `m*n` matrix. Maintaining two columns is enough and now we have the following code.\\n\\n    class Solution {\\n    public:\\n        int minPathSum(vector<vector<int>>& grid) {\\n            int m = grid.size();\\n            int n = grid[0].size();\\n            vector<int> pre(m, grid[0][0]);\\n            vector<int> cur(m, 0);\\n            for (int i = 1; i < m; i++)\\n                pre[i] = pre[i - 1] + grid[i][0];\\n            for (int j = 1; j < n; j++) { \\n                cur[0] = pre[0] + grid[0][j]; \\n                for (int i = 1; i < m; i++)\\n                    cur[i] = min(cur[i - 1], pre[i]) + grid[i][j];\\n                swap(pre, cur); \\n            }\\n            return pre[m - 1];\\n        }\\n    };\\n\\nFurther inspecting the above code, it can be seen that maintaining `pre` is for recovering `pre[i]`, which is simply `cur[i]` before its update. So it is enough to use only one vector. Now the space is further optimized and the code also gets shorter.\\n\\n    class Solution {\\n    public:\\n        int minPathSum(vector<vector<int>>& grid) {\\n            int m = grid.size();\\n            int n = grid[0].size();\\n            vector<int> cur(m, grid[0][0]);\\n            for (int i = 1; i < m; i++)\\n                cur[i] = cur[i - 1] + grid[i][0]; \\n            for (int j = 1; j < n; j++) {\\n                cur[0] += grid[0][j]; \\n                for (int i = 1; i < m; i++)\\n                    cur[i] = min(cur[i - 1], cur[i]) + grid[i][j];\\n            }\\n            return cur[m - 1];\\n        }\\n    };",
                "solutionTags": [
                    "C++",
                    "Dynamic Programming"
                ],
                "code": "class Solution {\\n    public:\\n        int minPathSum(vector<vector<int>>& grid) {\\n            int m = grid.size();\\n            int n = grid[0].size(); \\n            vector<vector<int> > sum(m, vector<int>(n, grid[0][0]));\\n            for (int i = 1; i < m; i++)\\n                sum[i][0] = sum[i - 1][0] + grid[i][0];\\n            for (int j = 1; j < n; j++)\\n                sum[0][j] = sum[0][j - 1] + grid[0][j];\\n            for (int i = 1; i < m; i++)\\n                for (int j = 1; j < n; j++)\\n                    sum[i][j]  = min(sum[i - 1][j], sum[i][j - 1]) + grid[i][j];\\n            return sum[m - 1][n - 1];\\n        }",
                "codeTag": "Java"
            },
            {
                "id": 344980,
                "title": "java-details-from-recursion-to-dp",
                "content": "I had been struggling for recursive and DP problems before. But now I feeling like I am getting better.\\nThis is a simple explanations for those who are still not that good at these just like me.\\n\\n1. Recursion:\\n\\nSo basically let\\'s begin with recursion because it is easier to understand and code. When we think about this problem, we could use a top down approach. To get a path, we need to travel from grid[0][0] to grid[row - 1][col - 1]. So let\\'s set grid[0][0] as the basic case. This is when we jump out of recursion. On the other hand, grid[row - 1][col - 1] would be the starting point. We write a helper function to do the recursion work. At the starting point, this function returns (value of the end cell + value of the cell that has the less one). But we need to consider that things could happen that we reached the first row or column and we gotta make sure that we stay within the array index limit.\\nAt last, when we reach grid[0][0], we are done!\\n\\n```\\npublic static int minPathSum(int[][] grid) {\\n\\n            int height = grid.length;\\n            int width = grid[0].length;\\n            return min(grid, height - 1, width - 1);\\n\\t\\t\\t\\n        }\\n\\t\\t\\npublic static int min(int[][]grid, int row, int col){\\n\\n            if(row == 0 && col == 0) return grid[row][col]; // this is the exit of the recursion\\n            if(row == 0) return grid[row][col] + min(grid, row, col - 1); /** when we reach the first row, we could only move horizontally.*/\\n            if(col == 0) return grid[row][col] + min(grid, row - 1, col); /** when we reach the first column, we could only move vertically.*/\\n            return grid[row][col] + Math.min(min(grid, row - 1, col), min(grid, row, col - 1)); /** we want the min sum path so we pick the cell with the less value */\\n\\t\\t\\t\\n}\\n```\\n\\n2. Dynamic Programming:\\n\\nNow, let\\'s upgrade this algorithm from recursion to DP since we don\\'t wanna get stackoverflow for large inputs. In fact, there is nothing fancy about DP. It is simply that we store or cache the results of every single calculation so that we don\\'t need to calculate the same thing again and again. The whole idea is almost the same. We just involve an array to store the values. Now let\\'s see the code:\\n\\n```\\npublic static int minPathSum(int[][] grid) {\\n\\n            int height = grid.length;\\n            int width = grid[0].length;\\n            for (int row = 0; row < height; row++) {\\n                for (int col = 0; col < width; col++) {\\n                    if(row == 0 && col == 0) grid[row][col] = grid[row][col];\\n                    else if(row == 0 && col != 0) grid[row][col] = grid[row][col] + grid[row][col - 1];\\n                    else if(col == 0 && row != 0) grid[row][col] = grid[row][col] + grid[row - 1][col];\\n                    else grid[row][col] = grid[row][col] + Math.min(grid[row - 1][col], grid[row][col - 1]);\\n                }\\n            }\\n            return grid[height - 1][width - 1];\\n        }\\n```\\n\\nLooks quite familiar, right? The idea is the same. It\\'s just we reused the grid to store each sum results to boost the whole process. See? That\\'s the difference from recursion and DP. Not that hard, right? I hope this could be helpful.",
                "solutionTags": [],
                "code": "```\\npublic static int minPathSum(int[][] grid) {\\n\\n            int height = grid.length;\\n            int width = grid[0].length;\\n            return min(grid, height - 1, width - 1);\\n\\t\\t\\t\\n        }\\n\\t\\t\\npublic static int min(int[][]grid, int row, int col){\\n\\n            if(row == 0 && col == 0) return grid[row][col]; // this is the exit of the recursion\\n            if(row == 0) return grid[row][col] + min(grid, row, col - 1); /** when we reach the first row, we could only move horizontally.*/\\n            if(col == 0) return grid[row][col] + min(grid, row - 1, col); /** when we reach the first column, we could only move vertically.*/\\n            return grid[row][col] + Math.min(min(grid, row - 1, col), min(grid, row, col - 1)); /** we want the min sum path so we pick the cell with the less value */\\n\\t\\t\\t\\n}\\n```\n```\\npublic static int minPathSum(int[][] grid) {\\n\\n            int height = grid.length;\\n            int width = grid[0].length;\\n            for (int row = 0; row < height; row++) {\\n                for (int col = 0; col < width; col++) {\\n                    if(row == 0 && col == 0) grid[row][col] = grid[row][col];\\n                    else if(row == 0 && col != 0) grid[row][col] = grid[row][col] + grid[row][col - 1];\\n                    else if(col == 0 && row != 0) grid[row][col] = grid[row][col] + grid[row - 1][col];\\n                    else grid[row][col] = grid[row][col] + Math.min(grid[row - 1][col], grid[row][col - 1]);\\n                }\\n            }\\n            return grid[height - 1][width - 1];\\n        }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3345656,
                "title": "python-java-c-simple-solution-easy-to-understand",
                "content": "# Please UPVOTE \\uD83D\\uDC4D\\n\\n**!! BIG ANNOUNCEMENT !!**\\nI am currently Giving away my premium content well-structured assignments and study materials to clear interviews at top companies related to computer science and data science to my current Subscribers this week. I planned to give for next 10,000 Subscribers as well. So **DON\\'T FORGET** to Subscribe\\n\\n**Search \\uD83D\\uDC49`Tech Wired leetcode` on YouTube to Subscribe**\\n\\n# Video Solution\\n**Search \\uD83D\\uDC49 `Minimum Path Sum by Tech Wired` on YouTube**\\n\\n![Yellow & Black Earn Money YouTube Thumbnail (1).png](https://assets.leetcode.com/users/images/7f71add2-6efd-46d3-82a0-a94fa2243b84_1679883432.537066.png)\\n\\n\\nHappy Learning, Cheers Guys \\uD83D\\uDE0A\\n\\n# Approach:\\n\\n- The code implements a dynamic programming approach to find the minimum path sum in a grid.\\n\\n- The algorithm uses a 2D array to store the minimum path sum to reach each position (i, j) in the grid, where i represents the row and j represents the column.\\n\\n- The minimum path sum to reach each position (i, j) is computed by taking the minimum of the path sum to reach the position above (i-1, j) and the position to the left (i, j-1), and adding the cost of the current position (i, j).\\n\\n- The minimum path sum to reach the bottom-right corner of the grid is stored in the last element of the array (grid[m-1][n-1]), where m is the number of rows and n is the number of columns in the grid.\\n\\n# Intuition:\\n\\n- The intuition behind the dynamic programming approach is that the minimum path sum to reach a position (i, j) in the grid can be computed by considering the minimum path sum to reach the positions (i-1, j) and (i, j-1).\\n\\n- This is because the only two possible ways to reach the position (i, j) are either by moving down from (i-1, j) or moving right from (i, j-1).\\n\\n- By computing the minimum path sum to reach each position in the grid, the algorithm can find the minimum path sum to reach the bottom-right corner of the grid by simply looking at the last element of the array (grid[m-1][n-1]).\\n\\n\\n```Python []\\nclass Solution:\\n    def minPathSum(self, grid: List[List[int]]) -> int:\\n            \\n        \\n        m, n = len(grid), len(grid[0])\\n        \\n        for i in range(1, m):\\n            grid[i][0] += grid[i-1][0]\\n        \\n        for i in range(1, n):\\n            grid[0][i] += grid[0][i-1]\\n        \\n        for i in range(1, m):\\n            for j in range(1, n):\\n                grid[i][j] += min(grid[i-1][j], grid[i][j-1])\\n        \\n        return grid[-1][-1]\\n    \\n        # An Upvote will be encouraging\\n\\n```\\n```Java []\\nclass Solution {\\n    public int minPathSum(int[][] grid) {\\n        int m = grid.length;\\n        int n = grid[0].length;\\n        \\n        for (int i = 1; i < m; i++) {\\n            grid[i][0] += grid[i-1][0];\\n        }\\n        \\n        for (int j = 1; j < n; j++) {\\n            grid[0][j] += grid[0][j-1];\\n        }\\n        \\n        for (int i = 1; i < m; i++) {\\n            for (int j = 1; j < n; j++) {\\n                grid[i][j] += Math.min(grid[i-1][j], grid[i][j-1]);\\n            }\\n        }\\n        \\n        return grid[m-1][n-1];\\n    }\\n}\\n\\n\\n```\\n```C++ []\\nclass Solution {\\npublic:\\n    int minPathSum(vector<vector<int>>& grid) {\\n        int m = grid.size();\\n        int n = grid[0].size();\\n        \\n        for (int i = 1; i < m; i++) {\\n            grid[i][0] += grid[i-1][0];\\n        }\\n        \\n        for (int j = 1; j < n; j++) {\\n            grid[0][j] += grid[0][j-1];\\n        }\\n        \\n        for (int i = 1; i < m; i++) {\\n            for (int j = 1; j < n; j++) {\\n                grid[i][j] += min(grid[i-1][j], grid[i][j-1]);\\n            }\\n        }\\n        \\n        return grid[m-1][n-1];\\n    }\\n};\\n\\n\\n```\\n\\n![image.png](https://assets.leetcode.com/users/images/e2515d84-99cf-4499-80fb-fe458e1bbae2_1678932606.8004954.png)\\n\\n# Please UPVOTE \\uD83D\\uDC4D",
                "solutionTags": [
                    "C++",
                    "Java",
                    "Python3",
                    "Array",
                    "Dynamic Programming"
                ],
                "code": "```Python []\\nclass Solution:\\n    def minPathSum(self, grid: List[List[int]]) -> int:\\n            \\n        \\n        m, n = len(grid), len(grid[0])\\n        \\n        for i in range(1, m):\\n            grid[i][0] += grid[i-1][0]\\n        \\n        for i in range(1, n):\\n            grid[0][i] += grid[0][i-1]\\n        \\n        for i in range(1, m):\\n            for j in range(1, n):\\n                grid[i][j] += min(grid[i-1][j], grid[i][j-1])\\n        \\n        return grid[-1][-1]\\n    \\n        # An Upvote will be encouraging\\n\\n```\n```Java []\\nclass Solution {\\n    public int minPathSum(int[][] grid) {\\n        int m = grid.length;\\n        int n = grid[0].length;\\n        \\n        for (int i = 1; i < m; i++) {\\n            grid[i][0] += grid[i-1][0];\\n        }\\n        \\n        for (int j = 1; j < n; j++) {\\n            grid[0][j] += grid[0][j-1];\\n        }\\n        \\n        for (int i = 1; i < m; i++) {\\n            for (int j = 1; j < n; j++) {\\n                grid[i][j] += Math.min(grid[i-1][j], grid[i][j-1]);\\n            }\\n        }\\n        \\n        return grid[m-1][n-1];\\n    }\\n}\\n\\n\\n```\n```C++ []\\nclass Solution {\\npublic:\\n    int minPathSum(vector<vector<int>>& grid) {\\n        int m = grid.size();\\n        int n = grid[0].size();\\n        \\n        for (int i = 1; i < m; i++) {\\n            grid[i][0] += grid[i-1][0];\\n        }\\n        \\n        for (int j = 1; j < n; j++) {\\n            grid[0][j] += grid[0][j-1];\\n        }\\n        \\n        for (int i = 1; i < m; i++) {\\n            for (int j = 1; j < n; j++) {\\n                grid[i][j] += min(grid[i-1][j], grid[i][j-1]);\\n            }\\n        }\\n        \\n        return grid[m-1][n-1];\\n    }\\n};\\n\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 23466,
                "title": "simple-python-dp-70ms",
                "content": "\\n\\n    def minPathSum(self, grid):\\n        m = len(grid)\\n        n = len(grid[0])\\n        for i in range(1, n):\\n            grid[0][i] += grid[0][i-1]\\n        for i in range(1, m):\\n            grid[i][0] += grid[i-1][0]\\n        for i in range(1, m):\\n            for j in range(1, n):\\n                grid[i][j] += min(grid[i-1][j], grid[i][j-1])\\n        return grid[-1][-1]",
                "solutionTags": [
                    "Python",
                    "Dynamic Programming"
                ],
                "code": "\\n\\n    def minPathSum(self, grid):\\n        m = len(grid)\\n        n = len(grid[0])\\n        for i in range(1, n):\\n            grid[0][i] += grid[0][i-1]\\n        for i in range(1, m):\\n            grid[i][0] += grid[i-1][0]\\n        for i in range(1, m):\\n            for j in range(1, n):\\n                grid[i][j] += min(grid[i-1][j], grid[i][j-1])\\n        return grid[-1][-1]",
                "codeTag": "Python3"
            },
            {
                "id": 23471,
                "title": "dp-with-o-n-n-space-complexity",
                "content": "\\tpublic int minPathSum(int[][] grid) {\\n\\t\\tint m = grid.length;// row\\n\\t\\tint n = grid[0].length; // column\\n\\t\\tfor (int i = 0; i < m; i++) {\\n\\t\\t\\tfor (int j = 0; j < n; j++) {\\n\\t\\t\\t\\tif (i == 0 && j != 0) {\\n\\t\\t\\t\\t\\tgrid[i][j] = grid[i][j] + grid[i][j - 1];\\n\\t\\t\\t\\t} else if (i != 0 && j == 0) {\\n\\t\\t\\t\\t\\tgrid[i][j] = grid[i][j] + grid[i - 1][j];\\n\\t\\t\\t\\t} else if (i == 0 && j == 0) {\\n\\t\\t\\t\\t\\tgrid[i][j] = grid[i][j];\\n\\t\\t\\t\\t} else {\\n\\t\\t\\t\\t\\tgrid[i][j] = Math.min(grid[i][j - 1], grid[i - 1][j])\\n\\t\\t\\t\\t\\t\\t\\t+ grid[i][j];\\n\\t\\t\\t\\t}\\n\\t\\t\\t}\\n\\t\\t}\\n\\n\\t\\treturn grid[m - 1][n - 1];\\n\\t}",
                "solutionTags": [],
                "code": "\\tpublic int minPathSum(int[][] grid) {\\n\\t\\tint m = grid.length;// row\\n\\t\\tint n = grid[0].length; // column\\n\\t\\tfor (int i = 0; i < m; i++) {\\n\\t\\t\\tfor (int j = 0; j < n; j++) {\\n\\t\\t\\t\\tif (i == 0 && j != 0) {\\n\\t\\t\\t\\t\\tgrid[i][j] = grid[i][j] + grid[i][j - 1];\\n\\t\\t\\t\\t} else if (i != 0 && j == 0) {\\n\\t\\t\\t\\t\\tgrid[i][j] = grid[i][j] + grid[i - 1][j];\\n\\t\\t\\t\\t} else if (i == 0 && j == 0) {\\n\\t\\t\\t\\t\\tgrid[i][j] = grid[i][j];\\n\\t\\t\\t\\t} else {\\n\\t\\t\\t\\t\\tgrid[i][j] = Math.min(grid[i][j - 1], grid[i - 1][j])\\n\\t\\t\\t\\t\\t\\t\\t+ grid[i][j];\\n\\t\\t\\t\\t}\\n\\t\\t\\t}\\n\\t\\t}\\n\\n\\t\\treturn grid[m - 1][n - 1];\\n\\t}",
                "codeTag": "Unknown"
            },
            {
                "id": 584967,
                "title": "python-grid-reduction-sounds-fancy-but-a-simple-method-no-additional-space",
                "content": "Let\\'s think of this problem in a super simple manner.\\n\\nOne important thing to remember is you can only walk right and down.\\n*Notation I am going to use (row, column).*\\n\\nWe are going to walk over the cells (the two for loops in the code). And each time we step on a cell, we are going to ask a question to ourself, how can I get to this cell with minimum sum from the previous step? Well, for the first cell (0,0) we don\\'t need to do anything, right?\\n\\nNext, think of walking over cell (0,1). What is the minimum sum to get to this cell? Well, it is too simple, just add the current number in the cell with the number of the cell on the left (for the case of (0,1) add it with the number in (0,0). This behavior is same for all the cells in the topmost row.\\n\\nNow, we get to the second row, we ask the same qustion for the cell in (1,0). How can we get here with minimum sum? This is too simple, add the number in (1,0) with (0,0). But now, when we get to (1,1), we have to add the number in (1,1) with **minimum** number from the cell above and the cell on the left. By this time, your cell above and the one on the left already contains the minimum sum path up to that cell. How conveninet, right? ^_^\\n\\nThat\\'s all you gotta do. And whenever you step on the cell, update the cell accordingly.\\n\\nWe don\\'t even need to use any additional space, we will overwrite stuff in the original grid. Why can we do this? We can do this since we are processing the grid and every point that we are currently reaching at bascially has the minimum sum *up to that cell*. We are accumulating the minimum sum path as we walk over the grid.\\n\\n\\n```\\nclass Solution:\\n    def minPathSum(self, grid: List[List[int]]) -> int:\\n        if len(grid) <= 0 or grid is None:\\n            return 0\\n        rows = len(grid)\\n        cols = len(grid[0])\\n        \\n        for r in range(rows):\\n            for c in range(cols):\\n                if r==0 and c==0: # We just want to skip the top-left corner of the grid\\n                    continue\\n                if r-1<0: # Cases for elements in top row\\n                    grid[r][c] = grid[r][c] + grid[r][c-1]  \\n                elif c-1<0: # Cases for elements in leftmost column\\n                    grid[r][c] = grid[r][c] + grid[r-1][c]  \\n                else: # Normal cell\\n                    grid[r][c] = grid[r][c] + min(grid[r-1][c], grid[r][c-1])               \\n        \\n        return grid[rows-1][cols-1] # We have got the minimum path accumaled at the bottom-right corner, just return this\\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def minPathSum(self, grid: List[List[int]]) -> int:\\n        if len(grid) <= 0 or grid is None:\\n            return 0\\n        rows = len(grid)\\n        cols = len(grid[0])\\n        \\n        for r in range(rows):\\n            for c in range(cols):\\n                if r==0 and c==0: # We just want to skip the top-left corner of the grid\\n                    continue\\n                if r-1<0: # Cases for elements in top row\\n                    grid[r][c] = grid[r][c] + grid[r][c-1]  \\n                elif c-1<0: # Cases for elements in leftmost column\\n                    grid[r][c] = grid[r][c] + grid[r-1][c]  \\n                else: # Normal cell\\n                    grid[r][c] = grid[r][c] + min(grid[r-1][c], grid[r][c-1])               \\n        \\n        return grid[rows-1][cols-1] # We have got the minimum path accumaled at the bottom-right corner, just return this\\n```",
                "codeTag": "Java"
            },
            {
                "id": 23647,
                "title": "my-8-lines-simple-solution",
                "content": "    int m = grid.length, n = grid[0].length;\\n    for(int i = 0; i < m; i++){\\n    \\tfor(int j = 0; j < n; j++){\\n    \\tif(i == 0 && j != 0) grid[i][j] += grid[i][j-1];\\n    \\tif(i != 0 && j == 0) grid[i][j] += grid[i-1][j];\\n    \\tif (i != 0 && j != 0) grid[i][j] += Math.min(grid[i-1][j], grid[i][j-1]);\\n    \\t}\\n    }\\n    return grid[m-1][n-1];",
                "solutionTags": [],
                "code": "    int m = grid.length, n = grid[0].length;\\n    for(int i = 0; i < m; i++){\\n    \\tfor(int j = 0; j < n; j++){\\n    \\tif(i == 0 && j != 0) grid[i][j] += grid[i][j-1];\\n    \\tif(i != 0 && j == 0) grid[i][j] += grid[i-1][j];\\n    \\tif (i != 0 && j != 0) grid[i][j] += Math.min(grid[i-1][j], grid[i][j-1]);\\n    \\t}\\n    }\\n    return grid[m-1][n-1];",
                "codeTag": "Unknown"
            },
            {
                "id": 584892,
                "title": "c-crystal-clear-dp",
                "content": "Question Decoration:\\n* Consider the matrix as a rectangular plot,\\nand grids as houses\\n* Now, you have to go from top-left house to bottom right    house\\n* Also when you are in some house, you have to pay the rent\\n* You can move by only one house at a time, either to Right   house  or to Down house\\n* You have to find the minimum rent to reach the bottom-Right house\\n------------------------------------------------------------------------\\nSolution:\\nWhy DP???\\nBECAUSE this problem requires optimizing the rent(minimum rent),and at each step we have multiple options, therefore we will use DP\\nsteps:\\n* Create a dp array of same size as grid\\n* dp[0][0] = grid[0][0] , b\\'coz we are initially in this house\\n* dp[i][j] means minimum rent i need to pay to reach the house [i,j]\\n* for 0th row , there is only one way to reach any house, and that is by moving to right, therefore ,\\n          dp[0][i] = dp[0][i-1] + grid[0][i]  (rent paid so far + rent for this house)\\n* for 0th column, there is only one way to reach any house, and that is by moving down, therefore,\\n         dp[i][0] = dp[i-1][0] + grid[i][0]  (rent paid so far + rent for this house)\\n* And now for rest of the houses in the grid, say grid[i][j]\\n         * we can reach either from grid[i-1][j]\\n         * or from grid[i][j-1]\\n         * we will choose the one with minimum rent\\n         therefore, dp[i][j] = min(dp[i-1][j],dp[i][j-1]) + grid[i][j]\\n* and .....\\nWe are Done \\uD83D\\uDE03\\n----------------------------------------\\nCODE:\\n```\\nint minPathSum(vector<vector<int>>& grid) {\\n    int m = grid.size();\\n    int n = grid[0].size();\\n    vector<vector<int>> dp(m,vector<int>(n,0));\\n    dp[0][0] = grid[0][0];\\n    for(int i=1;i<m;i++)\\n        dp[i][0] = dp[i-1][0] + grid[i][0];\\n    for(int j=1;j<n;j++)\\n        dp[0][j] = dp[0][j-1] + grid[0][j];\\n     for(int i=1;i<m;i++)\\n         for(int j=1;j<n;j++)\\n             dp[i][j] = min(dp[i-1][j],dp[i][j-1]) + grid[i][j];\\n        return dp[m-1][n-1];\\n    }",
                "solutionTags": [],
                "code": "Question Decoration:\\n* Consider the matrix as a rectangular plot,\\nand grids as houses\\n* Now, you have to go from top-left house to bottom right    house\\n* Also when you are in some house, you have to pay the rent\\n* You can move by only one house at a time, either to Right   house  or to Down house\\n* You have to find the minimum rent to reach the bottom-Right house\\n------------------------------------------------------------------------\\nSolution:\\nWhy DP???\\nBECAUSE this problem requires optimizing the rent(minimum rent),and at each step we have multiple options, therefore we will use DP\\nsteps:\\n* Create a dp array of same size as grid\\n* dp[0][0] = grid[0][0] , b\\'coz we are initially in this house\\n* dp[i][j] means minimum rent i need to pay to reach the house [i,j]\\n* for 0th row , there is only one way to reach any house, and that is by moving to right, therefore ,\\n          dp[0][i] = dp[0][i-1] + grid[0][i]  (rent paid so far + rent for this house)\\n* for 0th column, there is only one way to reach any house, and that is by moving down, therefore,\\n         dp[i][0] = dp[i-1][0] + grid[i][0]  (rent paid so far + rent for this house)\\n* And now for rest of the houses in the grid, say grid[i][j]\\n         * we can reach either from grid[i-1][j]\\n         * or from grid[i][j-1]\\n         * we will choose the one with minimum rent\\n         therefore, dp[i][j] = min(dp[i-1][j],dp[i][j-1]) + grid[i][j]\\n* and .....\\nWe are Done \\uD83D\\uDE03\\n----------------------------------------\\nCODE:\\n```\\nint minPathSum(vector<vector<int>>& grid) {\\n    int m = grid.size();\\n    int n = grid[0].size();\\n    vector<vector<int>> dp(m,vector<int>(n,0));\\n    dp[0][0] = grid[0][0];\\n    for(int i=1;i<m;i++)\\n        dp[i][0] = dp[i-1][0] + grid[i][0];\\n    for(int j=1;j<n;j++)\\n        dp[0][j] = dp[0][j-1] + grid[0][j];\\n     for(int i=1;i<m;i++)\\n         for(int j=1;j<n;j++)\\n             dp[i][j] = min(dp[i-1][j],dp[i][j-1]) + grid[i][j];\\n        return dp[m-1][n-1];\\n    }",
                "codeTag": "Unknown"
            },
            {
                "id": 856314,
                "title": "sequential-thought-recursion-memo-dp-faster-easy-understanding",
                "content": "```\\n// sequential thought process for this problem\\n\\n//The path to reach (m, n) must be through one of the 2 cells:(m-1, n) or (m, n-1). So minimum cost to reach (m, n) can be written as \\u201Cminimum of the 2 cells plus cost[m][n]\\u201D.\\n//minCost(m, n) =min(minCost(m-1, n), minCost(m, n-1) )+ cost[m][n]\\n\\n//1.Recursion(TLE) [time complexity of the code is exponential]\\n\\nclass Solution {\\npublic:\\n    int minCost(vector<vector<int>> &cost,int m, int n) { \\n      if (n <0 || m <0) \\n         return INT_MAX; \\n      else if(m==0 && n==0) \\n         return cost[m][n]; \\n        \\n      return cost[m][n]+min(minCost(cost,m-1,n),minCost(cost,m,n-1)); \\n    } \\n    \\n    int minPathSum(vector<vector<int>>& grid) {\\n        int M=grid.size(),N=grid[0].size();\\n        return minCost(grid,M-1,N-1);\\n    }\\n    \\n};\\n\\n//2.memoization[faster than 71.35% ]\\n\\nclass Solution {\\npublic:\\n    int minCost(vector<vector<int>> &cost,int m, int n,vector<vector<int>>& memo) { \\n      if (n <0 || m <0) \\n         return INT_MAX; \\n      else if(m==0 && n==0) \\n         return cost[m][n]; \\n      if(memo[m][n]!=-1)\\n          return memo[m][n];\\n      int r=cost[m][n]+min(minCost(cost,m-1,n,memo),minCost(cost,m,n-1,memo));\\n        memo[m][n]=r;\\n      return r;\\n    } \\n    \\n    int minPathSum(vector<vector<int>>& grid) {\\n        int m=grid.size(),n=grid[0].size();\\n        vector<vector<int>> memo(m,vector<int>(n, -1));\\n        return minCost(grid,m-1,n-1,memo);\\n    }\\n    \\n};\\n\\n//3. Dynamic Programming [ faster than 71.65% ] [ TC: (m*n) ]\\n\\nclass Solution {\\npublic:\\n    int minCost(vector<vector<int>> &cost,int m, int n,vector<vector<int>> dp) { \\n      dp[m-1][n-1]=cost[m-1][n-1];\\n      for(int i=n-2;i>=0;i--){\\n          dp[m-1][i]=dp[m-1][i+1]+cost[m-1][i];\\n      } \\n      for(int i=m-2;i>=0;i--){\\n          dp[i][n-1]=dp[i+1][n-1]+cost[i][n-1];\\n      }\\n      for(int i=m-2;i>=0;i--){\\n          for(int j=n-2;j>=0;j--){\\n              dp[i][j]=cost[i][j]+min(dp[i+1][j],dp[i][j+1]);\\n          }\\n      }\\n      return dp[0][0];\\n    } \\n    \\n    int minPathSum(vector<vector<int>>& grid) {\\n        int m=grid.size(),n=grid[0].size();\\n        vector<vector<int>> dp(m,vector<int>(n, 0));\\n        return minCost(grid,m,n,dp);\\n    }\\n    \\n};\\n```\\n**Feel free to ask any question in the comment section.**\\nI hope that you\\'ve found the solution useful.\\nIn that case, **please do upvote and encourage me** to on my quest to document all leetcode problems\\uD83D\\uDE03\\nHappy Coding :)\\n",
                "solutionTags": [
                    "C++",
                    "C",
                    "Dynamic Programming",
                    "Recursion",
                    "Memoization"
                ],
                "code": "```\\n// sequential thought process for this problem\\n\\n//The path to reach (m, n) must be through one of the 2 cells:(m-1, n) or (m, n-1). So minimum cost to reach (m, n) can be written as \\u201Cminimum of the 2 cells plus cost[m][n]\\u201D.\\n//minCost(m, n) =min(minCost(m-1, n), minCost(m, n-1) )+ cost[m][n]\\n\\n//1.Recursion(TLE) [time complexity of the code is exponential]\\n\\nclass Solution {\\npublic:\\n    int minCost(vector<vector<int>> &cost,int m, int n) { \\n      if (n <0 || m <0) \\n         return INT_MAX; \\n      else if(m==0 && n==0) \\n         return cost[m][n]; \\n        \\n      return cost[m][n]+min(minCost(cost,m-1,n),minCost(cost,m,n-1)); \\n    } \\n    \\n    int minPathSum(vector<vector<int>>& grid) {\\n        int M=grid.size(),N=grid[0].size();\\n        return minCost(grid,M-1,N-1);\\n    }\\n    \\n};\\n\\n//2.memoization[faster than 71.35% ]\\n\\nclass Solution {\\npublic:\\n    int minCost(vector<vector<int>> &cost,int m, int n,vector<vector<int>>& memo) { \\n      if (n <0 || m <0) \\n         return INT_MAX; \\n      else if(m==0 && n==0) \\n         return cost[m][n]; \\n      if(memo[m][n]!=-1)\\n          return memo[m][n];\\n      int r=cost[m][n]+min(minCost(cost,m-1,n,memo),minCost(cost,m,n-1,memo));\\n        memo[m][n]=r;\\n      return r;\\n    } \\n    \\n    int minPathSum(vector<vector<int>>& grid) {\\n        int m=grid.size(),n=grid[0].size();\\n        vector<vector<int>> memo(m,vector<int>(n, -1));\\n        return minCost(grid,m-1,n-1,memo);\\n    }\\n    \\n};\\n\\n//3. Dynamic Programming [ faster than 71.65% ] [ TC: (m*n) ]\\n\\nclass Solution {\\npublic:\\n    int minCost(vector<vector<int>> &cost,int m, int n,vector<vector<int>> dp) { \\n      dp[m-1][n-1]=cost[m-1][n-1];\\n      for(int i=n-2;i>=0;i--){\\n          dp[m-1][i]=dp[m-1][i+1]+cost[m-1][i];\\n      } \\n      for(int i=m-2;i>=0;i--){\\n          dp[i][n-1]=dp[i+1][n-1]+cost[i][n-1];\\n      }\\n      for(int i=m-2;i>=0;i--){\\n          for(int j=n-2;j>=0;j--){\\n              dp[i][j]=cost[i][j]+min(dp[i+1][j],dp[i][j+1]);\\n          }\\n      }\\n      return dp[0][0];\\n    } \\n    \\n    int minPathSum(vector<vector<int>>& grid) {\\n        int m=grid.size(),n=grid[0].size();\\n        vector<vector<int>> dp(m,vector<int>(n, 0));\\n        return minCost(grid,m,n,dp);\\n    }\\n    \\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 23477,
                "title": "dp-solution-linear-space",
                "content": "You can only reach a cell by going from its left or top neighbor.\\n\\n    class Solution {\\n    public:\\n        int minPathSum(vector<vector<int> > &grid) {\\n            if(!grid.size())return 0;\\n            const int rows=grid.size(),cols=grid[0].size();\\n            // r[i] == min path sum to previous row's column i.\\n            vector<int> r(cols,0);\\n            int i,j;\\n            r[0]=grid[0][0];\\n            for(j=1;j<cols;j++){\\n                r[j]=grid[0][j]+r[j-1];       \\n            }\\n            for(i=1;i<rows;i++){\\n                r[0]+=grid[i][0];\\n                for(j=1;j<cols;j++){\\n                    r[j]=min(r[j-1],r[j])+grid[i][j];\\n                }\\n            }\\n            return r[cols-1];\\n        }\\n    };",
                "solutionTags": [],
                "code": "class Solution {\\n    public:\\n        int minPathSum(vector<vector<int> > &grid) {\\n            if(!grid.size())return 0;\\n            const int rows=grid.size(),cols=grid[0].size();\\n            // r[i] == min path sum to previous row's column i.\\n            vector<int> r(cols,0);\\n            int i,j;\\n            r[0]=grid[0][0];\\n            for(j=1;j<cols;j++){\\n                r[j]=grid[0][j]+r[j-1];       \\n            }",
                "codeTag": "Java"
            },
            {
                "id": 23613,
                "title": "python-easy-to-understand-solutions-o-m-n-o-n-space",
                "content": "```\\nclass Solution(object):\\n    def minPathSum1(self, grid):\\n        r, c = len(grid), len(grid[0])\\n        dp = [[grid[0][0] for _ in range(c)] for _ in range(r)]\\n        for i in range(1, r):\\n            dp[i][0] = dp[i-1][0] + grid[i][0]\\n        for j in range(1, c):\\n            dp[0][j] = dp[0][j-1] + grid[0][j]\\n        for i in range(1, r):\\n            for j in range(1, c):\\n                dp[i][j] = min(dp[i-1][j], dp[i][j-1]) + grid[i][j]\\n        return dp[-1][-1]\\n    \\n    def minPathSum(self, grid):\\n        r, c = len(grid), len(grid[0])\\n        dp = [grid[0][0] for _ in range(c)]\\n        for j in range(1, c):\\n            dp[j] = dp[j-1] + grid[0][j]\\n        for i in range(1, r):\\n            dp[0] += grid[i][0]\\n            for j in range(1, c):\\n                dp[j] = min(dp[j-1], dp[j]) + grid[i][j]\\n        return dp[-1]\\n```",
                "solutionTags": [
                    "Python",
                    "Dynamic Programming"
                ],
                "code": "```\\nclass Solution(object):\\n    def minPathSum1(self, grid):\\n        r, c = len(grid), len(grid[0])\\n        dp = [[grid[0][0] for _ in range(c)] for _ in range(r)]\\n        for i in range(1, r):\\n            dp[i][0] = dp[i-1][0] + grid[i][0]\\n        for j in range(1, c):\\n            dp[0][j] = dp[0][j-1] + grid[0][j]\\n        for i in range(1, r):\\n            for j in range(1, c):\\n                dp[i][j] = min(dp[i-1][j], dp[i][j-1]) + grid[i][j]\\n        return dp[-1][-1]\\n    \\n    def minPathSum(self, grid):\\n        r, c = len(grid), len(grid[0])\\n        dp = [grid[0][0] for _ in range(c)]\\n        for j in range(1, c):\\n            dp[j] = dp[j-1] + grid[0][j]\\n        for i in range(1, r):\\n            dp[0] += grid[i][0]\\n            for j in range(1, c):\\n                dp[j] = min(dp[j-1], dp[j]) + grid[i][j]\\n        return dp[-1]\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3345999,
                "title": "python3-c-dp-91-ms-beats-94-21",
                "content": "This code is an implementation of the minimum path sum problem on a 2D grid. The problem requires finding the minimum sum of numbers along a path from the top-left corner to the bottom-right corner of the grid.\\n\\nThe function takes a 2D list of integers grid as input, which represents the values in the grid. The function uses dynamic programming approach to solve the problem.\\n\\nFirst, the function determines the dimensions of the grid using the len() function. Then, it iterates over the grid using two nested for loops to check each cell of the grid.\\n\\nFor each cell, the function checks if it is on the top row or the leftmost column of the grid. If the cell is on the top row, the function adds the value of the cell to the value of the cell immediately to its left. Similarly, if the cell is on the leftmost column, the function adds the value of the cell to the value of the cell immediately above it.\\n\\nFor all other cells, the function adds the value of the cell to the minimum value of the cells directly above and directly to the left of the current cell.\\n\\nFinally, the function returns the value in the bottom-right corner of the grid, which represents the minimum path sum.\\n![image.png](https://assets.leetcode.com/users/images/6e1928e7-6041-4e68-afbc-504275ec9b60_1679888401.7288485.png)\\n# Please Upvote \\uD83D\\uDE07\\n\\n## Python3\\n```\\nclass Solution:\\n    def minPathSum(self, grid: List[List[int]]) -> int:\\n        n=len(grid)\\n        m=len(grid[0])\\n        for i in range(n):\\n            for j in range(m):\\n                if i==0:\\n                    if j!=0:\\n                        grid[i][j]+=grid[i][j-1]\\n                elif j==0:\\n                    if i!=0:\\n                        grid[i][j]+=grid[i-1][j]\\n                else:\\n                    grid[i][j]+=min(grid[i-1][j],grid[i][j-1])\\n        return grid[n-1][m-1]\\n```\\n# C++\\n```\\nclass Solution {\\npublic:\\n    int minPathSum(vector<vector<int>>& grid) {\\n        int n=grid.size(),m=grid[0].size();\\n        for(int i=0;i<n;i++){\\n            for(int j=0;j<m;j++){\\n                if(i==0 and j!=0) grid[i][j]+=grid[i][j-1];\\n                if(j==0 and i!=0) grid[i][j]+=grid[i-1][j];\\n                if(i!=0 and j!=0) grid[i][j]+=min(grid[i-1][j],grid[i][j-1]);\\n            }\\n        }\\n        return grid[n-1][m-1];\\n    }\\n};\\n```\\n![image.png](https://assets.leetcode.com/users/images/a6c83c54-1d1a-4f26-8273-b687d119dd5b_1679889261.1494205.png)\\n",
                "solutionTags": [
                    "Python3",
                    "Dynamic Programming"
                ],
                "code": "```\\nclass Solution:\\n    def minPathSum(self, grid: List[List[int]]) -> int:\\n        n=len(grid)\\n        m=len(grid[0])\\n        for i in range(n):\\n            for j in range(m):\\n                if i==0:\\n                    if j!=0:\\n                        grid[i][j]+=grid[i][j-1]\\n                elif j==0:\\n                    if i!=0:\\n                        grid[i][j]+=grid[i-1][j]\\n                else:\\n                    grid[i][j]+=min(grid[i-1][j],grid[i][j-1])\\n        return grid[n-1][m-1]\\n```\n```\\nclass Solution {\\npublic:\\n    int minPathSum(vector<vector<int>>& grid) {\\n        int n=grid.size(),m=grid[0].size();\\n        for(int i=0;i<n;i++){\\n            for(int j=0;j<m;j++){\\n                if(i==0 and j!=0) grid[i][j]+=grid[i][j-1];\\n                if(j==0 and i!=0) grid[i][j]+=grid[i-1][j];\\n                if(i!=0 and j!=0) grid[i][j]+=min(grid[i-1][j],grid[i][j-1]);\\n            }\\n        }\\n        return grid[n-1][m-1];\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1202628,
                "title": "c-three-solutions-recursion-top-down-bottom-up-easy-to-understand",
                "content": "**Recursive Solution**\\n\\n```\\nint getMinPath(vector <vector <int>> &grid, int i, int j) {\\n        if (i == 0 && j == 0) {\\n            return grid[i][j];\\n        }\\n        int m = INT_MAX;\\n        if (j > 0) {\\n            m = grid[i][j] + getMinPath(grid, i, j - 1);\\n        }\\n        if (i > 0) {\\n            int s = grid[i][j] + getMinPath(grid, i - 1, j);\\n            m = min(m, s);\\n        }\\n        return m;\\n    }\\n    \\n```\\n\\n<br>\\n<hr>\\n<br>\\n\\n**Top Down DP - Memoization**\\n\\n```\\nint getMinPath(vector <vector <int>> &grid, int i, int j, vector <vector<int>> &dp) {\\n        if (i == 0 && j == 0) {\\n            return grid[i][j];\\n        }\\n        if (dp[i][j] != -1) {\\n            return dp[i][j];\\n        }\\n        \\n        int m = INT_MAX;\\n        if (j > 0) {\\n            m = grid[i][j] + getMinPath(grid, i, j - 1, dp);\\n        }\\n        if (i > 0) {\\n            int s = grid[i][j] + getMinPath(grid, i - 1, j, dp);\\n            m = min(m, s);\\n        }\\n        \\n        dp[i][j] = m;\\n        return dp[i][j];\\n    }\\n```\\n\\n<br>\\n<hr>\\n<br>\\n\\n**Bottom Up DP - Table Filling**\\n\\n```\\nint getMinPath(vector <vector <int>> &grid) {\\n        int r = grid.size();\\n        int c = grid[0].size();\\n\\n        vector <vector <int>> dp(r, vector <int>(c, 0));\\n        dp[0][0] = grid[0][0];\\n        \\n        for (int i = 1; i < c; i++) {\\n            dp[0][i] = grid[0][i] + dp[0][i - 1];\\n        }\\n        \\n        for (int i = 1; i < r; i++) {\\n            dp[i][0] = grid[i][0] + dp[i - 1][0];\\n        }\\n\\n        for (int i = 1; i < r; i++) {\\n            for (int j = 1; j < c; j++) {\\n                dp[i][j] = grid[i][j] + min(dp[i - 1][j], dp[i][j - 1]);\\n            }\\n        }\\n         \\n        return dp[r - 1][c - 1];\\n    }\\n```",
                "solutionTags": [
                    "C++",
                    "C",
                    "Dynamic Programming",
                    "Recursion",
                    "Memoization"
                ],
                "code": "```\\nint getMinPath(vector <vector <int>> &grid, int i, int j) {\\n        if (i == 0 && j == 0) {\\n            return grid[i][j];\\n        }\\n        int m = INT_MAX;\\n        if (j > 0) {\\n            m = grid[i][j] + getMinPath(grid, i, j - 1);\\n        }\\n        if (i > 0) {\\n            int s = grid[i][j] + getMinPath(grid, i - 1, j);\\n            m = min(m, s);\\n        }\\n        return m;\\n    }\\n    \\n```\n```\\nint getMinPath(vector <vector <int>> &grid, int i, int j, vector <vector<int>> &dp) {\\n        if (i == 0 && j == 0) {\\n            return grid[i][j];\\n        }\\n        if (dp[i][j] != -1) {\\n            return dp[i][j];\\n        }\\n        \\n        int m = INT_MAX;\\n        if (j > 0) {\\n            m = grid[i][j] + getMinPath(grid, i, j - 1, dp);\\n        }\\n        if (i > 0) {\\n            int s = grid[i][j] + getMinPath(grid, i - 1, j, dp);\\n            m = min(m, s);\\n        }\\n        \\n        dp[i][j] = m;\\n        return dp[i][j];\\n    }\\n```\n```\\nint getMinPath(vector <vector <int>> &grid) {\\n        int r = grid.size();\\n        int c = grid[0].size();\\n\\n        vector <vector <int>> dp(r, vector <int>(c, 0));\\n        dp[0][0] = grid[0][0];\\n        \\n        for (int i = 1; i < c; i++) {\\n            dp[0][i] = grid[0][i] + dp[0][i - 1];\\n        }\\n        \\n        for (int i = 1; i < r; i++) {\\n            dp[i][0] = grid[i][0] + dp[i - 1][0];\\n        }\\n\\n        for (int i = 1; i < r; i++) {\\n            for (int j = 1; j < c; j++) {\\n                dp[i][j] = grid[i][j] + min(dp[i - 1][j], dp[i][j - 1]);\\n            }\\n        }\\n         \\n        return dp[r - 1][c - 1];\\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1467216,
                "title": "python-bottom-up-dp-in-place-clean-concise",
                "content": "**Idea**\\n- For the current cell `[r, c]`, there are two options to choose:\\n\\t- Choose from up cell `[r-1, c]` go down to `[r, c]`.\\n\\t- Choose from left cell `[r, c-1]` go right to `[r, c]`.\\n- So, we need to choose minium cost between 2 above options.\\n```python\\nclass Solution:\\n    def minPathSum(self, grid: List[List[int]]) -> int:\\n        m, n = len(grid), len(grid[0])\\n        for r in range(m):\\n            for c in range(n):\\n                if r == 0 and c == 0:\\n                    pass\\n                elif r == 0:\\n                    grid[r][c] += grid[r][c-1]\\n                elif c == 0:\\n                    grid[r][c] += grid[r-1][c]\\n                else:\\n                    grid[r][c] += min(grid[r-1][c], grid[r][c-1])\\n        return grid[m-1][n-1]\\n```\\nComplexity:\\n- Time: `O(M*N)`, where `M <= 200` is number of rows, `N <= 200` is number of columns.\\n- Space: `O(1)`",
                "solutionTags": [],
                "code": "```python\\nclass Solution:\\n    def minPathSum(self, grid: List[List[int]]) -> int:\\n        m, n = len(grid), len(grid[0])\\n        for r in range(m):\\n            for c in range(n):\\n                if r == 0 and c == 0:\\n                    pass\\n                elif r == 0:\\n                    grid[r][c] += grid[r][c-1]\\n                elif c == 0:\\n                    grid[r][c] += grid[r-1][c]\\n                else:\\n                    grid[r][c] += min(grid[r-1][c], grid[r][c-1])\\n        return grid[m-1][n-1]\\n```",
                "codeTag": "Java"
            },
            {
                "id": 23532,
                "title": "python-solution-with-detailed-explanation",
                "content": "**Solution**\\n\\n**Minimum Path Sum**https://leetcode.com/problems/minimum-path-sum/\\n\\n**Dynamic Programming using Memoization**\\n* Start Point: 0, 0. Destination Point: M-1, N-1\\n* Cost[i,j]: The cost to reach destination from (i,j). Matrix is initialized to inf.\\n* The solution will be cost(0,0)\\n* Initialize the cost matrix with boundary condition. cost[M-1,N-1]=grid[M-1,N-1]\\n* Be careful with what you return for out of bound grid points. Make sure you return infinity so that they are ignored within the min equation\\n* Time and Space Complexity: O(MN)\\n```\\nclass Solution(object):\\n    def helper(self, x, y, grid, cost):\\n        M, N = len(grid), len(grid[0])\\n        if x == M or y == N:\\n            return float('inf')\\n        elif cost[x][y] != -1:\\n            return cost[x][y]\\n        else:\\n            right, down = self.helper(x,y+1,grid,cost), self.helper(x+1,y,grid,cost)\\n            cost[x][y] = min(right, down) + grid[x][y]\\n        return cost[x][y]\\n    \\n    def minPathSum(self, grid):\\n        \"\"\"\\n        :type grid: List[List[int]]\\n        :rtype: int\\n        \"\"\"\\n        M, N = len(grid), len(grid[0])\\n        cost = [[-1]*N for _ in range(M)]\\n        cost[M-1][N-1] = grid[M-1][N-1]\\n        return self.helper(0, 0, grid, cost)\\n```\\n\\n**Dynamic Programming: O(MN) space**\\n* Start Point: 0, 0. Destination Point: M-1, N-1\\n* Cost[i,j]: The cost to reach (i,j) from (0,0). We initialize  \\n* The solution will be cost(M-1,N-1)\\n* Time & Space Complexity:O(MN)\\n```\\nclass Solution(object):\\n    def minPathSum(self, grid):\\n        \"\"\"\\n        :type grid: List[List[int]]\\n        :rtype: int\\n        \"\"\"\\n        M, N = len(grid), len(grid[0])\\n        cost = [[0]*N for _ in range(M)]\\n        cost[0][0] = grid[0][0]\\n        for j in range(1,N):\\n            cost[0][j] = grid[0][j] + cost[0][j-1]\\n        for i in range(1,M):\\n            cost[i][0] = grid[i][0] + cost[i-1][0]\\n        for i in range(1,M):\\n            for j in range(1,N):\\n                cost[i][j] = min(cost[i-1][j], cost[i][j-1]) + grid[i][j]\\n        return cost[M-1][N-1]\\n```\\n\\n**Dynamic Programming: Using O(N) space**\\n* Space complexity can be reduced to O(N) since we only require the previous row to compute the current row.\\n* Note that we initialize the cost array to inf. Note how we initialize cost[0] at every row iteration.\\n```\\nclass Solution(object):\\n    def minPathSum(self, grid):\\n        \"\"\"\\n        :type grid: List[List[int]]\\n        :rtype: int\\n        \"\"\"\\n        M, N = len(grid), len(grid[0])\\n        cost = [float('inf')]*N\\n        for i in range(M):\\n            cost[0] = grid[i][0] + cost[0] if i > 0 else grid[i][0]\\n            for j in range(1,N):\\n                cost[j] = min(cost[j-1], cost[j]) + grid[i][j]\\n        return cost[-1]\\n```\\n\\n**Dynamic Programming: Using O(1) space**\\n* Space complexity can be reduced to O(1) as grid can be reused as cost matrix\\n* Notice how we iterate the two loops and the special condition we use for i=0\\n```\\nclass Solution(object):\\n    def minPathSum(self, grid):\\n        \"\"\"\\n        :type grid: List[List[int]]\\n        :rtype: int\\n        \"\"\"\\n        M, N = len(grid), len(grid[0])\\n        for i in range(M):\\n            grid[i][0] = grid[i][0] + grid[i-1][0] if i > 0 else grid[i][0]\\n            for j in range(1,N):\\n                grid[i][j] = min(grid[i-1][j], grid[i][j-1]) + grid[i][j] if i > 0 else grid[i][j-1]+grid[i][j]\\n        return grid[-1][-1]\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution(object):\\n    def helper(self, x, y, grid, cost):\\n        M, N = len(grid), len(grid[0])\\n        if x == M or y == N:\\n            return float('inf')\\n        elif cost[x][y] != -1:\\n            return cost[x][y]\\n        else:\\n            right, down = self.helper(x,y+1,grid,cost), self.helper(x+1,y,grid,cost)\\n            cost[x][y] = min(right, down) + grid[x][y]\\n        return cost[x][y]\\n    \\n    def minPathSum(self, grid):\\n        \"\"\"\\n        :type grid: List[List[int]]\\n        :rtype: int\\n        \"\"\"\\n        M, N = len(grid), len(grid[0])\\n        cost = [[-1]*N for _ in range(M)]\\n        cost[M-1][N-1] = grid[M-1][N-1]\\n        return self.helper(0, 0, grid, cost)\\n```\n```\\nclass Solution(object):\\n    def minPathSum(self, grid):\\n        \"\"\"\\n        :type grid: List[List[int]]\\n        :rtype: int\\n        \"\"\"\\n        M, N = len(grid), len(grid[0])\\n        cost = [[0]*N for _ in range(M)]\\n        cost[0][0] = grid[0][0]\\n        for j in range(1,N):\\n            cost[0][j] = grid[0][j] + cost[0][j-1]\\n        for i in range(1,M):\\n            cost[i][0] = grid[i][0] + cost[i-1][0]\\n        for i in range(1,M):\\n            for j in range(1,N):\\n                cost[i][j] = min(cost[i-1][j], cost[i][j-1]) + grid[i][j]\\n        return cost[M-1][N-1]\\n```\n```\\nclass Solution(object):\\n    def minPathSum(self, grid):\\n        \"\"\"\\n        :type grid: List[List[int]]\\n        :rtype: int\\n        \"\"\"\\n        M, N = len(grid), len(grid[0])\\n        cost = [float('inf')]*N\\n        for i in range(M):\\n            cost[0] = grid[i][0] + cost[0] if i > 0 else grid[i][0]\\n            for j in range(1,N):\\n                cost[j] = min(cost[j-1], cost[j]) + grid[i][j]\\n        return cost[-1]\\n```\n```\\nclass Solution(object):\\n    def minPathSum(self, grid):\\n        \"\"\"\\n        :type grid: List[List[int]]\\n        :rtype: int\\n        \"\"\"\\n        M, N = len(grid), len(grid[0])\\n        for i in range(M):\\n            grid[i][0] = grid[i][0] + grid[i-1][0] if i > 0 else grid[i][0]\\n            for j in range(1,N):\\n                grid[i][j] = min(grid[i-1][j], grid[i][j-1]) + grid[i][j] if i > 0 else grid[i][j-1]+grid[i][j]\\n        return grid[-1][-1]\\n```",
                "codeTag": "Java"
            },
            {
                "id": 502072,
                "title": "javascript-95-speed-o-mn-time-o-1-space-w-comments",
                "content": "```\\nvar minPathSum = function(grid) {\\n\\t// Get the two dimensions of the grid\\n    const n = grid.length;\\n    const m = grid[0].length;\\n    \\n\\t// Calculate the distance travelled within the first column\\n\\t// This is because each square depends on the one above\\n\\t// And the one to the left. However there is nothing left\\n\\t// of the first column so we can calculate it by adding\\n\\t// the current square to the square above it\\n    for(let i=1; i<n; i++) {\\n        grid[i][0] += grid[i-1][0];\\n    }\\n    \\n\\t// The same goes for the first row. There is nothing above the \\n\\t// first row. So we just calculate the distance by what is to the left\\n\\t// of it\\n    for(let j=1; j<m; j++) {\\n        grid[0][j] += grid[0][j-1];\\n    }\\n    \\n\\t// Start one row and one column in because we\\'ve precomputed\\n\\t// those above\\n    for(let i=1; i<n; i++) {\\n        for(let j=1; j<m; j++) {\\n\\t\\t\\t// The distance to the grid at i,j is equal to itself plus the minimum\\n\\t\\t\\t// of the two grid spaces (one above, one to the left)\\n            grid[i][j] += Math.min(grid[i-1][j], grid[i][j-1]);\\n        }\\n    }\\n    \\n\\t// Return the distance bottom right corner\\n    return grid[n-1][m-1];\\n};\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\nvar minPathSum = function(grid) {\\n\\t// Get the two dimensions of the grid\\n    const n = grid.length;\\n    const m = grid[0].length;\\n    \\n\\t// Calculate the distance travelled within the first column\\n\\t// This is because each square depends on the one above\\n\\t// And the one to the left. However there is nothing left\\n\\t// of the first column so we can calculate it by adding\\n\\t// the current square to the square above it\\n    for(let i=1; i<n; i++) {\\n        grid[i][0] += grid[i-1][0];\\n    }\\n    \\n\\t// The same goes for the first row. There is nothing above the \\n\\t// first row. So we just calculate the distance by what is to the left\\n\\t// of it\\n    for(let j=1; j<m; j++) {\\n        grid[0][j] += grid[0][j-1];\\n    }\\n    \\n\\t// Start one row and one column in because we\\'ve precomputed\\n\\t// those above\\n    for(let i=1; i<n; i++) {\\n        for(let j=1; j<m; j++) {\\n\\t\\t\\t// The distance to the grid at i,j is equal to itself plus the minimum\\n\\t\\t\\t// of the two grid spaces (one above, one to the left)\\n            grid[i][j] += Math.min(grid[i-1][j], grid[i][j-1]);\\n        }\\n    }\\n    \\n\\t// Return the distance bottom right corner\\n    return grid[n-1][m-1];\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3345863,
                "title": "image-explanation-recursion-dp-4-methods-c-java-python",
                "content": "# Video Solution (`Aryan Mittal`)\\n`Minimum Path Sum` by `Aryan Mittal`\\n![meta5.png](https://assets.leetcode.com/users/images/ba681d93-09f3-4124-8452-da3ff1212d19_1679887228.3219895.png)\\n\\n\\n# Approach & Intution\\n![image.png](https://assets.leetcode.com/users/images/1e83ac93-0c25-49f7-a1bc-5d19636b9c7c_1679883307.3522673.png)\\n![image.png](https://assets.leetcode.com/users/images/3d44f039-7517-4742-be15-675c7f45f7e4_1679883343.370807.png)\\n![image.png](https://assets.leetcode.com/users/images/7ec80aa0-711a-4e46-be05-33efca08da7e_1679883363.6013312.png)\\n![image.png](https://assets.leetcode.com/users/images/5df527f7-94c4-430d-b241-ba92925aa010_1679883392.19581.png)\\n![image.png](https://assets.leetcode.com/users/images/39a67687-3976-4fdd-a4e6-48ef70c2b867_1679883404.3252819.png)\\n![image.png](https://assets.leetcode.com/users/images/bf0d85ae-ff30-4140-a094-fbc4e5b10946_1679883414.034133.png)\\n![image.png](https://assets.leetcode.com/users/images/e98a682a-52a3-4e86-9a63-46f4408f3a04_1679883421.3524578.png)\\n![image.png](https://assets.leetcode.com/users/images/a03890d0-83f0-44dc-a008-2cac56151a9c_1679883428.471258.png)\\n![image.png](https://assets.leetcode.com/users/images/eb14045b-08d6-4774-b456-ff345390b3ee_1679883436.9386165.png)\\n\\n\\n\\n# Method1 Code: By Modifying the Grid O(1) Space\\n```C++ []\\nclass Solution {\\npublic:\\n    int minPathSum(vector<vector<int>>& grid) {\\n        int m = grid.size(), n = grid[0].size();\\n        \\n        for (int i = 1; i < m; i++) grid[i][0] += grid[i-1][0];\\n        \\n        for (int j = 1; j < n; j++) grid[0][j] += grid[0][j-1];\\n        \\n        for (int i = 1; i < m; i++)\\n            for (int j = 1; j < n; j++)\\n                grid[i][j] += min(grid[i-1][j], grid[i][j-1]);\\n        \\n        return grid[m-1][n-1];\\n    }\\n};\\n```\\n```Java []\\nclass Solution {\\n    public int minPathSum(int[][] grid) {\\n        int m = grid.length, n = grid[0].length;\\n        \\n        for (int i = 1; i < m; i++) grid[i][0] += grid[i-1][0];\\n        \\n        for (int j = 1; j < n; j++) grid[0][j] += grid[0][j-1];\\n        \\n        for (int i = 1; i < m; i++)\\n            for (int j = 1; j < n; j++)\\n                grid[i][j] += Math.min(grid[i-1][j], grid[i][j-1]);\\n        \\n        return grid[m-1][n-1];\\n    }\\n}\\n```\\n```Python []\\nclass Solution:\\n    def minPathSum(self, grid: List[List[int]]) -> int:\\n        m, n = len(grid), len(grid[0])\\n        \\n        for i in range(1, m):\\n            grid[i][0] += grid[i-1][0]\\n        \\n        for i in range(1, n):\\n            grid[0][i] += grid[0][i-1]\\n        \\n        for i in range(1, m):\\n            for j in range(1, n):\\n                grid[i][j] += min(grid[i-1][j], grid[i][j-1])\\n        \\n        return grid[-1][-1]\\n```\\n\\n# Method4 Code: Without Modifying the Grid O(m) Space\\n```C++ []\\nclass Solution {\\npublic:\\n    int minPathSum(vector<vector<int>>& grid) {\\n        int m = grid.size(), n = grid[0].size();\\n        vector<int> cur(m, grid[0][0]);\\n        \\n        for (int i = 1; i < m; i++)\\n            cur[i] = cur[i - 1] + grid[i][0]; \\n        \\n        for (int j = 1; j < n; j++) {\\n            cur[0] += grid[0][j]; \\n            for (int i = 1; i < m; i++)\\n                cur[i] = min(cur[i - 1], cur[i]) + grid[i][j];\\n        }\\n        return cur[m - 1];\\n    }\\n};\\n```\\n```Java []\\nclass Solution {\\n    public int minPathSum(int[][] grid) {\\n        int m = grid.length, n = grid[0].length;\\n        int[] cur = new int[m];\\n        cur[0] = grid[0][0];\\n        \\n        for (int i = 1; i < m; i++)\\n            cur[i] = cur[i - 1] + grid[i][0];\\n        \\n        for (int j = 1; j < n; j++) {\\n            cur[0] += grid[0][j];\\n            for (int i = 1; i < m; i++)\\n                cur[i] = Math.min(cur[i - 1], cur[i]) + grid[i][j];\\n        }\\n        return cur[m - 1];\\n    }\\n}\\n```\\n```Python []\\nclass Solution:\\n    def minPathSum(self, grid: List[List[int]]) -> int:\\n        m, n = len(grid), len(grid[0])\\n        cur = [grid[0][0]] * m\\n        \\n        for i in range(1, m):\\n            cur[i] = cur[i - 1] + grid[i][0]\\n        \\n        for j in range(1, n):\\n            cur[0] += grid[0][j]\\n            for i in range(1, m):\\n                cur[i] = min(cur[i - 1], cur[i]) + grid[i][j]\\n        \\n        return cur[m - 1]\\n```\\n",
                "solutionTags": [
                    "C++",
                    "Java",
                    "Python3",
                    "Dynamic Programming",
                    "Recursion"
                ],
                "code": "```C++ []\\nclass Solution {\\npublic:\\n    int minPathSum(vector<vector<int>>& grid) {\\n        int m = grid.size(), n = grid[0].size();\\n        \\n        for (int i = 1; i < m; i++) grid[i][0] += grid[i-1][0];\\n        \\n        for (int j = 1; j < n; j++) grid[0][j] += grid[0][j-1];\\n        \\n        for (int i = 1; i < m; i++)\\n            for (int j = 1; j < n; j++)\\n                grid[i][j] += min(grid[i-1][j], grid[i][j-1]);\\n        \\n        return grid[m-1][n-1];\\n    }\\n};\\n```\n```Java []\\nclass Solution {\\n    public int minPathSum(int[][] grid) {\\n        int m = grid.length, n = grid[0].length;\\n        \\n        for (int i = 1; i < m; i++) grid[i][0] += grid[i-1][0];\\n        \\n        for (int j = 1; j < n; j++) grid[0][j] += grid[0][j-1];\\n        \\n        for (int i = 1; i < m; i++)\\n            for (int j = 1; j < n; j++)\\n                grid[i][j] += Math.min(grid[i-1][j], grid[i][j-1]);\\n        \\n        return grid[m-1][n-1];\\n    }\\n}\\n```\n```Python []\\nclass Solution:\\n    def minPathSum(self, grid: List[List[int]]) -> int:\\n        m, n = len(grid), len(grid[0])\\n        \\n        for i in range(1, m):\\n            grid[i][0] += grid[i-1][0]\\n        \\n        for i in range(1, n):\\n            grid[0][i] += grid[0][i-1]\\n        \\n        for i in range(1, m):\\n            for j in range(1, n):\\n                grid[i][j] += min(grid[i-1][j], grid[i][j-1])\\n        \\n        return grid[-1][-1]\\n```\n```C++ []\\nclass Solution {\\npublic:\\n    int minPathSum(vector<vector<int>>& grid) {\\n        int m = grid.size(), n = grid[0].size();\\n        vector<int> cur(m, grid[0][0]);\\n        \\n        for (int i = 1; i < m; i++)\\n            cur[i] = cur[i - 1] + grid[i][0]; \\n        \\n        for (int j = 1; j < n; j++) {\\n            cur[0] += grid[0][j]; \\n            for (int i = 1; i < m; i++)\\n                cur[i] = min(cur[i - 1], cur[i]) + grid[i][j];\\n        }\\n        return cur[m - 1];\\n    }\\n};\\n```\n```Java []\\nclass Solution {\\n    public int minPathSum(int[][] grid) {\\n        int m = grid.length, n = grid[0].length;\\n        int[] cur = new int[m];\\n        cur[0] = grid[0][0];\\n        \\n        for (int i = 1; i < m; i++)\\n            cur[i] = cur[i - 1] + grid[i][0];\\n        \\n        for (int j = 1; j < n; j++) {\\n            cur[0] += grid[0][j];\\n            for (int i = 1; i < m; i++)\\n                cur[i] = Math.min(cur[i - 1], cur[i]) + grid[i][j];\\n        }\\n        return cur[m - 1];\\n    }\\n}\\n```\n```Python []\\nclass Solution:\\n    def minPathSum(self, grid: List[List[int]]) -> int:\\n        m, n = len(grid), len(grid[0])\\n        cur = [grid[0][0]] * m\\n        \\n        for i in range(1, m):\\n            cur[i] = cur[i - 1] + grid[i][0]\\n        \\n        for j in range(1, n):\\n            cur[0] += grid[0][j]\\n            for i in range(1, m):\\n                cur[i] = min(cur[i - 1], cur[i]) + grid[i][j]\\n        \\n        return cur[m - 1]\\n```",
                "codeTag": "Java"
            },
            {
                "id": 825410,
                "title": "python3-dynamic-programming-90-w-explaination",
                "content": "Dynamic programming is all about breaking the whole problem into smaller problems in which you can then minimize, which will result in the whole problem being minimized. In this question, we should notice that the minimum path sum for each cell is the smaller value between the cell itself plus the cell above it or the the cell itself plus the cell to the left of it. So, as you visit each future cell and refer to previous cells to the left and above you, you know that those cells have been optimized to have the minimum path sum for that index - thus obtaining the most optimal path.\\n\\nFor example,\\n```\\n[1,3,1],\\n[1,5,1],\\n[4,2,1]\\n```\\n* **grid[0][1]**, there is a cell to the left of it (grid[0][0] = 1) and no cell above it, this means we know that the minimum path sum for this cell is at best 4 (3 + 1).\\n* **grid[0][2]**, similar to grid[0][1], at best is 5 (1 + 4)\\n* **grid[1][0]**, there is a cell above (grid[0][0] = 1) and no cell to the left of it, this means we know that the minimum path sum for this cell is at best 2 (1 + 1).\\n* **grid[1][1]**, there is a cell above and also a cell to the left of it, we will need to add a cell (grid[0][1] = 4 or grid[1][0] = 2) that will result in the current cell having the smallest sum possible. It is ideal to add grid[1][0], thus the minimum path sum for this cell is at best 7 (2 + 5).\\n* **grid[1][2]**, similar to grid[1][1], at best is 6 (1 + 5)\\n* **grid[2][0]**, similar to grid[1][0], at best is 6 (4 + 2)\\n* **grid[2][1]**, similar to grid[1][1], at best is 8 (2 + 6)\\n* **grid[2][2]**, similar to grid[1][1], at best is 7 (1 + 6)\\n\\nThe resulting DP array - you can put your calculated results for each cell in a seperate 2D array or do it in-place (which I did).\\n```\\n[1,4,5],\\n[2,7,6],\\n[6,8,7]\\n```\\nHere is the actual code:\\n```\\ndef minPathSum(self, grid: List[List[int]]) -> int:\\n        for i in range(len(grid)):\\n            for j in range(len(grid[0])):\\n                if i > 0 and j > 0:\\n                    grid[i][j] = min(grid[i][j] + grid[i-1][j], grid[i][j] + grid[i][j-1])\\n                elif i > 0:\\n                    grid[i][j] += grid[i-1][j]\\n                elif j > 0:\\n                    grid[i][j] += grid[i][j-1]\\n        \\n        return grid[-1][-1]\\n```",
                "solutionTags": [
                    "Python",
                    "Python3",
                    "Dynamic Programming"
                ],
                "code": "```\\n[1,3,1],\\n[1,5,1],\\n[4,2,1]\\n```\n```\\n[1,4,5],\\n[2,7,6],\\n[6,8,7]\\n```\n```\\ndef minPathSum(self, grid: List[List[int]]) -> int:\\n        for i in range(len(grid)):\\n            for j in range(len(grid[0])):\\n                if i > 0 and j > 0:\\n                    grid[i][j] = min(grid[i][j] + grid[i-1][j], grid[i][j] + grid[i][j-1])\\n                elif i > 0:\\n                    grid[i][j] += grid[i-1][j]\\n                elif j > 0:\\n                    grid[i][j] += grid[i][j-1]\\n        \\n        return grid[-1][-1]\\n```",
                "codeTag": "Python3"
            },
            {
                "id": 180305,
                "title": "my-java-dp-solution-easy-to-understand-beats-96",
                "content": "The idea is to sum up the first row and first column as there is no way to reach to that point other than to go right or down respectively. For the rest of the grid[i][j] (for all i >1 and j >1) find the minimum of the grid-left (j-1) and grid-top (i-1) value and add to the current grid value. At the end, the minimum path sum would be the buttom last value in the grid.\n\n```\nclass Solution {\n    public int minPathSum(int[][] grid) {\n        \n        for(int i=1; i<grid.length; i++) {\n            grid[i][0] = grid[i-1][0] + grid[i][0];\n        }\n        for(int j=1; j<grid[0].length; j++) {\n            grid[0][j] = grid[0][j-1] + grid[0][j];\n        }\n        for(int i=1; i<grid.length; i++) {\n            for(int j=1; j<grid[0].length; j++) {\n                grid[i][j] = Math.min(grid[i-1][j], grid[i][j-1]) + grid[i][j];\n            }\n        }\n        return grid[grid.length-1][grid[0].length-1];\n    }\n}\n```",
                "solutionTags": [],
                "code": "```\nclass Solution {\n    public int minPathSum(int[][] grid) {\n        \n        for(int i=1; i<grid.length; i++) {\n            grid[i][0] = grid[i-1][0] + grid[i][0];\n        }\n        for(int j=1; j<grid[0].length; j++) {\n            grid[0][j] = grid[0][j-1] + grid[0][j];\n        }\n        for(int i=1; i<grid.length; i++) {\n            for(int j=1; j<grid[0].length; j++) {\n                grid[i][j] = Math.min(grid[i-1][j], grid[i][j-1]) + grid[i][j];\n            }\n        }\n        return grid[grid.length-1][grid[0].length-1];\n    }\n}\n```",
                "codeTag": "Java"
            },
            {
                "id": 3345894,
                "title": "easy-solutions-in-java-python-and-c-look-at-once",
                "content": "# Intuition\\nTo find the minimum sum path from the top left corner to the bottom right corner of the grid, we can use dynamic programming. We create a dp table to store the minimum sum path to each cell. The value in the (i, j) cell of the dp table represents the minimum sum path from the top left corner to that cell. We can then fill the dp table using the values from the grid.\\n\\n\\n\\n# Approach\\n- Initialize the dp table with the value of the top left corner of the grid.\\n- Fill the first row of the dp table by adding the values in the previous cell and the current cell in the grid.\\n- Fill the first column of the dp table by adding the values in the previous cell and the current cell in the grid.\\n- Fill the rest of the dp table by taking the minimum of the value above and the value to the left of the current cell in the dp table, and adding the value in the current cell of the grid.\\n- Return the value in the bottom right corner of the dp table, which represents the minimum sum path from the top left corner to the bottom right corner of the grid.\\n\\n# Complexity\\n- Time complexity: O(n), where n is the number of nodes in the graph. We visit each node at most once, and perform constant-time operations on each node.\\n\\n- Space complexity: O(n), where n is the number of nodes in the graph. We use an array of size n to keep track of the time at which we visit each node.\\n\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n![image.png](https://assets.leetcode.com/users/images/b427e686-2e5d-469a-8e7a-db5140022a6b_1677715904.0948765.png)\\n\\n\\n# Please Upvote\\uD83D\\uDC4D\\uD83D\\uDC4D\\n```\\nThanks for visiting my solution.\\uD83D\\uDE0A Keep Learning\\nPlease give my solution an upvote! \\uD83D\\uDC4D\\nIt\\'s a simple way to show your appreciation and\\nkeep me motivated. Thank you! \\uD83D\\uDE0A\\n```\\n# Code\\n```java []\\nclass Solution {\\n    public int minPathSum(int[][] grid) {\\n        int m = grid.length;\\n        int n = grid[0].length;\\n        \\n        // Create a dp table to store the minimum sum path to each cell\\n        int[][] dp = new int[m][n];\\n        dp[0][0] = grid[0][0];\\n        \\n        // Fill the first row\\n        for (int i = 1; i < n; i++) {\\n            dp[0][i] = dp[0][i-1] + grid[0][i];\\n        }\\n        \\n        // Fill the first column\\n        for (int i = 1; i < m; i++) {\\n            dp[i][0] = dp[i-1][0] + grid[i][0];\\n        }\\n        \\n        // Fill the rest of the dp table\\n        for (int i = 1; i < m; i++) {\\n            for (int j = 1; j < n; j++) {\\n                dp[i][j] = Math.min(dp[i-1][j], dp[i][j-1]) + grid[i][j];\\n            }\\n        }\\n        \\n        return dp[m-1][n-1];\\n    }\\n}\\n\\n\\n```\\n``` C++ []\\nclass Solution {\\npublic:\\n    int minPathSum(vector<vector<int>>& grid) {\\n        int m = grid.size();\\n        int n = grid[0].size();\\n        \\n        // Create a dp table to store the minimum sum path to each cell\\n        vector<vector<int>> dp(m, vector<int>(n));\\n        \\n        // Fill the first row\\n        dp[0][0] = grid[0][0];\\n        for (int i = 1; i < n; i++) {\\n            dp[0][i] = dp[0][i-1] + grid[0][i];\\n        }\\n        \\n        // Fill the first column\\n        for (int i = 1; i < m; i++) {\\n            dp[i][0] = dp[i-1][0] + grid[i][0];\\n        }\\n        \\n        // Fill the rest of the dp table\\n        for (int i = 1; i < m; i++) {\\n            for (int j = 1; j < n; j++) {\\n                dp[i][j] = min(dp[i-1][j], dp[i][j-1]) + grid[i][j];\\n            }\\n        }\\n        \\n        return dp[m-1][n-1];\\n    }\\n};\\n\\n\\n```\\n``` Python []\\nclass Solution(object):\\n    def minPathSum(self, grid):\\n        m = len(grid)\\n        n = len(grid[0])\\n        \\n        # Create a dp table to store the minimum sum path to each cell\\n        dp = [[0 for j in range(n)] for i in range(m)]\\n        \\n        # Fill the first row\\n        dp[0][0] = grid[0][0]\\n        for i in range(1, n):\\n            dp[0][i] = dp[0][i-1] + grid[0][i]\\n        \\n        # Fill the first column\\n        for i in range(1, m):\\n            dp[i][0] = dp[i-1][0] + grid[i][0]\\n        \\n        # Fill the rest of the dp table\\n        for i in range(1, m):\\n            for j in range(1, n):\\n                dp[i][j] = min(dp[i-1][j], dp[i][j-1]) + grid[i][j]\\n        \\n        return dp[m-1][n-1]\\n\\n\\n\\n```\\n# Please Comment\\uD83D\\uDC4D\\uD83D\\uDC4D\\n```\\nThanks for visiting my solution comment below if you like it.\\uD83D\\uDE0A\\n```",
                "solutionTags": [
                    "C++",
                    "Java",
                    "Python",
                    "Array",
                    "Dynamic Programming"
                ],
                "code": "```\\nThanks for visiting my solution.\\uD83D\\uDE0A Keep Learning\\nPlease give my solution an upvote! \\uD83D\\uDC4D\\nIt\\'s a simple way to show your appreciation and\\nkeep me motivated. Thank you! \\uD83D\\uDE0A\\n```\n```java []\\nclass Solution {\\n    public int minPathSum(int[][] grid) {\\n        int m = grid.length;\\n        int n = grid[0].length;\\n        \\n        // Create a dp table to store the minimum sum path to each cell\\n        int[][] dp = new int[m][n];\\n        dp[0][0] = grid[0][0];\\n        \\n        // Fill the first row\\n        for (int i = 1; i < n; i++) {\\n            dp[0][i] = dp[0][i-1] + grid[0][i];\\n        }\\n        \\n        // Fill the first column\\n        for (int i = 1; i < m; i++) {\\n            dp[i][0] = dp[i-1][0] + grid[i][0];\\n        }\\n        \\n        // Fill the rest of the dp table\\n        for (int i = 1; i < m; i++) {\\n            for (int j = 1; j < n; j++) {\\n                dp[i][j] = Math.min(dp[i-1][j], dp[i][j-1]) + grid[i][j];\\n            }\\n        }\\n        \\n        return dp[m-1][n-1];\\n    }\\n}\\n\\n\\n```\n``` C++ []\\nclass Solution {\\npublic:\\n    int minPathSum(vector<vector<int>>& grid) {\\n        int m = grid.size();\\n        int n = grid[0].size();\\n        \\n        // Create a dp table to store the minimum sum path to each cell\\n        vector<vector<int>> dp(m, vector<int>(n));\\n        \\n        // Fill the first row\\n        dp[0][0] = grid[0][0];\\n        for (int i = 1; i < n; i++) {\\n            dp[0][i] = dp[0][i-1] + grid[0][i];\\n        }\\n        \\n        // Fill the first column\\n        for (int i = 1; i < m; i++) {\\n            dp[i][0] = dp[i-1][0] + grid[i][0];\\n        }\\n        \\n        // Fill the rest of the dp table\\n        for (int i = 1; i < m; i++) {\\n            for (int j = 1; j < n; j++) {\\n                dp[i][j] = min(dp[i-1][j], dp[i][j-1]) + grid[i][j];\\n            }\\n        }\\n        \\n        return dp[m-1][n-1];\\n    }\\n};\\n\\n\\n```\n``` Python []\\nclass Solution(object):\\n    def minPathSum(self, grid):\\n        m = len(grid)\\n        n = len(grid[0])\\n        \\n        # Create a dp table to store the minimum sum path to each cell\\n        dp = [[0 for j in range(n)] for i in range(m)]\\n        \\n        # Fill the first row\\n        dp[0][0] = grid[0][0]\\n        for i in range(1, n):\\n            dp[0][i] = dp[0][i-1] + grid[0][i]\\n        \\n        # Fill the first column\\n        for i in range(1, m):\\n            dp[i][0] = dp[i-1][0] + grid[i][0]\\n        \\n        # Fill the rest of the dp table\\n        for i in range(1, m):\\n            for j in range(1, n):\\n                dp[i][j] = min(dp[i-1][j], dp[i][j-1]) + grid[i][j]\\n        \\n        return dp[m-1][n-1]\\n\\n\\n\\n```\n```\\nThanks for visiting my solution comment below if you like it.\\uD83D\\uDE0A\\n```",
                "codeTag": "Java"
            },
            {
                "id": 329435,
                "title": "python-dijkstra-s-with-topological-sort-o-e-v-time",
                "content": "Because we can only move down or right, we are given a directional acyclic graph (DAG) and do not need to check for cycles.\\n\\nWe also do not need to use a priority queue to select our next minimum distance vertex to visit.\\n\\nInstead we can use topological sort to make the next vertex selection, and process vertices which have an indegree of 0. This results in a linear O(|E| + |V|) time solution instead of O(|E| log |V|) with priority queue.\\n\\n```\\nfrom collections import defaultdict, deque\\n\\nclass Solution:\\n    def minPathSum(self, grid: List[List[int]]) -> int:\\n\\n        distances = {}\\n        adj_to = defaultdict(dict)\\n        indegree = defaultdict(int)\\n        \\n        for i, row in enumerate(grid):\\n            for j, dist in enumerate(row):\\n                distances[(i,j)] = float(\"inf\")\\n                if i > 0:\\n                    indegree[(i,j)] += 1\\n                    adj_to[(i-1,j)][(i,j)] = dist\\n                if j > 0:\\n                    indegree[(i,j)] += 1\\n                    adj_to[(i,j-1)][(i,j)] = dist\\n        \\n        to_visit = deque([((0,0), grid[0][0])])\\n        \\n        distances[(0,0)] = grid[0][0]\\n        \\n        while to_visit:\\n            cur, cur_dist = to_visit.popleft()\\n            \\n            for adj in adj_to[cur]:\\n                this_dist = cur_dist + adj_to[cur][adj]\\n                distances[adj] = min(this_dist,distances[adj])\\n                indegree[adj] -= 1\\n                if indegree[adj] == 0:\\n                    to_visit.append((adj, distances[adj]))\\n            \\n        return distances[max(distances)]\\n                \\n\\n```",
                "solutionTags": [],
                "code": "```\\nfrom collections import defaultdict, deque\\n\\nclass Solution:\\n    def minPathSum(self, grid: List[List[int]]) -> int:\\n\\n        distances = {}\\n        adj_to = defaultdict(dict)\\n        indegree = defaultdict(int)\\n        \\n        for i, row in enumerate(grid):\\n            for j, dist in enumerate(row):\\n                distances[(i,j)] = float(\"inf\")\\n                if i > 0:\\n                    indegree[(i,j)] += 1\\n                    adj_to[(i-1,j)][(i,j)] = dist\\n                if j > 0:\\n                    indegree[(i,j)] += 1\\n                    adj_to[(i,j-1)][(i,j)] = dist\\n        \\n        to_visit = deque([((0,0), grid[0][0])])\\n        \\n        distances[(0,0)] = grid[0][0]\\n        \\n        while to_visit:\\n            cur, cur_dist = to_visit.popleft()\\n            \\n            for adj in adj_to[cur]:\\n                this_dist = cur_dist + adj_to[cur][adj]\\n                distances[adj] = min(this_dist,distances[adj])\\n                indegree[adj] -= 1\\n                if indegree[adj] == 0:\\n                    to_visit.append((adj, distances[adj]))\\n            \\n        return distances[max(distances)]\\n                \\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1190409,
                "title": "java-best-recursive-memo-dp-solution",
                "content": "Start from basics and move forward.\\n\\n1. Recursive.\\n\\n```\\nclass Solution \\n{\\n    public int minPathSum(int[][] grid) \\n    {\\n        int m = grid.length-1;\\n        int n = grid[0].length-1;\\n        return find(grid, m, n);\\n\\t\\t}\\n    public int find(int grid[][], int m, int n)\\n    {\\n        if(m<0 || n<0)\\n            return Integer.MAX_VALUE;\\n        if(m==0 && n==0)\\n            return grid[0][0];\\n        \\n        return grid[m][n] + Math.min(find(grid, m-1, n),find(grid, m, n-1)); \\n   }\\n}\\n```\\n\\n2. Memo Based Solution\\n\\n```\\nclass Solution \\n{\\n    static int[][] memo;\\n    public int minPathSum(int[][] grid) \\n    {\\n        int m = grid.length-1;\\n        int n = grid[0].length-1;\\n        \\n        memo = new int[m+1][n+1];\\n        \\n        return find(grid, m, n, memo);\\n    }\\n    public int find(int grid[][], int m, int n, int[][] memo)\\n    {\\n        if(m==0 && n==0)\\n            return grid[0][0];\\n        \\n        else if(m<0 || n<0)\\n            return Integer.MAX_VALUE;\\n        \\n        else if(memo[m][n]!=0)\\n            return memo[m][n];\\n        else\\n            return memo[m][n] =  grid[m][n] + Math.min(find(grid, m-1, n, memo),find(grid, m, n-1, memo)); \\n}\\n    }\\n```\\n\\n3. Dp Based Solution\\n\\n```\\nclass Solution \\n{\\n    public int minPathSum(int[][] grid) \\n    {\\n        int m = grid.length;\\n        int n = grid[0].length;\\n        \\n        //Initialisation\\n        int[][] dp = new int[m][n];\\n        \\n        //Base Case Transformation\\n        \\n        dp[0][0] = grid[0][0];\\n        for(int i=1;i<n;i++)\\n        {\\n            dp[0][i]  = dp[0][i-1] + grid[0][i];\\n        }\\n        \\n        for(int i=1;i<m;i++)\\n        {\\n            dp[i][0]  = dp[i-1][0] + grid[i][0];\\n        }\\n        \\n        //Main logic\\n        \\n        for(int i=1;i<m;i++)\\n        {\\n            for(int j=1;j<n;j++)\\n            {\\n                dp[i][j] = Math.min(dp[i][j-1] , dp[i-1][j]) + grid[i][j];\\n            }\\n        }\\n        return dp[m-1][n-1];\\n    }\\n}\\n```\\n\\nI hope you get the solutions.",
                "solutionTags": [
                    "Java",
                    "Dynamic Programming",
                    "Recursion",
                    "Memoization"
                ],
                "code": "```\\nclass Solution \\n{\\n    public int minPathSum(int[][] grid) \\n    {\\n        int m = grid.length-1;\\n        int n = grid[0].length-1;\\n        return find(grid, m, n);\\n\\t\\t}\\n    public int find(int grid[][], int m, int n)\\n    {\\n        if(m<0 || n<0)\\n            return Integer.MAX_VALUE;\\n        if(m==0 && n==0)\\n            return grid[0][0];\\n        \\n        return grid[m][n] + Math.min(find(grid, m-1, n),find(grid, m, n-1)); \\n   }\\n}\\n```\n```\\nclass Solution \\n{\\n    static int[][] memo;\\n    public int minPathSum(int[][] grid) \\n    {\\n        int m = grid.length-1;\\n        int n = grid[0].length-1;\\n        \\n        memo = new int[m+1][n+1];\\n        \\n        return find(grid, m, n, memo);\\n    }\\n    public int find(int grid[][], int m, int n, int[][] memo)\\n    {\\n        if(m==0 && n==0)\\n            return grid[0][0];\\n        \\n        else if(m<0 || n<0)\\n            return Integer.MAX_VALUE;\\n        \\n        else if(memo[m][n]!=0)\\n            return memo[m][n];\\n        else\\n            return memo[m][n] =  grid[m][n] + Math.min(find(grid, m-1, n, memo),find(grid, m, n-1, memo)); \\n}\\n    }\\n```\n```\\nclass Solution \\n{\\n    public int minPathSum(int[][] grid) \\n    {\\n        int m = grid.length;\\n        int n = grid[0].length;\\n        \\n        //Initialisation\\n        int[][] dp = new int[m][n];\\n        \\n        //Base Case Transformation\\n        \\n        dp[0][0] = grid[0][0];\\n        for(int i=1;i<n;i++)\\n        {\\n            dp[0][i]  = dp[0][i-1] + grid[0][i];\\n        }\\n        \\n        for(int i=1;i<m;i++)\\n        {\\n            dp[i][0]  = dp[i-1][0] + grid[i][0];\\n        }\\n        \\n        //Main logic\\n        \\n        for(int i=1;i<m;i++)\\n        {\\n            for(int j=1;j<n;j++)\\n            {\\n                dp[i][j] = Math.min(dp[i][j-1] , dp[i-1][j]) + grid[i][j];\\n            }\\n        }\\n        return dp[m-1][n-1];\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 23555,
                "title": "ac-java-dp-solution-v-s-tle-dijstra-solution",
                "content": "When I looked at this question, the first thought was the Dijkstra solution, which is a very fast algorithm to calculate the shortest path. But this solution got TLE in this question, while DP solution worked fine.\\n\\nI will talk about the Dijkstra solution first, as it's the first though came into my mind, and there is already discussions on the DP solution. If you are not interested in the Dijkstra solution, you can jump to the latter part of this post, which is about the DP solution, which is accepted.\\n\\n**Dijkstra**\\nThe idea of Dijkstra algorithm is to divide the graph into 2 parts, visited and unvisited. \\nFor every node in the visited part has a *dist* value. Then we need to exam every edges across the visited part and the unvisited parts, which are edges that its start node is in the visited part, while its end node is in the unvisited part. What we are looking for is one edge, which has the minimum value of (dist(start node) + the edge's value). Then we put this node into the visited part and exam the edges again.\\n\\nFollowing is the code. It uses a Java Heap, PriorityQueue to keep track of the minimum (dist(start node) + the edge's value), but in this question, the edge value is in the node itself, which is the same for every edges ending to it, so actually the heap just keeps track of the mimimum dist(start node) of every unvisited nodes around the boarder between visited and unvisited.\\n\\n    public class Solution_dijkstra {\\n\\t\\n\\tclass PointComparator implements Comparator<int[]>{\\n    \\tint[][] dist;\\n    \\tpublic PointComparator(int[][] dist){\\n    \\t\\tthis.dist = dist;\\n    \\t}\\n    \\t@Override\\n    \\tpublic int compare(int[] o1, int[] o2) {\\n    \\t\\tint[] point1 = (int[])o1;\\n            int[] point2 = (int[])o2;\\n            return Integer.valueOf(dist[point1[0]][point1[1]])\\n                .compareTo(Integer.valueOf(dist[point2[0]][point2[1]]));\\n        }\\n    }\\n    \\t\\n    public int minPathSum(int[][] grid) {\\n        if(grid == null || grid.length == 0) return 0;\\n        int m = grid.length;\\n        int n = grid[0].length;\\n        \\n        boolean[][] visited = new boolean[m][n];\\n        int[][] dist = new int[m][n];\\n        \\n        for(int x = 0; x < m; x++){\\n            for(int y = 0; y < n; y++){\\n                dist[x][y] = Integer.MAX_VALUE;\\n            }\\n        }\\n        \\n        dist[0][0] = grid[0][0];\\n        \\n        PriorityQueue<int[]> pq = new PriorityQueue<int[]>( m*n, new PointComparator(dist));\\n        \\n        pq.add(new int[]{0, 0});\\n        \\n        while(!pq.isEmpty()){\\n            \\n            int[] point = pq.poll();\\n            int x = point[0];\\n            int y = point[1];\\n            int d = dist[x][y];\\n            \\n            if(x == n-1 && y == m-1){\\n                return d;\\n            }\\n            \\n            visited[x][y] = true;\\n            \\n            if((y+1 < n) && !visited[x][y+1]){\\n                dist[x][y+1] = min(\\n                    dist[x][y+1],\\n                    d + grid[x][y+1]);\\n                pq.add(new int[]{x, y+1});\\n            }\\n            \\n            if((x+1 < m ) && !visited[x+1][y]){\\n                dist[x+1][y] = min(\\n                    dist[x+1][y],\\n                    d + grid[x+1][y]);\\n                pq.add(new int[]{x+1, y});\\n            }\\n        }\\n        return 0;\\n        \\n    }\\n    \\n    private int min(int i1, int i2){\\n    \\treturn i1 < i2 ? i1 : i2;\\n    }\\n\\n\\n} \\n\\n\\nThis solution got LTE error, mostly because of the priority queue and doesn't consider the special condition here that it's a grid and directed, which means a node can only be accessed from it's left and upper nodes. Put all these into consideration, we have the DP solution. It's essentially formula is\\n\\ndist(node) = min( dist(upper node), dist(left node)) + node's value\\n\\n**DP**\\nhere is the code:\\n\\n    public class Solution_dp {\\n\\t\\n\\tprivate int getDist(int[][] dist, int x, int y){\\n\\t\\tif(x < 0 || y < 0){\\n\\t\\t\\treturn Integer.MAX_VALUE;\\n\\t\\t}\\n\\t\\t\\n\\t\\treturn dist[x][y];\\t\\t\\n\\t}\\n\\t\\n\\tprivate int min(int i1, int i2){\\n\\t\\treturn i1 < i2 ? i1 : i2;\\n\\t}\\n\\t\\n\\t\\n\\tpublic int minPathSum(int[][] grid) {\\n\\n\\t\\tif(grid == null || grid.length == 0) return 0;\\n\\t\\t\\n\\t\\tint m = grid.length;\\n\\t\\tint n = grid[0].length;\\n\\t\\t\\n\\t\\tint[][] dist = new int[m][n];\\n\\t\\t\\n\\t\\t\\t\\t\\n\\t\\t\\n\\t\\tfor(int x = 0; x < m; x++){\\n\\t\\t\\tfor(int y = 0; y < n; y++){\\n\\t\\t\\t\\t\\n\\t\\t\\t\\tif(x == 0 && y == 0){\\n\\t\\t\\t\\t\\tdist[0][0] = grid[0][0];\\n\\t\\t\\t\\t}else{\\n\\t\\t\\t\\t\\tdist[x][y] = min(getDist(dist, x-1, y), getDist(dist, x, y-1))  + grid[x][y];\\t\\t\\t\\t\\t\\n\\t\\t\\t\\t}\\n\\t\\t\\t}\\t\\t\\t\\n\\t\\t}\\n\\t\\n\\t\\treturn dist[m-1][n-1];\\n\\t\\t\\t\\t\\n\\t}\\n}",
                "solutionTags": [],
                "code": "class Solution_dijkstra {\\n\\t\\n\\tclass PointComparator implements Comparator<int[]>{\\n    \\tint[][] dist;\\n    \\tpublic PointComparator(int[][] dist){\\n    \\t\\tthis.dist = dist;\\n    \\t}",
                "codeTag": "Java"
            },
            {
                "id": 3345882,
                "title": "6-ways-to-solve-4-lines-of-codes-c-dp-tle-to-90-beat",
                "content": "# Intuition\\nTry to reach every points with minimium path sum.\\n\\n# Approach\\nReach to each point but alwasy with minimum path sum possible \\n```\\n<!-- Assume we need to reach ar[i][j]  -->\\n<!-- always check minimum possiblle rach value near by it -->\\nar[i][j] = ar[i][j] + min(ar[i-1][j],ar[i][j-1])\\n```\\nThat is all aproch and there is given 6 ways\\n\\n# CODES\\n\\n# Simple recursion start from (0,0) to (n,n) filling (TLE)\\n- Time complexity: O(2^n*m)\\n\\n- Space complexity: O(n*m)\\n\\n```\\nclass Solution {\\npublic:\\n    int fun(vector<vector<int>>& gr, int i, int j ){\\n        if(i==gr.size()-1 && j==gr[0].size()-1){\\n            return gr[i][j];\\n        }\\n        if(i==gr.size() || j==gr[0].size()){\\n            return 1e8;\\n        }\\n        int a = fun(gr,i+1,j);\\n        int b = fun(gr,i,j+1);\\n        return gr[i][j] + min(a,b);\\n    }\\n\\n    int minPathSum(vector<vector<int>>& gr) {\\n        vector<vector<int>> dp(gr.size(),vector<int>(gr[0].size(),-1));\\n        return fun(gr,0,0);\\n    }\\n};\\n``` \\n# Simple recursion start from (n,n) to (0,0) filling (TLE)\\n- Time complexity: O(2^n*m)\\n\\n- Space complexity: O(n*m)\\n\\n```\\nclass Solution {\\npublic:\\n    int fun(vector<vector<int>>& gr, int i, int j  ){\\n        if(i==0 && j==0) return gr[i][j];\\n        if(i<0 || j<0) return 1e8;\\n        return gr[i][j] + min(fun(gr,i-1,j),fun(gr,i,j-1));\\n    }\\n    int minPathSum(vector<vector<int>>& gr) {\\n        vector<vector<int>> dp(gr.size(),vector<int>(gr[0].size(),-1));\\n        return fun(gr,gr.size()-1,gr[0].size()-1);\\n    }\\n};\\n```\\n# Recursion + memoization (n,n) to (0,0) (ACCEPT)\\n- Time complexity: O(n*m)\\n\\n- Space complexity: O(n*m)\\n\\n```\\nclass Solution {\\npublic:\\n    int fun(vector<vector<int>>& gr, int i, int j ,vector<vector<int>> &dp ){\\n        if(i==0 && j==0) return gr[i][j];\\n\\n        if(i<0 || j<0)  return 1e8;\\n\\n        if(dp[i][j] != -1) return dp[i][j];\\n        \\n        return dp[i][j] = gr[i][j] + min(fun(gr,i-1,j,dp),fun(gr,i,j-1,dp));\\n    }\\n\\n    int minPathSum(vector<vector<int>>& gr) {\\n        vector<vector<int>> dp(gr.size(),vector<int>(gr[0].size(),-1));\\n        return fun(gr,gr.size()-1,gr[0].size()-1,dp);\\n    }\\n};\\n```\\n# Recursion + memoization (0,0) to (n,n) (ACCEPT)\\n- Time complexity: O(n*m)\\n\\n- Space complexity: O(n*m)\\n\\n```\\nclass Solution {\\npublic:\\n    int fun(vector<vector<int>>& gr, int i, int j, vector<vector<int>> &dp){\\n        if(i==gr.size()-1 && j==gr[0].size()-1){\\n            return gr[i][j];\\n        }\\n        if(i==gr.size() || j==gr[0].size()){\\n            return 1e8;\\n        }\\n        if(dp[i][j] != -1) return dp[i][j];\\n        int a = fun(gr,i+1,j,dp);\\n        int b = fun(gr,i,j+1,dp);\\n        return dp[i][j] = gr[i][j] + min(a,b);\\n    }\\n\\n    int minPathSum(vector<vector<int>>& gr) {\\n        vector<vector<int>> dp(gr.size(),vector<int>(gr[0].size(),-1));\\n        return fun(gr,0,0,dp);\\n    }\\n};\\n\\n```\\n# Tabulation (0,0) to (n,n) (ACCEPT)\\n- Time complexity: O(n*m)\\n\\n- Space complexity: O(n*m)\\n\\n```\\nclass Solution {\\npublic:\\n\\n    int minPathSum(vector<vector<int>>& gr) {\\n        vector<vector<int>> dp(gr.size(),vector<int>(gr[0].size(),-1));\\n        for(int i=0;i<gr.size();i++){\\n            for(int j=0; j<gr[0].size();j++){\\n                if(i==0 && j==0) dp[i][j] = gr[i][j];\\n                else{\\n                    int a=1e7,b=1e7;\\n                    if(i>0)\\n                        a= dp[i-1][j];\\n                    if(j>0)\\n                        b = dp[i][j-1];\\n                    dp[i][j] = gr[i][j] + min(a,b);\\n                }\\n            }\\n        }\\n        return dp[gr.size()-1][gr[0].size()-1];\\n    }\\n};\\n\\n```\\n# Tabulation (n,n) to (0,0) (ACCEPT)\\n- Time complexity: O(n*m)\\n\\n- Space complexity: O(n*m)\\n\\n```\\nclass Solution {\\npublic:\\n    int minPathSum(vector<vector<int>>& gr) {\\n        vector<vector<int>> dp(gr.size(),vector<int>(gr[0].size(),-1));\\n        for(int i = gr.size()-1; i>=0;i--){\\n            for(int j= gr[0].size()-1;j>=0;j--){\\n                if(i==gr.size()-1 && j==gr[0].size()-1) dp[i][j] = gr[i][j];\\n                else{\\n                    int a= 1e8, b= 1e8;\\n                    if(i < gr.size()-1)\\n                        a = dp[i+1][j];\\n                    if(j < gr[0].size()-1)\\n                        b= dp[i][j+1];\\n                    dp[i][j]=gr[i][j] + min(a,b);\\n                }\\n            }\\n        }\\n        return dp[0][0];\\n    }\\n};\\n\\n```\\n\\n",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\n<!-- Assume we need to reach ar[i][j]  -->\\n<!-- always check minimum possiblle rach value near by it -->\\nar[i][j] = ar[i][j] + min(ar[i-1][j],ar[i][j-1])\\n```\n```\\nclass Solution {\\npublic:\\n    int fun(vector<vector<int>>& gr, int i, int j ){\\n        if(i==gr.size()-1 && j==gr[0].size()-1){\\n            return gr[i][j];\\n        }\\n        if(i==gr.size() || j==gr[0].size()){\\n            return 1e8;\\n        }\\n        int a = fun(gr,i+1,j);\\n        int b = fun(gr,i,j+1);\\n        return gr[i][j] + min(a,b);\\n    }\\n\\n    int minPathSum(vector<vector<int>>& gr) {\\n        vector<vector<int>> dp(gr.size(),vector<int>(gr[0].size(),-1));\\n        return fun(gr,0,0);\\n    }\\n};\\n```\n```\\nclass Solution {\\npublic:\\n    int fun(vector<vector<int>>& gr, int i, int j  ){\\n        if(i==0 && j==0) return gr[i][j];\\n        if(i<0 || j<0) return 1e8;\\n        return gr[i][j] + min(fun(gr,i-1,j),fun(gr,i,j-1));\\n    }\\n    int minPathSum(vector<vector<int>>& gr) {\\n        vector<vector<int>> dp(gr.size(),vector<int>(gr[0].size(),-1));\\n        return fun(gr,gr.size()-1,gr[0].size()-1);\\n    }\\n};\\n```\n```\\nclass Solution {\\npublic:\\n    int fun(vector<vector<int>>& gr, int i, int j ,vector<vector<int>> &dp ){\\n        if(i==0 && j==0) return gr[i][j];\\n\\n        if(i<0 || j<0)  return 1e8;\\n\\n        if(dp[i][j] != -1) return dp[i][j];\\n        \\n        return dp[i][j] = gr[i][j] + min(fun(gr,i-1,j,dp),fun(gr,i,j-1,dp));\\n    }\\n\\n    int minPathSum(vector<vector<int>>& gr) {\\n        vector<vector<int>> dp(gr.size(),vector<int>(gr[0].size(),-1));\\n        return fun(gr,gr.size()-1,gr[0].size()-1,dp);\\n    }\\n};\\n```\n```\\nclass Solution {\\npublic:\\n    int fun(vector<vector<int>>& gr, int i, int j, vector<vector<int>> &dp){\\n        if(i==gr.size()-1 && j==gr[0].size()-1){\\n            return gr[i][j];\\n        }\\n        if(i==gr.size() || j==gr[0].size()){\\n            return 1e8;\\n        }\\n        if(dp[i][j] != -1) return dp[i][j];\\n        int a = fun(gr,i+1,j,dp);\\n        int b = fun(gr,i,j+1,dp);\\n        return dp[i][j] = gr[i][j] + min(a,b);\\n    }\\n\\n    int minPathSum(vector<vector<int>>& gr) {\\n        vector<vector<int>> dp(gr.size(),vector<int>(gr[0].size(),-1));\\n        return fun(gr,0,0,dp);\\n    }\\n};\\n\\n```\n```\\nclass Solution {\\npublic:\\n\\n    int minPathSum(vector<vector<int>>& gr) {\\n        vector<vector<int>> dp(gr.size(),vector<int>(gr[0].size(),-1));\\n        for(int i=0;i<gr.size();i++){\\n            for(int j=0; j<gr[0].size();j++){\\n                if(i==0 && j==0) dp[i][j] = gr[i][j];\\n                else{\\n                    int a=1e7,b=1e7;\\n                    if(i>0)\\n                        a= dp[i-1][j];\\n                    if(j>0)\\n                        b = dp[i][j-1];\\n                    dp[i][j] = gr[i][j] + min(a,b);\\n                }\\n            }\\n        }\\n        return dp[gr.size()-1][gr[0].size()-1];\\n    }\\n};\\n\\n```\n```\\nclass Solution {\\npublic:\\n    int minPathSum(vector<vector<int>>& gr) {\\n        vector<vector<int>> dp(gr.size(),vector<int>(gr[0].size(),-1));\\n        for(int i = gr.size()-1; i>=0;i--){\\n            for(int j= gr[0].size()-1;j>=0;j--){\\n                if(i==gr.size()-1 && j==gr[0].size()-1) dp[i][j] = gr[i][j];\\n                else{\\n                    int a= 1e8, b= 1e8;\\n                    if(i < gr.size()-1)\\n                        a = dp[i+1][j];\\n                    if(j < gr[0].size()-1)\\n                        b= dp[i][j+1];\\n                    dp[i][j]=gr[i][j] + min(a,b);\\n                }\\n            }\\n        }\\n        return dp[0][0];\\n    }\\n};\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 23493,
                "title": "my-java-solution-using-dp-with-memorization-beats-about-98-submissions",
                "content": "    public int minPathSum(int[][] grid) {\\n        int[][] memo = new int[grid.length][grid[0].length];\\n        return minPathSumHelper(grid, 0, 0, memo);\\n    }\\n    \\n    public int minPathSumHelper(int[][] grid, int row, int col, int[][] memo) {\\n        if(row == grid.length-1 && col == grid[0].length-1) return grid[row][col];\\n        if(memo[row][col] != 0) return memo[row][col];\\n\\n        int rowInc = Integer.MAX_VALUE, colInc = Integer.MAX_VALUE;\\n        if(row < grid.length-1) rowInc = minPathSumHelper(grid, row+1, col, memo);\\n        if(col < grid[0].length-1) colInc = minPathSumHelper(grid, row, col+1, memo);\\n        memo[row][col] = Math.min(rowInc, colInc) + grid[row][col];\\n        return memo[row][col];\\n    }\\n\\nUse a 2D array named memo to remember value which is calculated before to speed up.",
                "solutionTags": [
                    "Java",
                    "Dynamic Programming"
                ],
                "code": "    public int minPathSum(int[][] grid) {\\n        int[][] memo = new int[grid.length][grid[0].length];\\n        return minPathSumHelper(grid, 0, 0, memo);\\n    }\\n    \\n    public int minPathSumHelper(int[][] grid, int row, int col, int[][] memo) {\\n        if(row == grid.length-1 && col == grid[0].length-1) return grid[row][col];\\n        if(memo[row][col] != 0) return memo[row][col];\\n\\n        int rowInc = Integer.MAX_VALUE, colInc = Integer.MAX_VALUE;\\n        if(row < grid.length-1) rowInc = minPathSumHelper(grid, row+1, col, memo);\\n        if(col < grid[0].length-1) colInc = minPathSumHelper(grid, row, col+1, memo);\\n        memo[row][col] = Math.min(rowInc, colInc) + grid[row][col];\\n        return memo[row][col];\\n    }\\n\\nUse a 2D array named memo to remember value which is calculated before to speed up.",
                "codeTag": "Unknown"
            },
            {
                "id": 1513899,
                "title": "java-tc-o-r-c-sc-o-min-r-c-space-optimized-dynamic-programming-solution",
                "content": "```java\\n/**\\n * Space optimized Dynamic Programming solution (Input grid not modified)\\n *\\n * dp[i][j] = Math.min(dp[i-1][j], dp[i][j-1]) + grid[i][j].\\n * If j == 0, then dp[i][0] = dp[i-1][0] + grid[i][0].\\n * If i == 0, then dp[0][j] = dp[0][j-1] + grid[0][j].\\n *\\n * We can just use 1D array of size rows or columns.\\n *\\n * Time Complexity: O(R * C)\\n *\\n * Space Complexity : O(min(R, C))\\n *\\n * R = Number of rows. C = Number of columns.\\n */\\nclass Solution {\\n    public int minPathSum(int[][] grid) {\\n        if (grid == null) {\\n            throw new IllegalArgumentException(\"Input grid is null\");\\n        }\\n        if (grid.length == 0 || grid[0].length == 0) {\\n            return 0;\\n        }\\n\\n        int rows = grid.length;\\n        int cols = grid[0].length;\\n        if (rows == 1 && cols == 1) {\\n            return grid[0][0];\\n        }\\n\\n        if (cols <= rows) {\\n            return minPathSumHelper(grid, rows, cols, true);\\n        } else {\\n            return minPathSumHelper(grid, cols, rows, false);\\n        }\\n    }\\n\\n    private int minPathSumHelper(int[][] grid, int big, int small, boolean isColsSmall) {\\n        int[] dp = new int[small];\\n        // Process 1st small column/row\\n        dp[0] = grid[0][0];\\n        for (int j = 1; j < small; j++) {\\n            dp[j] = dp[j - 1] + (isColsSmall ? grid[0][j] : grid[j][0]);\\n        }\\n        // Process remaining columns/rows\\n        for (int i = 1; i < big; i++) {\\n            dp[0] += isColsSmall ? grid[i][0] : grid[0][i];\\n            for (int j = 1; j < small; j++) {\\n                dp[j] = Math.min(dp[j], dp[j - 1]) + (isColsSmall ? grid[i][j] : grid[j][i]);\\n            }\\n        }\\n        return dp[small - 1];\\n    }\\n}\\n```\\n\\n---\\n\\nSolutions to other parts of Unique Path question on LeetCode:\\n- [62. Unique Paths](https://leetcode.com/problems/unique-paths/discuss/1513886/Java-or-TC:-O(M*N)-or-SC:-O(min(MN))-or-Space-optimized-Dynamic-Programming-solution)\\n- [63. Unique Paths II](https://leetcode.com/problems/unique-paths-ii/discuss/1513891/Java-or-TC:-O(R*C)-or-SC:-O(min(RC))-or-Space-optimized-Dynamic-Programming-solution)\\n- [980. Unique Paths III](https://leetcode.com/problems/unique-paths-iii/discuss/1513906/Java-or-TC:-O(3(R*C))-or-SC:-O(R*C)-or-DFS-solution-with-Backtracking)\\n",
                "solutionTags": [
                    "Java",
                    "Array",
                    "Dynamic Programming",
                    "Matrix"
                ],
                "code": "```java\\n/**\\n * Space optimized Dynamic Programming solution (Input grid not modified)\\n *\\n * dp[i][j] = Math.min(dp[i-1][j], dp[i][j-1]) + grid[i][j].\\n * If j == 0, then dp[i][0] = dp[i-1][0] + grid[i][0].\\n * If i == 0, then dp[0][j] = dp[0][j-1] + grid[0][j].\\n *\\n * We can just use 1D array of size rows or columns.\\n *\\n * Time Complexity: O(R * C)\\n *\\n * Space Complexity : O(min(R, C))\\n *\\n * R = Number of rows. C = Number of columns.\\n */\\nclass Solution {\\n    public int minPathSum(int[][] grid) {\\n        if (grid == null) {\\n            throw new IllegalArgumentException(\"Input grid is null\");\\n        }\\n        if (grid.length == 0 || grid[0].length == 0) {\\n            return 0;\\n        }\\n\\n        int rows = grid.length;\\n        int cols = grid[0].length;\\n        if (rows == 1 && cols == 1) {\\n            return grid[0][0];\\n        }\\n\\n        if (cols <= rows) {\\n            return minPathSumHelper(grid, rows, cols, true);\\n        } else {\\n            return minPathSumHelper(grid, cols, rows, false);\\n        }\\n    }\\n\\n    private int minPathSumHelper(int[][] grid, int big, int small, boolean isColsSmall) {\\n        int[] dp = new int[small];\\n        // Process 1st small column/row\\n        dp[0] = grid[0][0];\\n        for (int j = 1; j < small; j++) {\\n            dp[j] = dp[j - 1] + (isColsSmall ? grid[0][j] : grid[j][0]);\\n        }\\n        // Process remaining columns/rows\\n        for (int i = 1; i < big; i++) {\\n            dp[0] += isColsSmall ? grid[i][0] : grid[0][i];\\n            for (int j = 1; j < small; j++) {\\n                dp[j] = Math.min(dp[j], dp[j - 1]) + (isColsSmall ? grid[i][j] : grid[j][i]);\\n            }\\n        }\\n        return dp[small - 1];\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 360106,
                "title": "python-5-approaches-dijkstra-a-dp-dfs-explained-and-visulaized",
                "content": "- Updated solutions 07/11/2021\\n------------------------------------------\\n\\n# [1] Dijkstra | 152 ms | faster than 12.02% \\n\\n------------------------------------------\\n- Cost to get to a cell is the value of the cell (the values of the cells will serve as weighted edges), while the nodes will only store the coordiantes of the cell.\\n\\t- nodes -> cells cooridinates\\n\\t- weighted edges -> costs -> values in cells\\n\\t- startNode = 0,0\\n\\t- endNode = len(grid)-1, len(grid[0])-1\\n\\n- Time: `O(Elogv)`\\n\\n![image](https://assets.leetcode.com/users/images/1c97142b-5137-4138-8c9c-151c9ab81cb8_1626646631.2057364.jpeg)\\n\\n\\n- the ultimate and only goal of Dijkstra is to populate the cost_so_far dict (or minWeights dict)\\nfor all nodes (aka min cost to get to each node)\\n- Dijkstra does not necessarlily have to wait until the entire weights dict is populated\\n- We can introduce an early exit if we are interesetd in a particular destination\\nthat we we might encounter in our search\\n\\n- we can also add a cameFrom dict to record parent:child relationships and\\nuse it to generate min path to any node we desire\\n\\n- heap frontier instead of queue\\n- find nei and add current cost to nei cost (cost to get to nei)\\n- For the nei we need to check:\\n\\t- [1] Is this the first time we are seeing this nei?\\n\\t- [2] Or, Did we see this nei before however this time we rached it via less expensive route?\\n\\n\\t- if the answer is yes to either [1] or [2]\\n\\t\\t- we update cost_so_far\\n\\n```\\ndef minPathSum(self, grid: List[List[int]]) -> int:\\n        \\n\\tfrom heapq import heappush, heappop\\n\\th = []\\n\\tstartNode = (grid[0][0], (0,0)) # cost, coor\\n\\theappush(h, startNode)\\n\\tdirs = [(1,0), (0,1)] # only right and down are allowed\\n\\tcost_so_far = {(0,0): grid[0][0]} # stores min cost to get to all nodes\\n\\t# cameFrom = {(0,0): None} # -- NOTE [1]\\n\\twhile h:\\n\\t\\tcost, node = heappop(h)\\n\\t\\tx, y = node\\n\\t\\tif x == len(grid)-1 and y == len(grid[0])-1: # destination found\\n\\t\\t\\tbreak\\n\\n\\t\\t# explore nei\\n\\t\\tfor dir in dirs:\\n\\t\\t\\tnewX, newY = x+dir[0], y+dir[1]\\n\\t\\t\\t# check bounds\\n\\t\\t\\tif newX <= len(grid)-1 and newY <= len(grid[0])-1:\\n\\t\\t\\t\\tedgeCost, nei = grid[newX][newY], (newX, newY)\\n\\t\\t\\t\\tnewCost = cost + edgeCost \\n\\t\\t\\t\\t# check if weights needs to be updated\\n\\t\\t\\t\\tif ( nei not in cost_so_far or (nei in cost_so_far and cost_so_far[nei] > newCost) ):\\n\\t\\t\\t\\t\\tcost_so_far[nei] = newCost\\n\\t\\t\\t\\t\\theappush(h, (newCost, nei))\\n\\t\\t\\t\\t\\t# cameFrom[nei] = node # -- NOTE [1]\\n\\n\\t# return cost to reach destination\\n\\treturn cost_so_far[(x,y)]\\n\\n\\t# NOTE [1]\\n\\t# --------\\n\\t# Min path debugging:\\n\\t# path = []\\n\\t# trgt = (len(grid)-1, len(grid[0])-1)\\n\\t# while trgt in cameFrom:\\n\\t#\\tpath.insert(0, trgt)\\n\\t#\\ttrgt = cameFrom[trgt]\\n\\t# print(\"path = \", path)\\n        \\n ```\\n \\n ------------------------------------------\\n# [2] A* Algorithm | 176 ms | faster than 7.45% of Python3\\n ------------------------------------------\\n \\n- Dijkstra wastes some time exploring paths that seem promising initailly due to its high sensetivity to local miminma\\n\\t- for ex: grid = [[1,3,1],[1,5,1],[4,2,1]]\\n\\t- correct answer (global mimima is achived by) : 1 \\u2192 3 \\u2192 1 \\u2192 1 \\u2192 1\\n\\t- however dijkstra will waste some time in the begining exploring the path\\n\\t\\t1 -> 1 -> 4 -> 2\\n\\t\\tbecause initally it looked more promising from the heap\\'s point of view\\n\\n- Let\\'s see if we can speed it up by adding a heurstic function (estimation) using manhattan distance\\n\\t- A* f(n) = g(n) + h(n)\\n\\t- h(n) = straight line distance (or Manhattan distance)\\n\\n\\tknowledge + estimation\\n\\tg(n) = knowledge\\n\\th(n) = estimation -> Eucledian or Manhattan distance\\n\\t\\n\\t![image](https://assets.leetcode.com/users/images/2bd70406-7c7e-4c78-b1f7-0b3ad23e0fe9_1626646839.7684267.jpeg)\\n\\n\\n\\t\\n\\t- Notice how our heuristic function of choice is admissible (aka. optimistic) meaning it\\'s optimistic in estimating the distance to the destination. Satisfying this condition is a prerequsite for the A* algorithm to be stable (it guarantess A* will find the optimal answer)\\n\\t- h(n) is optimistic when h(n) is less than the actual cost endured from cell n to target. \\n\\t- h(n) is optimisitic (aka admissible) because it simply adds up the remaining nodes that we need to traverse to reach target (and it DOES NOT assign any weights to the indivdual steps) whereas we know the range for the actual cost of each step is from `(1 ~ 100)`\\nfrom the input `0 <= grid[i][j] <= 100 `\\n\\n- h(n) should speed the search by serving as a tie breaker in situations where g(n) (aka. cost) is the same for two different directions/steps\\nThis is specially true because our grid is rectangular ` m*n`. Thus distance h(n) will favor either (a step to the right, or a step downwards) based on the distance.\\n- Using h(n) would still make sense even if we had a square grid `n*n` because narrows down the explored space before the target is found. See comparsion below:\\n\\n**[ credit** : https://www.redblobgames.com/pathfinding/a-star/introduction.html **]**\\n![image](https://assets.leetcode.com/users/images/89c24a54-cecb-46b8-b5aa-6513e5b8f5fa_1626645746.9307761.png)\\n\\n\\n- One last detail to pay attention to is the fact that -unlike Dijkstra- A* is not a `shortest-path-algorithm`, but rather a `search-algorithm`\\n\\t- In other words:\\n\\t\\t- A* : Essentially, helps us find a target in a grid:\\n\\t\\t\\t-  Faster than BFS\\n\\t\\t\\t-  Guarantees correctness -unlike purely greedy algorthims- which do not gauarntee correctness (aka. does not always return the global min/max) )\\n\\t\\t-  Dijkstra : By nature, allows us to find the shortest path to all nodes (including of-course our target node)\\n\\t\\t-  That being said, we need to do some post-processing after A* finishes\\n\\t\\t\\t-  Remember when we added h(n) to speed up the search and make it waste less time exploring\\n\\t\\t\\t-  The output of A* is a weights dict `ex: {node A : minCostToReach node A}` (simialr to Dijkstra)\\n\\t\\t\\t\\t-  However, the values of that dict will be the sum of `h(n) + g(n)` hence we have to subtract h(n) in order to return the correct answer. See note [1]. This extra step most probably cancels out any speed we might have gained by adding h(n) and converting our algorithm from Dijkstra to A*, however it\\'s worth the learning process. \\n\\n ```                        \\ndef minPathSum(self, grid: List[List[int]]) -> int:        \\n        \\n\\t# helper to generate heuristic function h(n) based on Manhattan distance\\n        def generateHeuristics():\\n            trgtX, trgtY = len(grid[0])-1, len(grid)-1\\n            heuristics = {}\\n            for r in range(len(grid)):\\n                for c in range(len(grid[0])):\\n                    dist = abs(trgtY - r) + abs(trgtX - c) \\n                    heuristics[(r,c)] = dist\\n            return heuristics\\n        \\n        \\n        # main\\n        heuristics = generateHeuristics()\\n        h = []\\n        from heapq import heappush, heappop\\n        # cost = cost + estimation\\n        cost = grid[0][0] + heuristics[(0,0)]\\n        start = (cost, (0,0))\\n        cost_so_far = {(0,0): cost}\\n        cameFrom = {(0,0): None}\\n        heappush(h, start)\\n        trgtX, trgtY = len(grid)-1, len(grid[0])-1\\n        \\n        dirs = [(1,0), (0,1)]\\n        totalEstimationAdded = 0\\n        while h:\\n            cost, (x,y) = heappop(h)\\n            # print(cost, (x,y))\\n            if (x,y) == (trgtX, trgtY): # trgt found\\n                break\\n            for dir in dirs:\\n                newX, newY = x+dir[0], y+dir[1]\\n                \\n                if newX <= len(grid)-1 and newY <= len(grid[0])-1: # bounds\\n                    # print(\\'newX, newY = \\', newX, newY)\\n                    edgeCost = grid[newX][newY] \\n                    newCost = cost + edgeCost\\n\\n                    if (newX, newY) not in cost_so_far or ((newX, newY) in cost_so_far and newCost < cost_so_far[(newX, newY)] ):\\n                        cost_so_far[(newX, newY)] = newCost\\n                        heappush(h, (newCost + heuristics[(newX, newY)], (newX, newY)))\\n                        cameFrom[(newX, newY)] = (x, y)\\n\\n        \\n        costFunc = cost_so_far[(trgtX, trgtY)] # - NOTE [1]\\n\\n        \\n        # NOTE [1]\\n        # --------\\n        # Please notice that costFunc is a sum of (knowledge, estimation) along the shortest path\\n        # hence does not exactly match the desired ouput of this problem (problem is only asking for knoweldge based cost - free from heurtisitc or estimation)\\n        # Perhaps A* is not best suited for this probelm since the problem is not\\n        # asking to just find the target (a process that A* accelartes)\\n        # but rather, asks for the actual cost (knowledge free from estimation)\\n        \\n        # However, we can obtain the desired output bu doing some simple post-processing to the answer since the answer\\n        # (aka cost) is a sum of both knowledge and estimation\\n        # we have to subtract estimation to arrive at the wanted answer\\n        # totalEstimationAdded += (cost - grid[x][y]) # subtract knowledge from total \\n        # we can do that by building the shortest path and then subtract\\n        \\n        \\n        # Generate shortest path\\n        path = []\\n        trgt = (trgtX, trgtY)\\n        while trgt in cameFrom:\\n            path.insert(0, trgt)\\n            trgt = cameFrom[trgt]\\n        # print(\"path = \", path)\\n        \\n        actualCost = costFunc\\n        for (x,y) in path:\\n            actualCost -= heuristics[(x,y)]\\n        return actualCost\\n```\\n\\n\\n ------------------------------------------\\n# [3] Bottom up DP with in-place tabulation | 88 ms | faster than 97.41%\\n ------------------------------------------\\n- Similar to UniquePaths I/II : https://leetcode.com/problems/unique-paths-ii/discuss/1595001/Python3-4-approaches-(top-down-bottom-up-brute-force)\\n- bottom - up approach, solving the problem at a smaller scale first\\n- Instead of finding the min cost to get to the m,n cell right away, we first find the min cost to get to each cell, starting from the cells adjacent to the origin.\\n- cells at the top most row, can only be accessed from the left\\nwhich means the cost of visiting each one of them will be simply the sum of the\\ncurr cell and the cell the preceeded it\\n\\n- same concept applies for the cells in the left most col\\n\\n- for the rest of the grid, cost of visiting each cell:\\n\\n\\tg[i][j] = min(g[i-1][j], g[i][j-1])\\n\\n\\twhich is very similar to what we did in unique paths\\n\\n\\tg[i][j] = g[i-1][j] + g[i][j-1]\\n\\n- time: O(m-1)*(n-1) === O(m*n)\\n- space: O(1) in-place\\n\\n- starting from cell (1,1) -> min(left, top) aka the 2 direction we might have came from\\n- use the grid itself as a dp matrix\\n- this is a 2-dimensional dp problem since the steps could either be 1) horizontal 2) vertical\\n\\n```\\ndef minPathSum(self, grid: List[List[int]]) -> int:  \\n\\t# top row\\n\\tfor i in range(1, len(grid[0])):\\n\\t\\tgrid[0][i] += grid[0][i-1]\\n\\n\\t# left most col\\n\\tfor i in range(1, len(grid)):\\n\\t\\tgrid[i][0] += grid[i-1][0]\\n\\n\\t# rest of the grid\\n\\tfor i in range(1, len(grid)):\\n\\t\\tfor j in range(1, len(grid[0])):\\n\\t\\t\\tgrid[i][j] += min(grid[i-1][j], grid[i][j-1]) \\n\\n\\ttrgtX, trgtY = len(grid)-1, len(grid[0])-1\\n\\treturn grid[trgtX][trgtY]\\n\\n```\\n\\n---------------------------------------------\\n# [4] Iterative brute-force DFS\\nTLE 20 / 61 test cases passed.\\n---------------------------------------------\\n---------------------------------------------\\n- a post discussing a simialr approach : https://leetcode.com/problems/all-paths-from-source-to-target/discuss/986429/Python-Iterative-DFS-with-detailed-time-complexity-and-visuals \\n- Examine each path individually till the end and return the one with min cost \\n- O(k-avg * N)\\nN = number of cells M*N\\nK-avg = the average of how many times a node is visited (due to not using a visited set)\\nk-min = 1\\nk-max = number of paths in the grid (number of times the (trgtX, trgtY) node is visited)\\nk-max = ( (m-1) + (n-1) ) / ( (m-1)! * (n-1)! )\\n\\n```\\ndef minPathSum(self, grid: List[List[int]]) -> int:  \\n\\tminPathCost = float(\\'inf\\')\\n\\tstack = [( (0,0), grid[0][0] )]\\n\\ttrgtX, trgtY = len(grid)-1, len(grid[0])-1\\n\\tdirs = [(1,0), (0,1)]\\n\\twhile stack:\\n\\t\\t(x,y), pathCost = stack.pop()\\n\\n\\t\\tif (x,y) == (trgtX, trgtY): # only capture pathCost when path is fully traversed (aka rigt-bottm corner cell is reached)\\n\\t\\t\\tminPathCost = min(minPathCost, pathCost)\\n\\n\\t\\tfor dir in dirs:\\n\\t\\t\\tnewX, newY = x+dir[0], y+dir[1]\\n\\t\\t\\tif newX <= trgtX and newY <= trgtY:\\n\\t\\t\\t\\tstack.append( ( (newX, newY), pathCost+grid[newX][newY] ) )\\n\\n\\treturn minPathCost\\n\\n```\\n\\n---------------------------------------------\\n# [5] Recursive DFS with memoization\\n---------------------------------------------\\n\\n\\n```\\n def minPathSum(self, grid: List[List[int]]) -> int:         \\n\\t# helper\\n\\tdef recurse(i,j):\\n\\n\\t\\tif (i,j) == (len(grid)-1, len(grid[0])-1): # reachedt traget\\n\\t\\t\\treturn grid[i][j] # return the value of the cell to be added to the sum\\n\\n\\t\\tif i > len(grid)-1 or j > len(grid[0])-1: # out of bounds\\n\\t\\t\\treturn float(\\'inf\\') # return a huge number to cause the path to be disgarded\\n\\n\\t\\tif (i,j) in memo:\\n\\t\\t\\treturn memo[(i,j)]\\n\\n\\t\\t# if none of the above\\n\\t\\tresult = grid[i][j] + min(recurse(i+1, j), recurse(i, j+1))\\n\\t\\tmemo[(i,j)] = result\\n\\t\\treturn result\\n\\n\\t# main:\\n\\tmemo = {}\\n\\treturn recurse(0,0) # starting Node\\n\\n\\t# NOTE\\n\\t# memo is going to start building from target \\n\\t# memo =  {}\\n\\t# memo =  {(2, 1): 3, (2, 0): 7}\\n\\t# memo =  {(2, 1): 3, (2, 0): 7, (1, 2): 2, (1, 1): 7, (1, 0): 8}\\n```",
                "solutionTags": [
                    "Python",
                    "Dynamic Programming",
                    "Depth-First Search",
                    "Iterator"
                ],
                "code": "```\\ndef minPathSum(self, grid: List[List[int]]) -> int:\\n        \\n\\tfrom heapq import heappush, heappop\\n\\th = []\\n\\tstartNode = (grid[0][0], (0,0)) # cost, coor\\n\\theappush(h, startNode)\\n\\tdirs = [(1,0), (0,1)] # only right and down are allowed\\n\\tcost_so_far = {(0,0): grid[0][0]} # stores min cost to get to all nodes\\n\\t# cameFrom = {(0,0): None} # -- NOTE [1]\\n\\twhile h:\\n\\t\\tcost, node = heappop(h)\\n\\t\\tx, y = node\\n\\t\\tif x == len(grid)-1 and y == len(grid[0])-1: # destination found\\n\\t\\t\\tbreak\\n\\n\\t\\t# explore nei\\n\\t\\tfor dir in dirs:\\n\\t\\t\\tnewX, newY = x+dir[0], y+dir[1]\\n\\t\\t\\t# check bounds\\n\\t\\t\\tif newX <= len(grid)-1 and newY <= len(grid[0])-1:\\n\\t\\t\\t\\tedgeCost, nei = grid[newX][newY], (newX, newY)\\n\\t\\t\\t\\tnewCost = cost + edgeCost \\n\\t\\t\\t\\t# check if weights needs to be updated\\n\\t\\t\\t\\tif ( nei not in cost_so_far or (nei in cost_so_far and cost_so_far[nei] > newCost) ):\\n\\t\\t\\t\\t\\tcost_so_far[nei] = newCost\\n\\t\\t\\t\\t\\theappush(h, (newCost, nei))\\n\\t\\t\\t\\t\\t# cameFrom[nei] = node # -- NOTE [1]\\n\\n\\t# return cost to reach destination\\n\\treturn cost_so_far[(x,y)]\\n\\n\\t# NOTE [1]\\n\\t# --------\\n\\t# Min path debugging:\\n\\t# path = []\\n\\t# trgt = (len(grid)-1, len(grid[0])-1)\\n\\t# while trgt in cameFrom:\\n\\t#\\tpath.insert(0, trgt)\\n\\t#\\ttrgt = cameFrom[trgt]\\n\\t# print(\"path = \", path)\\n        \\n ```\n```                        \\ndef minPathSum(self, grid: List[List[int]]) -> int:        \\n        \\n\\t# helper to generate heuristic function h(n) based on Manhattan distance\\n        def generateHeuristics():\\n            trgtX, trgtY = len(grid[0])-1, len(grid)-1\\n            heuristics = {}\\n            for r in range(len(grid)):\\n                for c in range(len(grid[0])):\\n                    dist = abs(trgtY - r) + abs(trgtX - c) \\n                    heuristics[(r,c)] = dist\\n            return heuristics\\n        \\n        \\n        # main\\n        heuristics = generateHeuristics()\\n        h = []\\n        from heapq import heappush, heappop\\n        # cost = cost + estimation\\n        cost = grid[0][0] + heuristics[(0,0)]\\n        start = (cost, (0,0))\\n        cost_so_far = {(0,0): cost}\\n        cameFrom = {(0,0): None}\\n        heappush(h, start)\\n        trgtX, trgtY = len(grid)-1, len(grid[0])-1\\n        \\n        dirs = [(1,0), (0,1)]\\n        totalEstimationAdded = 0\\n        while h:\\n            cost, (x,y) = heappop(h)\\n            # print(cost, (x,y))\\n            if (x,y) == (trgtX, trgtY): # trgt found\\n                break\\n            for dir in dirs:\\n                newX, newY = x+dir[0], y+dir[1]\\n                \\n                if newX <= len(grid)-1 and newY <= len(grid[0])-1: # bounds\\n                    # print(\\'newX, newY = \\', newX, newY)\\n                    edgeCost = grid[newX][newY] \\n                    newCost = cost + edgeCost\\n\\n                    if (newX, newY) not in cost_so_far or ((newX, newY) in cost_so_far and newCost < cost_so_far[(newX, newY)] ):\\n                        cost_so_far[(newX, newY)] = newCost\\n                        heappush(h, (newCost + heuristics[(newX, newY)], (newX, newY)))\\n                        cameFrom[(newX, newY)] = (x, y)\\n\\n        \\n        costFunc = cost_so_far[(trgtX, trgtY)] # - NOTE [1]\\n\\n        \\n        # NOTE [1]\\n        # --------\\n        # Please notice that costFunc is a sum of (knowledge, estimation) along the shortest path\\n        # hence does not exactly match the desired ouput of this problem (problem is only asking for knoweldge based cost - free from heurtisitc or estimation)\\n        # Perhaps A* is not best suited for this probelm since the problem is not\\n        # asking to just find the target (a process that A* accelartes)\\n        # but rather, asks for the actual cost (knowledge free from estimation)\\n        \\n        # However, we can obtain the desired output bu doing some simple post-processing to the answer since the answer\\n        # (aka cost) is a sum of both knowledge and estimation\\n        # we have to subtract estimation to arrive at the wanted answer\\n        # totalEstimationAdded += (cost - grid[x][y]) # subtract knowledge from total \\n        # we can do that by building the shortest path and then subtract\\n        \\n        \\n        # Generate shortest path\\n        path = []\\n        trgt = (trgtX, trgtY)\\n        while trgt in cameFrom:\\n            path.insert(0, trgt)\\n            trgt = cameFrom[trgt]\\n        # print(\"path = \", path)\\n        \\n        actualCost = costFunc\\n        for (x,y) in path:\\n            actualCost -= heuristics[(x,y)]\\n        return actualCost\\n```\n```\\ndef minPathSum(self, grid: List[List[int]]) -> int:  \\n\\t# top row\\n\\tfor i in range(1, len(grid[0])):\\n\\t\\tgrid[0][i] += grid[0][i-1]\\n\\n\\t# left most col\\n\\tfor i in range(1, len(grid)):\\n\\t\\tgrid[i][0] += grid[i-1][0]\\n\\n\\t# rest of the grid\\n\\tfor i in range(1, len(grid)):\\n\\t\\tfor j in range(1, len(grid[0])):\\n\\t\\t\\tgrid[i][j] += min(grid[i-1][j], grid[i][j-1]) \\n\\n\\ttrgtX, trgtY = len(grid)-1, len(grid[0])-1\\n\\treturn grid[trgtX][trgtY]\\n\\n```\n```\\ndef minPathSum(self, grid: List[List[int]]) -> int:  \\n\\tminPathCost = float(\\'inf\\')\\n\\tstack = [( (0,0), grid[0][0] )]\\n\\ttrgtX, trgtY = len(grid)-1, len(grid[0])-1\\n\\tdirs = [(1,0), (0,1)]\\n\\twhile stack:\\n\\t\\t(x,y), pathCost = stack.pop()\\n\\n\\t\\tif (x,y) == (trgtX, trgtY): # only capture pathCost when path is fully traversed (aka rigt-bottm corner cell is reached)\\n\\t\\t\\tminPathCost = min(minPathCost, pathCost)\\n\\n\\t\\tfor dir in dirs:\\n\\t\\t\\tnewX, newY = x+dir[0], y+dir[1]\\n\\t\\t\\tif newX <= trgtX and newY <= trgtY:\\n\\t\\t\\t\\tstack.append( ( (newX, newY), pathCost+grid[newX][newY] ) )\\n\\n\\treturn minPathCost\\n\\n```\n```\\n def minPathSum(self, grid: List[List[int]]) -> int:         \\n\\t# helper\\n\\tdef recurse(i,j):\\n\\n\\t\\tif (i,j) == (len(grid)-1, len(grid[0])-1): # reachedt traget\\n\\t\\t\\treturn grid[i][j] # return the value of the cell to be added to the sum\\n\\n\\t\\tif i > len(grid)-1 or j > len(grid[0])-1: # out of bounds\\n\\t\\t\\treturn float(\\'inf\\') # return a huge number to cause the path to be disgarded\\n\\n\\t\\tif (i,j) in memo:\\n\\t\\t\\treturn memo[(i,j)]\\n\\n\\t\\t# if none of the above\\n\\t\\tresult = grid[i][j] + min(recurse(i+1, j), recurse(i, j+1))\\n\\t\\tmemo[(i,j)] = result\\n\\t\\treturn result\\n\\n\\t# main:\\n\\tmemo = {}\\n\\treturn recurse(0,0) # starting Node\\n\\n\\t# NOTE\\n\\t# memo is going to start building from target \\n\\t# memo =  {}\\n\\t# memo =  {(2, 1): 3, (2, 0): 7}\\n\\t# memo =  {(2, 1): 3, (2, 0): 7, (1, 2): 2, (1, 1): 7, (1, 0): 8}\\n```",
                "codeTag": "Python3"
            },
            {
                "id": 23678,
                "title": "c-easy-solution-using-dp-space-compexity-o-1",
                "content": "    class Solution {\\n    public:\\n        int minPathSum(vector<vector<int>>& a) {\\n            int m=a.size();\\n            if(m==0) return 0;\\n            int n= a[0].size();\\n            \\n            for(int i = 0 ; i<m; i++  ){\\n                for(int j=0; j<n ; j++){\\n                    int left= (j==0) ? INT_MAX : a[i][j-1];\\n                    int up = (i==0) ? INT_MAX : a[i-1][j];\\n                    if(i==0 && j==0) continue;\\n                    a[i][j] += min(left, up );\\n                }\\n            }\\n            return a[m-1][n-1];\\n        }\\n    };",
                "solutionTags": [],
                "code": "class Solution {\\n    public:\\n        int minPathSum(vector<vector<int>>& a) {\\n            int m=a.size();\\n            if(m==0) return 0;\\n            int n= a[0].size();\\n            \\n            for(int i = 0 ; i<m; i++  ){\\n                for(int j=0; j<n ; j++){\\n                    int left= (j==0) ? INT_MAX : a[i][j-1];\\n                    int up = (i==0) ? INT_MAX : a[i-1][j];\\n                    if(i==0 && j==0) continue;\\n                    a[i][j] += min(left, up );\\n                }",
                "codeTag": "Java"
            },
            {
                "id": 23615,
                "title": "my-solution-beats-100-java-solutions",
                "content": "    public class Solution {\\n        public int minPathSum(int[][] grid) {\\n            if(grid.length == 0)  return 0;\\n            \\n            int r = grid.length;\\n            int c = grid[0].length;\\n            \\n            for(int i=0;i<r; i++) {\\n                for(int j=0; j<c; j++) {\\n                    int leftSum = (j>0) ? grid[i][j-1] : Integer.MAX_VALUE;\\n                    int topSum = (i>0) ? grid[i-1][j] : Integer.MAX_VALUE;\\n                    if(i==0 && j==0) continue;\\n                    \\n                    grid[i][j] += Math.min(leftSum, topSum);\\n                }\\n            }\\n            return grid[r-1][c-1];\\n        }\\n    }",
                "solutionTags": [
                    "Java"
                ],
                "code": "class Solution {\\n        public int minPathSum(int[][] grid) {\\n            if(grid.length == 0)  return 0;\\n            \\n            int r = grid.length;\\n            int c = grid[0].length;\\n            \\n            for(int i=0;i<r; i++) {\\n                for(int j=0; j<c; j++) {\\n                    int leftSum = (j>0) ? grid[i][j-1] : Integer.MAX_VALUE;\\n                    int topSum = (i>0) ? grid[i-1][j] : Integer.MAX_VALUE;\\n                    if(i==0 && j==0) continue;\\n                    \\n                    grid[i][j] += Math.min(leftSum, topSum);\\n                }",
                "codeTag": "Java"
            },
            {
                "id": 3345712,
                "title": "complete-intuition-explained-recursion-memoization-tabulation-dp",
                "content": "![image](https://assets.leetcode.com/users/images/c87574f8-29ca-47eb-af34-a41610f4dee4_1679888406.0141091.png)\\n![image](https://assets.leetcode.com/users/images/60006acc-70fe-4065-b14f-7585a2875ddc_1679888413.6319273.png)\\n![image](https://assets.leetcode.com/users/images/80f0011b-c7fc-4f0e-89c9-85fc16ec6840_1679888421.8878033.png)\\n\\n\\n\\n### RECURSION \\n```\\nclass Solution {\\npublic:\\n    int m, n;\\n    int solve(vector<vector<int>>&grid, int currRow, int currCol)\\n    {\\n        if (currRow >= m || currCol >= n) return INT_MAX; //when cell is out of bounds\\n        if (currRow == m - 1 && currCol == n - 1) return grid[m - 1][n - 1]; //reached the target\\n        \\n        int rightMin = solve(grid, currRow, currCol + 1);\\n        int downMin = solve(grid, currRow + 1, currCol);\\n        int bestChoice = min(rightMin, downMin);\\n        \\n        return (grid[currRow][currCol] + bestChoice);\\n    }\\n    int minPathSum(vector<vector<int>>& grid) \\n    {\\n        m = grid.size(); n = grid[0].size();\\n        return solve(grid, 0, 0);\\n    }\\n};\\n```\\n//===========================================================================================================================================\\n\\n### MEMOIZATION\\n```\\nclass Solution {\\npublic:\\n    int m, n;\\n    int solve(vector<vector<int>>&grid, vector<vector<int>>&dp, int currRow, int currCol)\\n    {\\n        if (currRow >= m || currCol >= n) return INT_MAX; //when cell is out of bounds\\n        if (currRow == m - 1 && currCol == n - 1) return grid[m - 1][n - 1]; //reached the target\\n        \\n        if (dp[currRow][currCol] !=  -1) return dp[currRow][currCol]; //use the already computed result\\n        int rightMin = solve(grid, dp, currRow, currCol + 1);\\n        int downMin = solve(grid, dp, currRow + 1, currCol);\\n        int bestChoice = min(rightMin, downMin);\\n        \\n        return dp[currRow][currCol] = (grid[currRow][currCol] + bestChoice); //store the result \\n    }\\n    int minPathSum(vector<vector<int>>& grid) \\n    {\\n        m = grid.size(); n = grid[0].size();\\n        vector<vector<int>>dp(m, vector<int>(n, -1)); \\n        //\\'-1\\' to denote that subproblem result for that cell is not computed and not stored\\n        return solve(grid, dp, 0, 0);\\n    }\\n};\\n```\\n\\n//=========================================================================================================================================\\n\\n### BOTTOM-UP DYNAMIC PROGRAMMING \\n```\\nclass Solution {\\npublic:\\n    int minPathSum(vector<vector<int>>& grid) \\n    {\\n        int m = grid.size(), n = grid[0].size();\\n        //traverse from \\'bottom->top\\' and \\'right->left\\'\\n        //as for any cell we need computed result from \\'down\\' and \\'right\\'\\n        for (int i = m - 1; i >= 0; i--)\\n        {\\n            for (int j = n - 1; j >= 0; j--)\\n            {\\n                if (i == m - 1 && j == n - 1) continue;\\n                \\n                //grid[i][j + 1] and grid[i + 1][j] will already have stored the result of subproblem\\n                int rightMin = (j + 1 >= n)? INT_MAX : grid[i][j + 1]; //\\n                int downMin = (i + 1 >= m)? INT_MAX : grid[i + 1][j];\\n                grid[i][j] = grid[i][j] + (min(rightMin, downMin)); \\n                //rather than making a new \\'DP\\' grid store results of subproblems in the same grid\\n            }\\n        }\\n        return grid[0][0];\\n        \\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "C",
                    "Dynamic Programming"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int m, n;\\n    int solve(vector<vector<int>>&grid, int currRow, int currCol)\\n    {\\n        if (currRow >= m || currCol >= n) return INT_MAX; //when cell is out of bounds\\n        if (currRow == m - 1 && currCol == n - 1) return grid[m - 1][n - 1]; //reached the target\\n        \\n        int rightMin = solve(grid, currRow, currCol + 1);\\n        int downMin = solve(grid, currRow + 1, currCol);\\n        int bestChoice = min(rightMin, downMin);\\n        \\n        return (grid[currRow][currCol] + bestChoice);\\n    }\\n    int minPathSum(vector<vector<int>>& grid) \\n    {\\n        m = grid.size(); n = grid[0].size();\\n        return solve(grid, 0, 0);\\n    }\\n};\\n```\n```\\nclass Solution {\\npublic:\\n    int m, n;\\n    int solve(vector<vector<int>>&grid, vector<vector<int>>&dp, int currRow, int currCol)\\n    {\\n        if (currRow >= m || currCol >= n) return INT_MAX; //when cell is out of bounds\\n        if (currRow == m - 1 && currCol == n - 1) return grid[m - 1][n - 1]; //reached the target\\n        \\n        if (dp[currRow][currCol] !=  -1) return dp[currRow][currCol]; //use the already computed result\\n        int rightMin = solve(grid, dp, currRow, currCol + 1);\\n        int downMin = solve(grid, dp, currRow + 1, currCol);\\n        int bestChoice = min(rightMin, downMin);\\n        \\n        return dp[currRow][currCol] = (grid[currRow][currCol] + bestChoice); //store the result \\n    }\\n    int minPathSum(vector<vector<int>>& grid) \\n    {\\n        m = grid.size(); n = grid[0].size();\\n        vector<vector<int>>dp(m, vector<int>(n, -1)); \\n        //\\'-1\\' to denote that subproblem result for that cell is not computed and not stored\\n        return solve(grid, dp, 0, 0);\\n    }\\n};\\n```\n```\\nclass Solution {\\npublic:\\n    int minPathSum(vector<vector<int>>& grid) \\n    {\\n        int m = grid.size(), n = grid[0].size();\\n        //traverse from \\'bottom->top\\' and \\'right->left\\'\\n        //as for any cell we need computed result from \\'down\\' and \\'right\\'\\n        for (int i = m - 1; i >= 0; i--)\\n        {\\n            for (int j = n - 1; j >= 0; j--)\\n            {\\n                if (i == m - 1 && j == n - 1) continue;\\n                \\n                //grid[i][j + 1] and grid[i + 1][j] will already have stored the result of subproblem\\n                int rightMin = (j + 1 >= n)? INT_MAX : grid[i][j + 1]; //\\n                int downMin = (i + 1 >= m)? INT_MAX : grid[i + 1][j];\\n                grid[i][j] = grid[i][j] + (min(rightMin, downMin)); \\n                //rather than making a new \\'DP\\' grid store results of subproblems in the same grid\\n            }\\n        }\\n        return grid[0][0];\\n        \\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 453856,
                "title": "beautiful-tasty-java-dp-solution-w-comments",
                "content": "```java\\nclass Solution {\\n    public int minPathSum(int[][] grid) {\\n        // get mxn sizes\\n        int m = grid.length; int n = grid[0].length;\\n        \\n        // dp array\\n        int[][] dp = new int[m][n];\\n        dp[0][0] = grid[0][0];\\n        \\n        // handle first column\\n        for (int i = 1; i < m; i++) {\\n            // add one before it\\n            dp[i][0] = grid[i][0] + dp[i-1][0];\\n        }\\n        \\n        // handle first row\\n        for (int i = 1; i < n; i++) {\\n            // add one before it\\n            dp[0][i] = grid[0][i] + dp[0][i-1];\\n        }\\n        \\n        // starting from (1,1) iterate thru array taking min path choices along the way\\n        for (int i = 1; i < m; i++) {\\n            for (int j = 1; j < n; j++) {\\n                // dp value at this coordinate is lesser of the two possible paths\\n                dp[i][j] = grid[i][j] + Math.min(dp[i-1][j], dp[i][j-1]);\\n            }\\n        }\\n        \\n        // the result should be at the bottom right corner of DP array\\n        return dp[m-1][n-1];\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Dynamic Programming"
                ],
                "code": "```java\\nclass Solution {\\n    public int minPathSum(int[][] grid) {\\n        // get mxn sizes\\n        int m = grid.length; int n = grid[0].length;\\n        \\n        // dp array\\n        int[][] dp = new int[m][n];\\n        dp[0][0] = grid[0][0];\\n        \\n        // handle first column\\n        for (int i = 1; i < m; i++) {\\n            // add one before it\\n            dp[i][0] = grid[i][0] + dp[i-1][0];\\n        }\\n        \\n        // handle first row\\n        for (int i = 1; i < n; i++) {\\n            // add one before it\\n            dp[0][i] = grid[0][i] + dp[0][i-1];\\n        }\\n        \\n        // starting from (1,1) iterate thru array taking min path choices along the way\\n        for (int i = 1; i < m; i++) {\\n            for (int j = 1; j < n; j++) {\\n                // dp value at this coordinate is lesser of the two possible paths\\n                dp[i][j] = grid[i][j] + Math.min(dp[i-1][j], dp[i][j-1]);\\n            }\\n        }\\n        \\n        // the result should be at the bottom right corner of DP array\\n        return dp[m-1][n-1];\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1848341,
                "title": "python-solution-greedy-recursive-memorization-bottom-up-approach",
                "content": "### Solution by Ranjal (Leetcode username: ranjal_omer)\\n\\t\\n\\timport sys\\n\\tclass Solution:\\n\\t\\tdef minPathSum(self, grid: List[List[int]]) -> int:\\n        \\n### ___ Greedy Approach___\\n        \"\"\"\\n        \\n        @ Lets Discuss why not to follow greedy technique in this problem:\\n        \\n        1- Because if we follow greedy we might endup choosing the wrong path which rather\\n        \\n        giving us the minimum value will give us some another higher value\\n        \\n        for example if we take a grid \\n            \\n            1 2 6 4\\n            5 8 5 85\\n            1 3 2 1\\n            \\n            if we follow the greedy method and starting from 0,0 we will choose minimum of (2,5)\\n            since 2 will be the minimum we will move in the direction of 2\\n            as we can only move downwards and right\\n            \\n            and so on we will get the path like 1-> 2 -> 6 -> 4 -> 85 ->1 === 99\\n            \\n            but because of the greeedy nature we have missed the optimum path which gives us the minimum\\n            sum that is\\n            \\n            1-> 5 -> 1 -> 3 -> 2 -> 1 ==== 13 \\n            \\n            Therefore the greedy Technique fails here\\n        \\n        \"\"\"\\n        #-----------------------------------------------------------------------------------------#\\n        \"\"\"\\n        \\n        Time Complexity : O(m*n)\\n        Stack Space : O(m*n)+ O(path length)\\n        \\n        \\n### ___ Recursive Approach___\\n        # Now moving towards the recursive solution\\n        \\n        # which will gives us all the possible path from which we can find the min path (Exploring all paths)\\n        \"\"\"\\n        def f(i,j):\\n            \\n            if i==0 and j==0:\\n                return grid[0][0]\\n           \\n            # in case we have reached out of the boundry then we have to return the maximum value so that after the addition of that value the the path...then the path will never be our answer\\n            # because following that path we have reached out of boundry\\n            \\n            if i<0 or j<0:\\n                \\n                return sys.maxsize\\n            \\n            \\n            up=grid[i][j]+f(i-1,j)\\n            left = grid[i][j]+ f(i,j-1)\\n            \\n            \\n            return min(up,left)\\n        \\n        # return f(len(grid)-1,len(grid[0])-1)\\n        \\n        #-----------------------------------------------------------------------------------------#\\n### ___ Memoizing the Recursive Approach___   \\n        \"\"\"\\n        \\n        Now memoizing the recursive code:---->\\n        \\n        \\n        \"\"\"\\n        n=len(grid)\\n        m= len(grid[0])\\n        \\n        dp=[[-1]*m for i in range(n)]\\n        \\n        def f(i,j):\\n            \\n            if i==0 and j==0:\\n                return grid[0][0]\\n           \\n            # in case we have reached out of the boundry then we have to return the maximum value so that after the addition of that value the the path...then the path will never be our answer\\n            # because following that path we have reached out of boundry\\n            \\n            if i<0 or j<0:\\n                \\n                return sys.maxsize\\n            \\n            if dp[i][j]!=-1:\\n                return dp[i][j]\\n            \\n            up=grid[i][j]+f(i-1,j)\\n            left = grid[i][j]+ f(i,j-1)\\n            \\n            \\n            dp[i][j]=min(up,left)\\n            return dp[i][j]\\n        # return f(n-1,m-1)\\n        \\n        \\n        \\n        \\n        #-----------------------------------------------------------------------------------------#\\n        \\n### ___ Bottom-Up Approach___\\n        \"\"\"\\n        \\n        Now Converting  the memoized code into bottom up:---->\\n        \\n        \\n        \"\"\"\\n        \\n        dp=[[0]*m for i in range(n)]\\n        \\n        for i in range(n):\\n            for j in range(m):\\n                if i==0 and j==0:\\n                    dp[i][j]= grid[i][j]\\n                    \\n                else:\\n                    up=grid[i][j]\\n                    left=grid[i][j]\\n                    \\n                    if i>0:\\n                        up+= dp[i-1][j]\\n                    else:\\n                        up+=sys.maxsize\\n                    if j>0:\\n                        left+=dp[i][j-1]\\n                    else:\\n                        left+=sys.maxsize\\n                    \\n                    dp[i][j]= min(up,left)\\n                    \\n        return dp[n-1][m-1]\\n\\t\\n## Thankyou for visiting!! \\n### Please upvote the solution and share it with your friends :) <3",
                "solutionTags": [
                    "Python",
                    "Dynamic Programming",
                    "Recursion",
                    "Memoization"
                ],
                "code": "### Solution by Ranjal (Leetcode username: ranjal_omer)\\n\\t\\n\\timport sys\\n\\tclass Solution:\\n\\t\\tdef minPathSum(self, grid: List[List[int]]) -> int:\\n        \\n### ___ Greedy Approach___\\n        \"\"\"\\n        \\n        @ Lets Discuss why not to follow greedy technique in this problem:\\n        \\n        1- Because if we follow greedy we might endup choosing the wrong path which rather\\n        \\n        giving us the minimum value will give us some another higher value\\n        \\n        for example if we take a grid \\n            \\n            1 2 6 4\\n            5 8 5 85\\n            1 3 2 1\\n            \\n            if we follow the greedy method and starting from 0,0 we will choose minimum of (2,5)\\n            since 2 will be the minimum we will move in the direction of 2\\n            as we can only move downwards and right\\n            \\n            and so on we will get the path like 1-> 2 -> 6 -> 4 -> 85 ->1 === 99\\n            \\n            but because of the greeedy nature we have missed the optimum path which gives us the minimum\\n            sum that is\\n            \\n            1-> 5 -> 1 -> 3 -> 2 -> 1 ==== 13 \\n            \\n            Therefore the greedy Technique fails here\\n        \\n        \"\"\"\\n        #-----------------------------------------------------------------------------------------#\\n        \"\"\"\\n        \\n        Time Complexity : O(m*n)\\n        Stack Space : O(m*n)+ O(path length)\\n        \\n        \\n### ___ Recursive Approach___\\n        # Now moving towards the recursive solution\\n        \\n        # which will gives us all the possible path from which we can find the min path (Exploring all paths)\\n        \"\"\"\\n        def f(i,j):\\n            \\n            if i==0 and j==0:\\n                return grid[0][0]\\n           \\n            # in case we have reached out of the boundry then we have to return the maximum value so that after the addition of that value the the path...then the path will never be our answer\\n            # because following that path we have reached out of boundry\\n            \\n            if i<0 or j<0:\\n                \\n                return sys.maxsize\\n            \\n            \\n            up=grid[i][j]+f(i-1,j)\\n            left = grid[i][j]+ f(i,j-1)\\n            \\n            \\n            return min(up,left)\\n        \\n        # return f(len(grid)-1,len(grid[0])-1)\\n        \\n        #-----------------------------------------------------------------------------------------#\\n### ___ Memoizing the Recursive Approach___   \\n        \"\"\"\\n        \\n        Now memoizing the recursive code:---->\\n        \\n        \\n        \"\"\"\\n        n=len(grid)\\n        m= len(grid[0])\\n        \\n        dp=[[-1]*m for i in range(n)]\\n        \\n        def f(i,j):\\n            \\n            if i==0 and j==0:\\n                return grid[0][0]\\n           \\n            # in case we have reached out of the boundry then we have to return the maximum value so that after the addition of that value the the path...then the path will never be our answer\\n            # because following that path we have reached out of boundry\\n            \\n            if i<0 or j<0:\\n                \\n                return sys.maxsize\\n            \\n            if dp[i][j]!=-1:\\n                return dp[i][j]\\n            \\n            up=grid[i][j]+f(i-1,j)\\n            left = grid[i][j]+ f(i,j-1)\\n            \\n            \\n            dp[i][j]=min(up,left)\\n            return dp[i][j]\\n        # return f(n-1,m-1)\\n        \\n        \\n        \\n        \\n        #-----------------------------------------------------------------------------------------#\\n        \\n### ___ Bottom-Up Approach___\\n        \"\"\"\\n        \\n        Now Converting  the memoized code into bottom up:---->\\n        \\n        \\n        \"\"\"\\n        \\n        dp=[[0]*m for i in range(n)]\\n        \\n        for i in range(n):\\n            for j in range(m):\\n                if i==0 and j==0:\\n                    dp[i][j]= grid[i][j]\\n                    \\n                else:\\n                    up=grid[i][j]\\n                    left=grid[i][j]\\n                    \\n                    if i>0:\\n                        up+= dp[i-1][j]\\n                    else:\\n                        up+=sys.maxsize\\n                    if j>0:\\n                        left+=dp[i][j-1]\\n                    else:\\n                        left+=sys.maxsize\\n                    \\n                    dp[i][j]= min(up,left)\\n                    \\n        return dp[n-1][m-1]\\n\\t\\n## Thankyou for visiting!! \\n### Please upvote the solution and share it with your friends :) <3",
                "codeTag": "Java"
            },
            {
                "id": 1145356,
                "title": "memoization",
                "content": "```\\nclass Solution \\n{\\n  public:\\n    int minPathSumHelper(vector<vector<int>> &grid,vector<vector<int>> &dp,int m, int n, int i, int j){\\n        //base case \\n        \\n        if(i==m-1 && j==n-1){\\n            return grid[i][j];\\n        }\\n        if(i>=m || j>=n){\\n            return INT_MAX; \\n        }\\n        if(dp[i][j]!=-1){\\n            return dp[i][j];\\n        }\\n        \\n        //recusrive call\\n        int x = minPathSumHelper(grid,dp,m,n,i+1,j);\\n        int y = minPathSumHelper(grid,dp,m,n,i,j+1);\\n        \\n        //small calculation for recursion\\n        int ans = min(x,y) + grid[i][j];\\n        dp[i][j] = ans;\\n        return ans;\\n    }\\n    int minPathSum(vector<vector<int>> &grid) {\\n        int m = grid.size();\\n        int n = grid[0].size();\\n        vector<vector<int>> dp(m, vector<int>(n,-1));\\n\\n       return minPathSumHelper(grid,dp,m,n,0,0);\\n    }\\n};",
                "solutionTags": [
                    "C++",
                    "C",
                    "Dynamic Programming",
                    "Memoization"
                ],
                "code": "class Solution \\n{\\n  public:\\n    int minPathSumHelper(vector<vector<int>> &grid,vector<vector<int>> &dp,int m, int n, int i, int j){\\n        //base case \\n        \\n        if(i==m-1 && j==n-1){\\n            return grid[i][j];\\n        }",
                "codeTag": "Java"
            },
            {
                "id": 644784,
                "title": "c-easy-to-understand-using-dp-with-explanation-must-see-for-beginners",
                "content": "Pls upvote if you find this helpful :))\\n```\\nclass Solution {\\npublic:\\n    int minPathSum(vector<vector<int>>& grid) {\\n```\\n        int row=grid.size();\\n        int column=grid[0].size();\\n        int sum=0;\\n        for(int i=0;i<column;i++) {\\t\\n\\t\\t\\tsum+=grid[0][i];                                      //Filling the first row ,only movement in right is possible here\\n            grid[0][i]=sum;\\n            }\\n        sum=0;\\n        for(int i=0;i<row;i++) {                                            \\n            sum+=grid[i][0];                                    //Filling the first column ,only movement in downward direction  \\n            grid[i][0]=sum;\\n            }\\n        for(int i=1;i<row;i++)\\n\\t\\t\\t{\\n            for(int j=1;j<column;j++)\\n\\t\\t\\t{                                                                            \\n            grid[i][j]=min(grid[i-1][j],grid[i][j-1])+grid[i][j];//Filling the remaining cells using the minimum value and adding to the current cell value   \\n            }\\n        }\\n        return grid[row-1][column-1];                  //Return the last grid\\n    }\\n};\\n",
                "solutionTags": [
                    "C++",
                    "C"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int minPathSum(vector<vector<int>>& grid) {\\n```",
                "codeTag": "Java"
            },
            {
                "id": 584871,
                "title": "very-easy-c-solution-without-using-space-explained",
                "content": "We can think of solving this problem recursively. We are standing at a current cell then the cost of reaching that cell is minimum of ( cost of reaching upper cell, cost of reaching the left cell ) + cost of current cell.\\n\\nSuppose we have a fiunction called getMinSum which return minimum cost to reach. Suppose We are at 2,2 then,\\ngetMinCost(2,2) = grid[2,2] + min(getMinCost(2,1), getMinCost(1,2));\\nRecursive Call, getMinCost(2,1) = grid[2,1] + min(getMinCost(2,0), getMinCost(1,1));\\nRecursive Call, getMinCost(2,0) = grid[2,0] + getMinCost(1,0);\\nRecursive Call, getMinCost(1,0) = grid[1,0] + getMinCost(0,0);\\nRecursive Call, getMinCost(1,0) = grid[0,0];\\nRecursive Call, getMinCost(1,1) = grid[1,1] + min(**getMinCost(1,0)**, getMinCost(0,1));\\nRecursive Call, getMinCost(0,1) = grid[0,1] + **getMinCost(0,0)** ;\\nRecursive Call, getMinCost(1,2) = grid[1,2] + min(**getMinCost(1,1)**, **getMinCost(0,2)**);\\n\\nNow as we can see direct recursive solution is making us to calculate the same cost of reaching a cell again and again(shown in bold above). For large matrix this can make the complexity of finding a solution to be exponential.\\n\\nWe need to store these results of subsolutions.\\n\\nFor the first row and column the path sum will only be the sum of the cells till that point as there is no other way to reach the other cells.\\n```\\ngrid[i][j] = grid[i][j] + min(grid[i-1][j], grid[i][j-1]);\\n```\\n\\n```\\nclass Solution {\\npublic:\\n    int minPathSum(vector<vector<int>>& grid) {\\n        int m = grid.size();\\n        if(m==0)    return 0;\\n        int n = grid[0].size();\\n        if(n==0)    return 0;\\n        for(int i=1; i<m; i++)\\n            grid[i][0] += grid[i-1][0];\\n        \\n        for(int i=1; i<n; i++)\\n            grid[0][i] += grid[0][i-1];\\n        for(int i=1; i<m; i++)\\n            for(int j=1; j<n; j++)\\n                grid[i][j] += min(grid[i-1][j], grid[i][j-1]);\\n            \\n        \\n        return grid[m-1][n-1];\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\ngrid[i][j] = grid[i][j] + min(grid[i-1][j], grid[i][j-1]);\\n```\n```\\nclass Solution {\\npublic:\\n    int minPathSum(vector<vector<int>>& grid) {\\n        int m = grid.size();\\n        if(m==0)    return 0;\\n        int n = grid[0].size();\\n        if(n==0)    return 0;\\n        for(int i=1; i<m; i++)\\n            grid[i][0] += grid[i-1][0];\\n        \\n        for(int i=1; i<n; i++)\\n            grid[0][i] += grid[0][i-1];\\n        for(int i=1; i<m; i++)\\n            for(int j=1; j<n; j++)\\n                grid[i][j] += min(grid[i-1][j], grid[i][j-1]);\\n            \\n        \\n        return grid[m-1][n-1];\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 23589,
                "title": "minimum-path-sum-how-can-i-reduce-the-memory",
                "content": "Here is the idea:\\n\\n 1. f[m][n] is a matrix store the min value of every location we can\\n    get.\\n 2. f[0][0] =grid[0][0], f[i][0]=f[i-1][0]+grid[i][0],\\n    f[0][j]=f[0][j-1]+grid[0][j]\\n 3. f[i][j]=min(f[i-1][j],f[i][j-1])+grid[i][j].\\n 4. at last return the f[m-1][n-1]\\n\\n----------\\n\\n\\n    class Solution {\\n            public:\\n                int minPathSum(vector<vector<int> > &grid) {\\n                    // IMPORTANT: Please reset any member data you declared, as\\n                    // the same Solution instance will be reused for each test case.\\n                    int m=grid.size();\\n                    int n=grid[0].size();\\n                    int** f;\\n                    f=new int*[m];\\n                    for(int i=0;i<m;i){\\n                        f[i]=new int[n];\\n                    }\\n                    f[0][0]=grid[0][0];\\n                    for(int i=1;i<m;i++){\\n                        f[i][0]=f[i-1][0]+grid[i][0];\\n                    }\\n                    for(int i=1;i<n;i++){\\n                        f[0][i]=f[0][i-1]+grid[0][i];\\n                    }\\n                    for(int i=1;i<m;i++){\\n                        for(int j=1;j<n;j++)\\n                            f[i][j]=min(f[i-1][j],f[i][j-1])+grid[i][j];\\n                    }\\n                    return f[m-1][n-1];\\n                }\\n                int min(int a,int b){\\n                    if(a>b)\\n                        return b;\\n                    else\\n                        return a;\\n                }\\n            };",
                "solutionTags": [],
                "code": "class Solution {\\n            public:\\n                int minPathSum(vector<vector<int> > &grid) {\\n                    // IMPORTANT: Please reset any member data you declared, as\\n                    // the same Solution instance will be reused for each test case.\\n                    int m=grid.size();\\n                    int n=grid[0].size();\\n                    int** f;\\n                    f=new int*[m];\\n                    for(int i=0;i<m;i){\\n                        f[i]=new int[n];\\n                    }",
                "codeTag": "Java"
            },
            {
                "id": 3347989,
                "title": "c-easy-dp-solution",
                "content": "# Code\\n```\\nclass Solution {\\npublic:\\n    int minPathSum(vector<vector<int>>& g) {\\n        int n=g.size();\\n        int m=g[0].size();\\n        vector<vector<int>>dp(n+1,vector<int>(m+1,0));\\n        for(int i=1;i<=n;i++){\\n         dp[i][1] =g[i-1][0] + dp[i-1][1];\\n        }\\n        for(int j=1;j<=m;j++){\\n         dp[1][j] = g[0][j-1] + dp[1][j-1];   \\n        }\\n        for(int i=2;i<=n;i++){\\n            for(int j=2;j<=m;j++){\\n                dp[i][j] = g[i-1][j-1] + min(dp[i-1][j] , dp[i][j-1]);\\n            }\\n        }\\n        return dp[n][m];\\n    }\\n};\\n```\\n![upvote (3).jpg](https://assets.leetcode.com/users/images/38a2afd8-6fc2-4079-bb12-4e653512ffed_1679927263.2603066.jpeg)\\n",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int minPathSum(vector<vector<int>>& g) {\\n        int n=g.size();\\n        int m=g[0].size();\\n        vector<vector<int>>dp(n+1,vector<int>(m+1,0));\\n        for(int i=1;i<=n;i++){\\n         dp[i][1] =g[i-1][0] + dp[i-1][1];\\n        }\\n        for(int j=1;j<=m;j++){\\n         dp[1][j] = g[0][j-1] + dp[1][j-1];   \\n        }\\n        for(int i=2;i<=n;i++){\\n            for(int j=2;j<=m;j++){\\n                dp[i][j] = g[i-1][j-1] + min(dp[i-1][j] , dp[i][j-1]);\\n            }\\n        }\\n        return dp[n][m];\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3346108,
                "title": "day-86-dp-o-1-space-easiest-beginner-friendly-sol",
                "content": "**NOTE - PLEASE READ INTUITION AND APPROACH FIRST THEN SEE THE CODE. YOU WILL DEFINITELY UNDERSTAND THE CODE LINE BY LINE AFTER SEEING THE APPROACH.**\\n\\n# Intuition of this Problem :\\nThe intuition behind the approach is that, in order to find the minimum path sum from the top left corner to the bottom right corner of the grid, we can consider the subproblems of finding the minimum path sum to reach each cell of the grid. We can then use the solutions to these subproblems to solve the original problem.\\n\\nTo calculate the minimum path sum to reach a cell (i, j), we can take the minimum of the minimum path sum to reach the cell above (i-1, j) and the cell to the left (i, j-1), and add it to the value of the current cell. This is because we can only move either down or right, so the minimum path sum to reach the current cell is the minimum of the minimum path sum to reach the cell above and the cell to the left, plus the value of the current cell.\\n\\nWe can use this approach to calculate the minimum path sum to reach each cell of the grid, starting from the top left corner and working our way down and to the right. By the time we reach the bottom right corner, the minimum path sum to reach that cell will be the solution to the original problem.\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach for this Problem :\\n1. Initialize variables row and col to the number of rows and columns of the grid, respectively.\\n2. Traverse the first row of the grid and set each element to be the cumulative sum of the previous elements in the row.\\n3. Traverse the first column of the grid and set each element to be the cumulative sum of the previous elements in the column.\\n4. Traverse the remaining cells of the grid using two nested loops, starting from the second row and second column.\\n5. For each cell (i, j), set the value of the cell to be the sum of the current cell\\'s value and the minimum of the values of the cells above (i-1, j) and to the left (i, j-1).\\n6. After traversing all cells, the minimum sum of all numbers along the path from top left to bottom right of the grid is stored in the bottom right cell (i.e., grid[row-1][col-1]).\\n7. Return the value of the bottom right cell as the output.\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Code :\\n```C++ []\\nclass Solution {\\npublic:\\n    int minPathSum(vector<vector<int>>& grid) {\\n        //we will modify the same array and return the last index grid[row-1][col-1]\\n        int row = grid.size();\\n        int col = grid[0].size();\\n        for (int i = 1; i < row; i++) {\\n            grid[i][0] += grid[i-1][0];\\n        }\\n        for (int j = 1; j < col; j++) {\\n            grid[0][j] += grid[0][j-1];\\n        }\\n        for (int i = 1; i < row; i++) {\\n            for (int j = 1; j < col; j++) {\\n                grid[i][j] = grid[i][j] + min(grid[i-1][j], grid[i][j-1]);\\n            }\\n        }\\n        return grid[row-1][col-1];\\n    }\\n};\\n```\\n```Java []\\nclass Solution {\\n    public int minPathSum(int[][] grid) {\\n        int row = grid.length;\\n        int col = grid[0].length;\\n        for (int i = 1; i < row; i++) {\\n            grid[i][0] += grid[i-1][0];\\n        }\\n        for (int j = 1; j < col; j++) {\\n            grid[0][j] += grid[0][j-1];\\n        }\\n        for (int i = 1; i < row; i++) {\\n            for (int j = 1; j < col; j++) {\\n                grid[i][j] = grid[i][j] + Math.min(grid[i-1][j], grid[i][j-1]);\\n            }\\n        }\\n        return grid[row-1][col-1];\\n    }\\n}\\n\\n```\\n```Python []\\nclass Solution:\\n    def minPathSum(self, grid: List[List[int]]) -> int:\\n        row = len(grid)\\n        col = len(grid[0])\\n        for i in range(1, row):\\n            grid[i][0] += grid[i-1][0]\\n        for j in range(1, col):\\n            grid[0][j] += grid[0][j-1]\\n        for i in range(1, row):\\n            for j in range(1, col):\\n                grid[i][j] += min(grid[i-1][j], grid[i][j-1])\\n        return grid[row-1][col-1]\\n\\n```\\n\\n# Time Complexity and Space Complexity:\\n- Time complexity : **O(mn)**, where m is number of rows and n is number of column\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity : **O(1)**\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->",
                "solutionTags": [
                    "C++",
                    "Java",
                    "Python3",
                    "Dynamic Programming",
                    "Matrix"
                ],
                "code": "```C++ []\\nclass Solution {\\npublic:\\n    int minPathSum(vector<vector<int>>& grid) {\\n        //we will modify the same array and return the last index grid[row-1][col-1]\\n        int row = grid.size();\\n        int col = grid[0].size();\\n        for (int i = 1; i < row; i++) {\\n            grid[i][0] += grid[i-1][0];\\n        }\\n        for (int j = 1; j < col; j++) {\\n            grid[0][j] += grid[0][j-1];\\n        }\\n        for (int i = 1; i < row; i++) {\\n            for (int j = 1; j < col; j++) {\\n                grid[i][j] = grid[i][j] + min(grid[i-1][j], grid[i][j-1]);\\n            }\\n        }\\n        return grid[row-1][col-1];\\n    }\\n};\\n```\n```Java []\\nclass Solution {\\n    public int minPathSum(int[][] grid) {\\n        int row = grid.length;\\n        int col = grid[0].length;\\n        for (int i = 1; i < row; i++) {\\n            grid[i][0] += grid[i-1][0];\\n        }\\n        for (int j = 1; j < col; j++) {\\n            grid[0][j] += grid[0][j-1];\\n        }\\n        for (int i = 1; i < row; i++) {\\n            for (int j = 1; j < col; j++) {\\n                grid[i][j] = grid[i][j] + Math.min(grid[i-1][j], grid[i][j-1]);\\n            }\\n        }\\n        return grid[row-1][col-1];\\n    }\\n}\\n\\n```\n```Python []\\nclass Solution:\\n    def minPathSum(self, grid: List[List[int]]) -> int:\\n        row = len(grid)\\n        col = len(grid[0])\\n        for i in range(1, row):\\n            grid[i][0] += grid[i-1][0]\\n        for j in range(1, col):\\n            grid[0][j] += grid[0][j-1]\\n        for i in range(1, row):\\n            for j in range(1, col):\\n                grid[i][j] += min(grid[i-1][j], grid[i][j-1])\\n        return grid[row-1][col-1]\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2677369,
                "title": "recursion-to-space-optimized-in-java",
                "content": "**upvote if it helped, feeel free to ask queries**\\n`IDEA : ALWAYS REMEMBER WHENEVER YOU FEEL LIKE THERE IS A NEED TO FIND ALL POSSIBLE WAYS, THERE\\'S A RECURSION(which can further be improved).`\\n**the state equation is S[i][j] = min(S[i - 1][j], S[i][j - 1]) + grid[i][j]**\\n\\nhere, to get a path, we need to travel from grid[0][0] to grid[row - 1][col - 1]. So let\\'s set grid[0][0] as the basic case. This is when we jump out of recursion. On the other hand, grid[row - 1][col - 1] would be the starting point.  we need to consider that things could happen that we reached the first row or column and we gotta make sure that we stay within the array index limit.\\nWe will move in grid for every row and column, looking for minimum path sum\\n\\n**Recursion**\\n------------------------------------------time complexity in exponential----------\\n```\\npublic static int minPathSum(int[][] grid) {\\n\\n            int m = grid.length;\\n            int n = grid[0].length;\\n            return min(grid, m - 1, n - 1);\\n\\t\\t\\t\\n        }\\n\\t\\t\\npublic static int min(int[][]grid, int m, int n){\\n\\n// this is the exit of the recursion\\n            if(m == 0 && n == 0) return grid[m][n]; \\n/** when we reach the first row, we could only move horizontally.*/\\n            if(m == 0) return grid[m][n] + min(grid, m, n - 1); \\n/** when we reach the first column, we could only move vertically.*/\\n            if(n == 0) return grid[m][n] + min(grid, m - 1, n); \\n/** we want the min sum path so we pick the cell with the less value */\\n            return grid[m][n] + Math.min(min(grid, m - 1, n), min(grid, m, n - 1)); \\n\\t\\t\\t\\n}\\n```\\n\\n**Memoization:**\\n*simply memoization to handle the recursion*\\n----------------------100% faster-----------------------1ms---------------------------\\n```\\nclass Solution {\\n    static int[][] memo;\\n    public int minPathSum(int[][] grid) {\\n        int m = grid.length;\\n        int n = grid[0].length;\\n        memo = new int[m][n];\\n        return find(grid, m-1, n-1, memo);\\n    }\\n    \\n    private int find(int[][] grid, int m, int n, int[][] memo){\\n        if(m==0 && n==0)\\n            return grid[0][0];\\n        else if(m<0 || n<0)\\n            return Integer.MAX_VALUE;\\n        else if(memo[m][n]!=0)\\n           return memo[m][n];\\n        return memo[m][n] = grid[m][n] + Math.min(find(grid, m-1, n, memo), find(grid, m, n-1, memo));\\n    }\\n}\\n```\\n**Tabulation:**\\n*now properly using pre-calculated values to enhance the performance*\\n-------------------------------------------------with 2-d array-----------\\n```\\nclass Solution {\\n    public int minPathSum(int[][] grid) {\\n        int m = grid.length;\\n        int n = grid[0].length;\\n        int[][] dp = new int[m][n];\\n        dp[0][0] = grid[0][0];\\n        for(int i=1;i<m;i++)\\n            dp[i][0] = dp[i-1][0] + grid[i][0];\\n        for(int j=1;j<n;j++)\\n            dp[0][j] = dp[0][j-1] + grid[0][j];\\n        for(int i=1;i<m;i++){\\n            for(int j=1;j<n;j++){\\n                dp[i][j] = Math.min(dp[i-1][j], dp[i][j-1]) + grid[i][j];\\n            }\\n        }\\n        return dp[m-1][n-1];\\n    }\\n}\\n```\\n\\n**always remember** \\n*if tabulation approach contains something like (i+1) or(i-1), that means u can always space optimized it\\ni+1 or i-1 means we are using last calculated results, which we can store in the input array itself too, and very easily*\\n\\n------------------------------------------------------space optimized----------------\\n```\\nclass Solution {\\n    public int minPathSum(int[][] grid) {\\n        int m = grid.length;\\n        int n = grid[0].length;\\n        for(int i=1;i<m;i++)\\n            grid[i][0] += grid[i-1][0];\\n        for(int j=1;j<n;j++)\\n            grid[0][j] += grid[0][j-1];\\n        for(int i=1;i<m;i++){\\n            for(int j=1;j<n;j++){\\n                grid[i][j] += Math.min(grid[i-1][j], grid[i][j-1]);\\n            }\\n        }\\n        return grid[m-1][n-1];\\n    }\\n}\\n```\\n\\n**upvote if u learned something**\\n\\n\\n![image.png](https://assets.leetcode.com/users/images/18dc01d9-d41f-40db-9b5a-1988158c2a07_1679893506.8129675.png)\\n",
                "solutionTags": [
                    "Java",
                    "Dynamic Programming"
                ],
                "code": "```\\npublic static int minPathSum(int[][] grid) {\\n\\n            int m = grid.length;\\n            int n = grid[0].length;\\n            return min(grid, m - 1, n - 1);\\n\\t\\t\\t\\n        }\\n\\t\\t\\npublic static int min(int[][]grid, int m, int n){\\n\\n// this is the exit of the recursion\\n            if(m == 0 && n == 0) return grid[m][n]; \\n/** when we reach the first row, we could only move horizontally.*/\\n            if(m == 0) return grid[m][n] + min(grid, m, n - 1); \\n/** when we reach the first column, we could only move vertically.*/\\n            if(n == 0) return grid[m][n] + min(grid, m - 1, n); \\n/** we want the min sum path so we pick the cell with the less value */\\n            return grid[m][n] + Math.min(min(grid, m - 1, n), min(grid, m, n - 1)); \\n\\t\\t\\t\\n}\\n```\n```\\nclass Solution {\\n    static int[][] memo;\\n    public int minPathSum(int[][] grid) {\\n        int m = grid.length;\\n        int n = grid[0].length;\\n        memo = new int[m][n];\\n        return find(grid, m-1, n-1, memo);\\n    }\\n    \\n    private int find(int[][] grid, int m, int n, int[][] memo){\\n        if(m==0 && n==0)\\n            return grid[0][0];\\n        else if(m<0 || n<0)\\n            return Integer.MAX_VALUE;\\n        else if(memo[m][n]!=0)\\n           return memo[m][n];\\n        return memo[m][n] = grid[m][n] + Math.min(find(grid, m-1, n, memo), find(grid, m, n-1, memo));\\n    }\\n}\\n```\n```\\nclass Solution {\\n    public int minPathSum(int[][] grid) {\\n        int m = grid.length;\\n        int n = grid[0].length;\\n        int[][] dp = new int[m][n];\\n        dp[0][0] = grid[0][0];\\n        for(int i=1;i<m;i++)\\n            dp[i][0] = dp[i-1][0] + grid[i][0];\\n        for(int j=1;j<n;j++)\\n            dp[0][j] = dp[0][j-1] + grid[0][j];\\n        for(int i=1;i<m;i++){\\n            for(int j=1;j<n;j++){\\n                dp[i][j] = Math.min(dp[i-1][j], dp[i][j-1]) + grid[i][j];\\n            }\\n        }\\n        return dp[m-1][n-1];\\n    }\\n}\\n```\n```\\nclass Solution {\\n    public int minPathSum(int[][] grid) {\\n        int m = grid.length;\\n        int n = grid[0].length;\\n        for(int i=1;i<m;i++)\\n            grid[i][0] += grid[i-1][0];\\n        for(int j=1;j<n;j++)\\n            grid[0][j] += grid[0][j-1];\\n        for(int i=1;i<m;i++){\\n            for(int j=1;j<n;j++){\\n                grid[i][j] += Math.min(grid[i-1][j], grid[i][j-1]);\\n            }\\n        }\\n        return grid[m-1][n-1];\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2054796,
                "title": "simple-understandable-c-code-dp-recursive-iterative",
                "content": "Recursion+Memoization\\n```\\nclass Solution {\\npublic:\\n    int m, n;\\n    vector<vector<int>> dp;\\n    int fun(int x, int y, vector<vector<int>>& grid){\\n        if(dp[x][y]!=-1) return dp[x][y];\\n        int ans = grid[x][y];\\n        if(x==m && y<n) ans += fun(x, y+1, grid);\\n        else if(x<m && y==n) ans += fun(x+1, y, grid);\\n        else if(x<m && y<n) ans += min (fun(x+1, y, grid), fun(x, y+1, grid));\\n        return dp[x][y] = ans;\\n    }\\n    int minPathSum(vector<vector<int>>& grid) {\\n        m = grid.size()-1, n = grid[0].size()-1;\\n        dp.resize(m+1, vector<int>(n+1, -1));\\n        return fun(0, 0, grid);\\n    }\\n};\\n```\\n\\n\\nIterative Approach\\n```\\nclass Solution {\\npublic:\\n    \\n    int minPathSum(vector<vector<int>>& grid) {\\n        int m = grid.size(), n = grid[0].size();\\n        vector<vector<int>> dp(m, vector<int>(n));\\n        for(int i=0;i<m;i++){\\n            for(int j=0;j<n;j++){\\n                dp[i][j] = grid[i][j];\\n                if(i>0 && j>0) dp[i][j] += min(dp[i-1][j], dp[i][j-1]);\\n                else if(i>0) dp[i][j] += dp[i-1][j];\\n                else if(j>0) dp[i][j] += dp[i][j-1];\\n            }\\n        }\\n        return dp[m-1][n-1];\\n    }\\n};\\n```",
                "solutionTags": [
                    "C",
                    "Dynamic Programming",
                    "Depth-First Search",
                    "Memoization"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int m, n;\\n    vector<vector<int>> dp;\\n    int fun(int x, int y, vector<vector<int>>& grid){\\n        if(dp[x][y]!=-1) return dp[x][y];\\n        int ans = grid[x][y];\\n        if(x==m && y<n) ans += fun(x, y+1, grid);\\n        else if(x<m && y==n) ans += fun(x+1, y, grid);\\n        else if(x<m && y<n) ans += min (fun(x+1, y, grid), fun(x, y+1, grid));\\n        return dp[x][y] = ans;\\n    }\\n    int minPathSum(vector<vector<int>>& grid) {\\n        m = grid.size()-1, n = grid[0].size()-1;\\n        dp.resize(m+1, vector<int>(n+1, -1));\\n        return fun(0, 0, grid);\\n    }\\n};\\n```\n```\\nclass Solution {\\npublic:\\n    \\n    int minPathSum(vector<vector<int>>& grid) {\\n        int m = grid.size(), n = grid[0].size();\\n        vector<vector<int>> dp(m, vector<int>(n));\\n        for(int i=0;i<m;i++){\\n            for(int j=0;j<n;j++){\\n                dp[i][j] = grid[i][j];\\n                if(i>0 && j>0) dp[i][j] += min(dp[i-1][j], dp[i][j-1]);\\n                else if(i>0) dp[i][j] += dp[i-1][j];\\n                else if(j>0) dp[i][j] += dp[i][j-1];\\n            }\\n        }\\n        return dp[m-1][n-1];\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1915672,
                "title": "100-fastest-swift-solution-time-o-n-m-space-o-m",
                "content": "```\\nclass Solution {\\n    // - Complexity:\\n    //   - time: O(n * m), where n is the number of rows in the grid, and m is the number of columns in the grid.\\n    //   - space: O(m), where m is the number of columns in the grid.\\n\\n    func minPathSum(_ grid: [[Int]]) -> Int {\\n        var matrix: [[Int]] = grid\\n        let n = grid.count - 1\\n        let m = grid[0].count - 1\\n        \\n        for i in 0...n {\\n            for j in 0...m {\\n                var step = matrix[i][j]\\n        \\n                if i > 0 && j > 0 {\\n                    step += min(matrix[i - 1][j], matrix[i][j - 1])\\n                } else if i > 0 && j == 0 {\\n                    step += matrix[i - 1][j]\\n                } else if j > 0 && i == 0 {\\n                    step += matrix[i][j - 1]\\n                }\\n                \\n                matrix[i][j] = step\\n            }\\n        }\\n        \\n        return matrix[n][m]\\n    }\\n\\n}\\n```\\n\\nLet me know in comments if you have any doubts. I will be happy to answer.\\n\\nPlease upvote if you found the solution useful.",
                "solutionTags": [
                    "Swift"
                ],
                "code": "```\\nclass Solution {\\n    // - Complexity:\\n    //   - time: O(n * m), where n is the number of rows in the grid, and m is the number of columns in the grid.\\n    //   - space: O(m), where m is the number of columns in the grid.\\n\\n    func minPathSum(_ grid: [[Int]]) -> Int {\\n        var matrix: [[Int]] = grid\\n        let n = grid.count - 1\\n        let m = grid[0].count - 1\\n        \\n        for i in 0...n {\\n            for j in 0...m {\\n                var step = matrix[i][j]\\n        \\n                if i > 0 && j > 0 {\\n                    step += min(matrix[i - 1][j], matrix[i][j - 1])\\n                } else if i > 0 && j == 0 {\\n                    step += matrix[i - 1][j]\\n                } else if j > 0 && i == 0 {\\n                    step += matrix[i][j - 1]\\n                }\\n                \\n                matrix[i][j] = step\\n            }\\n        }\\n        \\n        return matrix[n][m]\\n    }\\n\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 554297,
                "title": "python-in-place-dp-with-explanatory-comments-92ms-or-faster-than-97",
                "content": "```\\nclass Solution:\\n    def minPathSum(self, grid: List[List[int]]) -> int:\\n        \\n        # get dimensions\\n        n = len(grid) # no of cells in each col\\n        m = len(grid[0]) # no of cells in each row\\n        \\n        # populate first row using m for no of cells in row\\n        for i in range(1,m):\\n            grid[0][i] = grid[0][i] + grid[0][i-1]\\n        \\n        # populate first col using n for no of cells in col\\n        for j in range(1,n):\\n            grid[j][0] = grid[j-1][0] + grid[j][0]\\n        \\n        # populate the rest\\n        for i in range(1,n):\\n            for j in range(1,m):\\n\\t\\t\\t\\t# get min seen so far plus curr cell value\\n                grid[i][j] = min(grid[i-1][j],grid[i][j-1]) + grid[i][j]\\n        \\n        # return last cell\\n        return grid[-1][-1]\\n            \\n```\\n",
                "solutionTags": [
                    "Python",
                    "Python3",
                    "Dynamic Programming"
                ],
                "code": "```\\nclass Solution:\\n    def minPathSum(self, grid: List[List[int]]) -> int:\\n        \\n        # get dimensions\\n        n = len(grid) # no of cells in each col\\n        m = len(grid[0]) # no of cells in each row\\n        \\n        # populate first row using m for no of cells in row\\n        for i in range(1,m):\\n            grid[0][i] = grid[0][i] + grid[0][i-1]\\n        \\n        # populate first col using n for no of cells in col\\n        for j in range(1,n):\\n            grid[j][0] = grid[j-1][0] + grid[j][0]\\n        \\n        # populate the rest\\n        for i in range(1,n):\\n            for j in range(1,m):\\n\\t\\t\\t\\t# get min seen so far plus curr cell value\\n                grid[i][j] = min(grid[i-1][j],grid[i][j-1]) + grid[i][j]\\n        \\n        # return last cell\\n        return grid[-1][-1]\\n            \\n```",
                "codeTag": "Java"
            },
            {
                "id": 23617,
                "title": "c-solution-beat-98-59",
                "content": "    int minPathSum(vector<vector<int>>& grid) {\\n        if(grid.empty())\\n            return 0;\\n        \\n        vector<int> res(grid[0].size(),INT_MAX);\\n        res[0] = 0;\\n        \\n        for(int i=0;i<grid.size();i++)\\n            for(int j=0;j<grid[0].size();j++)\\n                if(j > 0)\\n                    res[j] = min(res[j-1],res[j]) + grid[i][j];\\n                else\\n                    res[j] = res[j] + grid[i][j];\\n        \\n        return res[grid[0].size()-1];\\n    }",
                "solutionTags": [],
                "code": "    int minPathSum(vector<vector<int>>& grid) {\\n        if(grid.empty())\\n            return 0;\\n        \\n        vector<int> res(grid[0].size(),INT_MAX);\\n        res[0] = 0;\\n        \\n        for(int i=0;i<grid.size();i++)\\n            for(int j=0;j<grid[0].size();j++)\\n                if(j > 0)\\n                    res[j] = min(res[j-1],res[j]) + grid[i][j];\\n                else\\n                    res[j] = res[j] + grid[i][j];\\n        \\n        return res[grid[0].size()-1];\\n    }",
                "codeTag": "Unknown"
            },
            {
                "id": 23611,
                "title": "my-java-clean-code-dp-no-extra-space",
                "content": "\\n    public int minPathSum(int[][] grid) {\\n        if(grid.length == 0 || grid[0].length == 0)\\n            return 0;\\n        for(int i = 0; i < grid.length; i++){\\n            for(int j = 0; j < grid[0].length; j++){\\n                if(i == 0 && j == 0) continue;\\n                if(i == 0) grid[i][j] += grid[i][j - 1];\\n                else if(j == 0) grid[i][j] += grid[i - 1][j];\\n                else grid[i][j] += Math.min(grid[i - 1][j], grid[i][j - 1]);\\n            }\\n        }\\n        return grid[grid.length - 1][grid[0].length - 1];\\n        \\n    }",
                "solutionTags": [],
                "code": "\\n    public int minPathSum(int[][] grid) {\\n        if(grid.length == 0 || grid[0].length == 0)\\n            return 0;\\n        for(int i = 0; i < grid.length; i++){\\n            for(int j = 0; j < grid[0].length; j++){\\n                if(i == 0 && j == 0) continue;\\n                if(i == 0) grid[i][j] += grid[i][j - 1];\\n                else if(j == 0) grid[i][j] += grid[i - 1][j];\\n                else grid[i][j] += Math.min(grid[i - 1][j], grid[i][j - 1]);\\n            }\\n        }\\n        return grid[grid.length - 1][grid[0].length - 1];\\n        \\n    }",
                "codeTag": "Unknown"
            },
            {
                "id": 3225715,
                "title": "dynamic-programming-finding-the-minimum-path-sum-in-a-grid",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\nThe problem asks to find the minimum sum of a path from the top-left corner to the bottom-right corner of a grid. Since we are only allowed to move right and down, the possible paths we can take are limited. Hence, we can use dynamic programming to solve this problem.\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\nWe can create a 2D array `dp` that stores the minimum sum of a path from the top-left corner to the current cell (i, j). We can initialize `dp[0][0]` as the first element of the grid. We can then populate the first row and column of the `dp` array by adding the current element of the grid to the previous element in the row/column.\\n\\nAfter initializing the first row and column, we can iterate through the rest of the `dp` array and calculate the minimum sum of the path to the current cell (i, j). We can calculate this by taking the minimum of the previous minimum path sum of the cell above (i-1, j) and the cell to the left (i, j-1). We then add the current element of the grid to the minimum sum.\\n\\nThe minimum sum of the path from the top-left corner to the bottom-right corner of the grid will be stored in `dp[m-1][n-1]`, where `m` and `n` are the dimensions of the grid.\\n# Complexity\\n- Time complexity: $$O(mn)$$, where m and n are the dimensions of the grid. We iterate through each cell in the `dp` array exactly once.\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: $$O(mn)$$, where m and n are the dimensions of the grid. We create a 2D array of size m x n to store the minimum path sum to each cell.\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution:\\n    def minPathSum(self, grid: List[List[int]]) -> int:\\n        m, n = len(grid), len(grid[0])\\n        dp = [[0] * n for _ in range(m)]\\n        dp[0][0] = grid[0][0]\\n        for i in range(1, m):\\n            dp[i][0] = dp[i-1][0] + grid[i][0]\\n        for j in range(1, n):\\n            dp[0][j] = dp[0][j-1] + grid[0][j]\\n        for i in range(1, m):\\n            for j in range(1, n):\\n                dp[i][j] = min(dp[i-1][j], dp[i][j-1]) + grid[i][j]\\n        return dp[m-1][n-1]\\n```",
                "solutionTags": [
                    "Python3",
                    "Array",
                    "Dynamic Programming",
                    "Matrix"
                ],
                "code": "```\\nclass Solution:\\n    def minPathSum(self, grid: List[List[int]]) -> int:\\n        m, n = len(grid), len(grid[0])\\n        dp = [[0] * n for _ in range(m)]\\n        dp[0][0] = grid[0][0]\\n        for i in range(1, m):\\n            dp[i][0] = dp[i-1][0] + grid[i][0]\\n        for j in range(1, n):\\n            dp[0][j] = dp[0][j-1] + grid[0][j]\\n        for i in range(1, m):\\n            for j in range(1, n):\\n                dp[i][j] = min(dp[i-1][j], dp[i][j-1]) + grid[i][j]\\n        return dp[m-1][n-1]\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2949291,
                "title": "simple-java-solution-with-tabulation-100-beat",
                "content": "\\n```\\nclass Solution {\\n    public int minPathSum(int[][] grid) {\\n    if(grid.length == 0) return 0;\\n    int row = grid.length;\\n    int col = grid[0].length;\\n    \\n    for(int i=0;i<row; i++) {\\n        for(int j=0; j<col; j++) {\\n            int leftSum = (j>0) ? grid[i][j-1] : Integer.MAX_VALUE;\\n            int topSum = (i>0) ? grid[i-1][j] : Integer.MAX_VALUE;\\n            if(i==0 && j==0) continue;\\n            \\n            grid[i][j] += Math.min(leftSum, topSum);\\n        }\\n    }\\n    return grid[row-1][col-1];\\n }\\n}\\n        \\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int minPathSum(int[][] grid) {\\n    if(grid.length == 0) return 0;\\n    int row = grid.length;\\n    int col = grid[0].length;\\n    \\n    for(int i=0;i<row; i++) {\\n        for(int j=0; j<col; j++) {\\n            int leftSum = (j>0) ? grid[i][j-1] : Integer.MAX_VALUE;\\n            int topSum = (i>0) ? grid[i-1][j] : Integer.MAX_VALUE;\\n            if(i==0 && j==0) continue;\\n            \\n            grid[i][j] += Math.min(leftSum, topSum);\\n        }\\n    }\\n    return grid[row-1][col-1];\\n }\\n}\\n        \\n```",
                "codeTag": "Java"
            },
            {
                "id": 2323556,
                "title": "java-recursive-memoization-tabulization",
                "content": "```\\n**RECURSIVE APPROACH **\\n(gives TLE)\\n\\nclass Solution {\\n    public int minPathSum(int[][] grid) {\\n        int n = grid.length;\\n        int m = grid[0].length;\\n        \\n        return minPathSum(0,0,n,m,grid);\\n    }\\n    \\n    public int minPathSum(int i, int j, int n, int m, int[][] grid){\\n        if(i >= n || j >=m)\\n            return Integer.MAX_VALUE;\\n        if(i == n-1 && j == m-1)\\n            return grid[i][j];\\n        \\n        return grid[i][j] + Math.min(minPathSum(i+1, j, n, m,grid), minPathSum(i, j+1, n,m,grid));\\n    }\\n}\\n```\\n**Memoization**\\n***ACCEPTED***\\n```\\npublic int minPathSum(int[][] grid) {\\n        int n = grid.length;\\n        int m = grid[0].length;\\n        int[][] memo = new int[n+1][m+1];\\n        for(int[] num : memo)\\n            Arrays.fill(num, -1);\\n        return minPathSum(0,0,n,m,grid, memo);\\n    }\\n    \\n    public int minPathSum(int i, int j, int n, int m, int[][] grid, int[][] memo){\\n        if(i >= n || j >=m)\\n            return Integer.MAX_VALUE;\\n        \\n        if(i == n-1 && j == m-1)\\n            return grid[i][j];\\n        if(memo[i][j] != -1)\\n            return memo[i][j];\\n        return memo[i][j] = grid[i][j] + Math.min(minPathSum(i+1, j, n, m,grid, memo), minPathSum(i, j+1, n,m,grid,memo));\\n    }\\n```\\n**Tabulization**\\n```\\nclass Solution {\\n    public int minPathSum(int[][] grid) {\\n        for(int i = 0; i<grid.length; i++){\\n            for(int j = 0; j<grid[0].length; j++){ \\n                if(i == 0 && j == 0)\\n                    grid[i][j] = grid[i][j];\\n \\n                else if(i == 0 && j != 0){\\n                    grid[i][j] = grid[i][j] + grid[i][j-1];\\n                }\\n                else if(i!= 0 && j == 0)\\n                    grid[i][j] = grid[i][j] + grid[i-1][j];\\n                else\\n                    grid[i][j] = grid[i][j] + Math.min(grid[i][j-1], grid[i-1][j]);\\n            }\\n        }\\n        return grid[grid.length-1][grid[0].length-1];\\n    }\\n}\\n```\\n```",
                "solutionTags": [
                    "Java",
                    "Dynamic Programming",
                    "Recursion",
                    "Memoization"
                ],
                "code": "```\\n**RECURSIVE APPROACH **\\n(gives TLE)\\n\\nclass Solution {\\n    public int minPathSum(int[][] grid) {\\n        int n = grid.length;\\n        int m = grid[0].length;\\n        \\n        return minPathSum(0,0,n,m,grid);\\n    }\\n    \\n    public int minPathSum(int i, int j, int n, int m, int[][] grid){\\n        if(i >= n || j >=m)\\n            return Integer.MAX_VALUE;\\n        if(i == n-1 && j == m-1)\\n            return grid[i][j];\\n        \\n        return grid[i][j] + Math.min(minPathSum(i+1, j, n, m,grid), minPathSum(i, j+1, n,m,grid));\\n    }\\n}\\n```\n```\\npublic int minPathSum(int[][] grid) {\\n        int n = grid.length;\\n        int m = grid[0].length;\\n        int[][] memo = new int[n+1][m+1];\\n        for(int[] num : memo)\\n            Arrays.fill(num, -1);\\n        return minPathSum(0,0,n,m,grid, memo);\\n    }\\n    \\n    public int minPathSum(int i, int j, int n, int m, int[][] grid, int[][] memo){\\n        if(i >= n || j >=m)\\n            return Integer.MAX_VALUE;\\n        \\n        if(i == n-1 && j == m-1)\\n            return grid[i][j];\\n        if(memo[i][j] != -1)\\n            return memo[i][j];\\n        return memo[i][j] = grid[i][j] + Math.min(minPathSum(i+1, j, n, m,grid, memo), minPathSum(i, j+1, n,m,grid,memo));\\n    }\\n```\n```\\nclass Solution {\\n    public int minPathSum(int[][] grid) {\\n        for(int i = 0; i<grid.length; i++){\\n            for(int j = 0; j<grid[0].length; j++){ \\n                if(i == 0 && j == 0)\\n                    grid[i][j] = grid[i][j];\\n \\n                else if(i == 0 && j != 0){\\n                    grid[i][j] = grid[i][j] + grid[i][j-1];\\n                }\\n                else if(i!= 0 && j == 0)\\n                    grid[i][j] = grid[i][j] + grid[i-1][j];\\n                else\\n                    grid[i][j] = grid[i][j] + Math.min(grid[i][j-1], grid[i-1][j]);\\n            }\\n        }\\n        return grid[grid.length-1][grid[0].length-1];\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 998855,
                "title": "backtracking-recursive-dp-java-solution-explained",
                "content": "**1. Backtracking**\\n\\tBacktracking template is Goal, Search Space & Constraint.\\n\\t\\n\\t```\\n\\t\\tpublic void backTracking() {\\n\\t\\t\\t// GOAL(Here we need to check what do we want in the end, \\n\\t\\t\\t// in our question the GOAL is to reach the bottom right index)\\n\\t\\t\\t\\n\\t\\t\\t// SEARCH SPACE(Here we basically iterate through \\n\\t\\t\\t// every possible move from current position, \\n\\t\\t\\t// in our question it is either moving to right or down)\\n\\t\\t\\t\\n\\t\\t\\t// CONSTRAINT(Here we need to check \\n\\t\\t\\t// whether the above chosen move is valid or not, here in our question \\n\\t\\t\\t// the CONSTRAINT is that the chosen move should be within the boundaries)\\n\\t\\t}\\n\\t```\\n\\t\\nWith the above being said, BackTracking Solution below\\n``` \\nclass Solution {\\n    private int res;\\n    public int minPathSum(int[][] arr) {\\n        int m = arr.length;\\n        int n = arr[0].length;\\n        res = Integer.MAX_VALUE;\\n        backTrack(arr, 0, 0, m-1, n-1, arr[0][0]);\\n        return res;\\n    }\\n    \\n    private int x[] = new int[]{0, 1};\\n    private int y[] = new int[]{1, 0};\\n    private void backTrack(int arr[][], int a, int b, int c, int d, int cur) {\\n\\t\\t// GOAL\\n        if(a == c && b == d) {\\n            res = Math.min(res, cur);\\n            return ;\\n        }\\n\\t\\t\\n\\t\\t// SEARCH SPACE\\n        for(int i=0;i<2;i++) {\\n            int nx = a + x[i];\\n            int ny = b + y[i];\\n\\t\\t\\t// CONSTRAINT\\n            if(isSafe(nx, ny, c, d)) {\\n                backTrack(arr, nx, ny, c, d, cur+arr[nx][ny]);\\n            }\\n        }\\n    }\\n    \\n    private boolean isSafe(int a, int b, int c, int d) {\\n        return a >= 0 && b >= 0 && a <= c && b <= d;\\n    }\\n}\\n```\\n\\nThe above solution gives **TLE** because it takes every possible path into consideration.\\n\\n2. **Recursive** approach\\n\\n\\tThis problem pattern is similar to **\"With, Without\"** classic principle.\\n\\t\\n\\tAt each and every position , we have 2 choices in our given question. We can either go to the right or we can go to down. And we need to take the minimum of those 2 choices.\\n\\t\\n\\tLet\\'s just say that we are at position (a, b) & the array is arr[][] & the number of rows as m and the number of columns as n.\\n\\t\\n\\tThe recursive function goes like this:\\n\\t```\\n\\tfunction(int a, int b, int m, int n, int arr[][]) {\\n\\t\\n\\t\\t// Handle base case \\n\\t\\t// which is when we reach our desired bottom right position\\n\\t\\tif(a == m-1 && b == n-1) {\\n\\t\\t\\treturn arr[a][b];\\n\\t\\t}\\n\\t\\t\\n\\t\\t// Handle out of boundary cases\\n\\t\\tif(a >= m || b >= n)\\n            return Integer.MAX_VALUE;\\n\\t\\t\\n\\t\\t\\n\\t\\t// Below means that we can take the current pos value \\n\\t\\t// and we are taking the minimum of right & down\\n\\t\\treturn arr[a][b] + Math.min(function(a, b+1, m, n, arr), function(a+1, b, m, n, arr));\\n\\t}\\n\\t```\\n\\t\\n\\tI have used a Map to cache the already calculated results\\n\\t\\n\\tWith that being said , Recursive solution below\\n\\t\\n\\t```\\n\\tclass Solution {\\n    private Map<String, Integer> map;\\n    public int minPathSum(int[][] arr) {\\n        int m = arr.length;\\n        int n = arr[0].length;\\n        map = new HashMap<>();\\n        return recur(arr, 0, 0, m, n);\\n    }\\n\\t\\n    private int recur(int arr[][], int a, int b, int c, int d) {\\n        if(a == c-1 && b == d-1)\\n            return arr[a][b];\\n        if(a >= c || b >= d)\\n            return Integer.MAX_VALUE;\\n        String key = String.valueOf(a) + \",\" + String.valueOf(b);\\n        if(map.containsKey(key))\\n            return map.get(key);\\n        int res = arr[a][b] + Math.min(\\n            recur(arr, a, b+1, c, d),\\n            recur(arr, a+1, b, c, d)\\n        );\\n        map.put(key, res);\\n        return res;\\n    }\\n}\\n\\t```\\n3. **Dynamic Programming** approach\\n\\nOnce we write the recursive approach, DP is easy to write.\\n\\nDP Solution below.\\n```\\nclass Solution {\\n    public int minPathSum(int[][] arr) {\\n        int m = arr.length;\\n        int n = arr[0].length;\\n        return dy(arr);\\n    }\\n    \\n    private int dy(int arr[][]) {\\n        int m = arr.length;\\n        int n = arr[0].length;\\n        int dp[][] = new int[m][n];\\n        for(int i=0;i<m;i++) {\\n            for(int j=0;j<n;j++) {\\n                if( i == 0 && j == 0) {\\n                    dp[i][j] = arr[i][j];\\n                    continue;\\n                }\\n                dp[i][j] = arr[i][j] + Math.min(j > 0 ? dp[i][j-1] : Integer.MAX_VALUE, i > 0 ? dp[i-1][j] : Integer.MAX_VALUE);\\n            }\\n        }\\n        return dp[m-1][n-1];\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Dynamic Programming",
                    "Backtracking",
                    "Recursion"
                ],
                "code": "```\\n\\t\\tpublic void backTracking() {\\n\\t\\t\\t// GOAL(Here we need to check what do we want in the end, \\n\\t\\t\\t// in our question the GOAL is to reach the bottom right index)\\n\\t\\t\\t\\n\\t\\t\\t// SEARCH SPACE(Here we basically iterate through \\n\\t\\t\\t// every possible move from current position, \\n\\t\\t\\t// in our question it is either moving to right or down)\\n\\t\\t\\t\\n\\t\\t\\t// CONSTRAINT(Here we need to check \\n\\t\\t\\t// whether the above chosen move is valid or not, here in our question \\n\\t\\t\\t// the CONSTRAINT is that the chosen move should be within the boundaries)\\n\\t\\t}\\n\\t```\n``` \\nclass Solution {\\n    private int res;\\n    public int minPathSum(int[][] arr) {\\n        int m = arr.length;\\n        int n = arr[0].length;\\n        res = Integer.MAX_VALUE;\\n        backTrack(arr, 0, 0, m-1, n-1, arr[0][0]);\\n        return res;\\n    }\\n    \\n    private int x[] = new int[]{0, 1};\\n    private int y[] = new int[]{1, 0};\\n    private void backTrack(int arr[][], int a, int b, int c, int d, int cur) {\\n\\t\\t// GOAL\\n        if(a == c && b == d) {\\n            res = Math.min(res, cur);\\n            return ;\\n        }\\n\\t\\t\\n\\t\\t// SEARCH SPACE\\n        for(int i=0;i<2;i++) {\\n            int nx = a + x[i];\\n            int ny = b + y[i];\\n\\t\\t\\t// CONSTRAINT\\n            if(isSafe(nx, ny, c, d)) {\\n                backTrack(arr, nx, ny, c, d, cur+arr[nx][ny]);\\n            }\\n        }\\n    }\\n    \\n    private boolean isSafe(int a, int b, int c, int d) {\\n        return a >= 0 && b >= 0 && a <= c && b <= d;\\n    }\\n}\\n```\n```\\n\\tfunction(int a, int b, int m, int n, int arr[][]) {\\n\\t\\n\\t\\t// Handle base case \\n\\t\\t// which is when we reach our desired bottom right position\\n\\t\\tif(a == m-1 && b == n-1) {\\n\\t\\t\\treturn arr[a][b];\\n\\t\\t}\\n\\t\\t\\n\\t\\t// Handle out of boundary cases\\n\\t\\tif(a >= m || b >= n)\\n            return Integer.MAX_VALUE;\\n\\t\\t\\n\\t\\t\\n\\t\\t// Below means that we can take the current pos value \\n\\t\\t// and we are taking the minimum of right & down\\n\\t\\treturn arr[a][b] + Math.min(function(a, b+1, m, n, arr), function(a+1, b, m, n, arr));\\n\\t}\\n\\t```\n```\\n\\tclass Solution {\\n    private Map<String, Integer> map;\\n    public int minPathSum(int[][] arr) {\\n        int m = arr.length;\\n        int n = arr[0].length;\\n        map = new HashMap<>();\\n        return recur(arr, 0, 0, m, n);\\n    }\\n\\t\\n    private int recur(int arr[][], int a, int b, int c, int d) {\\n        if(a == c-1 && b == d-1)\\n            return arr[a][b];\\n        if(a >= c || b >= d)\\n            return Integer.MAX_VALUE;\\n        String key = String.valueOf(a) + \",\" + String.valueOf(b);\\n        if(map.containsKey(key))\\n            return map.get(key);\\n        int res = arr[a][b] + Math.min(\\n            recur(arr, a, b+1, c, d),\\n            recur(arr, a+1, b, c, d)\\n        );\\n        map.put(key, res);\\n        return res;\\n    }\\n}\\n\\t```\n```\\nclass Solution {\\n    public int minPathSum(int[][] arr) {\\n        int m = arr.length;\\n        int n = arr[0].length;\\n        return dy(arr);\\n    }\\n    \\n    private int dy(int arr[][]) {\\n        int m = arr.length;\\n        int n = arr[0].length;\\n        int dp[][] = new int[m][n];\\n        for(int i=0;i<m;i++) {\\n            for(int j=0;j<n;j++) {\\n                if( i == 0 && j == 0) {\\n                    dp[i][j] = arr[i][j];\\n                    continue;\\n                }\\n                dp[i][j] = arr[i][j] + Math.min(j > 0 ? dp[i][j-1] : Integer.MAX_VALUE, i > 0 ? dp[i-1][j] : Integer.MAX_VALUE);\\n            }\\n        }\\n        return dp[m-1][n-1];\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 226798,
                "title": "javascript",
                "content": "**\\u89E3\\u9898\\u601D\\u8DEF:**\\n1. \\u57FA\\u672C\\u601D\\u8DEF\\u4E3A: (i, j) = (i, j) + min((i - 1, j), (i, j - 1)).\\n2. \\u4F46\\u662F\\u7B2C\\u4E00\\u5217\\u548C\\u7B2C\\u4E00\\u884C\\u7684\\u6BCF\\u4E00\\u4E2A\\u5143\\u7D20, \\u5747\\u9700\\u8981\\u52A0\\u4E0A\\u524D\\u9762\\u4E00\\u4E2A\\u5143\\u7D20.\\n\\n**\\u4EE3\\u7801:**\\n```\\nvar minPathSum = function(grid) {\\n  const m = grid.length;\\n  const n = grid[0].length;\\n  \\n  for (let i = 1; i < m; i++) {\\n    grid[i][0] += grid[i - 1][0];\\n  }\\n  for (let i = 1; i < n; i++) {\\n    grid[0][i] += grid[0][i - 1];\\n  }\\n  \\n  for (let i = 1; i < m; i++) {\\n    for (let j = 1; j < n; j++) {\\n      grid[i][j] += Math.min(grid[i - 1][j], grid[i][j - 1]);\\n    }\\n  }\\n  \\n  return grid[m - 1][n - 1];\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nvar minPathSum = function(grid) {\\n  const m = grid.length;\\n  const n = grid[0].length;\\n  \\n  for (let i = 1; i < m; i++) {\\n    grid[i][0] += grid[i - 1][0];\\n  }\\n  for (let i = 1; i < n; i++) {\\n    grid[0][i] += grid[0][i - 1];\\n  }\\n  \\n  for (let i = 1; i < m; i++) {\\n    for (let j = 1; j < n; j++) {\\n      grid[i][j] += Math.min(grid[i - 1][j], grid[i][j - 1]);\\n    }\\n  }\\n  \\n  return grid[m - 1][n - 1];\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3117215,
                "title": "c-recursion-dp-memoization-tabulation-space-optimization",
                "content": "# \\uD83D\\uDCA1Intuition and Approach :-\\n\\nhttps://www.youtube.com/watch?v=_rgTlyky1uQ&list=PLgUwDviBIf0qUlt5H_kiKYaNSqJ81PMMY&index=11\\n\\n#### This video helped me understand the Solution. Thanks to TUF and Striver \\uD83D\\uDE4F\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# \\uD83D\\uDCA1Code\\n# \\uD83D\\uDCA5Recursion :-\\n```\\nTC:O(2^n) SC:O((m-1)+(n-1))\\nclass Solution {\\npublic:\\n    int f(int i, int j, vector<vector<int>>& grid){\\n        if(i==0 && j==0) return grid[i][j];\\n        if(i<0 ||j<0) return INT_MAX;\\n\\n        int up = grid[i][j] + f(i-1, j, grid);\\n        int left = grid[i][j] + f(i, j-1, grid);\\n        return min(up, left);\\n    }\\n    int minPathSum(vector<vector<int>>& grid) {\\n        int m = grid[0].size();\\n        int n = grid.size();\\n        return f(n-1, m-1, grid);\\n    }\\n};\\n```\\n# \\uD83D\\uDCA5Memoization :-\\n```\\nTC:O(m*n) SC:O((m-1)+(n-1))+O(m*n)\\nclass Solution {\\npublic:\\n    int f(int i, int j, vector<vector<int>>& grid, vector<vector<int>> &dp){\\n        if(i==0 && j==0) return grid[0][0];\\n        if(i<0 ||j<0) return 1e9;\\n        if(dp[i][j]!=-1) return dp[i][j];\\n\\n        int up = grid[i][j] + f(i-1, j, grid, dp);\\n        int left = grid[i][j] + f(i, j-1, grid, dp);\\n        return dp[i][j] = min(up, left);\\n    }\\n    int minPathSum(vector<vector<int>>& grid) {\\n        int m = grid[0].size();\\n        int n = grid.size();\\n        vector<vector<int>> dp(n, vector<int> (m,-1));\\n        return f(n-1,m-1, grid, dp);\\n    }\\n};\\n```\\n# \\uD83D\\uDCA5Tabulation :-\\n```\\nTC:O(m*n) SC:O(m*n)\\nclass Solution {\\npublic:\\n    int minPathSum(vector<vector<int>>& grid) {\\n        int m = grid[0].size();\\n        int n = grid.size();\\n        vector<vector<int>> dp(n, vector<int> (m,-1));\\n        for(int i=0; i<n; i++){\\n            for(int j=0; j<m; j++){\\n                if(i==0 && j==0){\\n                    dp[0][0] = grid[0][0];\\n                }\\n                else{\\n                    int up = grid[i][j]; \\n                    if(i>0) up+= dp[i-1][j];\\n                    else up+= 1e9;\\n\\n                    int left = grid[i][j];\\n                    if(j>0) left+= dp[i][j-1];\\n                    else left+= 1e9;\\n\\n                    dp[i][j] = min(up, left);\\n                }\\n            }\\n        }\\n        return dp[n-1][m-1];\\n    }\\n};\\n\\n```\\n\\n# \\uD83D\\uDCA5Space Optimization :-\\n```\\nclass Solution {\\npublic:\\n    int minPathSum(vector<vector<int>>& grid) {\\n        int m = grid[0].size();\\n        int n = grid.size();\\n        vector<int> prev(m,0);\\n        for(int i=0; i<n; i++){\\n            vector<int> temp(m,0);\\n            for(int j=0; j<m; j++){\\n                if(i==0 && j==0){\\n                    temp[0] = grid[0][0];\\n                }\\n                else{\\n                    int up = grid[i][j]; \\n                    if(i>0) up+= prev[j];\\n                    else up+= 1e9;\\n\\n                    int left = grid[i][j];\\n                    if(j>0) left+= temp[j-1];\\n                    else left+= 1e9;\\n\\n                    temp[j] = min(up, left);\\n                }\\n            }\\n            prev = temp;\\n        }\\n        return prev[m-1];\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Array",
                    "Dynamic Programming",
                    "Memoization",
                    "Matrix"
                ],
                "code": "```\\nTC:O(2^n) SC:O((m-1)+(n-1))\\nclass Solution {\\npublic:\\n    int f(int i, int j, vector<vector<int>>& grid){\\n        if(i==0 && j==0) return grid[i][j];\\n        if(i<0 ||j<0) return INT_MAX;\\n\\n        int up = grid[i][j] + f(i-1, j, grid);\\n        int left = grid[i][j] + f(i, j-1, grid);\\n        return min(up, left);\\n    }\\n    int minPathSum(vector<vector<int>>& grid) {\\n        int m = grid[0].size();\\n        int n = grid.size();\\n        return f(n-1, m-1, grid);\\n    }\\n};\\n```\n```\\nTC:O(m*n) SC:O((m-1)+(n-1))+O(m*n)\\nclass Solution {\\npublic:\\n    int f(int i, int j, vector<vector<int>>& grid, vector<vector<int>> &dp){\\n        if(i==0 && j==0) return grid[0][0];\\n        if(i<0 ||j<0) return 1e9;\\n        if(dp[i][j]!=-1) return dp[i][j];\\n\\n        int up = grid[i][j] + f(i-1, j, grid, dp);\\n        int left = grid[i][j] + f(i, j-1, grid, dp);\\n        return dp[i][j] = min(up, left);\\n    }\\n    int minPathSum(vector<vector<int>>& grid) {\\n        int m = grid[0].size();\\n        int n = grid.size();\\n        vector<vector<int>> dp(n, vector<int> (m,-1));\\n        return f(n-1,m-1, grid, dp);\\n    }\\n};\\n```\n```\\nTC:O(m*n) SC:O(m*n)\\nclass Solution {\\npublic:\\n    int minPathSum(vector<vector<int>>& grid) {\\n        int m = grid[0].size();\\n        int n = grid.size();\\n        vector<vector<int>> dp(n, vector<int> (m,-1));\\n        for(int i=0; i<n; i++){\\n            for(int j=0; j<m; j++){\\n                if(i==0 && j==0){\\n                    dp[0][0] = grid[0][0];\\n                }\\n                else{\\n                    int up = grid[i][j]; \\n                    if(i>0) up+= dp[i-1][j];\\n                    else up+= 1e9;\\n\\n                    int left = grid[i][j];\\n                    if(j>0) left+= dp[i][j-1];\\n                    else left+= 1e9;\\n\\n                    dp[i][j] = min(up, left);\\n                }\\n            }\\n        }\\n        return dp[n-1][m-1];\\n    }\\n};\\n\\n```\n```\\nclass Solution {\\npublic:\\n    int minPathSum(vector<vector<int>>& grid) {\\n        int m = grid[0].size();\\n        int n = grid.size();\\n        vector<int> prev(m,0);\\n        for(int i=0; i<n; i++){\\n            vector<int> temp(m,0);\\n            for(int j=0; j<m; j++){\\n                if(i==0 && j==0){\\n                    temp[0] = grid[0][0];\\n                }\\n                else{\\n                    int up = grid[i][j]; \\n                    if(i>0) up+= prev[j];\\n                    else up+= 1e9;\\n\\n                    int left = grid[i][j];\\n                    if(j>0) left+= temp[j-1];\\n                    else left+= 1e9;\\n\\n                    temp[j] = min(up, left);\\n                }\\n            }\\n            prev = temp;\\n        }\\n        return prev[m-1];\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1405052,
                "title": "recursion-to-dp-memoization",
                "content": "Recursion:\\n\\n```\\nclass Solution:\\n    def minPathSum(self, grid: List[List[int]]) -> int:\\n        m = len(grid)\\n        n = len(grid[0])\\n                \\n        def helper(i,j):\\n            if i >= m or j>=n:\\n                return float(\\'inf\\')\\n            \\n            if i == m-1 and j == n-1:\\n                return grid[i][j]\\n            \\n            return grid[i][j] + min(helper(i+1,j), helper(i,j+1))\\n            \\n        \\n        return helper(0,0)\\n```\\n\\nAdding memoization:\\n```\\nclass Solution:\\n    def minPathSum(self, grid: List[List[int]]) -> int:\\n        m = len(grid)\\n        n = len(grid[0])\\n        \\n        cache = {}\\n        \\n        def helper(i,j):\\n            if i >= m or j>=n:\\n                return float(\\'inf\\')\\n            \\n            if i == m-1 and j == n-1:\\n                return grid[i][j]\\n            \\n\\t\\t\\t# return from cache if present\\n            if (i,j) in cache :\\n                return cache[(i,j)]\\n\\t\\t\\t\\n\\t\\t\\t# populate cache\\n            cache[(i,j)] = grid[i][j] + min(helper(i+1,j), helper(i,j+1))\\n            return cache[(i,j)]\\n            \\n        return helper(0,0)\\n```\\n",
                "solutionTags": [
                    "Python",
                    "Python3",
                    "Dynamic Programming",
                    "Recursion",
                    "Memoization"
                ],
                "code": "```\\nclass Solution:\\n    def minPathSum(self, grid: List[List[int]]) -> int:\\n        m = len(grid)\\n        n = len(grid[0])\\n                \\n        def helper(i,j):\\n            if i >= m or j>=n:\\n                return float(\\'inf\\')\\n            \\n            if i == m-1 and j == n-1:\\n                return grid[i][j]\\n            \\n            return grid[i][j] + min(helper(i+1,j), helper(i,j+1))\\n            \\n        \\n        return helper(0,0)\\n```\n```\\nclass Solution:\\n    def minPathSum(self, grid: List[List[int]]) -> int:\\n        m = len(grid)\\n        n = len(grid[0])\\n        \\n        cache = {}\\n        \\n        def helper(i,j):\\n            if i >= m or j>=n:\\n                return float(\\'inf\\')\\n            \\n            if i == m-1 and j == n-1:\\n                return grid[i][j]\\n            \\n\\t\\t\\t# return from cache if present\\n            if (i,j) in cache :\\n                return cache[(i,j)]\\n\\t\\t\\t\\n\\t\\t\\t# populate cache\\n            cache[(i,j)] = grid[i][j] + min(helper(i+1,j), helper(i,j+1))\\n            return cache[(i,j)]\\n            \\n        return helper(0,0)\\n```",
                "codeTag": "Java"
            },
            {
                "id": 23637,
                "title": "passed-c-code-only-need-o-n-extra-space-and-don-t-change-the-original-data",
                "content": "    int minPathSum(vector<vector<int> > &grid) {\\n        int rows = grid.size();\\n        if (rows==0) return 0;\\n        int cols = grid[0].size();\\n        vector<int> vi(cols, INT_MAX);\\n\\n        int i, j;\\n        vi[0] = 0;\\n        for (i=0; i<rows; i++) {\\n            vi[0] += grid[i][0];\\n            for (j=1; j<cols; j++) {\\n                vi[j] = min(vi[j-1], vi[j])+grid[i][j];\\n            }\\n        }\\n        return vi[cols-1];\\n    }",
                "solutionTags": [],
                "code": "    int minPathSum(vector<vector<int> > &grid) {\\n        int rows = grid.size();\\n        if (rows==0) return 0;\\n        int cols = grid[0].size();\\n        vector<int> vi(cols, INT_MAX);\\n\\n        int i, j;\\n        vi[0] = 0;\\n        for (i=0; i<rows; i++) {\\n            vi[0] += grid[i][0];\\n            for (j=1; j<cols; j++) {\\n                vi[j] = min(vi[j-1], vi[j])+grid[i][j];\\n            }\\n        }\\n        return vi[cols-1];\\n    }",
                "codeTag": "Unknown"
            },
            {
                "id": 3856514,
                "title": "most-optimized-2-methods-explained-dry-run-1d-dp-beats-100",
                "content": "# Method #1\\n# Intuition & Approach \\n<!-- Describe your first thoughts on how to solve this problem. -->\\n- We are creating a vector of size rows and storing grid[i][0] in cur[i]\\n- Cur vector is used as dp vector in this method.\\n- Now update cur as if we are following the downward path only. \\n- Use nested loop and dry run the code,\\n- Here we are comparing the two possibilities(Right or Downward direction)\\n- For reaching the cell[i][j] in matrix and update it with minimum.\\n- Return the answer.\\n\\n# Complexity\\n- Time complexity: O(n*m)\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: O(m): m(Rows)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int minPathSum(vector<vector<int>>& grid) {\\n        int m = grid.size();\\n        int n = grid[0].size();\\n        vector<int> cur(m, grid[0][0]);\\n        for (int i = 1; i < m; i++)\\n            cur[i] = cur[i - 1] + grid[i][0]; \\n\\n        for (int j = 1; j < n; j++) {\\n            cur[0] += grid[0][j]; \\n            for (int i = 1; i < m; i++)\\n                cur[i] = min(cur[i - 1], cur[i]) + grid[i][j];\\n        }\\n        return cur[m - 1];\\n    }\\n};\\n```\\n### Dry Run:\\n![#dryRunMethod1(MinimumPathSum).jpeg](https://assets.leetcode.com/users/images/073a6b38-7fbd-4c14-be48-bb2ae1a7e872_1691043144.5424638.jpeg)\\n\\n# Method #2\\n# Intuition & Approach\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n- In any matrix where dp is involved this is the **generic** way to solve the problem.\\n- Create DP vector of n*m, initialize it by -1.\\n- Call it recursively.\\n- Check for valid indices, if we are at destination return dp[i][j]\\n- Store results of possible way, like(down, right, left, up)\\n- Store the required result like max/min OR sum/multiplication of it in dp[i][j]\\n- Return the answer.\\n\\n# Complexity\\n- Time complexity: O(n*m)\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: O(n*m)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n  int f(int i, int j,vector<vector<int>> &grid, vector<vector<int>> &dp){\\n    if(i<0 || j<0 ) return 1e9;\\n    if(i==0 && j==0) return grid[0][0];\\n    if(dp[i][j] != -1) return dp[i][j];\\n    \\n    int up = grid[i][j] + f(i-1, j, grid, dp);\\n    int left = grid[i][j] + f(i,j-1, grid, dp);\\n    return dp[i][j] = min(left,up); \\n  }\\n    int minPathSum(vector<vector<int>>& grid) {\\n        int m = grid.size();\\n        int n = grid[0].size();\\n        vector<vector<int>>dp(m, vector<int> (n, -1));\\n\\n        return f(m-1, n-1,grid, dp);\\n    }\\n};\\n```\\n",
                "solutionTags": [
                    "C++",
                    "Array",
                    "Dynamic Programming",
                    "Recursion",
                    "Memoization",
                    "Matrix"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int minPathSum(vector<vector<int>>& grid) {\\n        int m = grid.size();\\n        int n = grid[0].size();\\n        vector<int> cur(m, grid[0][0]);\\n        for (int i = 1; i < m; i++)\\n            cur[i] = cur[i - 1] + grid[i][0]; \\n\\n        for (int j = 1; j < n; j++) {\\n            cur[0] += grid[0][j]; \\n            for (int i = 1; i < m; i++)\\n                cur[i] = min(cur[i - 1], cur[i]) + grid[i][j];\\n        }\\n        return cur[m - 1];\\n    }\\n};\\n```\n```\\nclass Solution {\\npublic:\\n  int f(int i, int j,vector<vector<int>> &grid, vector<vector<int>> &dp){\\n    if(i<0 || j<0 ) return 1e9;\\n    if(i==0 && j==0) return grid[0][0];\\n    if(dp[i][j] != -1) return dp[i][j];\\n    \\n    int up = grid[i][j] + f(i-1, j, grid, dp);\\n    int left = grid[i][j] + f(i,j-1, grid, dp);\\n    return dp[i][j] = min(left,up); \\n  }\\n    int minPathSum(vector<vector<int>>& grid) {\\n        int m = grid.size();\\n        int n = grid[0].size();\\n        vector<vector<int>>dp(m, vector<int> (n, -1));\\n\\n        return f(m-1, n-1,grid, dp);\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3345991,
                "title": "try-ones-more-using-my-hints-easy-java-solution-2-approaches-recursive-and-iterative",
                "content": "# Approach 1 Using recursion(Brute force)\\n\\n# Hints \\n- Use recursion \\n- Start from Destination grid[n][m] \\n- Each time check :- \\n    - If we reach source(i.e. n == 0 && m == 0) return grid[0][0]\\n    - Else if index is not valid return Integer.MAX_VALUE\\n    - Else return cost of current node(grid[n][m]) sum with mininum of cost to reach (n-1, m) and (n, m-1).\\n\\n# Note \\n- It will give Time Limit Exceeded as time is 2^n\\n\\n# Complexity\\n- Time complexity: O(2^(n*m))\\n\\n# Code \\n```\\nclass Solution {\\n    public int minPathSum(int[][] grid) {\\n        return minPathSum(grid, grid.length-1, grid[0].length-1);\\n    }\\n    private int minPathSum(int[][] grid, int n, int m){\\n        if(n == 0 && m == 0) return grid[n][m];\\n        if(n < 0 || m < 0) return Integer.MAX_VALUE;\\n        return grid[n][m] + Math.min(minPathSum(grid, n-1, m), minPathSum(grid, n, m-1));\\n    }\\n}\\n```\\n\\n# Approach 2 Using DP\\n- Same approach in dp\\n- Try to frame dp solution yourself\\n\\n# Complexity\\n- Time complexity: O(n*m)\\n\\n- Space complexity: O(n*m)\\n\\n# Code\\n```\\nclass Solution {\\n    public int minPathSum(int[][] grid) {\\n        int n = grid.length;\\n        int m = grid[0].length;\\n        int dp[][] = new int[grid.length][grid[0].length];\\n        for(int i = 0; i<n; i++){\\n            for(int j = 0; j<m; j++){\\n                if(i == 0 && j == 0) dp[i][j] = grid[i][j];\\n                else if(i == 0) dp[i][j] = dp[i][j-1] + grid[i][j];\\n                else if(j == 0) dp[i][j] = dp[i-1][j] + grid[i][j];\\n                else {\\n                    dp[i][j] = grid[i][j] + Math.min(dp[i][j-1], dp[i-1][j]);\\n                }\\n            }\\n        }\\n        return dp[n-1][m-1];\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Array",
                    "Dynamic Programming",
                    "Recursion",
                    "Matrix"
                ],
                "code": "```\\nclass Solution {\\n    public int minPathSum(int[][] grid) {\\n        return minPathSum(grid, grid.length-1, grid[0].length-1);\\n    }\\n    private int minPathSum(int[][] grid, int n, int m){\\n        if(n == 0 && m == 0) return grid[n][m];\\n        if(n < 0 || m < 0) return Integer.MAX_VALUE;\\n        return grid[n][m] + Math.min(minPathSum(grid, n-1, m), minPathSum(grid, n, m-1));\\n    }\\n}\\n```\n```\\nclass Solution {\\n    public int minPathSum(int[][] grid) {\\n        int n = grid.length;\\n        int m = grid[0].length;\\n        int dp[][] = new int[grid.length][grid[0].length];\\n        for(int i = 0; i<n; i++){\\n            for(int j = 0; j<m; j++){\\n                if(i == 0 && j == 0) dp[i][j] = grid[i][j];\\n                else if(i == 0) dp[i][j] = dp[i][j-1] + grid[i][j];\\n                else if(j == 0) dp[i][j] = dp[i-1][j] + grid[i][j];\\n                else {\\n                    dp[i][j] = grid[i][j] + Math.min(dp[i][j-1], dp[i-1][j]);\\n                }\\n            }\\n        }\\n        return dp[n-1][m-1];\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3345808,
                "title": "java-easy-solution-fully-explained-100-faster-code",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\npublic class Solution {\\n    /**\\n     * Space Complexity O(m*n) -- for dp matrix\\n     * Time Complexity O(m*n)\\n     * @param grid\\n     * @return\\n     */\\n    public int minPathSum(int[][] grid) {\\n        //initialise a dp with size same as original array\\n        int m = grid.length, n = grid[0].length;\\n        int[][] dp = new int[m][n];\\n\\n        for (int i = m - 1; i >= 0; i--) {\\n            for (int j = n - 1; j >= 0; j--) {\\n                //start counting the cost from the bottom right cell(bottom up approach) this is base condition\\n                //Cost of going to destination from destination is the lowest subset problem\\n                //then expand with the computed value to other cells gradually\\n                //when solving bigger subsets other than base condition, remember we can only go right or bottom\\n                if (i + 1 > m - 1 && j + 1 > n - 1) //base condition\\n                    dp[i][j] = grid[i][j];\\n\\n                else if (i + 1 > m - 1)//boundary condition: handles the bottom most row\\n                    dp[i][j] = dp[i][j + 1] + grid[i][j];\\n\\n                else if (j + 1 > n - 1)//boundary condition: handles the right most column\\n                    dp[i][j] = dp[i + 1][j] + grid[i][j];\\n                else {// normal cells : get the min of 1 horizontal  right travel and 1 vertical bottom travel\\n                    dp[i][j] = Math.min(dp[i][j + 1] + grid[i][j], dp[i + 1][j] + grid[i][j]);\\n                }\\n            }\\n        }\\n        return dp[0][0];\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\npublic class Solution {\\n    /**\\n     * Space Complexity O(m*n) -- for dp matrix\\n     * Time Complexity O(m*n)\\n     * @param grid\\n     * @return\\n     */\\n    public int minPathSum(int[][] grid) {\\n        //initialise a dp with size same as original array\\n        int m = grid.length, n = grid[0].length;\\n        int[][] dp = new int[m][n];\\n\\n        for (int i = m - 1; i >= 0; i--) {\\n            for (int j = n - 1; j >= 0; j--) {\\n                //start counting the cost from the bottom right cell(bottom up approach) this is base condition\\n                //Cost of going to destination from destination is the lowest subset problem\\n                //then expand with the computed value to other cells gradually\\n                //when solving bigger subsets other than base condition, remember we can only go right or bottom\\n                if (i + 1 > m - 1 && j + 1 > n - 1) //base condition\\n                    dp[i][j] = grid[i][j];\\n\\n                else if (i + 1 > m - 1)//boundary condition: handles the bottom most row\\n                    dp[i][j] = dp[i][j + 1] + grid[i][j];\\n\\n                else if (j + 1 > n - 1)//boundary condition: handles the right most column\\n                    dp[i][j] = dp[i + 1][j] + grid[i][j];\\n                else {// normal cells : get the min of 1 horizontal  right travel and 1 vertical bottom travel\\n                    dp[i][j] = Math.min(dp[i][j + 1] + grid[i][j], dp[i + 1][j] + grid[i][j]);\\n                }\\n            }\\n        }\\n        return dp[0][0];\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2240046,
                "title": "c-solution-recursion-memoization-tabulation-with-tc-and-sc",
                "content": "**Normal Recursion (Result in TLE)**\\n```\\nclass Solution\\n{\\n    int rec(int r, int c, int& m, int& n, vector<vector<int>>& grid)\\n    {\\n        // Base Cases\\n        if(r==m-1 && c==n-1)\\n            return grid[r][c];\\n        if(r >= m || c >= n)\\n            return 1000;  // Random big number\\n        \\n        int down = grid[r][c] + rec(r+1,c,m,n,grid,dp);\\n        int right = grid[r][c] + rec(r,c+1,m,n,grid,dp);\\n        \\n        return min(down,right);\\n    }\\npublic:\\n    int minPathSum(vector<vector<int>>& grid)\\n    {\\n        int m = grid.size(), n = grid[0].size();\\n        int ans = rec(0,0,m,n,grid);\\n        return ans;\\n    }\\n};\\n```\\nTC: O(2^mxn)\\nSC: O(n {which is the largest path}) (stack space)\\n<hr style=\"margin:2rem 0;\">\\n\\n**Memoization**\\n```\\nclass Solution\\n{\\n    int rec(int r, int c, int& m, int& n, vector<vector<int>>& grid, vector<vector<int>>& dp)\\n    {\\n        // Base Cases\\n        if(r==m-1 && c==n-1)\\n            return grid[r][c];\\n        if(r >= m || c >= n)\\n            return 1000;  // Random big number\\n        if(dp[r][c] != -1)\\n            return dp[r][c];\\n        \\n        int down = grid[r][c] + rec(r+1,c,m,n,grid,dp);\\n        int right = grid[r][c] + rec(r,c+1,m,n,grid,dp);\\n        \\n        \\n        return dp[r][c] = min(down,right);\\n    }\\npublic:\\n    int minPathSum(vector<vector<int>>& grid)\\n    {\\n        int m = grid.size(), n = grid[0].size();\\n        vector<vector<int>> dp(m,vector<int>(n,-1));\\n        int ans = rec(0,0,m,n,grid,dp);\\n        return ans;\\n    }\\n};\\n```\\nTC: O(mxn)\\nSC: O(n)(Stack space) + O(m x n) (DP array)\\n<hr style=\"margin:2rem 0;\">\\n\\n**Tabulation**\\n```\\n// Tabulation\\n// See Notes for recursion and memoization\\n\\nclass Solution\\n{\\npublic:\\n    int minPathSum(vector<vector<int>>& grid)\\n    {\\n        int m = grid.size(), n = grid[0].size(), down, right;\\n        vector<vector<int>> dp(m,vector<int>(n,-1));\\n        \\n        for(int i=0;i<m;i++)\\n        {\\n            for(int j=0;j<n;j++)\\n            {\\n                down = right = 1000; // Random large number\\n                if(i==0 && j==0)\\n                    dp[i][j] = grid[0][0];\\n                else\\n                {\\n                    if(i>0)\\n                        down = grid[i][j] + dp[i-1][j];\\n                    if(j>0)\\n                        right = grid[i][j] + dp[i][j-1];\\n                    \\n                    dp[i][j] = min(down,right);\\n                }\\n            }\\n        }\\n        return dp[m-1][n-1];\\n    }\\n};\\n```\\nTC: O(mxn)\\nSC: O(mxn) (DP array)",
                "solutionTags": [
                    "C",
                    "Dynamic Programming",
                    "Recursion",
                    "Memoization"
                ],
                "code": "```\\nclass Solution\\n{\\n    int rec(int r, int c, int& m, int& n, vector<vector<int>>& grid)\\n    {\\n        // Base Cases\\n        if(r==m-1 && c==n-1)\\n            return grid[r][c];\\n        if(r >= m || c >= n)\\n            return 1000;  // Random big number\\n        \\n        int down = grid[r][c] + rec(r+1,c,m,n,grid,dp);\\n        int right = grid[r][c] + rec(r,c+1,m,n,grid,dp);\\n        \\n        return min(down,right);\\n    }\\npublic:\\n    int minPathSum(vector<vector<int>>& grid)\\n    {\\n        int m = grid.size(), n = grid[0].size();\\n        int ans = rec(0,0,m,n,grid);\\n        return ans;\\n    }\\n};\\n```\n```\\nclass Solution\\n{\\n    int rec(int r, int c, int& m, int& n, vector<vector<int>>& grid, vector<vector<int>>& dp)\\n    {\\n        // Base Cases\\n        if(r==m-1 && c==n-1)\\n            return grid[r][c];\\n        if(r >= m || c >= n)\\n            return 1000;  // Random big number\\n        if(dp[r][c] != -1)\\n            return dp[r][c];\\n        \\n        int down = grid[r][c] + rec(r+1,c,m,n,grid,dp);\\n        int right = grid[r][c] + rec(r,c+1,m,n,grid,dp);\\n        \\n        \\n        return dp[r][c] = min(down,right);\\n    }\\npublic:\\n    int minPathSum(vector<vector<int>>& grid)\\n    {\\n        int m = grid.size(), n = grid[0].size();\\n        vector<vector<int>> dp(m,vector<int>(n,-1));\\n        int ans = rec(0,0,m,n,grid,dp);\\n        return ans;\\n    }\\n};\\n```\n```\\n// Tabulation\\n// See Notes for recursion and memoization\\n\\nclass Solution\\n{\\npublic:\\n    int minPathSum(vector<vector<int>>& grid)\\n    {\\n        int m = grid.size(), n = grid[0].size(), down, right;\\n        vector<vector<int>> dp(m,vector<int>(n,-1));\\n        \\n        for(int i=0;i<m;i++)\\n        {\\n            for(int j=0;j<n;j++)\\n            {\\n                down = right = 1000; // Random large number\\n                if(i==0 && j==0)\\n                    dp[i][j] = grid[0][0];\\n                else\\n                {\\n                    if(i>0)\\n                        down = grid[i][j] + dp[i-1][j];\\n                    if(j>0)\\n                        right = grid[i][j] + dp[i][j-1];\\n                    \\n                    dp[i][j] = min(down,right);\\n                }\\n            }\\n        }\\n        return dp[m-1][n-1];\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1985866,
                "title": "c-dp-6-ms-faster-than-94-05-o-n-2",
                "content": "Simple DP solution in O(n^2)\\n\\nStep 1: Initialize a dp array\\nStep 2: Fill the 0th row and 0th column of dp array where, the value at any position of row or column is the sum of all the elements from 0 to that index in the grid vector.\\nStep 3: Using two for loops iterate the whole dp array except the 0th row and col as we have already filled them in Step 2.\\nStep 4: The value of the dp[ i ][ j ] will be the value of grid[ i ][ j ] + min(dp[ i-1 ][ j ], dp[ i ][ j-1 ]) i.e.\\nthe value will be sum of the current value at grid, plus the minimum of the element at the top or element at the left side of the current element in the array.\\nStep 5: At the end return the value of the dp[ row-1 ][ col-1 ] i.e the last element of the matrix dp.\\n\\n\\n```\\nclass Solution {\\npublic:\\n    int minPathSum(vector<vector<int>>& grid) {\\n        \\n        \\n        int row = grid.size();\\n        int col = grid[0].size();\\n        \\n\\t\\t// Step 1: Initialize a dp array\\n\\n        int dp[row][col];\\n        \\n\\t\\t// Step 2: Fill the 0th row and 0th column of dp array where, the value at any position of row or\\n\\t\\t// column is the sum of all the elements from 0 to that index in the grid vector.\\n\\n        dp[0][0]=grid[0][0];\\n        for(int i=1;i<col;i++)\\n            dp[0][i] = dp[0][i-1]+grid[0][i];\\n        for(int i=1;i<row;i++)\\n            dp[i][0] = dp[i-1][0]+grid[i][0];\\n        \\n\\t\\t// Step 3: Using two for loops iterate the whole dp array except the 0th row and col as we have already \\n\\t\\t// filled them in Step 2.\\n\\n        for(int i=1;i<grid.size();i++){\\n            for(int j=1;j<grid[0].size();j++){\\n\\t\\t\\t\\n\\t\\t\\t// Step 4: The value of the dp[ i ][ j ] will be the value of grid[ i ][ j ] + min(dp[ i-1 ][ j ], dp[ i ][ j-1 ]) i.e.\\n\\t\\t\\t// the value will be sum of the current value at grid plus the minimum of the element at the top or \\n\\t\\t\\t// element at the left side of the current element in the array.\\n\\t\\t\\t\\n                dp[i][j] = min(dp[i-1][j], dp[i][j-1])+grid[i][j];\\n            }\\n        }\\n\\t\\t\\n\\t\\t// Step 5: At the end return the value of the dp[ row-1 ][ col-1 ] i.e the last element of the matrix dp.\\n        \\n        return dp[row-1][col-1];\\n        \\n    }\\n};\\n```",
                "solutionTags": [
                    "C",
                    "Dynamic Programming"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int minPathSum(vector<vector<int>>& grid) {\\n        \\n        \\n        int row = grid.size();\\n        int col = grid[0].size();\\n        \\n\\t\\t// Step 1: Initialize a dp array\\n\\n        int dp[row][col];\\n        \\n\\t\\t// Step 2: Fill the 0th row and 0th column of dp array where, the value at any position of row or\\n\\t\\t// column is the sum of all the elements from 0 to that index in the grid vector.\\n\\n        dp[0][0]=grid[0][0];\\n        for(int i=1;i<col;i++)\\n            dp[0][i] = dp[0][i-1]+grid[0][i];\\n        for(int i=1;i<row;i++)\\n            dp[i][0] = dp[i-1][0]+grid[i][0];\\n        \\n\\t\\t// Step 3: Using two for loops iterate the whole dp array except the 0th row and col as we have already \\n\\t\\t// filled them in Step 2.\\n\\n        for(int i=1;i<grid.size();i++){\\n            for(int j=1;j<grid[0].size();j++){\\n\\t\\t\\t\\n\\t\\t\\t// Step 4: The value of the dp[ i ][ j ] will be the value of grid[ i ][ j ] + min(dp[ i-1 ][ j ], dp[ i ][ j-1 ]) i.e.\\n\\t\\t\\t// the value will be sum of the current value at grid plus the minimum of the element at the top or \\n\\t\\t\\t// element at the left side of the current element in the array.\\n\\t\\t\\t\\n                dp[i][j] = min(dp[i-1][j], dp[i][j-1])+grid[i][j];\\n            }\\n        }\\n\\t\\t\\n\\t\\t// Step 5: At the end return the value of the dp[ row-1 ][ col-1 ] i.e the last element of the matrix dp.\\n        \\n        return dp[row-1][col-1];\\n        \\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1510686,
                "title": "javascript-solution-faster-than-98-91-o-n-easy-method",
                "content": "```\\n// Optimized Implementation  | Runtime O(n) | space O(1)\\n// Runtime: 68 ms, faster than 98.91 % of JavaScript online submissions for Minimum Path Sum.\\n// Memory Usage: 41 MB, less than 46.37 % of JavaScript online submissions for Minimum Path Sum.\\n\\n//By doing this method, we can find the shortest distance for all the cell in the grid from the starting point.\\n\\nvar minPathSum = function (grid) {\\n    //loops through all the cell in the grid:\\n    for (let i = 0; i < grid.length; i++)\\n        for (let j = 0; j < grid[0].length; j++)\\n            // if the position is (0,0) ,pass it...\\n            if (i == 0 && j == 0)\\n                continue\\n            // if i=0 then update the grid[0][j] position value by (0,j) + (0,j-1) position\\'s value  { other_words:: current cell value + left cell of the current cell\\'s value in the grid }\\n            else if (i == 0)\\n                grid[i][j] += grid[i][j - 1];\\n            // if j=0 then update the grid[i][0] position value by (i,0) + (i-1,0) position\\'s value { other_words:: current cell value + top cell of the current cell\\'s value in the grid }\\n            else if (j == 0)\\n                grid[i][j] += grid[i - 1][j];\\n            // else (both i and j are not equal to zero)\\n            else\\n                // current cell value + left cell of the current cell\\'s value in the grid is smaller { < } then  current cell value + top cell of the current cell\\'s value in the grid\\n                //if true ,update the grid[i][j] value by current cell value + left cell of the current cell\\'s value in the grid\\n                if (grid[i][j] + grid[i][j - 1] < grid[i][j] + grid[i - 1][j])\\n                    grid[i][j] += grid[i][j - 1];\\n                //else ,update the grid[i][j] value by current cell value + top cell of the current cell\\'s value in the grid\\n                else\\n                    grid[i][j] += grid[i - 1][j];\\n    //return the last cell value \\n    return grid[grid.length - 1][grid[0].length - 1];\\n};\\n\\nFor Example :\\n\\n    Input: grid = [[1,3,1],[1,5,1],[4,2,1]]\\n\\t____________________________\\n\\t| start  |        |        |\\n    |___1____|___3____|___1____|\\n    |        |        |        |\\n    |___1____|___5____|___1____|\\n    |        |        | finish |\\n    |___4____|___2____|___1____|\\n\\t\\n\\tAt the end , grid is updated to the shortest distance sum from the starting point :\\n\\t____________________________\\n\\t| start  |        |        |\\n    |___1____|___4____|___5____|\\n    |        |        |        |\\n    |___2____|___7____|___6____|\\n    |        |        | finish |\\n    |___6____|___8____|___7____|   return the last cell value  (7 in this case)\\n\\t\\n\\t\\tOutput: 7\\n\\t\\tExplanation: Because the path 1 \\u2192 3 \\u2192 1 \\u2192 1 \\u2192 1 minimizes the sum.\\n\\n\\n```\\n",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\n// Optimized Implementation  | Runtime O(n) | space O(1)\\n// Runtime: 68 ms, faster than 98.91 % of JavaScript online submissions for Minimum Path Sum.\\n// Memory Usage: 41 MB, less than 46.37 % of JavaScript online submissions for Minimum Path Sum.\\n\\n//By doing this method, we can find the shortest distance for all the cell in the grid from the starting point.\\n\\nvar minPathSum = function (grid) {\\n    //loops through all the cell in the grid:\\n    for (let i = 0; i < grid.length; i++)\\n        for (let j = 0; j < grid[0].length; j++)\\n            // if the position is (0,0) ,pass it...\\n            if (i == 0 && j == 0)\\n                continue\\n            // if i=0 then update the grid[0][j] position value by (0,j) + (0,j-1) position\\'s value  { other_words:: current cell value + left cell of the current cell\\'s value in the grid }\\n            else if (i == 0)\\n                grid[i][j] += grid[i][j - 1];\\n            // if j=0 then update the grid[i][0] position value by (i,0) + (i-1,0) position\\'s value { other_words:: current cell value + top cell of the current cell\\'s value in the grid }\\n            else if (j == 0)\\n                grid[i][j] += grid[i - 1][j];\\n            // else (both i and j are not equal to zero)\\n            else\\n                // current cell value + left cell of the current cell\\'s value in the grid is smaller { < } then  current cell value + top cell of the current cell\\'s value in the grid\\n                //if true ,update the grid[i][j] value by current cell value + left cell of the current cell\\'s value in the grid\\n                if (grid[i][j] + grid[i][j - 1] < grid[i][j] + grid[i - 1][j])\\n                    grid[i][j] += grid[i][j - 1];\\n                //else ,update the grid[i][j] value by current cell value + top cell of the current cell\\'s value in the grid\\n                else\\n                    grid[i][j] += grid[i - 1][j];\\n    //return the last cell value \\n    return grid[grid.length - 1][grid[0].length - 1];\\n};\\n\\nFor Example :\\n\\n    Input: grid = [[1,3,1],[1,5,1],[4,2,1]]\\n\\t____________________________\\n\\t| start  |        |        |\\n    |___1____|___3____|___1____|\\n    |        |        |        |\\n    |___1____|___5____|___1____|\\n    |        |        | finish |\\n    |___4____|___2____|___1____|\\n\\t\\n\\tAt the end , grid is updated to the shortest distance sum from the starting point :\\n\\t____________________________\\n\\t| start  |        |        |\\n    |___1____|___4____|___5____|\\n    |        |        |        |\\n    |___2____|___7____|___6____|\\n    |        |        | finish |\\n    |___6____|___8____|___7____|   return the last cell value  (7 in this case)\\n\\t\\n\\t\\tOutput: 7\\n\\t\\tExplanation: Because the path 1 \\u2192 3 \\u2192 1 \\u2192 1 \\u2192 1 minimizes the sum.\\n\\n\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1369639,
                "title": "swift-minimum-path-sum-test-cases",
                "content": "```swift\\nclass Solution {\\n    func minPathSum(_ grid: [[Int]]) -> Int {\\n        var dp = grid\\n        let rs = grid.count, cs = grid[0].count\\n        (1..<cs).forEach {\\n            dp[0][$0] += dp[0][$0-1]\\n        }\\n        (1..<rs).forEach {\\n            dp[$0][0] += dp[$0-1][0]\\n            for i in 1..<cs {\\n                dp[$0][i] += min(dp[$0-1][i], dp[$0][i-1])\\n            }\\n        }\\n        return dp[rs-1][cs-1]\\n    }\\n}\\n```\\n\\n```swift\\nimport XCTest\\n\\n// Executed 2 tests, with 0 failures (0 unexpected) in 0.036 (0.038) seconds\\n\\nclass Tests: XCTestCase {\\n    private let s = Solution()\\n    func test0() {\\n        let res = s.minPathSum([[1,3,1],[1,5,1],[4,2,1]])\\n        XCTAssertEqual(res, 7)\\n    }\\n    func test1() {\\n        let res = s.minPathSum([[1,2,3],[4,5,6]])\\n        XCTAssertEqual(res, 12)\\n    }\\n}\\n\\nTests.defaultTestSuite.run()\\n```",
                "solutionTags": [
                    "Swift"
                ],
                "code": "```swift\\nclass Solution {\\n    func minPathSum(_ grid: [[Int]]) -> Int {\\n        var dp = grid\\n        let rs = grid.count, cs = grid[0].count\\n        (1..<cs).forEach {\\n            dp[0][$0] += dp[0][$0-1]\\n        }\\n        (1..<rs).forEach {\\n            dp[$0][0] += dp[$0-1][0]\\n            for i in 1..<cs {\\n                dp[$0][i] += min(dp[$0-1][i], dp[$0][i-1])\\n            }\\n        }\\n        return dp[rs-1][cs-1]\\n    }\\n}\\n```\n```swift\\nimport XCTest\\n\\n// Executed 2 tests, with 0 failures (0 unexpected) in 0.036 (0.038) seconds\\n\\nclass Tests: XCTestCase {\\n    private let s = Solution()\\n    func test0() {\\n        let res = s.minPathSum([[1,3,1],[1,5,1],[4,2,1]])\\n        XCTAssertEqual(res, 7)\\n    }\\n    func test1() {\\n        let res = s.minPathSum([[1,2,3],[4,5,6]])\\n        XCTAssertEqual(res, 12)\\n    }\\n}\\n\\nTests.defaultTestSuite.run()\\n```",
                "codeTag": "Java"
            },
            {
                "id": 819102,
                "title": "evolve-from-recursion-to-dp",
                "content": "1.  brute force O(2^min(m,n)), dfs returns the min cost from i, j to bottom right.\\n```\\n\\tpublic int minPathSum(int[][] grid) {\\n        return dfs(0,0,grid);\\n    }\\n    private int dfs(int i, int j, int[][] grid) {\\n        int r=grid.length, c=grid[0].length;\\n        if(i==r||j==c) return Integer.MAX_VALUE;\\n        if(i==r-1&&j==c-1) return grid[i][j];\\n        int down=dfs(i+1,j,grid), right=dfs(i,j+1,grid);\\n        return Math.min(down,right)+grid[i][j];\\n    }\\n```\\n2. Memoization O(mn) \\n```\\n\\tpublic int minPathSum(int[][] grid) {\\n        Integer[][] mem=new Integer[grid.length][grid[0].length];\\n        return dfs(0,0,grid,mem);\\n    }\\n    private int dfs(int i, int j, int[][] grid, Integer[][] mem) {\\n        int r=grid.length, c=grid[0].length;\\n        if(i==r||j==c) return Integer.MAX_VALUE;\\n        if(i==r-1&&j==c-1) return grid[i][j];\\n        if(mem[i][j]!=null) return mem[i][j];\\n        int down=dfs(i+1,j,grid,mem), right=dfs(i,j+1,grid,mem);\\n        return mem[i][j]=Math.min(down,right)+grid[i][j];\\n    }\\n```\\n3. dp O(mn) Time, O(mn) Space. From #1, f[i][j] = min(f[i+1][j],f[i][j+1]) + grid[i][j] \\n```\\n\\t public int minPathSum(int[][] grid) {\\n        int r=grid.length, c=grid[0].length;\\n        int[][] dp=new int[r+1][c+1];\\n\\t\\tfor(int i=0;i<r-1;i++) dp[i][c]=Integer.MAX_VALUE;// dp[r-1][c]=0\\n        for(int i=0;i<c-1;i++) dp[r][i]=Integer.MAX_VALUE;// dp[r][c-1]=0\\n        for(int i=r-1;i>=0;i--)\\n            for(int j=c-1;j>=0;j--)\\n                dp[i][j]=Math.min(dp[i+1][j],dp[i][j+1])+grid[i][j];\\n        return dp[0][0];\\n    }\\n```\\n4. O(mn) Time, O(n) space dp\\n```\\n\\t public int minPathSum(int[][] grid) {\\n        int r=grid.length, c=grid[0].length;\\n        int[] dp=new int[c+1];\\n\\t\\tArrays.fill(dp,Integer.MAX_VALUE);//row r\\n        dp[c-1]=0;\\n        for(int i=r-1;i>=0;i--)\\n            for(int j=c-1;j>=0;j--)\\n                dp[j]=Math.min(dp[j],dp[j+1])+grid[i][j];\\n        return dp[0];\\n    }\\n```",
                "solutionTags": [],
                "code": "```\\n\\tpublic int minPathSum(int[][] grid) {\\n        return dfs(0,0,grid);\\n    }\\n    private int dfs(int i, int j, int[][] grid) {\\n        int r=grid.length, c=grid[0].length;\\n        if(i==r||j==c) return Integer.MAX_VALUE;\\n        if(i==r-1&&j==c-1) return grid[i][j];\\n        int down=dfs(i+1,j,grid), right=dfs(i,j+1,grid);\\n        return Math.min(down,right)+grid[i][j];\\n    }\\n```\n```\\n\\tpublic int minPathSum(int[][] grid) {\\n        Integer[][] mem=new Integer[grid.length][grid[0].length];\\n        return dfs(0,0,grid,mem);\\n    }\\n    private int dfs(int i, int j, int[][] grid, Integer[][] mem) {\\n        int r=grid.length, c=grid[0].length;\\n        if(i==r||j==c) return Integer.MAX_VALUE;\\n        if(i==r-1&&j==c-1) return grid[i][j];\\n        if(mem[i][j]!=null) return mem[i][j];\\n        int down=dfs(i+1,j,grid,mem), right=dfs(i,j+1,grid,mem);\\n        return mem[i][j]=Math.min(down,right)+grid[i][j];\\n    }\\n```\n```\\n\\t public int minPathSum(int[][] grid) {\\n        int r=grid.length, c=grid[0].length;\\n        int[][] dp=new int[r+1][c+1];\\n\\t\\tfor(int i=0;i<r-1;i++) dp[i][c]=Integer.MAX_VALUE;// dp[r-1][c]=0\\n        for(int i=0;i<c-1;i++) dp[r][i]=Integer.MAX_VALUE;// dp[r][c-1]=0\\n        for(int i=r-1;i>=0;i--)\\n            for(int j=c-1;j>=0;j--)\\n                dp[i][j]=Math.min(dp[i+1][j],dp[i][j+1])+grid[i][j];\\n        return dp[0][0];\\n    }\\n```\n```\\n\\t public int minPathSum(int[][] grid) {\\n        int r=grid.length, c=grid[0].length;\\n        int[] dp=new int[c+1];\\n\\t\\tArrays.fill(dp,Integer.MAX_VALUE);//row r\\n        dp[c-1]=0;\\n        for(int i=r-1;i>=0;i--)\\n            for(int j=c-1;j>=0;j--)\\n                dp[j]=Math.min(dp[j],dp[j+1])+grid[i][j];\\n        return dp[0];\\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 585111,
                "title": "javascript-solution",
                "content": "```js\\n/**\\n * @param {number[][]} grid\\n * @return {number}\\n */\\nvar minPathSum = function(grid) {\\n    const i = grid.length - 1\\n    const j = grid[0].length - 1\\n    \\n    for(let k = 0; k <= i; ++k) {\\n        for(let l = 0; l <= j; ++l) {\\n            if(k > 0 && l > 0)\\n                grid[k][l] = Math.min(grid[k][l] + grid[k][l - 1], grid[k - 1][l] + grid[k][l])\\n            else if(k > 0 || l > 0) {\\n                if(l > 0)\\n                    grid[k][l] += grid[k][l - 1]\\n                else\\n                    grid[k][l] += grid[k - 1][l]\\n                }   \\n        }\\n    }\\n    \\n    return grid[i][j]\\n};\\n \\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```js\\n/**\\n * @param {number[][]} grid\\n * @return {number}\\n */\\nvar minPathSum = function(grid) {\\n    const i = grid.length - 1\\n    const j = grid[0].length - 1\\n    \\n    for(let k = 0; k <= i; ++k) {\\n        for(let l = 0; l <= j; ++l) {\\n            if(k > 0 && l > 0)\\n                grid[k][l] = Math.min(grid[k][l] + grid[k][l - 1], grid[k - 1][l] + grid[k][l])\\n            else if(k > 0 || l > 0) {\\n                if(l > 0)\\n                    grid[k][l] += grid[k][l - 1]\\n                else\\n                    grid[k][l] += grid[k - 1][l]\\n                }   \\n        }\\n    }\\n    \\n    return grid[i][j]\\n};\\n \\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 324419,
                "title": "java-solution-using-bfs-priorityqueue",
                "content": "Should be more efficient when m >> n or n >> m.\\n```\\nclass Solution {\\n    \\n    final int[][] dirs = new int[][]{{0, 1},{1, 0}};\\n    \\n    public int minPathSum(int[][] grid) {\\n        PriorityQueue<int[]> pq = new PriorityQueue<>((a, b) -> (a[2] - b[2]));\\n        int m = grid.length, n = grid[0].length;\\n        int[][] dp = new int[m][n]; // dp[i][j] min sum to reach grid[i][j].\\n        boolean[][] visited = new boolean[m][n];\\n        pq.add(new int[]{0, 0, grid[0][0]});\\n        visited[0][0] = true;\\n        while(!pq.isEmpty()) {\\n            int[] curr = pq.poll();\\n            for(int[] dir : dirs) {\\n                int row = curr[0] + dir[0];\\n                int col = curr[1] + dir[1];\\n                if(row < 0 || row >= m || col < 0 || col >= n || visited[row][col])\\n                    continue;\\n                int[] next = new int[]{row, col, curr[2] + grid[row][col]};\\n                if(next[0] == m - 1 && next[1] == n - 1)\\n                    return next[2];\\n                visited[row][col] = true;\\n                pq.add(next);\\n            }\\n        }\\n        return grid[0][0]; // never reach unless m == n == 1.\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    \\n    final int[][] dirs = new int[][]{{0, 1},{1, 0}};\\n    \\n    public int minPathSum(int[][] grid) {\\n        PriorityQueue<int[]> pq = new PriorityQueue<>((a, b) -> (a[2] - b[2]));\\n        int m = grid.length, n = grid[0].length;\\n        int[][] dp = new int[m][n]; // dp[i][j] min sum to reach grid[i][j].\\n        boolean[][] visited = new boolean[m][n];\\n        pq.add(new int[]{0, 0, grid[0][0]});\\n        visited[0][0] = true;\\n        while(!pq.isEmpty()) {\\n            int[] curr = pq.poll();\\n            for(int[] dir : dirs) {\\n                int row = curr[0] + dir[0];\\n                int col = curr[1] + dir[1];\\n                if(row < 0 || row >= m || col < 0 || col >= n || visited[row][col])\\n                    continue;\\n                int[] next = new int[]{row, col, curr[2] + grid[row][col]};\\n                if(next[0] == m - 1 && next[1] == n - 1)\\n                    return next[2];\\n                visited[row][col] = true;\\n                pq.add(next);\\n            }\\n        }\\n        return grid[0][0]; // never reach unless m == n == 1.\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 132430,
                "title": "top-down-dp",
                "content": "```\\n// Iteratively - hard to implement:\\nfor each path from (0,0) to (m-1,n-1)\\n    maintain min sum path\\n\\n// Recursively - recursion formula:\\nminPathSumFrom(x, y) = min(grid[x][y] + minPathSumFrom(nx, ny))\\n\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\\\_ move down or right from (x, y)\\nreturn minPathSumFrom(0, 0)\\n\\n// Add memoization because:\\nminPathSumFrom(nx, ny) will be calculated for multiple times since we have different paths to reach (x, y)\\n```\\n****\\n**Top-down DP**\\n```\\nclass Solution {\\n    // Assume we can only move either down or right at any point in time\\n    private final int[][] dirs = {{0, 1}, {1, 0}};\\n    private Integer[][] memo;\\n    \\n    public int minPathSum(int[][] grid) {\\n        memo = new Integer[grid.length][grid[0].length];\\n        return minPathSumFrom(grid, 0, 0);\\n    }\\n    \\n    private int minPathSumFrom(int[][] grid, int x, int y) {\\n        if (x == grid.length - 1 && y == grid[0].length - 1){\\n            return grid[x][y];\\n        } else {\\n            if (memo[x][y] != null)\\n                return memo[x][y];\\n            \\n            int min = Integer.MAX_VALUE;\\n            for (int[] dir : dirs) {\\n                int nx = x + dir[0];\\n                int ny = y + dir[1];\\n                if (nx < grid.length && ny < grid[0].length) {\\n                    min = Math.min(grid[x][y] + minPathSumFrom(grid, nx, ny), min);\\n                }\\n            }\\n            \\n            memo[x][y] = min;\\n            return min;\\n        }\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\n// Iteratively - hard to implement:\\nfor each path from (0,0) to (m-1,n-1)\\n    maintain min sum path\\n\\n// Recursively - recursion formula:\\nminPathSumFrom(x, y) = min(grid[x][y] + minPathSumFrom(nx, ny))\\n\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\\\_ move down or right from (x, y)\\nreturn minPathSumFrom(0, 0)\\n\\n// Add memoization because:\\nminPathSumFrom(nx, ny) will be calculated for multiple times since we have different paths to reach (x, y)\\n```\n```\\nclass Solution {\\n    // Assume we can only move either down or right at any point in time\\n    private final int[][] dirs = {{0, 1}, {1, 0}};\\n    private Integer[][] memo;\\n    \\n    public int minPathSum(int[][] grid) {\\n        memo = new Integer[grid.length][grid[0].length];\\n        return minPathSumFrom(grid, 0, 0);\\n    }\\n    \\n    private int minPathSumFrom(int[][] grid, int x, int y) {\\n        if (x == grid.length - 1 && y == grid[0].length - 1){\\n            return grid[x][y];\\n        } else {\\n            if (memo[x][y] != null)\\n                return memo[x][y];\\n            \\n            int min = Integer.MAX_VALUE;\\n            for (int[] dir : dirs) {\\n                int nx = x + dir[0];\\n                int ny = y + dir[1];\\n                if (nx < grid.length && ny < grid[0].length) {\\n                    min = Math.min(grid[x][y] + minPathSumFrom(grid, nx, ny), min);\\n                }\\n            }\\n            \\n            memo[x][y] = min;\\n            return min;\\n        }\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 23610,
                "title": "go-golang-solution",
                "content": "    func minPathSum(grid [][]int) int {\\n        var m int = len(grid)\\n        var n int = len(grid[0])\\n        for i := 1; i < m; i++{\\n        \\tgrid[i][0] += grid[i-1][0];\\n        }\\n        for j := 1; j < n; j++{\\n            grid[0][j] += grid[0][j-1];\\n        }\\n        for i:= 1; i < m; i++{\\n            for j:=1; j<n; j++{\\n                grid[i][j] += min(grid[i-1][j], grid[i][j-1]);\\n            }\\n        }\\n        return grid[m-1][n-1];\\n        \\n    }\\n    func min(a, b int) int {\\n        if a < b {\\n            return a\\n        }\\n        return b\\n    }",
                "solutionTags": [
                    "Go"
                ],
                "code": "    func minPathSum(grid [][]int) int {\\n        var m int = len(grid)\\n        var n int = len(grid[0])\\n        for i := 1; i < m; i++{\\n        \\tgrid[i][0] += grid[i-1][0];\\n        }\\n        for j := 1; j < n; j++{\\n            grid[0][j] += grid[0][j-1];\\n        }\\n        for i:= 1; i < m; i++{\\n            for j:=1; j<n; j++{\\n                grid[i][j] += min(grid[i-1][j], grid[i][j-1]);\\n            }\\n        }\\n        return grid[m-1][n-1];\\n        \\n    }\\n    func min(a, b int) int {\\n        if a < b {\\n            return a\\n        }\\n        return b\\n    }",
                "codeTag": "Unknown"
            },
            {
                "id": 23621,
                "title": "python-solution-dp-52-ms",
                "content": "The fastest time: `52 ms,beats 100.00% ` . \\n\\n    def minPathSum(self, grid):\\n        m, n = len(grid), len(grid[0])\\n        dp = [0] * n\\n        for i in xrange(m):\\n            dp[0] += grid[i][0]\\n            for j in xrange(1, n):\\n                dp[j] = (min(dp[j], dp[j-1]) or dp[j-1]) + grid[i][j]\\n        return dp[-1]",
                "solutionTags": [
                    "Python",
                    "Dynamic Programming"
                ],
                "code": "The fastest time: `52 ms,beats 100.00% ` . \\n\\n    def minPathSum(self, grid):\\n        m, n = len(grid), len(grid[0])\\n        dp = [0] * n\\n        for i in xrange(m):\\n            dp[0] += grid[i][0]\\n            for j in xrange(1, n):\\n                dp[j] = (min(dp[j], dp[j-1]) or dp[j-1]) + grid[i][j]\\n        return dp[-1]",
                "codeTag": "Python3"
            },
            {
                "id": 23715,
                "title": "my-accepted-solution-in-java",
                "content": "In order to get the minimum sum to get to grid(m-1,n-1);\\n\\nSo we should get the minimum sum both  grid(m-1,n-1-1) and grid(m-1-1,n-1),\\n\\nSo that could convert to(I using every space in grid to hold the minimum sum get to grid(i,j))\\n\\n                               min( grid(i-1,j) , grid(i,j-1) ) + grid(i,j)                 i>0 && j>0\\n                       /  \\n          grid(i,j)=   |       grid(i,j-1)+grid(i,j)                                        i=0 && j>0\\n                       |  \\n                       |       grid(i-1,j)+grid(i,j)                                        i>0 && j=0 \\n                       \\\\  \\n                               grid(0,0)                                                    i=0 && j=0\\n                          \\n\\nFinally, the grid(m-1,n-1) is the result\\n\\nHope you can get my point :)\\n\\n\\n\\n    public class Solution {\\n        \\n        public int min(int a,int b)\\n        {\\n            return a>b?b:a;\\n        }\\n        \\n        public int minPathSum(int[][] grid) {\\n            if(grid.length==0) return 0;\\n            int m=grid.length;\\n            int n=grid[0].length;\\n            int[][] res=new int[grid.length][];\\n            for(int i=0;i<res.length;i++)\\n            {\\n                res[i]=Arrays.copyOf(grid[i],grid[i].length);\\n            }\\n            for(int i=1;i<n;i++)\\n            {\\n                res[0][i]+=res[0][i-1];\\n            }\\n            for(int i=1;i<m;i++)\\n            {\\n                res[i][0]+=res[i-1][0];\\n            }\\n            for(int i=1;i<m;i++)\\n            {\\n                for(int j=1;j<n;j++)\\n                {\\n                    res[i][j]+=min(res[i][j-1],res[i-1][j]);\\n                }\\n            }\\n            return res[m-1][n-1];\\n        }\\n    }",
                "solutionTags": [],
                "code": "class Solution {\\n        \\n        public int min(int a,int b)\\n        {\\n            return a>b?b:a;\\n        }",
                "codeTag": "Java"
            },
            {
                "id": 3771191,
                "title": "unlocking-optimal-time-complexity-with-memoization-tabulation-and-space-optimization",
                "content": "\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    // below is the function for recusion+memoization\\n    int solve(int i,int j,vector<vector<int>>& grid,vector<vector<int>>& DP)\\n    {\\n        if(i==0 && j==0)\\n            return grid[0][0];\\n        if(i<0 || j<0)\\n            return INT_MAX;\\n        if(DP[i][j] != -1)\\n            return DP[i][j];\\n        //here we need to take care if our solve function is returning INT_MAX and we adds grid[i][0] to it there will be integer overflow so I handled that only\\n        int up = (solve(i-1,j,grid,DP)==INT_MAX)?INT_MAX:(solve(i-1,j,grid,DP)+grid[i][j]);\\n        int left = (solve(i,j-1,grid,DP)==INT_MAX)?INT_MAX:(solve(i,j-1,grid,DP)+grid[i][j]);\\n\\n        return DP[i][j] = min(up,left);\\n    }\\n    int minPathSum(vector<vector<int>>& grid)\\n    {\\n        int m = grid.size();\\n        int n = grid[0].size();\\n        // vector<vector<int>> DP(m,vector<int> (n,-1));\\n        // return solve(m-1,n-1,grid,DP);\\n\\n        // this below code if of tabulation\\n        // for(int i=0;i<m;i++)\\n        // {\\n        //     for(int j=0;j<n;j++)\\n        //     {\\n        //         if(i==0 && j==0)\\n        //         {\\n        //             DP[i][j] = grid[0][0];\\n        //         }\\n        //         else\\n        //         {\\n        //             int up = INT_MAX;\\n        //             int left = INT_MAX;\\n        //             if(i>0)\\n        //                 up = DP[i-1][j] + grid[i][j]; \\n        //             if(j>0)\\n        //                 left = DP[i][j-1] + grid[i][j]; \\n        //             DP[i][j] = min(up,left);\\n        //         }\\n        //     }\\n        // }\\n        // return DP[m-1][n-1];\\n\\n\\n        // below is the code for space optimization\\n        // all we need is prev row and the current row on which we are doing operations\\n        vector<int> prev(n,-1);\\n        for(int i=0;i<m;i++)\\n        {\\n            vector<int> curr(n,-1);\\n            for(int j=0;j<n;j++)\\n            {\\n                if(i==0 && j==0)\\n                {\\n                    curr[j] = grid[0][0];\\n                }\\n                else\\n                {\\n                    int up = INT_MAX;\\n                    int left = INT_MAX;\\n                    if(i>0)\\n                        up = prev[j] + grid[i][j]; \\n                    if(j>0)\\n                        left = curr[j-1] + grid[i][j]; \\n                    curr[j] = min(up,left);\\n                }\\n                \\n            }\\n            prev = curr;\\n        }\\n        return prev[n-1];\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Array",
                    "Dynamic Programming",
                    "Recursion",
                    "Memoization"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    // below is the function for recusion+memoization\\n    int solve(int i,int j,vector<vector<int>>& grid,vector<vector<int>>& DP)\\n    {\\n        if(i==0 && j==0)\\n            return grid[0][0];\\n        if(i<0 || j<0)\\n            return INT_MAX;\\n        if(DP[i][j] != -1)\\n            return DP[i][j];\\n        //here we need to take care if our solve function is returning INT_MAX and we adds grid[i][0] to it there will be integer overflow so I handled that only\\n        int up = (solve(i-1,j,grid,DP)==INT_MAX)?INT_MAX:(solve(i-1,j,grid,DP)+grid[i][j]);\\n        int left = (solve(i,j-1,grid,DP)==INT_MAX)?INT_MAX:(solve(i,j-1,grid,DP)+grid[i][j]);\\n\\n        return DP[i][j] = min(up,left);\\n    }\\n    int minPathSum(vector<vector<int>>& grid)\\n    {\\n        int m = grid.size();\\n        int n = grid[0].size();\\n        // vector<vector<int>> DP(m,vector<int> (n,-1));\\n        // return solve(m-1,n-1,grid,DP);\\n\\n        // this below code if of tabulation\\n        // for(int i=0;i<m;i++)\\n        // {\\n        //     for(int j=0;j<n;j++)\\n        //     {\\n        //         if(i==0 && j==0)\\n        //         {\\n        //             DP[i][j] = grid[0][0];\\n        //         }\\n        //         else\\n        //         {\\n        //             int up = INT_MAX;\\n        //             int left = INT_MAX;\\n        //             if(i>0)\\n        //                 up = DP[i-1][j] + grid[i][j]; \\n        //             if(j>0)\\n        //                 left = DP[i][j-1] + grid[i][j]; \\n        //             DP[i][j] = min(up,left);\\n        //         }\\n        //     }\\n        // }\\n        // return DP[m-1][n-1];\\n\\n\\n        // below is the code for space optimization\\n        // all we need is prev row and the current row on which we are doing operations\\n        vector<int> prev(n,-1);\\n        for(int i=0;i<m;i++)\\n        {\\n            vector<int> curr(n,-1);\\n            for(int j=0;j<n;j++)\\n            {\\n                if(i==0 && j==0)\\n                {\\n                    curr[j] = grid[0][0];\\n                }\\n                else\\n                {\\n                    int up = INT_MAX;\\n                    int left = INT_MAX;\\n                    if(i>0)\\n                        up = prev[j] + grid[i][j]; \\n                    if(j>0)\\n                        left = curr[j-1] + grid[i][j]; \\n                    curr[j] = min(up,left);\\n                }\\n                \\n            }\\n            prev = curr;\\n        }\\n        return prev[n-1];\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3346652,
                "title": "cpp-solution-using-graph-bfs-dijkstra-greedy",
                "content": "I used the greedy approach along with Dijkstra to reach the destination node with lowest path sum possible.\\n\\n* Used the Priority Queue (to create min-heap) to get the lowest possible path sum node out from the queue.\\n* Priority Queue store in the format: `{pathSum,{row,col}}`\\n* Created the **vis** array to store the lowest path sum along each path.\\n* Then a simple **BFS** along every possible node and storing the min pathSum for the node in **vis** array.\\n```\\nclass Solution {\\npublic:\\n    int minPathSum(vector<vector<int>>& grid) {\\n        int n = grid.size();\\n        int m = grid[0].size();\\n        vector<vector<int>> vis(n,vector<int>(m,1e9));\\n        typedef pair<int,pair<int,int>> pi;\\n        priority_queue<pi,vector<pi>,greater<pi>> pq;\\n\\t\\tint pathSum0 = grid[0][0];\\n        pq.push({pathSum0,{0,0}});\\n        \\n        int delr[] = {1,0};\\n        int delc[] = {0,1};\\n        \\n        while(!pq.empty()){\\n            int val = pq.top().first;\\n            int row = pq.top().second.first;\\n            int col = pq.top().second.second;\\n            pq.pop();\\n            \\n\\t\\t\\t// Destination Node\\n            if(row==n-1 and col==m-1) return val;\\n            \\n\\t\\t\\t// checking for adjacent possible node\\n            for(int i=0;i<2;i++){\\n                int newr = row+delr[i];\\n                int newc = col+delc[i];\\n                \\n\\t\\t\\t\\t// Checking for valid nodes\\n                if(newr>=0 and newr<n and newc>=0 and newc<m){\\n\\t\\t\\t\\t\\tint pathSum=val+grid[newr][newc];\\n                    if(pathSum<vis[newr][newc]){\\n                        vis[newr][newc]=pathSum;\\n                        pq.push({pathSum,{newr,newc}});\\n                    }\\n                }\\n            }\\n        }\\n        \\n        return 0;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "C",
                    "Greedy",
                    "Breadth-First Search",
                    "Heap (Priority Queue)"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int minPathSum(vector<vector<int>>& grid) {\\n        int n = grid.size();\\n        int m = grid[0].size();\\n        vector<vector<int>> vis(n,vector<int>(m,1e9));\\n        typedef pair<int,pair<int,int>> pi;\\n        priority_queue<pi,vector<pi>,greater<pi>> pq;\\n\\t\\tint pathSum0 = grid[0][0];\\n        pq.push({pathSum0,{0,0}});\\n        \\n        int delr[] = {1,0};\\n        int delc[] = {0,1};\\n        \\n        while(!pq.empty()){\\n            int val = pq.top().first;\\n            int row = pq.top().second.first;\\n            int col = pq.top().second.second;\\n            pq.pop();\\n            \\n\\t\\t\\t// Destination Node\\n            if(row==n-1 and col==m-1) return val;\\n            \\n\\t\\t\\t// checking for adjacent possible node\\n            for(int i=0;i<2;i++){\\n                int newr = row+delr[i];\\n                int newc = col+delc[i];\\n                \\n\\t\\t\\t\\t// Checking for valid nodes\\n                if(newr>=0 and newr<n and newc>=0 and newc<m){\\n\\t\\t\\t\\t\\tint pathSum=val+grid[newr][newc];\\n                    if(pathSum<vis[newr][newc]){\\n                        vis[newr][newc]=pathSum;\\n                        pq.push({pathSum,{newr,newc}});\\n                    }\\n                }\\n            }\\n        }\\n        \\n        return 0;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3345844,
                "title": "python-3-7-lines-prefix-array-w-explanation-t-m-95-81",
                "content": "For this discussion, let`grid = [[1,3,1,2],[1,5,1,2],[4,2,1,3]]`(Figure 1 below). The general plan is to overwrite`grid`with a prefix array based on the minimum cost at each cell in`grid`.\\n\\nHere are the steps:\\n\\n1. We start with the first row and first column. Because only down and right moves are permitted, the paths to the [2,0] and [0,3] are straightforward. (Figure 2).\\n\\n2. Finally we iterate through`grid`, updating each cell with the sum of the cell\\'s value and the minimum of the cell above and the cell to the left of it (Figure 3).\\n3. The value at the end cell is returned as the minimum path sum (Figure 4).\\n\\n \\n![Untitled.jpg](https://assets.leetcode.com/users/images/8bf67e06-c194-4b35-9718-a5803e0e843f_1679890563.3292673.jpeg)\\n\\n\\n```\\nclass Solution:\\n    def minPathSum(self, grid: list[list[int]]) -> int:\\n\\n        m, n = len(grid), len(grid[0])\\n        M, N = range(1,m),range(1,n)\\n\\n        for i in N: grid[0][i] += grid[0][i - 1]            #  \\n                                                            # <\\u2013\\u2013 1.\\n        for j in M: grid[j][0] += grid[j - 1][0]            #\\n\\n        for i, j in product(M,N):\\n            grid[i][j] += min(grid[i-1][j], grid[i][j-1])   # <\\u2013\\u2013 2.\\n\\n        return grid[m-1][n-1]                               # <\\u2013\\u2013 3.\\n```\\n[https://leetcode.com/problems/minimum-path-sum/submissions/922719112/](http://)\\n\\n\\nI could be wrong, but I think that time complexity is *O*(*MN*) and space complexity is *O*(1).",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def minPathSum(self, grid: list[list[int]]) -> int:\\n\\n        m, n = len(grid), len(grid[0])\\n        M, N = range(1,m),range(1,n)\\n\\n        for i in N: grid[0][i] += grid[0][i - 1]            #  \\n                                                            # <\\u2013\\u2013 1.\\n        for j in M: grid[j][0] += grid[j - 1][0]            #\\n\\n        for i, j in product(M,N):\\n            grid[i][j] += min(grid[i-1][j], grid[i][j-1])   # <\\u2013\\u2013 2.\\n\\n        return grid[m-1][n-1]                               # <\\u2013\\u2013 3.\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3345625,
                "title": "daily-leetcoding-challenge-march-day-27",
                "content": "This problem is the Daily LeetCoding Challenge for March, Day 27.\n\nFeel free to share anything related to this problem here!\n\nYou can ask questions, discuss what you've learned from this problem, or show off how many days of streak you've made!\n\n---\n\nIf you'd like to share a detailed solution to the problem, please create a new post in the discuss section and provide\n- **Detailed Explanations**: Describe the algorithm you used to solve this problem. Include any insights you used to solve this problem.\n- **Images** that help explain the algorithm.\n- **Language and Code** you used to pass the problem.\n- **Time and Space complexity analysis**.\n\n---\n\n  **📌 Do you want to learn the problem thoroughly?**\n  Read [**⭐  LeetCode Official Solution⭐**](https://leetcode.com/problems/minimum-path-sum/solution) to learn the 3 approaches to the problem with detailed explanations to the algorithms, codes, and complexity analysis.\n  <details>\n  <summary> Spoiler Alert! We'll explain these 4 approaches in the official solution</summary>\n\n  \n**Approach 1:** Brute Force\n\n  \n**Approach 2:** Dynamic Programming 2D\n\n  \n**Approach 3:** Dynamic Programming 1D\n\n  \n**Approach 4:** Dynamic Programming (Without Extra Space)\n\n  \n</details>\n\n\n\nIf you're new to Daily LeetCoding Challenge, [**check out this post**](https://leetcode.com/discuss/general-discussion/655704/)!\n\n\n---\n\n<br>\n\n<p align=\"center\">\n<a href=\"https://leetcode.com/subscribe/?ref=ex_dc\" target=\"_blank\">\n  <img src=\"https://assets.leetcode.com/static_assets/marketing/daily_leetcoding_banner.png\" width=\"560px\" />\n</a>\n</p>\n\n<br>",
                "solutionTags": [],
                "code": "  Read [**⭐  LeetCode Official Solution⭐**](https://leetcode.com/problems/minimum-path-sum/solution) to learn the 3 approaches to the problem with detailed explanations to the algorithms, codes, and complexity analysis.\n**Approach 4:** Dynamic Programming (Without Extra Space)\nIf you're new to Daily LeetCoding Challenge, [**check out this post**](https://leetcode.com/discuss/general-discussion/655704/)!\n<p align=\"center\">\n<a href=\"https://leetcode.com/subscribe/?ref=ex_dc\" target=\"_blank\">\n  <img src=\"https://assets.leetcode.com/static_assets/marketing/daily_leetcoding_banner.png\" width=\"560px\" />",
                "codeTag": "Unknown"
            },
            {
                "id": 3055440,
                "title": "beats-100-most-efficient-solution-c",
                "content": "\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n\\n    int minPathSum(vector<vector<int>>& v) {\\n         int n = v.size(), m= v[0].size();\\n        vector<int>prev(m,0);\\n        for(int i=0;i<n;i++){\\n            vector<int>curr(m,0);\\n            for(int j=0;j<m;j++){\\n                if(i==0 && j==0){\\n                    curr[j] = v[0][0];\\n                }\\n                else{\\n              int up =v[i][j] , left = v[i][j] ;\\n              if(i>0) up += prev[j];\\n\\n              else up += 1e9;\\n\\n        \\t   if(j>0) left += curr[j-1];\\n\\n        \\t   else left += 1e9;\\n        \\t  \\n        \\t    curr[j] = min(up,left) ;\\n            }\\n            }\\n            prev = curr;\\n        }\\n        return prev[m-1];\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n\\n    int minPathSum(vector<vector<int>>& v) {\\n         int n = v.size(), m= v[0].size();\\n        vector<int>prev(m,0);\\n        for(int i=0;i<n;i++){\\n            vector<int>curr(m,0);\\n            for(int j=0;j<m;j++){\\n                if(i==0 && j==0){\\n                    curr[j] = v[0][0];\\n                }\\n                else{\\n              int up =v[i][j] , left = v[i][j] ;\\n              if(i>0) up += prev[j];\\n\\n              else up += 1e9;\\n\\n        \\t   if(j>0) left += curr[j-1];\\n\\n        \\t   else left += 1e9;\\n        \\t  \\n        \\t    curr[j] = min(up,left) ;\\n            }\\n            }\\n            prev = curr;\\n        }\\n        return prev[m-1];\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2810588,
                "title": "accepted-worst-to-most-optimised-approaches-easy-to-understand",
                "content": "# Approach 1: Recursion (TLE)\\n\\nStep 1: Take i and j variable initilaise both as 0, That will be or starting path for given matrix. Call solve fucntion.\\n\\nStep 2: (Base case) check if i and j are last box index then return grid [i][j];\\n\\nStep 3: Take down and right int variable initialize both as INT_MAX\\n* Check if we can jump to right side in our matrix range then check for right path and call same fuction with j+1\\n* Check if we can jump to down side in our matrix range then check for down path and call same fuction with i+1.\\n\\nStep 4: return sum of current grid[i][j] and min of either down or right value.\\n \\n\\n**Time Complexity: O(N * M)**\\n* **Reason:** At max, there will be N*M calls of recursion.\\n\\n**Space Complexity: O((M-1)+(N-1)) + O(N*M)**\\n* **Reason:** We are using a recursion stack space:O((M-1)+(N-1)), here (M-1)+(N-1) is the path length\\n\\n**Recrusive Tree**\\n![MicrosoftTeams-image (69).png](https://assets.leetcode.com/users/images/6a545a74-9c08-4ae1-91f7-47ed1ab11761_1668339452.307515.jpeg)\\n\\n\\n**C++ Code: (TLE)**\\n```\\nclass Solution {\\npublic:\\n    int solve(int i,int j,int n,int m,vector<vector<int>>& grid){\\n        if(i==n-1 and j==m-1) return grid[i][j];\\n\\n        int down=INT_MAX,right=INT_MAX;\\n        if(i+1<n) \\n            down=solve(i+1,j,n,m,grid);\\n        if(j+1<m)\\n            right=solve(i,j+1,n,m,grid);\\n\\n        return grid[i][j]+min(down,right);\\n    }\\n    int minPathSum(vector<vector<int>>& grid) {\\n        int n=grid.size();\\n        int m=grid[0].size();\\n        return solve(0,0,n,m,grid);\\n    }\\n};\\n```\\n\\n**Approach 2: Memoization (Accepted)**\\nwe have see that there are overlapping subproblems in recursive. In order to convert a recursive solution the following steps will be taken:\\n\\n1. Create a dp array of size [n][m]\\n2. Whenever we want to find the answer of a particular row and column (say f(i,j)), we first check whether the answer is already calculated using the dp array(i.e dp[i][j]!= -1 ). If yes, simply return the value from the dp array.\\n3. If not, then we are finding the answer for the given values for the first time, we will use the recursive relation as usual but before returning from the function, we will set dp[i][j] to the solution we get.\\n\\n**Time Complexity: O(N*M)**\\n* **Reason:** At max, there will be N*M calls of recursion.\\n\\n**Space Complexity: O((M-1)+(N-1)) + O(N*M)**\\n* **Reason:** We are using a recursion stack space:O((M-1)+(N-1)), here (M-1)+(N-1) is the path length and an external DP Array of size \\u2018N*M\\u2019\\n\\n**C++ Code (Accepted)**\\n```\\nclass Solution {\\npublic:\\n    int solve(int i,int j,int n,int m,vector<vector<int>>& grid,vector<vector<int>> &dp){\\n        if(i==n-1 and j==m-1) return grid[i][j];\\n        if(dp[i][j]!=-1) return dp[i][j];\\n        int down=INT_MAX,right=INT_MAX;\\n        \\n        if(i+1<n) \\n            down=solve(i+1,j,n,m,grid,dp);\\n        if(j+1<m)\\n            right=solve(i,j+1,n,m,grid,dp);\\n\\n        return dp[i][j]=grid[i][j]+min(down,right);\\n    }\\n    int minPathSum(vector<vector<int>>& grid) {\\n        int n=grid.size();\\n        int m=grid[0].size();\\n        vector<vector<int>> dp(n+1,vector<int>(m+1,-1));\\n        return solve(0,0,n,m,grid,dp);\\n    }\\n};\\n```\\n\\n**Approach 3: Tabulation (Accepted)**\\nTabulation is the bottom-up approach, which means we will go from the base case to the main problem.\\n\\nThe steps to convert to the tabular solution are given below:\\n\\n1. Declare a dp[] array of size [n][m].\\n2. First initialize the base condition values, i.e dp[n-1][m-1] = matrix[n-1][m-1]\\n3. Our answer should get stored in dp[0][0]. We want to move from (n-1,m-1) to (0,0). But we can\\u2019t move arbitrarily, we should move such that at a particular i and j, we have all the values required to compute dp[i][j].\\n4. If we see the memoized code, values required for dp[i][j] are: dp[i+1][j] and dp[i][j+1]. So we only use the next row and column value.\\n5. We have already filled the bottom-right corner (i=n-1 and j=m-1), if we move in any of the two following ways(given below), at every cell we do have all the previous values required to compute its value.\\n5. We can use two nested loops to have this traversal\\n6. Whenever i<n , j<n, we will simply mark dp[i][j] = matric[i][j] + min(dp[i+1][j],dp[i][j+1]), according to our recursive relation.\\n7. When i=n or j=m, we add to down OR right as INT_MAX, so that this path can be rejected.\\n\\n**Time Complexity: O(N*M)**\\n- **Reason:** There are two nested loops\\n\\n**Space Complexity: O(N*M)**\\n- **Reason:** We are using an external array of size \\u2018N*M\\u2019\\u2019.\\n\\n**Paper Dry run:**\\n![MicrosoftTeams-image (67).png](https://assets.leetcode.com/users/images/5645c7e7-bdd7-464a-8595-42391ac8c27c_1668338853.526015.jpeg)\\n\\n\\n**C++ Code:**\\n```\\nclass Solution {\\npublic:\\n    int minPathSum(vector<vector<int>>& grid) {\\n        int n=grid.size();\\n        int m=grid[0].size();\\n        vector<vector<int>> dp(n+1,vector<int>(m+1,0));\\n        for(int i=n-1;i>=0;i--){\\n            for(int j=m-1;j>=0;j--){\\n                if(i==n-1 and j==m-1){\\n                    dp[i][j]=grid[i][j];\\n                }else{\\n                    int down=INT_MAX,right=INT_MAX;\\n                    if(i+1<n)\\n                        down=dp[i+1][j];\\n                    if(j+1<m)\\n                        right=dp[i][j+1];\\n                    dp[i][j]=grid[i][j]+min(down,right);\\n                }\\n            }\\n        }\\n        return dp[0][0];\\n    }\\n};\\n```\\n\\n**Approach 4: Space optimised (Accepted most Optimised)**\\nIf we closely look the relation,\\n- dp[i][j] = grid[i][j] + min(dp[i+1][j] + dp[i][j+1]))\\n\\nWe see that we only need the next row and column, in order to calculate dp[i][j]. Therefore we can space optimize it.\\n\\n1. Initially, we can take a dummy row ( say prevRow) and initialize it as 0.\\n2. Now the current row(say CurrRow) only needs the next row value and the current row\\u2019s value in order to calculate dp[i][j].\\n\\n![MicrosoftTeams-image (68).png](https://assets.leetcode.com/users/images/b2caf957-e9d4-4a87-bc3b-75e66d420245_1668339394.1703806.jpeg)\\n\\n3. At the next step, the currRow array becomes the prevRow of the next step and using its values we can still calculate the next row\\u2019s values.\\n4. At last prevRow[0] will give us the required answer.\\n\\n**Time Complexity: O(M*N)**\\n- **Reason:** There are two nested loops\\n\\n**Space Complexity: O(N)**\\n- **Reason:** We are using an external array of size \\u2018N\\u2019 to store only one row.\\n\\n**C++ Code**\\n```\\nclass Solution {\\npublic:\\n    int minPathSum(vector<vector<int>>& grid) {\\n        int n=grid.size();\\n        int m=grid[0].size();\\n        vector<int> prevRow(m+1,0);\\n        \\n        for(int i=n-1;i>=0;i--){\\n            vector<int> currRow(m+1,0);\\n            for(int j=m-1;j>=0;j--){\\n                if(i==n-1 and j==m-1){\\n                    currRow[j]=grid[i][j];\\n                }else{\\n                    int down=INT_MAX,right=INT_MAX;\\n                    if(i+1<n)\\n                        down=prevRow[j];\\n                    if(j+1<m)\\n                        right=currRow[j+1];\\n                    currRow[j]=grid[i][j]+min(down,right);\\n                }\\n            }\\n            prevRow=currRow;\\n        }\\n        \\n        return prevRow[0];\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Hash Table",
                    "Dynamic Programming",
                    "Memoization"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int solve(int i,int j,int n,int m,vector<vector<int>>& grid){\\n        if(i==n-1 and j==m-1) return grid[i][j];\\n\\n        int down=INT_MAX,right=INT_MAX;\\n        if(i+1<n) \\n            down=solve(i+1,j,n,m,grid);\\n        if(j+1<m)\\n            right=solve(i,j+1,n,m,grid);\\n\\n        return grid[i][j]+min(down,right);\\n    }\\n    int minPathSum(vector<vector<int>>& grid) {\\n        int n=grid.size();\\n        int m=grid[0].size();\\n        return solve(0,0,n,m,grid);\\n    }\\n};\\n```\n```\\nclass Solution {\\npublic:\\n    int solve(int i,int j,int n,int m,vector<vector<int>>& grid,vector<vector<int>> &dp){\\n        if(i==n-1 and j==m-1) return grid[i][j];\\n        if(dp[i][j]!=-1) return dp[i][j];\\n        int down=INT_MAX,right=INT_MAX;\\n        \\n        if(i+1<n) \\n            down=solve(i+1,j,n,m,grid,dp);\\n        if(j+1<m)\\n            right=solve(i,j+1,n,m,grid,dp);\\n\\n        return dp[i][j]=grid[i][j]+min(down,right);\\n    }\\n    int minPathSum(vector<vector<int>>& grid) {\\n        int n=grid.size();\\n        int m=grid[0].size();\\n        vector<vector<int>> dp(n+1,vector<int>(m+1,-1));\\n        return solve(0,0,n,m,grid,dp);\\n    }\\n};\\n```\n```\\nclass Solution {\\npublic:\\n    int minPathSum(vector<vector<int>>& grid) {\\n        int n=grid.size();\\n        int m=grid[0].size();\\n        vector<vector<int>> dp(n+1,vector<int>(m+1,0));\\n        for(int i=n-1;i>=0;i--){\\n            for(int j=m-1;j>=0;j--){\\n                if(i==n-1 and j==m-1){\\n                    dp[i][j]=grid[i][j];\\n                }else{\\n                    int down=INT_MAX,right=INT_MAX;\\n                    if(i+1<n)\\n                        down=dp[i+1][j];\\n                    if(j+1<m)\\n                        right=dp[i][j+1];\\n                    dp[i][j]=grid[i][j]+min(down,right);\\n                }\\n            }\\n        }\\n        return dp[0][0];\\n    }\\n};\\n```\n```\\nclass Solution {\\npublic:\\n    int minPathSum(vector<vector<int>>& grid) {\\n        int n=grid.size();\\n        int m=grid[0].size();\\n        vector<int> prevRow(m+1,0);\\n        \\n        for(int i=n-1;i>=0;i--){\\n            vector<int> currRow(m+1,0);\\n            for(int j=m-1;j>=0;j--){\\n                if(i==n-1 and j==m-1){\\n                    currRow[j]=grid[i][j];\\n                }else{\\n                    int down=INT_MAX,right=INT_MAX;\\n                    if(i+1<n)\\n                        down=prevRow[j];\\n                    if(j+1<m)\\n                        right=currRow[j+1];\\n                    currRow[j]=grid[i][j]+min(down,right);\\n                }\\n            }\\n            prevRow=currRow;\\n        }\\n        \\n        return prevRow[0];\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2693577,
                "title": "c-easy-fast-dp-solution",
                "content": "```\\nclass Solution {\\npublic:\\n    int getmin(int i, int j, vector<vector<int>> &dp, int x)\\n    {        \\n        if(i==0 and j==0) return x;\\n        int n = dp.size(), m = dp[0].size();\\n        \\n        if(i==0) return dp[i][j-1] + x;\\n        if(j==0) return dp[i-1][j] + x;\\n        return min(dp[i-1][j], dp[i][j-1]) + x;\\n    }\\n    \\n    int minPathSum(vector<vector<int>>& grid) {\\n        int n = grid.size(), m = grid[0].size();\\n        vector<vector<int>> dp(n, vector<int> (m, 0));\\n        \\n        dp[0][0] = grid[0][0];\\n        \\n        for (int i = 0;i<n;i++)\\n        {\\n            for(int j = 0;j<m;j++)\\n            {\\n                dp[i][j] = getmin(i,j, dp, grid[i][j]);\\n            }\\n        }\\n        return dp[n-1][m-1];\\n    }\\n};\\n```\\n**UPVOTE**",
                "solutionTags": [
                    "C",
                    "Dynamic Programming"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int getmin(int i, int j, vector<vector<int>> &dp, int x)\\n    {        \\n        if(i==0 and j==0) return x;\\n        int n = dp.size(), m = dp[0].size();\\n        \\n        if(i==0) return dp[i][j-1] + x;\\n        if(j==0) return dp[i-1][j] + x;\\n        return min(dp[i-1][j], dp[i][j-1]) + x;\\n    }\\n    \\n    int minPathSum(vector<vector<int>>& grid) {\\n        int n = grid.size(), m = grid[0].size();\\n        vector<vector<int>> dp(n, vector<int> (m, 0));\\n        \\n        dp[0][0] = grid[0][0];\\n        \\n        for (int i = 0;i<n;i++)\\n        {\\n            for(int j = 0;j<m;j++)\\n            {\\n                dp[i][j] = getmin(i,j, dp, grid[i][j]);\\n            }\\n        }\\n        return dp[n-1][m-1];\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2693571,
                "title": "c-easy-and-fast-dp-solution",
                "content": "```\\nclass Solution {\\npublic:\\n    int getmin(int i, int j, vector<vector<int>> &dp, int x)\\n    {        \\n        if(i==0 and j==0) return x;\\n        int n = dp.size(), m = dp[0].size();\\n        \\n        if(i==0) return dp[i][j-1] + x;\\n        if(j==0) return dp[i-1][j] + x;\\n        return min(dp[i-1][j], dp[i][j-1]) + x;\\n    }\\n    \\n    int minPathSum(vector<vector<int>>& grid) {\\n        int n = grid.size(), m = grid[0].size();\\n        vector<vector<int>> dp(n, vector<int> (m, 0));\\n        \\n        dp[0][0] = grid[0][0];\\n        \\n        for (int i = 0;i<n;i++)\\n        {\\n            for(int j = 0;j<m;j++)\\n            {\\n                dp[i][j] = getmin(i,j, dp, grid[i][j]);\\n            }\\n        }\\n        return dp[n-1][m-1];\\n    }\\n};\\n```\\n**UPVOTE**",
                "solutionTags": [
                    "C",
                    "Dynamic Programming"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int getmin(int i, int j, vector<vector<int>> &dp, int x)\\n    {        \\n        if(i==0 and j==0) return x;\\n        int n = dp.size(), m = dp[0].size();\\n        \\n        if(i==0) return dp[i][j-1] + x;\\n        if(j==0) return dp[i-1][j] + x;\\n        return min(dp[i-1][j], dp[i][j-1]) + x;\\n    }\\n    \\n    int minPathSum(vector<vector<int>>& grid) {\\n        int n = grid.size(), m = grid[0].size();\\n        vector<vector<int>> dp(n, vector<int> (m, 0));\\n        \\n        dp[0][0] = grid[0][0];\\n        \\n        for (int i = 0;i<n;i++)\\n        {\\n            for(int j = 0;j<m;j++)\\n            {\\n                dp[i][j] = getmin(i,j, dp, grid[i][j]);\\n            }\\n        }\\n        return dp[n-1][m-1];\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1766321,
                "title": "c-3-solutions-recursive-memoization-tabulation",
                "content": "**1. Recursion**\\n```\\nint calculate(int row, int col, vector<vector<int>> &grid) {\\n    if(row == 0 && col == 0) \\n        return grid[0][0];\\n    if(row < 0 || col < 0)\\n        return 101;\\n    int left = calculate(row, col - 1, grid) + grid[row][col];\\n    int up = calculate(row - 1, col, grid) + grid[row][col];\\n    return min(left, up);\\n}\\n\\nint minPathSum(vector<vector<int>>& grid) {\\n    int row = grid.size(), col = grid[0].size();\\n    return calculate(row - 1, col - 1, grid);\\n}\\n```\\n\\n**2. Memoization**\\n```\\nint calculate(int row, int col, vector<vector<int>> &grid, vector<vector<int>> &dp) {\\n    if(row == 0 && col == 0) \\n        return grid[0][0];\\n    if(row < 0 || col < 0)\\n        return INT_MAX;\\n    if(dp[row][col] != -1)\\n        return dp[row][col];\\n    \\n    int left = calculate(row, col - 1, grid, dp);\\n    int up = calculate(row - 1, col, grid, dp);\\n    return dp[row][col] = min(left, up) + grid[row][col];\\n}\\n\\nint minPathSum(vector<vector<int>>& grid) {\\n    int row = grid.size(), col = grid[0].size();\\n    vector<vector<int>> dp(row, vector<int> (col, -1));\\n    return calculate(row - 1, col - 1, grid, dp);\\n}\\n```\\n\\n**3. Tabulation**\\n```\\nint minPathSum(vector<vector<int>>& grid) {\\n    int row = grid.size(), col = grid[0].size();\\n    vector<vector<int>> dp(row, vector<int> (col, -1));\\n    \\n    for(int i = 0; i < row; i++) {\\n        for(int j = 0; j < col; j++) {\\n            if(i == 0 && j == 0) dp[i][j] = grid[i][j];\\n            else {\\n                int left = INT_MAX, up = INT_MAX;\\n                if(i > 0) up = min(up, dp[i - 1][j]);\\n                if(j > 0) left = min(left, dp[i][j - 1]);\\n                \\n                dp[i][j] = min(up, left) + grid[i][j];\\n            }\\n        }\\n    }\\n    return dp[row - 1][col - 1];\\n}\\n```",
                "solutionTags": [
                    "Dynamic Programming",
                    "Recursion",
                    "Memoization"
                ],
                "code": "```\\nint calculate(int row, int col, vector<vector<int>> &grid) {\\n    if(row == 0 && col == 0) \\n        return grid[0][0];\\n    if(row < 0 || col < 0)\\n        return 101;\\n    int left = calculate(row, col - 1, grid) + grid[row][col];\\n    int up = calculate(row - 1, col, grid) + grid[row][col];\\n    return min(left, up);\\n}\\n\\nint minPathSum(vector<vector<int>>& grid) {\\n    int row = grid.size(), col = grid[0].size();\\n    return calculate(row - 1, col - 1, grid);\\n}\\n```\n```\\nint calculate(int row, int col, vector<vector<int>> &grid, vector<vector<int>> &dp) {\\n    if(row == 0 && col == 0) \\n        return grid[0][0];\\n    if(row < 0 || col < 0)\\n        return INT_MAX;\\n    if(dp[row][col] != -1)\\n        return dp[row][col];\\n    \\n    int left = calculate(row, col - 1, grid, dp);\\n    int up = calculate(row - 1, col, grid, dp);\\n    return dp[row][col] = min(left, up) + grid[row][col];\\n}\\n\\nint minPathSum(vector<vector<int>>& grid) {\\n    int row = grid.size(), col = grid[0].size();\\n    vector<vector<int>> dp(row, vector<int> (col, -1));\\n    return calculate(row - 1, col - 1, grid, dp);\\n}\\n```\n```\\nint minPathSum(vector<vector<int>>& grid) {\\n    int row = grid.size(), col = grid[0].size();\\n    vector<vector<int>> dp(row, vector<int> (col, -1));\\n    \\n    for(int i = 0; i < row; i++) {\\n        for(int j = 0; j < col; j++) {\\n            if(i == 0 && j == 0) dp[i][j] = grid[i][j];\\n            else {\\n                int left = INT_MAX, up = INT_MAX;\\n                if(i > 0) up = min(up, dp[i - 1][j]);\\n                if(j > 0) left = min(left, dp[i][j - 1]);\\n                \\n                dp[i][j] = min(up, left) + grid[i][j];\\n            }\\n        }\\n    }\\n    return dp[row - 1][col - 1];\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1401676,
                "title": "c-dp-space-o-1-time-o-m-n",
                "content": "Please upvote if it was helpful.\\n\\t\\n\\tclass Solution {\\n\\tpublic:\\n\\t\\tint minPathSum(vector<vector<int>>& grid) {\\n\\t\\t\\tint m = grid.size(), n = grid[0].size();\\n\\t\\t\\tfor(int i=1; i<m; i++){\\n\\t\\t\\t\\tgrid[i][0] += grid[i-1][0];\\n\\t\\t\\t}\\n\\t\\t\\tfor(int j=1; j<n; j++){\\n\\t\\t\\t\\tgrid[0][j] += grid[0][j-1];\\n\\t\\t\\t}\\n\\t\\t\\tfor(int i=1; i<m; i++){\\n\\t\\t\\t\\tfor(int j=1; j<n; j++){\\n\\t\\t\\t\\t\\tgrid[i][j] += min(grid[i-1][j], grid[i][j-1]);\\n\\t\\t\\t\\t}\\n\\t\\t\\t}\\n\\t\\t\\treturn grid[m-1][n-1];\\n\\t\\t}\\n\\t};\\nThank You!!",
                "solutionTags": [],
                "code": "class Solution {\\n\\tpublic:\\n\\t\\tint minPathSum(vector<vector<int>>& grid) {\\n\\t\\t\\tint m = grid.size(), n = grid[0].size();\\n\\t\\t\\tfor(int i=1; i<m; i++){\\n\\t\\t\\t\\tgrid[i][0] += grid[i-1][0];\\n\\t\\t\\t}",
                "codeTag": "Java"
            },
            {
                "id": 1361958,
                "title": "c-solution-for-64-minimum-path-sum-using-dp",
                "content": "```\\nclass Solution {\\npublic:\\n    int minPathSum(vector<vector<int>>& grid) \\n    {   \\n        int m = grid.size(); int n = grid[0].size();\\n        vector<vector<long long>> dp(m,vector<long long>(n));\\n\\n        for(int i=0; i<m; i++)\\n        {\\n            for(int j=0; j<n; j++)\\n            {\\n                if(i==0 && j==0){ dp[0][0] = grid[0][0]; }\\n                else if(i==0){ dp[0][j] = dp[0][j-1] + grid[0][j]; }\\n                else if(j==0){ dp[i][0] = dp[i-1][0] + grid[i][0]; }\\n                else\\n                {\\n                    dp[i][j] = min(dp[i-1][j], dp[i][j-1]) + grid[i][j] ; \\n                }\\n            }\\n        }\\n        return dp[m-1][n-1];    \\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "C",
                    "Dynamic Programming"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int minPathSum(vector<vector<int>>& grid) \\n    {   \\n        int m = grid.size(); int n = grid[0].size();\\n        vector<vector<long long>> dp(m,vector<long long>(n));\\n\\n        for(int i=0; i<m; i++)\\n        {\\n            for(int j=0; j<n; j++)\\n            {\\n                if(i==0 && j==0){ dp[0][0] = grid[0][0]; }\\n                else if(i==0){ dp[0][j] = dp[0][j-1] + grid[0][j]; }\\n                else if(j==0){ dp[i][0] = dp[i-1][0] + grid[i][0]; }\\n                else\\n                {\\n                    dp[i][j] = min(dp[i-1][j], dp[i][j-1]) + grid[i][j] ; \\n                }\\n            }\\n        }\\n        return dp[m-1][n-1];    \\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1231754,
                "title": "c-dynamic-programming-short-and-easy-approach",
                "content": "class Solution {\\npublic:\\n**The idea is to traverse from right to left (starting from bottom to top).\\nEach cell of the dp will contain cost to reach the end cell.**\\n\\n\\n    int minPathSum(vector<vector<int>>& grid) {\\n        int row=grid.size();\\n        int col=grid[0].size();\\n        int dp[row][col];\\n        for(int i=row-1;i>=0;i--){\\n            for(int j=col-1 ; j>=0 ; j--){\\n                if(i==row-1 and j==col-1){ //means we are at end cell\\n                    dp[i][j]=grid[i][j];\\n                }\\n                else if(i==row-1){  //means we are at last row\\n                    dp[i][j]=grid[i][j]+dp[i][j+1];\\n                }\\n                else if(j==col-1){ //means we are at last col\\n                    dp[i][j]=grid[i][j]+dp[i+1][j];\\n                }\\n                else{  //rest of the cell\\n                    dp[i][j] = grid[i][j] + min(dp[i+1][j],dp[i][j+1]);\\n                }\\n                \\n            }\\n        }\\n        return dp[0][0];\\n    }\\n};",
                "solutionTags": [
                    "C",
                    "Dynamic Programming"
                ],
                "code": "class Solution {\\npublic:\\n**The idea is to traverse from right to left (starting from bottom to top).\\nEach cell of the dp will contain cost to reach the end cell.**\\n\\n\\n    int minPathSum(vector<vector<int>>& grid) {\\n        int row=grid.size();\\n        int col=grid[0].size();\\n        int dp[row][col];\\n        for(int i=row-1;i>=0;i--){\\n            for(int j=col-1 ; j>=0 ; j--){\\n                if(i==row-1 and j==col-1){ //means we are at end cell\\n                    dp[i][j]=grid[i][j];\\n                }",
                "codeTag": "Java"
            },
            {
                "id": 1111685,
                "title": "c-dp-minimum-path-sum",
                "content": "```int n=grid.size();\\n        int m=grid[0].size();\\n        int dp[n][m];\\n        dp[n-1][m-1]=grid[n-1][m-1];\\n        for(int i=m-2;i>=0;i--){\\n            dp[n-1][i]=grid[n-1][i]+dp[n-1][i+1];\\n        }\\n        for(int i=n-2;i>=0;i--){\\n            dp[i][m-1]=grid[i][m-1]+dp[i+1][m-1];\\n        }\\n        for(int i=n-2;i>=0;i--){\\n            for(int j=m-2;j>=0;j--){\\n                dp[i][j]=grid[i][j]+min(dp[i+1][j],dp[i][j+1]);\\n            }\\n        }\\n        return dp[0][0];```",
                "solutionTags": [
                    "C",
                    "Math",
                    "Dynamic Programming",
                    "Matrix"
                ],
                "code": "```int n=grid.size();\\n        int m=grid[0].size();\\n        int dp[n][m];\\n        dp[n-1][m-1]=grid[n-1][m-1];\\n        for(int i=m-2;i>=0;i--){\\n            dp[n-1][i]=grid[n-1][i]+dp[n-1][i+1];\\n        }\\n        for(int i=n-2;i>=0;i--){\\n            dp[i][m-1]=grid[i][m-1]+dp[i+1][m-1];\\n        }\\n        for(int i=n-2;i>=0;i--){\\n            for(int j=m-2;j>=0;j--){\\n                dp[i][j]=grid[i][j]+min(dp[i+1][j],dp[i][j+1]);\\n            }\\n        }\\n        return dp[0][0];```",
                "codeTag": "Unknown"
            },
            {
                "id": 652173,
                "title": "python-dp",
                "content": "Python version:\\n\\n``` \\nclass Solution:\\n    def minPathSum(self, grid: List[List[int]]) -> int:\\n    \\n        n = len(grid)\\n        m = len(grid[0])\\n       \\n        # Edit the first row:\\n        for i in range(1, m):\\n            grid[0][i] = grid[0][i-1] + grid[0][i]\\n        \\n        # Edit the first col:\\n        for i in range(1, n):\\n            grid[i][0] = grid[i-1][0] + grid[i][0]\\n        \\n        # Edit the remaining values in the grid accordingly!\\n        for i in range(1, n):\\n            for j in range(1, m):\\n                grid[i][j] = min(grid[i-1][j], grid[i][j-1]) + grid[i][j]\\n        \\n        \\n        return grid[-1][-1]\\n```",
                "solutionTags": [],
                "code": "``` \\nclass Solution:\\n    def minPathSum(self, grid: List[List[int]]) -> int:\\n    \\n        n = len(grid)\\n        m = len(grid[0])\\n       \\n        # Edit the first row:\\n        for i in range(1, m):\\n            grid[0][i] = grid[0][i-1] + grid[0][i]\\n        \\n        # Edit the first col:\\n        for i in range(1, n):\\n            grid[i][0] = grid[i-1][0] + grid[i][0]\\n        \\n        # Edit the remaining values in the grid accordingly!\\n        for i in range(1, n):\\n            for j in range(1, m):\\n                grid[i][j] = min(grid[i-1][j], grid[i][j-1]) + grid[i][j]\\n        \\n        \\n        return grid[-1][-1]\\n```",
                "codeTag": "Java"
            },
            {
                "id": 645575,
                "title": "all-possible-solution-with-c-code-brute-force-memoization-and-bottom-up",
                "content": "***Brute Force***\\n```\\nint findMinSumInGrid(vector<vector<int>>& grid,int row,int col,int currRow,int currCol){\\n    \\n    if(currRow == row-1 && currCol == col-1){\\n        return grid[currRow][currCol];\\n    }\\n    \\n    if(currRow >= row || currCol >= col){\\n        return INT_MAX;\\n    }\\n    \\n    return grid[currRow][currCol] + min(findMinSumInGrid(grid,row,col,currRow,currCol+1),findMinSumInGrid(grid,row,col,currRow+1,currCol));\\n\\n}\\n\\nclass Solution {\\npublic:\\n    int minPathSum(vector<vector<int>>& grid) {\\n        //assumin that a path to reach the end point always exist\\n        //INT_MAX is not present as any value\\n        //if present we will be using long long instead of int\\n        int row = grid.size();\\n        if(row == 0)    return 0;\\n        int col = grid[0].size();\\n        \\n        return findMinSumInGrid(grid,row,col,0,0);\\n    \\n    }\\n};\\n```\\n\\n***memoization***\\n```\\nint findMinSumInGrid(vector<vector<int>>& grid,int row,int col,int currRow,int currCol,vector<vector<int>>& dp){\\n    \\n    if(currRow == row-1 && currCol == col-1){\\n        return grid[currRow][currCol];\\n    }\\n    \\n    if(currRow >= row || currCol >= col){\\n        return INT_MAX;\\n    }\\n    \\n    if(dp[currRow][currCol] != -1)  return dp[currRow][currCol];\\n    \\n    return dp[currRow][currCol] = grid[currRow][currCol] + min(findMinSumInGrid(grid,row,col,currRow,currCol+1,dp),findMinSumInGrid(grid,row,col,currRow+1,currCol,dp));\\n\\n}\\n\\nclass Solution {\\npublic:\\n    int minPathSum(vector<vector<int>>& grid) {\\n        //assumin that a path to reach the end point always exist\\n        //INT_MAX is not present as any value\\n        //if present we will be using long long instead of int\\n        int row = grid.size();\\n        if(row == 0)    return 0;\\n        int col = grid[0].size();\\n        vector<vector<int>> dp(row,vector<int> (col,-1));\\n        return findMinSumInGrid(grid,row,col,0,0,dp);\\n    \\n    }\\n};\\n```\\n***Bottom up***\\n```\\nclass Solution {\\npublic:\\n    int minPathSum(vector<vector<int>>& grid) {\\n        //bottom up approach for the problem\\n        //space complexity will be O(n*m)\\n        int row = grid.size();\\n        if(row == 0)    return 0;\\n        int col = grid[0].size();\\n        \\n        vector<vector<int>> dp(row,vector<int> (col,0));\\n        \\n        \\n        for(int i=0;i<row;i++){\\n            for(int j=0;j<col;j++){\\n                \\n                if(i == 0 && j == 0){\\n                    dp[i][j] = grid[i][j];\\n                }else{\\n                    if(i == 0){\\n                        dp[i][j] = grid[i][j] + dp[i][j-1];\\n                    }else{\\n                        if(j == 0){\\n                            dp[i][j] = grid[i][j] + dp[i-1][j];\\n                        }else{\\n                            dp[i][j] = grid[i][j] + min(dp[i-1][j],dp[i][j-1]);\\n                        }\\n                    }\\n                }\\n                \\n            }\\n        }\\n        \\n        return dp[row-1][col-1];\\n    }\\n};\\n```\\nhope it helps!!",
                "solutionTags": [
                    "C",
                    "Dynamic Programming",
                    "Memoization"
                ],
                "code": "```\\nint findMinSumInGrid(vector<vector<int>>& grid,int row,int col,int currRow,int currCol){\\n    \\n    if(currRow == row-1 && currCol == col-1){\\n        return grid[currRow][currCol];\\n    }\\n    \\n    if(currRow >= row || currCol >= col){\\n        return INT_MAX;\\n    }\\n    \\n    return grid[currRow][currCol] + min(findMinSumInGrid(grid,row,col,currRow,currCol+1),findMinSumInGrid(grid,row,col,currRow+1,currCol));\\n\\n}\\n\\nclass Solution {\\npublic:\\n    int minPathSum(vector<vector<int>>& grid) {\\n        //assumin that a path to reach the end point always exist\\n        //INT_MAX is not present as any value\\n        //if present we will be using long long instead of int\\n        int row = grid.size();\\n        if(row == 0)    return 0;\\n        int col = grid[0].size();\\n        \\n        return findMinSumInGrid(grid,row,col,0,0);\\n    \\n    }\\n};\\n```\n```\\nint findMinSumInGrid(vector<vector<int>>& grid,int row,int col,int currRow,int currCol,vector<vector<int>>& dp){\\n    \\n    if(currRow == row-1 && currCol == col-1){\\n        return grid[currRow][currCol];\\n    }\\n    \\n    if(currRow >= row || currCol >= col){\\n        return INT_MAX;\\n    }\\n    \\n    if(dp[currRow][currCol] != -1)  return dp[currRow][currCol];\\n    \\n    return dp[currRow][currCol] = grid[currRow][currCol] + min(findMinSumInGrid(grid,row,col,currRow,currCol+1,dp),findMinSumInGrid(grid,row,col,currRow+1,currCol,dp));\\n\\n}\\n\\nclass Solution {\\npublic:\\n    int minPathSum(vector<vector<int>>& grid) {\\n        //assumin that a path to reach the end point always exist\\n        //INT_MAX is not present as any value\\n        //if present we will be using long long instead of int\\n        int row = grid.size();\\n        if(row == 0)    return 0;\\n        int col = grid[0].size();\\n        vector<vector<int>> dp(row,vector<int> (col,-1));\\n        return findMinSumInGrid(grid,row,col,0,0,dp);\\n    \\n    }\\n};\\n```\n```\\nclass Solution {\\npublic:\\n    int minPathSum(vector<vector<int>>& grid) {\\n        //bottom up approach for the problem\\n        //space complexity will be O(n*m)\\n        int row = grid.size();\\n        if(row == 0)    return 0;\\n        int col = grid[0].size();\\n        \\n        vector<vector<int>> dp(row,vector<int> (col,0));\\n        \\n        \\n        for(int i=0;i<row;i++){\\n            for(int j=0;j<col;j++){\\n                \\n                if(i == 0 && j == 0){\\n                    dp[i][j] = grid[i][j];\\n                }else{\\n                    if(i == 0){\\n                        dp[i][j] = grid[i][j] + dp[i][j-1];\\n                    }else{\\n                        if(j == 0){\\n                            dp[i][j] = grid[i][j] + dp[i-1][j];\\n                        }else{\\n                            dp[i][j] = grid[i][j] + min(dp[i-1][j],dp[i][j-1]);\\n                        }\\n                    }\\n                }\\n                \\n            }\\n        }\\n        \\n        return dp[row-1][col-1];\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 586683,
                "title": "c-iterative-dp",
                "content": "```\\n/*I\\'m going to solve it by iterative dynamic programming\\n\\nfor iterative DP base cases shuld be filled \\n\\nbase cases are in this problem is that you can fill first row and first column the reson behind it is that you don\\'t have multiple path to reach there\\n\\nso for sample test case dp array would be look like\\n\\n1 4 5 (1,1+3,1+3+1)\\n2 \\n6\\n(\\n1,\\n1+1,\\n1+1+4\\n)\\n\\nnow iteratively I\\'m going to fell other enteries if I want to fill dp[i][j] it is obvious that i reach i,j from i-1,j or i,j-1 so I will take min of them and add it into grid[i][j]\\n\\n1 4 5\\n2 7\\n6\\n\\n1 4 5\\n2 7 6\\n6\\n\\n1 4 5\\n2 7 6\\n6 8 \\n\\n1 4 5\\n2 7 6\\n6 8 7\\n\\n7 is answer\\n\\n*/\\nclass Solution {\\npublic:\\n    int minPathSum(vector<vector<int>>& grid) {\\n        int m=grid.size();\\n        int n=grid[0].size();\\n        int** dp=new int*[m];\\n        for(int i=0;i<m;i++){\\n            dp[i]=new int[n];\\n        }\\n        dp[0][0]=grid[0][0];\\n        for(int i=1;i<n;i++){\\n            dp[0][i]=dp[0][i-1]+grid[0][i];\\n        }\\n        for(int i=1;i<m;i++){\\n            dp[i][0]=dp[i-1][0]+grid[i][0];\\n        }\\n        for(int i=1;i<m;i++){\\n            for(int j=1;j<n;j++){\\n                dp[i][j]=min(dp[i-1][j],dp[i][j-1])+grid[i][j];\\n            }\\n        }\\n        int ans=dp[m-1][n-1];\\n        for(int i=0;i<grid.size();i++){\\n            delete[] dp[i];\\n        }\\n        delete[] dp;\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\n/*I\\'m going to solve it by iterative dynamic programming\\n\\nfor iterative DP base cases shuld be filled \\n\\nbase cases are in this problem is that you can fill first row and first column the reson behind it is that you don\\'t have multiple path to reach there\\n\\nso for sample test case dp array would be look like\\n\\n1 4 5 (1,1+3,1+3+1)\\n2 \\n6\\n(\\n1,\\n1+1,\\n1+1+4\\n)\\n\\nnow iteratively I\\'m going to fell other enteries if I want to fill dp[i][j] it is obvious that i reach i,j from i-1,j or i,j-1 so I will take min of them and add it into grid[i][j]\\n\\n1 4 5\\n2 7\\n6\\n\\n1 4 5\\n2 7 6\\n6\\n\\n1 4 5\\n2 7 6\\n6 8 \\n\\n1 4 5\\n2 7 6\\n6 8 7\\n\\n7 is answer\\n\\n*/\\nclass Solution {\\npublic:\\n    int minPathSum(vector<vector<int>>& grid) {\\n        int m=grid.size();\\n        int n=grid[0].size();\\n        int** dp=new int*[m];\\n        for(int i=0;i<m;i++){\\n            dp[i]=new int[n];\\n        }\\n        dp[0][0]=grid[0][0];\\n        for(int i=1;i<n;i++){\\n            dp[0][i]=dp[0][i-1]+grid[0][i];\\n        }\\n        for(int i=1;i<m;i++){\\n            dp[i][0]=dp[i-1][0]+grid[i][0];\\n        }\\n        for(int i=1;i<m;i++){\\n            for(int j=1;j<n;j++){\\n                dp[i][j]=min(dp[i-1][j],dp[i][j-1])+grid[i][j];\\n            }\\n        }\\n        int ans=dp[m-1][n-1];\\n        for(int i=0;i<grid.size();i++){\\n            delete[] dp[i];\\n        }\\n        delete[] dp;\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 584858,
                "title": "python-straightforward-recursion-with-caching",
                "content": "```\\nclass Solution:\\n    def minPathSum(self, grid: List[List[int]]) -> int:\\n        maxx,maxy = len(grid),len(grid[0])\\n        cache={}\\n        \\n        def mPS(x,y):\\n            if x+1==maxx and y+1==maxy:\\n                return grid[x][y]            \\n            if x+1<maxx and y+1<maxy:\\n                if (x,y) not in cache:\\n                    cache[(x,y)] = grid[x][y]+min(mPS(x+1,y),mPS(x,y+1))\\n            elif x+1<maxx:\\n                if (x,y) not in cache:\\n                    cache[(x,y)] = grid[x][y]+mPS(x+1,y)\\n            elif y+1<maxy:\\n                if (x,y) not in cache:\\n                    cache[(x,y)] = grid[x][y]+mPS(x,y+1)\\n            return cache[(x,y)]\\n            \\n        return mPS(0,0)  \\n```\\n\\nPretty much self explanatory.\\n\\nRecursion ends when we hit the last cell. Otherwise we recursively try cells caching results along the way.\\n",
                "solutionTags": [],
                "code": "```\\nclass Solution:\\n    def minPathSum(self, grid: List[List[int]]) -> int:\\n        maxx,maxy = len(grid),len(grid[0])\\n        cache={}\\n        \\n        def mPS(x,y):\\n            if x+1==maxx and y+1==maxy:\\n                return grid[x][y]            \\n            if x+1<maxx and y+1<maxy:\\n                if (x,y) not in cache:\\n                    cache[(x,y)] = grid[x][y]+min(mPS(x+1,y),mPS(x,y+1))\\n            elif x+1<maxx:\\n                if (x,y) not in cache:\\n                    cache[(x,y)] = grid[x][y]+mPS(x+1,y)\\n            elif y+1<maxy:\\n                if (x,y) not in cache:\\n                    cache[(x,y)] = grid[x][y]+mPS(x,y+1)\\n            return cache[(x,y)]\\n            \\n        return mPS(0,0)  \\n```",
                "codeTag": "Java"
            },
            {
                "id": 574715,
                "title": "java-o-n-in-place-no-recursion-simple-with-explaination",
                "content": "Since we don\\'t have any blocked squares, we can iterate through the entire array of arrays and find the minimum possible ways to reach from everywhere.\\nInstead of using another storage block, here we cumulatively add the values to the next cells and initialize the first row and first columns.\\nFor all the internal cells, we add the minimum value to reach from top or left, whichever is smaller.\\nAt the end, return the last cell which was our destination.\\n\\nThe time complexity is O(n) where n is the number of cells in the matrix. The space complexity is O(1) because no additional space is used.\\n```\\nclass Solution {\\n    public int minPathSum(int[][] grid) {\\n        for(int i = 1; i < grid.length; i++){\\n            grid[i][0] += grid[i-1][0];\\n        }\\n        for(int j = 1; j < grid[0].length; j++){\\n            grid[0][j] += grid[0][j-1];\\n        }\\n        for(int i = 1; i < grid.length; i++){\\n            for(int j = 1; j < grid[0].length; j++){\\n                grid[i][j] += Math.min(grid[i][j-1], grid[i-1][j]);\\n            }\\n        }\\n        return grid[grid.length-1][grid[0].length-1];\\n    }\\n}\\n```\\n\\n**Please upvote the solution if you found it helpful.**",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int minPathSum(int[][] grid) {\\n        for(int i = 1; i < grid.length; i++){\\n            grid[i][0] += grid[i-1][0];\\n        }\\n        for(int j = 1; j < grid[0].length; j++){\\n            grid[0][j] += grid[0][j-1];\\n        }\\n        for(int i = 1; i < grid.length; i++){\\n            for(int j = 1; j < grid[0].length; j++){\\n                grid[i][j] += Math.min(grid[i][j-1], grid[i-1][j]);\\n            }\\n        }\\n        return grid[grid.length-1][grid[0].length-1];\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 321325,
                "title": "java-two-solutions-memorization-and-dp",
                "content": "1. Recursion with memorization\\n```java\\n    public int minPathSum(int[][] grid) {\\n        // boundary check\\n        if (grid == null || grid.length == 0 || grid[0].length == 0) return 0;\\n        \\n        int row = grid.length;\\n        int col = grid[0].length;\\n\\n        // init cache\\n        int[][] cache = new int[row][col];\\n        for (int[] r : cache) Arrays.fill(r, -1);\\n        \\n        // fill cache\\n        cache[0][0] = grid[0][0];\\n        dfs(row - 1, col - 1, grid, cache);\\n\\t\\t\\n\\t\\t// return result\\n        return cache[row - 1][col - 1];\\n    }\\n    \\n    public int dfs(int m, int n, int[][] grid, int[][] cache) {\\n        // reach to edge row or col, just return the max int to get row or col value\\n        if (m < 0 || n < 0) return Integer.MAX_VALUE; \\n\\t\\t// return grid[0][0]\\n        if (m == 0 && n == 0) return grid[m][n]; \\n\\t\\t// recursively compute min value if it\\'s not recorded in cache\\n        if (cache[m][n] == -1) \\n            cache[m][n] = grid[m][n] + Math.min(dfs(m - 1, n, grid, cache), dfs(m, n - 1, grid, cache));\\n        return cache[m][n];\\n    }\\n```\\n\\n2. DP\\n```java\\n    public int minPathSum(int[][] grid) {\\n        if (grid == null || grid.length == 0 || grid[0].length == 0) return 0;\\n\\n        int row = grid.length;\\n        int col = grid[0].length;\\n\\n        // init cache\\n        int[][] cache = new int[row][col];\\n        cache[0][0] = grid[0][0];\\n\\n        // fill first row\\n        for (int i = 1; i < col; i++) {\\n            cache[0][i] = cache[0][i - 1] + grid[0][i];\\n        }\\n\\n        // fill first col\\n        for (int i = 1; i < row; i++) {\\n            cache[i][0] = cache[i - 1][0] + grid[i][0];\\n        }\\n\\n        // fill intermediate grid\\n        for(int i = 1; i < row; i++) {\\n            for (int j = 1; j < col; j++) {\\n                cache[i][j] = grid[i][j] + Math.min(cache[i - 1][j], cache[i][j - 1]);\\n            }\\n        }\\n        return cache[row - 1][col - 1];\\n    }\\n```",
                "solutionTags": [],
                "code": "```java\\n    public int minPathSum(int[][] grid) {\\n        // boundary check\\n        if (grid == null || grid.length == 0 || grid[0].length == 0) return 0;\\n        \\n        int row = grid.length;\\n        int col = grid[0].length;\\n\\n        // init cache\\n        int[][] cache = new int[row][col];\\n        for (int[] r : cache) Arrays.fill(r, -1);\\n        \\n        // fill cache\\n        cache[0][0] = grid[0][0];\\n        dfs(row - 1, col - 1, grid, cache);\\n\\t\\t\\n\\t\\t// return result\\n        return cache[row - 1][col - 1];\\n    }\\n    \\n    public int dfs(int m, int n, int[][] grid, int[][] cache) {\\n        // reach to edge row or col, just return the max int to get row or col value\\n        if (m < 0 || n < 0) return Integer.MAX_VALUE; \\n\\t\\t// return grid[0][0]\\n        if (m == 0 && n == 0) return grid[m][n]; \\n\\t\\t// recursively compute min value if it\\'s not recorded in cache\\n        if (cache[m][n] == -1) \\n            cache[m][n] = grid[m][n] + Math.min(dfs(m - 1, n, grid, cache), dfs(m, n - 1, grid, cache));\\n        return cache[m][n];\\n    }\\n```\n```java\\n    public int minPathSum(int[][] grid) {\\n        if (grid == null || grid.length == 0 || grid[0].length == 0) return 0;\\n\\n        int row = grid.length;\\n        int col = grid[0].length;\\n\\n        // init cache\\n        int[][] cache = new int[row][col];\\n        cache[0][0] = grid[0][0];\\n\\n        // fill first row\\n        for (int i = 1; i < col; i++) {\\n            cache[0][i] = cache[0][i - 1] + grid[0][i];\\n        }\\n\\n        // fill first col\\n        for (int i = 1; i < row; i++) {\\n            cache[i][0] = cache[i - 1][0] + grid[i][0];\\n        }\\n\\n        // fill intermediate grid\\n        for(int i = 1; i < row; i++) {\\n            for (int j = 1; j < col; j++) {\\n                cache[i][j] = grid[i][j] + Math.min(cache[i - 1][j], cache[i][j - 1]);\\n            }\\n        }\\n        return cache[row - 1][col - 1];\\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 185358,
                "title": "easy-recursive-solution-with-memo-java",
                "content": "```\\n    public int minPathSum(int[][] grid) {\\n        int[][] memo = new int[grid.length][grid[0].length];\\n        for(int i = 0; i < memo.length; i++){\\n            Arrays.fill(memo[i],Integer.MAX_VALUE);\\n        }\\n        return dfs(grid,0,0,memo);\\n\\n    }\\n    \\n    private int dfs(int[][] grid,int i, int j, int[][] memo){\\n        if( i < 0 || i >= grid.length || j < 0 || j >= grid[0].length )\\n            return Integer.MAX_VALUE;\\n        else if(memo[i][j] != Integer.MAX_VALUE)\\n            return memo[i][j];\\n        else if(i == grid.length - 1  && j == grid[0].length -1)\\n            return grid[i][j];\\n         else \\n            memo[i][j] = grid[i][j] + Math.min(dfs(grid, i + 1, j,memo),dfs(grid, i, j + 1,memo));\\n        \\n        return memo[i][j];\\n        \\n    }\\n```\\n\\t",
                "solutionTags": [],
                "code": "```\\n    public int minPathSum(int[][] grid) {\\n        int[][] memo = new int[grid.length][grid[0].length];\\n        for(int i = 0; i < memo.length; i++){\\n            Arrays.fill(memo[i],Integer.MAX_VALUE);\\n        }\\n        return dfs(grid,0,0,memo);\\n\\n    }\\n    \\n    private int dfs(int[][] grid,int i, int j, int[][] memo){\\n        if( i < 0 || i >= grid.length || j < 0 || j >= grid[0].length )\\n            return Integer.MAX_VALUE;\\n        else if(memo[i][j] != Integer.MAX_VALUE)\\n            return memo[i][j];\\n        else if(i == grid.length - 1  && j == grid[0].length -1)\\n            return grid[i][j];\\n         else \\n            memo[i][j] = grid[i][j] + Math.min(dfs(grid, i + 1, j,memo),dfs(grid, i, j + 1,memo));\\n        \\n        return memo[i][j];\\n        \\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 23600,
                "title": "share-my-java-solution",
                "content": "    public int minPathSum(int[][] grid) {\\n        if(grid==null||grid.length<1)\\n            return 0;\\n            \\n        int[][] minsum = new int[grid.length][grid[0].length];\\n        //initialize\\n        minsum[0][0] = grid[0][0];\\n        \\n        for(int j=1;j<minsum[0].length;j++){\\n            minsum[0][j] = minsum[0][j-1]+grid[0][j];\\n        }\\n        \\n        for(int i=1;i<minsum.length;i++){\\n            minsum[i][0] = minsum[i-1][0] + grid[i][0];\\n        }\\n        // calculate sum along the path\\n        for(int i = 1;i<minsum.length;i++){\\n            for(int j = 1;j<minsum[0].length;j++){\\n                minsum[i][j] = Math.min(minsum[i-1][j], minsum[i][j-1]) + grid[i][j];\\n            }\\n        }\\n        \\n        return minsum[minsum.length-1][minsum[0].length-1];\\n    }",
                "solutionTags": [
                    "Java",
                    "Dynamic Programming"
                ],
                "code": "    public int minPathSum(int[][] grid) {\\n        if(grid==null||grid.length<1)\\n            return 0;\\n            \\n        int[][] minsum = new int[grid.length][grid[0].length];\\n        //initialize\\n        minsum[0][0] = grid[0][0];\\n        \\n        for(int j=1;j<minsum[0].length;j++){\\n            minsum[0][j] = minsum[0][j-1]+grid[0][j];\\n        }\\n        \\n        for(int i=1;i<minsum.length;i++){\\n            minsum[i][0] = minsum[i-1][0] + grid[i][0];\\n        }\\n        // calculate sum along the path\\n        for(int i = 1;i<minsum.length;i++){\\n            for(int j = 1;j<minsum[0].length;j++){\\n                minsum[i][j] = Math.min(minsum[i-1][j], minsum[i][j-1]) + grid[i][j];\\n            }\\n        }\\n        \\n        return minsum[minsum.length-1][minsum[0].length-1];\\n    }",
                "codeTag": "Unknown"
            },
            {
                "id": 23593,
                "title": "beats-100-with-o-n-space",
                "content": "    class Solution {\\n    public:\\n        int minPathSum(vector<vector<int>>& grid) {\\n            int m = grid.size();\\n            int n = grid[0].size();\\n            vector<int> dp(n);\\n            \\n            dp[0] = grid[0][0];\\n            for (int j = 1; j < n; j++) {   // init\\n                dp[j] = dp[j-1] + grid[0][j];\\n            }\\n            \\n            for (int i = 1; i < m; i++) {\\n                for (int j = 0; j < n; j++) {\\n                    dp[j] = (j == 0 ? dp[j] : min(dp[j], dp[j-1])) + grid[i][j];\\n                }   \\n            }\\n            return dp[n-1];\\n        }\\n    };\\n\\n\\nIn usual provide O(mn) solution first, then try to optimize it. From dp[i][j] = min(dp[i][j-1], dp[i-1][j]) + grid[i][j], you can see it only depends on previous row and current row value, we waste a lot space if use mn space. \\n\\ndp[i][j] is row i, column j; \\ndp[i][j-1] is row i, column j-1; \\ndp[i-1][j] is row i-1, column j;\\n\\nif we just use row to represent dp[i], then it should be \\n\\nrow[j] = min(row[j-1], row[j]) + grid[i][j]; \\n\\nwhy dp[i-1][j] is row[j], because before we set new value for row[j], it saves old value, which is dp[i-1][j].\\n\\nSo the new transition formula is:\\n\\nrow[j] = min(row[j-1], row[j]) + grid[i][j];\\n\\nstill use dp variable to replace row, it is:\\n\\ndp[j] = min(dp[j-1], dp[j]) + grid[i][j];\\n\\nvariable j is from 0 to n, same as before. But the i is not used in two dimension row number, just use iteration number. We need do m-1 iterations, because we don't need do it for first row, which is init value.",
                "solutionTags": [],
                "code": "class Solution {\\n    public:\\n        int minPathSum(vector<vector<int>>& grid) {\\n            int m = grid.size();\\n            int n = grid[0].size();\\n            vector<int> dp(n);\\n            \\n            dp[0] = grid[0][0];\\n            for (int j = 1; j < n; j++) {   // init\\n                dp[j] = dp[j-1] + grid[0][j];\\n            }",
                "codeTag": "Java"
            },
            {
                "id": 23679,
                "title": "python-recursive-solution-with-cache-114ms",
                "content": "    class Solution:\\n        # @param {integer[][]} grid\\n        # @return {integer}\\n        def minPathSum(self, grid):\\n            if not len(grid) or not len(grid[0]):\\n                return 0\\n    \\n            m, n, cache = len(grid) - 1, len(grid[0]) - 1, {}\\n    \\n            return self.findMinSum(grid, m, n, cache)\\n    \\n        def findMinSum(self, grid, m, n, cache):\\n            if (m, n) in cache:\\n                return cache[(m, n)]\\n            elif m < 0 or n < 0:\\n                return float('inf')\\n            elif m == 0 and n == 0:\\n                return grid[0][0]\\n            else:\\n                cache[(m, n)] = grid[m][n] + min(self.findMinSum(grid, m - 1, n, cache), self.findMinSum(grid, m, n - 1, cache))\\n    \\n                return cache[(m, n)]",
                "solutionTags": [
                    "Python",
                    "Dynamic Programming"
                ],
                "code": "class Solution:\\n        # @param {integer[][]}",
                "codeTag": "Java"
            },
            {
                "id": 3988970,
                "title": "easy-dp-solution",
                "content": "\\n# **PLEASE UPVOTE MY SOLUTION IG YOU LIKE IT**\\n# **CONNECT WITH ME**\\n# **[https://www.linkedin.com/in/pratay-nandy-9ba57b229/]()**\\n# **[https://www.instagram.com/pratay_nandy/]()**\\n# Approach\\nThe minPathSum function initializes a 2D vector dp with dimensions n x m+1 and initializes all elements to -1. This dp array will be used to memoize the results of subproblems to avoid redundant calculations.\\n\\nIt calls the solve function with the given grid, the starting indices (n-1, m-1), and the dp array.\\n\\nThe solve function is a recursive function with memoization. It takes the current cell (i, j) in the grid and calculates the minimum path sum from the top-left corner to that cell.\\n\\nIf (i, j) is the top-left corner (i.e., i == 0 and j == 0), it returns the value in that cell because there\\'s only one path to reach that cell.\\n\\nIf (i, j) is out of bounds (i.e., i < 0 or j < 0), it returns a large value (1e9) to indicate that this path is not valid.\\n\\nIf the result for (i, j) is already calculated and stored in the dp array, it returns that result to avoid redundant computation.\\n\\nIf the result for (i, j) is not calculated, it recursively calculates the minimum path sum by considering two possible moves:\\n\\nMoving up (i.e., (i-1, j)) and adding the current cell\\'s value to it.\\nMoving left (i.e., (i, j-1)) and adding the current cell\\'s value to it.\\nIt stores the minimum of these two values in the dp array at position (i, j) and returns that minimum value.\\n\\nFinally, the minPathSum function returns the result obtained by calling solve with the bottom-right corner cell (n-1, m-1).\\n\\nThis approach effectively uses memoization to avoid redundant calculations and finds the minimum path sum efficiently. The result returned by minPathSum is the minimum sum required to reach the bottom-right corner of the grid while moving only right or down.\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:0(M*N)\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:0(M*N)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\nint solve(vector<vector<int>>& grid ,int i,int j,vector<vector<int>>& dp)\\n{\\n    if(i==0 && j==0 )\\n    {\\n        return grid[i][j];\\n    }\\n    if(i<0 || j<0)\\n    {\\n        return 1e9;\\n    } \\n    if(dp[i][j]!=-1)\\n    {\\n        return dp[i][j];\\n    }\\n    int up= grid[i][j]+solve(grid, i-1,j,dp);\\n    int left= grid[i][j]+solve(grid, i,j-1,dp);\\n    return dp[i][j] = min(up,left);\\n\\n}\\n    int minPathSum(vector<vector<int>>& grid) {\\n        int n = grid.size();\\n        int m= grid[0].size(); \\n        vector<vector<int>>dp(n,vector<int>(m+1,-1));\\n        return solve(grid,n-1,m-1,dp);\\n\\n        \\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Array",
                    "Dynamic Programming",
                    "Matrix"
                ],
                "code": "```\\nclass Solution {\\npublic:\\nint solve(vector<vector<int>>& grid ,int i,int j,vector<vector<int>>& dp)\\n{\\n    if(i==0 && j==0 )\\n    {\\n        return grid[i][j];\\n    }\\n    if(i<0 || j<0)\\n    {\\n        return 1e9;\\n    } \\n    if(dp[i][j]!=-1)\\n    {\\n        return dp[i][j];\\n    }\\n    int up= grid[i][j]+solve(grid, i-1,j,dp);\\n    int left= grid[i][j]+solve(grid, i,j-1,dp);\\n    return dp[i][j] = min(up,left);\\n\\n}\\n    int minPathSum(vector<vector<int>>& grid) {\\n        int n = grid.size();\\n        int m= grid[0].size(); \\n        vector<vector<int>>dp(n,vector<int>(m+1,-1));\\n        return solve(grid,n-1,m-1,dp);\\n\\n        \\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3775468,
                "title": "4-steps-of-optimization-naive-recursion-optimization-dp",
                "content": "# 1. Naive Recursive approach (TLE)\\n- **Time complexity: O(mn)**\\n In the worst case, the recursive calls will visit all cells in the grid except the first cell (grid[0][0]). Therefore, the total number of function calls will be (m-1) * (n-1). Each function call performs constant time operations, so the time complexity is O(mn).\\n- **Space complexity: O(m + n)**\\nIn the worst case, the recursive calls will visit all cells in the grid except the first cell (grid[0][0]). Therefore, the maximum depth of recursion will be m + n - 2. Since each recursive call requires constant space, the space complexity is O(m + n).\\n```\\nclass Solution {\\npublic:\\n    int f(vector<vector<int>>& grid, int row, int col){\\n        if(row==1 && col==1) return grid[0][0];\\n        if(row==0 || col==0) return 10001;\\n        int res=grid[row-1][col-1];\\n        int left=f(grid, row, col-1);\\n        int up=f(grid, row-1, col);\\n        return res + min(left, up);\\n    }\\n\\n    int minPathSum(vector<vector<int>>& grid) {\\n        int m=grid.size();\\n        int n=grid[0].size();\\n        return f(grid, m, n);\\n    }\\n};\\n\\n```\\n# 2. Memoization(DP)\\n- Time complexity: O(m*n)\\n- Space complexity: O(m*n)\\n\\n```\\nclass Solution {\\npublic:\\n    int f(vector<vector<int>>& grid, int row, int col, vector<vector<int>>&dp){\\n        if(row==1 && col==1) return grid[0][0];\\n        if(row==0 || col==0) return 10001;\\n        if(dp[row][col]!=-1) return dp[row][col];\\n        int res=grid[row-1][col-1];\\n        int left=f(grid, row, col-1, dp);\\n        int up=f(grid, row-1, col, dp);\\n        return dp[row][col] = res + min(left, up);\\n    }\\n\\n    int minPathSum(vector<vector<int>>& grid) {\\n        int m=grid.size();\\n        int n=grid[0].size();\\n        vector<vector<int>>dp(m+1, vector<int>(n+1, -1));\\n        return f(grid, m, n, dp);\\n    }\\n};\\n\\n```\\n\\n# 3. Tabulation(DP)\\n- Time complexity: O(m*n)\\n- Space complexity: O(m*n)\\n\\n```\\nclass Solution {\\npublic:\\n    int minPathSum(vector<vector<int>>& grid) {\\n        int m=grid.size();\\n        int n=grid[0].size();\\n        vector<vector<int>>dp(m+1, vector<int>(n+1, 40001));\\n        for(int i=1;i<=m;i++){\\n            for(int j=1;j<=n;j++){\\n                if(i==1 && j==1){\\n                    dp[1][1]=grid[0][0];\\n                }\\n                else dp[i][j]=grid[i-1][j-1] + min(dp[i][j-1], dp[i-1][j]);\\n            }\\n        }\\n        return dp[m][n];\\n    }\\n};\\n\\n```\\n\\n# 4. Optimized Space (Best Code)\\n- Time complexity: O(m*n)\\n- Space complexity: O(n)\\n\\n```\\nclass Solution {\\npublic:\\n    int minPathSum(vector<vector<int>>& grid) {\\n        int m=grid.size();\\n        int n=grid[0].size();\\n        vector<int>dp(n+1, 40001);\\n        for(int i=1;i<=m;i++){\\n            for(int j=1;j<=n;j++){\\n                if(i==1 && j==1) dp[1]=grid[0][0];\\n                else dp[j]=grid[i-1][j-1] + min(dp[j-1], dp[j]);\\n            }\\n        }\\n        return dp[n];\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Dynamic Programming",
                    "Recursion"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int f(vector<vector<int>>& grid, int row, int col){\\n        if(row==1 && col==1) return grid[0][0];\\n        if(row==0 || col==0) return 10001;\\n        int res=grid[row-1][col-1];\\n        int left=f(grid, row, col-1);\\n        int up=f(grid, row-1, col);\\n        return res + min(left, up);\\n    }\\n\\n    int minPathSum(vector<vector<int>>& grid) {\\n        int m=grid.size();\\n        int n=grid[0].size();\\n        return f(grid, m, n);\\n    }\\n};\\n\\n```\n```\\nclass Solution {\\npublic:\\n    int f(vector<vector<int>>& grid, int row, int col, vector<vector<int>>&dp){\\n        if(row==1 && col==1) return grid[0][0];\\n        if(row==0 || col==0) return 10001;\\n        if(dp[row][col]!=-1) return dp[row][col];\\n        int res=grid[row-1][col-1];\\n        int left=f(grid, row, col-1, dp);\\n        int up=f(grid, row-1, col, dp);\\n        return dp[row][col] = res + min(left, up);\\n    }\\n\\n    int minPathSum(vector<vector<int>>& grid) {\\n        int m=grid.size();\\n        int n=grid[0].size();\\n        vector<vector<int>>dp(m+1, vector<int>(n+1, -1));\\n        return f(grid, m, n, dp);\\n    }\\n};\\n\\n```\n```\\nclass Solution {\\npublic:\\n    int minPathSum(vector<vector<int>>& grid) {\\n        int m=grid.size();\\n        int n=grid[0].size();\\n        vector<vector<int>>dp(m+1, vector<int>(n+1, 40001));\\n        for(int i=1;i<=m;i++){\\n            for(int j=1;j<=n;j++){\\n                if(i==1 && j==1){\\n                    dp[1][1]=grid[0][0];\\n                }\\n                else dp[i][j]=grid[i-1][j-1] + min(dp[i][j-1], dp[i-1][j]);\\n            }\\n        }\\n        return dp[m][n];\\n    }\\n};\\n\\n```\n```\\nclass Solution {\\npublic:\\n    int minPathSum(vector<vector<int>>& grid) {\\n        int m=grid.size();\\n        int n=grid[0].size();\\n        vector<int>dp(n+1, 40001);\\n        for(int i=1;i<=m;i++){\\n            for(int j=1;j<=n;j++){\\n                if(i==1 && j==1) dp[1]=grid[0][0];\\n                else dp[j]=grid[i-1][j-1] + min(dp[j-1], dp[j]);\\n            }\\n        }\\n        return dp[n];\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3704034,
                "title": "simple-c",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\nint solve(int i,int j,vector<vector<int>>& grid,vector<vector<int>> &dp){\\n    int n=grid.size();\\n    int m=grid[0].size();\\n    if(i==n-1 && j==m-1){\\n        return grid[i][j];\\n\\n    }\\n    if(dp[i][j]!=-1) return dp[i][j];\\n    int r=INT_MAX;\\n    int d=INT_MAX;\\n    if(i+1<n ){\\n        d=solve(i+1,j,grid,dp);\\n    }\\n    if(j+1<m) r=solve(i,j+1,grid,dp);\\n   \\n    return dp[i][j]=grid[i][j]+min(r,d);\\n\\n}\\n    int minPathSum(vector<vector<int>>& grid) {\\n         int n=grid.size();\\n    int m=grid[0].size();\\n        vector<vector<int>> dp(n+1,vector<int>(m+1,-1));\\n        return solve(0,0,grid,dp);\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\nint solve(int i,int j,vector<vector<int>>& grid,vector<vector<int>> &dp){\\n    int n=grid.size();\\n    int m=grid[0].size();\\n    if(i==n-1 && j==m-1){\\n        return grid[i][j];\\n\\n    }\\n    if(dp[i][j]!=-1) return dp[i][j];\\n    int r=INT_MAX;\\n    int d=INT_MAX;\\n    if(i+1<n ){\\n        d=solve(i+1,j,grid,dp);\\n    }\\n    if(j+1<m) r=solve(i,j+1,grid,dp);\\n   \\n    return dp[i][j]=grid[i][j]+min(r,d);\\n\\n}\\n    int minPathSum(vector<vector<int>>& grid) {\\n         int n=grid.size();\\n    int m=grid[0].size();\\n        vector<vector<int>> dp(n+1,vector<int>(m+1,-1));\\n        return solve(0,0,grid,dp);\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3349044,
                "title": "java-memoized-dfs-and-dp-beats-99",
                "content": "# Approach 1: DFS\\nIn DFS we need to traverse all possibilities up to [m-1][n-1] and then compute the minimal path on our way from bottom up.\\nThere will be a lot of duplicated computations, so we need to memoize our dfs at i,j.\\n\\n# Complexity\\n- Time complexity:\\n$$O(m*n)$$\\n\\n- Space complexity:\\n$$O(m*n)$$\\n\\n# Code\\n```\\nclass Solution {\\n    private int[][] memo;\\n    private int[][] grid;\\n    private int m = 0;\\n    private int n = 0;\\n\\n    public int minPathSum(int[][] grid) {\\n        m = grid.length;\\n        n = grid[0].length;\\n        memo = new int[m][n];\\n        this.grid = grid;\\n        for (int[] row: memo) {\\n            Arrays.fill(row, -1);\\n        }\\n        return dfs(0, 0);\\n    }\\n\\n    private int dfs(int i, int j) {\\n        if (i == m || j == n) return Integer.MAX_VALUE;\\n        if (i == m-1 && j == n-1) return grid[i][j];\\n        if (memo[i][j] != -1) return memo[i][j];\\n        memo[i][j] = grid[i][j] + Math.min(\\n            dfs(i+1, j),\\n            dfs(i, j+1)\\n        );\\n        return memo[i][j];\\n    }\\n}\\n```\\n\\n# Approach 2: Dynamic programming\\nThis is a little more complicated and less straightforward as memoized DFS. We need to somehow tell what is the optimal previous path for index i,j. That means we need to memoize the best paths up to [i-1][j] and [i][j-1].\\n\\nThis means that our loop at i,j must do the following:\\n1. get previous at [i-1][j] or Infinity if it doesnt exist\\n2. get previous at [i][j-1] or Infinity\\n3. get minimum of these values (spec case is if they are both infinity, then we need to make them zero, because there is no previous path)\\n4. minPrev + grid[i][j] is our optimal value at i,j\\n5. the minimum in [m-1][n-1] is our answer\\n\\n\\n# Complexity\\n- Time complexity:\\n$$O(m*n)$$\\n\\n- Space complexity:\\n$$O(m*n)$$\\n\\n# Code\\n```\\nclass Solution {\\n    public int minPathSum(int[][] grid) {\\n        int m = grid.length;\\n        int n = grid[0].length;\\n        int[][] memo = new int[m][n];\\n        for (int i = 0; i < m; i++) {\\n            for (int j = 0; j < n; j++) {\\n                int prev = Math.min(\\n                    i > 0 ? memo[i-1][j] : Integer.MAX_VALUE,\\n                    j > 0 ? memo[i][j-1] : Integer.MAX_VALUE\\n                );\\n                memo[i][j] = (prev != Integer.MAX_VALUE ? prev : 0) + grid[i][j];\\n            }\\n        }\\n        return memo[m-1][n-1];\\n    }\\n}\\n```\\nBonus:\\nIf we are allowed to modify the input, we can solve it in O(1) space\\n\\n# Code\\n```\\nclass Solution {\\n    public int minPathSum(int[][] grid) {\\n        int m = grid.length;\\n        int n = grid[0].length;\\n        for (int i = 0; i < m; i++) {\\n            for (int j = 0; j < n; j++) {\\n                int prev = Math.min(\\n                    i > 0 ? grid[i-1][j] : Integer.MAX_VALUE,\\n                    j > 0 ? grid[i][j-1] : Integer.MAX_VALUE\\n                );\\n                grid[i][j] = (prev != Integer.MAX_VALUE ? prev : 0) + grid[i][j];\\n            }\\n        }\\n        return grid[m-1][n-1];\\n    }\\n}\\n```\\n\\n\\n---\\n\\uD83D\\uDC4D\\uFE0F\\uD83D\\uDC4D\\uFE0F If you like this solution or find it helpful, please upvote this post. \\uD83D\\uDC4D\\uFE0F\\uD83D\\uDC4D\\uFE0F",
                "solutionTags": [
                    "Java",
                    "Dynamic Programming",
                    "Depth-First Search",
                    "Memoization",
                    "Matrix"
                ],
                "code": "```\\nclass Solution {\\n    private int[][] memo;\\n    private int[][] grid;\\n    private int m = 0;\\n    private int n = 0;\\n\\n    public int minPathSum(int[][] grid) {\\n        m = grid.length;\\n        n = grid[0].length;\\n        memo = new int[m][n];\\n        this.grid = grid;\\n        for (int[] row: memo) {\\n            Arrays.fill(row, -1);\\n        }\\n        return dfs(0, 0);\\n    }\\n\\n    private int dfs(int i, int j) {\\n        if (i == m || j == n) return Integer.MAX_VALUE;\\n        if (i == m-1 && j == n-1) return grid[i][j];\\n        if (memo[i][j] != -1) return memo[i][j];\\n        memo[i][j] = grid[i][j] + Math.min(\\n            dfs(i+1, j),\\n            dfs(i, j+1)\\n        );\\n        return memo[i][j];\\n    }\\n}\\n```\n```\\nclass Solution {\\n    public int minPathSum(int[][] grid) {\\n        int m = grid.length;\\n        int n = grid[0].length;\\n        int[][] memo = new int[m][n];\\n        for (int i = 0; i < m; i++) {\\n            for (int j = 0; j < n; j++) {\\n                int prev = Math.min(\\n                    i > 0 ? memo[i-1][j] : Integer.MAX_VALUE,\\n                    j > 0 ? memo[i][j-1] : Integer.MAX_VALUE\\n                );\\n                memo[i][j] = (prev != Integer.MAX_VALUE ? prev : 0) + grid[i][j];\\n            }\\n        }\\n        return memo[m-1][n-1];\\n    }\\n}\\n```\n```\\nclass Solution {\\n    public int minPathSum(int[][] grid) {\\n        int m = grid.length;\\n        int n = grid[0].length;\\n        for (int i = 0; i < m; i++) {\\n            for (int j = 0; j < n; j++) {\\n                int prev = Math.min(\\n                    i > 0 ? grid[i-1][j] : Integer.MAX_VALUE,\\n                    j > 0 ? grid[i][j-1] : Integer.MAX_VALUE\\n                );\\n                grid[i][j] = (prev != Integer.MAX_VALUE ? prev : 0) + grid[i][j];\\n            }\\n        }\\n        return grid[m-1][n-1];\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3347990,
                "title": "easy-solution-in-js-beat-91-just-loop-through-grid",
                "content": "Please UPVOTE!!!!\\n```\\nvar minPathSum = function(grid) {\\n    let row = grid.length;\\n    let col = grid[0].length;\\n    for(let i=0;i<row;i++) {\\n        for(let j=0;j<col;j++) {\\n            if(i == 0 && j== 0) {\\n                continue\\n            } else if( i== 0) {\\n                grid[i][j] += grid[i][j-1]\\n            } else if ( j== 0) {\\n                grid[i][j] += grid[i-1][j]\\n            } else {\\n                grid[i][j] += Math.min(grid[i-1][j],grid[i][j-1])\\n            }\\n        }\\n    }\\n    return grid[row-1][col-1]\\n};\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\nvar minPathSum = function(grid) {\\n    let row = grid.length;\\n    let col = grid[0].length;\\n    for(let i=0;i<row;i++) {\\n        for(let j=0;j<col;j++) {\\n            if(i == 0 && j== 0) {\\n                continue\\n            } else if( i== 0) {\\n                grid[i][j] += grid[i][j-1]\\n            } else if ( j== 0) {\\n                grid[i][j] += grid[i-1][j]\\n            } else {\\n                grid[i][j] += Math.min(grid[i-1][j],grid[i][j-1])\\n            }\\n        }\\n    }\\n    return grid[row-1][col-1]\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3347067,
                "title": "easy-solutions-with-explanation-in-java-dp",
                "content": "# Intuition\\nTo find minimum path sum we need result of our previous choices that we took, so this gives us intution of storing previous data and hence we choose DP\\nConsidering testcase 1\\nInput: grid = [[1,3,1],[1,5,1],[4,2,1]]\\nOutput: 7\\n\\n# Approach\\n***Beginner -> Space O(n^2)***\\n\\n1) Begin by taking same size 2D and fill the first element from grid[0][0] to our new matrix dp[][];\\n2) Prefill first row and first column, because \\n\\n- ROW\\nWe can reach row 0 elements from only side i.e grid[0][0] will contribute to grid[0][1]  and so on\\nintially grid : 1 --> 3 ---> 1\\nso first row will look like \\nafter operation dp: 1 --> 4 --> 5\\n\\n- COL\\nWe can reach row 0 elements only from top as left indexes are out of bound\\ngrid --after operation-->  dp\\n1  ---->  1\\n5  ---->  6\\n1  ---->  7\\n\\n3) Now for any other element will is not part of corner case, we can reach from top or from same row left side so \\ndp[i][j] = Math.min(element from top, element from side) + current value\\ndp[i][j] = Math.min(dp[i][j-1], dp[i-1][j])\\n\\nand we return the last element of dp[n][n] which is the answer\\n\\n---\\n\\n\\n*Space O(n)*\\nWe can also solve the problem by using a 1D array, the array will always store the upper row values ( i.e the values that we fetch via dp[i-1][j]).\\nSo initially we will prefill it with 1 row same as in 2nd step row part.\\n\\nMin path of any element is\\ndp[j] = elements values will be added + min of ( top, side)\\n- top row data is already in the dp array and side we can calculate via dp[j-1]\\ndp[j]=  grid[i][j] +Math.min(dp[j], dp[j-1])+\\n\\n\\n---\\n\\n\\n# Complexity\\n- Time complexity:\\nO(n^2) Since we visit all element of the matrix.\\n\\n# Code Space O(n^2)\\n```\\nclass Solution {\\n    public int minPathSum(int[][] grid) {\\n        if(grid==null || grid.length==0 )\\n            return 0;\\n        int row = grid.length;\\n        int col = grid[0].length;\\n        \\n        /* prefilling the first row and first column */\\n        for(int i=1;i<col;i++)\\n            grid[0][i]+=grid[0][i-1];\\n        \\n        for(int i=1;i<row;i++)\\n            grid[i][0]+=grid[i-1][0];\\n        \\n        for(int i=1;i<row;i++){\\n            for(int j=1;j<col;j++){\\n                grid[i][j]+=Math.min(grid[i][j-1], grid[i-1][j]);\\n            }\\n        }\\n        return grid[row-1][col-1];\\n    }\\n}\\n```\\n\\n# Code Space O(n)\\n```\\nclass Solution {\\n    public int minPathSum(int[][] grid) {\\n        int row= grid.length;\\n        int col= grid[0].length;\\n        int [] dp = new int[col];\\n        \\n        dp[0]= grid[0][0];\\n        \\n        for(int i=1; i<col;i++)\\n            dp[i]=dp[i-1] + grid[0][i];\\n        \\n        for(int i=1; i<row; i++){\\n            for(int j=0; j<col; j++){\\n                if(j>0){\\n                    dp[j]=Math.min(dp[j], dp[j-1])+ grid[i][j];\\n                }else{\\n                    dp[j]+=grid[i][j];\\n                }\\n            }\\n        }\\n        \\n        return dp[col-1];\\n        \\n    }\\n}\\n```\\nHope it is easy to understand.\\nLet me know if there is something unclear and i can fix it.\\n\\nOtherwise, please upvote if you like the solution, it would be encouraging.\\n\\n![LCUpvote.png](https://assets.leetcode.com/users/images/839efe73-c747-4529-80da-c693220bcf93_1679908593.3237262.png)\\n",
                "solutionTags": [
                    "Java",
                    "Dynamic Programming"
                ],
                "code": "```\\nclass Solution {\\n    public int minPathSum(int[][] grid) {\\n        if(grid==null || grid.length==0 )\\n            return 0;\\n        int row = grid.length;\\n        int col = grid[0].length;\\n        \\n        /* prefilling the first row and first column */\\n        for(int i=1;i<col;i++)\\n            grid[0][i]+=grid[0][i-1];\\n        \\n        for(int i=1;i<row;i++)\\n            grid[i][0]+=grid[i-1][0];\\n        \\n        for(int i=1;i<row;i++){\\n            for(int j=1;j<col;j++){\\n                grid[i][j]+=Math.min(grid[i][j-1], grid[i-1][j]);\\n            }\\n        }\\n        return grid[row-1][col-1];\\n    }\\n}\\n```\n```\\nclass Solution {\\n    public int minPathSum(int[][] grid) {\\n        int row= grid.length;\\n        int col= grid[0].length;\\n        int [] dp = new int[col];\\n        \\n        dp[0]= grid[0][0];\\n        \\n        for(int i=1; i<col;i++)\\n            dp[i]=dp[i-1] + grid[0][i];\\n        \\n        for(int i=1; i<row; i++){\\n            for(int j=0; j<col; j++){\\n                if(j>0){\\n                    dp[j]=Math.min(dp[j], dp[j-1])+ grid[i][j];\\n                }else{\\n                    dp[j]+=grid[i][j];\\n                }\\n            }\\n        }\\n        \\n        return dp[col-1];\\n        \\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3347028,
                "title": "minimum-pathsum-recursion-memoisation-tabulation-space-optimized-in-o-m-instead-of-o-n-m",
                "content": "# Intuition\\nJust go from bottom right corner to top left and check the minimum cost to reach the top left of the grid.\\nfun(i,j):\\n    if(i<0 || j<0) return INT_MAX;  (returning int_max is preferrable for finding the minimum)\\n    if(i==0 && j==0) return grid[i][j];\\n    return grid[i][j]+min(fun(i-1,j),fun(i,j-1));\\n\\n\\n# Code\\nBasic recursion code which will give TLE\\n```\\nclass Solution {\\npublic:\\n        int fun(int i,int j,vector<vector<int>>& grid){\\n            //just do a normal index shift which willl be useful during tabulation if you want to  do from this intuition\\n\\n            if(i==0 ||j==0) return INT_MAX;\\n\\n            if(i-1==0 && j-1==0) return grid[i-1][j-1];\\n\\n            int up=fun(i-1,j,grid);\\n            int lef=fun(i,j-1,grid);\\n\\n                //here returning that grid cost +min(getfrom left recursuon ,getfrom up recursioj)\\n            return grid[i-1][j-1]+min(up,lef);\\n\\n         \\n        }\\n    int minPathSum(vector<vector<int>>& grid) {\\n        int n=grid.size();\\n        int m=grid[0].size();\\n        \\n\\n        return fun(n,m,grid);\\n    }\\n};\\n```\\nMemosiation\\n```\\nclass Solution {\\npublic:\\n        int fun(int i,int j,vector<vector<int>>& grid,   vector<vector<int>>& dp){\\n            if(i==0 ||j==0) return INT_MAX;\\n            if(dp[i][j]!=-1) return dp[i][j];\\n            if(i-1==0 && j-1==0) return grid[i-1][j-1];\\n\\n            int up=fun(i-1,j,grid,dp);\\n            int lef=fun(i,j-1,grid,dp);\\n\\n            return dp[i][j]=grid[i-1][j-1]+min(up,lef);\\n\\n         \\n        }\\n    int minPathSum(vector<vector<int>>& grid) {\\n        int n=grid.size();\\n        int m=grid[0].size();\\n        vector<vector<int>> dp(n+1,vector<int>(m+1,-1));\\n\\n        return fun(n,m,grid,dp);\\n    }\\n};\\n```\\nTabulation which reduce our axuliary space complexity\\n```\\nclass Solution {\\npublic:\\n\\n    int minPathSum(vector<vector<int>>& grid) {\\n        int n=grid.size();\\n        int m=grid[0].size();\\n        vector<vector<int>> dp(n,vector<int>(m,0));\\n\\n\\n        for(int i=0;i<n;i++){\\n            for(int j=0;j<m;j++){\\n\\n                if(i==0 && j==0){\\n                    dp[i][j]=grid[i][j];\\n                }\\n                else{\\n                    int up=grid[i][j];\\n        //just handling arror of indexing / runtime error\\n                   if(i>0) up+=dp[i-1][j];\\n                   else{\\n                       up+=1e5;\\n                   }\\n                   int lef=grid[i][j];\\n                   if(j>0) lef+=dp[i][j-1];\\n                   else{\\n                       lef+=1e5;\\n                   }\\n                   dp[i][j]=min(up,lef);\\n                }\\n                 \\n            }\\n        }\\n\\n        // return fun(n,m,grid,dp);\\n        return dp[n-1][m-1];\\n    }\\n};\\n```\\nTablulation space optimized O(n)\\n```\\nclass Solution {\\npublic:\\n        int fun(int i,int j,vector<vector<int>>& grid,   vector<vector<int>>& dp){\\n            if(i==0 ||j==0) return INT_MAX;\\n            if(dp[i][j]!=-1) return dp[i][j];\\n            if(i-1==0 && j-1==0) return grid[i-1][j-1];\\n\\n            int up=fun(i-1,j,grid,dp);\\n            int lef=fun(i,j-1,grid,dp);\\n\\n            return dp[i][j]=grid[i-1][j-1]+min(up,lef);\\n\\n         \\n        }\\n    int minPathSum(vector<vector<int>>& grid) {\\n        int n=grid.size();\\n        int m=grid[0].size();\\n        // vector<vector<int>> dp(n,vector<int>(m,0));\\n     vector<int> prev(m, 0), cur(m, 0);\\n        for (int i = 0; i < n; i++) {\\n            for (int j = 0; j < m; j++) {\\n                if (i == 0 && j == 0) cur[j] = grid[i][j];\\n                else {\\n                    int up = i >= 1 ? grid[i][j] + prev[j] : INT_MAX;\\n                    int left = j >= 1 ? grid[i][j] + cur[j - 1] : INT_MAX;\\n                    cur[j] = min(up, left);\\n                }\\n            }\\n            prev = cur;\\n        }\\n        return prev[m - 1];\\n    }\\n};\\n```\\n\\n\\n\\n",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n        int fun(int i,int j,vector<vector<int>>& grid){\\n            //just do a normal index shift which willl be useful during tabulation if you want to  do from this intuition\\n\\n            if(i==0 ||j==0) return INT_MAX;\\n\\n            if(i-1==0 && j-1==0) return grid[i-1][j-1];\\n\\n            int up=fun(i-1,j,grid);\\n            int lef=fun(i,j-1,grid);\\n\\n                //here returning that grid cost +min(getfrom left recursuon ,getfrom up recursioj)\\n            return grid[i-1][j-1]+min(up,lef);\\n\\n         \\n        }\\n    int minPathSum(vector<vector<int>>& grid) {\\n        int n=grid.size();\\n        int m=grid[0].size();\\n        \\n\\n        return fun(n,m,grid);\\n    }\\n};\\n```\n```\\nclass Solution {\\npublic:\\n        int fun(int i,int j,vector<vector<int>>& grid,   vector<vector<int>>& dp){\\n            if(i==0 ||j==0) return INT_MAX;\\n            if(dp[i][j]!=-1) return dp[i][j];\\n            if(i-1==0 && j-1==0) return grid[i-1][j-1];\\n\\n            int up=fun(i-1,j,grid,dp);\\n            int lef=fun(i,j-1,grid,dp);\\n\\n            return dp[i][j]=grid[i-1][j-1]+min(up,lef);\\n\\n         \\n        }\\n    int minPathSum(vector<vector<int>>& grid) {\\n        int n=grid.size();\\n        int m=grid[0].size();\\n        vector<vector<int>> dp(n+1,vector<int>(m+1,-1));\\n\\n        return fun(n,m,grid,dp);\\n    }\\n};\\n```\n```\\nclass Solution {\\npublic:\\n\\n    int minPathSum(vector<vector<int>>& grid) {\\n        int n=grid.size();\\n        int m=grid[0].size();\\n        vector<vector<int>> dp(n,vector<int>(m,0));\\n\\n\\n        for(int i=0;i<n;i++){\\n            for(int j=0;j<m;j++){\\n\\n                if(i==0 && j==0){\\n                    dp[i][j]=grid[i][j];\\n                }\\n                else{\\n                    int up=grid[i][j];\\n        //just handling arror of indexing / runtime error\\n                   if(i>0) up+=dp[i-1][j];\\n                   else{\\n                       up+=1e5;\\n                   }\\n                   int lef=grid[i][j];\\n                   if(j>0) lef+=dp[i][j-1];\\n                   else{\\n                       lef+=1e5;\\n                   }\\n                   dp[i][j]=min(up,lef);\\n                }\\n                 \\n            }\\n        }\\n\\n        // return fun(n,m,grid,dp);\\n        return dp[n-1][m-1];\\n    }\\n};\\n```\n```\\nclass Solution {\\npublic:\\n        int fun(int i,int j,vector<vector<int>>& grid,   vector<vector<int>>& dp){\\n            if(i==0 ||j==0) return INT_MAX;\\n            if(dp[i][j]!=-1) return dp[i][j];\\n            if(i-1==0 && j-1==0) return grid[i-1][j-1];\\n\\n            int up=fun(i-1,j,grid,dp);\\n            int lef=fun(i,j-1,grid,dp);\\n\\n            return dp[i][j]=grid[i-1][j-1]+min(up,lef);\\n\\n         \\n        }\\n    int minPathSum(vector<vector<int>>& grid) {\\n        int n=grid.size();\\n        int m=grid[0].size();\\n        // vector<vector<int>> dp(n,vector<int>(m,0));\\n     vector<int> prev(m, 0), cur(m, 0);\\n        for (int i = 0; i < n; i++) {\\n            for (int j = 0; j < m; j++) {\\n                if (i == 0 && j == 0) cur[j] = grid[i][j];\\n                else {\\n                    int up = i >= 1 ? grid[i][j] + prev[j] : INT_MAX;\\n                    int left = j >= 1 ? grid[i][j] + cur[j - 1] : INT_MAX;\\n                    cur[j] = min(up, left);\\n                }\\n            }\\n            prev = cur;\\n        }\\n        return prev[m - 1];\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3332681,
                "title": "best-o-m-n-solution",
                "content": "# Approach 1\\nRecursion (TLE)\\n\\n# Complexity\\n- Time complexity:\\n$$O(2^S)$$ --> S = m * n\\n\\n- Space complexity:\\n$$O(m + n)$$\\n\\n# Code\\n```\\nclass Solution {\\nprivate:\\n    int solve(int row, int col, vector<vector<int>>& grid) {\\n        if (row == 0 && col == 0)\\n            return grid[row][col];\\n        if (row < 0 || col < 0)\\n            return INT_MAX;\\n        int left = grid[row][col] + solve(row, col-1, grid);\\n        int up = grid[row][col] + solve(row-1, col, grid);\\n        return min (left, up);        \\n    }  \\npublic:\\n    int minPathSum(vector<vector<int>>& grid) {\\n        int m = grid.size(), n = grid[0].size();\\n        return solve(m-1, n-1, grid);\\n    }\\n};\\n```\\n\\n# Approach 2\\nDP (Top Down Approach)\\n\\n# Complexity\\n- Time complexity:\\n$$O(m * n)$$\\n\\n- Space complexity:\\n$$O(m * n)$$\\n\\n# Code\\n```\\nclass Solution {\\nprivate:\\n    int solve(int row, int col, vector<vector<int>>& grid, vector<vector<int>>& dp) {\\n        if (row == 0 && col == 0)\\n            return grid[row][col];\\n        if (row < 0 || col < 0)\\n            return 1e9;\\n        if (dp[row][col] != -1)\\n            return dp[row][col];    \\n        int left = grid[row][col] + solve(row, col-1, grid, dp);\\n        int up = grid[row][col] + solve(row-1, col, grid, dp);\\n        return dp[row][col] = min (left, up);        \\n    }  \\npublic:\\n    int minPathSum(vector<vector<int>>& grid) {\\n        int m = grid.size(), n = grid[0].size();\\n        vector<vector<int>> dp(m, vector<int>(n, -1));\\n        return solve(m-1, n-1, grid, dp);\\n    }\\n};\\n```\\n\\n# Approach 3\\nDP (Bottom Up Approach)\\n\\n# Complexity\\n- Time complexity:\\n$$O(m * n)$$\\n\\n- Space complexity:\\n$$O(m * n)$$\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int minPathSum(vector<vector<int>>& grid) {\\n        int m = grid.size(), n = grid[0].size();\\n        vector<vector<int>> dp(m, vector<int>(n, -1));\\n        for (int i = 0; i < m; i++) {\\n            for (int j = 0; j < n; j++) {\\n                if (i == 0 && j == 0) {\\n                    dp[i][j] = grid[i][j];\\n                    continue;\\n                }\\n                int left = grid[i][j], up = grid[i][j];\\n                if (j > 0)\\n                    left += dp[i][j-1];\\n                else\\n                    left += 1e9;    \\n                if (i > 0)    \\n                    up += dp[i-1][j];\\n                else\\n                    up += 1e9;    \\n                dp[i][j] = min (left, up);\\n            }\\n        }\\n        return dp[m-1][n-1];\\n    }\\n};\\n```\\n\\n# Approach 4\\nDP (Bottom Up Approach) + Space Optimization\\n\\n# Complexity\\n- Time complexity:\\n$$O(m * n)$$ \\n\\n- Space complexity:\\n$$O(n)$$\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int minPathSum(vector<vector<int>>& grid) {\\n        int m = grid.size(), n = grid[0].size();\\n        vector <int> prev(n, 0);\\n        for (int i = 0; i < m; i++) {\\n            vector <int> cur(n, 0);\\n            for (int j = 0; j < n; j++) {\\n                if (i == 0 && j == 0) {\\n                    cur[j] = grid[i][j];\\n                    continue;\\n                }\\n                int left = grid[i][j], up = grid[i][j];\\n                if (j > 0)\\n                    left += cur[j-1];\\n                else\\n                    left += 1e9;    \\n                if (i > 0)    \\n                    up += prev[j];\\n                else\\n                    up += 1e9;    \\n                cur[j] = min (left, up);\\n            }\\n            prev = cur;\\n        }\\n        return prev[n-1];  \\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\nprivate:\\n    int solve(int row, int col, vector<vector<int>>& grid) {\\n        if (row == 0 && col == 0)\\n            return grid[row][col];\\n        if (row < 0 || col < 0)\\n            return INT_MAX;\\n        int left = grid[row][col] + solve(row, col-1, grid);\\n        int up = grid[row][col] + solve(row-1, col, grid);\\n        return min (left, up);        \\n    }  \\npublic:\\n    int minPathSum(vector<vector<int>>& grid) {\\n        int m = grid.size(), n = grid[0].size();\\n        return solve(m-1, n-1, grid);\\n    }\\n};\\n```\n```\\nclass Solution {\\nprivate:\\n    int solve(int row, int col, vector<vector<int>>& grid, vector<vector<int>>& dp) {\\n        if (row == 0 && col == 0)\\n            return grid[row][col];\\n        if (row < 0 || col < 0)\\n            return 1e9;\\n        if (dp[row][col] != -1)\\n            return dp[row][col];    \\n        int left = grid[row][col] + solve(row, col-1, grid, dp);\\n        int up = grid[row][col] + solve(row-1, col, grid, dp);\\n        return dp[row][col] = min (left, up);        \\n    }  \\npublic:\\n    int minPathSum(vector<vector<int>>& grid) {\\n        int m = grid.size(), n = grid[0].size();\\n        vector<vector<int>> dp(m, vector<int>(n, -1));\\n        return solve(m-1, n-1, grid, dp);\\n    }\\n};\\n```\n```\\nclass Solution {\\npublic:\\n    int minPathSum(vector<vector<int>>& grid) {\\n        int m = grid.size(), n = grid[0].size();\\n        vector<vector<int>> dp(m, vector<int>(n, -1));\\n        for (int i = 0; i < m; i++) {\\n            for (int j = 0; j < n; j++) {\\n                if (i == 0 && j == 0) {\\n                    dp[i][j] = grid[i][j];\\n                    continue;\\n                }\\n                int left = grid[i][j], up = grid[i][j];\\n                if (j > 0)\\n                    left += dp[i][j-1];\\n                else\\n                    left += 1e9;    \\n                if (i > 0)    \\n                    up += dp[i-1][j];\\n                else\\n                    up += 1e9;    \\n                dp[i][j] = min (left, up);\\n            }\\n        }\\n        return dp[m-1][n-1];\\n    }\\n};\\n```\n```\\nclass Solution {\\npublic:\\n    int minPathSum(vector<vector<int>>& grid) {\\n        int m = grid.size(), n = grid[0].size();\\n        vector <int> prev(n, 0);\\n        for (int i = 0; i < m; i++) {\\n            vector <int> cur(n, 0);\\n            for (int j = 0; j < n; j++) {\\n                if (i == 0 && j == 0) {\\n                    cur[j] = grid[i][j];\\n                    continue;\\n                }\\n                int left = grid[i][j], up = grid[i][j];\\n                if (j > 0)\\n                    left += cur[j-1];\\n                else\\n                    left += 1e9;    \\n                if (i > 0)    \\n                    up += prev[j];\\n                else\\n                    up += 1e9;    \\n                cur[j] = min (left, up);\\n            }\\n            prev = cur;\\n        }\\n        return prev[n-1];  \\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2974540,
                "title": "c-solution",
                "content": "# Approach\\n<!-- Describe your approach to solving the problem. -->\\n    DP\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n    O(N * M)\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n    O(N * M)\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int minPathSum(vector<vector<int>>& grid) {\\n        int n = grid.size(), m = grid[0].size();\\n        int dp[n][m];\\n        dp[0][0] = grid[0][0];\\n        for(int i=1; i<m; i++) dp[0][i] = dp[0][i-1] + grid[0][i];\\n        for(int i=1; i<n; i++) dp[i][0] = dp[i-1][0] + grid[i][0];\\n        for(int i=1; i<n; i++) {\\n            for(int j=1; j<m; j++) {\\n                dp[i][j] = min(dp[i][j-1], dp[i-1][j]) + grid[i][j];\\n            }\\n        }\\n        return dp[n-1][m-1];\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int minPathSum(vector<vector<int>>& grid) {\\n        int n = grid.size(), m = grid[0].size();\\n        int dp[n][m];\\n        dp[0][0] = grid[0][0];\\n        for(int i=1; i<m; i++) dp[0][i] = dp[0][i-1] + grid[0][i];\\n        for(int i=1; i<n; i++) dp[i][0] = dp[i-1][0] + grid[i][0];\\n        for(int i=1; i<n; i++) {\\n            for(int j=1; j<m; j++) {\\n                dp[i][j] = min(dp[i][j-1], dp[i-1][j]) + grid[i][j];\\n            }\\n        }\\n        return dp[n-1][m-1];\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2937659,
                "title": "easy-solution-short-simple-best-method-easy-to-understand",
                "content": "\\n# Code\\n```\\nclass Solution {\\npublic:\\n    \\n    int solve(vector<vector<int>>& grid, int m, int n, vector<vector<int>>& dp)\\n    {\\n        if(m==0 && n==0)\\n            return dp[m][n];\\n        if(dp[m][n]!=-1)\\n            return dp[m][n];\\n        if(m==0 && n!=0)\\n            return dp[m][n] = grid[m][n]+solve(grid, m, n-1, dp);\\n        \\n        if(n==0 && m!=0)\\n            return dp[m][n] =grid[m][n]+solve(grid, m-1, n, dp);\\n        \\n        else\\n            return dp[m][n] =grid[m][n] + min(solve(grid, m-1, n, dp), solve(grid, m, n-1, dp));\\n    }\\n    int minPathSum(vector<vector<int>>& grid) {\\n       \\n        int m=grid.size();\\n        int n=grid[0].size();\\n        for(int i=0;i<m;i++)\\n        {\\n            for(int j=0;j<n;j++)\\n            {\\n                if(i==0 && j!=0)\\n                    grid[i][j]+=grid[i][j-1];\\n                else if(j==0 && i!=0)\\n                    grid[i][j]+=grid[i-1][j];\\n                else if(i && j)\\n                    grid[i][j]+=min(grid[i][j-1], grid[i-1][j]);\\n                // cout<<grid[i][j]<<\" \";\\n            }\\n        }\\n        return grid[m-1][n-1];\\n    }\\n};\\n```\\nPlease **UPVOTE** if it helps \\u2764\\uFE0F\\uD83D\\uDE0A\\nThank You and Happy To Help You!!",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    \\n    int solve(vector<vector<int>>& grid, int m, int n, vector<vector<int>>& dp)\\n    {\\n        if(m==0 && n==0)\\n            return dp[m][n];\\n        if(dp[m][n]!=-1)\\n            return dp[m][n];\\n        if(m==0 && n!=0)\\n            return dp[m][n] = grid[m][n]+solve(grid, m, n-1, dp);\\n        \\n        if(n==0 && m!=0)\\n            return dp[m][n] =grid[m][n]+solve(grid, m-1, n, dp);\\n        \\n        else\\n            return dp[m][n] =grid[m][n] + min(solve(grid, m-1, n, dp), solve(grid, m, n-1, dp));\\n    }\\n    int minPathSum(vector<vector<int>>& grid) {\\n       \\n        int m=grid.size();\\n        int n=grid[0].size();\\n        for(int i=0;i<m;i++)\\n        {\\n            for(int j=0;j<n;j++)\\n            {\\n                if(i==0 && j!=0)\\n                    grid[i][j]+=grid[i][j-1];\\n                else if(j==0 && i!=0)\\n                    grid[i][j]+=grid[i-1][j];\\n                else if(i && j)\\n                    grid[i][j]+=min(grid[i][j-1], grid[i-1][j]);\\n                // cout<<grid[i][j]<<\" \";\\n            }\\n        }\\n        return grid[m-1][n-1];\\n    }\\n};\\n```",
                "codeTag": "C++"
            },
            {
                "id": 1771810,
                "title": "python-dp-solution-easy-and-simple",
                "content": "```\\nclass Solution:\\n    def minPathSum(self, grid: List[List[int]]) -> int:\\n        \\'\\'\\'\\n        Approach:\\n        1. Compute the sum to reach untill each element in first column\\n        2. Compute the sum to reach untill each element in first row\\n        3. Then traverse from index 1,1 to untill end and only take the minimum path at each location \\n        \\n        Minimum path comes from either from previous element(previous row and column).\\n        \\'\\'\\'\\n        m, n = len(grid), len(grid[0]) \\n        for i in range(1, m):\\n            grid[i][0] += grid[i-1][0]\\n        for j in range(1, n):\\n            grid[0][j] += grid[0][j-1]\\n        for i in range(1, m):\\n            for j in range(1, n):\\n                grid[i][j] += min(grid[i-1][j], grid[i][j-1])\\n        return grid[-1][-1]\\n```\\n**I hope that you\\'ve found this useful.**\\n**In that case, please upvote. It only motivates me to write more such posts\\uD83D\\uDE03**\\nComment below if you have any queries.",
                "solutionTags": [
                    "Python",
                    "Dynamic Programming"
                ],
                "code": "```\\nclass Solution:\\n    def minPathSum(self, grid: List[List[int]]) -> int:\\n        \\'\\'\\'\\n        Approach:\\n        1. Compute the sum to reach untill each element in first column\\n        2. Compute the sum to reach untill each element in first row\\n        3. Then traverse from index 1,1 to untill end and only take the minimum path at each location \\n        \\n        Minimum path comes from either from previous element(previous row and column).\\n        \\'\\'\\'\\n        m, n = len(grid), len(grid[0]) \\n        for i in range(1, m):\\n            grid[i][0] += grid[i-1][0]\\n        for j in range(1, n):\\n            grid[0][j] += grid[0][j-1]\\n        for i in range(1, m):\\n            for j in range(1, n):\\n                grid[i][j] += min(grid[i-1][j], grid[i][j-1])\\n        return grid[-1][-1]\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1643189,
                "title": "c-simple-dp-solution",
                "content": "```\\nclass Solution {\\npublic:\\n    int minPathSum(vector<vector<int>>& grid) {\\n        int n = grid.size(), m = grid[0].size();\\n        vector<vector<int>> dp(n, vector<int>(m));\\n        for(int i = n-1; i >= 0; i--){\\n            for(int j = m-1; j >= 0; j--){\\n                if(i == n-1 && j == m-1) // bottom right element\\n                    dp[i][j] = grid[i][j];\\n                else if(i == n-1)        // In last row we can\\'t go downwards\\n                    dp[i][j] = dp[i][j+1] + grid[i][j];\\n                else if(j == m-1)        // In last column we can\\'t go rightwards\\n                    dp[i][j] = dp[i+1][j] + grid[i][j];\\n                else\\n                    dp[i][j] = min(dp[i+1][j], dp[i][j+1]) + grid[i][j];\\n            }\\n        }\\n        return dp[0][0];\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "C",
                    "Dynamic Programming",
                    "Memoization"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int minPathSum(vector<vector<int>>& grid) {\\n        int n = grid.size(), m = grid[0].size();\\n        vector<vector<int>> dp(n, vector<int>(m));\\n        for(int i = n-1; i >= 0; i--){\\n            for(int j = m-1; j >= 0; j--){\\n                if(i == n-1 && j == m-1) // bottom right element\\n                    dp[i][j] = grid[i][j];\\n                else if(i == n-1)        // In last row we can\\'t go downwards\\n                    dp[i][j] = dp[i][j+1] + grid[i][j];\\n                else if(j == m-1)        // In last column we can\\'t go rightwards\\n                    dp[i][j] = dp[i+1][j] + grid[i][j];\\n                else\\n                    dp[i][j] = min(dp[i+1][j], dp[i][j+1]) + grid[i][j];\\n            }\\n        }\\n        return dp[0][0];\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1496137,
                "title": "python-bfs-solution",
                "content": "```\\nclass Solution:\\n    def minPathSum(self, grid: List[List[int]]) -> int:\\n        \\n        # square becomes minimum of the thing above it or to the left of it\\n        # plus its own value\\n        \\n        \\n        # bfs right then down\\n        if len(grid) == 1 and len(grid[0]) == 1:\\n            return grid[0][0]\\n        \\n        \\n        q = deque()\\n        visited = set()\\n        q.append((0,0))\\n        \\n        while(q):\\n            row, col = q.popleft()\\n            if (row, col) in visited:\\n                continue\\n            if row >= 0 and row < len(grid) and col >= 0 and col < len(grid[0]):\\n                q.append((row, col+1))\\n                q.append((row+1, col))\\n                visited.add((row,col))\\n                if row == 0 and col == 0:\\n                    continue\\n                elif row == 0 and col > 0:\\n                    grid[row][col] += grid[row][col-1]\\n                elif col == 0:\\n                    grid[row][col] += grid[row-1][col]\\n                else:\\n                    grid[row][col] += min(grid[row-1][col], grid[row][col-1])\\n       \\n            \\n        return grid[-1][-1]\\n",
                "solutionTags": [
                    "Python",
                    "Breadth-First Search"
                ],
                "code": "```\\nclass Solution:\\n    def minPathSum(self, grid: List[List[int]]) -> int:\\n        \\n        # square becomes minimum of the thing above it or to the left of it\\n        # plus its own value\\n        \\n        \\n        # bfs right then down\\n        if len(grid) == 1 and len(grid[0]) == 1:\\n            return grid[0][0]\\n        \\n        \\n        q = deque()\\n        visited = set()\\n        q.append((0,0))\\n        \\n        while(q):\\n            row, col = q.popleft()\\n            if (row, col) in visited:\\n                continue\\n            if row >= 0 and row < len(grid) and col >= 0 and col < len(grid[0]):\\n                q.append((row, col+1))\\n                q.append((row+1, col))\\n                visited.add((row,col))\\n                if row == 0 and col == 0:\\n                    continue\\n                elif row == 0 and col > 0:\\n                    grid[row][col] += grid[row][col-1]\\n                elif col == 0:\\n                    grid[row][col] += grid[row-1][col]\\n                else:\\n                    grid[row][col] += min(grid[row-1][col], grid[row][col-1])\\n       \\n            \\n        return grid[-1][-1]\\n",
                "codeTag": "Java"
            },
            {
                "id": 1476146,
                "title": "generalized-way-of-using-recursion-on-matrix-solution-for-this-problem-recursive-and-top-down",
                "content": "**WHAT IS RECURSION?**\\n=> just a lazy guy who will take help from others  to get the work done.{calling same function on smaller inputs eventually reaching base case where we will get our answer}\\n\\n**RECURSON IN MATRIX**\\n1) In a matrix we have to figure out the way to traverse, if I am at (0,0) and i have to go down then(1,0), up(-1,0),   right(0, 1) and left(0, -1). Generalizing this from (i, j) -> down(i+1, j), up(i-1, j), left(i, j-1), right(i, j+1).\\n2) While traversing we have to take care that we are inside out matrix, generalizing this if we go below 0 we are going out from two sides(left and top), if we go above n, m (considering n x m matrix) then we are going outside from other two sides.\\n3) At last we have to figure out the logic according to the question through which we will calculate the output.\\n\\n\\n**RECURSIVE SOLUTION (will result in TLE):**\\n```\\nclass Solution {\\nprivate:\\n    int recursion(int i, int j, int n, int m, vector<vector<int>> &grid){\\n        //checking wheter we are inside the matrix or not. if not, we return INT_MAX as we are checking for minimum.(conditions for returning will change according to question)\\n        if(i >= n || j >= m){\\n            return INT_MAX;\\n        }\\n        //cost to reach last cell from last cell is the value present in the last cell\\n        if(i == n-1 && j == m-1){\\n            return grid[n-1][m-1];\\n        }\\n        \\n        int down = recursion(i+1, j, n, m, grid); // value which i will get when i go down\\n        int right = recursion(i, j+1, n, m, grid);// value which i will get when i go right\\n        \\n        return grid[i][j] + min(down, right); // since we want minimum we will choose minimum from down and right + value at the present cell.\\n    }\\npublic:\\n    int minPathSum(vector<vector<int>>& grid) {\\n        int row = grid.size();\\n        int col = grid[0].size();\\n        return recursion(0, 0, row, col, grid); // at index (0, 0) we will have the total min cost to reach end from (0,0).\\n    }\\n};\\n```\\n\\n**TOP-DOWN DP(AC):**\\n```\\nclass Solution {\\nprivate:\\n    int topDown(int i, int j, int n, int m, vector<vector<int>> &grid, vector<vector<int>> &dp){\\n        //checking wheter we are inside the matrix or not. if not, we return INT_MAX as we are checking for minimum.\\n        if(i >= n || j >= m){\\n            return INT_MAX;\\n        }\\n        //cost to reach last cell from last cell is the value present in the last cell\\n        if(i == n-1 && j == m-1){\\n            return grid[n-1][m-1];\\n        }\\n        \\n        if(dp[i][j] != -1) return dp[i][j]; // if not -1 then the value is already computed no need to calculate again\\n        \\n        int down = topDown(i+1, j, n, m, grid, dp); // value which function will return when we go down\\n        int right = topDown(i, j+1, n, m, grid, dp);// value which function will get when return we go right\\n        \\n        return dp[i][j] = grid[i][j] + min(down, right); // since we want minimum we will choose minimum from down and right + value at the present cell and store it in dp matrix\\n    }\\npublic:\\n    int minPathSum(vector<vector<int>>& grid) {\\n        int row = grid.size();\\n        int col = grid[0].size();\\n        vector<vector<int>> dp(row, vector<int>(col, -1)); // declaring 2d matrix initialized as -1 to store values\\n        return topDown(0, 0, row, col, grid, dp);\\n    }\\n};\\n```\\n",
                "solutionTags": [
                    "Array",
                    "Dynamic Programming",
                    "Depth-First Search",
                    "Recursion",
                    "Matrix"
                ],
                "code": "```\\nclass Solution {\\nprivate:\\n    int recursion(int i, int j, int n, int m, vector<vector<int>> &grid){\\n        //checking wheter we are inside the matrix or not. if not, we return INT_MAX as we are checking for minimum.(conditions for returning will change according to question)\\n        if(i >= n || j >= m){\\n            return INT_MAX;\\n        }\\n        //cost to reach last cell from last cell is the value present in the last cell\\n        if(i == n-1 && j == m-1){\\n            return grid[n-1][m-1];\\n        }\\n        \\n        int down = recursion(i+1, j, n, m, grid); // value which i will get when i go down\\n        int right = recursion(i, j+1, n, m, grid);// value which i will get when i go right\\n        \\n        return grid[i][j] + min(down, right); // since we want minimum we will choose minimum from down and right + value at the present cell.\\n    }\\npublic:\\n    int minPathSum(vector<vector<int>>& grid) {\\n        int row = grid.size();\\n        int col = grid[0].size();\\n        return recursion(0, 0, row, col, grid); // at index (0, 0) we will have the total min cost to reach end from (0,0).\\n    }\\n};\\n```\n```\\nclass Solution {\\nprivate:\\n    int topDown(int i, int j, int n, int m, vector<vector<int>> &grid, vector<vector<int>> &dp){\\n        //checking wheter we are inside the matrix or not. if not, we return INT_MAX as we are checking for minimum.\\n        if(i >= n || j >= m){\\n            return INT_MAX;\\n        }\\n        //cost to reach last cell from last cell is the value present in the last cell\\n        if(i == n-1 && j == m-1){\\n            return grid[n-1][m-1];\\n        }\\n        \\n        if(dp[i][j] != -1) return dp[i][j]; // if not -1 then the value is already computed no need to calculate again\\n        \\n        int down = topDown(i+1, j, n, m, grid, dp); // value which function will return when we go down\\n        int right = topDown(i, j+1, n, m, grid, dp);// value which function will get when return we go right\\n        \\n        return dp[i][j] = grid[i][j] + min(down, right); // since we want minimum we will choose minimum from down and right + value at the present cell and store it in dp matrix\\n    }\\npublic:\\n    int minPathSum(vector<vector<int>>& grid) {\\n        int row = grid.size();\\n        int col = grid[0].size();\\n        vector<vector<int>> dp(row, vector<int>(col, -1)); // declaring 2d matrix initialized as -1 to store values\\n        return topDown(0, 0, row, col, grid, dp);\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1450433,
                "title": "1-ms-faster-than-99-of-java-online-submissions-for-minimum-path-sum",
                "content": "// It is much similar problem to Unique paths problem.\\nclass Solution {\\n    public int minPathSum(int[][] grid) {\\n       \\n        \\n        for(int i=1;i<grid[0].length;i++){\\n            \\n            grid[0][i]+=grid[0][i-1];\\n        }\\n        for(int j=1;j<grid.length;j++){\\n            \\n            grid[j][0]+=grid[j-1][0];\\n        }\\n        for(int i=1;i<grid.length;i++){\\n            for(int j=1;j<grid[0].length;j++){\\n                grid[i][j]+=Math.min(grid[i-1][j],grid[i][j-1]);\\n            }\\n        }\\n        return grid[grid.length-1][grid[0].length-1];\\n    }\\n}",
                "solutionTags": [
                    "Java",
                    "Dynamic Programming"
                ],
                "code": "class Solution {\\n    public int minPathSum(int[][] grid) {\\n       \\n        \\n        for(int i=1;i<grid[0].length;i++){\\n            \\n            grid[0][i]+=grid[0][i-1];\\n        }",
                "codeTag": "Java"
            },
            {
                "id": 1266207,
                "title": "top-down-recursion-memoization-c-beginners",
                "content": "Simplest top down approach\\n\\n```\\nclass Solution {\\npublic:\\n    \\n    int dp[2001][2001];\\n    int rec(vector<vector<int> > &A,int i,int j)\\n    {\\n        int m=A.size(),n=A[0].size();\\n\\n        if(i>=m or j>=n) return INT_MAX;\\n        if(i==m-1 and j==n-1) return A[i][j];\\n        if(dp[i][j]!=-1) return dp[i][j];\\n\\n        return dp[i][j]=min(rec(A,i+1,j),rec(A,i,j+1))+A[i][j];\\n    }\\n\\n    int minPathSum(vector<vector<int>>& grid) {\\n        memset(dp,-1,sizeof(dp));\\n        return rec(grid,0,0);\\n    }\\n};\\n```\\n",
                "solutionTags": [
                    "Recursion",
                    "Memoization"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    \\n    int dp[2001][2001];\\n    int rec(vector<vector<int> > &A,int i,int j)\\n    {\\n        int m=A.size(),n=A[0].size();\\n\\n        if(i>=m or j>=n) return INT_MAX;\\n        if(i==m-1 and j==n-1) return A[i][j];\\n        if(dp[i][j]!=-1) return dp[i][j];\\n\\n        return dp[i][j]=min(rec(A,i+1,j),rec(A,i,j+1))+A[i][j];\\n    }\\n\\n    int minPathSum(vector<vector<int>>& grid) {\\n        memset(dp,-1,sizeof(dp));\\n        return rec(grid,0,0);\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 585513,
                "title": "python-bottom-up-dynamic-programming",
                "content": "You only have two choices when determining the the minimum for a particular cell. Either you take the value above you or the value left from you. Choose the the minimum between them and add the value from the cell you\\'re currently on. Keep doing that untill you make it to the end of the grid.\\n\\n```python\\nclass Solution:\\n    def minPathSum(self, grid: List[List[int]]) -> int:\\n        for i in range(1, len(grid)):\\n            grid[i][0] += grid[i-1][0]\\n        \\n        for j in range(1, len(grid[0])):\\n            grid[0][j] += grid[0][j-1]\\n        \\n        for i in range(1, len(grid)):\\n            for j in range(1, len(grid[0])):\\n                grid[i][j] += min(grid[i-1][j], grid[i][j-1])\\n                \\n        return grid[-1][-1]\\n```\\n\\n**Time:** `O(m*n)`\\n**Space:** `O(1)`",
                "solutionTags": [
                    "Python",
                    "Dynamic Programming"
                ],
                "code": "```python\\nclass Solution:\\n    def minPathSum(self, grid: List[List[int]]) -> int:\\n        for i in range(1, len(grid)):\\n            grid[i][0] += grid[i-1][0]\\n        \\n        for j in range(1, len(grid[0])):\\n            grid[0][j] += grid[0][j-1]\\n        \\n        for i in range(1, len(grid)):\\n            for j in range(1, len(grid[0])):\\n                grid[i][j] += min(grid[i-1][j], grid[i][j-1])\\n                \\n        return grid[-1][-1]\\n```",
                "codeTag": "Java"
            },
            {
                "id": 585035,
                "title": "java-linear-time-constant-space-easy-to-understand-dp-solution",
                "content": "```\\npublic int minPathSum(int[][] grid) {\\n        int xlen = grid.length;\\n        if(xlen == 0) return 0;\\n        int ylen = grid[0].length;\\n        //using grid as dp grid\\n        for(int i=1;i<xlen;i++) {\\n            grid[i][0]+=grid[i-1][0];\\n        }\\n        for(int i=1;i<ylen;i++) {\\n            grid[0][i]+=grid[0][i-1];\\n        }\\n        for(int i=1;i<xlen;i++){\\n            for(int j=1; j<ylen;j++) {\\n                grid[i][j] += Math.min(grid[i-1][j], grid[i][j-1]);\\n            }\\n        }\\n        return grid[xlen-1][ylen-1];\\n    }\\n```",
                "solutionTags": [],
                "code": "```\\npublic int minPathSum(int[][] grid) {\\n        int xlen = grid.length;\\n        if(xlen == 0) return 0;\\n        int ylen = grid[0].length;\\n        //using grid as dp grid\\n        for(int i=1;i<xlen;i++) {\\n            grid[i][0]+=grid[i-1][0];\\n        }\\n        for(int i=1;i<ylen;i++) {\\n            grid[0][i]+=grid[0][i-1];\\n        }\\n        for(int i=1;i<xlen;i++){\\n            for(int j=1; j<ylen;j++) {\\n                grid[i][j] += Math.min(grid[i-1][j], grid[i][j-1]);\\n            }\\n        }\\n        return grid[xlen-1][ylen-1];\\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 482511,
                "title": "dijkstra-s-algorithm-with-python-3-pictures",
                "content": "\\nPracticing on problems in which people have tagged with Dijkstra\\'s algorithm.\\n\\nSteps\\n* Convert to graph\\n* inf on unseen nodes\\n* start 0,0\\n* Loop\\n\\t* relax node\\n\\t* add cost to seen edge\\n\\t* mark node as visit\\n\\t* find min value cost on seen but not visited nodes\\n* Return value end  n, n\\n\\nThings I found\\n* Building graphs is expensive\\n* Didn\\'t see much improvement using a heap but could be smaller test sets.\\n* There\\'s still a lot I don\\'t know about Python.  First time using heaps and multi-key defaultdict\\n* Amazon youtube instructors like Abdul Bari https://youtu.be/XB4MIexjvY0\\n\\nVisual walk through \\n1.  ![image](https://assets.leetcode.com/users/dentedghost/image_1579222011.png)\\n2.  ![image](https://assets.leetcode.com/users/dentedghost/image_1579222457.png)\\n3.  ![image](https://assets.leetcode.com/users/dentedghost/image_1579222525.png)\\n4.  ![image](https://assets.leetcode.com/users/dentedghost/image_1579222551.png)\\n5.  ![image](https://assets.leetcode.com/users/dentedghost/image_1579222573.png)\\n6.  ![image](https://assets.leetcode.com/users/dentedghost/image_1579222609.png)\\n7.  ![image](https://assets.leetcode.com/users/dentedghost/image_1579222625.png)\\n8.  ![image](https://assets.leetcode.com/users/dentedghost/image_1579222657.png)\\n9.  ![image](https://assets.leetcode.com/users/dentedghost/image_1579222691.png)\\n10. ![image](https://assets.leetcode.com/users/dentedghost/image_1579222744.png)\\n11. ![image](https://assets.leetcode.com/users/dentedghost/image_1579222763.png)\\n\\nCode:\\n```\\n    def minPathSum(self, grid: List[List[int]]) -> int:\\n        row =  len(grid)\\n        column = len(grid[0])\\n        \\n        # Craft graphs\\n        heap = []\\n        sum = defaultdict(list)\\n        cost = defaultdict(list)\\n        graph = defaultdict(list)\\n        seen = defaultdict(list)\\n        for r in range (0, row):\\n            for c in range (0, column):\\n                sum[r,c] = float(\\'inf\\')\\n                cost[r,c].append(grid[r][c])\\n                # check right\\n                if c < column - 1:\\n                    graph[r,c].append([r,c+1])\\n                # check down\\n                if r < row - 1:\\n                    graph[r,c].append([r+1,c])\\n  \\n        # Setup for start and end\\n        min_node = (0,0)\\n        end_node = ((row-1),(column-1))   \\n        sum[(min_node)] = cost.get(min_node)[0]\\n        seen[(min_node)] = True\\n        \\n        while len(seen) > 0:\\n            # check attached nodes\\n            if graph.get(min_node):\\n                # Visit next mini-value node and relax it\\'s edge\\n                for node in graph.get(min_node):\\n                    n = tuple(node)\\n                    visit_cost = cost.get(n)[0] + (sum.get(min_node))\\n                    # Check if relaxing has reduced the cost\\n                    if visit_cost < sum.get(n):\\n                        # Update the cost for each updated node\\n                        sum[(n)] = visit_cost\\n                        # Add to head future nodes to visit\\n                        heappush(heap, (visit_cost, n))\\n                        seen[(n)] = True\\n\\n            seen.pop(min_node)\\n\\n            # Check Next Cost Optimized with a heap\\n            if len(heap) > 0:\\n                next_min_node = heappop(heap)[1]\\n                min_node = next_min_node\\n\\n        return sum.get(end_node)\\n```\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n",
                "solutionTags": [
                    "Python"
                ],
                "code": "```\\n    def minPathSum(self, grid: List[List[int]]) -> int:\\n        row =  len(grid)\\n        column = len(grid[0])\\n        \\n        # Craft graphs\\n        heap = []\\n        sum = defaultdict(list)\\n        cost = defaultdict(list)\\n        graph = defaultdict(list)\\n        seen = defaultdict(list)\\n        for r in range (0, row):\\n            for c in range (0, column):\\n                sum[r,c] = float(\\'inf\\')\\n                cost[r,c].append(grid[r][c])\\n                # check right\\n                if c < column - 1:\\n                    graph[r,c].append([r,c+1])\\n                # check down\\n                if r < row - 1:\\n                    graph[r,c].append([r+1,c])\\n  \\n        # Setup for start and end\\n        min_node = (0,0)\\n        end_node = ((row-1),(column-1))   \\n        sum[(min_node)] = cost.get(min_node)[0]\\n        seen[(min_node)] = True\\n        \\n        while len(seen) > 0:\\n            # check attached nodes\\n            if graph.get(min_node):\\n                # Visit next mini-value node and relax it\\'s edge\\n                for node in graph.get(min_node):\\n                    n = tuple(node)\\n                    visit_cost = cost.get(n)[0] + (sum.get(min_node))\\n                    # Check if relaxing has reduced the cost\\n                    if visit_cost < sum.get(n):\\n                        # Update the cost for each updated node\\n                        sum[(n)] = visit_cost\\n                        # Add to head future nodes to visit\\n                        heappush(heap, (visit_cost, n))\\n                        seen[(n)] = True\\n\\n            seen.pop(min_node)\\n\\n            # Check Next Cost Optimized with a heap\\n            if len(heap) > 0:\\n                next_min_node = heappop(heap)[1]\\n                min_node = next_min_node\\n\\n        return sum.get(end_node)\\n```",
                "codeTag": "Python3"
            },
            {
                "id": 352726,
                "title": "java-dp-inplace-with-o-1-space-complexity",
                "content": "```\\nclass Solution {\\n    public int minPathSum(int[][] grid) {\\n        int m = grid.length;\\n        int n = grid[0].length;\\n        // corner case \\n        if(grid == null || m == 0 || grid[0] == null || n == 0) return Integer.MIN_VALUE;\\n        // initialization -> overwrite 1st row & 1st col\\n        for(int i = 1; i < m; i++){\\n            grid[i][0] = grid[i][0] + grid[i-1][0];\\n        }\\n        for(int j = 1; j < n; j++){\\n            grid[0][j] = grid[0][j] + grid[0][j-1];\\n        }\\n        for(int i = 1; i < m; i++){\\n            for(int j = 1; j < n; j++){\\n                grid[i][j] += Math.min(grid[i-1][j], grid[i][j-1]);\\n            }\\n        }\\n        return grid[m - 1][n - 1];\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Dynamic Programming"
                ],
                "code": "```\\nclass Solution {\\n    public int minPathSum(int[][] grid) {\\n        int m = grid.length;\\n        int n = grid[0].length;\\n        // corner case \\n        if(grid == null || m == 0 || grid[0] == null || n == 0) return Integer.MIN_VALUE;\\n        // initialization -> overwrite 1st row & 1st col\\n        for(int i = 1; i < m; i++){\\n            grid[i][0] = grid[i][0] + grid[i-1][0];\\n        }\\n        for(int j = 1; j < n; j++){\\n            grid[0][j] = grid[0][j] + grid[0][j-1];\\n        }\\n        for(int i = 1; i < m; i++){\\n            for(int j = 1; j < n; j++){\\n                grid[i][j] += Math.min(grid[i-1][j], grid[i][j-1]);\\n            }\\n        }\\n        return grid[m - 1][n - 1];\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 267314,
                "title": "c-96-100",
                "content": "```\\npublic class Solution {\\n    public int MinPathSum(int[][] grid) {\\n        for (var i = 0; i < grid.Length; i++)\\n        {\\n            for (var j = 0; j < grid[0].Length; j++)\\n            {\\n                if (i == 0 && j == 0) continue;\\n\\n                grid[i][j] += Math.Min( i > 0 ? grid[i - 1][j] : int.MaxValue, j > 0 ? grid[i][j - 1] : int.MaxValue);\\n            }\\n        }\\n\\n        return grid[grid.Length - 1][grid[0].Length - 1];\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\npublic class Solution {\\n    public int MinPathSum(int[][] grid) {\\n        for (var i = 0; i < grid.Length; i++)\\n        {\\n            for (var j = 0; j < grid[0].Length; j++)\\n            {\\n                if (i == 0 && j == 0) continue;\\n\\n                grid[i][j] += Math.Min( i > 0 ? grid[i - 1][j] : int.MaxValue, j > 0 ? grid[i][j - 1] : int.MaxValue);\\n            }\\n        }\\n\\n        return grid[grid.Length - 1][grid[0].Length - 1];\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 200981,
                "title": "straight-forward-javascript-solution-beats-100",
                "content": "Very easy to understand. It is an Bottom-Up dynamic programming.\\n\\nTime Complexity: **O(n * m)**\\n\\n```javascript\\nvar minPathSum = function(grid) {\\n    for (let i = 0; i < grid.length; i++) {\\n        for (let j = 0; j < grid[0].length; j++) {\\n            if (i === 0 && j === 0) {\\n                continue;\\n            } else if (i === 0) {\\n                grid[i][j] = grid[i][j] + grid[i][j - 1];\\n            } else if (j === 0) {\\n                grid[i][j] = grid[i][j] + grid[i - 1][j];\\n            } else {\\n                grid[i][j] =  grid[i][j] + Math.min(grid[i - 1][j],  grid[i][j - 1]);\\n            }\\n        }\\n    }\\n    return grid[grid.length - 1][grid[0].length - 1];\\n};\\n```",
                "solutionTags": [],
                "code": "```javascript\\nvar minPathSum = function(grid) {\\n    for (let i = 0; i < grid.length; i++) {\\n        for (let j = 0; j < grid[0].length; j++) {\\n            if (i === 0 && j === 0) {\\n                continue;\\n            } else if (i === 0) {\\n                grid[i][j] = grid[i][j] + grid[i][j - 1];\\n            } else if (j === 0) {\\n                grid[i][j] = grid[i][j] + grid[i - 1][j];\\n            } else {\\n                grid[i][j] =  grid[i][j] + Math.min(grid[i - 1][j],  grid[i][j - 1]);\\n            }\\n        }\\n    }\\n    return grid[grid.length - 1][grid[0].length - 1];\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 132703,
                "title": "dijkstra-s-shortest-path-algorithm",
                "content": "We can convert the given input to a DAG by number the vertices 0, 1, 2... and the edge weight to be the value at the sink node.\\nFor the sample input:\\n[\\n  [1,3,1],\\n  [1,5,1],\\n  [4,2,1]\\n]\\n\\nThe corresponding graph would be.\\n![image](https://s3-lc-upload.s3.amazonaws.com/users/charansingh/image_1526912419.png)\\n\\nNow our problem reduces to finding the shortest path from top-left vertex to the bottom-right vertex.\\n\\n```\\n vector<int> adj(vector<vector<int>>& grid, int i) {\\n      vector<int> res;\\n      int cols = grid[0].size();\\n      int rows = grid.size();\\n      int row = i / cols;\\n      int col = i % cols;\\n      if ( row < rows - 1)\\n         res.push_back(i + cols);\\n      if ( col < cols - 1)\\n         res.push_back(i + 1);\\n      return res;\\n    }\\n    int minPathSum(vector<vector<int>>& grid) {\\n       const unsigned int INF = 0x3f3f3f3f;\\n       int V = grid.size() * grid[0].size();\\n       // Create a vector for distances and initialize all distances as infinity\\n       vector<int> dist(V, INF);\\n       // Find shortest path from src(top-left vertex) to dst(bottom-right) vertex;\\n       int src = 0;\\n       dist[src] = 0;\\n       priority_queue<pair<int,int>, vector <pair<int,int>> , greater<pair<int,int>>> pq;\\n       pq.push(make_pair(0, src));\\n       while (!pq.empty()) {\\n          int u = pq.top().second;\\n          pq.pop();\\n          // weight is nothing but the value of grid[row][col]\\n          for (int v : adj(grid, u)) {\\n            int weight = grid[v / grid[0].size()][v % grid[0].size()];\\n            if (dist[v] > dist[u] + weight) {\\n               dist[v] = dist[u] + weight;\\n               pq.push(make_pair(dist[v], v));\\n            }\\n          }\\n       }\\n\\t\\t\\t // Account for the value at [0][0]\\n       return dist[grid.size() * grid[0].size() - 1] + grid[0][0];\\n    }\\n```",
                "solutionTags": [],
                "code": "```\\n vector<int> adj(vector<vector<int>>& grid, int i) {\\n      vector<int> res;\\n      int cols = grid[0].size();\\n      int rows = grid.size();\\n      int row = i / cols;\\n      int col = i % cols;\\n      if ( row < rows - 1)\\n         res.push_back(i + cols);\\n      if ( col < cols - 1)\\n         res.push_back(i + 1);\\n      return res;\\n    }\\n    int minPathSum(vector<vector<int>>& grid) {\\n       const unsigned int INF = 0x3f3f3f3f;\\n       int V = grid.size() * grid[0].size();\\n       // Create a vector for distances and initialize all distances as infinity\\n       vector<int> dist(V, INF);\\n       // Find shortest path from src(top-left vertex) to dst(bottom-right) vertex;\\n       int src = 0;\\n       dist[src] = 0;\\n       priority_queue<pair<int,int>, vector <pair<int,int>> , greater<pair<int,int>>> pq;\\n       pq.push(make_pair(0, src));\\n       while (!pq.empty()) {\\n          int u = pq.top().second;\\n          pq.pop();\\n          // weight is nothing but the value of grid[row][col]\\n          for (int v : adj(grid, u)) {\\n            int weight = grid[v / grid[0].size()][v % grid[0].size()];\\n            if (dist[v] > dist[u] + weight) {\\n               dist[v] = dist[u] + weight;\\n               pq.push(make_pair(dist[v], v));\\n            }\\n          }\\n       }\\n\\t\\t\\t // Account for the value at [0][0]\\n       return dist[grid.size() * grid[0].size() - 1] + grid[0][0];\\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 23644,
                "title": "c-dp-solutions-o-m-n-and-o-n-space",
                "content": "       \\n    // O(m*n) space\\n    int minPathSum1(vector<vector<int>>& grid) {\\n        vector<vector<int>> dp = grid;\\n        int row = dp.size(), col = dp[0].size();\\n        for (unsigned int i = 1; i < row; i++)\\n            dp[i][0] += dp[i-1][0];\\n        for (unsigned int j = 1; j < col;  j++) \\n            dp[0][j] += dp[0][j-1];\\n        for (unsigned int i = 1; i < row; i++) \\n            for (unsigned int j = 1; j < col; j++) \\n                dp[i][j] += min(dp[i-1][j], dp[i][j-1]);\\n        return dp[row-1][col-1];\\n    }\\n    \\n    // O(n) space\\n    int minPathSum(vector<vector<int>>& grid) {\\n        int row = grid.size(), col = grid[0].size();\\n        vector<int> dp = grid[0];\\n        for (unsigned int j = 1; j < col; j++)\\n            dp[j] += dp[j-1];\\n        for (unsigned int i = 1; i < row; i++) {\\n            dp[0] += grid[i][0];\\n            for (unsigned int j = 1; j < col; j++)\\n                dp[j] = grid[i][j] + min(dp[j-1], dp[j]);\\n        }\\n        return dp[col-1];\\n    }",
                "solutionTags": [
                    "C++",
                    "Dynamic Programming"
                ],
                "code": "       \\n    // O(m*n) space\\n    int minPathSum1(vector<vector<int>>& grid) {\\n        vector<vector<int>> dp = grid;\\n        int row = dp.size(), col = dp[0].size();\\n        for (unsigned int i = 1; i < row; i++)\\n            dp[i][0] += dp[i-1][0];\\n        for (unsigned int j = 1; j < col;  j++) \\n            dp[0][j] += dp[0][j-1];\\n        for (unsigned int i = 1; i < row; i++) \\n            for (unsigned int j = 1; j < col; j++) \\n                dp[i][j] += min(dp[i-1][j], dp[i][j-1]);\\n        return dp[row-1][col-1];\\n    }\\n    \\n    // O(n) space\\n    int minPathSum(vector<vector<int>>& grid) {\\n        int row = grid.size(), col = grid[0].size();\\n        vector<int> dp = grid[0];\\n        for (unsigned int j = 1; j < col; j++)\\n            dp[j] += dp[j-1];\\n        for (unsigned int i = 1; i < row; i++) {\\n            dp[0] += grid[i][0];\\n            for (unsigned int j = 1; j < col; j++)\\n                dp[j] = grid[i][j] + min(dp[j-1], dp[j]);\\n        }\\n        return dp[col-1];\\n    }",
                "codeTag": "Unknown"
            },
            {
                "id": 3693641,
                "title": "c-solution-dp-memorization",
                "content": "\\n# Code\\n```\\nclass Solution {\\npublic:\\n\\n    int mini(int m, int n, vector<vector<int>> &arr, vector<vector<int>> &memo){\\n        if(m==0 && n==0){\\n            return arr[0][0];\\n        }\\n        if(m<0 || n<0) return 1e9;\\n\\n        if(memo[m][n]!= -1) return memo[m][n];\\n\\n        int up = arr[m][n] + mini( m-1, n,arr, memo);\\n        int left = arr[m][n] + mini(m, n-1, arr, memo);\\n        memo[m][n] = min(up,  left);\\n        return memo[m][n];\\n    }\\n  \\n    int minPathSum(vector<vector<int>>& grid) {\\n        int m = grid.size(), n = grid[0].size();\\n        vector<vector<int>> memo(m, vector<int>( n, -1));\\n        return mini(m-1, n-1, grid, memo);\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Dynamic Programming",
                    "Memoization"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n\\n    int mini(int m, int n, vector<vector<int>> &arr, vector<vector<int>> &memo){\\n        if(m==0 && n==0){\\n            return arr[0][0];\\n        }\\n        if(m<0 || n<0) return 1e9;\\n\\n        if(memo[m][n]!= -1) return memo[m][n];\\n\\n        int up = arr[m][n] + mini( m-1, n,arr, memo);\\n        int left = arr[m][n] + mini(m, n-1, arr, memo);\\n        memo[m][n] = min(up,  left);\\n        return memo[m][n];\\n    }\\n  \\n    int minPathSum(vector<vector<int>>& grid) {\\n        int m = grid.size(), n = grid[0].size();\\n        vector<vector<int>> memo(m, vector<int>( n, -1));\\n        return mini(m-1, n-1, grid, memo);\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3639702,
                "title": "ekdm-garda-simpul-solution-recursion-memoization",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nRecursive --> memoize\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\nrecursive logic-> YOU ARE ON Nth row and Mth column \\n1. Assume recursion will give minimum sum till (row-1)th and (col-1)th position\\n2. Add current cell value to it.\\n3. Memoize \\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n                     O(n*m)\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n                     O(n*m)\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int solve(vector<vector<int>>&grid,int row,int col,vector<vector<int>>&dp){\\n       \\n        if(row==0 && col==0) return grid[row][col];\\n        if(row<0 || col<0) return 1e9;\\n         if(dp[row][col]!=-1) {\\n            return dp[row][col];\\n        }\\n        return dp[row][col]=grid[row][col]+min(solve(grid,row-1,col,dp),solve(grid,row,col-1,dp));\\n    }\\n    int minPathSum(vector<vector<int>>& grid) {\\n        if(grid.size()==0) return 0;\\n        int n=grid.size();\\n        int m=grid[0].size();\\n        vector<vector<int>>dp(n,vector<int>(m,-1));\\n        return solve(grid,n-1,m-1,dp);\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Dynamic Programming",
                    "Recursion",
                    "Memoization"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int solve(vector<vector<int>>&grid,int row,int col,vector<vector<int>>&dp){\\n       \\n        if(row==0 && col==0) return grid[row][col];\\n        if(row<0 || col<0) return 1e9;\\n         if(dp[row][col]!=-1) {\\n            return dp[row][col];\\n        }\\n        return dp[row][col]=grid[row][col]+min(solve(grid,row-1,col,dp),solve(grid,row,col-1,dp));\\n    }\\n    int minPathSum(vector<vector<int>>& grid) {\\n        if(grid.size()==0) return 0;\\n        int n=grid.size();\\n        int m=grid[0].size();\\n        vector<vector<int>>dp(n,vector<int>(m,-1));\\n        return solve(grid,n-1,m-1,dp);\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3354349,
                "title": "minimum-path-sum-dijikstra-python-3",
                "content": "If you had solved binary path in a maze, you\\'ll deduce its Intaution\\n```\\nclass Solution:\\n    def minPathSum(self, grid: List[List[int]]) -> int:\\n        dis = [[inf] * len(grid[0]) for _ in range(len(grid))]\\n        dis[0][0] = grid[0][0]\\n        \\n        pq = [(grid[0][0], 0, 0)]\\n        directions = [[0,1],[1,0]]\\n        \\n        while pq :\\n            distance,row,col = heappop(pq)\\n            \\n            for dx,dy in directions :\\n                vis_row = row + dx\\n                vis_col = col + dy\\n                if vis_row < len(grid)   and vis_row >=0 and vis_col >= 0 and vis_col< len(grid[0])  :\\n                    if distance + grid[vis_row][vis_col] < dis[vis_row][vis_col] :\\n                        dis[vis_row][vis_col]  = distance + grid[vis_row][vis_col]\\n                        heappush(pq, (distance + grid[vis_row][vis_col],vis_row,vis_col))\\n                        \\n        return dis[-1][-1]\\n",
                "solutionTags": [
                    "Python3",
                    "Graph"
                ],
                "code": "If you had solved binary path in a maze, you\\'ll deduce its Intaution\\n```\\nclass Solution:\\n    def minPathSum(self, grid: List[List[int]]) -> int:\\n        dis = [[inf] * len(grid[0]) for _ in range(len(grid))]\\n        dis[0][0] = grid[0][0]\\n        \\n        pq = [(grid[0][0], 0, 0)]\\n        directions = [[0,1],[1,0]]\\n        \\n        while pq :\\n            distance,row,col = heappop(pq)\\n            \\n            for dx,dy in directions :\\n                vis_row = row + dx\\n                vis_col = col + dy\\n                if vis_row < len(grid)   and vis_row >=0 and vis_col >= 0 and vis_col< len(grid[0])  :\\n                    if distance + grid[vis_row][vis_col] < dis[vis_row][vis_col] :\\n                        dis[vis_row][vis_col]  = distance + grid[vis_row][vis_col]\\n                        heappush(pq, (distance + grid[vis_row][vis_col],vis_row,vis_col))\\n                        \\n        return dis[-1][-1]\\n",
                "codeTag": "Java"
            },
            {
                "id": 3352633,
                "title": "simple-solution-well-explained-c",
                "content": "# Intuition\\nThe very simple approach is to try all paths to reach the destination from source and find the minimum path. Here i started from destionation and found the ways to reach source. (We can not apply grredy here because the elements are not uniform).\\n\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\nThe first approach that hit my brain is recursion, The question allowed to moves right and down, as i am moving backwards(dest. to source) so I\\'m alloweded left or up moves, so the idea is to explore all the paths and find that path which has minimum sum. \\nBase Condition of recursion-\\n1-> Suppose i reached (0,0), in this case I have to add the value present at this index.\\n2-> Suppose a path which takes me to an invalid index, so I did not reach to my destination, In that case I have to return something that this answer never considered in my answer, because we have to find minimum path sum here that\\'s why i returned a big integer.\\nAs I previously said I have two move left and up and they will be called recursively. At last minimum of them will be returned.\\n\\nSo the recursive solution gives TLE, then I opptimized it by using Memoization(saving recursive calls), it further reduced the time complexity but it increased the space complexity because we are using extra space(dp array).\\n\\nTabulation method is more optimized beacuse there is no recursion involved, and we saved the space taken by recursive calls in the programming stack.\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    // Recursive solution(it will give TLE)\\n    int solve(vector<vector<int>>& grid, int i, int j){\\n        if(i==0 && j==0) return grid[i][j];\\n        if(i<0 || j<0) return 1e9;\\n        long left = grid[i][j]+ solve(grid, i, j-1);\\n        long up = grid[i][j]+ solve(grid,i-1, j );\\n        return min(left, up);\\n    }\\n    // MEMOIZATION\\n    int memo(vector<vector<int>>& grid, int i, int j, vector<vector<int>>& dp){\\n        if(i==0 && j==0) return grid[i][j];\\n        if(i<0 || j<0) return 1e9;\\n        if(dp[i][j]!=-1) return dp[i][j];\\n        long left = grid[i][j]+ solve(grid, i, j-1);\\n        long up = grid[i][j]+ solve(grid,i-1, j );  \\n        return dp[i][j] = min(left, up);\\n    }\\n    int minPathSum(vector<vector<int>>& grid) {\\n        // int row= grid.size();\\n        // int col= grid[0].size();\\n        // // return solve(grid,row-1, col-1);\\n        // vector<vector<int>> dp(row,vector<int>(col,-1));\\n        // return memo(grid,row-1, col-1, dp);\\n\\n        // TABULATION\\n        int n= grid.size();\\n        int m= grid[0].size();\\n        vector<vector<int>>dp(n, vector<int>(m,0));\\n        for(int i=0; i<n;i++){\\n            for(int j=0; j<m ;j++){\\n                if(i==0 && j==0) dp[i][j]= grid[i][j];\\n                else{\\n                    int up= grid[i][j];\\n                    int left= grid[i][j];\\n                    if(i>0)\\n                        up += dp[i-1][j];\\n                    else up += 1e9;\\n                    if(j>0)\\n                        left += dp[i][j-1];\\n                    else left+=1e9;\\n                    dp[i][j]= min(up, left);\\n                }\\n            }    \\n        }\\n        return dp[n-1][m-1];\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Dynamic Programming",
                    "Matrix",
                    "Shortest Path"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    // Recursive solution(it will give TLE)\\n    int solve(vector<vector<int>>& grid, int i, int j){\\n        if(i==0 && j==0) return grid[i][j];\\n        if(i<0 || j<0) return 1e9;\\n        long left = grid[i][j]+ solve(grid, i, j-1);\\n        long up = grid[i][j]+ solve(grid,i-1, j );\\n        return min(left, up);\\n    }\\n    // MEMOIZATION\\n    int memo(vector<vector<int>>& grid, int i, int j, vector<vector<int>>& dp){\\n        if(i==0 && j==0) return grid[i][j];\\n        if(i<0 || j<0) return 1e9;\\n        if(dp[i][j]!=-1) return dp[i][j];\\n        long left = grid[i][j]+ solve(grid, i, j-1);\\n        long up = grid[i][j]+ solve(grid,i-1, j );  \\n        return dp[i][j] = min(left, up);\\n    }\\n    int minPathSum(vector<vector<int>>& grid) {\\n        // int row= grid.size();\\n        // int col= grid[0].size();\\n        // // return solve(grid,row-1, col-1);\\n        // vector<vector<int>> dp(row,vector<int>(col,-1));\\n        // return memo(grid,row-1, col-1, dp);\\n\\n        // TABULATION\\n        int n= grid.size();\\n        int m= grid[0].size();\\n        vector<vector<int>>dp(n, vector<int>(m,0));\\n        for(int i=0; i<n;i++){\\n            for(int j=0; j<m ;j++){\\n                if(i==0 && j==0) dp[i][j]= grid[i][j];\\n                else{\\n                    int up= grid[i][j];\\n                    int left= grid[i][j];\\n                    if(i>0)\\n                        up += dp[i-1][j];\\n                    else up += 1e9;\\n                    if(j>0)\\n                        left += dp[i][j-1];\\n                    else left+=1e9;\\n                    dp[i][j]= min(up, left);\\n                }\\n            }    \\n        }\\n        return dp[n-1][m-1];\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3348274,
                "title": "python-easy-dp-beats-90-tc-o-m-n-sc-o-1",
                "content": "# Intuition\\nIteratively add minimum of upper or left cell to the current cell and return the last cell of last row.\\n\\n# Approach\\nFor 0th row, start from (0, 1) position and add the left cell value to the current cell.\\nFor 0th col, start from (1, 0) position and add the upper cell value to the current cell.\\n\\nNow for every other cell starting from (1, 1) position, choose the minimum of the upper cell value or the left cell value and add it to the current cell (as we can only go down or right).\\n\\n# Complexity\\n- Time complexity: $$O(m*n)$$\\n\\n- Space complexity: $$O(1)$$\\n\\n# Code\\n```\\nclass Solution:\\n    def minPathSum(self, grid: List[List[int]]) -> int:\\n        m, n = len(grid), len(grid[0])\\n        for i in range(1, m):\\n            grid[i][0] += grid[i-1][0]\\n        for i in range(1, n):\\n            grid[0][i] += grid[0][i-1]\\n        for i in range(1, m):\\n            for j in range(1, n):\\n                grid[i][j] += min(grid[i-1][j], grid[i][j-1])\\n        return grid[m-1][n-1]\\n```",
                "solutionTags": [
                    "Python3",
                    "Array",
                    "Dynamic Programming"
                ],
                "code": "```\\nclass Solution:\\n    def minPathSum(self, grid: List[List[int]]) -> int:\\n        m, n = len(grid), len(grid[0])\\n        for i in range(1, m):\\n            grid[i][0] += grid[i-1][0]\\n        for i in range(1, n):\\n            grid[0][i] += grid[0][i-1]\\n        for i in range(1, m):\\n            for j in range(1, n):\\n                grid[i][j] += min(grid[i-1][j], grid[i][j-1])\\n        return grid[m-1][n-1]\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3346941,
                "title": "c-time-o-m-n-space-o-1-short-sweet-easy-to-understand-tabulation",
                "content": "````\\nclass Solution {\\npublic:\\n    int minPathSum(vector<vector<int>>& grid) {\\n        int i,j,m=grid.size(),n=grid[0].size();\\n        for(i = 1; i < n; i++){\\n            grid[0][i] += grid[0][i-1];\\n        }\\n        for(j = 1; j < m; j++){\\n            grid[j][0] += grid[j-1][0];\\n        }\\n        for(i = 1; i < m; i++){\\n            for(j = 1; j < n; j++){\\n                grid[i][j] += min(grid[i-1][j],grid[i][j-1]);\\n            }\\n        }\\n        return grid[m-1][n-1];\\n    }\\n};\\n````",
                "solutionTags": [
                    "C++",
                    "C",
                    "Dynamic Programming"
                ],
                "code": "````\\nclass Solution {\\npublic:\\n    int minPathSum(vector<vector<int>>& grid) {\\n        int i,j,m=grid.size(),n=grid[0].size();\\n        for(i = 1; i < n; i++){\\n            grid[0][i] += grid[0][i-1];\\n        }\\n        for(j = 1; j < m; j++){\\n            grid[j][0] += grid[j-1][0];\\n        }\\n        for(i = 1; i < m; i++){\\n            for(j = 1; j < n; j++){\\n                grid[i][j] += min(grid[i-1][j],grid[i][j-1]);\\n            }\\n        }\\n        return grid[m-1][n-1];\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3346886,
                "title": "python-elegant-short-dp-top-down-bottom-up-o-1-memory",
                "content": "# Top-Down DP\\n\\n## Complexity\\n- Time complexity: $$O(n*m)$$\\n- Space complexity: $$O(n*m)$$\\n\\n```\\nclass Solution:\\n    def minPathSum(self, grid: List[List[int]]) -> int:\\n        @cache\\n        def dp(i: int, j: int) -> int:\\n            if i < 0 or j < 0:\\n                return maxsize\\n            if i == j == 0:\\n                return grid[0][0]\\n            return grid[i][j] + min(dp(i - 1, j), dp(i, j - 1))\\n\\n        return dp(len(grid) - 1, len(grid[0]) - 1)\\n```\\n\\n\\n# Dottom-Up DP\\n\\n## Complexity\\n- Time complexity: $$O(n*m)$$\\n- Space complexity: $$O(1)$$\\n\\n```\\nclass Solution:\\n    def minPathSum(self, grid: List[List[int]]) -> int:\\n        n, m = len(grid), len(grid[0])\\n\\n        for i in range(1, n):\\n            grid[i][0] += grid[i - 1][0]\\n\\n        for j in range(1, m):\\n            grid[0][j] += grid[0][j - 1]\\n\\n        for i in range(1, n):\\n            for j in range(1, m):\\n                grid[i][j] += min(grid[i - 1][j], grid[i][j - 1])\\n\\n        return grid[n - 1][m - 1]\\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def minPathSum(self, grid: List[List[int]]) -> int:\\n        @cache\\n        def dp(i: int, j: int) -> int:\\n            if i < 0 or j < 0:\\n                return maxsize\\n            if i == j == 0:\\n                return grid[0][0]\\n            return grid[i][j] + min(dp(i - 1, j), dp(i, j - 1))\\n\\n        return dp(len(grid) - 1, len(grid[0]) - 1)\\n```\n```\\nclass Solution:\\n    def minPathSum(self, grid: List[List[int]]) -> int:\\n        n, m = len(grid), len(grid[0])\\n\\n        for i in range(1, n):\\n            grid[i][0] += grid[i - 1][0]\\n\\n        for j in range(1, m):\\n            grid[0][j] += grid[0][j - 1]\\n\\n        for i in range(1, n):\\n            for j in range(1, m):\\n                grid[i][j] += min(grid[i - 1][j], grid[i][j - 1])\\n\\n        return grid[n - 1][m - 1]\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3346205,
                "title": "easy-java-explained-dp",
                "content": "\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\nThe algorithm works by first initializing the first row and the first column of the **grid** array with the cumulative sum of the numbers in each row and column, respectively. Then, for each cell in the **grid** array that is not in the first row or column, the minimum path sum to reach that cell is the sum of the current cell value and the minimum of the path sum to reach the cell above and the cell to the left. This is computed using the formula **grid[i][j] += Math.min(grid[i-1][j], grid[i][j-1]);**. Finally, the minimum path sum to reach the bottom-right corner of the **grid** array is returned.\\n\\n# Complexity\\n- Time complexity: $$O(m*n)$$\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: $$O(1)$$\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\n    public int minPathSum(int[][] grid) {\\n        int m = grid.length;\\n        int n = grid[0].length;\\n\\n        for(int i=1;i<m; i++){\\n            grid[i][0] += grid[i-1][0];\\n        }\\n        for(int j=1; j<n; j++){\\n            grid[0][j] += grid[0][j-1];\\n        }\\n        for(int i=1; i<m; i++){\\n            for(int j=1; j<n; j++){\\n                grid[i][j] += Math.min(grid[i-1][j], grid[i][j-1]);\\n            }\\n        }\\n        return grid[m-1][n-1];\\n    }\\n}\\n```\\n\\n![a.jpg](https://assets.leetcode.com/users/images/4fcb60b5-156a-4322-bea7-9eaa100b4e78_1679892022.773603.jpeg)\\n\\n# **If you like the Solution Please Upvote me...**\\n",
                "solutionTags": [
                    "Java",
                    "Array",
                    "Dynamic Programming",
                    "Matrix"
                ],
                "code": "```\\nclass Solution {\\n    public int minPathSum(int[][] grid) {\\n        int m = grid.length;\\n        int n = grid[0].length;\\n\\n        for(int i=1;i<m; i++){\\n            grid[i][0] += grid[i-1][0];\\n        }\\n        for(int j=1; j<n; j++){\\n            grid[0][j] += grid[0][j-1];\\n        }\\n        for(int i=1; i<m; i++){\\n            for(int j=1; j<n; j++){\\n                grid[i][j] += Math.min(grid[i-1][j], grid[i][j-1]);\\n            }\\n        }\\n        return grid[m-1][n-1];\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3345904,
                "title": "c-very-simple-and-fast-solution",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\nTime Complexity: o(m*n)\\n\\n- Space complexity:\\nSpace Complexity: o(1)\\n\\n# Code\\n```\\npublic class Solution {\\n    public int MinPathSum(int[][] grid) {\\n        for(int i = 0; i < grid.Length; i++) {\\n            for (int j = 0; j < grid[i].Length; j++) {\\n                if (i == 0 && j == 0)\\n                    continue;\\n\\n                if (i == 0) {\\n                    grid[i][j] += grid[i][j - 1];\\n                    continue;\\n                }\\n\\n                if (j == 0) {\\n                    grid[i][j] += grid[i - 1][j];\\n                    continue;\\n                }\\n\\n                grid[i][j] += Math.Min(grid[i][j - 1], grid[i - 1][j]);\\n            }\\n        }\\n\\n        return grid[grid.Length - 1][grid[0].Length - 1];\\n    }\\n}\\n```",
                "solutionTags": [
                    "C#"
                ],
                "code": "```\\npublic class Solution {\\n    public int MinPathSum(int[][] grid) {\\n        for(int i = 0; i < grid.Length; i++) {\\n            for (int j = 0; j < grid[i].Length; j++) {\\n                if (i == 0 && j == 0)\\n                    continue;\\n\\n                if (i == 0) {\\n                    grid[i][j] += grid[i][j - 1];\\n                    continue;\\n                }\\n\\n                if (j == 0) {\\n                    grid[i][j] += grid[i - 1][j];\\n                    continue;\\n                }\\n\\n                grid[i][j] += Math.Min(grid[i][j - 1], grid[i - 1][j]);\\n            }\\n        }\\n\\n        return grid[grid.Length - 1][grid[0].Length - 1];\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3345767,
                "title": "3-approaches-recursive-to-most-optimised",
                "content": "# Code\\n```\\nclass Solution {\\npublic:\\n\\n\\n// SOLUTION 1 : RECURSIVE APPROACH\\n    int solve(int row, int col, vector<vector<int>>&grid){\\n        // base case\\n        if(row == 0 && col == 0){\\n            return grid[0][0];\\n        }\\n        \\n        // out of bound case\\n        if(row < 0 || col < 0){\\n            return 1e9;\\n        }\\n        \\n        // recursive calls\\n        int up = grid[row][col] + solve(row-1, col, grid);\\n        int left = grid[row][col] + solve(row, col-1, grid);\\n        int ans = min(up , left);\\n        \\n        return ans;\\n    }\\n    \\n// SOLUTION 2 : RECURSIVE + MEMOIZATION APPROACH\\n    int solve2(int i, int j, vector<vector<int>>&grid, vector<vector<int>>&dp){\\n        // base case\\n        if(i == 0 && j == 0){\\n            return grid[0][0];\\n        }\\n        \\n        if( i < 0 || j < 0){\\n            return 1e9;\\n        }\\n        \\n        if(dp[i][j] != -1){\\n            return dp[i][j];\\n        }\\n        \\n        // recursive calls\\n        int up = grid[i][j] + solve2(i-1, j, grid, dp);\\n        int left = grid[i][j] + solve2(i, j-1, grid, dp);\\n        int ans = min(up, left);\\n        \\n        return dp[i][j] = ans;\\n    }\\n\\n\\n// SOLUTION 3 : TABULATION METHOD (BOTTOM UP APPORACH)\\n    int solve3(vector<vector<int>>& grid){\\n        int row = grid.size();\\n        int col = grid[0].size();\\n\\n        vector<vector<int>>dp(row, vector<int>(col, 0));\\n\\n        for(int i = 0; i<row; i++){\\n            for(int j = 0; j<col; j++){\\n\\n                if(i == 0 && j == 0){\\n                    dp[i][j] = grid[i][j];\\n                }\\n\\n                else{\\n\\n                    int up = grid[i][j];\\n                    if(i > 0) up+= dp[i-1][j];\\n                    else up+= 1e9;\\n\\n                    int left = grid[i][j];\\n                    if(j > 0) left+= dp[i][j-1];\\n                    else left += 1e9;\\n\\n                    dp[i][j] = min(up, left);\\n                }\\n            }\\n        }\\n\\n        return dp[row-1][col-1];\\n    }\\n\\n\\n\\n    int minPathSum(vector<vector<int>>& grid) {\\n        // recursive solution \\n        // int row = grid.size();\\n        // int col = grid[0].size();\\n        // return solve(row-1, col-1, grid);\\n        \\n        // recursion + memoization\\n        //    int row = grid.size();\\n        //    int col = grid[0].size();\\n        //    vector<vector<int>>dp(row, vector<int>(col, -1));\\n        //    return solve2(row-1, col-1, grid, dp);\\n\\n        // tabulation method\\n           return solve3(grid);\\n    }\\n\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n\\n\\n// SOLUTION 1 : RECURSIVE APPROACH\\n    int solve(int row, int col, vector<vector<int>>&grid){\\n        // base case\\n        if(row == 0 && col == 0){\\n            return grid[0][0];\\n        }\\n        \\n        // out of bound case\\n        if(row < 0 || col < 0){\\n            return 1e9;\\n        }\\n        \\n        // recursive calls\\n        int up = grid[row][col] + solve(row-1, col, grid);\\n        int left = grid[row][col] + solve(row, col-1, grid);\\n        int ans = min(up , left);\\n        \\n        return ans;\\n    }\\n    \\n// SOLUTION 2 : RECURSIVE + MEMOIZATION APPROACH\\n    int solve2(int i, int j, vector<vector<int>>&grid, vector<vector<int>>&dp){\\n        // base case\\n        if(i == 0 && j == 0){\\n            return grid[0][0];\\n        }\\n        \\n        if( i < 0 || j < 0){\\n            return 1e9;\\n        }\\n        \\n        if(dp[i][j] != -1){\\n            return dp[i][j];\\n        }\\n        \\n        // recursive calls\\n        int up = grid[i][j] + solve2(i-1, j, grid, dp);\\n        int left = grid[i][j] + solve2(i, j-1, grid, dp);\\n        int ans = min(up, left);\\n        \\n        return dp[i][j] = ans;\\n    }\\n\\n\\n// SOLUTION 3 : TABULATION METHOD (BOTTOM UP APPORACH)\\n    int solve3(vector<vector<int>>& grid){\\n        int row = grid.size();\\n        int col = grid[0].size();\\n\\n        vector<vector<int>>dp(row, vector<int>(col, 0));\\n\\n        for(int i = 0; i<row; i++){\\n            for(int j = 0; j<col; j++){\\n\\n                if(i == 0 && j == 0){\\n                    dp[i][j] = grid[i][j];\\n                }\\n\\n                else{\\n\\n                    int up = grid[i][j];\\n                    if(i > 0) up+= dp[i-1][j];\\n                    else up+= 1e9;\\n\\n                    int left = grid[i][j];\\n                    if(j > 0) left+= dp[i][j-1];\\n                    else left += 1e9;\\n\\n                    dp[i][j] = min(up, left);\\n                }\\n            }\\n        }\\n\\n        return dp[row-1][col-1];\\n    }\\n\\n\\n\\n    int minPathSum(vector<vector<int>>& grid) {\\n        // recursive solution \\n        // int row = grid.size();\\n        // int col = grid[0].size();\\n        // return solve(row-1, col-1, grid);\\n        \\n        // recursion + memoization\\n        //    int row = grid.size();\\n        //    int col = grid[0].size();\\n        //    vector<vector<int>>dp(row, vector<int>(col, -1));\\n        //    return solve2(row-1, col-1, grid, dp);\\n\\n        // tabulation method\\n           return solve3(grid);\\n    }\\n\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3345695,
                "title": "java-dp-o-1-space-7-line-solution",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity: $$O(m*n)$$\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: $$O(1)$$\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\n  public int minPathSum(int[][] grid) {\\n    var m = grid.length;\\n    var n = grid[0].length;\\n\\n    for (var i=0; i<m; i++) {\\n      for (var j=0; j<n; j++) {\\n        if (i == 0 && j == 0) continue;\\n\\n        grid[i][j] +=\\n          Math.min(i == 0 ? 1000 : grid[i-1][j],\\n                   j == 0 ? 1000 : grid[i][j-1]);\\n      }\\n    }\\n    return grid[m-1][n-1];\\n  }\\n}\\n```\\nIf you like my solution, please upvote it!",
                "solutionTags": [
                    "Java",
                    "Dynamic Programming",
                    "Matrix"
                ],
                "code": "```\\nclass Solution {\\n  public int minPathSum(int[][] grid) {\\n    var m = grid.length;\\n    var n = grid[0].length;\\n\\n    for (var i=0; i<m; i++) {\\n      for (var j=0; j<n; j++) {\\n        if (i == 0 && j == 0) continue;\\n\\n        grid[i][j] +=\\n          Math.min(i == 0 ? 1000 : grid[i-1][j],\\n                   j == 0 ? 1000 : grid[i][j-1]);\\n      }\\n    }\\n    return grid[m-1][n-1];\\n  }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3335810,
                "title": "tabulation-approach-based-explanation-c-beats-100",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nSince there can be numerous number of ways using which we can reach from (0,0) to (m-1, n-1), recursion is evident that it needs to be applied here. Also, after applying some basic recursion, we accordingly optimise our code using memoization, tabulation and space optimisation techniques.\\n![image.png](https://assets.leetcode.com/users/images/59a709e2-b2db-4dbe-bf2a-37cc20ef5f27_1679660889.3993416.png)\\n\\n\\n\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n=Declare a dp[] array of size [n][m].\\n=First initialize the base condition values, i.e dp[0][0] = matrix[0][0]\\n=Our answer should get stored in dp[n-1][m-1]. We want to move from (0,0) to (n-1,m-1). But we can\\u2019t move arbitrarily, we should move such that at a particular i and j, we have all the values required to compute dp[i][j].\\n=If we see the memoized code, values required for dp[i][j] are: dp[i-1][j] and dp[i][j-1]. So we only use the previous row and column value.\\n=We have already filled the top-left corner (i=0 and j=0), if we move in any of the two following ways(given below), at every cell we do have all the previous values required to compute its value.\\n=We can use two nested loops to have this traversal\\n=Whenever i>0 , j>0, we will simply mark dp[i][j] = matric[i][j] + min(dp[i-1][j],dp[i][j-1]), according to our recursive relation.\\n=When i=0 or j=0, we add to up( or left) 1e9, so that this path can be rejected.\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\nO(n*m) {as there are two nested loops}\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\nO(n*m) {as we are using an array of size n*m}\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int minPathSum(vector<vector<int>>& grid) {\\n        int m = grid.size();\\n        int n = grid[0].size();\\n        \\n        vector<vector<int>>dp(m, vector<int>(n, 0));\\n        \\n        for(int i = 0; i<m; i++){\\n            for(int j = 0; j<n; j++){\\n                if(i==0 && j==0) dp[i][j] = grid[i][j];\\n                \\n                else{\\n                    int up = grid[i][j];\\n                    if(i>0) up+=dp[i-1][j];\\n                    else up+=1e9;\\n                    \\n                    int left = grid[i][j];\\n                    if(j>0) left+=dp[i][j-1];\\n                    else left+=1e9;\\n                    \\n                    dp[i][j] = min(up, left);\\n                }\\n            }\\n        }\\n        \\n        return dp[m-1][n-1];\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int minPathSum(vector<vector<int>>& grid) {\\n        int m = grid.size();\\n        int n = grid[0].size();\\n        \\n        vector<vector<int>>dp(m, vector<int>(n, 0));\\n        \\n        for(int i = 0; i<m; i++){\\n            for(int j = 0; j<n; j++){\\n                if(i==0 && j==0) dp[i][j] = grid[i][j];\\n                \\n                else{\\n                    int up = grid[i][j];\\n                    if(i>0) up+=dp[i-1][j];\\n                    else up+=1e9;\\n                    \\n                    int left = grid[i][j];\\n                    if(j>0) left+=dp[i][j-1];\\n                    else left+=1e9;\\n                    \\n                    dp[i][j] = min(up, left);\\n                }\\n            }\\n        }\\n        \\n        return dp[m-1][n-1];\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3287986,
                "title": "java-memoization-solution-99-faster",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n    O(n*m)\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n    O(n*m)\\n# Code\\n```\\nclass Solution {\\n    public int f(int i , int j , int[][] grid,int n , int m , int[][] dp) {\\n        if(i == n-1 && j == m-1) return grid[i][j]; \\n        if(i == n || j== m) return (int)1e9;\\n        if(dp[i][j] != -1) return dp[i][j];\\n        int right = grid[i][j] + f(i,j+1,grid,n,m,dp);\\n        int down = grid[i][j] + f(i+1,j,grid,n,m,dp);\\n        return dp[i][j] = Math.min(right,down);\\n\\n    }\\n    public int minPathSum(int[][] grid) {\\n        int n = grid.length,m = grid[0].length;\\n        int[][] dp = new int[n][m];\\n        for(int[] d : dp) Arrays.fill(d,-1);\\n        return f(0,0,grid,n,m,dp);\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Memoization"
                ],
                "code": "```\\nclass Solution {\\n    public int f(int i , int j , int[][] grid,int n , int m , int[][] dp) {\\n        if(i == n-1 && j == m-1) return grid[i][j]; \\n        if(i == n || j== m) return (int)1e9;\\n        if(dp[i][j] != -1) return dp[i][j];\\n        int right = grid[i][j] + f(i,j+1,grid,n,m,dp);\\n        int down = grid[i][j] + f(i+1,j,grid,n,m,dp);\\n        return dp[i][j] = Math.min(right,down);\\n\\n    }\\n    public int minPathSum(int[][] grid) {\\n        int n = grid.length,m = grid[0].length;\\n        int[][] dp = new int[n][m];\\n        for(int[] d : dp) Arrays.fill(d,-1);\\n        return f(0,0,grid,n,m,dp);\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3182290,
                "title": "time-o-m-n-space-o-1-c",
                "content": "```\\nclass Solution {\\npublic:\\n    int minPathSum(vector<vector<int>>& grid) {\\n        int i,j,m=grid.size(),n=grid[0].size();\\n        for(j = 1; j < n;j++){\\n            grid[0][j] += grid[0][j-1];\\n        }\\n        for(i = 1; i < m; i++){\\n            grid[i][0] += grid[i-1][0];\\n        }\\n        for(i = 1; i < m; i++){\\n            for(j = 1; j < n; j++){\\n                grid[i][j] = min(grid[i-1][j],grid[i][j-1])+grid[i][j];\\n            }\\n        }\\n        return grid[m-1][n-1];\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "C",
                    "Dynamic Programming"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int minPathSum(vector<vector<int>>& grid) {\\n        int i,j,m=grid.size(),n=grid[0].size();\\n        for(j = 1; j < n;j++){\\n            grid[0][j] += grid[0][j-1];\\n        }\\n        for(i = 1; i < m; i++){\\n            grid[i][0] += grid[i-1][0];\\n        }\\n        for(i = 1; i < m; i++){\\n            for(j = 1; j < n; j++){\\n                grid[i][j] = min(grid[i-1][j],grid[i][j-1])+grid[i][j];\\n            }\\n        }\\n        return grid[m-1][n-1];\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3180672,
                "title": "beats-96-4-64-minimum-path-sum-with-step-by-step-explanation",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n- Initialize m and n as the number of rows and columns of the grid.\\n- Initialize dp list of size n with the first element of dp being the first element of the first row of the grid.\\n- Loop through the remaining columns of the first row, updating each dp[i] as dp[i-1] + grid[0][i].\\n- Loop through the remaining rows of the grid, updating the first column of each row as dp[0] + grid[i][0].\\n- Loop through the remaining columns of the current row, updating each dp[j] as the minimum of dp[j-1] and dp[j] plus the current grid element.\\n- Return the last element of dp which is the minimum path sum from top left to bottom right.\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution:\\n    def minPathSum(self, grid: List[List[int]]) -> int:\\n        m, n = len(grid), len(grid[0])\\n        dp = [0] * n\\n        dp[0] = grid[0][0]\\n        for i in range(1, n):\\n            dp[i] = dp[i-1] + grid[0][i]\\n        for i in range(1, m):\\n            dp[0] += grid[i][0]\\n            for j in range(1, n):\\n                dp[j] = min(dp[j-1], dp[j]) + grid[i][j]\\n        return dp[n-1]\\n\\n```",
                "solutionTags": [
                    "Python",
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def minPathSum(self, grid: List[List[int]]) -> int:\\n        m, n = len(grid), len(grid[0])\\n        dp = [0] * n\\n        dp[0] = grid[0][0]\\n        for i in range(1, n):\\n            dp[i] = dp[i-1] + grid[0][i]\\n        for i in range(1, m):\\n            dp[0] += grid[i][0]\\n            for j in range(1, n):\\n                dp[j] = min(dp[j-1], dp[j]) + grid[i][j]\\n        return dp[n-1]\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3164319,
                "title": "solution",
                "content": "```C++ []\\nclass Solution {\\npublic:\\n    int minPathSum(vector<vector<int>>& grid) {\\n        int i,j,m=grid.size(),n=grid[0].size();\\n        for(j = 1; j < n;j++){\\n            grid[0][j] += grid[0][j-1];\\n        }\\n        for(i = 1; i < m; i++){\\n            grid[i][0] += grid[i-1][0];\\n        }\\n        for(i = 1; i < m; i++){\\n            for(j = 1; j < n; j++){\\n                grid[i][j] = min(grid[i-1][j],grid[i][j-1])+grid[i][j];\\n            }\\n        }\\n        return grid[m-1][n-1];\\n    }\\n};\\n```\\n\\n```Python3 []\\nclass Solution:\\n    def minPathSum(self, grid: List[List[int]]) -> int:\\n        sols = [[x for x in row] for row in grid]\\n\\n        for row in range(1, len(grid)):\\n            sols[row][0] += sols[row - 1][0]\\n\\n        for col in range(1, len(grid[0])):\\n            sols[0][col] += sols[0][col - 1]\\n        \\n        for row in range(1, len(grid)):\\n            for col in range(1, len(grid[0])):\\n                sols[row][col] += min(sols[row - 1][col], sols[row][col - 1])\\n\\n        return sols[-1][-1]\\n```\\n\\n```Java []\\nclass Solution {\\n    public int minPathSum(int[][] grid) {\\n        fill(0, 0, grid);\\n        return grid[grid.length - 1][grid[0].length - 1];\\n    }\\n\\n    public void fill(int row, int col, int[][] grid) {\\n        if (row >= grid.length || col >= grid[0].length) {\\n            return;\\n        }\\n        if (row != 0 && col != 0) {\\n            grid[row][col] = grid[row][col] + Math.min(grid[row - 1][col], grid[row][col - 1]);\\n        }\\n        for (int i = row + 1; i < grid.length; i++) {\\n            if (col == 0) {\\n                grid[i][col] = grid[i - 1][col] + grid[i][col];\\n            } else {\\n                grid[i][col] = grid[i][col] + Math.min(grid[i - 1][col], grid[i][col - 1]);\\n            }\\n        }\\n\\n        for (int i = col + 1; i < grid[0].length; i++) {\\n            if (row == 0) {\\n                grid[row][i] = grid[row][i - 1] + grid[row][i];\\n            } else {\\n            grid[row][i] = grid[row][i] + Math.min(grid[row][i - 1], grid[row - 1][i]);\\n            }\\n        } \\n        fill(row + 1, col + 1, grid);\\n    }\\n}\\n```\\n",
                "solutionTags": [
                    "C++",
                    "Java",
                    "Python3"
                ],
                "code": "```C++ []\\nclass Solution {\\npublic:\\n    int minPathSum(vector<vector<int>>& grid) {\\n        int i,j,m=grid.size(),n=grid[0].size();\\n        for(j = 1; j < n;j++){\\n            grid[0][j] += grid[0][j-1];\\n        }\\n        for(i = 1; i < m; i++){\\n            grid[i][0] += grid[i-1][0];\\n        }\\n        for(i = 1; i < m; i++){\\n            for(j = 1; j < n; j++){\\n                grid[i][j] = min(grid[i-1][j],grid[i][j-1])+grid[i][j];\\n            }\\n        }\\n        return grid[m-1][n-1];\\n    }\\n};\\n```\n```Python3 []\\nclass Solution:\\n    def minPathSum(self, grid: List[List[int]]) -> int:\\n        sols = [[x for x in row] for row in grid]\\n\\n        for row in range(1, len(grid)):\\n            sols[row][0] += sols[row - 1][0]\\n\\n        for col in range(1, len(grid[0])):\\n            sols[0][col] += sols[0][col - 1]\\n        \\n        for row in range(1, len(grid)):\\n            for col in range(1, len(grid[0])):\\n                sols[row][col] += min(sols[row - 1][col], sols[row][col - 1])\\n\\n        return sols[-1][-1]\\n```\n```Java []\\nclass Solution {\\n    public int minPathSum(int[][] grid) {\\n        fill(0, 0, grid);\\n        return grid[grid.length - 1][grid[0].length - 1];\\n    }\\n\\n    public void fill(int row, int col, int[][] grid) {\\n        if (row >= grid.length || col >= grid[0].length) {\\n            return;\\n        }\\n        if (row != 0 && col != 0) {\\n            grid[row][col] = grid[row][col] + Math.min(grid[row - 1][col], grid[row][col - 1]);\\n        }\\n        for (int i = row + 1; i < grid.length; i++) {\\n            if (col == 0) {\\n                grid[i][col] = grid[i - 1][col] + grid[i][col];\\n            } else {\\n                grid[i][col] = grid[i][col] + Math.min(grid[i - 1][col], grid[i][col - 1]);\\n            }\\n        }\\n\\n        for (int i = col + 1; i < grid[0].length; i++) {\\n            if (row == 0) {\\n                grid[row][i] = grid[row][i - 1] + grid[row][i];\\n            } else {\\n            grid[row][i] = grid[row][i] + Math.min(grid[row][i - 1], grid[row - 1][i]);\\n            }\\n        } \\n        fill(row + 1, col + 1, grid);\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3096502,
                "title": "2-ms-fastest-ever-java-python-bottom-up-dp-space-optimized",
                "content": "\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n// 2D Dp\\nExcept boundary cases :\\n *   dp[i][j]=Math.min(dp[i-1][j],dp[i][j-1])+grid[i][j]\\n\\n// 1D space optimized\\nPreprocess the dp[] array with the first rwo of the grid.\\nThen iterate through remaining elements and choose :\\n*    dp[j]=Math.min(dp[j],dp[j-1])+grid[i][j]\\n# Complexity\\n- Time complexity:O(n*m)\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:O(m)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n# In-place \\n```\\nclass Solution:\\n    def minPathSum(self, grid: List[List[int]]) -> int:\\n        for i in range(len(grid)):\\n            for j in range(len(grid[0])):\\n                if i==0 and j==0:\\n                    continue\\n                elif i==0:\\n                    grid[i][j]+=grid[i][j-1]\\n                elif j==0:\\n                    grid[i][j]+=grid[i-1][j]\\n                else:\\n                    grid[i][j]=min(grid[i-1][j],grid[i][j-1])+grid[i][j]\\n        return grid[-1][-1]\\n```\\n# Space optimized (Not in-place)\\n```\\nclass Solution { // 1D space optimized\\n    public int minPathSum(int[][] grid) {\\n        int m=grid.length,n=grid[0].length;\\n        int dp[]=new int[n];\\n        dp[0]=grid[0][0];\\n        for(int i=1;i<n;i++)\\n        {\\n            dp[i]=dp[i-1]+grid[0][i];\\n        }\\n        for(int i=1;i<m;i++)\\n        for(int j=0;j<n;j++)\\n        {\\n            if(j==0) dp[j]=grid[i][j]+dp[j];\\n            else\\n            dp[j]=Math.min(dp[j],dp[j-1])+grid[i][j];\\n        }\\n        return dp[n-1];\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Python3",
                    "Matrix"
                ],
                "code": "```\\nclass Solution:\\n    def minPathSum(self, grid: List[List[int]]) -> int:\\n        for i in range(len(grid)):\\n            for j in range(len(grid[0])):\\n                if i==0 and j==0:\\n                    continue\\n                elif i==0:\\n                    grid[i][j]+=grid[i][j-1]\\n                elif j==0:\\n                    grid[i][j]+=grid[i-1][j]\\n                else:\\n                    grid[i][j]=min(grid[i-1][j],grid[i][j-1])+grid[i][j]\\n        return grid[-1][-1]\\n```\n```\\nclass Solution { // 1D space optimized\\n    public int minPathSum(int[][] grid) {\\n        int m=grid.length,n=grid[0].length;\\n        int dp[]=new int[n];\\n        dp[0]=grid[0][0];\\n        for(int i=1;i<n;i++)\\n        {\\n            dp[i]=dp[i-1]+grid[0][i];\\n        }\\n        for(int i=1;i<m;i++)\\n        for(int j=0;j<n;j++)\\n        {\\n            if(j==0) dp[j]=grid[i][j]+dp[j];\\n            else\\n            dp[j]=Math.min(dp[j],dp[j-1])+grid[i][j];\\n        }\\n        return dp[n-1];\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3060624,
                "title": "dynamic-programming-solution-in-python3",
                "content": "# | Dynamic Programming Solution in Python3:\\n\\n![solution.png](https://assets.leetcode.com/users/images/c42cc536-3e54-4245-a93d-7d0b4bdcbaf1_1673897684.0651052.png)\\n\\n### Complexity\\n***Time complexity =>***  \\nO(n^2)\\n***Space complexity =>***  \\nO(n^2)\\n\\n## Code\\n```\\nclass Solution:\\n    def minPathSum(self, grid: List[List[int]]) -> int:\\n        n = len(grid[0])\\n        m = len(grid)\\n        \\n        dp = [[0]*(n) for x in range(m)]\\n        \\n        for i in range(m):\\n            for j in range(n):\\n                if i==0 and j==0:\\n                    dp[i][j] = grid[i][j]\\n                elif i == 0:\\n                    dp[i][j] = grid[i][j] + dp[i][j - 1]\\n                elif j == 0:\\n                    dp[i][j] = grid[i][j] + dp[i - 1][j]\\n                else:\\n                    dp[i][j] = min(grid[i][j] + dp[i-1][j], grid[i][j] + dp[i][j - 1])\\n        \\n        return dp[m-1][n-1]\\n        \\n```",
                "solutionTags": [
                    "Python3",
                    "Dynamic Programming"
                ],
                "code": "```\\nclass Solution:\\n    def minPathSum(self, grid: List[List[int]]) -> int:\\n        n = len(grid[0])\\n        m = len(grid)\\n        \\n        dp = [[0]*(n) for x in range(m)]\\n        \\n        for i in range(m):\\n            for j in range(n):\\n                if i==0 and j==0:\\n                    dp[i][j] = grid[i][j]\\n                elif i == 0:\\n                    dp[i][j] = grid[i][j] + dp[i][j - 1]\\n                elif j == 0:\\n                    dp[i][j] = grid[i][j] + dp[i - 1][j]\\n                else:\\n                    dp[i][j] = min(grid[i][j] + dp[i-1][j], grid[i][j] + dp[i][j - 1])\\n        \\n        return dp[m-1][n-1]\\n        \\n```",
                "codeTag": "Java"
            },
            {
                "id": 3041086,
                "title": "recursion-to-space-optimization-all-solutions",
                "content": "**DO UPVOTE IF YOU FIND IT HELPFUL**\\n\\n**RECURSION**\\n```\\n  int solve(int i,int j,vector<vector<int>>& grid)\\n     {\\n         if(i==0 && j==0)\\n         return grid[0][0];\\n         if(i<0||j<0)\\n         return 1e9;\\n         int up=grid[i][j] + solve(i-1,j,grid);\\n         int left=grid[i][j] + solve(i,j-1,grid);\\n         return min(left,up);\\n     }\\n```\\n**MEMOIZATION**\\n```\\nint solve(int i,int j,vector<vector<int>>& grid,vector<vector<int>>&dp)\\n     {\\n         if(i==0 && j==0)\\n         return grid[0][0];\\n         if(i<0||j<0)\\n         return 1e9;\\n         if(dp[i][j]!=-1)\\n         return dp[i][j];\\n\\n         int up=grid[i][j] + solve(i-1,j,grid,dp);\\n         int left=grid[i][j] + solve(i,j-1,grid,dp);\\n         return dp[i][j]= min(left,up);\\n    }\\n```\\n**TABULATION**\\n```\\n vector<vector<int>>dp(n,vector<int>(m,0));\\n     for(int i=0;i<n;i++)\\n     {\\n         for(int j=0;j<m;j++)\\n         {\\n             if(i==0&&j==0)\\n              dp[i][j]=grid[i][j];\\n              else\\n              {\\n                  int up=1e9,left=1e9;\\n                  if(i>0)\\n                  up=grid[i][j]+dp[i-1][j];\\n                  if(j>0)\\n                  left=grid[i][j]+dp[i][j-1];\\n                  dp[i][j]=min(up,left);\\n              }\\n         }\\n     }\\n     return dp[n-1][m-1];\\n```\\n**SPACE OPTIMIZATION**\\n\\n```\\nvector<int>prev(m,0),curr(m,0);\\n      for(int i=0;i<n;i++)\\n      {\\n          for(int j=0;j<m;j++)\\n          {\\n              if(i==0&&j==0)\\n               curr[j]=grid[i][j];\\n               else\\n               {\\n                   int up=1e9,left=1e9;\\n                   if(i>0)\\n                   up=grid[i][j]+prev[j];\\n                   if(j>0)\\n                   left=grid[i][j]+curr[j-1];\\n                   curr[j]=min(up,left);\\n               }\\n          }\\n          prev=curr;\\n      }\\n      return prev[m-1];\\n```",
                "solutionTags": [
                    "C++",
                    "Dynamic Programming",
                    "Recursion",
                    "Memoization"
                ],
                "code": "```\\n  int solve(int i,int j,vector<vector<int>>& grid)\\n     {\\n         if(i==0 && j==0)\\n         return grid[0][0];\\n         if(i<0||j<0)\\n         return 1e9;\\n         int up=grid[i][j] + solve(i-1,j,grid);\\n         int left=grid[i][j] + solve(i,j-1,grid);\\n         return min(left,up);\\n     }\\n```\n```\\nint solve(int i,int j,vector<vector<int>>& grid,vector<vector<int>>&dp)\\n     {\\n         if(i==0 && j==0)\\n         return grid[0][0];\\n         if(i<0||j<0)\\n         return 1e9;\\n         if(dp[i][j]!=-1)\\n         return dp[i][j];\\n\\n         int up=grid[i][j] + solve(i-1,j,grid,dp);\\n         int left=grid[i][j] + solve(i,j-1,grid,dp);\\n         return dp[i][j]= min(left,up);\\n    }\\n```\n```\\n vector<vector<int>>dp(n,vector<int>(m,0));\\n     for(int i=0;i<n;i++)\\n     {\\n         for(int j=0;j<m;j++)\\n         {\\n             if(i==0&&j==0)\\n              dp[i][j]=grid[i][j];\\n              else\\n              {\\n                  int up=1e9,left=1e9;\\n                  if(i>0)\\n                  up=grid[i][j]+dp[i-1][j];\\n                  if(j>0)\\n                  left=grid[i][j]+dp[i][j-1];\\n                  dp[i][j]=min(up,left);\\n              }\\n         }\\n     }\\n     return dp[n-1][m-1];\\n```\n```\\nvector<int>prev(m,0),curr(m,0);\\n      for(int i=0;i<n;i++)\\n      {\\n          for(int j=0;j<m;j++)\\n          {\\n              if(i==0&&j==0)\\n               curr[j]=grid[i][j];\\n               else\\n               {\\n                   int up=1e9,left=1e9;\\n                   if(i>0)\\n                   up=grid[i][j]+prev[j];\\n                   if(j>0)\\n                   left=grid[i][j]+curr[j-1];\\n                   curr[j]=min(up,left);\\n               }\\n          }\\n          prev=curr;\\n      }\\n      return prev[m-1];\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3015988,
                "title": "easy-java-solution-recursive-dp-beginner-friendly",
                "content": "# Intuition\\n1. Handle base cases\\n2. Get down and right value recursive\\n3. Return min(down, right) + self value\\n\\n# Code\\n```\\nclass Solution {\\n    public int minPathSum(int[][] grid, int row, int col, int[][] dp) {\\n        if(row < 0 || row >= grid.length || col < 0 || col >=grid[0].length){\\n            return Integer.MAX_VALUE;\\n        }\\n        if(dp[row][col] != 0) {\\n            return dp[row][col];\\n        }\\n        if(row == grid.length -1 && col == grid[0].length - 1) {\\n            return grid[row][col];\\n        }\\n\\n        int rightSum = minPathSum(grid, row, col + 1, dp);\\n        int downSum = minPathSum(grid, row + 1, col, dp);\\n        return dp[row][col] = Math.min(rightSum, downSum) + grid[row][col];\\n        \\n    }\\n    public int minPathSum(int[][] grid) {\\n        int[][] dp = new int[grid.length][grid[0].length];\\n        return minPathSum(grid, 0 ,0, dp);\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int minPathSum(int[][] grid, int row, int col, int[][] dp) {\\n        if(row < 0 || row >= grid.length || col < 0 || col >=grid[0].length){\\n            return Integer.MAX_VALUE;\\n        }\\n        if(dp[row][col] != 0) {\\n            return dp[row][col];\\n        }\\n        if(row == grid.length -1 && col == grid[0].length - 1) {\\n            return grid[row][col];\\n        }\\n\\n        int rightSum = minPathSum(grid, row, col + 1, dp);\\n        int downSum = minPathSum(grid, row + 1, col, dp);\\n        return dp[row][col] = Math.min(rightSum, downSum) + grid[row][col];\\n        \\n    }\\n    public int minPathSum(int[][] grid) {\\n        int[][] dp = new int[grid.length][grid[0].length];\\n        return minPathSum(grid, 0 ,0, dp);\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2970608,
                "title": "memoization-tabulation-space-optimization-c",
                "content": "# Memoization\\n```\\nclass Solution {\\n    int dfs(int i, int j, vector<vector<int>> &grid, vector<vector<int>> &dp) {\\n        if(!i && !j) return grid[i][j];\\n        if(i < 0 || j < 0) return INT_MAX;\\n        if(dp[i][j] != -1) return dp[i][j];\\n\\n        int u = dfs(i - 1, j, grid, dp);\\n        int l = dfs(i, j - 1, grid, dp);\\n\\n        return dp[i][j] = grid[i][j] + min(u, l);\\n    }\\npublic:\\n    int minPathSum(vector<vector<int>>& grid) {\\n        int n = grid.size(), m = grid[0].size();\\n        vector<vector<int>> dp(n, vector<int>(m, -1));\\n\\n        return dfs(n - 1, m - 1, grid, dp);\\n    }\\n};\\n```\\n\\n# Tabulation\\n```\\nclass Solution {\\npublic:\\n    int minPathSum(vector<vector<int>>& grid) {\\n        int n = grid.size(), m = grid[0].size();\\n        vector<vector<int>> dp(n, vector<int>(m, -1));\\n        dp[0][0] = grid[0][0];\\n\\n        for(int i=0; i<n; i++) {\\n            for(int j=0; j<m; j++) {\\n                if(!i && !j) continue;\\n                int u = INT_MAX, l = INT_MAX;\\n                if(i > 0) u = dp[i - 1][j];\\n                if(j > 0) l = dp[i][j - 1];\\n                dp[i][j] = grid[i][j] + min(u, l);\\n            }\\n        }\\n        return dp[n - 1][m - 1];\\n    }\\n};\\n```\\n\\n# Space Optimization\\n```\\nclass Solution {\\npublic:\\n    int minPathSum(vector<vector<int>>& grid) {\\n        int n = grid.size(), m = grid[0].size();\\n        vector<int> dp(m, INT_MAX);\\n        dp[0] = 0;\\n\\n        for(int i=0; i<n; i++) {\\n            vector<int> temp(m);\\n            for(int j=0; j<m; j++) {\\n                temp[j] = grid[i][j] + min(dp[j], (j > 0 ? temp[j - 1] : INT_MAX));\\n            }\\n            dp = temp;\\n        }\\n        return dp[m - 1];\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Dynamic Programming",
                    "Memoization"
                ],
                "code": "```\\nclass Solution {\\n    int dfs(int i, int j, vector<vector<int>> &grid, vector<vector<int>> &dp) {\\n        if(!i && !j) return grid[i][j];\\n        if(i < 0 || j < 0) return INT_MAX;\\n        if(dp[i][j] != -1) return dp[i][j];\\n\\n        int u = dfs(i - 1, j, grid, dp);\\n        int l = dfs(i, j - 1, grid, dp);\\n\\n        return dp[i][j] = grid[i][j] + min(u, l);\\n    }\\npublic:\\n    int minPathSum(vector<vector<int>>& grid) {\\n        int n = grid.size(), m = grid[0].size();\\n        vector<vector<int>> dp(n, vector<int>(m, -1));\\n\\n        return dfs(n - 1, m - 1, grid, dp);\\n    }\\n};\\n```\n```\\nclass Solution {\\npublic:\\n    int minPathSum(vector<vector<int>>& grid) {\\n        int n = grid.size(), m = grid[0].size();\\n        vector<vector<int>> dp(n, vector<int>(m, -1));\\n        dp[0][0] = grid[0][0];\\n\\n        for(int i=0; i<n; i++) {\\n            for(int j=0; j<m; j++) {\\n                if(!i && !j) continue;\\n                int u = INT_MAX, l = INT_MAX;\\n                if(i > 0) u = dp[i - 1][j];\\n                if(j > 0) l = dp[i][j - 1];\\n                dp[i][j] = grid[i][j] + min(u, l);\\n            }\\n        }\\n        return dp[n - 1][m - 1];\\n    }\\n};\\n```\n```\\nclass Solution {\\npublic:\\n    int minPathSum(vector<vector<int>>& grid) {\\n        int n = grid.size(), m = grid[0].size();\\n        vector<int> dp(m, INT_MAX);\\n        dp[0] = 0;\\n\\n        for(int i=0; i<n; i++) {\\n            vector<int> temp(m);\\n            for(int j=0; j<m; j++) {\\n                temp[j] = grid[i][j] + min(dp[j], (j > 0 ? temp[j - 1] : INT_MAX));\\n            }\\n            dp = temp;\\n        }\\n        return dp[m - 1];\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2912143,
                "title": "c-recursion-memorization-tabulation-space-optimization-teache-by-striver",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity: o(m*N)\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: o(N) + O(M-1 N-1)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\n*********************RECURSION********************************\\nclass Solution {\\n    long long func(int i,int j,vector<vector<int>>&grid){\\n        if(i==0 && j==0){\\n            return grid[0][0];\\n        }\\n      if(i<0 || j<0){\\n          return INT_MAX;\\n      }\\n      long long up = grid[i][j] + func(i-1,j,grid);\\n      long long  left = grid[i][j] + func(i,j-1,grid);\\n      return min(left,up);\\n    }\\npublic:\\n    int minPathSum(vector<vector<int>>& grid) {\\n        int  m=grid.size();\\n        int n=grid[0].size();\\n        return func(m-1,n-1,grid);\\n        \\n    }\\n};\\n\\n****************************MEMORIZATION*************************\\nclass Solution {\\n    long long func(int i,int j,vector<vector<int>>&grid,vector<vector<int>>&dp){\\n        if(i==0 && j==0){\\n            return grid[0][0];\\n        }\\n      if(i<0 || j<0){\\n          return INT_MAX;\\n      }\\n      if(dp[i][j] != -1) return dp[i][j];\\n      long long up = grid[i][j] + func(i-1,j,grid,dp);\\n      long long  left = grid[i][j] + func(i,j-1,grid,dp);\\n      return dp[i][j] = min(left,up);\\n    }\\npublic:\\n    int minPathSum(vector<vector<int>>& grid) {\\n        int  m=grid.size();\\n        int n=grid[0].size();\\n        vector<vector<int>>dp(m,vector<int>(n,-1));\\n        return func(m-1,n-1,grid,dp);\\n        \\n    }\\n};\\n******************************TABULATION********************************\\n\\npublic:\\n    int minPathSum(vector<vector<int>>& grid) {\\n        int  m=grid.size();\\n        int n=grid[0].size();\\n        vector<vector<int>>dp(m,vector<int>(n,0));\\n        for(int i=0;i<m;i++){\\n            for(int j=0;j<n;j++){\\n                if(i==0 && j==0){\\n                    dp[i][j] = grid[0][0];\\n                }\\n                else {\\n                    int up = grid[i][j];\\n                    int left = grid[i][j];\\n                    if(i>0) up +=dp[i-1][j];\\n                    else up +=1e9;\\n                    if(j>0) left +=dp[i][j-1];\\n                    else left +=1e9;\\n\\n                    dp[i][j] = min(up,left);\\n                }\\n            }\\n        }\\n        return dp[m-1][n-1];\\n        \\n    }\\n};\\n************************SPACE OPTIMIZATION*************************\\n\\nclass Solution {\\npublic:\\n    int minPathSum(vector<vector<int>>& grid) {\\n        int  m=grid.size();\\n        int n=grid[0].size();\\n        vector<int>prev(n,0);\\n        for(int i=0;i<m;i++){\\n            vector<int>temp(n,0);\\n            for(int j=0;j<n;j++){\\n                if(i==0 && j==0){\\n                    temp[j] = grid[0][0];\\n                }\\n                else {\\n                    int up = grid[i][j];\\n                    int left = grid[i][j];\\n                    if(i>0) up +=prev[j];\\n                    else up +=1e9;\\n                    if(j>0) left +=temp[j-1];\\n                    else left +=1e9;\\n\\n                    temp[j] = min(up,left);\\n                }\\n            }\\n            prev =temp;\\n        }\\n        return prev[n-1];\\n        \\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\n*********************RECURSION********************************\\nclass Solution {\\n    long long func(int i,int j,vector<vector<int>>&grid){\\n        if(i==0 && j==0){\\n            return grid[0][0];\\n        }\\n      if(i<0 || j<0){\\n          return INT_MAX;\\n      }\\n      long long up = grid[i][j] + func(i-1,j,grid);\\n      long long  left = grid[i][j] + func(i,j-1,grid);\\n      return min(left,up);\\n    }\\npublic:\\n    int minPathSum(vector<vector<int>>& grid) {\\n        int  m=grid.size();\\n        int n=grid[0].size();\\n        return func(m-1,n-1,grid);\\n        \\n    }\\n};\\n\\n****************************MEMORIZATION*************************\\nclass Solution {\\n    long long func(int i,int j,vector<vector<int>>&grid,vector<vector<int>>&dp){\\n        if(i==0 && j==0){\\n            return grid[0][0];\\n        }\\n      if(i<0 || j<0){\\n          return INT_MAX;\\n      }\\n      if(dp[i][j] != -1) return dp[i][j];\\n      long long up = grid[i][j] + func(i-1,j,grid,dp);\\n      long long  left = grid[i][j] + func(i,j-1,grid,dp);\\n      return dp[i][j] = min(left,up);\\n    }\\npublic:\\n    int minPathSum(vector<vector<int>>& grid) {\\n        int  m=grid.size();\\n        int n=grid[0].size();\\n        vector<vector<int>>dp(m,vector<int>(n,-1));\\n        return func(m-1,n-1,grid,dp);\\n        \\n    }\\n};\\n******************************TABULATION********************************\\n\\npublic:\\n    int minPathSum(vector<vector<int>>& grid) {\\n        int  m=grid.size();\\n        int n=grid[0].size();\\n        vector<vector<int>>dp(m,vector<int>(n,0));\\n        for(int i=0;i<m;i++){\\n            for(int j=0;j<n;j++){\\n                if(i==0 && j==0){\\n                    dp[i][j] = grid[0][0];\\n                }\\n                else {\\n                    int up = grid[i][j];\\n                    int left = grid[i][j];\\n                    if(i>0) up +=dp[i-1][j];\\n                    else up +=1e9;\\n                    if(j>0) left +=dp[i][j-1];\\n                    else left +=1e9;\\n\\n                    dp[i][j] = min(up,left);\\n                }\\n            }\\n        }\\n        return dp[m-1][n-1];\\n        \\n    }\\n};\\n************************SPACE OPTIMIZATION*************************\\n\\nclass Solution {\\npublic:\\n    int minPathSum(vector<vector<int>>& grid) {\\n        int  m=grid.size();\\n        int n=grid[0].size();\\n        vector<int>prev(n,0);\\n        for(int i=0;i<m;i++){\\n            vector<int>temp(n,0);\\n            for(int j=0;j<n;j++){\\n                if(i==0 && j==0){\\n                    temp[j] = grid[0][0];\\n                }\\n                else {\\n                    int up = grid[i][j];\\n                    int left = grid[i][j];\\n                    if(i>0) up +=prev[j];\\n                    else up +=1e9;\\n                    if(j>0) left +=temp[j-1];\\n                    else left +=1e9;\\n\\n                    temp[j] = min(up,left);\\n                }\\n            }\\n            prev =temp;\\n        }\\n        return prev[n-1];\\n        \\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2880796,
                "title": "c-memoization-dp-recursion-with-clean-comments",
                "content": "At every step, we have **two choices** - to move *right* **or** to move *down*, and we need **min** from both the recursive calls.\\n\\nso, first add the current cell\\'s value and then go to the next cell, either right or down, and return minimum.\\n\\nthen just memoize the recursion, to optimise it.\\n```\\nclass Solution {\\nprivate:\\n    int dp[201][201];\\n    \\n    int rec(vector<vector<int>>& grid, int i, int j) {\\n        // pruning statement to check out of bounds\\n        if(i < 0 || j < 0 || i >= grid.size() || j >= grid[0].size())\\n            return 1e9;\\n        \\n        // base case, reached at destination\\n        if(i == grid.size() - 1 && j == grid[0].size() - 1)\\n            return grid[i][j];\\n        \\n        // cache check\\n        if(dp[i][j] != -1)\\n            return dp[i][j];\\n        \\n        // compute and store/memoize\\n        return dp[i][j] = min(\\n            grid[i][j] + rec(grid, i + 1, j), \\n            grid[i][j] + rec(grid, i, j + 1)\\n        );\\n    }\\n\\npublic:\\n    int minPathSum(vector<vector<int>>& grid) {\\n        memset(dp, -1, sizeof dp);\\n        \\n        return rec(grid, 0, 0);\\n    }\\n};\\n```\\nif you have any doubts, *feel free to ask* :)\\nplease **UpVote** \\uD83D\\uDD3C , if it helped",
                "solutionTags": [
                    "C++",
                    "C",
                    "Dynamic Programming",
                    "Recursion",
                    "Memoization"
                ],
                "code": "```\\nclass Solution {\\nprivate:\\n    int dp[201][201];\\n    \\n    int rec(vector<vector<int>>& grid, int i, int j) {\\n        // pruning statement to check out of bounds\\n        if(i < 0 || j < 0 || i >= grid.size() || j >= grid[0].size())\\n            return 1e9;\\n        \\n        // base case, reached at destination\\n        if(i == grid.size() - 1 && j == grid[0].size() - 1)\\n            return grid[i][j];\\n        \\n        // cache check\\n        if(dp[i][j] != -1)\\n            return dp[i][j];\\n        \\n        // compute and store/memoize\\n        return dp[i][j] = min(\\n            grid[i][j] + rec(grid, i + 1, j), \\n            grid[i][j] + rec(grid, i, j + 1)\\n        );\\n    }\\n\\npublic:\\n    int minPathSum(vector<vector<int>>& grid) {\\n        memset(dp, -1, sizeof dp);\\n        \\n        return rec(grid, 0, 0);\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2819398,
                "title": "how-to-print-the-path-if-asked",
                "content": "[ShadyCoder](https://leetcode.com/ShadyCoder/) in the [Discuss section]() asked -> \\n\\n\"What if the follow-up question is how do you store the path information that gives the minimum pathsum? Any ideas about how we can achieve that in a better design perspective?\"\\n\\nIt is implemented in `minPath()` Function below...\\n\\n# Code\\n```\\n#include <bits/stdc++.h>\\n\\nusing namespace std;\\n\\nclass Solution\\n{\\npublic:\\n    int minPathSum(vector<vector<int>> &grid)\\n    {\\n        int m = grid.size(), n = grid[0].size();\\n        vector<vector<int>> dp(m, vector<int>(n, 0));\\n\\n        dp[0][0] = grid[0][0];\\n\\n        for (int i = 1; i < m; i++)\\n        {\\n            dp[i][0] = dp[i - 1][0] + grid[i][0];\\n        }\\n        for (int j = 1; j < n; j++)\\n        {\\n            dp[0][j] = dp[0][j - 1] + grid[0][j];\\n        }\\n\\n        for (int i = 1; i < m; i++)\\n        {\\n            for (int j = 1; j < n; j++)\\n            {\\n                dp[i][j] = min(dp[i - 1][j], dp[i][j - 1]) + grid[i][j];\\n            }\\n        }\\n        return dp[m - 1][n - 1];\\n    }\\n// function for minPath getting the minPath string....\\n    string minPath(vector<vector<int>> &grid)\\n    {\\n        int m = grid.size(), n = grid[0].size();\\n        vector<vector<int>> dp(m, vector<int>(n, 0));\\n        vector<vector<string>> path(m, vector<string>(n));\\n        dp[0][0] = grid[0][0];\\n\\n        for (int i = 1; i < m; i++)\\n        {\\n            dp[i][0] = dp[i - 1][0] + grid[i][0];\\n            path[i][0] += path[i - 1][0] + \"D\";\\n        }\\n        for (int j = 1; j < n; j++)\\n        {\\n            dp[0][j] = dp[0][j - 1] + grid[0][j];\\n            path[0][j] += path[0][j - 1] + \"R\";\\n        }\\n\\n        for (int i = 1; i < m; i++)\\n        {\\n            for (int j = 1; j < n; j++)\\n            {\\n                dp[i][j] = min(dp[i - 1][j], dp[i][j - 1]) + grid[i][j];\\n                if (dp[i][j] == grid[i][j] + dp[i - 1][j])\\n                    path[i][j] = path[i - 1][j] + \"D\";\\n                else\\n                    path[i][j] = path[i][j - 1] + \"R\";\\n            }\\n        }\\n        return path[m - 1][n - 1];\\n    }\\n};\\n\\n// driver code \\nint main()\\n{\\n    vector<vector<vector<int>>> TestCases(3);\\n    TestCases[0] = {{1, 3, 1}, {1, 5, 1}, {4, 2, 1}};\\n    TestCases[1] = {{1, 2, 3}, {4, 5, 6}};\\n    TestCases[2] = {{1, 15, 3, 10}, {2, 2, 10, 32}, {3, 6, 1, 1}, {10, 5, 3, 5}, {3, 4, 2, 10}};\\n    Solution S;\\n    for (int i = 0; i < TestCases.size(); i++)\\n    {\\n        cout << \"Test Case #\" << i + 1 << endl;\\n        for (auto &v : TestCases[i])\\n        {\\n            for (auto &x : v)\\n                cout << x << \"\\\\t\";\\n            cout << endl;\\n        }\\n        cout << \"Min Path Sum = \" << S.minPathSum(TestCases[i]) << endl;\\n        cout << \"Min Path = \" << S.minPath(TestCases[i]) << endl;\\n        cout << endl;\\n    }\\n    return 0;\\n}\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\n#include <bits/stdc++.h>\\n\\nusing namespace std;\\n\\nclass Solution\\n{\\npublic:\\n    int minPathSum(vector<vector<int>> &grid)\\n    {\\n        int m = grid.size(), n = grid[0].size();\\n        vector<vector<int>> dp(m, vector<int>(n, 0));\\n\\n        dp[0][0] = grid[0][0];\\n\\n        for (int i = 1; i < m; i++)\\n        {\\n            dp[i][0] = dp[i - 1][0] + grid[i][0];\\n        }\\n        for (int j = 1; j < n; j++)\\n        {\\n            dp[0][j] = dp[0][j - 1] + grid[0][j];\\n        }\\n\\n        for (int i = 1; i < m; i++)\\n        {\\n            for (int j = 1; j < n; j++)\\n            {\\n                dp[i][j] = min(dp[i - 1][j], dp[i][j - 1]) + grid[i][j];\\n            }\\n        }\\n        return dp[m - 1][n - 1];\\n    }\\n// function for minPath getting the minPath string....\\n    string minPath(vector<vector<int>> &grid)\\n    {\\n        int m = grid.size(), n = grid[0].size();\\n        vector<vector<int>> dp(m, vector<int>(n, 0));\\n        vector<vector<string>> path(m, vector<string>(n));\\n        dp[0][0] = grid[0][0];\\n\\n        for (int i = 1; i < m; i++)\\n        {\\n            dp[i][0] = dp[i - 1][0] + grid[i][0];\\n            path[i][0] += path[i - 1][0] + \"D\";\\n        }\\n        for (int j = 1; j < n; j++)\\n        {\\n            dp[0][j] = dp[0][j - 1] + grid[0][j];\\n            path[0][j] += path[0][j - 1] + \"R\";\\n        }\\n\\n        for (int i = 1; i < m; i++)\\n        {\\n            for (int j = 1; j < n; j++)\\n            {\\n                dp[i][j] = min(dp[i - 1][j], dp[i][j - 1]) + grid[i][j];\\n                if (dp[i][j] == grid[i][j] + dp[i - 1][j])\\n                    path[i][j] = path[i - 1][j] + \"D\";\\n                else\\n                    path[i][j] = path[i][j - 1] + \"R\";\\n            }\\n        }\\n        return path[m - 1][n - 1];\\n    }\\n};\\n\\n// driver code \\nint main()\\n{\\n    vector<vector<vector<int>>> TestCases(3);\\n    TestCases[0] = {{1, 3, 1}, {1, 5, 1}, {4, 2, 1}};\\n    TestCases[1] = {{1, 2, 3}, {4, 5, 6}};\\n    TestCases[2] = {{1, 15, 3, 10}, {2, 2, 10, 32}, {3, 6, 1, 1}, {10, 5, 3, 5}, {3, 4, 2, 10}};\\n    Solution S;\\n    for (int i = 0; i < TestCases.size(); i++)\\n    {\\n        cout << \"Test Case #\" << i + 1 << endl;\\n        for (auto &v : TestCases[i])\\n        {\\n            for (auto &x : v)\\n                cout << x << \"\\\\t\";\\n            cout << endl;\\n        }\\n        cout << \"Min Path Sum = \" << S.minPathSum(TestCases[i]) << endl;\\n        cout << \"Min Path = \" << S.minPath(TestCases[i]) << endl;\\n        cout << endl;\\n    }\\n    return 0;\\n}\\n```",
                "codeTag": "C++"
            },
            {
                "id": 2577847,
                "title": "python-90-solution-dp",
                "content": "```python\\nclass Solution:\\n    def minPathSum(self, grid: List[List[int]]) -> int:\\n        dp=[[0 for _ in range(len(grid[0]))] for _ in range(len(grid))]\\n        for row in range(len(grid)):\\n            for col in range(len(grid[0])):\\n                dp[row][col]=grid[row][col]\\n                if row==0 and col==0:\\n                    continue\\n                candidates=set()\\n                if col>0:\\n                    candidates.add(dp[row][col-1])\\n                if row>0:\\n                    candidates.add(dp[row-1][col])\\n                dp[row][col]+=min(candidates)\\n        return dp[-1][-1]\\n```",
                "solutionTags": [
                    "Python",
                    "Dynamic Programming"
                ],
                "code": "```python\\nclass Solution:\\n    def minPathSum(self, grid: List[List[int]]) -> int:\\n        dp=[[0 for _ in range(len(grid[0]))] for _ in range(len(grid))]\\n        for row in range(len(grid)):\\n            for col in range(len(grid[0])):\\n                dp[row][col]=grid[row][col]\\n                if row==0 and col==0:\\n                    continue\\n                candidates=set()\\n                if col>0:\\n                    candidates.add(dp[row][col-1])\\n                if row>0:\\n                    candidates.add(dp[row-1][col])\\n                dp[row][col]+=min(candidates)\\n        return dp[-1][-1]\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2455017,
                "title": "java-simple-solution",
                "content": "https://www.youtube.com/watch?v=694ITcSBySY",
                "solutionTags": [],
                "code": "https://www.youtube.com/watch?v=694ITcSBySY",
                "codeTag": "Unknown"
            },
            {
                "id": 2410066,
                "title": "python-solution-from-recursion-to-dp-and-then-dp-space-optimisation-o-n",
                "content": "**Please Upvote if you liked it**\\n\\n**Recursion : TLE**\\n```\\nclass Solution:\\n    def solve(self,i,j,a):\\n        if i==0 and j==0:\\n            return a[0][0]\\n        if i<0 or j<0:\\n            return 1000000000000\\n        up=a[i][j]+self.solve(i-1,j,a)\\n        down=a[i][j]+self.solve(i,j-1,a)\\n        return min(up,down)\\n    \\n    def minPathSum(self, grid: List[List[int]]) -> int:\\n        m=len(grid)\\n        n=len(grid[0])\\n        return self.solve(m-1,n-1,grid)\\n```\\n**Memoization : Accepted**\\n```\\nclass Solution:\\n    def solve(self,i,j,a,dp):\\n        if i==0 and j==0:\\n            return a[0][0]\\n        if i<0 or j<0:\\n            return 1000000000000\\n        if dp[i][j]!=-1:\\n            return dp[i][j]\\n        \\n        up = a[i][j] + self.solve(i-1,j,a,dp)\\n        down = a[i][j] + self.solve(i,j-1,a,dp)\\n        dp[i][j] = min(up,down)\\n        return dp[i][j]\\n    \\n    def minPathSum(self, grid: List[List[int]]) -> int:\\n        m=len(grid)\\n        n=len(grid[0])\\n        dp=[[-1 for i in range(n)] for j in range(m)]\\n        return self.solve(m-1,n-1,grid,dp)\\n```\\n***Dynamic Programming(tabulation): Accepted***\\n```\\nclass Solution:\\n\\t    def minPathSum(self, grid: List[List[int]]) -> int:\\n        m=len(grid)\\n        n=len(grid[0])\\n        dp=[[-1 for i in range(n)] for j in range(m)]\\n        for i in range(m):\\n            for j in range(n):\\n                if i==0 and j==0:\\n                    dp[0][0]=grid[0][0]\\n                else:\\n                    up=grid[i][j]\\n                    if i>0:\\n                        up+=dp[i-1][j]\\n                    else:\\n                        up+=10000000000000\\n                        \\n                    left=grid[i][j]\\n                    if j>0:\\n                        left+=dp[i][j-1]\\n                    else:\\n                        left+=10000000000000\\n                        \\n                    dp[i][j]=min(up,left)\\n                    \\n        return dp[m-1][n-1]\\n```\\n# *Space Optimization O(N)+O(N)*\\n```\\n    def minPathSum(self, grid: List[List[int]]) -> int:\\n        n=len(grid[0])\\n        prev=[-1]*n\\n        for i in range(m):\\n            curr=[-1]*n\\n            for j in range(n):\\n                if i==0 and j==0:\\n                    curr[0]=grid[0][0]\\n                else:\\n                    up=grid[i][j]\\n                    if i>0:\\n                        up+=prev[j]\\n                    else:\\n                        up+=10000000000000\\n                        \\n                    left=grid[i][j]\\n                    if j>0:\\n                        left+=curr[j-1]\\n                    else:\\n                        left+=10000000000000\\n                        \\n                    curr[j]=min(up,left)\\n            prev=curr\\n                    \\n        return prev[n-1]\\n```\\n\\n",
                "solutionTags": [
                    "Python",
                    "Dynamic Programming",
                    "Recursion",
                    "Memoization"
                ],
                "code": "```\\nclass Solution:\\n    def solve(self,i,j,a):\\n        if i==0 and j==0:\\n            return a[0][0]\\n        if i<0 or j<0:\\n            return 1000000000000\\n        up=a[i][j]+self.solve(i-1,j,a)\\n        down=a[i][j]+self.solve(i,j-1,a)\\n        return min(up,down)\\n    \\n    def minPathSum(self, grid: List[List[int]]) -> int:\\n        m=len(grid)\\n        n=len(grid[0])\\n        return self.solve(m-1,n-1,grid)\\n```\n```\\nclass Solution:\\n    def solve(self,i,j,a,dp):\\n        if i==0 and j==0:\\n            return a[0][0]\\n        if i<0 or j<0:\\n            return 1000000000000\\n        if dp[i][j]!=-1:\\n            return dp[i][j]\\n        \\n        up = a[i][j] + self.solve(i-1,j,a,dp)\\n        down = a[i][j] + self.solve(i,j-1,a,dp)\\n        dp[i][j] = min(up,down)\\n        return dp[i][j]\\n    \\n    def minPathSum(self, grid: List[List[int]]) -> int:\\n        m=len(grid)\\n        n=len(grid[0])\\n        dp=[[-1 for i in range(n)] for j in range(m)]\\n        return self.solve(m-1,n-1,grid,dp)\\n```\n```\\nclass Solution:\\n\\t    def minPathSum(self, grid: List[List[int]]) -> int:\\n        m=len(grid)\\n        n=len(grid[0])\\n        dp=[[-1 for i in range(n)] for j in range(m)]\\n        for i in range(m):\\n            for j in range(n):\\n                if i==0 and j==0:\\n                    dp[0][0]=grid[0][0]\\n                else:\\n                    up=grid[i][j]\\n                    if i>0:\\n                        up+=dp[i-1][j]\\n                    else:\\n                        up+=10000000000000\\n                        \\n                    left=grid[i][j]\\n                    if j>0:\\n                        left+=dp[i][j-1]\\n                    else:\\n                        left+=10000000000000\\n                        \\n                    dp[i][j]=min(up,left)\\n                    \\n        return dp[m-1][n-1]\\n```\n```\\n    def minPathSum(self, grid: List[List[int]]) -> int:\\n        n=len(grid[0])\\n        prev=[-1]*n\\n        for i in range(m):\\n            curr=[-1]*n\\n            for j in range(n):\\n                if i==0 and j==0:\\n                    curr[0]=grid[0][0]\\n                else:\\n                    up=grid[i][j]\\n                    if i>0:\\n                        up+=prev[j]\\n                    else:\\n                        up+=10000000000000\\n                        \\n                    left=grid[i][j]\\n                    if j>0:\\n                        left+=curr[j-1]\\n                    else:\\n                        left+=10000000000000\\n                        \\n                    curr[j]=min(up,left)\\n            prev=curr\\n                    \\n        return prev[n-1]\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2375062,
                "title": "explained-java-solution-easy-to-understand-2ms-90-faster-full-explanation",
                "content": "**NOTE** : Please do try **UNIQUE PATH** problem before trying this problem : https://leetcode.com/problems/unique-paths/\\nand my solution and explanation to that problem is : https://leetcode.com/problems/unique-paths/discuss/2364894/JAVA-SOLUTION-or-0MS-100-FASTER-or-FULL-EXPLANATION\\n\\nNow coming to this problem :\\n* we can move either down or right \\n* for the grid[0][0] we don\\'t update it.\\n* so for the 0th row or column we will update the cost by adding the cost before that column i.e\\n1.  \\t\\t\\tfor the 0th row --> grid[i][j] += grid[i][j-1]\\n1.  \\t\\t\\tfor the 0th col --> grid[i][j] += grid[i-1][j];\\n\\n\\n\\n* Now for the other elements we update them adding that block value to **MIN** of the value from top element above them and the left element to that block (since we can from either down or right , therefor to reach any element we enter in it either from top of it of left of it )\\n\\n```\\npublic int minPathSum(int[][] grid) {\\n        int m = grid.length;\\n        int n= grid[0].length;\\n        for(int i=0;i<m;i++){\\n            for(int j=0;j<n;j++){\\n                if(i==0 && j==0) continue;\\n                else if (i == 0){\\n                    grid[i][j] += grid[i][j-1];\\n                }\\n                else if(j == 0){\\n                    grid[i][j] += grid[i-1][j];\\n                }\\n                else {\\n                    grid[i][j] += Math.min(grid[i-1][j],grid[i][j-1]);\\n                }\\n            }\\n        }\\n        return grid[m-1][n-1];\\n    }\\n```\\n\\n\\n\\n\\n.\\n.\\n.\\n.\\n* Let\\'s see how a grid looks like after all these operations \\n```\\n1\\t3\\t1                              1     4     5\\n1\\t5\\t1           -->                2     7     6\\n4\\t2\\t1                              6     8     7\\n```\\n\\n",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\npublic int minPathSum(int[][] grid) {\\n        int m = grid.length;\\n        int n= grid[0].length;\\n        for(int i=0;i<m;i++){\\n            for(int j=0;j<n;j++){\\n                if(i==0 && j==0) continue;\\n                else if (i == 0){\\n                    grid[i][j] += grid[i][j-1];\\n                }\\n                else if(j == 0){\\n                    grid[i][j] += grid[i-1][j];\\n                }\\n                else {\\n                    grid[i][j] += Math.min(grid[i-1][j],grid[i][j-1]);\\n                }\\n            }\\n        }\\n        return grid[m-1][n-1];\\n    }\\n```\n```\\n1\\t3\\t1                              1     4     5\\n1\\t5\\t1           -->                2     7     6\\n4\\t2\\t1                              6     8     7\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2334414,
                "title": "recursive-memoization-tabulation-c",
                "content": "**1) RECURSION**\\n\\nThis solution will give **TLE (ONLY 23 / 61 TEST CASES PASSED)**\\n\\n```\\n// Recursive Solution\\n\\nclass Solution {\\npublic:\\n    long long int solve(int i, int j, vector<vector<int>> &grid)\\n    {\\n        if(i == 0 && j == 0)\\n            return grid[0][0];\\n        \\n\\t\\t// Out of bounds case\\n\\t\\t// Add a large value so that this path is not taken into consideration\\n        if(i < 0 || j < 0)\\n            return INT_MAX;\\n        \\n        long long int up = grid[i][j] + solve(i - 1, j, grid);\\n        long long int left = grid[i][j] + solve(i, j - 1, grid);\\n        \\n        return min(up, left);\\n    }\\n    \\n    int minPathSum(vector<vector<int>>& grid) \\n    {\\n        int m = grid.size();\\n        int n = grid[0].size();\\n        \\n        return solve(m - 1, n - 1, grid);\\n    }\\n};\\n```\\n\\n\\n**2) MEMOIZATION**\\n\\n  This solution passes all the test cases\\n```\\n// Memoization\\n\\nclass Solution {\\npublic:\\n    long long int solve(int i, int j, vector<vector<int>> &grid, vector<vector<long long int>> &dp)\\n    {\\n        if(i == 0 && j == 0)\\n            return grid[0][0];\\n        \\n\\t\\t// Out of bounds case\\n\\t\\t// Add a large value so that this path is not taken into consideration\\n        if(i < 0 || j < 0)\\n            return INT_MAX;\\n        \\n        if(dp[i][j] != -1)\\n            return dp[i][j];\\n        \\n        long long int up = grid[i][j] + solve(i - 1, j, grid, dp);\\n        long long int left = grid[i][j] + solve(i, j - 1, grid, dp);\\n        \\n        return dp[i][j] = min(up, left);\\n    }\\n    \\n    int minPathSum(vector<vector<int>>& grid) \\n    {\\n        int m = grid.size();\\n        int n = grid[0].size();\\n        \\n        vector<vector<long long int>> dp(m, vector<long long int> (n, -1));\\n        \\n        return solve(m - 1, n - 1, grid, dp);\\n    }\\n};\\n```\\n\\n\\n**3) TABULATION**\\n This solution passes all the test cases\\n \\n```\\nclass Solution {\\npublic:\\n    int minPathSum(vector<vector<int>>& grid)\\n    {\\n        int m = grid.size();\\n        int n = grid[0].size();\\n        \\n        vector<vector<long long int>> dp(m, vector<long long int> (n, 0));\\n        \\n        for(int i = 0; i < m; i++)\\n        {\\n            for(int j = 0; j < n; j++)\\n            {\\n                if(i == 0 && j == 0)\\n                {\\n                    dp[i][j] = grid[0][0];\\n                }\\n                else\\n                {\\n                    long long int up = grid[i][j];\\n                    if(i > 0)\\n                        up += dp[i - 1][j];\\n                    else\\n                        up += 1e9; // to neglect this path  \\n                    \\n                    long long int left = grid[i][j];                    \\n                    if(j > 0)\\n                        left += dp[i][j - 1];\\n                    else\\n                        left += 1e9; // to neglect this path\\n                    \\n                    dp[i][j] = min(left, up);\\n                }\\n            }\\n        }\\n        \\n        return dp[m - 1][n - 1];\\n    }\\n};\\n```\\n\\n\\n",
                "solutionTags": [
                    "C",
                    "Recursion"
                ],
                "code": "```\\n// Recursive Solution\\n\\nclass Solution {\\npublic:\\n    long long int solve(int i, int j, vector<vector<int>> &grid)\\n    {\\n        if(i == 0 && j == 0)\\n            return grid[0][0];\\n        \\n\\t\\t// Out of bounds case\\n\\t\\t// Add a large value so that this path is not taken into consideration\\n        if(i < 0 || j < 0)\\n            return INT_MAX;\\n        \\n        long long int up = grid[i][j] + solve(i - 1, j, grid);\\n        long long int left = grid[i][j] + solve(i, j - 1, grid);\\n        \\n        return min(up, left);\\n    }\\n    \\n    int minPathSum(vector<vector<int>>& grid) \\n    {\\n        int m = grid.size();\\n        int n = grid[0].size();\\n        \\n        return solve(m - 1, n - 1, grid);\\n    }\\n};\\n```\n```\\n// Memoization\\n\\nclass Solution {\\npublic:\\n    long long int solve(int i, int j, vector<vector<int>> &grid, vector<vector<long long int>> &dp)\\n    {\\n        if(i == 0 && j == 0)\\n            return grid[0][0];\\n        \\n\\t\\t// Out of bounds case\\n\\t\\t// Add a large value so that this path is not taken into consideration\\n        if(i < 0 || j < 0)\\n            return INT_MAX;\\n        \\n        if(dp[i][j] != -1)\\n            return dp[i][j];\\n        \\n        long long int up = grid[i][j] + solve(i - 1, j, grid, dp);\\n        long long int left = grid[i][j] + solve(i, j - 1, grid, dp);\\n        \\n        return dp[i][j] = min(up, left);\\n    }\\n    \\n    int minPathSum(vector<vector<int>>& grid) \\n    {\\n        int m = grid.size();\\n        int n = grid[0].size();\\n        \\n        vector<vector<long long int>> dp(m, vector<long long int> (n, -1));\\n        \\n        return solve(m - 1, n - 1, grid, dp);\\n    }\\n};\\n```\n```\\nclass Solution {\\npublic:\\n    int minPathSum(vector<vector<int>>& grid)\\n    {\\n        int m = grid.size();\\n        int n = grid[0].size();\\n        \\n        vector<vector<long long int>> dp(m, vector<long long int> (n, 0));\\n        \\n        for(int i = 0; i < m; i++)\\n        {\\n            for(int j = 0; j < n; j++)\\n            {\\n                if(i == 0 && j == 0)\\n                {\\n                    dp[i][j] = grid[0][0];\\n                }\\n                else\\n                {\\n                    long long int up = grid[i][j];\\n                    if(i > 0)\\n                        up += dp[i - 1][j];\\n                    else\\n                        up += 1e9; // to neglect this path  \\n                    \\n                    long long int left = grid[i][j];                    \\n                    if(j > 0)\\n                        left += dp[i][j - 1];\\n                    else\\n                        left += 1e9; // to neglect this path\\n                    \\n                    dp[i][j] = min(left, up);\\n                }\\n            }\\n        }\\n        \\n        return dp[m - 1][n - 1];\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2093326,
                "title": "easy-to-understand-cpp-solution",
                "content": "go through the matrix from (1,1);\\n\\n````\\nclass Solution {\\npublic:\\n    int minPathSum(vector<vector<int>>& arr) {\\n        int n=arr.size();\\n        int m=arr[0].size();\\n        \\n        for(int j=1; j<m; j++){\\n            arr[0][j]+=arr[0][j-1];\\n        }\\n        for(int j=1; j<n; j++){\\n            arr[j][0]+=arr[j-1][0];\\n        }\\n        \\n        for(int i=1; i<n; i++){\\n            for(int j=1; j<m; j++){\\n                arr[i][j]+=min(arr[i-1][j],arr[i][j-1]);\\n            }\\n        }\\n        return arr[n-1][m-1];\\n    }\\n};\\n````\\n",
                "solutionTags": [
                    "C++",
                    "C",
                    "Dynamic Programming",
                    "Matrix"
                ],
                "code": "````\\nclass Solution {\\npublic:\\n    int minPathSum(vector<vector<int>>& arr) {\\n        int n=arr.size();\\n        int m=arr[0].size();\\n        \\n        for(int j=1; j<m; j++){\\n            arr[0][j]+=arr[0][j-1];\\n        }\\n        for(int j=1; j<n; j++){\\n            arr[j][0]+=arr[j-1][0];\\n        }\\n        \\n        for(int i=1; i<n; i++){\\n            for(int j=1; j<m; j++){\\n                arr[i][j]+=min(arr[i-1][j],arr[i][j-1]);\\n            }\\n        }\\n        return arr[n-1][m-1];\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2072550,
                "title": "all-c-solutions-brute-memoization-dp-dp-optimised-dp-constant-space",
                "content": "### Approach 1 - Recursion\\n```\\nclass Solution {\\npublic:\\n    int helper(int x, int y, vector<vector<int>>& grid){\\n        if(x == 0 and y == 0){\\n            return grid[x][y];\\n        }\\n        \\n        int up = 10e5, left = 10e5;\\n        if(x-1 >= 0) up = grid[x][y] + helper(x-1, y, grid);\\n        if(y-1 >= 0) left = grid[x][y] + helper(x, y-1, grid);\\n        \\n        return min(up, left);\\n    }\\n    int minPathSum(vector<vector<int>>& grid) {\\n        int m = grid.size(), n = grid[0].size();\\n        return helper(m-1, n-1, grid);\\n    }\\n};\\n```\\n\\nTime Complexity - O(2^(M+N)) \\nSpace Complexity - O(M+N)\\n\\n### Approach 2 - Memoization\\n```\\nclass Solution {\\npublic:\\n    int helper(int x, int y, vector<vector<int>>& grid, vector<vector<int>>& memo){\\n        if(x == 0 and y == 0){\\n            return grid[x][y];\\n        }\\n        if(memo[x][y] != -1) return memo[x][y];\\n        \\n        int up = 10e5, left = 10e5;\\n        if(x-1 >= 0) up = grid[x][y] + helper(x-1, y, grid, memo);\\n        if(y-1 >= 0) left = grid[x][y] + helper(x, y-1, grid, memo);\\n        \\n        return memo[x][y] = min(up, left);\\n    }\\n    int minPathSum(vector<vector<int>>& grid) {\\n        int m = grid.size(), n = grid[0].size();\\n        vector<vector<int>> memo(m, vector<int>(n, -1));\\n        return helper(m-1, n-1, grid, memo);\\n    }\\n};\\n```\\n\\nTime Complexity - O(M*N) \\nSpace Complexity - O((M+N) + M\\\\*N) - Recursice Stack Space + Memo table\\n\\n### Approach 3 - DP\\n```\\nclass Solution {\\npublic:\\n    int minPathSum(vector<vector<int>>& grid) {\\n        int m = grid.size(), n = grid[0].size();\\n        vector<vector<int>> dp (m, vector<int>(n, 0));\\n        dp[0][0] = grid[0][0];\\n        for(int x=0; x<m; x++){\\n            for(int y=0; y<n; y++){\\n                if(x == 0 and y == 0) continue;\\n                int up = 10e5, left = 10e5;\\n                if(x-1 >= 0) up = grid[x][y] + dp[x-1][y];\\n                if(y-1 >= 0) left = grid[x][y] + dp[x][y-1];\\n                \\n                dp[x][y] = min(up, left);\\n            }\\n        }\\n        return dp[m-1][n-1];\\n    }\\n};\\n```\\n\\nTime Complexity - O(M*N) \\nSpace Complexity - O(M\\\\*N) - DP table\\n\\n### Approach 4 - DP optimised\\n```\\nclass Solution {\\npublic:\\n    int minPathSum(vector<vector<int>>& grid) {\\n        int m = grid.size(), n = grid[0].size();\\n        vector<int> prevRow(n, 0), curRow(n, 0);\\n        curRow[0] = grid[0][0];\\n        for(int x=0; x<m; x++){\\n            for(int y=0; y<n; y++){\\n                if(x == 0 and y == 0) continue;\\n                int up = 10e5, left = 10e5;\\n                if(x-1 >= 0) up = grid[x][y] + prevRow[y];\\n                if(y-1 >= 0) left = grid[x][y] + curRow[y-1];\\n                \\n                curRow[y] = min(up, left);\\n            }\\n            prevRow = curRow;\\n        }\\n        return curRow[n-1];\\n    }\\n};\\n```\\n\\nTime Complexity - O(M*N) \\nSpace Complexity - O(N) - DP table\\n\\n### Approach 5 - DP with constant space\\n##### The approach involves modification of the input array and the solution will fail if the input array is immutable\\n```\\nclass Solution {\\npublic:\\n    int minPathSum(vector<vector<int>>& grid) {\\n        int m = grid.size(), n = grid[0].size();\\n        for(int x=0; x<m; x++){\\n            for(int y=0; y<n; y++){\\n                if(x == 0 and y == 0) continue;\\n                int up = 10e5, left = 10e5;\\n                if(x-1 >= 0) up = grid[x-1][y];\\n                if(y-1 >= 0) left = grid[x][y-1];\\n                \\n                grid[x][y] += min(up, left);\\n            }\\n        }\\n        return grid[m-1][n-1];\\n    }\\n};\\n```\\n\\nTime Complexity - O(M*N) \\nSpace Complexity - O(1)",
                "solutionTags": [
                    "C++",
                    "C",
                    "Dynamic Programming",
                    "Recursion",
                    "Memoization"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int helper(int x, int y, vector<vector<int>>& grid){\\n        if(x == 0 and y == 0){\\n            return grid[x][y];\\n        }\\n        \\n        int up = 10e5, left = 10e5;\\n        if(x-1 >= 0) up = grid[x][y] + helper(x-1, y, grid);\\n        if(y-1 >= 0) left = grid[x][y] + helper(x, y-1, grid);\\n        \\n        return min(up, left);\\n    }\\n    int minPathSum(vector<vector<int>>& grid) {\\n        int m = grid.size(), n = grid[0].size();\\n        return helper(m-1, n-1, grid);\\n    }\\n};\\n```\n```\\nclass Solution {\\npublic:\\n    int helper(int x, int y, vector<vector<int>>& grid, vector<vector<int>>& memo){\\n        if(x == 0 and y == 0){\\n            return grid[x][y];\\n        }\\n        if(memo[x][y] != -1) return memo[x][y];\\n        \\n        int up = 10e5, left = 10e5;\\n        if(x-1 >= 0) up = grid[x][y] + helper(x-1, y, grid, memo);\\n        if(y-1 >= 0) left = grid[x][y] + helper(x, y-1, grid, memo);\\n        \\n        return memo[x][y] = min(up, left);\\n    }\\n    int minPathSum(vector<vector<int>>& grid) {\\n        int m = grid.size(), n = grid[0].size();\\n        vector<vector<int>> memo(m, vector<int>(n, -1));\\n        return helper(m-1, n-1, grid, memo);\\n    }\\n};\\n```\n```\\nclass Solution {\\npublic:\\n    int minPathSum(vector<vector<int>>& grid) {\\n        int m = grid.size(), n = grid[0].size();\\n        vector<vector<int>> dp (m, vector<int>(n, 0));\\n        dp[0][0] = grid[0][0];\\n        for(int x=0; x<m; x++){\\n            for(int y=0; y<n; y++){\\n                if(x == 0 and y == 0) continue;\\n                int up = 10e5, left = 10e5;\\n                if(x-1 >= 0) up = grid[x][y] + dp[x-1][y];\\n                if(y-1 >= 0) left = grid[x][y] + dp[x][y-1];\\n                \\n                dp[x][y] = min(up, left);\\n            }\\n        }\\n        return dp[m-1][n-1];\\n    }\\n};\\n```\n```\\nclass Solution {\\npublic:\\n    int minPathSum(vector<vector<int>>& grid) {\\n        int m = grid.size(), n = grid[0].size();\\n        vector<int> prevRow(n, 0), curRow(n, 0);\\n        curRow[0] = grid[0][0];\\n        for(int x=0; x<m; x++){\\n            for(int y=0; y<n; y++){\\n                if(x == 0 and y == 0) continue;\\n                int up = 10e5, left = 10e5;\\n                if(x-1 >= 0) up = grid[x][y] + prevRow[y];\\n                if(y-1 >= 0) left = grid[x][y] + curRow[y-1];\\n                \\n                curRow[y] = min(up, left);\\n            }\\n            prevRow = curRow;\\n        }\\n        return curRow[n-1];\\n    }\\n};\\n```\n```\\nclass Solution {\\npublic:\\n    int minPathSum(vector<vector<int>>& grid) {\\n        int m = grid.size(), n = grid[0].size();\\n        for(int x=0; x<m; x++){\\n            for(int y=0; y<n; y++){\\n                if(x == 0 and y == 0) continue;\\n                int up = 10e5, left = 10e5;\\n                if(x-1 >= 0) up = grid[x-1][y];\\n                if(y-1 >= 0) left = grid[x][y-1];\\n                \\n                grid[x][y] += min(up, left);\\n            }\\n        }\\n        return grid[m-1][n-1];\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1967500,
                "title": "dp-solution-o-n-m",
                "content": "```\\nclass Solution {\\npublic:\\n    int minPathSum(vector<vector<int>>& grid) {\\n        int n=grid.size(), m=grid[0].size();\\n        vector<vector<int>>dp(n,vector<int>(m));\\n        for(int i=0;i<n;i++){\\n            for(int j=0;j<m;j++){\\n                if(i==0 && j==0) {\\n                    dp[i][j]=grid[i][j]; //filling top-left cell\\n                }\\n                if(i==0 && j!=0){\\n                    dp[i][j]=dp[i][j-1]+grid[i][j]; //filling first row\\n                }\\n                if(j==0 && i!=0){\\n                    dp[i][j]=dp[i-1][j]+grid[i][j]; //filling first column\\n                }\\n                if(i!=0 && j!=0){\\n                    dp[i][j]=min(dp[i-1][j],dp[i][j-1])+grid[i][j]; //filling rest of the cells\\n                }\\n            }\\n        }\\n        return dp[n-1][m-1];\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    int minPathSum(vector<vector<int>>& grid) {\\n        int n=grid.size(), m=grid[0].size();\\n        vector<vector<int>>dp(n,vector<int>(m));\\n        for(int i=0;i<n;i++){\\n            for(int j=0;j<m;j++){\\n                if(i==0 && j==0) {\\n                    dp[i][j]=grid[i][j]; //filling top-left cell\\n                }\\n                if(i==0 && j!=0){\\n                    dp[i][j]=dp[i][j-1]+grid[i][j]; //filling first row\\n                }\\n                if(j==0 && i!=0){\\n                    dp[i][j]=dp[i-1][j]+grid[i][j]; //filling first column\\n                }\\n                if(i!=0 && j!=0){\\n                    dp[i][j]=min(dp[i-1][j],dp[i][j-1])+grid[i][j]; //filling rest of the cells\\n                }\\n            }\\n        }\\n        return dp[n-1][m-1];\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1879199,
                "title": "c-very-very-easy-simple-8-line-code-tc-o-n-m-sc-o-1",
                "content": "```\\n\\tint minPathSum(vector<vector<int>>& grid) {\\n        int n=grid.size(), m=grid[0].size();\\n        for(int i=0;i<n;++i){\\n            for(int j=0;j<m;++j){\\n                if(i==0 && j==0) continue;\\n                else if(i==0) grid[i][j]+=grid[i][j-1];\\n                else if(j==0) grid[i][j]+=grid[i-1][j];\\n                else grid[i][j]+=min(grid[i-1][j], grid[i][j-1]);\\n            }\\n        }\\n        return grid[n-1][m-1];\\n    }\\n```\\n\\nThe extension of this problem is [174. Dungeon Game](https://leetcode.com/problems/dungeon-game/). The solution of this question is similar to this.\\nSolution link - https://leetcode.com/problems/dungeon-game/discuss/1879082/c-very-very-easy-simple-9-line-code-tc-o-nm-sc-o-1",
                "solutionTags": [
                    "C",
                    "Dynamic Programming"
                ],
                "code": "```\\n\\tint minPathSum(vector<vector<int>>& grid) {\\n        int n=grid.size(), m=grid[0].size();\\n        for(int i=0;i<n;++i){\\n            for(int j=0;j<m;++j){\\n                if(i==0 && j==0) continue;\\n                else if(i==0) grid[i][j]+=grid[i][j-1];\\n                else if(j==0) grid[i][j]+=grid[i-1][j];\\n                else grid[i][j]+=min(grid[i-1][j], grid[i][j-1]);\\n            }\\n        }\\n        return grid[n-1][m-1];\\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1837560,
                "title": "c-very-easy-recursive-memoization-tabulation-solution",
                "content": "Just upvote to make a little effort for your motivation \\n// Memoization \\n```\\nclass Solution {\\npublic:\\n    int dp[201][201];\\n    int find(vector<vector<int>>& grid, int m,int n, int i,int j){\\n            \\n        if(i == m-1 and j == n-1) return grid[i][j]; \\n        \\n        if(dp[i][j]!=-1) return dp[i][j];\\n        \\n        int right=INT_MAX, bottom = INT_MAX;\\n        if(i<m-1) right= grid[i][j]+find(grid,m,n,i+1,j);\\n        if(j<n-1) bottom = grid[i][j]+find(grid,m,n,i,j+1);\\n        \\n        return dp[i][j]=min(right, bottom);\\n    }\\n    \\n    int minPathSum(vector<vector<int>>& grid) {\\n        memset(dp,-1,sizeof(dp));\\n       int m= grid.size(),n= grid[0].size();\\n        return find(grid,m,n,0,0);\\n    }\\n};\\n```\\n\\n// DP tabulation\\n```\\nclass Solution{\\npublic:\\nint minPathSum(vector<vector<int>>& grid) {\\n        \\n       int m= grid.size(),n= grid[0].size();\\n  \\n        int dp[m][n];\\n        dp[0][0]=grid[0][0];\\n        for(int i=1; i<m ; i++) dp[i][0]= dp[i-1][0]+grid[i][0];\\n        for(int j=1; j<n ; j++) dp[0][j]= dp[0][j-1]+grid[0][j];\\n        \\n        for(int i=1; i<m; i++){\\n            for(int j=1; j<n; j++){\\n                dp[i][j]= grid[i][j]+min(dp[i-1][j], dp[i][j-1]);\\n            }\\n        }\\n        return dp[m-1][n-1];\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "C",
                    "Dynamic Programming",
                    "Memoization"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int dp[201][201];\\n    int find(vector<vector<int>>& grid, int m,int n, int i,int j){\\n            \\n        if(i == m-1 and j == n-1) return grid[i][j]; \\n        \\n        if(dp[i][j]!=-1) return dp[i][j];\\n        \\n        int right=INT_MAX, bottom = INT_MAX;\\n        if(i<m-1) right= grid[i][j]+find(grid,m,n,i+1,j);\\n        if(j<n-1) bottom = grid[i][j]+find(grid,m,n,i,j+1);\\n        \\n        return dp[i][j]=min(right, bottom);\\n    }\\n    \\n    int minPathSum(vector<vector<int>>& grid) {\\n        memset(dp,-1,sizeof(dp));\\n       int m= grid.size(),n= grid[0].size();\\n        return find(grid,m,n,0,0);\\n    }\\n};\\n```\n```\\nclass Solution{\\npublic:\\nint minPathSum(vector<vector<int>>& grid) {\\n        \\n       int m= grid.size(),n= grid[0].size();\\n  \\n        int dp[m][n];\\n        dp[0][0]=grid[0][0];\\n        for(int i=1; i<m ; i++) dp[i][0]= dp[i-1][0]+grid[i][0];\\n        for(int j=1; j<n ; j++) dp[0][j]= dp[0][j-1]+grid[0][j];\\n        \\n        for(int i=1; i<m; i++){\\n            for(int j=1; j<n; j++){\\n                dp[i][j]= grid[i][j]+min(dp[i-1][j], dp[i][j-1]);\\n            }\\n        }\\n        return dp[m-1][n-1];\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1803657,
                "title": "recursion-memorization-c-dp",
                "content": "```\\nclass Solution {\\npublic:\\n    int solve(int i,int j,int m,int n,vector<vector<int>> &grid,vector<vector<int>>&dp){\\n        if(i == m-1 and j == n-1) return grid[i][j];\\n        else if(dp[i][j] != -1) return dp[i][j];\\n        \\n        int down = INT_MAX, right = INT_MAX;\\n        \\n        if(i+1 < grid.size())    down = solve(i+1,j,m,n,grid,dp);\\n        \\n        if(j+1 < grid[0].size()) right = solve(i,j+1,m,n,grid,dp);\\n        \\n        int ans = grid[i][j] + min(down,right);\\n        return dp[i][j] = ans;\\n    }\\n    int minPathSum(vector<vector<int>>& grid){\\n        int m = grid.size(), n = grid[0].size();\\n        vector<vector<int>> dp(m,vector<int> (n,-1));\\n        return solve(0,0,m,n,grid,dp);\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "C",
                    "Dynamic Programming",
                    "Recursion",
                    "Memoization"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int solve(int i,int j,int m,int n,vector<vector<int>> &grid,vector<vector<int>>&dp){\\n        if(i == m-1 and j == n-1) return grid[i][j];\\n        else if(dp[i][j] != -1) return dp[i][j];\\n        \\n        int down = INT_MAX, right = INT_MAX;\\n        \\n        if(i+1 < grid.size())    down = solve(i+1,j,m,n,grid,dp);\\n        \\n        if(j+1 < grid[0].size()) right = solve(i,j+1,m,n,grid,dp);\\n        \\n        int ans = grid[i][j] + min(down,right);\\n        return dp[i][j] = ans;\\n    }\\n    int minPathSum(vector<vector<int>>& grid){\\n        int m = grid.size(), n = grid[0].size();\\n        vector<vector<int>> dp(m,vector<int> (n,-1));\\n        return solve(0,0,m,n,grid,dp);\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1783719,
                "title": "java-top-down-dp-simple-code-explained",
                "content": "class Solution {\\n    public int minPathSum(int[][] grid) {\\n        \\n       // Create DP matrix // Following Top Down Approach\\n       int[][] result = new int[grid.length][grid[0].length];\\n        \\n    \\t\\n    \\tfor(int i=0; i<grid.length; i++) {\\n    \\t\\tfor(int j=0; j<grid[0].length; j++) {\\n                \\n                \\n    \\t\\t\\tif(i==0 && j==0) { // For 1st element // Directly add\\n    \\t\\t\\t\\tresult[i][j]= grid[i][j];\\n    \\t\\t\\t}\\n                \\n                \\n                //\\u2192\\n                else if(i==0 ) { // For 1st Row \\n                    result[i][j] = result[i][j-1] + grid[i][j];\\n    \\t\\t\\t}\\n                \\n                \\n                // \\u2193\\n    \\t\\t\\telse if(j==0) { // For 1st Column\\n    \\t\\t\\t\\tresult[i][j] = result[i-1][j] + grid[i][j];\\n    \\t\\t\\t}\\n                \\n                // \\u2192                \\n                //\\u2193\\n    \\t\\t\\telse { // Except 1st row and 1st column\\n    \\t\\t\\t\\tresult[i][j] = Math.min(result[i-1][j],result[i][j-1]) + grid[i][j];\\n    \\t\\t\\t}\\t\\t\\t\\n    \\t}\\n        \\n      }\\n    return result[grid.length - 1][grid[0].length- 1]; // Return result[2][2]  \\n    }\\n}",
                "solutionTags": [
                    "Java",
                    "Dynamic Programming"
                ],
                "code": "class Solution {\\n    public int minPathSum(int[][] grid) {\\n        \\n       // Create DP matrix // Following Top Down Approach\\n       int[][] result = new int[grid.length][grid[0].length];\\n        \\n    \\t\\n    \\tfor(int i=0; i<grid.length; i++) {\\n    \\t\\tfor(int j=0; j<grid[0].length; j++) {\\n                \\n                \\n    \\t\\t\\tif(i==0 && j==0) { // For 1st element // Directly add\\n    \\t\\t\\t\\tresult[i][j]= grid[i][j];\\n    \\t\\t\\t}",
                "codeTag": "Java"
            },
            {
                "id": 1768077,
                "title": "c-dp-recursive-memoization-tabulation-space-optimization",
                "content": "```\\nclass Solution {\\npublic:\\n//Recusrive-> TLE\\n//Time and Space: O(2^(n+m)) and O(N)stack + O(m-1, n-1);\\n    int func(int i, int j, vector<vector<int>>& a){\\n        //base case\\n        if(i==0 && j==0) return a[i][j];\\n        //out of boundary case\\n        if(i<0 || j<0) return 1e8;  \\n        \\n        int up = a[i][j] + func(i-1,j,a);\\n        int left = a[i][j] + func(i,j-1,a);\\n        \\n        return min(left,up);\\n    }\\n    int minPathSum(vector<vector<int>>& a) {\\n        int n = a.size(), m = a[0].size();\\n        return func(n-1,m-1,a);\\n    }\\n    \\n//Memoization-> Accepted\\uD83D\\uDD25\\n//Time and Space: O(n*m) and O(N)stack + O(n*m);\\n   int func(int i, int j, vector<vector<int>>& a,vector<vector<int>> &dp){\\n        //base case\\n        if(i==0 && j==0) return a[i][j];\\n        //out of boundary case\\n        if(i<0 || j<0) return 1e8;  \\n        \\n        if(dp[i][j] != -1) return dp[i][j];\\n        \\n        int up = a[i][j] + func(i-1,j,a,dp);\\n        int left = a[i][j] + func(i,j-1,a,dp);\\n        \\n        return dp[i][j] = min(left,up);\\n    }\\n    int minPathSum(vector<vector<int>>& a) {\\n        int n = a.size(), m = a[0].size();\\n        vector<vector<int>> dp(n,vector<int> (m,-1));\\n        return func(n-1,m-1,a,dp);\\n    }\\n    \\n//Tabulation-> Accepted\\uD83D\\uDD25\\n//Time and Space: O(n*m) and O(n*m);\\n    int minPathSum(vector<vector<int>>& a) {\\n        int n = a.size(), m = a[0].size();\\n        vector<vector<int>> dp(n,vector<int> (m,0));\\n        for(int i=0;i<n;i++){\\n            for(int j=0;j<m;j++){\\n                // base case from Memoization\\n                if(i==0 && j==0) dp[i][j] = a[i][j];\\n                else{\\n                    int up = a[i][j];\\n                    if(i>0) up+= dp[i-1][j];\\n                    else up+= 1e8;\\n\\n                    int left = a[i][j];\\n                    if(j>0) left+= dp[i][j-1];\\n                    else left+= 1e8;\\n                \\n                    dp[i][j] = min(left, up);\\n                }\\n            }\\n        }\\n        return dp[n-1][m-1];\\n    }\\n    \\n// Space Optimiztion->Accepted\\uD83D\\uDD25\\n// Time: O(n*m)\\n// Space: O(m)\\nint minPathSum(vector<vector<int>>& a) {\\n        int n = a.size(), m = a[0].size();\\n        vector<int>prev(m,0), curr(m,0);\\n        for(int i=0;i<n;i++){\\n            for(int j=0;j<m;j++){\\n                // base case from Memoization\\n                if(i==0 && j==0) curr[j] = a[i][j];\\n                else{\\n                    int up = a[i][j];\\n                    if(i>0) up+= prev[j];\\n                    else up+= 1e8;\\n\\n                    int left = a[i][j];\\n                    if(j>0) left+= curr[j-1];\\n                    else left+= 1e8;\\n                \\n                    curr[j] = min(left, up);\\n                }\\n            }\\n            prev = curr;\\n        }\\n        return prev[m-1];\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "C",
                    "Dynamic Programming"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n//Recusrive-> TLE\\n//Time and Space: O(2^(n+m)) and O(N)stack + O(m-1, n-1);\\n    int func(int i, int j, vector<vector<int>>& a){\\n        //base case\\n        if(i==0 && j==0) return a[i][j];\\n        //out of boundary case\\n        if(i<0 || j<0) return 1e8;  \\n        \\n        int up = a[i][j] + func(i-1,j,a);\\n        int left = a[i][j] + func(i,j-1,a);\\n        \\n        return min(left,up);\\n    }\\n    int minPathSum(vector<vector<int>>& a) {\\n        int n = a.size(), m = a[0].size();\\n        return func(n-1,m-1,a);\\n    }\\n    \\n//Memoization-> Accepted\\uD83D\\uDD25\\n//Time and Space: O(n*m) and O(N)stack + O(n*m);\\n   int func(int i, int j, vector<vector<int>>& a,vector<vector<int>> &dp){\\n        //base case\\n        if(i==0 && j==0) return a[i][j];\\n        //out of boundary case\\n        if(i<0 || j<0) return 1e8;  \\n        \\n        if(dp[i][j] != -1) return dp[i][j];\\n        \\n        int up = a[i][j] + func(i-1,j,a,dp);\\n        int left = a[i][j] + func(i,j-1,a,dp);\\n        \\n        return dp[i][j] = min(left,up);\\n    }\\n    int minPathSum(vector<vector<int>>& a) {\\n        int n = a.size(), m = a[0].size();\\n        vector<vector<int>> dp(n,vector<int> (m,-1));\\n        return func(n-1,m-1,a,dp);\\n    }\\n    \\n//Tabulation-> Accepted\\uD83D\\uDD25\\n//Time and Space: O(n*m) and O(n*m);\\n    int minPathSum(vector<vector<int>>& a) {\\n        int n = a.size(), m = a[0].size();\\n        vector<vector<int>> dp(n,vector<int> (m,0));\\n        for(int i=0;i<n;i++){\\n            for(int j=0;j<m;j++){\\n                // base case from Memoization\\n                if(i==0 && j==0) dp[i][j] = a[i][j];\\n                else{\\n                    int up = a[i][j];\\n                    if(i>0) up+= dp[i-1][j];\\n                    else up+= 1e8;\\n\\n                    int left = a[i][j];\\n                    if(j>0) left+= dp[i][j-1];\\n                    else left+= 1e8;\\n                \\n                    dp[i][j] = min(left, up);\\n                }\\n            }\\n        }\\n        return dp[n-1][m-1];\\n    }\\n    \\n// Space Optimiztion->Accepted\\uD83D\\uDD25\\n// Time: O(n*m)\\n// Space: O(m)\\nint minPathSum(vector<vector<int>>& a) {\\n        int n = a.size(), m = a[0].size();\\n        vector<int>prev(m,0), curr(m,0);\\n        for(int i=0;i<n;i++){\\n            for(int j=0;j<m;j++){\\n                // base case from Memoization\\n                if(i==0 && j==0) curr[j] = a[i][j];\\n                else{\\n                    int up = a[i][j];\\n                    if(i>0) up+= prev[j];\\n                    else up+= 1e8;\\n\\n                    int left = a[i][j];\\n                    if(j>0) left+= curr[j-1];\\n                    else left+= 1e8;\\n                \\n                    curr[j] = min(left, up);\\n                }\\n            }\\n            prev = curr;\\n        }\\n        return prev[m-1];\\n    }\\n};\\n```",
                "codeTag": "Java"
            }
        ],
        "discussions": [
            {
                "id": 1844924,
                "content": [
                    {
                        "username": "_srahul_",
                        "content": "Friendship ended with graph, now DP is my best friend."
                    },
                    {
                        "username": "user4401w",
                        "content": "XD\\n"
                    },
                    {
                        "username": "codeMonarch",
                        "content": "agree++;\\n"
                    },
                    {
                        "username": "daring-calf",
                        "content": "When I first met this problem 8 months ago it was so hard and frustrating, I spent a whole night and didn\\'t quite get it even after watching the solutions. And today it only took 5 minutes to write.\\nTo all the noobcoders out there: it always hurts the first time; but hang in there, eventually you\\'ll enjoy it."
                    },
                    {
                        "username": "bhuppidhamii",
                        "content": "right bro."
                    },
                    {
                        "username": "kartikey_wariyal",
                        "content": "i too cant solve right now\\n"
                    },
                    {
                        "username": "diabloexodia",
                        "content": "I believe in the heart of the algorithms"
                    },
                    {
                        "username": "sk03167",
                        "content": "I love the discussion section. It's nice to see people in the same journey as you. I have never solved this question before but I know earlier I would written a whole ass recursive function, then optimized with memo. Now, it was intuitive that it's a 2d dp problem and how to write it. Took all but 11 lines of code to beat 90% both time and space."
                    },
                    {
                        "username": "Crispy_coffee",
                        "content": "Still TLE bmro"
                    },
                    {
                        "username": "cOde_Ranvir25",
                        "content": "# Here is an Approach :-)\\n**The problem statement is to find the minimum path sum from the top-left corner to the bottom-right corner of a grid, where each cell in the grid has a non-negative integer value. The path can only move down or right at each step.**\\n\\n- We can use dynamic programming to solve this problem efficiently. We will create a 2D array dp of the same size as the input grid, where each cell dp[i][j] represents the minimum path sum from the top-left corner to cell (i, j).\\n\\n- We can initialize the dp array as follows:\\n\\n1. dp[0][0] = grid[0][0] since the minimum path sum to the top-left corner is the value of the top-left cell.\\n2. For the first row i=0 and first column j=0 < j < n, the minimum path sum can only be reached by moving right or down from the previous cell. So, we can compute dp[0][j] = dp[0][j-1] + grid[0][j] and dp[i][0] = dp[i-1][0] + grid[i][0] respectively.\\n3. For the rest of the cells, we can compute the minimum path sum as follows:\\ndp[i][j] = grid[i][j] + min(dp[i-1][j], dp[i][j-1]) since we can reach the current cell from the cell above or the cell to the left, and we want to take the path with the minimum sum.\\n- Once we have filled the dp array, the minimum path sum to the bottom-right corner will be dp[m-1][n-1], where m is the number of rows and n is the number of columns of the input grid.\\n\\n**The time complexity of this approach is O(mn) since we visit each cell once. The space complexity is also O(mn) since we use the dp array to store the intermediate results.**"
                    },
                    {
                        "username": "user5400vw",
                        "content": "good explanation.  the original grid can also act as your dp table."
                    },
                    {
                        "username": "cOde_Ranvir25",
                        "content": "***Here is the code link for reference:-)***\\nhttps://leetcode.com/problems/minimum-path-sum/solutions/2887704/easiest-solution/"
                    },
                    {
                        "username": "zaim",
                        "content": "On input \\n[[5,4,2,9,6,0,3,5,1,4,9,8,4,9,7,5,1],\\n [3,4,9,2,9,9,0,9,7,9,4,7,8,4,4,5,8],\\n [6,1,8,9,8,0,3,7,0,9,8,7,4,9,2,0,1],\\n [4,0,0,5,1,7,4,7,6,4,1,0,1,0,6,2,8],\\n [7,2,0,2,9,3,4,7,0,8,9,5,9,0,1,1,0],\\n [8,2,9,4,9,7,9,3,7,0,3,6,5,3,5,9,6],\\n [8,9,9,2,6,1,2,5,8,3,7,0,4,9,8,8,8],\\n [5,8,5,4,1,5,6,6,3,3,1,8,3,9,6,4,8],\\n [0,2,2,3,0,2,6,7,2,3,7,3,1,5,8,1,3],\\n [4,4,0,2,0,3,8,4,1,3,3,0,7,4,2,9,8],\\n [5,9,0,4,7,5,7,6,0,8,3,0,0,6,6,6,8],\\n [0,7,1,8,3,5,1,8,7,0,2,9,2,2,7,1,5],\\n [1,0,0,0,6,2,0,0,2,2,8,0,9,7,0,8,0],\\n [1,1,7,2,9,6,5,4,8,7,8,5,0,3,8,1,5],\\n [8,9,7,8,1,1,3,0,1,2,9,4,0,1,5,3,1],\\n [9,2,7,4,8,7,3,9,2,4,2,2,7,8,2,6,7],\\n [3,8,1,6,0,4,8,9,8,0,2,5,3,5,5,7,5],\\n [1,8,2,5,7,7,1,9,9,8,9,2,4,9,5,4,0],\\n [3,4,4,1,5,3,3,8,8,6,3,5,3,8,7,1,3]]\\n\\nckeckers solution is 82, but mine is is 79 with the following path:\\n\\n[05] 04  02  09  06  00  03  05  01  04  09  08  04  09  07  05  01 \\n\\n[03][04] 09  02  09  09  00  09  07  09  04  07  08  04  04  05  08 \\n\\n 06 [01] 08  09  08  00  03  07  00  09  08  07  04  09  02  00  01 \\n\\n 04 [00][00] 05  01  07  04  07  06  04  01  00  01  00  06  02  08 \\n\\n 07  02 [00][02] 09  03  04  07  00  08  09  05  09  00  01  01  00 \\n\\n 08  02  09 [04] 09  07  09  03  07  00  03  06  05  03  05  09  06 \\n\\n 08  09  09 [02] 06  01  02  05  08  03  07  00  04  09  08  08  08 \\n\\n 05  08  05 [04][01] 05  06  06  03  03  01  08  03  09  06  04  08 \\n\\n 00  02  02  03 [00] 02  06  07  02  03  07  03  01  05  08  01  03 \\n\\n 04  04 [00][02][00] 03  08  04  01  03  03  00  07  04  02  09  08 \\n\\n 05  09 [00] 04  07  05  07  06  00  08  03  00  00  06  06  06  08 \\n\\n 00  07 [01] 08  03  05  01  08  07  00  02  09  02  02  07  01  05 \\n\\n 01  00 [00][00][06][02][00][00][02][02][08][00] 09  07  00  08  00 \\n\\n 01  01  07  02  09  06  05  04  08  07  08 [05][00] 03  08  01  05 \\n\\n 08  09  07  08  01  01  03  00  01  02  09  04 [00][01][05][03][01]\\n\\n 09  02  07  04  08  07  03  09  02  04  02  02  07  08  02  06 [07]\\n\\n 03  08  01  06  00  04  08  09  08  00  02  05  03  05  05  07 [05]\\n\\n 01  08  02  05  07  07  01  09  09  08  09  02  04  09  05  04 [00]\\n\\n 03  04  04  01  05  03  03  08  08  06  03  05  03  08  07  01 [03]\\n\\nDoes anyone have a suggestion what I am doing wrong?"
                    },
                    {
                        "username": "LucidLynxxx",
                        "content": "I believe it is illlegal to move back, which you do? \"Note: You can only move either down or right at any point in time.\""
                    },
                    {
                        "username": "red_akb",
                        "content": "See 10th line, you\\'re moving left\\n\\nBut it is clearly mentioned in que that ->\\n\\n\"Note: You can only move either down or right at any point in time.\"\\n\\nSo if you\\'re doing by recursion, only use two operations as move_right, or move_down."
                    },
                    {
                        "username": "Shaa-Khan",
                        "content": "you can move only down and right"
                    },
                    {
                        "username": "Aman_gupta-9833",
                        "content": "hats off for these much long query buddy"
                    },
                    {
                        "username": "conrad001",
                        "content": "The problem statement says you are only allowed to move right or down but in your solution the path moves left at some point too. That is the problem with your solution."
                    },
                    {
                        "username": "Heyns95",
                        "content": "I also get 79. How do we notify leetcode?"
                    },
                    {
                        "username": "adriankuehn",
                        "content": "Yip, same here for me for testcase 56/61. I solved it by only allowing the BFS to go down and right as mentioned in the task. Then I get 82 instead of 79. But the path for 79 looks correct for me as well. "
                    },
                    {
                        "username": "jamesh",
                        "content": "Such as:\\n\\n    1, 9, 1, 1, 1\\n    1, 1, 1, 9, 1\\n\\nAll the 1's form the minimum path."
                    },
                    {
                        "username": "Earth-Turtle",
                        "content": "There\\'s a clarification in the description that you can only move down or right"
                    },
                    {
                        "username": "psionl0",
                        "content": "After yesterday\\'s problem, it is nice to be able to just code an answer and have it pass all test cases right off the bat without even any syntax errors."
                    },
                    {
                        "username": "tensionstate",
                        "content": "I understand that in some shortest path algorithms on general node weighted graphs, negative cycles lead to non-termination, but here I do not see any problem, so why does the question state that the weights are not negative?"
                    },
                    {
                        "username": "AdityaBhate",
                        "content": "# \\uD83D\\uDCCC C++ || Recursion , DP - Memoization, Tabulation + Space Optimization\\nhttps://leetcode.com/problems/minimum-path-sum/solutions/3117215/c-recursion-dp-memoization-tabulation-space-optimization/?orderBy=hot"
                    },
                    {
                        "username": "ShadyCoder",
                        "content": "What if the follow-up question is how do you store the path information that gives the minimum pathsum? Any ideas about how we can achieve that in a better design perspective?"
                    },
                    {
                        "username": "mayank_pant",
                        "content": "backtracking using the created dp array. "
                    },
                    {
                        "username": "neel19",
                        "content": "Go in reverse order like we do LCS i.e, from $dp[row-1][col-1]$ keep going till cell $dp[0][0]$. "
                    },
                    {
                        "username": "alpharomeo99",
                        "content": "Apart from the solutions mentioned one can just start from the source after creating the dp array. From source move greedily towards the the cell that has the minimum path sum to the destination and accordingly update the path. This will take O(N) time."
                    },
                    {
                        "username": "keshav97",
                        "content": "use recursion we have 2 choices either go right or go down"
                    },
                    {
                        "username": "kushalnagwanshicloud",
                        "content": "I did this -> \\nhttps://leetcode.com/problems/minimum-path-sum/solutions/2819398/how-to-print-the-path-if-asked/"
                    },
                    {
                        "username": "f20200445",
                        "content": "Can someone explain why this is giving me TLE only on the last testcase? I could do tabulation but memoization is giving TLE.\\n\\n    int f(int i,int j,int m,int n,vector<vector<int>> grid,vector<vector<int>> &dp) {\\n        if(i==m-1 && j==n-1) {\\n            return grid[i][j];\\n        }\\n\\n        if(dp[i][j]!=-1) {\\n            return dp[i][j];\\n        }\\n\\n        if(i==m-1) {\\n            return dp[i][j]=grid[i][j]+f(i,j+1,m,n,grid,dp);\\n        }\\n        else if(j==n-1) {\\n            return dp[i][j]=grid[i][j]+f(i+1,j,m,n,grid,dp);\\n        }\\n\\n        return dp[i][j]=grid[i][j] + min(f(i,j+1,m,n,grid,dp),f(i+1,j,m,n,grid,dp));\\n    }\\n    int minPathSum(vector<vector<int>>& grid) {\\n        int m = grid.size();\\n        int n = grid[0].size();\\n        vector<vector<int>> dp(m,vector<int>(n,-1));\\n        return f(0,0,m,n,grid,dp);\\n    }"
                    },
                    {
                        "username": "oops_moment",
                        "content": "Hey even i did the same way, it will pass . Just pass through reference since otherwise multiple copies are created hence increasing time complexity of code. \\nHope it clears the doubt"
                    },
                    {
                        "username": "ee20b053",
                        "content": "in function \\'f\\' pass the matrix grid by reference to further reduce time complexity\\n"
                    },
                    {
                        "username": "viku_kr",
                        "content": "Instead of doing recursively, this question can be done iteratively. Leave the first row and first column, then for all other positions best way to move there is from minimum of (i-1,j) or (i, j-1)"
                    }
                ]
            },
            {
                "id": 1844935,
                "content": [
                    {
                        "username": "_srahul_",
                        "content": "Friendship ended with graph, now DP is my best friend."
                    },
                    {
                        "username": "user4401w",
                        "content": "XD\\n"
                    },
                    {
                        "username": "codeMonarch",
                        "content": "agree++;\\n"
                    },
                    {
                        "username": "daring-calf",
                        "content": "When I first met this problem 8 months ago it was so hard and frustrating, I spent a whole night and didn\\'t quite get it even after watching the solutions. And today it only took 5 minutes to write.\\nTo all the noobcoders out there: it always hurts the first time; but hang in there, eventually you\\'ll enjoy it."
                    },
                    {
                        "username": "bhuppidhamii",
                        "content": "right bro."
                    },
                    {
                        "username": "kartikey_wariyal",
                        "content": "i too cant solve right now\\n"
                    },
                    {
                        "username": "diabloexodia",
                        "content": "I believe in the heart of the algorithms"
                    },
                    {
                        "username": "sk03167",
                        "content": "I love the discussion section. It's nice to see people in the same journey as you. I have never solved this question before but I know earlier I would written a whole ass recursive function, then optimized with memo. Now, it was intuitive that it's a 2d dp problem and how to write it. Took all but 11 lines of code to beat 90% both time and space."
                    },
                    {
                        "username": "Crispy_coffee",
                        "content": "Still TLE bmro"
                    },
                    {
                        "username": "cOde_Ranvir25",
                        "content": "# Here is an Approach :-)\\n**The problem statement is to find the minimum path sum from the top-left corner to the bottom-right corner of a grid, where each cell in the grid has a non-negative integer value. The path can only move down or right at each step.**\\n\\n- We can use dynamic programming to solve this problem efficiently. We will create a 2D array dp of the same size as the input grid, where each cell dp[i][j] represents the minimum path sum from the top-left corner to cell (i, j).\\n\\n- We can initialize the dp array as follows:\\n\\n1. dp[0][0] = grid[0][0] since the minimum path sum to the top-left corner is the value of the top-left cell.\\n2. For the first row i=0 and first column j=0 < j < n, the minimum path sum can only be reached by moving right or down from the previous cell. So, we can compute dp[0][j] = dp[0][j-1] + grid[0][j] and dp[i][0] = dp[i-1][0] + grid[i][0] respectively.\\n3. For the rest of the cells, we can compute the minimum path sum as follows:\\ndp[i][j] = grid[i][j] + min(dp[i-1][j], dp[i][j-1]) since we can reach the current cell from the cell above or the cell to the left, and we want to take the path with the minimum sum.\\n- Once we have filled the dp array, the minimum path sum to the bottom-right corner will be dp[m-1][n-1], where m is the number of rows and n is the number of columns of the input grid.\\n\\n**The time complexity of this approach is O(mn) since we visit each cell once. The space complexity is also O(mn) since we use the dp array to store the intermediate results.**"
                    },
                    {
                        "username": "user5400vw",
                        "content": "good explanation.  the original grid can also act as your dp table."
                    },
                    {
                        "username": "cOde_Ranvir25",
                        "content": "***Here is the code link for reference:-)***\\nhttps://leetcode.com/problems/minimum-path-sum/solutions/2887704/easiest-solution/"
                    },
                    {
                        "username": "zaim",
                        "content": "On input \\n[[5,4,2,9,6,0,3,5,1,4,9,8,4,9,7,5,1],\\n [3,4,9,2,9,9,0,9,7,9,4,7,8,4,4,5,8],\\n [6,1,8,9,8,0,3,7,0,9,8,7,4,9,2,0,1],\\n [4,0,0,5,1,7,4,7,6,4,1,0,1,0,6,2,8],\\n [7,2,0,2,9,3,4,7,0,8,9,5,9,0,1,1,0],\\n [8,2,9,4,9,7,9,3,7,0,3,6,5,3,5,9,6],\\n [8,9,9,2,6,1,2,5,8,3,7,0,4,9,8,8,8],\\n [5,8,5,4,1,5,6,6,3,3,1,8,3,9,6,4,8],\\n [0,2,2,3,0,2,6,7,2,3,7,3,1,5,8,1,3],\\n [4,4,0,2,0,3,8,4,1,3,3,0,7,4,2,9,8],\\n [5,9,0,4,7,5,7,6,0,8,3,0,0,6,6,6,8],\\n [0,7,1,8,3,5,1,8,7,0,2,9,2,2,7,1,5],\\n [1,0,0,0,6,2,0,0,2,2,8,0,9,7,0,8,0],\\n [1,1,7,2,9,6,5,4,8,7,8,5,0,3,8,1,5],\\n [8,9,7,8,1,1,3,0,1,2,9,4,0,1,5,3,1],\\n [9,2,7,4,8,7,3,9,2,4,2,2,7,8,2,6,7],\\n [3,8,1,6,0,4,8,9,8,0,2,5,3,5,5,7,5],\\n [1,8,2,5,7,7,1,9,9,8,9,2,4,9,5,4,0],\\n [3,4,4,1,5,3,3,8,8,6,3,5,3,8,7,1,3]]\\n\\nckeckers solution is 82, but mine is is 79 with the following path:\\n\\n[05] 04  02  09  06  00  03  05  01  04  09  08  04  09  07  05  01 \\n\\n[03][04] 09  02  09  09  00  09  07  09  04  07  08  04  04  05  08 \\n\\n 06 [01] 08  09  08  00  03  07  00  09  08  07  04  09  02  00  01 \\n\\n 04 [00][00] 05  01  07  04  07  06  04  01  00  01  00  06  02  08 \\n\\n 07  02 [00][02] 09  03  04  07  00  08  09  05  09  00  01  01  00 \\n\\n 08  02  09 [04] 09  07  09  03  07  00  03  06  05  03  05  09  06 \\n\\n 08  09  09 [02] 06  01  02  05  08  03  07  00  04  09  08  08  08 \\n\\n 05  08  05 [04][01] 05  06  06  03  03  01  08  03  09  06  04  08 \\n\\n 00  02  02  03 [00] 02  06  07  02  03  07  03  01  05  08  01  03 \\n\\n 04  04 [00][02][00] 03  08  04  01  03  03  00  07  04  02  09  08 \\n\\n 05  09 [00] 04  07  05  07  06  00  08  03  00  00  06  06  06  08 \\n\\n 00  07 [01] 08  03  05  01  08  07  00  02  09  02  02  07  01  05 \\n\\n 01  00 [00][00][06][02][00][00][02][02][08][00] 09  07  00  08  00 \\n\\n 01  01  07  02  09  06  05  04  08  07  08 [05][00] 03  08  01  05 \\n\\n 08  09  07  08  01  01  03  00  01  02  09  04 [00][01][05][03][01]\\n\\n 09  02  07  04  08  07  03  09  02  04  02  02  07  08  02  06 [07]\\n\\n 03  08  01  06  00  04  08  09  08  00  02  05  03  05  05  07 [05]\\n\\n 01  08  02  05  07  07  01  09  09  08  09  02  04  09  05  04 [00]\\n\\n 03  04  04  01  05  03  03  08  08  06  03  05  03  08  07  01 [03]\\n\\nDoes anyone have a suggestion what I am doing wrong?"
                    },
                    {
                        "username": "LucidLynxxx",
                        "content": "I believe it is illlegal to move back, which you do? \"Note: You can only move either down or right at any point in time.\""
                    },
                    {
                        "username": "red_akb",
                        "content": "See 10th line, you\\'re moving left\\n\\nBut it is clearly mentioned in que that ->\\n\\n\"Note: You can only move either down or right at any point in time.\"\\n\\nSo if you\\'re doing by recursion, only use two operations as move_right, or move_down."
                    },
                    {
                        "username": "Shaa-Khan",
                        "content": "you can move only down and right"
                    },
                    {
                        "username": "Aman_gupta-9833",
                        "content": "hats off for these much long query buddy"
                    },
                    {
                        "username": "conrad001",
                        "content": "The problem statement says you are only allowed to move right or down but in your solution the path moves left at some point too. That is the problem with your solution."
                    },
                    {
                        "username": "Heyns95",
                        "content": "I also get 79. How do we notify leetcode?"
                    },
                    {
                        "username": "adriankuehn",
                        "content": "Yip, same here for me for testcase 56/61. I solved it by only allowing the BFS to go down and right as mentioned in the task. Then I get 82 instead of 79. But the path for 79 looks correct for me as well. "
                    },
                    {
                        "username": "jamesh",
                        "content": "Such as:\\n\\n    1, 9, 1, 1, 1\\n    1, 1, 1, 9, 1\\n\\nAll the 1's form the minimum path."
                    },
                    {
                        "username": "Earth-Turtle",
                        "content": "There\\'s a clarification in the description that you can only move down or right"
                    },
                    {
                        "username": "psionl0",
                        "content": "After yesterday\\'s problem, it is nice to be able to just code an answer and have it pass all test cases right off the bat without even any syntax errors."
                    },
                    {
                        "username": "tensionstate",
                        "content": "I understand that in some shortest path algorithms on general node weighted graphs, negative cycles lead to non-termination, but here I do not see any problem, so why does the question state that the weights are not negative?"
                    },
                    {
                        "username": "AdityaBhate",
                        "content": "# \\uD83D\\uDCCC C++ || Recursion , DP - Memoization, Tabulation + Space Optimization\\nhttps://leetcode.com/problems/minimum-path-sum/solutions/3117215/c-recursion-dp-memoization-tabulation-space-optimization/?orderBy=hot"
                    },
                    {
                        "username": "ShadyCoder",
                        "content": "What if the follow-up question is how do you store the path information that gives the minimum pathsum? Any ideas about how we can achieve that in a better design perspective?"
                    },
                    {
                        "username": "mayank_pant",
                        "content": "backtracking using the created dp array. "
                    },
                    {
                        "username": "neel19",
                        "content": "Go in reverse order like we do LCS i.e, from $dp[row-1][col-1]$ keep going till cell $dp[0][0]$. "
                    },
                    {
                        "username": "alpharomeo99",
                        "content": "Apart from the solutions mentioned one can just start from the source after creating the dp array. From source move greedily towards the the cell that has the minimum path sum to the destination and accordingly update the path. This will take O(N) time."
                    },
                    {
                        "username": "keshav97",
                        "content": "use recursion we have 2 choices either go right or go down"
                    },
                    {
                        "username": "kushalnagwanshicloud",
                        "content": "I did this -> \\nhttps://leetcode.com/problems/minimum-path-sum/solutions/2819398/how-to-print-the-path-if-asked/"
                    },
                    {
                        "username": "f20200445",
                        "content": "Can someone explain why this is giving me TLE only on the last testcase? I could do tabulation but memoization is giving TLE.\\n\\n    int f(int i,int j,int m,int n,vector<vector<int>> grid,vector<vector<int>> &dp) {\\n        if(i==m-1 && j==n-1) {\\n            return grid[i][j];\\n        }\\n\\n        if(dp[i][j]!=-1) {\\n            return dp[i][j];\\n        }\\n\\n        if(i==m-1) {\\n            return dp[i][j]=grid[i][j]+f(i,j+1,m,n,grid,dp);\\n        }\\n        else if(j==n-1) {\\n            return dp[i][j]=grid[i][j]+f(i+1,j,m,n,grid,dp);\\n        }\\n\\n        return dp[i][j]=grid[i][j] + min(f(i,j+1,m,n,grid,dp),f(i+1,j,m,n,grid,dp));\\n    }\\n    int minPathSum(vector<vector<int>>& grid) {\\n        int m = grid.size();\\n        int n = grid[0].size();\\n        vector<vector<int>> dp(m,vector<int>(n,-1));\\n        return f(0,0,m,n,grid,dp);\\n    }"
                    },
                    {
                        "username": "oops_moment",
                        "content": "Hey even i did the same way, it will pass . Just pass through reference since otherwise multiple copies are created hence increasing time complexity of code. \\nHope it clears the doubt"
                    },
                    {
                        "username": "ee20b053",
                        "content": "in function \\'f\\' pass the matrix grid by reference to further reduce time complexity\\n"
                    },
                    {
                        "username": "viku_kr",
                        "content": "Instead of doing recursively, this question can be done iteratively. Leave the first row and first column, then for all other positions best way to move there is from minimum of (i-1,j) or (i, j-1)"
                    }
                ]
            },
            {
                "id": 1844856,
                "content": [
                    {
                        "username": "_srahul_",
                        "content": "Friendship ended with graph, now DP is my best friend."
                    },
                    {
                        "username": "user4401w",
                        "content": "XD\\n"
                    },
                    {
                        "username": "codeMonarch",
                        "content": "agree++;\\n"
                    },
                    {
                        "username": "daring-calf",
                        "content": "When I first met this problem 8 months ago it was so hard and frustrating, I spent a whole night and didn\\'t quite get it even after watching the solutions. And today it only took 5 minutes to write.\\nTo all the noobcoders out there: it always hurts the first time; but hang in there, eventually you\\'ll enjoy it."
                    },
                    {
                        "username": "bhuppidhamii",
                        "content": "right bro."
                    },
                    {
                        "username": "kartikey_wariyal",
                        "content": "i too cant solve right now\\n"
                    },
                    {
                        "username": "diabloexodia",
                        "content": "I believe in the heart of the algorithms"
                    },
                    {
                        "username": "sk03167",
                        "content": "I love the discussion section. It's nice to see people in the same journey as you. I have never solved this question before but I know earlier I would written a whole ass recursive function, then optimized with memo. Now, it was intuitive that it's a 2d dp problem and how to write it. Took all but 11 lines of code to beat 90% both time and space."
                    },
                    {
                        "username": "Crispy_coffee",
                        "content": "Still TLE bmro"
                    },
                    {
                        "username": "cOde_Ranvir25",
                        "content": "# Here is an Approach :-)\\n**The problem statement is to find the minimum path sum from the top-left corner to the bottom-right corner of a grid, where each cell in the grid has a non-negative integer value. The path can only move down or right at each step.**\\n\\n- We can use dynamic programming to solve this problem efficiently. We will create a 2D array dp of the same size as the input grid, where each cell dp[i][j] represents the minimum path sum from the top-left corner to cell (i, j).\\n\\n- We can initialize the dp array as follows:\\n\\n1. dp[0][0] = grid[0][0] since the minimum path sum to the top-left corner is the value of the top-left cell.\\n2. For the first row i=0 and first column j=0 < j < n, the minimum path sum can only be reached by moving right or down from the previous cell. So, we can compute dp[0][j] = dp[0][j-1] + grid[0][j] and dp[i][0] = dp[i-1][0] + grid[i][0] respectively.\\n3. For the rest of the cells, we can compute the minimum path sum as follows:\\ndp[i][j] = grid[i][j] + min(dp[i-1][j], dp[i][j-1]) since we can reach the current cell from the cell above or the cell to the left, and we want to take the path with the minimum sum.\\n- Once we have filled the dp array, the minimum path sum to the bottom-right corner will be dp[m-1][n-1], where m is the number of rows and n is the number of columns of the input grid.\\n\\n**The time complexity of this approach is O(mn) since we visit each cell once. The space complexity is also O(mn) since we use the dp array to store the intermediate results.**"
                    },
                    {
                        "username": "user5400vw",
                        "content": "good explanation.  the original grid can also act as your dp table."
                    },
                    {
                        "username": "cOde_Ranvir25",
                        "content": "***Here is the code link for reference:-)***\\nhttps://leetcode.com/problems/minimum-path-sum/solutions/2887704/easiest-solution/"
                    },
                    {
                        "username": "zaim",
                        "content": "On input \\n[[5,4,2,9,6,0,3,5,1,4,9,8,4,9,7,5,1],\\n [3,4,9,2,9,9,0,9,7,9,4,7,8,4,4,5,8],\\n [6,1,8,9,8,0,3,7,0,9,8,7,4,9,2,0,1],\\n [4,0,0,5,1,7,4,7,6,4,1,0,1,0,6,2,8],\\n [7,2,0,2,9,3,4,7,0,8,9,5,9,0,1,1,0],\\n [8,2,9,4,9,7,9,3,7,0,3,6,5,3,5,9,6],\\n [8,9,9,2,6,1,2,5,8,3,7,0,4,9,8,8,8],\\n [5,8,5,4,1,5,6,6,3,3,1,8,3,9,6,4,8],\\n [0,2,2,3,0,2,6,7,2,3,7,3,1,5,8,1,3],\\n [4,4,0,2,0,3,8,4,1,3,3,0,7,4,2,9,8],\\n [5,9,0,4,7,5,7,6,0,8,3,0,0,6,6,6,8],\\n [0,7,1,8,3,5,1,8,7,0,2,9,2,2,7,1,5],\\n [1,0,0,0,6,2,0,0,2,2,8,0,9,7,0,8,0],\\n [1,1,7,2,9,6,5,4,8,7,8,5,0,3,8,1,5],\\n [8,9,7,8,1,1,3,0,1,2,9,4,0,1,5,3,1],\\n [9,2,7,4,8,7,3,9,2,4,2,2,7,8,2,6,7],\\n [3,8,1,6,0,4,8,9,8,0,2,5,3,5,5,7,5],\\n [1,8,2,5,7,7,1,9,9,8,9,2,4,9,5,4,0],\\n [3,4,4,1,5,3,3,8,8,6,3,5,3,8,7,1,3]]\\n\\nckeckers solution is 82, but mine is is 79 with the following path:\\n\\n[05] 04  02  09  06  00  03  05  01  04  09  08  04  09  07  05  01 \\n\\n[03][04] 09  02  09  09  00  09  07  09  04  07  08  04  04  05  08 \\n\\n 06 [01] 08  09  08  00  03  07  00  09  08  07  04  09  02  00  01 \\n\\n 04 [00][00] 05  01  07  04  07  06  04  01  00  01  00  06  02  08 \\n\\n 07  02 [00][02] 09  03  04  07  00  08  09  05  09  00  01  01  00 \\n\\n 08  02  09 [04] 09  07  09  03  07  00  03  06  05  03  05  09  06 \\n\\n 08  09  09 [02] 06  01  02  05  08  03  07  00  04  09  08  08  08 \\n\\n 05  08  05 [04][01] 05  06  06  03  03  01  08  03  09  06  04  08 \\n\\n 00  02  02  03 [00] 02  06  07  02  03  07  03  01  05  08  01  03 \\n\\n 04  04 [00][02][00] 03  08  04  01  03  03  00  07  04  02  09  08 \\n\\n 05  09 [00] 04  07  05  07  06  00  08  03  00  00  06  06  06  08 \\n\\n 00  07 [01] 08  03  05  01  08  07  00  02  09  02  02  07  01  05 \\n\\n 01  00 [00][00][06][02][00][00][02][02][08][00] 09  07  00  08  00 \\n\\n 01  01  07  02  09  06  05  04  08  07  08 [05][00] 03  08  01  05 \\n\\n 08  09  07  08  01  01  03  00  01  02  09  04 [00][01][05][03][01]\\n\\n 09  02  07  04  08  07  03  09  02  04  02  02  07  08  02  06 [07]\\n\\n 03  08  01  06  00  04  08  09  08  00  02  05  03  05  05  07 [05]\\n\\n 01  08  02  05  07  07  01  09  09  08  09  02  04  09  05  04 [00]\\n\\n 03  04  04  01  05  03  03  08  08  06  03  05  03  08  07  01 [03]\\n\\nDoes anyone have a suggestion what I am doing wrong?"
                    },
                    {
                        "username": "LucidLynxxx",
                        "content": "I believe it is illlegal to move back, which you do? \"Note: You can only move either down or right at any point in time.\""
                    },
                    {
                        "username": "red_akb",
                        "content": "See 10th line, you\\'re moving left\\n\\nBut it is clearly mentioned in que that ->\\n\\n\"Note: You can only move either down or right at any point in time.\"\\n\\nSo if you\\'re doing by recursion, only use two operations as move_right, or move_down."
                    },
                    {
                        "username": "Shaa-Khan",
                        "content": "you can move only down and right"
                    },
                    {
                        "username": "Aman_gupta-9833",
                        "content": "hats off for these much long query buddy"
                    },
                    {
                        "username": "conrad001",
                        "content": "The problem statement says you are only allowed to move right or down but in your solution the path moves left at some point too. That is the problem with your solution."
                    },
                    {
                        "username": "Heyns95",
                        "content": "I also get 79. How do we notify leetcode?"
                    },
                    {
                        "username": "adriankuehn",
                        "content": "Yip, same here for me for testcase 56/61. I solved it by only allowing the BFS to go down and right as mentioned in the task. Then I get 82 instead of 79. But the path for 79 looks correct for me as well. "
                    },
                    {
                        "username": "jamesh",
                        "content": "Such as:\\n\\n    1, 9, 1, 1, 1\\n    1, 1, 1, 9, 1\\n\\nAll the 1's form the minimum path."
                    },
                    {
                        "username": "Earth-Turtle",
                        "content": "There\\'s a clarification in the description that you can only move down or right"
                    },
                    {
                        "username": "psionl0",
                        "content": "After yesterday\\'s problem, it is nice to be able to just code an answer and have it pass all test cases right off the bat without even any syntax errors."
                    },
                    {
                        "username": "tensionstate",
                        "content": "I understand that in some shortest path algorithms on general node weighted graphs, negative cycles lead to non-termination, but here I do not see any problem, so why does the question state that the weights are not negative?"
                    },
                    {
                        "username": "AdityaBhate",
                        "content": "# \\uD83D\\uDCCC C++ || Recursion , DP - Memoization, Tabulation + Space Optimization\\nhttps://leetcode.com/problems/minimum-path-sum/solutions/3117215/c-recursion-dp-memoization-tabulation-space-optimization/?orderBy=hot"
                    },
                    {
                        "username": "ShadyCoder",
                        "content": "What if the follow-up question is how do you store the path information that gives the minimum pathsum? Any ideas about how we can achieve that in a better design perspective?"
                    },
                    {
                        "username": "mayank_pant",
                        "content": "backtracking using the created dp array. "
                    },
                    {
                        "username": "neel19",
                        "content": "Go in reverse order like we do LCS i.e, from $dp[row-1][col-1]$ keep going till cell $dp[0][0]$. "
                    },
                    {
                        "username": "alpharomeo99",
                        "content": "Apart from the solutions mentioned one can just start from the source after creating the dp array. From source move greedily towards the the cell that has the minimum path sum to the destination and accordingly update the path. This will take O(N) time."
                    },
                    {
                        "username": "keshav97",
                        "content": "use recursion we have 2 choices either go right or go down"
                    },
                    {
                        "username": "kushalnagwanshicloud",
                        "content": "I did this -> \\nhttps://leetcode.com/problems/minimum-path-sum/solutions/2819398/how-to-print-the-path-if-asked/"
                    },
                    {
                        "username": "f20200445",
                        "content": "Can someone explain why this is giving me TLE only on the last testcase? I could do tabulation but memoization is giving TLE.\\n\\n    int f(int i,int j,int m,int n,vector<vector<int>> grid,vector<vector<int>> &dp) {\\n        if(i==m-1 && j==n-1) {\\n            return grid[i][j];\\n        }\\n\\n        if(dp[i][j]!=-1) {\\n            return dp[i][j];\\n        }\\n\\n        if(i==m-1) {\\n            return dp[i][j]=grid[i][j]+f(i,j+1,m,n,grid,dp);\\n        }\\n        else if(j==n-1) {\\n            return dp[i][j]=grid[i][j]+f(i+1,j,m,n,grid,dp);\\n        }\\n\\n        return dp[i][j]=grid[i][j] + min(f(i,j+1,m,n,grid,dp),f(i+1,j,m,n,grid,dp));\\n    }\\n    int minPathSum(vector<vector<int>>& grid) {\\n        int m = grid.size();\\n        int n = grid[0].size();\\n        vector<vector<int>> dp(m,vector<int>(n,-1));\\n        return f(0,0,m,n,grid,dp);\\n    }"
                    },
                    {
                        "username": "oops_moment",
                        "content": "Hey even i did the same way, it will pass . Just pass through reference since otherwise multiple copies are created hence increasing time complexity of code. \\nHope it clears the doubt"
                    },
                    {
                        "username": "ee20b053",
                        "content": "in function \\'f\\' pass the matrix grid by reference to further reduce time complexity\\n"
                    },
                    {
                        "username": "viku_kr",
                        "content": "Instead of doing recursively, this question can be done iteratively. Leave the first row and first column, then for all other positions best way to move there is from minimum of (i-1,j) or (i, j-1)"
                    }
                ]
            },
            {
                "id": 1568882,
                "content": [
                    {
                        "username": "_srahul_",
                        "content": "Friendship ended with graph, now DP is my best friend."
                    },
                    {
                        "username": "user4401w",
                        "content": "XD\\n"
                    },
                    {
                        "username": "codeMonarch",
                        "content": "agree++;\\n"
                    },
                    {
                        "username": "daring-calf",
                        "content": "When I first met this problem 8 months ago it was so hard and frustrating, I spent a whole night and didn\\'t quite get it even after watching the solutions. And today it only took 5 minutes to write.\\nTo all the noobcoders out there: it always hurts the first time; but hang in there, eventually you\\'ll enjoy it."
                    },
                    {
                        "username": "bhuppidhamii",
                        "content": "right bro."
                    },
                    {
                        "username": "kartikey_wariyal",
                        "content": "i too cant solve right now\\n"
                    },
                    {
                        "username": "diabloexodia",
                        "content": "I believe in the heart of the algorithms"
                    },
                    {
                        "username": "sk03167",
                        "content": "I love the discussion section. It's nice to see people in the same journey as you. I have never solved this question before but I know earlier I would written a whole ass recursive function, then optimized with memo. Now, it was intuitive that it's a 2d dp problem and how to write it. Took all but 11 lines of code to beat 90% both time and space."
                    },
                    {
                        "username": "Crispy_coffee",
                        "content": "Still TLE bmro"
                    },
                    {
                        "username": "cOde_Ranvir25",
                        "content": "# Here is an Approach :-)\\n**The problem statement is to find the minimum path sum from the top-left corner to the bottom-right corner of a grid, where each cell in the grid has a non-negative integer value. The path can only move down or right at each step.**\\n\\n- We can use dynamic programming to solve this problem efficiently. We will create a 2D array dp of the same size as the input grid, where each cell dp[i][j] represents the minimum path sum from the top-left corner to cell (i, j).\\n\\n- We can initialize the dp array as follows:\\n\\n1. dp[0][0] = grid[0][0] since the minimum path sum to the top-left corner is the value of the top-left cell.\\n2. For the first row i=0 and first column j=0 < j < n, the minimum path sum can only be reached by moving right or down from the previous cell. So, we can compute dp[0][j] = dp[0][j-1] + grid[0][j] and dp[i][0] = dp[i-1][0] + grid[i][0] respectively.\\n3. For the rest of the cells, we can compute the minimum path sum as follows:\\ndp[i][j] = grid[i][j] + min(dp[i-1][j], dp[i][j-1]) since we can reach the current cell from the cell above or the cell to the left, and we want to take the path with the minimum sum.\\n- Once we have filled the dp array, the minimum path sum to the bottom-right corner will be dp[m-1][n-1], where m is the number of rows and n is the number of columns of the input grid.\\n\\n**The time complexity of this approach is O(mn) since we visit each cell once. The space complexity is also O(mn) since we use the dp array to store the intermediate results.**"
                    },
                    {
                        "username": "user5400vw",
                        "content": "good explanation.  the original grid can also act as your dp table."
                    },
                    {
                        "username": "cOde_Ranvir25",
                        "content": "***Here is the code link for reference:-)***\\nhttps://leetcode.com/problems/minimum-path-sum/solutions/2887704/easiest-solution/"
                    },
                    {
                        "username": "zaim",
                        "content": "On input \\n[[5,4,2,9,6,0,3,5,1,4,9,8,4,9,7,5,1],\\n [3,4,9,2,9,9,0,9,7,9,4,7,8,4,4,5,8],\\n [6,1,8,9,8,0,3,7,0,9,8,7,4,9,2,0,1],\\n [4,0,0,5,1,7,4,7,6,4,1,0,1,0,6,2,8],\\n [7,2,0,2,9,3,4,7,0,8,9,5,9,0,1,1,0],\\n [8,2,9,4,9,7,9,3,7,0,3,6,5,3,5,9,6],\\n [8,9,9,2,6,1,2,5,8,3,7,0,4,9,8,8,8],\\n [5,8,5,4,1,5,6,6,3,3,1,8,3,9,6,4,8],\\n [0,2,2,3,0,2,6,7,2,3,7,3,1,5,8,1,3],\\n [4,4,0,2,0,3,8,4,1,3,3,0,7,4,2,9,8],\\n [5,9,0,4,7,5,7,6,0,8,3,0,0,6,6,6,8],\\n [0,7,1,8,3,5,1,8,7,0,2,9,2,2,7,1,5],\\n [1,0,0,0,6,2,0,0,2,2,8,0,9,7,0,8,0],\\n [1,1,7,2,9,6,5,4,8,7,8,5,0,3,8,1,5],\\n [8,9,7,8,1,1,3,0,1,2,9,4,0,1,5,3,1],\\n [9,2,7,4,8,7,3,9,2,4,2,2,7,8,2,6,7],\\n [3,8,1,6,0,4,8,9,8,0,2,5,3,5,5,7,5],\\n [1,8,2,5,7,7,1,9,9,8,9,2,4,9,5,4,0],\\n [3,4,4,1,5,3,3,8,8,6,3,5,3,8,7,1,3]]\\n\\nckeckers solution is 82, but mine is is 79 with the following path:\\n\\n[05] 04  02  09  06  00  03  05  01  04  09  08  04  09  07  05  01 \\n\\n[03][04] 09  02  09  09  00  09  07  09  04  07  08  04  04  05  08 \\n\\n 06 [01] 08  09  08  00  03  07  00  09  08  07  04  09  02  00  01 \\n\\n 04 [00][00] 05  01  07  04  07  06  04  01  00  01  00  06  02  08 \\n\\n 07  02 [00][02] 09  03  04  07  00  08  09  05  09  00  01  01  00 \\n\\n 08  02  09 [04] 09  07  09  03  07  00  03  06  05  03  05  09  06 \\n\\n 08  09  09 [02] 06  01  02  05  08  03  07  00  04  09  08  08  08 \\n\\n 05  08  05 [04][01] 05  06  06  03  03  01  08  03  09  06  04  08 \\n\\n 00  02  02  03 [00] 02  06  07  02  03  07  03  01  05  08  01  03 \\n\\n 04  04 [00][02][00] 03  08  04  01  03  03  00  07  04  02  09  08 \\n\\n 05  09 [00] 04  07  05  07  06  00  08  03  00  00  06  06  06  08 \\n\\n 00  07 [01] 08  03  05  01  08  07  00  02  09  02  02  07  01  05 \\n\\n 01  00 [00][00][06][02][00][00][02][02][08][00] 09  07  00  08  00 \\n\\n 01  01  07  02  09  06  05  04  08  07  08 [05][00] 03  08  01  05 \\n\\n 08  09  07  08  01  01  03  00  01  02  09  04 [00][01][05][03][01]\\n\\n 09  02  07  04  08  07  03  09  02  04  02  02  07  08  02  06 [07]\\n\\n 03  08  01  06  00  04  08  09  08  00  02  05  03  05  05  07 [05]\\n\\n 01  08  02  05  07  07  01  09  09  08  09  02  04  09  05  04 [00]\\n\\n 03  04  04  01  05  03  03  08  08  06  03  05  03  08  07  01 [03]\\n\\nDoes anyone have a suggestion what I am doing wrong?"
                    },
                    {
                        "username": "LucidLynxxx",
                        "content": "I believe it is illlegal to move back, which you do? \"Note: You can only move either down or right at any point in time.\""
                    },
                    {
                        "username": "red_akb",
                        "content": "See 10th line, you\\'re moving left\\n\\nBut it is clearly mentioned in que that ->\\n\\n\"Note: You can only move either down or right at any point in time.\"\\n\\nSo if you\\'re doing by recursion, only use two operations as move_right, or move_down."
                    },
                    {
                        "username": "Shaa-Khan",
                        "content": "you can move only down and right"
                    },
                    {
                        "username": "Aman_gupta-9833",
                        "content": "hats off for these much long query buddy"
                    },
                    {
                        "username": "conrad001",
                        "content": "The problem statement says you are only allowed to move right or down but in your solution the path moves left at some point too. That is the problem with your solution."
                    },
                    {
                        "username": "Heyns95",
                        "content": "I also get 79. How do we notify leetcode?"
                    },
                    {
                        "username": "adriankuehn",
                        "content": "Yip, same here for me for testcase 56/61. I solved it by only allowing the BFS to go down and right as mentioned in the task. Then I get 82 instead of 79. But the path for 79 looks correct for me as well. "
                    },
                    {
                        "username": "jamesh",
                        "content": "Such as:\\n\\n    1, 9, 1, 1, 1\\n    1, 1, 1, 9, 1\\n\\nAll the 1's form the minimum path."
                    },
                    {
                        "username": "Earth-Turtle",
                        "content": "There\\'s a clarification in the description that you can only move down or right"
                    },
                    {
                        "username": "psionl0",
                        "content": "After yesterday\\'s problem, it is nice to be able to just code an answer and have it pass all test cases right off the bat without even any syntax errors."
                    },
                    {
                        "username": "tensionstate",
                        "content": "I understand that in some shortest path algorithms on general node weighted graphs, negative cycles lead to non-termination, but here I do not see any problem, so why does the question state that the weights are not negative?"
                    },
                    {
                        "username": "AdityaBhate",
                        "content": "# \\uD83D\\uDCCC C++ || Recursion , DP - Memoization, Tabulation + Space Optimization\\nhttps://leetcode.com/problems/minimum-path-sum/solutions/3117215/c-recursion-dp-memoization-tabulation-space-optimization/?orderBy=hot"
                    },
                    {
                        "username": "ShadyCoder",
                        "content": "What if the follow-up question is how do you store the path information that gives the minimum pathsum? Any ideas about how we can achieve that in a better design perspective?"
                    },
                    {
                        "username": "mayank_pant",
                        "content": "backtracking using the created dp array. "
                    },
                    {
                        "username": "neel19",
                        "content": "Go in reverse order like we do LCS i.e, from $dp[row-1][col-1]$ keep going till cell $dp[0][0]$. "
                    },
                    {
                        "username": "alpharomeo99",
                        "content": "Apart from the solutions mentioned one can just start from the source after creating the dp array. From source move greedily towards the the cell that has the minimum path sum to the destination and accordingly update the path. This will take O(N) time."
                    },
                    {
                        "username": "keshav97",
                        "content": "use recursion we have 2 choices either go right or go down"
                    },
                    {
                        "username": "kushalnagwanshicloud",
                        "content": "I did this -> \\nhttps://leetcode.com/problems/minimum-path-sum/solutions/2819398/how-to-print-the-path-if-asked/"
                    },
                    {
                        "username": "f20200445",
                        "content": "Can someone explain why this is giving me TLE only on the last testcase? I could do tabulation but memoization is giving TLE.\\n\\n    int f(int i,int j,int m,int n,vector<vector<int>> grid,vector<vector<int>> &dp) {\\n        if(i==m-1 && j==n-1) {\\n            return grid[i][j];\\n        }\\n\\n        if(dp[i][j]!=-1) {\\n            return dp[i][j];\\n        }\\n\\n        if(i==m-1) {\\n            return dp[i][j]=grid[i][j]+f(i,j+1,m,n,grid,dp);\\n        }\\n        else if(j==n-1) {\\n            return dp[i][j]=grid[i][j]+f(i+1,j,m,n,grid,dp);\\n        }\\n\\n        return dp[i][j]=grid[i][j] + min(f(i,j+1,m,n,grid,dp),f(i+1,j,m,n,grid,dp));\\n    }\\n    int minPathSum(vector<vector<int>>& grid) {\\n        int m = grid.size();\\n        int n = grid[0].size();\\n        vector<vector<int>> dp(m,vector<int>(n,-1));\\n        return f(0,0,m,n,grid,dp);\\n    }"
                    },
                    {
                        "username": "oops_moment",
                        "content": "Hey even i did the same way, it will pass . Just pass through reference since otherwise multiple copies are created hence increasing time complexity of code. \\nHope it clears the doubt"
                    },
                    {
                        "username": "ee20b053",
                        "content": "in function \\'f\\' pass the matrix grid by reference to further reduce time complexity\\n"
                    },
                    {
                        "username": "viku_kr",
                        "content": "Instead of doing recursively, this question can be done iteratively. Leave the first row and first column, then for all other positions best way to move there is from minimum of (i-1,j) or (i, j-1)"
                    }
                ]
            },
            {
                "id": 1567180,
                "content": [
                    {
                        "username": "_srahul_",
                        "content": "Friendship ended with graph, now DP is my best friend."
                    },
                    {
                        "username": "user4401w",
                        "content": "XD\\n"
                    },
                    {
                        "username": "codeMonarch",
                        "content": "agree++;\\n"
                    },
                    {
                        "username": "daring-calf",
                        "content": "When I first met this problem 8 months ago it was so hard and frustrating, I spent a whole night and didn\\'t quite get it even after watching the solutions. And today it only took 5 minutes to write.\\nTo all the noobcoders out there: it always hurts the first time; but hang in there, eventually you\\'ll enjoy it."
                    },
                    {
                        "username": "bhuppidhamii",
                        "content": "right bro."
                    },
                    {
                        "username": "kartikey_wariyal",
                        "content": "i too cant solve right now\\n"
                    },
                    {
                        "username": "diabloexodia",
                        "content": "I believe in the heart of the algorithms"
                    },
                    {
                        "username": "sk03167",
                        "content": "I love the discussion section. It's nice to see people in the same journey as you. I have never solved this question before but I know earlier I would written a whole ass recursive function, then optimized with memo. Now, it was intuitive that it's a 2d dp problem and how to write it. Took all but 11 lines of code to beat 90% both time and space."
                    },
                    {
                        "username": "Crispy_coffee",
                        "content": "Still TLE bmro"
                    },
                    {
                        "username": "cOde_Ranvir25",
                        "content": "# Here is an Approach :-)\\n**The problem statement is to find the minimum path sum from the top-left corner to the bottom-right corner of a grid, where each cell in the grid has a non-negative integer value. The path can only move down or right at each step.**\\n\\n- We can use dynamic programming to solve this problem efficiently. We will create a 2D array dp of the same size as the input grid, where each cell dp[i][j] represents the minimum path sum from the top-left corner to cell (i, j).\\n\\n- We can initialize the dp array as follows:\\n\\n1. dp[0][0] = grid[0][0] since the minimum path sum to the top-left corner is the value of the top-left cell.\\n2. For the first row i=0 and first column j=0 < j < n, the minimum path sum can only be reached by moving right or down from the previous cell. So, we can compute dp[0][j] = dp[0][j-1] + grid[0][j] and dp[i][0] = dp[i-1][0] + grid[i][0] respectively.\\n3. For the rest of the cells, we can compute the minimum path sum as follows:\\ndp[i][j] = grid[i][j] + min(dp[i-1][j], dp[i][j-1]) since we can reach the current cell from the cell above or the cell to the left, and we want to take the path with the minimum sum.\\n- Once we have filled the dp array, the minimum path sum to the bottom-right corner will be dp[m-1][n-1], where m is the number of rows and n is the number of columns of the input grid.\\n\\n**The time complexity of this approach is O(mn) since we visit each cell once. The space complexity is also O(mn) since we use the dp array to store the intermediate results.**"
                    },
                    {
                        "username": "user5400vw",
                        "content": "good explanation.  the original grid can also act as your dp table."
                    },
                    {
                        "username": "cOde_Ranvir25",
                        "content": "***Here is the code link for reference:-)***\\nhttps://leetcode.com/problems/minimum-path-sum/solutions/2887704/easiest-solution/"
                    },
                    {
                        "username": "zaim",
                        "content": "On input \\n[[5,4,2,9,6,0,3,5,1,4,9,8,4,9,7,5,1],\\n [3,4,9,2,9,9,0,9,7,9,4,7,8,4,4,5,8],\\n [6,1,8,9,8,0,3,7,0,9,8,7,4,9,2,0,1],\\n [4,0,0,5,1,7,4,7,6,4,1,0,1,0,6,2,8],\\n [7,2,0,2,9,3,4,7,0,8,9,5,9,0,1,1,0],\\n [8,2,9,4,9,7,9,3,7,0,3,6,5,3,5,9,6],\\n [8,9,9,2,6,1,2,5,8,3,7,0,4,9,8,8,8],\\n [5,8,5,4,1,5,6,6,3,3,1,8,3,9,6,4,8],\\n [0,2,2,3,0,2,6,7,2,3,7,3,1,5,8,1,3],\\n [4,4,0,2,0,3,8,4,1,3,3,0,7,4,2,9,8],\\n [5,9,0,4,7,5,7,6,0,8,3,0,0,6,6,6,8],\\n [0,7,1,8,3,5,1,8,7,0,2,9,2,2,7,1,5],\\n [1,0,0,0,6,2,0,0,2,2,8,0,9,7,0,8,0],\\n [1,1,7,2,9,6,5,4,8,7,8,5,0,3,8,1,5],\\n [8,9,7,8,1,1,3,0,1,2,9,4,0,1,5,3,1],\\n [9,2,7,4,8,7,3,9,2,4,2,2,7,8,2,6,7],\\n [3,8,1,6,0,4,8,9,8,0,2,5,3,5,5,7,5],\\n [1,8,2,5,7,7,1,9,9,8,9,2,4,9,5,4,0],\\n [3,4,4,1,5,3,3,8,8,6,3,5,3,8,7,1,3]]\\n\\nckeckers solution is 82, but mine is is 79 with the following path:\\n\\n[05] 04  02  09  06  00  03  05  01  04  09  08  04  09  07  05  01 \\n\\n[03][04] 09  02  09  09  00  09  07  09  04  07  08  04  04  05  08 \\n\\n 06 [01] 08  09  08  00  03  07  00  09  08  07  04  09  02  00  01 \\n\\n 04 [00][00] 05  01  07  04  07  06  04  01  00  01  00  06  02  08 \\n\\n 07  02 [00][02] 09  03  04  07  00  08  09  05  09  00  01  01  00 \\n\\n 08  02  09 [04] 09  07  09  03  07  00  03  06  05  03  05  09  06 \\n\\n 08  09  09 [02] 06  01  02  05  08  03  07  00  04  09  08  08  08 \\n\\n 05  08  05 [04][01] 05  06  06  03  03  01  08  03  09  06  04  08 \\n\\n 00  02  02  03 [00] 02  06  07  02  03  07  03  01  05  08  01  03 \\n\\n 04  04 [00][02][00] 03  08  04  01  03  03  00  07  04  02  09  08 \\n\\n 05  09 [00] 04  07  05  07  06  00  08  03  00  00  06  06  06  08 \\n\\n 00  07 [01] 08  03  05  01  08  07  00  02  09  02  02  07  01  05 \\n\\n 01  00 [00][00][06][02][00][00][02][02][08][00] 09  07  00  08  00 \\n\\n 01  01  07  02  09  06  05  04  08  07  08 [05][00] 03  08  01  05 \\n\\n 08  09  07  08  01  01  03  00  01  02  09  04 [00][01][05][03][01]\\n\\n 09  02  07  04  08  07  03  09  02  04  02  02  07  08  02  06 [07]\\n\\n 03  08  01  06  00  04  08  09  08  00  02  05  03  05  05  07 [05]\\n\\n 01  08  02  05  07  07  01  09  09  08  09  02  04  09  05  04 [00]\\n\\n 03  04  04  01  05  03  03  08  08  06  03  05  03  08  07  01 [03]\\n\\nDoes anyone have a suggestion what I am doing wrong?"
                    },
                    {
                        "username": "LucidLynxxx",
                        "content": "I believe it is illlegal to move back, which you do? \"Note: You can only move either down or right at any point in time.\""
                    },
                    {
                        "username": "red_akb",
                        "content": "See 10th line, you\\'re moving left\\n\\nBut it is clearly mentioned in que that ->\\n\\n\"Note: You can only move either down or right at any point in time.\"\\n\\nSo if you\\'re doing by recursion, only use two operations as move_right, or move_down."
                    },
                    {
                        "username": "Shaa-Khan",
                        "content": "you can move only down and right"
                    },
                    {
                        "username": "Aman_gupta-9833",
                        "content": "hats off for these much long query buddy"
                    },
                    {
                        "username": "conrad001",
                        "content": "The problem statement says you are only allowed to move right or down but in your solution the path moves left at some point too. That is the problem with your solution."
                    },
                    {
                        "username": "Heyns95",
                        "content": "I also get 79. How do we notify leetcode?"
                    },
                    {
                        "username": "adriankuehn",
                        "content": "Yip, same here for me for testcase 56/61. I solved it by only allowing the BFS to go down and right as mentioned in the task. Then I get 82 instead of 79. But the path for 79 looks correct for me as well. "
                    },
                    {
                        "username": "jamesh",
                        "content": "Such as:\\n\\n    1, 9, 1, 1, 1\\n    1, 1, 1, 9, 1\\n\\nAll the 1's form the minimum path."
                    },
                    {
                        "username": "Earth-Turtle",
                        "content": "There\\'s a clarification in the description that you can only move down or right"
                    },
                    {
                        "username": "psionl0",
                        "content": "After yesterday\\'s problem, it is nice to be able to just code an answer and have it pass all test cases right off the bat without even any syntax errors."
                    },
                    {
                        "username": "tensionstate",
                        "content": "I understand that in some shortest path algorithms on general node weighted graphs, negative cycles lead to non-termination, but here I do not see any problem, so why does the question state that the weights are not negative?"
                    },
                    {
                        "username": "AdityaBhate",
                        "content": "# \\uD83D\\uDCCC C++ || Recursion , DP - Memoization, Tabulation + Space Optimization\\nhttps://leetcode.com/problems/minimum-path-sum/solutions/3117215/c-recursion-dp-memoization-tabulation-space-optimization/?orderBy=hot"
                    },
                    {
                        "username": "ShadyCoder",
                        "content": "What if the follow-up question is how do you store the path information that gives the minimum pathsum? Any ideas about how we can achieve that in a better design perspective?"
                    },
                    {
                        "username": "mayank_pant",
                        "content": "backtracking using the created dp array. "
                    },
                    {
                        "username": "neel19",
                        "content": "Go in reverse order like we do LCS i.e, from $dp[row-1][col-1]$ keep going till cell $dp[0][0]$. "
                    },
                    {
                        "username": "alpharomeo99",
                        "content": "Apart from the solutions mentioned one can just start from the source after creating the dp array. From source move greedily towards the the cell that has the minimum path sum to the destination and accordingly update the path. This will take O(N) time."
                    },
                    {
                        "username": "keshav97",
                        "content": "use recursion we have 2 choices either go right or go down"
                    },
                    {
                        "username": "kushalnagwanshicloud",
                        "content": "I did this -> \\nhttps://leetcode.com/problems/minimum-path-sum/solutions/2819398/how-to-print-the-path-if-asked/"
                    },
                    {
                        "username": "f20200445",
                        "content": "Can someone explain why this is giving me TLE only on the last testcase? I could do tabulation but memoization is giving TLE.\\n\\n    int f(int i,int j,int m,int n,vector<vector<int>> grid,vector<vector<int>> &dp) {\\n        if(i==m-1 && j==n-1) {\\n            return grid[i][j];\\n        }\\n\\n        if(dp[i][j]!=-1) {\\n            return dp[i][j];\\n        }\\n\\n        if(i==m-1) {\\n            return dp[i][j]=grid[i][j]+f(i,j+1,m,n,grid,dp);\\n        }\\n        else if(j==n-1) {\\n            return dp[i][j]=grid[i][j]+f(i+1,j,m,n,grid,dp);\\n        }\\n\\n        return dp[i][j]=grid[i][j] + min(f(i,j+1,m,n,grid,dp),f(i+1,j,m,n,grid,dp));\\n    }\\n    int minPathSum(vector<vector<int>>& grid) {\\n        int m = grid.size();\\n        int n = grid[0].size();\\n        vector<vector<int>> dp(m,vector<int>(n,-1));\\n        return f(0,0,m,n,grid,dp);\\n    }"
                    },
                    {
                        "username": "oops_moment",
                        "content": "Hey even i did the same way, it will pass . Just pass through reference since otherwise multiple copies are created hence increasing time complexity of code. \\nHope it clears the doubt"
                    },
                    {
                        "username": "ee20b053",
                        "content": "in function \\'f\\' pass the matrix grid by reference to further reduce time complexity\\n"
                    },
                    {
                        "username": "viku_kr",
                        "content": "Instead of doing recursively, this question can be done iteratively. Leave the first row and first column, then for all other positions best way to move there is from minimum of (i-1,j) or (i, j-1)"
                    }
                ]
            },
            {
                "id": 1844809,
                "content": [
                    {
                        "username": "_srahul_",
                        "content": "Friendship ended with graph, now DP is my best friend."
                    },
                    {
                        "username": "user4401w",
                        "content": "XD\\n"
                    },
                    {
                        "username": "codeMonarch",
                        "content": "agree++;\\n"
                    },
                    {
                        "username": "daring-calf",
                        "content": "When I first met this problem 8 months ago it was so hard and frustrating, I spent a whole night and didn\\'t quite get it even after watching the solutions. And today it only took 5 minutes to write.\\nTo all the noobcoders out there: it always hurts the first time; but hang in there, eventually you\\'ll enjoy it."
                    },
                    {
                        "username": "bhuppidhamii",
                        "content": "right bro."
                    },
                    {
                        "username": "kartikey_wariyal",
                        "content": "i too cant solve right now\\n"
                    },
                    {
                        "username": "diabloexodia",
                        "content": "I believe in the heart of the algorithms"
                    },
                    {
                        "username": "sk03167",
                        "content": "I love the discussion section. It's nice to see people in the same journey as you. I have never solved this question before but I know earlier I would written a whole ass recursive function, then optimized with memo. Now, it was intuitive that it's a 2d dp problem and how to write it. Took all but 11 lines of code to beat 90% both time and space."
                    },
                    {
                        "username": "Crispy_coffee",
                        "content": "Still TLE bmro"
                    },
                    {
                        "username": "cOde_Ranvir25",
                        "content": "# Here is an Approach :-)\\n**The problem statement is to find the minimum path sum from the top-left corner to the bottom-right corner of a grid, where each cell in the grid has a non-negative integer value. The path can only move down or right at each step.**\\n\\n- We can use dynamic programming to solve this problem efficiently. We will create a 2D array dp of the same size as the input grid, where each cell dp[i][j] represents the minimum path sum from the top-left corner to cell (i, j).\\n\\n- We can initialize the dp array as follows:\\n\\n1. dp[0][0] = grid[0][0] since the minimum path sum to the top-left corner is the value of the top-left cell.\\n2. For the first row i=0 and first column j=0 < j < n, the minimum path sum can only be reached by moving right or down from the previous cell. So, we can compute dp[0][j] = dp[0][j-1] + grid[0][j] and dp[i][0] = dp[i-1][0] + grid[i][0] respectively.\\n3. For the rest of the cells, we can compute the minimum path sum as follows:\\ndp[i][j] = grid[i][j] + min(dp[i-1][j], dp[i][j-1]) since we can reach the current cell from the cell above or the cell to the left, and we want to take the path with the minimum sum.\\n- Once we have filled the dp array, the minimum path sum to the bottom-right corner will be dp[m-1][n-1], where m is the number of rows and n is the number of columns of the input grid.\\n\\n**The time complexity of this approach is O(mn) since we visit each cell once. The space complexity is also O(mn) since we use the dp array to store the intermediate results.**"
                    },
                    {
                        "username": "user5400vw",
                        "content": "good explanation.  the original grid can also act as your dp table."
                    },
                    {
                        "username": "cOde_Ranvir25",
                        "content": "***Here is the code link for reference:-)***\\nhttps://leetcode.com/problems/minimum-path-sum/solutions/2887704/easiest-solution/"
                    },
                    {
                        "username": "zaim",
                        "content": "On input \\n[[5,4,2,9,6,0,3,5,1,4,9,8,4,9,7,5,1],\\n [3,4,9,2,9,9,0,9,7,9,4,7,8,4,4,5,8],\\n [6,1,8,9,8,0,3,7,0,9,8,7,4,9,2,0,1],\\n [4,0,0,5,1,7,4,7,6,4,1,0,1,0,6,2,8],\\n [7,2,0,2,9,3,4,7,0,8,9,5,9,0,1,1,0],\\n [8,2,9,4,9,7,9,3,7,0,3,6,5,3,5,9,6],\\n [8,9,9,2,6,1,2,5,8,3,7,0,4,9,8,8,8],\\n [5,8,5,4,1,5,6,6,3,3,1,8,3,9,6,4,8],\\n [0,2,2,3,0,2,6,7,2,3,7,3,1,5,8,1,3],\\n [4,4,0,2,0,3,8,4,1,3,3,0,7,4,2,9,8],\\n [5,9,0,4,7,5,7,6,0,8,3,0,0,6,6,6,8],\\n [0,7,1,8,3,5,1,8,7,0,2,9,2,2,7,1,5],\\n [1,0,0,0,6,2,0,0,2,2,8,0,9,7,0,8,0],\\n [1,1,7,2,9,6,5,4,8,7,8,5,0,3,8,1,5],\\n [8,9,7,8,1,1,3,0,1,2,9,4,0,1,5,3,1],\\n [9,2,7,4,8,7,3,9,2,4,2,2,7,8,2,6,7],\\n [3,8,1,6,0,4,8,9,8,0,2,5,3,5,5,7,5],\\n [1,8,2,5,7,7,1,9,9,8,9,2,4,9,5,4,0],\\n [3,4,4,1,5,3,3,8,8,6,3,5,3,8,7,1,3]]\\n\\nckeckers solution is 82, but mine is is 79 with the following path:\\n\\n[05] 04  02  09  06  00  03  05  01  04  09  08  04  09  07  05  01 \\n\\n[03][04] 09  02  09  09  00  09  07  09  04  07  08  04  04  05  08 \\n\\n 06 [01] 08  09  08  00  03  07  00  09  08  07  04  09  02  00  01 \\n\\n 04 [00][00] 05  01  07  04  07  06  04  01  00  01  00  06  02  08 \\n\\n 07  02 [00][02] 09  03  04  07  00  08  09  05  09  00  01  01  00 \\n\\n 08  02  09 [04] 09  07  09  03  07  00  03  06  05  03  05  09  06 \\n\\n 08  09  09 [02] 06  01  02  05  08  03  07  00  04  09  08  08  08 \\n\\n 05  08  05 [04][01] 05  06  06  03  03  01  08  03  09  06  04  08 \\n\\n 00  02  02  03 [00] 02  06  07  02  03  07  03  01  05  08  01  03 \\n\\n 04  04 [00][02][00] 03  08  04  01  03  03  00  07  04  02  09  08 \\n\\n 05  09 [00] 04  07  05  07  06  00  08  03  00  00  06  06  06  08 \\n\\n 00  07 [01] 08  03  05  01  08  07  00  02  09  02  02  07  01  05 \\n\\n 01  00 [00][00][06][02][00][00][02][02][08][00] 09  07  00  08  00 \\n\\n 01  01  07  02  09  06  05  04  08  07  08 [05][00] 03  08  01  05 \\n\\n 08  09  07  08  01  01  03  00  01  02  09  04 [00][01][05][03][01]\\n\\n 09  02  07  04  08  07  03  09  02  04  02  02  07  08  02  06 [07]\\n\\n 03  08  01  06  00  04  08  09  08  00  02  05  03  05  05  07 [05]\\n\\n 01  08  02  05  07  07  01  09  09  08  09  02  04  09  05  04 [00]\\n\\n 03  04  04  01  05  03  03  08  08  06  03  05  03  08  07  01 [03]\\n\\nDoes anyone have a suggestion what I am doing wrong?"
                    },
                    {
                        "username": "LucidLynxxx",
                        "content": "I believe it is illlegal to move back, which you do? \"Note: You can only move either down or right at any point in time.\""
                    },
                    {
                        "username": "red_akb",
                        "content": "See 10th line, you\\'re moving left\\n\\nBut it is clearly mentioned in que that ->\\n\\n\"Note: You can only move either down or right at any point in time.\"\\n\\nSo if you\\'re doing by recursion, only use two operations as move_right, or move_down."
                    },
                    {
                        "username": "Shaa-Khan",
                        "content": "you can move only down and right"
                    },
                    {
                        "username": "Aman_gupta-9833",
                        "content": "hats off for these much long query buddy"
                    },
                    {
                        "username": "conrad001",
                        "content": "The problem statement says you are only allowed to move right or down but in your solution the path moves left at some point too. That is the problem with your solution."
                    },
                    {
                        "username": "Heyns95",
                        "content": "I also get 79. How do we notify leetcode?"
                    },
                    {
                        "username": "adriankuehn",
                        "content": "Yip, same here for me for testcase 56/61. I solved it by only allowing the BFS to go down and right as mentioned in the task. Then I get 82 instead of 79. But the path for 79 looks correct for me as well. "
                    },
                    {
                        "username": "jamesh",
                        "content": "Such as:\\n\\n    1, 9, 1, 1, 1\\n    1, 1, 1, 9, 1\\n\\nAll the 1's form the minimum path."
                    },
                    {
                        "username": "Earth-Turtle",
                        "content": "There\\'s a clarification in the description that you can only move down or right"
                    },
                    {
                        "username": "psionl0",
                        "content": "After yesterday\\'s problem, it is nice to be able to just code an answer and have it pass all test cases right off the bat without even any syntax errors."
                    },
                    {
                        "username": "tensionstate",
                        "content": "I understand that in some shortest path algorithms on general node weighted graphs, negative cycles lead to non-termination, but here I do not see any problem, so why does the question state that the weights are not negative?"
                    },
                    {
                        "username": "AdityaBhate",
                        "content": "# \\uD83D\\uDCCC C++ || Recursion , DP - Memoization, Tabulation + Space Optimization\\nhttps://leetcode.com/problems/minimum-path-sum/solutions/3117215/c-recursion-dp-memoization-tabulation-space-optimization/?orderBy=hot"
                    },
                    {
                        "username": "ShadyCoder",
                        "content": "What if the follow-up question is how do you store the path information that gives the minimum pathsum? Any ideas about how we can achieve that in a better design perspective?"
                    },
                    {
                        "username": "mayank_pant",
                        "content": "backtracking using the created dp array. "
                    },
                    {
                        "username": "neel19",
                        "content": "Go in reverse order like we do LCS i.e, from $dp[row-1][col-1]$ keep going till cell $dp[0][0]$. "
                    },
                    {
                        "username": "alpharomeo99",
                        "content": "Apart from the solutions mentioned one can just start from the source after creating the dp array. From source move greedily towards the the cell that has the minimum path sum to the destination and accordingly update the path. This will take O(N) time."
                    },
                    {
                        "username": "keshav97",
                        "content": "use recursion we have 2 choices either go right or go down"
                    },
                    {
                        "username": "kushalnagwanshicloud",
                        "content": "I did this -> \\nhttps://leetcode.com/problems/minimum-path-sum/solutions/2819398/how-to-print-the-path-if-asked/"
                    },
                    {
                        "username": "f20200445",
                        "content": "Can someone explain why this is giving me TLE only on the last testcase? I could do tabulation but memoization is giving TLE.\\n\\n    int f(int i,int j,int m,int n,vector<vector<int>> grid,vector<vector<int>> &dp) {\\n        if(i==m-1 && j==n-1) {\\n            return grid[i][j];\\n        }\\n\\n        if(dp[i][j]!=-1) {\\n            return dp[i][j];\\n        }\\n\\n        if(i==m-1) {\\n            return dp[i][j]=grid[i][j]+f(i,j+1,m,n,grid,dp);\\n        }\\n        else if(j==n-1) {\\n            return dp[i][j]=grid[i][j]+f(i+1,j,m,n,grid,dp);\\n        }\\n\\n        return dp[i][j]=grid[i][j] + min(f(i,j+1,m,n,grid,dp),f(i+1,j,m,n,grid,dp));\\n    }\\n    int minPathSum(vector<vector<int>>& grid) {\\n        int m = grid.size();\\n        int n = grid[0].size();\\n        vector<vector<int>> dp(m,vector<int>(n,-1));\\n        return f(0,0,m,n,grid,dp);\\n    }"
                    },
                    {
                        "username": "oops_moment",
                        "content": "Hey even i did the same way, it will pass . Just pass through reference since otherwise multiple copies are created hence increasing time complexity of code. \\nHope it clears the doubt"
                    },
                    {
                        "username": "ee20b053",
                        "content": "in function \\'f\\' pass the matrix grid by reference to further reduce time complexity\\n"
                    },
                    {
                        "username": "viku_kr",
                        "content": "Instead of doing recursively, this question can be done iteratively. Leave the first row and first column, then for all other positions best way to move there is from minimum of (i-1,j) or (i, j-1)"
                    }
                ]
            },
            {
                "id": 1567830,
                "content": [
                    {
                        "username": "_srahul_",
                        "content": "Friendship ended with graph, now DP is my best friend."
                    },
                    {
                        "username": "user4401w",
                        "content": "XD\\n"
                    },
                    {
                        "username": "codeMonarch",
                        "content": "agree++;\\n"
                    },
                    {
                        "username": "daring-calf",
                        "content": "When I first met this problem 8 months ago it was so hard and frustrating, I spent a whole night and didn\\'t quite get it even after watching the solutions. And today it only took 5 minutes to write.\\nTo all the noobcoders out there: it always hurts the first time; but hang in there, eventually you\\'ll enjoy it."
                    },
                    {
                        "username": "bhuppidhamii",
                        "content": "right bro."
                    },
                    {
                        "username": "kartikey_wariyal",
                        "content": "i too cant solve right now\\n"
                    },
                    {
                        "username": "diabloexodia",
                        "content": "I believe in the heart of the algorithms"
                    },
                    {
                        "username": "sk03167",
                        "content": "I love the discussion section. It's nice to see people in the same journey as you. I have never solved this question before but I know earlier I would written a whole ass recursive function, then optimized with memo. Now, it was intuitive that it's a 2d dp problem and how to write it. Took all but 11 lines of code to beat 90% both time and space."
                    },
                    {
                        "username": "Crispy_coffee",
                        "content": "Still TLE bmro"
                    },
                    {
                        "username": "cOde_Ranvir25",
                        "content": "# Here is an Approach :-)\\n**The problem statement is to find the minimum path sum from the top-left corner to the bottom-right corner of a grid, where each cell in the grid has a non-negative integer value. The path can only move down or right at each step.**\\n\\n- We can use dynamic programming to solve this problem efficiently. We will create a 2D array dp of the same size as the input grid, where each cell dp[i][j] represents the minimum path sum from the top-left corner to cell (i, j).\\n\\n- We can initialize the dp array as follows:\\n\\n1. dp[0][0] = grid[0][0] since the minimum path sum to the top-left corner is the value of the top-left cell.\\n2. For the first row i=0 and first column j=0 < j < n, the minimum path sum can only be reached by moving right or down from the previous cell. So, we can compute dp[0][j] = dp[0][j-1] + grid[0][j] and dp[i][0] = dp[i-1][0] + grid[i][0] respectively.\\n3. For the rest of the cells, we can compute the minimum path sum as follows:\\ndp[i][j] = grid[i][j] + min(dp[i-1][j], dp[i][j-1]) since we can reach the current cell from the cell above or the cell to the left, and we want to take the path with the minimum sum.\\n- Once we have filled the dp array, the minimum path sum to the bottom-right corner will be dp[m-1][n-1], where m is the number of rows and n is the number of columns of the input grid.\\n\\n**The time complexity of this approach is O(mn) since we visit each cell once. The space complexity is also O(mn) since we use the dp array to store the intermediate results.**"
                    },
                    {
                        "username": "user5400vw",
                        "content": "good explanation.  the original grid can also act as your dp table."
                    },
                    {
                        "username": "cOde_Ranvir25",
                        "content": "***Here is the code link for reference:-)***\\nhttps://leetcode.com/problems/minimum-path-sum/solutions/2887704/easiest-solution/"
                    },
                    {
                        "username": "zaim",
                        "content": "On input \\n[[5,4,2,9,6,0,3,5,1,4,9,8,4,9,7,5,1],\\n [3,4,9,2,9,9,0,9,7,9,4,7,8,4,4,5,8],\\n [6,1,8,9,8,0,3,7,0,9,8,7,4,9,2,0,1],\\n [4,0,0,5,1,7,4,7,6,4,1,0,1,0,6,2,8],\\n [7,2,0,2,9,3,4,7,0,8,9,5,9,0,1,1,0],\\n [8,2,9,4,9,7,9,3,7,0,3,6,5,3,5,9,6],\\n [8,9,9,2,6,1,2,5,8,3,7,0,4,9,8,8,8],\\n [5,8,5,4,1,5,6,6,3,3,1,8,3,9,6,4,8],\\n [0,2,2,3,0,2,6,7,2,3,7,3,1,5,8,1,3],\\n [4,4,0,2,0,3,8,4,1,3,3,0,7,4,2,9,8],\\n [5,9,0,4,7,5,7,6,0,8,3,0,0,6,6,6,8],\\n [0,7,1,8,3,5,1,8,7,0,2,9,2,2,7,1,5],\\n [1,0,0,0,6,2,0,0,2,2,8,0,9,7,0,8,0],\\n [1,1,7,2,9,6,5,4,8,7,8,5,0,3,8,1,5],\\n [8,9,7,8,1,1,3,0,1,2,9,4,0,1,5,3,1],\\n [9,2,7,4,8,7,3,9,2,4,2,2,7,8,2,6,7],\\n [3,8,1,6,0,4,8,9,8,0,2,5,3,5,5,7,5],\\n [1,8,2,5,7,7,1,9,9,8,9,2,4,9,5,4,0],\\n [3,4,4,1,5,3,3,8,8,6,3,5,3,8,7,1,3]]\\n\\nckeckers solution is 82, but mine is is 79 with the following path:\\n\\n[05] 04  02  09  06  00  03  05  01  04  09  08  04  09  07  05  01 \\n\\n[03][04] 09  02  09  09  00  09  07  09  04  07  08  04  04  05  08 \\n\\n 06 [01] 08  09  08  00  03  07  00  09  08  07  04  09  02  00  01 \\n\\n 04 [00][00] 05  01  07  04  07  06  04  01  00  01  00  06  02  08 \\n\\n 07  02 [00][02] 09  03  04  07  00  08  09  05  09  00  01  01  00 \\n\\n 08  02  09 [04] 09  07  09  03  07  00  03  06  05  03  05  09  06 \\n\\n 08  09  09 [02] 06  01  02  05  08  03  07  00  04  09  08  08  08 \\n\\n 05  08  05 [04][01] 05  06  06  03  03  01  08  03  09  06  04  08 \\n\\n 00  02  02  03 [00] 02  06  07  02  03  07  03  01  05  08  01  03 \\n\\n 04  04 [00][02][00] 03  08  04  01  03  03  00  07  04  02  09  08 \\n\\n 05  09 [00] 04  07  05  07  06  00  08  03  00  00  06  06  06  08 \\n\\n 00  07 [01] 08  03  05  01  08  07  00  02  09  02  02  07  01  05 \\n\\n 01  00 [00][00][06][02][00][00][02][02][08][00] 09  07  00  08  00 \\n\\n 01  01  07  02  09  06  05  04  08  07  08 [05][00] 03  08  01  05 \\n\\n 08  09  07  08  01  01  03  00  01  02  09  04 [00][01][05][03][01]\\n\\n 09  02  07  04  08  07  03  09  02  04  02  02  07  08  02  06 [07]\\n\\n 03  08  01  06  00  04  08  09  08  00  02  05  03  05  05  07 [05]\\n\\n 01  08  02  05  07  07  01  09  09  08  09  02  04  09  05  04 [00]\\n\\n 03  04  04  01  05  03  03  08  08  06  03  05  03  08  07  01 [03]\\n\\nDoes anyone have a suggestion what I am doing wrong?"
                    },
                    {
                        "username": "LucidLynxxx",
                        "content": "I believe it is illlegal to move back, which you do? \"Note: You can only move either down or right at any point in time.\""
                    },
                    {
                        "username": "red_akb",
                        "content": "See 10th line, you\\'re moving left\\n\\nBut it is clearly mentioned in que that ->\\n\\n\"Note: You can only move either down or right at any point in time.\"\\n\\nSo if you\\'re doing by recursion, only use two operations as move_right, or move_down."
                    },
                    {
                        "username": "Shaa-Khan",
                        "content": "you can move only down and right"
                    },
                    {
                        "username": "Aman_gupta-9833",
                        "content": "hats off for these much long query buddy"
                    },
                    {
                        "username": "conrad001",
                        "content": "The problem statement says you are only allowed to move right or down but in your solution the path moves left at some point too. That is the problem with your solution."
                    },
                    {
                        "username": "Heyns95",
                        "content": "I also get 79. How do we notify leetcode?"
                    },
                    {
                        "username": "adriankuehn",
                        "content": "Yip, same here for me for testcase 56/61. I solved it by only allowing the BFS to go down and right as mentioned in the task. Then I get 82 instead of 79. But the path for 79 looks correct for me as well. "
                    },
                    {
                        "username": "jamesh",
                        "content": "Such as:\\n\\n    1, 9, 1, 1, 1\\n    1, 1, 1, 9, 1\\n\\nAll the 1's form the minimum path."
                    },
                    {
                        "username": "Earth-Turtle",
                        "content": "There\\'s a clarification in the description that you can only move down or right"
                    },
                    {
                        "username": "psionl0",
                        "content": "After yesterday\\'s problem, it is nice to be able to just code an answer and have it pass all test cases right off the bat without even any syntax errors."
                    },
                    {
                        "username": "tensionstate",
                        "content": "I understand that in some shortest path algorithms on general node weighted graphs, negative cycles lead to non-termination, but here I do not see any problem, so why does the question state that the weights are not negative?"
                    },
                    {
                        "username": "AdityaBhate",
                        "content": "# \\uD83D\\uDCCC C++ || Recursion , DP - Memoization, Tabulation + Space Optimization\\nhttps://leetcode.com/problems/minimum-path-sum/solutions/3117215/c-recursion-dp-memoization-tabulation-space-optimization/?orderBy=hot"
                    },
                    {
                        "username": "ShadyCoder",
                        "content": "What if the follow-up question is how do you store the path information that gives the minimum pathsum? Any ideas about how we can achieve that in a better design perspective?"
                    },
                    {
                        "username": "mayank_pant",
                        "content": "backtracking using the created dp array. "
                    },
                    {
                        "username": "neel19",
                        "content": "Go in reverse order like we do LCS i.e, from $dp[row-1][col-1]$ keep going till cell $dp[0][0]$. "
                    },
                    {
                        "username": "alpharomeo99",
                        "content": "Apart from the solutions mentioned one can just start from the source after creating the dp array. From source move greedily towards the the cell that has the minimum path sum to the destination and accordingly update the path. This will take O(N) time."
                    },
                    {
                        "username": "keshav97",
                        "content": "use recursion we have 2 choices either go right or go down"
                    },
                    {
                        "username": "kushalnagwanshicloud",
                        "content": "I did this -> \\nhttps://leetcode.com/problems/minimum-path-sum/solutions/2819398/how-to-print-the-path-if-asked/"
                    },
                    {
                        "username": "f20200445",
                        "content": "Can someone explain why this is giving me TLE only on the last testcase? I could do tabulation but memoization is giving TLE.\\n\\n    int f(int i,int j,int m,int n,vector<vector<int>> grid,vector<vector<int>> &dp) {\\n        if(i==m-1 && j==n-1) {\\n            return grid[i][j];\\n        }\\n\\n        if(dp[i][j]!=-1) {\\n            return dp[i][j];\\n        }\\n\\n        if(i==m-1) {\\n            return dp[i][j]=grid[i][j]+f(i,j+1,m,n,grid,dp);\\n        }\\n        else if(j==n-1) {\\n            return dp[i][j]=grid[i][j]+f(i+1,j,m,n,grid,dp);\\n        }\\n\\n        return dp[i][j]=grid[i][j] + min(f(i,j+1,m,n,grid,dp),f(i+1,j,m,n,grid,dp));\\n    }\\n    int minPathSum(vector<vector<int>>& grid) {\\n        int m = grid.size();\\n        int n = grid[0].size();\\n        vector<vector<int>> dp(m,vector<int>(n,-1));\\n        return f(0,0,m,n,grid,dp);\\n    }"
                    },
                    {
                        "username": "oops_moment",
                        "content": "Hey even i did the same way, it will pass . Just pass through reference since otherwise multiple copies are created hence increasing time complexity of code. \\nHope it clears the doubt"
                    },
                    {
                        "username": "ee20b053",
                        "content": "in function \\'f\\' pass the matrix grid by reference to further reduce time complexity\\n"
                    },
                    {
                        "username": "viku_kr",
                        "content": "Instead of doing recursively, this question can be done iteratively. Leave the first row and first column, then for all other positions best way to move there is from minimum of (i-1,j) or (i, j-1)"
                    }
                ]
            },
            {
                "id": 1780572,
                "content": [
                    {
                        "username": "_srahul_",
                        "content": "Friendship ended with graph, now DP is my best friend."
                    },
                    {
                        "username": "user4401w",
                        "content": "XD\\n"
                    },
                    {
                        "username": "codeMonarch",
                        "content": "agree++;\\n"
                    },
                    {
                        "username": "daring-calf",
                        "content": "When I first met this problem 8 months ago it was so hard and frustrating, I spent a whole night and didn\\'t quite get it even after watching the solutions. And today it only took 5 minutes to write.\\nTo all the noobcoders out there: it always hurts the first time; but hang in there, eventually you\\'ll enjoy it."
                    },
                    {
                        "username": "bhuppidhamii",
                        "content": "right bro."
                    },
                    {
                        "username": "kartikey_wariyal",
                        "content": "i too cant solve right now\\n"
                    },
                    {
                        "username": "diabloexodia",
                        "content": "I believe in the heart of the algorithms"
                    },
                    {
                        "username": "sk03167",
                        "content": "I love the discussion section. It's nice to see people in the same journey as you. I have never solved this question before but I know earlier I would written a whole ass recursive function, then optimized with memo. Now, it was intuitive that it's a 2d dp problem and how to write it. Took all but 11 lines of code to beat 90% both time and space."
                    },
                    {
                        "username": "Crispy_coffee",
                        "content": "Still TLE bmro"
                    },
                    {
                        "username": "cOde_Ranvir25",
                        "content": "# Here is an Approach :-)\\n**The problem statement is to find the minimum path sum from the top-left corner to the bottom-right corner of a grid, where each cell in the grid has a non-negative integer value. The path can only move down or right at each step.**\\n\\n- We can use dynamic programming to solve this problem efficiently. We will create a 2D array dp of the same size as the input grid, where each cell dp[i][j] represents the minimum path sum from the top-left corner to cell (i, j).\\n\\n- We can initialize the dp array as follows:\\n\\n1. dp[0][0] = grid[0][0] since the minimum path sum to the top-left corner is the value of the top-left cell.\\n2. For the first row i=0 and first column j=0 < j < n, the minimum path sum can only be reached by moving right or down from the previous cell. So, we can compute dp[0][j] = dp[0][j-1] + grid[0][j] and dp[i][0] = dp[i-1][0] + grid[i][0] respectively.\\n3. For the rest of the cells, we can compute the minimum path sum as follows:\\ndp[i][j] = grid[i][j] + min(dp[i-1][j], dp[i][j-1]) since we can reach the current cell from the cell above or the cell to the left, and we want to take the path with the minimum sum.\\n- Once we have filled the dp array, the minimum path sum to the bottom-right corner will be dp[m-1][n-1], where m is the number of rows and n is the number of columns of the input grid.\\n\\n**The time complexity of this approach is O(mn) since we visit each cell once. The space complexity is also O(mn) since we use the dp array to store the intermediate results.**"
                    },
                    {
                        "username": "user5400vw",
                        "content": "good explanation.  the original grid can also act as your dp table."
                    },
                    {
                        "username": "cOde_Ranvir25",
                        "content": "***Here is the code link for reference:-)***\\nhttps://leetcode.com/problems/minimum-path-sum/solutions/2887704/easiest-solution/"
                    },
                    {
                        "username": "zaim",
                        "content": "On input \\n[[5,4,2,9,6,0,3,5,1,4,9,8,4,9,7,5,1],\\n [3,4,9,2,9,9,0,9,7,9,4,7,8,4,4,5,8],\\n [6,1,8,9,8,0,3,7,0,9,8,7,4,9,2,0,1],\\n [4,0,0,5,1,7,4,7,6,4,1,0,1,0,6,2,8],\\n [7,2,0,2,9,3,4,7,0,8,9,5,9,0,1,1,0],\\n [8,2,9,4,9,7,9,3,7,0,3,6,5,3,5,9,6],\\n [8,9,9,2,6,1,2,5,8,3,7,0,4,9,8,8,8],\\n [5,8,5,4,1,5,6,6,3,3,1,8,3,9,6,4,8],\\n [0,2,2,3,0,2,6,7,2,3,7,3,1,5,8,1,3],\\n [4,4,0,2,0,3,8,4,1,3,3,0,7,4,2,9,8],\\n [5,9,0,4,7,5,7,6,0,8,3,0,0,6,6,6,8],\\n [0,7,1,8,3,5,1,8,7,0,2,9,2,2,7,1,5],\\n [1,0,0,0,6,2,0,0,2,2,8,0,9,7,0,8,0],\\n [1,1,7,2,9,6,5,4,8,7,8,5,0,3,8,1,5],\\n [8,9,7,8,1,1,3,0,1,2,9,4,0,1,5,3,1],\\n [9,2,7,4,8,7,3,9,2,4,2,2,7,8,2,6,7],\\n [3,8,1,6,0,4,8,9,8,0,2,5,3,5,5,7,5],\\n [1,8,2,5,7,7,1,9,9,8,9,2,4,9,5,4,0],\\n [3,4,4,1,5,3,3,8,8,6,3,5,3,8,7,1,3]]\\n\\nckeckers solution is 82, but mine is is 79 with the following path:\\n\\n[05] 04  02  09  06  00  03  05  01  04  09  08  04  09  07  05  01 \\n\\n[03][04] 09  02  09  09  00  09  07  09  04  07  08  04  04  05  08 \\n\\n 06 [01] 08  09  08  00  03  07  00  09  08  07  04  09  02  00  01 \\n\\n 04 [00][00] 05  01  07  04  07  06  04  01  00  01  00  06  02  08 \\n\\n 07  02 [00][02] 09  03  04  07  00  08  09  05  09  00  01  01  00 \\n\\n 08  02  09 [04] 09  07  09  03  07  00  03  06  05  03  05  09  06 \\n\\n 08  09  09 [02] 06  01  02  05  08  03  07  00  04  09  08  08  08 \\n\\n 05  08  05 [04][01] 05  06  06  03  03  01  08  03  09  06  04  08 \\n\\n 00  02  02  03 [00] 02  06  07  02  03  07  03  01  05  08  01  03 \\n\\n 04  04 [00][02][00] 03  08  04  01  03  03  00  07  04  02  09  08 \\n\\n 05  09 [00] 04  07  05  07  06  00  08  03  00  00  06  06  06  08 \\n\\n 00  07 [01] 08  03  05  01  08  07  00  02  09  02  02  07  01  05 \\n\\n 01  00 [00][00][06][02][00][00][02][02][08][00] 09  07  00  08  00 \\n\\n 01  01  07  02  09  06  05  04  08  07  08 [05][00] 03  08  01  05 \\n\\n 08  09  07  08  01  01  03  00  01  02  09  04 [00][01][05][03][01]\\n\\n 09  02  07  04  08  07  03  09  02  04  02  02  07  08  02  06 [07]\\n\\n 03  08  01  06  00  04  08  09  08  00  02  05  03  05  05  07 [05]\\n\\n 01  08  02  05  07  07  01  09  09  08  09  02  04  09  05  04 [00]\\n\\n 03  04  04  01  05  03  03  08  08  06  03  05  03  08  07  01 [03]\\n\\nDoes anyone have a suggestion what I am doing wrong?"
                    },
                    {
                        "username": "LucidLynxxx",
                        "content": "I believe it is illlegal to move back, which you do? \"Note: You can only move either down or right at any point in time.\""
                    },
                    {
                        "username": "red_akb",
                        "content": "See 10th line, you\\'re moving left\\n\\nBut it is clearly mentioned in que that ->\\n\\n\"Note: You can only move either down or right at any point in time.\"\\n\\nSo if you\\'re doing by recursion, only use two operations as move_right, or move_down."
                    },
                    {
                        "username": "Shaa-Khan",
                        "content": "you can move only down and right"
                    },
                    {
                        "username": "Aman_gupta-9833",
                        "content": "hats off for these much long query buddy"
                    },
                    {
                        "username": "conrad001",
                        "content": "The problem statement says you are only allowed to move right or down but in your solution the path moves left at some point too. That is the problem with your solution."
                    },
                    {
                        "username": "Heyns95",
                        "content": "I also get 79. How do we notify leetcode?"
                    },
                    {
                        "username": "adriankuehn",
                        "content": "Yip, same here for me for testcase 56/61. I solved it by only allowing the BFS to go down and right as mentioned in the task. Then I get 82 instead of 79. But the path for 79 looks correct for me as well. "
                    },
                    {
                        "username": "jamesh",
                        "content": "Such as:\\n\\n    1, 9, 1, 1, 1\\n    1, 1, 1, 9, 1\\n\\nAll the 1's form the minimum path."
                    },
                    {
                        "username": "Earth-Turtle",
                        "content": "There\\'s a clarification in the description that you can only move down or right"
                    },
                    {
                        "username": "psionl0",
                        "content": "After yesterday\\'s problem, it is nice to be able to just code an answer and have it pass all test cases right off the bat without even any syntax errors."
                    },
                    {
                        "username": "tensionstate",
                        "content": "I understand that in some shortest path algorithms on general node weighted graphs, negative cycles lead to non-termination, but here I do not see any problem, so why does the question state that the weights are not negative?"
                    },
                    {
                        "username": "AdityaBhate",
                        "content": "# \\uD83D\\uDCCC C++ || Recursion , DP - Memoization, Tabulation + Space Optimization\\nhttps://leetcode.com/problems/minimum-path-sum/solutions/3117215/c-recursion-dp-memoization-tabulation-space-optimization/?orderBy=hot"
                    },
                    {
                        "username": "ShadyCoder",
                        "content": "What if the follow-up question is how do you store the path information that gives the minimum pathsum? Any ideas about how we can achieve that in a better design perspective?"
                    },
                    {
                        "username": "mayank_pant",
                        "content": "backtracking using the created dp array. "
                    },
                    {
                        "username": "neel19",
                        "content": "Go in reverse order like we do LCS i.e, from $dp[row-1][col-1]$ keep going till cell $dp[0][0]$. "
                    },
                    {
                        "username": "alpharomeo99",
                        "content": "Apart from the solutions mentioned one can just start from the source after creating the dp array. From source move greedily towards the the cell that has the minimum path sum to the destination and accordingly update the path. This will take O(N) time."
                    },
                    {
                        "username": "keshav97",
                        "content": "use recursion we have 2 choices either go right or go down"
                    },
                    {
                        "username": "kushalnagwanshicloud",
                        "content": "I did this -> \\nhttps://leetcode.com/problems/minimum-path-sum/solutions/2819398/how-to-print-the-path-if-asked/"
                    },
                    {
                        "username": "f20200445",
                        "content": "Can someone explain why this is giving me TLE only on the last testcase? I could do tabulation but memoization is giving TLE.\\n\\n    int f(int i,int j,int m,int n,vector<vector<int>> grid,vector<vector<int>> &dp) {\\n        if(i==m-1 && j==n-1) {\\n            return grid[i][j];\\n        }\\n\\n        if(dp[i][j]!=-1) {\\n            return dp[i][j];\\n        }\\n\\n        if(i==m-1) {\\n            return dp[i][j]=grid[i][j]+f(i,j+1,m,n,grid,dp);\\n        }\\n        else if(j==n-1) {\\n            return dp[i][j]=grid[i][j]+f(i+1,j,m,n,grid,dp);\\n        }\\n\\n        return dp[i][j]=grid[i][j] + min(f(i,j+1,m,n,grid,dp),f(i+1,j,m,n,grid,dp));\\n    }\\n    int minPathSum(vector<vector<int>>& grid) {\\n        int m = grid.size();\\n        int n = grid[0].size();\\n        vector<vector<int>> dp(m,vector<int>(n,-1));\\n        return f(0,0,m,n,grid,dp);\\n    }"
                    },
                    {
                        "username": "oops_moment",
                        "content": "Hey even i did the same way, it will pass . Just pass through reference since otherwise multiple copies are created hence increasing time complexity of code. \\nHope it clears the doubt"
                    },
                    {
                        "username": "ee20b053",
                        "content": "in function \\'f\\' pass the matrix grid by reference to further reduce time complexity\\n"
                    },
                    {
                        "username": "viku_kr",
                        "content": "Instead of doing recursively, this question can be done iteratively. Leave the first row and first column, then for all other positions best way to move there is from minimum of (i-1,j) or (i, j-1)"
                    }
                ]
            },
            {
                "id": 1569788,
                "content": [
                    {
                        "username": "_srahul_",
                        "content": "Friendship ended with graph, now DP is my best friend."
                    },
                    {
                        "username": "user4401w",
                        "content": "XD\\n"
                    },
                    {
                        "username": "codeMonarch",
                        "content": "agree++;\\n"
                    },
                    {
                        "username": "daring-calf",
                        "content": "When I first met this problem 8 months ago it was so hard and frustrating, I spent a whole night and didn\\'t quite get it even after watching the solutions. And today it only took 5 minutes to write.\\nTo all the noobcoders out there: it always hurts the first time; but hang in there, eventually you\\'ll enjoy it."
                    },
                    {
                        "username": "bhuppidhamii",
                        "content": "right bro."
                    },
                    {
                        "username": "kartikey_wariyal",
                        "content": "i too cant solve right now\\n"
                    },
                    {
                        "username": "diabloexodia",
                        "content": "I believe in the heart of the algorithms"
                    },
                    {
                        "username": "sk03167",
                        "content": "I love the discussion section. It's nice to see people in the same journey as you. I have never solved this question before but I know earlier I would written a whole ass recursive function, then optimized with memo. Now, it was intuitive that it's a 2d dp problem and how to write it. Took all but 11 lines of code to beat 90% both time and space."
                    },
                    {
                        "username": "Crispy_coffee",
                        "content": "Still TLE bmro"
                    },
                    {
                        "username": "cOde_Ranvir25",
                        "content": "# Here is an Approach :-)\\n**The problem statement is to find the minimum path sum from the top-left corner to the bottom-right corner of a grid, where each cell in the grid has a non-negative integer value. The path can only move down or right at each step.**\\n\\n- We can use dynamic programming to solve this problem efficiently. We will create a 2D array dp of the same size as the input grid, where each cell dp[i][j] represents the minimum path sum from the top-left corner to cell (i, j).\\n\\n- We can initialize the dp array as follows:\\n\\n1. dp[0][0] = grid[0][0] since the minimum path sum to the top-left corner is the value of the top-left cell.\\n2. For the first row i=0 and first column j=0 < j < n, the minimum path sum can only be reached by moving right or down from the previous cell. So, we can compute dp[0][j] = dp[0][j-1] + grid[0][j] and dp[i][0] = dp[i-1][0] + grid[i][0] respectively.\\n3. For the rest of the cells, we can compute the minimum path sum as follows:\\ndp[i][j] = grid[i][j] + min(dp[i-1][j], dp[i][j-1]) since we can reach the current cell from the cell above or the cell to the left, and we want to take the path with the minimum sum.\\n- Once we have filled the dp array, the minimum path sum to the bottom-right corner will be dp[m-1][n-1], where m is the number of rows and n is the number of columns of the input grid.\\n\\n**The time complexity of this approach is O(mn) since we visit each cell once. The space complexity is also O(mn) since we use the dp array to store the intermediate results.**"
                    },
                    {
                        "username": "user5400vw",
                        "content": "good explanation.  the original grid can also act as your dp table."
                    },
                    {
                        "username": "cOde_Ranvir25",
                        "content": "***Here is the code link for reference:-)***\\nhttps://leetcode.com/problems/minimum-path-sum/solutions/2887704/easiest-solution/"
                    },
                    {
                        "username": "zaim",
                        "content": "On input \\n[[5,4,2,9,6,0,3,5,1,4,9,8,4,9,7,5,1],\\n [3,4,9,2,9,9,0,9,7,9,4,7,8,4,4,5,8],\\n [6,1,8,9,8,0,3,7,0,9,8,7,4,9,2,0,1],\\n [4,0,0,5,1,7,4,7,6,4,1,0,1,0,6,2,8],\\n [7,2,0,2,9,3,4,7,0,8,9,5,9,0,1,1,0],\\n [8,2,9,4,9,7,9,3,7,0,3,6,5,3,5,9,6],\\n [8,9,9,2,6,1,2,5,8,3,7,0,4,9,8,8,8],\\n [5,8,5,4,1,5,6,6,3,3,1,8,3,9,6,4,8],\\n [0,2,2,3,0,2,6,7,2,3,7,3,1,5,8,1,3],\\n [4,4,0,2,0,3,8,4,1,3,3,0,7,4,2,9,8],\\n [5,9,0,4,7,5,7,6,0,8,3,0,0,6,6,6,8],\\n [0,7,1,8,3,5,1,8,7,0,2,9,2,2,7,1,5],\\n [1,0,0,0,6,2,0,0,2,2,8,0,9,7,0,8,0],\\n [1,1,7,2,9,6,5,4,8,7,8,5,0,3,8,1,5],\\n [8,9,7,8,1,1,3,0,1,2,9,4,0,1,5,3,1],\\n [9,2,7,4,8,7,3,9,2,4,2,2,7,8,2,6,7],\\n [3,8,1,6,0,4,8,9,8,0,2,5,3,5,5,7,5],\\n [1,8,2,5,7,7,1,9,9,8,9,2,4,9,5,4,0],\\n [3,4,4,1,5,3,3,8,8,6,3,5,3,8,7,1,3]]\\n\\nckeckers solution is 82, but mine is is 79 with the following path:\\n\\n[05] 04  02  09  06  00  03  05  01  04  09  08  04  09  07  05  01 \\n\\n[03][04] 09  02  09  09  00  09  07  09  04  07  08  04  04  05  08 \\n\\n 06 [01] 08  09  08  00  03  07  00  09  08  07  04  09  02  00  01 \\n\\n 04 [00][00] 05  01  07  04  07  06  04  01  00  01  00  06  02  08 \\n\\n 07  02 [00][02] 09  03  04  07  00  08  09  05  09  00  01  01  00 \\n\\n 08  02  09 [04] 09  07  09  03  07  00  03  06  05  03  05  09  06 \\n\\n 08  09  09 [02] 06  01  02  05  08  03  07  00  04  09  08  08  08 \\n\\n 05  08  05 [04][01] 05  06  06  03  03  01  08  03  09  06  04  08 \\n\\n 00  02  02  03 [00] 02  06  07  02  03  07  03  01  05  08  01  03 \\n\\n 04  04 [00][02][00] 03  08  04  01  03  03  00  07  04  02  09  08 \\n\\n 05  09 [00] 04  07  05  07  06  00  08  03  00  00  06  06  06  08 \\n\\n 00  07 [01] 08  03  05  01  08  07  00  02  09  02  02  07  01  05 \\n\\n 01  00 [00][00][06][02][00][00][02][02][08][00] 09  07  00  08  00 \\n\\n 01  01  07  02  09  06  05  04  08  07  08 [05][00] 03  08  01  05 \\n\\n 08  09  07  08  01  01  03  00  01  02  09  04 [00][01][05][03][01]\\n\\n 09  02  07  04  08  07  03  09  02  04  02  02  07  08  02  06 [07]\\n\\n 03  08  01  06  00  04  08  09  08  00  02  05  03  05  05  07 [05]\\n\\n 01  08  02  05  07  07  01  09  09  08  09  02  04  09  05  04 [00]\\n\\n 03  04  04  01  05  03  03  08  08  06  03  05  03  08  07  01 [03]\\n\\nDoes anyone have a suggestion what I am doing wrong?"
                    },
                    {
                        "username": "LucidLynxxx",
                        "content": "I believe it is illlegal to move back, which you do? \"Note: You can only move either down or right at any point in time.\""
                    },
                    {
                        "username": "red_akb",
                        "content": "See 10th line, you\\'re moving left\\n\\nBut it is clearly mentioned in que that ->\\n\\n\"Note: You can only move either down or right at any point in time.\"\\n\\nSo if you\\'re doing by recursion, only use two operations as move_right, or move_down."
                    },
                    {
                        "username": "Shaa-Khan",
                        "content": "you can move only down and right"
                    },
                    {
                        "username": "Aman_gupta-9833",
                        "content": "hats off for these much long query buddy"
                    },
                    {
                        "username": "conrad001",
                        "content": "The problem statement says you are only allowed to move right or down but in your solution the path moves left at some point too. That is the problem with your solution."
                    },
                    {
                        "username": "Heyns95",
                        "content": "I also get 79. How do we notify leetcode?"
                    },
                    {
                        "username": "adriankuehn",
                        "content": "Yip, same here for me for testcase 56/61. I solved it by only allowing the BFS to go down and right as mentioned in the task. Then I get 82 instead of 79. But the path for 79 looks correct for me as well. "
                    },
                    {
                        "username": "jamesh",
                        "content": "Such as:\\n\\n    1, 9, 1, 1, 1\\n    1, 1, 1, 9, 1\\n\\nAll the 1's form the minimum path."
                    },
                    {
                        "username": "Earth-Turtle",
                        "content": "There\\'s a clarification in the description that you can only move down or right"
                    },
                    {
                        "username": "psionl0",
                        "content": "After yesterday\\'s problem, it is nice to be able to just code an answer and have it pass all test cases right off the bat without even any syntax errors."
                    },
                    {
                        "username": "tensionstate",
                        "content": "I understand that in some shortest path algorithms on general node weighted graphs, negative cycles lead to non-termination, but here I do not see any problem, so why does the question state that the weights are not negative?"
                    },
                    {
                        "username": "AdityaBhate",
                        "content": "# \\uD83D\\uDCCC C++ || Recursion , DP - Memoization, Tabulation + Space Optimization\\nhttps://leetcode.com/problems/minimum-path-sum/solutions/3117215/c-recursion-dp-memoization-tabulation-space-optimization/?orderBy=hot"
                    },
                    {
                        "username": "ShadyCoder",
                        "content": "What if the follow-up question is how do you store the path information that gives the minimum pathsum? Any ideas about how we can achieve that in a better design perspective?"
                    },
                    {
                        "username": "mayank_pant",
                        "content": "backtracking using the created dp array. "
                    },
                    {
                        "username": "neel19",
                        "content": "Go in reverse order like we do LCS i.e, from $dp[row-1][col-1]$ keep going till cell $dp[0][0]$. "
                    },
                    {
                        "username": "alpharomeo99",
                        "content": "Apart from the solutions mentioned one can just start from the source after creating the dp array. From source move greedily towards the the cell that has the minimum path sum to the destination and accordingly update the path. This will take O(N) time."
                    },
                    {
                        "username": "keshav97",
                        "content": "use recursion we have 2 choices either go right or go down"
                    },
                    {
                        "username": "kushalnagwanshicloud",
                        "content": "I did this -> \\nhttps://leetcode.com/problems/minimum-path-sum/solutions/2819398/how-to-print-the-path-if-asked/"
                    },
                    {
                        "username": "f20200445",
                        "content": "Can someone explain why this is giving me TLE only on the last testcase? I could do tabulation but memoization is giving TLE.\\n\\n    int f(int i,int j,int m,int n,vector<vector<int>> grid,vector<vector<int>> &dp) {\\n        if(i==m-1 && j==n-1) {\\n            return grid[i][j];\\n        }\\n\\n        if(dp[i][j]!=-1) {\\n            return dp[i][j];\\n        }\\n\\n        if(i==m-1) {\\n            return dp[i][j]=grid[i][j]+f(i,j+1,m,n,grid,dp);\\n        }\\n        else if(j==n-1) {\\n            return dp[i][j]=grid[i][j]+f(i+1,j,m,n,grid,dp);\\n        }\\n\\n        return dp[i][j]=grid[i][j] + min(f(i,j+1,m,n,grid,dp),f(i+1,j,m,n,grid,dp));\\n    }\\n    int minPathSum(vector<vector<int>>& grid) {\\n        int m = grid.size();\\n        int n = grid[0].size();\\n        vector<vector<int>> dp(m,vector<int>(n,-1));\\n        return f(0,0,m,n,grid,dp);\\n    }"
                    },
                    {
                        "username": "oops_moment",
                        "content": "Hey even i did the same way, it will pass . Just pass through reference since otherwise multiple copies are created hence increasing time complexity of code. \\nHope it clears the doubt"
                    },
                    {
                        "username": "ee20b053",
                        "content": "in function \\'f\\' pass the matrix grid by reference to further reduce time complexity\\n"
                    },
                    {
                        "username": "viku_kr",
                        "content": "Instead of doing recursively, this question can be done iteratively. Leave the first row and first column, then for all other positions best way to move there is from minimum of (i-1,j) or (i, j-1)"
                    }
                ]
            },
            {
                "id": 1800731,
                "content": [
                    {
                        "username": "_srahul_",
                        "content": "Friendship ended with graph, now DP is my best friend."
                    },
                    {
                        "username": "user4401w",
                        "content": "XD\\n"
                    },
                    {
                        "username": "codeMonarch",
                        "content": "agree++;\\n"
                    },
                    {
                        "username": "daring-calf",
                        "content": "When I first met this problem 8 months ago it was so hard and frustrating, I spent a whole night and didn\\'t quite get it even after watching the solutions. And today it only took 5 minutes to write.\\nTo all the noobcoders out there: it always hurts the first time; but hang in there, eventually you\\'ll enjoy it."
                    },
                    {
                        "username": "bhuppidhamii",
                        "content": "right bro."
                    },
                    {
                        "username": "kartikey_wariyal",
                        "content": "i too cant solve right now\\n"
                    },
                    {
                        "username": "diabloexodia",
                        "content": "I believe in the heart of the algorithms"
                    },
                    {
                        "username": "sk03167",
                        "content": "I love the discussion section. It's nice to see people in the same journey as you. I have never solved this question before but I know earlier I would written a whole ass recursive function, then optimized with memo. Now, it was intuitive that it's a 2d dp problem and how to write it. Took all but 11 lines of code to beat 90% both time and space."
                    },
                    {
                        "username": "Crispy_coffee",
                        "content": "Still TLE bmro"
                    },
                    {
                        "username": "cOde_Ranvir25",
                        "content": "# Here is an Approach :-)\\n**The problem statement is to find the minimum path sum from the top-left corner to the bottom-right corner of a grid, where each cell in the grid has a non-negative integer value. The path can only move down or right at each step.**\\n\\n- We can use dynamic programming to solve this problem efficiently. We will create a 2D array dp of the same size as the input grid, where each cell dp[i][j] represents the minimum path sum from the top-left corner to cell (i, j).\\n\\n- We can initialize the dp array as follows:\\n\\n1. dp[0][0] = grid[0][0] since the minimum path sum to the top-left corner is the value of the top-left cell.\\n2. For the first row i=0 and first column j=0 < j < n, the minimum path sum can only be reached by moving right or down from the previous cell. So, we can compute dp[0][j] = dp[0][j-1] + grid[0][j] and dp[i][0] = dp[i-1][0] + grid[i][0] respectively.\\n3. For the rest of the cells, we can compute the minimum path sum as follows:\\ndp[i][j] = grid[i][j] + min(dp[i-1][j], dp[i][j-1]) since we can reach the current cell from the cell above or the cell to the left, and we want to take the path with the minimum sum.\\n- Once we have filled the dp array, the minimum path sum to the bottom-right corner will be dp[m-1][n-1], where m is the number of rows and n is the number of columns of the input grid.\\n\\n**The time complexity of this approach is O(mn) since we visit each cell once. The space complexity is also O(mn) since we use the dp array to store the intermediate results.**"
                    },
                    {
                        "username": "user5400vw",
                        "content": "good explanation.  the original grid can also act as your dp table."
                    },
                    {
                        "username": "cOde_Ranvir25",
                        "content": "***Here is the code link for reference:-)***\\nhttps://leetcode.com/problems/minimum-path-sum/solutions/2887704/easiest-solution/"
                    },
                    {
                        "username": "zaim",
                        "content": "On input \\n[[5,4,2,9,6,0,3,5,1,4,9,8,4,9,7,5,1],\\n [3,4,9,2,9,9,0,9,7,9,4,7,8,4,4,5,8],\\n [6,1,8,9,8,0,3,7,0,9,8,7,4,9,2,0,1],\\n [4,0,0,5,1,7,4,7,6,4,1,0,1,0,6,2,8],\\n [7,2,0,2,9,3,4,7,0,8,9,5,9,0,1,1,0],\\n [8,2,9,4,9,7,9,3,7,0,3,6,5,3,5,9,6],\\n [8,9,9,2,6,1,2,5,8,3,7,0,4,9,8,8,8],\\n [5,8,5,4,1,5,6,6,3,3,1,8,3,9,6,4,8],\\n [0,2,2,3,0,2,6,7,2,3,7,3,1,5,8,1,3],\\n [4,4,0,2,0,3,8,4,1,3,3,0,7,4,2,9,8],\\n [5,9,0,4,7,5,7,6,0,8,3,0,0,6,6,6,8],\\n [0,7,1,8,3,5,1,8,7,0,2,9,2,2,7,1,5],\\n [1,0,0,0,6,2,0,0,2,2,8,0,9,7,0,8,0],\\n [1,1,7,2,9,6,5,4,8,7,8,5,0,3,8,1,5],\\n [8,9,7,8,1,1,3,0,1,2,9,4,0,1,5,3,1],\\n [9,2,7,4,8,7,3,9,2,4,2,2,7,8,2,6,7],\\n [3,8,1,6,0,4,8,9,8,0,2,5,3,5,5,7,5],\\n [1,8,2,5,7,7,1,9,9,8,9,2,4,9,5,4,0],\\n [3,4,4,1,5,3,3,8,8,6,3,5,3,8,7,1,3]]\\n\\nckeckers solution is 82, but mine is is 79 with the following path:\\n\\n[05] 04  02  09  06  00  03  05  01  04  09  08  04  09  07  05  01 \\n\\n[03][04] 09  02  09  09  00  09  07  09  04  07  08  04  04  05  08 \\n\\n 06 [01] 08  09  08  00  03  07  00  09  08  07  04  09  02  00  01 \\n\\n 04 [00][00] 05  01  07  04  07  06  04  01  00  01  00  06  02  08 \\n\\n 07  02 [00][02] 09  03  04  07  00  08  09  05  09  00  01  01  00 \\n\\n 08  02  09 [04] 09  07  09  03  07  00  03  06  05  03  05  09  06 \\n\\n 08  09  09 [02] 06  01  02  05  08  03  07  00  04  09  08  08  08 \\n\\n 05  08  05 [04][01] 05  06  06  03  03  01  08  03  09  06  04  08 \\n\\n 00  02  02  03 [00] 02  06  07  02  03  07  03  01  05  08  01  03 \\n\\n 04  04 [00][02][00] 03  08  04  01  03  03  00  07  04  02  09  08 \\n\\n 05  09 [00] 04  07  05  07  06  00  08  03  00  00  06  06  06  08 \\n\\n 00  07 [01] 08  03  05  01  08  07  00  02  09  02  02  07  01  05 \\n\\n 01  00 [00][00][06][02][00][00][02][02][08][00] 09  07  00  08  00 \\n\\n 01  01  07  02  09  06  05  04  08  07  08 [05][00] 03  08  01  05 \\n\\n 08  09  07  08  01  01  03  00  01  02  09  04 [00][01][05][03][01]\\n\\n 09  02  07  04  08  07  03  09  02  04  02  02  07  08  02  06 [07]\\n\\n 03  08  01  06  00  04  08  09  08  00  02  05  03  05  05  07 [05]\\n\\n 01  08  02  05  07  07  01  09  09  08  09  02  04  09  05  04 [00]\\n\\n 03  04  04  01  05  03  03  08  08  06  03  05  03  08  07  01 [03]\\n\\nDoes anyone have a suggestion what I am doing wrong?"
                    },
                    {
                        "username": "LucidLynxxx",
                        "content": "I believe it is illlegal to move back, which you do? \"Note: You can only move either down or right at any point in time.\""
                    },
                    {
                        "username": "red_akb",
                        "content": "See 10th line, you\\'re moving left\\n\\nBut it is clearly mentioned in que that ->\\n\\n\"Note: You can only move either down or right at any point in time.\"\\n\\nSo if you\\'re doing by recursion, only use two operations as move_right, or move_down."
                    },
                    {
                        "username": "Shaa-Khan",
                        "content": "you can move only down and right"
                    },
                    {
                        "username": "Aman_gupta-9833",
                        "content": "hats off for these much long query buddy"
                    },
                    {
                        "username": "conrad001",
                        "content": "The problem statement says you are only allowed to move right or down but in your solution the path moves left at some point too. That is the problem with your solution."
                    },
                    {
                        "username": "Heyns95",
                        "content": "I also get 79. How do we notify leetcode?"
                    },
                    {
                        "username": "adriankuehn",
                        "content": "Yip, same here for me for testcase 56/61. I solved it by only allowing the BFS to go down and right as mentioned in the task. Then I get 82 instead of 79. But the path for 79 looks correct for me as well. "
                    },
                    {
                        "username": "jamesh",
                        "content": "Such as:\\n\\n    1, 9, 1, 1, 1\\n    1, 1, 1, 9, 1\\n\\nAll the 1's form the minimum path."
                    },
                    {
                        "username": "Earth-Turtle",
                        "content": "There\\'s a clarification in the description that you can only move down or right"
                    },
                    {
                        "username": "psionl0",
                        "content": "After yesterday\\'s problem, it is nice to be able to just code an answer and have it pass all test cases right off the bat without even any syntax errors."
                    },
                    {
                        "username": "tensionstate",
                        "content": "I understand that in some shortest path algorithms on general node weighted graphs, negative cycles lead to non-termination, but here I do not see any problem, so why does the question state that the weights are not negative?"
                    },
                    {
                        "username": "AdityaBhate",
                        "content": "# \\uD83D\\uDCCC C++ || Recursion , DP - Memoization, Tabulation + Space Optimization\\nhttps://leetcode.com/problems/minimum-path-sum/solutions/3117215/c-recursion-dp-memoization-tabulation-space-optimization/?orderBy=hot"
                    },
                    {
                        "username": "ShadyCoder",
                        "content": "What if the follow-up question is how do you store the path information that gives the minimum pathsum? Any ideas about how we can achieve that in a better design perspective?"
                    },
                    {
                        "username": "mayank_pant",
                        "content": "backtracking using the created dp array. "
                    },
                    {
                        "username": "neel19",
                        "content": "Go in reverse order like we do LCS i.e, from $dp[row-1][col-1]$ keep going till cell $dp[0][0]$. "
                    },
                    {
                        "username": "alpharomeo99",
                        "content": "Apart from the solutions mentioned one can just start from the source after creating the dp array. From source move greedily towards the the cell that has the minimum path sum to the destination and accordingly update the path. This will take O(N) time."
                    },
                    {
                        "username": "keshav97",
                        "content": "use recursion we have 2 choices either go right or go down"
                    },
                    {
                        "username": "kushalnagwanshicloud",
                        "content": "I did this -> \\nhttps://leetcode.com/problems/minimum-path-sum/solutions/2819398/how-to-print-the-path-if-asked/"
                    },
                    {
                        "username": "f20200445",
                        "content": "Can someone explain why this is giving me TLE only on the last testcase? I could do tabulation but memoization is giving TLE.\\n\\n    int f(int i,int j,int m,int n,vector<vector<int>> grid,vector<vector<int>> &dp) {\\n        if(i==m-1 && j==n-1) {\\n            return grid[i][j];\\n        }\\n\\n        if(dp[i][j]!=-1) {\\n            return dp[i][j];\\n        }\\n\\n        if(i==m-1) {\\n            return dp[i][j]=grid[i][j]+f(i,j+1,m,n,grid,dp);\\n        }\\n        else if(j==n-1) {\\n            return dp[i][j]=grid[i][j]+f(i+1,j,m,n,grid,dp);\\n        }\\n\\n        return dp[i][j]=grid[i][j] + min(f(i,j+1,m,n,grid,dp),f(i+1,j,m,n,grid,dp));\\n    }\\n    int minPathSum(vector<vector<int>>& grid) {\\n        int m = grid.size();\\n        int n = grid[0].size();\\n        vector<vector<int>> dp(m,vector<int>(n,-1));\\n        return f(0,0,m,n,grid,dp);\\n    }"
                    },
                    {
                        "username": "oops_moment",
                        "content": "Hey even i did the same way, it will pass . Just pass through reference since otherwise multiple copies are created hence increasing time complexity of code. \\nHope it clears the doubt"
                    },
                    {
                        "username": "ee20b053",
                        "content": "in function \\'f\\' pass the matrix grid by reference to further reduce time complexity\\n"
                    },
                    {
                        "username": "viku_kr",
                        "content": "Instead of doing recursively, this question can be done iteratively. Leave the first row and first column, then for all other positions best way to move there is from minimum of (i-1,j) or (i, j-1)"
                    }
                ]
            },
            {
                "id": 1844924,
                "content": [
                    {
                        "username": "_srahul_",
                        "content": "Friendship ended with graph, now DP is my best friend."
                    },
                    {
                        "username": "user4401w",
                        "content": "XD\\n"
                    },
                    {
                        "username": "codeMonarch",
                        "content": "agree++;\\n"
                    },
                    {
                        "username": "daring-calf",
                        "content": "When I first met this problem 8 months ago it was so hard and frustrating, I spent a whole night and didn\\'t quite get it even after watching the solutions. And today it only took 5 minutes to write.\\nTo all the noobcoders out there: it always hurts the first time; but hang in there, eventually you\\'ll enjoy it."
                    },
                    {
                        "username": "bhuppidhamii",
                        "content": "right bro."
                    },
                    {
                        "username": "kartikey_wariyal",
                        "content": "i too cant solve right now\\n"
                    },
                    {
                        "username": "diabloexodia",
                        "content": "I believe in the heart of the algorithms"
                    },
                    {
                        "username": "sk03167",
                        "content": "I love the discussion section. It's nice to see people in the same journey as you. I have never solved this question before but I know earlier I would written a whole ass recursive function, then optimized with memo. Now, it was intuitive that it's a 2d dp problem and how to write it. Took all but 11 lines of code to beat 90% both time and space."
                    },
                    {
                        "username": "Crispy_coffee",
                        "content": "Still TLE bmro"
                    },
                    {
                        "username": "cOde_Ranvir25",
                        "content": "# Here is an Approach :-)\\n**The problem statement is to find the minimum path sum from the top-left corner to the bottom-right corner of a grid, where each cell in the grid has a non-negative integer value. The path can only move down or right at each step.**\\n\\n- We can use dynamic programming to solve this problem efficiently. We will create a 2D array dp of the same size as the input grid, where each cell dp[i][j] represents the minimum path sum from the top-left corner to cell (i, j).\\n\\n- We can initialize the dp array as follows:\\n\\n1. dp[0][0] = grid[0][0] since the minimum path sum to the top-left corner is the value of the top-left cell.\\n2. For the first row i=0 and first column j=0 < j < n, the minimum path sum can only be reached by moving right or down from the previous cell. So, we can compute dp[0][j] = dp[0][j-1] + grid[0][j] and dp[i][0] = dp[i-1][0] + grid[i][0] respectively.\\n3. For the rest of the cells, we can compute the minimum path sum as follows:\\ndp[i][j] = grid[i][j] + min(dp[i-1][j], dp[i][j-1]) since we can reach the current cell from the cell above or the cell to the left, and we want to take the path with the minimum sum.\\n- Once we have filled the dp array, the minimum path sum to the bottom-right corner will be dp[m-1][n-1], where m is the number of rows and n is the number of columns of the input grid.\\n\\n**The time complexity of this approach is O(mn) since we visit each cell once. The space complexity is also O(mn) since we use the dp array to store the intermediate results.**"
                    },
                    {
                        "username": "user5400vw",
                        "content": "good explanation.  the original grid can also act as your dp table."
                    },
                    {
                        "username": "cOde_Ranvir25",
                        "content": "***Here is the code link for reference:-)***\\nhttps://leetcode.com/problems/minimum-path-sum/solutions/2887704/easiest-solution/"
                    },
                    {
                        "username": "zaim",
                        "content": "On input \\n[[5,4,2,9,6,0,3,5,1,4,9,8,4,9,7,5,1],\\n [3,4,9,2,9,9,0,9,7,9,4,7,8,4,4,5,8],\\n [6,1,8,9,8,0,3,7,0,9,8,7,4,9,2,0,1],\\n [4,0,0,5,1,7,4,7,6,4,1,0,1,0,6,2,8],\\n [7,2,0,2,9,3,4,7,0,8,9,5,9,0,1,1,0],\\n [8,2,9,4,9,7,9,3,7,0,3,6,5,3,5,9,6],\\n [8,9,9,2,6,1,2,5,8,3,7,0,4,9,8,8,8],\\n [5,8,5,4,1,5,6,6,3,3,1,8,3,9,6,4,8],\\n [0,2,2,3,0,2,6,7,2,3,7,3,1,5,8,1,3],\\n [4,4,0,2,0,3,8,4,1,3,3,0,7,4,2,9,8],\\n [5,9,0,4,7,5,7,6,0,8,3,0,0,6,6,6,8],\\n [0,7,1,8,3,5,1,8,7,0,2,9,2,2,7,1,5],\\n [1,0,0,0,6,2,0,0,2,2,8,0,9,7,0,8,0],\\n [1,1,7,2,9,6,5,4,8,7,8,5,0,3,8,1,5],\\n [8,9,7,8,1,1,3,0,1,2,9,4,0,1,5,3,1],\\n [9,2,7,4,8,7,3,9,2,4,2,2,7,8,2,6,7],\\n [3,8,1,6,0,4,8,9,8,0,2,5,3,5,5,7,5],\\n [1,8,2,5,7,7,1,9,9,8,9,2,4,9,5,4,0],\\n [3,4,4,1,5,3,3,8,8,6,3,5,3,8,7,1,3]]\\n\\nckeckers solution is 82, but mine is is 79 with the following path:\\n\\n[05] 04  02  09  06  00  03  05  01  04  09  08  04  09  07  05  01 \\n\\n[03][04] 09  02  09  09  00  09  07  09  04  07  08  04  04  05  08 \\n\\n 06 [01] 08  09  08  00  03  07  00  09  08  07  04  09  02  00  01 \\n\\n 04 [00][00] 05  01  07  04  07  06  04  01  00  01  00  06  02  08 \\n\\n 07  02 [00][02] 09  03  04  07  00  08  09  05  09  00  01  01  00 \\n\\n 08  02  09 [04] 09  07  09  03  07  00  03  06  05  03  05  09  06 \\n\\n 08  09  09 [02] 06  01  02  05  08  03  07  00  04  09  08  08  08 \\n\\n 05  08  05 [04][01] 05  06  06  03  03  01  08  03  09  06  04  08 \\n\\n 00  02  02  03 [00] 02  06  07  02  03  07  03  01  05  08  01  03 \\n\\n 04  04 [00][02][00] 03  08  04  01  03  03  00  07  04  02  09  08 \\n\\n 05  09 [00] 04  07  05  07  06  00  08  03  00  00  06  06  06  08 \\n\\n 00  07 [01] 08  03  05  01  08  07  00  02  09  02  02  07  01  05 \\n\\n 01  00 [00][00][06][02][00][00][02][02][08][00] 09  07  00  08  00 \\n\\n 01  01  07  02  09  06  05  04  08  07  08 [05][00] 03  08  01  05 \\n\\n 08  09  07  08  01  01  03  00  01  02  09  04 [00][01][05][03][01]\\n\\n 09  02  07  04  08  07  03  09  02  04  02  02  07  08  02  06 [07]\\n\\n 03  08  01  06  00  04  08  09  08  00  02  05  03  05  05  07 [05]\\n\\n 01  08  02  05  07  07  01  09  09  08  09  02  04  09  05  04 [00]\\n\\n 03  04  04  01  05  03  03  08  08  06  03  05  03  08  07  01 [03]\\n\\nDoes anyone have a suggestion what I am doing wrong?"
                    },
                    {
                        "username": "LucidLynxxx",
                        "content": "I believe it is illlegal to move back, which you do? \"Note: You can only move either down or right at any point in time.\""
                    },
                    {
                        "username": "red_akb",
                        "content": "See 10th line, you\\'re moving left\\n\\nBut it is clearly mentioned in que that ->\\n\\n\"Note: You can only move either down or right at any point in time.\"\\n\\nSo if you\\'re doing by recursion, only use two operations as move_right, or move_down."
                    },
                    {
                        "username": "Shaa-Khan",
                        "content": "you can move only down and right"
                    },
                    {
                        "username": "Aman_gupta-9833",
                        "content": "hats off for these much long query buddy"
                    },
                    {
                        "username": "conrad001",
                        "content": "The problem statement says you are only allowed to move right or down but in your solution the path moves left at some point too. That is the problem with your solution."
                    },
                    {
                        "username": "Heyns95",
                        "content": "I also get 79. How do we notify leetcode?"
                    },
                    {
                        "username": "adriankuehn",
                        "content": "Yip, same here for me for testcase 56/61. I solved it by only allowing the BFS to go down and right as mentioned in the task. Then I get 82 instead of 79. But the path for 79 looks correct for me as well. "
                    },
                    {
                        "username": "jamesh",
                        "content": "Such as:\\n\\n    1, 9, 1, 1, 1\\n    1, 1, 1, 9, 1\\n\\nAll the 1's form the minimum path."
                    },
                    {
                        "username": "Earth-Turtle",
                        "content": "There\\'s a clarification in the description that you can only move down or right"
                    },
                    {
                        "username": "psionl0",
                        "content": "After yesterday\\'s problem, it is nice to be able to just code an answer and have it pass all test cases right off the bat without even any syntax errors."
                    },
                    {
                        "username": "tensionstate",
                        "content": "I understand that in some shortest path algorithms on general node weighted graphs, negative cycles lead to non-termination, but here I do not see any problem, so why does the question state that the weights are not negative?"
                    },
                    {
                        "username": "AdityaBhate",
                        "content": "# \\uD83D\\uDCCC C++ || Recursion , DP - Memoization, Tabulation + Space Optimization\\nhttps://leetcode.com/problems/minimum-path-sum/solutions/3117215/c-recursion-dp-memoization-tabulation-space-optimization/?orderBy=hot"
                    },
                    {
                        "username": "ShadyCoder",
                        "content": "What if the follow-up question is how do you store the path information that gives the minimum pathsum? Any ideas about how we can achieve that in a better design perspective?"
                    },
                    {
                        "username": "mayank_pant",
                        "content": "backtracking using the created dp array. "
                    },
                    {
                        "username": "neel19",
                        "content": "Go in reverse order like we do LCS i.e, from $dp[row-1][col-1]$ keep going till cell $dp[0][0]$. "
                    },
                    {
                        "username": "alpharomeo99",
                        "content": "Apart from the solutions mentioned one can just start from the source after creating the dp array. From source move greedily towards the the cell that has the minimum path sum to the destination and accordingly update the path. This will take O(N) time."
                    },
                    {
                        "username": "keshav97",
                        "content": "use recursion we have 2 choices either go right or go down"
                    },
                    {
                        "username": "kushalnagwanshicloud",
                        "content": "I did this -> \\nhttps://leetcode.com/problems/minimum-path-sum/solutions/2819398/how-to-print-the-path-if-asked/"
                    },
                    {
                        "username": "f20200445",
                        "content": "Can someone explain why this is giving me TLE only on the last testcase? I could do tabulation but memoization is giving TLE.\\n\\n    int f(int i,int j,int m,int n,vector<vector<int>> grid,vector<vector<int>> &dp) {\\n        if(i==m-1 && j==n-1) {\\n            return grid[i][j];\\n        }\\n\\n        if(dp[i][j]!=-1) {\\n            return dp[i][j];\\n        }\\n\\n        if(i==m-1) {\\n            return dp[i][j]=grid[i][j]+f(i,j+1,m,n,grid,dp);\\n        }\\n        else if(j==n-1) {\\n            return dp[i][j]=grid[i][j]+f(i+1,j,m,n,grid,dp);\\n        }\\n\\n        return dp[i][j]=grid[i][j] + min(f(i,j+1,m,n,grid,dp),f(i+1,j,m,n,grid,dp));\\n    }\\n    int minPathSum(vector<vector<int>>& grid) {\\n        int m = grid.size();\\n        int n = grid[0].size();\\n        vector<vector<int>> dp(m,vector<int>(n,-1));\\n        return f(0,0,m,n,grid,dp);\\n    }"
                    },
                    {
                        "username": "oops_moment",
                        "content": "Hey even i did the same way, it will pass . Just pass through reference since otherwise multiple copies are created hence increasing time complexity of code. \\nHope it clears the doubt"
                    },
                    {
                        "username": "ee20b053",
                        "content": "in function \\'f\\' pass the matrix grid by reference to further reduce time complexity\\n"
                    },
                    {
                        "username": "viku_kr",
                        "content": "Instead of doing recursively, this question can be done iteratively. Leave the first row and first column, then for all other positions best way to move there is from minimum of (i-1,j) or (i, j-1)"
                    }
                ]
            },
            {
                "id": 1844935,
                "content": [
                    {
                        "username": "_srahul_",
                        "content": "Friendship ended with graph, now DP is my best friend."
                    },
                    {
                        "username": "user4401w",
                        "content": "XD\\n"
                    },
                    {
                        "username": "codeMonarch",
                        "content": "agree++;\\n"
                    },
                    {
                        "username": "daring-calf",
                        "content": "When I first met this problem 8 months ago it was so hard and frustrating, I spent a whole night and didn\\'t quite get it even after watching the solutions. And today it only took 5 minutes to write.\\nTo all the noobcoders out there: it always hurts the first time; but hang in there, eventually you\\'ll enjoy it."
                    },
                    {
                        "username": "bhuppidhamii",
                        "content": "right bro."
                    },
                    {
                        "username": "kartikey_wariyal",
                        "content": "i too cant solve right now\\n"
                    },
                    {
                        "username": "diabloexodia",
                        "content": "I believe in the heart of the algorithms"
                    },
                    {
                        "username": "sk03167",
                        "content": "I love the discussion section. It's nice to see people in the same journey as you. I have never solved this question before but I know earlier I would written a whole ass recursive function, then optimized with memo. Now, it was intuitive that it's a 2d dp problem and how to write it. Took all but 11 lines of code to beat 90% both time and space."
                    },
                    {
                        "username": "Crispy_coffee",
                        "content": "Still TLE bmro"
                    },
                    {
                        "username": "cOde_Ranvir25",
                        "content": "# Here is an Approach :-)\\n**The problem statement is to find the minimum path sum from the top-left corner to the bottom-right corner of a grid, where each cell in the grid has a non-negative integer value. The path can only move down or right at each step.**\\n\\n- We can use dynamic programming to solve this problem efficiently. We will create a 2D array dp of the same size as the input grid, where each cell dp[i][j] represents the minimum path sum from the top-left corner to cell (i, j).\\n\\n- We can initialize the dp array as follows:\\n\\n1. dp[0][0] = grid[0][0] since the minimum path sum to the top-left corner is the value of the top-left cell.\\n2. For the first row i=0 and first column j=0 < j < n, the minimum path sum can only be reached by moving right or down from the previous cell. So, we can compute dp[0][j] = dp[0][j-1] + grid[0][j] and dp[i][0] = dp[i-1][0] + grid[i][0] respectively.\\n3. For the rest of the cells, we can compute the minimum path sum as follows:\\ndp[i][j] = grid[i][j] + min(dp[i-1][j], dp[i][j-1]) since we can reach the current cell from the cell above or the cell to the left, and we want to take the path with the minimum sum.\\n- Once we have filled the dp array, the minimum path sum to the bottom-right corner will be dp[m-1][n-1], where m is the number of rows and n is the number of columns of the input grid.\\n\\n**The time complexity of this approach is O(mn) since we visit each cell once. The space complexity is also O(mn) since we use the dp array to store the intermediate results.**"
                    },
                    {
                        "username": "user5400vw",
                        "content": "good explanation.  the original grid can also act as your dp table."
                    },
                    {
                        "username": "cOde_Ranvir25",
                        "content": "***Here is the code link for reference:-)***\\nhttps://leetcode.com/problems/minimum-path-sum/solutions/2887704/easiest-solution/"
                    },
                    {
                        "username": "zaim",
                        "content": "On input \\n[[5,4,2,9,6,0,3,5,1,4,9,8,4,9,7,5,1],\\n [3,4,9,2,9,9,0,9,7,9,4,7,8,4,4,5,8],\\n [6,1,8,9,8,0,3,7,0,9,8,7,4,9,2,0,1],\\n [4,0,0,5,1,7,4,7,6,4,1,0,1,0,6,2,8],\\n [7,2,0,2,9,3,4,7,0,8,9,5,9,0,1,1,0],\\n [8,2,9,4,9,7,9,3,7,0,3,6,5,3,5,9,6],\\n [8,9,9,2,6,1,2,5,8,3,7,0,4,9,8,8,8],\\n [5,8,5,4,1,5,6,6,3,3,1,8,3,9,6,4,8],\\n [0,2,2,3,0,2,6,7,2,3,7,3,1,5,8,1,3],\\n [4,4,0,2,0,3,8,4,1,3,3,0,7,4,2,9,8],\\n [5,9,0,4,7,5,7,6,0,8,3,0,0,6,6,6,8],\\n [0,7,1,8,3,5,1,8,7,0,2,9,2,2,7,1,5],\\n [1,0,0,0,6,2,0,0,2,2,8,0,9,7,0,8,0],\\n [1,1,7,2,9,6,5,4,8,7,8,5,0,3,8,1,5],\\n [8,9,7,8,1,1,3,0,1,2,9,4,0,1,5,3,1],\\n [9,2,7,4,8,7,3,9,2,4,2,2,7,8,2,6,7],\\n [3,8,1,6,0,4,8,9,8,0,2,5,3,5,5,7,5],\\n [1,8,2,5,7,7,1,9,9,8,9,2,4,9,5,4,0],\\n [3,4,4,1,5,3,3,8,8,6,3,5,3,8,7,1,3]]\\n\\nckeckers solution is 82, but mine is is 79 with the following path:\\n\\n[05] 04  02  09  06  00  03  05  01  04  09  08  04  09  07  05  01 \\n\\n[03][04] 09  02  09  09  00  09  07  09  04  07  08  04  04  05  08 \\n\\n 06 [01] 08  09  08  00  03  07  00  09  08  07  04  09  02  00  01 \\n\\n 04 [00][00] 05  01  07  04  07  06  04  01  00  01  00  06  02  08 \\n\\n 07  02 [00][02] 09  03  04  07  00  08  09  05  09  00  01  01  00 \\n\\n 08  02  09 [04] 09  07  09  03  07  00  03  06  05  03  05  09  06 \\n\\n 08  09  09 [02] 06  01  02  05  08  03  07  00  04  09  08  08  08 \\n\\n 05  08  05 [04][01] 05  06  06  03  03  01  08  03  09  06  04  08 \\n\\n 00  02  02  03 [00] 02  06  07  02  03  07  03  01  05  08  01  03 \\n\\n 04  04 [00][02][00] 03  08  04  01  03  03  00  07  04  02  09  08 \\n\\n 05  09 [00] 04  07  05  07  06  00  08  03  00  00  06  06  06  08 \\n\\n 00  07 [01] 08  03  05  01  08  07  00  02  09  02  02  07  01  05 \\n\\n 01  00 [00][00][06][02][00][00][02][02][08][00] 09  07  00  08  00 \\n\\n 01  01  07  02  09  06  05  04  08  07  08 [05][00] 03  08  01  05 \\n\\n 08  09  07  08  01  01  03  00  01  02  09  04 [00][01][05][03][01]\\n\\n 09  02  07  04  08  07  03  09  02  04  02  02  07  08  02  06 [07]\\n\\n 03  08  01  06  00  04  08  09  08  00  02  05  03  05  05  07 [05]\\n\\n 01  08  02  05  07  07  01  09  09  08  09  02  04  09  05  04 [00]\\n\\n 03  04  04  01  05  03  03  08  08  06  03  05  03  08  07  01 [03]\\n\\nDoes anyone have a suggestion what I am doing wrong?"
                    },
                    {
                        "username": "LucidLynxxx",
                        "content": "I believe it is illlegal to move back, which you do? \"Note: You can only move either down or right at any point in time.\""
                    },
                    {
                        "username": "red_akb",
                        "content": "See 10th line, you\\'re moving left\\n\\nBut it is clearly mentioned in que that ->\\n\\n\"Note: You can only move either down or right at any point in time.\"\\n\\nSo if you\\'re doing by recursion, only use two operations as move_right, or move_down."
                    },
                    {
                        "username": "Shaa-Khan",
                        "content": "you can move only down and right"
                    },
                    {
                        "username": "Aman_gupta-9833",
                        "content": "hats off for these much long query buddy"
                    },
                    {
                        "username": "conrad001",
                        "content": "The problem statement says you are only allowed to move right or down but in your solution the path moves left at some point too. That is the problem with your solution."
                    },
                    {
                        "username": "Heyns95",
                        "content": "I also get 79. How do we notify leetcode?"
                    },
                    {
                        "username": "adriankuehn",
                        "content": "Yip, same here for me for testcase 56/61. I solved it by only allowing the BFS to go down and right as mentioned in the task. Then I get 82 instead of 79. But the path for 79 looks correct for me as well. "
                    },
                    {
                        "username": "jamesh",
                        "content": "Such as:\\n\\n    1, 9, 1, 1, 1\\n    1, 1, 1, 9, 1\\n\\nAll the 1's form the minimum path."
                    },
                    {
                        "username": "Earth-Turtle",
                        "content": "There\\'s a clarification in the description that you can only move down or right"
                    },
                    {
                        "username": "psionl0",
                        "content": "After yesterday\\'s problem, it is nice to be able to just code an answer and have it pass all test cases right off the bat without even any syntax errors."
                    },
                    {
                        "username": "tensionstate",
                        "content": "I understand that in some shortest path algorithms on general node weighted graphs, negative cycles lead to non-termination, but here I do not see any problem, so why does the question state that the weights are not negative?"
                    },
                    {
                        "username": "AdityaBhate",
                        "content": "# \\uD83D\\uDCCC C++ || Recursion , DP - Memoization, Tabulation + Space Optimization\\nhttps://leetcode.com/problems/minimum-path-sum/solutions/3117215/c-recursion-dp-memoization-tabulation-space-optimization/?orderBy=hot"
                    },
                    {
                        "username": "ShadyCoder",
                        "content": "What if the follow-up question is how do you store the path information that gives the minimum pathsum? Any ideas about how we can achieve that in a better design perspective?"
                    },
                    {
                        "username": "mayank_pant",
                        "content": "backtracking using the created dp array. "
                    },
                    {
                        "username": "neel19",
                        "content": "Go in reverse order like we do LCS i.e, from $dp[row-1][col-1]$ keep going till cell $dp[0][0]$. "
                    },
                    {
                        "username": "alpharomeo99",
                        "content": "Apart from the solutions mentioned one can just start from the source after creating the dp array. From source move greedily towards the the cell that has the minimum path sum to the destination and accordingly update the path. This will take O(N) time."
                    },
                    {
                        "username": "keshav97",
                        "content": "use recursion we have 2 choices either go right or go down"
                    },
                    {
                        "username": "kushalnagwanshicloud",
                        "content": "I did this -> \\nhttps://leetcode.com/problems/minimum-path-sum/solutions/2819398/how-to-print-the-path-if-asked/"
                    },
                    {
                        "username": "f20200445",
                        "content": "Can someone explain why this is giving me TLE only on the last testcase? I could do tabulation but memoization is giving TLE.\\n\\n    int f(int i,int j,int m,int n,vector<vector<int>> grid,vector<vector<int>> &dp) {\\n        if(i==m-1 && j==n-1) {\\n            return grid[i][j];\\n        }\\n\\n        if(dp[i][j]!=-1) {\\n            return dp[i][j];\\n        }\\n\\n        if(i==m-1) {\\n            return dp[i][j]=grid[i][j]+f(i,j+1,m,n,grid,dp);\\n        }\\n        else if(j==n-1) {\\n            return dp[i][j]=grid[i][j]+f(i+1,j,m,n,grid,dp);\\n        }\\n\\n        return dp[i][j]=grid[i][j] + min(f(i,j+1,m,n,grid,dp),f(i+1,j,m,n,grid,dp));\\n    }\\n    int minPathSum(vector<vector<int>>& grid) {\\n        int m = grid.size();\\n        int n = grid[0].size();\\n        vector<vector<int>> dp(m,vector<int>(n,-1));\\n        return f(0,0,m,n,grid,dp);\\n    }"
                    },
                    {
                        "username": "oops_moment",
                        "content": "Hey even i did the same way, it will pass . Just pass through reference since otherwise multiple copies are created hence increasing time complexity of code. \\nHope it clears the doubt"
                    },
                    {
                        "username": "ee20b053",
                        "content": "in function \\'f\\' pass the matrix grid by reference to further reduce time complexity\\n"
                    },
                    {
                        "username": "viku_kr",
                        "content": "Instead of doing recursively, this question can be done iteratively. Leave the first row and first column, then for all other positions best way to move there is from minimum of (i-1,j) or (i, j-1)"
                    }
                ]
            },
            {
                "id": 1844856,
                "content": [
                    {
                        "username": "_srahul_",
                        "content": "Friendship ended with graph, now DP is my best friend."
                    },
                    {
                        "username": "user4401w",
                        "content": "XD\\n"
                    },
                    {
                        "username": "codeMonarch",
                        "content": "agree++;\\n"
                    },
                    {
                        "username": "daring-calf",
                        "content": "When I first met this problem 8 months ago it was so hard and frustrating, I spent a whole night and didn\\'t quite get it even after watching the solutions. And today it only took 5 minutes to write.\\nTo all the noobcoders out there: it always hurts the first time; but hang in there, eventually you\\'ll enjoy it."
                    },
                    {
                        "username": "bhuppidhamii",
                        "content": "right bro."
                    },
                    {
                        "username": "kartikey_wariyal",
                        "content": "i too cant solve right now\\n"
                    },
                    {
                        "username": "diabloexodia",
                        "content": "I believe in the heart of the algorithms"
                    },
                    {
                        "username": "sk03167",
                        "content": "I love the discussion section. It's nice to see people in the same journey as you. I have never solved this question before but I know earlier I would written a whole ass recursive function, then optimized with memo. Now, it was intuitive that it's a 2d dp problem and how to write it. Took all but 11 lines of code to beat 90% both time and space."
                    },
                    {
                        "username": "Crispy_coffee",
                        "content": "Still TLE bmro"
                    },
                    {
                        "username": "cOde_Ranvir25",
                        "content": "# Here is an Approach :-)\\n**The problem statement is to find the minimum path sum from the top-left corner to the bottom-right corner of a grid, where each cell in the grid has a non-negative integer value. The path can only move down or right at each step.**\\n\\n- We can use dynamic programming to solve this problem efficiently. We will create a 2D array dp of the same size as the input grid, where each cell dp[i][j] represents the minimum path sum from the top-left corner to cell (i, j).\\n\\n- We can initialize the dp array as follows:\\n\\n1. dp[0][0] = grid[0][0] since the minimum path sum to the top-left corner is the value of the top-left cell.\\n2. For the first row i=0 and first column j=0 < j < n, the minimum path sum can only be reached by moving right or down from the previous cell. So, we can compute dp[0][j] = dp[0][j-1] + grid[0][j] and dp[i][0] = dp[i-1][0] + grid[i][0] respectively.\\n3. For the rest of the cells, we can compute the minimum path sum as follows:\\ndp[i][j] = grid[i][j] + min(dp[i-1][j], dp[i][j-1]) since we can reach the current cell from the cell above or the cell to the left, and we want to take the path with the minimum sum.\\n- Once we have filled the dp array, the minimum path sum to the bottom-right corner will be dp[m-1][n-1], where m is the number of rows and n is the number of columns of the input grid.\\n\\n**The time complexity of this approach is O(mn) since we visit each cell once. The space complexity is also O(mn) since we use the dp array to store the intermediate results.**"
                    },
                    {
                        "username": "user5400vw",
                        "content": "good explanation.  the original grid can also act as your dp table."
                    },
                    {
                        "username": "cOde_Ranvir25",
                        "content": "***Here is the code link for reference:-)***\\nhttps://leetcode.com/problems/minimum-path-sum/solutions/2887704/easiest-solution/"
                    },
                    {
                        "username": "zaim",
                        "content": "On input \\n[[5,4,2,9,6,0,3,5,1,4,9,8,4,9,7,5,1],\\n [3,4,9,2,9,9,0,9,7,9,4,7,8,4,4,5,8],\\n [6,1,8,9,8,0,3,7,0,9,8,7,4,9,2,0,1],\\n [4,0,0,5,1,7,4,7,6,4,1,0,1,0,6,2,8],\\n [7,2,0,2,9,3,4,7,0,8,9,5,9,0,1,1,0],\\n [8,2,9,4,9,7,9,3,7,0,3,6,5,3,5,9,6],\\n [8,9,9,2,6,1,2,5,8,3,7,0,4,9,8,8,8],\\n [5,8,5,4,1,5,6,6,3,3,1,8,3,9,6,4,8],\\n [0,2,2,3,0,2,6,7,2,3,7,3,1,5,8,1,3],\\n [4,4,0,2,0,3,8,4,1,3,3,0,7,4,2,9,8],\\n [5,9,0,4,7,5,7,6,0,8,3,0,0,6,6,6,8],\\n [0,7,1,8,3,5,1,8,7,0,2,9,2,2,7,1,5],\\n [1,0,0,0,6,2,0,0,2,2,8,0,9,7,0,8,0],\\n [1,1,7,2,9,6,5,4,8,7,8,5,0,3,8,1,5],\\n [8,9,7,8,1,1,3,0,1,2,9,4,0,1,5,3,1],\\n [9,2,7,4,8,7,3,9,2,4,2,2,7,8,2,6,7],\\n [3,8,1,6,0,4,8,9,8,0,2,5,3,5,5,7,5],\\n [1,8,2,5,7,7,1,9,9,8,9,2,4,9,5,4,0],\\n [3,4,4,1,5,3,3,8,8,6,3,5,3,8,7,1,3]]\\n\\nckeckers solution is 82, but mine is is 79 with the following path:\\n\\n[05] 04  02  09  06  00  03  05  01  04  09  08  04  09  07  05  01 \\n\\n[03][04] 09  02  09  09  00  09  07  09  04  07  08  04  04  05  08 \\n\\n 06 [01] 08  09  08  00  03  07  00  09  08  07  04  09  02  00  01 \\n\\n 04 [00][00] 05  01  07  04  07  06  04  01  00  01  00  06  02  08 \\n\\n 07  02 [00][02] 09  03  04  07  00  08  09  05  09  00  01  01  00 \\n\\n 08  02  09 [04] 09  07  09  03  07  00  03  06  05  03  05  09  06 \\n\\n 08  09  09 [02] 06  01  02  05  08  03  07  00  04  09  08  08  08 \\n\\n 05  08  05 [04][01] 05  06  06  03  03  01  08  03  09  06  04  08 \\n\\n 00  02  02  03 [00] 02  06  07  02  03  07  03  01  05  08  01  03 \\n\\n 04  04 [00][02][00] 03  08  04  01  03  03  00  07  04  02  09  08 \\n\\n 05  09 [00] 04  07  05  07  06  00  08  03  00  00  06  06  06  08 \\n\\n 00  07 [01] 08  03  05  01  08  07  00  02  09  02  02  07  01  05 \\n\\n 01  00 [00][00][06][02][00][00][02][02][08][00] 09  07  00  08  00 \\n\\n 01  01  07  02  09  06  05  04  08  07  08 [05][00] 03  08  01  05 \\n\\n 08  09  07  08  01  01  03  00  01  02  09  04 [00][01][05][03][01]\\n\\n 09  02  07  04  08  07  03  09  02  04  02  02  07  08  02  06 [07]\\n\\n 03  08  01  06  00  04  08  09  08  00  02  05  03  05  05  07 [05]\\n\\n 01  08  02  05  07  07  01  09  09  08  09  02  04  09  05  04 [00]\\n\\n 03  04  04  01  05  03  03  08  08  06  03  05  03  08  07  01 [03]\\n\\nDoes anyone have a suggestion what I am doing wrong?"
                    },
                    {
                        "username": "LucidLynxxx",
                        "content": "I believe it is illlegal to move back, which you do? \"Note: You can only move either down or right at any point in time.\""
                    },
                    {
                        "username": "red_akb",
                        "content": "See 10th line, you\\'re moving left\\n\\nBut it is clearly mentioned in que that ->\\n\\n\"Note: You can only move either down or right at any point in time.\"\\n\\nSo if you\\'re doing by recursion, only use two operations as move_right, or move_down."
                    },
                    {
                        "username": "Shaa-Khan",
                        "content": "you can move only down and right"
                    },
                    {
                        "username": "Aman_gupta-9833",
                        "content": "hats off for these much long query buddy"
                    },
                    {
                        "username": "conrad001",
                        "content": "The problem statement says you are only allowed to move right or down but in your solution the path moves left at some point too. That is the problem with your solution."
                    },
                    {
                        "username": "Heyns95",
                        "content": "I also get 79. How do we notify leetcode?"
                    },
                    {
                        "username": "adriankuehn",
                        "content": "Yip, same here for me for testcase 56/61. I solved it by only allowing the BFS to go down and right as mentioned in the task. Then I get 82 instead of 79. But the path for 79 looks correct for me as well. "
                    },
                    {
                        "username": "jamesh",
                        "content": "Such as:\\n\\n    1, 9, 1, 1, 1\\n    1, 1, 1, 9, 1\\n\\nAll the 1's form the minimum path."
                    },
                    {
                        "username": "Earth-Turtle",
                        "content": "There\\'s a clarification in the description that you can only move down or right"
                    },
                    {
                        "username": "psionl0",
                        "content": "After yesterday\\'s problem, it is nice to be able to just code an answer and have it pass all test cases right off the bat without even any syntax errors."
                    },
                    {
                        "username": "tensionstate",
                        "content": "I understand that in some shortest path algorithms on general node weighted graphs, negative cycles lead to non-termination, but here I do not see any problem, so why does the question state that the weights are not negative?"
                    },
                    {
                        "username": "AdityaBhate",
                        "content": "# \\uD83D\\uDCCC C++ || Recursion , DP - Memoization, Tabulation + Space Optimization\\nhttps://leetcode.com/problems/minimum-path-sum/solutions/3117215/c-recursion-dp-memoization-tabulation-space-optimization/?orderBy=hot"
                    },
                    {
                        "username": "ShadyCoder",
                        "content": "What if the follow-up question is how do you store the path information that gives the minimum pathsum? Any ideas about how we can achieve that in a better design perspective?"
                    },
                    {
                        "username": "mayank_pant",
                        "content": "backtracking using the created dp array. "
                    },
                    {
                        "username": "neel19",
                        "content": "Go in reverse order like we do LCS i.e, from $dp[row-1][col-1]$ keep going till cell $dp[0][0]$. "
                    },
                    {
                        "username": "alpharomeo99",
                        "content": "Apart from the solutions mentioned one can just start from the source after creating the dp array. From source move greedily towards the the cell that has the minimum path sum to the destination and accordingly update the path. This will take O(N) time."
                    },
                    {
                        "username": "keshav97",
                        "content": "use recursion we have 2 choices either go right or go down"
                    },
                    {
                        "username": "kushalnagwanshicloud",
                        "content": "I did this -> \\nhttps://leetcode.com/problems/minimum-path-sum/solutions/2819398/how-to-print-the-path-if-asked/"
                    },
                    {
                        "username": "f20200445",
                        "content": "Can someone explain why this is giving me TLE only on the last testcase? I could do tabulation but memoization is giving TLE.\\n\\n    int f(int i,int j,int m,int n,vector<vector<int>> grid,vector<vector<int>> &dp) {\\n        if(i==m-1 && j==n-1) {\\n            return grid[i][j];\\n        }\\n\\n        if(dp[i][j]!=-1) {\\n            return dp[i][j];\\n        }\\n\\n        if(i==m-1) {\\n            return dp[i][j]=grid[i][j]+f(i,j+1,m,n,grid,dp);\\n        }\\n        else if(j==n-1) {\\n            return dp[i][j]=grid[i][j]+f(i+1,j,m,n,grid,dp);\\n        }\\n\\n        return dp[i][j]=grid[i][j] + min(f(i,j+1,m,n,grid,dp),f(i+1,j,m,n,grid,dp));\\n    }\\n    int minPathSum(vector<vector<int>>& grid) {\\n        int m = grid.size();\\n        int n = grid[0].size();\\n        vector<vector<int>> dp(m,vector<int>(n,-1));\\n        return f(0,0,m,n,grid,dp);\\n    }"
                    },
                    {
                        "username": "oops_moment",
                        "content": "Hey even i did the same way, it will pass . Just pass through reference since otherwise multiple copies are created hence increasing time complexity of code. \\nHope it clears the doubt"
                    },
                    {
                        "username": "ee20b053",
                        "content": "in function \\'f\\' pass the matrix grid by reference to further reduce time complexity\\n"
                    },
                    {
                        "username": "viku_kr",
                        "content": "Instead of doing recursively, this question can be done iteratively. Leave the first row and first column, then for all other positions best way to move there is from minimum of (i-1,j) or (i, j-1)"
                    }
                ]
            },
            {
                "id": 1568882,
                "content": [
                    {
                        "username": "_srahul_",
                        "content": "Friendship ended with graph, now DP is my best friend."
                    },
                    {
                        "username": "user4401w",
                        "content": "XD\\n"
                    },
                    {
                        "username": "codeMonarch",
                        "content": "agree++;\\n"
                    },
                    {
                        "username": "daring-calf",
                        "content": "When I first met this problem 8 months ago it was so hard and frustrating, I spent a whole night and didn\\'t quite get it even after watching the solutions. And today it only took 5 minutes to write.\\nTo all the noobcoders out there: it always hurts the first time; but hang in there, eventually you\\'ll enjoy it."
                    },
                    {
                        "username": "bhuppidhamii",
                        "content": "right bro."
                    },
                    {
                        "username": "kartikey_wariyal",
                        "content": "i too cant solve right now\\n"
                    },
                    {
                        "username": "diabloexodia",
                        "content": "I believe in the heart of the algorithms"
                    },
                    {
                        "username": "sk03167",
                        "content": "I love the discussion section. It's nice to see people in the same journey as you. I have never solved this question before but I know earlier I would written a whole ass recursive function, then optimized with memo. Now, it was intuitive that it's a 2d dp problem and how to write it. Took all but 11 lines of code to beat 90% both time and space."
                    },
                    {
                        "username": "Crispy_coffee",
                        "content": "Still TLE bmro"
                    },
                    {
                        "username": "cOde_Ranvir25",
                        "content": "# Here is an Approach :-)\\n**The problem statement is to find the minimum path sum from the top-left corner to the bottom-right corner of a grid, where each cell in the grid has a non-negative integer value. The path can only move down or right at each step.**\\n\\n- We can use dynamic programming to solve this problem efficiently. We will create a 2D array dp of the same size as the input grid, where each cell dp[i][j] represents the minimum path sum from the top-left corner to cell (i, j).\\n\\n- We can initialize the dp array as follows:\\n\\n1. dp[0][0] = grid[0][0] since the minimum path sum to the top-left corner is the value of the top-left cell.\\n2. For the first row i=0 and first column j=0 < j < n, the minimum path sum can only be reached by moving right or down from the previous cell. So, we can compute dp[0][j] = dp[0][j-1] + grid[0][j] and dp[i][0] = dp[i-1][0] + grid[i][0] respectively.\\n3. For the rest of the cells, we can compute the minimum path sum as follows:\\ndp[i][j] = grid[i][j] + min(dp[i-1][j], dp[i][j-1]) since we can reach the current cell from the cell above or the cell to the left, and we want to take the path with the minimum sum.\\n- Once we have filled the dp array, the minimum path sum to the bottom-right corner will be dp[m-1][n-1], where m is the number of rows and n is the number of columns of the input grid.\\n\\n**The time complexity of this approach is O(mn) since we visit each cell once. The space complexity is also O(mn) since we use the dp array to store the intermediate results.**"
                    },
                    {
                        "username": "user5400vw",
                        "content": "good explanation.  the original grid can also act as your dp table."
                    },
                    {
                        "username": "cOde_Ranvir25",
                        "content": "***Here is the code link for reference:-)***\\nhttps://leetcode.com/problems/minimum-path-sum/solutions/2887704/easiest-solution/"
                    },
                    {
                        "username": "zaim",
                        "content": "On input \\n[[5,4,2,9,6,0,3,5,1,4,9,8,4,9,7,5,1],\\n [3,4,9,2,9,9,0,9,7,9,4,7,8,4,4,5,8],\\n [6,1,8,9,8,0,3,7,0,9,8,7,4,9,2,0,1],\\n [4,0,0,5,1,7,4,7,6,4,1,0,1,0,6,2,8],\\n [7,2,0,2,9,3,4,7,0,8,9,5,9,0,1,1,0],\\n [8,2,9,4,9,7,9,3,7,0,3,6,5,3,5,9,6],\\n [8,9,9,2,6,1,2,5,8,3,7,0,4,9,8,8,8],\\n [5,8,5,4,1,5,6,6,3,3,1,8,3,9,6,4,8],\\n [0,2,2,3,0,2,6,7,2,3,7,3,1,5,8,1,3],\\n [4,4,0,2,0,3,8,4,1,3,3,0,7,4,2,9,8],\\n [5,9,0,4,7,5,7,6,0,8,3,0,0,6,6,6,8],\\n [0,7,1,8,3,5,1,8,7,0,2,9,2,2,7,1,5],\\n [1,0,0,0,6,2,0,0,2,2,8,0,9,7,0,8,0],\\n [1,1,7,2,9,6,5,4,8,7,8,5,0,3,8,1,5],\\n [8,9,7,8,1,1,3,0,1,2,9,4,0,1,5,3,1],\\n [9,2,7,4,8,7,3,9,2,4,2,2,7,8,2,6,7],\\n [3,8,1,6,0,4,8,9,8,0,2,5,3,5,5,7,5],\\n [1,8,2,5,7,7,1,9,9,8,9,2,4,9,5,4,0],\\n [3,4,4,1,5,3,3,8,8,6,3,5,3,8,7,1,3]]\\n\\nckeckers solution is 82, but mine is is 79 with the following path:\\n\\n[05] 04  02  09  06  00  03  05  01  04  09  08  04  09  07  05  01 \\n\\n[03][04] 09  02  09  09  00  09  07  09  04  07  08  04  04  05  08 \\n\\n 06 [01] 08  09  08  00  03  07  00  09  08  07  04  09  02  00  01 \\n\\n 04 [00][00] 05  01  07  04  07  06  04  01  00  01  00  06  02  08 \\n\\n 07  02 [00][02] 09  03  04  07  00  08  09  05  09  00  01  01  00 \\n\\n 08  02  09 [04] 09  07  09  03  07  00  03  06  05  03  05  09  06 \\n\\n 08  09  09 [02] 06  01  02  05  08  03  07  00  04  09  08  08  08 \\n\\n 05  08  05 [04][01] 05  06  06  03  03  01  08  03  09  06  04  08 \\n\\n 00  02  02  03 [00] 02  06  07  02  03  07  03  01  05  08  01  03 \\n\\n 04  04 [00][02][00] 03  08  04  01  03  03  00  07  04  02  09  08 \\n\\n 05  09 [00] 04  07  05  07  06  00  08  03  00  00  06  06  06  08 \\n\\n 00  07 [01] 08  03  05  01  08  07  00  02  09  02  02  07  01  05 \\n\\n 01  00 [00][00][06][02][00][00][02][02][08][00] 09  07  00  08  00 \\n\\n 01  01  07  02  09  06  05  04  08  07  08 [05][00] 03  08  01  05 \\n\\n 08  09  07  08  01  01  03  00  01  02  09  04 [00][01][05][03][01]\\n\\n 09  02  07  04  08  07  03  09  02  04  02  02  07  08  02  06 [07]\\n\\n 03  08  01  06  00  04  08  09  08  00  02  05  03  05  05  07 [05]\\n\\n 01  08  02  05  07  07  01  09  09  08  09  02  04  09  05  04 [00]\\n\\n 03  04  04  01  05  03  03  08  08  06  03  05  03  08  07  01 [03]\\n\\nDoes anyone have a suggestion what I am doing wrong?"
                    },
                    {
                        "username": "LucidLynxxx",
                        "content": "I believe it is illlegal to move back, which you do? \"Note: You can only move either down or right at any point in time.\""
                    },
                    {
                        "username": "red_akb",
                        "content": "See 10th line, you\\'re moving left\\n\\nBut it is clearly mentioned in que that ->\\n\\n\"Note: You can only move either down or right at any point in time.\"\\n\\nSo if you\\'re doing by recursion, only use two operations as move_right, or move_down."
                    },
                    {
                        "username": "Shaa-Khan",
                        "content": "you can move only down and right"
                    },
                    {
                        "username": "Aman_gupta-9833",
                        "content": "hats off for these much long query buddy"
                    },
                    {
                        "username": "conrad001",
                        "content": "The problem statement says you are only allowed to move right or down but in your solution the path moves left at some point too. That is the problem with your solution."
                    },
                    {
                        "username": "Heyns95",
                        "content": "I also get 79. How do we notify leetcode?"
                    },
                    {
                        "username": "adriankuehn",
                        "content": "Yip, same here for me for testcase 56/61. I solved it by only allowing the BFS to go down and right as mentioned in the task. Then I get 82 instead of 79. But the path for 79 looks correct for me as well. "
                    },
                    {
                        "username": "jamesh",
                        "content": "Such as:\\n\\n    1, 9, 1, 1, 1\\n    1, 1, 1, 9, 1\\n\\nAll the 1's form the minimum path."
                    },
                    {
                        "username": "Earth-Turtle",
                        "content": "There\\'s a clarification in the description that you can only move down or right"
                    },
                    {
                        "username": "psionl0",
                        "content": "After yesterday\\'s problem, it is nice to be able to just code an answer and have it pass all test cases right off the bat without even any syntax errors."
                    },
                    {
                        "username": "tensionstate",
                        "content": "I understand that in some shortest path algorithms on general node weighted graphs, negative cycles lead to non-termination, but here I do not see any problem, so why does the question state that the weights are not negative?"
                    },
                    {
                        "username": "AdityaBhate",
                        "content": "# \\uD83D\\uDCCC C++ || Recursion , DP - Memoization, Tabulation + Space Optimization\\nhttps://leetcode.com/problems/minimum-path-sum/solutions/3117215/c-recursion-dp-memoization-tabulation-space-optimization/?orderBy=hot"
                    },
                    {
                        "username": "ShadyCoder",
                        "content": "What if the follow-up question is how do you store the path information that gives the minimum pathsum? Any ideas about how we can achieve that in a better design perspective?"
                    },
                    {
                        "username": "mayank_pant",
                        "content": "backtracking using the created dp array. "
                    },
                    {
                        "username": "neel19",
                        "content": "Go in reverse order like we do LCS i.e, from $dp[row-1][col-1]$ keep going till cell $dp[0][0]$. "
                    },
                    {
                        "username": "alpharomeo99",
                        "content": "Apart from the solutions mentioned one can just start from the source after creating the dp array. From source move greedily towards the the cell that has the minimum path sum to the destination and accordingly update the path. This will take O(N) time."
                    },
                    {
                        "username": "keshav97",
                        "content": "use recursion we have 2 choices either go right or go down"
                    },
                    {
                        "username": "kushalnagwanshicloud",
                        "content": "I did this -> \\nhttps://leetcode.com/problems/minimum-path-sum/solutions/2819398/how-to-print-the-path-if-asked/"
                    },
                    {
                        "username": "f20200445",
                        "content": "Can someone explain why this is giving me TLE only on the last testcase? I could do tabulation but memoization is giving TLE.\\n\\n    int f(int i,int j,int m,int n,vector<vector<int>> grid,vector<vector<int>> &dp) {\\n        if(i==m-1 && j==n-1) {\\n            return grid[i][j];\\n        }\\n\\n        if(dp[i][j]!=-1) {\\n            return dp[i][j];\\n        }\\n\\n        if(i==m-1) {\\n            return dp[i][j]=grid[i][j]+f(i,j+1,m,n,grid,dp);\\n        }\\n        else if(j==n-1) {\\n            return dp[i][j]=grid[i][j]+f(i+1,j,m,n,grid,dp);\\n        }\\n\\n        return dp[i][j]=grid[i][j] + min(f(i,j+1,m,n,grid,dp),f(i+1,j,m,n,grid,dp));\\n    }\\n    int minPathSum(vector<vector<int>>& grid) {\\n        int m = grid.size();\\n        int n = grid[0].size();\\n        vector<vector<int>> dp(m,vector<int>(n,-1));\\n        return f(0,0,m,n,grid,dp);\\n    }"
                    },
                    {
                        "username": "oops_moment",
                        "content": "Hey even i did the same way, it will pass . Just pass through reference since otherwise multiple copies are created hence increasing time complexity of code. \\nHope it clears the doubt"
                    },
                    {
                        "username": "ee20b053",
                        "content": "in function \\'f\\' pass the matrix grid by reference to further reduce time complexity\\n"
                    },
                    {
                        "username": "viku_kr",
                        "content": "Instead of doing recursively, this question can be done iteratively. Leave the first row and first column, then for all other positions best way to move there is from minimum of (i-1,j) or (i, j-1)"
                    }
                ]
            },
            {
                "id": 1567180,
                "content": [
                    {
                        "username": "_srahul_",
                        "content": "Friendship ended with graph, now DP is my best friend."
                    },
                    {
                        "username": "user4401w",
                        "content": "XD\\n"
                    },
                    {
                        "username": "codeMonarch",
                        "content": "agree++;\\n"
                    },
                    {
                        "username": "daring-calf",
                        "content": "When I first met this problem 8 months ago it was so hard and frustrating, I spent a whole night and didn\\'t quite get it even after watching the solutions. And today it only took 5 minutes to write.\\nTo all the noobcoders out there: it always hurts the first time; but hang in there, eventually you\\'ll enjoy it."
                    },
                    {
                        "username": "bhuppidhamii",
                        "content": "right bro."
                    },
                    {
                        "username": "kartikey_wariyal",
                        "content": "i too cant solve right now\\n"
                    },
                    {
                        "username": "diabloexodia",
                        "content": "I believe in the heart of the algorithms"
                    },
                    {
                        "username": "sk03167",
                        "content": "I love the discussion section. It's nice to see people in the same journey as you. I have never solved this question before but I know earlier I would written a whole ass recursive function, then optimized with memo. Now, it was intuitive that it's a 2d dp problem and how to write it. Took all but 11 lines of code to beat 90% both time and space."
                    },
                    {
                        "username": "Crispy_coffee",
                        "content": "Still TLE bmro"
                    },
                    {
                        "username": "cOde_Ranvir25",
                        "content": "# Here is an Approach :-)\\n**The problem statement is to find the minimum path sum from the top-left corner to the bottom-right corner of a grid, where each cell in the grid has a non-negative integer value. The path can only move down or right at each step.**\\n\\n- We can use dynamic programming to solve this problem efficiently. We will create a 2D array dp of the same size as the input grid, where each cell dp[i][j] represents the minimum path sum from the top-left corner to cell (i, j).\\n\\n- We can initialize the dp array as follows:\\n\\n1. dp[0][0] = grid[0][0] since the minimum path sum to the top-left corner is the value of the top-left cell.\\n2. For the first row i=0 and first column j=0 < j < n, the minimum path sum can only be reached by moving right or down from the previous cell. So, we can compute dp[0][j] = dp[0][j-1] + grid[0][j] and dp[i][0] = dp[i-1][0] + grid[i][0] respectively.\\n3. For the rest of the cells, we can compute the minimum path sum as follows:\\ndp[i][j] = grid[i][j] + min(dp[i-1][j], dp[i][j-1]) since we can reach the current cell from the cell above or the cell to the left, and we want to take the path with the minimum sum.\\n- Once we have filled the dp array, the minimum path sum to the bottom-right corner will be dp[m-1][n-1], where m is the number of rows and n is the number of columns of the input grid.\\n\\n**The time complexity of this approach is O(mn) since we visit each cell once. The space complexity is also O(mn) since we use the dp array to store the intermediate results.**"
                    },
                    {
                        "username": "user5400vw",
                        "content": "good explanation.  the original grid can also act as your dp table."
                    },
                    {
                        "username": "cOde_Ranvir25",
                        "content": "***Here is the code link for reference:-)***\\nhttps://leetcode.com/problems/minimum-path-sum/solutions/2887704/easiest-solution/"
                    },
                    {
                        "username": "zaim",
                        "content": "On input \\n[[5,4,2,9,6,0,3,5,1,4,9,8,4,9,7,5,1],\\n [3,4,9,2,9,9,0,9,7,9,4,7,8,4,4,5,8],\\n [6,1,8,9,8,0,3,7,0,9,8,7,4,9,2,0,1],\\n [4,0,0,5,1,7,4,7,6,4,1,0,1,0,6,2,8],\\n [7,2,0,2,9,3,4,7,0,8,9,5,9,0,1,1,0],\\n [8,2,9,4,9,7,9,3,7,0,3,6,5,3,5,9,6],\\n [8,9,9,2,6,1,2,5,8,3,7,0,4,9,8,8,8],\\n [5,8,5,4,1,5,6,6,3,3,1,8,3,9,6,4,8],\\n [0,2,2,3,0,2,6,7,2,3,7,3,1,5,8,1,3],\\n [4,4,0,2,0,3,8,4,1,3,3,0,7,4,2,9,8],\\n [5,9,0,4,7,5,7,6,0,8,3,0,0,6,6,6,8],\\n [0,7,1,8,3,5,1,8,7,0,2,9,2,2,7,1,5],\\n [1,0,0,0,6,2,0,0,2,2,8,0,9,7,0,8,0],\\n [1,1,7,2,9,6,5,4,8,7,8,5,0,3,8,1,5],\\n [8,9,7,8,1,1,3,0,1,2,9,4,0,1,5,3,1],\\n [9,2,7,4,8,7,3,9,2,4,2,2,7,8,2,6,7],\\n [3,8,1,6,0,4,8,9,8,0,2,5,3,5,5,7,5],\\n [1,8,2,5,7,7,1,9,9,8,9,2,4,9,5,4,0],\\n [3,4,4,1,5,3,3,8,8,6,3,5,3,8,7,1,3]]\\n\\nckeckers solution is 82, but mine is is 79 with the following path:\\n\\n[05] 04  02  09  06  00  03  05  01  04  09  08  04  09  07  05  01 \\n\\n[03][04] 09  02  09  09  00  09  07  09  04  07  08  04  04  05  08 \\n\\n 06 [01] 08  09  08  00  03  07  00  09  08  07  04  09  02  00  01 \\n\\n 04 [00][00] 05  01  07  04  07  06  04  01  00  01  00  06  02  08 \\n\\n 07  02 [00][02] 09  03  04  07  00  08  09  05  09  00  01  01  00 \\n\\n 08  02  09 [04] 09  07  09  03  07  00  03  06  05  03  05  09  06 \\n\\n 08  09  09 [02] 06  01  02  05  08  03  07  00  04  09  08  08  08 \\n\\n 05  08  05 [04][01] 05  06  06  03  03  01  08  03  09  06  04  08 \\n\\n 00  02  02  03 [00] 02  06  07  02  03  07  03  01  05  08  01  03 \\n\\n 04  04 [00][02][00] 03  08  04  01  03  03  00  07  04  02  09  08 \\n\\n 05  09 [00] 04  07  05  07  06  00  08  03  00  00  06  06  06  08 \\n\\n 00  07 [01] 08  03  05  01  08  07  00  02  09  02  02  07  01  05 \\n\\n 01  00 [00][00][06][02][00][00][02][02][08][00] 09  07  00  08  00 \\n\\n 01  01  07  02  09  06  05  04  08  07  08 [05][00] 03  08  01  05 \\n\\n 08  09  07  08  01  01  03  00  01  02  09  04 [00][01][05][03][01]\\n\\n 09  02  07  04  08  07  03  09  02  04  02  02  07  08  02  06 [07]\\n\\n 03  08  01  06  00  04  08  09  08  00  02  05  03  05  05  07 [05]\\n\\n 01  08  02  05  07  07  01  09  09  08  09  02  04  09  05  04 [00]\\n\\n 03  04  04  01  05  03  03  08  08  06  03  05  03  08  07  01 [03]\\n\\nDoes anyone have a suggestion what I am doing wrong?"
                    },
                    {
                        "username": "LucidLynxxx",
                        "content": "I believe it is illlegal to move back, which you do? \"Note: You can only move either down or right at any point in time.\""
                    },
                    {
                        "username": "red_akb",
                        "content": "See 10th line, you\\'re moving left\\n\\nBut it is clearly mentioned in que that ->\\n\\n\"Note: You can only move either down or right at any point in time.\"\\n\\nSo if you\\'re doing by recursion, only use two operations as move_right, or move_down."
                    },
                    {
                        "username": "Shaa-Khan",
                        "content": "you can move only down and right"
                    },
                    {
                        "username": "Aman_gupta-9833",
                        "content": "hats off for these much long query buddy"
                    },
                    {
                        "username": "conrad001",
                        "content": "The problem statement says you are only allowed to move right or down but in your solution the path moves left at some point too. That is the problem with your solution."
                    },
                    {
                        "username": "Heyns95",
                        "content": "I also get 79. How do we notify leetcode?"
                    },
                    {
                        "username": "adriankuehn",
                        "content": "Yip, same here for me for testcase 56/61. I solved it by only allowing the BFS to go down and right as mentioned in the task. Then I get 82 instead of 79. But the path for 79 looks correct for me as well. "
                    },
                    {
                        "username": "jamesh",
                        "content": "Such as:\\n\\n    1, 9, 1, 1, 1\\n    1, 1, 1, 9, 1\\n\\nAll the 1's form the minimum path."
                    },
                    {
                        "username": "Earth-Turtle",
                        "content": "There\\'s a clarification in the description that you can only move down or right"
                    },
                    {
                        "username": "psionl0",
                        "content": "After yesterday\\'s problem, it is nice to be able to just code an answer and have it pass all test cases right off the bat without even any syntax errors."
                    },
                    {
                        "username": "tensionstate",
                        "content": "I understand that in some shortest path algorithms on general node weighted graphs, negative cycles lead to non-termination, but here I do not see any problem, so why does the question state that the weights are not negative?"
                    },
                    {
                        "username": "AdityaBhate",
                        "content": "# \\uD83D\\uDCCC C++ || Recursion , DP - Memoization, Tabulation + Space Optimization\\nhttps://leetcode.com/problems/minimum-path-sum/solutions/3117215/c-recursion-dp-memoization-tabulation-space-optimization/?orderBy=hot"
                    },
                    {
                        "username": "ShadyCoder",
                        "content": "What if the follow-up question is how do you store the path information that gives the minimum pathsum? Any ideas about how we can achieve that in a better design perspective?"
                    },
                    {
                        "username": "mayank_pant",
                        "content": "backtracking using the created dp array. "
                    },
                    {
                        "username": "neel19",
                        "content": "Go in reverse order like we do LCS i.e, from $dp[row-1][col-1]$ keep going till cell $dp[0][0]$. "
                    },
                    {
                        "username": "alpharomeo99",
                        "content": "Apart from the solutions mentioned one can just start from the source after creating the dp array. From source move greedily towards the the cell that has the minimum path sum to the destination and accordingly update the path. This will take O(N) time."
                    },
                    {
                        "username": "keshav97",
                        "content": "use recursion we have 2 choices either go right or go down"
                    },
                    {
                        "username": "kushalnagwanshicloud",
                        "content": "I did this -> \\nhttps://leetcode.com/problems/minimum-path-sum/solutions/2819398/how-to-print-the-path-if-asked/"
                    },
                    {
                        "username": "f20200445",
                        "content": "Can someone explain why this is giving me TLE only on the last testcase? I could do tabulation but memoization is giving TLE.\\n\\n    int f(int i,int j,int m,int n,vector<vector<int>> grid,vector<vector<int>> &dp) {\\n        if(i==m-1 && j==n-1) {\\n            return grid[i][j];\\n        }\\n\\n        if(dp[i][j]!=-1) {\\n            return dp[i][j];\\n        }\\n\\n        if(i==m-1) {\\n            return dp[i][j]=grid[i][j]+f(i,j+1,m,n,grid,dp);\\n        }\\n        else if(j==n-1) {\\n            return dp[i][j]=grid[i][j]+f(i+1,j,m,n,grid,dp);\\n        }\\n\\n        return dp[i][j]=grid[i][j] + min(f(i,j+1,m,n,grid,dp),f(i+1,j,m,n,grid,dp));\\n    }\\n    int minPathSum(vector<vector<int>>& grid) {\\n        int m = grid.size();\\n        int n = grid[0].size();\\n        vector<vector<int>> dp(m,vector<int>(n,-1));\\n        return f(0,0,m,n,grid,dp);\\n    }"
                    },
                    {
                        "username": "oops_moment",
                        "content": "Hey even i did the same way, it will pass . Just pass through reference since otherwise multiple copies are created hence increasing time complexity of code. \\nHope it clears the doubt"
                    },
                    {
                        "username": "ee20b053",
                        "content": "in function \\'f\\' pass the matrix grid by reference to further reduce time complexity\\n"
                    },
                    {
                        "username": "viku_kr",
                        "content": "Instead of doing recursively, this question can be done iteratively. Leave the first row and first column, then for all other positions best way to move there is from minimum of (i-1,j) or (i, j-1)"
                    }
                ]
            },
            {
                "id": 1844809,
                "content": [
                    {
                        "username": "_srahul_",
                        "content": "Friendship ended with graph, now DP is my best friend."
                    },
                    {
                        "username": "user4401w",
                        "content": "XD\\n"
                    },
                    {
                        "username": "codeMonarch",
                        "content": "agree++;\\n"
                    },
                    {
                        "username": "daring-calf",
                        "content": "When I first met this problem 8 months ago it was so hard and frustrating, I spent a whole night and didn\\'t quite get it even after watching the solutions. And today it only took 5 minutes to write.\\nTo all the noobcoders out there: it always hurts the first time; but hang in there, eventually you\\'ll enjoy it."
                    },
                    {
                        "username": "bhuppidhamii",
                        "content": "right bro."
                    },
                    {
                        "username": "kartikey_wariyal",
                        "content": "i too cant solve right now\\n"
                    },
                    {
                        "username": "diabloexodia",
                        "content": "I believe in the heart of the algorithms"
                    },
                    {
                        "username": "sk03167",
                        "content": "I love the discussion section. It's nice to see people in the same journey as you. I have never solved this question before but I know earlier I would written a whole ass recursive function, then optimized with memo. Now, it was intuitive that it's a 2d dp problem and how to write it. Took all but 11 lines of code to beat 90% both time and space."
                    },
                    {
                        "username": "Crispy_coffee",
                        "content": "Still TLE bmro"
                    },
                    {
                        "username": "cOde_Ranvir25",
                        "content": "# Here is an Approach :-)\\n**The problem statement is to find the minimum path sum from the top-left corner to the bottom-right corner of a grid, where each cell in the grid has a non-negative integer value. The path can only move down or right at each step.**\\n\\n- We can use dynamic programming to solve this problem efficiently. We will create a 2D array dp of the same size as the input grid, where each cell dp[i][j] represents the minimum path sum from the top-left corner to cell (i, j).\\n\\n- We can initialize the dp array as follows:\\n\\n1. dp[0][0] = grid[0][0] since the minimum path sum to the top-left corner is the value of the top-left cell.\\n2. For the first row i=0 and first column j=0 < j < n, the minimum path sum can only be reached by moving right or down from the previous cell. So, we can compute dp[0][j] = dp[0][j-1] + grid[0][j] and dp[i][0] = dp[i-1][0] + grid[i][0] respectively.\\n3. For the rest of the cells, we can compute the minimum path sum as follows:\\ndp[i][j] = grid[i][j] + min(dp[i-1][j], dp[i][j-1]) since we can reach the current cell from the cell above or the cell to the left, and we want to take the path with the minimum sum.\\n- Once we have filled the dp array, the minimum path sum to the bottom-right corner will be dp[m-1][n-1], where m is the number of rows and n is the number of columns of the input grid.\\n\\n**The time complexity of this approach is O(mn) since we visit each cell once. The space complexity is also O(mn) since we use the dp array to store the intermediate results.**"
                    },
                    {
                        "username": "user5400vw",
                        "content": "good explanation.  the original grid can also act as your dp table."
                    },
                    {
                        "username": "cOde_Ranvir25",
                        "content": "***Here is the code link for reference:-)***\\nhttps://leetcode.com/problems/minimum-path-sum/solutions/2887704/easiest-solution/"
                    },
                    {
                        "username": "zaim",
                        "content": "On input \\n[[5,4,2,9,6,0,3,5,1,4,9,8,4,9,7,5,1],\\n [3,4,9,2,9,9,0,9,7,9,4,7,8,4,4,5,8],\\n [6,1,8,9,8,0,3,7,0,9,8,7,4,9,2,0,1],\\n [4,0,0,5,1,7,4,7,6,4,1,0,1,0,6,2,8],\\n [7,2,0,2,9,3,4,7,0,8,9,5,9,0,1,1,0],\\n [8,2,9,4,9,7,9,3,7,0,3,6,5,3,5,9,6],\\n [8,9,9,2,6,1,2,5,8,3,7,0,4,9,8,8,8],\\n [5,8,5,4,1,5,6,6,3,3,1,8,3,9,6,4,8],\\n [0,2,2,3,0,2,6,7,2,3,7,3,1,5,8,1,3],\\n [4,4,0,2,0,3,8,4,1,3,3,0,7,4,2,9,8],\\n [5,9,0,4,7,5,7,6,0,8,3,0,0,6,6,6,8],\\n [0,7,1,8,3,5,1,8,7,0,2,9,2,2,7,1,5],\\n [1,0,0,0,6,2,0,0,2,2,8,0,9,7,0,8,0],\\n [1,1,7,2,9,6,5,4,8,7,8,5,0,3,8,1,5],\\n [8,9,7,8,1,1,3,0,1,2,9,4,0,1,5,3,1],\\n [9,2,7,4,8,7,3,9,2,4,2,2,7,8,2,6,7],\\n [3,8,1,6,0,4,8,9,8,0,2,5,3,5,5,7,5],\\n [1,8,2,5,7,7,1,9,9,8,9,2,4,9,5,4,0],\\n [3,4,4,1,5,3,3,8,8,6,3,5,3,8,7,1,3]]\\n\\nckeckers solution is 82, but mine is is 79 with the following path:\\n\\n[05] 04  02  09  06  00  03  05  01  04  09  08  04  09  07  05  01 \\n\\n[03][04] 09  02  09  09  00  09  07  09  04  07  08  04  04  05  08 \\n\\n 06 [01] 08  09  08  00  03  07  00  09  08  07  04  09  02  00  01 \\n\\n 04 [00][00] 05  01  07  04  07  06  04  01  00  01  00  06  02  08 \\n\\n 07  02 [00][02] 09  03  04  07  00  08  09  05  09  00  01  01  00 \\n\\n 08  02  09 [04] 09  07  09  03  07  00  03  06  05  03  05  09  06 \\n\\n 08  09  09 [02] 06  01  02  05  08  03  07  00  04  09  08  08  08 \\n\\n 05  08  05 [04][01] 05  06  06  03  03  01  08  03  09  06  04  08 \\n\\n 00  02  02  03 [00] 02  06  07  02  03  07  03  01  05  08  01  03 \\n\\n 04  04 [00][02][00] 03  08  04  01  03  03  00  07  04  02  09  08 \\n\\n 05  09 [00] 04  07  05  07  06  00  08  03  00  00  06  06  06  08 \\n\\n 00  07 [01] 08  03  05  01  08  07  00  02  09  02  02  07  01  05 \\n\\n 01  00 [00][00][06][02][00][00][02][02][08][00] 09  07  00  08  00 \\n\\n 01  01  07  02  09  06  05  04  08  07  08 [05][00] 03  08  01  05 \\n\\n 08  09  07  08  01  01  03  00  01  02  09  04 [00][01][05][03][01]\\n\\n 09  02  07  04  08  07  03  09  02  04  02  02  07  08  02  06 [07]\\n\\n 03  08  01  06  00  04  08  09  08  00  02  05  03  05  05  07 [05]\\n\\n 01  08  02  05  07  07  01  09  09  08  09  02  04  09  05  04 [00]\\n\\n 03  04  04  01  05  03  03  08  08  06  03  05  03  08  07  01 [03]\\n\\nDoes anyone have a suggestion what I am doing wrong?"
                    },
                    {
                        "username": "LucidLynxxx",
                        "content": "I believe it is illlegal to move back, which you do? \"Note: You can only move either down or right at any point in time.\""
                    },
                    {
                        "username": "red_akb",
                        "content": "See 10th line, you\\'re moving left\\n\\nBut it is clearly mentioned in que that ->\\n\\n\"Note: You can only move either down or right at any point in time.\"\\n\\nSo if you\\'re doing by recursion, only use two operations as move_right, or move_down."
                    },
                    {
                        "username": "Shaa-Khan",
                        "content": "you can move only down and right"
                    },
                    {
                        "username": "Aman_gupta-9833",
                        "content": "hats off for these much long query buddy"
                    },
                    {
                        "username": "conrad001",
                        "content": "The problem statement says you are only allowed to move right or down but in your solution the path moves left at some point too. That is the problem with your solution."
                    },
                    {
                        "username": "Heyns95",
                        "content": "I also get 79. How do we notify leetcode?"
                    },
                    {
                        "username": "adriankuehn",
                        "content": "Yip, same here for me for testcase 56/61. I solved it by only allowing the BFS to go down and right as mentioned in the task. Then I get 82 instead of 79. But the path for 79 looks correct for me as well. "
                    },
                    {
                        "username": "jamesh",
                        "content": "Such as:\\n\\n    1, 9, 1, 1, 1\\n    1, 1, 1, 9, 1\\n\\nAll the 1's form the minimum path."
                    },
                    {
                        "username": "Earth-Turtle",
                        "content": "There\\'s a clarification in the description that you can only move down or right"
                    },
                    {
                        "username": "psionl0",
                        "content": "After yesterday\\'s problem, it is nice to be able to just code an answer and have it pass all test cases right off the bat without even any syntax errors."
                    },
                    {
                        "username": "tensionstate",
                        "content": "I understand that in some shortest path algorithms on general node weighted graphs, negative cycles lead to non-termination, but here I do not see any problem, so why does the question state that the weights are not negative?"
                    },
                    {
                        "username": "AdityaBhate",
                        "content": "# \\uD83D\\uDCCC C++ || Recursion , DP - Memoization, Tabulation + Space Optimization\\nhttps://leetcode.com/problems/minimum-path-sum/solutions/3117215/c-recursion-dp-memoization-tabulation-space-optimization/?orderBy=hot"
                    },
                    {
                        "username": "ShadyCoder",
                        "content": "What if the follow-up question is how do you store the path information that gives the minimum pathsum? Any ideas about how we can achieve that in a better design perspective?"
                    },
                    {
                        "username": "mayank_pant",
                        "content": "backtracking using the created dp array. "
                    },
                    {
                        "username": "neel19",
                        "content": "Go in reverse order like we do LCS i.e, from $dp[row-1][col-1]$ keep going till cell $dp[0][0]$. "
                    },
                    {
                        "username": "alpharomeo99",
                        "content": "Apart from the solutions mentioned one can just start from the source after creating the dp array. From source move greedily towards the the cell that has the minimum path sum to the destination and accordingly update the path. This will take O(N) time."
                    },
                    {
                        "username": "keshav97",
                        "content": "use recursion we have 2 choices either go right or go down"
                    },
                    {
                        "username": "kushalnagwanshicloud",
                        "content": "I did this -> \\nhttps://leetcode.com/problems/minimum-path-sum/solutions/2819398/how-to-print-the-path-if-asked/"
                    },
                    {
                        "username": "f20200445",
                        "content": "Can someone explain why this is giving me TLE only on the last testcase? I could do tabulation but memoization is giving TLE.\\n\\n    int f(int i,int j,int m,int n,vector<vector<int>> grid,vector<vector<int>> &dp) {\\n        if(i==m-1 && j==n-1) {\\n            return grid[i][j];\\n        }\\n\\n        if(dp[i][j]!=-1) {\\n            return dp[i][j];\\n        }\\n\\n        if(i==m-1) {\\n            return dp[i][j]=grid[i][j]+f(i,j+1,m,n,grid,dp);\\n        }\\n        else if(j==n-1) {\\n            return dp[i][j]=grid[i][j]+f(i+1,j,m,n,grid,dp);\\n        }\\n\\n        return dp[i][j]=grid[i][j] + min(f(i,j+1,m,n,grid,dp),f(i+1,j,m,n,grid,dp));\\n    }\\n    int minPathSum(vector<vector<int>>& grid) {\\n        int m = grid.size();\\n        int n = grid[0].size();\\n        vector<vector<int>> dp(m,vector<int>(n,-1));\\n        return f(0,0,m,n,grid,dp);\\n    }"
                    },
                    {
                        "username": "oops_moment",
                        "content": "Hey even i did the same way, it will pass . Just pass through reference since otherwise multiple copies are created hence increasing time complexity of code. \\nHope it clears the doubt"
                    },
                    {
                        "username": "ee20b053",
                        "content": "in function \\'f\\' pass the matrix grid by reference to further reduce time complexity\\n"
                    },
                    {
                        "username": "viku_kr",
                        "content": "Instead of doing recursively, this question can be done iteratively. Leave the first row and first column, then for all other positions best way to move there is from minimum of (i-1,j) or (i, j-1)"
                    }
                ]
            },
            {
                "id": 1567830,
                "content": [
                    {
                        "username": "_srahul_",
                        "content": "Friendship ended with graph, now DP is my best friend."
                    },
                    {
                        "username": "user4401w",
                        "content": "XD\\n"
                    },
                    {
                        "username": "codeMonarch",
                        "content": "agree++;\\n"
                    },
                    {
                        "username": "daring-calf",
                        "content": "When I first met this problem 8 months ago it was so hard and frustrating, I spent a whole night and didn\\'t quite get it even after watching the solutions. And today it only took 5 minutes to write.\\nTo all the noobcoders out there: it always hurts the first time; but hang in there, eventually you\\'ll enjoy it."
                    },
                    {
                        "username": "bhuppidhamii",
                        "content": "right bro."
                    },
                    {
                        "username": "kartikey_wariyal",
                        "content": "i too cant solve right now\\n"
                    },
                    {
                        "username": "diabloexodia",
                        "content": "I believe in the heart of the algorithms"
                    },
                    {
                        "username": "sk03167",
                        "content": "I love the discussion section. It's nice to see people in the same journey as you. I have never solved this question before but I know earlier I would written a whole ass recursive function, then optimized with memo. Now, it was intuitive that it's a 2d dp problem and how to write it. Took all but 11 lines of code to beat 90% both time and space."
                    },
                    {
                        "username": "Crispy_coffee",
                        "content": "Still TLE bmro"
                    },
                    {
                        "username": "cOde_Ranvir25",
                        "content": "# Here is an Approach :-)\\n**The problem statement is to find the minimum path sum from the top-left corner to the bottom-right corner of a grid, where each cell in the grid has a non-negative integer value. The path can only move down or right at each step.**\\n\\n- We can use dynamic programming to solve this problem efficiently. We will create a 2D array dp of the same size as the input grid, where each cell dp[i][j] represents the minimum path sum from the top-left corner to cell (i, j).\\n\\n- We can initialize the dp array as follows:\\n\\n1. dp[0][0] = grid[0][0] since the minimum path sum to the top-left corner is the value of the top-left cell.\\n2. For the first row i=0 and first column j=0 < j < n, the minimum path sum can only be reached by moving right or down from the previous cell. So, we can compute dp[0][j] = dp[0][j-1] + grid[0][j] and dp[i][0] = dp[i-1][0] + grid[i][0] respectively.\\n3. For the rest of the cells, we can compute the minimum path sum as follows:\\ndp[i][j] = grid[i][j] + min(dp[i-1][j], dp[i][j-1]) since we can reach the current cell from the cell above or the cell to the left, and we want to take the path with the minimum sum.\\n- Once we have filled the dp array, the minimum path sum to the bottom-right corner will be dp[m-1][n-1], where m is the number of rows and n is the number of columns of the input grid.\\n\\n**The time complexity of this approach is O(mn) since we visit each cell once. The space complexity is also O(mn) since we use the dp array to store the intermediate results.**"
                    },
                    {
                        "username": "user5400vw",
                        "content": "good explanation.  the original grid can also act as your dp table."
                    },
                    {
                        "username": "cOde_Ranvir25",
                        "content": "***Here is the code link for reference:-)***\\nhttps://leetcode.com/problems/minimum-path-sum/solutions/2887704/easiest-solution/"
                    },
                    {
                        "username": "zaim",
                        "content": "On input \\n[[5,4,2,9,6,0,3,5,1,4,9,8,4,9,7,5,1],\\n [3,4,9,2,9,9,0,9,7,9,4,7,8,4,4,5,8],\\n [6,1,8,9,8,0,3,7,0,9,8,7,4,9,2,0,1],\\n [4,0,0,5,1,7,4,7,6,4,1,0,1,0,6,2,8],\\n [7,2,0,2,9,3,4,7,0,8,9,5,9,0,1,1,0],\\n [8,2,9,4,9,7,9,3,7,0,3,6,5,3,5,9,6],\\n [8,9,9,2,6,1,2,5,8,3,7,0,4,9,8,8,8],\\n [5,8,5,4,1,5,6,6,3,3,1,8,3,9,6,4,8],\\n [0,2,2,3,0,2,6,7,2,3,7,3,1,5,8,1,3],\\n [4,4,0,2,0,3,8,4,1,3,3,0,7,4,2,9,8],\\n [5,9,0,4,7,5,7,6,0,8,3,0,0,6,6,6,8],\\n [0,7,1,8,3,5,1,8,7,0,2,9,2,2,7,1,5],\\n [1,0,0,0,6,2,0,0,2,2,8,0,9,7,0,8,0],\\n [1,1,7,2,9,6,5,4,8,7,8,5,0,3,8,1,5],\\n [8,9,7,8,1,1,3,0,1,2,9,4,0,1,5,3,1],\\n [9,2,7,4,8,7,3,9,2,4,2,2,7,8,2,6,7],\\n [3,8,1,6,0,4,8,9,8,0,2,5,3,5,5,7,5],\\n [1,8,2,5,7,7,1,9,9,8,9,2,4,9,5,4,0],\\n [3,4,4,1,5,3,3,8,8,6,3,5,3,8,7,1,3]]\\n\\nckeckers solution is 82, but mine is is 79 with the following path:\\n\\n[05] 04  02  09  06  00  03  05  01  04  09  08  04  09  07  05  01 \\n\\n[03][04] 09  02  09  09  00  09  07  09  04  07  08  04  04  05  08 \\n\\n 06 [01] 08  09  08  00  03  07  00  09  08  07  04  09  02  00  01 \\n\\n 04 [00][00] 05  01  07  04  07  06  04  01  00  01  00  06  02  08 \\n\\n 07  02 [00][02] 09  03  04  07  00  08  09  05  09  00  01  01  00 \\n\\n 08  02  09 [04] 09  07  09  03  07  00  03  06  05  03  05  09  06 \\n\\n 08  09  09 [02] 06  01  02  05  08  03  07  00  04  09  08  08  08 \\n\\n 05  08  05 [04][01] 05  06  06  03  03  01  08  03  09  06  04  08 \\n\\n 00  02  02  03 [00] 02  06  07  02  03  07  03  01  05  08  01  03 \\n\\n 04  04 [00][02][00] 03  08  04  01  03  03  00  07  04  02  09  08 \\n\\n 05  09 [00] 04  07  05  07  06  00  08  03  00  00  06  06  06  08 \\n\\n 00  07 [01] 08  03  05  01  08  07  00  02  09  02  02  07  01  05 \\n\\n 01  00 [00][00][06][02][00][00][02][02][08][00] 09  07  00  08  00 \\n\\n 01  01  07  02  09  06  05  04  08  07  08 [05][00] 03  08  01  05 \\n\\n 08  09  07  08  01  01  03  00  01  02  09  04 [00][01][05][03][01]\\n\\n 09  02  07  04  08  07  03  09  02  04  02  02  07  08  02  06 [07]\\n\\n 03  08  01  06  00  04  08  09  08  00  02  05  03  05  05  07 [05]\\n\\n 01  08  02  05  07  07  01  09  09  08  09  02  04  09  05  04 [00]\\n\\n 03  04  04  01  05  03  03  08  08  06  03  05  03  08  07  01 [03]\\n\\nDoes anyone have a suggestion what I am doing wrong?"
                    },
                    {
                        "username": "LucidLynxxx",
                        "content": "I believe it is illlegal to move back, which you do? \"Note: You can only move either down or right at any point in time.\""
                    },
                    {
                        "username": "red_akb",
                        "content": "See 10th line, you\\'re moving left\\n\\nBut it is clearly mentioned in que that ->\\n\\n\"Note: You can only move either down or right at any point in time.\"\\n\\nSo if you\\'re doing by recursion, only use two operations as move_right, or move_down."
                    },
                    {
                        "username": "Shaa-Khan",
                        "content": "you can move only down and right"
                    },
                    {
                        "username": "Aman_gupta-9833",
                        "content": "hats off for these much long query buddy"
                    },
                    {
                        "username": "conrad001",
                        "content": "The problem statement says you are only allowed to move right or down but in your solution the path moves left at some point too. That is the problem with your solution."
                    },
                    {
                        "username": "Heyns95",
                        "content": "I also get 79. How do we notify leetcode?"
                    },
                    {
                        "username": "adriankuehn",
                        "content": "Yip, same here for me for testcase 56/61. I solved it by only allowing the BFS to go down and right as mentioned in the task. Then I get 82 instead of 79. But the path for 79 looks correct for me as well. "
                    },
                    {
                        "username": "jamesh",
                        "content": "Such as:\\n\\n    1, 9, 1, 1, 1\\n    1, 1, 1, 9, 1\\n\\nAll the 1's form the minimum path."
                    },
                    {
                        "username": "Earth-Turtle",
                        "content": "There\\'s a clarification in the description that you can only move down or right"
                    },
                    {
                        "username": "psionl0",
                        "content": "After yesterday\\'s problem, it is nice to be able to just code an answer and have it pass all test cases right off the bat without even any syntax errors."
                    },
                    {
                        "username": "tensionstate",
                        "content": "I understand that in some shortest path algorithms on general node weighted graphs, negative cycles lead to non-termination, but here I do not see any problem, so why does the question state that the weights are not negative?"
                    },
                    {
                        "username": "AdityaBhate",
                        "content": "# \\uD83D\\uDCCC C++ || Recursion , DP - Memoization, Tabulation + Space Optimization\\nhttps://leetcode.com/problems/minimum-path-sum/solutions/3117215/c-recursion-dp-memoization-tabulation-space-optimization/?orderBy=hot"
                    },
                    {
                        "username": "ShadyCoder",
                        "content": "What if the follow-up question is how do you store the path information that gives the minimum pathsum? Any ideas about how we can achieve that in a better design perspective?"
                    },
                    {
                        "username": "mayank_pant",
                        "content": "backtracking using the created dp array. "
                    },
                    {
                        "username": "neel19",
                        "content": "Go in reverse order like we do LCS i.e, from $dp[row-1][col-1]$ keep going till cell $dp[0][0]$. "
                    },
                    {
                        "username": "alpharomeo99",
                        "content": "Apart from the solutions mentioned one can just start from the source after creating the dp array. From source move greedily towards the the cell that has the minimum path sum to the destination and accordingly update the path. This will take O(N) time."
                    },
                    {
                        "username": "keshav97",
                        "content": "use recursion we have 2 choices either go right or go down"
                    },
                    {
                        "username": "kushalnagwanshicloud",
                        "content": "I did this -> \\nhttps://leetcode.com/problems/minimum-path-sum/solutions/2819398/how-to-print-the-path-if-asked/"
                    },
                    {
                        "username": "f20200445",
                        "content": "Can someone explain why this is giving me TLE only on the last testcase? I could do tabulation but memoization is giving TLE.\\n\\n    int f(int i,int j,int m,int n,vector<vector<int>> grid,vector<vector<int>> &dp) {\\n        if(i==m-1 && j==n-1) {\\n            return grid[i][j];\\n        }\\n\\n        if(dp[i][j]!=-1) {\\n            return dp[i][j];\\n        }\\n\\n        if(i==m-1) {\\n            return dp[i][j]=grid[i][j]+f(i,j+1,m,n,grid,dp);\\n        }\\n        else if(j==n-1) {\\n            return dp[i][j]=grid[i][j]+f(i+1,j,m,n,grid,dp);\\n        }\\n\\n        return dp[i][j]=grid[i][j] + min(f(i,j+1,m,n,grid,dp),f(i+1,j,m,n,grid,dp));\\n    }\\n    int minPathSum(vector<vector<int>>& grid) {\\n        int m = grid.size();\\n        int n = grid[0].size();\\n        vector<vector<int>> dp(m,vector<int>(n,-1));\\n        return f(0,0,m,n,grid,dp);\\n    }"
                    },
                    {
                        "username": "oops_moment",
                        "content": "Hey even i did the same way, it will pass . Just pass through reference since otherwise multiple copies are created hence increasing time complexity of code. \\nHope it clears the doubt"
                    },
                    {
                        "username": "ee20b053",
                        "content": "in function \\'f\\' pass the matrix grid by reference to further reduce time complexity\\n"
                    },
                    {
                        "username": "viku_kr",
                        "content": "Instead of doing recursively, this question can be done iteratively. Leave the first row and first column, then for all other positions best way to move there is from minimum of (i-1,j) or (i, j-1)"
                    }
                ]
            },
            {
                "id": 1780572,
                "content": [
                    {
                        "username": "_srahul_",
                        "content": "Friendship ended with graph, now DP is my best friend."
                    },
                    {
                        "username": "user4401w",
                        "content": "XD\\n"
                    },
                    {
                        "username": "codeMonarch",
                        "content": "agree++;\\n"
                    },
                    {
                        "username": "daring-calf",
                        "content": "When I first met this problem 8 months ago it was so hard and frustrating, I spent a whole night and didn\\'t quite get it even after watching the solutions. And today it only took 5 minutes to write.\\nTo all the noobcoders out there: it always hurts the first time; but hang in there, eventually you\\'ll enjoy it."
                    },
                    {
                        "username": "bhuppidhamii",
                        "content": "right bro."
                    },
                    {
                        "username": "kartikey_wariyal",
                        "content": "i too cant solve right now\\n"
                    },
                    {
                        "username": "diabloexodia",
                        "content": "I believe in the heart of the algorithms"
                    },
                    {
                        "username": "sk03167",
                        "content": "I love the discussion section. It's nice to see people in the same journey as you. I have never solved this question before but I know earlier I would written a whole ass recursive function, then optimized with memo. Now, it was intuitive that it's a 2d dp problem and how to write it. Took all but 11 lines of code to beat 90% both time and space."
                    },
                    {
                        "username": "Crispy_coffee",
                        "content": "Still TLE bmro"
                    },
                    {
                        "username": "cOde_Ranvir25",
                        "content": "# Here is an Approach :-)\\n**The problem statement is to find the minimum path sum from the top-left corner to the bottom-right corner of a grid, where each cell in the grid has a non-negative integer value. The path can only move down or right at each step.**\\n\\n- We can use dynamic programming to solve this problem efficiently. We will create a 2D array dp of the same size as the input grid, where each cell dp[i][j] represents the minimum path sum from the top-left corner to cell (i, j).\\n\\n- We can initialize the dp array as follows:\\n\\n1. dp[0][0] = grid[0][0] since the minimum path sum to the top-left corner is the value of the top-left cell.\\n2. For the first row i=0 and first column j=0 < j < n, the minimum path sum can only be reached by moving right or down from the previous cell. So, we can compute dp[0][j] = dp[0][j-1] + grid[0][j] and dp[i][0] = dp[i-1][0] + grid[i][0] respectively.\\n3. For the rest of the cells, we can compute the minimum path sum as follows:\\ndp[i][j] = grid[i][j] + min(dp[i-1][j], dp[i][j-1]) since we can reach the current cell from the cell above or the cell to the left, and we want to take the path with the minimum sum.\\n- Once we have filled the dp array, the minimum path sum to the bottom-right corner will be dp[m-1][n-1], where m is the number of rows and n is the number of columns of the input grid.\\n\\n**The time complexity of this approach is O(mn) since we visit each cell once. The space complexity is also O(mn) since we use the dp array to store the intermediate results.**"
                    },
                    {
                        "username": "user5400vw",
                        "content": "good explanation.  the original grid can also act as your dp table."
                    },
                    {
                        "username": "cOde_Ranvir25",
                        "content": "***Here is the code link for reference:-)***\\nhttps://leetcode.com/problems/minimum-path-sum/solutions/2887704/easiest-solution/"
                    },
                    {
                        "username": "zaim",
                        "content": "On input \\n[[5,4,2,9,6,0,3,5,1,4,9,8,4,9,7,5,1],\\n [3,4,9,2,9,9,0,9,7,9,4,7,8,4,4,5,8],\\n [6,1,8,9,8,0,3,7,0,9,8,7,4,9,2,0,1],\\n [4,0,0,5,1,7,4,7,6,4,1,0,1,0,6,2,8],\\n [7,2,0,2,9,3,4,7,0,8,9,5,9,0,1,1,0],\\n [8,2,9,4,9,7,9,3,7,0,3,6,5,3,5,9,6],\\n [8,9,9,2,6,1,2,5,8,3,7,0,4,9,8,8,8],\\n [5,8,5,4,1,5,6,6,3,3,1,8,3,9,6,4,8],\\n [0,2,2,3,0,2,6,7,2,3,7,3,1,5,8,1,3],\\n [4,4,0,2,0,3,8,4,1,3,3,0,7,4,2,9,8],\\n [5,9,0,4,7,5,7,6,0,8,3,0,0,6,6,6,8],\\n [0,7,1,8,3,5,1,8,7,0,2,9,2,2,7,1,5],\\n [1,0,0,0,6,2,0,0,2,2,8,0,9,7,0,8,0],\\n [1,1,7,2,9,6,5,4,8,7,8,5,0,3,8,1,5],\\n [8,9,7,8,1,1,3,0,1,2,9,4,0,1,5,3,1],\\n [9,2,7,4,8,7,3,9,2,4,2,2,7,8,2,6,7],\\n [3,8,1,6,0,4,8,9,8,0,2,5,3,5,5,7,5],\\n [1,8,2,5,7,7,1,9,9,8,9,2,4,9,5,4,0],\\n [3,4,4,1,5,3,3,8,8,6,3,5,3,8,7,1,3]]\\n\\nckeckers solution is 82, but mine is is 79 with the following path:\\n\\n[05] 04  02  09  06  00  03  05  01  04  09  08  04  09  07  05  01 \\n\\n[03][04] 09  02  09  09  00  09  07  09  04  07  08  04  04  05  08 \\n\\n 06 [01] 08  09  08  00  03  07  00  09  08  07  04  09  02  00  01 \\n\\n 04 [00][00] 05  01  07  04  07  06  04  01  00  01  00  06  02  08 \\n\\n 07  02 [00][02] 09  03  04  07  00  08  09  05  09  00  01  01  00 \\n\\n 08  02  09 [04] 09  07  09  03  07  00  03  06  05  03  05  09  06 \\n\\n 08  09  09 [02] 06  01  02  05  08  03  07  00  04  09  08  08  08 \\n\\n 05  08  05 [04][01] 05  06  06  03  03  01  08  03  09  06  04  08 \\n\\n 00  02  02  03 [00] 02  06  07  02  03  07  03  01  05  08  01  03 \\n\\n 04  04 [00][02][00] 03  08  04  01  03  03  00  07  04  02  09  08 \\n\\n 05  09 [00] 04  07  05  07  06  00  08  03  00  00  06  06  06  08 \\n\\n 00  07 [01] 08  03  05  01  08  07  00  02  09  02  02  07  01  05 \\n\\n 01  00 [00][00][06][02][00][00][02][02][08][00] 09  07  00  08  00 \\n\\n 01  01  07  02  09  06  05  04  08  07  08 [05][00] 03  08  01  05 \\n\\n 08  09  07  08  01  01  03  00  01  02  09  04 [00][01][05][03][01]\\n\\n 09  02  07  04  08  07  03  09  02  04  02  02  07  08  02  06 [07]\\n\\n 03  08  01  06  00  04  08  09  08  00  02  05  03  05  05  07 [05]\\n\\n 01  08  02  05  07  07  01  09  09  08  09  02  04  09  05  04 [00]\\n\\n 03  04  04  01  05  03  03  08  08  06  03  05  03  08  07  01 [03]\\n\\nDoes anyone have a suggestion what I am doing wrong?"
                    },
                    {
                        "username": "LucidLynxxx",
                        "content": "I believe it is illlegal to move back, which you do? \"Note: You can only move either down or right at any point in time.\""
                    },
                    {
                        "username": "red_akb",
                        "content": "See 10th line, you\\'re moving left\\n\\nBut it is clearly mentioned in que that ->\\n\\n\"Note: You can only move either down or right at any point in time.\"\\n\\nSo if you\\'re doing by recursion, only use two operations as move_right, or move_down."
                    },
                    {
                        "username": "Shaa-Khan",
                        "content": "you can move only down and right"
                    },
                    {
                        "username": "Aman_gupta-9833",
                        "content": "hats off for these much long query buddy"
                    },
                    {
                        "username": "conrad001",
                        "content": "The problem statement says you are only allowed to move right or down but in your solution the path moves left at some point too. That is the problem with your solution."
                    },
                    {
                        "username": "Heyns95",
                        "content": "I also get 79. How do we notify leetcode?"
                    },
                    {
                        "username": "adriankuehn",
                        "content": "Yip, same here for me for testcase 56/61. I solved it by only allowing the BFS to go down and right as mentioned in the task. Then I get 82 instead of 79. But the path for 79 looks correct for me as well. "
                    },
                    {
                        "username": "jamesh",
                        "content": "Such as:\\n\\n    1, 9, 1, 1, 1\\n    1, 1, 1, 9, 1\\n\\nAll the 1's form the minimum path."
                    },
                    {
                        "username": "Earth-Turtle",
                        "content": "There\\'s a clarification in the description that you can only move down or right"
                    },
                    {
                        "username": "psionl0",
                        "content": "After yesterday\\'s problem, it is nice to be able to just code an answer and have it pass all test cases right off the bat without even any syntax errors."
                    },
                    {
                        "username": "tensionstate",
                        "content": "I understand that in some shortest path algorithms on general node weighted graphs, negative cycles lead to non-termination, but here I do not see any problem, so why does the question state that the weights are not negative?"
                    },
                    {
                        "username": "AdityaBhate",
                        "content": "# \\uD83D\\uDCCC C++ || Recursion , DP - Memoization, Tabulation + Space Optimization\\nhttps://leetcode.com/problems/minimum-path-sum/solutions/3117215/c-recursion-dp-memoization-tabulation-space-optimization/?orderBy=hot"
                    },
                    {
                        "username": "ShadyCoder",
                        "content": "What if the follow-up question is how do you store the path information that gives the minimum pathsum? Any ideas about how we can achieve that in a better design perspective?"
                    },
                    {
                        "username": "mayank_pant",
                        "content": "backtracking using the created dp array. "
                    },
                    {
                        "username": "neel19",
                        "content": "Go in reverse order like we do LCS i.e, from $dp[row-1][col-1]$ keep going till cell $dp[0][0]$. "
                    },
                    {
                        "username": "alpharomeo99",
                        "content": "Apart from the solutions mentioned one can just start from the source after creating the dp array. From source move greedily towards the the cell that has the minimum path sum to the destination and accordingly update the path. This will take O(N) time."
                    },
                    {
                        "username": "keshav97",
                        "content": "use recursion we have 2 choices either go right or go down"
                    },
                    {
                        "username": "kushalnagwanshicloud",
                        "content": "I did this -> \\nhttps://leetcode.com/problems/minimum-path-sum/solutions/2819398/how-to-print-the-path-if-asked/"
                    },
                    {
                        "username": "f20200445",
                        "content": "Can someone explain why this is giving me TLE only on the last testcase? I could do tabulation but memoization is giving TLE.\\n\\n    int f(int i,int j,int m,int n,vector<vector<int>> grid,vector<vector<int>> &dp) {\\n        if(i==m-1 && j==n-1) {\\n            return grid[i][j];\\n        }\\n\\n        if(dp[i][j]!=-1) {\\n            return dp[i][j];\\n        }\\n\\n        if(i==m-1) {\\n            return dp[i][j]=grid[i][j]+f(i,j+1,m,n,grid,dp);\\n        }\\n        else if(j==n-1) {\\n            return dp[i][j]=grid[i][j]+f(i+1,j,m,n,grid,dp);\\n        }\\n\\n        return dp[i][j]=grid[i][j] + min(f(i,j+1,m,n,grid,dp),f(i+1,j,m,n,grid,dp));\\n    }\\n    int minPathSum(vector<vector<int>>& grid) {\\n        int m = grid.size();\\n        int n = grid[0].size();\\n        vector<vector<int>> dp(m,vector<int>(n,-1));\\n        return f(0,0,m,n,grid,dp);\\n    }"
                    },
                    {
                        "username": "oops_moment",
                        "content": "Hey even i did the same way, it will pass . Just pass through reference since otherwise multiple copies are created hence increasing time complexity of code. \\nHope it clears the doubt"
                    },
                    {
                        "username": "ee20b053",
                        "content": "in function \\'f\\' pass the matrix grid by reference to further reduce time complexity\\n"
                    },
                    {
                        "username": "viku_kr",
                        "content": "Instead of doing recursively, this question can be done iteratively. Leave the first row and first column, then for all other positions best way to move there is from minimum of (i-1,j) or (i, j-1)"
                    }
                ]
            },
            {
                "id": 1569788,
                "content": [
                    {
                        "username": "_srahul_",
                        "content": "Friendship ended with graph, now DP is my best friend."
                    },
                    {
                        "username": "user4401w",
                        "content": "XD\\n"
                    },
                    {
                        "username": "codeMonarch",
                        "content": "agree++;\\n"
                    },
                    {
                        "username": "daring-calf",
                        "content": "When I first met this problem 8 months ago it was so hard and frustrating, I spent a whole night and didn\\'t quite get it even after watching the solutions. And today it only took 5 minutes to write.\\nTo all the noobcoders out there: it always hurts the first time; but hang in there, eventually you\\'ll enjoy it."
                    },
                    {
                        "username": "bhuppidhamii",
                        "content": "right bro."
                    },
                    {
                        "username": "kartikey_wariyal",
                        "content": "i too cant solve right now\\n"
                    },
                    {
                        "username": "diabloexodia",
                        "content": "I believe in the heart of the algorithms"
                    },
                    {
                        "username": "sk03167",
                        "content": "I love the discussion section. It's nice to see people in the same journey as you. I have never solved this question before but I know earlier I would written a whole ass recursive function, then optimized with memo. Now, it was intuitive that it's a 2d dp problem and how to write it. Took all but 11 lines of code to beat 90% both time and space."
                    },
                    {
                        "username": "Crispy_coffee",
                        "content": "Still TLE bmro"
                    },
                    {
                        "username": "cOde_Ranvir25",
                        "content": "# Here is an Approach :-)\\n**The problem statement is to find the minimum path sum from the top-left corner to the bottom-right corner of a grid, where each cell in the grid has a non-negative integer value. The path can only move down or right at each step.**\\n\\n- We can use dynamic programming to solve this problem efficiently. We will create a 2D array dp of the same size as the input grid, where each cell dp[i][j] represents the minimum path sum from the top-left corner to cell (i, j).\\n\\n- We can initialize the dp array as follows:\\n\\n1. dp[0][0] = grid[0][0] since the minimum path sum to the top-left corner is the value of the top-left cell.\\n2. For the first row i=0 and first column j=0 < j < n, the minimum path sum can only be reached by moving right or down from the previous cell. So, we can compute dp[0][j] = dp[0][j-1] + grid[0][j] and dp[i][0] = dp[i-1][0] + grid[i][0] respectively.\\n3. For the rest of the cells, we can compute the minimum path sum as follows:\\ndp[i][j] = grid[i][j] + min(dp[i-1][j], dp[i][j-1]) since we can reach the current cell from the cell above or the cell to the left, and we want to take the path with the minimum sum.\\n- Once we have filled the dp array, the minimum path sum to the bottom-right corner will be dp[m-1][n-1], where m is the number of rows and n is the number of columns of the input grid.\\n\\n**The time complexity of this approach is O(mn) since we visit each cell once. The space complexity is also O(mn) since we use the dp array to store the intermediate results.**"
                    },
                    {
                        "username": "user5400vw",
                        "content": "good explanation.  the original grid can also act as your dp table."
                    },
                    {
                        "username": "cOde_Ranvir25",
                        "content": "***Here is the code link for reference:-)***\\nhttps://leetcode.com/problems/minimum-path-sum/solutions/2887704/easiest-solution/"
                    },
                    {
                        "username": "zaim",
                        "content": "On input \\n[[5,4,2,9,6,0,3,5,1,4,9,8,4,9,7,5,1],\\n [3,4,9,2,9,9,0,9,7,9,4,7,8,4,4,5,8],\\n [6,1,8,9,8,0,3,7,0,9,8,7,4,9,2,0,1],\\n [4,0,0,5,1,7,4,7,6,4,1,0,1,0,6,2,8],\\n [7,2,0,2,9,3,4,7,0,8,9,5,9,0,1,1,0],\\n [8,2,9,4,9,7,9,3,7,0,3,6,5,3,5,9,6],\\n [8,9,9,2,6,1,2,5,8,3,7,0,4,9,8,8,8],\\n [5,8,5,4,1,5,6,6,3,3,1,8,3,9,6,4,8],\\n [0,2,2,3,0,2,6,7,2,3,7,3,1,5,8,1,3],\\n [4,4,0,2,0,3,8,4,1,3,3,0,7,4,2,9,8],\\n [5,9,0,4,7,5,7,6,0,8,3,0,0,6,6,6,8],\\n [0,7,1,8,3,5,1,8,7,0,2,9,2,2,7,1,5],\\n [1,0,0,0,6,2,0,0,2,2,8,0,9,7,0,8,0],\\n [1,1,7,2,9,6,5,4,8,7,8,5,0,3,8,1,5],\\n [8,9,7,8,1,1,3,0,1,2,9,4,0,1,5,3,1],\\n [9,2,7,4,8,7,3,9,2,4,2,2,7,8,2,6,7],\\n [3,8,1,6,0,4,8,9,8,0,2,5,3,5,5,7,5],\\n [1,8,2,5,7,7,1,9,9,8,9,2,4,9,5,4,0],\\n [3,4,4,1,5,3,3,8,8,6,3,5,3,8,7,1,3]]\\n\\nckeckers solution is 82, but mine is is 79 with the following path:\\n\\n[05] 04  02  09  06  00  03  05  01  04  09  08  04  09  07  05  01 \\n\\n[03][04] 09  02  09  09  00  09  07  09  04  07  08  04  04  05  08 \\n\\n 06 [01] 08  09  08  00  03  07  00  09  08  07  04  09  02  00  01 \\n\\n 04 [00][00] 05  01  07  04  07  06  04  01  00  01  00  06  02  08 \\n\\n 07  02 [00][02] 09  03  04  07  00  08  09  05  09  00  01  01  00 \\n\\n 08  02  09 [04] 09  07  09  03  07  00  03  06  05  03  05  09  06 \\n\\n 08  09  09 [02] 06  01  02  05  08  03  07  00  04  09  08  08  08 \\n\\n 05  08  05 [04][01] 05  06  06  03  03  01  08  03  09  06  04  08 \\n\\n 00  02  02  03 [00] 02  06  07  02  03  07  03  01  05  08  01  03 \\n\\n 04  04 [00][02][00] 03  08  04  01  03  03  00  07  04  02  09  08 \\n\\n 05  09 [00] 04  07  05  07  06  00  08  03  00  00  06  06  06  08 \\n\\n 00  07 [01] 08  03  05  01  08  07  00  02  09  02  02  07  01  05 \\n\\n 01  00 [00][00][06][02][00][00][02][02][08][00] 09  07  00  08  00 \\n\\n 01  01  07  02  09  06  05  04  08  07  08 [05][00] 03  08  01  05 \\n\\n 08  09  07  08  01  01  03  00  01  02  09  04 [00][01][05][03][01]\\n\\n 09  02  07  04  08  07  03  09  02  04  02  02  07  08  02  06 [07]\\n\\n 03  08  01  06  00  04  08  09  08  00  02  05  03  05  05  07 [05]\\n\\n 01  08  02  05  07  07  01  09  09  08  09  02  04  09  05  04 [00]\\n\\n 03  04  04  01  05  03  03  08  08  06  03  05  03  08  07  01 [03]\\n\\nDoes anyone have a suggestion what I am doing wrong?"
                    },
                    {
                        "username": "LucidLynxxx",
                        "content": "I believe it is illlegal to move back, which you do? \"Note: You can only move either down or right at any point in time.\""
                    },
                    {
                        "username": "red_akb",
                        "content": "See 10th line, you\\'re moving left\\n\\nBut it is clearly mentioned in que that ->\\n\\n\"Note: You can only move either down or right at any point in time.\"\\n\\nSo if you\\'re doing by recursion, only use two operations as move_right, or move_down."
                    },
                    {
                        "username": "Shaa-Khan",
                        "content": "you can move only down and right"
                    },
                    {
                        "username": "Aman_gupta-9833",
                        "content": "hats off for these much long query buddy"
                    },
                    {
                        "username": "conrad001",
                        "content": "The problem statement says you are only allowed to move right or down but in your solution the path moves left at some point too. That is the problem with your solution."
                    },
                    {
                        "username": "Heyns95",
                        "content": "I also get 79. How do we notify leetcode?"
                    },
                    {
                        "username": "adriankuehn",
                        "content": "Yip, same here for me for testcase 56/61. I solved it by only allowing the BFS to go down and right as mentioned in the task. Then I get 82 instead of 79. But the path for 79 looks correct for me as well. "
                    },
                    {
                        "username": "jamesh",
                        "content": "Such as:\\n\\n    1, 9, 1, 1, 1\\n    1, 1, 1, 9, 1\\n\\nAll the 1's form the minimum path."
                    },
                    {
                        "username": "Earth-Turtle",
                        "content": "There\\'s a clarification in the description that you can only move down or right"
                    },
                    {
                        "username": "psionl0",
                        "content": "After yesterday\\'s problem, it is nice to be able to just code an answer and have it pass all test cases right off the bat without even any syntax errors."
                    },
                    {
                        "username": "tensionstate",
                        "content": "I understand that in some shortest path algorithms on general node weighted graphs, negative cycles lead to non-termination, but here I do not see any problem, so why does the question state that the weights are not negative?"
                    },
                    {
                        "username": "AdityaBhate",
                        "content": "# \\uD83D\\uDCCC C++ || Recursion , DP - Memoization, Tabulation + Space Optimization\\nhttps://leetcode.com/problems/minimum-path-sum/solutions/3117215/c-recursion-dp-memoization-tabulation-space-optimization/?orderBy=hot"
                    },
                    {
                        "username": "ShadyCoder",
                        "content": "What if the follow-up question is how do you store the path information that gives the minimum pathsum? Any ideas about how we can achieve that in a better design perspective?"
                    },
                    {
                        "username": "mayank_pant",
                        "content": "backtracking using the created dp array. "
                    },
                    {
                        "username": "neel19",
                        "content": "Go in reverse order like we do LCS i.e, from $dp[row-1][col-1]$ keep going till cell $dp[0][0]$. "
                    },
                    {
                        "username": "alpharomeo99",
                        "content": "Apart from the solutions mentioned one can just start from the source after creating the dp array. From source move greedily towards the the cell that has the minimum path sum to the destination and accordingly update the path. This will take O(N) time."
                    },
                    {
                        "username": "keshav97",
                        "content": "use recursion we have 2 choices either go right or go down"
                    },
                    {
                        "username": "kushalnagwanshicloud",
                        "content": "I did this -> \\nhttps://leetcode.com/problems/minimum-path-sum/solutions/2819398/how-to-print-the-path-if-asked/"
                    },
                    {
                        "username": "f20200445",
                        "content": "Can someone explain why this is giving me TLE only on the last testcase? I could do tabulation but memoization is giving TLE.\\n\\n    int f(int i,int j,int m,int n,vector<vector<int>> grid,vector<vector<int>> &dp) {\\n        if(i==m-1 && j==n-1) {\\n            return grid[i][j];\\n        }\\n\\n        if(dp[i][j]!=-1) {\\n            return dp[i][j];\\n        }\\n\\n        if(i==m-1) {\\n            return dp[i][j]=grid[i][j]+f(i,j+1,m,n,grid,dp);\\n        }\\n        else if(j==n-1) {\\n            return dp[i][j]=grid[i][j]+f(i+1,j,m,n,grid,dp);\\n        }\\n\\n        return dp[i][j]=grid[i][j] + min(f(i,j+1,m,n,grid,dp),f(i+1,j,m,n,grid,dp));\\n    }\\n    int minPathSum(vector<vector<int>>& grid) {\\n        int m = grid.size();\\n        int n = grid[0].size();\\n        vector<vector<int>> dp(m,vector<int>(n,-1));\\n        return f(0,0,m,n,grid,dp);\\n    }"
                    },
                    {
                        "username": "oops_moment",
                        "content": "Hey even i did the same way, it will pass . Just pass through reference since otherwise multiple copies are created hence increasing time complexity of code. \\nHope it clears the doubt"
                    },
                    {
                        "username": "ee20b053",
                        "content": "in function \\'f\\' pass the matrix grid by reference to further reduce time complexity\\n"
                    },
                    {
                        "username": "viku_kr",
                        "content": "Instead of doing recursively, this question can be done iteratively. Leave the first row and first column, then for all other positions best way to move there is from minimum of (i-1,j) or (i, j-1)"
                    }
                ]
            },
            {
                "id": 1800731,
                "content": [
                    {
                        "username": "_srahul_",
                        "content": "Friendship ended with graph, now DP is my best friend."
                    },
                    {
                        "username": "user4401w",
                        "content": "XD\\n"
                    },
                    {
                        "username": "codeMonarch",
                        "content": "agree++;\\n"
                    },
                    {
                        "username": "daring-calf",
                        "content": "When I first met this problem 8 months ago it was so hard and frustrating, I spent a whole night and didn\\'t quite get it even after watching the solutions. And today it only took 5 minutes to write.\\nTo all the noobcoders out there: it always hurts the first time; but hang in there, eventually you\\'ll enjoy it."
                    },
                    {
                        "username": "bhuppidhamii",
                        "content": "right bro."
                    },
                    {
                        "username": "kartikey_wariyal",
                        "content": "i too cant solve right now\\n"
                    },
                    {
                        "username": "diabloexodia",
                        "content": "I believe in the heart of the algorithms"
                    },
                    {
                        "username": "sk03167",
                        "content": "I love the discussion section. It's nice to see people in the same journey as you. I have never solved this question before but I know earlier I would written a whole ass recursive function, then optimized with memo. Now, it was intuitive that it's a 2d dp problem and how to write it. Took all but 11 lines of code to beat 90% both time and space."
                    },
                    {
                        "username": "Crispy_coffee",
                        "content": "Still TLE bmro"
                    },
                    {
                        "username": "cOde_Ranvir25",
                        "content": "# Here is an Approach :-)\\n**The problem statement is to find the minimum path sum from the top-left corner to the bottom-right corner of a grid, where each cell in the grid has a non-negative integer value. The path can only move down or right at each step.**\\n\\n- We can use dynamic programming to solve this problem efficiently. We will create a 2D array dp of the same size as the input grid, where each cell dp[i][j] represents the minimum path sum from the top-left corner to cell (i, j).\\n\\n- We can initialize the dp array as follows:\\n\\n1. dp[0][0] = grid[0][0] since the minimum path sum to the top-left corner is the value of the top-left cell.\\n2. For the first row i=0 and first column j=0 < j < n, the minimum path sum can only be reached by moving right or down from the previous cell. So, we can compute dp[0][j] = dp[0][j-1] + grid[0][j] and dp[i][0] = dp[i-1][0] + grid[i][0] respectively.\\n3. For the rest of the cells, we can compute the minimum path sum as follows:\\ndp[i][j] = grid[i][j] + min(dp[i-1][j], dp[i][j-1]) since we can reach the current cell from the cell above or the cell to the left, and we want to take the path with the minimum sum.\\n- Once we have filled the dp array, the minimum path sum to the bottom-right corner will be dp[m-1][n-1], where m is the number of rows and n is the number of columns of the input grid.\\n\\n**The time complexity of this approach is O(mn) since we visit each cell once. The space complexity is also O(mn) since we use the dp array to store the intermediate results.**"
                    },
                    {
                        "username": "user5400vw",
                        "content": "good explanation.  the original grid can also act as your dp table."
                    },
                    {
                        "username": "cOde_Ranvir25",
                        "content": "***Here is the code link for reference:-)***\\nhttps://leetcode.com/problems/minimum-path-sum/solutions/2887704/easiest-solution/"
                    },
                    {
                        "username": "zaim",
                        "content": "On input \\n[[5,4,2,9,6,0,3,5,1,4,9,8,4,9,7,5,1],\\n [3,4,9,2,9,9,0,9,7,9,4,7,8,4,4,5,8],\\n [6,1,8,9,8,0,3,7,0,9,8,7,4,9,2,0,1],\\n [4,0,0,5,1,7,4,7,6,4,1,0,1,0,6,2,8],\\n [7,2,0,2,9,3,4,7,0,8,9,5,9,0,1,1,0],\\n [8,2,9,4,9,7,9,3,7,0,3,6,5,3,5,9,6],\\n [8,9,9,2,6,1,2,5,8,3,7,0,4,9,8,8,8],\\n [5,8,5,4,1,5,6,6,3,3,1,8,3,9,6,4,8],\\n [0,2,2,3,0,2,6,7,2,3,7,3,1,5,8,1,3],\\n [4,4,0,2,0,3,8,4,1,3,3,0,7,4,2,9,8],\\n [5,9,0,4,7,5,7,6,0,8,3,0,0,6,6,6,8],\\n [0,7,1,8,3,5,1,8,7,0,2,9,2,2,7,1,5],\\n [1,0,0,0,6,2,0,0,2,2,8,0,9,7,0,8,0],\\n [1,1,7,2,9,6,5,4,8,7,8,5,0,3,8,1,5],\\n [8,9,7,8,1,1,3,0,1,2,9,4,0,1,5,3,1],\\n [9,2,7,4,8,7,3,9,2,4,2,2,7,8,2,6,7],\\n [3,8,1,6,0,4,8,9,8,0,2,5,3,5,5,7,5],\\n [1,8,2,5,7,7,1,9,9,8,9,2,4,9,5,4,0],\\n [3,4,4,1,5,3,3,8,8,6,3,5,3,8,7,1,3]]\\n\\nckeckers solution is 82, but mine is is 79 with the following path:\\n\\n[05] 04  02  09  06  00  03  05  01  04  09  08  04  09  07  05  01 \\n\\n[03][04] 09  02  09  09  00  09  07  09  04  07  08  04  04  05  08 \\n\\n 06 [01] 08  09  08  00  03  07  00  09  08  07  04  09  02  00  01 \\n\\n 04 [00][00] 05  01  07  04  07  06  04  01  00  01  00  06  02  08 \\n\\n 07  02 [00][02] 09  03  04  07  00  08  09  05  09  00  01  01  00 \\n\\n 08  02  09 [04] 09  07  09  03  07  00  03  06  05  03  05  09  06 \\n\\n 08  09  09 [02] 06  01  02  05  08  03  07  00  04  09  08  08  08 \\n\\n 05  08  05 [04][01] 05  06  06  03  03  01  08  03  09  06  04  08 \\n\\n 00  02  02  03 [00] 02  06  07  02  03  07  03  01  05  08  01  03 \\n\\n 04  04 [00][02][00] 03  08  04  01  03  03  00  07  04  02  09  08 \\n\\n 05  09 [00] 04  07  05  07  06  00  08  03  00  00  06  06  06  08 \\n\\n 00  07 [01] 08  03  05  01  08  07  00  02  09  02  02  07  01  05 \\n\\n 01  00 [00][00][06][02][00][00][02][02][08][00] 09  07  00  08  00 \\n\\n 01  01  07  02  09  06  05  04  08  07  08 [05][00] 03  08  01  05 \\n\\n 08  09  07  08  01  01  03  00  01  02  09  04 [00][01][05][03][01]\\n\\n 09  02  07  04  08  07  03  09  02  04  02  02  07  08  02  06 [07]\\n\\n 03  08  01  06  00  04  08  09  08  00  02  05  03  05  05  07 [05]\\n\\n 01  08  02  05  07  07  01  09  09  08  09  02  04  09  05  04 [00]\\n\\n 03  04  04  01  05  03  03  08  08  06  03  05  03  08  07  01 [03]\\n\\nDoes anyone have a suggestion what I am doing wrong?"
                    },
                    {
                        "username": "LucidLynxxx",
                        "content": "I believe it is illlegal to move back, which you do? \"Note: You can only move either down or right at any point in time.\""
                    },
                    {
                        "username": "red_akb",
                        "content": "See 10th line, you\\'re moving left\\n\\nBut it is clearly mentioned in que that ->\\n\\n\"Note: You can only move either down or right at any point in time.\"\\n\\nSo if you\\'re doing by recursion, only use two operations as move_right, or move_down."
                    },
                    {
                        "username": "Shaa-Khan",
                        "content": "you can move only down and right"
                    },
                    {
                        "username": "Aman_gupta-9833",
                        "content": "hats off for these much long query buddy"
                    },
                    {
                        "username": "conrad001",
                        "content": "The problem statement says you are only allowed to move right or down but in your solution the path moves left at some point too. That is the problem with your solution."
                    },
                    {
                        "username": "Heyns95",
                        "content": "I also get 79. How do we notify leetcode?"
                    },
                    {
                        "username": "adriankuehn",
                        "content": "Yip, same here for me for testcase 56/61. I solved it by only allowing the BFS to go down and right as mentioned in the task. Then I get 82 instead of 79. But the path for 79 looks correct for me as well. "
                    },
                    {
                        "username": "jamesh",
                        "content": "Such as:\\n\\n    1, 9, 1, 1, 1\\n    1, 1, 1, 9, 1\\n\\nAll the 1's form the minimum path."
                    },
                    {
                        "username": "Earth-Turtle",
                        "content": "There\\'s a clarification in the description that you can only move down or right"
                    },
                    {
                        "username": "psionl0",
                        "content": "After yesterday\\'s problem, it is nice to be able to just code an answer and have it pass all test cases right off the bat without even any syntax errors."
                    },
                    {
                        "username": "tensionstate",
                        "content": "I understand that in some shortest path algorithms on general node weighted graphs, negative cycles lead to non-termination, but here I do not see any problem, so why does the question state that the weights are not negative?"
                    },
                    {
                        "username": "AdityaBhate",
                        "content": "# \\uD83D\\uDCCC C++ || Recursion , DP - Memoization, Tabulation + Space Optimization\\nhttps://leetcode.com/problems/minimum-path-sum/solutions/3117215/c-recursion-dp-memoization-tabulation-space-optimization/?orderBy=hot"
                    },
                    {
                        "username": "ShadyCoder",
                        "content": "What if the follow-up question is how do you store the path information that gives the minimum pathsum? Any ideas about how we can achieve that in a better design perspective?"
                    },
                    {
                        "username": "mayank_pant",
                        "content": "backtracking using the created dp array. "
                    },
                    {
                        "username": "neel19",
                        "content": "Go in reverse order like we do LCS i.e, from $dp[row-1][col-1]$ keep going till cell $dp[0][0]$. "
                    },
                    {
                        "username": "alpharomeo99",
                        "content": "Apart from the solutions mentioned one can just start from the source after creating the dp array. From source move greedily towards the the cell that has the minimum path sum to the destination and accordingly update the path. This will take O(N) time."
                    },
                    {
                        "username": "keshav97",
                        "content": "use recursion we have 2 choices either go right or go down"
                    },
                    {
                        "username": "kushalnagwanshicloud",
                        "content": "I did this -> \\nhttps://leetcode.com/problems/minimum-path-sum/solutions/2819398/how-to-print-the-path-if-asked/"
                    },
                    {
                        "username": "f20200445",
                        "content": "Can someone explain why this is giving me TLE only on the last testcase? I could do tabulation but memoization is giving TLE.\\n\\n    int f(int i,int j,int m,int n,vector<vector<int>> grid,vector<vector<int>> &dp) {\\n        if(i==m-1 && j==n-1) {\\n            return grid[i][j];\\n        }\\n\\n        if(dp[i][j]!=-1) {\\n            return dp[i][j];\\n        }\\n\\n        if(i==m-1) {\\n            return dp[i][j]=grid[i][j]+f(i,j+1,m,n,grid,dp);\\n        }\\n        else if(j==n-1) {\\n            return dp[i][j]=grid[i][j]+f(i+1,j,m,n,grid,dp);\\n        }\\n\\n        return dp[i][j]=grid[i][j] + min(f(i,j+1,m,n,grid,dp),f(i+1,j,m,n,grid,dp));\\n    }\\n    int minPathSum(vector<vector<int>>& grid) {\\n        int m = grid.size();\\n        int n = grid[0].size();\\n        vector<vector<int>> dp(m,vector<int>(n,-1));\\n        return f(0,0,m,n,grid,dp);\\n    }"
                    },
                    {
                        "username": "oops_moment",
                        "content": "Hey even i did the same way, it will pass . Just pass through reference since otherwise multiple copies are created hence increasing time complexity of code. \\nHope it clears the doubt"
                    },
                    {
                        "username": "ee20b053",
                        "content": "in function \\'f\\' pass the matrix grid by reference to further reduce time complexity\\n"
                    },
                    {
                        "username": "viku_kr",
                        "content": "Instead of doing recursively, this question can be done iteratively. Leave the first row and first column, then for all other positions best way to move there is from minimum of (i-1,j) or (i, j-1)"
                    }
                ]
            },
            {
                "id": 1732247,
                "content": [
                    {
                        "username": "DavalC",
                        "content": "The time complexity of the minPathSum function is O(nm), where n is the number of rows in the grid and m is the number of columns in the grid. This is because the function needs to traverse all the cells in the grid once in order to calculate the minimum path sum at each cell.\\n\\nThe space complexity is also O(nm), as the function stores the minimum path sum at each cell in an array. The size of the array is equal to the number of cells in the grid, so the space complexity is linear in the size of the input.\\n\\nIt\\'s worth noting that the space complexity of this function can be improved by using a recursive approach, which would have a space complexity of O(n) due to the use of the call stack. However, this would come at the cost of increased time complexity, as the recursive approach would require additional function calls for each level of recursion."
                    },
                    {
                        "username": "olyabalashova",
                        "content": "Space complexity is O(1) since you don\\'t use any additional space. You can store everything in the original array. If you consider original array in space complexity, then recursive approach wouldn\\'t improve it."
                    },
                    {
                        "username": "khangnguyen0318",
                        "content": "on testcase 13 I got this grid [[1,2,5],[3,2,1]] and expected return is 6, I return 7 so that FAILED, I don\\'t know how. Anyone can explain for me this expectation?"
                    },
                    {
                        "username": "mufaddalali53",
                        "content": "x[0][0] ->x[0][1] ->x[1][1]->x[1][2]\\n1 + 2+ 2+1 =6"
                    },
                    {
                        "username": "thunderfly",
                        "content": "if present [] or [[]]\\nleetcode will show\\nLine 933: Char 34: runtime error: pointer index expression with base 0x000000000000 overflowed to 0xfffffffffffffffc (stl_vector.h)\\n\\nare these also valid test case that should be take care of?"
                    },
                    {
                        "username": "viku_kr",
                        "content": "There is minimum 1 row and 1 column. So, this case will not occur."
                    },
                    {
                        "username": "serinsabu",
                        "content": "Why my case I==0 && j==0  is not working , it gives integer.max_value as the result  for all cases in java but in c++ if we give 1e9 then it gives right answer, instead I==m-1 and j==n-1 works and going towards right and down position works"
                    },
                    {
                        "username": "AlecLC",
                        "content": "Why is this medium\n\n    def minPathSum(self, grid: List[List[int]]) -> int:\n        for r in range(len(grid)):\n            for c in range(len(grid[0])):\n                if r and c:\n                    grid[r][c] += min(grid[r-1][c], grid[r][c-1])\n                elif not r and c:\n                    grid[r][c] += grid[r][c-1]\n                elif not c and r:\n                    grid[r][c] += grid[r-1][c]\n        \n        return grid[-1][-1]"
                    },
                    {
                        "username": "sk03167",
                        "content": "Can we leave the discussion tab just for general discussions. Posting full solutions here lead to useless cluttering. If you want to post solutions, you can use the solutions tab. "
                    },
                    {
                        "username": "rushabhvg",
                        "content": "Cause they don\\'t think that this is easy!"
                    },
                    {
                        "username": "ihsansfd",
                        "content": "After learning Dijkstra I know get confused on why DP/DFS with cache is used in preference of BFS. It's shortest path problem right. I solved it both ways I DP performs better (DP = N* M, Dijkstra = log(N * M) M * N). \n\nLearning new algorithm makes me confused on which approach I have to decide in the first place :(. People told me that when you hear \"shortest path\", use BFS. But this???"
                    },
                    {
                        "username": "yash45885",
                        "content": "Best tabulated JAVA solution : \\nclass Solution {\\n    public int minPathSum(int[][] grid) {\\n        int m = grid.length;\\n        int n = grid[0].length;\\n        int[][] dp = new int[m][n];\\n        //dp[0][0] = grid[0][0];\\n\\n        for(int i=0;i<m;i++){\\n            int down = 0, right = 0;\\n            for(int j=0;j<n;j++){\\n                if(i==0 && j==0)\\n                    dp[i][j] = grid[i][j];\\n                else{\\n                    if(i>0)\\n                        down = grid[i][j] + dp[i-1][j];\\n                    else\\n                        down = grid[i][j] + (int)(1e9);\\n                    if(j>0)\\n                        right = grid[i][j] + dp[i][j-1];\\n                    else\\n                        right = grid[i][j] + (int)(1e9);\\n                    dp[i][j] = Math.min(down, right);\\n                }\\n            }\\n        }\\n        return dp[m-1][n-1];\\n    }\\n}"
                    },
                    {
                        "username": "kanukolanuManjith",
                        "content": "class Solution {\\npublic:\\n    int m,n;\\n    int minPathSum(vector<vector<int>>& grid) {\\n        int a=1000;\\n        m=grid.size();\\n        n=grid[0].size();\\n        pathSum(grid,0,0,0,a);\\n        return a;\\n    }\\n    void pathSum(vector<vector<int>>& grid,int i,int j,int k,int &a)\\n    {\\n        if(i==m && j==n)\\n        {\\n            a=min(a,k);\\n            return ;\\n        }\\n        if(i==m || j==n)\\n        {\\n            return ;\\n        }\\n        k=k+grid[i][j];\\n        pathSum(grid,i,j+1,k,a);\\n        pathSum(grid,i+1,j,k,a);\\n    }\\n};\\n\\nwhat wrong in code pls tell"
                    },
                    {
                        "username": "Shanks333",
                        "content": "Why Memoization giving Memory limit exceeded?"
                    },
                    {
                        "username": "sarthakkharabanda",
                        "content": "It legit took me over an hour to figure out i had missed  `[0]` in `j==grid[0].length-1` -__-"
                    }
                ]
            },
            {
                "id": 1845396,
                "content": [
                    {
                        "username": "DavalC",
                        "content": "The time complexity of the minPathSum function is O(nm), where n is the number of rows in the grid and m is the number of columns in the grid. This is because the function needs to traverse all the cells in the grid once in order to calculate the minimum path sum at each cell.\\n\\nThe space complexity is also O(nm), as the function stores the minimum path sum at each cell in an array. The size of the array is equal to the number of cells in the grid, so the space complexity is linear in the size of the input.\\n\\nIt\\'s worth noting that the space complexity of this function can be improved by using a recursive approach, which would have a space complexity of O(n) due to the use of the call stack. However, this would come at the cost of increased time complexity, as the recursive approach would require additional function calls for each level of recursion."
                    },
                    {
                        "username": "olyabalashova",
                        "content": "Space complexity is O(1) since you don\\'t use any additional space. You can store everything in the original array. If you consider original array in space complexity, then recursive approach wouldn\\'t improve it."
                    },
                    {
                        "username": "khangnguyen0318",
                        "content": "on testcase 13 I got this grid [[1,2,5],[3,2,1]] and expected return is 6, I return 7 so that FAILED, I don\\'t know how. Anyone can explain for me this expectation?"
                    },
                    {
                        "username": "mufaddalali53",
                        "content": "x[0][0] ->x[0][1] ->x[1][1]->x[1][2]\\n1 + 2+ 2+1 =6"
                    },
                    {
                        "username": "thunderfly",
                        "content": "if present [] or [[]]\\nleetcode will show\\nLine 933: Char 34: runtime error: pointer index expression with base 0x000000000000 overflowed to 0xfffffffffffffffc (stl_vector.h)\\n\\nare these also valid test case that should be take care of?"
                    },
                    {
                        "username": "viku_kr",
                        "content": "There is minimum 1 row and 1 column. So, this case will not occur."
                    },
                    {
                        "username": "serinsabu",
                        "content": "Why my case I==0 && j==0  is not working , it gives integer.max_value as the result  for all cases in java but in c++ if we give 1e9 then it gives right answer, instead I==m-1 and j==n-1 works and going towards right and down position works"
                    },
                    {
                        "username": "AlecLC",
                        "content": "Why is this medium\n\n    def minPathSum(self, grid: List[List[int]]) -> int:\n        for r in range(len(grid)):\n            for c in range(len(grid[0])):\n                if r and c:\n                    grid[r][c] += min(grid[r-1][c], grid[r][c-1])\n                elif not r and c:\n                    grid[r][c] += grid[r][c-1]\n                elif not c and r:\n                    grid[r][c] += grid[r-1][c]\n        \n        return grid[-1][-1]"
                    },
                    {
                        "username": "sk03167",
                        "content": "Can we leave the discussion tab just for general discussions. Posting full solutions here lead to useless cluttering. If you want to post solutions, you can use the solutions tab. "
                    },
                    {
                        "username": "rushabhvg",
                        "content": "Cause they don\\'t think that this is easy!"
                    },
                    {
                        "username": "ihsansfd",
                        "content": "After learning Dijkstra I know get confused on why DP/DFS with cache is used in preference of BFS. It's shortest path problem right. I solved it both ways I DP performs better (DP = N* M, Dijkstra = log(N * M) M * N). \n\nLearning new algorithm makes me confused on which approach I have to decide in the first place :(. People told me that when you hear \"shortest path\", use BFS. But this???"
                    },
                    {
                        "username": "yash45885",
                        "content": "Best tabulated JAVA solution : \\nclass Solution {\\n    public int minPathSum(int[][] grid) {\\n        int m = grid.length;\\n        int n = grid[0].length;\\n        int[][] dp = new int[m][n];\\n        //dp[0][0] = grid[0][0];\\n\\n        for(int i=0;i<m;i++){\\n            int down = 0, right = 0;\\n            for(int j=0;j<n;j++){\\n                if(i==0 && j==0)\\n                    dp[i][j] = grid[i][j];\\n                else{\\n                    if(i>0)\\n                        down = grid[i][j] + dp[i-1][j];\\n                    else\\n                        down = grid[i][j] + (int)(1e9);\\n                    if(j>0)\\n                        right = grid[i][j] + dp[i][j-1];\\n                    else\\n                        right = grid[i][j] + (int)(1e9);\\n                    dp[i][j] = Math.min(down, right);\\n                }\\n            }\\n        }\\n        return dp[m-1][n-1];\\n    }\\n}"
                    },
                    {
                        "username": "kanukolanuManjith",
                        "content": "class Solution {\\npublic:\\n    int m,n;\\n    int minPathSum(vector<vector<int>>& grid) {\\n        int a=1000;\\n        m=grid.size();\\n        n=grid[0].size();\\n        pathSum(grid,0,0,0,a);\\n        return a;\\n    }\\n    void pathSum(vector<vector<int>>& grid,int i,int j,int k,int &a)\\n    {\\n        if(i==m && j==n)\\n        {\\n            a=min(a,k);\\n            return ;\\n        }\\n        if(i==m || j==n)\\n        {\\n            return ;\\n        }\\n        k=k+grid[i][j];\\n        pathSum(grid,i,j+1,k,a);\\n        pathSum(grid,i+1,j,k,a);\\n    }\\n};\\n\\nwhat wrong in code pls tell"
                    },
                    {
                        "username": "Shanks333",
                        "content": "Why Memoization giving Memory limit exceeded?"
                    },
                    {
                        "username": "sarthakkharabanda",
                        "content": "It legit took me over an hour to figure out i had missed  `[0]` in `j==grid[0].length-1` -__-"
                    }
                ]
            },
            {
                "id": 1569523,
                "content": [
                    {
                        "username": "DavalC",
                        "content": "The time complexity of the minPathSum function is O(nm), where n is the number of rows in the grid and m is the number of columns in the grid. This is because the function needs to traverse all the cells in the grid once in order to calculate the minimum path sum at each cell.\\n\\nThe space complexity is also O(nm), as the function stores the minimum path sum at each cell in an array. The size of the array is equal to the number of cells in the grid, so the space complexity is linear in the size of the input.\\n\\nIt\\'s worth noting that the space complexity of this function can be improved by using a recursive approach, which would have a space complexity of O(n) due to the use of the call stack. However, this would come at the cost of increased time complexity, as the recursive approach would require additional function calls for each level of recursion."
                    },
                    {
                        "username": "olyabalashova",
                        "content": "Space complexity is O(1) since you don\\'t use any additional space. You can store everything in the original array. If you consider original array in space complexity, then recursive approach wouldn\\'t improve it."
                    },
                    {
                        "username": "khangnguyen0318",
                        "content": "on testcase 13 I got this grid [[1,2,5],[3,2,1]] and expected return is 6, I return 7 so that FAILED, I don\\'t know how. Anyone can explain for me this expectation?"
                    },
                    {
                        "username": "mufaddalali53",
                        "content": "x[0][0] ->x[0][1] ->x[1][1]->x[1][2]\\n1 + 2+ 2+1 =6"
                    },
                    {
                        "username": "thunderfly",
                        "content": "if present [] or [[]]\\nleetcode will show\\nLine 933: Char 34: runtime error: pointer index expression with base 0x000000000000 overflowed to 0xfffffffffffffffc (stl_vector.h)\\n\\nare these also valid test case that should be take care of?"
                    },
                    {
                        "username": "viku_kr",
                        "content": "There is minimum 1 row and 1 column. So, this case will not occur."
                    },
                    {
                        "username": "serinsabu",
                        "content": "Why my case I==0 && j==0  is not working , it gives integer.max_value as the result  for all cases in java but in c++ if we give 1e9 then it gives right answer, instead I==m-1 and j==n-1 works and going towards right and down position works"
                    },
                    {
                        "username": "AlecLC",
                        "content": "Why is this medium\n\n    def minPathSum(self, grid: List[List[int]]) -> int:\n        for r in range(len(grid)):\n            for c in range(len(grid[0])):\n                if r and c:\n                    grid[r][c] += min(grid[r-1][c], grid[r][c-1])\n                elif not r and c:\n                    grid[r][c] += grid[r][c-1]\n                elif not c and r:\n                    grid[r][c] += grid[r-1][c]\n        \n        return grid[-1][-1]"
                    },
                    {
                        "username": "sk03167",
                        "content": "Can we leave the discussion tab just for general discussions. Posting full solutions here lead to useless cluttering. If you want to post solutions, you can use the solutions tab. "
                    },
                    {
                        "username": "rushabhvg",
                        "content": "Cause they don\\'t think that this is easy!"
                    },
                    {
                        "username": "ihsansfd",
                        "content": "After learning Dijkstra I know get confused on why DP/DFS with cache is used in preference of BFS. It's shortest path problem right. I solved it both ways I DP performs better (DP = N* M, Dijkstra = log(N * M) M * N). \n\nLearning new algorithm makes me confused on which approach I have to decide in the first place :(. People told me that when you hear \"shortest path\", use BFS. But this???"
                    },
                    {
                        "username": "yash45885",
                        "content": "Best tabulated JAVA solution : \\nclass Solution {\\n    public int minPathSum(int[][] grid) {\\n        int m = grid.length;\\n        int n = grid[0].length;\\n        int[][] dp = new int[m][n];\\n        //dp[0][0] = grid[0][0];\\n\\n        for(int i=0;i<m;i++){\\n            int down = 0, right = 0;\\n            for(int j=0;j<n;j++){\\n                if(i==0 && j==0)\\n                    dp[i][j] = grid[i][j];\\n                else{\\n                    if(i>0)\\n                        down = grid[i][j] + dp[i-1][j];\\n                    else\\n                        down = grid[i][j] + (int)(1e9);\\n                    if(j>0)\\n                        right = grid[i][j] + dp[i][j-1];\\n                    else\\n                        right = grid[i][j] + (int)(1e9);\\n                    dp[i][j] = Math.min(down, right);\\n                }\\n            }\\n        }\\n        return dp[m-1][n-1];\\n    }\\n}"
                    },
                    {
                        "username": "kanukolanuManjith",
                        "content": "class Solution {\\npublic:\\n    int m,n;\\n    int minPathSum(vector<vector<int>>& grid) {\\n        int a=1000;\\n        m=grid.size();\\n        n=grid[0].size();\\n        pathSum(grid,0,0,0,a);\\n        return a;\\n    }\\n    void pathSum(vector<vector<int>>& grid,int i,int j,int k,int &a)\\n    {\\n        if(i==m && j==n)\\n        {\\n            a=min(a,k);\\n            return ;\\n        }\\n        if(i==m || j==n)\\n        {\\n            return ;\\n        }\\n        k=k+grid[i][j];\\n        pathSum(grid,i,j+1,k,a);\\n        pathSum(grid,i+1,j,k,a);\\n    }\\n};\\n\\nwhat wrong in code pls tell"
                    },
                    {
                        "username": "Shanks333",
                        "content": "Why Memoization giving Memory limit exceeded?"
                    },
                    {
                        "username": "sarthakkharabanda",
                        "content": "It legit took me over an hour to figure out i had missed  `[0]` in `j==grid[0].length-1` -__-"
                    }
                ]
            },
            {
                "id": 1845071,
                "content": [
                    {
                        "username": "DavalC",
                        "content": "The time complexity of the minPathSum function is O(nm), where n is the number of rows in the grid and m is the number of columns in the grid. This is because the function needs to traverse all the cells in the grid once in order to calculate the minimum path sum at each cell.\\n\\nThe space complexity is also O(nm), as the function stores the minimum path sum at each cell in an array. The size of the array is equal to the number of cells in the grid, so the space complexity is linear in the size of the input.\\n\\nIt\\'s worth noting that the space complexity of this function can be improved by using a recursive approach, which would have a space complexity of O(n) due to the use of the call stack. However, this would come at the cost of increased time complexity, as the recursive approach would require additional function calls for each level of recursion."
                    },
                    {
                        "username": "olyabalashova",
                        "content": "Space complexity is O(1) since you don\\'t use any additional space. You can store everything in the original array. If you consider original array in space complexity, then recursive approach wouldn\\'t improve it."
                    },
                    {
                        "username": "khangnguyen0318",
                        "content": "on testcase 13 I got this grid [[1,2,5],[3,2,1]] and expected return is 6, I return 7 so that FAILED, I don\\'t know how. Anyone can explain for me this expectation?"
                    },
                    {
                        "username": "mufaddalali53",
                        "content": "x[0][0] ->x[0][1] ->x[1][1]->x[1][2]\\n1 + 2+ 2+1 =6"
                    },
                    {
                        "username": "thunderfly",
                        "content": "if present [] or [[]]\\nleetcode will show\\nLine 933: Char 34: runtime error: pointer index expression with base 0x000000000000 overflowed to 0xfffffffffffffffc (stl_vector.h)\\n\\nare these also valid test case that should be take care of?"
                    },
                    {
                        "username": "viku_kr",
                        "content": "There is minimum 1 row and 1 column. So, this case will not occur."
                    },
                    {
                        "username": "serinsabu",
                        "content": "Why my case I==0 && j==0  is not working , it gives integer.max_value as the result  for all cases in java but in c++ if we give 1e9 then it gives right answer, instead I==m-1 and j==n-1 works and going towards right and down position works"
                    },
                    {
                        "username": "AlecLC",
                        "content": "Why is this medium\n\n    def minPathSum(self, grid: List[List[int]]) -> int:\n        for r in range(len(grid)):\n            for c in range(len(grid[0])):\n                if r and c:\n                    grid[r][c] += min(grid[r-1][c], grid[r][c-1])\n                elif not r and c:\n                    grid[r][c] += grid[r][c-1]\n                elif not c and r:\n                    grid[r][c] += grid[r-1][c]\n        \n        return grid[-1][-1]"
                    },
                    {
                        "username": "sk03167",
                        "content": "Can we leave the discussion tab just for general discussions. Posting full solutions here lead to useless cluttering. If you want to post solutions, you can use the solutions tab. "
                    },
                    {
                        "username": "rushabhvg",
                        "content": "Cause they don\\'t think that this is easy!"
                    },
                    {
                        "username": "ihsansfd",
                        "content": "After learning Dijkstra I know get confused on why DP/DFS with cache is used in preference of BFS. It's shortest path problem right. I solved it both ways I DP performs better (DP = N* M, Dijkstra = log(N * M) M * N). \n\nLearning new algorithm makes me confused on which approach I have to decide in the first place :(. People told me that when you hear \"shortest path\", use BFS. But this???"
                    },
                    {
                        "username": "yash45885",
                        "content": "Best tabulated JAVA solution : \\nclass Solution {\\n    public int minPathSum(int[][] grid) {\\n        int m = grid.length;\\n        int n = grid[0].length;\\n        int[][] dp = new int[m][n];\\n        //dp[0][0] = grid[0][0];\\n\\n        for(int i=0;i<m;i++){\\n            int down = 0, right = 0;\\n            for(int j=0;j<n;j++){\\n                if(i==0 && j==0)\\n                    dp[i][j] = grid[i][j];\\n                else{\\n                    if(i>0)\\n                        down = grid[i][j] + dp[i-1][j];\\n                    else\\n                        down = grid[i][j] + (int)(1e9);\\n                    if(j>0)\\n                        right = grid[i][j] + dp[i][j-1];\\n                    else\\n                        right = grid[i][j] + (int)(1e9);\\n                    dp[i][j] = Math.min(down, right);\\n                }\\n            }\\n        }\\n        return dp[m-1][n-1];\\n    }\\n}"
                    },
                    {
                        "username": "kanukolanuManjith",
                        "content": "class Solution {\\npublic:\\n    int m,n;\\n    int minPathSum(vector<vector<int>>& grid) {\\n        int a=1000;\\n        m=grid.size();\\n        n=grid[0].size();\\n        pathSum(grid,0,0,0,a);\\n        return a;\\n    }\\n    void pathSum(vector<vector<int>>& grid,int i,int j,int k,int &a)\\n    {\\n        if(i==m && j==n)\\n        {\\n            a=min(a,k);\\n            return ;\\n        }\\n        if(i==m || j==n)\\n        {\\n            return ;\\n        }\\n        k=k+grid[i][j];\\n        pathSum(grid,i,j+1,k,a);\\n        pathSum(grid,i+1,j,k,a);\\n    }\\n};\\n\\nwhat wrong in code pls tell"
                    },
                    {
                        "username": "Shanks333",
                        "content": "Why Memoization giving Memory limit exceeded?"
                    },
                    {
                        "username": "sarthakkharabanda",
                        "content": "It legit took me over an hour to figure out i had missed  `[0]` in `j==grid[0].length-1` -__-"
                    }
                ]
            },
            {
                "id": 1845039,
                "content": [
                    {
                        "username": "DavalC",
                        "content": "The time complexity of the minPathSum function is O(nm), where n is the number of rows in the grid and m is the number of columns in the grid. This is because the function needs to traverse all the cells in the grid once in order to calculate the minimum path sum at each cell.\\n\\nThe space complexity is also O(nm), as the function stores the minimum path sum at each cell in an array. The size of the array is equal to the number of cells in the grid, so the space complexity is linear in the size of the input.\\n\\nIt\\'s worth noting that the space complexity of this function can be improved by using a recursive approach, which would have a space complexity of O(n) due to the use of the call stack. However, this would come at the cost of increased time complexity, as the recursive approach would require additional function calls for each level of recursion."
                    },
                    {
                        "username": "olyabalashova",
                        "content": "Space complexity is O(1) since you don\\'t use any additional space. You can store everything in the original array. If you consider original array in space complexity, then recursive approach wouldn\\'t improve it."
                    },
                    {
                        "username": "khangnguyen0318",
                        "content": "on testcase 13 I got this grid [[1,2,5],[3,2,1]] and expected return is 6, I return 7 so that FAILED, I don\\'t know how. Anyone can explain for me this expectation?"
                    },
                    {
                        "username": "mufaddalali53",
                        "content": "x[0][0] ->x[0][1] ->x[1][1]->x[1][2]\\n1 + 2+ 2+1 =6"
                    },
                    {
                        "username": "thunderfly",
                        "content": "if present [] or [[]]\\nleetcode will show\\nLine 933: Char 34: runtime error: pointer index expression with base 0x000000000000 overflowed to 0xfffffffffffffffc (stl_vector.h)\\n\\nare these also valid test case that should be take care of?"
                    },
                    {
                        "username": "viku_kr",
                        "content": "There is minimum 1 row and 1 column. So, this case will not occur."
                    },
                    {
                        "username": "serinsabu",
                        "content": "Why my case I==0 && j==0  is not working , it gives integer.max_value as the result  for all cases in java but in c++ if we give 1e9 then it gives right answer, instead I==m-1 and j==n-1 works and going towards right and down position works"
                    },
                    {
                        "username": "AlecLC",
                        "content": "Why is this medium\n\n    def minPathSum(self, grid: List[List[int]]) -> int:\n        for r in range(len(grid)):\n            for c in range(len(grid[0])):\n                if r and c:\n                    grid[r][c] += min(grid[r-1][c], grid[r][c-1])\n                elif not r and c:\n                    grid[r][c] += grid[r][c-1]\n                elif not c and r:\n                    grid[r][c] += grid[r-1][c]\n        \n        return grid[-1][-1]"
                    },
                    {
                        "username": "sk03167",
                        "content": "Can we leave the discussion tab just for general discussions. Posting full solutions here lead to useless cluttering. If you want to post solutions, you can use the solutions tab. "
                    },
                    {
                        "username": "rushabhvg",
                        "content": "Cause they don\\'t think that this is easy!"
                    },
                    {
                        "username": "ihsansfd",
                        "content": "After learning Dijkstra I know get confused on why DP/DFS with cache is used in preference of BFS. It's shortest path problem right. I solved it both ways I DP performs better (DP = N* M, Dijkstra = log(N * M) M * N). \n\nLearning new algorithm makes me confused on which approach I have to decide in the first place :(. People told me that when you hear \"shortest path\", use BFS. But this???"
                    },
                    {
                        "username": "yash45885",
                        "content": "Best tabulated JAVA solution : \\nclass Solution {\\n    public int minPathSum(int[][] grid) {\\n        int m = grid.length;\\n        int n = grid[0].length;\\n        int[][] dp = new int[m][n];\\n        //dp[0][0] = grid[0][0];\\n\\n        for(int i=0;i<m;i++){\\n            int down = 0, right = 0;\\n            for(int j=0;j<n;j++){\\n                if(i==0 && j==0)\\n                    dp[i][j] = grid[i][j];\\n                else{\\n                    if(i>0)\\n                        down = grid[i][j] + dp[i-1][j];\\n                    else\\n                        down = grid[i][j] + (int)(1e9);\\n                    if(j>0)\\n                        right = grid[i][j] + dp[i][j-1];\\n                    else\\n                        right = grid[i][j] + (int)(1e9);\\n                    dp[i][j] = Math.min(down, right);\\n                }\\n            }\\n        }\\n        return dp[m-1][n-1];\\n    }\\n}"
                    },
                    {
                        "username": "kanukolanuManjith",
                        "content": "class Solution {\\npublic:\\n    int m,n;\\n    int minPathSum(vector<vector<int>>& grid) {\\n        int a=1000;\\n        m=grid.size();\\n        n=grid[0].size();\\n        pathSum(grid,0,0,0,a);\\n        return a;\\n    }\\n    void pathSum(vector<vector<int>>& grid,int i,int j,int k,int &a)\\n    {\\n        if(i==m && j==n)\\n        {\\n            a=min(a,k);\\n            return ;\\n        }\\n        if(i==m || j==n)\\n        {\\n            return ;\\n        }\\n        k=k+grid[i][j];\\n        pathSum(grid,i,j+1,k,a);\\n        pathSum(grid,i+1,j,k,a);\\n    }\\n};\\n\\nwhat wrong in code pls tell"
                    },
                    {
                        "username": "Shanks333",
                        "content": "Why Memoization giving Memory limit exceeded?"
                    },
                    {
                        "username": "sarthakkharabanda",
                        "content": "It legit took me over an hour to figure out i had missed  `[0]` in `j==grid[0].length-1` -__-"
                    }
                ]
            },
            {
                "id": 2069231,
                "content": [
                    {
                        "username": "DavalC",
                        "content": "The time complexity of the minPathSum function is O(nm), where n is the number of rows in the grid and m is the number of columns in the grid. This is because the function needs to traverse all the cells in the grid once in order to calculate the minimum path sum at each cell.\\n\\nThe space complexity is also O(nm), as the function stores the minimum path sum at each cell in an array. The size of the array is equal to the number of cells in the grid, so the space complexity is linear in the size of the input.\\n\\nIt\\'s worth noting that the space complexity of this function can be improved by using a recursive approach, which would have a space complexity of O(n) due to the use of the call stack. However, this would come at the cost of increased time complexity, as the recursive approach would require additional function calls for each level of recursion."
                    },
                    {
                        "username": "olyabalashova",
                        "content": "Space complexity is O(1) since you don\\'t use any additional space. You can store everything in the original array. If you consider original array in space complexity, then recursive approach wouldn\\'t improve it."
                    },
                    {
                        "username": "khangnguyen0318",
                        "content": "on testcase 13 I got this grid [[1,2,5],[3,2,1]] and expected return is 6, I return 7 so that FAILED, I don\\'t know how. Anyone can explain for me this expectation?"
                    },
                    {
                        "username": "mufaddalali53",
                        "content": "x[0][0] ->x[0][1] ->x[1][1]->x[1][2]\\n1 + 2+ 2+1 =6"
                    },
                    {
                        "username": "thunderfly",
                        "content": "if present [] or [[]]\\nleetcode will show\\nLine 933: Char 34: runtime error: pointer index expression with base 0x000000000000 overflowed to 0xfffffffffffffffc (stl_vector.h)\\n\\nare these also valid test case that should be take care of?"
                    },
                    {
                        "username": "viku_kr",
                        "content": "There is minimum 1 row and 1 column. So, this case will not occur."
                    },
                    {
                        "username": "serinsabu",
                        "content": "Why my case I==0 && j==0  is not working , it gives integer.max_value as the result  for all cases in java but in c++ if we give 1e9 then it gives right answer, instead I==m-1 and j==n-1 works and going towards right and down position works"
                    },
                    {
                        "username": "AlecLC",
                        "content": "Why is this medium\n\n    def minPathSum(self, grid: List[List[int]]) -> int:\n        for r in range(len(grid)):\n            for c in range(len(grid[0])):\n                if r and c:\n                    grid[r][c] += min(grid[r-1][c], grid[r][c-1])\n                elif not r and c:\n                    grid[r][c] += grid[r][c-1]\n                elif not c and r:\n                    grid[r][c] += grid[r-1][c]\n        \n        return grid[-1][-1]"
                    },
                    {
                        "username": "sk03167",
                        "content": "Can we leave the discussion tab just for general discussions. Posting full solutions here lead to useless cluttering. If you want to post solutions, you can use the solutions tab. "
                    },
                    {
                        "username": "rushabhvg",
                        "content": "Cause they don\\'t think that this is easy!"
                    },
                    {
                        "username": "ihsansfd",
                        "content": "After learning Dijkstra I know get confused on why DP/DFS with cache is used in preference of BFS. It's shortest path problem right. I solved it both ways I DP performs better (DP = N* M, Dijkstra = log(N * M) M * N). \n\nLearning new algorithm makes me confused on which approach I have to decide in the first place :(. People told me that when you hear \"shortest path\", use BFS. But this???"
                    },
                    {
                        "username": "yash45885",
                        "content": "Best tabulated JAVA solution : \\nclass Solution {\\n    public int minPathSum(int[][] grid) {\\n        int m = grid.length;\\n        int n = grid[0].length;\\n        int[][] dp = new int[m][n];\\n        //dp[0][0] = grid[0][0];\\n\\n        for(int i=0;i<m;i++){\\n            int down = 0, right = 0;\\n            for(int j=0;j<n;j++){\\n                if(i==0 && j==0)\\n                    dp[i][j] = grid[i][j];\\n                else{\\n                    if(i>0)\\n                        down = grid[i][j] + dp[i-1][j];\\n                    else\\n                        down = grid[i][j] + (int)(1e9);\\n                    if(j>0)\\n                        right = grid[i][j] + dp[i][j-1];\\n                    else\\n                        right = grid[i][j] + (int)(1e9);\\n                    dp[i][j] = Math.min(down, right);\\n                }\\n            }\\n        }\\n        return dp[m-1][n-1];\\n    }\\n}"
                    },
                    {
                        "username": "kanukolanuManjith",
                        "content": "class Solution {\\npublic:\\n    int m,n;\\n    int minPathSum(vector<vector<int>>& grid) {\\n        int a=1000;\\n        m=grid.size();\\n        n=grid[0].size();\\n        pathSum(grid,0,0,0,a);\\n        return a;\\n    }\\n    void pathSum(vector<vector<int>>& grid,int i,int j,int k,int &a)\\n    {\\n        if(i==m && j==n)\\n        {\\n            a=min(a,k);\\n            return ;\\n        }\\n        if(i==m || j==n)\\n        {\\n            return ;\\n        }\\n        k=k+grid[i][j];\\n        pathSum(grid,i,j+1,k,a);\\n        pathSum(grid,i+1,j,k,a);\\n    }\\n};\\n\\nwhat wrong in code pls tell"
                    },
                    {
                        "username": "Shanks333",
                        "content": "Why Memoization giving Memory limit exceeded?"
                    },
                    {
                        "username": "sarthakkharabanda",
                        "content": "It legit took me over an hour to figure out i had missed  `[0]` in `j==grid[0].length-1` -__-"
                    }
                ]
            },
            {
                "id": 2066589,
                "content": [
                    {
                        "username": "DavalC",
                        "content": "The time complexity of the minPathSum function is O(nm), where n is the number of rows in the grid and m is the number of columns in the grid. This is because the function needs to traverse all the cells in the grid once in order to calculate the minimum path sum at each cell.\\n\\nThe space complexity is also O(nm), as the function stores the minimum path sum at each cell in an array. The size of the array is equal to the number of cells in the grid, so the space complexity is linear in the size of the input.\\n\\nIt\\'s worth noting that the space complexity of this function can be improved by using a recursive approach, which would have a space complexity of O(n) due to the use of the call stack. However, this would come at the cost of increased time complexity, as the recursive approach would require additional function calls for each level of recursion."
                    },
                    {
                        "username": "olyabalashova",
                        "content": "Space complexity is O(1) since you don\\'t use any additional space. You can store everything in the original array. If you consider original array in space complexity, then recursive approach wouldn\\'t improve it."
                    },
                    {
                        "username": "khangnguyen0318",
                        "content": "on testcase 13 I got this grid [[1,2,5],[3,2,1]] and expected return is 6, I return 7 so that FAILED, I don\\'t know how. Anyone can explain for me this expectation?"
                    },
                    {
                        "username": "mufaddalali53",
                        "content": "x[0][0] ->x[0][1] ->x[1][1]->x[1][2]\\n1 + 2+ 2+1 =6"
                    },
                    {
                        "username": "thunderfly",
                        "content": "if present [] or [[]]\\nleetcode will show\\nLine 933: Char 34: runtime error: pointer index expression with base 0x000000000000 overflowed to 0xfffffffffffffffc (stl_vector.h)\\n\\nare these also valid test case that should be take care of?"
                    },
                    {
                        "username": "viku_kr",
                        "content": "There is minimum 1 row and 1 column. So, this case will not occur."
                    },
                    {
                        "username": "serinsabu",
                        "content": "Why my case I==0 && j==0  is not working , it gives integer.max_value as the result  for all cases in java but in c++ if we give 1e9 then it gives right answer, instead I==m-1 and j==n-1 works and going towards right and down position works"
                    },
                    {
                        "username": "AlecLC",
                        "content": "Why is this medium\n\n    def minPathSum(self, grid: List[List[int]]) -> int:\n        for r in range(len(grid)):\n            for c in range(len(grid[0])):\n                if r and c:\n                    grid[r][c] += min(grid[r-1][c], grid[r][c-1])\n                elif not r and c:\n                    grid[r][c] += grid[r][c-1]\n                elif not c and r:\n                    grid[r][c] += grid[r-1][c]\n        \n        return grid[-1][-1]"
                    },
                    {
                        "username": "sk03167",
                        "content": "Can we leave the discussion tab just for general discussions. Posting full solutions here lead to useless cluttering. If you want to post solutions, you can use the solutions tab. "
                    },
                    {
                        "username": "rushabhvg",
                        "content": "Cause they don\\'t think that this is easy!"
                    },
                    {
                        "username": "ihsansfd",
                        "content": "After learning Dijkstra I know get confused on why DP/DFS with cache is used in preference of BFS. It's shortest path problem right. I solved it both ways I DP performs better (DP = N* M, Dijkstra = log(N * M) M * N). \n\nLearning new algorithm makes me confused on which approach I have to decide in the first place :(. People told me that when you hear \"shortest path\", use BFS. But this???"
                    },
                    {
                        "username": "yash45885",
                        "content": "Best tabulated JAVA solution : \\nclass Solution {\\n    public int minPathSum(int[][] grid) {\\n        int m = grid.length;\\n        int n = grid[0].length;\\n        int[][] dp = new int[m][n];\\n        //dp[0][0] = grid[0][0];\\n\\n        for(int i=0;i<m;i++){\\n            int down = 0, right = 0;\\n            for(int j=0;j<n;j++){\\n                if(i==0 && j==0)\\n                    dp[i][j] = grid[i][j];\\n                else{\\n                    if(i>0)\\n                        down = grid[i][j] + dp[i-1][j];\\n                    else\\n                        down = grid[i][j] + (int)(1e9);\\n                    if(j>0)\\n                        right = grid[i][j] + dp[i][j-1];\\n                    else\\n                        right = grid[i][j] + (int)(1e9);\\n                    dp[i][j] = Math.min(down, right);\\n                }\\n            }\\n        }\\n        return dp[m-1][n-1];\\n    }\\n}"
                    },
                    {
                        "username": "kanukolanuManjith",
                        "content": "class Solution {\\npublic:\\n    int m,n;\\n    int minPathSum(vector<vector<int>>& grid) {\\n        int a=1000;\\n        m=grid.size();\\n        n=grid[0].size();\\n        pathSum(grid,0,0,0,a);\\n        return a;\\n    }\\n    void pathSum(vector<vector<int>>& grid,int i,int j,int k,int &a)\\n    {\\n        if(i==m && j==n)\\n        {\\n            a=min(a,k);\\n            return ;\\n        }\\n        if(i==m || j==n)\\n        {\\n            return ;\\n        }\\n        k=k+grid[i][j];\\n        pathSum(grid,i,j+1,k,a);\\n        pathSum(grid,i+1,j,k,a);\\n    }\\n};\\n\\nwhat wrong in code pls tell"
                    },
                    {
                        "username": "Shanks333",
                        "content": "Why Memoization giving Memory limit exceeded?"
                    },
                    {
                        "username": "sarthakkharabanda",
                        "content": "It legit took me over an hour to figure out i had missed  `[0]` in `j==grid[0].length-1` -__-"
                    }
                ]
            },
            {
                "id": 2062807,
                "content": [
                    {
                        "username": "DavalC",
                        "content": "The time complexity of the minPathSum function is O(nm), where n is the number of rows in the grid and m is the number of columns in the grid. This is because the function needs to traverse all the cells in the grid once in order to calculate the minimum path sum at each cell.\\n\\nThe space complexity is also O(nm), as the function stores the minimum path sum at each cell in an array. The size of the array is equal to the number of cells in the grid, so the space complexity is linear in the size of the input.\\n\\nIt\\'s worth noting that the space complexity of this function can be improved by using a recursive approach, which would have a space complexity of O(n) due to the use of the call stack. However, this would come at the cost of increased time complexity, as the recursive approach would require additional function calls for each level of recursion."
                    },
                    {
                        "username": "olyabalashova",
                        "content": "Space complexity is O(1) since you don\\'t use any additional space. You can store everything in the original array. If you consider original array in space complexity, then recursive approach wouldn\\'t improve it."
                    },
                    {
                        "username": "khangnguyen0318",
                        "content": "on testcase 13 I got this grid [[1,2,5],[3,2,1]] and expected return is 6, I return 7 so that FAILED, I don\\'t know how. Anyone can explain for me this expectation?"
                    },
                    {
                        "username": "mufaddalali53",
                        "content": "x[0][0] ->x[0][1] ->x[1][1]->x[1][2]\\n1 + 2+ 2+1 =6"
                    },
                    {
                        "username": "thunderfly",
                        "content": "if present [] or [[]]\\nleetcode will show\\nLine 933: Char 34: runtime error: pointer index expression with base 0x000000000000 overflowed to 0xfffffffffffffffc (stl_vector.h)\\n\\nare these also valid test case that should be take care of?"
                    },
                    {
                        "username": "viku_kr",
                        "content": "There is minimum 1 row and 1 column. So, this case will not occur."
                    },
                    {
                        "username": "serinsabu",
                        "content": "Why my case I==0 && j==0  is not working , it gives integer.max_value as the result  for all cases in java but in c++ if we give 1e9 then it gives right answer, instead I==m-1 and j==n-1 works and going towards right and down position works"
                    },
                    {
                        "username": "AlecLC",
                        "content": "Why is this medium\n\n    def minPathSum(self, grid: List[List[int]]) -> int:\n        for r in range(len(grid)):\n            for c in range(len(grid[0])):\n                if r and c:\n                    grid[r][c] += min(grid[r-1][c], grid[r][c-1])\n                elif not r and c:\n                    grid[r][c] += grid[r][c-1]\n                elif not c and r:\n                    grid[r][c] += grid[r-1][c]\n        \n        return grid[-1][-1]"
                    },
                    {
                        "username": "sk03167",
                        "content": "Can we leave the discussion tab just for general discussions. Posting full solutions here lead to useless cluttering. If you want to post solutions, you can use the solutions tab. "
                    },
                    {
                        "username": "rushabhvg",
                        "content": "Cause they don\\'t think that this is easy!"
                    },
                    {
                        "username": "ihsansfd",
                        "content": "After learning Dijkstra I know get confused on why DP/DFS with cache is used in preference of BFS. It's shortest path problem right. I solved it both ways I DP performs better (DP = N* M, Dijkstra = log(N * M) M * N). \n\nLearning new algorithm makes me confused on which approach I have to decide in the first place :(. People told me that when you hear \"shortest path\", use BFS. But this???"
                    },
                    {
                        "username": "yash45885",
                        "content": "Best tabulated JAVA solution : \\nclass Solution {\\n    public int minPathSum(int[][] grid) {\\n        int m = grid.length;\\n        int n = grid[0].length;\\n        int[][] dp = new int[m][n];\\n        //dp[0][0] = grid[0][0];\\n\\n        for(int i=0;i<m;i++){\\n            int down = 0, right = 0;\\n            for(int j=0;j<n;j++){\\n                if(i==0 && j==0)\\n                    dp[i][j] = grid[i][j];\\n                else{\\n                    if(i>0)\\n                        down = grid[i][j] + dp[i-1][j];\\n                    else\\n                        down = grid[i][j] + (int)(1e9);\\n                    if(j>0)\\n                        right = grid[i][j] + dp[i][j-1];\\n                    else\\n                        right = grid[i][j] + (int)(1e9);\\n                    dp[i][j] = Math.min(down, right);\\n                }\\n            }\\n        }\\n        return dp[m-1][n-1];\\n    }\\n}"
                    },
                    {
                        "username": "kanukolanuManjith",
                        "content": "class Solution {\\npublic:\\n    int m,n;\\n    int minPathSum(vector<vector<int>>& grid) {\\n        int a=1000;\\n        m=grid.size();\\n        n=grid[0].size();\\n        pathSum(grid,0,0,0,a);\\n        return a;\\n    }\\n    void pathSum(vector<vector<int>>& grid,int i,int j,int k,int &a)\\n    {\\n        if(i==m && j==n)\\n        {\\n            a=min(a,k);\\n            return ;\\n        }\\n        if(i==m || j==n)\\n        {\\n            return ;\\n        }\\n        k=k+grid[i][j];\\n        pathSum(grid,i,j+1,k,a);\\n        pathSum(grid,i+1,j,k,a);\\n    }\\n};\\n\\nwhat wrong in code pls tell"
                    },
                    {
                        "username": "Shanks333",
                        "content": "Why Memoization giving Memory limit exceeded?"
                    },
                    {
                        "username": "sarthakkharabanda",
                        "content": "It legit took me over an hour to figure out i had missed  `[0]` in `j==grid[0].length-1` -__-"
                    }
                ]
            },
            {
                "id": 2046516,
                "content": [
                    {
                        "username": "DavalC",
                        "content": "The time complexity of the minPathSum function is O(nm), where n is the number of rows in the grid and m is the number of columns in the grid. This is because the function needs to traverse all the cells in the grid once in order to calculate the minimum path sum at each cell.\\n\\nThe space complexity is also O(nm), as the function stores the minimum path sum at each cell in an array. The size of the array is equal to the number of cells in the grid, so the space complexity is linear in the size of the input.\\n\\nIt\\'s worth noting that the space complexity of this function can be improved by using a recursive approach, which would have a space complexity of O(n) due to the use of the call stack. However, this would come at the cost of increased time complexity, as the recursive approach would require additional function calls for each level of recursion."
                    },
                    {
                        "username": "olyabalashova",
                        "content": "Space complexity is O(1) since you don\\'t use any additional space. You can store everything in the original array. If you consider original array in space complexity, then recursive approach wouldn\\'t improve it."
                    },
                    {
                        "username": "khangnguyen0318",
                        "content": "on testcase 13 I got this grid [[1,2,5],[3,2,1]] and expected return is 6, I return 7 so that FAILED, I don\\'t know how. Anyone can explain for me this expectation?"
                    },
                    {
                        "username": "mufaddalali53",
                        "content": "x[0][0] ->x[0][1] ->x[1][1]->x[1][2]\\n1 + 2+ 2+1 =6"
                    },
                    {
                        "username": "thunderfly",
                        "content": "if present [] or [[]]\\nleetcode will show\\nLine 933: Char 34: runtime error: pointer index expression with base 0x000000000000 overflowed to 0xfffffffffffffffc (stl_vector.h)\\n\\nare these also valid test case that should be take care of?"
                    },
                    {
                        "username": "viku_kr",
                        "content": "There is minimum 1 row and 1 column. So, this case will not occur."
                    },
                    {
                        "username": "serinsabu",
                        "content": "Why my case I==0 && j==0  is not working , it gives integer.max_value as the result  for all cases in java but in c++ if we give 1e9 then it gives right answer, instead I==m-1 and j==n-1 works and going towards right and down position works"
                    },
                    {
                        "username": "AlecLC",
                        "content": "Why is this medium\n\n    def minPathSum(self, grid: List[List[int]]) -> int:\n        for r in range(len(grid)):\n            for c in range(len(grid[0])):\n                if r and c:\n                    grid[r][c] += min(grid[r-1][c], grid[r][c-1])\n                elif not r and c:\n                    grid[r][c] += grid[r][c-1]\n                elif not c and r:\n                    grid[r][c] += grid[r-1][c]\n        \n        return grid[-1][-1]"
                    },
                    {
                        "username": "sk03167",
                        "content": "Can we leave the discussion tab just for general discussions. Posting full solutions here lead to useless cluttering. If you want to post solutions, you can use the solutions tab. "
                    },
                    {
                        "username": "rushabhvg",
                        "content": "Cause they don\\'t think that this is easy!"
                    },
                    {
                        "username": "ihsansfd",
                        "content": "After learning Dijkstra I know get confused on why DP/DFS with cache is used in preference of BFS. It's shortest path problem right. I solved it both ways I DP performs better (DP = N* M, Dijkstra = log(N * M) M * N). \n\nLearning new algorithm makes me confused on which approach I have to decide in the first place :(. People told me that when you hear \"shortest path\", use BFS. But this???"
                    },
                    {
                        "username": "yash45885",
                        "content": "Best tabulated JAVA solution : \\nclass Solution {\\n    public int minPathSum(int[][] grid) {\\n        int m = grid.length;\\n        int n = grid[0].length;\\n        int[][] dp = new int[m][n];\\n        //dp[0][0] = grid[0][0];\\n\\n        for(int i=0;i<m;i++){\\n            int down = 0, right = 0;\\n            for(int j=0;j<n;j++){\\n                if(i==0 && j==0)\\n                    dp[i][j] = grid[i][j];\\n                else{\\n                    if(i>0)\\n                        down = grid[i][j] + dp[i-1][j];\\n                    else\\n                        down = grid[i][j] + (int)(1e9);\\n                    if(j>0)\\n                        right = grid[i][j] + dp[i][j-1];\\n                    else\\n                        right = grid[i][j] + (int)(1e9);\\n                    dp[i][j] = Math.min(down, right);\\n                }\\n            }\\n        }\\n        return dp[m-1][n-1];\\n    }\\n}"
                    },
                    {
                        "username": "kanukolanuManjith",
                        "content": "class Solution {\\npublic:\\n    int m,n;\\n    int minPathSum(vector<vector<int>>& grid) {\\n        int a=1000;\\n        m=grid.size();\\n        n=grid[0].size();\\n        pathSum(grid,0,0,0,a);\\n        return a;\\n    }\\n    void pathSum(vector<vector<int>>& grid,int i,int j,int k,int &a)\\n    {\\n        if(i==m && j==n)\\n        {\\n            a=min(a,k);\\n            return ;\\n        }\\n        if(i==m || j==n)\\n        {\\n            return ;\\n        }\\n        k=k+grid[i][j];\\n        pathSum(grid,i,j+1,k,a);\\n        pathSum(grid,i+1,j,k,a);\\n    }\\n};\\n\\nwhat wrong in code pls tell"
                    },
                    {
                        "username": "Shanks333",
                        "content": "Why Memoization giving Memory limit exceeded?"
                    },
                    {
                        "username": "sarthakkharabanda",
                        "content": "It legit took me over an hour to figure out i had missed  `[0]` in `j==grid[0].length-1` -__-"
                    }
                ]
            },
            {
                "id": 2044908,
                "content": [
                    {
                        "username": "DavalC",
                        "content": "The time complexity of the minPathSum function is O(nm), where n is the number of rows in the grid and m is the number of columns in the grid. This is because the function needs to traverse all the cells in the grid once in order to calculate the minimum path sum at each cell.\\n\\nThe space complexity is also O(nm), as the function stores the minimum path sum at each cell in an array. The size of the array is equal to the number of cells in the grid, so the space complexity is linear in the size of the input.\\n\\nIt\\'s worth noting that the space complexity of this function can be improved by using a recursive approach, which would have a space complexity of O(n) due to the use of the call stack. However, this would come at the cost of increased time complexity, as the recursive approach would require additional function calls for each level of recursion."
                    },
                    {
                        "username": "olyabalashova",
                        "content": "Space complexity is O(1) since you don\\'t use any additional space. You can store everything in the original array. If you consider original array in space complexity, then recursive approach wouldn\\'t improve it."
                    },
                    {
                        "username": "khangnguyen0318",
                        "content": "on testcase 13 I got this grid [[1,2,5],[3,2,1]] and expected return is 6, I return 7 so that FAILED, I don\\'t know how. Anyone can explain for me this expectation?"
                    },
                    {
                        "username": "mufaddalali53",
                        "content": "x[0][0] ->x[0][1] ->x[1][1]->x[1][2]\\n1 + 2+ 2+1 =6"
                    },
                    {
                        "username": "thunderfly",
                        "content": "if present [] or [[]]\\nleetcode will show\\nLine 933: Char 34: runtime error: pointer index expression with base 0x000000000000 overflowed to 0xfffffffffffffffc (stl_vector.h)\\n\\nare these also valid test case that should be take care of?"
                    },
                    {
                        "username": "viku_kr",
                        "content": "There is minimum 1 row and 1 column. So, this case will not occur."
                    },
                    {
                        "username": "serinsabu",
                        "content": "Why my case I==0 && j==0  is not working , it gives integer.max_value as the result  for all cases in java but in c++ if we give 1e9 then it gives right answer, instead I==m-1 and j==n-1 works and going towards right and down position works"
                    },
                    {
                        "username": "AlecLC",
                        "content": "Why is this medium\n\n    def minPathSum(self, grid: List[List[int]]) -> int:\n        for r in range(len(grid)):\n            for c in range(len(grid[0])):\n                if r and c:\n                    grid[r][c] += min(grid[r-1][c], grid[r][c-1])\n                elif not r and c:\n                    grid[r][c] += grid[r][c-1]\n                elif not c and r:\n                    grid[r][c] += grid[r-1][c]\n        \n        return grid[-1][-1]"
                    },
                    {
                        "username": "sk03167",
                        "content": "Can we leave the discussion tab just for general discussions. Posting full solutions here lead to useless cluttering. If you want to post solutions, you can use the solutions tab. "
                    },
                    {
                        "username": "rushabhvg",
                        "content": "Cause they don\\'t think that this is easy!"
                    },
                    {
                        "username": "ihsansfd",
                        "content": "After learning Dijkstra I know get confused on why DP/DFS with cache is used in preference of BFS. It's shortest path problem right. I solved it both ways I DP performs better (DP = N* M, Dijkstra = log(N * M) M * N). \n\nLearning new algorithm makes me confused on which approach I have to decide in the first place :(. People told me that when you hear \"shortest path\", use BFS. But this???"
                    },
                    {
                        "username": "yash45885",
                        "content": "Best tabulated JAVA solution : \\nclass Solution {\\n    public int minPathSum(int[][] grid) {\\n        int m = grid.length;\\n        int n = grid[0].length;\\n        int[][] dp = new int[m][n];\\n        //dp[0][0] = grid[0][0];\\n\\n        for(int i=0;i<m;i++){\\n            int down = 0, right = 0;\\n            for(int j=0;j<n;j++){\\n                if(i==0 && j==0)\\n                    dp[i][j] = grid[i][j];\\n                else{\\n                    if(i>0)\\n                        down = grid[i][j] + dp[i-1][j];\\n                    else\\n                        down = grid[i][j] + (int)(1e9);\\n                    if(j>0)\\n                        right = grid[i][j] + dp[i][j-1];\\n                    else\\n                        right = grid[i][j] + (int)(1e9);\\n                    dp[i][j] = Math.min(down, right);\\n                }\\n            }\\n        }\\n        return dp[m-1][n-1];\\n    }\\n}"
                    },
                    {
                        "username": "kanukolanuManjith",
                        "content": "class Solution {\\npublic:\\n    int m,n;\\n    int minPathSum(vector<vector<int>>& grid) {\\n        int a=1000;\\n        m=grid.size();\\n        n=grid[0].size();\\n        pathSum(grid,0,0,0,a);\\n        return a;\\n    }\\n    void pathSum(vector<vector<int>>& grid,int i,int j,int k,int &a)\\n    {\\n        if(i==m && j==n)\\n        {\\n            a=min(a,k);\\n            return ;\\n        }\\n        if(i==m || j==n)\\n        {\\n            return ;\\n        }\\n        k=k+grid[i][j];\\n        pathSum(grid,i,j+1,k,a);\\n        pathSum(grid,i+1,j,k,a);\\n    }\\n};\\n\\nwhat wrong in code pls tell"
                    },
                    {
                        "username": "Shanks333",
                        "content": "Why Memoization giving Memory limit exceeded?"
                    },
                    {
                        "username": "sarthakkharabanda",
                        "content": "It legit took me over an hour to figure out i had missed  `[0]` in `j==grid[0].length-1` -__-"
                    }
                ]
            },
            {
                "id": 2044546,
                "content": [
                    {
                        "username": "layyy",
                        "content": "very similar to unique paths 1 and 2"
                    },
                    {
                        "username": "rustii_rust",
                        "content": "Oh, I love this type of DP problems, so concise so elegant, \\uD83D\\uDE0A "
                    },
                    {
                        "username": "HotSpices",
                        "content": "Can anyone tell me what i did wrong,  this works for the first two testcases but doesn't when grid = [[1,3],[1,1]].\n\nclass Solution:\n    def __init__(self):\n        self.res = float(\"Inf\")\n    def minPathSum(self, grid: List[List[int]]) -> int:\n        self.path(grid, len(grid) - 1, len(grid[0])- 1, grid[len(grid) - 1][len(grid[0]) - 1])\n        return self.res\n    def path(self, grid, m, n, total):\n        if m == n == 0:\n            self.res = min(self.res, total)\n            return\n        if m != 0:\n            return self.path(grid, m - 1, n, total + grid[m-1][n])\n        if n != 0:\n            return self.path(grid, m, n - 1, total + grid[m][n-1])\n\n\n        \n\n        "
                    },
                    {
                        "username": "oops_moment",
                        "content": "Things become so easy with recursion + memoization , but i need to practise hard to directly write dp solution :((. Any suggestions "
                    },
                    {
                        "username": "JustinAdams",
                        "content": "2D prefix-sum."
                    },
                    {
                        "username": "himanshuyadav6224",
                        "content": "can someone tell why this is TLE\\nint solve(vector<vector<int>> grid,int n,int m,vector<vector<int>> &dp){\\n        if(dp[n][m] != -1) return dp[n][m];\\n        if(n == 0 and m == 0) return grid[0][0];\\n        int left = 500, right = 500;\\n        if(n > 0)\\n            left = solve(grid,n-1,m,dp);\\n        if(m > 0)\\n            right = solve(grid,n,m-1,dp) ;\\n        return dp[n][m] = min(left, right) + grid[n][m];\\n    }\\n"
                    },
                    {
                        "username": "cai9",
                        "content": "what is non-negative numbers condition used for? I think the dp solution also works for negative cell value."
                    },
                    {
                        "username": "lepamoore",
                        "content": "Hey, I\\'m kinda new to coding. I tried to solve this Problem in JavaScript. I needed some time, but I got it. The first 10 testcases are passing, but the eleventh test killed it. I got this error: FATAL ERROR: Scavenger: semi-space copy Allocation failed - JavaScript heap out of memory. That\\'s pretty fucked up because I think my solution is correct since it solves all paths correctly, but it seems to take too much space or smth i don\\'t really know. If someone could tell me how to improve, I would really appreciate that. Thank You!\\nHere you can see my Code:\\n\\n `\\n/**\\n * @param {number[][]} grid\\n * @return {number}\\n */\\n\\nvar permArr = [],\\n  usedChars = [];\\n\\nfunction permute(input) {\\n  var i, ch;\\n  for (i = 0; i < input.length; i++) {\\n    ch = input.splice(i, 1)[0];\\n    usedChars.push(ch);\\n    if (input.length === 0) {\\n      permArr.push(usedChars.slice());\\n    }\\n    permute(input);\\n    input.splice(i, 0, ch);\\n    usedChars.pop();\\n  }\\n  return permArr;\\n}\\n\\nvar minPathSum = function (grid) {\\n  let arrToPermute = [];\\n  let uniqueCombinations = [];\\n  let gridX = 0;\\n  let gridY = 0;\\n  let solutionArr = [];\\n  let newArr = [];\\n\\n  if (grid[0].length === 1) {\\n    return grid[0][0];\\n  }\\n\\n  for (let i = 0; i < grid.length - 1; i++) {\\n    arrToPermute.push(\"y\");\\n  }\\n\\n  for (let j = 0; j < grid[0].length - 1; j++) {\\n    arrToPermute.push(\"x\");\\n  }\\n\\n  let combinations = permute(arrToPermute);\\n\\n  combinations.forEach((element) => {\\n    if (!uniqueCombinations.includes(element.toString())) {\\n      uniqueCombinations.push(element.toString());\\n    }\\n  });\\n\\n  uniqueCombinations = uniqueCombinations.map((element) => element.split(\",\"));\\n\\n  for (let outerLoop = 0; outerLoop < uniqueCombinations.length; outerLoop++) {\\n    newArr = [];\\n    gridY = 0;\\n    gridX = 0;\\n    newArr.push(grid[0][0]);\\n    for (\\n      let innerLoop = 0;\\n      innerLoop < uniqueCombinations[outerLoop].length;\\n      innerLoop++\\n    ) {\\n      if (uniqueCombinations[outerLoop][innerLoop] === \"y\") {\\n        gridY++;\\n      } else if (uniqueCombinations[outerLoop][innerLoop] === \"x\") {\\n        gridX++;\\n      }\\n      newArr.push(grid[gridY][gridX]);\\n    }\\n    solutionArr.push(newArr);\\n  }\\n\\n  for (let a = 0; a < solutionArr.length; a++) {\\n    solutionArr[a] = solutionArr[a].reduce(\\n      (accumulator, currentValue) => accumulator + currentValue,\\n      0\\n    );\\n  }\\n  permArr = [];\\n  usedChars = [];\\n\\n  return Math.min(...solutionArr);\\n};\\n\\n`"
                    },
                    {
                        "username": "user4836NR",
                        "content": "grid = [[1,2],[1,1]]\\nwhy the answer for this 3?\\n1 2\\n1 1 \\n1+2+1 = 4 right?"
                    },
                    {
                        "username": "user4836NR",
                        "content": "[@khangnguyen0318](/khangnguyen0318) ahhh okay thanks"
                    },
                    {
                        "username": "khangnguyen0318",
                        "content": "you need to understand the question. There are 2 paths to reach the goal at bottom right and you should return the minimum sum the result is 1 -> 1 -> 1 and total is 3"
                    },
                    {
                        "username": "parascode",
                        "content": "DP week lesssgo.."
                    }
                ]
            },
            {
                "id": 1991689,
                "content": [
                    {
                        "username": "layyy",
                        "content": "very similar to unique paths 1 and 2"
                    },
                    {
                        "username": "rustii_rust",
                        "content": "Oh, I love this type of DP problems, so concise so elegant, \\uD83D\\uDE0A "
                    },
                    {
                        "username": "HotSpices",
                        "content": "Can anyone tell me what i did wrong,  this works for the first two testcases but doesn't when grid = [[1,3],[1,1]].\n\nclass Solution:\n    def __init__(self):\n        self.res = float(\"Inf\")\n    def minPathSum(self, grid: List[List[int]]) -> int:\n        self.path(grid, len(grid) - 1, len(grid[0])- 1, grid[len(grid) - 1][len(grid[0]) - 1])\n        return self.res\n    def path(self, grid, m, n, total):\n        if m == n == 0:\n            self.res = min(self.res, total)\n            return\n        if m != 0:\n            return self.path(grid, m - 1, n, total + grid[m-1][n])\n        if n != 0:\n            return self.path(grid, m, n - 1, total + grid[m][n-1])\n\n\n        \n\n        "
                    },
                    {
                        "username": "oops_moment",
                        "content": "Things become so easy with recursion + memoization , but i need to practise hard to directly write dp solution :((. Any suggestions "
                    },
                    {
                        "username": "JustinAdams",
                        "content": "2D prefix-sum."
                    },
                    {
                        "username": "himanshuyadav6224",
                        "content": "can someone tell why this is TLE\\nint solve(vector<vector<int>> grid,int n,int m,vector<vector<int>> &dp){\\n        if(dp[n][m] != -1) return dp[n][m];\\n        if(n == 0 and m == 0) return grid[0][0];\\n        int left = 500, right = 500;\\n        if(n > 0)\\n            left = solve(grid,n-1,m,dp);\\n        if(m > 0)\\n            right = solve(grid,n,m-1,dp) ;\\n        return dp[n][m] = min(left, right) + grid[n][m];\\n    }\\n"
                    },
                    {
                        "username": "cai9",
                        "content": "what is non-negative numbers condition used for? I think the dp solution also works for negative cell value."
                    },
                    {
                        "username": "lepamoore",
                        "content": "Hey, I\\'m kinda new to coding. I tried to solve this Problem in JavaScript. I needed some time, but I got it. The first 10 testcases are passing, but the eleventh test killed it. I got this error: FATAL ERROR: Scavenger: semi-space copy Allocation failed - JavaScript heap out of memory. That\\'s pretty fucked up because I think my solution is correct since it solves all paths correctly, but it seems to take too much space or smth i don\\'t really know. If someone could tell me how to improve, I would really appreciate that. Thank You!\\nHere you can see my Code:\\n\\n `\\n/**\\n * @param {number[][]} grid\\n * @return {number}\\n */\\n\\nvar permArr = [],\\n  usedChars = [];\\n\\nfunction permute(input) {\\n  var i, ch;\\n  for (i = 0; i < input.length; i++) {\\n    ch = input.splice(i, 1)[0];\\n    usedChars.push(ch);\\n    if (input.length === 0) {\\n      permArr.push(usedChars.slice());\\n    }\\n    permute(input);\\n    input.splice(i, 0, ch);\\n    usedChars.pop();\\n  }\\n  return permArr;\\n}\\n\\nvar minPathSum = function (grid) {\\n  let arrToPermute = [];\\n  let uniqueCombinations = [];\\n  let gridX = 0;\\n  let gridY = 0;\\n  let solutionArr = [];\\n  let newArr = [];\\n\\n  if (grid[0].length === 1) {\\n    return grid[0][0];\\n  }\\n\\n  for (let i = 0; i < grid.length - 1; i++) {\\n    arrToPermute.push(\"y\");\\n  }\\n\\n  for (let j = 0; j < grid[0].length - 1; j++) {\\n    arrToPermute.push(\"x\");\\n  }\\n\\n  let combinations = permute(arrToPermute);\\n\\n  combinations.forEach((element) => {\\n    if (!uniqueCombinations.includes(element.toString())) {\\n      uniqueCombinations.push(element.toString());\\n    }\\n  });\\n\\n  uniqueCombinations = uniqueCombinations.map((element) => element.split(\",\"));\\n\\n  for (let outerLoop = 0; outerLoop < uniqueCombinations.length; outerLoop++) {\\n    newArr = [];\\n    gridY = 0;\\n    gridX = 0;\\n    newArr.push(grid[0][0]);\\n    for (\\n      let innerLoop = 0;\\n      innerLoop < uniqueCombinations[outerLoop].length;\\n      innerLoop++\\n    ) {\\n      if (uniqueCombinations[outerLoop][innerLoop] === \"y\") {\\n        gridY++;\\n      } else if (uniqueCombinations[outerLoop][innerLoop] === \"x\") {\\n        gridX++;\\n      }\\n      newArr.push(grid[gridY][gridX]);\\n    }\\n    solutionArr.push(newArr);\\n  }\\n\\n  for (let a = 0; a < solutionArr.length; a++) {\\n    solutionArr[a] = solutionArr[a].reduce(\\n      (accumulator, currentValue) => accumulator + currentValue,\\n      0\\n    );\\n  }\\n  permArr = [];\\n  usedChars = [];\\n\\n  return Math.min(...solutionArr);\\n};\\n\\n`"
                    },
                    {
                        "username": "user4836NR",
                        "content": "grid = [[1,2],[1,1]]\\nwhy the answer for this 3?\\n1 2\\n1 1 \\n1+2+1 = 4 right?"
                    },
                    {
                        "username": "user4836NR",
                        "content": "[@khangnguyen0318](/khangnguyen0318) ahhh okay thanks"
                    },
                    {
                        "username": "khangnguyen0318",
                        "content": "you need to understand the question. There are 2 paths to reach the goal at bottom right and you should return the minimum sum the result is 1 -> 1 -> 1 and total is 3"
                    },
                    {
                        "username": "parascode",
                        "content": "DP week lesssgo.."
                    }
                ]
            },
            {
                "id": 1970176,
                "content": [
                    {
                        "username": "layyy",
                        "content": "very similar to unique paths 1 and 2"
                    },
                    {
                        "username": "rustii_rust",
                        "content": "Oh, I love this type of DP problems, so concise so elegant, \\uD83D\\uDE0A "
                    },
                    {
                        "username": "HotSpices",
                        "content": "Can anyone tell me what i did wrong,  this works for the first two testcases but doesn't when grid = [[1,3],[1,1]].\n\nclass Solution:\n    def __init__(self):\n        self.res = float(\"Inf\")\n    def minPathSum(self, grid: List[List[int]]) -> int:\n        self.path(grid, len(grid) - 1, len(grid[0])- 1, grid[len(grid) - 1][len(grid[0]) - 1])\n        return self.res\n    def path(self, grid, m, n, total):\n        if m == n == 0:\n            self.res = min(self.res, total)\n            return\n        if m != 0:\n            return self.path(grid, m - 1, n, total + grid[m-1][n])\n        if n != 0:\n            return self.path(grid, m, n - 1, total + grid[m][n-1])\n\n\n        \n\n        "
                    },
                    {
                        "username": "oops_moment",
                        "content": "Things become so easy with recursion + memoization , but i need to practise hard to directly write dp solution :((. Any suggestions "
                    },
                    {
                        "username": "JustinAdams",
                        "content": "2D prefix-sum."
                    },
                    {
                        "username": "himanshuyadav6224",
                        "content": "can someone tell why this is TLE\\nint solve(vector<vector<int>> grid,int n,int m,vector<vector<int>> &dp){\\n        if(dp[n][m] != -1) return dp[n][m];\\n        if(n == 0 and m == 0) return grid[0][0];\\n        int left = 500, right = 500;\\n        if(n > 0)\\n            left = solve(grid,n-1,m,dp);\\n        if(m > 0)\\n            right = solve(grid,n,m-1,dp) ;\\n        return dp[n][m] = min(left, right) + grid[n][m];\\n    }\\n"
                    },
                    {
                        "username": "cai9",
                        "content": "what is non-negative numbers condition used for? I think the dp solution also works for negative cell value."
                    },
                    {
                        "username": "lepamoore",
                        "content": "Hey, I\\'m kinda new to coding. I tried to solve this Problem in JavaScript. I needed some time, but I got it. The first 10 testcases are passing, but the eleventh test killed it. I got this error: FATAL ERROR: Scavenger: semi-space copy Allocation failed - JavaScript heap out of memory. That\\'s pretty fucked up because I think my solution is correct since it solves all paths correctly, but it seems to take too much space or smth i don\\'t really know. If someone could tell me how to improve, I would really appreciate that. Thank You!\\nHere you can see my Code:\\n\\n `\\n/**\\n * @param {number[][]} grid\\n * @return {number}\\n */\\n\\nvar permArr = [],\\n  usedChars = [];\\n\\nfunction permute(input) {\\n  var i, ch;\\n  for (i = 0; i < input.length; i++) {\\n    ch = input.splice(i, 1)[0];\\n    usedChars.push(ch);\\n    if (input.length === 0) {\\n      permArr.push(usedChars.slice());\\n    }\\n    permute(input);\\n    input.splice(i, 0, ch);\\n    usedChars.pop();\\n  }\\n  return permArr;\\n}\\n\\nvar minPathSum = function (grid) {\\n  let arrToPermute = [];\\n  let uniqueCombinations = [];\\n  let gridX = 0;\\n  let gridY = 0;\\n  let solutionArr = [];\\n  let newArr = [];\\n\\n  if (grid[0].length === 1) {\\n    return grid[0][0];\\n  }\\n\\n  for (let i = 0; i < grid.length - 1; i++) {\\n    arrToPermute.push(\"y\");\\n  }\\n\\n  for (let j = 0; j < grid[0].length - 1; j++) {\\n    arrToPermute.push(\"x\");\\n  }\\n\\n  let combinations = permute(arrToPermute);\\n\\n  combinations.forEach((element) => {\\n    if (!uniqueCombinations.includes(element.toString())) {\\n      uniqueCombinations.push(element.toString());\\n    }\\n  });\\n\\n  uniqueCombinations = uniqueCombinations.map((element) => element.split(\",\"));\\n\\n  for (let outerLoop = 0; outerLoop < uniqueCombinations.length; outerLoop++) {\\n    newArr = [];\\n    gridY = 0;\\n    gridX = 0;\\n    newArr.push(grid[0][0]);\\n    for (\\n      let innerLoop = 0;\\n      innerLoop < uniqueCombinations[outerLoop].length;\\n      innerLoop++\\n    ) {\\n      if (uniqueCombinations[outerLoop][innerLoop] === \"y\") {\\n        gridY++;\\n      } else if (uniqueCombinations[outerLoop][innerLoop] === \"x\") {\\n        gridX++;\\n      }\\n      newArr.push(grid[gridY][gridX]);\\n    }\\n    solutionArr.push(newArr);\\n  }\\n\\n  for (let a = 0; a < solutionArr.length; a++) {\\n    solutionArr[a] = solutionArr[a].reduce(\\n      (accumulator, currentValue) => accumulator + currentValue,\\n      0\\n    );\\n  }\\n  permArr = [];\\n  usedChars = [];\\n\\n  return Math.min(...solutionArr);\\n};\\n\\n`"
                    },
                    {
                        "username": "user4836NR",
                        "content": "grid = [[1,2],[1,1]]\\nwhy the answer for this 3?\\n1 2\\n1 1 \\n1+2+1 = 4 right?"
                    },
                    {
                        "username": "user4836NR",
                        "content": "[@khangnguyen0318](/khangnguyen0318) ahhh okay thanks"
                    },
                    {
                        "username": "khangnguyen0318",
                        "content": "you need to understand the question. There are 2 paths to reach the goal at bottom right and you should return the minimum sum the result is 1 -> 1 -> 1 and total is 3"
                    },
                    {
                        "username": "parascode",
                        "content": "DP week lesssgo.."
                    }
                ]
            },
            {
                "id": 1968499,
                "content": [
                    {
                        "username": "layyy",
                        "content": "very similar to unique paths 1 and 2"
                    },
                    {
                        "username": "rustii_rust",
                        "content": "Oh, I love this type of DP problems, so concise so elegant, \\uD83D\\uDE0A "
                    },
                    {
                        "username": "HotSpices",
                        "content": "Can anyone tell me what i did wrong,  this works for the first two testcases but doesn't when grid = [[1,3],[1,1]].\n\nclass Solution:\n    def __init__(self):\n        self.res = float(\"Inf\")\n    def minPathSum(self, grid: List[List[int]]) -> int:\n        self.path(grid, len(grid) - 1, len(grid[0])- 1, grid[len(grid) - 1][len(grid[0]) - 1])\n        return self.res\n    def path(self, grid, m, n, total):\n        if m == n == 0:\n            self.res = min(self.res, total)\n            return\n        if m != 0:\n            return self.path(grid, m - 1, n, total + grid[m-1][n])\n        if n != 0:\n            return self.path(grid, m, n - 1, total + grid[m][n-1])\n\n\n        \n\n        "
                    },
                    {
                        "username": "oops_moment",
                        "content": "Things become so easy with recursion + memoization , but i need to practise hard to directly write dp solution :((. Any suggestions "
                    },
                    {
                        "username": "JustinAdams",
                        "content": "2D prefix-sum."
                    },
                    {
                        "username": "himanshuyadav6224",
                        "content": "can someone tell why this is TLE\\nint solve(vector<vector<int>> grid,int n,int m,vector<vector<int>> &dp){\\n        if(dp[n][m] != -1) return dp[n][m];\\n        if(n == 0 and m == 0) return grid[0][0];\\n        int left = 500, right = 500;\\n        if(n > 0)\\n            left = solve(grid,n-1,m,dp);\\n        if(m > 0)\\n            right = solve(grid,n,m-1,dp) ;\\n        return dp[n][m] = min(left, right) + grid[n][m];\\n    }\\n"
                    },
                    {
                        "username": "cai9",
                        "content": "what is non-negative numbers condition used for? I think the dp solution also works for negative cell value."
                    },
                    {
                        "username": "lepamoore",
                        "content": "Hey, I\\'m kinda new to coding. I tried to solve this Problem in JavaScript. I needed some time, but I got it. The first 10 testcases are passing, but the eleventh test killed it. I got this error: FATAL ERROR: Scavenger: semi-space copy Allocation failed - JavaScript heap out of memory. That\\'s pretty fucked up because I think my solution is correct since it solves all paths correctly, but it seems to take too much space or smth i don\\'t really know. If someone could tell me how to improve, I would really appreciate that. Thank You!\\nHere you can see my Code:\\n\\n `\\n/**\\n * @param {number[][]} grid\\n * @return {number}\\n */\\n\\nvar permArr = [],\\n  usedChars = [];\\n\\nfunction permute(input) {\\n  var i, ch;\\n  for (i = 0; i < input.length; i++) {\\n    ch = input.splice(i, 1)[0];\\n    usedChars.push(ch);\\n    if (input.length === 0) {\\n      permArr.push(usedChars.slice());\\n    }\\n    permute(input);\\n    input.splice(i, 0, ch);\\n    usedChars.pop();\\n  }\\n  return permArr;\\n}\\n\\nvar minPathSum = function (grid) {\\n  let arrToPermute = [];\\n  let uniqueCombinations = [];\\n  let gridX = 0;\\n  let gridY = 0;\\n  let solutionArr = [];\\n  let newArr = [];\\n\\n  if (grid[0].length === 1) {\\n    return grid[0][0];\\n  }\\n\\n  for (let i = 0; i < grid.length - 1; i++) {\\n    arrToPermute.push(\"y\");\\n  }\\n\\n  for (let j = 0; j < grid[0].length - 1; j++) {\\n    arrToPermute.push(\"x\");\\n  }\\n\\n  let combinations = permute(arrToPermute);\\n\\n  combinations.forEach((element) => {\\n    if (!uniqueCombinations.includes(element.toString())) {\\n      uniqueCombinations.push(element.toString());\\n    }\\n  });\\n\\n  uniqueCombinations = uniqueCombinations.map((element) => element.split(\",\"));\\n\\n  for (let outerLoop = 0; outerLoop < uniqueCombinations.length; outerLoop++) {\\n    newArr = [];\\n    gridY = 0;\\n    gridX = 0;\\n    newArr.push(grid[0][0]);\\n    for (\\n      let innerLoop = 0;\\n      innerLoop < uniqueCombinations[outerLoop].length;\\n      innerLoop++\\n    ) {\\n      if (uniqueCombinations[outerLoop][innerLoop] === \"y\") {\\n        gridY++;\\n      } else if (uniqueCombinations[outerLoop][innerLoop] === \"x\") {\\n        gridX++;\\n      }\\n      newArr.push(grid[gridY][gridX]);\\n    }\\n    solutionArr.push(newArr);\\n  }\\n\\n  for (let a = 0; a < solutionArr.length; a++) {\\n    solutionArr[a] = solutionArr[a].reduce(\\n      (accumulator, currentValue) => accumulator + currentValue,\\n      0\\n    );\\n  }\\n  permArr = [];\\n  usedChars = [];\\n\\n  return Math.min(...solutionArr);\\n};\\n\\n`"
                    },
                    {
                        "username": "user4836NR",
                        "content": "grid = [[1,2],[1,1]]\\nwhy the answer for this 3?\\n1 2\\n1 1 \\n1+2+1 = 4 right?"
                    },
                    {
                        "username": "user4836NR",
                        "content": "[@khangnguyen0318](/khangnguyen0318) ahhh okay thanks"
                    },
                    {
                        "username": "khangnguyen0318",
                        "content": "you need to understand the question. There are 2 paths to reach the goal at bottom right and you should return the minimum sum the result is 1 -> 1 -> 1 and total is 3"
                    },
                    {
                        "username": "parascode",
                        "content": "DP week lesssgo.."
                    }
                ]
            },
            {
                "id": 1963540,
                "content": [
                    {
                        "username": "layyy",
                        "content": "very similar to unique paths 1 and 2"
                    },
                    {
                        "username": "rustii_rust",
                        "content": "Oh, I love this type of DP problems, so concise so elegant, \\uD83D\\uDE0A "
                    },
                    {
                        "username": "HotSpices",
                        "content": "Can anyone tell me what i did wrong,  this works for the first two testcases but doesn't when grid = [[1,3],[1,1]].\n\nclass Solution:\n    def __init__(self):\n        self.res = float(\"Inf\")\n    def minPathSum(self, grid: List[List[int]]) -> int:\n        self.path(grid, len(grid) - 1, len(grid[0])- 1, grid[len(grid) - 1][len(grid[0]) - 1])\n        return self.res\n    def path(self, grid, m, n, total):\n        if m == n == 0:\n            self.res = min(self.res, total)\n            return\n        if m != 0:\n            return self.path(grid, m - 1, n, total + grid[m-1][n])\n        if n != 0:\n            return self.path(grid, m, n - 1, total + grid[m][n-1])\n\n\n        \n\n        "
                    },
                    {
                        "username": "oops_moment",
                        "content": "Things become so easy with recursion + memoization , but i need to practise hard to directly write dp solution :((. Any suggestions "
                    },
                    {
                        "username": "JustinAdams",
                        "content": "2D prefix-sum."
                    },
                    {
                        "username": "himanshuyadav6224",
                        "content": "can someone tell why this is TLE\\nint solve(vector<vector<int>> grid,int n,int m,vector<vector<int>> &dp){\\n        if(dp[n][m] != -1) return dp[n][m];\\n        if(n == 0 and m == 0) return grid[0][0];\\n        int left = 500, right = 500;\\n        if(n > 0)\\n            left = solve(grid,n-1,m,dp);\\n        if(m > 0)\\n            right = solve(grid,n,m-1,dp) ;\\n        return dp[n][m] = min(left, right) + grid[n][m];\\n    }\\n"
                    },
                    {
                        "username": "cai9",
                        "content": "what is non-negative numbers condition used for? I think the dp solution also works for negative cell value."
                    },
                    {
                        "username": "lepamoore",
                        "content": "Hey, I\\'m kinda new to coding. I tried to solve this Problem in JavaScript. I needed some time, but I got it. The first 10 testcases are passing, but the eleventh test killed it. I got this error: FATAL ERROR: Scavenger: semi-space copy Allocation failed - JavaScript heap out of memory. That\\'s pretty fucked up because I think my solution is correct since it solves all paths correctly, but it seems to take too much space or smth i don\\'t really know. If someone could tell me how to improve, I would really appreciate that. Thank You!\\nHere you can see my Code:\\n\\n `\\n/**\\n * @param {number[][]} grid\\n * @return {number}\\n */\\n\\nvar permArr = [],\\n  usedChars = [];\\n\\nfunction permute(input) {\\n  var i, ch;\\n  for (i = 0; i < input.length; i++) {\\n    ch = input.splice(i, 1)[0];\\n    usedChars.push(ch);\\n    if (input.length === 0) {\\n      permArr.push(usedChars.slice());\\n    }\\n    permute(input);\\n    input.splice(i, 0, ch);\\n    usedChars.pop();\\n  }\\n  return permArr;\\n}\\n\\nvar minPathSum = function (grid) {\\n  let arrToPermute = [];\\n  let uniqueCombinations = [];\\n  let gridX = 0;\\n  let gridY = 0;\\n  let solutionArr = [];\\n  let newArr = [];\\n\\n  if (grid[0].length === 1) {\\n    return grid[0][0];\\n  }\\n\\n  for (let i = 0; i < grid.length - 1; i++) {\\n    arrToPermute.push(\"y\");\\n  }\\n\\n  for (let j = 0; j < grid[0].length - 1; j++) {\\n    arrToPermute.push(\"x\");\\n  }\\n\\n  let combinations = permute(arrToPermute);\\n\\n  combinations.forEach((element) => {\\n    if (!uniqueCombinations.includes(element.toString())) {\\n      uniqueCombinations.push(element.toString());\\n    }\\n  });\\n\\n  uniqueCombinations = uniqueCombinations.map((element) => element.split(\",\"));\\n\\n  for (let outerLoop = 0; outerLoop < uniqueCombinations.length; outerLoop++) {\\n    newArr = [];\\n    gridY = 0;\\n    gridX = 0;\\n    newArr.push(grid[0][0]);\\n    for (\\n      let innerLoop = 0;\\n      innerLoop < uniqueCombinations[outerLoop].length;\\n      innerLoop++\\n    ) {\\n      if (uniqueCombinations[outerLoop][innerLoop] === \"y\") {\\n        gridY++;\\n      } else if (uniqueCombinations[outerLoop][innerLoop] === \"x\") {\\n        gridX++;\\n      }\\n      newArr.push(grid[gridY][gridX]);\\n    }\\n    solutionArr.push(newArr);\\n  }\\n\\n  for (let a = 0; a < solutionArr.length; a++) {\\n    solutionArr[a] = solutionArr[a].reduce(\\n      (accumulator, currentValue) => accumulator + currentValue,\\n      0\\n    );\\n  }\\n  permArr = [];\\n  usedChars = [];\\n\\n  return Math.min(...solutionArr);\\n};\\n\\n`"
                    },
                    {
                        "username": "user4836NR",
                        "content": "grid = [[1,2],[1,1]]\\nwhy the answer for this 3?\\n1 2\\n1 1 \\n1+2+1 = 4 right?"
                    },
                    {
                        "username": "user4836NR",
                        "content": "[@khangnguyen0318](/khangnguyen0318) ahhh okay thanks"
                    },
                    {
                        "username": "khangnguyen0318",
                        "content": "you need to understand the question. There are 2 paths to reach the goal at bottom right and you should return the minimum sum the result is 1 -> 1 -> 1 and total is 3"
                    },
                    {
                        "username": "parascode",
                        "content": "DP week lesssgo.."
                    }
                ]
            },
            {
                "id": 1922475,
                "content": [
                    {
                        "username": "layyy",
                        "content": "very similar to unique paths 1 and 2"
                    },
                    {
                        "username": "rustii_rust",
                        "content": "Oh, I love this type of DP problems, so concise so elegant, \\uD83D\\uDE0A "
                    },
                    {
                        "username": "HotSpices",
                        "content": "Can anyone tell me what i did wrong,  this works for the first two testcases but doesn't when grid = [[1,3],[1,1]].\n\nclass Solution:\n    def __init__(self):\n        self.res = float(\"Inf\")\n    def minPathSum(self, grid: List[List[int]]) -> int:\n        self.path(grid, len(grid) - 1, len(grid[0])- 1, grid[len(grid) - 1][len(grid[0]) - 1])\n        return self.res\n    def path(self, grid, m, n, total):\n        if m == n == 0:\n            self.res = min(self.res, total)\n            return\n        if m != 0:\n            return self.path(grid, m - 1, n, total + grid[m-1][n])\n        if n != 0:\n            return self.path(grid, m, n - 1, total + grid[m][n-1])\n\n\n        \n\n        "
                    },
                    {
                        "username": "oops_moment",
                        "content": "Things become so easy with recursion + memoization , but i need to practise hard to directly write dp solution :((. Any suggestions "
                    },
                    {
                        "username": "JustinAdams",
                        "content": "2D prefix-sum."
                    },
                    {
                        "username": "himanshuyadav6224",
                        "content": "can someone tell why this is TLE\\nint solve(vector<vector<int>> grid,int n,int m,vector<vector<int>> &dp){\\n        if(dp[n][m] != -1) return dp[n][m];\\n        if(n == 0 and m == 0) return grid[0][0];\\n        int left = 500, right = 500;\\n        if(n > 0)\\n            left = solve(grid,n-1,m,dp);\\n        if(m > 0)\\n            right = solve(grid,n,m-1,dp) ;\\n        return dp[n][m] = min(left, right) + grid[n][m];\\n    }\\n"
                    },
                    {
                        "username": "cai9",
                        "content": "what is non-negative numbers condition used for? I think the dp solution also works for negative cell value."
                    },
                    {
                        "username": "lepamoore",
                        "content": "Hey, I\\'m kinda new to coding. I tried to solve this Problem in JavaScript. I needed some time, but I got it. The first 10 testcases are passing, but the eleventh test killed it. I got this error: FATAL ERROR: Scavenger: semi-space copy Allocation failed - JavaScript heap out of memory. That\\'s pretty fucked up because I think my solution is correct since it solves all paths correctly, but it seems to take too much space or smth i don\\'t really know. If someone could tell me how to improve, I would really appreciate that. Thank You!\\nHere you can see my Code:\\n\\n `\\n/**\\n * @param {number[][]} grid\\n * @return {number}\\n */\\n\\nvar permArr = [],\\n  usedChars = [];\\n\\nfunction permute(input) {\\n  var i, ch;\\n  for (i = 0; i < input.length; i++) {\\n    ch = input.splice(i, 1)[0];\\n    usedChars.push(ch);\\n    if (input.length === 0) {\\n      permArr.push(usedChars.slice());\\n    }\\n    permute(input);\\n    input.splice(i, 0, ch);\\n    usedChars.pop();\\n  }\\n  return permArr;\\n}\\n\\nvar minPathSum = function (grid) {\\n  let arrToPermute = [];\\n  let uniqueCombinations = [];\\n  let gridX = 0;\\n  let gridY = 0;\\n  let solutionArr = [];\\n  let newArr = [];\\n\\n  if (grid[0].length === 1) {\\n    return grid[0][0];\\n  }\\n\\n  for (let i = 0; i < grid.length - 1; i++) {\\n    arrToPermute.push(\"y\");\\n  }\\n\\n  for (let j = 0; j < grid[0].length - 1; j++) {\\n    arrToPermute.push(\"x\");\\n  }\\n\\n  let combinations = permute(arrToPermute);\\n\\n  combinations.forEach((element) => {\\n    if (!uniqueCombinations.includes(element.toString())) {\\n      uniqueCombinations.push(element.toString());\\n    }\\n  });\\n\\n  uniqueCombinations = uniqueCombinations.map((element) => element.split(\",\"));\\n\\n  for (let outerLoop = 0; outerLoop < uniqueCombinations.length; outerLoop++) {\\n    newArr = [];\\n    gridY = 0;\\n    gridX = 0;\\n    newArr.push(grid[0][0]);\\n    for (\\n      let innerLoop = 0;\\n      innerLoop < uniqueCombinations[outerLoop].length;\\n      innerLoop++\\n    ) {\\n      if (uniqueCombinations[outerLoop][innerLoop] === \"y\") {\\n        gridY++;\\n      } else if (uniqueCombinations[outerLoop][innerLoop] === \"x\") {\\n        gridX++;\\n      }\\n      newArr.push(grid[gridY][gridX]);\\n    }\\n    solutionArr.push(newArr);\\n  }\\n\\n  for (let a = 0; a < solutionArr.length; a++) {\\n    solutionArr[a] = solutionArr[a].reduce(\\n      (accumulator, currentValue) => accumulator + currentValue,\\n      0\\n    );\\n  }\\n  permArr = [];\\n  usedChars = [];\\n\\n  return Math.min(...solutionArr);\\n};\\n\\n`"
                    },
                    {
                        "username": "user4836NR",
                        "content": "grid = [[1,2],[1,1]]\\nwhy the answer for this 3?\\n1 2\\n1 1 \\n1+2+1 = 4 right?"
                    },
                    {
                        "username": "user4836NR",
                        "content": "[@khangnguyen0318](/khangnguyen0318) ahhh okay thanks"
                    },
                    {
                        "username": "khangnguyen0318",
                        "content": "you need to understand the question. There are 2 paths to reach the goal at bottom right and you should return the minimum sum the result is 1 -> 1 -> 1 and total is 3"
                    },
                    {
                        "username": "parascode",
                        "content": "DP week lesssgo.."
                    }
                ]
            },
            {
                "id": 1910311,
                "content": [
                    {
                        "username": "layyy",
                        "content": "very similar to unique paths 1 and 2"
                    },
                    {
                        "username": "rustii_rust",
                        "content": "Oh, I love this type of DP problems, so concise so elegant, \\uD83D\\uDE0A "
                    },
                    {
                        "username": "HotSpices",
                        "content": "Can anyone tell me what i did wrong,  this works for the first two testcases but doesn't when grid = [[1,3],[1,1]].\n\nclass Solution:\n    def __init__(self):\n        self.res = float(\"Inf\")\n    def minPathSum(self, grid: List[List[int]]) -> int:\n        self.path(grid, len(grid) - 1, len(grid[0])- 1, grid[len(grid) - 1][len(grid[0]) - 1])\n        return self.res\n    def path(self, grid, m, n, total):\n        if m == n == 0:\n            self.res = min(self.res, total)\n            return\n        if m != 0:\n            return self.path(grid, m - 1, n, total + grid[m-1][n])\n        if n != 0:\n            return self.path(grid, m, n - 1, total + grid[m][n-1])\n\n\n        \n\n        "
                    },
                    {
                        "username": "oops_moment",
                        "content": "Things become so easy with recursion + memoization , but i need to practise hard to directly write dp solution :((. Any suggestions "
                    },
                    {
                        "username": "JustinAdams",
                        "content": "2D prefix-sum."
                    },
                    {
                        "username": "himanshuyadav6224",
                        "content": "can someone tell why this is TLE\\nint solve(vector<vector<int>> grid,int n,int m,vector<vector<int>> &dp){\\n        if(dp[n][m] != -1) return dp[n][m];\\n        if(n == 0 and m == 0) return grid[0][0];\\n        int left = 500, right = 500;\\n        if(n > 0)\\n            left = solve(grid,n-1,m,dp);\\n        if(m > 0)\\n            right = solve(grid,n,m-1,dp) ;\\n        return dp[n][m] = min(left, right) + grid[n][m];\\n    }\\n"
                    },
                    {
                        "username": "cai9",
                        "content": "what is non-negative numbers condition used for? I think the dp solution also works for negative cell value."
                    },
                    {
                        "username": "lepamoore",
                        "content": "Hey, I\\'m kinda new to coding. I tried to solve this Problem in JavaScript. I needed some time, but I got it. The first 10 testcases are passing, but the eleventh test killed it. I got this error: FATAL ERROR: Scavenger: semi-space copy Allocation failed - JavaScript heap out of memory. That\\'s pretty fucked up because I think my solution is correct since it solves all paths correctly, but it seems to take too much space or smth i don\\'t really know. If someone could tell me how to improve, I would really appreciate that. Thank You!\\nHere you can see my Code:\\n\\n `\\n/**\\n * @param {number[][]} grid\\n * @return {number}\\n */\\n\\nvar permArr = [],\\n  usedChars = [];\\n\\nfunction permute(input) {\\n  var i, ch;\\n  for (i = 0; i < input.length; i++) {\\n    ch = input.splice(i, 1)[0];\\n    usedChars.push(ch);\\n    if (input.length === 0) {\\n      permArr.push(usedChars.slice());\\n    }\\n    permute(input);\\n    input.splice(i, 0, ch);\\n    usedChars.pop();\\n  }\\n  return permArr;\\n}\\n\\nvar minPathSum = function (grid) {\\n  let arrToPermute = [];\\n  let uniqueCombinations = [];\\n  let gridX = 0;\\n  let gridY = 0;\\n  let solutionArr = [];\\n  let newArr = [];\\n\\n  if (grid[0].length === 1) {\\n    return grid[0][0];\\n  }\\n\\n  for (let i = 0; i < grid.length - 1; i++) {\\n    arrToPermute.push(\"y\");\\n  }\\n\\n  for (let j = 0; j < grid[0].length - 1; j++) {\\n    arrToPermute.push(\"x\");\\n  }\\n\\n  let combinations = permute(arrToPermute);\\n\\n  combinations.forEach((element) => {\\n    if (!uniqueCombinations.includes(element.toString())) {\\n      uniqueCombinations.push(element.toString());\\n    }\\n  });\\n\\n  uniqueCombinations = uniqueCombinations.map((element) => element.split(\",\"));\\n\\n  for (let outerLoop = 0; outerLoop < uniqueCombinations.length; outerLoop++) {\\n    newArr = [];\\n    gridY = 0;\\n    gridX = 0;\\n    newArr.push(grid[0][0]);\\n    for (\\n      let innerLoop = 0;\\n      innerLoop < uniqueCombinations[outerLoop].length;\\n      innerLoop++\\n    ) {\\n      if (uniqueCombinations[outerLoop][innerLoop] === \"y\") {\\n        gridY++;\\n      } else if (uniqueCombinations[outerLoop][innerLoop] === \"x\") {\\n        gridX++;\\n      }\\n      newArr.push(grid[gridY][gridX]);\\n    }\\n    solutionArr.push(newArr);\\n  }\\n\\n  for (let a = 0; a < solutionArr.length; a++) {\\n    solutionArr[a] = solutionArr[a].reduce(\\n      (accumulator, currentValue) => accumulator + currentValue,\\n      0\\n    );\\n  }\\n  permArr = [];\\n  usedChars = [];\\n\\n  return Math.min(...solutionArr);\\n};\\n\\n`"
                    },
                    {
                        "username": "user4836NR",
                        "content": "grid = [[1,2],[1,1]]\\nwhy the answer for this 3?\\n1 2\\n1 1 \\n1+2+1 = 4 right?"
                    },
                    {
                        "username": "user4836NR",
                        "content": "[@khangnguyen0318](/khangnguyen0318) ahhh okay thanks"
                    },
                    {
                        "username": "khangnguyen0318",
                        "content": "you need to understand the question. There are 2 paths to reach the goal at bottom right and you should return the minimum sum the result is 1 -> 1 -> 1 and total is 3"
                    },
                    {
                        "username": "parascode",
                        "content": "DP week lesssgo.."
                    }
                ]
            },
            {
                "id": 1845593,
                "content": [
                    {
                        "username": "layyy",
                        "content": "very similar to unique paths 1 and 2"
                    },
                    {
                        "username": "rustii_rust",
                        "content": "Oh, I love this type of DP problems, so concise so elegant, \\uD83D\\uDE0A "
                    },
                    {
                        "username": "HotSpices",
                        "content": "Can anyone tell me what i did wrong,  this works for the first two testcases but doesn't when grid = [[1,3],[1,1]].\n\nclass Solution:\n    def __init__(self):\n        self.res = float(\"Inf\")\n    def minPathSum(self, grid: List[List[int]]) -> int:\n        self.path(grid, len(grid) - 1, len(grid[0])- 1, grid[len(grid) - 1][len(grid[0]) - 1])\n        return self.res\n    def path(self, grid, m, n, total):\n        if m == n == 0:\n            self.res = min(self.res, total)\n            return\n        if m != 0:\n            return self.path(grid, m - 1, n, total + grid[m-1][n])\n        if n != 0:\n            return self.path(grid, m, n - 1, total + grid[m][n-1])\n\n\n        \n\n        "
                    },
                    {
                        "username": "oops_moment",
                        "content": "Things become so easy with recursion + memoization , but i need to practise hard to directly write dp solution :((. Any suggestions "
                    },
                    {
                        "username": "JustinAdams",
                        "content": "2D prefix-sum."
                    },
                    {
                        "username": "himanshuyadav6224",
                        "content": "can someone tell why this is TLE\\nint solve(vector<vector<int>> grid,int n,int m,vector<vector<int>> &dp){\\n        if(dp[n][m] != -1) return dp[n][m];\\n        if(n == 0 and m == 0) return grid[0][0];\\n        int left = 500, right = 500;\\n        if(n > 0)\\n            left = solve(grid,n-1,m,dp);\\n        if(m > 0)\\n            right = solve(grid,n,m-1,dp) ;\\n        return dp[n][m] = min(left, right) + grid[n][m];\\n    }\\n"
                    },
                    {
                        "username": "cai9",
                        "content": "what is non-negative numbers condition used for? I think the dp solution also works for negative cell value."
                    },
                    {
                        "username": "lepamoore",
                        "content": "Hey, I\\'m kinda new to coding. I tried to solve this Problem in JavaScript. I needed some time, but I got it. The first 10 testcases are passing, but the eleventh test killed it. I got this error: FATAL ERROR: Scavenger: semi-space copy Allocation failed - JavaScript heap out of memory. That\\'s pretty fucked up because I think my solution is correct since it solves all paths correctly, but it seems to take too much space or smth i don\\'t really know. If someone could tell me how to improve, I would really appreciate that. Thank You!\\nHere you can see my Code:\\n\\n `\\n/**\\n * @param {number[][]} grid\\n * @return {number}\\n */\\n\\nvar permArr = [],\\n  usedChars = [];\\n\\nfunction permute(input) {\\n  var i, ch;\\n  for (i = 0; i < input.length; i++) {\\n    ch = input.splice(i, 1)[0];\\n    usedChars.push(ch);\\n    if (input.length === 0) {\\n      permArr.push(usedChars.slice());\\n    }\\n    permute(input);\\n    input.splice(i, 0, ch);\\n    usedChars.pop();\\n  }\\n  return permArr;\\n}\\n\\nvar minPathSum = function (grid) {\\n  let arrToPermute = [];\\n  let uniqueCombinations = [];\\n  let gridX = 0;\\n  let gridY = 0;\\n  let solutionArr = [];\\n  let newArr = [];\\n\\n  if (grid[0].length === 1) {\\n    return grid[0][0];\\n  }\\n\\n  for (let i = 0; i < grid.length - 1; i++) {\\n    arrToPermute.push(\"y\");\\n  }\\n\\n  for (let j = 0; j < grid[0].length - 1; j++) {\\n    arrToPermute.push(\"x\");\\n  }\\n\\n  let combinations = permute(arrToPermute);\\n\\n  combinations.forEach((element) => {\\n    if (!uniqueCombinations.includes(element.toString())) {\\n      uniqueCombinations.push(element.toString());\\n    }\\n  });\\n\\n  uniqueCombinations = uniqueCombinations.map((element) => element.split(\",\"));\\n\\n  for (let outerLoop = 0; outerLoop < uniqueCombinations.length; outerLoop++) {\\n    newArr = [];\\n    gridY = 0;\\n    gridX = 0;\\n    newArr.push(grid[0][0]);\\n    for (\\n      let innerLoop = 0;\\n      innerLoop < uniqueCombinations[outerLoop].length;\\n      innerLoop++\\n    ) {\\n      if (uniqueCombinations[outerLoop][innerLoop] === \"y\") {\\n        gridY++;\\n      } else if (uniqueCombinations[outerLoop][innerLoop] === \"x\") {\\n        gridX++;\\n      }\\n      newArr.push(grid[gridY][gridX]);\\n    }\\n    solutionArr.push(newArr);\\n  }\\n\\n  for (let a = 0; a < solutionArr.length; a++) {\\n    solutionArr[a] = solutionArr[a].reduce(\\n      (accumulator, currentValue) => accumulator + currentValue,\\n      0\\n    );\\n  }\\n  permArr = [];\\n  usedChars = [];\\n\\n  return Math.min(...solutionArr);\\n};\\n\\n`"
                    },
                    {
                        "username": "user4836NR",
                        "content": "grid = [[1,2],[1,1]]\\nwhy the answer for this 3?\\n1 2\\n1 1 \\n1+2+1 = 4 right?"
                    },
                    {
                        "username": "user4836NR",
                        "content": "[@khangnguyen0318](/khangnguyen0318) ahhh okay thanks"
                    },
                    {
                        "username": "khangnguyen0318",
                        "content": "you need to understand the question. There are 2 paths to reach the goal at bottom right and you should return the minimum sum the result is 1 -> 1 -> 1 and total is 3"
                    },
                    {
                        "username": "parascode",
                        "content": "DP week lesssgo.."
                    }
                ]
            },
            {
                "id": 1845487,
                "content": [
                    {
                        "username": "layyy",
                        "content": "very similar to unique paths 1 and 2"
                    },
                    {
                        "username": "rustii_rust",
                        "content": "Oh, I love this type of DP problems, so concise so elegant, \\uD83D\\uDE0A "
                    },
                    {
                        "username": "HotSpices",
                        "content": "Can anyone tell me what i did wrong,  this works for the first two testcases but doesn't when grid = [[1,3],[1,1]].\n\nclass Solution:\n    def __init__(self):\n        self.res = float(\"Inf\")\n    def minPathSum(self, grid: List[List[int]]) -> int:\n        self.path(grid, len(grid) - 1, len(grid[0])- 1, grid[len(grid) - 1][len(grid[0]) - 1])\n        return self.res\n    def path(self, grid, m, n, total):\n        if m == n == 0:\n            self.res = min(self.res, total)\n            return\n        if m != 0:\n            return self.path(grid, m - 1, n, total + grid[m-1][n])\n        if n != 0:\n            return self.path(grid, m, n - 1, total + grid[m][n-1])\n\n\n        \n\n        "
                    },
                    {
                        "username": "oops_moment",
                        "content": "Things become so easy with recursion + memoization , but i need to practise hard to directly write dp solution :((. Any suggestions "
                    },
                    {
                        "username": "JustinAdams",
                        "content": "2D prefix-sum."
                    },
                    {
                        "username": "himanshuyadav6224",
                        "content": "can someone tell why this is TLE\\nint solve(vector<vector<int>> grid,int n,int m,vector<vector<int>> &dp){\\n        if(dp[n][m] != -1) return dp[n][m];\\n        if(n == 0 and m == 0) return grid[0][0];\\n        int left = 500, right = 500;\\n        if(n > 0)\\n            left = solve(grid,n-1,m,dp);\\n        if(m > 0)\\n            right = solve(grid,n,m-1,dp) ;\\n        return dp[n][m] = min(left, right) + grid[n][m];\\n    }\\n"
                    },
                    {
                        "username": "cai9",
                        "content": "what is non-negative numbers condition used for? I think the dp solution also works for negative cell value."
                    },
                    {
                        "username": "lepamoore",
                        "content": "Hey, I\\'m kinda new to coding. I tried to solve this Problem in JavaScript. I needed some time, but I got it. The first 10 testcases are passing, but the eleventh test killed it. I got this error: FATAL ERROR: Scavenger: semi-space copy Allocation failed - JavaScript heap out of memory. That\\'s pretty fucked up because I think my solution is correct since it solves all paths correctly, but it seems to take too much space or smth i don\\'t really know. If someone could tell me how to improve, I would really appreciate that. Thank You!\\nHere you can see my Code:\\n\\n `\\n/**\\n * @param {number[][]} grid\\n * @return {number}\\n */\\n\\nvar permArr = [],\\n  usedChars = [];\\n\\nfunction permute(input) {\\n  var i, ch;\\n  for (i = 0; i < input.length; i++) {\\n    ch = input.splice(i, 1)[0];\\n    usedChars.push(ch);\\n    if (input.length === 0) {\\n      permArr.push(usedChars.slice());\\n    }\\n    permute(input);\\n    input.splice(i, 0, ch);\\n    usedChars.pop();\\n  }\\n  return permArr;\\n}\\n\\nvar minPathSum = function (grid) {\\n  let arrToPermute = [];\\n  let uniqueCombinations = [];\\n  let gridX = 0;\\n  let gridY = 0;\\n  let solutionArr = [];\\n  let newArr = [];\\n\\n  if (grid[0].length === 1) {\\n    return grid[0][0];\\n  }\\n\\n  for (let i = 0; i < grid.length - 1; i++) {\\n    arrToPermute.push(\"y\");\\n  }\\n\\n  for (let j = 0; j < grid[0].length - 1; j++) {\\n    arrToPermute.push(\"x\");\\n  }\\n\\n  let combinations = permute(arrToPermute);\\n\\n  combinations.forEach((element) => {\\n    if (!uniqueCombinations.includes(element.toString())) {\\n      uniqueCombinations.push(element.toString());\\n    }\\n  });\\n\\n  uniqueCombinations = uniqueCombinations.map((element) => element.split(\",\"));\\n\\n  for (let outerLoop = 0; outerLoop < uniqueCombinations.length; outerLoop++) {\\n    newArr = [];\\n    gridY = 0;\\n    gridX = 0;\\n    newArr.push(grid[0][0]);\\n    for (\\n      let innerLoop = 0;\\n      innerLoop < uniqueCombinations[outerLoop].length;\\n      innerLoop++\\n    ) {\\n      if (uniqueCombinations[outerLoop][innerLoop] === \"y\") {\\n        gridY++;\\n      } else if (uniqueCombinations[outerLoop][innerLoop] === \"x\") {\\n        gridX++;\\n      }\\n      newArr.push(grid[gridY][gridX]);\\n    }\\n    solutionArr.push(newArr);\\n  }\\n\\n  for (let a = 0; a < solutionArr.length; a++) {\\n    solutionArr[a] = solutionArr[a].reduce(\\n      (accumulator, currentValue) => accumulator + currentValue,\\n      0\\n    );\\n  }\\n  permArr = [];\\n  usedChars = [];\\n\\n  return Math.min(...solutionArr);\\n};\\n\\n`"
                    },
                    {
                        "username": "user4836NR",
                        "content": "grid = [[1,2],[1,1]]\\nwhy the answer for this 3?\\n1 2\\n1 1 \\n1+2+1 = 4 right?"
                    },
                    {
                        "username": "user4836NR",
                        "content": "[@khangnguyen0318](/khangnguyen0318) ahhh okay thanks"
                    },
                    {
                        "username": "khangnguyen0318",
                        "content": "you need to understand the question. There are 2 paths to reach the goal at bottom right and you should return the minimum sum the result is 1 -> 1 -> 1 and total is 3"
                    },
                    {
                        "username": "parascode",
                        "content": "DP week lesssgo.."
                    }
                ]
            },
            {
                "id": 1845410,
                "content": [
                    {
                        "username": "layyy",
                        "content": "very similar to unique paths 1 and 2"
                    },
                    {
                        "username": "rustii_rust",
                        "content": "Oh, I love this type of DP problems, so concise so elegant, \\uD83D\\uDE0A "
                    },
                    {
                        "username": "HotSpices",
                        "content": "Can anyone tell me what i did wrong,  this works for the first two testcases but doesn't when grid = [[1,3],[1,1]].\n\nclass Solution:\n    def __init__(self):\n        self.res = float(\"Inf\")\n    def minPathSum(self, grid: List[List[int]]) -> int:\n        self.path(grid, len(grid) - 1, len(grid[0])- 1, grid[len(grid) - 1][len(grid[0]) - 1])\n        return self.res\n    def path(self, grid, m, n, total):\n        if m == n == 0:\n            self.res = min(self.res, total)\n            return\n        if m != 0:\n            return self.path(grid, m - 1, n, total + grid[m-1][n])\n        if n != 0:\n            return self.path(grid, m, n - 1, total + grid[m][n-1])\n\n\n        \n\n        "
                    },
                    {
                        "username": "oops_moment",
                        "content": "Things become so easy with recursion + memoization , but i need to practise hard to directly write dp solution :((. Any suggestions "
                    },
                    {
                        "username": "JustinAdams",
                        "content": "2D prefix-sum."
                    },
                    {
                        "username": "himanshuyadav6224",
                        "content": "can someone tell why this is TLE\\nint solve(vector<vector<int>> grid,int n,int m,vector<vector<int>> &dp){\\n        if(dp[n][m] != -1) return dp[n][m];\\n        if(n == 0 and m == 0) return grid[0][0];\\n        int left = 500, right = 500;\\n        if(n > 0)\\n            left = solve(grid,n-1,m,dp);\\n        if(m > 0)\\n            right = solve(grid,n,m-1,dp) ;\\n        return dp[n][m] = min(left, right) + grid[n][m];\\n    }\\n"
                    },
                    {
                        "username": "cai9",
                        "content": "what is non-negative numbers condition used for? I think the dp solution also works for negative cell value."
                    },
                    {
                        "username": "lepamoore",
                        "content": "Hey, I\\'m kinda new to coding. I tried to solve this Problem in JavaScript. I needed some time, but I got it. The first 10 testcases are passing, but the eleventh test killed it. I got this error: FATAL ERROR: Scavenger: semi-space copy Allocation failed - JavaScript heap out of memory. That\\'s pretty fucked up because I think my solution is correct since it solves all paths correctly, but it seems to take too much space or smth i don\\'t really know. If someone could tell me how to improve, I would really appreciate that. Thank You!\\nHere you can see my Code:\\n\\n `\\n/**\\n * @param {number[][]} grid\\n * @return {number}\\n */\\n\\nvar permArr = [],\\n  usedChars = [];\\n\\nfunction permute(input) {\\n  var i, ch;\\n  for (i = 0; i < input.length; i++) {\\n    ch = input.splice(i, 1)[0];\\n    usedChars.push(ch);\\n    if (input.length === 0) {\\n      permArr.push(usedChars.slice());\\n    }\\n    permute(input);\\n    input.splice(i, 0, ch);\\n    usedChars.pop();\\n  }\\n  return permArr;\\n}\\n\\nvar minPathSum = function (grid) {\\n  let arrToPermute = [];\\n  let uniqueCombinations = [];\\n  let gridX = 0;\\n  let gridY = 0;\\n  let solutionArr = [];\\n  let newArr = [];\\n\\n  if (grid[0].length === 1) {\\n    return grid[0][0];\\n  }\\n\\n  for (let i = 0; i < grid.length - 1; i++) {\\n    arrToPermute.push(\"y\");\\n  }\\n\\n  for (let j = 0; j < grid[0].length - 1; j++) {\\n    arrToPermute.push(\"x\");\\n  }\\n\\n  let combinations = permute(arrToPermute);\\n\\n  combinations.forEach((element) => {\\n    if (!uniqueCombinations.includes(element.toString())) {\\n      uniqueCombinations.push(element.toString());\\n    }\\n  });\\n\\n  uniqueCombinations = uniqueCombinations.map((element) => element.split(\",\"));\\n\\n  for (let outerLoop = 0; outerLoop < uniqueCombinations.length; outerLoop++) {\\n    newArr = [];\\n    gridY = 0;\\n    gridX = 0;\\n    newArr.push(grid[0][0]);\\n    for (\\n      let innerLoop = 0;\\n      innerLoop < uniqueCombinations[outerLoop].length;\\n      innerLoop++\\n    ) {\\n      if (uniqueCombinations[outerLoop][innerLoop] === \"y\") {\\n        gridY++;\\n      } else if (uniqueCombinations[outerLoop][innerLoop] === \"x\") {\\n        gridX++;\\n      }\\n      newArr.push(grid[gridY][gridX]);\\n    }\\n    solutionArr.push(newArr);\\n  }\\n\\n  for (let a = 0; a < solutionArr.length; a++) {\\n    solutionArr[a] = solutionArr[a].reduce(\\n      (accumulator, currentValue) => accumulator + currentValue,\\n      0\\n    );\\n  }\\n  permArr = [];\\n  usedChars = [];\\n\\n  return Math.min(...solutionArr);\\n};\\n\\n`"
                    },
                    {
                        "username": "user4836NR",
                        "content": "grid = [[1,2],[1,1]]\\nwhy the answer for this 3?\\n1 2\\n1 1 \\n1+2+1 = 4 right?"
                    },
                    {
                        "username": "user4836NR",
                        "content": "[@khangnguyen0318](/khangnguyen0318) ahhh okay thanks"
                    },
                    {
                        "username": "khangnguyen0318",
                        "content": "you need to understand the question. There are 2 paths to reach the goal at bottom right and you should return the minimum sum the result is 1 -> 1 -> 1 and total is 3"
                    },
                    {
                        "username": "parascode",
                        "content": "DP week lesssgo.."
                    }
                ]
            },
            {
                "id": 1845351,
                "content": [
                    {
                        "username": "NevNadNik",
                        "content": "Is it strange, that it feels easy now?... I remember, how I struggled with same dp/coloring grid 2 months ago. And now it was so... intuitive. "
                    },
                    {
                        "username": "guddukumar0709",
                        "content": "Assume if question were asked to move in any direction at any point of time (not as \"You can only move either down or right at any point in time\").\\n\\nCan you think how to approach this problem.... think twice .... any idea anyone???\\n\\nexample here - \\n\\n[[0,1,1,1,9],\\n[9,9,9,1,9],\\n[9,9,1,3,9],\\n[9,9,1,5,9],\\n[9,9,1,2,1]]\\n\\nfor this minimum path cost =\\n 0 + 1 + 1 + 1 + 1 + 3 + 1 + 1 + 1 + 2 + 1  = 13\\n\\nBut if you run this testcase in this problem(minimum path sum)  you will end up getting solution 15.\\n\\nThink about this way also how to do that problem.\\n"
                    },
                    {
                        "username": "guddukumar0709",
                        "content": "[@rushabhvg](/rushabhvg) \nBut here question is how to approach this problem if their is no such constraints.\n\nAlso as I mention in example i am not going back direction, I am just changing direction to left side which is not visited in past path. \n\nHere is path as I mention above-\n \n[[0,1,1,1---],\n[-------1--],\n[-----1 3--],\n[-----1----],\n[-----1,2,1]]\n\n\nHere question is how to approach this type of problem.\n\n(Note - If question as - You can move in any direction at any point in time)"
                    },
                    {
                        "username": "rushabhvg",
                        "content": "Also, this is a classic/one of the most basic problem of Dynamic Programming (DP). If you have learnt about dynamic programming (dp), you will immediately use not because you learnt it, but, because dp is the easiest way to solve those kind of problems."
                    },
                    {
                        "username": "rushabhvg",
                        "content": "After \"0 + 1 + 1 + 1 + 1 + 3\" it should be either 9 or 5. You can\\'t go back. Exactly as \"Note: You can only move either down or right at any point in time.\""
                    },
                    {
                        "username": "sugarteddy",
                        "content": "Hi, can anyone help \\nif we could move up and left as well in this problem, how the solution will be. Dose DP still work? What should I change in the code? Thanks in advance!"
                    },
                    {
                        "username": "jolswlf",
                        "content": "[@rushabhvg](/rushabhvg) I think DP could still work "
                    },
                    {
                        "username": "rushabhvg",
                        "content": "I guess we can\\'t use DP in that case, don\\'t know about any solution."
                    },
                    {
                        "username": "veeyikpong",
                        "content": "Approach\n1. For each cell, we can come from either top or left, since we can only move down or right\n2. We can compute the current cell minimum value as either:\n   - current cell value + left\n   - current cell value + top\n3. Check for boundary cases for cell 0,0, first row and first column\n\nNote: We can reuse the same input grid to store the computed value, resulting in the space O(1)\n\nExample:\nInput:\n```\n1 3 1\n2 3 2\n4 3 1\n```\n\nDP Table:\n```\n1 4 5\n3 6 7\n7 9 8\n```"
                    },
                    {
                        "username": "veeyikpong",
                        "content": "\\n\\nhttps://leetcode.com/problems/minimum-path-sum/solutions/3346369/kotlin-dp-table-with-o-mn-time-and-o-1-space-simple-code/"
                    },
                    {
                        "username": "sasukesharma",
                        "content": "a 4 ways explained solution: https://leetcode.com/problems/minimum-path-sum/solutions/2677369/recursion-to-space-optimized-in-java/?orderBy=most_votes"
                    },
                    {
                        "username": "sasukesharma",
                        "content": "**this week we have to deal with Dynamic Programming\\nGood luck**"
                    },
                    {
                        "username": "idnedvryaasnein",
                        "content": "Graph week ends..\\nAnd DP week starts.\\n"
                    },
                    {
                        "username": "suren-yeager",
                        "content": "DP week starts \\uD83E\\uDD73"
                    },
                    {
                        "username": "sam_Eldoro",
                        "content": "Friends, TLE!!!!!!!!!"
                    },
                    {
                        "username": "Crispy_coffee",
                        "content": "same bisi"
                    },
                    {
                        "username": "user5400vw",
                        "content": "try to solve it by iterating through each of the 2d array\\'s items in one pass."
                    },
                    {
                        "username": "anwendeng",
                        "content": "How about recursion with memoization?"
                    },
                    {
                        "username": "anwendeng",
                        "content": "Here is a solution:https://leetcode.com/problems/minimum-path-sum/solutions/3347033/easy-memoization-c-solution/"
                    },
                    {
                        "username": "jolswlf",
                        "content": "how and why would you use recursion exactly"
                    }
                ]
            },
            {
                "id": 1845074,
                "content": [
                    {
                        "username": "NevNadNik",
                        "content": "Is it strange, that it feels easy now?... I remember, how I struggled with same dp/coloring grid 2 months ago. And now it was so... intuitive. "
                    },
                    {
                        "username": "guddukumar0709",
                        "content": "Assume if question were asked to move in any direction at any point of time (not as \"You can only move either down or right at any point in time\").\\n\\nCan you think how to approach this problem.... think twice .... any idea anyone???\\n\\nexample here - \\n\\n[[0,1,1,1,9],\\n[9,9,9,1,9],\\n[9,9,1,3,9],\\n[9,9,1,5,9],\\n[9,9,1,2,1]]\\n\\nfor this minimum path cost =\\n 0 + 1 + 1 + 1 + 1 + 3 + 1 + 1 + 1 + 2 + 1  = 13\\n\\nBut if you run this testcase in this problem(minimum path sum)  you will end up getting solution 15.\\n\\nThink about this way also how to do that problem.\\n"
                    },
                    {
                        "username": "guddukumar0709",
                        "content": "[@rushabhvg](/rushabhvg) \nBut here question is how to approach this problem if their is no such constraints.\n\nAlso as I mention in example i am not going back direction, I am just changing direction to left side which is not visited in past path. \n\nHere is path as I mention above-\n \n[[0,1,1,1---],\n[-------1--],\n[-----1 3--],\n[-----1----],\n[-----1,2,1]]\n\n\nHere question is how to approach this type of problem.\n\n(Note - If question as - You can move in any direction at any point in time)"
                    },
                    {
                        "username": "rushabhvg",
                        "content": "Also, this is a classic/one of the most basic problem of Dynamic Programming (DP). If you have learnt about dynamic programming (dp), you will immediately use not because you learnt it, but, because dp is the easiest way to solve those kind of problems."
                    },
                    {
                        "username": "rushabhvg",
                        "content": "After \"0 + 1 + 1 + 1 + 1 + 3\" it should be either 9 or 5. You can\\'t go back. Exactly as \"Note: You can only move either down or right at any point in time.\""
                    },
                    {
                        "username": "sugarteddy",
                        "content": "Hi, can anyone help \\nif we could move up and left as well in this problem, how the solution will be. Dose DP still work? What should I change in the code? Thanks in advance!"
                    },
                    {
                        "username": "jolswlf",
                        "content": "[@rushabhvg](/rushabhvg) I think DP could still work "
                    },
                    {
                        "username": "rushabhvg",
                        "content": "I guess we can\\'t use DP in that case, don\\'t know about any solution."
                    },
                    {
                        "username": "veeyikpong",
                        "content": "Approach\n1. For each cell, we can come from either top or left, since we can only move down or right\n2. We can compute the current cell minimum value as either:\n   - current cell value + left\n   - current cell value + top\n3. Check for boundary cases for cell 0,0, first row and first column\n\nNote: We can reuse the same input grid to store the computed value, resulting in the space O(1)\n\nExample:\nInput:\n```\n1 3 1\n2 3 2\n4 3 1\n```\n\nDP Table:\n```\n1 4 5\n3 6 7\n7 9 8\n```"
                    },
                    {
                        "username": "veeyikpong",
                        "content": "\\n\\nhttps://leetcode.com/problems/minimum-path-sum/solutions/3346369/kotlin-dp-table-with-o-mn-time-and-o-1-space-simple-code/"
                    },
                    {
                        "username": "sasukesharma",
                        "content": "a 4 ways explained solution: https://leetcode.com/problems/minimum-path-sum/solutions/2677369/recursion-to-space-optimized-in-java/?orderBy=most_votes"
                    },
                    {
                        "username": "sasukesharma",
                        "content": "**this week we have to deal with Dynamic Programming\\nGood luck**"
                    },
                    {
                        "username": "idnedvryaasnein",
                        "content": "Graph week ends..\\nAnd DP week starts.\\n"
                    },
                    {
                        "username": "suren-yeager",
                        "content": "DP week starts \\uD83E\\uDD73"
                    },
                    {
                        "username": "sam_Eldoro",
                        "content": "Friends, TLE!!!!!!!!!"
                    },
                    {
                        "username": "Crispy_coffee",
                        "content": "same bisi"
                    },
                    {
                        "username": "user5400vw",
                        "content": "try to solve it by iterating through each of the 2d array\\'s items in one pass."
                    },
                    {
                        "username": "anwendeng",
                        "content": "How about recursion with memoization?"
                    },
                    {
                        "username": "anwendeng",
                        "content": "Here is a solution:https://leetcode.com/problems/minimum-path-sum/solutions/3347033/easy-memoization-c-solution/"
                    },
                    {
                        "username": "jolswlf",
                        "content": "how and why would you use recursion exactly"
                    }
                ]
            },
            {
                "id": 1845032,
                "content": [
                    {
                        "username": "NevNadNik",
                        "content": "Is it strange, that it feels easy now?... I remember, how I struggled with same dp/coloring grid 2 months ago. And now it was so... intuitive. "
                    },
                    {
                        "username": "guddukumar0709",
                        "content": "Assume if question were asked to move in any direction at any point of time (not as \"You can only move either down or right at any point in time\").\\n\\nCan you think how to approach this problem.... think twice .... any idea anyone???\\n\\nexample here - \\n\\n[[0,1,1,1,9],\\n[9,9,9,1,9],\\n[9,9,1,3,9],\\n[9,9,1,5,9],\\n[9,9,1,2,1]]\\n\\nfor this minimum path cost =\\n 0 + 1 + 1 + 1 + 1 + 3 + 1 + 1 + 1 + 2 + 1  = 13\\n\\nBut if you run this testcase in this problem(minimum path sum)  you will end up getting solution 15.\\n\\nThink about this way also how to do that problem.\\n"
                    },
                    {
                        "username": "guddukumar0709",
                        "content": "[@rushabhvg](/rushabhvg) \nBut here question is how to approach this problem if their is no such constraints.\n\nAlso as I mention in example i am not going back direction, I am just changing direction to left side which is not visited in past path. \n\nHere is path as I mention above-\n \n[[0,1,1,1---],\n[-------1--],\n[-----1 3--],\n[-----1----],\n[-----1,2,1]]\n\n\nHere question is how to approach this type of problem.\n\n(Note - If question as - You can move in any direction at any point in time)"
                    },
                    {
                        "username": "rushabhvg",
                        "content": "Also, this is a classic/one of the most basic problem of Dynamic Programming (DP). If you have learnt about dynamic programming (dp), you will immediately use not because you learnt it, but, because dp is the easiest way to solve those kind of problems."
                    },
                    {
                        "username": "rushabhvg",
                        "content": "After \"0 + 1 + 1 + 1 + 1 + 3\" it should be either 9 or 5. You can\\'t go back. Exactly as \"Note: You can only move either down or right at any point in time.\""
                    },
                    {
                        "username": "sugarteddy",
                        "content": "Hi, can anyone help \\nif we could move up and left as well in this problem, how the solution will be. Dose DP still work? What should I change in the code? Thanks in advance!"
                    },
                    {
                        "username": "jolswlf",
                        "content": "[@rushabhvg](/rushabhvg) I think DP could still work "
                    },
                    {
                        "username": "rushabhvg",
                        "content": "I guess we can\\'t use DP in that case, don\\'t know about any solution."
                    },
                    {
                        "username": "veeyikpong",
                        "content": "Approach\n1. For each cell, we can come from either top or left, since we can only move down or right\n2. We can compute the current cell minimum value as either:\n   - current cell value + left\n   - current cell value + top\n3. Check for boundary cases for cell 0,0, first row and first column\n\nNote: We can reuse the same input grid to store the computed value, resulting in the space O(1)\n\nExample:\nInput:\n```\n1 3 1\n2 3 2\n4 3 1\n```\n\nDP Table:\n```\n1 4 5\n3 6 7\n7 9 8\n```"
                    },
                    {
                        "username": "veeyikpong",
                        "content": "\\n\\nhttps://leetcode.com/problems/minimum-path-sum/solutions/3346369/kotlin-dp-table-with-o-mn-time-and-o-1-space-simple-code/"
                    },
                    {
                        "username": "sasukesharma",
                        "content": "a 4 ways explained solution: https://leetcode.com/problems/minimum-path-sum/solutions/2677369/recursion-to-space-optimized-in-java/?orderBy=most_votes"
                    },
                    {
                        "username": "sasukesharma",
                        "content": "**this week we have to deal with Dynamic Programming\\nGood luck**"
                    },
                    {
                        "username": "idnedvryaasnein",
                        "content": "Graph week ends..\\nAnd DP week starts.\\n"
                    },
                    {
                        "username": "suren-yeager",
                        "content": "DP week starts \\uD83E\\uDD73"
                    },
                    {
                        "username": "sam_Eldoro",
                        "content": "Friends, TLE!!!!!!!!!"
                    },
                    {
                        "username": "Crispy_coffee",
                        "content": "same bisi"
                    },
                    {
                        "username": "user5400vw",
                        "content": "try to solve it by iterating through each of the 2d array\\'s items in one pass."
                    },
                    {
                        "username": "anwendeng",
                        "content": "How about recursion with memoization?"
                    },
                    {
                        "username": "anwendeng",
                        "content": "Here is a solution:https://leetcode.com/problems/minimum-path-sum/solutions/3347033/easy-memoization-c-solution/"
                    },
                    {
                        "username": "jolswlf",
                        "content": "how and why would you use recursion exactly"
                    }
                ]
            },
            {
                "id": 1845018,
                "content": [
                    {
                        "username": "NevNadNik",
                        "content": "Is it strange, that it feels easy now?... I remember, how I struggled with same dp/coloring grid 2 months ago. And now it was so... intuitive. "
                    },
                    {
                        "username": "guddukumar0709",
                        "content": "Assume if question were asked to move in any direction at any point of time (not as \"You can only move either down or right at any point in time\").\\n\\nCan you think how to approach this problem.... think twice .... any idea anyone???\\n\\nexample here - \\n\\n[[0,1,1,1,9],\\n[9,9,9,1,9],\\n[9,9,1,3,9],\\n[9,9,1,5,9],\\n[9,9,1,2,1]]\\n\\nfor this minimum path cost =\\n 0 + 1 + 1 + 1 + 1 + 3 + 1 + 1 + 1 + 2 + 1  = 13\\n\\nBut if you run this testcase in this problem(minimum path sum)  you will end up getting solution 15.\\n\\nThink about this way also how to do that problem.\\n"
                    },
                    {
                        "username": "guddukumar0709",
                        "content": "[@rushabhvg](/rushabhvg) \nBut here question is how to approach this problem if their is no such constraints.\n\nAlso as I mention in example i am not going back direction, I am just changing direction to left side which is not visited in past path. \n\nHere is path as I mention above-\n \n[[0,1,1,1---],\n[-------1--],\n[-----1 3--],\n[-----1----],\n[-----1,2,1]]\n\n\nHere question is how to approach this type of problem.\n\n(Note - If question as - You can move in any direction at any point in time)"
                    },
                    {
                        "username": "rushabhvg",
                        "content": "Also, this is a classic/one of the most basic problem of Dynamic Programming (DP). If you have learnt about dynamic programming (dp), you will immediately use not because you learnt it, but, because dp is the easiest way to solve those kind of problems."
                    },
                    {
                        "username": "rushabhvg",
                        "content": "After \"0 + 1 + 1 + 1 + 1 + 3\" it should be either 9 or 5. You can\\'t go back. Exactly as \"Note: You can only move either down or right at any point in time.\""
                    },
                    {
                        "username": "sugarteddy",
                        "content": "Hi, can anyone help \\nif we could move up and left as well in this problem, how the solution will be. Dose DP still work? What should I change in the code? Thanks in advance!"
                    },
                    {
                        "username": "jolswlf",
                        "content": "[@rushabhvg](/rushabhvg) I think DP could still work "
                    },
                    {
                        "username": "rushabhvg",
                        "content": "I guess we can\\'t use DP in that case, don\\'t know about any solution."
                    },
                    {
                        "username": "veeyikpong",
                        "content": "Approach\n1. For each cell, we can come from either top or left, since we can only move down or right\n2. We can compute the current cell minimum value as either:\n   - current cell value + left\n   - current cell value + top\n3. Check for boundary cases for cell 0,0, first row and first column\n\nNote: We can reuse the same input grid to store the computed value, resulting in the space O(1)\n\nExample:\nInput:\n```\n1 3 1\n2 3 2\n4 3 1\n```\n\nDP Table:\n```\n1 4 5\n3 6 7\n7 9 8\n```"
                    },
                    {
                        "username": "veeyikpong",
                        "content": "\\n\\nhttps://leetcode.com/problems/minimum-path-sum/solutions/3346369/kotlin-dp-table-with-o-mn-time-and-o-1-space-simple-code/"
                    },
                    {
                        "username": "sasukesharma",
                        "content": "a 4 ways explained solution: https://leetcode.com/problems/minimum-path-sum/solutions/2677369/recursion-to-space-optimized-in-java/?orderBy=most_votes"
                    },
                    {
                        "username": "sasukesharma",
                        "content": "**this week we have to deal with Dynamic Programming\\nGood luck**"
                    },
                    {
                        "username": "idnedvryaasnein",
                        "content": "Graph week ends..\\nAnd DP week starts.\\n"
                    },
                    {
                        "username": "suren-yeager",
                        "content": "DP week starts \\uD83E\\uDD73"
                    },
                    {
                        "username": "sam_Eldoro",
                        "content": "Friends, TLE!!!!!!!!!"
                    },
                    {
                        "username": "Crispy_coffee",
                        "content": "same bisi"
                    },
                    {
                        "username": "user5400vw",
                        "content": "try to solve it by iterating through each of the 2d array\\'s items in one pass."
                    },
                    {
                        "username": "anwendeng",
                        "content": "How about recursion with memoization?"
                    },
                    {
                        "username": "anwendeng",
                        "content": "Here is a solution:https://leetcode.com/problems/minimum-path-sum/solutions/3347033/easy-memoization-c-solution/"
                    },
                    {
                        "username": "jolswlf",
                        "content": "how and why would you use recursion exactly"
                    }
                ]
            },
            {
                "id": 1844992,
                "content": [
                    {
                        "username": "NevNadNik",
                        "content": "Is it strange, that it feels easy now?... I remember, how I struggled with same dp/coloring grid 2 months ago. And now it was so... intuitive. "
                    },
                    {
                        "username": "guddukumar0709",
                        "content": "Assume if question were asked to move in any direction at any point of time (not as \"You can only move either down or right at any point in time\").\\n\\nCan you think how to approach this problem.... think twice .... any idea anyone???\\n\\nexample here - \\n\\n[[0,1,1,1,9],\\n[9,9,9,1,9],\\n[9,9,1,3,9],\\n[9,9,1,5,9],\\n[9,9,1,2,1]]\\n\\nfor this minimum path cost =\\n 0 + 1 + 1 + 1 + 1 + 3 + 1 + 1 + 1 + 2 + 1  = 13\\n\\nBut if you run this testcase in this problem(minimum path sum)  you will end up getting solution 15.\\n\\nThink about this way also how to do that problem.\\n"
                    },
                    {
                        "username": "guddukumar0709",
                        "content": "[@rushabhvg](/rushabhvg) \nBut here question is how to approach this problem if their is no such constraints.\n\nAlso as I mention in example i am not going back direction, I am just changing direction to left side which is not visited in past path. \n\nHere is path as I mention above-\n \n[[0,1,1,1---],\n[-------1--],\n[-----1 3--],\n[-----1----],\n[-----1,2,1]]\n\n\nHere question is how to approach this type of problem.\n\n(Note - If question as - You can move in any direction at any point in time)"
                    },
                    {
                        "username": "rushabhvg",
                        "content": "Also, this is a classic/one of the most basic problem of Dynamic Programming (DP). If you have learnt about dynamic programming (dp), you will immediately use not because you learnt it, but, because dp is the easiest way to solve those kind of problems."
                    },
                    {
                        "username": "rushabhvg",
                        "content": "After \"0 + 1 + 1 + 1 + 1 + 3\" it should be either 9 or 5. You can\\'t go back. Exactly as \"Note: You can only move either down or right at any point in time.\""
                    },
                    {
                        "username": "sugarteddy",
                        "content": "Hi, can anyone help \\nif we could move up and left as well in this problem, how the solution will be. Dose DP still work? What should I change in the code? Thanks in advance!"
                    },
                    {
                        "username": "jolswlf",
                        "content": "[@rushabhvg](/rushabhvg) I think DP could still work "
                    },
                    {
                        "username": "rushabhvg",
                        "content": "I guess we can\\'t use DP in that case, don\\'t know about any solution."
                    },
                    {
                        "username": "veeyikpong",
                        "content": "Approach\n1. For each cell, we can come from either top or left, since we can only move down or right\n2. We can compute the current cell minimum value as either:\n   - current cell value + left\n   - current cell value + top\n3. Check for boundary cases for cell 0,0, first row and first column\n\nNote: We can reuse the same input grid to store the computed value, resulting in the space O(1)\n\nExample:\nInput:\n```\n1 3 1\n2 3 2\n4 3 1\n```\n\nDP Table:\n```\n1 4 5\n3 6 7\n7 9 8\n```"
                    },
                    {
                        "username": "veeyikpong",
                        "content": "\\n\\nhttps://leetcode.com/problems/minimum-path-sum/solutions/3346369/kotlin-dp-table-with-o-mn-time-and-o-1-space-simple-code/"
                    },
                    {
                        "username": "sasukesharma",
                        "content": "a 4 ways explained solution: https://leetcode.com/problems/minimum-path-sum/solutions/2677369/recursion-to-space-optimized-in-java/?orderBy=most_votes"
                    },
                    {
                        "username": "sasukesharma",
                        "content": "**this week we have to deal with Dynamic Programming\\nGood luck**"
                    },
                    {
                        "username": "idnedvryaasnein",
                        "content": "Graph week ends..\\nAnd DP week starts.\\n"
                    },
                    {
                        "username": "suren-yeager",
                        "content": "DP week starts \\uD83E\\uDD73"
                    },
                    {
                        "username": "sam_Eldoro",
                        "content": "Friends, TLE!!!!!!!!!"
                    },
                    {
                        "username": "Crispy_coffee",
                        "content": "same bisi"
                    },
                    {
                        "username": "user5400vw",
                        "content": "try to solve it by iterating through each of the 2d array\\'s items in one pass."
                    },
                    {
                        "username": "anwendeng",
                        "content": "How about recursion with memoization?"
                    },
                    {
                        "username": "anwendeng",
                        "content": "Here is a solution:https://leetcode.com/problems/minimum-path-sum/solutions/3347033/easy-memoization-c-solution/"
                    },
                    {
                        "username": "jolswlf",
                        "content": "how and why would you use recursion exactly"
                    }
                ]
            },
            {
                "id": 1844962,
                "content": [
                    {
                        "username": "NevNadNik",
                        "content": "Is it strange, that it feels easy now?... I remember, how I struggled with same dp/coloring grid 2 months ago. And now it was so... intuitive. "
                    },
                    {
                        "username": "guddukumar0709",
                        "content": "Assume if question were asked to move in any direction at any point of time (not as \"You can only move either down or right at any point in time\").\\n\\nCan you think how to approach this problem.... think twice .... any idea anyone???\\n\\nexample here - \\n\\n[[0,1,1,1,9],\\n[9,9,9,1,9],\\n[9,9,1,3,9],\\n[9,9,1,5,9],\\n[9,9,1,2,1]]\\n\\nfor this minimum path cost =\\n 0 + 1 + 1 + 1 + 1 + 3 + 1 + 1 + 1 + 2 + 1  = 13\\n\\nBut if you run this testcase in this problem(minimum path sum)  you will end up getting solution 15.\\n\\nThink about this way also how to do that problem.\\n"
                    },
                    {
                        "username": "guddukumar0709",
                        "content": "[@rushabhvg](/rushabhvg) \nBut here question is how to approach this problem if their is no such constraints.\n\nAlso as I mention in example i am not going back direction, I am just changing direction to left side which is not visited in past path. \n\nHere is path as I mention above-\n \n[[0,1,1,1---],\n[-------1--],\n[-----1 3--],\n[-----1----],\n[-----1,2,1]]\n\n\nHere question is how to approach this type of problem.\n\n(Note - If question as - You can move in any direction at any point in time)"
                    },
                    {
                        "username": "rushabhvg",
                        "content": "Also, this is a classic/one of the most basic problem of Dynamic Programming (DP). If you have learnt about dynamic programming (dp), you will immediately use not because you learnt it, but, because dp is the easiest way to solve those kind of problems."
                    },
                    {
                        "username": "rushabhvg",
                        "content": "After \"0 + 1 + 1 + 1 + 1 + 3\" it should be either 9 or 5. You can\\'t go back. Exactly as \"Note: You can only move either down or right at any point in time.\""
                    },
                    {
                        "username": "sugarteddy",
                        "content": "Hi, can anyone help \\nif we could move up and left as well in this problem, how the solution will be. Dose DP still work? What should I change in the code? Thanks in advance!"
                    },
                    {
                        "username": "jolswlf",
                        "content": "[@rushabhvg](/rushabhvg) I think DP could still work "
                    },
                    {
                        "username": "rushabhvg",
                        "content": "I guess we can\\'t use DP in that case, don\\'t know about any solution."
                    },
                    {
                        "username": "veeyikpong",
                        "content": "Approach\n1. For each cell, we can come from either top or left, since we can only move down or right\n2. We can compute the current cell minimum value as either:\n   - current cell value + left\n   - current cell value + top\n3. Check for boundary cases for cell 0,0, first row and first column\n\nNote: We can reuse the same input grid to store the computed value, resulting in the space O(1)\n\nExample:\nInput:\n```\n1 3 1\n2 3 2\n4 3 1\n```\n\nDP Table:\n```\n1 4 5\n3 6 7\n7 9 8\n```"
                    },
                    {
                        "username": "veeyikpong",
                        "content": "\\n\\nhttps://leetcode.com/problems/minimum-path-sum/solutions/3346369/kotlin-dp-table-with-o-mn-time-and-o-1-space-simple-code/"
                    },
                    {
                        "username": "sasukesharma",
                        "content": "a 4 ways explained solution: https://leetcode.com/problems/minimum-path-sum/solutions/2677369/recursion-to-space-optimized-in-java/?orderBy=most_votes"
                    },
                    {
                        "username": "sasukesharma",
                        "content": "**this week we have to deal with Dynamic Programming\\nGood luck**"
                    },
                    {
                        "username": "idnedvryaasnein",
                        "content": "Graph week ends..\\nAnd DP week starts.\\n"
                    },
                    {
                        "username": "suren-yeager",
                        "content": "DP week starts \\uD83E\\uDD73"
                    },
                    {
                        "username": "sam_Eldoro",
                        "content": "Friends, TLE!!!!!!!!!"
                    },
                    {
                        "username": "Crispy_coffee",
                        "content": "same bisi"
                    },
                    {
                        "username": "user5400vw",
                        "content": "try to solve it by iterating through each of the 2d array\\'s items in one pass."
                    },
                    {
                        "username": "anwendeng",
                        "content": "How about recursion with memoization?"
                    },
                    {
                        "username": "anwendeng",
                        "content": "Here is a solution:https://leetcode.com/problems/minimum-path-sum/solutions/3347033/easy-memoization-c-solution/"
                    },
                    {
                        "username": "jolswlf",
                        "content": "how and why would you use recursion exactly"
                    }
                ]
            },
            {
                "id": 1844954,
                "content": [
                    {
                        "username": "NevNadNik",
                        "content": "Is it strange, that it feels easy now?... I remember, how I struggled with same dp/coloring grid 2 months ago. And now it was so... intuitive. "
                    },
                    {
                        "username": "guddukumar0709",
                        "content": "Assume if question were asked to move in any direction at any point of time (not as \"You can only move either down or right at any point in time\").\\n\\nCan you think how to approach this problem.... think twice .... any idea anyone???\\n\\nexample here - \\n\\n[[0,1,1,1,9],\\n[9,9,9,1,9],\\n[9,9,1,3,9],\\n[9,9,1,5,9],\\n[9,9,1,2,1]]\\n\\nfor this minimum path cost =\\n 0 + 1 + 1 + 1 + 1 + 3 + 1 + 1 + 1 + 2 + 1  = 13\\n\\nBut if you run this testcase in this problem(minimum path sum)  you will end up getting solution 15.\\n\\nThink about this way also how to do that problem.\\n"
                    },
                    {
                        "username": "guddukumar0709",
                        "content": "[@rushabhvg](/rushabhvg) \nBut here question is how to approach this problem if their is no such constraints.\n\nAlso as I mention in example i am not going back direction, I am just changing direction to left side which is not visited in past path. \n\nHere is path as I mention above-\n \n[[0,1,1,1---],\n[-------1--],\n[-----1 3--],\n[-----1----],\n[-----1,2,1]]\n\n\nHere question is how to approach this type of problem.\n\n(Note - If question as - You can move in any direction at any point in time)"
                    },
                    {
                        "username": "rushabhvg",
                        "content": "Also, this is a classic/one of the most basic problem of Dynamic Programming (DP). If you have learnt about dynamic programming (dp), you will immediately use not because you learnt it, but, because dp is the easiest way to solve those kind of problems."
                    },
                    {
                        "username": "rushabhvg",
                        "content": "After \"0 + 1 + 1 + 1 + 1 + 3\" it should be either 9 or 5. You can\\'t go back. Exactly as \"Note: You can only move either down or right at any point in time.\""
                    },
                    {
                        "username": "sugarteddy",
                        "content": "Hi, can anyone help \\nif we could move up and left as well in this problem, how the solution will be. Dose DP still work? What should I change in the code? Thanks in advance!"
                    },
                    {
                        "username": "jolswlf",
                        "content": "[@rushabhvg](/rushabhvg) I think DP could still work "
                    },
                    {
                        "username": "rushabhvg",
                        "content": "I guess we can\\'t use DP in that case, don\\'t know about any solution."
                    },
                    {
                        "username": "veeyikpong",
                        "content": "Approach\n1. For each cell, we can come from either top or left, since we can only move down or right\n2. We can compute the current cell minimum value as either:\n   - current cell value + left\n   - current cell value + top\n3. Check for boundary cases for cell 0,0, first row and first column\n\nNote: We can reuse the same input grid to store the computed value, resulting in the space O(1)\n\nExample:\nInput:\n```\n1 3 1\n2 3 2\n4 3 1\n```\n\nDP Table:\n```\n1 4 5\n3 6 7\n7 9 8\n```"
                    },
                    {
                        "username": "veeyikpong",
                        "content": "\\n\\nhttps://leetcode.com/problems/minimum-path-sum/solutions/3346369/kotlin-dp-table-with-o-mn-time-and-o-1-space-simple-code/"
                    },
                    {
                        "username": "sasukesharma",
                        "content": "a 4 ways explained solution: https://leetcode.com/problems/minimum-path-sum/solutions/2677369/recursion-to-space-optimized-in-java/?orderBy=most_votes"
                    },
                    {
                        "username": "sasukesharma",
                        "content": "**this week we have to deal with Dynamic Programming\\nGood luck**"
                    },
                    {
                        "username": "idnedvryaasnein",
                        "content": "Graph week ends..\\nAnd DP week starts.\\n"
                    },
                    {
                        "username": "suren-yeager",
                        "content": "DP week starts \\uD83E\\uDD73"
                    },
                    {
                        "username": "sam_Eldoro",
                        "content": "Friends, TLE!!!!!!!!!"
                    },
                    {
                        "username": "Crispy_coffee",
                        "content": "same bisi"
                    },
                    {
                        "username": "user5400vw",
                        "content": "try to solve it by iterating through each of the 2d array\\'s items in one pass."
                    },
                    {
                        "username": "anwendeng",
                        "content": "How about recursion with memoization?"
                    },
                    {
                        "username": "anwendeng",
                        "content": "Here is a solution:https://leetcode.com/problems/minimum-path-sum/solutions/3347033/easy-memoization-c-solution/"
                    },
                    {
                        "username": "jolswlf",
                        "content": "how and why would you use recursion exactly"
                    }
                ]
            },
            {
                "id": 1844952,
                "content": [
                    {
                        "username": "NevNadNik",
                        "content": "Is it strange, that it feels easy now?... I remember, how I struggled with same dp/coloring grid 2 months ago. And now it was so... intuitive. "
                    },
                    {
                        "username": "guddukumar0709",
                        "content": "Assume if question were asked to move in any direction at any point of time (not as \"You can only move either down or right at any point in time\").\\n\\nCan you think how to approach this problem.... think twice .... any idea anyone???\\n\\nexample here - \\n\\n[[0,1,1,1,9],\\n[9,9,9,1,9],\\n[9,9,1,3,9],\\n[9,9,1,5,9],\\n[9,9,1,2,1]]\\n\\nfor this minimum path cost =\\n 0 + 1 + 1 + 1 + 1 + 3 + 1 + 1 + 1 + 2 + 1  = 13\\n\\nBut if you run this testcase in this problem(minimum path sum)  you will end up getting solution 15.\\n\\nThink about this way also how to do that problem.\\n"
                    },
                    {
                        "username": "guddukumar0709",
                        "content": "[@rushabhvg](/rushabhvg) \nBut here question is how to approach this problem if their is no such constraints.\n\nAlso as I mention in example i am not going back direction, I am just changing direction to left side which is not visited in past path. \n\nHere is path as I mention above-\n \n[[0,1,1,1---],\n[-------1--],\n[-----1 3--],\n[-----1----],\n[-----1,2,1]]\n\n\nHere question is how to approach this type of problem.\n\n(Note - If question as - You can move in any direction at any point in time)"
                    },
                    {
                        "username": "rushabhvg",
                        "content": "Also, this is a classic/one of the most basic problem of Dynamic Programming (DP). If you have learnt about dynamic programming (dp), you will immediately use not because you learnt it, but, because dp is the easiest way to solve those kind of problems."
                    },
                    {
                        "username": "rushabhvg",
                        "content": "After \"0 + 1 + 1 + 1 + 1 + 3\" it should be either 9 or 5. You can\\'t go back. Exactly as \"Note: You can only move either down or right at any point in time.\""
                    },
                    {
                        "username": "sugarteddy",
                        "content": "Hi, can anyone help \\nif we could move up and left as well in this problem, how the solution will be. Dose DP still work? What should I change in the code? Thanks in advance!"
                    },
                    {
                        "username": "jolswlf",
                        "content": "[@rushabhvg](/rushabhvg) I think DP could still work "
                    },
                    {
                        "username": "rushabhvg",
                        "content": "I guess we can\\'t use DP in that case, don\\'t know about any solution."
                    },
                    {
                        "username": "veeyikpong",
                        "content": "Approach\n1. For each cell, we can come from either top or left, since we can only move down or right\n2. We can compute the current cell minimum value as either:\n   - current cell value + left\n   - current cell value + top\n3. Check for boundary cases for cell 0,0, first row and first column\n\nNote: We can reuse the same input grid to store the computed value, resulting in the space O(1)\n\nExample:\nInput:\n```\n1 3 1\n2 3 2\n4 3 1\n```\n\nDP Table:\n```\n1 4 5\n3 6 7\n7 9 8\n```"
                    },
                    {
                        "username": "veeyikpong",
                        "content": "\\n\\nhttps://leetcode.com/problems/minimum-path-sum/solutions/3346369/kotlin-dp-table-with-o-mn-time-and-o-1-space-simple-code/"
                    },
                    {
                        "username": "sasukesharma",
                        "content": "a 4 ways explained solution: https://leetcode.com/problems/minimum-path-sum/solutions/2677369/recursion-to-space-optimized-in-java/?orderBy=most_votes"
                    },
                    {
                        "username": "sasukesharma",
                        "content": "**this week we have to deal with Dynamic Programming\\nGood luck**"
                    },
                    {
                        "username": "idnedvryaasnein",
                        "content": "Graph week ends..\\nAnd DP week starts.\\n"
                    },
                    {
                        "username": "suren-yeager",
                        "content": "DP week starts \\uD83E\\uDD73"
                    },
                    {
                        "username": "sam_Eldoro",
                        "content": "Friends, TLE!!!!!!!!!"
                    },
                    {
                        "username": "Crispy_coffee",
                        "content": "same bisi"
                    },
                    {
                        "username": "user5400vw",
                        "content": "try to solve it by iterating through each of the 2d array\\'s items in one pass."
                    },
                    {
                        "username": "anwendeng",
                        "content": "How about recursion with memoization?"
                    },
                    {
                        "username": "anwendeng",
                        "content": "Here is a solution:https://leetcode.com/problems/minimum-path-sum/solutions/3347033/easy-memoization-c-solution/"
                    },
                    {
                        "username": "jolswlf",
                        "content": "how and why would you use recursion exactly"
                    }
                ]
            },
            {
                "id": 1844923,
                "content": [
                    {
                        "username": "NevNadNik",
                        "content": "Is it strange, that it feels easy now?... I remember, how I struggled with same dp/coloring grid 2 months ago. And now it was so... intuitive. "
                    },
                    {
                        "username": "guddukumar0709",
                        "content": "Assume if question were asked to move in any direction at any point of time (not as \"You can only move either down or right at any point in time\").\\n\\nCan you think how to approach this problem.... think twice .... any idea anyone???\\n\\nexample here - \\n\\n[[0,1,1,1,9],\\n[9,9,9,1,9],\\n[9,9,1,3,9],\\n[9,9,1,5,9],\\n[9,9,1,2,1]]\\n\\nfor this minimum path cost =\\n 0 + 1 + 1 + 1 + 1 + 3 + 1 + 1 + 1 + 2 + 1  = 13\\n\\nBut if you run this testcase in this problem(minimum path sum)  you will end up getting solution 15.\\n\\nThink about this way also how to do that problem.\\n"
                    },
                    {
                        "username": "guddukumar0709",
                        "content": "[@rushabhvg](/rushabhvg) \nBut here question is how to approach this problem if their is no such constraints.\n\nAlso as I mention in example i am not going back direction, I am just changing direction to left side which is not visited in past path. \n\nHere is path as I mention above-\n \n[[0,1,1,1---],\n[-------1--],\n[-----1 3--],\n[-----1----],\n[-----1,2,1]]\n\n\nHere question is how to approach this type of problem.\n\n(Note - If question as - You can move in any direction at any point in time)"
                    },
                    {
                        "username": "rushabhvg",
                        "content": "Also, this is a classic/one of the most basic problem of Dynamic Programming (DP). If you have learnt about dynamic programming (dp), you will immediately use not because you learnt it, but, because dp is the easiest way to solve those kind of problems."
                    },
                    {
                        "username": "rushabhvg",
                        "content": "After \"0 + 1 + 1 + 1 + 1 + 3\" it should be either 9 or 5. You can\\'t go back. Exactly as \"Note: You can only move either down or right at any point in time.\""
                    },
                    {
                        "username": "sugarteddy",
                        "content": "Hi, can anyone help \\nif we could move up and left as well in this problem, how the solution will be. Dose DP still work? What should I change in the code? Thanks in advance!"
                    },
                    {
                        "username": "jolswlf",
                        "content": "[@rushabhvg](/rushabhvg) I think DP could still work "
                    },
                    {
                        "username": "rushabhvg",
                        "content": "I guess we can\\'t use DP in that case, don\\'t know about any solution."
                    },
                    {
                        "username": "veeyikpong",
                        "content": "Approach\n1. For each cell, we can come from either top or left, since we can only move down or right\n2. We can compute the current cell minimum value as either:\n   - current cell value + left\n   - current cell value + top\n3. Check for boundary cases for cell 0,0, first row and first column\n\nNote: We can reuse the same input grid to store the computed value, resulting in the space O(1)\n\nExample:\nInput:\n```\n1 3 1\n2 3 2\n4 3 1\n```\n\nDP Table:\n```\n1 4 5\n3 6 7\n7 9 8\n```"
                    },
                    {
                        "username": "veeyikpong",
                        "content": "\\n\\nhttps://leetcode.com/problems/minimum-path-sum/solutions/3346369/kotlin-dp-table-with-o-mn-time-and-o-1-space-simple-code/"
                    },
                    {
                        "username": "sasukesharma",
                        "content": "a 4 ways explained solution: https://leetcode.com/problems/minimum-path-sum/solutions/2677369/recursion-to-space-optimized-in-java/?orderBy=most_votes"
                    },
                    {
                        "username": "sasukesharma",
                        "content": "**this week we have to deal with Dynamic Programming\\nGood luck**"
                    },
                    {
                        "username": "idnedvryaasnein",
                        "content": "Graph week ends..\\nAnd DP week starts.\\n"
                    },
                    {
                        "username": "suren-yeager",
                        "content": "DP week starts \\uD83E\\uDD73"
                    },
                    {
                        "username": "sam_Eldoro",
                        "content": "Friends, TLE!!!!!!!!!"
                    },
                    {
                        "username": "Crispy_coffee",
                        "content": "same bisi"
                    },
                    {
                        "username": "user5400vw",
                        "content": "try to solve it by iterating through each of the 2d array\\'s items in one pass."
                    },
                    {
                        "username": "anwendeng",
                        "content": "How about recursion with memoization?"
                    },
                    {
                        "username": "anwendeng",
                        "content": "Here is a solution:https://leetcode.com/problems/minimum-path-sum/solutions/3347033/easy-memoization-c-solution/"
                    },
                    {
                        "username": "jolswlf",
                        "content": "how and why would you use recursion exactly"
                    }
                ]
            },
            {
                "id": 1844904,
                "content": [
                    {
                        "username": "NevNadNik",
                        "content": "Is it strange, that it feels easy now?... I remember, how I struggled with same dp/coloring grid 2 months ago. And now it was so... intuitive. "
                    },
                    {
                        "username": "guddukumar0709",
                        "content": "Assume if question were asked to move in any direction at any point of time (not as \"You can only move either down or right at any point in time\").\\n\\nCan you think how to approach this problem.... think twice .... any idea anyone???\\n\\nexample here - \\n\\n[[0,1,1,1,9],\\n[9,9,9,1,9],\\n[9,9,1,3,9],\\n[9,9,1,5,9],\\n[9,9,1,2,1]]\\n\\nfor this minimum path cost =\\n 0 + 1 + 1 + 1 + 1 + 3 + 1 + 1 + 1 + 2 + 1  = 13\\n\\nBut if you run this testcase in this problem(minimum path sum)  you will end up getting solution 15.\\n\\nThink about this way also how to do that problem.\\n"
                    },
                    {
                        "username": "guddukumar0709",
                        "content": "[@rushabhvg](/rushabhvg) \nBut here question is how to approach this problem if their is no such constraints.\n\nAlso as I mention in example i am not going back direction, I am just changing direction to left side which is not visited in past path. \n\nHere is path as I mention above-\n \n[[0,1,1,1---],\n[-------1--],\n[-----1 3--],\n[-----1----],\n[-----1,2,1]]\n\n\nHere question is how to approach this type of problem.\n\n(Note - If question as - You can move in any direction at any point in time)"
                    },
                    {
                        "username": "rushabhvg",
                        "content": "Also, this is a classic/one of the most basic problem of Dynamic Programming (DP). If you have learnt about dynamic programming (dp), you will immediately use not because you learnt it, but, because dp is the easiest way to solve those kind of problems."
                    },
                    {
                        "username": "rushabhvg",
                        "content": "After \"0 + 1 + 1 + 1 + 1 + 3\" it should be either 9 or 5. You can\\'t go back. Exactly as \"Note: You can only move either down or right at any point in time.\""
                    },
                    {
                        "username": "sugarteddy",
                        "content": "Hi, can anyone help \\nif we could move up and left as well in this problem, how the solution will be. Dose DP still work? What should I change in the code? Thanks in advance!"
                    },
                    {
                        "username": "jolswlf",
                        "content": "[@rushabhvg](/rushabhvg) I think DP could still work "
                    },
                    {
                        "username": "rushabhvg",
                        "content": "I guess we can\\'t use DP in that case, don\\'t know about any solution."
                    },
                    {
                        "username": "veeyikpong",
                        "content": "Approach\n1. For each cell, we can come from either top or left, since we can only move down or right\n2. We can compute the current cell minimum value as either:\n   - current cell value + left\n   - current cell value + top\n3. Check for boundary cases for cell 0,0, first row and first column\n\nNote: We can reuse the same input grid to store the computed value, resulting in the space O(1)\n\nExample:\nInput:\n```\n1 3 1\n2 3 2\n4 3 1\n```\n\nDP Table:\n```\n1 4 5\n3 6 7\n7 9 8\n```"
                    },
                    {
                        "username": "veeyikpong",
                        "content": "\\n\\nhttps://leetcode.com/problems/minimum-path-sum/solutions/3346369/kotlin-dp-table-with-o-mn-time-and-o-1-space-simple-code/"
                    },
                    {
                        "username": "sasukesharma",
                        "content": "a 4 ways explained solution: https://leetcode.com/problems/minimum-path-sum/solutions/2677369/recursion-to-space-optimized-in-java/?orderBy=most_votes"
                    },
                    {
                        "username": "sasukesharma",
                        "content": "**this week we have to deal with Dynamic Programming\\nGood luck**"
                    },
                    {
                        "username": "idnedvryaasnein",
                        "content": "Graph week ends..\\nAnd DP week starts.\\n"
                    },
                    {
                        "username": "suren-yeager",
                        "content": "DP week starts \\uD83E\\uDD73"
                    },
                    {
                        "username": "sam_Eldoro",
                        "content": "Friends, TLE!!!!!!!!!"
                    },
                    {
                        "username": "Crispy_coffee",
                        "content": "same bisi"
                    },
                    {
                        "username": "user5400vw",
                        "content": "try to solve it by iterating through each of the 2d array\\'s items in one pass."
                    },
                    {
                        "username": "anwendeng",
                        "content": "How about recursion with memoization?"
                    },
                    {
                        "username": "anwendeng",
                        "content": "Here is a solution:https://leetcode.com/problems/minimum-path-sum/solutions/3347033/easy-memoization-c-solution/"
                    },
                    {
                        "username": "jolswlf",
                        "content": "how and why would you use recursion exactly"
                    }
                ]
            },
            {
                "id": 1844902,
                "content": [
                    {
                        "username": "Masterdemon123",
                        "content": "help guys , I having this code and leetcode keeps telling me that the output for case grid = [[1,2,3],[4,5,6]] is 11 meanwhile I have tested it in 2 different IDE using debug mode (visual studio and programiz) and the result is 12 \\n```\\nclass Solution:\\n    lastMinPath = {}\\n\\n    def insertResult(self, i: int, j: int, result):\\n        code = str(i) +  \" \" + str(j) \\n        self.lastMinPath[code] = result \\n\\n    def findMinPath(self, grid: list[list[int]], i: int, j: int) -> int:\\n        if i == 0 and j == 0 :\\n            return grid[i][j]\\n\\n        if i == 0 :\\n\\n            minPath = -1\\n\\n            code = str(i) + \" \" + str(j - 1)\\n            if code in self.lastMinPath:\\n                minPath = self.lastMinPath[code]\\n            else:\\n                minPath = self.findMinPath(grid,i,j - 1)\\n\\n            result = grid[i][j] + minPath\\n            self.insertResult(i,j,result)\\n            return result\\n\\n        if j == 0 :\\n            minPath = -1\\n\\n            code = str(i - 1) + \" \" + str(j)\\n            if code in self.lastMinPath:\\n                minPath = self.lastMinPath[code]\\n            else:\\n                minPath = self.findMinPath(grid,i-1,j) \\n\\n            result = grid[i][j] + minPath\\n            self.insertResult(i,j,result)\\n            return result\\n\\n\\n        minPath1 = -1\\n\\n        code = str(i) + \" \" + str(j - 1)\\n        if code in self.lastMinPath:\\n            minPath1 = self.lastMinPath[code]\\n        else:\\n            minPath1 = self.findMinPath(grid,i,j-1) \\n\\n        minPath2 = -1\\n        code = str(i - 1) + \" \" + str(j)\\n        if code in self.lastMinPath:\\n            minPath2 = self.lastMinPath[code]\\n        else:\\n            minPath2 = self.findMinPath(grid,i - 1,j) \\n\\n        result = grid[i][j] + min(minPath1,minPath2)\\n        self.insertResult(i,j,result)\\n        return result\\n\\n    def minPathSum(self, grid: List[List[int]]) -> int:\\n        code = \"0 0\"\\n        self.lastMinPath[code] = grid[0][0] \\n        return self.findMinPath(grid,len(grid) - 1,len(grid[0]) - 1)\\n```\\nI don\\'t know and can\\'t find the problem , can you tell me why ?\\n\\n"
                    },
                    {
                        "username": "alshine",
                        "content": "if you are experiencing problems, I advise you to solve [62. Unique Paths\n](https://leetcode.com/problems/unique-paths/)"
                    },
                    {
                        "username": "Ztilly",
                        "content": "This is a bad problem due to the fact that the maximized number possible will always use every tile. The example given is incorrect. The maxamized path would be 1 -> 3 -> 1 -> 1 -> 5 -> 1 -> 4 -> 2 -> 1, resulting in 19, not 7. \n\nstarting top left you move accross the board to the right, then once you reach the end you go down once, to the left, and back to the right once more. In the event there's an even amount of rows, it's still possible to touch every tile while only moving one space as a time in the left or right direction, and this will always be the case for any size square or rectangle."
                    },
                    {
                        "username": "AMerrill",
                        "content": "\"You can only move either down or right at any point in time.\" \\n\\nAlso, you want to minimize the the sum."
                    },
                    {
                        "username": "arumuga007",
                        "content": "what the correct output for [1,2], [1,1]?i get 4 but it expect 3??\\nAnyone explain me how??"
                    },
                    {
                        "username": "AMerrill",
                        "content": "take 1 -> 1 -> 1 or moving Down and then Right. Total sum is $$3$$.\n\n^This is the path with the minimum sum."
                    },
                    {
                        "username": "JiayingGao",
                        "content": "How to optimize my bfs code? It can AC but need run almost 1.7s  :<.\\n\\'\\'\\'\\nclass Solution {\\npublic:\\n    int minPathSum(vector<vector<int>>& grid) {\\n        \\n        int m = grid.size(), n = grid.front().size(), nd[2][2] = {{1, 0}, {0, 1}};\\n        vector<vector<int>> marked(m, vector<int>(n, INT_MAX)); marked[0][0] = grid[0][0];\\n        queue<tuple<int, int, int>> units;  units.push({0, 0, grid[0][0]});\\n        while(!units.empty()){\\n            auto [y, x, sum] = units.front();  units.pop();\\n            for (int k = 0; k < 2; k++){\\n                int ny = y + nd[k][0], nx = x + nd[k][1];\\n                if (ny >= m || nx >= n) continue;\\n                int update_sum = sum + grid[ny][nx];\\n                if (update_sum < marked[ny][nx]){\\n                    marked[ny][nx] = update_sum;\\n                    units.push({ny, nx, update_sum});\\n                }\\n            }\\n        }\\n        return marked[m - 1][n - 1];\\n    }\\n};\\n\\'\\'\\' "
                    },
                    {
                        "username": "alpharomeo99",
                        "content": "In case you're asked to find the path with minimum sum, you can just start from the source after creating the dp array. From source move greedily towards the the cell that has the minimum path sum to the destination and accordingly update the path. This will take O(N) time."
                    },
                    {
                        "username": "sanshoys",
                        "content": "grid =\\n[[1,2],[1,1]]\\nOutput\\n4\\nExpected\\n3 \\n\\nwhy is it 3?  1 + 2 + 1 = 4"
                    },
                    {
                        "username": "hoangnn451",
                        "content": "1 + 1 + 1 = 3\\nstart from (0,0), move down (1,0), move right (1,1)\\n(0,0) + (1,0) + (1,1) = 1 + 1 + 1 = 3 \\n\\nNote: You can only move either down or right at any point in time."
                    },
                    {
                        "username": "Sumit2828",
                        "content": "class Solution {\\npublic:\\n    int minPathSum(vector<vector<int>>& grid) {\\n        int m=grid.size();\\n        int n=grid[0].size();\\n\\n        int dp[m][n];\\n        dp[0][0]=grid[0][0];\\n        for(int i=1;i<m;i++){\\n            dp[0][i]+=dp[0][i-1];\\n        }\\n        for(int i=1;i<n;i++){\\n            dp[i][0]+=dp[i-1][0];\\n        }\\n        for(int i=1;i<m;i++){\\n            for(int j=1;j<n;j++){\\n                dp[i][j]+=min(dp[i-1][j],dp[i][j-1]);\\n            }\\n        }\\n        return dp[m-1][n-1];\\n        \\n    }\\n};\\n\\nThis code is giving the runtime error as dynamic-stack-buffer-overflow , can anyone give the fault in the code  corresponding to the given error, and the solution to the error."
                    },
                    {
                        "username": "Sumit2828",
                        "content": "[@manifold1985](/manifold1985) Thanks\\uD83D\\uDC4D"
                    },
                    {
                        "username": "manifold1985",
                        "content": "You used syntax such as \"dp[i][j]+=min(dp[i-1][j],dp[i][j-1])\", but your dp[i][j] hasn\\'t been assigned any value yet. I am afraid that\\'s the cause. Also, it seems like grid[i][j] hasn\\'t been incorporated into your code. You should modify your code accordingly."
                    },
                    {
                        "username": "PAIN_an_c",
                        "content": "why this code giving tle even i travelled m*n using recursion\\n\\nclass Solution {\\npublic:\\n    void reduce(vector<vector<int>>grid,vector<vector<int>>& box,int i,int j){\\n        if(i==grid.size())\\n            return ;\\n        else if(j==grid[0].size()){\\n           reduce(grid,box,i+1,0);\\n           return ;\\n        }\\n        if(i-1>=0 && j-1>=0){box[i][j]=grid[i][j]+min(box[i-1][j],box[i][j-1]);}\\n        else if(i-1>=0){box[i][j]=grid[i][j]+box[i-1][j];}\\n        else{box[i][j]=grid[i][j]+box[i][j-1];}\\n\\n        reduce(grid,box,i,j+1);\\n    }\\npublic:\\n\\n    int minPathSum(vector<vector<int>>& grid) {\\n        int m=grid.size(),n=grid[0].size();\\n        vector<vector<int>>box(m,vector<int>(n,-1)); \\n        box[0][0]=grid[0][0];\\n        reduce(grid,box,0,1);\\n        return box[m-1][n-1];   \\n    }\\n};"
                    },
                    {
                        "username": "JiayingGao",
                        "content": "Just remember to let the memorization works, add: if (box[y][x] != -1) return memory;"
                    },
                    {
                        "username": "SharmaAyush",
                        "content": "class Solution {\\npublic:\\n   \\n    int minPathSum(vector<vector<int>>&grid){\\n        int m=grid.size();\\n        int n = grid[0].size();\\n\\n        int** dp = new int*[m];\\n\\n        for(int i=0;i<m;i++){\\n            dp[i] = new int[n];\\n        }\\n\\n        dp[0][0] =grid[0][0];\\n\\n        for(int i=1;i<n;i++){\\n            dp[0][i] = dp[0][i-1]+grid[0][i];\\n        }\\n            for(int i=1;i<m;i++){\\n            dp[i][0] = dp[i-1][0]+grid[i][0];\\n        }\\n\\n        for(int i=1;i<m;i++){\\n            for(int j=1;j<n;j++){\\n                dp[i][j] = min(dp[i-1][j],dp[i][j-1]) +grid[i][j];\\n            }\\n        \\n        }   \\n        return dp[m-1][n-1];\\n    }\\n};"
                    }
                ]
            },
            {
                "id": 1844895,
                "content": [
                    {
                        "username": "Masterdemon123",
                        "content": "help guys , I having this code and leetcode keeps telling me that the output for case grid = [[1,2,3],[4,5,6]] is 11 meanwhile I have tested it in 2 different IDE using debug mode (visual studio and programiz) and the result is 12 \\n```\\nclass Solution:\\n    lastMinPath = {}\\n\\n    def insertResult(self, i: int, j: int, result):\\n        code = str(i) +  \" \" + str(j) \\n        self.lastMinPath[code] = result \\n\\n    def findMinPath(self, grid: list[list[int]], i: int, j: int) -> int:\\n        if i == 0 and j == 0 :\\n            return grid[i][j]\\n\\n        if i == 0 :\\n\\n            minPath = -1\\n\\n            code = str(i) + \" \" + str(j - 1)\\n            if code in self.lastMinPath:\\n                minPath = self.lastMinPath[code]\\n            else:\\n                minPath = self.findMinPath(grid,i,j - 1)\\n\\n            result = grid[i][j] + minPath\\n            self.insertResult(i,j,result)\\n            return result\\n\\n        if j == 0 :\\n            minPath = -1\\n\\n            code = str(i - 1) + \" \" + str(j)\\n            if code in self.lastMinPath:\\n                minPath = self.lastMinPath[code]\\n            else:\\n                minPath = self.findMinPath(grid,i-1,j) \\n\\n            result = grid[i][j] + minPath\\n            self.insertResult(i,j,result)\\n            return result\\n\\n\\n        minPath1 = -1\\n\\n        code = str(i) + \" \" + str(j - 1)\\n        if code in self.lastMinPath:\\n            minPath1 = self.lastMinPath[code]\\n        else:\\n            minPath1 = self.findMinPath(grid,i,j-1) \\n\\n        minPath2 = -1\\n        code = str(i - 1) + \" \" + str(j)\\n        if code in self.lastMinPath:\\n            minPath2 = self.lastMinPath[code]\\n        else:\\n            minPath2 = self.findMinPath(grid,i - 1,j) \\n\\n        result = grid[i][j] + min(minPath1,minPath2)\\n        self.insertResult(i,j,result)\\n        return result\\n\\n    def minPathSum(self, grid: List[List[int]]) -> int:\\n        code = \"0 0\"\\n        self.lastMinPath[code] = grid[0][0] \\n        return self.findMinPath(grid,len(grid) - 1,len(grid[0]) - 1)\\n```\\nI don\\'t know and can\\'t find the problem , can you tell me why ?\\n\\n"
                    },
                    {
                        "username": "alshine",
                        "content": "if you are experiencing problems, I advise you to solve [62. Unique Paths\n](https://leetcode.com/problems/unique-paths/)"
                    },
                    {
                        "username": "Ztilly",
                        "content": "This is a bad problem due to the fact that the maximized number possible will always use every tile. The example given is incorrect. The maxamized path would be 1 -> 3 -> 1 -> 1 -> 5 -> 1 -> 4 -> 2 -> 1, resulting in 19, not 7. \n\nstarting top left you move accross the board to the right, then once you reach the end you go down once, to the left, and back to the right once more. In the event there's an even amount of rows, it's still possible to touch every tile while only moving one space as a time in the left or right direction, and this will always be the case for any size square or rectangle."
                    },
                    {
                        "username": "AMerrill",
                        "content": "\"You can only move either down or right at any point in time.\" \\n\\nAlso, you want to minimize the the sum."
                    },
                    {
                        "username": "arumuga007",
                        "content": "what the correct output for [1,2], [1,1]?i get 4 but it expect 3??\\nAnyone explain me how??"
                    },
                    {
                        "username": "AMerrill",
                        "content": "take 1 -> 1 -> 1 or moving Down and then Right. Total sum is $$3$$.\n\n^This is the path with the minimum sum."
                    },
                    {
                        "username": "JiayingGao",
                        "content": "How to optimize my bfs code? It can AC but need run almost 1.7s  :<.\\n\\'\\'\\'\\nclass Solution {\\npublic:\\n    int minPathSum(vector<vector<int>>& grid) {\\n        \\n        int m = grid.size(), n = grid.front().size(), nd[2][2] = {{1, 0}, {0, 1}};\\n        vector<vector<int>> marked(m, vector<int>(n, INT_MAX)); marked[0][0] = grid[0][0];\\n        queue<tuple<int, int, int>> units;  units.push({0, 0, grid[0][0]});\\n        while(!units.empty()){\\n            auto [y, x, sum] = units.front();  units.pop();\\n            for (int k = 0; k < 2; k++){\\n                int ny = y + nd[k][0], nx = x + nd[k][1];\\n                if (ny >= m || nx >= n) continue;\\n                int update_sum = sum + grid[ny][nx];\\n                if (update_sum < marked[ny][nx]){\\n                    marked[ny][nx] = update_sum;\\n                    units.push({ny, nx, update_sum});\\n                }\\n            }\\n        }\\n        return marked[m - 1][n - 1];\\n    }\\n};\\n\\'\\'\\' "
                    },
                    {
                        "username": "alpharomeo99",
                        "content": "In case you're asked to find the path with minimum sum, you can just start from the source after creating the dp array. From source move greedily towards the the cell that has the minimum path sum to the destination and accordingly update the path. This will take O(N) time."
                    },
                    {
                        "username": "sanshoys",
                        "content": "grid =\\n[[1,2],[1,1]]\\nOutput\\n4\\nExpected\\n3 \\n\\nwhy is it 3?  1 + 2 + 1 = 4"
                    },
                    {
                        "username": "hoangnn451",
                        "content": "1 + 1 + 1 = 3\\nstart from (0,0), move down (1,0), move right (1,1)\\n(0,0) + (1,0) + (1,1) = 1 + 1 + 1 = 3 \\n\\nNote: You can only move either down or right at any point in time."
                    },
                    {
                        "username": "Sumit2828",
                        "content": "class Solution {\\npublic:\\n    int minPathSum(vector<vector<int>>& grid) {\\n        int m=grid.size();\\n        int n=grid[0].size();\\n\\n        int dp[m][n];\\n        dp[0][0]=grid[0][0];\\n        for(int i=1;i<m;i++){\\n            dp[0][i]+=dp[0][i-1];\\n        }\\n        for(int i=1;i<n;i++){\\n            dp[i][0]+=dp[i-1][0];\\n        }\\n        for(int i=1;i<m;i++){\\n            for(int j=1;j<n;j++){\\n                dp[i][j]+=min(dp[i-1][j],dp[i][j-1]);\\n            }\\n        }\\n        return dp[m-1][n-1];\\n        \\n    }\\n};\\n\\nThis code is giving the runtime error as dynamic-stack-buffer-overflow , can anyone give the fault in the code  corresponding to the given error, and the solution to the error."
                    },
                    {
                        "username": "Sumit2828",
                        "content": "[@manifold1985](/manifold1985) Thanks\\uD83D\\uDC4D"
                    },
                    {
                        "username": "manifold1985",
                        "content": "You used syntax such as \"dp[i][j]+=min(dp[i-1][j],dp[i][j-1])\", but your dp[i][j] hasn\\'t been assigned any value yet. I am afraid that\\'s the cause. Also, it seems like grid[i][j] hasn\\'t been incorporated into your code. You should modify your code accordingly."
                    },
                    {
                        "username": "PAIN_an_c",
                        "content": "why this code giving tle even i travelled m*n using recursion\\n\\nclass Solution {\\npublic:\\n    void reduce(vector<vector<int>>grid,vector<vector<int>>& box,int i,int j){\\n        if(i==grid.size())\\n            return ;\\n        else if(j==grid[0].size()){\\n           reduce(grid,box,i+1,0);\\n           return ;\\n        }\\n        if(i-1>=0 && j-1>=0){box[i][j]=grid[i][j]+min(box[i-1][j],box[i][j-1]);}\\n        else if(i-1>=0){box[i][j]=grid[i][j]+box[i-1][j];}\\n        else{box[i][j]=grid[i][j]+box[i][j-1];}\\n\\n        reduce(grid,box,i,j+1);\\n    }\\npublic:\\n\\n    int minPathSum(vector<vector<int>>& grid) {\\n        int m=grid.size(),n=grid[0].size();\\n        vector<vector<int>>box(m,vector<int>(n,-1)); \\n        box[0][0]=grid[0][0];\\n        reduce(grid,box,0,1);\\n        return box[m-1][n-1];   \\n    }\\n};"
                    },
                    {
                        "username": "JiayingGao",
                        "content": "Just remember to let the memorization works, add: if (box[y][x] != -1) return memory;"
                    },
                    {
                        "username": "SharmaAyush",
                        "content": "class Solution {\\npublic:\\n   \\n    int minPathSum(vector<vector<int>>&grid){\\n        int m=grid.size();\\n        int n = grid[0].size();\\n\\n        int** dp = new int*[m];\\n\\n        for(int i=0;i<m;i++){\\n            dp[i] = new int[n];\\n        }\\n\\n        dp[0][0] =grid[0][0];\\n\\n        for(int i=1;i<n;i++){\\n            dp[0][i] = dp[0][i-1]+grid[0][i];\\n        }\\n            for(int i=1;i<m;i++){\\n            dp[i][0] = dp[i-1][0]+grid[i][0];\\n        }\\n\\n        for(int i=1;i<m;i++){\\n            for(int j=1;j<n;j++){\\n                dp[i][j] = min(dp[i-1][j],dp[i][j-1]) +grid[i][j];\\n            }\\n        \\n        }   \\n        return dp[m-1][n-1];\\n    }\\n};"
                    }
                ]
            },
            {
                "id": 1844858,
                "content": [
                    {
                        "username": "Masterdemon123",
                        "content": "help guys , I having this code and leetcode keeps telling me that the output for case grid = [[1,2,3],[4,5,6]] is 11 meanwhile I have tested it in 2 different IDE using debug mode (visual studio and programiz) and the result is 12 \\n```\\nclass Solution:\\n    lastMinPath = {}\\n\\n    def insertResult(self, i: int, j: int, result):\\n        code = str(i) +  \" \" + str(j) \\n        self.lastMinPath[code] = result \\n\\n    def findMinPath(self, grid: list[list[int]], i: int, j: int) -> int:\\n        if i == 0 and j == 0 :\\n            return grid[i][j]\\n\\n        if i == 0 :\\n\\n            minPath = -1\\n\\n            code = str(i) + \" \" + str(j - 1)\\n            if code in self.lastMinPath:\\n                minPath = self.lastMinPath[code]\\n            else:\\n                minPath = self.findMinPath(grid,i,j - 1)\\n\\n            result = grid[i][j] + minPath\\n            self.insertResult(i,j,result)\\n            return result\\n\\n        if j == 0 :\\n            minPath = -1\\n\\n            code = str(i - 1) + \" \" + str(j)\\n            if code in self.lastMinPath:\\n                minPath = self.lastMinPath[code]\\n            else:\\n                minPath = self.findMinPath(grid,i-1,j) \\n\\n            result = grid[i][j] + minPath\\n            self.insertResult(i,j,result)\\n            return result\\n\\n\\n        minPath1 = -1\\n\\n        code = str(i) + \" \" + str(j - 1)\\n        if code in self.lastMinPath:\\n            minPath1 = self.lastMinPath[code]\\n        else:\\n            minPath1 = self.findMinPath(grid,i,j-1) \\n\\n        minPath2 = -1\\n        code = str(i - 1) + \" \" + str(j)\\n        if code in self.lastMinPath:\\n            minPath2 = self.lastMinPath[code]\\n        else:\\n            minPath2 = self.findMinPath(grid,i - 1,j) \\n\\n        result = grid[i][j] + min(minPath1,minPath2)\\n        self.insertResult(i,j,result)\\n        return result\\n\\n    def minPathSum(self, grid: List[List[int]]) -> int:\\n        code = \"0 0\"\\n        self.lastMinPath[code] = grid[0][0] \\n        return self.findMinPath(grid,len(grid) - 1,len(grid[0]) - 1)\\n```\\nI don\\'t know and can\\'t find the problem , can you tell me why ?\\n\\n"
                    },
                    {
                        "username": "alshine",
                        "content": "if you are experiencing problems, I advise you to solve [62. Unique Paths\n](https://leetcode.com/problems/unique-paths/)"
                    },
                    {
                        "username": "Ztilly",
                        "content": "This is a bad problem due to the fact that the maximized number possible will always use every tile. The example given is incorrect. The maxamized path would be 1 -> 3 -> 1 -> 1 -> 5 -> 1 -> 4 -> 2 -> 1, resulting in 19, not 7. \n\nstarting top left you move accross the board to the right, then once you reach the end you go down once, to the left, and back to the right once more. In the event there's an even amount of rows, it's still possible to touch every tile while only moving one space as a time in the left or right direction, and this will always be the case for any size square or rectangle."
                    },
                    {
                        "username": "AMerrill",
                        "content": "\"You can only move either down or right at any point in time.\" \\n\\nAlso, you want to minimize the the sum."
                    },
                    {
                        "username": "arumuga007",
                        "content": "what the correct output for [1,2], [1,1]?i get 4 but it expect 3??\\nAnyone explain me how??"
                    },
                    {
                        "username": "AMerrill",
                        "content": "take 1 -> 1 -> 1 or moving Down and then Right. Total sum is $$3$$.\n\n^This is the path with the minimum sum."
                    },
                    {
                        "username": "JiayingGao",
                        "content": "How to optimize my bfs code? It can AC but need run almost 1.7s  :<.\\n\\'\\'\\'\\nclass Solution {\\npublic:\\n    int minPathSum(vector<vector<int>>& grid) {\\n        \\n        int m = grid.size(), n = grid.front().size(), nd[2][2] = {{1, 0}, {0, 1}};\\n        vector<vector<int>> marked(m, vector<int>(n, INT_MAX)); marked[0][0] = grid[0][0];\\n        queue<tuple<int, int, int>> units;  units.push({0, 0, grid[0][0]});\\n        while(!units.empty()){\\n            auto [y, x, sum] = units.front();  units.pop();\\n            for (int k = 0; k < 2; k++){\\n                int ny = y + nd[k][0], nx = x + nd[k][1];\\n                if (ny >= m || nx >= n) continue;\\n                int update_sum = sum + grid[ny][nx];\\n                if (update_sum < marked[ny][nx]){\\n                    marked[ny][nx] = update_sum;\\n                    units.push({ny, nx, update_sum});\\n                }\\n            }\\n        }\\n        return marked[m - 1][n - 1];\\n    }\\n};\\n\\'\\'\\' "
                    },
                    {
                        "username": "alpharomeo99",
                        "content": "In case you're asked to find the path with minimum sum, you can just start from the source after creating the dp array. From source move greedily towards the the cell that has the minimum path sum to the destination and accordingly update the path. This will take O(N) time."
                    },
                    {
                        "username": "sanshoys",
                        "content": "grid =\\n[[1,2],[1,1]]\\nOutput\\n4\\nExpected\\n3 \\n\\nwhy is it 3?  1 + 2 + 1 = 4"
                    },
                    {
                        "username": "hoangnn451",
                        "content": "1 + 1 + 1 = 3\\nstart from (0,0), move down (1,0), move right (1,1)\\n(0,0) + (1,0) + (1,1) = 1 + 1 + 1 = 3 \\n\\nNote: You can only move either down or right at any point in time."
                    },
                    {
                        "username": "Sumit2828",
                        "content": "class Solution {\\npublic:\\n    int minPathSum(vector<vector<int>>& grid) {\\n        int m=grid.size();\\n        int n=grid[0].size();\\n\\n        int dp[m][n];\\n        dp[0][0]=grid[0][0];\\n        for(int i=1;i<m;i++){\\n            dp[0][i]+=dp[0][i-1];\\n        }\\n        for(int i=1;i<n;i++){\\n            dp[i][0]+=dp[i-1][0];\\n        }\\n        for(int i=1;i<m;i++){\\n            for(int j=1;j<n;j++){\\n                dp[i][j]+=min(dp[i-1][j],dp[i][j-1]);\\n            }\\n        }\\n        return dp[m-1][n-1];\\n        \\n    }\\n};\\n\\nThis code is giving the runtime error as dynamic-stack-buffer-overflow , can anyone give the fault in the code  corresponding to the given error, and the solution to the error."
                    },
                    {
                        "username": "Sumit2828",
                        "content": "[@manifold1985](/manifold1985) Thanks\\uD83D\\uDC4D"
                    },
                    {
                        "username": "manifold1985",
                        "content": "You used syntax such as \"dp[i][j]+=min(dp[i-1][j],dp[i][j-1])\", but your dp[i][j] hasn\\'t been assigned any value yet. I am afraid that\\'s the cause. Also, it seems like grid[i][j] hasn\\'t been incorporated into your code. You should modify your code accordingly."
                    },
                    {
                        "username": "PAIN_an_c",
                        "content": "why this code giving tle even i travelled m*n using recursion\\n\\nclass Solution {\\npublic:\\n    void reduce(vector<vector<int>>grid,vector<vector<int>>& box,int i,int j){\\n        if(i==grid.size())\\n            return ;\\n        else if(j==grid[0].size()){\\n           reduce(grid,box,i+1,0);\\n           return ;\\n        }\\n        if(i-1>=0 && j-1>=0){box[i][j]=grid[i][j]+min(box[i-1][j],box[i][j-1]);}\\n        else if(i-1>=0){box[i][j]=grid[i][j]+box[i-1][j];}\\n        else{box[i][j]=grid[i][j]+box[i][j-1];}\\n\\n        reduce(grid,box,i,j+1);\\n    }\\npublic:\\n\\n    int minPathSum(vector<vector<int>>& grid) {\\n        int m=grid.size(),n=grid[0].size();\\n        vector<vector<int>>box(m,vector<int>(n,-1)); \\n        box[0][0]=grid[0][0];\\n        reduce(grid,box,0,1);\\n        return box[m-1][n-1];   \\n    }\\n};"
                    },
                    {
                        "username": "JiayingGao",
                        "content": "Just remember to let the memorization works, add: if (box[y][x] != -1) return memory;"
                    },
                    {
                        "username": "SharmaAyush",
                        "content": "class Solution {\\npublic:\\n   \\n    int minPathSum(vector<vector<int>>&grid){\\n        int m=grid.size();\\n        int n = grid[0].size();\\n\\n        int** dp = new int*[m];\\n\\n        for(int i=0;i<m;i++){\\n            dp[i] = new int[n];\\n        }\\n\\n        dp[0][0] =grid[0][0];\\n\\n        for(int i=1;i<n;i++){\\n            dp[0][i] = dp[0][i-1]+grid[0][i];\\n        }\\n            for(int i=1;i<m;i++){\\n            dp[i][0] = dp[i-1][0]+grid[i][0];\\n        }\\n\\n        for(int i=1;i<m;i++){\\n            for(int j=1;j<n;j++){\\n                dp[i][j] = min(dp[i-1][j],dp[i][j-1]) +grid[i][j];\\n            }\\n        \\n        }   \\n        return dp[m-1][n-1];\\n    }\\n};"
                    }
                ]
            },
            {
                "id": 1844855,
                "content": [
                    {
                        "username": "Masterdemon123",
                        "content": "help guys , I having this code and leetcode keeps telling me that the output for case grid = [[1,2,3],[4,5,6]] is 11 meanwhile I have tested it in 2 different IDE using debug mode (visual studio and programiz) and the result is 12 \\n```\\nclass Solution:\\n    lastMinPath = {}\\n\\n    def insertResult(self, i: int, j: int, result):\\n        code = str(i) +  \" \" + str(j) \\n        self.lastMinPath[code] = result \\n\\n    def findMinPath(self, grid: list[list[int]], i: int, j: int) -> int:\\n        if i == 0 and j == 0 :\\n            return grid[i][j]\\n\\n        if i == 0 :\\n\\n            minPath = -1\\n\\n            code = str(i) + \" \" + str(j - 1)\\n            if code in self.lastMinPath:\\n                minPath = self.lastMinPath[code]\\n            else:\\n                minPath = self.findMinPath(grid,i,j - 1)\\n\\n            result = grid[i][j] + minPath\\n            self.insertResult(i,j,result)\\n            return result\\n\\n        if j == 0 :\\n            minPath = -1\\n\\n            code = str(i - 1) + \" \" + str(j)\\n            if code in self.lastMinPath:\\n                minPath = self.lastMinPath[code]\\n            else:\\n                minPath = self.findMinPath(grid,i-1,j) \\n\\n            result = grid[i][j] + minPath\\n            self.insertResult(i,j,result)\\n            return result\\n\\n\\n        minPath1 = -1\\n\\n        code = str(i) + \" \" + str(j - 1)\\n        if code in self.lastMinPath:\\n            minPath1 = self.lastMinPath[code]\\n        else:\\n            minPath1 = self.findMinPath(grid,i,j-1) \\n\\n        minPath2 = -1\\n        code = str(i - 1) + \" \" + str(j)\\n        if code in self.lastMinPath:\\n            minPath2 = self.lastMinPath[code]\\n        else:\\n            minPath2 = self.findMinPath(grid,i - 1,j) \\n\\n        result = grid[i][j] + min(minPath1,minPath2)\\n        self.insertResult(i,j,result)\\n        return result\\n\\n    def minPathSum(self, grid: List[List[int]]) -> int:\\n        code = \"0 0\"\\n        self.lastMinPath[code] = grid[0][0] \\n        return self.findMinPath(grid,len(grid) - 1,len(grid[0]) - 1)\\n```\\nI don\\'t know and can\\'t find the problem , can you tell me why ?\\n\\n"
                    },
                    {
                        "username": "alshine",
                        "content": "if you are experiencing problems, I advise you to solve [62. Unique Paths\n](https://leetcode.com/problems/unique-paths/)"
                    },
                    {
                        "username": "Ztilly",
                        "content": "This is a bad problem due to the fact that the maximized number possible will always use every tile. The example given is incorrect. The maxamized path would be 1 -> 3 -> 1 -> 1 -> 5 -> 1 -> 4 -> 2 -> 1, resulting in 19, not 7. \n\nstarting top left you move accross the board to the right, then once you reach the end you go down once, to the left, and back to the right once more. In the event there's an even amount of rows, it's still possible to touch every tile while only moving one space as a time in the left or right direction, and this will always be the case for any size square or rectangle."
                    },
                    {
                        "username": "AMerrill",
                        "content": "\"You can only move either down or right at any point in time.\" \\n\\nAlso, you want to minimize the the sum."
                    },
                    {
                        "username": "arumuga007",
                        "content": "what the correct output for [1,2], [1,1]?i get 4 but it expect 3??\\nAnyone explain me how??"
                    },
                    {
                        "username": "AMerrill",
                        "content": "take 1 -> 1 -> 1 or moving Down and then Right. Total sum is $$3$$.\n\n^This is the path with the minimum sum."
                    },
                    {
                        "username": "JiayingGao",
                        "content": "How to optimize my bfs code? It can AC but need run almost 1.7s  :<.\\n\\'\\'\\'\\nclass Solution {\\npublic:\\n    int minPathSum(vector<vector<int>>& grid) {\\n        \\n        int m = grid.size(), n = grid.front().size(), nd[2][2] = {{1, 0}, {0, 1}};\\n        vector<vector<int>> marked(m, vector<int>(n, INT_MAX)); marked[0][0] = grid[0][0];\\n        queue<tuple<int, int, int>> units;  units.push({0, 0, grid[0][0]});\\n        while(!units.empty()){\\n            auto [y, x, sum] = units.front();  units.pop();\\n            for (int k = 0; k < 2; k++){\\n                int ny = y + nd[k][0], nx = x + nd[k][1];\\n                if (ny >= m || nx >= n) continue;\\n                int update_sum = sum + grid[ny][nx];\\n                if (update_sum < marked[ny][nx]){\\n                    marked[ny][nx] = update_sum;\\n                    units.push({ny, nx, update_sum});\\n                }\\n            }\\n        }\\n        return marked[m - 1][n - 1];\\n    }\\n};\\n\\'\\'\\' "
                    },
                    {
                        "username": "alpharomeo99",
                        "content": "In case you're asked to find the path with minimum sum, you can just start from the source after creating the dp array. From source move greedily towards the the cell that has the minimum path sum to the destination and accordingly update the path. This will take O(N) time."
                    },
                    {
                        "username": "sanshoys",
                        "content": "grid =\\n[[1,2],[1,1]]\\nOutput\\n4\\nExpected\\n3 \\n\\nwhy is it 3?  1 + 2 + 1 = 4"
                    },
                    {
                        "username": "hoangnn451",
                        "content": "1 + 1 + 1 = 3\\nstart from (0,0), move down (1,0), move right (1,1)\\n(0,0) + (1,0) + (1,1) = 1 + 1 + 1 = 3 \\n\\nNote: You can only move either down or right at any point in time."
                    },
                    {
                        "username": "Sumit2828",
                        "content": "class Solution {\\npublic:\\n    int minPathSum(vector<vector<int>>& grid) {\\n        int m=grid.size();\\n        int n=grid[0].size();\\n\\n        int dp[m][n];\\n        dp[0][0]=grid[0][0];\\n        for(int i=1;i<m;i++){\\n            dp[0][i]+=dp[0][i-1];\\n        }\\n        for(int i=1;i<n;i++){\\n            dp[i][0]+=dp[i-1][0];\\n        }\\n        for(int i=1;i<m;i++){\\n            for(int j=1;j<n;j++){\\n                dp[i][j]+=min(dp[i-1][j],dp[i][j-1]);\\n            }\\n        }\\n        return dp[m-1][n-1];\\n        \\n    }\\n};\\n\\nThis code is giving the runtime error as dynamic-stack-buffer-overflow , can anyone give the fault in the code  corresponding to the given error, and the solution to the error."
                    },
                    {
                        "username": "Sumit2828",
                        "content": "[@manifold1985](/manifold1985) Thanks\\uD83D\\uDC4D"
                    },
                    {
                        "username": "manifold1985",
                        "content": "You used syntax such as \"dp[i][j]+=min(dp[i-1][j],dp[i][j-1])\", but your dp[i][j] hasn\\'t been assigned any value yet. I am afraid that\\'s the cause. Also, it seems like grid[i][j] hasn\\'t been incorporated into your code. You should modify your code accordingly."
                    },
                    {
                        "username": "PAIN_an_c",
                        "content": "why this code giving tle even i travelled m*n using recursion\\n\\nclass Solution {\\npublic:\\n    void reduce(vector<vector<int>>grid,vector<vector<int>>& box,int i,int j){\\n        if(i==grid.size())\\n            return ;\\n        else if(j==grid[0].size()){\\n           reduce(grid,box,i+1,0);\\n           return ;\\n        }\\n        if(i-1>=0 && j-1>=0){box[i][j]=grid[i][j]+min(box[i-1][j],box[i][j-1]);}\\n        else if(i-1>=0){box[i][j]=grid[i][j]+box[i-1][j];}\\n        else{box[i][j]=grid[i][j]+box[i][j-1];}\\n\\n        reduce(grid,box,i,j+1);\\n    }\\npublic:\\n\\n    int minPathSum(vector<vector<int>>& grid) {\\n        int m=grid.size(),n=grid[0].size();\\n        vector<vector<int>>box(m,vector<int>(n,-1)); \\n        box[0][0]=grid[0][0];\\n        reduce(grid,box,0,1);\\n        return box[m-1][n-1];   \\n    }\\n};"
                    },
                    {
                        "username": "JiayingGao",
                        "content": "Just remember to let the memorization works, add: if (box[y][x] != -1) return memory;"
                    },
                    {
                        "username": "SharmaAyush",
                        "content": "class Solution {\\npublic:\\n   \\n    int minPathSum(vector<vector<int>>&grid){\\n        int m=grid.size();\\n        int n = grid[0].size();\\n\\n        int** dp = new int*[m];\\n\\n        for(int i=0;i<m;i++){\\n            dp[i] = new int[n];\\n        }\\n\\n        dp[0][0] =grid[0][0];\\n\\n        for(int i=1;i<n;i++){\\n            dp[0][i] = dp[0][i-1]+grid[0][i];\\n        }\\n            for(int i=1;i<m;i++){\\n            dp[i][0] = dp[i-1][0]+grid[i][0];\\n        }\\n\\n        for(int i=1;i<m;i++){\\n            for(int j=1;j<n;j++){\\n                dp[i][j] = min(dp[i-1][j],dp[i][j-1]) +grid[i][j];\\n            }\\n        \\n        }   \\n        return dp[m-1][n-1];\\n    }\\n};"
                    }
                ]
            },
            {
                "id": 1844841,
                "content": [
                    {
                        "username": "Masterdemon123",
                        "content": "help guys , I having this code and leetcode keeps telling me that the output for case grid = [[1,2,3],[4,5,6]] is 11 meanwhile I have tested it in 2 different IDE using debug mode (visual studio and programiz) and the result is 12 \\n```\\nclass Solution:\\n    lastMinPath = {}\\n\\n    def insertResult(self, i: int, j: int, result):\\n        code = str(i) +  \" \" + str(j) \\n        self.lastMinPath[code] = result \\n\\n    def findMinPath(self, grid: list[list[int]], i: int, j: int) -> int:\\n        if i == 0 and j == 0 :\\n            return grid[i][j]\\n\\n        if i == 0 :\\n\\n            minPath = -1\\n\\n            code = str(i) + \" \" + str(j - 1)\\n            if code in self.lastMinPath:\\n                minPath = self.lastMinPath[code]\\n            else:\\n                minPath = self.findMinPath(grid,i,j - 1)\\n\\n            result = grid[i][j] + minPath\\n            self.insertResult(i,j,result)\\n            return result\\n\\n        if j == 0 :\\n            minPath = -1\\n\\n            code = str(i - 1) + \" \" + str(j)\\n            if code in self.lastMinPath:\\n                minPath = self.lastMinPath[code]\\n            else:\\n                minPath = self.findMinPath(grid,i-1,j) \\n\\n            result = grid[i][j] + minPath\\n            self.insertResult(i,j,result)\\n            return result\\n\\n\\n        minPath1 = -1\\n\\n        code = str(i) + \" \" + str(j - 1)\\n        if code in self.lastMinPath:\\n            minPath1 = self.lastMinPath[code]\\n        else:\\n            minPath1 = self.findMinPath(grid,i,j-1) \\n\\n        minPath2 = -1\\n        code = str(i - 1) + \" \" + str(j)\\n        if code in self.lastMinPath:\\n            minPath2 = self.lastMinPath[code]\\n        else:\\n            minPath2 = self.findMinPath(grid,i - 1,j) \\n\\n        result = grid[i][j] + min(minPath1,minPath2)\\n        self.insertResult(i,j,result)\\n        return result\\n\\n    def minPathSum(self, grid: List[List[int]]) -> int:\\n        code = \"0 0\"\\n        self.lastMinPath[code] = grid[0][0] \\n        return self.findMinPath(grid,len(grid) - 1,len(grid[0]) - 1)\\n```\\nI don\\'t know and can\\'t find the problem , can you tell me why ?\\n\\n"
                    },
                    {
                        "username": "alshine",
                        "content": "if you are experiencing problems, I advise you to solve [62. Unique Paths\n](https://leetcode.com/problems/unique-paths/)"
                    },
                    {
                        "username": "Ztilly",
                        "content": "This is a bad problem due to the fact that the maximized number possible will always use every tile. The example given is incorrect. The maxamized path would be 1 -> 3 -> 1 -> 1 -> 5 -> 1 -> 4 -> 2 -> 1, resulting in 19, not 7. \n\nstarting top left you move accross the board to the right, then once you reach the end you go down once, to the left, and back to the right once more. In the event there's an even amount of rows, it's still possible to touch every tile while only moving one space as a time in the left or right direction, and this will always be the case for any size square or rectangle."
                    },
                    {
                        "username": "AMerrill",
                        "content": "\"You can only move either down or right at any point in time.\" \\n\\nAlso, you want to minimize the the sum."
                    },
                    {
                        "username": "arumuga007",
                        "content": "what the correct output for [1,2], [1,1]?i get 4 but it expect 3??\\nAnyone explain me how??"
                    },
                    {
                        "username": "AMerrill",
                        "content": "take 1 -> 1 -> 1 or moving Down and then Right. Total sum is $$3$$.\n\n^This is the path with the minimum sum."
                    },
                    {
                        "username": "JiayingGao",
                        "content": "How to optimize my bfs code? It can AC but need run almost 1.7s  :<.\\n\\'\\'\\'\\nclass Solution {\\npublic:\\n    int minPathSum(vector<vector<int>>& grid) {\\n        \\n        int m = grid.size(), n = grid.front().size(), nd[2][2] = {{1, 0}, {0, 1}};\\n        vector<vector<int>> marked(m, vector<int>(n, INT_MAX)); marked[0][0] = grid[0][0];\\n        queue<tuple<int, int, int>> units;  units.push({0, 0, grid[0][0]});\\n        while(!units.empty()){\\n            auto [y, x, sum] = units.front();  units.pop();\\n            for (int k = 0; k < 2; k++){\\n                int ny = y + nd[k][0], nx = x + nd[k][1];\\n                if (ny >= m || nx >= n) continue;\\n                int update_sum = sum + grid[ny][nx];\\n                if (update_sum < marked[ny][nx]){\\n                    marked[ny][nx] = update_sum;\\n                    units.push({ny, nx, update_sum});\\n                }\\n            }\\n        }\\n        return marked[m - 1][n - 1];\\n    }\\n};\\n\\'\\'\\' "
                    },
                    {
                        "username": "alpharomeo99",
                        "content": "In case you're asked to find the path with minimum sum, you can just start from the source after creating the dp array. From source move greedily towards the the cell that has the minimum path sum to the destination and accordingly update the path. This will take O(N) time."
                    },
                    {
                        "username": "sanshoys",
                        "content": "grid =\\n[[1,2],[1,1]]\\nOutput\\n4\\nExpected\\n3 \\n\\nwhy is it 3?  1 + 2 + 1 = 4"
                    },
                    {
                        "username": "hoangnn451",
                        "content": "1 + 1 + 1 = 3\\nstart from (0,0), move down (1,0), move right (1,1)\\n(0,0) + (1,0) + (1,1) = 1 + 1 + 1 = 3 \\n\\nNote: You can only move either down or right at any point in time."
                    },
                    {
                        "username": "Sumit2828",
                        "content": "class Solution {\\npublic:\\n    int minPathSum(vector<vector<int>>& grid) {\\n        int m=grid.size();\\n        int n=grid[0].size();\\n\\n        int dp[m][n];\\n        dp[0][0]=grid[0][0];\\n        for(int i=1;i<m;i++){\\n            dp[0][i]+=dp[0][i-1];\\n        }\\n        for(int i=1;i<n;i++){\\n            dp[i][0]+=dp[i-1][0];\\n        }\\n        for(int i=1;i<m;i++){\\n            for(int j=1;j<n;j++){\\n                dp[i][j]+=min(dp[i-1][j],dp[i][j-1]);\\n            }\\n        }\\n        return dp[m-1][n-1];\\n        \\n    }\\n};\\n\\nThis code is giving the runtime error as dynamic-stack-buffer-overflow , can anyone give the fault in the code  corresponding to the given error, and the solution to the error."
                    },
                    {
                        "username": "Sumit2828",
                        "content": "[@manifold1985](/manifold1985) Thanks\\uD83D\\uDC4D"
                    },
                    {
                        "username": "manifold1985",
                        "content": "You used syntax such as \"dp[i][j]+=min(dp[i-1][j],dp[i][j-1])\", but your dp[i][j] hasn\\'t been assigned any value yet. I am afraid that\\'s the cause. Also, it seems like grid[i][j] hasn\\'t been incorporated into your code. You should modify your code accordingly."
                    },
                    {
                        "username": "PAIN_an_c",
                        "content": "why this code giving tle even i travelled m*n using recursion\\n\\nclass Solution {\\npublic:\\n    void reduce(vector<vector<int>>grid,vector<vector<int>>& box,int i,int j){\\n        if(i==grid.size())\\n            return ;\\n        else if(j==grid[0].size()){\\n           reduce(grid,box,i+1,0);\\n           return ;\\n        }\\n        if(i-1>=0 && j-1>=0){box[i][j]=grid[i][j]+min(box[i-1][j],box[i][j-1]);}\\n        else if(i-1>=0){box[i][j]=grid[i][j]+box[i-1][j];}\\n        else{box[i][j]=grid[i][j]+box[i][j-1];}\\n\\n        reduce(grid,box,i,j+1);\\n    }\\npublic:\\n\\n    int minPathSum(vector<vector<int>>& grid) {\\n        int m=grid.size(),n=grid[0].size();\\n        vector<vector<int>>box(m,vector<int>(n,-1)); \\n        box[0][0]=grid[0][0];\\n        reduce(grid,box,0,1);\\n        return box[m-1][n-1];   \\n    }\\n};"
                    },
                    {
                        "username": "JiayingGao",
                        "content": "Just remember to let the memorization works, add: if (box[y][x] != -1) return memory;"
                    },
                    {
                        "username": "SharmaAyush",
                        "content": "class Solution {\\npublic:\\n   \\n    int minPathSum(vector<vector<int>>&grid){\\n        int m=grid.size();\\n        int n = grid[0].size();\\n\\n        int** dp = new int*[m];\\n\\n        for(int i=0;i<m;i++){\\n            dp[i] = new int[n];\\n        }\\n\\n        dp[0][0] =grid[0][0];\\n\\n        for(int i=1;i<n;i++){\\n            dp[0][i] = dp[0][i-1]+grid[0][i];\\n        }\\n            for(int i=1;i<m;i++){\\n            dp[i][0] = dp[i-1][0]+grid[i][0];\\n        }\\n\\n        for(int i=1;i<m;i++){\\n            for(int j=1;j<n;j++){\\n                dp[i][j] = min(dp[i-1][j],dp[i][j-1]) +grid[i][j];\\n            }\\n        \\n        }   \\n        return dp[m-1][n-1];\\n    }\\n};"
                    }
                ]
            },
            {
                "id": 1844840,
                "content": [
                    {
                        "username": "Masterdemon123",
                        "content": "help guys , I having this code and leetcode keeps telling me that the output for case grid = [[1,2,3],[4,5,6]] is 11 meanwhile I have tested it in 2 different IDE using debug mode (visual studio and programiz) and the result is 12 \\n```\\nclass Solution:\\n    lastMinPath = {}\\n\\n    def insertResult(self, i: int, j: int, result):\\n        code = str(i) +  \" \" + str(j) \\n        self.lastMinPath[code] = result \\n\\n    def findMinPath(self, grid: list[list[int]], i: int, j: int) -> int:\\n        if i == 0 and j == 0 :\\n            return grid[i][j]\\n\\n        if i == 0 :\\n\\n            minPath = -1\\n\\n            code = str(i) + \" \" + str(j - 1)\\n            if code in self.lastMinPath:\\n                minPath = self.lastMinPath[code]\\n            else:\\n                minPath = self.findMinPath(grid,i,j - 1)\\n\\n            result = grid[i][j] + minPath\\n            self.insertResult(i,j,result)\\n            return result\\n\\n        if j == 0 :\\n            minPath = -1\\n\\n            code = str(i - 1) + \" \" + str(j)\\n            if code in self.lastMinPath:\\n                minPath = self.lastMinPath[code]\\n            else:\\n                minPath = self.findMinPath(grid,i-1,j) \\n\\n            result = grid[i][j] + minPath\\n            self.insertResult(i,j,result)\\n            return result\\n\\n\\n        minPath1 = -1\\n\\n        code = str(i) + \" \" + str(j - 1)\\n        if code in self.lastMinPath:\\n            minPath1 = self.lastMinPath[code]\\n        else:\\n            minPath1 = self.findMinPath(grid,i,j-1) \\n\\n        minPath2 = -1\\n        code = str(i - 1) + \" \" + str(j)\\n        if code in self.lastMinPath:\\n            minPath2 = self.lastMinPath[code]\\n        else:\\n            minPath2 = self.findMinPath(grid,i - 1,j) \\n\\n        result = grid[i][j] + min(minPath1,minPath2)\\n        self.insertResult(i,j,result)\\n        return result\\n\\n    def minPathSum(self, grid: List[List[int]]) -> int:\\n        code = \"0 0\"\\n        self.lastMinPath[code] = grid[0][0] \\n        return self.findMinPath(grid,len(grid) - 1,len(grid[0]) - 1)\\n```\\nI don\\'t know and can\\'t find the problem , can you tell me why ?\\n\\n"
                    },
                    {
                        "username": "alshine",
                        "content": "if you are experiencing problems, I advise you to solve [62. Unique Paths\n](https://leetcode.com/problems/unique-paths/)"
                    },
                    {
                        "username": "Ztilly",
                        "content": "This is a bad problem due to the fact that the maximized number possible will always use every tile. The example given is incorrect. The maxamized path would be 1 -> 3 -> 1 -> 1 -> 5 -> 1 -> 4 -> 2 -> 1, resulting in 19, not 7. \n\nstarting top left you move accross the board to the right, then once you reach the end you go down once, to the left, and back to the right once more. In the event there's an even amount of rows, it's still possible to touch every tile while only moving one space as a time in the left or right direction, and this will always be the case for any size square or rectangle."
                    },
                    {
                        "username": "AMerrill",
                        "content": "\"You can only move either down or right at any point in time.\" \\n\\nAlso, you want to minimize the the sum."
                    },
                    {
                        "username": "arumuga007",
                        "content": "what the correct output for [1,2], [1,1]?i get 4 but it expect 3??\\nAnyone explain me how??"
                    },
                    {
                        "username": "AMerrill",
                        "content": "take 1 -> 1 -> 1 or moving Down and then Right. Total sum is $$3$$.\n\n^This is the path with the minimum sum."
                    },
                    {
                        "username": "JiayingGao",
                        "content": "How to optimize my bfs code? It can AC but need run almost 1.7s  :<.\\n\\'\\'\\'\\nclass Solution {\\npublic:\\n    int minPathSum(vector<vector<int>>& grid) {\\n        \\n        int m = grid.size(), n = grid.front().size(), nd[2][2] = {{1, 0}, {0, 1}};\\n        vector<vector<int>> marked(m, vector<int>(n, INT_MAX)); marked[0][0] = grid[0][0];\\n        queue<tuple<int, int, int>> units;  units.push({0, 0, grid[0][0]});\\n        while(!units.empty()){\\n            auto [y, x, sum] = units.front();  units.pop();\\n            for (int k = 0; k < 2; k++){\\n                int ny = y + nd[k][0], nx = x + nd[k][1];\\n                if (ny >= m || nx >= n) continue;\\n                int update_sum = sum + grid[ny][nx];\\n                if (update_sum < marked[ny][nx]){\\n                    marked[ny][nx] = update_sum;\\n                    units.push({ny, nx, update_sum});\\n                }\\n            }\\n        }\\n        return marked[m - 1][n - 1];\\n    }\\n};\\n\\'\\'\\' "
                    },
                    {
                        "username": "alpharomeo99",
                        "content": "In case you're asked to find the path with minimum sum, you can just start from the source after creating the dp array. From source move greedily towards the the cell that has the minimum path sum to the destination and accordingly update the path. This will take O(N) time."
                    },
                    {
                        "username": "sanshoys",
                        "content": "grid =\\n[[1,2],[1,1]]\\nOutput\\n4\\nExpected\\n3 \\n\\nwhy is it 3?  1 + 2 + 1 = 4"
                    },
                    {
                        "username": "hoangnn451",
                        "content": "1 + 1 + 1 = 3\\nstart from (0,0), move down (1,0), move right (1,1)\\n(0,0) + (1,0) + (1,1) = 1 + 1 + 1 = 3 \\n\\nNote: You can only move either down or right at any point in time."
                    },
                    {
                        "username": "Sumit2828",
                        "content": "class Solution {\\npublic:\\n    int minPathSum(vector<vector<int>>& grid) {\\n        int m=grid.size();\\n        int n=grid[0].size();\\n\\n        int dp[m][n];\\n        dp[0][0]=grid[0][0];\\n        for(int i=1;i<m;i++){\\n            dp[0][i]+=dp[0][i-1];\\n        }\\n        for(int i=1;i<n;i++){\\n            dp[i][0]+=dp[i-1][0];\\n        }\\n        for(int i=1;i<m;i++){\\n            for(int j=1;j<n;j++){\\n                dp[i][j]+=min(dp[i-1][j],dp[i][j-1]);\\n            }\\n        }\\n        return dp[m-1][n-1];\\n        \\n    }\\n};\\n\\nThis code is giving the runtime error as dynamic-stack-buffer-overflow , can anyone give the fault in the code  corresponding to the given error, and the solution to the error."
                    },
                    {
                        "username": "Sumit2828",
                        "content": "[@manifold1985](/manifold1985) Thanks\\uD83D\\uDC4D"
                    },
                    {
                        "username": "manifold1985",
                        "content": "You used syntax such as \"dp[i][j]+=min(dp[i-1][j],dp[i][j-1])\", but your dp[i][j] hasn\\'t been assigned any value yet. I am afraid that\\'s the cause. Also, it seems like grid[i][j] hasn\\'t been incorporated into your code. You should modify your code accordingly."
                    },
                    {
                        "username": "PAIN_an_c",
                        "content": "why this code giving tle even i travelled m*n using recursion\\n\\nclass Solution {\\npublic:\\n    void reduce(vector<vector<int>>grid,vector<vector<int>>& box,int i,int j){\\n        if(i==grid.size())\\n            return ;\\n        else if(j==grid[0].size()){\\n           reduce(grid,box,i+1,0);\\n           return ;\\n        }\\n        if(i-1>=0 && j-1>=0){box[i][j]=grid[i][j]+min(box[i-1][j],box[i][j-1]);}\\n        else if(i-1>=0){box[i][j]=grid[i][j]+box[i-1][j];}\\n        else{box[i][j]=grid[i][j]+box[i][j-1];}\\n\\n        reduce(grid,box,i,j+1);\\n    }\\npublic:\\n\\n    int minPathSum(vector<vector<int>>& grid) {\\n        int m=grid.size(),n=grid[0].size();\\n        vector<vector<int>>box(m,vector<int>(n,-1)); \\n        box[0][0]=grid[0][0];\\n        reduce(grid,box,0,1);\\n        return box[m-1][n-1];   \\n    }\\n};"
                    },
                    {
                        "username": "JiayingGao",
                        "content": "Just remember to let the memorization works, add: if (box[y][x] != -1) return memory;"
                    },
                    {
                        "username": "SharmaAyush",
                        "content": "class Solution {\\npublic:\\n   \\n    int minPathSum(vector<vector<int>>&grid){\\n        int m=grid.size();\\n        int n = grid[0].size();\\n\\n        int** dp = new int*[m];\\n\\n        for(int i=0;i<m;i++){\\n            dp[i] = new int[n];\\n        }\\n\\n        dp[0][0] =grid[0][0];\\n\\n        for(int i=1;i<n;i++){\\n            dp[0][i] = dp[0][i-1]+grid[0][i];\\n        }\\n            for(int i=1;i<m;i++){\\n            dp[i][0] = dp[i-1][0]+grid[i][0];\\n        }\\n\\n        for(int i=1;i<m;i++){\\n            for(int j=1;j<n;j++){\\n                dp[i][j] = min(dp[i-1][j],dp[i][j-1]) +grid[i][j];\\n            }\\n        \\n        }   \\n        return dp[m-1][n-1];\\n    }\\n};"
                    }
                ]
            },
            {
                "id": 1844330,
                "content": [
                    {
                        "username": "Masterdemon123",
                        "content": "help guys , I having this code and leetcode keeps telling me that the output for case grid = [[1,2,3],[4,5,6]] is 11 meanwhile I have tested it in 2 different IDE using debug mode (visual studio and programiz) and the result is 12 \\n```\\nclass Solution:\\n    lastMinPath = {}\\n\\n    def insertResult(self, i: int, j: int, result):\\n        code = str(i) +  \" \" + str(j) \\n        self.lastMinPath[code] = result \\n\\n    def findMinPath(self, grid: list[list[int]], i: int, j: int) -> int:\\n        if i == 0 and j == 0 :\\n            return grid[i][j]\\n\\n        if i == 0 :\\n\\n            minPath = -1\\n\\n            code = str(i) + \" \" + str(j - 1)\\n            if code in self.lastMinPath:\\n                minPath = self.lastMinPath[code]\\n            else:\\n                minPath = self.findMinPath(grid,i,j - 1)\\n\\n            result = grid[i][j] + minPath\\n            self.insertResult(i,j,result)\\n            return result\\n\\n        if j == 0 :\\n            minPath = -1\\n\\n            code = str(i - 1) + \" \" + str(j)\\n            if code in self.lastMinPath:\\n                minPath = self.lastMinPath[code]\\n            else:\\n                minPath = self.findMinPath(grid,i-1,j) \\n\\n            result = grid[i][j] + minPath\\n            self.insertResult(i,j,result)\\n            return result\\n\\n\\n        minPath1 = -1\\n\\n        code = str(i) + \" \" + str(j - 1)\\n        if code in self.lastMinPath:\\n            minPath1 = self.lastMinPath[code]\\n        else:\\n            minPath1 = self.findMinPath(grid,i,j-1) \\n\\n        minPath2 = -1\\n        code = str(i - 1) + \" \" + str(j)\\n        if code in self.lastMinPath:\\n            minPath2 = self.lastMinPath[code]\\n        else:\\n            minPath2 = self.findMinPath(grid,i - 1,j) \\n\\n        result = grid[i][j] + min(minPath1,minPath2)\\n        self.insertResult(i,j,result)\\n        return result\\n\\n    def minPathSum(self, grid: List[List[int]]) -> int:\\n        code = \"0 0\"\\n        self.lastMinPath[code] = grid[0][0] \\n        return self.findMinPath(grid,len(grid) - 1,len(grid[0]) - 1)\\n```\\nI don\\'t know and can\\'t find the problem , can you tell me why ?\\n\\n"
                    },
                    {
                        "username": "alshine",
                        "content": "if you are experiencing problems, I advise you to solve [62. Unique Paths\n](https://leetcode.com/problems/unique-paths/)"
                    },
                    {
                        "username": "Ztilly",
                        "content": "This is a bad problem due to the fact that the maximized number possible will always use every tile. The example given is incorrect. The maxamized path would be 1 -> 3 -> 1 -> 1 -> 5 -> 1 -> 4 -> 2 -> 1, resulting in 19, not 7. \n\nstarting top left you move accross the board to the right, then once you reach the end you go down once, to the left, and back to the right once more. In the event there's an even amount of rows, it's still possible to touch every tile while only moving one space as a time in the left or right direction, and this will always be the case for any size square or rectangle."
                    },
                    {
                        "username": "AMerrill",
                        "content": "\"You can only move either down or right at any point in time.\" \\n\\nAlso, you want to minimize the the sum."
                    },
                    {
                        "username": "arumuga007",
                        "content": "what the correct output for [1,2], [1,1]?i get 4 but it expect 3??\\nAnyone explain me how??"
                    },
                    {
                        "username": "AMerrill",
                        "content": "take 1 -> 1 -> 1 or moving Down and then Right. Total sum is $$3$$.\n\n^This is the path with the minimum sum."
                    },
                    {
                        "username": "JiayingGao",
                        "content": "How to optimize my bfs code? It can AC but need run almost 1.7s  :<.\\n\\'\\'\\'\\nclass Solution {\\npublic:\\n    int minPathSum(vector<vector<int>>& grid) {\\n        \\n        int m = grid.size(), n = grid.front().size(), nd[2][2] = {{1, 0}, {0, 1}};\\n        vector<vector<int>> marked(m, vector<int>(n, INT_MAX)); marked[0][0] = grid[0][0];\\n        queue<tuple<int, int, int>> units;  units.push({0, 0, grid[0][0]});\\n        while(!units.empty()){\\n            auto [y, x, sum] = units.front();  units.pop();\\n            for (int k = 0; k < 2; k++){\\n                int ny = y + nd[k][0], nx = x + nd[k][1];\\n                if (ny >= m || nx >= n) continue;\\n                int update_sum = sum + grid[ny][nx];\\n                if (update_sum < marked[ny][nx]){\\n                    marked[ny][nx] = update_sum;\\n                    units.push({ny, nx, update_sum});\\n                }\\n            }\\n        }\\n        return marked[m - 1][n - 1];\\n    }\\n};\\n\\'\\'\\' "
                    },
                    {
                        "username": "alpharomeo99",
                        "content": "In case you're asked to find the path with minimum sum, you can just start from the source after creating the dp array. From source move greedily towards the the cell that has the minimum path sum to the destination and accordingly update the path. This will take O(N) time."
                    },
                    {
                        "username": "sanshoys",
                        "content": "grid =\\n[[1,2],[1,1]]\\nOutput\\n4\\nExpected\\n3 \\n\\nwhy is it 3?  1 + 2 + 1 = 4"
                    },
                    {
                        "username": "hoangnn451",
                        "content": "1 + 1 + 1 = 3\\nstart from (0,0), move down (1,0), move right (1,1)\\n(0,0) + (1,0) + (1,1) = 1 + 1 + 1 = 3 \\n\\nNote: You can only move either down or right at any point in time."
                    },
                    {
                        "username": "Sumit2828",
                        "content": "class Solution {\\npublic:\\n    int minPathSum(vector<vector<int>>& grid) {\\n        int m=grid.size();\\n        int n=grid[0].size();\\n\\n        int dp[m][n];\\n        dp[0][0]=grid[0][0];\\n        for(int i=1;i<m;i++){\\n            dp[0][i]+=dp[0][i-1];\\n        }\\n        for(int i=1;i<n;i++){\\n            dp[i][0]+=dp[i-1][0];\\n        }\\n        for(int i=1;i<m;i++){\\n            for(int j=1;j<n;j++){\\n                dp[i][j]+=min(dp[i-1][j],dp[i][j-1]);\\n            }\\n        }\\n        return dp[m-1][n-1];\\n        \\n    }\\n};\\n\\nThis code is giving the runtime error as dynamic-stack-buffer-overflow , can anyone give the fault in the code  corresponding to the given error, and the solution to the error."
                    },
                    {
                        "username": "Sumit2828",
                        "content": "[@manifold1985](/manifold1985) Thanks\\uD83D\\uDC4D"
                    },
                    {
                        "username": "manifold1985",
                        "content": "You used syntax such as \"dp[i][j]+=min(dp[i-1][j],dp[i][j-1])\", but your dp[i][j] hasn\\'t been assigned any value yet. I am afraid that\\'s the cause. Also, it seems like grid[i][j] hasn\\'t been incorporated into your code. You should modify your code accordingly."
                    },
                    {
                        "username": "PAIN_an_c",
                        "content": "why this code giving tle even i travelled m*n using recursion\\n\\nclass Solution {\\npublic:\\n    void reduce(vector<vector<int>>grid,vector<vector<int>>& box,int i,int j){\\n        if(i==grid.size())\\n            return ;\\n        else if(j==grid[0].size()){\\n           reduce(grid,box,i+1,0);\\n           return ;\\n        }\\n        if(i-1>=0 && j-1>=0){box[i][j]=grid[i][j]+min(box[i-1][j],box[i][j-1]);}\\n        else if(i-1>=0){box[i][j]=grid[i][j]+box[i-1][j];}\\n        else{box[i][j]=grid[i][j]+box[i][j-1];}\\n\\n        reduce(grid,box,i,j+1);\\n    }\\npublic:\\n\\n    int minPathSum(vector<vector<int>>& grid) {\\n        int m=grid.size(),n=grid[0].size();\\n        vector<vector<int>>box(m,vector<int>(n,-1)); \\n        box[0][0]=grid[0][0];\\n        reduce(grid,box,0,1);\\n        return box[m-1][n-1];   \\n    }\\n};"
                    },
                    {
                        "username": "JiayingGao",
                        "content": "Just remember to let the memorization works, add: if (box[y][x] != -1) return memory;"
                    },
                    {
                        "username": "SharmaAyush",
                        "content": "class Solution {\\npublic:\\n   \\n    int minPathSum(vector<vector<int>>&grid){\\n        int m=grid.size();\\n        int n = grid[0].size();\\n\\n        int** dp = new int*[m];\\n\\n        for(int i=0;i<m;i++){\\n            dp[i] = new int[n];\\n        }\\n\\n        dp[0][0] =grid[0][0];\\n\\n        for(int i=1;i<n;i++){\\n            dp[0][i] = dp[0][i-1]+grid[0][i];\\n        }\\n            for(int i=1;i<m;i++){\\n            dp[i][0] = dp[i-1][0]+grid[i][0];\\n        }\\n\\n        for(int i=1;i<m;i++){\\n            for(int j=1;j<n;j++){\\n                dp[i][j] = min(dp[i-1][j],dp[i][j-1]) +grid[i][j];\\n            }\\n        \\n        }   \\n        return dp[m-1][n-1];\\n    }\\n};"
                    }
                ]
            },
            {
                "id": 1842951,
                "content": [
                    {
                        "username": "Masterdemon123",
                        "content": "help guys , I having this code and leetcode keeps telling me that the output for case grid = [[1,2,3],[4,5,6]] is 11 meanwhile I have tested it in 2 different IDE using debug mode (visual studio and programiz) and the result is 12 \\n```\\nclass Solution:\\n    lastMinPath = {}\\n\\n    def insertResult(self, i: int, j: int, result):\\n        code = str(i) +  \" \" + str(j) \\n        self.lastMinPath[code] = result \\n\\n    def findMinPath(self, grid: list[list[int]], i: int, j: int) -> int:\\n        if i == 0 and j == 0 :\\n            return grid[i][j]\\n\\n        if i == 0 :\\n\\n            minPath = -1\\n\\n            code = str(i) + \" \" + str(j - 1)\\n            if code in self.lastMinPath:\\n                minPath = self.lastMinPath[code]\\n            else:\\n                minPath = self.findMinPath(grid,i,j - 1)\\n\\n            result = grid[i][j] + minPath\\n            self.insertResult(i,j,result)\\n            return result\\n\\n        if j == 0 :\\n            minPath = -1\\n\\n            code = str(i - 1) + \" \" + str(j)\\n            if code in self.lastMinPath:\\n                minPath = self.lastMinPath[code]\\n            else:\\n                minPath = self.findMinPath(grid,i-1,j) \\n\\n            result = grid[i][j] + minPath\\n            self.insertResult(i,j,result)\\n            return result\\n\\n\\n        minPath1 = -1\\n\\n        code = str(i) + \" \" + str(j - 1)\\n        if code in self.lastMinPath:\\n            minPath1 = self.lastMinPath[code]\\n        else:\\n            minPath1 = self.findMinPath(grid,i,j-1) \\n\\n        minPath2 = -1\\n        code = str(i - 1) + \" \" + str(j)\\n        if code in self.lastMinPath:\\n            minPath2 = self.lastMinPath[code]\\n        else:\\n            minPath2 = self.findMinPath(grid,i - 1,j) \\n\\n        result = grid[i][j] + min(minPath1,minPath2)\\n        self.insertResult(i,j,result)\\n        return result\\n\\n    def minPathSum(self, grid: List[List[int]]) -> int:\\n        code = \"0 0\"\\n        self.lastMinPath[code] = grid[0][0] \\n        return self.findMinPath(grid,len(grid) - 1,len(grid[0]) - 1)\\n```\\nI don\\'t know and can\\'t find the problem , can you tell me why ?\\n\\n"
                    },
                    {
                        "username": "alshine",
                        "content": "if you are experiencing problems, I advise you to solve [62. Unique Paths\n](https://leetcode.com/problems/unique-paths/)"
                    },
                    {
                        "username": "Ztilly",
                        "content": "This is a bad problem due to the fact that the maximized number possible will always use every tile. The example given is incorrect. The maxamized path would be 1 -> 3 -> 1 -> 1 -> 5 -> 1 -> 4 -> 2 -> 1, resulting in 19, not 7. \n\nstarting top left you move accross the board to the right, then once you reach the end you go down once, to the left, and back to the right once more. In the event there's an even amount of rows, it's still possible to touch every tile while only moving one space as a time in the left or right direction, and this will always be the case for any size square or rectangle."
                    },
                    {
                        "username": "AMerrill",
                        "content": "\"You can only move either down or right at any point in time.\" \\n\\nAlso, you want to minimize the the sum."
                    },
                    {
                        "username": "arumuga007",
                        "content": "what the correct output for [1,2], [1,1]?i get 4 but it expect 3??\\nAnyone explain me how??"
                    },
                    {
                        "username": "AMerrill",
                        "content": "take 1 -> 1 -> 1 or moving Down and then Right. Total sum is $$3$$.\n\n^This is the path with the minimum sum."
                    },
                    {
                        "username": "JiayingGao",
                        "content": "How to optimize my bfs code? It can AC but need run almost 1.7s  :<.\\n\\'\\'\\'\\nclass Solution {\\npublic:\\n    int minPathSum(vector<vector<int>>& grid) {\\n        \\n        int m = grid.size(), n = grid.front().size(), nd[2][2] = {{1, 0}, {0, 1}};\\n        vector<vector<int>> marked(m, vector<int>(n, INT_MAX)); marked[0][0] = grid[0][0];\\n        queue<tuple<int, int, int>> units;  units.push({0, 0, grid[0][0]});\\n        while(!units.empty()){\\n            auto [y, x, sum] = units.front();  units.pop();\\n            for (int k = 0; k < 2; k++){\\n                int ny = y + nd[k][0], nx = x + nd[k][1];\\n                if (ny >= m || nx >= n) continue;\\n                int update_sum = sum + grid[ny][nx];\\n                if (update_sum < marked[ny][nx]){\\n                    marked[ny][nx] = update_sum;\\n                    units.push({ny, nx, update_sum});\\n                }\\n            }\\n        }\\n        return marked[m - 1][n - 1];\\n    }\\n};\\n\\'\\'\\' "
                    },
                    {
                        "username": "alpharomeo99",
                        "content": "In case you're asked to find the path with minimum sum, you can just start from the source after creating the dp array. From source move greedily towards the the cell that has the minimum path sum to the destination and accordingly update the path. This will take O(N) time."
                    },
                    {
                        "username": "sanshoys",
                        "content": "grid =\\n[[1,2],[1,1]]\\nOutput\\n4\\nExpected\\n3 \\n\\nwhy is it 3?  1 + 2 + 1 = 4"
                    },
                    {
                        "username": "hoangnn451",
                        "content": "1 + 1 + 1 = 3\\nstart from (0,0), move down (1,0), move right (1,1)\\n(0,0) + (1,0) + (1,1) = 1 + 1 + 1 = 3 \\n\\nNote: You can only move either down or right at any point in time."
                    },
                    {
                        "username": "Sumit2828",
                        "content": "class Solution {\\npublic:\\n    int minPathSum(vector<vector<int>>& grid) {\\n        int m=grid.size();\\n        int n=grid[0].size();\\n\\n        int dp[m][n];\\n        dp[0][0]=grid[0][0];\\n        for(int i=1;i<m;i++){\\n            dp[0][i]+=dp[0][i-1];\\n        }\\n        for(int i=1;i<n;i++){\\n            dp[i][0]+=dp[i-1][0];\\n        }\\n        for(int i=1;i<m;i++){\\n            for(int j=1;j<n;j++){\\n                dp[i][j]+=min(dp[i-1][j],dp[i][j-1]);\\n            }\\n        }\\n        return dp[m-1][n-1];\\n        \\n    }\\n};\\n\\nThis code is giving the runtime error as dynamic-stack-buffer-overflow , can anyone give the fault in the code  corresponding to the given error, and the solution to the error."
                    },
                    {
                        "username": "Sumit2828",
                        "content": "[@manifold1985](/manifold1985) Thanks\\uD83D\\uDC4D"
                    },
                    {
                        "username": "manifold1985",
                        "content": "You used syntax such as \"dp[i][j]+=min(dp[i-1][j],dp[i][j-1])\", but your dp[i][j] hasn\\'t been assigned any value yet. I am afraid that\\'s the cause. Also, it seems like grid[i][j] hasn\\'t been incorporated into your code. You should modify your code accordingly."
                    },
                    {
                        "username": "PAIN_an_c",
                        "content": "why this code giving tle even i travelled m*n using recursion\\n\\nclass Solution {\\npublic:\\n    void reduce(vector<vector<int>>grid,vector<vector<int>>& box,int i,int j){\\n        if(i==grid.size())\\n            return ;\\n        else if(j==grid[0].size()){\\n           reduce(grid,box,i+1,0);\\n           return ;\\n        }\\n        if(i-1>=0 && j-1>=0){box[i][j]=grid[i][j]+min(box[i-1][j],box[i][j-1]);}\\n        else if(i-1>=0){box[i][j]=grid[i][j]+box[i-1][j];}\\n        else{box[i][j]=grid[i][j]+box[i][j-1];}\\n\\n        reduce(grid,box,i,j+1);\\n    }\\npublic:\\n\\n    int minPathSum(vector<vector<int>>& grid) {\\n        int m=grid.size(),n=grid[0].size();\\n        vector<vector<int>>box(m,vector<int>(n,-1)); \\n        box[0][0]=grid[0][0];\\n        reduce(grid,box,0,1);\\n        return box[m-1][n-1];   \\n    }\\n};"
                    },
                    {
                        "username": "JiayingGao",
                        "content": "Just remember to let the memorization works, add: if (box[y][x] != -1) return memory;"
                    },
                    {
                        "username": "SharmaAyush",
                        "content": "class Solution {\\npublic:\\n   \\n    int minPathSum(vector<vector<int>>&grid){\\n        int m=grid.size();\\n        int n = grid[0].size();\\n\\n        int** dp = new int*[m];\\n\\n        for(int i=0;i<m;i++){\\n            dp[i] = new int[n];\\n        }\\n\\n        dp[0][0] =grid[0][0];\\n\\n        for(int i=1;i<n;i++){\\n            dp[0][i] = dp[0][i-1]+grid[0][i];\\n        }\\n            for(int i=1;i<m;i++){\\n            dp[i][0] = dp[i-1][0]+grid[i][0];\\n        }\\n\\n        for(int i=1;i<m;i++){\\n            for(int j=1;j<n;j++){\\n                dp[i][j] = min(dp[i-1][j],dp[i][j-1]) +grid[i][j];\\n            }\\n        \\n        }   \\n        return dp[m-1][n-1];\\n    }\\n};"
                    }
                ]
            },
            {
                "id": 1835620,
                "content": [
                    {
                        "username": "Masterdemon123",
                        "content": "help guys , I having this code and leetcode keeps telling me that the output for case grid = [[1,2,3],[4,5,6]] is 11 meanwhile I have tested it in 2 different IDE using debug mode (visual studio and programiz) and the result is 12 \\n```\\nclass Solution:\\n    lastMinPath = {}\\n\\n    def insertResult(self, i: int, j: int, result):\\n        code = str(i) +  \" \" + str(j) \\n        self.lastMinPath[code] = result \\n\\n    def findMinPath(self, grid: list[list[int]], i: int, j: int) -> int:\\n        if i == 0 and j == 0 :\\n            return grid[i][j]\\n\\n        if i == 0 :\\n\\n            minPath = -1\\n\\n            code = str(i) + \" \" + str(j - 1)\\n            if code in self.lastMinPath:\\n                minPath = self.lastMinPath[code]\\n            else:\\n                minPath = self.findMinPath(grid,i,j - 1)\\n\\n            result = grid[i][j] + minPath\\n            self.insertResult(i,j,result)\\n            return result\\n\\n        if j == 0 :\\n            minPath = -1\\n\\n            code = str(i - 1) + \" \" + str(j)\\n            if code in self.lastMinPath:\\n                minPath = self.lastMinPath[code]\\n            else:\\n                minPath = self.findMinPath(grid,i-1,j) \\n\\n            result = grid[i][j] + minPath\\n            self.insertResult(i,j,result)\\n            return result\\n\\n\\n        minPath1 = -1\\n\\n        code = str(i) + \" \" + str(j - 1)\\n        if code in self.lastMinPath:\\n            minPath1 = self.lastMinPath[code]\\n        else:\\n            minPath1 = self.findMinPath(grid,i,j-1) \\n\\n        minPath2 = -1\\n        code = str(i - 1) + \" \" + str(j)\\n        if code in self.lastMinPath:\\n            minPath2 = self.lastMinPath[code]\\n        else:\\n            minPath2 = self.findMinPath(grid,i - 1,j) \\n\\n        result = grid[i][j] + min(minPath1,minPath2)\\n        self.insertResult(i,j,result)\\n        return result\\n\\n    def minPathSum(self, grid: List[List[int]]) -> int:\\n        code = \"0 0\"\\n        self.lastMinPath[code] = grid[0][0] \\n        return self.findMinPath(grid,len(grid) - 1,len(grid[0]) - 1)\\n```\\nI don\\'t know and can\\'t find the problem , can you tell me why ?\\n\\n"
                    },
                    {
                        "username": "alshine",
                        "content": "if you are experiencing problems, I advise you to solve [62. Unique Paths\n](https://leetcode.com/problems/unique-paths/)"
                    },
                    {
                        "username": "Ztilly",
                        "content": "This is a bad problem due to the fact that the maximized number possible will always use every tile. The example given is incorrect. The maxamized path would be 1 -> 3 -> 1 -> 1 -> 5 -> 1 -> 4 -> 2 -> 1, resulting in 19, not 7. \n\nstarting top left you move accross the board to the right, then once you reach the end you go down once, to the left, and back to the right once more. In the event there's an even amount of rows, it's still possible to touch every tile while only moving one space as a time in the left or right direction, and this will always be the case for any size square or rectangle."
                    },
                    {
                        "username": "AMerrill",
                        "content": "\"You can only move either down or right at any point in time.\" \\n\\nAlso, you want to minimize the the sum."
                    },
                    {
                        "username": "arumuga007",
                        "content": "what the correct output for [1,2], [1,1]?i get 4 but it expect 3??\\nAnyone explain me how??"
                    },
                    {
                        "username": "AMerrill",
                        "content": "take 1 -> 1 -> 1 or moving Down and then Right. Total sum is $$3$$.\n\n^This is the path with the minimum sum."
                    },
                    {
                        "username": "JiayingGao",
                        "content": "How to optimize my bfs code? It can AC but need run almost 1.7s  :<.\\n\\'\\'\\'\\nclass Solution {\\npublic:\\n    int minPathSum(vector<vector<int>>& grid) {\\n        \\n        int m = grid.size(), n = grid.front().size(), nd[2][2] = {{1, 0}, {0, 1}};\\n        vector<vector<int>> marked(m, vector<int>(n, INT_MAX)); marked[0][0] = grid[0][0];\\n        queue<tuple<int, int, int>> units;  units.push({0, 0, grid[0][0]});\\n        while(!units.empty()){\\n            auto [y, x, sum] = units.front();  units.pop();\\n            for (int k = 0; k < 2; k++){\\n                int ny = y + nd[k][0], nx = x + nd[k][1];\\n                if (ny >= m || nx >= n) continue;\\n                int update_sum = sum + grid[ny][nx];\\n                if (update_sum < marked[ny][nx]){\\n                    marked[ny][nx] = update_sum;\\n                    units.push({ny, nx, update_sum});\\n                }\\n            }\\n        }\\n        return marked[m - 1][n - 1];\\n    }\\n};\\n\\'\\'\\' "
                    },
                    {
                        "username": "alpharomeo99",
                        "content": "In case you're asked to find the path with minimum sum, you can just start from the source after creating the dp array. From source move greedily towards the the cell that has the minimum path sum to the destination and accordingly update the path. This will take O(N) time."
                    },
                    {
                        "username": "sanshoys",
                        "content": "grid =\\n[[1,2],[1,1]]\\nOutput\\n4\\nExpected\\n3 \\n\\nwhy is it 3?  1 + 2 + 1 = 4"
                    },
                    {
                        "username": "hoangnn451",
                        "content": "1 + 1 + 1 = 3\\nstart from (0,0), move down (1,0), move right (1,1)\\n(0,0) + (1,0) + (1,1) = 1 + 1 + 1 = 3 \\n\\nNote: You can only move either down or right at any point in time."
                    },
                    {
                        "username": "Sumit2828",
                        "content": "class Solution {\\npublic:\\n    int minPathSum(vector<vector<int>>& grid) {\\n        int m=grid.size();\\n        int n=grid[0].size();\\n\\n        int dp[m][n];\\n        dp[0][0]=grid[0][0];\\n        for(int i=1;i<m;i++){\\n            dp[0][i]+=dp[0][i-1];\\n        }\\n        for(int i=1;i<n;i++){\\n            dp[i][0]+=dp[i-1][0];\\n        }\\n        for(int i=1;i<m;i++){\\n            for(int j=1;j<n;j++){\\n                dp[i][j]+=min(dp[i-1][j],dp[i][j-1]);\\n            }\\n        }\\n        return dp[m-1][n-1];\\n        \\n    }\\n};\\n\\nThis code is giving the runtime error as dynamic-stack-buffer-overflow , can anyone give the fault in the code  corresponding to the given error, and the solution to the error."
                    },
                    {
                        "username": "Sumit2828",
                        "content": "[@manifold1985](/manifold1985) Thanks\\uD83D\\uDC4D"
                    },
                    {
                        "username": "manifold1985",
                        "content": "You used syntax such as \"dp[i][j]+=min(dp[i-1][j],dp[i][j-1])\", but your dp[i][j] hasn\\'t been assigned any value yet. I am afraid that\\'s the cause. Also, it seems like grid[i][j] hasn\\'t been incorporated into your code. You should modify your code accordingly."
                    },
                    {
                        "username": "PAIN_an_c",
                        "content": "why this code giving tle even i travelled m*n using recursion\\n\\nclass Solution {\\npublic:\\n    void reduce(vector<vector<int>>grid,vector<vector<int>>& box,int i,int j){\\n        if(i==grid.size())\\n            return ;\\n        else if(j==grid[0].size()){\\n           reduce(grid,box,i+1,0);\\n           return ;\\n        }\\n        if(i-1>=0 && j-1>=0){box[i][j]=grid[i][j]+min(box[i-1][j],box[i][j-1]);}\\n        else if(i-1>=0){box[i][j]=grid[i][j]+box[i-1][j];}\\n        else{box[i][j]=grid[i][j]+box[i][j-1];}\\n\\n        reduce(grid,box,i,j+1);\\n    }\\npublic:\\n\\n    int minPathSum(vector<vector<int>>& grid) {\\n        int m=grid.size(),n=grid[0].size();\\n        vector<vector<int>>box(m,vector<int>(n,-1)); \\n        box[0][0]=grid[0][0];\\n        reduce(grid,box,0,1);\\n        return box[m-1][n-1];   \\n    }\\n};"
                    },
                    {
                        "username": "JiayingGao",
                        "content": "Just remember to let the memorization works, add: if (box[y][x] != -1) return memory;"
                    },
                    {
                        "username": "SharmaAyush",
                        "content": "class Solution {\\npublic:\\n   \\n    int minPathSum(vector<vector<int>>&grid){\\n        int m=grid.size();\\n        int n = grid[0].size();\\n\\n        int** dp = new int*[m];\\n\\n        for(int i=0;i<m;i++){\\n            dp[i] = new int[n];\\n        }\\n\\n        dp[0][0] =grid[0][0];\\n\\n        for(int i=1;i<n;i++){\\n            dp[0][i] = dp[0][i-1]+grid[0][i];\\n        }\\n            for(int i=1;i<m;i++){\\n            dp[i][0] = dp[i-1][0]+grid[i][0];\\n        }\\n\\n        for(int i=1;i<m;i++){\\n            for(int j=1;j<n;j++){\\n                dp[i][j] = min(dp[i-1][j],dp[i][j-1]) +grid[i][j];\\n            }\\n        \\n        }   \\n        return dp[m-1][n-1];\\n    }\\n};"
                    }
                ]
            },
            {
                "id": 1810558,
                "content": [
                    {
                        "username": "Masterdemon123",
                        "content": "help guys , I having this code and leetcode keeps telling me that the output for case grid = [[1,2,3],[4,5,6]] is 11 meanwhile I have tested it in 2 different IDE using debug mode (visual studio and programiz) and the result is 12 \\n```\\nclass Solution:\\n    lastMinPath = {}\\n\\n    def insertResult(self, i: int, j: int, result):\\n        code = str(i) +  \" \" + str(j) \\n        self.lastMinPath[code] = result \\n\\n    def findMinPath(self, grid: list[list[int]], i: int, j: int) -> int:\\n        if i == 0 and j == 0 :\\n            return grid[i][j]\\n\\n        if i == 0 :\\n\\n            minPath = -1\\n\\n            code = str(i) + \" \" + str(j - 1)\\n            if code in self.lastMinPath:\\n                minPath = self.lastMinPath[code]\\n            else:\\n                minPath = self.findMinPath(grid,i,j - 1)\\n\\n            result = grid[i][j] + minPath\\n            self.insertResult(i,j,result)\\n            return result\\n\\n        if j == 0 :\\n            minPath = -1\\n\\n            code = str(i - 1) + \" \" + str(j)\\n            if code in self.lastMinPath:\\n                minPath = self.lastMinPath[code]\\n            else:\\n                minPath = self.findMinPath(grid,i-1,j) \\n\\n            result = grid[i][j] + minPath\\n            self.insertResult(i,j,result)\\n            return result\\n\\n\\n        minPath1 = -1\\n\\n        code = str(i) + \" \" + str(j - 1)\\n        if code in self.lastMinPath:\\n            minPath1 = self.lastMinPath[code]\\n        else:\\n            minPath1 = self.findMinPath(grid,i,j-1) \\n\\n        minPath2 = -1\\n        code = str(i - 1) + \" \" + str(j)\\n        if code in self.lastMinPath:\\n            minPath2 = self.lastMinPath[code]\\n        else:\\n            minPath2 = self.findMinPath(grid,i - 1,j) \\n\\n        result = grid[i][j] + min(minPath1,minPath2)\\n        self.insertResult(i,j,result)\\n        return result\\n\\n    def minPathSum(self, grid: List[List[int]]) -> int:\\n        code = \"0 0\"\\n        self.lastMinPath[code] = grid[0][0] \\n        return self.findMinPath(grid,len(grid) - 1,len(grid[0]) - 1)\\n```\\nI don\\'t know and can\\'t find the problem , can you tell me why ?\\n\\n"
                    },
                    {
                        "username": "alshine",
                        "content": "if you are experiencing problems, I advise you to solve [62. Unique Paths\n](https://leetcode.com/problems/unique-paths/)"
                    },
                    {
                        "username": "Ztilly",
                        "content": "This is a bad problem due to the fact that the maximized number possible will always use every tile. The example given is incorrect. The maxamized path would be 1 -> 3 -> 1 -> 1 -> 5 -> 1 -> 4 -> 2 -> 1, resulting in 19, not 7. \n\nstarting top left you move accross the board to the right, then once you reach the end you go down once, to the left, and back to the right once more. In the event there's an even amount of rows, it's still possible to touch every tile while only moving one space as a time in the left or right direction, and this will always be the case for any size square or rectangle."
                    },
                    {
                        "username": "AMerrill",
                        "content": "\"You can only move either down or right at any point in time.\" \\n\\nAlso, you want to minimize the the sum."
                    },
                    {
                        "username": "arumuga007",
                        "content": "what the correct output for [1,2], [1,1]?i get 4 but it expect 3??\\nAnyone explain me how??"
                    },
                    {
                        "username": "AMerrill",
                        "content": "take 1 -> 1 -> 1 or moving Down and then Right. Total sum is $$3$$.\n\n^This is the path with the minimum sum."
                    },
                    {
                        "username": "JiayingGao",
                        "content": "How to optimize my bfs code? It can AC but need run almost 1.7s  :<.\\n\\'\\'\\'\\nclass Solution {\\npublic:\\n    int minPathSum(vector<vector<int>>& grid) {\\n        \\n        int m = grid.size(), n = grid.front().size(), nd[2][2] = {{1, 0}, {0, 1}};\\n        vector<vector<int>> marked(m, vector<int>(n, INT_MAX)); marked[0][0] = grid[0][0];\\n        queue<tuple<int, int, int>> units;  units.push({0, 0, grid[0][0]});\\n        while(!units.empty()){\\n            auto [y, x, sum] = units.front();  units.pop();\\n            for (int k = 0; k < 2; k++){\\n                int ny = y + nd[k][0], nx = x + nd[k][1];\\n                if (ny >= m || nx >= n) continue;\\n                int update_sum = sum + grid[ny][nx];\\n                if (update_sum < marked[ny][nx]){\\n                    marked[ny][nx] = update_sum;\\n                    units.push({ny, nx, update_sum});\\n                }\\n            }\\n        }\\n        return marked[m - 1][n - 1];\\n    }\\n};\\n\\'\\'\\' "
                    },
                    {
                        "username": "alpharomeo99",
                        "content": "In case you're asked to find the path with minimum sum, you can just start from the source after creating the dp array. From source move greedily towards the the cell that has the minimum path sum to the destination and accordingly update the path. This will take O(N) time."
                    },
                    {
                        "username": "sanshoys",
                        "content": "grid =\\n[[1,2],[1,1]]\\nOutput\\n4\\nExpected\\n3 \\n\\nwhy is it 3?  1 + 2 + 1 = 4"
                    },
                    {
                        "username": "hoangnn451",
                        "content": "1 + 1 + 1 = 3\\nstart from (0,0), move down (1,0), move right (1,1)\\n(0,0) + (1,0) + (1,1) = 1 + 1 + 1 = 3 \\n\\nNote: You can only move either down or right at any point in time."
                    },
                    {
                        "username": "Sumit2828",
                        "content": "class Solution {\\npublic:\\n    int minPathSum(vector<vector<int>>& grid) {\\n        int m=grid.size();\\n        int n=grid[0].size();\\n\\n        int dp[m][n];\\n        dp[0][0]=grid[0][0];\\n        for(int i=1;i<m;i++){\\n            dp[0][i]+=dp[0][i-1];\\n        }\\n        for(int i=1;i<n;i++){\\n            dp[i][0]+=dp[i-1][0];\\n        }\\n        for(int i=1;i<m;i++){\\n            for(int j=1;j<n;j++){\\n                dp[i][j]+=min(dp[i-1][j],dp[i][j-1]);\\n            }\\n        }\\n        return dp[m-1][n-1];\\n        \\n    }\\n};\\n\\nThis code is giving the runtime error as dynamic-stack-buffer-overflow , can anyone give the fault in the code  corresponding to the given error, and the solution to the error."
                    },
                    {
                        "username": "Sumit2828",
                        "content": "[@manifold1985](/manifold1985) Thanks\\uD83D\\uDC4D"
                    },
                    {
                        "username": "manifold1985",
                        "content": "You used syntax such as \"dp[i][j]+=min(dp[i-1][j],dp[i][j-1])\", but your dp[i][j] hasn\\'t been assigned any value yet. I am afraid that\\'s the cause. Also, it seems like grid[i][j] hasn\\'t been incorporated into your code. You should modify your code accordingly."
                    },
                    {
                        "username": "PAIN_an_c",
                        "content": "why this code giving tle even i travelled m*n using recursion\\n\\nclass Solution {\\npublic:\\n    void reduce(vector<vector<int>>grid,vector<vector<int>>& box,int i,int j){\\n        if(i==grid.size())\\n            return ;\\n        else if(j==grid[0].size()){\\n           reduce(grid,box,i+1,0);\\n           return ;\\n        }\\n        if(i-1>=0 && j-1>=0){box[i][j]=grid[i][j]+min(box[i-1][j],box[i][j-1]);}\\n        else if(i-1>=0){box[i][j]=grid[i][j]+box[i-1][j];}\\n        else{box[i][j]=grid[i][j]+box[i][j-1];}\\n\\n        reduce(grid,box,i,j+1);\\n    }\\npublic:\\n\\n    int minPathSum(vector<vector<int>>& grid) {\\n        int m=grid.size(),n=grid[0].size();\\n        vector<vector<int>>box(m,vector<int>(n,-1)); \\n        box[0][0]=grid[0][0];\\n        reduce(grid,box,0,1);\\n        return box[m-1][n-1];   \\n    }\\n};"
                    },
                    {
                        "username": "JiayingGao",
                        "content": "Just remember to let the memorization works, add: if (box[y][x] != -1) return memory;"
                    },
                    {
                        "username": "SharmaAyush",
                        "content": "class Solution {\\npublic:\\n   \\n    int minPathSum(vector<vector<int>>&grid){\\n        int m=grid.size();\\n        int n = grid[0].size();\\n\\n        int** dp = new int*[m];\\n\\n        for(int i=0;i<m;i++){\\n            dp[i] = new int[n];\\n        }\\n\\n        dp[0][0] =grid[0][0];\\n\\n        for(int i=1;i<n;i++){\\n            dp[0][i] = dp[0][i-1]+grid[0][i];\\n        }\\n            for(int i=1;i<m;i++){\\n            dp[i][0] = dp[i-1][0]+grid[i][0];\\n        }\\n\\n        for(int i=1;i<m;i++){\\n            for(int j=1;j<n;j++){\\n                dp[i][j] = min(dp[i-1][j],dp[i][j-1]) +grid[i][j];\\n            }\\n        \\n        }   \\n        return dp[m-1][n-1];\\n    }\\n};"
                    }
                ]
            },
            {
                "id": 1795151,
                "content": [
                    {
                        "username": "chandrahansprakashsaha",
                        "content": "java solution\\nclass Solution {\\n    public int minPathSum(int[][] grid) {\\n        \\n      \\n       int m=grid.length;\\n       int n=grid[0].length;\\n        int x= fun(grid,m,n);\\n        return x;\\n        }\\n     public int fun(int grid[][],int m,int n){\\n        int dp[][]=new int[m][n];\\n        dp[0][0]=grid[0][0];\\n        \\n        for(int i=0;i<m;i++) {\\n            for(int j=0;j<n;j++) {\\n                if(i==0 && j==0) continue;\\n                if(i==0) {\\n                    dp[i][j] = dp[i][j-1] + grid[i][j];\\n                } else if(j==0) {\\n                    dp[i][j] = dp[i-1][j] + grid[i][j];\\n                } else {\\n                    dp[i][j] = Math.min(dp[i-1][j], dp[i][j-1]) + grid[i][j];\\n                }\\n            }\\n        }\\n        \\n        \\n       return dp[m-1][n-1];\\n        \\n    \\n    }\\n}"
                    },
                    {
                        "username": "mohamed_waseela",
                        "content": "https://youtu.be/-Qpk2XJ5XJQ"
                    },
                    {
                        "username": "teckyshubham",
                        "content": "class Solution {\\n    int dp[][];\\n    int helper(int [][]grid,int i,int j){\\n        if(i==0&&j==0){\\n            return grid[i][j];\\n        }\\n        if(i<0||j<0){\\n            return (int)Math.pow(10,9);\\n        }\\n        if(dp[i][j]!=-1){\\n            return dp[i][j];\\n        }\\n        int left=grid[i][j]+helper(grid,i,j-1);\\n        int top=grid[i][j]+helper(grid,i-1,j);\\n        return dp[i][j]=Math.min(left,top);\\n    }\\n    public int minPathSum(int[][] grid) {\\n        dp=new int[grid.length][grid[0].length];\\n        for(int []row:dp){\\n            Arrays.fill(row,-1);\\n        }\\n        return helper(grid,grid.length-1,grid[0].length-1);\\n    }\\n}class Solution {\\n    int dp[][];\\n    int helper(int [][]grid,int i,int j){\\n        if(i==0&&j==0){\\n            return grid[i][j];\\n        }\\n        if(i<0||j<0){\\n            return (int)Math.pow(10,9);\\n        }\\n        if(dp[i][j]!=-1){\\n            return dp[i][j];\\n        }\\n        int left=grid[i][j]+helper(grid,i,j-1);\\n        int top=grid[i][j]+helper(grid,i-1,j);\\n        return dp[i][j]=Math.min(left,top);\\n    }\\n    public int minPathSum(int[][] grid) {\\n        dp=new int[grid.length][grid[0].length];\\n        for(int []row:dp){\\n            Arrays.fill(row,-1);\\n        }\\n        return helper(grid,grid.length-1,grid[0].length-1);\\n    }\\n}"
                    },
                    {
                        "username": "shivanshnema_04",
                        "content": "why Dijekstra giving TLE in this question ?"
                    },
                    {
                        "username": "shubhamhazra",
                        "content": "no it\\'s working fine.  \\nhere is my code : \\nclass Solution {\\npublic:\\n    int minPathSum(vector<vector<int>>& grid) {\\n        int m = grid.size();\\n        int n = grid[0].size();\\n  \\n        priority_queue<pair<int,pair<int,int>>, vector<pair<int,pair<int,int>>>,greater<pair<int,pair<int,int>>>>pq; // dist , x , y\\n        pq.push({grid[0][0] , {0,0}});\\n        vector<vector<int>>dist(m,vector<int>(n,INT_MAX));\\n        dist[0][0] = grid[0][0];\\n\\n        while(!pq.empty()){\\n            auto top = pq.top();\\n            pq.pop();\\n            int d = top.first;\\n            int x = top.second.first;\\n            int y = top.second.second;\\n\\n            int delx[2] = {1,0};\\n            int dely[2] = {0,1};\\n\\n            for(int i=0;i<2;i++){\\n                \\n                int X = x + delx[i];\\n                int Y = y + dely[i];\\n\\n                if(X>=0 && Y>=0 && X<m && Y<n)\\n                {\\n                if(d + grid[X][Y] < dist[X][Y]){\\n                    dist[X][Y] = d + grid[X][Y];\\n                    pq.push({dist[X][Y],{X,Y}});\\n                }\\n                }\\n            }\\n\\n        }\\n        return dist[m-1][n-1];\\n        \\n    }\\n};"
                    },
                    {
                        "username": "FrankieHacks",
                        "content": "Can anyone help me understand why my solution is slow. I submitted this and it gave better than `5%`. Thanks.\n```\nclass Solution {\n    public int minPathSum(int[][] grid) {\n      int m = grid.length, n = grid[0].length;\n      int[][] dp = new int[m][n];\n      for (int r = 0; r < m; r++) {\n        for (int c = 0; c < n; c++) {\n          int min = Integer.MAX_VALUE;\n          if (r != 0) {\n            min = Math.min(min, dp[r-1][c]);\n          }\n          if (c != 0) {\n            min = Math.min(min, dp[r][c-1]);\n          }\n          dp[r][c] = grid[r][c] + (min != Integer.MAX_VALUE ? min : 0);\n        }\n      }\n      return dp[m-1][n-1];\n    }\n}\n```"
                    },
                    {
                        "username": "matheus-rodrigues00",
                        "content": "Why the solution using a queue gives TLE?"
                    },
                    {
                        "username": "Aastha_Goyal",
                        "content": "Anyone can help me, my solution give wrong ans but by implementing same approach in diff way giving me correct ans. Where this implementation is wrong?\\n```\\nclass Solution {\\n    int min = Integer.MAX_VALUE;\\n    boolean[][] vis;\\n    public int minPathSum(int[][] grid) {\\n         vis = new boolean[grid.length][grid[0].length];\\n        recur(0,0,grid,0);\\n       \\n        return min;\\n    }\\n\\n    public void recur(int i, int j, int[][] grid, int psf){\\n        if(i<0 || j<0 || i>=grid.length || j>=grid[0].length || vis[i][j]) return ;\\n        if(i == grid.length-1 && j==grid[0].length-1){\\n            min = Math.min(min,psf);\\n            // System.out.println(psf);\\n            return ;\\n        }\\n        vis[i][j] = true;\\n\\n        recur(i+1,j,grid,psf+grid[i][j]);\\n        recur(i,j+1,grid,psf+grid[i][j]);\\n\\n        vis[i][j] = false;\\n        psf-=grid[i][j];\\n    }\\n}\\n\\n```"
                    },
                    {
                        "username": "wodxuming",
                        "content": "```\\nclass Solution {\\npublic:\\n    int minPathSum(vector<vector<int>>& grid) {\\n        const int m = grid.size();\\n        const int n = grid[0].size();\\n        vector< vector<int> > dp(m, vector(n, 0));\\n\\n        //base case\\n        dp[0][0] = grid[0][0];\\n        for (int i = 1; i < m; i++) {\\n            dp[i][0] = dp[i - 1][0] + grid[i][0];\\n        }\\n    \\n        for (int j = 1; j < n; j++)\\n            dp[0][j] = dp[0][j - 1] + grid[0][j]; \\n\\n        for (int i = 1; i < m; i++) {\\n            for (int j = 1; j < n; j++) {\\n                dp[i][j] = min(\\n                    dp[i - 1][j],\\n                    dp[i][j - 1]\\n                ) + grid[i][j];\\n            }\\n        }\\n\\n        return dp[m - 1][n - 1];\\n    }\\n};\\n\\n```"
                    },
                    {
                        "username": "patelsatyam",
                        "content": " public int minPathSum(int[][] grid) {\n        int row=grid.length;\n        int col=grid[0].length;\n\n        int[][] dp=new int[row][col];\n\n        for(int i=row-1; i>=0; i--)\n        {\n            for(int j=col-1; j>=0; j--)\n            {\n                if(i==row-1 && j==col-1)\n                {\n                    dp[i][j]=grid[i][j];\n                }\n                else if(i==row-1)\n                {\n                    dp[i][j]=dp[i][j+1]+grid[i][j];\n                }\n                else if(j==col-1)\n                {\n                    dp[i][j]=dp[i+1][j]+grid[i][j];\n                }\n                else\n                {\n                    dp[i][j]=Math.min(dp[i][j+1],dp[i+1][j]) + grid[i][j];\n                }\n            }\n        }\n\n        return dp[0][0];\n        \n    }"
                    },
                    {
                        "username": "djkhanna835",
                        "content": "\\nRitik khanna || JAVA SOLUTION\\n\\nclass Solution {\\n\\n    public int MinPathSum (int [][] grid, int i, int j, int [][] dp){\\n        int N = grid.length;\\n        int M = grid[0].length; \\n        if(i == N-1 && j == M-1) return grid[i][j];\\n        if(i >= N || j >= M) return Integer.MAX_VALUE;\\n\\n        if(dp[i][j] != -1) return dp[i][j];\\n        return dp[i][j] = grid[i][j] + Math.min(MinPathSum(grid, i+1, j, dp), MinPathSum(grid, i, j+1, dp));\\n\\n    }\\n    public int minPathSum(int[][] grid) {\\n        \\n        int N = grid.length;\\n        int M = grid[0].length; \\n        int [][] dp = new int[N][M];\\n        for(int i=0; i<dp.length; i++){\\n            for(int j=0; j<dp[0].length; j++) dp[i][j] = -1;\\n        }\\n        return MinPathSum(grid, 0, 0, dp );\\n    }\\n}"
                    }
                ]
            },
            {
                "id": 1754116,
                "content": [
                    {
                        "username": "chandrahansprakashsaha",
                        "content": "java solution\\nclass Solution {\\n    public int minPathSum(int[][] grid) {\\n        \\n      \\n       int m=grid.length;\\n       int n=grid[0].length;\\n        int x= fun(grid,m,n);\\n        return x;\\n        }\\n     public int fun(int grid[][],int m,int n){\\n        int dp[][]=new int[m][n];\\n        dp[0][0]=grid[0][0];\\n        \\n        for(int i=0;i<m;i++) {\\n            for(int j=0;j<n;j++) {\\n                if(i==0 && j==0) continue;\\n                if(i==0) {\\n                    dp[i][j] = dp[i][j-1] + grid[i][j];\\n                } else if(j==0) {\\n                    dp[i][j] = dp[i-1][j] + grid[i][j];\\n                } else {\\n                    dp[i][j] = Math.min(dp[i-1][j], dp[i][j-1]) + grid[i][j];\\n                }\\n            }\\n        }\\n        \\n        \\n       return dp[m-1][n-1];\\n        \\n    \\n    }\\n}"
                    },
                    {
                        "username": "mohamed_waseela",
                        "content": "https://youtu.be/-Qpk2XJ5XJQ"
                    },
                    {
                        "username": "teckyshubham",
                        "content": "class Solution {\\n    int dp[][];\\n    int helper(int [][]grid,int i,int j){\\n        if(i==0&&j==0){\\n            return grid[i][j];\\n        }\\n        if(i<0||j<0){\\n            return (int)Math.pow(10,9);\\n        }\\n        if(dp[i][j]!=-1){\\n            return dp[i][j];\\n        }\\n        int left=grid[i][j]+helper(grid,i,j-1);\\n        int top=grid[i][j]+helper(grid,i-1,j);\\n        return dp[i][j]=Math.min(left,top);\\n    }\\n    public int minPathSum(int[][] grid) {\\n        dp=new int[grid.length][grid[0].length];\\n        for(int []row:dp){\\n            Arrays.fill(row,-1);\\n        }\\n        return helper(grid,grid.length-1,grid[0].length-1);\\n    }\\n}class Solution {\\n    int dp[][];\\n    int helper(int [][]grid,int i,int j){\\n        if(i==0&&j==0){\\n            return grid[i][j];\\n        }\\n        if(i<0||j<0){\\n            return (int)Math.pow(10,9);\\n        }\\n        if(dp[i][j]!=-1){\\n            return dp[i][j];\\n        }\\n        int left=grid[i][j]+helper(grid,i,j-1);\\n        int top=grid[i][j]+helper(grid,i-1,j);\\n        return dp[i][j]=Math.min(left,top);\\n    }\\n    public int minPathSum(int[][] grid) {\\n        dp=new int[grid.length][grid[0].length];\\n        for(int []row:dp){\\n            Arrays.fill(row,-1);\\n        }\\n        return helper(grid,grid.length-1,grid[0].length-1);\\n    }\\n}"
                    },
                    {
                        "username": "shivanshnema_04",
                        "content": "why Dijekstra giving TLE in this question ?"
                    },
                    {
                        "username": "shubhamhazra",
                        "content": "no it\\'s working fine.  \\nhere is my code : \\nclass Solution {\\npublic:\\n    int minPathSum(vector<vector<int>>& grid) {\\n        int m = grid.size();\\n        int n = grid[0].size();\\n  \\n        priority_queue<pair<int,pair<int,int>>, vector<pair<int,pair<int,int>>>,greater<pair<int,pair<int,int>>>>pq; // dist , x , y\\n        pq.push({grid[0][0] , {0,0}});\\n        vector<vector<int>>dist(m,vector<int>(n,INT_MAX));\\n        dist[0][0] = grid[0][0];\\n\\n        while(!pq.empty()){\\n            auto top = pq.top();\\n            pq.pop();\\n            int d = top.first;\\n            int x = top.second.first;\\n            int y = top.second.second;\\n\\n            int delx[2] = {1,0};\\n            int dely[2] = {0,1};\\n\\n            for(int i=0;i<2;i++){\\n                \\n                int X = x + delx[i];\\n                int Y = y + dely[i];\\n\\n                if(X>=0 && Y>=0 && X<m && Y<n)\\n                {\\n                if(d + grid[X][Y] < dist[X][Y]){\\n                    dist[X][Y] = d + grid[X][Y];\\n                    pq.push({dist[X][Y],{X,Y}});\\n                }\\n                }\\n            }\\n\\n        }\\n        return dist[m-1][n-1];\\n        \\n    }\\n};"
                    },
                    {
                        "username": "FrankieHacks",
                        "content": "Can anyone help me understand why my solution is slow. I submitted this and it gave better than `5%`. Thanks.\n```\nclass Solution {\n    public int minPathSum(int[][] grid) {\n      int m = grid.length, n = grid[0].length;\n      int[][] dp = new int[m][n];\n      for (int r = 0; r < m; r++) {\n        for (int c = 0; c < n; c++) {\n          int min = Integer.MAX_VALUE;\n          if (r != 0) {\n            min = Math.min(min, dp[r-1][c]);\n          }\n          if (c != 0) {\n            min = Math.min(min, dp[r][c-1]);\n          }\n          dp[r][c] = grid[r][c] + (min != Integer.MAX_VALUE ? min : 0);\n        }\n      }\n      return dp[m-1][n-1];\n    }\n}\n```"
                    },
                    {
                        "username": "matheus-rodrigues00",
                        "content": "Why the solution using a queue gives TLE?"
                    },
                    {
                        "username": "Aastha_Goyal",
                        "content": "Anyone can help me, my solution give wrong ans but by implementing same approach in diff way giving me correct ans. Where this implementation is wrong?\\n```\\nclass Solution {\\n    int min = Integer.MAX_VALUE;\\n    boolean[][] vis;\\n    public int minPathSum(int[][] grid) {\\n         vis = new boolean[grid.length][grid[0].length];\\n        recur(0,0,grid,0);\\n       \\n        return min;\\n    }\\n\\n    public void recur(int i, int j, int[][] grid, int psf){\\n        if(i<0 || j<0 || i>=grid.length || j>=grid[0].length || vis[i][j]) return ;\\n        if(i == grid.length-1 && j==grid[0].length-1){\\n            min = Math.min(min,psf);\\n            // System.out.println(psf);\\n            return ;\\n        }\\n        vis[i][j] = true;\\n\\n        recur(i+1,j,grid,psf+grid[i][j]);\\n        recur(i,j+1,grid,psf+grid[i][j]);\\n\\n        vis[i][j] = false;\\n        psf-=grid[i][j];\\n    }\\n}\\n\\n```"
                    },
                    {
                        "username": "wodxuming",
                        "content": "```\\nclass Solution {\\npublic:\\n    int minPathSum(vector<vector<int>>& grid) {\\n        const int m = grid.size();\\n        const int n = grid[0].size();\\n        vector< vector<int> > dp(m, vector(n, 0));\\n\\n        //base case\\n        dp[0][0] = grid[0][0];\\n        for (int i = 1; i < m; i++) {\\n            dp[i][0] = dp[i - 1][0] + grid[i][0];\\n        }\\n    \\n        for (int j = 1; j < n; j++)\\n            dp[0][j] = dp[0][j - 1] + grid[0][j]; \\n\\n        for (int i = 1; i < m; i++) {\\n            for (int j = 1; j < n; j++) {\\n                dp[i][j] = min(\\n                    dp[i - 1][j],\\n                    dp[i][j - 1]\\n                ) + grid[i][j];\\n            }\\n        }\\n\\n        return dp[m - 1][n - 1];\\n    }\\n};\\n\\n```"
                    },
                    {
                        "username": "patelsatyam",
                        "content": " public int minPathSum(int[][] grid) {\n        int row=grid.length;\n        int col=grid[0].length;\n\n        int[][] dp=new int[row][col];\n\n        for(int i=row-1; i>=0; i--)\n        {\n            for(int j=col-1; j>=0; j--)\n            {\n                if(i==row-1 && j==col-1)\n                {\n                    dp[i][j]=grid[i][j];\n                }\n                else if(i==row-1)\n                {\n                    dp[i][j]=dp[i][j+1]+grid[i][j];\n                }\n                else if(j==col-1)\n                {\n                    dp[i][j]=dp[i+1][j]+grid[i][j];\n                }\n                else\n                {\n                    dp[i][j]=Math.min(dp[i][j+1],dp[i+1][j]) + grid[i][j];\n                }\n            }\n        }\n\n        return dp[0][0];\n        \n    }"
                    },
                    {
                        "username": "djkhanna835",
                        "content": "\\nRitik khanna || JAVA SOLUTION\\n\\nclass Solution {\\n\\n    public int MinPathSum (int [][] grid, int i, int j, int [][] dp){\\n        int N = grid.length;\\n        int M = grid[0].length; \\n        if(i == N-1 && j == M-1) return grid[i][j];\\n        if(i >= N || j >= M) return Integer.MAX_VALUE;\\n\\n        if(dp[i][j] != -1) return dp[i][j];\\n        return dp[i][j] = grid[i][j] + Math.min(MinPathSum(grid, i+1, j, dp), MinPathSum(grid, i, j+1, dp));\\n\\n    }\\n    public int minPathSum(int[][] grid) {\\n        \\n        int N = grid.length;\\n        int M = grid[0].length; \\n        int [][] dp = new int[N][M];\\n        for(int i=0; i<dp.length; i++){\\n            for(int j=0; j<dp[0].length; j++) dp[i][j] = -1;\\n        }\\n        return MinPathSum(grid, 0, 0, dp );\\n    }\\n}"
                    }
                ]
            },
            {
                "id": 1740933,
                "content": [
                    {
                        "username": "chandrahansprakashsaha",
                        "content": "java solution\\nclass Solution {\\n    public int minPathSum(int[][] grid) {\\n        \\n      \\n       int m=grid.length;\\n       int n=grid[0].length;\\n        int x= fun(grid,m,n);\\n        return x;\\n        }\\n     public int fun(int grid[][],int m,int n){\\n        int dp[][]=new int[m][n];\\n        dp[0][0]=grid[0][0];\\n        \\n        for(int i=0;i<m;i++) {\\n            for(int j=0;j<n;j++) {\\n                if(i==0 && j==0) continue;\\n                if(i==0) {\\n                    dp[i][j] = dp[i][j-1] + grid[i][j];\\n                } else if(j==0) {\\n                    dp[i][j] = dp[i-1][j] + grid[i][j];\\n                } else {\\n                    dp[i][j] = Math.min(dp[i-1][j], dp[i][j-1]) + grid[i][j];\\n                }\\n            }\\n        }\\n        \\n        \\n       return dp[m-1][n-1];\\n        \\n    \\n    }\\n}"
                    },
                    {
                        "username": "mohamed_waseela",
                        "content": "https://youtu.be/-Qpk2XJ5XJQ"
                    },
                    {
                        "username": "teckyshubham",
                        "content": "class Solution {\\n    int dp[][];\\n    int helper(int [][]grid,int i,int j){\\n        if(i==0&&j==0){\\n            return grid[i][j];\\n        }\\n        if(i<0||j<0){\\n            return (int)Math.pow(10,9);\\n        }\\n        if(dp[i][j]!=-1){\\n            return dp[i][j];\\n        }\\n        int left=grid[i][j]+helper(grid,i,j-1);\\n        int top=grid[i][j]+helper(grid,i-1,j);\\n        return dp[i][j]=Math.min(left,top);\\n    }\\n    public int minPathSum(int[][] grid) {\\n        dp=new int[grid.length][grid[0].length];\\n        for(int []row:dp){\\n            Arrays.fill(row,-1);\\n        }\\n        return helper(grid,grid.length-1,grid[0].length-1);\\n    }\\n}class Solution {\\n    int dp[][];\\n    int helper(int [][]grid,int i,int j){\\n        if(i==0&&j==0){\\n            return grid[i][j];\\n        }\\n        if(i<0||j<0){\\n            return (int)Math.pow(10,9);\\n        }\\n        if(dp[i][j]!=-1){\\n            return dp[i][j];\\n        }\\n        int left=grid[i][j]+helper(grid,i,j-1);\\n        int top=grid[i][j]+helper(grid,i-1,j);\\n        return dp[i][j]=Math.min(left,top);\\n    }\\n    public int minPathSum(int[][] grid) {\\n        dp=new int[grid.length][grid[0].length];\\n        for(int []row:dp){\\n            Arrays.fill(row,-1);\\n        }\\n        return helper(grid,grid.length-1,grid[0].length-1);\\n    }\\n}"
                    },
                    {
                        "username": "shivanshnema_04",
                        "content": "why Dijekstra giving TLE in this question ?"
                    },
                    {
                        "username": "shubhamhazra",
                        "content": "no it\\'s working fine.  \\nhere is my code : \\nclass Solution {\\npublic:\\n    int minPathSum(vector<vector<int>>& grid) {\\n        int m = grid.size();\\n        int n = grid[0].size();\\n  \\n        priority_queue<pair<int,pair<int,int>>, vector<pair<int,pair<int,int>>>,greater<pair<int,pair<int,int>>>>pq; // dist , x , y\\n        pq.push({grid[0][0] , {0,0}});\\n        vector<vector<int>>dist(m,vector<int>(n,INT_MAX));\\n        dist[0][0] = grid[0][0];\\n\\n        while(!pq.empty()){\\n            auto top = pq.top();\\n            pq.pop();\\n            int d = top.first;\\n            int x = top.second.first;\\n            int y = top.second.second;\\n\\n            int delx[2] = {1,0};\\n            int dely[2] = {0,1};\\n\\n            for(int i=0;i<2;i++){\\n                \\n                int X = x + delx[i];\\n                int Y = y + dely[i];\\n\\n                if(X>=0 && Y>=0 && X<m && Y<n)\\n                {\\n                if(d + grid[X][Y] < dist[X][Y]){\\n                    dist[X][Y] = d + grid[X][Y];\\n                    pq.push({dist[X][Y],{X,Y}});\\n                }\\n                }\\n            }\\n\\n        }\\n        return dist[m-1][n-1];\\n        \\n    }\\n};"
                    },
                    {
                        "username": "FrankieHacks",
                        "content": "Can anyone help me understand why my solution is slow. I submitted this and it gave better than `5%`. Thanks.\n```\nclass Solution {\n    public int minPathSum(int[][] grid) {\n      int m = grid.length, n = grid[0].length;\n      int[][] dp = new int[m][n];\n      for (int r = 0; r < m; r++) {\n        for (int c = 0; c < n; c++) {\n          int min = Integer.MAX_VALUE;\n          if (r != 0) {\n            min = Math.min(min, dp[r-1][c]);\n          }\n          if (c != 0) {\n            min = Math.min(min, dp[r][c-1]);\n          }\n          dp[r][c] = grid[r][c] + (min != Integer.MAX_VALUE ? min : 0);\n        }\n      }\n      return dp[m-1][n-1];\n    }\n}\n```"
                    },
                    {
                        "username": "matheus-rodrigues00",
                        "content": "Why the solution using a queue gives TLE?"
                    },
                    {
                        "username": "Aastha_Goyal",
                        "content": "Anyone can help me, my solution give wrong ans but by implementing same approach in diff way giving me correct ans. Where this implementation is wrong?\\n```\\nclass Solution {\\n    int min = Integer.MAX_VALUE;\\n    boolean[][] vis;\\n    public int minPathSum(int[][] grid) {\\n         vis = new boolean[grid.length][grid[0].length];\\n        recur(0,0,grid,0);\\n       \\n        return min;\\n    }\\n\\n    public void recur(int i, int j, int[][] grid, int psf){\\n        if(i<0 || j<0 || i>=grid.length || j>=grid[0].length || vis[i][j]) return ;\\n        if(i == grid.length-1 && j==grid[0].length-1){\\n            min = Math.min(min,psf);\\n            // System.out.println(psf);\\n            return ;\\n        }\\n        vis[i][j] = true;\\n\\n        recur(i+1,j,grid,psf+grid[i][j]);\\n        recur(i,j+1,grid,psf+grid[i][j]);\\n\\n        vis[i][j] = false;\\n        psf-=grid[i][j];\\n    }\\n}\\n\\n```"
                    },
                    {
                        "username": "wodxuming",
                        "content": "```\\nclass Solution {\\npublic:\\n    int minPathSum(vector<vector<int>>& grid) {\\n        const int m = grid.size();\\n        const int n = grid[0].size();\\n        vector< vector<int> > dp(m, vector(n, 0));\\n\\n        //base case\\n        dp[0][0] = grid[0][0];\\n        for (int i = 1; i < m; i++) {\\n            dp[i][0] = dp[i - 1][0] + grid[i][0];\\n        }\\n    \\n        for (int j = 1; j < n; j++)\\n            dp[0][j] = dp[0][j - 1] + grid[0][j]; \\n\\n        for (int i = 1; i < m; i++) {\\n            for (int j = 1; j < n; j++) {\\n                dp[i][j] = min(\\n                    dp[i - 1][j],\\n                    dp[i][j - 1]\\n                ) + grid[i][j];\\n            }\\n        }\\n\\n        return dp[m - 1][n - 1];\\n    }\\n};\\n\\n```"
                    },
                    {
                        "username": "patelsatyam",
                        "content": " public int minPathSum(int[][] grid) {\n        int row=grid.length;\n        int col=grid[0].length;\n\n        int[][] dp=new int[row][col];\n\n        for(int i=row-1; i>=0; i--)\n        {\n            for(int j=col-1; j>=0; j--)\n            {\n                if(i==row-1 && j==col-1)\n                {\n                    dp[i][j]=grid[i][j];\n                }\n                else if(i==row-1)\n                {\n                    dp[i][j]=dp[i][j+1]+grid[i][j];\n                }\n                else if(j==col-1)\n                {\n                    dp[i][j]=dp[i+1][j]+grid[i][j];\n                }\n                else\n                {\n                    dp[i][j]=Math.min(dp[i][j+1],dp[i+1][j]) + grid[i][j];\n                }\n            }\n        }\n\n        return dp[0][0];\n        \n    }"
                    },
                    {
                        "username": "djkhanna835",
                        "content": "\\nRitik khanna || JAVA SOLUTION\\n\\nclass Solution {\\n\\n    public int MinPathSum (int [][] grid, int i, int j, int [][] dp){\\n        int N = grid.length;\\n        int M = grid[0].length; \\n        if(i == N-1 && j == M-1) return grid[i][j];\\n        if(i >= N || j >= M) return Integer.MAX_VALUE;\\n\\n        if(dp[i][j] != -1) return dp[i][j];\\n        return dp[i][j] = grid[i][j] + Math.min(MinPathSum(grid, i+1, j, dp), MinPathSum(grid, i, j+1, dp));\\n\\n    }\\n    public int minPathSum(int[][] grid) {\\n        \\n        int N = grid.length;\\n        int M = grid[0].length; \\n        int [][] dp = new int[N][M];\\n        for(int i=0; i<dp.length; i++){\\n            for(int j=0; j<dp[0].length; j++) dp[i][j] = -1;\\n        }\\n        return MinPathSum(grid, 0, 0, dp );\\n    }\\n}"
                    }
                ]
            },
            {
                "id": 1729388,
                "content": [
                    {
                        "username": "chandrahansprakashsaha",
                        "content": "java solution\\nclass Solution {\\n    public int minPathSum(int[][] grid) {\\n        \\n      \\n       int m=grid.length;\\n       int n=grid[0].length;\\n        int x= fun(grid,m,n);\\n        return x;\\n        }\\n     public int fun(int grid[][],int m,int n){\\n        int dp[][]=new int[m][n];\\n        dp[0][0]=grid[0][0];\\n        \\n        for(int i=0;i<m;i++) {\\n            for(int j=0;j<n;j++) {\\n                if(i==0 && j==0) continue;\\n                if(i==0) {\\n                    dp[i][j] = dp[i][j-1] + grid[i][j];\\n                } else if(j==0) {\\n                    dp[i][j] = dp[i-1][j] + grid[i][j];\\n                } else {\\n                    dp[i][j] = Math.min(dp[i-1][j], dp[i][j-1]) + grid[i][j];\\n                }\\n            }\\n        }\\n        \\n        \\n       return dp[m-1][n-1];\\n        \\n    \\n    }\\n}"
                    },
                    {
                        "username": "mohamed_waseela",
                        "content": "https://youtu.be/-Qpk2XJ5XJQ"
                    },
                    {
                        "username": "teckyshubham",
                        "content": "class Solution {\\n    int dp[][];\\n    int helper(int [][]grid,int i,int j){\\n        if(i==0&&j==0){\\n            return grid[i][j];\\n        }\\n        if(i<0||j<0){\\n            return (int)Math.pow(10,9);\\n        }\\n        if(dp[i][j]!=-1){\\n            return dp[i][j];\\n        }\\n        int left=grid[i][j]+helper(grid,i,j-1);\\n        int top=grid[i][j]+helper(grid,i-1,j);\\n        return dp[i][j]=Math.min(left,top);\\n    }\\n    public int minPathSum(int[][] grid) {\\n        dp=new int[grid.length][grid[0].length];\\n        for(int []row:dp){\\n            Arrays.fill(row,-1);\\n        }\\n        return helper(grid,grid.length-1,grid[0].length-1);\\n    }\\n}class Solution {\\n    int dp[][];\\n    int helper(int [][]grid,int i,int j){\\n        if(i==0&&j==0){\\n            return grid[i][j];\\n        }\\n        if(i<0||j<0){\\n            return (int)Math.pow(10,9);\\n        }\\n        if(dp[i][j]!=-1){\\n            return dp[i][j];\\n        }\\n        int left=grid[i][j]+helper(grid,i,j-1);\\n        int top=grid[i][j]+helper(grid,i-1,j);\\n        return dp[i][j]=Math.min(left,top);\\n    }\\n    public int minPathSum(int[][] grid) {\\n        dp=new int[grid.length][grid[0].length];\\n        for(int []row:dp){\\n            Arrays.fill(row,-1);\\n        }\\n        return helper(grid,grid.length-1,grid[0].length-1);\\n    }\\n}"
                    },
                    {
                        "username": "shivanshnema_04",
                        "content": "why Dijekstra giving TLE in this question ?"
                    },
                    {
                        "username": "shubhamhazra",
                        "content": "no it\\'s working fine.  \\nhere is my code : \\nclass Solution {\\npublic:\\n    int minPathSum(vector<vector<int>>& grid) {\\n        int m = grid.size();\\n        int n = grid[0].size();\\n  \\n        priority_queue<pair<int,pair<int,int>>, vector<pair<int,pair<int,int>>>,greater<pair<int,pair<int,int>>>>pq; // dist , x , y\\n        pq.push({grid[0][0] , {0,0}});\\n        vector<vector<int>>dist(m,vector<int>(n,INT_MAX));\\n        dist[0][0] = grid[0][0];\\n\\n        while(!pq.empty()){\\n            auto top = pq.top();\\n            pq.pop();\\n            int d = top.first;\\n            int x = top.second.first;\\n            int y = top.second.second;\\n\\n            int delx[2] = {1,0};\\n            int dely[2] = {0,1};\\n\\n            for(int i=0;i<2;i++){\\n                \\n                int X = x + delx[i];\\n                int Y = y + dely[i];\\n\\n                if(X>=0 && Y>=0 && X<m && Y<n)\\n                {\\n                if(d + grid[X][Y] < dist[X][Y]){\\n                    dist[X][Y] = d + grid[X][Y];\\n                    pq.push({dist[X][Y],{X,Y}});\\n                }\\n                }\\n            }\\n\\n        }\\n        return dist[m-1][n-1];\\n        \\n    }\\n};"
                    },
                    {
                        "username": "FrankieHacks",
                        "content": "Can anyone help me understand why my solution is slow. I submitted this and it gave better than `5%`. Thanks.\n```\nclass Solution {\n    public int minPathSum(int[][] grid) {\n      int m = grid.length, n = grid[0].length;\n      int[][] dp = new int[m][n];\n      for (int r = 0; r < m; r++) {\n        for (int c = 0; c < n; c++) {\n          int min = Integer.MAX_VALUE;\n          if (r != 0) {\n            min = Math.min(min, dp[r-1][c]);\n          }\n          if (c != 0) {\n            min = Math.min(min, dp[r][c-1]);\n          }\n          dp[r][c] = grid[r][c] + (min != Integer.MAX_VALUE ? min : 0);\n        }\n      }\n      return dp[m-1][n-1];\n    }\n}\n```"
                    },
                    {
                        "username": "matheus-rodrigues00",
                        "content": "Why the solution using a queue gives TLE?"
                    },
                    {
                        "username": "Aastha_Goyal",
                        "content": "Anyone can help me, my solution give wrong ans but by implementing same approach in diff way giving me correct ans. Where this implementation is wrong?\\n```\\nclass Solution {\\n    int min = Integer.MAX_VALUE;\\n    boolean[][] vis;\\n    public int minPathSum(int[][] grid) {\\n         vis = new boolean[grid.length][grid[0].length];\\n        recur(0,0,grid,0);\\n       \\n        return min;\\n    }\\n\\n    public void recur(int i, int j, int[][] grid, int psf){\\n        if(i<0 || j<0 || i>=grid.length || j>=grid[0].length || vis[i][j]) return ;\\n        if(i == grid.length-1 && j==grid[0].length-1){\\n            min = Math.min(min,psf);\\n            // System.out.println(psf);\\n            return ;\\n        }\\n        vis[i][j] = true;\\n\\n        recur(i+1,j,grid,psf+grid[i][j]);\\n        recur(i,j+1,grid,psf+grid[i][j]);\\n\\n        vis[i][j] = false;\\n        psf-=grid[i][j];\\n    }\\n}\\n\\n```"
                    },
                    {
                        "username": "wodxuming",
                        "content": "```\\nclass Solution {\\npublic:\\n    int minPathSum(vector<vector<int>>& grid) {\\n        const int m = grid.size();\\n        const int n = grid[0].size();\\n        vector< vector<int> > dp(m, vector(n, 0));\\n\\n        //base case\\n        dp[0][0] = grid[0][0];\\n        for (int i = 1; i < m; i++) {\\n            dp[i][0] = dp[i - 1][0] + grid[i][0];\\n        }\\n    \\n        for (int j = 1; j < n; j++)\\n            dp[0][j] = dp[0][j - 1] + grid[0][j]; \\n\\n        for (int i = 1; i < m; i++) {\\n            for (int j = 1; j < n; j++) {\\n                dp[i][j] = min(\\n                    dp[i - 1][j],\\n                    dp[i][j - 1]\\n                ) + grid[i][j];\\n            }\\n        }\\n\\n        return dp[m - 1][n - 1];\\n    }\\n};\\n\\n```"
                    },
                    {
                        "username": "patelsatyam",
                        "content": " public int minPathSum(int[][] grid) {\n        int row=grid.length;\n        int col=grid[0].length;\n\n        int[][] dp=new int[row][col];\n\n        for(int i=row-1; i>=0; i--)\n        {\n            for(int j=col-1; j>=0; j--)\n            {\n                if(i==row-1 && j==col-1)\n                {\n                    dp[i][j]=grid[i][j];\n                }\n                else if(i==row-1)\n                {\n                    dp[i][j]=dp[i][j+1]+grid[i][j];\n                }\n                else if(j==col-1)\n                {\n                    dp[i][j]=dp[i+1][j]+grid[i][j];\n                }\n                else\n                {\n                    dp[i][j]=Math.min(dp[i][j+1],dp[i+1][j]) + grid[i][j];\n                }\n            }\n        }\n\n        return dp[0][0];\n        \n    }"
                    },
                    {
                        "username": "djkhanna835",
                        "content": "\\nRitik khanna || JAVA SOLUTION\\n\\nclass Solution {\\n\\n    public int MinPathSum (int [][] grid, int i, int j, int [][] dp){\\n        int N = grid.length;\\n        int M = grid[0].length; \\n        if(i == N-1 && j == M-1) return grid[i][j];\\n        if(i >= N || j >= M) return Integer.MAX_VALUE;\\n\\n        if(dp[i][j] != -1) return dp[i][j];\\n        return dp[i][j] = grid[i][j] + Math.min(MinPathSum(grid, i+1, j, dp), MinPathSum(grid, i, j+1, dp));\\n\\n    }\\n    public int minPathSum(int[][] grid) {\\n        \\n        int N = grid.length;\\n        int M = grid[0].length; \\n        int [][] dp = new int[N][M];\\n        for(int i=0; i<dp.length; i++){\\n            for(int j=0; j<dp[0].length; j++) dp[i][j] = -1;\\n        }\\n        return MinPathSum(grid, 0, 0, dp );\\n    }\\n}"
                    }
                ]
            },
            {
                "id": 1722996,
                "content": [
                    {
                        "username": "chandrahansprakashsaha",
                        "content": "java solution\\nclass Solution {\\n    public int minPathSum(int[][] grid) {\\n        \\n      \\n       int m=grid.length;\\n       int n=grid[0].length;\\n        int x= fun(grid,m,n);\\n        return x;\\n        }\\n     public int fun(int grid[][],int m,int n){\\n        int dp[][]=new int[m][n];\\n        dp[0][0]=grid[0][0];\\n        \\n        for(int i=0;i<m;i++) {\\n            for(int j=0;j<n;j++) {\\n                if(i==0 && j==0) continue;\\n                if(i==0) {\\n                    dp[i][j] = dp[i][j-1] + grid[i][j];\\n                } else if(j==0) {\\n                    dp[i][j] = dp[i-1][j] + grid[i][j];\\n                } else {\\n                    dp[i][j] = Math.min(dp[i-1][j], dp[i][j-1]) + grid[i][j];\\n                }\\n            }\\n        }\\n        \\n        \\n       return dp[m-1][n-1];\\n        \\n    \\n    }\\n}"
                    },
                    {
                        "username": "mohamed_waseela",
                        "content": "https://youtu.be/-Qpk2XJ5XJQ"
                    },
                    {
                        "username": "teckyshubham",
                        "content": "class Solution {\\n    int dp[][];\\n    int helper(int [][]grid,int i,int j){\\n        if(i==0&&j==0){\\n            return grid[i][j];\\n        }\\n        if(i<0||j<0){\\n            return (int)Math.pow(10,9);\\n        }\\n        if(dp[i][j]!=-1){\\n            return dp[i][j];\\n        }\\n        int left=grid[i][j]+helper(grid,i,j-1);\\n        int top=grid[i][j]+helper(grid,i-1,j);\\n        return dp[i][j]=Math.min(left,top);\\n    }\\n    public int minPathSum(int[][] grid) {\\n        dp=new int[grid.length][grid[0].length];\\n        for(int []row:dp){\\n            Arrays.fill(row,-1);\\n        }\\n        return helper(grid,grid.length-1,grid[0].length-1);\\n    }\\n}class Solution {\\n    int dp[][];\\n    int helper(int [][]grid,int i,int j){\\n        if(i==0&&j==0){\\n            return grid[i][j];\\n        }\\n        if(i<0||j<0){\\n            return (int)Math.pow(10,9);\\n        }\\n        if(dp[i][j]!=-1){\\n            return dp[i][j];\\n        }\\n        int left=grid[i][j]+helper(grid,i,j-1);\\n        int top=grid[i][j]+helper(grid,i-1,j);\\n        return dp[i][j]=Math.min(left,top);\\n    }\\n    public int minPathSum(int[][] grid) {\\n        dp=new int[grid.length][grid[0].length];\\n        for(int []row:dp){\\n            Arrays.fill(row,-1);\\n        }\\n        return helper(grid,grid.length-1,grid[0].length-1);\\n    }\\n}"
                    },
                    {
                        "username": "shivanshnema_04",
                        "content": "why Dijekstra giving TLE in this question ?"
                    },
                    {
                        "username": "shubhamhazra",
                        "content": "no it\\'s working fine.  \\nhere is my code : \\nclass Solution {\\npublic:\\n    int minPathSum(vector<vector<int>>& grid) {\\n        int m = grid.size();\\n        int n = grid[0].size();\\n  \\n        priority_queue<pair<int,pair<int,int>>, vector<pair<int,pair<int,int>>>,greater<pair<int,pair<int,int>>>>pq; // dist , x , y\\n        pq.push({grid[0][0] , {0,0}});\\n        vector<vector<int>>dist(m,vector<int>(n,INT_MAX));\\n        dist[0][0] = grid[0][0];\\n\\n        while(!pq.empty()){\\n            auto top = pq.top();\\n            pq.pop();\\n            int d = top.first;\\n            int x = top.second.first;\\n            int y = top.second.second;\\n\\n            int delx[2] = {1,0};\\n            int dely[2] = {0,1};\\n\\n            for(int i=0;i<2;i++){\\n                \\n                int X = x + delx[i];\\n                int Y = y + dely[i];\\n\\n                if(X>=0 && Y>=0 && X<m && Y<n)\\n                {\\n                if(d + grid[X][Y] < dist[X][Y]){\\n                    dist[X][Y] = d + grid[X][Y];\\n                    pq.push({dist[X][Y],{X,Y}});\\n                }\\n                }\\n            }\\n\\n        }\\n        return dist[m-1][n-1];\\n        \\n    }\\n};"
                    },
                    {
                        "username": "FrankieHacks",
                        "content": "Can anyone help me understand why my solution is slow. I submitted this and it gave better than `5%`. Thanks.\n```\nclass Solution {\n    public int minPathSum(int[][] grid) {\n      int m = grid.length, n = grid[0].length;\n      int[][] dp = new int[m][n];\n      for (int r = 0; r < m; r++) {\n        for (int c = 0; c < n; c++) {\n          int min = Integer.MAX_VALUE;\n          if (r != 0) {\n            min = Math.min(min, dp[r-1][c]);\n          }\n          if (c != 0) {\n            min = Math.min(min, dp[r][c-1]);\n          }\n          dp[r][c] = grid[r][c] + (min != Integer.MAX_VALUE ? min : 0);\n        }\n      }\n      return dp[m-1][n-1];\n    }\n}\n```"
                    },
                    {
                        "username": "matheus-rodrigues00",
                        "content": "Why the solution using a queue gives TLE?"
                    },
                    {
                        "username": "Aastha_Goyal",
                        "content": "Anyone can help me, my solution give wrong ans but by implementing same approach in diff way giving me correct ans. Where this implementation is wrong?\\n```\\nclass Solution {\\n    int min = Integer.MAX_VALUE;\\n    boolean[][] vis;\\n    public int minPathSum(int[][] grid) {\\n         vis = new boolean[grid.length][grid[0].length];\\n        recur(0,0,grid,0);\\n       \\n        return min;\\n    }\\n\\n    public void recur(int i, int j, int[][] grid, int psf){\\n        if(i<0 || j<0 || i>=grid.length || j>=grid[0].length || vis[i][j]) return ;\\n        if(i == grid.length-1 && j==grid[0].length-1){\\n            min = Math.min(min,psf);\\n            // System.out.println(psf);\\n            return ;\\n        }\\n        vis[i][j] = true;\\n\\n        recur(i+1,j,grid,psf+grid[i][j]);\\n        recur(i,j+1,grid,psf+grid[i][j]);\\n\\n        vis[i][j] = false;\\n        psf-=grid[i][j];\\n    }\\n}\\n\\n```"
                    },
                    {
                        "username": "wodxuming",
                        "content": "```\\nclass Solution {\\npublic:\\n    int minPathSum(vector<vector<int>>& grid) {\\n        const int m = grid.size();\\n        const int n = grid[0].size();\\n        vector< vector<int> > dp(m, vector(n, 0));\\n\\n        //base case\\n        dp[0][0] = grid[0][0];\\n        for (int i = 1; i < m; i++) {\\n            dp[i][0] = dp[i - 1][0] + grid[i][0];\\n        }\\n    \\n        for (int j = 1; j < n; j++)\\n            dp[0][j] = dp[0][j - 1] + grid[0][j]; \\n\\n        for (int i = 1; i < m; i++) {\\n            for (int j = 1; j < n; j++) {\\n                dp[i][j] = min(\\n                    dp[i - 1][j],\\n                    dp[i][j - 1]\\n                ) + grid[i][j];\\n            }\\n        }\\n\\n        return dp[m - 1][n - 1];\\n    }\\n};\\n\\n```"
                    },
                    {
                        "username": "patelsatyam",
                        "content": " public int minPathSum(int[][] grid) {\n        int row=grid.length;\n        int col=grid[0].length;\n\n        int[][] dp=new int[row][col];\n\n        for(int i=row-1; i>=0; i--)\n        {\n            for(int j=col-1; j>=0; j--)\n            {\n                if(i==row-1 && j==col-1)\n                {\n                    dp[i][j]=grid[i][j];\n                }\n                else if(i==row-1)\n                {\n                    dp[i][j]=dp[i][j+1]+grid[i][j];\n                }\n                else if(j==col-1)\n                {\n                    dp[i][j]=dp[i+1][j]+grid[i][j];\n                }\n                else\n                {\n                    dp[i][j]=Math.min(dp[i][j+1],dp[i+1][j]) + grid[i][j];\n                }\n            }\n        }\n\n        return dp[0][0];\n        \n    }"
                    },
                    {
                        "username": "djkhanna835",
                        "content": "\\nRitik khanna || JAVA SOLUTION\\n\\nclass Solution {\\n\\n    public int MinPathSum (int [][] grid, int i, int j, int [][] dp){\\n        int N = grid.length;\\n        int M = grid[0].length; \\n        if(i == N-1 && j == M-1) return grid[i][j];\\n        if(i >= N || j >= M) return Integer.MAX_VALUE;\\n\\n        if(dp[i][j] != -1) return dp[i][j];\\n        return dp[i][j] = grid[i][j] + Math.min(MinPathSum(grid, i+1, j, dp), MinPathSum(grid, i, j+1, dp));\\n\\n    }\\n    public int minPathSum(int[][] grid) {\\n        \\n        int N = grid.length;\\n        int M = grid[0].length; \\n        int [][] dp = new int[N][M];\\n        for(int i=0; i<dp.length; i++){\\n            for(int j=0; j<dp[0].length; j++) dp[i][j] = -1;\\n        }\\n        return MinPathSum(grid, 0, 0, dp );\\n    }\\n}"
                    }
                ]
            },
            {
                "id": 1718321,
                "content": [
                    {
                        "username": "chandrahansprakashsaha",
                        "content": "java solution\\nclass Solution {\\n    public int minPathSum(int[][] grid) {\\n        \\n      \\n       int m=grid.length;\\n       int n=grid[0].length;\\n        int x= fun(grid,m,n);\\n        return x;\\n        }\\n     public int fun(int grid[][],int m,int n){\\n        int dp[][]=new int[m][n];\\n        dp[0][0]=grid[0][0];\\n        \\n        for(int i=0;i<m;i++) {\\n            for(int j=0;j<n;j++) {\\n                if(i==0 && j==0) continue;\\n                if(i==0) {\\n                    dp[i][j] = dp[i][j-1] + grid[i][j];\\n                } else if(j==0) {\\n                    dp[i][j] = dp[i-1][j] + grid[i][j];\\n                } else {\\n                    dp[i][j] = Math.min(dp[i-1][j], dp[i][j-1]) + grid[i][j];\\n                }\\n            }\\n        }\\n        \\n        \\n       return dp[m-1][n-1];\\n        \\n    \\n    }\\n}"
                    },
                    {
                        "username": "mohamed_waseela",
                        "content": "https://youtu.be/-Qpk2XJ5XJQ"
                    },
                    {
                        "username": "teckyshubham",
                        "content": "class Solution {\\n    int dp[][];\\n    int helper(int [][]grid,int i,int j){\\n        if(i==0&&j==0){\\n            return grid[i][j];\\n        }\\n        if(i<0||j<0){\\n            return (int)Math.pow(10,9);\\n        }\\n        if(dp[i][j]!=-1){\\n            return dp[i][j];\\n        }\\n        int left=grid[i][j]+helper(grid,i,j-1);\\n        int top=grid[i][j]+helper(grid,i-1,j);\\n        return dp[i][j]=Math.min(left,top);\\n    }\\n    public int minPathSum(int[][] grid) {\\n        dp=new int[grid.length][grid[0].length];\\n        for(int []row:dp){\\n            Arrays.fill(row,-1);\\n        }\\n        return helper(grid,grid.length-1,grid[0].length-1);\\n    }\\n}class Solution {\\n    int dp[][];\\n    int helper(int [][]grid,int i,int j){\\n        if(i==0&&j==0){\\n            return grid[i][j];\\n        }\\n        if(i<0||j<0){\\n            return (int)Math.pow(10,9);\\n        }\\n        if(dp[i][j]!=-1){\\n            return dp[i][j];\\n        }\\n        int left=grid[i][j]+helper(grid,i,j-1);\\n        int top=grid[i][j]+helper(grid,i-1,j);\\n        return dp[i][j]=Math.min(left,top);\\n    }\\n    public int minPathSum(int[][] grid) {\\n        dp=new int[grid.length][grid[0].length];\\n        for(int []row:dp){\\n            Arrays.fill(row,-1);\\n        }\\n        return helper(grid,grid.length-1,grid[0].length-1);\\n    }\\n}"
                    },
                    {
                        "username": "shivanshnema_04",
                        "content": "why Dijekstra giving TLE in this question ?"
                    },
                    {
                        "username": "shubhamhazra",
                        "content": "no it\\'s working fine.  \\nhere is my code : \\nclass Solution {\\npublic:\\n    int minPathSum(vector<vector<int>>& grid) {\\n        int m = grid.size();\\n        int n = grid[0].size();\\n  \\n        priority_queue<pair<int,pair<int,int>>, vector<pair<int,pair<int,int>>>,greater<pair<int,pair<int,int>>>>pq; // dist , x , y\\n        pq.push({grid[0][0] , {0,0}});\\n        vector<vector<int>>dist(m,vector<int>(n,INT_MAX));\\n        dist[0][0] = grid[0][0];\\n\\n        while(!pq.empty()){\\n            auto top = pq.top();\\n            pq.pop();\\n            int d = top.first;\\n            int x = top.second.first;\\n            int y = top.second.second;\\n\\n            int delx[2] = {1,0};\\n            int dely[2] = {0,1};\\n\\n            for(int i=0;i<2;i++){\\n                \\n                int X = x + delx[i];\\n                int Y = y + dely[i];\\n\\n                if(X>=0 && Y>=0 && X<m && Y<n)\\n                {\\n                if(d + grid[X][Y] < dist[X][Y]){\\n                    dist[X][Y] = d + grid[X][Y];\\n                    pq.push({dist[X][Y],{X,Y}});\\n                }\\n                }\\n            }\\n\\n        }\\n        return dist[m-1][n-1];\\n        \\n    }\\n};"
                    },
                    {
                        "username": "FrankieHacks",
                        "content": "Can anyone help me understand why my solution is slow. I submitted this and it gave better than `5%`. Thanks.\n```\nclass Solution {\n    public int minPathSum(int[][] grid) {\n      int m = grid.length, n = grid[0].length;\n      int[][] dp = new int[m][n];\n      for (int r = 0; r < m; r++) {\n        for (int c = 0; c < n; c++) {\n          int min = Integer.MAX_VALUE;\n          if (r != 0) {\n            min = Math.min(min, dp[r-1][c]);\n          }\n          if (c != 0) {\n            min = Math.min(min, dp[r][c-1]);\n          }\n          dp[r][c] = grid[r][c] + (min != Integer.MAX_VALUE ? min : 0);\n        }\n      }\n      return dp[m-1][n-1];\n    }\n}\n```"
                    },
                    {
                        "username": "matheus-rodrigues00",
                        "content": "Why the solution using a queue gives TLE?"
                    },
                    {
                        "username": "Aastha_Goyal",
                        "content": "Anyone can help me, my solution give wrong ans but by implementing same approach in diff way giving me correct ans. Where this implementation is wrong?\\n```\\nclass Solution {\\n    int min = Integer.MAX_VALUE;\\n    boolean[][] vis;\\n    public int minPathSum(int[][] grid) {\\n         vis = new boolean[grid.length][grid[0].length];\\n        recur(0,0,grid,0);\\n       \\n        return min;\\n    }\\n\\n    public void recur(int i, int j, int[][] grid, int psf){\\n        if(i<0 || j<0 || i>=grid.length || j>=grid[0].length || vis[i][j]) return ;\\n        if(i == grid.length-1 && j==grid[0].length-1){\\n            min = Math.min(min,psf);\\n            // System.out.println(psf);\\n            return ;\\n        }\\n        vis[i][j] = true;\\n\\n        recur(i+1,j,grid,psf+grid[i][j]);\\n        recur(i,j+1,grid,psf+grid[i][j]);\\n\\n        vis[i][j] = false;\\n        psf-=grid[i][j];\\n    }\\n}\\n\\n```"
                    },
                    {
                        "username": "wodxuming",
                        "content": "```\\nclass Solution {\\npublic:\\n    int minPathSum(vector<vector<int>>& grid) {\\n        const int m = grid.size();\\n        const int n = grid[0].size();\\n        vector< vector<int> > dp(m, vector(n, 0));\\n\\n        //base case\\n        dp[0][0] = grid[0][0];\\n        for (int i = 1; i < m; i++) {\\n            dp[i][0] = dp[i - 1][0] + grid[i][0];\\n        }\\n    \\n        for (int j = 1; j < n; j++)\\n            dp[0][j] = dp[0][j - 1] + grid[0][j]; \\n\\n        for (int i = 1; i < m; i++) {\\n            for (int j = 1; j < n; j++) {\\n                dp[i][j] = min(\\n                    dp[i - 1][j],\\n                    dp[i][j - 1]\\n                ) + grid[i][j];\\n            }\\n        }\\n\\n        return dp[m - 1][n - 1];\\n    }\\n};\\n\\n```"
                    },
                    {
                        "username": "patelsatyam",
                        "content": " public int minPathSum(int[][] grid) {\n        int row=grid.length;\n        int col=grid[0].length;\n\n        int[][] dp=new int[row][col];\n\n        for(int i=row-1; i>=0; i--)\n        {\n            for(int j=col-1; j>=0; j--)\n            {\n                if(i==row-1 && j==col-1)\n                {\n                    dp[i][j]=grid[i][j];\n                }\n                else if(i==row-1)\n                {\n                    dp[i][j]=dp[i][j+1]+grid[i][j];\n                }\n                else if(j==col-1)\n                {\n                    dp[i][j]=dp[i+1][j]+grid[i][j];\n                }\n                else\n                {\n                    dp[i][j]=Math.min(dp[i][j+1],dp[i+1][j]) + grid[i][j];\n                }\n            }\n        }\n\n        return dp[0][0];\n        \n    }"
                    },
                    {
                        "username": "djkhanna835",
                        "content": "\\nRitik khanna || JAVA SOLUTION\\n\\nclass Solution {\\n\\n    public int MinPathSum (int [][] grid, int i, int j, int [][] dp){\\n        int N = grid.length;\\n        int M = grid[0].length; \\n        if(i == N-1 && j == M-1) return grid[i][j];\\n        if(i >= N || j >= M) return Integer.MAX_VALUE;\\n\\n        if(dp[i][j] != -1) return dp[i][j];\\n        return dp[i][j] = grid[i][j] + Math.min(MinPathSum(grid, i+1, j, dp), MinPathSum(grid, i, j+1, dp));\\n\\n    }\\n    public int minPathSum(int[][] grid) {\\n        \\n        int N = grid.length;\\n        int M = grid[0].length; \\n        int [][] dp = new int[N][M];\\n        for(int i=0; i<dp.length; i++){\\n            for(int j=0; j<dp[0].length; j++) dp[i][j] = -1;\\n        }\\n        return MinPathSum(grid, 0, 0, dp );\\n    }\\n}"
                    }
                ]
            },
            {
                "id": 1713015,
                "content": [
                    {
                        "username": "chandrahansprakashsaha",
                        "content": "java solution\\nclass Solution {\\n    public int minPathSum(int[][] grid) {\\n        \\n      \\n       int m=grid.length;\\n       int n=grid[0].length;\\n        int x= fun(grid,m,n);\\n        return x;\\n        }\\n     public int fun(int grid[][],int m,int n){\\n        int dp[][]=new int[m][n];\\n        dp[0][0]=grid[0][0];\\n        \\n        for(int i=0;i<m;i++) {\\n            for(int j=0;j<n;j++) {\\n                if(i==0 && j==0) continue;\\n                if(i==0) {\\n                    dp[i][j] = dp[i][j-1] + grid[i][j];\\n                } else if(j==0) {\\n                    dp[i][j] = dp[i-1][j] + grid[i][j];\\n                } else {\\n                    dp[i][j] = Math.min(dp[i-1][j], dp[i][j-1]) + grid[i][j];\\n                }\\n            }\\n        }\\n        \\n        \\n       return dp[m-1][n-1];\\n        \\n    \\n    }\\n}"
                    },
                    {
                        "username": "mohamed_waseela",
                        "content": "https://youtu.be/-Qpk2XJ5XJQ"
                    },
                    {
                        "username": "teckyshubham",
                        "content": "class Solution {\\n    int dp[][];\\n    int helper(int [][]grid,int i,int j){\\n        if(i==0&&j==0){\\n            return grid[i][j];\\n        }\\n        if(i<0||j<0){\\n            return (int)Math.pow(10,9);\\n        }\\n        if(dp[i][j]!=-1){\\n            return dp[i][j];\\n        }\\n        int left=grid[i][j]+helper(grid,i,j-1);\\n        int top=grid[i][j]+helper(grid,i-1,j);\\n        return dp[i][j]=Math.min(left,top);\\n    }\\n    public int minPathSum(int[][] grid) {\\n        dp=new int[grid.length][grid[0].length];\\n        for(int []row:dp){\\n            Arrays.fill(row,-1);\\n        }\\n        return helper(grid,grid.length-1,grid[0].length-1);\\n    }\\n}class Solution {\\n    int dp[][];\\n    int helper(int [][]grid,int i,int j){\\n        if(i==0&&j==0){\\n            return grid[i][j];\\n        }\\n        if(i<0||j<0){\\n            return (int)Math.pow(10,9);\\n        }\\n        if(dp[i][j]!=-1){\\n            return dp[i][j];\\n        }\\n        int left=grid[i][j]+helper(grid,i,j-1);\\n        int top=grid[i][j]+helper(grid,i-1,j);\\n        return dp[i][j]=Math.min(left,top);\\n    }\\n    public int minPathSum(int[][] grid) {\\n        dp=new int[grid.length][grid[0].length];\\n        for(int []row:dp){\\n            Arrays.fill(row,-1);\\n        }\\n        return helper(grid,grid.length-1,grid[0].length-1);\\n    }\\n}"
                    },
                    {
                        "username": "shivanshnema_04",
                        "content": "why Dijekstra giving TLE in this question ?"
                    },
                    {
                        "username": "shubhamhazra",
                        "content": "no it\\'s working fine.  \\nhere is my code : \\nclass Solution {\\npublic:\\n    int minPathSum(vector<vector<int>>& grid) {\\n        int m = grid.size();\\n        int n = grid[0].size();\\n  \\n        priority_queue<pair<int,pair<int,int>>, vector<pair<int,pair<int,int>>>,greater<pair<int,pair<int,int>>>>pq; // dist , x , y\\n        pq.push({grid[0][0] , {0,0}});\\n        vector<vector<int>>dist(m,vector<int>(n,INT_MAX));\\n        dist[0][0] = grid[0][0];\\n\\n        while(!pq.empty()){\\n            auto top = pq.top();\\n            pq.pop();\\n            int d = top.first;\\n            int x = top.second.first;\\n            int y = top.second.second;\\n\\n            int delx[2] = {1,0};\\n            int dely[2] = {0,1};\\n\\n            for(int i=0;i<2;i++){\\n                \\n                int X = x + delx[i];\\n                int Y = y + dely[i];\\n\\n                if(X>=0 && Y>=0 && X<m && Y<n)\\n                {\\n                if(d + grid[X][Y] < dist[X][Y]){\\n                    dist[X][Y] = d + grid[X][Y];\\n                    pq.push({dist[X][Y],{X,Y}});\\n                }\\n                }\\n            }\\n\\n        }\\n        return dist[m-1][n-1];\\n        \\n    }\\n};"
                    },
                    {
                        "username": "FrankieHacks",
                        "content": "Can anyone help me understand why my solution is slow. I submitted this and it gave better than `5%`. Thanks.\n```\nclass Solution {\n    public int minPathSum(int[][] grid) {\n      int m = grid.length, n = grid[0].length;\n      int[][] dp = new int[m][n];\n      for (int r = 0; r < m; r++) {\n        for (int c = 0; c < n; c++) {\n          int min = Integer.MAX_VALUE;\n          if (r != 0) {\n            min = Math.min(min, dp[r-1][c]);\n          }\n          if (c != 0) {\n            min = Math.min(min, dp[r][c-1]);\n          }\n          dp[r][c] = grid[r][c] + (min != Integer.MAX_VALUE ? min : 0);\n        }\n      }\n      return dp[m-1][n-1];\n    }\n}\n```"
                    },
                    {
                        "username": "matheus-rodrigues00",
                        "content": "Why the solution using a queue gives TLE?"
                    },
                    {
                        "username": "Aastha_Goyal",
                        "content": "Anyone can help me, my solution give wrong ans but by implementing same approach in diff way giving me correct ans. Where this implementation is wrong?\\n```\\nclass Solution {\\n    int min = Integer.MAX_VALUE;\\n    boolean[][] vis;\\n    public int minPathSum(int[][] grid) {\\n         vis = new boolean[grid.length][grid[0].length];\\n        recur(0,0,grid,0);\\n       \\n        return min;\\n    }\\n\\n    public void recur(int i, int j, int[][] grid, int psf){\\n        if(i<0 || j<0 || i>=grid.length || j>=grid[0].length || vis[i][j]) return ;\\n        if(i == grid.length-1 && j==grid[0].length-1){\\n            min = Math.min(min,psf);\\n            // System.out.println(psf);\\n            return ;\\n        }\\n        vis[i][j] = true;\\n\\n        recur(i+1,j,grid,psf+grid[i][j]);\\n        recur(i,j+1,grid,psf+grid[i][j]);\\n\\n        vis[i][j] = false;\\n        psf-=grid[i][j];\\n    }\\n}\\n\\n```"
                    },
                    {
                        "username": "wodxuming",
                        "content": "```\\nclass Solution {\\npublic:\\n    int minPathSum(vector<vector<int>>& grid) {\\n        const int m = grid.size();\\n        const int n = grid[0].size();\\n        vector< vector<int> > dp(m, vector(n, 0));\\n\\n        //base case\\n        dp[0][0] = grid[0][0];\\n        for (int i = 1; i < m; i++) {\\n            dp[i][0] = dp[i - 1][0] + grid[i][0];\\n        }\\n    \\n        for (int j = 1; j < n; j++)\\n            dp[0][j] = dp[0][j - 1] + grid[0][j]; \\n\\n        for (int i = 1; i < m; i++) {\\n            for (int j = 1; j < n; j++) {\\n                dp[i][j] = min(\\n                    dp[i - 1][j],\\n                    dp[i][j - 1]\\n                ) + grid[i][j];\\n            }\\n        }\\n\\n        return dp[m - 1][n - 1];\\n    }\\n};\\n\\n```"
                    },
                    {
                        "username": "patelsatyam",
                        "content": " public int minPathSum(int[][] grid) {\n        int row=grid.length;\n        int col=grid[0].length;\n\n        int[][] dp=new int[row][col];\n\n        for(int i=row-1; i>=0; i--)\n        {\n            for(int j=col-1; j>=0; j--)\n            {\n                if(i==row-1 && j==col-1)\n                {\n                    dp[i][j]=grid[i][j];\n                }\n                else if(i==row-1)\n                {\n                    dp[i][j]=dp[i][j+1]+grid[i][j];\n                }\n                else if(j==col-1)\n                {\n                    dp[i][j]=dp[i+1][j]+grid[i][j];\n                }\n                else\n                {\n                    dp[i][j]=Math.min(dp[i][j+1],dp[i+1][j]) + grid[i][j];\n                }\n            }\n        }\n\n        return dp[0][0];\n        \n    }"
                    },
                    {
                        "username": "djkhanna835",
                        "content": "\\nRitik khanna || JAVA SOLUTION\\n\\nclass Solution {\\n\\n    public int MinPathSum (int [][] grid, int i, int j, int [][] dp){\\n        int N = grid.length;\\n        int M = grid[0].length; \\n        if(i == N-1 && j == M-1) return grid[i][j];\\n        if(i >= N || j >= M) return Integer.MAX_VALUE;\\n\\n        if(dp[i][j] != -1) return dp[i][j];\\n        return dp[i][j] = grid[i][j] + Math.min(MinPathSum(grid, i+1, j, dp), MinPathSum(grid, i, j+1, dp));\\n\\n    }\\n    public int minPathSum(int[][] grid) {\\n        \\n        int N = grid.length;\\n        int M = grid[0].length; \\n        int [][] dp = new int[N][M];\\n        for(int i=0; i<dp.length; i++){\\n            for(int j=0; j<dp[0].length; j++) dp[i][j] = -1;\\n        }\\n        return MinPathSum(grid, 0, 0, dp );\\n    }\\n}"
                    }
                ]
            },
            {
                "id": 1694940,
                "content": [
                    {
                        "username": "chandrahansprakashsaha",
                        "content": "java solution\\nclass Solution {\\n    public int minPathSum(int[][] grid) {\\n        \\n      \\n       int m=grid.length;\\n       int n=grid[0].length;\\n        int x= fun(grid,m,n);\\n        return x;\\n        }\\n     public int fun(int grid[][],int m,int n){\\n        int dp[][]=new int[m][n];\\n        dp[0][0]=grid[0][0];\\n        \\n        for(int i=0;i<m;i++) {\\n            for(int j=0;j<n;j++) {\\n                if(i==0 && j==0) continue;\\n                if(i==0) {\\n                    dp[i][j] = dp[i][j-1] + grid[i][j];\\n                } else if(j==0) {\\n                    dp[i][j] = dp[i-1][j] + grid[i][j];\\n                } else {\\n                    dp[i][j] = Math.min(dp[i-1][j], dp[i][j-1]) + grid[i][j];\\n                }\\n            }\\n        }\\n        \\n        \\n       return dp[m-1][n-1];\\n        \\n    \\n    }\\n}"
                    },
                    {
                        "username": "mohamed_waseela",
                        "content": "https://youtu.be/-Qpk2XJ5XJQ"
                    },
                    {
                        "username": "teckyshubham",
                        "content": "class Solution {\\n    int dp[][];\\n    int helper(int [][]grid,int i,int j){\\n        if(i==0&&j==0){\\n            return grid[i][j];\\n        }\\n        if(i<0||j<0){\\n            return (int)Math.pow(10,9);\\n        }\\n        if(dp[i][j]!=-1){\\n            return dp[i][j];\\n        }\\n        int left=grid[i][j]+helper(grid,i,j-1);\\n        int top=grid[i][j]+helper(grid,i-1,j);\\n        return dp[i][j]=Math.min(left,top);\\n    }\\n    public int minPathSum(int[][] grid) {\\n        dp=new int[grid.length][grid[0].length];\\n        for(int []row:dp){\\n            Arrays.fill(row,-1);\\n        }\\n        return helper(grid,grid.length-1,grid[0].length-1);\\n    }\\n}class Solution {\\n    int dp[][];\\n    int helper(int [][]grid,int i,int j){\\n        if(i==0&&j==0){\\n            return grid[i][j];\\n        }\\n        if(i<0||j<0){\\n            return (int)Math.pow(10,9);\\n        }\\n        if(dp[i][j]!=-1){\\n            return dp[i][j];\\n        }\\n        int left=grid[i][j]+helper(grid,i,j-1);\\n        int top=grid[i][j]+helper(grid,i-1,j);\\n        return dp[i][j]=Math.min(left,top);\\n    }\\n    public int minPathSum(int[][] grid) {\\n        dp=new int[grid.length][grid[0].length];\\n        for(int []row:dp){\\n            Arrays.fill(row,-1);\\n        }\\n        return helper(grid,grid.length-1,grid[0].length-1);\\n    }\\n}"
                    },
                    {
                        "username": "shivanshnema_04",
                        "content": "why Dijekstra giving TLE in this question ?"
                    },
                    {
                        "username": "shubhamhazra",
                        "content": "no it\\'s working fine.  \\nhere is my code : \\nclass Solution {\\npublic:\\n    int minPathSum(vector<vector<int>>& grid) {\\n        int m = grid.size();\\n        int n = grid[0].size();\\n  \\n        priority_queue<pair<int,pair<int,int>>, vector<pair<int,pair<int,int>>>,greater<pair<int,pair<int,int>>>>pq; // dist , x , y\\n        pq.push({grid[0][0] , {0,0}});\\n        vector<vector<int>>dist(m,vector<int>(n,INT_MAX));\\n        dist[0][0] = grid[0][0];\\n\\n        while(!pq.empty()){\\n            auto top = pq.top();\\n            pq.pop();\\n            int d = top.first;\\n            int x = top.second.first;\\n            int y = top.second.second;\\n\\n            int delx[2] = {1,0};\\n            int dely[2] = {0,1};\\n\\n            for(int i=0;i<2;i++){\\n                \\n                int X = x + delx[i];\\n                int Y = y + dely[i];\\n\\n                if(X>=0 && Y>=0 && X<m && Y<n)\\n                {\\n                if(d + grid[X][Y] < dist[X][Y]){\\n                    dist[X][Y] = d + grid[X][Y];\\n                    pq.push({dist[X][Y],{X,Y}});\\n                }\\n                }\\n            }\\n\\n        }\\n        return dist[m-1][n-1];\\n        \\n    }\\n};"
                    },
                    {
                        "username": "FrankieHacks",
                        "content": "Can anyone help me understand why my solution is slow. I submitted this and it gave better than `5%`. Thanks.\n```\nclass Solution {\n    public int minPathSum(int[][] grid) {\n      int m = grid.length, n = grid[0].length;\n      int[][] dp = new int[m][n];\n      for (int r = 0; r < m; r++) {\n        for (int c = 0; c < n; c++) {\n          int min = Integer.MAX_VALUE;\n          if (r != 0) {\n            min = Math.min(min, dp[r-1][c]);\n          }\n          if (c != 0) {\n            min = Math.min(min, dp[r][c-1]);\n          }\n          dp[r][c] = grid[r][c] + (min != Integer.MAX_VALUE ? min : 0);\n        }\n      }\n      return dp[m-1][n-1];\n    }\n}\n```"
                    },
                    {
                        "username": "matheus-rodrigues00",
                        "content": "Why the solution using a queue gives TLE?"
                    },
                    {
                        "username": "Aastha_Goyal",
                        "content": "Anyone can help me, my solution give wrong ans but by implementing same approach in diff way giving me correct ans. Where this implementation is wrong?\\n```\\nclass Solution {\\n    int min = Integer.MAX_VALUE;\\n    boolean[][] vis;\\n    public int minPathSum(int[][] grid) {\\n         vis = new boolean[grid.length][grid[0].length];\\n        recur(0,0,grid,0);\\n       \\n        return min;\\n    }\\n\\n    public void recur(int i, int j, int[][] grid, int psf){\\n        if(i<0 || j<0 || i>=grid.length || j>=grid[0].length || vis[i][j]) return ;\\n        if(i == grid.length-1 && j==grid[0].length-1){\\n            min = Math.min(min,psf);\\n            // System.out.println(psf);\\n            return ;\\n        }\\n        vis[i][j] = true;\\n\\n        recur(i+1,j,grid,psf+grid[i][j]);\\n        recur(i,j+1,grid,psf+grid[i][j]);\\n\\n        vis[i][j] = false;\\n        psf-=grid[i][j];\\n    }\\n}\\n\\n```"
                    },
                    {
                        "username": "wodxuming",
                        "content": "```\\nclass Solution {\\npublic:\\n    int minPathSum(vector<vector<int>>& grid) {\\n        const int m = grid.size();\\n        const int n = grid[0].size();\\n        vector< vector<int> > dp(m, vector(n, 0));\\n\\n        //base case\\n        dp[0][0] = grid[0][0];\\n        for (int i = 1; i < m; i++) {\\n            dp[i][0] = dp[i - 1][0] + grid[i][0];\\n        }\\n    \\n        for (int j = 1; j < n; j++)\\n            dp[0][j] = dp[0][j - 1] + grid[0][j]; \\n\\n        for (int i = 1; i < m; i++) {\\n            for (int j = 1; j < n; j++) {\\n                dp[i][j] = min(\\n                    dp[i - 1][j],\\n                    dp[i][j - 1]\\n                ) + grid[i][j];\\n            }\\n        }\\n\\n        return dp[m - 1][n - 1];\\n    }\\n};\\n\\n```"
                    },
                    {
                        "username": "patelsatyam",
                        "content": " public int minPathSum(int[][] grid) {\n        int row=grid.length;\n        int col=grid[0].length;\n\n        int[][] dp=new int[row][col];\n\n        for(int i=row-1; i>=0; i--)\n        {\n            for(int j=col-1; j>=0; j--)\n            {\n                if(i==row-1 && j==col-1)\n                {\n                    dp[i][j]=grid[i][j];\n                }\n                else if(i==row-1)\n                {\n                    dp[i][j]=dp[i][j+1]+grid[i][j];\n                }\n                else if(j==col-1)\n                {\n                    dp[i][j]=dp[i+1][j]+grid[i][j];\n                }\n                else\n                {\n                    dp[i][j]=Math.min(dp[i][j+1],dp[i+1][j]) + grid[i][j];\n                }\n            }\n        }\n\n        return dp[0][0];\n        \n    }"
                    },
                    {
                        "username": "djkhanna835",
                        "content": "\\nRitik khanna || JAVA SOLUTION\\n\\nclass Solution {\\n\\n    public int MinPathSum (int [][] grid, int i, int j, int [][] dp){\\n        int N = grid.length;\\n        int M = grid[0].length; \\n        if(i == N-1 && j == M-1) return grid[i][j];\\n        if(i >= N || j >= M) return Integer.MAX_VALUE;\\n\\n        if(dp[i][j] != -1) return dp[i][j];\\n        return dp[i][j] = grid[i][j] + Math.min(MinPathSum(grid, i+1, j, dp), MinPathSum(grid, i, j+1, dp));\\n\\n    }\\n    public int minPathSum(int[][] grid) {\\n        \\n        int N = grid.length;\\n        int M = grid[0].length; \\n        int [][] dp = new int[N][M];\\n        for(int i=0; i<dp.length; i++){\\n            for(int j=0; j<dp[0].length; j++) dp[i][j] = -1;\\n        }\\n        return MinPathSum(grid, 0, 0, dp );\\n    }\\n}"
                    }
                ]
            },
            {
                "id": 1675957,
                "content": [
                    {
                        "username": "chandrahansprakashsaha",
                        "content": "java solution\\nclass Solution {\\n    public int minPathSum(int[][] grid) {\\n        \\n      \\n       int m=grid.length;\\n       int n=grid[0].length;\\n        int x= fun(grid,m,n);\\n        return x;\\n        }\\n     public int fun(int grid[][],int m,int n){\\n        int dp[][]=new int[m][n];\\n        dp[0][0]=grid[0][0];\\n        \\n        for(int i=0;i<m;i++) {\\n            for(int j=0;j<n;j++) {\\n                if(i==0 && j==0) continue;\\n                if(i==0) {\\n                    dp[i][j] = dp[i][j-1] + grid[i][j];\\n                } else if(j==0) {\\n                    dp[i][j] = dp[i-1][j] + grid[i][j];\\n                } else {\\n                    dp[i][j] = Math.min(dp[i-1][j], dp[i][j-1]) + grid[i][j];\\n                }\\n            }\\n        }\\n        \\n        \\n       return dp[m-1][n-1];\\n        \\n    \\n    }\\n}"
                    },
                    {
                        "username": "mohamed_waseela",
                        "content": "https://youtu.be/-Qpk2XJ5XJQ"
                    },
                    {
                        "username": "teckyshubham",
                        "content": "class Solution {\\n    int dp[][];\\n    int helper(int [][]grid,int i,int j){\\n        if(i==0&&j==0){\\n            return grid[i][j];\\n        }\\n        if(i<0||j<0){\\n            return (int)Math.pow(10,9);\\n        }\\n        if(dp[i][j]!=-1){\\n            return dp[i][j];\\n        }\\n        int left=grid[i][j]+helper(grid,i,j-1);\\n        int top=grid[i][j]+helper(grid,i-1,j);\\n        return dp[i][j]=Math.min(left,top);\\n    }\\n    public int minPathSum(int[][] grid) {\\n        dp=new int[grid.length][grid[0].length];\\n        for(int []row:dp){\\n            Arrays.fill(row,-1);\\n        }\\n        return helper(grid,grid.length-1,grid[0].length-1);\\n    }\\n}class Solution {\\n    int dp[][];\\n    int helper(int [][]grid,int i,int j){\\n        if(i==0&&j==0){\\n            return grid[i][j];\\n        }\\n        if(i<0||j<0){\\n            return (int)Math.pow(10,9);\\n        }\\n        if(dp[i][j]!=-1){\\n            return dp[i][j];\\n        }\\n        int left=grid[i][j]+helper(grid,i,j-1);\\n        int top=grid[i][j]+helper(grid,i-1,j);\\n        return dp[i][j]=Math.min(left,top);\\n    }\\n    public int minPathSum(int[][] grid) {\\n        dp=new int[grid.length][grid[0].length];\\n        for(int []row:dp){\\n            Arrays.fill(row,-1);\\n        }\\n        return helper(grid,grid.length-1,grid[0].length-1);\\n    }\\n}"
                    },
                    {
                        "username": "shivanshnema_04",
                        "content": "why Dijekstra giving TLE in this question ?"
                    },
                    {
                        "username": "shubhamhazra",
                        "content": "no it\\'s working fine.  \\nhere is my code : \\nclass Solution {\\npublic:\\n    int minPathSum(vector<vector<int>>& grid) {\\n        int m = grid.size();\\n        int n = grid[0].size();\\n  \\n        priority_queue<pair<int,pair<int,int>>, vector<pair<int,pair<int,int>>>,greater<pair<int,pair<int,int>>>>pq; // dist , x , y\\n        pq.push({grid[0][0] , {0,0}});\\n        vector<vector<int>>dist(m,vector<int>(n,INT_MAX));\\n        dist[0][0] = grid[0][0];\\n\\n        while(!pq.empty()){\\n            auto top = pq.top();\\n            pq.pop();\\n            int d = top.first;\\n            int x = top.second.first;\\n            int y = top.second.second;\\n\\n            int delx[2] = {1,0};\\n            int dely[2] = {0,1};\\n\\n            for(int i=0;i<2;i++){\\n                \\n                int X = x + delx[i];\\n                int Y = y + dely[i];\\n\\n                if(X>=0 && Y>=0 && X<m && Y<n)\\n                {\\n                if(d + grid[X][Y] < dist[X][Y]){\\n                    dist[X][Y] = d + grid[X][Y];\\n                    pq.push({dist[X][Y],{X,Y}});\\n                }\\n                }\\n            }\\n\\n        }\\n        return dist[m-1][n-1];\\n        \\n    }\\n};"
                    },
                    {
                        "username": "FrankieHacks",
                        "content": "Can anyone help me understand why my solution is slow. I submitted this and it gave better than `5%`. Thanks.\n```\nclass Solution {\n    public int minPathSum(int[][] grid) {\n      int m = grid.length, n = grid[0].length;\n      int[][] dp = new int[m][n];\n      for (int r = 0; r < m; r++) {\n        for (int c = 0; c < n; c++) {\n          int min = Integer.MAX_VALUE;\n          if (r != 0) {\n            min = Math.min(min, dp[r-1][c]);\n          }\n          if (c != 0) {\n            min = Math.min(min, dp[r][c-1]);\n          }\n          dp[r][c] = grid[r][c] + (min != Integer.MAX_VALUE ? min : 0);\n        }\n      }\n      return dp[m-1][n-1];\n    }\n}\n```"
                    },
                    {
                        "username": "matheus-rodrigues00",
                        "content": "Why the solution using a queue gives TLE?"
                    },
                    {
                        "username": "Aastha_Goyal",
                        "content": "Anyone can help me, my solution give wrong ans but by implementing same approach in diff way giving me correct ans. Where this implementation is wrong?\\n```\\nclass Solution {\\n    int min = Integer.MAX_VALUE;\\n    boolean[][] vis;\\n    public int minPathSum(int[][] grid) {\\n         vis = new boolean[grid.length][grid[0].length];\\n        recur(0,0,grid,0);\\n       \\n        return min;\\n    }\\n\\n    public void recur(int i, int j, int[][] grid, int psf){\\n        if(i<0 || j<0 || i>=grid.length || j>=grid[0].length || vis[i][j]) return ;\\n        if(i == grid.length-1 && j==grid[0].length-1){\\n            min = Math.min(min,psf);\\n            // System.out.println(psf);\\n            return ;\\n        }\\n        vis[i][j] = true;\\n\\n        recur(i+1,j,grid,psf+grid[i][j]);\\n        recur(i,j+1,grid,psf+grid[i][j]);\\n\\n        vis[i][j] = false;\\n        psf-=grid[i][j];\\n    }\\n}\\n\\n```"
                    },
                    {
                        "username": "wodxuming",
                        "content": "```\\nclass Solution {\\npublic:\\n    int minPathSum(vector<vector<int>>& grid) {\\n        const int m = grid.size();\\n        const int n = grid[0].size();\\n        vector< vector<int> > dp(m, vector(n, 0));\\n\\n        //base case\\n        dp[0][0] = grid[0][0];\\n        for (int i = 1; i < m; i++) {\\n            dp[i][0] = dp[i - 1][0] + grid[i][0];\\n        }\\n    \\n        for (int j = 1; j < n; j++)\\n            dp[0][j] = dp[0][j - 1] + grid[0][j]; \\n\\n        for (int i = 1; i < m; i++) {\\n            for (int j = 1; j < n; j++) {\\n                dp[i][j] = min(\\n                    dp[i - 1][j],\\n                    dp[i][j - 1]\\n                ) + grid[i][j];\\n            }\\n        }\\n\\n        return dp[m - 1][n - 1];\\n    }\\n};\\n\\n```"
                    },
                    {
                        "username": "patelsatyam",
                        "content": " public int minPathSum(int[][] grid) {\n        int row=grid.length;\n        int col=grid[0].length;\n\n        int[][] dp=new int[row][col];\n\n        for(int i=row-1; i>=0; i--)\n        {\n            for(int j=col-1; j>=0; j--)\n            {\n                if(i==row-1 && j==col-1)\n                {\n                    dp[i][j]=grid[i][j];\n                }\n                else if(i==row-1)\n                {\n                    dp[i][j]=dp[i][j+1]+grid[i][j];\n                }\n                else if(j==col-1)\n                {\n                    dp[i][j]=dp[i+1][j]+grid[i][j];\n                }\n                else\n                {\n                    dp[i][j]=Math.min(dp[i][j+1],dp[i+1][j]) + grid[i][j];\n                }\n            }\n        }\n\n        return dp[0][0];\n        \n    }"
                    },
                    {
                        "username": "djkhanna835",
                        "content": "\\nRitik khanna || JAVA SOLUTION\\n\\nclass Solution {\\n\\n    public int MinPathSum (int [][] grid, int i, int j, int [][] dp){\\n        int N = grid.length;\\n        int M = grid[0].length; \\n        if(i == N-1 && j == M-1) return grid[i][j];\\n        if(i >= N || j >= M) return Integer.MAX_VALUE;\\n\\n        if(dp[i][j] != -1) return dp[i][j];\\n        return dp[i][j] = grid[i][j] + Math.min(MinPathSum(grid, i+1, j, dp), MinPathSum(grid, i, j+1, dp));\\n\\n    }\\n    public int minPathSum(int[][] grid) {\\n        \\n        int N = grid.length;\\n        int M = grid[0].length; \\n        int [][] dp = new int[N][M];\\n        for(int i=0; i<dp.length; i++){\\n            for(int j=0; j<dp[0].length; j++) dp[i][j] = -1;\\n        }\\n        return MinPathSum(grid, 0, 0, dp );\\n    }\\n}"
                    }
                ]
            },
            {
                "id": 1670947,
                "content": [
                    {
                        "username": "chandrahansprakashsaha",
                        "content": "java solution\\nclass Solution {\\n    public int minPathSum(int[][] grid) {\\n        \\n      \\n       int m=grid.length;\\n       int n=grid[0].length;\\n        int x= fun(grid,m,n);\\n        return x;\\n        }\\n     public int fun(int grid[][],int m,int n){\\n        int dp[][]=new int[m][n];\\n        dp[0][0]=grid[0][0];\\n        \\n        for(int i=0;i<m;i++) {\\n            for(int j=0;j<n;j++) {\\n                if(i==0 && j==0) continue;\\n                if(i==0) {\\n                    dp[i][j] = dp[i][j-1] + grid[i][j];\\n                } else if(j==0) {\\n                    dp[i][j] = dp[i-1][j] + grid[i][j];\\n                } else {\\n                    dp[i][j] = Math.min(dp[i-1][j], dp[i][j-1]) + grid[i][j];\\n                }\\n            }\\n        }\\n        \\n        \\n       return dp[m-1][n-1];\\n        \\n    \\n    }\\n}"
                    },
                    {
                        "username": "mohamed_waseela",
                        "content": "https://youtu.be/-Qpk2XJ5XJQ"
                    },
                    {
                        "username": "teckyshubham",
                        "content": "class Solution {\\n    int dp[][];\\n    int helper(int [][]grid,int i,int j){\\n        if(i==0&&j==0){\\n            return grid[i][j];\\n        }\\n        if(i<0||j<0){\\n            return (int)Math.pow(10,9);\\n        }\\n        if(dp[i][j]!=-1){\\n            return dp[i][j];\\n        }\\n        int left=grid[i][j]+helper(grid,i,j-1);\\n        int top=grid[i][j]+helper(grid,i-1,j);\\n        return dp[i][j]=Math.min(left,top);\\n    }\\n    public int minPathSum(int[][] grid) {\\n        dp=new int[grid.length][grid[0].length];\\n        for(int []row:dp){\\n            Arrays.fill(row,-1);\\n        }\\n        return helper(grid,grid.length-1,grid[0].length-1);\\n    }\\n}class Solution {\\n    int dp[][];\\n    int helper(int [][]grid,int i,int j){\\n        if(i==0&&j==0){\\n            return grid[i][j];\\n        }\\n        if(i<0||j<0){\\n            return (int)Math.pow(10,9);\\n        }\\n        if(dp[i][j]!=-1){\\n            return dp[i][j];\\n        }\\n        int left=grid[i][j]+helper(grid,i,j-1);\\n        int top=grid[i][j]+helper(grid,i-1,j);\\n        return dp[i][j]=Math.min(left,top);\\n    }\\n    public int minPathSum(int[][] grid) {\\n        dp=new int[grid.length][grid[0].length];\\n        for(int []row:dp){\\n            Arrays.fill(row,-1);\\n        }\\n        return helper(grid,grid.length-1,grid[0].length-1);\\n    }\\n}"
                    },
                    {
                        "username": "shivanshnema_04",
                        "content": "why Dijekstra giving TLE in this question ?"
                    },
                    {
                        "username": "shubhamhazra",
                        "content": "no it\\'s working fine.  \\nhere is my code : \\nclass Solution {\\npublic:\\n    int minPathSum(vector<vector<int>>& grid) {\\n        int m = grid.size();\\n        int n = grid[0].size();\\n  \\n        priority_queue<pair<int,pair<int,int>>, vector<pair<int,pair<int,int>>>,greater<pair<int,pair<int,int>>>>pq; // dist , x , y\\n        pq.push({grid[0][0] , {0,0}});\\n        vector<vector<int>>dist(m,vector<int>(n,INT_MAX));\\n        dist[0][0] = grid[0][0];\\n\\n        while(!pq.empty()){\\n            auto top = pq.top();\\n            pq.pop();\\n            int d = top.first;\\n            int x = top.second.first;\\n            int y = top.second.second;\\n\\n            int delx[2] = {1,0};\\n            int dely[2] = {0,1};\\n\\n            for(int i=0;i<2;i++){\\n                \\n                int X = x + delx[i];\\n                int Y = y + dely[i];\\n\\n                if(X>=0 && Y>=0 && X<m && Y<n)\\n                {\\n                if(d + grid[X][Y] < dist[X][Y]){\\n                    dist[X][Y] = d + grid[X][Y];\\n                    pq.push({dist[X][Y],{X,Y}});\\n                }\\n                }\\n            }\\n\\n        }\\n        return dist[m-1][n-1];\\n        \\n    }\\n};"
                    },
                    {
                        "username": "FrankieHacks",
                        "content": "Can anyone help me understand why my solution is slow. I submitted this and it gave better than `5%`. Thanks.\n```\nclass Solution {\n    public int minPathSum(int[][] grid) {\n      int m = grid.length, n = grid[0].length;\n      int[][] dp = new int[m][n];\n      for (int r = 0; r < m; r++) {\n        for (int c = 0; c < n; c++) {\n          int min = Integer.MAX_VALUE;\n          if (r != 0) {\n            min = Math.min(min, dp[r-1][c]);\n          }\n          if (c != 0) {\n            min = Math.min(min, dp[r][c-1]);\n          }\n          dp[r][c] = grid[r][c] + (min != Integer.MAX_VALUE ? min : 0);\n        }\n      }\n      return dp[m-1][n-1];\n    }\n}\n```"
                    },
                    {
                        "username": "matheus-rodrigues00",
                        "content": "Why the solution using a queue gives TLE?"
                    },
                    {
                        "username": "Aastha_Goyal",
                        "content": "Anyone can help me, my solution give wrong ans but by implementing same approach in diff way giving me correct ans. Where this implementation is wrong?\\n```\\nclass Solution {\\n    int min = Integer.MAX_VALUE;\\n    boolean[][] vis;\\n    public int minPathSum(int[][] grid) {\\n         vis = new boolean[grid.length][grid[0].length];\\n        recur(0,0,grid,0);\\n       \\n        return min;\\n    }\\n\\n    public void recur(int i, int j, int[][] grid, int psf){\\n        if(i<0 || j<0 || i>=grid.length || j>=grid[0].length || vis[i][j]) return ;\\n        if(i == grid.length-1 && j==grid[0].length-1){\\n            min = Math.min(min,psf);\\n            // System.out.println(psf);\\n            return ;\\n        }\\n        vis[i][j] = true;\\n\\n        recur(i+1,j,grid,psf+grid[i][j]);\\n        recur(i,j+1,grid,psf+grid[i][j]);\\n\\n        vis[i][j] = false;\\n        psf-=grid[i][j];\\n    }\\n}\\n\\n```"
                    },
                    {
                        "username": "wodxuming",
                        "content": "```\\nclass Solution {\\npublic:\\n    int minPathSum(vector<vector<int>>& grid) {\\n        const int m = grid.size();\\n        const int n = grid[0].size();\\n        vector< vector<int> > dp(m, vector(n, 0));\\n\\n        //base case\\n        dp[0][0] = grid[0][0];\\n        for (int i = 1; i < m; i++) {\\n            dp[i][0] = dp[i - 1][0] + grid[i][0];\\n        }\\n    \\n        for (int j = 1; j < n; j++)\\n            dp[0][j] = dp[0][j - 1] + grid[0][j]; \\n\\n        for (int i = 1; i < m; i++) {\\n            for (int j = 1; j < n; j++) {\\n                dp[i][j] = min(\\n                    dp[i - 1][j],\\n                    dp[i][j - 1]\\n                ) + grid[i][j];\\n            }\\n        }\\n\\n        return dp[m - 1][n - 1];\\n    }\\n};\\n\\n```"
                    },
                    {
                        "username": "patelsatyam",
                        "content": " public int minPathSum(int[][] grid) {\n        int row=grid.length;\n        int col=grid[0].length;\n\n        int[][] dp=new int[row][col];\n\n        for(int i=row-1; i>=0; i--)\n        {\n            for(int j=col-1; j>=0; j--)\n            {\n                if(i==row-1 && j==col-1)\n                {\n                    dp[i][j]=grid[i][j];\n                }\n                else if(i==row-1)\n                {\n                    dp[i][j]=dp[i][j+1]+grid[i][j];\n                }\n                else if(j==col-1)\n                {\n                    dp[i][j]=dp[i+1][j]+grid[i][j];\n                }\n                else\n                {\n                    dp[i][j]=Math.min(dp[i][j+1],dp[i+1][j]) + grid[i][j];\n                }\n            }\n        }\n\n        return dp[0][0];\n        \n    }"
                    },
                    {
                        "username": "djkhanna835",
                        "content": "\\nRitik khanna || JAVA SOLUTION\\n\\nclass Solution {\\n\\n    public int MinPathSum (int [][] grid, int i, int j, int [][] dp){\\n        int N = grid.length;\\n        int M = grid[0].length; \\n        if(i == N-1 && j == M-1) return grid[i][j];\\n        if(i >= N || j >= M) return Integer.MAX_VALUE;\\n\\n        if(dp[i][j] != -1) return dp[i][j];\\n        return dp[i][j] = grid[i][j] + Math.min(MinPathSum(grid, i+1, j, dp), MinPathSum(grid, i, j+1, dp));\\n\\n    }\\n    public int minPathSum(int[][] grid) {\\n        \\n        int N = grid.length;\\n        int M = grid[0].length; \\n        int [][] dp = new int[N][M];\\n        for(int i=0; i<dp.length; i++){\\n            for(int j=0; j<dp[0].length; j++) dp[i][j] = -1;\\n        }\\n        return MinPathSum(grid, 0, 0, dp );\\n    }\\n}"
                    }
                ]
            }
        ]
    },
    {
        "title": "Maximum Gap",
        "question_content": "<p>Given an integer array <code>nums</code>, return <em>the maximum difference between two successive elements in its sorted form</em>. If the array contains less than two elements, return <code>0</code>.</p>\n\n<p>You must write an algorithm that runs in linear time and uses linear extra space.</p>\n\n<p>&nbsp;</p>\n<p><strong class=\"example\">Example 1:</strong></p>\n\n<pre>\n<strong>Input:</strong> nums = [3,6,9,1]\n<strong>Output:</strong> 3\n<strong>Explanation:</strong> The sorted form of the array is [1,3,6,9], either (3,6) or (6,9) has the maximum difference 3.\n</pre>\n\n<p><strong class=\"example\">Example 2:</strong></p>\n\n<pre>\n<strong>Input:</strong> nums = [10]\n<strong>Output:</strong> 0\n<strong>Explanation:</strong> The array contains less than 2 elements, therefore return 0.\n</pre>\n\n<p>&nbsp;</p>\n<p><strong>Constraints:</strong></p>\n\n<ul>\n\t<li><code>1 &lt;= nums.length &lt;= 10<sup>5</sup></code></li>\n\t<li><code>0 &lt;= nums[i] &lt;= 10<sup>9</sup></code></li>\n</ul>\n",
        "solutions": [
            {
                "id": 50643,
                "title": "bucket-sort-java-solution-with-explanation-o-n-time-and-space",
                "content": "Suppose there are N elements in the array, the min value is ***min*** and the max value is ***max***. Then the maximum gap will be no smaller than ceiling[(***max*** - ***min*** ) / (N - 1)].\\n\\nLet gap = ceiling[(***max*** - ***min*** ) / (N - 1)]. We divide all numbers in the array into n-1 buckets, where k-th bucket contains all numbers in [***min***  + (k-1)gap, ***min***  + k*gap). Since there are n-2 numbers that are not equal ***min***  or ***max*** and there are n-1 buckets, at least one of the buckets are empty. We only need to store the largest number and the smallest number in each bucket. \\n\\nAfter we put all the numbers into the buckets. We can scan the buckets sequentially and get the max gap.\\n[my blog for this problem][1]\\n\\n    public class Solution {\\n    public int maximumGap(int[] num) {\\n        if (num == null || num.length < 2)\\n            return 0;\\n        // get the max and min value of the array\\n        int min = num[0];\\n        int max = num[0];\\n        for (int i:num) {\\n            min = Math.min(min, i);\\n            max = Math.max(max, i);\\n        }\\n        // the minimum possibale gap, ceiling of the integer division\\n        int gap = (int)Math.ceil((double)(max - min)/(num.length - 1));\\n        int[] bucketsMIN = new int[num.length - 1]; // store the min value in that bucket\\n        int[] bucketsMAX = new int[num.length - 1]; // store the max value in that bucket\\n        Arrays.fill(bucketsMIN, Integer.MAX_VALUE);\\n        Arrays.fill(bucketsMAX, Integer.MIN_VALUE);\\n        // put numbers into buckets\\n        for (int i:num) {\\n            if (i == min || i == max)\\n                continue;\\n            int idx = (i - min) / gap; // index of the right position in the buckets\\n            bucketsMIN[idx] = Math.min(i, bucketsMIN[idx]);\\n            bucketsMAX[idx] = Math.max(i, bucketsMAX[idx]);\\n        }\\n        // scan the buckets for the max gap\\n        int maxGap = Integer.MIN_VALUE;\\n        int previous = min;\\n        for (int i = 0; i < num.length - 1; i++) {\\n            if (bucketsMIN[i] == Integer.MAX_VALUE && bucketsMAX[i] == Integer.MIN_VALUE)\\n                // empty bucket\\n                continue;\\n            // min value minus the previous value is the current gap\\n            maxGap = Math.max(maxGap, bucketsMIN[i] - previous);\\n            // update previous bucket value\\n            previous = bucketsMAX[i];\\n        }\\n        maxGap = Math.max(maxGap, max - previous); // updata the final max value gap\\n        return maxGap;\\n    }\\n}\\n\\n\\n  [1]: http://zkfairytale.blogspot.ca/2014/12/maximum-gap.html",
                "solutionTags": [],
                "code": "class Solution {\\n    public int maximumGap(int[] num) {\\n        if (num == null || num.length < 2)\\n            return 0;\\n        // get the max and min value of the array\\n        int min = num[0];\\n        int max = num[0];\\n        for (int i:num) {\\n            min = Math.min(min, i);\\n            max = Math.max(max, i);\\n        }",
                "codeTag": "Java"
            },
            {
                "id": 1240543,
                "title": "python-bucket-sort-explained",
                "content": "This is quite difficult problem if you never used the idea of bucket sort. Let us divide all range of numbers into `n-1` cells. We will talk a bit later, why it is `n-1` and not other number. It is simpler to look at example:\\n\\n`nums = [3,14,15,83,6,4,19,20,40]`. Then we have 8 buckets, with numbers `0,1,2,3,4,5,6,7`, some of them are empty:\\n\\n`0: [3, 6, 4]`\\n`1: [14, 15, 19, 20]`\\n`3: [40]`\\n`7: [83]`\\n\\nHow we choose what to put where: we have range `[3-----83]`, which we separated into `n-1` groups: `[3--13), [13--23), ..., [73--83]`. Note, that numbers are not sorted inside groups. Now, let us notice one simple thing: there can not be maximum gap between sorted values of array inside each bucket. Why? Because there is `n-1` gaps with total difference `hi - lo`, so by pigeonhole principle, there is difference which is bigger or equal than `(hi - lo)/(n-1)`: indeed if all differences are smaller than this value, than total sum will be smaller than `(hi - lo)`. So, it suffies to look only at the differences between adjacent buckets and moreover it is difference between smallest number of one buckets and biggest value of previous bucket.\\n\\nSo, here are to following steps of our algorithm:\\n\\n1. Distribute numbers to buckets. Be careful with the biggest one, I put it to `n-2`-th bucket, but if you put it to `n-1` th, it will also be OK.\\n2. Find minimum and maximum in each buckets, we do not need anything else.\\n3. Iterate through buckets and check every difference between smallest element in one bucket and biggest in previous. Note, that here we also will check differences between say `1`-st and `3`-rd buckets if we have empty `2`-nd bucket.\\n\\n#### Complexity\\nTime complexity is `O(n)`: we traversed our data several times, space complexity is `O(n)` to keep buckets.\\n\\n#### Code\\n```python\\nclass Solution:\\n    def maximumGap(self, nums):\\n        lo, hi, n = min(nums), max(nums), len(nums)\\n        if n <= 2 or hi == lo: return hi - lo\\n        B = defaultdict(list)\\n        for num in nums:\\n            ind = n-2 if num == hi else (num - lo)*(n-1)//(hi-lo)\\n            B[ind].append(num)\\n            \\n        cands = [[min(B[i]), max(B[i])] for i in range(n-1) if B[i]]\\n        return max(y[0]-x[1] for x,y in zip(cands, cands[1:]))\\n```\\n\\nIf you have any questions, feel free to ask. If you like solution and explanations, please **Upvote!**",
                "solutionTags": [
                    "Bucket Sort"
                ],
                "code": "```python\\nclass Solution:\\n    def maximumGap(self, nums):\\n        lo, hi, n = min(nums), max(nums), len(nums)\\n        if n <= 2 or hi == lo: return hi - lo\\n        B = defaultdict(list)\\n        for num in nums:\\n            ind = n-2 if num == hi else (num - lo)*(n-1)//(hi-lo)\\n            B[ind].append(num)\\n            \\n        cands = [[min(B[i]), max(B[i])] for i in range(n-1) if B[i]]\\n        return max(y[0]-x[1] for x,y in zip(cands, cands[1:]))\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1241681,
                "title": "java-python-bucket-idea-with-picture-clean-concise-o-n",
                "content": "**Idea**\\n- Suppose in our integer array `N` elements, the min value is **min** and the max value is **max**. Then the maximum gap will be **greater or equal** to `ceiling[(max - min ) / (N - 1)]`.\\n- Let `bucketSize = ceiling[(max - min ) / (N - 1)]`. \\n- We divide all numbers in the array into `N` buckets, each bucket has size of `bucketSize`, where `i-th` (zero-based index) bucket contains all numbers in range `[min + i*bucketSize, min + (i+1)*bucketSize)`. \\n- Because maximum gap is always **greater or equal** to `bucketSize` so in each bucket, we only need to store max element and min element, skip middle elements (min < middle < max) in the same bucket.\\n- Finally, we only need to compare max number in current bucket and min number in next bucket to get the relatively large gap and find out which two bucket have the maximum gap.\\n\\n**Example picture**\\n![image](https://assets.leetcode.com/users/images/f555af3f-496f-4c42-b57f-4701fd276f82_1622433690.1145518.png)\\n\\n\\n**Complexity**\\n- Time: `O(N)`\\n- Space: `O(N)`\\n\\n**Python 3**\\n```python\\nclass Solution:\\n    def maximumGap(self, nums: List[int]) -> int:\\n        mi, ma, n = min(nums), max(nums), len(nums)\\n        if mi == ma: return 0  # All elements are the same\\n        bucketSize = math.ceil((ma - mi) / (n - 1))\\n        minBucket = [math.inf] * n\\n        maxBucket = [-math.inf] * n\\n        for x in nums:\\n            idx = (x - mi) // bucketSize\\n            minBucket[idx] = min(minBucket[idx], x)\\n            maxBucket[idx] = max(maxBucket[idx], x)\\n\\n        maxGap = bucketSize  # Maximum gap is always greater or equal to bucketSize\\n        prev = maxBucket[0]  # We always have 0th bucket\\n        for i in range(1, n):\\n            if minBucket[i] == math.inf: continue  # Skip empty bucket\\n            maxGap = max(maxGap, minBucket[i] - prev)\\n            prev = maxBucket[i]\\n        return maxGap\\n```\\n\\n**Java**\\n```java\\nclass Solution {\\n    public int maximumGap(int[] nums) {\\n        int min = nums[0], max = nums[0], n = nums.length;\\n        for (int x : nums) {\\n            min = Math.min(min, x);\\n            max = Math.max(max, x);\\n        }\\n        if (min == max) return 0; // All elements are the same\\n        int bucketSize = (int) Math.ceil((double) (max - min) / (n - 1));\\n        int[] minBucket = new int[n];\\n        int[] maxBucket = new int[n];\\n        Arrays.fill(minBucket, Integer.MAX_VALUE);\\n        Arrays.fill(maxBucket, Integer.MIN_VALUE);\\n        for (int x : nums) {\\n            int idx = (x - min) / bucketSize;\\n            minBucket[idx] = Math.min(x, minBucket[idx]);\\n            maxBucket[idx] = Math.max(x, maxBucket[idx]);\\n        }\\n        int maxGap = bucketSize; // Maximum gap is always greater or equal to bucketSize\\n        int previous = maxBucket[0]; // We always have 0th bucket\\n        for (int i = 1; i < n; i++) {\\n            if (minBucket[i] == Integer.MAX_VALUE) continue; // Skip empty bucket\\n            maxGap = Math.max(maxGap, minBucket[i] - previous);\\n            previous = maxBucket[i];\\n        }\\n        return maxGap;\\n    }\\n}\\n```\\n*This post is inspired by @zkfairytale and @DyXrLxSTAOadoD from this [post](https://leetcode.com/problems/maximum-gap/discuss/50643/)*\\n\\nIf you found this post useful, please **give it a vote**. If you have any questions, **feel free to comment** below. Thanks.\\n",
                "solutionTags": [],
                "code": "```python\\nclass Solution:\\n    def maximumGap(self, nums: List[int]) -> int:\\n        mi, ma, n = min(nums), max(nums), len(nums)\\n        if mi == ma: return 0  # All elements are the same\\n        bucketSize = math.ceil((ma - mi) / (n - 1))\\n        minBucket = [math.inf] * n\\n        maxBucket = [-math.inf] * n\\n        for x in nums:\\n            idx = (x - mi) // bucketSize\\n            minBucket[idx] = min(minBucket[idx], x)\\n            maxBucket[idx] = max(maxBucket[idx], x)\\n\\n        maxGap = bucketSize  # Maximum gap is always greater or equal to bucketSize\\n        prev = maxBucket[0]  # We always have 0th bucket\\n        for i in range(1, n):\\n            if minBucket[i] == math.inf: continue  # Skip empty bucket\\n            maxGap = max(maxGap, minBucket[i] - prev)\\n            prev = maxBucket[i]\\n        return maxGap\\n```\n```java\\nclass Solution {\\n    public int maximumGap(int[] nums) {\\n        int min = nums[0], max = nums[0], n = nums.length;\\n        for (int x : nums) {\\n            min = Math.min(min, x);\\n            max = Math.max(max, x);\\n        }\\n        if (min == max) return 0; // All elements are the same\\n        int bucketSize = (int) Math.ceil((double) (max - min) / (n - 1));\\n        int[] minBucket = new int[n];\\n        int[] maxBucket = new int[n];\\n        Arrays.fill(minBucket, Integer.MAX_VALUE);\\n        Arrays.fill(maxBucket, Integer.MIN_VALUE);\\n        for (int x : nums) {\\n            int idx = (x - min) / bucketSize;\\n            minBucket[idx] = Math.min(x, minBucket[idx]);\\n            maxBucket[idx] = Math.max(x, maxBucket[idx]);\\n        }\\n        int maxGap = bucketSize; // Maximum gap is always greater or equal to bucketSize\\n        int previous = maxBucket[0]; // We always have 0th bucket\\n        for (int i = 1; i < n; i++) {\\n            if (minBucket[i] == Integer.MAX_VALUE) continue; // Skip empty bucket\\n            maxGap = Math.max(maxGap, minBucket[i] - previous);\\n            previous = maxBucket[i];\\n        }\\n        return maxGap;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 50644,
                "title": "pigeon-hole-principle",
                "content": "Suppose you have n pigeons with labels and you put them into m holes based on their label with each hole of the same size. Why bother putting pigeons into holes? Because you want to disregard the distance between pigeons **within** each one hole. \\n\\nOnly when at least one hole is empty can we disregard the distance between pigeons within each one hole and compute the maximum gap solely by the distance between pigeons **in adjacent holes**. We make sure that at least one hole is empty by using m=n-1 (i.e. n-2 pigeons in n-1 holes => at least one hole is empty).\\n\\n    int maximumGap(vector<int>& nums) {\\n            const int n = nums.size();\\n            if(n<=1) return 0;\\n            int maxE = *max_element(nums.begin(),nums.end());\\n            int minE = *min_element(nums.begin(),nums.end());\\n            double len = double(maxE-minE)/double(n-1);\\n            vector<int> maxA(n,INT_MIN);\\n            vector<int> minA(n,INT_MAX);\\n            for(int i=0; i<n; i++) {\\n                int index = (nums[i]-minE)/len;\\n                maxA[index] = max(maxA[index],nums[i]);\\n                minA[index] = min(minA[index],nums[i]);\\n            }\\n            int gap = 0, prev = maxA[0];\\n            for(int i=1; i<n; i++) {\\n                if(minA[i]==INT_MAX) continue;\\n                gap = max(gap,minA[i]-prev);\\n                prev = maxA[i];\\n            }\\n            return gap;\\n        }",
                "solutionTags": [],
                "code": "Suppose you have n pigeons with labels and you put them into m holes based on their label with each hole of the same size. Why bother putting pigeons into holes? Because you want to disregard the distance between pigeons **within** each one hole. \\n\\nOnly when at least one hole is empty can we disregard the distance between pigeons within each one hole and compute the maximum gap solely by the distance between pigeons **in adjacent holes**. We make sure that at least one hole is empty by using m=n-1 (i.e. n-2 pigeons in n-1 holes => at least one hole is empty).\\n\\n    int maximumGap(vector<int>& nums) {\\n            const int n = nums.size();\\n            if(n<=1) return 0;\\n            int maxE = *max_element(nums.begin(),nums.end());\\n            int minE = *min_element(nums.begin(),nums.end());\\n            double len = double(maxE-minE)/double(n-1);\\n            vector<int> maxA(n,INT_MIN);\\n            vector<int> minA(n,INT_MAX);\\n            for(int i=0; i<n; i++) {\\n                int index = (nums[i]-minE)/len;\\n                maxA[index] = max(maxA[index],nums[i]);\\n                minA[index] = min(minA[index],nums[i]);\\n            }\\n            int gap = 0, prev = maxA[0];\\n            for(int i=1; i<n; i++) {\\n                if(minA[i]==INT_MAX) continue;\\n                gap = max(gap,minA[i]-prev);\\n                prev = maxA[i];\\n            }\\n            return gap;\\n        }",
                "codeTag": "Unknown"
            },
            {
                "id": 50642,
                "title": "radix-sort-solution-in-java-with-explanation",
                "content": "You can look at radix sort visualization here before reading the code:\\nhttps://www.cs.usfca.edu/~galles/visualization/RadixSort.html\\n\\n    public class Solution {\\n    public int maximumGap(int[] nums) {\\n        if (nums == null || nums.length < 2) {\\n            return 0;\\n        }\\n        \\n        // m is the maximal number in nums\\n        int m = nums[0];\\n        for (int i = 1; i < nums.length; i++) {\\n            m = Math.max(m, nums[i]);\\n        }\\n        \\n        int exp = 1; // 1, 10, 100, 1000 ...\\n        int R = 10; // 10 digits\\n\\n        int[] aux = new int[nums.length];\\n        \\n        while (m / exp > 0) { // Go through all digits from LSB to MSB\\n            int[] count = new int[R];\\n            \\n            for (int i = 0; i < nums.length; i++) {\\n                count[(nums[i] / exp) % 10]++;\\n            }\\n            \\n            for (int i = 1; i < count.length; i++) {\\n                count[i] += count[i - 1];\\n            }\\n            \\n            for (int i = nums.length - 1; i >= 0; i--) {\\n                aux[--count[(nums[i] / exp) % 10]] = nums[i];\\n            }\\n            \\n            for (int i = 0; i < nums.length; i++) {\\n                nums[i] = aux[i];\\n            }\\n            exp *= 10;\\n        }\\n        \\n        int max = 0;\\n        for (int i = 1; i < aux.length; i++) {\\n            max = Math.max(max, aux[i] - aux[i - 1]);\\n        }\\n         \\n        return max;\\n    }\\n}\\n\\n 1. The first step is to find the maximum value in nums array, it will\\n     be the threshold to end while loop.    \\n 2. Then use the radix sort algorithm to sort based on each digit from Least Significant Bit\\n        (LSB) to Most Significant Bit (MSB), that's exactly what's showing\\n        in the link.\\n 3. `(nums[i] / exp) % 10` is used to get the digit, for each digit, basically the digit itself serves as the index to\\n    access the count array. Count array stores the index to access aux\\n    array which stores the numbers after sorting based on the current\\n    digit.\\n 4. Finally, find the maximum gap from sorted array.\\n\\nTime and space complexities are both O(n). (Actually time is O(10n) at worst case for Integer.MAX_VALUE 2147483647)",
                "solutionTags": [
                    "Java"
                ],
                "code": "class Solution {\\n    public int maximumGap(int[] nums) {\\n        if (nums == null || nums.length < 2) {\\n            return 0;\\n        }",
                "codeTag": "Java"
            },
            {
                "id": 1240838,
                "title": "js-python-java-c-simple-bucket-sort-solution-w-explanation",
                "content": "*(Note: This is part of a series of Leetcode solution explanations. If you like this solution or find it useful,* ***please upvote*** *this post.)*\\n\\n---\\n\\n#### ***Idea:***\\n\\nFor this problem, we don\\'t need to actually sort every element, which would take longer than **O(N) time**. What we need to do is to find a way to group together numbers in such a way as to allow us to check the larger gaps between consecutive numbers. For this, we can turn to a **bucket sort**.\\n\\nA bucket sort involves creating an array (**buckets**) in which the elements represent buckets that cover the spread of the numbers to be sorted. Imagine trying to sort a deck of cards; it would only take once through the deck to sort it entirely into **13** \"buckets\", one for each value. Then we could go through the individual buckets and perform another, smaller sort before joining the entire deck together.\\n\\nIn this situation, however, we only need to perform the first part of the bucket sort. The idea is to define the size of our buckets such that the maximum gap will necessarily be larger than a single bucket. That would mean that our answer could then be found by comparing the highest value in each bucket with the lowest value in the next occupied bucket.\\n\\nTo achieve the right bucket size (**bsize**) for this to work, we\\'ll need to iterate through **nums** once to find the total range (**hi - lo**), then use that to figure out the absolute smallest possible maximum gap value (**(hi - lo) / (nums.length - 1)**). If we make sure to define the bucket size _smaller_ than this value, then as stated earlier, the two numbers that form the maximum gap will have to be found in separate buckets.\\n\\nSince there are exactly **N** numbers spread throughout the buckets, and since it only requires a single iteration of each number in a bucket to observe the local high and lo values (**currhi, currlo**), then it will take a total of **O(N) time** to perform this process for the entire **buckets** array. And since we only need to make one comparison per pair of buckets with consecutive numbers, and as there are only a maximum of **2 * N** buckets, the comparisons will only take **O(N) time**, as well.\\n\\nWe\\'ll just need to make sure that we remember the previous occupied bucket\\'s high value (**prevhi**) for the next comparison, as well as keeping track of the best result found so far (**ans**). Then, once we reach the end of our **buckets** array, we can simply **return ans**.\\n\\n - _**Time Complexity: O(N)** where **N** is the length of **nums**_\\n    - _finding **hi** and **lo** in **nums**: **O(N)**_\\n    - _fill **buckets**: **O(N)**_\\n    - _finding all bucket **hi**\\'s and **lo**\\'s: **O(N)**_\\n    - _comparing all bucket gaps: **O(N)** for up to **2 * N** buckets_\\n - _**Space Complexity: O(N)** for **N** numbers spread among at most **2 * N** buckets_\\n\\n---\\n\\n#### ***Javascript Code:***\\n```javascript\\nvar maximumGap = function(nums) {\\n    if (nums.length < 2) return 0\\n    let hi = 0, lo = 2e9, ans = 0\\n    for (let n of nums)\\n        hi = Math.max(hi, n), lo = Math.min(lo, n)\\n    let bsize = ~~((hi - lo) / (nums.length - 1)) || 1,\\n        buckets = Array.from({length: ~~((hi - lo) / bsize) + 1}, () => [])\\n    for (let n of nums)\\n        buckets[~~((n - lo) / bsize)].push(n)\\n    let currhi = 0\\n    for (let b of buckets) {\\n        if (!b.length) continue\\n        let prevhi = currhi || b[0], currlo = b[0]\\n        for (let n of b) \\n            currhi = Math.max(currhi, n), currlo = Math.min(currlo, n)\\n        ans = Math.max(ans, currlo - prevhi)\\n    }\\n    return ans\\n};\\n```\\n\\n---\\n\\n#### ***Python Code:***\\n```python\\nclass Solution:\\n    def maximumGap(self, nums: List[int]) -> int:\\n        if len(nums) < 2: return 0\\n        hi, lo, ans = max(nums), min(nums), 0\\n        bsize = (hi - lo) // (len(nums) - 1) or 1\\n        buckets = [[] for _ in range(((hi - lo) // bsize) + 1)]\\n        for n in nums:\\n            buckets[(n - lo) // bsize].append(n)\\n        currhi = 0\\n        for b in buckets:\\n            if not len(b): continue\\n            prevhi, currlo = currhi or b[0], b[0]\\n            for n in b: \\n                currhi, currlo = max(currhi, n), min(currlo, n)\\n            ans = max(ans, currlo - prevhi)\\n        return ans\\n```\\n\\n---\\n\\n#### ***Java Code:***\\n```java\\nclass Solution {\\n    public int maximumGap(int[] nums) {\\n        if (nums.length < 2) return 0;\\n        int hi = 0, lo = Integer.MAX_VALUE, ans = 0;\\n        for (int n : nums) {\\n            hi = Math.max(hi, n);\\n            lo = Math.min(lo, n);\\n        }\\n        int bsize = Math.max((hi - lo) / (nums.length - 1), 1);\\n        List<List<Integer>> buckets = new ArrayList<>();\\n        for (int i = (hi - lo) / bsize; i >= 0; i--)\\n            buckets.add(new ArrayList<>());\\n        for (int n : nums)\\n            buckets.get((n - lo) / bsize).add(n);\\n        int currhi = 0;\\n        for (List<Integer> b : buckets) {\\n            if (b.isEmpty()) continue;\\n            int prevhi = currhi > 0 ? currhi : b.get(0), currlo = b.get(0);\\n            for (int n : b) {\\n                currhi = Math.max(currhi, n);\\n                currlo = Math.min(currlo, n);\\n            }\\n            ans = Math.max(ans, currlo - prevhi);\\n        }\\n        return ans;\\n    }\\n}\\n```\\n\\n---\\n\\n#### ***C++ Code:***\\n```c++\\nclass Solution {\\npublic:\\n    int maximumGap(vector<int>& nums) {\\n        if (nums.size() < 2) return 0;\\n        int hi = 0, lo = INT_MAX, ans = 0;\\n        for (auto& n : nums)\\n            hi = max(hi, n), lo = min(lo, n);\\n        int bsize = max(int((hi - lo) / (nums.size() - 1)), 1);\\n        vector<vector<int>> buckets((hi - lo) / bsize + 1, vector<int>());\\n        for (auto& n : nums)\\n            buckets[(n - lo) / bsize].push_back(n);\\n        int currhi = 0;\\n        for (auto& b : buckets) {\\n            if (b.empty()) continue;\\n            int prevhi = currhi ? currhi : b[0], currlo = b[0];\\n            for (auto& n : b)\\n                currhi = max(currhi, n), currlo = min(currlo, n);\\n            ans = max(ans, currlo - prevhi);\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "Java",
                    "Python",
                    "C",
                    "JavaScript"
                ],
                "code": "```javascript\\nvar maximumGap = function(nums) {\\n    if (nums.length < 2) return 0\\n    let hi = 0, lo = 2e9, ans = 0\\n    for (let n of nums)\\n        hi = Math.max(hi, n), lo = Math.min(lo, n)\\n    let bsize = ~~((hi - lo) / (nums.length - 1)) || 1,\\n        buckets = Array.from({length: ~~((hi - lo) / bsize) + 1}, () => [])\\n    for (let n of nums)\\n        buckets[~~((n - lo) / bsize)].push(n)\\n    let currhi = 0\\n    for (let b of buckets) {\\n        if (!b.length) continue\\n        let prevhi = currhi || b[0], currlo = b[0]\\n        for (let n of b) \\n            currhi = Math.max(currhi, n), currlo = Math.min(currlo, n)\\n        ans = Math.max(ans, currlo - prevhi)\\n    }\\n    return ans\\n};\\n```\n```python\\nclass Solution:\\n    def maximumGap(self, nums: List[int]) -> int:\\n        if len(nums) < 2: return 0\\n        hi, lo, ans = max(nums), min(nums), 0\\n        bsize = (hi - lo) // (len(nums) - 1) or 1\\n        buckets = [[] for _ in range(((hi - lo) // bsize) + 1)]\\n        for n in nums:\\n            buckets[(n - lo) // bsize].append(n)\\n        currhi = 0\\n        for b in buckets:\\n            if not len(b): continue\\n            prevhi, currlo = currhi or b[0], b[0]\\n            for n in b: \\n                currhi, currlo = max(currhi, n), min(currlo, n)\\n            ans = max(ans, currlo - prevhi)\\n        return ans\\n```\n```java\\nclass Solution {\\n    public int maximumGap(int[] nums) {\\n        if (nums.length < 2) return 0;\\n        int hi = 0, lo = Integer.MAX_VALUE, ans = 0;\\n        for (int n : nums) {\\n            hi = Math.max(hi, n);\\n            lo = Math.min(lo, n);\\n        }\\n        int bsize = Math.max((hi - lo) / (nums.length - 1), 1);\\n        List<List<Integer>> buckets = new ArrayList<>();\\n        for (int i = (hi - lo) / bsize; i >= 0; i--)\\n            buckets.add(new ArrayList<>());\\n        for (int n : nums)\\n            buckets.get((n - lo) / bsize).add(n);\\n        int currhi = 0;\\n        for (List<Integer> b : buckets) {\\n            if (b.isEmpty()) continue;\\n            int prevhi = currhi > 0 ? currhi : b.get(0), currlo = b.get(0);\\n            for (int n : b) {\\n                currhi = Math.max(currhi, n);\\n                currlo = Math.min(currlo, n);\\n            }\\n            ans = Math.max(ans, currlo - prevhi);\\n        }\\n        return ans;\\n    }\\n}\\n```\n```c++\\nclass Solution {\\npublic:\\n    int maximumGap(vector<int>& nums) {\\n        if (nums.size() < 2) return 0;\\n        int hi = 0, lo = INT_MAX, ans = 0;\\n        for (auto& n : nums)\\n            hi = max(hi, n), lo = min(lo, n);\\n        int bsize = max(int((hi - lo) / (nums.size() - 1)), 1);\\n        vector<vector<int>> buckets((hi - lo) / bsize + 1, vector<int>());\\n        for (auto& n : nums)\\n            buckets[(n - lo) / bsize].push_back(n);\\n        int currhi = 0;\\n        for (auto& b : buckets) {\\n            if (b.empty()) continue;\\n            int prevhi = currhi ? currhi : b[0], currlo = b[0];\\n            for (auto& n : b)\\n                currhi = max(currhi, n), currlo = min(currlo, n);\\n            ans = max(ans, currlo - prevhi);\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 50650,
                "title": "python-bucket-sort-from-official-solution",
                "content": "    class Solution:\\n    # @param num, a list of integer\\n    # @return an integer\\n    def maximumGap(self, num):\\n        if len(num) < 2 or min(num) == max(num):\\n            return 0\\n        a, b = min(num), max(num)\\n        size = math.ceil((b-a)/(len(num)-1))\\n        bucket = [[None, None] for _ in range((b-a)//size+1)]\\n        for n in num:\\n            b = bucket[(n-a)//size]\\n            b[0] = n if b[0] is None else min(b[0], n)\\n            b[1] = n if b[1] is None else max(b[1], n)\\n        bucket = [b for b in bucket if b[0] is not None]\\n        return max(bucket[i][0]-bucket[i-1][1] for i in range(1, len(bucket)))\\n\\nThe python version is 3.4, for 2.7 version rewrite the size",
                "solutionTags": [],
                "code": "    class Solution:\\n    # @param num, a list of integer\\n    # @return an integer\\n    def maximumGap(self, num):\\n        if len(num) < 2 or min(num) == max(num):\\n            return 0\\n        a, b = min(num), max(num)\\n        size = math.ceil((b-a)/(len(num)-1))\\n        bucket = [[None, None] for _ in range((b-a)//size+1)]\\n        for n in num:\\n            b = bucket[(n-a)//size]\\n            b[0] = n if b[0] is None else min(b[0], n)\\n            b[1] = n if b[1] is None else max(b[1], n)\\n        bucket = [b for b in bucket if b[0] is not None]\\n        return max(bucket[i][0]-bucket[i-1][1] for i in range(1, len(bucket)))\\n\\nThe python version is 3.4, for 2.7 version rewrite the size",
                "codeTag": "Java"
            },
            {
                "id": 1240841,
                "title": "maximum-gap-js-python-java-c-simple-bucket-sort-solution-w-explanation",
                "content": "*(Note: This is part of a series of Leetcode solution explanations. If you like this solution or find it useful,* ***please upvote*** *this post.)*\\n\\n---\\n\\n#### ***Idea:***\\n\\nFor this problem, we don\\'t need to actually sort every element, which would take longer than **O(N) time**. What we need to do is to find a way to group together numbers in such a way as to allow us to check the larger gaps between consecutive numbers. For this, we can turn to a **bucket sort**.\\n\\nA bucket sort involves creating an array (**buckets**) in which the elements represent buckets that cover the spread of the numbers to be sorted. Imagine trying to sort a deck of cards; it would only take once through the deck to sort it entirely into **13** \"buckets\", one for each value. Then we could go through the individual buckets and perform another, smaller sort before joining the entire deck together.\\n\\nIn this situation, however, we only need to perform the first part of the bucket sort. The idea is to define the size of our buckets such that the maximum gap will necessarily be larger than a single bucket. That would mean that our answer could then be found by comparing the highest value in each bucket with the lowest value in the next occupied bucket.\\n\\nTo achieve the right bucket size (**bsize**) for this to work, we\\'ll need to iterate through **nums** once to find the total range (**hi - lo**), then use that to figure out the absolute smallest possible maximum gap value (**(hi - lo) / (nums.length - 1)**). If we make sure to define the bucket size _smaller_ than this value, then as stated earlier, the two numbers that form the maximum gap will have to be found in separate buckets.\\n\\nSince there are exactly **N** numbers spread throughout the buckets, and since it only requires a single iteration of each number in a bucket to observe the local high and lo values (**currhi, currlo**), then it will take a total of **O(N) time** to perform this process for the entire **buckets** array. And since we only need to make one comparison per pair of buckets with consecutive numbers, and as there are only a maximum of **2 * N** buckets, the comparisons will only take **O(N) time**, as well.\\n\\nWe\\'ll just need to make sure that we remember the previous occupied bucket\\'s high value (**prevhi**) for the next comparison, as well as keeping track of the best result found so far (**ans**). Then, once we reach the end of our **buckets** array, we can simply **return ans**.\\n\\n - _**Time Complexity: O(N)** where **N** is the length of **nums**_\\n    - _finding **hi** and **lo** in **nums**: **O(N)**_\\n    - _fill **buckets**: **O(N)**_\\n    - _finding all bucket **hi**\\'s and **lo**\\'s: **O(N)**_\\n    - _comparing all bucket gaps: **O(N)** for up to **2 * N** buckets_\\n - _**Space Complexity: O(N)** for **N** numbers spread among at most **2 * N** buckets_\\n\\n---\\n\\n#### ***Javascript Code:***\\n```javascript\\nvar maximumGap = function(nums) {\\n    if (nums.length < 2) return 0\\n    let hi = 0, lo = 2e9, ans = 0\\n    for (let n of nums)\\n        hi = Math.max(hi, n), lo = Math.min(lo, n)\\n    let bsize = ~~((hi - lo) / (nums.length - 1)) || 1,\\n        buckets = Array.from({length: ~~((hi - lo) / bsize) + 1}, () => [])\\n    for (let n of nums)\\n        buckets[~~((n - lo) / bsize)].push(n)\\n    let currhi = 0\\n    for (let b of buckets) {\\n        if (!b.length) continue\\n        let prevhi = currhi || b[0], currlo = b[0]\\n        for (let n of b) \\n            currhi = Math.max(currhi, n), currlo = Math.min(currlo, n)\\n        ans = Math.max(ans, currlo - prevhi)\\n    }\\n    return ans\\n};\\n```\\n\\n---\\n\\n#### ***Python Code:***\\n```python\\nclass Solution:\\n    def maximumGap(self, nums: List[int]) -> int:\\n        if len(nums) < 2: return 0\\n        hi, lo, ans = max(nums), min(nums), 0\\n        bsize = (hi - lo) // (len(nums) - 1) or 1\\n        buckets = [[] for _ in range(((hi - lo) // bsize) + 1)]\\n        for n in nums:\\n            buckets[(n - lo) // bsize].append(n)\\n        currhi = 0\\n        for b in buckets:\\n            if not len(b): continue\\n            prevhi, currlo = currhi or b[0], b[0]\\n            for n in b: \\n                currhi, currlo = max(currhi, n), min(currlo, n)\\n            ans = max(ans, currlo - prevhi)\\n        return ans\\n```\\n\\n---\\n\\n#### ***Java Code:***\\n```java\\nclass Solution {\\n    public int maximumGap(int[] nums) {\\n        if (nums.length < 2) return 0;\\n        int hi = 0, lo = Integer.MAX_VALUE, ans = 0;\\n        for (int n : nums) {\\n            hi = Math.max(hi, n);\\n            lo = Math.min(lo, n);\\n        }\\n        int bsize = Math.max((hi - lo) / (nums.length - 1), 1);\\n        List<List<Integer>> buckets = new ArrayList<>();\\n        for (int i = (hi - lo) / bsize; i >= 0; i--)\\n            buckets.add(new ArrayList<>());\\n        for (int n : nums)\\n            buckets.get((n - lo) / bsize).add(n);\\n        int currhi = 0;\\n        for (List<Integer> b : buckets) {\\n            if (b.isEmpty()) continue;\\n            int prevhi = currhi > 0 ? currhi : b.get(0), currlo = b.get(0);\\n            for (int n : b) {\\n                currhi = Math.max(currhi, n);\\n                currlo = Math.min(currlo, n);\\n            }\\n            ans = Math.max(ans, currlo - prevhi);\\n        }\\n        return ans;\\n    }\\n}\\n```\\n\\n---\\n\\n#### ***C++ Code:***\\n```c++\\nclass Solution {\\npublic:\\n    int maximumGap(vector<int>& nums) {\\n        if (nums.size() < 2) return 0;\\n        int hi = 0, lo = INT_MAX, ans = 0;\\n        for (auto& n : nums)\\n            hi = max(hi, n), lo = min(lo, n);\\n        int bsize = max(int((hi - lo) / (nums.size() - 1)), 1);\\n        vector<vector<int>> buckets((hi - lo) / bsize + 1, vector<int>());\\n        for (auto& n : nums)\\n            buckets[(n - lo) / bsize].push_back(n);\\n        int currhi = 0;\\n        for (auto& b : buckets) {\\n            if (b.empty()) continue;\\n            int prevhi = currhi ? currhi : b[0], currlo = b[0];\\n            for (auto& n : b)\\n                currhi = max(currhi, n), currlo = min(currlo, n);\\n            ans = max(ans, currlo - prevhi);\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```javascript\\nvar maximumGap = function(nums) {\\n    if (nums.length < 2) return 0\\n    let hi = 0, lo = 2e9, ans = 0\\n    for (let n of nums)\\n        hi = Math.max(hi, n), lo = Math.min(lo, n)\\n    let bsize = ~~((hi - lo) / (nums.length - 1)) || 1,\\n        buckets = Array.from({length: ~~((hi - lo) / bsize) + 1}, () => [])\\n    for (let n of nums)\\n        buckets[~~((n - lo) / bsize)].push(n)\\n    let currhi = 0\\n    for (let b of buckets) {\\n        if (!b.length) continue\\n        let prevhi = currhi || b[0], currlo = b[0]\\n        for (let n of b) \\n            currhi = Math.max(currhi, n), currlo = Math.min(currlo, n)\\n        ans = Math.max(ans, currlo - prevhi)\\n    }\\n    return ans\\n};\\n```\n```python\\nclass Solution:\\n    def maximumGap(self, nums: List[int]) -> int:\\n        if len(nums) < 2: return 0\\n        hi, lo, ans = max(nums), min(nums), 0\\n        bsize = (hi - lo) // (len(nums) - 1) or 1\\n        buckets = [[] for _ in range(((hi - lo) // bsize) + 1)]\\n        for n in nums:\\n            buckets[(n - lo) // bsize].append(n)\\n        currhi = 0\\n        for b in buckets:\\n            if not len(b): continue\\n            prevhi, currlo = currhi or b[0], b[0]\\n            for n in b: \\n                currhi, currlo = max(currhi, n), min(currlo, n)\\n            ans = max(ans, currlo - prevhi)\\n        return ans\\n```\n```java\\nclass Solution {\\n    public int maximumGap(int[] nums) {\\n        if (nums.length < 2) return 0;\\n        int hi = 0, lo = Integer.MAX_VALUE, ans = 0;\\n        for (int n : nums) {\\n            hi = Math.max(hi, n);\\n            lo = Math.min(lo, n);\\n        }\\n        int bsize = Math.max((hi - lo) / (nums.length - 1), 1);\\n        List<List<Integer>> buckets = new ArrayList<>();\\n        for (int i = (hi - lo) / bsize; i >= 0; i--)\\n            buckets.add(new ArrayList<>());\\n        for (int n : nums)\\n            buckets.get((n - lo) / bsize).add(n);\\n        int currhi = 0;\\n        for (List<Integer> b : buckets) {\\n            if (b.isEmpty()) continue;\\n            int prevhi = currhi > 0 ? currhi : b.get(0), currlo = b.get(0);\\n            for (int n : b) {\\n                currhi = Math.max(currhi, n);\\n                currlo = Math.min(currlo, n);\\n            }\\n            ans = Math.max(ans, currlo - prevhi);\\n        }\\n        return ans;\\n    }\\n}\\n```\n```c++\\nclass Solution {\\npublic:\\n    int maximumGap(vector<int>& nums) {\\n        if (nums.size() < 2) return 0;\\n        int hi = 0, lo = INT_MAX, ans = 0;\\n        for (auto& n : nums)\\n            hi = max(hi, n), lo = min(lo, n);\\n        int bsize = max(int((hi - lo) / (nums.size() - 1)), 1);\\n        vector<vector<int>> buckets((hi - lo) / bsize + 1, vector<int>());\\n        for (auto& n : nums)\\n            buckets[(n - lo) / bsize].push_back(n);\\n        int currhi = 0;\\n        for (auto& b : buckets) {\\n            if (b.empty()) continue;\\n            int prevhi = currhi ? currhi : b[0], currlo = b[0];\\n            for (auto& n : b)\\n                currhi = max(currhi, n), currlo = min(currlo, n);\\n            ans = max(ans, currlo - prevhi);\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 50647,
                "title": "i-solved-it-using-radix-sort",
                "content": "Since linear time and space is required and all nums are non-negative, radix sort seems to be fit.\\nHere is the implementation.\\n\\nAny better ideas?\\n\\n    class Solution:\\n        # @param num, a list of integer\\n        # @return an integer\\n        def maximumGap(self, num):\\n            if len(num) < 2:\\n                return 0\\n            num = self.radixSort(num)\\n            res = 0\\n            for i in range(1, len(num)):\\n                res = max(num[i] - num[i - 1], res)\\n            return res\\n        \\n        def radixSort(self, num):\\n            for i in range(31):\\n                onebucket = []\\n                zerobucket = []\\n                needle = 1 << i\\n                for j in range(len(num)):\\n                    if num[j] & needle != 0:\\n                        onebucket.append(num[j])\\n                    else:\\n                        zerobucket.append(num[j])\\n                num = []\\n                num += zerobucket\\n                num += onebucket\\n            return num",
                "solutionTags": [],
                "code": "Since linear time and space is required and all nums are non-negative, radix sort seems to be fit.\\nHere is the implementation.\\n\\nAny better ideas?\\n\\n    class Solution:\\n        # @param num, a list of integer\\n        # @return an integer\\n        def maximumGap(self, num):\\n            if len(num) < 2:\\n                return 0\\n            num = self.radixSort(num)\\n            res = 0\\n            for i in range(1, len(num)):\\n                res = max(num[i] - num[i - 1], res)\\n            return res\\n        \\n        def radixSort(self, num):\\n            for i in range(31):\\n                onebucket = []\\n                zerobucket = []\\n                needle = 1 << i\\n                for j in range(len(num)):\\n                    if num[j] & needle != 0:\\n                        onebucket.append(num[j])\\n                    else:\\n                        zerobucket.append(num[j])\\n                num = []\\n                num += zerobucket\\n                num += onebucket\\n            return num",
                "codeTag": "Java"
            },
            {
                "id": 50725,
                "title": "my-c-code-12-ms-bucket-sort-o-n-time-and-space",
                "content": "The key is to use the fact that the lower bound of the gap is (maxV - minV )/ (sSize - 1). With such in mind, we can put all the num elements into different bucket with size (maxV - minV )/ (sSize - 1) (please note when such size is less than 1, then use 1 instead) and in such way, we only need to consider the min and max of each bucket and don't need to worry the numbers in between of each bucket since the gaps among those elements are smaller than the bucket size, and then the lower bound of the gap, so they can not achieve the max gap.\\n\\nclass Solution {\\npublic:\\n    int maximumGap(vector<int> &num) {\\n        int sSize = num.size();\\n        int i, res =0;\\n        int minV, maxV;\\n        int bucket_size, bucket_num, bucket_id;\\n        int maxGap = INT_MIN;\\n        int last_max;\\n        \\n        if(sSize>1)\\n        {\\n            minV =  maxV = num[0];\\n            for(i=1; i<sSize; i++)\\n            {\\n                if(minV > num[i]) minV = num[i];\\n                else if(maxV < num[i]) maxV = num[i];\\n            }\\n            \\n            bucket_size = max(1, (maxV - minV )/ (sSize - 1)));\\n            bucket_num  = (maxV - minV)/bucket_size + 1;\\n\\n            if(bucket_num <=1) return (maxV - minV); \\n            vector<int> bucket_max(bucket_num, INT_MIN);\\n            vector<int> bucket_min(bucket_num, INT_MAX);\\n            vector<int> bucket_count(bucket_num, 0);\\n            \\n            for(i=0; i<sSize; i++)\\n            {\\n                bucket_id = (num[i] - minV)/bucket_size;\\n                bucket_count[bucket_id]++;\\n                bucket_min[bucket_id] = bucket_min[bucket_id] > num[i]? num[i]:bucket_min[bucket_id];\\n                bucket_max[bucket_id] = bucket_max[bucket_id] < num[i]? num[i]:bucket_max[bucket_id];\\n            }\\n            \\n            last_max = minV;\\n            for(i=0; i<bucket_num; i++)\\n            {\\n                if(bucket_count[i]>0)\\n                {\\n                    maxGap = max(maxGap, bucket_min[i]- last_max);\\n                    last_max = bucket_max[i];\\n                }\\n            }\\n            return maxGap;\\n        }\\n        return 0;\\n    }\\n};",
                "solutionTags": [],
                "code": "class Solution {\\npublic:\\n    int maximumGap(vector<int> &num) {\\n        int sSize = num.size();\\n        int i, res =0;\\n        int minV, maxV;\\n        int bucket_size, bucket_num, bucket_id;\\n        int maxGap = INT_MIN;\\n        int last_max;\\n        \\n        if(sSize>1)\\n        {\\n            minV =  maxV = num[0];\\n            for(i=1; i<sSize; i++)\\n            {\\n                if(minV > num[i]) minV = num[i];\\n                else if(maxV < num[i]) maxV = num[i];\\n            }",
                "codeTag": "Java"
            },
            {
                "id": 50669,
                "title": "beat-99-81-java-coder",
                "content": "    public class Solution {\\n    public int maximumGap(int[] nums) {\\n        int n = nums.length;\\n        if(n < 2) return 0;\\n        int min = nums[0];\\n        int max = nums[0];\\n        for(int i = 1;i < n;i++){\\n            if(min > nums[i]) min = nums[i];\\n            if(max < nums[i]) max = nums[i];\\n        }\\n        \\n        int gap = (max-min)/(n-1);\\n        if(gap == 0) gap++;\\n        int len = (max-min)/gap+1;\\n        int [] tmax = new int [len];\\n        int [] tmin = new int [len];\\n        \\n        for(int i = 0;i < n;i++){\\n            int index = (nums[i]-min)/gap;\\n            if(nums[i] > tmax[index]) tmax[index] = nums[i];\\n            if(tmin[index] == 0 || nums[i] < tmin[index]) tmin[index] = nums[i];\\n        }\\n        int myMax = 0;\\n        for(int i = 0;i < len;i++){\\n            if(myMax < tmin[i]-min) myMax = tmin[i]-min;\\n            if(tmax[i] != 0) min = tmax[i];\\n        }\\n        return myMax;\\n    }\\n}",
                "solutionTags": [
                    "Java"
                ],
                "code": "class Solution {\\n    public int maximumGap(int[] nums) {\\n        int n = nums.length;\\n        if(n < 2) return 0;\\n        int min = nums[0];\\n        int max = nums[0];\\n        for(int i = 1;i < n;i++){\\n            if(min > nums[i]) min = nums[i];\\n            if(max < nums[i]) max = nums[i];\\n        }",
                "codeTag": "Java"
            },
            {
                "id": 50667,
                "title": "solutions-in-c-with-explanation-read-it-and-then-you-get-it",
                "content": "### Solutions\\nWhen first coming into this problem, the first direct idea is to sort it and then search for the maximal difference along the array. And as a result we will have a sort solution as follows.\\n\\n#### Sort\\nVery straightforward solution via sorting using O(1) space while efficient enough time cost O(nlogn).\\n\\n```\\nint maximumGap(vector<int>& nums) \\n{\\n\\tint size = nums.size();\\n\\tif(size < 2) return 0;\\n\\tif(size == 2) return abs(nums[1]-nums[0]);\\n\\tint maxDiff = 0;\\n\\tsort(nums.begin(), nums.end());\\n\\tfor(int i = 0; i < size-1; ++i)\\n\\t\\tmaxDiff = max(maxDiff, nums[i+1]-nums[i]);\\n\\treturn maxDiff;\\n}\\n```\\n\\n#### Bucket\\nBut sorting the whole array is really costly since it's quite unnecessary to sort them all when just trying to find out the maximal difference between successive two numbers in its sorted state. So quite intuitively we would like to use bucket sort to accelerate the process, another typical case using space to accelerate. Why using bucket? If we can set a proper size for each bucket to ensure the maximal difference definitely comes from two different buckets then we do not need to sort the whole array, just checking the minimal and maximal number of each bucket from small to big buckets - ascending order. But how to select the right size for each bucket?\\n\\nBefore reading the analysis below, please do remember the following rule.\\n\\n- **ensure the maximal difference comes from different buckets**\\n\\nHere are some analysis about it:\\n\\n1. since we are to adopt bucket here, we have to first retrieve the max and min number of the array;\\n2. the array with `size` numbers will split the [min, max] space into `size-1` different blocks so the numbers of the array will lie in [min, min+gap), [min+gap, min+2\\\\*gap), ..., [min+(size-2)\\\\*gap, min+(size-1)\\\\*gap) by the way the gap here is the size of the block which we will discuss further later; the blocks here are the buckets we mentioned \\n3. via the ranges of buckets, we can easily locate the bucket-index of any number in the array by `(num-min)/gap` and also simply let's get the answer of the size of the bucket `(max-min)/(size-1)+1` but how to get the size exactly? We still have no clue.\\n4. normally the average distance between two numbers should be `(max-min)/(size-1)` but the maximal difference here must be no less than that (why?  Just imagine if the max difference is less than the average, how come the average is so big here?) as we have discussed in 2, the maximal difference within a bucket will be `gap-1` (take the first range [min, min+gap) for an example, then the min+gap-1-min = gap-1 is the difference within the bucket) so here we should set the size of bucket as `(max-min)/(size-1)+1` to split the array then the maximal difference within a bucket will be `(max-min)/(size-1)` but when we can divide (max-min) completely by (size-1), the case will be different? \\n\\n> Take an example to make it easier here:\\n[1, 2, 3, 4, 21] so max = 21, min = 1, size = 5 => (max-min)/(size-1)+1 = 20/4+1 = 6\\nso as a result the ranges of buckets are [1, 7), [7, 13), [13, 19), [19, 25) \\n> - the maximal difference within a bucket now is 5, which is the average distance and we have discussed it already\\n> - all the numbers in the array are covered including the min and max\\n> - even when the array is [1, 6, 11, 16, 21] the maximal difference still can be retrieved from different buckets here.\\n\\nWhen we can not completely divide (max-min) by (size-1) and there is remainder, the case will be still the same and even clearer.\\n\\n5. since we get the most tricky part done then let's just solve it step by step; remember we are going to retrieve the maximal difference from different buckets? So we only need to record the min and max of the bucket instead of all the numbers inside here;\\n6. after filling up the buckets, we now can retrieve the maximal from the first till the end.\\n\\nThe final solution in C++ is as follows, of course the best submission here, since it's hard to read all the things above. Enjoy now...\\n\\n```\\nint maximumGap(vector<int>& nums) \\n{\\n    int size = nums.size();\\n    if(size < 1) return 0;\\n    if(size == 2) return abs(nums[1]-nums[0]);\\n    int minNum = INT_MAX, maxNum = INT_MIN;\\n    for(int i = 0; i < size; ++i) minNum = min(minNum, nums[i]), maxNum = max(maxNum, nums[i]);\\n    if(minNum == maxNum) return 0;\\n    int gap = (maxNum-minNum)/(size-1)+1;\\n    int mins[size], maxs[size]{0};\\n    for(int i = 0; i < size; ++i) mins[i] = -1;\\n    for(int i = 0; i < size; ++i)\\n    {\\n        int k = (nums[i]-minNum)/gap;\\n        if(mins[k] == -1) mins[k] = nums[i];\\n        else mins[k] = min(mins[k], nums[i]);\\n        maxs[k] = max(maxs[k], nums[i]);\\n    }\\n    int start = maxs[0], end = mins[0];\\n    int maxGap = start-end;\\n    for(int i = 1; i < size; ++i)\\n    {\\n        if(mins[i] != -1)\\n        {\\n            maxGap = max(maxGap, mins[i]-start);\\n            start = maxs[i];\\n        }\\n    }\\n    return maxGap;\\n}\\n```\\n\\nAlways welcome new ideas and `practical` tricks, just leave them in the comments!",
                "solutionTags": [],
                "code": "```\\nint maximumGap(vector<int>& nums) \\n{\\n\\tint size = nums.size();\\n\\tif(size < 2) return 0;\\n\\tif(size == 2) return abs(nums[1]-nums[0]);\\n\\tint maxDiff = 0;\\n\\tsort(nums.begin(), nums.end());\\n\\tfor(int i = 0; i < size-1; ++i)\\n\\t\\tmaxDiff = max(maxDiff, nums[i+1]-nums[i]);\\n\\treturn maxDiff;\\n}\\n```\n```\\nint maximumGap(vector<int>& nums) \\n{\\n    int size = nums.size();\\n    if(size < 1) return 0;\\n    if(size == 2) return abs(nums[1]-nums[0]);\\n    int minNum = INT_MAX, maxNum = INT_MIN;\\n    for(int i = 0; i < size; ++i) minNum = min(minNum, nums[i]), maxNum = max(maxNum, nums[i]);\\n    if(minNum == maxNum) return 0;\\n    int gap = (maxNum-minNum)/(size-1)+1;\\n    int mins[size], maxs[size]{0};\\n    for(int i = 0; i < size; ++i) mins[i] = -1;\\n    for(int i = 0; i < size; ++i)\\n    {\\n        int k = (nums[i]-minNum)/gap;\\n        if(mins[k] == -1) mins[k] = nums[i];\\n        else mins[k] = min(mins[k], nums[i]);\\n        maxs[k] = max(maxs[k], nums[i]);\\n    }\\n    int start = maxs[0], end = mins[0];\\n    int maxGap = start-end;\\n    for(int i = 1; i < size; ++i)\\n    {\\n        if(mins[i] != -1)\\n        {\\n            maxGap = max(maxGap, mins[i]-start);\\n            start = maxs[i];\\n        }\\n    }\\n    return maxGap;\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3616338,
                "title": "python3-code-runtime-beats-92-32-memory-beats-65-96",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution:\\n    def maximumGap(self, nums: List[int]) -> int:\\n        nums=sorted(nums)\\n        min=float(\"-inf\")\\n        if len(nums)<2:\\n            return 0\\n        for i in range(len(nums)-1):\\n            x=abs(nums[i]-nums[i+1])\\n            if min<x:\\n                min=x\\n        return min\\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def maximumGap(self, nums: List[int]) -> int:\\n        nums=sorted(nums)\\n        min=float(\"-inf\")\\n        if len(nums)<2:\\n            return 0\\n        for i in range(len(nums)-1):\\n            x=abs(nums[i]-nums[i+1])\\n            if min<x:\\n                min=x\\n        return min\\n```",
                "codeTag": "Java"
            },
            {
                "id": 50690,
                "title": "clean-c-implementation-of-3-linear-time-sort-alg-with-detailed-explaination",
                "content": "As we can see, we should grasp all the 3 typical linear-time-sorting algorithm implementation. \\nAll the following 3 implementations have been modified from the GeeksForGeeks.\\nI have change the counting sort implementation to support negative numbers.\\nAnd the bucket support any float array input.\\n\\n> counting sort    [ stable ]       [ support:+/- intergers ]\\n> \\n> radix sort        [ use counting sort as sub-routine]   [ support only\\n> positive intergers]\\n> \\n> bucket sort     [support float : we need to change the array to in the\\n> range [0, 1)  ]\\n\\n\\n    #include <iostream>\\n    #include <vector>\\n    #include <algorithm>\\n    using namespace std;\\n    \\n\\n>     /* counting sort  Time O(N)  Space O(N+range) */\\n>     /* \\n>        support : positive / negative arrays\\n>        the last travese the array X : \\n>              FORWARD->not stable  \\n>     \\t\\t BACKWARD->stable\\n>     */\\n\\n    void countingSort(vector<int>& X){\\n    \\tint len = X.size();\\n    \\tint start = INT_MAX, end = INT_MIN;\\n    \\tfor (int i = 0; i < len; i++){\\n    \\t\\tstart = min(start, X[i]);\\n    \\t\\tend = max(end, X[i]);\\n    \\t}\\n    \\tint range = end - start + 1;\\n    \\tvector<int> count(range, 0);\\n    \\tvector<int> result(len, 0);\\n    \\tfor (int i = 0; i < len; i++){\\n    \\t\\tcount[X[i]-start]++;\\n    \\t}\\n    \\tfor (int i = 1; i < range; i++){\\n    \\t\\tcount[i]=count[i-1]+count[i];\\n    \\t}\\n    \\t//for-ward traverse is not stable sorting\\n    \\t//for (int i = 0; i < len; i++)\\n    \\t//back-ward traverse is stable sorting\\n    \\tfor (int i = len-1; i >= 0; i--){\\n    \\t\\t//as we know that the count array recorded element should '-1' to get the index\\n    \\t\\tresult[count[X[i] - start]-1] = X[i];\\n    \\t\\tcount[X[i] - start]--;\\n    \\t}\\n    \\tfor (int i = 0; i < len; i++){\\n    \\t\\tX[i] = result[i];\\n    \\t}\\n    }\\n    \\n    \\n    \\n\\n>     /* Radix sort  Time O(log(base,MAX)*(N+base))  Space O(constant)  default:base=10 */\\n>     /* \\n>        support : only positive interger \\n>        can only deal with positive integers or change the float number \\n>        of the specified precision to intergers by multiplying 10^n \\n>     */\\n\\n    \\n    void countingSort(vector<int>& X, int exp, int base){\\n    \\tint len = X.size();\\n    \\tint start = INT_MAX, end = INT_MIN;\\n    \\tfor (int i = 0; i < len; i++){\\n    \\t\\tstart = min(start, (X[i] / exp)%base);\\n    \\t\\tend = max(end, (X[i] / exp) % base);\\n    \\t}\\n    \\tint range = end - start + 1;\\n    \\tvector<int> count(range, 0);\\n    \\tvector<int> result(len, 0);\\n    \\tfor (int i = 0; i < len; i++){\\n    \\t\\tcount[(X[i] / exp) % base -start]++;\\n    \\t}\\n    \\tfor (int i = 1; i < range; i++){\\n    \\t\\tcount[i] = count[i - 1] + count[i];\\n    \\t}\\n    \\t//back-ward traverse is stable sorting\\n    \\tfor (int i = len - 1; i >= 0; i--){\\n    \\t\\t//as we know that the count array recorded element should '-1' to get the index\\n    \\t\\tresult[count[(X[i] / exp) % base -start] - 1] = X[i];\\n    \\t\\tcount[(X[i] / exp) % base - start]--;\\n    \\t}\\n    \\tfor (int i = 0; i < len; i++){\\n    \\t\\tX[i] = result[i];\\n    \\t}\\n    }\\n    \\n    void radixSort(vector<int> &X){\\n    \\tint len = X.size();\\n    \\tint max_val = INT_MIN;\\n    \\tint base = 10;\\n    \\tfor (int i = 0; i < len; i++) max_val = max(X[i], max_val);\\n    \\tfor (int exp = 1; max_val / exp>0; exp *= base){\\n    \\t\\tcountingSort(X, exp, base);\\n    \\t}\\n    }\\n    \\n    \\n\\n>     /* bubble sort  Time   Space */\\n>     /*\\n>       support : any float & int numbers\\n>       sort a large set of floating nubmers in range from 0.0 to 1.0\\n>       uniformly distributed across the range \\n>       the key idea is : \\n>             the insertion sort for all individual bucket is O(N)\\n>     */\\n\\n    void bucketSort(vector<float>& X){\\n    \\tint len = X.size();\\n    \\tfloat max_val = X[0], min_val = X[0];;\\n    \\tfor (int i = 1; i < len; i++) {\\n    \\t\\tmax_val = max(max_val, X[i]);\\n    \\t\\tmin_val = min(min_val, X[i]);\\n    \\t}\\n    \\tmax_val++;\\n    \\n    \\tvector<vector<float>> bucket(len, vector<float>());\\n    \\tfor (int i = 0; i < len; i++){\\n    \\t\\tint index = len*(X[i]-min_val)/(max_val-min_val);\\n    \\t\\tbucket[index].push_back(X[i]);\\n    \\t}\\n    \\n    \\tfor (int i = 0; i < len; i++)\\tsort(bucket[i].begin(), bucket[i].end());\\n    \\n    \\tint index = 0;\\n    \\tfor (int i = 0; i < len; i++)\\n    \\t\\tfor (int j = 0; j < bucket[i].size(); j++)\\n    \\t\\t\\tX[index++] = bucket[i][j];\\n    }\\n    \\n\\n>  /*   test all the 3-linear-sorting-implementation  */\\n\\n    int main(){\\n    \\tvector<int> test1 = { 11, -200, 14, -2000, 30, 400, 10, 22, 456 };\\n    \\tcountingSort(test1);\\n    \\tcout << endl<<\"counting Sort result: \";\\n    \\tfor (int i = 0; i < test1.size(); i++)\\t cout << test1[i] <<\" - \";\\n    \\tvector<int> test2 = { 11, 200, 14, 2000, 30, 400, 10, 22, 456 };\\n    \\tradixSort(test2);\\n    \\tcout << endl << \"radix Sort result: \";\\n    \\tfor (int i = 0; i < test2.size(); i++)\\t cout << test2[i] << \" - \";\\n    \\tvector<float> test3 = { 11, -200, 14, -2000, 30, 400, 10, 22, 456 };\\n    \\tbucketSort(test3);\\t\\n    \\tcout << endl << \"bucket Sort result: \";\\n    \\tfor (int i = 0; i < test3.size(); i++)\\t cout << test3[i] << \" - \";\\n    \\treturn 0;\\n    }",
                "solutionTags": [],
                "code": "As we can see, we should grasp all the 3 typical linear-time-sorting algorithm implementation. \\nAll the following 3 implementations have been modified from the GeeksForGeeks.\\nI have change the counting sort implementation to support negative numbers.\\nAnd the bucket support any float array input.\\n\\n> counting sort    [ stable ]       [ support:+/- intergers ]\\n> \\n> radix sort        [ use counting sort as sub-routine]   [ support only\\n> positive intergers]\\n> \\n> bucket sort     [support float : we need to change the array to in the\\n> range [0, 1)  ]\\n\\n\\n    #include <iostream>\\n    #include <vector>\\n    #include <algorithm>\\n    using namespace std;\\n    \\n\\n>     /* counting sort  Time O(N)  Space O(N+range) */\\n>     /* \\n>        support : positive / negative arrays\\n>        the last travese the array X : \\n>              FORWARD->not stable  \\n>     \\t\\t BACKWARD->stable\\n>     */\\n\\n    void countingSort(vector<int>& X){\\n    \\tint len = X.size();\\n    \\tint start = INT_MAX, end = INT_MIN;\\n    \\tfor (int i = 0; i < len; i++){\\n    \\t\\tstart = min(start, X[i]);\\n    \\t\\tend = max(end, X[i]);\\n    \\t}\\n    \\tint range = end - start + 1;\\n    \\tvector<int> count(range, 0);\\n    \\tvector<int> result(len, 0);\\n    \\tfor (int i = 0; i < len; i++){\\n    \\t\\tcount[X[i]-start]++;\\n    \\t}\\n    \\tfor (int i = 1; i < range; i++){\\n    \\t\\tcount[i]=count[i-1]+count[i];\\n    \\t}\\n    \\t//for-ward traverse is not stable sorting\\n    \\t//for (int i = 0; i < len; i++)\\n    \\t//back-ward traverse is stable sorting\\n    \\tfor (int i = len-1; i >= 0; i--){\\n    \\t\\t//as we know that the count array recorded element should '-1' to get the index\\n    \\t\\tresult[count[X[i] - start]-1] = X[i];\\n    \\t\\tcount[X[i] - start]--;\\n    \\t}\\n    \\tfor (int i = 0; i < len; i++){\\n    \\t\\tX[i] = result[i];\\n    \\t}\\n    }\\n    \\n    \\n    \\n\\n>     /* Radix sort  Time O(log(base,MAX)*(N+base))  Space O(constant)  default:base=10 */\\n>     /* \\n>        support : only positive interger \\n>        can only deal with positive integers or change the float number \\n>        of the specified precision to intergers by multiplying 10^n \\n>     */\\n\\n    \\n    void countingSort(vector<int>& X, int exp, int base){\\n    \\tint len = X.size();\\n    \\tint start = INT_MAX, end = INT_MIN;\\n    \\tfor (int i = 0; i < len; i++){\\n    \\t\\tstart = min(start, (X[i] / exp)%base);\\n    \\t\\tend = max(end, (X[i] / exp) % base);\\n    \\t}\\n    \\tint range = end - start + 1;\\n    \\tvector<int> count(range, 0);\\n    \\tvector<int> result(len, 0);\\n    \\tfor (int i = 0; i < len; i++){\\n    \\t\\tcount[(X[i] / exp) % base -start]++;\\n    \\t}\\n    \\tfor (int i = 1; i < range; i++){\\n    \\t\\tcount[i] = count[i - 1] + count[i];\\n    \\t}\\n    \\t//back-ward traverse is stable sorting\\n    \\tfor (int i = len - 1; i >= 0; i--){\\n    \\t\\t//as we know that the count array recorded element should '-1' to get the index\\n    \\t\\tresult[count[(X[i] / exp) % base -start] - 1] = X[i];\\n    \\t\\tcount[(X[i] / exp) % base - start]--;\\n    \\t}\\n    \\tfor (int i = 0; i < len; i++){\\n    \\t\\tX[i] = result[i];\\n    \\t}\\n    }\\n    \\n    void radixSort(vector<int> &X){\\n    \\tint len = X.size();\\n    \\tint max_val = INT_MIN;\\n    \\tint base = 10;\\n    \\tfor (int i = 0; i < len; i++) max_val = max(X[i], max_val);\\n    \\tfor (int exp = 1; max_val / exp>0; exp *= base){\\n    \\t\\tcountingSort(X, exp, base);\\n    \\t}\\n    }\\n    \\n    \\n\\n>     /* bubble sort  Time   Space */\\n>     /*\\n>       support : any float & int numbers\\n>       sort a large set of floating nubmers in range from 0.0 to 1.0\\n>       uniformly distributed across the range \\n>       the key idea is : \\n>             the insertion sort for all individual bucket is O(N)\\n>     */\\n\\n    void bucketSort(vector<float>& X){\\n    \\tint len = X.size();\\n    \\tfloat max_val = X[0], min_val = X[0];;\\n    \\tfor (int i = 1; i < len; i++) {\\n    \\t\\tmax_val = max(max_val, X[i]);\\n    \\t\\tmin_val = min(min_val, X[i]);\\n    \\t}\\n    \\tmax_val++;\\n    \\n    \\tvector<vector<float>> bucket(len, vector<float>());\\n    \\tfor (int i = 0; i < len; i++){\\n    \\t\\tint index = len*(X[i]-min_val)/(max_val-min_val);\\n    \\t\\tbucket[index].push_back(X[i]);\\n    \\t}\\n    \\n    \\tfor (int i = 0; i < len; i++)\\tsort(bucket[i].begin(), bucket[i].end());\\n    \\n    \\tint index = 0;\\n    \\tfor (int i = 0; i < len; i++)\\n    \\t\\tfor (int j = 0; j < bucket[i].size(); j++)\\n    \\t\\t\\tX[index++] = bucket[i][j];\\n    }\\n    \\n\\n>  /*   test all the 3-linear-sorting-implementation  */\\n\\n    int main(){\\n    \\tvector<int> test1 = { 11, -200, 14, -2000, 30, 400, 10, 22, 456 };\\n    \\tcountingSort(test1);\\n    \\tcout << endl<<\"counting Sort result: \";\\n    \\tfor (int i = 0; i < test1.size(); i++)\\t cout << test1[i] <<\" - \";\\n    \\tvector<int> test2 = { 11, 200, 14, 2000, 30, 400, 10, 22, 456 };\\n    \\tradixSort(test2);\\n    \\tcout << endl << \"radix Sort result: \";\\n    \\tfor (int i = 0; i < test2.size(); i++)\\t cout << test2[i] << \" - \";\\n    \\tvector<float> test3 = { 11, -200, 14, -2000, 30, 400, 10, 22, 456 };\\n    \\tbucketSort(test3);\\t\\n    \\tcout << endl << \"bucket Sort result: \";\\n    \\tfor (int i = 0; i < test3.size(); i++)\\t cout << test3[i] << \" - \";\\n    \\treturn 0;\\n    }",
                "codeTag": "C++"
            },
            {
                "id": 50724,
                "title": "my-concise-and-short-c-code-with-comment-explanation",
                "content": "    int maximumGap(vector<int>& nums) {\\n        int n = nums.size();\\n        if( n < 2 ) return 0;\\n        int maxE = *max_element(nums.begin(),nums.end());\\n        int minE = *min_element(nums.begin(),nums.end());\\n        \\n        int len = maxE - minE;\\n        if( len <= 1 ) return len;\\n        vector<int> buck_max(n, INT_MIN);\\n        vector<int> buck_min(n, INT_MAX);\\n        \\n        for(int i = 0; i < n; i++) {\\n            // note the divide and multiply order and the double cast\\n            // it's used to avoid the overflow and underflow during calculation\\n            int index = (double)( nums[i] - minE )  / len * ( n - 1 );\\n            buck_max[index] = max(buck_max[index], nums[i]);\\n            buck_min[index] = min(buck_min[index], nums[i]);\\n        }\\n        \\n        int gap = 0, pre = buck_max[0];\\n        for(int i = 1; i < n; i++) {\\n            if( buck_max[i] == INT_MIN ) continue;\\n            gap = max(gap, buck_min[i] - pre);\\n            pre = buck_max[i];\\n        }\\n        return gap;\\n    }",
                "solutionTags": [
                    "Sorting"
                ],
                "code": "    int maximumGap(vector<int>& nums) {\\n        int n = nums.size();\\n        if( n < 2 ) return 0;\\n        int maxE = *max_element(nums.begin(),nums.end());\\n        int minE = *min_element(nums.begin(),nums.end());\\n        \\n        int len = maxE - minE;\\n        if( len <= 1 ) return len;\\n        vector<int> buck_max(n, INT_MIN);\\n        vector<int> buck_min(n, INT_MAX);\\n        \\n        for(int i = 0; i < n; i++) {\\n            // note the divide and multiply order and the double cast\\n            // it's used to avoid the overflow and underflow during calculation\\n            int index = (double)( nums[i] - minE )  / len * ( n - 1 );\\n            buck_max[index] = max(buck_max[index], nums[i]);\\n            buck_min[index] = min(buck_min[index], nums[i]);\\n        }\\n        \\n        int gap = 0, pre = buck_max[0];\\n        for(int i = 1; i < n; i++) {\\n            if( buck_max[i] == INT_MIN ) continue;\\n            gap = max(gap, buck_min[i] - pre);\\n            pre = buck_max[i];\\n        }\\n        return gap;\\n    }",
                "codeTag": "Unknown"
            },
            {
                "id": 1663928,
                "title": "c-linear-time-space-using-buckets-w-explanation",
                "content": "```\\nclass Solution {\\npublic:\\n    int maximumGap(vector<int>& nums) {\\n        if(nums.size()<2) return 0;\\n        \\n        int maxi = -1, mini = INT_MAX, n = nums.size();\\n        for(auto u : nums) maxi = max(maxi,u), mini = min(mini,u);\\n        // Since there will be n-1 gaps in between the numbers, this will be the average gap between\\n        // any two numbers in the array.\\n        // NOTE : Its very important to take the upper value of average gap, or else we will have a runtime error\\n        // in the index of bucket that we will find in the next step.\\n        int avg_gap = (int)ceil((double)(maxi-mini)/(n-1));\\n        // To handle cases where all the elements are same!!!\\n        if(avg_gap == 0) return 0;      \\n        /*\\n        Now, we can allot all the numbers a bucket, by dividing them with this average gap. Now it \\n        can be easily observed that by dividing any numbers with this average gap, it is sure to fall \\n        in one of the (n-1) buckets that will be formed. \\n        Taking the example 1, \\n                \\n                [3, 6, 9, 1]      =>    avg gap = ceil[(9-1)/3] ~= 3\\n        Now we have to find the maximum gap, therefore, it will be >= average gap.\\n        Alloting the buckets : [[arr[i]-min]/average_gap], for all numbers of the array, this formula will result\\n                               in numbers that lie in a range, and thus the result for each can be considered as \\n                               the bucket index.\\n                               \\n                [3-1]/3 = 0\\n                [6-1]/3 = 1\\n                [9-1]/3 = 2\\n                [1-1]/3 = 0\\n            \\n              0        1      2\\n            1___3    ____6  ____9\\n            \\n            Now as we said, the maximum gap will be greater than or equal to the average gap, therefore, the answer\\n            will not lie within a bucket because its gap between the maximum and minimum element will always be\\n            less than the average gap, for reference, consider in bucket 2nd, we had the bucket fully filled, then\\n            in that case, we would have 4 as the minimum and 6 as maximum and there difference be 2. So, even in \\n            worst case, we have a difference 1 less than the average. So, for the question, we only need to check\\n            in between the buckets. Thus we only compare the difference between the maximum of one bucket and \\n            minimum of next.\\n        */\\n        \\n        // Allocating the buckets and storing the maximum and minimum of each bucket \\n        vector <int> bucket_max(n,-1), bucket_min(n,INT_MAX);\\n        for(int i = 0; i<n; i++){\\n            int index = (nums[i]-mini)/avg_gap;\\n            bucket_min[index] = min(bucket_min[index],nums[i]);\\n            bucket_max[index] = max(bucket_max[index],nums[i]);\\n        }\\n        \\n        // After filling the min and max arrays, we just need to compare...\\n        int prev = mini, ans = 0;\\n        for(int i = 0; i<bucket_min.size(); i++){\\n            if(bucket_max[i] == -1) continue;\\n            ans = max(ans,bucket_min[i]-prev);\\n            prev = bucket_max[i];\\n        }\\n        // We need to compare with the last element which is maximum...\\n        ans = max(ans,maxi-prev);\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int maximumGap(vector<int>& nums) {\\n        if(nums.size()<2) return 0;\\n        \\n        int maxi = -1, mini = INT_MAX, n = nums.size();\\n        for(auto u : nums) maxi = max(maxi,u), mini = min(mini,u);\\n        // Since there will be n-1 gaps in between the numbers, this will be the average gap between\\n        // any two numbers in the array.\\n        // NOTE : Its very important to take the upper value of average gap, or else we will have a runtime error\\n        // in the index of bucket that we will find in the next step.\\n        int avg_gap = (int)ceil((double)(maxi-mini)/(n-1));\\n        // To handle cases where all the elements are same!!!\\n        if(avg_gap == 0) return 0;      \\n        /*\\n        Now, we can allot all the numbers a bucket, by dividing them with this average gap. Now it \\n        can be easily observed that by dividing any numbers with this average gap, it is sure to fall \\n        in one of the (n-1) buckets that will be formed. \\n        Taking the example 1, \\n                \\n                [3, 6, 9, 1]      =>    avg gap = ceil[(9-1)/3] ~= 3\\n        Now we have to find the maximum gap, therefore, it will be >= average gap.\\n        Alloting the buckets : [[arr[i]-min]/average_gap], for all numbers of the array, this formula will result\\n                               in numbers that lie in a range, and thus the result for each can be considered as \\n                               the bucket index.\\n                               \\n                [3-1]/3 = 0\\n                [6-1]/3 = 1\\n                [9-1]/3 = 2\\n                [1-1]/3 = 0\\n            \\n              0        1      2\\n            1___3    ____6  ____9\\n            \\n            Now as we said, the maximum gap will be greater than or equal to the average gap, therefore, the answer\\n            will not lie within a bucket because its gap between the maximum and minimum element will always be\\n            less than the average gap, for reference, consider in bucket 2nd, we had the bucket fully filled, then\\n            in that case, we would have 4 as the minimum and 6 as maximum and there difference be 2. So, even in \\n            worst case, we have a difference 1 less than the average. So, for the question, we only need to check\\n            in between the buckets. Thus we only compare the difference between the maximum of one bucket and \\n            minimum of next.\\n        */\\n        \\n        // Allocating the buckets and storing the maximum and minimum of each bucket \\n        vector <int> bucket_max(n,-1), bucket_min(n,INT_MAX);\\n        for(int i = 0; i<n; i++){\\n            int index = (nums[i]-mini)/avg_gap;\\n            bucket_min[index] = min(bucket_min[index],nums[i]);\\n            bucket_max[index] = max(bucket_max[index],nums[i]);\\n        }\\n        \\n        // After filling the min and max arrays, we just need to compare...\\n        int prev = mini, ans = 0;\\n        for(int i = 0; i<bucket_min.size(); i++){\\n            if(bucket_max[i] == -1) continue;\\n            ans = max(ans,bucket_min[i]-prev);\\n            prev = bucket_max[i];\\n        }\\n        // We need to compare with the last element which is maximum...\\n        ans = max(ans,maxi-prev);\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1038791,
                "title": "bucket-sort-solution-in-golang-with-explanation",
                "content": "Sort the whole array is unnecessary, we just need for loop the whole array and group  a set of elements in a way that elements in the same group are more similar (close value) to each other than to those in other groups, yeah, a bit like clustering, bucket sort can solve kind of this problem. \\n\\nAfter clustering, we will have many groups(called buckets), we store two elements in each bucket(the max one and the min one) because all elements in same bucket have close value, so the max gap is ```minValue(current bucket) - maxValue(previous bucket)```\\n\\nLet me explain more with some examples\\n\\n**NOTICE**: *In order to explain more clearly(IMHO), I made some fake data and screenshots to demonstrate how I think about this problem, that means data and screenshot may not compatible and appeared in real.*\\n\\nFor example, we have a array like this ```array = [1,2,9,3,10]```,  assume we have two bucket: ```bucketA``` and ```bucketB```, we retrieve each elements of array and put them into bucktes, because ```1,2,3``` are close value, so put they three into ```bucketA```, put ```9,10``` into ```bucketB```:\\n\\n![image](https://assets.leetcode.com/users/images/fde4e091-d920-4dc7-a542-9172028ca74c_1611821091.3885255.png)\\n\\n\\n\\t\\nIt is obviously: ```maxGap =  bucketB.min - bucketA.max```, and also,  you may see that ```2``` in ```bucketA``` is unnecessary, so we dont store it in code, each bucket has only ```2``` elements: the min one and the max one\\n\\nWell, now, the question is how to clustering these elements ?\\n\\nThe ```average gap``` between two element should be ```(array.Max - array.Min) / (array.Size - 1)``` , the max gap here must bigger than that.\\n\\nLet\\'s calculate the ```average gap``` in ```array ([1,2,9,3,10])``` above:\\n ```gap = ((2-1) + (9-2) + (3-9) + (10-3)) / (array.Size - 1)```\\n  ```gap = (1+7-6+7) / 4```\\n  ```gap = 9 / 4 = 2.25```\\n well, it is equal to```(10 - 1) / 4 = 2.25``` , so if the gap between two element is bigger than ```2.25```,  it makes itself possible to be the final, maxGap.\\n\\n\\nHere are buckets we initialized, by default they have default values respecitively:\\n![image](https://assets.leetcode.com/users/images/e1eb8e14-2c60-46cd-b93a-26dd4b674b16_1611826566.7701204.png)\\n\\n\\n\\n\\n\\n  \\n```idx``` is the index of buckets we should put elements into. ```idx := (array.element - min) / gap```\\n\\nHow many buckets I used ?  \\n```numOfBuckets = array.Size - 1```\\n\\nAssume, our buckets are looks like this:\\n![image](https://assets.leetcode.com/users/images/be4db3a6-c46b-4151-98fc-1378f5ae8c0a_1611825060.9715645.png)\\n\\n\\n\\n```Max``` is the result.\\n\\nOk, my english is not good, let see the final solution in Golang is as follows\\n```\\n\\nfunc maximumGap(nums []int) int {\\n\\n\\tsize := len(nums)\\n\\n\\tif 2 == size {\\n\\t\\treturn int(math.Abs(float64(nums[0] - nums[1])))\\n\\t}\\n\\n\\tif size < 2 {\\n\\t\\treturn 0\\n\\t}\\n\\n\\t// retrieve min and max of array\\n\\tmin, max := nums[0], nums[0]\\n\\n\\tfor i := 1; i < size; i++ {\\n\\t\\tif nums[i] > max {\\n\\t\\t\\tmax = nums[i]\\n\\t\\t} else if nums[i] < min {\\n\\t\\t\\tmin = nums[i]\\n\\t\\t}\\n\\t}\\n\\n\\t// equal elements\\n\\tif min == max {\\n\\t\\treturn 0\\n\\t}\\n\\n\\tgap := int(float64((max - min) / (size - 1))) + 1\\n\\tcapacity := size - 1\\n\\n\\tbucketMIN := make([]int, capacity)\\n\\tbucketMAX := make([]int, capacity)\\n\\n\\tfor i := 0; i < capacity; i++ {\\n\\t\\tbucketMIN[i] = math.MaxInt64\\n\\t\\tbucketMAX[i] = math.MinInt64\\n\\t}\\n\\n\\t// buckets become\\n\\t// bucketMIN = { MaxInt64, MaxInt64, MaxInt64, ...}\\n\\t// bucketMAX = { MinInt64, MinInt64, MinInt64, ...}\\n\\n\\t// put nums into buckets respectively\\n\\tfor i := 0; i < size; i++ {\\n\\n\\t\\tnum := nums[i]\\n\\n\\t\\tif num == max || num == min {\\n\\t\\t\\tcontinue\\n\\t\\t}\\n\\n\\t\\t// index of buckets\\n\\t\\tidx := (num - min) / gap\\n\\n\\t\\tbucketMIN[idx] = int(math.Min(float64(num), float64(bucketMIN[idx])))\\n\\t\\tbucketMAX[idx] = int(math.Max(float64(num), float64(bucketMAX[idx])))\\n\\t}\\n\\n\\tmaxGap := math.MinInt64\\n\\tprev := min\\n\\n\\tfor i := 0; i < capacity; i++ {\\n\\n\\t\\tif bucketMIN[i] == math.MaxInt64 &&\\n\\t\\t\\tbucketMAX[i] == math.MinInt64 {\\n\\n\\t\\t\\t// empty bucket\\n\\t\\t\\tcontinue\\n\\t\\t}\\n\\n\\t\\tmaxGap = int(math.Max(float64(maxGap), float64(bucketMIN[i] - prev)))\\n\\t\\tprev = bucketMAX[i]\\n\\t}\\n\\n\\tmaxGap = int(math.Max(float64(maxGap), float64(max - prev)))\\n\\treturn maxGap\\n}\\n\\n```\\n\\nLeetcode says:\\n```\\nRuntime: 4 ms, faster than 95.83% of Go online submissions for Maximum Gap.\\nMemory Usage: 3.7 MB, less than 25.00% of Go online submissions for Maximum Gap.\\n```\\n\\nThanks for reading.\\n\\n\\n\\n",
                "solutionTags": [
                    "Go"
                ],
                "code": "```minValue(current bucket) - maxValue(previous bucket)```\n```array = [1,2,9,3,10]```\n```bucketA```\n```bucketB```\n```1,2,3```\n```bucketA```\n```9,10```\n```bucketB```\n```maxGap =  bucketB.min - bucketA.max```\n```2```\n```bucketA```\n```2```\n```average gap```\n```(array.Max - array.Min) / (array.Size - 1)```\n```average gap```\n```array ([1,2,9,3,10])```\n```gap = ((2-1) + (9-2) + (3-9) + (10-3)) / (array.Size - 1)```\n```gap = (1+7-6+7) / 4```\n```gap = 9 / 4 = 2.25```\n```(10 - 1) / 4 = 2.25```\n```2.25```\n```idx```\n```idx := (array.element - min) / gap```\n```numOfBuckets = array.Size - 1```\n```Max```\n```\\n\\nfunc maximumGap(nums []int) int {\\n\\n\\tsize := len(nums)\\n\\n\\tif 2 == size {\\n\\t\\treturn int(math.Abs(float64(nums[0] - nums[1])))\\n\\t}\\n\\n\\tif size < 2 {\\n\\t\\treturn 0\\n\\t}\\n\\n\\t// retrieve min and max of array\\n\\tmin, max := nums[0], nums[0]\\n\\n\\tfor i := 1; i < size; i++ {\\n\\t\\tif nums[i] > max {\\n\\t\\t\\tmax = nums[i]\\n\\t\\t} else if nums[i] < min {\\n\\t\\t\\tmin = nums[i]\\n\\t\\t}\\n\\t}\\n\\n\\t// equal elements\\n\\tif min == max {\\n\\t\\treturn 0\\n\\t}\\n\\n\\tgap := int(float64((max - min) / (size - 1))) + 1\\n\\tcapacity := size - 1\\n\\n\\tbucketMIN := make([]int, capacity)\\n\\tbucketMAX := make([]int, capacity)\\n\\n\\tfor i := 0; i < capacity; i++ {\\n\\t\\tbucketMIN[i] = math.MaxInt64\\n\\t\\tbucketMAX[i] = math.MinInt64\\n\\t}\\n\\n\\t// buckets become\\n\\t// bucketMIN = { MaxInt64, MaxInt64, MaxInt64, ...}\\n\\t// bucketMAX = { MinInt64, MinInt64, MinInt64, ...}\\n\\n\\t// put nums into buckets respectively\\n\\tfor i := 0; i < size; i++ {\\n\\n\\t\\tnum := nums[i]\\n\\n\\t\\tif num == max || num == min {\\n\\t\\t\\tcontinue\\n\\t\\t}\\n\\n\\t\\t// index of buckets\\n\\t\\tidx := (num - min) / gap\\n\\n\\t\\tbucketMIN[idx] = int(math.Min(float64(num), float64(bucketMIN[idx])))\\n\\t\\tbucketMAX[idx] = int(math.Max(float64(num), float64(bucketMAX[idx])))\\n\\t}\\n\\n\\tmaxGap := math.MinInt64\\n\\tprev := min\\n\\n\\tfor i := 0; i < capacity; i++ {\\n\\n\\t\\tif bucketMIN[i] == math.MaxInt64 &&\\n\\t\\t\\tbucketMAX[i] == math.MinInt64 {\\n\\n\\t\\t\\t// empty bucket\\n\\t\\t\\tcontinue\\n\\t\\t}\\n\\n\\t\\tmaxGap = int(math.Max(float64(maxGap), float64(bucketMIN[i] - prev)))\\n\\t\\tprev = bucketMAX[i]\\n\\t}\\n\\n\\tmaxGap = int(math.Max(float64(maxGap), float64(max - prev)))\\n\\treturn maxGap\\n}\\n\\n```\n```\\nRuntime: 4 ms, faster than 95.83% of Go online submissions for Maximum Gap.\\nMemory Usage: 3.7 MB, less than 25.00% of Go online submissions for Maximum Gap.\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 50649,
                "title": "simple-radix-sort-solution-in-python",
                "content": "    class Solution:\\n        # @param {integer[]} nums\\n        # @return {integer}\\n        def radixSort(self, A): \\n            for k in xrange(10):     \\n                s=[[] for i in xrange(10)]\\n                for i in A:\\n                    s[i/(10**k)%10].append(i)\\n                A=[a for b in s for a in b] \\n            return A\\n        \\n        def maximumGap(self, nums): \\n            A = self.radixSort(nums)\\n            ans = 0\\n            if len(A) == 0: return 0\\n            prev = A[0]\\n            for i in A:\\n                if i - prev > ans: ans = i - prev\\n                prev = i\\n            return ans",
                "solutionTags": [],
                "code": "class Solution:\\n        # @param {integer[]}",
                "codeTag": "Java"
            },
            {
                "id": 3908856,
                "title": "java-python3-explanation-code-brute-force-optimized-approach-bukcet-sort",
                "content": "# Brute Force\\n# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nJust sort the array and check the pair of two adjacent elements having the maximum gap in the array.\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\nStep 1: Sort the array\\nStep 2: Traverse the loop in the reverse order and compare the difference between the last and its previous element.\\nStep 3: Replace the value max if value exceeds.\\nStep 4: Return the max difference.\\n# Complexity\\n- Time complexity: O(nlogn)\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: O(1)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n\\n\\n```Java []\\nclass Solution {\\n    public int maximumGap(int[] nums) {\\n        if(nums.length < 2)return 0;\\n        Arrays.sort(nums);\\n        int maxDiff = 0;\\n        for(int i=0;i<nums.length-1;i++){\\n            maxDiff = Math.max(maxDiff, nums[i+1] - nums[i]);\\n        }\\n        return maxDiff;\\n    }\\n}\\n```\\n```python3 []\\nclass Solution:\\n    def maximumGap(self, nums):\\n        if len(nums) < 2:\\n            return 0\\n    \\n        nums.sort()\\n        maxDiff = 0\\n\\n        for i in range(1, len(nums)):\\n            maxDiff = max(maxDiff, nums[i] - nums[i - 1])\\n    \\n        return maxDiff\\n```\\n\\n---\\n# Optimized Approach\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\nFor finding maximum gap we are making bucket for putting middle n-2 elements and bucket size will be n-1 means (smallest and largest elements are to be avoided) means there will be one bucket that will be empty so that previous max and next mix elements of bucket will give the max difference. For doing so we make the bucket of `size n-1` for both storing max and min element in the bucket and bucket will contain and bucket will store `(max-min)/n-1` range of elements . Now we start putting elements in bucket so for checking in which index we have to put that element we find `(x-min)/avg` and avg is `(max-min)/n-1` so we get the index and we fill max and min buckets with this elements . Now we simply take difference between max of one bucket and min of next bucket. \\n# Complexity\\n- Time complexity:` O(n)`, where n is the length of the input array.\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: `O(n)`, because we are using an array to store the buckets. However, we can reduce the space complexity to `O(1) `by using a linked list instead of an array to store the buckets.\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n\\n\\n```Java []\\nclass Solution {\\n    public int maximumGap(int[] nums) {\\n        if(nums.length < 2)\\n            return 0;\\n        int n = nums.length;\\n        int max = nums[0], min= nums[0];\\n        for(int i  : nums) {\\n            max = Math.max(max, i);\\n            min = Math.min(min, i);\\n        }\\n        int bucketSize = (max - min)/(n - 1);\\n        if(bucketSize == 0)\\n            bucketSize++;\\n        int totalBuckets = ((max - min)/bucketSize) + 1;\\n        int[] minBucket = new int[totalBuckets];\\n        int[] maxBucket = new int[totalBuckets];\\n        Arrays.fill(minBucket, Integer.MAX_VALUE);\\n        for(int i = 0 ; i < n ; i++) {\\n            int index = (nums[i] - min)/bucketSize;\\n            minBucket[index] = Math.min(minBucket[index], nums[i]);\\n            maxBucket[index] = Math.max(maxBucket[index], nums[i]);\\n        }\\n        int prevMax = maxBucket[0], result = 0;\\n        for(int i = 1; i < totalBuckets; i++) {\\n            if(minBucket[i] == Integer.MAX_VALUE)\\n                continue;\\n            result = Math.max(result, minBucket[i] - prevMax);\\n            prevMax = maxBucket[i];\\n        }\\n        return result;\\n    }\\n}\\n```\\n```python3 []\\nclass Solution:\\n    def maximumGap(self, nums: List[int]) -> int:\\n        n = len(nums)\\n        if n < 2:\\n            return 0\\n        \\n        # compute the maximum and minimum values\\n        max_value, min_value = max(nums), min(nums)\\n        \\n        # compute the size of each bucket\\n        bucket_size = max(1, (max_value - min_value) // (n - 1))\\n        \\n        # compute the number of buckets\\n        num_buckets = (max_value - min_value) // bucket_size + 1\\n        \\n        # initialize the buckets with maximum and minimum values\\n        buckets = [[float(\\'inf\\'), float(\\'-inf\\')] for _ in range(num_buckets)]\\n        for num in nums:\\n            bucket_index = (num - min_value) // bucket_size\\n            buckets[bucket_index][0] = min(buckets[bucket_index][0], num)\\n            buckets[bucket_index][1] = max(buckets[bucket_index][1], num)\\n        \\n        # compute the maximum difference\\n        max_diff = 0\\n        prev_max = buckets[0][1]\\n        for i in range(1, num_buckets):\\n            if buckets[i][0] == float(\\'inf\\'):\\n                continue\\n            max_diff = max(max_diff, buckets[i][0] - prev_max)\\n            prev_max = buckets[i][1]\\n        \\n        return max_diff\\n```\\n\\n\\n",
                "solutionTags": [
                    "Java",
                    "Python",
                    "Python3",
                    "Sorting",
                    "Bucket Sort"
                ],
                "code": "```Java []\\nclass Solution {\\n    public int maximumGap(int[] nums) {\\n        if(nums.length < 2)return 0;\\n        Arrays.sort(nums);\\n        int maxDiff = 0;\\n        for(int i=0;i<nums.length-1;i++){\\n            maxDiff = Math.max(maxDiff, nums[i+1] - nums[i]);\\n        }\\n        return maxDiff;\\n    }\\n}\\n```\n```python3 []\\nclass Solution:\\n    def maximumGap(self, nums):\\n        if len(nums) < 2:\\n            return 0\\n    \\n        nums.sort()\\n        maxDiff = 0\\n\\n        for i in range(1, len(nums)):\\n            maxDiff = max(maxDiff, nums[i] - nums[i - 1])\\n    \\n        return maxDiff\\n```\n```Java []\\nclass Solution {\\n    public int maximumGap(int[] nums) {\\n        if(nums.length < 2)\\n            return 0;\\n        int n = nums.length;\\n        int max = nums[0], min= nums[0];\\n        for(int i  : nums) {\\n            max = Math.max(max, i);\\n            min = Math.min(min, i);\\n        }\\n        int bucketSize = (max - min)/(n - 1);\\n        if(bucketSize == 0)\\n            bucketSize++;\\n        int totalBuckets = ((max - min)/bucketSize) + 1;\\n        int[] minBucket = new int[totalBuckets];\\n        int[] maxBucket = new int[totalBuckets];\\n        Arrays.fill(minBucket, Integer.MAX_VALUE);\\n        for(int i = 0 ; i < n ; i++) {\\n            int index = (nums[i] - min)/bucketSize;\\n            minBucket[index] = Math.min(minBucket[index], nums[i]);\\n            maxBucket[index] = Math.max(maxBucket[index], nums[i]);\\n        }\\n        int prevMax = maxBucket[0], result = 0;\\n        for(int i = 1; i < totalBuckets; i++) {\\n            if(minBucket[i] == Integer.MAX_VALUE)\\n                continue;\\n            result = Math.max(result, minBucket[i] - prevMax);\\n            prevMax = maxBucket[i];\\n        }\\n        return result;\\n    }\\n}\\n```\n```python3 []\\nclass Solution:\\n    def maximumGap(self, nums: List[int]) -> int:\\n        n = len(nums)\\n        if n < 2:\\n            return 0\\n        \\n        # compute the maximum and minimum values\\n        max_value, min_value = max(nums), min(nums)\\n        \\n        # compute the size of each bucket\\n        bucket_size = max(1, (max_value - min_value) // (n - 1))\\n        \\n        # compute the number of buckets\\n        num_buckets = (max_value - min_value) // bucket_size + 1\\n        \\n        # initialize the buckets with maximum and minimum values\\n        buckets = [[float(\\'inf\\'), float(\\'-inf\\')] for _ in range(num_buckets)]\\n        for num in nums:\\n            bucket_index = (num - min_value) // bucket_size\\n            buckets[bucket_index][0] = min(buckets[bucket_index][0], num)\\n            buckets[bucket_index][1] = max(buckets[bucket_index][1], num)\\n        \\n        # compute the maximum difference\\n        max_diff = 0\\n        prev_max = buckets[0][1]\\n        for i in range(1, num_buckets):\\n            if buckets[i][0] == float(\\'inf\\'):\\n                continue\\n            max_diff = max(max_diff, buckets[i][0] - prev_max)\\n            prev_max = buckets[i][1]\\n        \\n        return max_diff\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1482255,
                "title": "faster-than-95-c-bucket-sort-o-n-space-o-n-time",
                "content": "bucket sort\\n\\n~~~C++\\nclass Solution {\\npublic:\\n    int maximumGap(vector<int>& nums) {\\n        int mn = INT_MAX, mx = INT_MIN;\\n        int n = nums.size();\\n        if (n < 2)\\n        \\treturn 0;\\n        for (int i=0;i<n;++i) {\\n        \\tmn = min(nums[i], mn);\\n        \\tmx = max(nums[i], mx);\\n\\t\\t}\\n\\t\\tif (mx == mn)\\n\\t\\t\\treturn 0;\\n\\t\\tdouble bucket = (mx - mn + 0.0) / n; \\n\\t\\tvector<int> big(n, -1); \\n\\t\\tvector<int> small(n, -1);  \\n\\t\\tfor (int i=0;i<n;++i) {\\n\\t\\t\\tint index = (nums[i] - mn) / bucket;\\n\\t\\t\\tif (index >= n) \\n\\t\\t\\t\\tindex = n - 1; \\n\\t\\t\\t\\n\\t\\t\\tif (big[index] == -1) {\\n\\t\\t\\t\\tbig[index] = small[index] = nums[i];\\n\\t\\t\\t}\\n\\t\\t\\telse {\\n\\t\\t\\t\\tbig[index] = max(big[index], nums[i]);\\n\\t\\t\\t\\tsmall[index] = min(small[index], nums[i]);\\n\\t\\t\\t}\\n\\t\\t}\\n\\t\\tint result = 0;\\n\\t\\tint s = mn, b = mn;\\n\\t\\tfor (int i=0;i<n;++i) { \\n\\t\\t\\tif (big[i] == -1)\\n\\t\\t\\t\\tcontinue;\\n\\t\\t\\tresult = max(small[i] - b, result); \\n\\t\\t\\ts = small[i];\\n\\t\\t\\tb = big[i];\\n\\t\\t}\\n\\t\\treturn result;\\n    }\\n};",
                "solutionTags": [
                    "C",
                    "Bucket Sort"
                ],
                "code": "class Solution {\\npublic:\\n    int maximumGap(vector<int>& nums) {\\n        int mn = INT_MAX, mx = INT_MIN;\\n        int n = nums.size();\\n        if (n < 2)\\n        \\treturn 0;\\n        for (int i=0;i<n;++i) {\\n        \\tmn = min(nums[i], mn);\\n        \\tmx = max(nums[i], mx);\\n\\t\\t}",
                "codeTag": "Java"
            },
            {
                "id": 1251483,
                "title": "c-o-n-bucket-sort-and-pigeon-hole-with-detail-explanation-one-of-the-very-nice-approach",
                "content": "in O(nlogn) its very simple to solve lets solve in O(n)  using bucket sort pigeon hole principle. If  already done bucket sort then its not so tricky  if not then lets see\\n   \\n   lets take example [3,6,9,1] \\n     \\n\\t find the min and max in the array min=1 and max=9. so numbers in the array will range from 1 to 9. and there are total n-1 gaps.\\n\\t  3____6____9____1\\n       g1   g2   g3\\nn-1=3 total 3 gaps.now we will calculate avg dist of gap\\n     avg=(max-min)/(n-1)\\nnow we will take few buckets(we will calculate it\\'s size) and in each bucket we will put elmt like -\\nbucket 1---->[min....min+avg-1] \\nbucket 2---->[min+avg......min+2*avg-1]\\n\\'\\n\\'\\n[\\n in bucket1---->[1,2] (any of them which is present in the array can come to this \\n    bucket2----->[3,4]       bucket)\\n\\tbucket3----->[5,6]\\n\\tbucket4----->[7,8]\\n\\tbucket5----->[9]\\n\\t]\\n\\t now will calculate the number of buckets---\\n\\t numbuckets=(max-min)/avg+1;\\n\\t      here (9-1)/2+1=5;\\n   and we will put each elmt its correspondence bucket\\n     bucketIndex=(nums[i]-min)/avg;\\n\\t\\n\\tfor 3--->index=(3-1)/2=1;\\n\\t     6--->index=(6-1)/2=2;\\n\\t\\t 9--->index=(9-1)/2=4;\\n\\t\\t 1--->index=(1-1)/2=0;\\n\\t 0    bucket1----->[1]\\n     1    bucket2----->[3]\\n\\t 2    bucket3----->[6]\\n\\t 3   bucket4----->  []\\n\\t 4  bucket5----->[9]\\n\\t \\n* In each bucket the maximum diff between any two number will always be less than     avg.\\n* And our actual ans will be  always ( >=avg ) so both no\\'s (which diff is                 maximum)  cannot be in same bucket .\\n* So they will be in different buckets.Since we have to find adjacent elements different so it will be then min of next bucket and max of present bucket\\'s different.\\n* We will check for each bucket and choose the maximum .\\n* here we can optimize our space little bit instead of storing all elements in             buckets we will only store max and min in bucket .and calculate out ans.\\n\\t\\t   minBucket--->[1,3,6,INT_MAX,9]\\n\\t\\t   maxBucket--->[1,3,6,INT_MIN,9]\\n since there is <=1 element in each bucket so it will be the same if there will multiple element then min and max are stored.\\n Now  ans=0;\\n  ans=max(ans,3-1)=2;\\n  ans=max(ans,6-3)=3;\\n  ans=max(ans,9-6)=3;\\n  \\n  (if there is INT_MAX or INT_MIN ignore this)\\n  \\n  \\n ```\\n   class Solution {\\npublic:\\n    int maximumGap(vector<int>& nums) {\\n       int n=nums.size();\\n        if(n<2) return 0;\\n      \\n          int mx=nums[0],mn=nums[0];\\n        for(int i=0;i<n;i++) { mn=min(mn,nums[i]);       mx=max(mx,nums[i]); }\\n\\t\\t\\n            int avg=max((mx-mn)/(n-1),1);  //\\n            int size=(mx-mn)/avg+1;   //number of buckets \\n        \\n          int mnA[size],  mxA[size];\\n        \\n        for(int i=0;i<size;i++) mnA[i]=INT_MAX,  mxA[i]=INT_MIN;\\n        \\n      for(int i=0;i<n;i++){\\n          int pos=(nums[i]-mn)/avg;    //index of bucket\\n          \\n          mnA[pos]=min(mnA[pos],nums[i]);  //puting elements in their buckets\\n          mxA[pos]=max(mxA[pos],nums[i]);   //\\n      }\\n     int ans=0;\\n        int i=0, j=1;\\n        while(i<size-1&&j<size) {\\n            if(mnA[j]==INT_MAX)  {  j++;   continue; }  //  Ignoring this bucket since \\n            if(mxA[i]==INT_MIN) {  i++;      continue;}   //there is no element present\\n            ans=max(ans,mnA[j]-mxA[i]);\\n            i++, j++;\\n        }\\n        return ans;\\n       \\n    }\\n}; \\n     ```\\n",
                "solutionTags": [],
                "code": "```\\n   class Solution {\\npublic:\\n    int maximumGap(vector<int>& nums) {\\n       int n=nums.size();\\n        if(n<2) return 0;\\n      \\n          int mx=nums[0],mn=nums[0];\\n        for(int i=0;i<n;i++) { mn=min(mn,nums[i]);       mx=max(mx,nums[i]); }\\n\\t\\t\\n            int avg=max((mx-mn)/(n-1),1);  //\\n            int size=(mx-mn)/avg+1;   //number of buckets \\n        \\n          int mnA[size],  mxA[size];\\n        \\n        for(int i=0;i<size;i++) mnA[i]=INT_MAX,  mxA[i]=INT_MIN;\\n        \\n      for(int i=0;i<n;i++){\\n          int pos=(nums[i]-mn)/avg;    //index of bucket\\n          \\n          mnA[pos]=min(mnA[pos],nums[i]);  //puting elements in their buckets\\n          mxA[pos]=max(mxA[pos],nums[i]);   //\\n      }\\n     int ans=0;\\n        int i=0, j=1;\\n        while(i<size-1&&j<size) {\\n            if(mnA[j]==INT_MAX)  {  j++;   continue; }  //  Ignoring this bucket since \\n            if(mxA[i]==INT_MIN) {  i++;      continue;}   //there is no element present\\n            ans=max(ans,mnA[j]-mxA[i]);\\n            i++, j++;\\n        }\\n        return ans;\\n       \\n    }\\n}; \\n     ```",
                "codeTag": "Java"
            },
            {
                "id": 727709,
                "title": "python3-group-data-into-buckets",
                "content": "Algo\\nIn several posts, the algo is termed \"pigeon hole principle\". To explain it in less fancier terms, let\\'s set `n - 1` buckets equally spaced between `min` and `max` to contain `n - 2` inner points. Then, there will be at least one empty bucket. In the spirit of this, one could safely ignore the distance within the buckets as it cannot be the largest. Instead, focusing on the distance between buckets is enough to give the correct answer. \\n\\n```\\nclass Solution:\\n    def maximumGap(self, nums: List[int]) -> int:\\n        if len(nums) == 0: return 0 #edge case \\n        mn, mx = min(nums), max(nums)\\n        step = max(1, (mx - mn)//(len(nums)-1)) #n-1 holes \\n        size = (mx - mn)//step + 1\\n        buckets = [[inf, -inf] for _ in range(size)]\\n        \\n        for num in nums: \\n            i = (num - mn)//step\\n            x, xx = buckets[i]\\n            buckets[i] = min(x, num), max(xx, num)\\n        \\n        ans = 0\\n        prev = mn\\n        for i in range(size):\\n            x, xx = buckets[i]\\n            if x < inf:\\n                ans = max(ans, x - prev)\\n                prev = xx \\n        return ans \\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def maximumGap(self, nums: List[int]) -> int:\\n        if len(nums) == 0: return 0 #edge case \\n        mn, mx = min(nums), max(nums)\\n        step = max(1, (mx - mn)//(len(nums)-1)) #n-1 holes \\n        size = (mx - mn)//step + 1\\n        buckets = [[inf, -inf] for _ in range(size)]\\n        \\n        for num in nums: \\n            i = (num - mn)//step\\n            x, xx = buckets[i]\\n            buckets[i] = min(x, num), max(xx, num)\\n        \\n        ans = 0\\n        prev = mn\\n        for i in range(size):\\n            x, xx = buckets[i]\\n            if x < inf:\\n                ans = max(ans, x - prev)\\n                prev = xx \\n        return ans \\n```",
                "codeTag": "Java"
            },
            {
                "id": 50698,
                "title": "c-solution-using-bucket-to-record",
                "content": "    int maximumGap(vector<int>& nums) {\\n        const int size_num = nums.size();\\n        if (size_num < 2) return 0;\\n        int maxV = *max_element(nums.begin(), nums.end());\\n        int minV = *min_element(nums.begin(), nums.end());\\n        if (maxV == minV) return 0;\\n        double range = (maxV - minV) / double(size_num - 1);\\n        vector<int> max_b(size_num, INT_MIN), min_b(size_num, INT_MAX);\\n        for (int i = 0; i < size_num; i++) {\\n            int index = (nums[i] - minV) / range;\\n            max_b[index] = max(max_b[index], nums[i]);\\n            min_b[index] = min(min_b[index], nums[i]);\\n        }\\n        int max_g = (int)range,  start = max_b[0];\\n        for (int i = 1; i < size_num; i++) {\\n            if (min_b[i] == INT_MAX) continue;\\n            max_g = max(max_g, min_b[i] - start);\\n            start = max_b[i];\\n        }\\n        return max_g;\\n    }",
                "solutionTags": [
                    "C++"
                ],
                "code": "    int maximumGap(vector<int>& nums) {\\n        const int size_num = nums.size();\\n        if (size_num < 2) return 0;\\n        int maxV = *max_element(nums.begin(), nums.end());\\n        int minV = *min_element(nums.begin(), nums.end());\\n        if (maxV == minV) return 0;\\n        double range = (maxV - minV) / double(size_num - 1);\\n        vector<int> max_b(size_num, INT_MIN), min_b(size_num, INT_MAX);\\n        for (int i = 0; i < size_num; i++) {\\n            int index = (nums[i] - minV) / range;\\n            max_b[index] = max(max_b[index], nums[i]);\\n            min_b[index] = min(min_b[index], nums[i]);\\n        }\\n        int max_g = (int)range,  start = max_b[0];\\n        for (int i = 1; i < size_num; i++) {\\n            if (min_b[i] == INT_MAX) continue;\\n            max_g = max(max_g, min_b[i] - start);\\n            start = max_b[i];\\n        }\\n        return max_g;\\n    }",
                "codeTag": "Unknown"
            },
            {
                "id": 3338914,
                "title": "trippy-s-coding-approach-simple-to-the-point",
                "content": "# Intuition\\nSHORT AND CRISPY SOLUTION.\\nHERE I AM PRESENTING ONLY JAVA SOLUTION, FOR C++ JUST USE VECTOR INSTEAD OF ARRAY \\n\\n# Approach\\nUSING SS APPRAOCH \\n**JUST SMILE AND SOLVE** \\n\\n# Complexity\\nNOTHING COMPLEX HERE \\n\\n# PLEASE UPVOTE\\nPLEASE UPVOTE IF I HELPED YOU\\nTHANK YOU.\\nKEEP IT UP.\\nLOVE FOR YOU BY TRIPPY \\u2764\\uFE0F\\u2764\\uFE0F\\n\\n# Code\\n```\\nclass Solution {\\n    public int maximumGap(int[] arr) {\\n        Arrays.sort(arr);\\n        int l=arr.length;\\n        if(l<2)\\n        return 0;\\n        int max=0;\\n        for(int i=0;i<l-1;i++)\\n        {\\n            int c=arr[i+1]-arr[i];\\n            if(c>max)\\n            max=c;\\n          \\n        }\\n        return max;\\n        //PLEASE UPVOTE\\n    }\\n}\\n```",
                "solutionTags": [
                    "C++",
                    "Java",
                    "Array",
                    "Math",
                    "Sort"
                ],
                "code": "```\\nclass Solution {\\n    public int maximumGap(int[] arr) {\\n        Arrays.sort(arr);\\n        int l=arr.length;\\n        if(l<2)\\n        return 0;\\n        int max=0;\\n        for(int i=0;i<l-1;i++)\\n        {\\n            int c=arr[i+1]-arr[i];\\n            if(c>max)\\n            max=c;\\n          \\n        }\\n        return max;\\n        //PLEASE UPVOTE\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3208798,
                "title": "164-solution-with-step-by-step-explanation",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n1. We define a Solution class with a maximumGap method that takes a list of integers nums as input and returns an integer, the maximum gap between two successive elements in the sorted form of nums.\\n\\n2. We check if the length of nums is less than 2, and return 0 if so, because we cannot find a gap between two elements if there is only one or none.\\n\\n3. We get the minimum and maximum values in nums using the built-in min and max functions.\\n\\n4. We calculate the bucket size as the maximum of 1 and the integer division of the range of nums (i.e., max_val - min_val) by the number of elements in nums minus 1 (i.e., len(nums) - 1). This ensures that we have at least one element in each bucket. We also calculate the number of buckets as the integer division of the range of nums by the bucket size plus 1, to ensure that we have a bucket for the maximum value.\\n\\n5. We initialize an empty list buckets of length num_buckets to hold the buckets.\\n\\n6. We loop through each element num in nums and calculate the index of the bucket it belongs to as the integer division of its distance from min_val by the bucket size. We then check if the corresponding bucket is empty or not, and if it is, we initialize it with the min and max values of num. Otherwise, we update the min and max values of the bucket with the minimum and maximum of num and the current min and max values, respectively.\\n\\n7. We initialize a variable max_gap to hold the maximum gap between adjacent buckets, and a variable prev_max to hold the maximum value in the previous bucket, initially set to min_val.\\n\\n8. We loop through each bucket in buckets, and if it is not empty, we update max_gap with the difference between its `min\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution:\\n    def maximumGap(self, nums: List[int]) -> int:\\n        \\n        # Check if the list is empty or contains only one element\\n        if len(nums) < 2:\\n            return 0\\n        \\n        # Get the minimum and maximum values in the list\\n        min_val = min(nums)\\n        max_val = max(nums)\\n        \\n        # Calculate the bucket size and number of buckets\\n        bucket_size = max(1, (max_val - min_val) // (len(nums) - 1))\\n        num_buckets = (max_val - min_val) // bucket_size + 1\\n        \\n        # Initialize the buckets\\n        buckets = [None] * num_buckets\\n        \\n        # Put each element in its corresponding bucket\\n        for num in nums:\\n            bucket_index = (num - min_val) // bucket_size\\n            if not buckets[bucket_index]:\\n                buckets[bucket_index] = {\\'min\\': num, \\'max\\': num}\\n            else:\\n                buckets[bucket_index][\\'min\\'] = min(buckets[bucket_index][\\'min\\'], num)\\n                buckets[bucket_index][\\'max\\'] = max(buckets[bucket_index][\\'max\\'], num)\\n        \\n        # Calculate the maximum gap between adjacent buckets\\n        max_gap = 0\\n        prev_max = min_val\\n        for bucket in buckets:\\n            if bucket:\\n                max_gap = max(max_gap, bucket[\\'min\\'] - prev_max)\\n                prev_max = bucket[\\'max\\']\\n        \\n        return max_gap\\n\\n```",
                "solutionTags": [
                    "Python",
                    "Python3",
                    "Array",
                    "Sorting",
                    "Bucket Sort"
                ],
                "code": "```\\nclass Solution:\\n    def maximumGap(self, nums: List[int]) -> int:\\n        \\n        # Check if the list is empty or contains only one element\\n        if len(nums) < 2:\\n            return 0\\n        \\n        # Get the minimum and maximum values in the list\\n        min_val = min(nums)\\n        max_val = max(nums)\\n        \\n        # Calculate the bucket size and number of buckets\\n        bucket_size = max(1, (max_val - min_val) // (len(nums) - 1))\\n        num_buckets = (max_val - min_val) // bucket_size + 1\\n        \\n        # Initialize the buckets\\n        buckets = [None] * num_buckets\\n        \\n        # Put each element in its corresponding bucket\\n        for num in nums:\\n            bucket_index = (num - min_val) // bucket_size\\n            if not buckets[bucket_index]:\\n                buckets[bucket_index] = {\\'min\\': num, \\'max\\': num}\\n            else:\\n                buckets[bucket_index][\\'min\\'] = min(buckets[bucket_index][\\'min\\'], num)\\n                buckets[bucket_index][\\'max\\'] = max(buckets[bucket_index][\\'max\\'], num)\\n        \\n        # Calculate the maximum gap between adjacent buckets\\n        max_gap = 0\\n        prev_max = min_val\\n        for bucket in buckets:\\n            if bucket:\\n                max_gap = max(max_gap, bucket[\\'min\\'] - prev_max)\\n                prev_max = bucket[\\'max\\']\\n        \\n        return max_gap\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1451782,
                "title": "c-bucketing-explanation-code",
                "content": "**Problem:** Sorting takes O(NlogN) but we have to solve it in O(N) time. Here we use the bucketing or bucket sort method.\\n\\n**Pigeonhole Principle:** If you have n pigeons and n-1 nests, atleast one hole will have two pigeons! Trivial but very useful. \\n\\n**Why bucketing:** Let\\'s combine bucketing with the Pigeohole Principle. Now if we sort the elements and divide them into n-1 buckets of constant size, we will have 2 elements in atleast 1 bucket (as per Pigeonhole). Additionally, if 1 bucket has >2 elements, then there is atleast 1 empty bucket, which would mean Maximum Gap>bucket size.\\n\\n**Case 1:** If there are more than 1 elements within buckets, to find \"maximum\" gap withing a bucket you have to take minimum of that bucket and maximum of that bucket and subtract them. \\n**Case 2:** We take max from previous bucket and min from current bucket and subtract these two.\\n\\n*Now, the case one becomes not necessary because if there is an empty bucket, the max gap will be anyways greater than bucket size and in case 1 since we are within the bucket max gap will always be less than bucket size!!.*\\n\\n**NOTE:** Look at it this way. We made \\'n-1\\' buckets and there are \\'n\\' elements. Now, if there is atleast 1 bucket with >2 elements we distribute n-3 elements in n-2 buckets, meaning atleast 1 bucket is empty. Now the maximum gap has to be greater than bucket size! Therefore we ignore case 1 here. (The remaining case we deal with is when exactly 1 bucket has 2 elements and the others have 1 element each.)\\n\\nI understand this is difficult to click, but now that you know this thing exists, the next application would become easier!!\\n\\n```\\nclass Solution {\\npublic:\\n    int maximumGap(vector<int>& nums) \\n    {\\n        int n = nums.size(), mx=INT_MIN, mn=INT_MAX;\\n        if(n<2) return 0; //Given in question.\\n        if(n==2) return abs(nums[0]-nums[1]); //Optional, just reduces time.\\n        for(int i=0; i<n; i++)\\n        {\\n            mx = max(mx, nums[i]);\\n            mn = min(mn, nums[i]);\\n        }\\n        if(mx==mn) return 0; //This means all elements may be equal, hence answer is 0.\\n\\t\\t\\n\\t\\t//We make n-1 buckets, I made 2 different arrays, but you could use a vector of pairs\\n        vector<int> min_buck(n-1,INT_MAX); \\n        vector<int> max_buck(n-1, -1);\\n\\t\\t\\n\\t\\t\\n\\t\\t//Size of each bucket  = Range/No. of buckets  -> sz = (max - mn) / (n-1) \\n\\t\\t\\n        int sz = (int)ceil((mx - mn + 0.0)/(n-1)); \\n        for(int i=0;i<n;i++)\\n        {\\n            if(nums[i]==mn || nums[i]==mx) continue;  //This we will account for later\\n            int index = (nums[i]-mn)/sz;  //Finding which bucket number belongs to\\n            min_buck[index]=min(min_buck[index],nums[i]);  \\n            max_buck[index]=max(max_buck[index],nums[i]);\\n        }\\n        int prev = mn, ans = 0;  //Prev variable accounts for the minimum (mn) value\\n        for(int i=0; i<min_buck.size(); i++)\\n        {\\n            if(min_buck[i]==INT_MAX || max_buck[i]==-1) continue;\\n            ans = max(ans, min_buck[i]-prev);  //We only subtract prev from minimum of curr bucket\\n            prev = max_buck[i]; //Update prev\\n        }\\n        ans = max(ans, mx-prev); //Accounting for mx (maximum)\\n        return ans;\\n    }\\n};\\n```\\n\\n\\n\\n",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    int maximumGap(vector<int>& nums) \\n    {\\n        int n = nums.size(), mx=INT_MIN, mn=INT_MAX;\\n        if(n<2) return 0; //Given in question.\\n        if(n==2) return abs(nums[0]-nums[1]); //Optional, just reduces time.\\n        for(int i=0; i<n; i++)\\n        {\\n            mx = max(mx, nums[i]);\\n            mn = min(mn, nums[i]);\\n        }\\n        if(mx==mn) return 0; //This means all elements may be equal, hence answer is 0.\\n\\t\\t\\n\\t\\t//We make n-1 buckets, I made 2 different arrays, but you could use a vector of pairs\\n        vector<int> min_buck(n-1,INT_MAX); \\n        vector<int> max_buck(n-1, -1);\\n\\t\\t\\n\\t\\t\\n\\t\\t//Size of each bucket  = Range/No. of buckets  -> sz = (max - mn) / (n-1) \\n\\t\\t\\n        int sz = (int)ceil((mx - mn + 0.0)/(n-1)); \\n        for(int i=0;i<n;i++)\\n        {\\n            if(nums[i]==mn || nums[i]==mx) continue;  //This we will account for later\\n            int index = (nums[i]-mn)/sz;  //Finding which bucket number belongs to\\n            min_buck[index]=min(min_buck[index],nums[i]);  \\n            max_buck[index]=max(max_buck[index],nums[i]);\\n        }\\n        int prev = mn, ans = 0;  //Prev variable accounts for the minimum (mn) value\\n        for(int i=0; i<min_buck.size(); i++)\\n        {\\n            if(min_buck[i]==INT_MAX || max_buck[i]==-1) continue;\\n            ans = max(ans, min_buck[i]-prev);  //We only subtract prev from minimum of curr bucket\\n            prev = max_buck[i]; //Update prev\\n        }\\n        ans = max(ans, mx-prev); //Accounting for mx (maximum)\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 50663,
                "title": "very-simple-solution-accepted-as-best-in-c-well-explained",
                "content": "Actually I just want to use QuickSort and then search for the value which will actually takes quite good performance accepted with 8ms in C -> even size of the list is 2^32 the sorting time will be controlled in O(32n) -> O(nlogn); but of course we should try some other funny solutions also.\\n\\n- space cost O(1);\\n- time cost O(nlogn) using QuickSort;\\n\\n\\n----------\\n\\n    void sort(int* nums, int begin, int end)\\n    {\\n        int l=begin, r=end;\\n        int v = nums[l+(r-l)/2];\\n        while(l <= r)\\n        {\\n            while(nums[l] < v) l++;\\n            while(nums[r] > v) r--;\\n            if(l <= r)\\n            {\\n                int t = nums[l];\\n                nums[l] = nums[r];\\n                nums[r] = t;\\n                l++; r--;\\n            }\\n        }\\n        if(begin < r)\\n        sort(nums, begin, r);\\n        if(l < end)\\n        sort(nums, l, end);\\n    }\\n    \\n    //AC - 8ms;\\n    int maximumGap(int* nums, int size) \\n    {\\n        sort(nums, 0, size-1);\\n        int max = 0;\\n        for(int i = 1; i < size; i++)\\n            if(nums[i]-nums[i-1] > max)\\n                max = nums[i]-nums[i-1];\\n        return max;\\n    \\n    }\\n\\n----------\\n\\nSince we are required to solve it in linear time, we have to abandon our lovely QuickSort which really make the whole code quite clean and concise. Using BucketSort is the way or actually another way as other posts mentioned RadixSort which actually I think is just a derivative of BucketSort. Three steps to solve this problem linearly:\\n\\n- get the range of the number -> O(n) find the min and max of the numbers; then get the gap within a bucket by gap=(max-min)/(size-1)+1; the bucket will cover [min+k*gap, min+(k+1)*gap) while the left inclusive and the right exclusive; as a result the maximal numbers located in a single bucket will be (max-min)/(size-1) and so there must be a gap between two consecutive numbers are bigger than this average gap -> maximal gap and then located in two different buckets -> that's why we need bucket sorting; if you don't know why, please check  [Pigeonhole Principle](https://en.wikipedia.org/wiki/Pigeonhole_principle) first.\\n\\n- map the number into buckets; but we actually only need to store the minimal and maximal value of the bucket since the maximal gap will definitely bigger than the average gap;\\n- traverse the buckets to get the maximal gap.\\n\\nEnd of Story!\\n\\n- space cost O(n) using space to save time;\\n- time cost O(n) actually when the numbers are not that much, this solution can be slower compared with the previous one.\\n\\n----------\\n\\n    int maximumGap(int* nums, int size)\\n    {\\n        if(size < 2) return 0;\\n        int min=INT_MAX, max=0;\\n        for(int i = 0; i < size; i++)\\n        {\\n            if(nums[i] < min) min = nums[i];\\n            if(nums[i] > max) max = nums[i];\\n        }\\n        if(min == max) return 0; //some corner cases;\\n        if(min+1 == max) return 1;\\n        if(size == 2) return max-min;\\n        int gap = (max-min)/(size-1)+1; //make later index searching process easier but actually there will be also (max-min)/(size-1) numbers in each bucket;\\n        int** buckets = (int**)malloc(sizeof(int*)*size); //only store the min and max in the bucket;\\n        for(int i = 0; i < size; i++)\\n        {\\n            buckets[i] = (int*)malloc(sizeof(int)*2);\\n            buckets[i][0] = -1;\\n            buckets[i][1] = 0;\\n        }\\n        for(int i = 0; i < size; i++) //[min+k*gap, min+(k+1)*gap);\\n        {\\n            int k = (nums[i]-min)/gap; //get the index of the bucket;\\n            if(nums[i] > buckets[k][1]) //the greatest in the bucket;\\n                buckets[k][1] = nums[i];\\n            if(buckets[k][0]==-1 || nums[i]<buckets[k][0]) //store the minimal in the kth gap;\\n                buckets[k][0] = nums[i];\\n        }\\n        int start = buckets[0][1];\\n        int end = buckets[0][0];\\n        int maxGap = 1;\\n        for(int i = 0; i < size; i++)\\n        {\\n            if(buckets[i][0] > end) //move to the next bucket that has numbers since we initialize bucket with -1 and 0;\\n            {\\n                end = buckets[i][0]; //the end of the gap;\\n                if(end-start > maxGap)\\n                    maxGap = end-start;\\n                start = buckets[i][1]; //move to the next start;\\n            }\\n        }\\n        return maxGap;\\n    }",
                "solutionTags": [],
                "code": "Actually I just want to use QuickSort and then search for the value which will actually takes quite good performance accepted with 8ms in C -> even size of the list is 2^32 the sorting time will be controlled in O(32n) -> O(nlogn); but of course we should try some other funny solutions also.\\n\\n- space cost O(1);\\n- time cost O(nlogn) using QuickSort;\\n\\n\\n----------\\n\\n    void sort(int* nums, int begin, int end)\\n    {\\n        int l=begin, r=end;\\n        int v = nums[l+(r-l)/2];\\n        while(l <= r)\\n        {\\n            while(nums[l] < v) l++;\\n            while(nums[r] > v) r--;\\n            if(l <= r)\\n            {\\n                int t = nums[l];\\n                nums[l] = nums[r];\\n                nums[r] = t;\\n                l++; r--;\\n            }\\n        }\\n        if(begin < r)\\n        sort(nums, begin, r);\\n        if(l < end)\\n        sort(nums, l, end);\\n    }\\n    \\n    //AC - 8ms;\\n    int maximumGap(int* nums, int size) \\n    {\\n        sort(nums, 0, size-1);\\n        int max = 0;\\n        for(int i = 1; i < size; i++)\\n            if(nums[i]-nums[i-1] > max)\\n                max = nums[i]-nums[i-1];\\n        return max;\\n    \\n    }\\n\\n----------\\n\\nSince we are required to solve it in linear time, we have to abandon our lovely QuickSort which really make the whole code quite clean and concise. Using BucketSort is the way or actually another way as other posts mentioned RadixSort which actually I think is just a derivative of BucketSort. Three steps to solve this problem linearly:\\n\\n- get the range of the number -> O(n) find the min and max of the numbers; then get the gap within a bucket by gap=(max-min)/(size-1)+1; the bucket will cover [min+k*gap, min+(k+1)*gap) while the left inclusive and the right exclusive; as a result the maximal numbers located in a single bucket will be (max-min)/(size-1) and so there must be a gap between two consecutive numbers are bigger than this average gap -> maximal gap and then located in two different buckets -> that's why we need bucket sorting; if you don't know why, please check  [Pigeonhole Principle](https://en.wikipedia.org/wiki/Pigeonhole_principle) first.\\n\\n- map the number into buckets; but we actually only need to store the minimal and maximal value of the bucket since the maximal gap will definitely bigger than the average gap;\\n- traverse the buckets to get the maximal gap.\\n\\nEnd of Story!\\n\\n- space cost O(n) using space to save time;\\n- time cost O(n) actually when the numbers are not that much, this solution can be slower compared with the previous one.\\n\\n----------\\n\\n    int maximumGap(int* nums, int size)\\n    {\\n        if(size < 2) return 0;\\n        int min=INT_MAX, max=0;\\n        for(int i = 0; i < size; i++)\\n        {\\n            if(nums[i] < min) min = nums[i];\\n            if(nums[i] > max) max = nums[i];\\n        }\\n        if(min == max) return 0; //some corner cases;\\n        if(min+1 == max) return 1;\\n        if(size == 2) return max-min;\\n        int gap = (max-min)/(size-1)+1; //make later index searching process easier but actually there will be also (max-min)/(size-1) numbers in each bucket;\\n        int** buckets = (int**)malloc(sizeof(int*)*size); //only store the min and max in the bucket;\\n        for(int i = 0; i < size; i++)\\n        {\\n            buckets[i] = (int*)malloc(sizeof(int)*2);\\n            buckets[i][0] = -1;\\n            buckets[i][1] = 0;\\n        }\\n        for(int i = 0; i < size; i++) //[min+k*gap, min+(k+1)*gap);\\n        {\\n            int k = (nums[i]-min)/gap; //get the index of the bucket;\\n            if(nums[i] > buckets[k][1]) //the greatest in the bucket;\\n                buckets[k][1] = nums[i];\\n            if(buckets[k][0]==-1 || nums[i]<buckets[k][0]) //store the minimal in the kth gap;\\n                buckets[k][0] = nums[i];\\n        }\\n        int start = buckets[0][1];\\n        int end = buckets[0][0];\\n        int maxGap = 1;\\n        for(int i = 0; i < size; i++)\\n        {\\n            if(buckets[i][0] > end) //move to the next bucket that has numbers since we initialize bucket with -1 and 0;\\n            {\\n                end = buckets[i][0]; //the end of the gap;\\n                if(end-start > maxGap)\\n                    maxGap = end-start;\\n                start = buckets[i][1]; //move to the next start;\\n            }\\n        }\\n        return maxGap;\\n    }",
                "codeTag": "Unknown"
            },
            {
                "id": 3433120,
                "title": "step-by-step-c-solution-using-buckets-o-n",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity: \\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int maximumGap(vector<int>& nums) {\\n        int n = nums.size();\\n\\n        // if number of elements are 1 or 2 only\\n        if(n == 1)\\n            return 0;\\n        if(n == 2)\\n            return abs(nums[0]-nums[1]);\\n\\n        // storing maximum value and minimum value\\n        int maxEle = nums[0];\\n        int minEle = nums[0];\\n        for(int i=1; i<n; i++){\\n            maxEle = max(maxEle, nums[i]);\\n            minEle = min(minEle, nums[i]);\\n        }\\n\\n        // generating bucket size with formula\\n        int bucketSize = ceil(float(maxEle-minEle)/(n-1));\\n        // bucket size will be zero if all elements are same, then max gap is 0\\n        if(bucketSize == 0)\\n            return 0;\\n        \\n        int numOfBuckets = n;\\n\\n        //made vectors to store the max and min value of each bucket\\n        vector<int> maxOfBucket(numOfBuckets, INT_MIN);\\n        vector<int> minOfBucket(numOfBuckets, INT_MAX);\\n\\n        // checking in which bucket element will fall, updating the max and min value of bucket if possible\\n        for(int i=0; i<n; i++){\\n            int ele = nums[i];\\n            int whichBucket = ((ele - minEle)/bucketSize);\\n\\n            maxOfBucket[whichBucket] = max(maxOfBucket[whichBucket], ele); \\n            minOfBucket[whichBucket] = min(minOfBucket[whichBucket], ele);\\n        }\\n\\n        // finally answer will be atleast the bucketSize or greater\\n        int ans = bucketSize;\\n\\n        // stored previous max, to find the max gap with the curr buckets minimum\\n        int prevMax = maxOfBucket[0];\\n        for(int i=1; i<numOfBuckets; i++){\\n            //because there can be buckets in between with no elements\\n            if(minOfBucket[i] == INT_MAX)\\n                continue;\\n\\n            ans = max(ans, (minOfBucket[i]-prevMax));\\n            prevMax = maxOfBucket[i];\\n        }\\n\\n        // final answer, max gap\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int maximumGap(vector<int>& nums) {\\n        int n = nums.size();\\n\\n        // if number of elements are 1 or 2 only\\n        if(n == 1)\\n            return 0;\\n        if(n == 2)\\n            return abs(nums[0]-nums[1]);\\n\\n        // storing maximum value and minimum value\\n        int maxEle = nums[0];\\n        int minEle = nums[0];\\n        for(int i=1; i<n; i++){\\n            maxEle = max(maxEle, nums[i]);\\n            minEle = min(minEle, nums[i]);\\n        }\\n\\n        // generating bucket size with formula\\n        int bucketSize = ceil(float(maxEle-minEle)/(n-1));\\n        // bucket size will be zero if all elements are same, then max gap is 0\\n        if(bucketSize == 0)\\n            return 0;\\n        \\n        int numOfBuckets = n;\\n\\n        //made vectors to store the max and min value of each bucket\\n        vector<int> maxOfBucket(numOfBuckets, INT_MIN);\\n        vector<int> minOfBucket(numOfBuckets, INT_MAX);\\n\\n        // checking in which bucket element will fall, updating the max and min value of bucket if possible\\n        for(int i=0; i<n; i++){\\n            int ele = nums[i];\\n            int whichBucket = ((ele - minEle)/bucketSize);\\n\\n            maxOfBucket[whichBucket] = max(maxOfBucket[whichBucket], ele); \\n            minOfBucket[whichBucket] = min(minOfBucket[whichBucket], ele);\\n        }\\n\\n        // finally answer will be atleast the bucketSize or greater\\n        int ans = bucketSize;\\n\\n        // stored previous max, to find the max gap with the curr buckets minimum\\n        int prevMax = maxOfBucket[0];\\n        for(int i=1; i<numOfBuckets; i++){\\n            //because there can be buckets in between with no elements\\n            if(minOfBucket[i] == INT_MAX)\\n                continue;\\n\\n            ans = max(ans, (minOfBucket[i]-prevMax));\\n            prevMax = maxOfBucket[i];\\n        }\\n\\n        // final answer, max gap\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2701945,
                "title": "c-100-faster-bucket-sort-technique",
                "content": "```\\nclass Solution {\\npublic:\\n    int maximumGap(vector<int>& nums) {\\n        int min_ = INT_MAX , max_ = INT_MIN ;\\n        int l = nums.size() ;\\n        if ( l < 2 ) return 0 ;\\n        for ( int i = 0 ; i < nums.size() ; ++i) {\\n            min_ = min(min_ , nums[i]) ;\\n            max_ = max(max_ , nums[i]) ;\\n            \\n        }\\n        \\n        int gap = ceil((max_ - min_)/((l-1)*1.0)) ;\\n        vector<int> m(nums.size() , INT_MAX);\\n        vector<int> n(nums.size() , INT_MIN) ;\\n        \\n        for(int i = 0 ; i < l ; ++i) {\\n            if (nums[i] == min_ || nums[i] == max_ ) continue ;\\n            \\n            int ind = ( nums[i] - min_ ) / (gap);\\n            m[ind] = min(m[ind] , nums[i]) ;\\n            n[ind] = max(n[ind] , nums[i]) ;\\n            \\n            \\n            \\n            \\n        }\\n        int ans = 0 ;\\n        for(int i = 0 ; i< m.size() ; ++i) {\\n            if (m[i] == INT_MAX) continue ;\\n            ans = max(ans , m[i] - min_ ) ;\\n            min_ = n[i] ;\\n        }\\n        \\n        ans = max(ans , max_ - min_ ) ;\\n        return ans ;\\n    }\\n};\\n",
                "solutionTags": [
                    "C++",
                    "C",
                    "Sorting",
                    "Bucket Sort"
                ],
                "code": "class Solution {\\npublic:\\n    int maximumGap(vector<int>& nums) {\\n        int min_ = INT_MAX , max_ = INT_MIN ;\\n        int l = nums.size() ;\\n        if ( l < 2 ) return 0 ;\\n        for ( int i = 0 ; i < nums.size() ; ++i) {\\n            min_ = min(min_ , nums[i]) ;\\n            max_ = max(max_ , nums[i]) ;\\n            \\n        }",
                "codeTag": "Java"
            },
            {
                "id": 1240781,
                "title": "rust-o-n-base-10-radix-sort",
                "content": "Unlike comparison-based sorts, a radix sort achieves `O(n)` time complexity.\\nThis solution uses a base-10 radix sort starting from the least-significant digits of each element in `nums` _(similiar to a bucket sort)_:\\n\\n```rust\\nimpl Solution {\\n    pub fn maximum_gap(mut nums: Vec<i32>) -> i32 {\\n        Self::radix_sort_base10(&mut nums);\\n        nums.windows(2).map(|w| w[1] - w[0]).max().unwrap_or(0)\\n    }\\n\\n    fn radix_sort_base10(nums: &mut [i32]) {\\n        let mut buckets = vec![vec![]; 10];\\n        for i in 0..10 {\\n            nums.iter()\\n                .for_each(|&x| buckets[((x / 10_i32.pow(i)) % 10) as usize].push(x));\\n            buckets\\n                .iter()\\n                .flat_map(|b| b.iter())\\n                .zip(nums.iter_mut())\\n                .for_each(|(&x, y)| *y = x);\\n            buckets.iter_mut().for_each(|b| b.clear());\\n        }\\n    }\\n}\\n```",
                "solutionTags": [
                    "Rust"
                ],
                "code": "```rust\\nimpl Solution {\\n    pub fn maximum_gap(mut nums: Vec<i32>) -> i32 {\\n        Self::radix_sort_base10(&mut nums);\\n        nums.windows(2).map(|w| w[1] - w[0]).max().unwrap_or(0)\\n    }\\n\\n    fn radix_sort_base10(nums: &mut [i32]) {\\n        let mut buckets = vec![vec![]; 10];\\n        for i in 0..10 {\\n            nums.iter()\\n                .for_each(|&x| buckets[((x / 10_i32.pow(i)) % 10) as usize].push(x));\\n            buckets\\n                .iter()\\n                .flat_map(|b| b.iter())\\n                .zip(nums.iter_mut())\\n                .for_each(|(&x, y)| *y = x);\\n            buckets.iter_mut().for_each(|b| b.clear());\\n        }\\n    }\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 50755,
                "title": "my-accepted-java-code-time-o-n-space-o-n",
                "content": "    public int maximumGap(int[] num) {\\n            int n;\\n            if(num == null || (n = num.length) < 2) {\\n                return 0;\\n            }\\n            int min = num[0];\\n            int max = num[0];\\n            for(int i : num) {\\n               if(i > max) {\\n                   max = i;\\n               } else if(i < min) {\\n                   min = i;\\n               }\\n            }\\n            double dist = (double)(max-min)/(double)(n-1);\\n            int[] mins = new int[n-1];\\n            int[] maxs = new int[n-1];\\n            Arrays.fill(mins, -1);\\n            Arrays.fill(maxs, -1);\\n            for(int i : num) {\\n                int idx = (i == max ? n-2 : (int) ((i-min)/dist));\\n                if(mins[idx] == -1 || i < mins[idx]) {\\n                    mins[idx] = i;\\n                }\\n                if(maxs[idx] == -1 || i > maxs[idx]) {\\n                    maxs[idx] = i;\\n                }\\n            }\\n            int prevMax = maxs[0];\\n            int maxGap = maxs[0]-mins[0];\\n            for(int i = 1; i < n-1; i++) {\\n                if(mins[i] == -1) {\\n                    continue;\\n                }\\n                int gap = mins[i] - prevMax;\\n                if(gap > maxGap) {\\n                    maxGap = gap;\\n                }\\n                prevMax = maxs[i];\\n            }\\n            return maxGap;\\n        }",
                "solutionTags": [],
                "code": "    public int maximumGap(int[] num) {\\n            int n;\\n            if(num == null || (n = num.length) < 2) {\\n                return 0;\\n            }\\n            int min = num[0];\\n            int max = num[0];\\n            for(int i : num) {\\n               if(i > max) {\\n                   max = i;\\n               } else if(i < min) {\\n                   min = i;\\n               }\\n            }\\n            double dist = (double)(max-min)/(double)(n-1);\\n            int[] mins = new int[n-1];\\n            int[] maxs = new int[n-1];\\n            Arrays.fill(mins, -1);\\n            Arrays.fill(maxs, -1);\\n            for(int i : num) {\\n                int idx = (i == max ? n-2 : (int) ((i-min)/dist));\\n                if(mins[idx] == -1 || i < mins[idx]) {\\n                    mins[idx] = i;\\n                }\\n                if(maxs[idx] == -1 || i > maxs[idx]) {\\n                    maxs[idx] = i;\\n                }\\n            }\\n            int prevMax = maxs[0];\\n            int maxGap = maxs[0]-mins[0];\\n            for(int i = 1; i < n-1; i++) {\\n                if(mins[i] == -1) {\\n                    continue;\\n                }\\n                int gap = mins[i] - prevMax;\\n                if(gap > maxGap) {\\n                    maxGap = gap;\\n                }\\n                prevMax = maxs[i];\\n            }\\n            return maxGap;\\n        }",
                "codeTag": "Unknown"
            },
            {
                "id": 3910212,
                "title": "java-very-easy-solution",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:O(nlogn)\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:O(1)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\n    public int maximumGap(int[] nums) {\\n        Arrays.sort(nums);\\n        int ans=0;\\n        for(int i=1;i<nums.length;i++) {\\n            ans= Math.max((nums[i]-nums[i-1]),ans);\\n        }\\n        return ans;\\n    }\\n}\\n```\\n# PLZ UPVOTE THE SOLUTION IF YOU UNDERSTAND",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int maximumGap(int[] nums) {\\n        Arrays.sort(nums);\\n        int ans=0;\\n        for(int i=1;i<nums.length;i++) {\\n            ans= Math.max((nums[i]-nums[i-1]),ans);\\n        }\\n        return ans;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3696652,
                "title": "bucket-sort",
                "content": "```\\nclass Solution {\\npublic:\\n    int maximumGap(vector<int>& nums) {\\n        int n = nums.size();\\n        if (n < 2) return 0;\\n\\n        int minn = nums[0], maxx = nums[0];\\n        for (auto i: nums) {\\n            minn = min(minn, i);\\n            maxx = max(maxx, i);\\n        }\\n\\n        int gap = ceil((1.0*maxx - 1.0*minn)/(n-1));\\n        if (gap < 1) gap = 1;\\n\\n        vector<pair<int, int>> arr(n, {INT_MAX, INT_MIN});\\n        for (auto i: nums) {\\n            int pos = (i-minn)/gap;\\n            arr[pos].first = min(arr[pos].first, i);\\n            arr[pos].second = max(arr[pos].second, i);\\n        }\\n\\n        int prev = minn;\\n        int res = 0;\\n        for (auto i: arr) {\\n            if (i.first == INT_MAX) continue;\\n            res = max(res, i.first-prev);\\n            prev = i.second;\\n        }\\n\\n        return res;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int maximumGap(vector<int>& nums) {\\n        int n = nums.size();\\n        if (n < 2) return 0;\\n\\n        int minn = nums[0], maxx = nums[0];\\n        for (auto i: nums) {\\n            minn = min(minn, i);\\n            maxx = max(maxx, i);\\n        }\\n\\n        int gap = ceil((1.0*maxx - 1.0*minn)/(n-1));\\n        if (gap < 1) gap = 1;\\n\\n        vector<pair<int, int>> arr(n, {INT_MAX, INT_MIN});\\n        for (auto i: nums) {\\n            int pos = (i-minn)/gap;\\n            arr[pos].first = min(arr[pos].first, i);\\n            arr[pos].second = max(arr[pos].second, i);\\n        }\\n\\n        int prev = minn;\\n        int res = 0;\\n        for (auto i: arr) {\\n            if (i.first == INT_MAX) continue;\\n            res = max(res, i.first-prev);\\n            prev = i.second;\\n        }\\n\\n        return res;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1911176,
                "title": "c-using-bucket-sort",
                "content": "**Please Upvote if you like the solution!**\\n\\n    class Solution {\\n    public:\\n    void maxGap(vector<int> &nums)\\n    {\\n        int mx=*max_element(nums.begin(),nums.end());//finding maximum element\\n        int mn=*min_element(nums.begin(),nums.end());//finding minimum element\\n        \\n        int n=nums.size();\\n        int range=(mx-mn)/n+1;//range or number of buckets \\n        \\n        vector<int> bucket[range];//creating a bucket array for storing different range values\\n        \\n        for(int i=0;i<n;i++)\\n        {\\n            int bi=(range*nums[i])/mx;//finding index actually on which range current index value is coming\\n            bucket[bi].push_back(nums[i]);//insert curr arr val to the correct range in bucket\\n        }\\n        for(int i=0;i<range;i++)\\n        {\\n            sort(bucket[i].begin(),bucket[i].end());//sort all values in bucket\\n        }\\n        int index=0;\\n        for(int i=0;i<range;i++)//modifying original arr according to sorted order of buckets\\n        {\\n            for(int j=0;j<bucket[i].size();j++)\\n            {\\n                nums[index++]=bucket[i][j];\\n            }\\n        }\\n    }\\n    int maximumGap(vector<int>& nums) \\n    {\\n        int res=0;\\n        maxGap(nums);\\n        \\n        for(int i=0;i<nums.size()-1;i++)//finding out maximum gap\\n        {\\n            res=max(res,abs(nums[i]-nums[i+1]));\\n        }\\n        return res;\\n    }\\n    };",
                "solutionTags": [
                    "C++",
                    "C",
                    "Sorting"
                ],
                "code": "class Solution {\\n    public:\\n    void maxGap(vector<int> &nums)\\n    {\\n        int mx=*max_element(nums.begin(),nums.end());//finding maximum element\\n        int mn=*min_element(nums.begin(),nums.end());//finding minimum element\\n        \\n        int n=nums.size();\\n        int range=(mx-mn)/n+1;//range or number of buckets \\n        \\n        vector<int> bucket[range];//creating a bucket array for storing different range values\\n        \\n        for(int i=0;i<n;i++)\\n        {\\n            int bi=(range*nums[i])/mx;//finding index actually on which range current index value is coming\\n            bucket[bi].push_back(nums[i]);//insert curr arr val to the correct range in bucket\\n        }",
                "codeTag": "Java"
            },
            {
                "id": 1241861,
                "title": "c-bucket-sorting-to-invent-o-n-sorting-must-use-partial-sorting",
                "content": "Approach 1: bucket sorting[1][2]\\n```\\nclass Solution {\\npublic:\\n    int maximumGap(vector<int>& nums) {\\n        const int n = nums.size();\\n        if(n < 2) return 0;\\n        int ans = 0;\\n        const auto& [minV, maxV] = minmax_element(nums.begin(), nums.end());\\n        const int range = *maxV - *minV;\\n        const int bucket_size = max(1, range/(n-1)); // minimum possible maximum gap, to prove it, refer to [1]\\n        const int bucket_num = range/bucket_size + 1; // minimum bucket number to hold ALL the array items \\n        vector<int> bucket_mins(bucket_num, INT_MAX);\\n        vector<int> bucket_maxs(bucket_num, INT_MIN);\\n        for(auto& num: nums){\\n            int bucket_idx = (num - *minV)/bucket_size;\\n            bucket_mins[bucket_idx] = min(bucket_mins[bucket_idx], num);\\n            bucket_maxs[bucket_idx] = max(bucket_maxs[bucket_idx], num);\\n        }\\n        \\n        int pre_maxV = bucket_maxs[0];        \\n        for(int i = 1; i < bucket_num; i++){\\n            if(bucket_mins[i]!=INT_MAX){ // ensure current bucket is non-empty\\n                ans = max(ans, bucket_mins[i] - pre_maxV);\\n                pre_maxV = bucket_maxs[i];\\n            }\\n        }\\n        return ans;                \\n    }\\n};\\n```\\n[1] https://leetcode.com/problems/maximum-gap/solution/\\n[2] https://zxi.mytechroad.com/blog/difficulty/hard/leetcode-164-maximum-gap/",
                "solutionTags": [
                    "C"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int maximumGap(vector<int>& nums) {\\n        const int n = nums.size();\\n        if(n < 2) return 0;\\n        int ans = 0;\\n        const auto& [minV, maxV] = minmax_element(nums.begin(), nums.end());\\n        const int range = *maxV - *minV;\\n        const int bucket_size = max(1, range/(n-1)); // minimum possible maximum gap, to prove it, refer to [1]\\n        const int bucket_num = range/bucket_size + 1; // minimum bucket number to hold ALL the array items \\n        vector<int> bucket_mins(bucket_num, INT_MAX);\\n        vector<int> bucket_maxs(bucket_num, INT_MIN);\\n        for(auto& num: nums){\\n            int bucket_idx = (num - *minV)/bucket_size;\\n            bucket_mins[bucket_idx] = min(bucket_mins[bucket_idx], num);\\n            bucket_maxs[bucket_idx] = max(bucket_maxs[bucket_idx], num);\\n        }\\n        \\n        int pre_maxV = bucket_maxs[0];        \\n        for(int i = 1; i < bucket_num; i++){\\n            if(bucket_mins[i]!=INT_MAX){ // ensure current bucket is non-empty\\n                ans = max(ans, bucket_mins[i] - pre_maxV);\\n                pre_maxV = bucket_maxs[i];\\n            }\\n        }\\n        return ans;                \\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1113111,
                "title": "c-99-o-n-time-o-n-space-pigeonhole-principle",
                "content": "```\\n#define ll long long\\nclass Solution {\\npublic:\\n    int maximumGap(vector<int>& nums) {\\n        ll maxnum=*max_element(nums.begin(),nums.end());\\n        ll minnum=*min_element(nums.begin(),nums.end());\\n        int bsize=nums.size()-1;\\n        if(bsize==0 or minnum==maxnum)return 0;\\n        double width=(maxnum-minnum + 0.0)/bsize;\\n        int maxin[bsize];\\n        int minin[bsize];\\n        for(int i=0;i<bsize;i++)\\n        {\\n            maxin[i]=INT_MIN;\\n            minin[i]=INT_MAX;\\n        }\\n        for(int i=0;i<bsize+1;i++)\\n        {\\n            if(nums[i]==minnum or nums[i]==maxnum)\\n                continue;\\n            int bnum=(nums[i]-minnum+0.0)/width;\\n            maxin[bnum]=max(nums[i],maxin[bnum]);\\n            minin[bnum]=min(nums[i],minin[bnum]);\\n        }\\n        ll res=0;\\n        ll prev=minnum;\\n        for(int i=0;i<bsize;i++)\\n        {\\n            if(maxin[i]==INT_MIN)\\n                continue;\\n            res=max(res,minin[i]-prev);\\n            prev=maxin[i];\\n        }\\n        return max(res,maxnum-prev);\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\n#define ll long long\\nclass Solution {\\npublic:\\n    int maximumGap(vector<int>& nums) {\\n        ll maxnum=*max_element(nums.begin(),nums.end());\\n        ll minnum=*min_element(nums.begin(),nums.end());\\n        int bsize=nums.size()-1;\\n        if(bsize==0 or minnum==maxnum)return 0;\\n        double width=(maxnum-minnum + 0.0)/bsize;\\n        int maxin[bsize];\\n        int minin[bsize];\\n        for(int i=0;i<bsize;i++)\\n        {\\n            maxin[i]=INT_MIN;\\n            minin[i]=INT_MAX;\\n        }\\n        for(int i=0;i<bsize+1;i++)\\n        {\\n            if(nums[i]==minnum or nums[i]==maxnum)\\n                continue;\\n            int bnum=(nums[i]-minnum+0.0)/width;\\n            maxin[bnum]=max(nums[i],maxin[bnum]);\\n            minin[bnum]=min(nums[i],minin[bnum]);\\n        }\\n        ll res=0;\\n        ll prev=minnum;\\n        for(int i=0;i<bsize;i++)\\n        {\\n            if(maxin[i]==INT_MIN)\\n                continue;\\n            res=max(res,minin[i]-prev);\\n            prev=maxin[i];\\n        }\\n        return max(res,maxnum-prev);\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 824271,
                "title": "java-o-n-heavily-commented-solution",
                "content": "```\\nclass Solution {\\n    public int maximumGap(int[] nums) {\\n        /* Idea : We will use Bucked sort to solve this question. \\n            \\n            We have to first define the intervals, We will use the min and max to find the total number of intervals needed.\\n            \\n            Now, we need the min and max value of each interval, so we  can compare it with the previous bucket.\\n            \\n            In the end we will traverse from the min to the max and then check the elements in each buckets.\\n            \\n            To assign a bucket to each element, we will use : nums[i] - min / no_of_intervals.\\n            \\n            no_of_intervals = Math.ceil((max-min)/ nums.length-1).\\n            \\n            And finally we will use the max element to check if  difference between the final element and the final bucket is the answer.\\n        */\\n        int ans =0;\\n        int size = nums.length;\\n        // Base Case :\\n        if(size < 2)\\n            return 0;\\n        \\n        int min = nums[0],max=nums[0];\\n        \\n        for(int i : nums){\\n            min = Math.min(min,i);\\n            max = Math.max(max,i);\\n        }\\n        \\n        int interval = (int)Math.ceil((max-min+0.0f)/(size-1));\\n        \\n        int[] minOfBucket = new int[size-1];\\n        int[] maxOfBucket = new int[size-1];\\n        \\n        Arrays.fill(minOfBucket, Integer.MAX_VALUE);\\n        Arrays.fill(maxOfBucket, -1);\\n        \\n        //Set the min and max of bucket.\\n        for(int i =0;i<size; i++){\\n            if(nums[i]== min || nums[i]==max)\\n                continue;\\n            \\n            int idx = (nums[i] - min)/interval;\\n            minOfBucket[idx] = Math.min(minOfBucket[idx], nums[i]);\\n            maxOfBucket[idx] = Math.max(maxOfBucket[idx], nums[i]);\\n        }\\n        \\n        \\n        // Now we will use min to see the maximum of previous bucket.\\n        for(int i =0;i<size-1;i++){\\n            if(maxOfBucket[i]==-1)\\n                continue;\\n            ans = Math.max(minOfBucket[i] - min, ans);\\n            min = maxOfBucket[i];\\n        }\\n        \\n        ans = Math.max(ans, max-min);\\n        return ans;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Bucket Sort"
                ],
                "code": "```\\nclass Solution {\\n    public int maximumGap(int[] nums) {\\n        /* Idea : We will use Bucked sort to solve this question. \\n            \\n            We have to first define the intervals, We will use the min and max to find the total number of intervals needed.\\n            \\n            Now, we need the min and max value of each interval, so we  can compare it with the previous bucket.\\n            \\n            In the end we will traverse from the min to the max and then check the elements in each buckets.\\n            \\n            To assign a bucket to each element, we will use : nums[i] - min / no_of_intervals.\\n            \\n            no_of_intervals = Math.ceil((max-min)/ nums.length-1).\\n            \\n            And finally we will use the max element to check if  difference between the final element and the final bucket is the answer.\\n        */\\n        int ans =0;\\n        int size = nums.length;\\n        // Base Case :\\n        if(size < 2)\\n            return 0;\\n        \\n        int min = nums[0],max=nums[0];\\n        \\n        for(int i : nums){\\n            min = Math.min(min,i);\\n            max = Math.max(max,i);\\n        }\\n        \\n        int interval = (int)Math.ceil((max-min+0.0f)/(size-1));\\n        \\n        int[] minOfBucket = new int[size-1];\\n        int[] maxOfBucket = new int[size-1];\\n        \\n        Arrays.fill(minOfBucket, Integer.MAX_VALUE);\\n        Arrays.fill(maxOfBucket, -1);\\n        \\n        //Set the min and max of bucket.\\n        for(int i =0;i<size; i++){\\n            if(nums[i]== min || nums[i]==max)\\n                continue;\\n            \\n            int idx = (nums[i] - min)/interval;\\n            minOfBucket[idx] = Math.min(minOfBucket[idx], nums[i]);\\n            maxOfBucket[idx] = Math.max(maxOfBucket[idx], nums[i]);\\n        }\\n        \\n        \\n        // Now we will use min to see the maximum of previous bucket.\\n        for(int i =0;i<size-1;i++){\\n            if(maxOfBucket[i]==-1)\\n                continue;\\n            ans = Math.max(minOfBucket[i] - min, ans);\\n            min = maxOfBucket[i];\\n        }\\n        \\n        ans = Math.max(ans, max-min);\\n        return ans;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 622139,
                "title": "javascript-solution-using-pigeonhole-principle-and-bucket-size",
                "content": "```\\n/**\\n * @param {number[]} nums\\n * @return {number}\\n */\\nvar maximumGap = function(nums) {\\n    let max = Math.max(...nums);\\n    let min = Math.min(...nums);\\n    \\n    let bucketSize = Math.max(1, Math.floor((max - min)/ nums.length - 1));\\n    \\n    let buckets = {};\\n    \\n    for(let i=0;i<nums.length;i++) {\\n        let bucketId = Math.floor((nums[i] - min) / bucketSize);\\n        buckets[bucketId] = {\\n            min: Math.min(nums[i], buckets[bucketId] ? buckets[bucketId].min : Infinity),\\n            max: Math.max(nums[i], buckets[bucketId] ? buckets[bucketId].max : -Infinity)\\n        };\\n    }\\n\\n\\tlet prevBucketMax = min, maxGap = 0;\\n    Object.values(buckets).forEach((b) => {\\n\\t\\t\\tmaxGap = Math.max(maxGap, b.min - prevBucketMax);\\n            prevBucketMax = b.max;\\n    });\\n    \\n    return maxGap;\\n};\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\n/**\\n * @param {number[]} nums\\n * @return {number}\\n */\\nvar maximumGap = function(nums) {\\n    let max = Math.max(...nums);\\n    let min = Math.min(...nums);\\n    \\n    let bucketSize = Math.max(1, Math.floor((max - min)/ nums.length - 1));\\n    \\n    let buckets = {};\\n    \\n    for(let i=0;i<nums.length;i++) {\\n        let bucketId = Math.floor((nums[i] - min) / bucketSize);\\n        buckets[bucketId] = {\\n            min: Math.min(nums[i], buckets[bucketId] ? buckets[bucketId].min : Infinity),\\n            max: Math.max(nums[i], buckets[bucketId] ? buckets[bucketId].max : -Infinity)\\n        };\\n    }\\n\\n\\tlet prevBucketMax = min, maxGap = 0;\\n    Object.values(buckets).forEach((b) => {\\n\\t\\t\\tmaxGap = Math.max(maxGap, b.min - prevBucketMax);\\n            prevBucketMax = b.max;\\n    });\\n    \\n    return maxGap;\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 554936,
                "title": "c-pigeonhole-principle-impl",
                "content": "```\\n    public class Solution\\n    {\\n        public int MaximumGap(int[] nums)\\n        {\\n            if (nums.Length < 2)\\n            {\\n                return 0;\\n            }\\n\\n            if (nums.Length == 2)\\n            {\\n                return Math.Abs(nums[0] - nums[1]);\\n            }\\n\\n            int min = nums.Min();\\n            int max = nums.Max();\\n\\n            int bucketSize = Math.Max(1, (max - min) / (nums.Length - 1));\\n            int bucketCount = (max - min) / bucketSize + 1;\\n\\n            (int? min, int? max)[] buckets = new (int? min, int? max)[bucketCount];\\n\\n            foreach (var num in nums)\\n            {\\n                var idx = (num - min) / bucketSize;\\n                var current = buckets[idx];\\n\\n                current.min = Math.Min(current.min.GetValueOrDefault(int.MaxValue), num);\\n                current.max = Math.Max(current.max.GetValueOrDefault(int.MinValue), num);\\n                buckets[idx] = current;\\n            }\\n\\n            int res = 0;\\n\\n            int prevGapIdx = -1;\\n            for (int i = 0; i < bucketCount; i++)\\n            {\\n                if (!buckets[i].min.HasValue)\\n                {\\n                    continue;\\n                }\\n\\n                var prev = prevGapIdx >= 0 ? buckets[prevGapIdx].max.Value : min;\\n                res = Math.Max(res, buckets[i].min.Value - prev);\\n                prevGapIdx = i;\\n            }\\n\\n            return res;\\n        }\\n    }\\n```",
                "solutionTags": [],
                "code": "```\\n    public class Solution\\n    {\\n        public int MaximumGap(int[] nums)\\n        {\\n            if (nums.Length < 2)\\n            {\\n                return 0;\\n            }\\n\\n            if (nums.Length == 2)\\n            {\\n                return Math.Abs(nums[0] - nums[1]);\\n            }\\n\\n            int min = nums.Min();\\n            int max = nums.Max();\\n\\n            int bucketSize = Math.Max(1, (max - min) / (nums.Length - 1));\\n            int bucketCount = (max - min) / bucketSize + 1;\\n\\n            (int? min, int? max)[] buckets = new (int? min, int? max)[bucketCount];\\n\\n            foreach (var num in nums)\\n            {\\n                var idx = (num - min) / bucketSize;\\n                var current = buckets[idx];\\n\\n                current.min = Math.Min(current.min.GetValueOrDefault(int.MaxValue), num);\\n                current.max = Math.Max(current.max.GetValueOrDefault(int.MinValue), num);\\n                buckets[idx] = current;\\n            }\\n\\n            int res = 0;\\n\\n            int prevGapIdx = -1;\\n            for (int i = 0; i < bucketCount; i++)\\n            {\\n                if (!buckets[i].min.HasValue)\\n                {\\n                    continue;\\n                }\\n\\n                var prev = prevGapIdx >= 0 ? buckets[prevGapIdx].max.Value : min;\\n                res = Math.Max(res, buckets[i].min.Value - prev);\\n                prevGapIdx = i;\\n            }\\n\\n            return res;\\n        }\\n    }\\n```",
                "codeTag": "Java"
            },
            {
                "id": 346881,
                "title": "python-8-lines-radix-sort-with-comments-o-n",
                "content": "Code can be more concised, but will affect readability imo. \\n```\\nclass Solution:\\n    def maximumGap(self, nums: List[int]) -> int:\\n        if len(nums) <= 1: return 0\\n\\t\\t # Convert nums list to reversed bit array list\\n        nums = [bin(num)[2:][::-1] for num in nums]                                 \\n        \\n        for i in range(max(map(len, nums))):\\n            nums0 = [x for x in nums if i >= len(x) or x[i] == \\'0\\']\\n            nums1 = [x for x in nums if i < len(x) and x[i] == \\'1\\']\\n\\t\\t\\t# it will only have two buckets (0, 1) in radix sort.\\n            nums = nums0 + nums1                                                                     \\n            \\n\\t    # convert the number back to base 10 integer. \\n        nums = [int(num[::-1], 2) for num in nums]     \\n\\t\\t# 1 pass to get the largest gap\\n        return max(nums[i] - nums[i - 1] for i in range(1, len(nums)))    \\n```\\n",
                "solutionTags": [
                    "Python",
                    "Sorting"
                ],
                "code": "```\\nclass Solution:\\n    def maximumGap(self, nums: List[int]) -> int:\\n        if len(nums) <= 1: return 0\\n\\t\\t # Convert nums list to reversed bit array list\\n        nums = [bin(num)[2:][::-1] for num in nums]                                 \\n        \\n        for i in range(max(map(len, nums))):\\n            nums0 = [x for x in nums if i >= len(x) or x[i] == \\'0\\']\\n            nums1 = [x for x in nums if i < len(x) and x[i] == \\'1\\']\\n\\t\\t\\t# it will only have two buckets (0, 1) in radix sort.\\n            nums = nums0 + nums1                                                                     \\n            \\n\\t    # convert the number back to base 10 integer. \\n        nums = [int(num[::-1], 2) for num in nums]     \\n\\t\\t# 1 pass to get the largest gap\\n        return max(nums[i] - nums[i - 1] for i in range(1, len(nums)))    \\n```",
                "codeTag": "Java"
            },
            {
                "id": 330028,
                "title": "explaining-the-bucket-method-in-layman-terms-python-code",
                "content": "Take length of nums = N\\n\\n- first of all we get max_num and min_num from the array, the maximum and minimum number from array\\n- Now not considering max_num and min_num, we have remaining N-2 numbers, we create N-1 buckets of equal size and we put numbers in them.\\n- **We are now sure that numbers falling inside the same bucket can have maximum gap of bucket_size-1**\\n\\n- **But we have created N-1 buckets for N-2 numbers, so there is at least 1 empty bucket, thus the maximum gap will come from numbers lying in the buckets to the left and right of the empty bucket**\\n- **since there is at least an empty bucket in between, so the maximum gap will be at least bucket_size**\\n- Kth bucket will have numbers lying in the range [min_num + k* bucket_size, min_num + (k+1)* bucket_size) where 0 <= k <= N-2 --> N-1 buckets\\n- we calculate bucket size = math.ceil( (max_num - min_num)/(N-1) )\\n- when we are given a number p, we can find in which bucket does it lie, which is (p-min_num)/bucket_size\\n- We store bucketMin and bucketMax, the minimum and maximum number present inside bucket, useful for calculating maxGap.\\n\\n**Take this Example, here N=8 so buckets = N-1 = 7:**\\n![image](https://assets.leetcode.com/users/gulshan98125/image_1562573422.png)\\n\\n\\n\\n**Python code:**\\n```\\nimport math\\nclass Solution(object):\\n    def maximumGap(self, nums):\\n        if not nums or len(nums)<2:\\n            return 0\\n        N = len(nums)\\n        min_num = float(\\'inf\\')\\n        max_num = -float(\\'inf\\')\\n        \\n        for p in nums:\\n            min_num = min(p,min_num)\\n            max_num = max(p,max_num)\\n        \\n        bucketMin = [float(\\'inf\\') for i in xrange(N-1)]\\n        bucketMax = [-float(\\'inf\\') for i in xrange(N-1)]\\n        \\n        #math.ceil so that it can accomodate all the between numbers\\n        bucket_size = int(math.ceil( (max_num-min_num)/float((N-1)) ))\\n        \\n        for p in nums:\\n            if p==min_num or p==max_num:\\n                continue\\n            index = (p-min_num)/bucket_size\\n            bucketMin[index] = min(p,bucketMin[index])\\n            bucketMax[index] = max(p,bucketMax[index])\\n        \\n        maxGap = -float(\\'inf\\')\\n        previous = min_num\\n        \\n        for bucket_num in xrange(N-1):\\n            #if empty bucket then skip\\n            if bucketMin[bucket_num]== float(\\'inf\\') or \\\\\\n            bucketMax[bucket_num]== -float(\\'inf\\'):\\n                continue\\n                \\n            maxGap = max(maxGap,bucketMin[bucket_num]-previous)\\n            previous = bucketMax[bucket_num]\\n        \\n        maxGap = max(maxGap, max_num - previous);\\n        return maxGap\\n```",
                "solutionTags": [],
                "code": "```\\nimport math\\nclass Solution(object):\\n    def maximumGap(self, nums):\\n        if not nums or len(nums)<2:\\n            return 0\\n        N = len(nums)\\n        min_num = float(\\'inf\\')\\n        max_num = -float(\\'inf\\')\\n        \\n        for p in nums:\\n            min_num = min(p,min_num)\\n            max_num = max(p,max_num)\\n        \\n        bucketMin = [float(\\'inf\\') for i in xrange(N-1)]\\n        bucketMax = [-float(\\'inf\\') for i in xrange(N-1)]\\n        \\n        #math.ceil so that it can accomodate all the between numbers\\n        bucket_size = int(math.ceil( (max_num-min_num)/float((N-1)) ))\\n        \\n        for p in nums:\\n            if p==min_num or p==max_num:\\n                continue\\n            index = (p-min_num)/bucket_size\\n            bucketMin[index] = min(p,bucketMin[index])\\n            bucketMax[index] = max(p,bucketMax[index])\\n        \\n        maxGap = -float(\\'inf\\')\\n        previous = min_num\\n        \\n        for bucket_num in xrange(N-1):\\n            #if empty bucket then skip\\n            if bucketMin[bucket_num]== float(\\'inf\\') or \\\\\\n            bucketMax[bucket_num]== -float(\\'inf\\'):\\n                continue\\n                \\n            maxGap = max(maxGap,bucketMin[bucket_num]-previous)\\n            previous = bucketMax[bucket_num]\\n        \\n        maxGap = max(maxGap, max_num - previous);\\n        return maxGap\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3408256,
                "title": "easy-way-to-solve-c",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nJust the brute force way.\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. --> \\nSimply we create a **max variable** and intilize it with zero and **check the difference** of the elements and **update max if greater** than the earlier value stored in it.\\n\\n![image.png](https://assets.leetcode.com/users/images/1f3ad12b-6c3e-4f51-b127-a2c50cfacf57_1681293191.8231432.png)\\n\\n\\n\\n# Complexity\\n- Time complexity:O(nlogn)-> **As we are using only one loop and sort inbuilt function.**\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n\\n- Space complexity:O(1)-> **No extra space created**\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int maximumGap(vector<int>& nums) {\\n        //if size of the given array is less than 2 there is no use of finding difference\\n        if(nums.size()<2){\\n            return 0;\\n        }\\n        sort(nums.begin(),nums.end());\\n        int max=0;\\n        for(int i=0;i<nums.size()-1;i++){\\n                if(nums[i+1] -nums[i]>max){\\n                    max=nums[i+1] -nums[i];\\n                }\\n        }\\n        return max;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int maximumGap(vector<int>& nums) {\\n        //if size of the given array is less than 2 there is no use of finding difference\\n        if(nums.size()<2){\\n            return 0;\\n        }\\n        sort(nums.begin(),nums.end());\\n        int max=0;\\n        for(int i=0;i<nums.size()-1;i++){\\n                if(nums[i+1] -nums[i]>max){\\n                    max=nums[i+1] -nums[i];\\n                }\\n        }\\n        return max;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3001449,
                "title": "short-clean-priorityqueue-java",
                "content": "```java []\\nclass Solution {\\n    public int maximumGap(int[] nums) {\\n        PriorityQueue<Integer> pq = new PriorityQueue<>();\\n        for(int num: nums)    pq.add(num);\\n        int max_diff = 0;\\n        while(pq.size() > 1){\\n            max_diff = Math.max(max_diff, Math.abs(pq.poll()-pq.peek()));\\n        }\\n        return max_diff;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Heap (Priority Queue)"
                ],
                "code": "```java []\\nclass Solution {\\n    public int maximumGap(int[] nums) {\\n        PriorityQueue<Integer> pq = new PriorityQueue<>();\\n        for(int num: nums)    pq.add(num);\\n        int max_diff = 0;\\n        while(pq.size() > 1){\\n            max_diff = Math.max(max_diff, Math.abs(pq.poll()-pq.peek()));\\n        }\\n        return max_diff;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2481421,
                "title": "real-o-n-solution-using-rounding",
                "content": "\\n\\t\\tclass Solution:\\n\\t\\tdef maximumGap(self, nums: List[int]) -> int:\\n\\t\\t\\tn=len(nums)\\n\\t\\t\\tif n==1:\\n\\t\\t\\t\\treturn 0\\n\\t\\t\\tmin_val = min(nums)\\n\\t\\t\\tmax_val = max(nums)\\n\\n\\t\\t\\tif max_val==min_val:\\n\\t\\t\\t\\treturn 0\\n\\n\\t\\t\\tRange = max_val-min_val\\n\\n\\n\\t\\t\\twidth = Range/n\\n\\n\\t\\t\\tpartition = [ [] for _ in range( int(min_val/width),int(max_val/width)+1)]\\n\\n\\t\\t\\tshift = min_val/width\\n\\n\\t\\t\\tfor num in nums:\\n\\t\\t\\t\\ttemp = num/width\\n\\t\\t\\t\\tpartition[int(temp-shift)].append(num)\\n\\n\\t\\t\\tj=0\\n\\t\\t\\tdif = 0\\n\\t\\t\\tfor i in range(1,len(partition)):\\n\\t\\t\\t\\tif partition[i]:\\n\\t\\t\\t\\t\\tdif = max(dif,min(partition[i])-max(partition[j]))\\n\\t\\t\\t\\t\\tj=i\\n\\n\\t\\t\\treturn dif\\n",
                "solutionTags": [],
                "code": "\\n\\t\\tclass Solution:\\n\\t\\tdef maximumGap(self, nums: List[int]) -> int:\\n\\t\\t\\tn=len(nums)\\n\\t\\t\\tif n==1:\\n\\t\\t\\t\\treturn 0\\n\\t\\t\\tmin_val = min(nums)\\n\\t\\t\\tmax_val = max(nums)\\n\\n\\t\\t\\tif max_val==min_val:\\n\\t\\t\\t\\treturn 0\\n\\n\\t\\t\\tRange = max_val-min_val\\n\\n\\n\\t\\t\\twidth = Range/n\\n\\n\\t\\t\\tpartition = [ [] for _ in range( int(min_val/width),int(max_val/width)+1)]\\n\\n\\t\\t\\tshift = min_val/width\\n\\n\\t\\t\\tfor num in nums:\\n\\t\\t\\t\\ttemp = num/width\\n\\t\\t\\t\\tpartition[int(temp-shift)].append(num)\\n\\n\\t\\t\\tj=0\\n\\t\\t\\tdif = 0\\n\\t\\t\\tfor i in range(1,len(partition)):\\n\\t\\t\\t\\tif partition[i]:\\n\\t\\t\\t\\t\\tdif = max(dif,min(partition[i])-max(partition[j]))\\n\\t\\t\\t\\t\\tj=i\\n\\n\\t\\t\\treturn dif\\n",
                "codeTag": "Java"
            },
            {
                "id": 1861119,
                "title": "c-conceptual-radixsort-based-algorithm-without-stl-linear-time-as-asked-in-question",
                "content": "Pls Upvote if you Like the solution\\nIf you don\\'t have idea of how radix sort works, [click here](https://www.javatpoint.com/radix-sort).\\n```\\nclass Solution {\\npublic:\\n    int maximumGap(vector<int>& nums) {\\n        int n=nums.size();\\n        if(n==1){\\n            return 0;\\n        }\\n        if(n==2){\\n            return abs(nums[0]-nums[1]);\\n        }\\n        int power=1;\\n        int maxDigits=log10(*max_element(nums.begin(),nums.end()))+1;\\n        bool check=true;\\n        while(maxDigits--){\\n            vector<int> temp(n);\\n            vector<int>count(10,0);\\n            for(int i=0;i<n;i++){\\n                int digit=(int)(nums[i]/power)%10;\\n                count[digit]++;\\n            }\\n            for(int i=1;i<10;i++)\\n                count[i]+=count[i-1];\\n            for(int i=n-1;i>=0;i--){\\n                int digit=(int)(nums[i]/power)%10;\\n                temp[--count[digit]]=nums[i];\\n            }\\n            nums=temp;\\n            power*=10;\\n            \\n        }\\n        int ans=abs(nums[0]-nums[1]);\\n        for(int i:nums){\\n            cout<<i<<\" \";\\n        }\\n        for(int i=1;i<n;i++){\\n            ans=max(ans,abs(nums[i]-nums[i-1]));\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int maximumGap(vector<int>& nums) {\\n        int n=nums.size();\\n        if(n==1){\\n            return 0;\\n        }\\n        if(n==2){\\n            return abs(nums[0]-nums[1]);\\n        }\\n        int power=1;\\n        int maxDigits=log10(*max_element(nums.begin(),nums.end()))+1;\\n        bool check=true;\\n        while(maxDigits--){\\n            vector<int> temp(n);\\n            vector<int>count(10,0);\\n            for(int i=0;i<n;i++){\\n                int digit=(int)(nums[i]/power)%10;\\n                count[digit]++;\\n            }\\n            for(int i=1;i<10;i++)\\n                count[i]+=count[i-1];\\n            for(int i=n-1;i>=0;i--){\\n                int digit=(int)(nums[i]/power)%10;\\n                temp[--count[digit]]=nums[i];\\n            }\\n            nums=temp;\\n            power*=10;\\n            \\n        }\\n        int ans=abs(nums[0]-nums[1]);\\n        for(int i:nums){\\n            cout<<i<<\" \";\\n        }\\n        for(int i=1;i<n;i++){\\n            ans=max(ans,abs(nums[i]-nums[i-1]));\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "C++"
            },
            {
                "id": 1330979,
                "title": "radix-sort-o-31-n-time-o-1-space-solution",
                "content": "```\\nvoid radix( vector<int>&A , int st , int en , int p )\\n{\\n    if( p < 0 )return ;\\n    if( st >= en )return ;\\n    int l = st ;\\n    int h = en ;\\n    while( l <= h )\\n    {\\n        if( A[l]&(1<<p) )\\n            swap( A[l] , A[h--] );\\n        else\\n            l++;\\n    }\\n    radix( A , st , l-1 , p-1 );\\n    radix( A , l , en , p-1 );\\n}\\n\\nclass Solution {\\npublic:\\nint maximumGap(vector<int>& A ) {\\n    int N = A.size();\\n    radix( A , 0 , N-1 , 31 );\\n    int mx = 0 ; \\n    for( int i = 0 ; i < N-1 ; i++ )\\n        mx = max( mx , A[i+1] - A[i] );\\n    return mx ;\\n  }\\n};\\n\\n// time complexity - O(32*N) \\n// space complexity - O(1) \\n```",
                "solutionTags": [],
                "code": "```\\nvoid radix( vector<int>&A , int st , int en , int p )\\n{\\n    if( p < 0 )return ;\\n    if( st >= en )return ;\\n    int l = st ;\\n    int h = en ;\\n    while( l <= h )\\n    {\\n        if( A[l]&(1<<p) )\\n            swap( A[l] , A[h--] );\\n        else\\n            l++;\\n    }\\n    radix( A , st , l-1 , p-1 );\\n    radix( A , l , en , p-1 );\\n}\\n\\nclass Solution {\\npublic:\\nint maximumGap(vector<int>& A ) {\\n    int N = A.size();\\n    radix( A , 0 , N-1 , 31 );\\n    int mx = 0 ; \\n    for( int i = 0 ; i < N-1 ; i++ )\\n        mx = max( mx , A[i+1] - A[i] );\\n    return mx ;\\n  }\\n};\\n\\n// time complexity - O(32*N) \\n// space complexity - O(1) \\n```",
                "codeTag": "Java"
            },
            {
                "id": 1316807,
                "title": "simplest-c-solution-using-bucket-sort-o-n",
                "content": "```\\nclass Solution {\\npublic:\\n    int maximumGap(vector<int>& nums) {\\n        int maxe=*max_element(nums.begin(),nums.end());\\n        int mine=*min_element(nums.begin(),nums.end());\\n        \\n        int n=nums.size();\\n        \\n        int range=(maxe-mine)/n +1;\\n        vector<vector<int>> bucket(n+1);\\n        if(range==0)\\n            return 0;\\n        for(int i=0;i<n;i++)\\n        {\\n            int index=(nums[i]-mine)/range;\\n            bucket[index].push_back(nums[i]);\\n        }\\n        int prev=mine;\\n        int ans=INT_MIN;\\n        for(auto b:bucket)\\n        {\\n            sort(b.begin(),b.end());\\n            for(int i:b)\\n            {\\n                ans=max(ans,i-prev);\\n                prev=i;\\n            }\\n        }\\n        return ans;\\n    }\\n};\\n\\n```",
                "solutionTags": [
                    "C",
                    "Bucket Sort"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int maximumGap(vector<int>& nums) {\\n        int maxe=*max_element(nums.begin(),nums.end());\\n        int mine=*min_element(nums.begin(),nums.end());\\n        \\n        int n=nums.size();\\n        \\n        int range=(maxe-mine)/n +1;\\n        vector<vector<int>> bucket(n+1);\\n        if(range==0)\\n            return 0;\\n        for(int i=0;i<n;i++)\\n        {\\n            int index=(nums[i]-mine)/range;\\n            bucket[index].push_back(nums[i]);\\n        }\\n        int prev=mine;\\n        int ans=INT_MIN;\\n        for(auto b:bucket)\\n        {\\n            sort(b.begin(),b.end());\\n            for(int i:b)\\n            {\\n                ans=max(ans,i-prev);\\n                prev=i;\\n            }\\n        }\\n        return ans;\\n    }\\n};\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1241833,
                "title": "approach-using-radix-sort-easy-understandable-code-o-10-n-log10-maxe",
                "content": "Please give a upvote if you like this solutions. Comment if you didn\\'t get it.\\n```\\nclass Solution {\\n    \\n    void radixSort(vector<int> &nums, int value, int N) {\\n        \\n        int countDigit[10] = {0};\\n        \\n        for(int i = 0; i < N; i++) {\\n            int element = nums[i]/value;\\n            countDigit[element%10] += 1;\\n        }\\n        \\n        for(int i = 1; i < 10; i++) {\\n            countDigit[i] += countDigit[i - 1];\\n        }\\n        \\n        int sorteByPlace[N];\\n        \\n        int ans[N];\\n        \\n        for(int i = N - 1; i >= 0; i--) {\\n            \\n            int element = nums[i]/value;\\n\\t        int correctIndex = countDigit[element % 10] - 1;            \\n            sorteByPlace[correctIndex] = nums[i];\\t        \\n\\t        countDigit[element % 10] -= 1;\\n\\t    }\\n        \\n        for(int i = 0; i < N; i++) {\\n            nums[i] = sorteByPlace[i];\\n        }\\n    }\\n    \\npublic:\\n    int maximumGap(vector<int>& nums) {\\n        \\n        int N = nums.size();\\n        if(N < 2) return 0;\\n        \\n        int maxElement = *max_element(nums.begin(), nums.end());\\n        int value = 1;\\n\\t\\t\\n\\t\\t// Iterate till each digit from one\\'s place to the\\n\\t\\t// ten\\'s to the hundred\\'s  and so on\\n        while(value <= maxElement) {\\n            radixSort(nums, value, N);\\n            value *= 10;\\n        }\\n        \\n        int maxDifference = -1;\\n        for(int i = 0; i < N - 1; i++) {\\n            maxDifference = max(maxDifference, nums[i + 1] - nums[i]);\\n        }\\n        \\n        return maxDifference;\\n        \\n    }\\n};\\n```\\nTime Complexity: O((10 + N)\\\\*log10(maxE))\\nAuxiliary Space: O(N)",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    \\n    void radixSort(vector<int> &nums, int value, int N) {\\n        \\n        int countDigit[10] = {0};\\n        \\n        for(int i = 0; i < N; i++) {\\n            int element = nums[i]/value;\\n            countDigit[element%10] += 1;\\n        }\\n        \\n        for(int i = 1; i < 10; i++) {\\n            countDigit[i] += countDigit[i - 1];\\n        }\\n        \\n        int sorteByPlace[N];\\n        \\n        int ans[N];\\n        \\n        for(int i = N - 1; i >= 0; i--) {\\n            \\n            int element = nums[i]/value;\\n\\t        int correctIndex = countDigit[element % 10] - 1;            \\n            sorteByPlace[correctIndex] = nums[i];\\t        \\n\\t        countDigit[element % 10] -= 1;\\n\\t    }\\n        \\n        for(int i = 0; i < N; i++) {\\n            nums[i] = sorteByPlace[i];\\n        }\\n    }\\n    \\npublic:\\n    int maximumGap(vector<int>& nums) {\\n        \\n        int N = nums.size();\\n        if(N < 2) return 0;\\n        \\n        int maxElement = *max_element(nums.begin(), nums.end());\\n        int value = 1;\\n\\t\\t\\n\\t\\t// Iterate till each digit from one\\'s place to the\\n\\t\\t// ten\\'s to the hundred\\'s  and so on\\n        while(value <= maxElement) {\\n            radixSort(nums, value, N);\\n            value *= 10;\\n        }\\n        \\n        int maxDifference = -1;\\n        for(int i = 0; i < N - 1; i++) {\\n            maxDifference = max(maxDifference, nums[i + 1] - nums[i]);\\n        }\\n        \\n        return maxDifference;\\n        \\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 296892,
                "title": "java-radix-sort-solution-with-explanation",
                "content": "```\\npublic int maximumGap(int[] nums) {\\n    int max = 0; // the number of sort passes depends on the base of max element\\n    for(int i = 0; i < nums.length; i++)\\n        max = Math.max(nums[i], max);\\n\\n    int divisor = 1;\\n    int temp[][] = new int[10][nums.length]; // save the elements in ten buckets\\n    int count[] = new int[10]; // count the size of each bucket\\n    \\n    while( divisor <= max ) { // sort the array\\n        for(int i = 0; i < nums.length; i++) { // put elements into corresponding bucket\\n            int index = (nums[i] / divisor) % 10;\\n            temp[index][count[index]] = nums[i];\\n            count[index]++;\\n        }\\n\\n        int current = 0;\\n        for(int i = 0; i < 10; i++) { // update nums after each turn\\n            for(int j = 0; j < count[i]; j++) {\\n                nums[current++] = temp[i][j];\\n            }\\n            count[i] = 0;\\n        }\\n\\n        divisor *= 10;\\n    }\\n\\n    int result = 0;\\n    for(int i = 1; i < nums.length; i++)\\n        result = Math.max(nums[i] - nums[i - 1], result);\\n\\n    return result;\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\npublic int maximumGap(int[] nums) {\\n    int max = 0; // the number of sort passes depends on the base of max element\\n    for(int i = 0; i < nums.length; i++)\\n        max = Math.max(nums[i], max);\\n\\n    int divisor = 1;\\n    int temp[][] = new int[10][nums.length]; // save the elements in ten buckets\\n    int count[] = new int[10]; // count the size of each bucket\\n    \\n    while( divisor <= max ) { // sort the array\\n        for(int i = 0; i < nums.length; i++) { // put elements into corresponding bucket\\n            int index = (nums[i] / divisor) % 10;\\n            temp[index][count[index]] = nums[i];\\n            count[index]++;\\n        }\\n\\n        int current = 0;\\n        for(int i = 0; i < 10; i++) { // update nums after each turn\\n            for(int j = 0; j < count[i]; j++) {\\n                nums[current++] = temp[i][j];\\n            }\\n            count[i] = 0;\\n        }\\n\\n        divisor *= 10;\\n    }\\n\\n    int result = 0;\\n    for(int i = 1; i < nums.length; i++)\\n        result = Math.max(nums[i] - nums[i - 1], result);\\n\\n    return result;\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 50680,
                "title": "java-radix-sort",
                "content": "Because the question has tell us that every number has 32 bits. This can remind us to use radix sort whose run time and extra space are both linear.\\n~~~\\npublic class Solution {\\n    public int maximumGap(int[] nums) {\\n        if(nums == null || nums.length == 0 || nums.length == 1) {\\n            return 0;\\n        }\\n        int res = 0;\\n        radixsort(nums);\\n        for(int i = 1 ; i < nums.length ; i++) {\\n            res = Math.max(res , nums[i] - nums[i-1]);\\n        }\\n        return res;\\n    }\\n    \\n    protected void radixsort(int[] nums) {\\n        int[] temp = new int[nums.length];\\n        for(int i = 0 ; i < 32 ; i++) {\\n            int[] c = new int[2];\\n            for(int num : nums) {\\n                int digit = num >> i;\\n                if((digit & 1) == 0) c[0]++;\\n                else c[1]++;\\n            }\\n            c[1] = c[0] + c[1];\\n            for(int j = nums.length-1 ; j >= 0 ; j--) {\\n                int digit = (nums[j] >> i) & 1;\\n                temp[c[digit]-1] = nums[j];\\n                c[digit]--;\\n            }\\n            for(int j = 0 ; j < nums.length ; j++) {\\n                nums[j] = temp[j];\\n            }\\n        }\\n    }\\n}",
                "solutionTags": [],
                "code": "class Solution {\\n    public int maximumGap(int[] nums) {\\n        if(nums == null || nums.length == 0 || nums.length == 1) {\\n            return 0;\\n        }",
                "codeTag": "Java"
            },
            {
                "id": 50684,
                "title": "c-12ms-bucket-sort",
                "content": "    class Solution {\\n    public:\\n        //bucket sort\\n        int maximumGap(vector<int>& nums) {\\n            int len = nums.size();\\n            if(len < 2){\\n                return 0;\\n            }\\n            int minValue = INT_MAX;\\n            int maxValue = INT_MIN;\\n            for(int i : nums){\\n                minValue = min(minValue, i);\\n                maxValue = max(maxValue, i);\\n            }\\n            int gap = ceil(double((maxValue - minValue))/ (len - 1));\\n            vector<int> minGaps(len - 1, INT_MAX);// the minmum value of each bucket\\n            vector<int> maxGaps(len - 1, INT_MIN);\\n            for(int i : nums){ // fill in the bucket\\n                if(i == minValue || i == maxValue){\\n                    continue;\\n                }\\n                int gapidx = (i - minValue) / gap;\\n                minGaps[gapidx] = min(minGaps[gapidx], i);\\n                maxGaps[gapidx] = max(maxGaps[gapidx], i);\\n            }\\n            int pre = minValue;\\n            int ans = INT_MIN;\\n            for(int i = 0; i < len - 1; ++i){\\n                if(minGaps[i] == INT_MAX && maxGaps[i] == INT_MIN){\\n                    continue;\\n                }\\n                ans = max(ans, minGaps[i] - pre);\\n                pre = maxGaps[i];\\n            }\\n            ans = max(ans, maxValue - pre);\\n            return ans;\\n        }\\n    };",
                "solutionTags": [
                    "C++"
                ],
                "code": "class Solution {\\n    public:\\n        //bucket sort\\n        int maximumGap(vector<int>& nums) {\\n            int len = nums.size();\\n            if(len < 2){\\n                return 0;\\n            }",
                "codeTag": "Java"
            },
            {
                "id": 50699,
                "title": "clean-c-implementation-based-on-radix-sort",
                "content": " Please refer to  \\n[https://leetcode.com/discuss/80529/recommend-beginners-implementation-detailed-explaination][1]\\n\\nfor implementation details and explainations.\\n\\n      class Solution {\\n        public:\\n            /* radix-based-sorting-implementation */\\n            int maximumGap(vector<int>& nums){\\n                radixSort(nums);\\n            \\tint result = 0;\\n            \\tfor (int i = 1; i < nums.size(); i++){\\n            \\t\\tresult = max(result, nums[i] - nums[i - 1]);\\n            \\t}\\n            \\treturn result;\\n            }\\n            \\n            void countingSort(vector<int>& X, int exp, int base){\\n            \\tint len = X.size();\\n            \\tint start = INT_MAX, end = INT_MIN;\\n            \\tfor (int i = 0; i < len; i++){\\n            \\t\\tstart = min(start, (X[i] / exp)%base);\\n            \\t\\tend = max(end, (X[i] / exp) % base);\\n            \\t}\\n            \\tint range = end - start + 1;\\n            \\tvector<int> count(range, 0);\\n            \\tvector<int> result(len, 0);\\n            \\tfor (int i = 0; i < len; i++){\\n            \\t\\tcount[(X[i] / exp) % base -start]++;\\n            \\t}\\n            \\tfor (int i = 1; i < range; i++){\\n            \\t\\tcount[i] = count[i - 1] + count[i];\\n            \\t}\\n            \\t//back-ward traverse is stable sorting\\n            \\tfor (int i = len - 1; i >= 0; i--){\\n            \\t\\t//as we know that the count array recorded element should '-1' to get the index\\n            \\t\\tresult[count[(X[i] / exp) % base -start] - 1] = X[i];\\n            \\t\\tcount[(X[i] / exp) % base - start]--;\\n            \\t}\\n            \\tfor (int i = 0; i < len; i++){\\n            \\t\\tX[i] = result[i];\\n            \\t}\\n            }\\n        \\n            void radixSort(vector<int> &X){\\n            \\tint len = X.size();\\n            \\tint max_val = INT_MIN;\\n            \\tint base = 10;\\n            \\tfor (int i = 0; i < len; i++) max_val = max(X[i], max_val);\\n            \\tfor (int exp = 1; max_val / exp>0; exp *= base){\\n            \\t\\tcountingSort(X, exp, base);\\n            \\t}\\n            }\\n        };\\n\\n  [1]: https://leetcode.com/discuss/80529/recommend-beginners-implementation-detailed-explaination",
                "solutionTags": [],
                "code": "class Solution {\\n        public:\\n            /* radix-based-sorting-implementation */\\n            int maximumGap(vector<int>& nums){\\n                radixSort(nums);\\n            \\tint result = 0;\\n            \\tfor (int i = 1; i < nums.size(); i++){\\n            \\t\\tresult = max(result, nums[i] - nums[i - 1]);\\n            \\t}",
                "codeTag": "Java"
            },
            {
                "id": 50709,
                "title": "radix-sort-in-python",
                "content": "    \\n    class Solution(object):\\n    \"\"\"\\n    Radix sort, you can see the explanation follow the links.\\n    https://www.cs.usfca.edu/~galles/visualization/RadixSort.html\\n    \"\"\"\\n    def maximumGap(self, nums):\\n        if not nums:\\n            return 0\\n\\n        max_num = max(nums)\\n        bucket = [[] for i in range(10)]\\n        exp = 1\\n        while max_num / exp > 0:\\n            for num in nums:\\n                bucket[(num/exp) % 10].append(num)\\n            nums = []\\n            for each in bucket:\\n                nums.extend(each)\\n            bucket = [[] for i in range(10)]\\n            exp *= 10\\n\\n        max_gap = 0\\n        for i in range(1, len(nums)):\\n            max_gap = max(max_gap, nums[i]-nums[i-1])\\n        return max_gap",
                "solutionTags": [
                    "Python"
                ],
                "code": "    \\n    class Solution(object):\\n    \"\"\"\\n    Radix sort, you can see the explanation follow the links.\\n    https://www.cs.usfca.edu/~galles/visualization/RadixSort.html\\n    \"\"\"\\n    def maximumGap(self, nums):\\n        if not nums:\\n            return 0\\n\\n        max_num = max(nums)\\n        bucket = [[] for i in range(10)]\\n        exp = 1\\n        while max_num / exp > 0:\\n            for num in nums:\\n                bucket[(num/exp) % 10].append(num)\\n            nums = []\\n            for each in bucket:\\n                nums.extend(each)\\n            bucket = [[] for i in range(10)]\\n            exp *= 10\\n\\n        max_gap = 0\\n        for i in range(1, len(nums)):\\n            max_gap = max(max_gap, nums[i]-nums[i-1])\\n        return max_gap",
                "codeTag": "Java"
            },
            {
                "id": 50735,
                "title": "concise-ac-java-standard-buckets",
                "content": "   I believe it's the simplest approach to distributed also min/max. It simplifies also last loop. Regards.\\n\\n    public class Solution {\\n      private class Pair {\\n        int min, max;\\n        public Pair(int min, int max) {\\n            this.min = min; this.max = max;\\n        }\\n      }\\n      public int maximumGap(int[] num) {\\n        if (num == null || num.length < 2) {\\n            return 0;\\n        }\\n        int min=num[0], max=num[0], N=num.length;\\n        for (int n: num) {\\n            min = Math.min(min, n);\\n            max = Math.max(max, n);\\n        }\\n        if (max == min) return 0;\\n        int dist=(((max-min)-1)/(N-1))+1;\\n        Pair[] buckets = new Pair[N];\\n        for(int n: num) {\\n            int bucket = (n-min)/dist;\\n            Pair p = buckets[bucket];\\n            if (p == null) {\\n                buckets[bucket] = new Pair(n, n);\\n            } else {\\n                p.min = Math.min(p.min, n);\\n                p.max = Math.max(p.max, n);\\n            }\\n        }\\n        max = dist;\\n        int prevBucketMax=buckets[0].max;\\n        for (int i=1; i<buckets.length; i++) {\\n            if (buckets[i] == null) continue;\\n            max = Math.max(max, buckets[i].min-prevBucketMax);\\n            prevBucketMax = buckets[i].max;\\n        }\\n        return max;\\n      }\\n    }",
                "solutionTags": [
                    "Java"
                ],
                "code": "class Solution {\\n      private class Pair {\\n        int min, max;\\n        public Pair(int min, int max) {\\n            this.min = min; this.max = max;\\n        }",
                "codeTag": "Java"
            },
            {
                "id": 3867555,
                "title": "using-radix-sort-c-in-linear-time-and-space",
                "content": "# Code\\n```\\nclass Solution {\\npublic:\\n    int maximumGap(vector<int>& nums) {\\n        if(nums.size()<2){\\n            return 0;\\n        }\\n        int ans=0;\\n        int n=nums.size();\\n        int maxi=0;\\n        for(int i=0;i<n;i++){\\n            maxi=max(maxi,nums[i]);\\n        }\\n        string num=to_string(maxi);\\n        int len=num.size();\\n        long int a=10;\\n        long int b=1;\\n        vector<int>count(10,0);\\n        vector<int>dup(n);\\n        for(int i=0;i<len;i++){\\n            for(auto j:nums){   \\n                int val=((j%a)/b);\\n                count[val]++;\\n            }\\n            for(int j=1;j<10;j++){\\n                count[j]+=count[j-1];\\n            }\\n            for(int k=n-1;k>=0;k--){\\n                int j=nums[k];\\n                int val=((j%a)/b);\\n                count[val]--;\\n                int ind=count[val];\\n                dup[ind]=j;\\n            }\\n            for(int j=0;j<n;j++){\\n                nums[j]=dup[j];\\n            }\\n            for(int j=0;j<10;j++){\\n                count[j]=0;\\n            }\\n            a*=10;\\n            b*=10;\\n        }\\n        for(int i=1;i<n;i++){\\n            ans=max(ans,nums[i]-nums[i-1]);\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int maximumGap(vector<int>& nums) {\\n        if(nums.size()<2){\\n            return 0;\\n        }\\n        int ans=0;\\n        int n=nums.size();\\n        int maxi=0;\\n        for(int i=0;i<n;i++){\\n            maxi=max(maxi,nums[i]);\\n        }\\n        string num=to_string(maxi);\\n        int len=num.size();\\n        long int a=10;\\n        long int b=1;\\n        vector<int>count(10,0);\\n        vector<int>dup(n);\\n        for(int i=0;i<len;i++){\\n            for(auto j:nums){   \\n                int val=((j%a)/b);\\n                count[val]++;\\n            }\\n            for(int j=1;j<10;j++){\\n                count[j]+=count[j-1];\\n            }\\n            for(int k=n-1;k>=0;k--){\\n                int j=nums[k];\\n                int val=((j%a)/b);\\n                count[val]--;\\n                int ind=count[val];\\n                dup[ind]=j;\\n            }\\n            for(int j=0;j<n;j++){\\n                nums[j]=dup[j];\\n            }\\n            for(int j=0;j<10;j++){\\n                count[j]=0;\\n            }\\n            a*=10;\\n            b*=10;\\n        }\\n        for(int i=1;i<n;i++){\\n            ans=max(ans,nums[i]-nums[i-1]);\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3841213,
                "title": "python-easy-solution-100-beginners-friendly",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\nAs descripted is problem if array have 1 element then return 0\\nNext will sort the arrey and get the diffrence of each element and compare the value of max variable to this.\\n\\n# Complexity\\n- Time complexity: $$O(n)$$\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: $$O(n)$$\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution:\\n    def maximumGap(self, nums: List[int]) -> int:\\n        mx = 0\\n        if len(nums)<2:\\n            return 0\\n        else:\\n            nums.sort()\\n            for i in range(len(nums)-1):\\n                mx = max(mx, (nums[i+1])-nums[i])\\n            return mx\\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def maximumGap(self, nums: List[int]) -> int:\\n        mx = 0\\n        if len(nums)<2:\\n            return 0\\n        else:\\n            nums.sort()\\n            for i in range(len(nums)-1):\\n                mx = max(mx, (nums[i+1])-nums[i])\\n            return mx\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3838809,
                "title": "simple-kotlin-solution",
                "content": "# Code\\n```\\nimport kotlin.math.abs\\n\\nclass Solution {\\n    fun maximumGap(nums: IntArray) =\\n        nums.takeIf { it.size > 1 }?.sorted()?.run {\\n            List(size - 1) { abs(get(it) - get(it + 1)) }.max()\\n        } ?: 0\\n}\\n```",
                "solutionTags": [
                    "Kotlin"
                ],
                "code": "```\\nimport kotlin.math.abs\\n\\nclass Solution {\\n    fun maximumGap(nums: IntArray) =\\n        nums.takeIf { it.size > 1 }?.sorted()?.run {\\n            List(size - 1) { abs(get(it) - get(it + 1)) }.max()\\n        } ?: 0\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3673520,
                "title": "without-solution-life-is-nothing",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution:\\n    def maximumGap(self, nums: List[int]) -> int:\\n        if len(nums)<2:\\n            return 0\\n        ls = sorted(nums)\\n        a = []\\n        for i in range(1,len(ls)):\\n            a.append(ls[i]-ls[i-1])\\n        return max(a)\\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def maximumGap(self, nums: List[int]) -> int:\\n        if len(nums)<2:\\n            return 0\\n        ls = sorted(nums)\\n        a = []\\n        for i in range(1,len(ls)):\\n            a.append(ls[i]-ls[i-1])\\n        return max(a)\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3615306,
                "title": "easy-c-solution-t-c-o-nlogn-and-s-c-o-1",
                "content": "\\n\\n# Complexity\\n- Time complexity: O(1)\\n\\n- Space complexity: O(nlogn)\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int maximumGap(vector<int>& nums) {\\n        if(nums.size()==1){\\n            return 0;\\n        }\\n        int ans;\\n        sort(nums.begin(),nums.end());\\n        for(int i=0; i<nums.size()-1;i++){\\n            int maxi = 0;\\n            maxi = nums[i+1]-nums[i];\\n\\n            if(maxi>ans){\\n                ans = maxi;\\n            }\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Array",
                    "Sorting"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int maximumGap(vector<int>& nums) {\\n        if(nums.size()==1){\\n            return 0;\\n        }\\n        int ans;\\n        sort(nums.begin(),nums.end());\\n        for(int i=0; i<nums.size()-1;i++){\\n            int maxi = 0;\\n            maxi = nums[i+1]-nums[i];\\n\\n            if(maxi>ans){\\n                ans = maxi;\\n            }\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3588866,
                "title": "maximum-gap-in-an-unsorted-array",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nThe approach is based on the concept of the **Pigeonhole Principle**. By dividing the range of values into buckets and tracking the maximum and minimum values within each bucket, we can find the maximum gap between elements. The maximum gap will always be equal to or greater than the bucket size because if it\\'s smaller, then at least one bucket will be empty.\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n1. Find the maximum and minimum elements in the array.\\n2. Calculate the bucket size using the formula **ceil((maxele - minele) / (n - 1))**, where **\\'maxele\\'** is the maximum element and **\\'minele\\'** is the minimum element.\\n3. If the bucket size is zero, it means all elements are the same, so return 0 as the maximum gap.\\n4. Create two arrays, **\\'maxofb\\'** and **\\'minofb\\'**, of size **\\'n\\'** to store the maximum and minimum values of each bucket.\\n5. Iterate through the array and determine the bucket index for each element using the formula **\\'(arr[i] - minele) / bucketsz\\'**.\\n6. Update the **\\'maxofb[whichb]\\'** and **\\'minofb[whichb]\\'** values by comparing them with the current element.\\n7. Initialize ans as the bucket size and pre as the maximum value in the first non-empty bucket **\\'(maxofb[0])\\'**.\\n8. Iterate through the buckets starting from the second bucket.\\n   * If **\\' minofb[i]\\'** is **\\'INT_MAX\\'**, it means the current bucket is empty, so skip it.\\n   * Update ans by comparing it with the difference between **\\'minofb[i]\\'** and **\\'pre\\'**.\\n   * Update pre with the maximum value in the current bucket **\\'(maxofb[i])\\'**.\\n9. Return **\\'ans\\'** as the maximum gap.\\n\\n# Time Complexity\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n- Finding the maximum and minimum values in the array requires a linear scan, taking $$O(n)$$ time.\\n- Building the buckets and tracking the maximum and minimum values within each bucket also requires iterating through the array, resulting in $$O(n)$$ time complexity.\\n- Overall, the time complexity is $$O(n)$$.\\n\\n# Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\nThe space complexity is$$O(n)$$ because we need to store the maximum and minimum values for each bucket in separate arrays, **\\'maxofb\\'** and **\\'minofb\\'**, each of size **\\'n\\'**.\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int maximumGap(vector<int>& arr) \\n    {\\n        int n = arr.size();\\n        if(n == 1)\\n        {\\n            return 0;\\n        }        \\n        if(n == 2)\\n        {\\n            return abs(arr[0] - arr[1]);\\n        }\\n\\n        int maxele = arr[0];\\n        int minele = arr[0];\\n\\n        // Find the maximum and minimum elements in the array\\n        for(auto i:arr)\\n        {\\n            maxele = max(maxele,i);\\n            minele = min(minele,i);\\n        }\\n\\n        // Calculate the bucket size\\n        int bucketsz = ceil(float(maxele-minele)/(n-1));\\n\\n        // If the bucket size is zero, return 0 as the maximum gap\\n        if(bucketsz == 0)\\n        {\\n            return 0;\\n        }\\n\\n        // Create arrays to store the maximum and minimum values of each bucket\\n        vector<int>maxofb(n,INT_MIN);\\n        vector<int>minofb(n,INT_MAX);\\n\\n        // Assign each element to its corresponding bucket and update the maximum and minimum values of each bucket\\n        for(int i=0;i<n;i++)\\n        {\\n            int whichb = ((arr[i] - minele)/bucketsz);\\n\\n            maxofb[whichb] = max(maxofb[whichb],arr[i]);\\n            minofb[whichb] = min(minofb[whichb],arr[i]);\\n        }\\n\\n        // Initialize the answer as the bucket size and the previous maximum value as the maximum value in the first non-empty bucket\\n        int ans = bucketsz, pre = maxofb[0];\\n\\n        // Iterate through the buckets and find the maximum gap\\n        for(int i=1;i<n;i++)\\n        {\\n            // Skip empty buckets\\n            if(minofb[i] == INT_MAX)\\n            {\\n                continue;\\n            }\\n\\n            // Update the answer by comparing it with the difference between the minimum value of the current bucket and the previous maximum value\\n            ans = max(ans,minofb[i]-pre);\\n            pre = maxofb[i];\\n        }\\n\\n        // Return the maximum gap\\n        return ans;\\n    }\\n};\\n\\n```",
                "solutionTags": [
                    "C++",
                    "Bucket Sort"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int maximumGap(vector<int>& arr) \\n    {\\n        int n = arr.size();\\n        if(n == 1)\\n        {\\n            return 0;\\n        }        \\n        if(n == 2)\\n        {\\n            return abs(arr[0] - arr[1]);\\n        }\\n\\n        int maxele = arr[0];\\n        int minele = arr[0];\\n\\n        // Find the maximum and minimum elements in the array\\n        for(auto i:arr)\\n        {\\n            maxele = max(maxele,i);\\n            minele = min(minele,i);\\n        }\\n\\n        // Calculate the bucket size\\n        int bucketsz = ceil(float(maxele-minele)/(n-1));\\n\\n        // If the bucket size is zero, return 0 as the maximum gap\\n        if(bucketsz == 0)\\n        {\\n            return 0;\\n        }\\n\\n        // Create arrays to store the maximum and minimum values of each bucket\\n        vector<int>maxofb(n,INT_MIN);\\n        vector<int>minofb(n,INT_MAX);\\n\\n        // Assign each element to its corresponding bucket and update the maximum and minimum values of each bucket\\n        for(int i=0;i<n;i++)\\n        {\\n            int whichb = ((arr[i] - minele)/bucketsz);\\n\\n            maxofb[whichb] = max(maxofb[whichb],arr[i]);\\n            minofb[whichb] = min(minofb[whichb],arr[i]);\\n        }\\n\\n        // Initialize the answer as the bucket size and the previous maximum value as the maximum value in the first non-empty bucket\\n        int ans = bucketsz, pre = maxofb[0];\\n\\n        // Iterate through the buckets and find the maximum gap\\n        for(int i=1;i<n;i++)\\n        {\\n            // Skip empty buckets\\n            if(minofb[i] == INT_MAX)\\n            {\\n                continue;\\n            }\\n\\n            // Update the answer by comparing it with the difference between the minimum value of the current bucket and the previous maximum value\\n            ans = max(ans,minofb[i]-pre);\\n            pre = maxofb[i];\\n        }\\n\\n        // Return the maximum gap\\n        return ans;\\n    }\\n};\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3580473,
                "title": "easy-solution-simple-code-o-n",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n1. <!-- Add your time complexity here, e.g. $$O(n)$$ --> O(N)\\n\\n- Space complexity:\\n- <!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int maximumGap(vector<int>& nums) {\\n        if (nums.size()==1) return 0;\\n        sort(nums.begin(), nums.end());\\n        int maxdiff=0;\\n        for(int i=1; i<nums.size(); i++){\\n          maxdiff=abs(max(maxdiff,nums[i]-nums[i-1]));\\n          \\n        } \\n        return maxdiff;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Array"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int maximumGap(vector<int>& nums) {\\n        if (nums.size()==1) return 0;\\n        sort(nums.begin(), nums.end());\\n        int maxdiff=0;\\n        for(int i=1; i<nums.size(); i++){\\n          maxdiff=abs(max(maxdiff,nums[i]-nums[i-1]));\\n          \\n        } \\n        return maxdiff;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3005534,
                "title": "maximum-gap-easy-to-understand-100-faster-and-0-ms-runtime",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->O(N)\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int maximumGap(vector<int>& nums) {\\n        int n = nums.size();\\n        int max = 0;\\n        int result = 0;\\n        if(n == 1) {\\n            return 0;\\n        }\\n        sort(nums.begin(),nums.end());\\n        for(int i=0; i<n-1; i++) {\\n            max = nums[i+1]-nums[i];\\n            if(result < max) {\\n                result = max;\\n            }\\n        }\\n        return result;\\n    }\\n};\\n\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int maximumGap(vector<int>& nums) {\\n        int n = nums.size();\\n        int max = 0;\\n        int result = 0;\\n        if(n == 1) {\\n            return 0;\\n        }\\n        sort(nums.begin(),nums.end());\\n        for(int i=0; i<n-1; i++) {\\n            max = nums[i+1]-nums[i];\\n            if(result < max) {\\n                result = max;\\n            }\\n        }\\n        return result;\\n    }\\n};\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2903035,
                "title": "using-sort",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int maximumGap(vector<int>& nums) \\n    {\\n       long long int n = nums.size() ;\\n       if(n<2)\\n       {\\n           return 0 ;\\n       }   \\n       sort(nums.begin(),nums.end()) ;\\n       long int diff = abs(nums[0]-nums[1]) ;\\n       for(int i=1;i<n-1;i++)\\n       {\\n           long int d = abs(nums[i]-nums[i+1]);\\n           if(d>diff)\\n           {\\n               diff=d;\\n           }\\n       }\\n       return diff;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int maximumGap(vector<int>& nums) \\n    {\\n       long long int n = nums.size() ;\\n       if(n<2)\\n       {\\n           return 0 ;\\n       }   \\n       sort(nums.begin(),nums.end()) ;\\n       long int diff = abs(nums[0]-nums[1]) ;\\n       for(int i=1;i<n-1;i++)\\n       {\\n           long int d = abs(nums[i]-nums[i+1]);\\n           if(d>diff)\\n           {\\n               diff=d;\\n           }\\n       }\\n       return diff;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2305748,
                "title": "c-easy-solution",
                "content": "class Solution {\\npublic:\\n    int maximumGap(vector<int>& nums) {\\n        \\n        sort(nums.begin(),nums.end());\\n        int ans=0;\\n        for(int i=1;i<nums.size();i++){\\n            ans=max(ans,abs(nums[i]-nums[i-1]));\\n        }\\n                    return ans;\\n    }\\n};",
                "solutionTags": [],
                "code": "class Solution {\\npublic:\\n    int maximumGap(vector<int>& nums) {\\n        \\n        sort(nums.begin(),nums.end());\\n        int ans=0;\\n        for(int i=1;i<nums.size();i++){\\n            ans=max(ans,abs(nums[i]-nums[i-1]));\\n        }",
                "codeTag": "Java"
            },
            {
                "id": 2305713,
                "title": "c-radix-sort",
                "content": "```\\nclass Solution {\\npublic:\\n//Count the digits in the largest digit\\n    int digitCount(int n)\\n    {\\n        int count=0;\\n        while(n)\\n        {\\n            n=n/10;\\n            count++;\\n        }\\n        return count;\\n    }\\n\\t//Radix sort for m values of 0 to maxDig\\n    void radixSort(vector<int>&nums,int m)\\n    {\\n        queue<int>bin[10];\\n        int p=pow(10,m);\\n        for(int i=0;i<nums.size();i++)\\n        {\\n            bin[(nums[i]/p)%10].push(nums[i]);\\n        }\\n        int i=0;\\n        int j=0;\\n        while(j<10)\\n        {\\n            while(!bin[j].empty())\\n            {\\n                nums[i++]=bin[j].front();\\n                bin[j].pop();\\n            }\\n            j++;\\n        }\\n    }\\n    int maximumGap(vector<int>& nums) {\\n        int n=nums.size();\\n        if(n<2)\\n            return 0;\\n        int maxi=*max_element(nums.begin(),nums.end());\\n        int maxDig=digitCount(maxi);\\n        for(int i=0;i<maxDig;i++)\\n            radixSort(nums,i);\\n        \\n        int ans=0;\\n        for(int i=1;i<n;i++)\\n        {\\n            ans=max(ans,nums[i]-nums[i-1]);\\n        }\\n        return ans;\\n        \\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n//Count the digits in the largest digit\\n    int digitCount(int n)\\n    {\\n        int count=0;\\n        while(n)\\n        {\\n            n=n/10;\\n            count++;\\n        }\\n        return count;\\n    }\\n\\t//Radix sort for m values of 0 to maxDig\\n    void radixSort(vector<int>&nums,int m)\\n    {\\n        queue<int>bin[10];\\n        int p=pow(10,m);\\n        for(int i=0;i<nums.size();i++)\\n        {\\n            bin[(nums[i]/p)%10].push(nums[i]);\\n        }\\n        int i=0;\\n        int j=0;\\n        while(j<10)\\n        {\\n            while(!bin[j].empty())\\n            {\\n                nums[i++]=bin[j].front();\\n                bin[j].pop();\\n            }\\n            j++;\\n        }\\n    }\\n    int maximumGap(vector<int>& nums) {\\n        int n=nums.size();\\n        if(n<2)\\n            return 0;\\n        int maxi=*max_element(nums.begin(),nums.end());\\n        int maxDig=digitCount(maxi);\\n        for(int i=0;i<maxDig;i++)\\n            radixSort(nums,i);\\n        \\n        int ans=0;\\n        for(int i=1;i<n;i++)\\n        {\\n            ans=max(ans,nums[i]-nums[i-1]);\\n        }\\n        return ans;\\n        \\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2129190,
                "title": "radix-sort-solution",
                "content": "```\\nclass Solution {\\npublic:\\n    void countSort(vector<int>& nums,int n,int exp){\\n        vector<int> count(10,0);\\n        vector<int> temp(n,0);\\n        for(int i=0;i<n;i++){\\n            count[(nums[i]/exp)%10]++;\\n        }\\n        for(int i=1;i<10;i++){\\n            count[i] += count[i-1];\\n        }\\n        \\n        for(int i=n-1;i>=0;i--){\\n            temp[count[(nums[i]/exp)%10]-1] = nums[i];\\n            count[(nums[i]/exp)%10]--;\\n        }\\n        for(int i=0;i<n;i++){\\n            nums[i] = temp[i];\\n        }\\n    }\\n    int maximumGap(vector<int>& nums) {\\n        int n = nums.size();\\n        if(n<2) return 0;\\n        int maxi = nums[0];\\n        for(int i=1;i<n;i++){\\n            if(nums[i]>maxi) maxi = nums[i];\\n        }\\n        for(int exp=1;maxi/exp > 0;exp*=10){\\n            countSort(nums,n,exp);\\n        }\\n        int maxDiff = 0;\\n        for(int i=1;i<n;i++){\\n            int temp = nums[i]-nums[i-1];\\n            if(temp > maxDiff){\\n                maxDiff = temp;\\n            }\\n        }\\n        return maxDiff;\\n    }\\n    \\n};",
                "solutionTags": [],
                "code": "class Solution {\\npublic:\\n    void countSort(vector<int>& nums,int n,int exp){\\n        vector<int> count(10,0);\\n        vector<int> temp(n,0);\\n        for(int i=0;i<n;i++){\\n            count[(nums[i]/exp)%10]++;\\n        }",
                "codeTag": "Java"
            },
            {
                "id": 2057566,
                "title": "java-time-0-n-radix-sort-count-sort",
                "content": "```\\nclass Solution {\\n    public int maximumGap(int[] nums) \\n    {\\n        int n= nums.length;\\n    \\n        int max=Integer.MIN_VALUE;\\n        for(int x:nums)\\n        {\\n            max=Math.max(max,x);\\n        }\\n        \\n        int i=1;\\n        while(i<=max)\\n        {\\n            countSort(nums,i);\\n            i=i*10;\\n        }\\n        \\n        int ans=0;\\n        for(int j=1;j<n;j++)\\n        {\\n            ans=Math.max(nums[j]-nums[j-1],ans);\\n        }\\n        \\n        return ans;\\n    }\\n    \\n    public void countSort(int[] nums,int exp)\\n    {\\n        int frq[]=new int[10]; \\n        int sorted[]=new int[nums.length];\\n        \\n        for(int i=0;i<nums.length;i++)\\n        {\\n            frq[(nums[i]/exp)%10]+=1;\\n        }\\n        \\n        frq[0]-=1;\\n        for(int i=1;i<10;i++)\\n        {\\n            frq[i]+=frq[i-1];\\n        }\\n        \\n        for(int i=nums.length-1;i>=0;i--)\\n        {\\n            sorted[frq[(nums[i]/exp)%10]]=nums[i];\\n            frq[(nums[i]/exp)%10]-=1;\\n        }\\n        \\n        for(int i=0;i<nums.length;i++)\\n        {\\n            nums[i]=sorted[i];\\n        }\\n    }\\n}\\n```",
                "solutionTags": [
                    "Sorting"
                ],
                "code": "```\\nclass Solution {\\n    public int maximumGap(int[] nums) \\n    {\\n        int n= nums.length;\\n    \\n        int max=Integer.MIN_VALUE;\\n        for(int x:nums)\\n        {\\n            max=Math.max(max,x);\\n        }\\n        \\n        int i=1;\\n        while(i<=max)\\n        {\\n            countSort(nums,i);\\n            i=i*10;\\n        }\\n        \\n        int ans=0;\\n        for(int j=1;j<n;j++)\\n        {\\n            ans=Math.max(nums[j]-nums[j-1],ans);\\n        }\\n        \\n        return ans;\\n    }\\n    \\n    public void countSort(int[] nums,int exp)\\n    {\\n        int frq[]=new int[10]; \\n        int sorted[]=new int[nums.length];\\n        \\n        for(int i=0;i<nums.length;i++)\\n        {\\n            frq[(nums[i]/exp)%10]+=1;\\n        }\\n        \\n        frq[0]-=1;\\n        for(int i=1;i<10;i++)\\n        {\\n            frq[i]+=frq[i-1];\\n        }\\n        \\n        for(int i=nums.length-1;i>=0;i--)\\n        {\\n            sorted[frq[(nums[i]/exp)%10]]=nums[i];\\n            frq[(nums[i]/exp)%10]-=1;\\n        }\\n        \\n        for(int i=0;i<nums.length;i++)\\n        {\\n            nums[i]=sorted[i];\\n        }\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2056120,
                "title": "must-be-tagged-as-easy-problem-not-hard-one",
                "content": "class Solution {\\npublic:\\n\\n    int maximumGap(vector<int>& nums) {\\n        int n=nums.size();\\n        if(n==1) return 0;\\n        \\n        sort(nums.begin(),nums.end());\\n        int ans=0;\\n        for(int i=1;i<n;i++){\\n                if((nums[i]-nums[i-1])>ans)\\n                    ans=(nums[i]-nums[i-1]);\\n        }\\n        return ans;\\n    }\\n};",
                "solutionTags": [
                    "C",
                    "Sorting"
                ],
                "code": "class Solution {\\npublic:\\n\\n    int maximumGap(vector<int>& nums) {\\n        int n=nums.size();\\n        if(n==1) return 0;\\n        \\n        sort(nums.begin(),nums.end());\\n        int ans=0;\\n        for(int i=1;i<n;i++){\\n                if((nums[i]-nums[i-1])>ans)\\n                    ans=(nums[i]-nums[i-1]);\\n        }",
                "codeTag": "Java"
            },
            {
                "id": 2048437,
                "title": "python-radix-sort-simple-solution",
                "content": "```\\nclass Solution:\\n    def countingSort(self, arr, digitPlace):\\n        lookup = [0] * 10\\n        for i in arr:\\n            index = i / digitPlace\\n            lookup[int(index % 10)] += 1\\n        for i in range(1, 10):\\n            lookup[i] += lookup[i - 1]\\n        sortedArr = [None] * len(arr)\\n        for i in range(len(arr) - 1, -1, -1):\\n            index = arr[i] / digitPlace\\n            sortedArr[lookup[int(index % 10)] - 1] = arr[i]\\n            lookup[int(index % 10)] -= 1\\n        return sortedArr\\n\\n    def radixSort(self, arr):\\n        maxArr = max(arr)\\n        digitPlace = 1\\n        while int(maxArr) > 0:\\n            arr = self.countingSort(arr, digitPlace)\\n            digitPlace *= 10\\n            maxArr /= 10\\n        return arr\\n\\n    def maximumGap(self, nums: List[int]) -> int:\\n        nums = self.radixSort(nums)\\n        maxGap = 0\\n        for i in range(1, len(nums)):\\n            maxGap = max(maxGap, (nums[i] - nums[i - 1]))\\n        return maxGap\\n```\\n\\n***If you liked the above solution then please upvote!***",
                "solutionTags": [
                    "Python"
                ],
                "code": "```\\nclass Solution:\\n    def countingSort(self, arr, digitPlace):\\n        lookup = [0] * 10\\n        for i in arr:\\n            index = i / digitPlace\\n            lookup[int(index % 10)] += 1\\n        for i in range(1, 10):\\n            lookup[i] += lookup[i - 1]\\n        sortedArr = [None] * len(arr)\\n        for i in range(len(arr) - 1, -1, -1):\\n            index = arr[i] / digitPlace\\n            sortedArr[lookup[int(index % 10)] - 1] = arr[i]\\n            lookup[int(index % 10)] -= 1\\n        return sortedArr\\n\\n    def radixSort(self, arr):\\n        maxArr = max(arr)\\n        digitPlace = 1\\n        while int(maxArr) > 0:\\n            arr = self.countingSort(arr, digitPlace)\\n            digitPlace *= 10\\n            maxArr /= 10\\n        return arr\\n\\n    def maximumGap(self, nums: List[int]) -> int:\\n        nums = self.radixSort(nums)\\n        maxGap = 0\\n        for i in range(1, len(nums)):\\n            maxGap = max(maxGap, (nums[i] - nums[i - 1]))\\n        return maxGap\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1989052,
                "title": "buckets-solution-t-o-n-s-o-n-javascript",
                "content": "\\t/**\\n\\t * The buckets solution.\\n\\t * \\n\\t * Time Complexity:  O(n)\\n\\t * Space Complexity: O(n)\\n\\t * \\n\\t * @param {number[]} nums\\n\\t * @return {number}\\n\\t */\\n\\tvar maximumGap = function(nums) {\\n\\t\\tconst n = nums.length\\n\\n\\t\\tif (n < 2) {\\n\\t\\t\\treturn 0\\n\\t\\t}\\n\\n\\t\\tif (n < 3) {\\n\\t\\t\\treturn Math.abs(nums[0] - nums[1])\\n\\t\\t}\\n\\n\\t\\tlet maxNum = -Infinity\\n\\t\\tlet minNum = +Infinity\\n\\n\\t\\tfor (let i = 0; i < n; i++) {\\n\\t\\t\\tmaxNum = Math.max(maxNum, nums[i])\\n\\t\\t\\tminNum = Math.min(minNum, nums[i])\\n\\t\\t}\\n\\n\\t\\tif (maxNum === minNum) {\\n\\t\\t\\treturn 0\\n\\t\\t}\\n\\n\\t\\tconst k = n - 1\\n\\t\\tconst averageGap = (maxNum - minNum) / k\\n\\n\\t\\tconst minBuckets = new Array(k)\\n\\t\\tconst maxBuckets = new Array(k)\\n\\n\\t\\tminBuckets[0] = minNum\\n\\t\\tmaxBuckets[0] = minNum\\n\\n\\t\\tminBuckets[k - 1] = maxNum\\n\\t\\tmaxBuckets[k - 1] = maxNum\\n\\n\\t\\tfor (let i = 0; i < n; i++) {\\n\\t\\t\\tif (minNum === nums[i] || nums[i] === maxNum) {\\n\\t\\t\\t\\tcontinue\\n\\t\\t\\t}\\n\\n\\t\\t\\tconst j = Math.floor((nums[i] - minNum) / averageGap)\\n\\n\\t\\t\\tminBuckets[j] = minBuckets[j] ? Math.min(minBuckets[j], nums[i]) : nums[i]\\n\\t\\t\\tmaxBuckets[j] = maxBuckets[j] ? Math.max(maxBuckets[j], nums[i]) : nums[i]\\n\\t\\t}\\n\\n\\t\\tlet largestGap = 0\\n\\t\\tlet prevMaxIndex = 0\\n\\n\\t\\tfor (let i = 1; i < n - 1; i++) {\\n\\t\\t\\tif (minBuckets[i]) {\\n\\t\\t\\t\\tlargestGap = Math.max(largestGap, minBuckets[i] - maxBuckets[prevMaxIndex])\\n\\t\\t\\t}\\n\\n\\t\\t\\tif (maxBuckets[i]) {\\n\\t\\t\\t\\tprevMaxIndex = i\\n\\t\\t\\t}\\n\\t\\t}\\n\\n\\t\\treturn largestGap\\n\\t}",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "\\t/**\\n\\t * The buckets solution.\\n\\t * \\n\\t * Time Complexity:  O(n)\\n\\t * Space Complexity: O(n)\\n\\t * \\n\\t * @param {number[]} nums\\n\\t * @return {number}\\n\\t */\\n\\tvar maximumGap = function(nums) {\\n\\t\\tconst n = nums.length\\n\\n\\t\\tif (n < 2) {\\n\\t\\t\\treturn 0\\n\\t\\t}\\n\\n\\t\\tif (n < 3) {\\n\\t\\t\\treturn Math.abs(nums[0] - nums[1])\\n\\t\\t}\\n\\n\\t\\tlet maxNum = -Infinity\\n\\t\\tlet minNum = +Infinity\\n\\n\\t\\tfor (let i = 0; i < n; i++) {\\n\\t\\t\\tmaxNum = Math.max(maxNum, nums[i])\\n\\t\\t\\tminNum = Math.min(minNum, nums[i])\\n\\t\\t}\\n\\n\\t\\tif (maxNum === minNum) {\\n\\t\\t\\treturn 0\\n\\t\\t}\\n\\n\\t\\tconst k = n - 1\\n\\t\\tconst averageGap = (maxNum - minNum) / k\\n\\n\\t\\tconst minBuckets = new Array(k)\\n\\t\\tconst maxBuckets = new Array(k)\\n\\n\\t\\tminBuckets[0] = minNum\\n\\t\\tmaxBuckets[0] = minNum\\n\\n\\t\\tminBuckets[k - 1] = maxNum\\n\\t\\tmaxBuckets[k - 1] = maxNum\\n\\n\\t\\tfor (let i = 0; i < n; i++) {\\n\\t\\t\\tif (minNum === nums[i] || nums[i] === maxNum) {\\n\\t\\t\\t\\tcontinue\\n\\t\\t\\t}\\n\\n\\t\\t\\tconst j = Math.floor((nums[i] - minNum) / averageGap)\\n\\n\\t\\t\\tminBuckets[j] = minBuckets[j] ? Math.min(minBuckets[j], nums[i]) : nums[i]\\n\\t\\t\\tmaxBuckets[j] = maxBuckets[j] ? Math.max(maxBuckets[j], nums[i]) : nums[i]\\n\\t\\t}\\n\\n\\t\\tlet largestGap = 0\\n\\t\\tlet prevMaxIndex = 0\\n\\n\\t\\tfor (let i = 1; i < n - 1; i++) {\\n\\t\\t\\tif (minBuckets[i]) {\\n\\t\\t\\t\\tlargestGap = Math.max(largestGap, minBuckets[i] - maxBuckets[prevMaxIndex])\\n\\t\\t\\t}\\n\\n\\t\\t\\tif (maxBuckets[i]) {\\n\\t\\t\\t\\tprevMaxIndex = i\\n\\t\\t\\t}\\n\\t\\t}\\n\\n\\t\\treturn largestGap\\n\\t}",
                "codeTag": "Unknown"
            },
            {
                "id": 1630027,
                "title": "clean-and-concise-java-solution",
                "content": "```\\nclass Solution {\\n    public int maximumGap(int[] nums) {\\n        \\n        if(nums.length < 2)\\n            return 0;\\n        \\n        if(nums.length == 2)\\n            return Math.abs(nums[0] - nums[1]);\\n        \\n        Arrays.sort(nums);\\n        \\n        int maxDiff = Integer.MIN_VALUE;\\n        \\n        for(int i = 0; i < nums.length - 1; i++)\\n            maxDiff = Math.max((nums[i+1] - nums[i]), maxDiff);\\n        \\n        return maxDiff;\\n    }\\n}",
                "solutionTags": [
                    "Java"
                ],
                "code": "class Solution {\\n    public int maximumGap(int[] nums) {\\n        \\n        if(nums.length < 2)\\n            return 0;\\n        \\n        if(nums.length == 2)\\n            return Math.abs(nums[0] - nums[1]);\\n        \\n        Arrays.sort(nums);\\n        \\n        int maxDiff = Integer.MIN_VALUE;\\n        \\n        for(int i = 0; i < nums.length - 1; i++)\\n            maxDiff = Math.max((nums[i+1] - nums[i]), maxDiff);\\n        \\n        return maxDiff;\\n    }",
                "codeTag": "Java"
            },
            {
                "id": 1462178,
                "title": "python-radix-sort-solution-o-n-time",
                "content": "1. Use radix sort to sort nums in O(dn) time with d <= 9, so it\\'s approximately equal to O(n).\\n2. Loop over the list to get the maximum gap across the list.\\n```\\nfrom functools import reduce\\nclass Solution(object):\\n        def maximumGap(self, nums):\\n            if len(nums) == 1:\\n                return 0\\n            \\n            sorted_array = self.radix_sort(nums)\\n            max_gap = self.maximum_Gap(sorted_array)\\n            return max_gap\\n            \\n                \\n        def radix_sort(self, nums):\\n            num_digits = len(str(max(nums)))\\n            A = nums \\n            for i in range(num_digits):\\n                B = [[] for _ in range(10)]\\n                for num in A:\\n                    bucket = (num // (10 ** i)) % 10\\n                    B[bucket].append(num)\\n                A = reduce(lambda x, y: x+y, B)\\n                \\n            return A\\n            \\n                \\n        def maximum_Gap(self, sorted_array):\\n            max_gap = -float(\\'inf\\')\\n            for i in range(1, len(sorted_array)):\\n                if sorted_array[i] - sorted_array[i-1] >= max_gap:\\n                    max_gap = sorted_array[i] - sorted_array[i-1]\\n            \\n            return max_gap\\n```",
                "solutionTags": [
                    "Python"
                ],
                "code": "```\\nfrom functools import reduce\\nclass Solution(object):\\n        def maximumGap(self, nums):\\n            if len(nums) == 1:\\n                return 0\\n            \\n            sorted_array = self.radix_sort(nums)\\n            max_gap = self.maximum_Gap(sorted_array)\\n            return max_gap\\n            \\n                \\n        def radix_sort(self, nums):\\n            num_digits = len(str(max(nums)))\\n            A = nums \\n            for i in range(num_digits):\\n                B = [[] for _ in range(10)]\\n                for num in A:\\n                    bucket = (num // (10 ** i)) % 10\\n                    B[bucket].append(num)\\n                A = reduce(lambda x, y: x+y, B)\\n                \\n            return A\\n            \\n                \\n        def maximum_Gap(self, sorted_array):\\n            max_gap = -float(\\'inf\\')\\n            for i in range(1, len(sorted_array)):\\n                if sorted_array[i] - sorted_array[i-1] >= max_gap:\\n                    max_gap = sorted_array[i] - sorted_array[i-1]\\n            \\n            return max_gap\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1415450,
                "title": "c-radix-sort",
                "content": "```\\nclass Solution {\\npublic:\\n    \\n    int getDigit(int num, int factor) \\n    {\\n        return (abs(num) / abs(factor)) % 10;\\n    }\\n    \\n    void radixCountingSort(vector<int> &nums, int factor) \\n    {\\n        int freqSize = 10, size = nums.size();\\n        vector<int> freq(freqSize, 0), sorted(size, 0);\\n        \\n        for (int ind = 0; ind < size; ind++)\\n            freq[getDigit(nums[ind], factor)]++;\\n        \\n        for (int ind = 1; ind < freqSize; ind++)\\n            freq[ind] += freq[ind - 1];\\n        \\n        // for stable sorting start ind from end and decrement till 0\\n        \\n        for (int ind = size - 1; ind >= 0; ind--) \\n            sorted[freq[getDigit(nums[ind], factor)]-- - 1] = nums[ind];\\n        \\n        nums = sorted;\\n    }\\n    \\n    void radixSort(vector<int> &nums)\\n    {\\n        int minVal = *min_element(nums.begin(), nums.end());\\n        for(auto &num : nums) \\n            num -= minVal;\\n        \\n        int factor = 1, maxVal = *max_element(nums.begin(), nums.end());\\n        \\n        while (maxVal / factor) \\n        {\\n            radixCountingSort(nums, factor);\\n            factor *= 10;\\n        }\\n        \\n        for (auto &num : nums) \\n            num += minVal;\\n    }\\n    \\n    int maximumGap(vector<int>& nums) \\n    {    \\n        if(nums.size() < 2)\\n            return 0;\\n        \\n        radixSort(nums);\\n        //sort(nums.begin(), nums.end());\\n        \\n        int result = INT_MIN;\\n        for(int i = 0; i < nums.size() - 1; i++)\\n            result = max(result, nums[i + 1] - nums[i]);\\n        return result;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "C"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    \\n    int getDigit(int num, int factor) \\n    {\\n        return (abs(num) / abs(factor)) % 10;\\n    }\\n    \\n    void radixCountingSort(vector<int> &nums, int factor) \\n    {\\n        int freqSize = 10, size = nums.size();\\n        vector<int> freq(freqSize, 0), sorted(size, 0);\\n        \\n        for (int ind = 0; ind < size; ind++)\\n            freq[getDigit(nums[ind], factor)]++;\\n        \\n        for (int ind = 1; ind < freqSize; ind++)\\n            freq[ind] += freq[ind - 1];\\n        \\n        // for stable sorting start ind from end and decrement till 0\\n        \\n        for (int ind = size - 1; ind >= 0; ind--) \\n            sorted[freq[getDigit(nums[ind], factor)]-- - 1] = nums[ind];\\n        \\n        nums = sorted;\\n    }\\n    \\n    void radixSort(vector<int> &nums)\\n    {\\n        int minVal = *min_element(nums.begin(), nums.end());\\n        for(auto &num : nums) \\n            num -= minVal;\\n        \\n        int factor = 1, maxVal = *max_element(nums.begin(), nums.end());\\n        \\n        while (maxVal / factor) \\n        {\\n            radixCountingSort(nums, factor);\\n            factor *= 10;\\n        }\\n        \\n        for (auto &num : nums) \\n            num += minVal;\\n    }\\n    \\n    int maximumGap(vector<int>& nums) \\n    {    \\n        if(nums.size() < 2)\\n            return 0;\\n        \\n        radixSort(nums);\\n        //sort(nums.begin(), nums.end());\\n        \\n        int result = INT_MIN;\\n        for(int i = 0; i < nums.size() - 1; i++)\\n            result = max(result, nums[i + 1] - nums[i]);\\n        return result;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1386071,
                "title": "bucket-sort-o-n-time-and-space-complexity-cpp",
                "content": "```\\nclass Solution {\\npublic:\\n    int maximumGap(vector<int>& nums) {\\n        int n = nums.size();\\n        int bucketNo = n+1;\\n        int maxVal = *max_element(nums.begin(), nums.end());\\n        int minVal = *min_element(nums.begin(), nums.end());\\n        if(maxVal == minVal) return 0;\\n        int bucketSize = (maxVal - minVal)/n+1;\\n        \\n        vector<vector<int>> buckets(bucketNo);\\n        \\n        for(int i=0;i<n;i++){\\n            int index = (nums[i] - minVal)/bucketSize;\\n            buckets[index].push_back(nums[i]);\\n        }\\n        int prevVal  = minVal;\\n        int maxDiff = 0;\\n        \\n        for(auto b: buckets){\\n            sort(b.begin(), b.end());\\n            for(auto i: b){\\n                 maxDiff = max(maxDiff, i-prevVal);\\n                 prevVal = i;\\n            }\\n            \\n        }\\n        \\n      return maxDiff;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Sorting",
                    "Bucket Sort"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int maximumGap(vector<int>& nums) {\\n        int n = nums.size();\\n        int bucketNo = n+1;\\n        int maxVal = *max_element(nums.begin(), nums.end());\\n        int minVal = *min_element(nums.begin(), nums.end());\\n        if(maxVal == minVal) return 0;\\n        int bucketSize = (maxVal - minVal)/n+1;\\n        \\n        vector<vector<int>> buckets(bucketNo);\\n        \\n        for(int i=0;i<n;i++){\\n            int index = (nums[i] - minVal)/bucketSize;\\n            buckets[index].push_back(nums[i]);\\n        }\\n        int prevVal  = minVal;\\n        int maxDiff = 0;\\n        \\n        for(auto b: buckets){\\n            sort(b.begin(), b.end());\\n            for(auto i: b){\\n                 maxDiff = max(maxDiff, i-prevVal);\\n                 prevVal = i;\\n            }\\n            \\n        }\\n        \\n      return maxDiff;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1360504,
                "title": "radix-sort-o-n",
                "content": "```\\n// Radix sort\\nclass Solution {\\n    public int maximumGap(int[] nums) {\\n        \\n        int n = nums.length;\\n        \\n        for (int i = 0; i < 10; i++) { // O(N)\\n            int[] sorted = countSort(nums, i);\\n            nums = sorted;\\n        }\\n        int res = Integer.MIN_VALUE;\\n        for (int i = 1; i < n; i++) { // O(N)\\n            res = Math.max(res, nums[i] - nums[i - 1]);\\n        }\\n        if (res == Integer.MIN_VALUE) return 0;\\n        return res;\\n    }\\n    \\n    private int[] countSort(int[] nums, int d) {\\n        int n = nums.length;\\n        int[] sorted = new int[n];\\n        int[] count = new int[10];\\n        for (int i = 0; i < n; i++) { // o(n)\\n            int curr = nums[i] / (int) Math.pow(10, d) % 10;\\n            count[curr]++;\\n        }\\n        for (int j = 1; j < 10; j++) { // o(1)\\n            count[j] += count[j - 1];\\n        }\\n        for (int i = n - 1; i >= 0; i--) { // (n)\\n            int curr = nums[i] / (int) Math.pow(10, d) % 10;\\n            int index = count[curr] - 1;\\n            count[curr]--;\\n            sorted[index] = nums[i];\\n        }\\n        return sorted;\\n    }\\n}\\n\\n\\n\\n```",
                "solutionTags": [],
                "code": "```\\n// Radix sort\\nclass Solution {\\n    public int maximumGap(int[] nums) {\\n        \\n        int n = nums.length;\\n        \\n        for (int i = 0; i < 10; i++) { // O(N)\\n            int[] sorted = countSort(nums, i);\\n            nums = sorted;\\n        }\\n        int res = Integer.MIN_VALUE;\\n        for (int i = 1; i < n; i++) { // O(N)\\n            res = Math.max(res, nums[i] - nums[i - 1]);\\n        }\\n        if (res == Integer.MIN_VALUE) return 0;\\n        return res;\\n    }\\n    \\n    private int[] countSort(int[] nums, int d) {\\n        int n = nums.length;\\n        int[] sorted = new int[n];\\n        int[] count = new int[10];\\n        for (int i = 0; i < n; i++) { // o(n)\\n            int curr = nums[i] / (int) Math.pow(10, d) % 10;\\n            count[curr]++;\\n        }\\n        for (int j = 1; j < 10; j++) { // o(1)\\n            count[j] += count[j - 1];\\n        }\\n        for (int i = n - 1; i >= 0; i--) { // (n)\\n            int curr = nums[i] / (int) Math.pow(10, d) % 10;\\n            int index = count[curr] - 1;\\n            count[curr]--;\\n            sorted[index] = nums[i];\\n        }\\n        return sorted;\\n    }\\n}\\n\\n\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1326627,
                "title": "radix-sort-clean-solution",
                "content": "```\\nclass Solution {\\npublic:\\n    int maximumGap(vector<int>& a) {\\n        if(a.size()<2)return 0;\\n        int mx = *max_element(a.begin(),a.end()),v=1,ans=0,n=a.size();\\n        while(v<=mx and v){\\n            vector<int>A[10];\\n            for(int V:a){\\n                A[(V/v)%10].push_back(V);\\n            }\\n            int idx =0;\\n            for(int i = 0;i<10;i++){\\n                for(int V:A[i])a[idx++]=V;\\n            }\\n            v*=10;\\n        }\\n        for(int i=0;i<n-1;i++){\\n            ans=max(ans,a[i+1]-a[i]);\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int maximumGap(vector<int>& a) {\\n        if(a.size()<2)return 0;\\n        int mx = *max_element(a.begin(),a.end()),v=1,ans=0,n=a.size();\\n        while(v<=mx and v){\\n            vector<int>A[10];\\n            for(int V:a){\\n                A[(V/v)%10].push_back(V);\\n            }\\n            int idx =0;\\n            for(int i = 0;i<10;i++){\\n                for(int V:A[i])a[idx++]=V;\\n            }\\n            v*=10;\\n        }\\n        for(int i=0;i<n-1;i++){\\n            ans=max(ans,a[i+1]-a[i]);\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1293328,
                "title": "c-bucket-sort-easy-to-understand-proper-comments-clean-and-concise",
                "content": "Please upvote if it helps!\\n```\\nclass Solution {\\npublic:\\n    int maximumGap(vector<int>& a) {\\n        int n=a.size(), maxi = INT_MIN, mini = INT_MAX, ans = INT_MIN;\\n        vector<vector<int>> bucket(n+1);\\n        for(int i=0;i<n;i++)\\n        {\\n            maxi = max(a[i], maxi);\\n            mini = min(a[i], mini);\\n        }\\n        if(maxi == mini)\\n            return 0;\\n        \\n        //create bucket\\n        int range = (maxi - mini)/n + 1; // range must be greater than equal to 1\\n        for(int i=0;i<n;i++)\\n        {\\n            \\n            int b_index = (a[i] - mini)/range;\\n            if((a[i]-mini)%range==0 && a[i]!=mini)\\n            {\\n                bucket[((a[i] - mini)/range) - 1].push_back(a[i]);\\n                continue;\\n            }\\n            bucket[b_index].push_back(a[i]);\\n        }\\n        \\n        // traverse bucket\\n        int temp = -1;\\n        for(auto p:bucket)\\n        {\\n            if(p.size()==0)\\n                continue;\\n            sort(p.begin(), p.end());\\n            for(int i=0;i<p.size();i++)\\n            {\\n                if(temp == -1)\\n                {\\n                    temp = p[i];\\n                    continue;\\n                }\\n                ans = max(ans, p[i]-temp);\\n                temp = p[i];\\n            }\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "C"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int maximumGap(vector<int>& a) {\\n        int n=a.size(), maxi = INT_MIN, mini = INT_MAX, ans = INT_MIN;\\n        vector<vector<int>> bucket(n+1);\\n        for(int i=0;i<n;i++)\\n        {\\n            maxi = max(a[i], maxi);\\n            mini = min(a[i], mini);\\n        }\\n        if(maxi == mini)\\n            return 0;\\n        \\n        //create bucket\\n        int range = (maxi - mini)/n + 1; // range must be greater than equal to 1\\n        for(int i=0;i<n;i++)\\n        {\\n            \\n            int b_index = (a[i] - mini)/range;\\n            if((a[i]-mini)%range==0 && a[i]!=mini)\\n            {\\n                bucket[((a[i] - mini)/range) - 1].push_back(a[i]);\\n                continue;\\n            }\\n            bucket[b_index].push_back(a[i]);\\n        }\\n        \\n        // traverse bucket\\n        int temp = -1;\\n        for(auto p:bucket)\\n        {\\n            if(p.size()==0)\\n                continue;\\n            sort(p.begin(), p.end());\\n            for(int i=0;i<p.size();i++)\\n            {\\n                if(temp == -1)\\n                {\\n                    temp = p[i];\\n                    continue;\\n                }\\n                ans = max(ans, p[i]-temp);\\n                temp = p[i];\\n            }\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1241098,
                "title": "maximum-gap-c-using-pigeonhole-sort",
                "content": "If you like the solution, please ***upvote*** this post!!!!!\\n```\\nclass Solution {\\npublic:\\n    int maximumGap(vector<int>& nums) {\\n        if(nums.size()<2)\\n            return 0;\\n        int n =nums.size();\\n        int max_value = nums[0], min_value = nums[0];\\n    for (int i = 1; i < n; i++) {\\n        max_value = max(max_value, nums[i]);\\n        min_value = min(min_value, nums[i]);\\n    }\\n \\n    int max_Bucket[n - 1];\\n    int min_Bucket[n - 1];\\n    fill_n(max_Bucket, n - 1, INT_MIN);\\n    fill_n(min_Bucket, n - 1, INT_MAX);\\n \\n    float delta = (float)(max_value - min_value) / (float)(n - 1);\\n\\n    for (int i = 0; i < n; i++) {\\n        if (nums[i] == max_value || nums[i] == min_value)\\n            continue;\\n        int index = (float)(floor(nums[i] - min_value) / delta);\\n        max_Bucket[index] = max(max_Bucket[index], nums[i]);\\n        min_Bucket[index] = min(min_Bucket[index], nums[i]);\\n    }\\n \\n    int prev_val = min_value;\\n    int max_gap = 0;\\n    for (int i = 0; i < n - 1; i++) {\\n        if (min_Bucket[i] == INT_MAX)\\n            continue;\\n        max_gap = max(max_gap, min_Bucket[i] - prev_val);\\n        prev_val = max_Bucket[i];\\n    }\\n    max_gap = max(max_gap, max_value - prev_val);\\n    return max_gap;\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    int maximumGap(vector<int>& nums) {\\n        if(nums.size()<2)\\n            return 0;\\n        int n =nums.size();\\n        int max_value = nums[0], min_value = nums[0];\\n    for (int i = 1; i < n; i++) {\\n        max_value = max(max_value, nums[i]);\\n        min_value = min(min_value, nums[i]);\\n    }\\n \\n    int max_Bucket[n - 1];\\n    int min_Bucket[n - 1];\\n    fill_n(max_Bucket, n - 1, INT_MIN);\\n    fill_n(min_Bucket, n - 1, INT_MAX);\\n \\n    float delta = (float)(max_value - min_value) / (float)(n - 1);\\n\\n    for (int i = 0; i < n; i++) {\\n        if (nums[i] == max_value || nums[i] == min_value)\\n            continue;\\n        int index = (float)(floor(nums[i] - min_value) / delta);\\n        max_Bucket[index] = max(max_Bucket[index], nums[i]);\\n        min_Bucket[index] = min(min_Bucket[index], nums[i]);\\n    }\\n \\n    int prev_val = min_value;\\n    int max_gap = 0;\\n    for (int i = 0; i < n - 1; i++) {\\n        if (min_Bucket[i] == INT_MAX)\\n            continue;\\n        max_gap = max(max_gap, min_Bucket[i] - prev_val);\\n        prev_val = max_Bucket[i];\\n    }\\n    max_gap = max(max_gap, max_value - prev_val);\\n    return max_gap;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1240880,
                "title": "c-solution-bucket-sort",
                "content": "```\\n    /*\\n     * Approach followed is bucket sorting technique because the\\n     * algorithm should take only linear time\\n    */\\n    int maximumGap(vector<int>& nums) {\\n        // check if the array hase less than two elements\\n        if (nums.size() < 2) {\\n            // Input has less than 2 elements return 0;\\n            return 0;\\n        }\\n        \\n        // For Performing bucket sort, first thing to do is to\\n        // find the range of the elements in input array ie...,\\n        // min and max elements in the input array\\n        int minVal = *min_element(nums.begin(), nums.end());\\n        int maxVal = *max_element(nums.begin(), nums.end());\\n        \\n        // variable to hold the size of input vector\\n        int n = nums.size();\\n        \\n        // Calculate the gap between each bucket and no of buckets\\n        // Eg: 3, 6, 9, 1 -> min = 1, max = 9\\n        // gap = 9 - 1 / n - 1 = 8 / 3 = 2.66\\n        // =>   -------------------------------------------------\\n        //     1     2.66          5.32          7.98           9\\n        // From above, it is clear that we have 4 buckets\\n        float gap = (float)(maxVal - minVal) / (float)(n - 1);\\n        \\n        // Cornor case where if the gap is zero\\n        if (gap == 0.0) {\\n            // Gap between buckets is zero ie.., we have same elements\\n            // in input array for eg: [1,1,1,1]\\n            // Max difference will be always zero\\n            return 0;\\n        }\\n        \\n        // Vectors to store min and max elements in each bucket\\n        vector<int> minBucket(n, INT_MAX);\\n        vector<int> maxBucket(n, INT_MIN);\\n        \\n        int idx;\\n        // Traverse the input vector and put the elements in correct bucket\\n        for (int& num : nums) {\\n            // Identify in which bucket this number should go\\n            idx = (num - minVal) / gap;\\n            \\n            // place the current number in min and max buckets\\n            minBucket[idx] = min(num, minBucket[idx]);\\n            maxBucket[idx] = max(num, maxBucket[idx]);\\n        }\\n        \\n        // Traverse the loop to find the max differnece between successive elements\\n        int prev = minBucket[0];\\n        // variable to store maxDifference\\n        int maxDiff = 0;\\n        \\n        for (int i = 0; i < n; i++) {\\n            // Check if the bucket is empty\\n            if (minBucket[i] != INT_MAX) {\\n                maxDiff = max(maxDiff, minBucket[i] - prev);\\n                prev = maxBucket[i];\\n            }\\n        }\\n        \\n        return maxDiff;\\n}\\n```",
                "solutionTags": [],
                "code": "```\\n    /*\\n     * Approach followed is bucket sorting technique because the\\n     * algorithm should take only linear time\\n    */\\n    int maximumGap(vector<int>& nums) {\\n        // check if the array hase less than two elements\\n        if (nums.size() < 2) {\\n            // Input has less than 2 elements return 0;\\n            return 0;\\n        }\\n        \\n        // For Performing bucket sort, first thing to do is to\\n        // find the range of the elements in input array ie...,\\n        // min and max elements in the input array\\n        int minVal = *min_element(nums.begin(), nums.end());\\n        int maxVal = *max_element(nums.begin(), nums.end());\\n        \\n        // variable to hold the size of input vector\\n        int n = nums.size();\\n        \\n        // Calculate the gap between each bucket and no of buckets\\n        // Eg: 3, 6, 9, 1 -> min = 1, max = 9\\n        // gap = 9 - 1 / n - 1 = 8 / 3 = 2.66\\n        // =>   -------------------------------------------------\\n        //     1     2.66          5.32          7.98           9\\n        // From above, it is clear that we have 4 buckets\\n        float gap = (float)(maxVal - minVal) / (float)(n - 1);\\n        \\n        // Cornor case where if the gap is zero\\n        if (gap == 0.0) {\\n            // Gap between buckets is zero ie.., we have same elements\\n            // in input array for eg: [1,1,1,1]\\n            // Max difference will be always zero\\n            return 0;\\n        }\\n        \\n        // Vectors to store min and max elements in each bucket\\n        vector<int> minBucket(n, INT_MAX);\\n        vector<int> maxBucket(n, INT_MIN);\\n        \\n        int idx;\\n        // Traverse the input vector and put the elements in correct bucket\\n        for (int& num : nums) {\\n            // Identify in which bucket this number should go\\n            idx = (num - minVal) / gap;\\n            \\n            // place the current number in min and max buckets\\n            minBucket[idx] = min(num, minBucket[idx]);\\n            maxBucket[idx] = max(num, maxBucket[idx]);\\n        }\\n        \\n        // Traverse the loop to find the max differnece between successive elements\\n        int prev = minBucket[0];\\n        // variable to store maxDifference\\n        int maxDiff = 0;\\n        \\n        for (int i = 0; i < n; i++) {\\n            // Check if the bucket is empty\\n            if (minBucket[i] != INT_MAX) {\\n                maxDiff = max(maxDiff, minBucket[i] - prev);\\n                prev = maxBucket[i];\\n            }\\n        }\\n        \\n        return maxDiff;\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1240475,
                "title": "c-bucket-sort",
                "content": "```\\nclass Solution {\\npublic:\\n    int maximumGap(vector<int>& nums) {\\n        const int n = nums.size();\\n        if(n<2) return 0;\\n        int maxE = *max_element(nums.begin(),nums.end());\\n        int minE = *min_element(nums.begin(),nums.end());\\n        int avgIntervals = (int)ceil(double(maxE-minE)/double(n-1));\\n        vector<int> maxA(n-1,INT_MIN); // n-1 buckets enough as per pegion hole principle\\n        vector<int> minA(n-1,INT_MAX);\\n        // We shouldn\\'t worry about other elements. In each bucket, minimum and maximum is enough.\\n        for(int i=0; i<n-1; i++) {\\n            if(nums[i]==minE || nums[i]==maxE) continue;  //[1,1,1,1]. AvgIntervals=0 and divByZero next line\\n            int bucketIndx = (nums[i]-minE)/avgIntervals; // Magic formula to find bucket index.\\n            maxA[bucketIndx] = max(maxA[bucketIndx],nums[i]);\\n            minA[bucketIndx] = min(minA[bucketIndx],nums[i]);\\n        }\\n        \\n        //We didn\\'t place min element and max element in the buckets before. We would start prev with min ele\\n        int gap = INT_MIN, prev = minE;\\n        for(int i=0; i<n-1; i++) {\\n            if(maxA[i]==INT_MIN || minA[i]==INT_MAX) continue; // Empty bucket\\n            gap = max(gap,minA[i]-prev); // Find diff b/w minimum of current and maximum of prev bucket\\n            prev = maxA[i];\\n        }\\n        //Finally compare with Maximum element\\n        gap=max(gap, maxE-prev);\\n        return gap;\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    int maximumGap(vector<int>& nums) {\\n        const int n = nums.size();\\n        if(n<2) return 0;\\n        int maxE = *max_element(nums.begin(),nums.end());\\n        int minE = *min_element(nums.begin(),nums.end());\\n        int avgIntervals = (int)ceil(double(maxE-minE)/double(n-1));\\n        vector<int> maxA(n-1,INT_MIN); // n-1 buckets enough as per pegion hole principle\\n        vector<int> minA(n-1,INT_MAX);\\n        // We shouldn\\'t worry about other elements. In each bucket, minimum and maximum is enough.\\n        for(int i=0; i<n-1; i++) {\\n            if(nums[i]==minE || nums[i]==maxE) continue;  //[1,1,1,1]. AvgIntervals=0 and divByZero next line\\n            int bucketIndx = (nums[i]-minE)/avgIntervals; // Magic formula to find bucket index.\\n            maxA[bucketIndx] = max(maxA[bucketIndx],nums[i]);\\n            minA[bucketIndx] = min(minA[bucketIndx],nums[i]);\\n        }\\n        \\n        //We didn\\'t place min element and max element in the buckets before. We would start prev with min ele\\n        int gap = INT_MIN, prev = minE;\\n        for(int i=0; i<n-1; i++) {\\n            if(maxA[i]==INT_MIN || minA[i]==INT_MAX) continue; // Empty bucket\\n            gap = max(gap,minA[i]-prev); // Find diff b/w minimum of current and maximum of prev bucket\\n            prev = maxA[i];\\n        }\\n        //Finally compare with Maximum element\\n        gap=max(gap, maxE-prev);\\n        return gap;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1240248,
                "title": "c-bucket-sort-solution-o-n-time-and-space-complexity",
                "content": "```\\nclass Solution {\\npublic:\\n    int maximumGap(vector<int>& nums) {\\n        int n = nums.size();\\n        if (n < 2) return 0;\\n        vector<pair<int, int>> min_max(n, {INT_MAX, INT_MIN});\\n        int mn = *min_element(nums.begin(), nums.end()), mx = *max_element(nums.begin(), nums.end());\\n        int diff = (mx - mn) / (n - 1);\\n        if ((mx - mn) % (n - 1)) diff++;\\n        if (diff == 0) return 0;\\n\\n        for (int num : nums) {\\n            int ind = (num - mn) / diff;\\n            min_max[ind].first = min(min_max[ind].first, num);\\n            min_max[ind].second = max(min_max[ind].second, num);\\n        }\\n\\n        int ans = 0;\\n        int curr_mn = INT_MIN, curr_mx = INT_MAX;\\n\\n        int i = 0;\\n        while (i < n) {\\n            if (min_max[i].first == INT_MAX) {\\n                i++; continue;\\n            }\\n            if (curr_mx == INT_MAX) {\\n                curr_mx = min_max[i++].second; continue;\\n            }\\n            ans = max(ans, min_max[i].first - curr_mx);\\n            curr_mx = min_max[i++].second;\\n        }\\n\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    int maximumGap(vector<int>& nums) {\\n        int n = nums.size();\\n        if (n < 2) return 0;\\n        vector<pair<int, int>> min_max(n, {INT_MAX, INT_MIN});\\n        int mn = *min_element(nums.begin(), nums.end()), mx = *max_element(nums.begin(), nums.end());\\n        int diff = (mx - mn) / (n - 1);\\n        if ((mx - mn) % (n - 1)) diff++;\\n        if (diff == 0) return 0;\\n\\n        for (int num : nums) {\\n            int ind = (num - mn) / diff;\\n            min_max[ind].first = min(min_max[ind].first, num);\\n            min_max[ind].second = max(min_max[ind].second, num);\\n        }\\n\\n        int ans = 0;\\n        int curr_mn = INT_MIN, curr_mx = INT_MAX;\\n\\n        int i = 0;\\n        while (i < n) {\\n            if (min_max[i].first == INT_MAX) {\\n                i++; continue;\\n            }\\n            if (curr_mx == INT_MAX) {\\n                curr_mx = min_max[i++].second; continue;\\n            }\\n            ans = max(ans, min_max[i].first - curr_mx);\\n            curr_mx = min_max[i++].second;\\n        }\\n\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1228401,
                "title": "c-solution-using-buckets-with-comments",
                "content": "```\\nclass Solution {\\npublic:\\n    int maximumGap(vector<int>& nums) {\\n        int n = nums.size();\\n\\t\\t\\n\\t\\t//Base Case\\n        if (n < 2) return 0;\\n        if (n == 2) return max(nums[0], nums[1]) - min(nums[0], nums[1]);\\n        \\n\\t\\t//Calculate minimum and maximum values in the given array\\n        int minVal = nums[0], maxVal = 0; \\n        for (int num : nums) {\\n            minVal = min(num, minVal);\\n            maxVal = max(num, maxVal);\\n        }\\n        \\n\\t\\t//Calculate the intervals i.e size of buckets\\n        int interval = (int)ceil((maxVal - minVal + 0.0) / (n - 1));\\n\\t\\t\\n\\t\\t//interval 0 implies all the data valuesin the array are same, hence max gap is 0\\n        if (!interval) return 0;\\n        \\n\\t\\t//Initialize buckets, now we need on two because we wil be comparing only the maximum and minimum values in the interval, hence we dont need to store intermediate values\\n        vector<int> BucketMin(n-1, INT_MAX), BucketMax(n-1, -1);\\n        \\n\\t\\t//Fill the buckets using the magic formula\\n        int index;\\n        for (int num : nums) {\\n            if (num == maxVal || num == minVal) continue;\\n            index = (num - minVal) / interval;\\n            BucketMin[index] = min(BucketMin[index], num);\\n            BucketMax[index] = max(BucketMax[index], num);\\n        }\\n        \\n\\t\\t//Comaparing the buckets\\n\\t\\t//We consider the difference between the minimum value of current interval and the max value of previous interval\\n\\t\\t//For better understanding consider this,\\n\\t\\t// 1   ---A---5   47----B---68\\n\\t\\t//Let there be two buckets A and B, if you notice the minimum value of bucket B will be consecutive to maximum value of bucket A in sorted order\\n        int prev = minVal, res = 0;\\n        for (int i = 0; i < BucketMin.size(); i++) {\\n            if (BucketMax[i] == -1) continue;\\n            res = max(res, BucketMin[i] - prev);\\n            prev = BucketMax[i];\\n        }\\n        \\n        res = max(res, maxVal - prev);\\n        \\n        return res;\\n    }\\n};\\n```\\n\\nTime Complexity : O(N)\\nSpace Complexity: O(N)",
                "solutionTags": [
                    "C"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int maximumGap(vector<int>& nums) {\\n        int n = nums.size();\\n\\t\\t\\n\\t\\t//Base Case\\n        if (n < 2) return 0;\\n        if (n == 2) return max(nums[0], nums[1]) - min(nums[0], nums[1]);\\n        \\n\\t\\t//Calculate minimum and maximum values in the given array\\n        int minVal = nums[0], maxVal = 0; \\n        for (int num : nums) {\\n            minVal = min(num, minVal);\\n            maxVal = max(num, maxVal);\\n        }\\n        \\n\\t\\t//Calculate the intervals i.e size of buckets\\n        int interval = (int)ceil((maxVal - minVal + 0.0) / (n - 1));\\n\\t\\t\\n\\t\\t//interval 0 implies all the data valuesin the array are same, hence max gap is 0\\n        if (!interval) return 0;\\n        \\n\\t\\t//Initialize buckets, now we need on two because we wil be comparing only the maximum and minimum values in the interval, hence we dont need to store intermediate values\\n        vector<int> BucketMin(n-1, INT_MAX), BucketMax(n-1, -1);\\n        \\n\\t\\t//Fill the buckets using the magic formula\\n        int index;\\n        for (int num : nums) {\\n            if (num == maxVal || num == minVal) continue;\\n            index = (num - minVal) / interval;\\n            BucketMin[index] = min(BucketMin[index], num);\\n            BucketMax[index] = max(BucketMax[index], num);\\n        }\\n        \\n\\t\\t//Comaparing the buckets\\n\\t\\t//We consider the difference between the minimum value of current interval and the max value of previous interval\\n\\t\\t//For better understanding consider this,\\n\\t\\t// 1   ---A---5   47----B---68\\n\\t\\t//Let there be two buckets A and B, if you notice the minimum value of bucket B will be consecutive to maximum value of bucket A in sorted order\\n        int prev = minVal, res = 0;\\n        for (int i = 0; i < BucketMin.size(); i++) {\\n            if (BucketMax[i] == -1) continue;\\n            res = max(res, BucketMin[i] - prev);\\n            prev = BucketMax[i];\\n        }\\n        \\n        res = max(res, maxVal - prev);\\n        \\n        return res;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 961598,
                "title": "buckets-sort-and-the-pigeonhole-principle-with-o-n-explained-in-comments",
                "content": "```\\n// return 0 if nums length is less than 0\\n// find the min and max of nums array\\n// then find the interval by subtracting max and min and dividing it by length\\n// make two array bucketMin and bucketMax and fill both array with max integer and minus one\\n// after that put the minimum value in particular index of bucketMin and maximum value in particular index of bucketMax\\n// at last compare the max interval gap with max of particular index\\n// after the loop compare maxgap with final interval and return the maxgap\\n\\nclass Solution {\\n    public int maximumGap(int[] nums) {\\n        if(nums.length < 2) return 0;\\n        int min = nums[0], max = 0;\\n        for(int num : nums){\\n            min = Math.min(min, num);\\n            max = Math.max(max, num);\\n        }\\n        \\n        int interval = (int)(Math.ceil((max - min + 0.0)/(nums.length - 1)));\\n        int[] bucketMin = new int[nums.length - 1];\\n        int[] bucketMax = new int[nums.length - 1];\\n        Arrays.fill(bucketMin, Integer.MAX_VALUE);\\n        Arrays.fill(bucketMax, -1);                             \\n                        \\n        for(int i=0; i < nums.length; i++){\\n            if(nums[i] == min || nums[i] == max) continue;\\n            int index = (nums[i] - min)/interval;\\n            bucketMin[index] = Math.min(bucketMin[index], nums[i]);\\n            bucketMax[index] = Math.max(bucketMax[index], nums[i]);\\n        }\\n                             \\n        int prev = min, maxGap = 0;\\n        for(int i=0; i<bucketMin.length; i++){\\n            if(bucketMax[i] == -1) continue;\\n            maxGap = Math.max(bucketMin[i] - prev, maxGap);\\n            prev = bucketMax[i];\\n        }\\n                             \\n        maxGap = Math.max(max - prev, maxGap);\\n        return maxGap;\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\n// return 0 if nums length is less than 0\\n// find the min and max of nums array\\n// then find the interval by subtracting max and min and dividing it by length\\n// make two array bucketMin and bucketMax and fill both array with max integer and minus one\\n// after that put the minimum value in particular index of bucketMin and maximum value in particular index of bucketMax\\n// at last compare the max interval gap with max of particular index\\n// after the loop compare maxgap with final interval and return the maxgap\\n\\nclass Solution {\\n    public int maximumGap(int[] nums) {\\n        if(nums.length < 2) return 0;\\n        int min = nums[0], max = 0;\\n        for(int num : nums){\\n            min = Math.min(min, num);\\n            max = Math.max(max, num);\\n        }\\n        \\n        int interval = (int)(Math.ceil((max - min + 0.0)/(nums.length - 1)));\\n        int[] bucketMin = new int[nums.length - 1];\\n        int[] bucketMax = new int[nums.length - 1];\\n        Arrays.fill(bucketMin, Integer.MAX_VALUE);\\n        Arrays.fill(bucketMax, -1);                             \\n                        \\n        for(int i=0; i < nums.length; i++){\\n            if(nums[i] == min || nums[i] == max) continue;\\n            int index = (nums[i] - min)/interval;\\n            bucketMin[index] = Math.min(bucketMin[index], nums[i]);\\n            bucketMax[index] = Math.max(bucketMax[index], nums[i]);\\n        }\\n                             \\n        int prev = min, maxGap = 0;\\n        for(int i=0; i<bucketMin.length; i++){\\n            if(bucketMax[i] == -1) continue;\\n            maxGap = Math.max(bucketMin[i] - prev, maxGap);\\n            prev = bucketMax[i];\\n        }\\n                             \\n        maxGap = Math.max(max - prev, maxGap);\\n        return maxGap;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 861517,
                "title": "swift-radix-sort-bucket-sort",
                "content": "Radix sort\\nO(d*(n+b)) O(n+b)\\n```\\nfunc maximumGap(_ nums: [Int]) -> Int {\\n\\tif nums.isEmpty || nums.count == 1 { return 0 }\\n\\tlet count = nums.count\\n\\tlet maxNum = nums.max()!\\n\\tvar temp = nums\\n\\tvar exp = 1\\n\\n\\twhile maxNum / exp > 0 {\\n\\t\\tvar freqs = Array(repeating: 0, count: 10)\\n\\n\\t\\tfor num in temp {\\n\\t\\t\\tfreqs[(num / exp) % 10] += 1\\n\\t\\t}\\n\\n\\t\\tfor i in 1...9 {\\n\\t\\t\\tfreqs[i] += freqs[i - 1]\\n\\t\\t}\\n\\n\\t\\tfor num in temp.reversed() {\\n\\t\\t\\tlet digit = (num / exp) % 10\\n\\t\\t\\tfreqs[digit] -= 1\\n\\t\\t\\ttemp[freqs[digit]] = num\\n\\t\\t}\\n\\t\\texp *= 10\\n\\t}\\n\\n\\tvar maxGap = 0\\n\\tfor i in 1..<count {\\n\\t\\tmaxGap = max(maxGap, temp[i] - temp[i - 1])\\n\\t}\\n\\n\\treturn maxGap\\n}\\n```\\n\\nBucket sort, supa fast\\nO(n), O(n)\\n```\\nfunc maximumGap(_ nums: [Int]) -> Int {\\n\\tif nums.isEmpty || nums.count == 1 { return 0 }\\n\\tlet count = nums.count\\n\\tlet minNum = nums.min()!\\n\\tlet maxNum = nums.max()!\\n\\tif minNum == maxNum { return 0 }\\n\\tlet gap = Int((Double(maxNum - minNum)/Double(count - 1)).rounded(.up))\\n\\n\\tvar minBucket = Array(repeating: Int.max, count: count)\\n\\tvar maxBucket = Array(repeating: Int.min, count: count)\\n\\n\\tfor num in nums {\\n\\t\\tlet index = (num - minNum) / gap\\n\\n\\t\\tminBucket[index] = min(minBucket[index], num)\\n\\t\\tmaxBucket[index] = max(maxBucket[index], num)\\n\\t}\\n\\n\\tvar maxGap = 0\\n\\tvar prev = maxBucket[0]\\n\\tfor i in 1..<count {\\n\\t\\tif minBucket[i] == Int.max { continue }\\n\\t\\tmaxGap = max(maxGap, minBucket[i] - prev)\\n\\t\\tprev = maxBucket[i]\\n\\t}\\n\\n\\treturn maxGap\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nfunc maximumGap(_ nums: [Int]) -> Int {\\n\\tif nums.isEmpty || nums.count == 1 { return 0 }\\n\\tlet count = nums.count\\n\\tlet maxNum = nums.max()!\\n\\tvar temp = nums\\n\\tvar exp = 1\\n\\n\\twhile maxNum / exp > 0 {\\n\\t\\tvar freqs = Array(repeating: 0, count: 10)\\n\\n\\t\\tfor num in temp {\\n\\t\\t\\tfreqs[(num / exp) % 10] += 1\\n\\t\\t}\\n\\n\\t\\tfor i in 1...9 {\\n\\t\\t\\tfreqs[i] += freqs[i - 1]\\n\\t\\t}\\n\\n\\t\\tfor num in temp.reversed() {\\n\\t\\t\\tlet digit = (num / exp) % 10\\n\\t\\t\\tfreqs[digit] -= 1\\n\\t\\t\\ttemp[freqs[digit]] = num\\n\\t\\t}\\n\\t\\texp *= 10\\n\\t}\\n\\n\\tvar maxGap = 0\\n\\tfor i in 1..<count {\\n\\t\\tmaxGap = max(maxGap, temp[i] - temp[i - 1])\\n\\t}\\n\\n\\treturn maxGap\\n}\\n```\n```\\nfunc maximumGap(_ nums: [Int]) -> Int {\\n\\tif nums.isEmpty || nums.count == 1 { return 0 }\\n\\tlet count = nums.count\\n\\tlet minNum = nums.min()!\\n\\tlet maxNum = nums.max()!\\n\\tif minNum == maxNum { return 0 }\\n\\tlet gap = Int((Double(maxNum - minNum)/Double(count - 1)).rounded(.up))\\n\\n\\tvar minBucket = Array(repeating: Int.max, count: count)\\n\\tvar maxBucket = Array(repeating: Int.min, count: count)\\n\\n\\tfor num in nums {\\n\\t\\tlet index = (num - minNum) / gap\\n\\n\\t\\tminBucket[index] = min(minBucket[index], num)\\n\\t\\tmaxBucket[index] = max(maxBucket[index], num)\\n\\t}\\n\\n\\tvar maxGap = 0\\n\\tvar prev = maxBucket[0]\\n\\tfor i in 1..<count {\\n\\t\\tif minBucket[i] == Int.max { continue }\\n\\t\\tmaxGap = max(maxGap, minBucket[i] - prev)\\n\\t\\tprev = maxBucket[i]\\n\\t}\\n\\n\\treturn maxGap\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 726951,
                "title": "java-meaningful-variable-names-radix-sort-bucket-sort",
                "content": "***Radix Sort :*** \\nOnce you understand this - https://www.cs.usfca.edu/~galles/visualization/RadixSort.html , radix sort will be easy for you.\\n```\\nclass Solution {\\n    public int maximumGap(int[] nums) {\\n        if(nums.length < 2) return 0;\\n        int largest = nums[0];\\n        int[] aux = new int[nums.length];\\n        int divisor = 1;\\n        for(int i : nums)    largest = Math.max(largest, i);\\n        while(largest / divisor > 0){\\n            int[] count = new int[10];\\n            for(int i = 0; i < nums.length; i++){\\n                count[(nums[i] / divisor) % 10]++;\\n            }\\n            for(int i = 1; i < count.length; i++){\\n                count[i] += count[i-1];\\n            }\\n            for(int i = nums.length-1; i >= 0; i--){\\n                aux[--count[(nums[i]/divisor)%10]] = nums[i];\\n            }\\n            System.arraycopy(aux, 0, nums, 0, nums.length);\\n            divisor = divisor * 10;\\n        }        \\n        int res = 0;\\n        for(int i = 1; i < nums.length; i++){\\n            res = Math.max(res, nums[i]-nums[i-1]);\\n        }\\n        return res;\\n    }\\n}\\n```\\n***Bucket Sort :***\\n*  bucketSize is chosen wisely as \\n\\t*  ``` bucketSize = (max-min)/(n+1)```\\n\\t*  max = largest element in nums\\n\\t*  min = smallest element in nums\\n\\t*  n = size of nums\\n*  Reason for this bucketSize :\\n\\t*  Note that ```(n+1)```  gives total number of differences (gaps) in nums.\\n\\t*  the value of ```(max-min)/(n+1)``` gives minimum possible maximum gap in nums. This can only be maximum difference (gap) in nums iff sorted nums have uniform gap between each element, otherwise it will always be  < maximum gap in nums.\\n\\t* consider case of ```1,2,3,4,5,6``` .\\n\\t* If any of the changes in non-corner elements in made, maxGap will get greater than ```(max-min)/(n+1)```.\\n*  We are storing elements in buckets such that for each bucket, (difference between any 2 elements in the bucket < bucketSize). Hence, we don\\'t need to calculate differences between elements of a bucket, as they won\\'t give us maximum gap of nums.\\n* Let\\'s see how we have found total number of buckets.\\n\\t*  we know that ```max = min + (bucketSize * totalBuckets)```\\n\\t*  Using above formulae, ```totalBuckets = (max-min)/bucketSize```\\n* Now, we have to store elements in buckets\\n\\t*  Formula for this : ``` index = (nums[i]-min)/bucketSize;```\\n* Since differences between elements of a bucket won\\'t give us ans, we have to find inter-bucket difference. Hence, we need to find difference between maximum of a bucket with the manimum of next bucket ( for all buckets).\\n```\\nclass Solution {\\n    public int maximumGap(int[] nums) {\\n        if(nums.length < 2) return 0;\\n        int min = nums[0], max = nums[0];\\n        for(int i : nums){\\n            min = Math.min(min, i);\\n            max = Math.max(max, i);\\n        }\\n        int n = nums.length;\\n        int bucketSize = (max-min)/(n-1);\\n        if(bucketSize == 0) bucketSize++;\\n        int totalBuckets = (max-min)/bucketSize + 1;\\n        \\n        int[] minBucket = new int[totalBuckets];\\n        int[] maxBucket = new int[totalBuckets];\\n        Arrays.fill(minBucket, Integer.MAX_VALUE);\\n        \\n        for(int i = 0; i < n; i++){\\n            int index = (nums[i]-min)/bucketSize;\\n            minBucket[index] = Math.min(minBucket[index], nums[i]);\\n            maxBucket[index] = Math.max(maxBucket[index], nums[i]);\\n        }\\n        int prevMax = maxBucket[0], result = 0;\\n        for(int i = 1; i< totalBuckets; i++){\\n            if(minBucket[i] == Integer.MAX_VALUE)   continue;\\n            result = Math.max(result, minBucket[i]-prevMax);\\n            prevMax = maxBucket[i];\\n        }\\n        return result;\\n    }\\n}\\n```\\n",
                "solutionTags": [
                    "Java",
                    "Bucket Sort"
                ],
                "code": "```\\nclass Solution {\\n    public int maximumGap(int[] nums) {\\n        if(nums.length < 2) return 0;\\n        int largest = nums[0];\\n        int[] aux = new int[nums.length];\\n        int divisor = 1;\\n        for(int i : nums)    largest = Math.max(largest, i);\\n        while(largest / divisor > 0){\\n            int[] count = new int[10];\\n            for(int i = 0; i < nums.length; i++){\\n                count[(nums[i] / divisor) % 10]++;\\n            }\\n            for(int i = 1; i < count.length; i++){\\n                count[i] += count[i-1];\\n            }\\n            for(int i = nums.length-1; i >= 0; i--){\\n                aux[--count[(nums[i]/divisor)%10]] = nums[i];\\n            }\\n            System.arraycopy(aux, 0, nums, 0, nums.length);\\n            divisor = divisor * 10;\\n        }        \\n        int res = 0;\\n        for(int i = 1; i < nums.length; i++){\\n            res = Math.max(res, nums[i]-nums[i-1]);\\n        }\\n        return res;\\n    }\\n}\\n```\n``` bucketSize = (max-min)/(n+1)```\n```(n+1)```\n```(max-min)/(n+1)```\n```1,2,3,4,5,6```\n```(max-min)/(n+1)```\n```max = min + (bucketSize * totalBuckets)```\n```totalBuckets = (max-min)/bucketSize```\n``` index = (nums[i]-min)/bucketSize;```\n```\\nclass Solution {\\n    public int maximumGap(int[] nums) {\\n        if(nums.length < 2) return 0;\\n        int min = nums[0], max = nums[0];\\n        for(int i : nums){\\n            min = Math.min(min, i);\\n            max = Math.max(max, i);\\n        }\\n        int n = nums.length;\\n        int bucketSize = (max-min)/(n-1);\\n        if(bucketSize == 0) bucketSize++;\\n        int totalBuckets = (max-min)/bucketSize + 1;\\n        \\n        int[] minBucket = new int[totalBuckets];\\n        int[] maxBucket = new int[totalBuckets];\\n        Arrays.fill(minBucket, Integer.MAX_VALUE);\\n        \\n        for(int i = 0; i < n; i++){\\n            int index = (nums[i]-min)/bucketSize;\\n            minBucket[index] = Math.min(minBucket[index], nums[i]);\\n            maxBucket[index] = Math.max(maxBucket[index], nums[i]);\\n        }\\n        int prevMax = maxBucket[0], result = 0;\\n        for(int i = 1; i< totalBuckets; i++){\\n            if(minBucket[i] == Integer.MAX_VALUE)   continue;\\n            result = Math.max(result, minBucket[i]-prevMax);\\n            prevMax = maxBucket[i];\\n        }\\n        return result;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 611353,
                "title": "python-implementation-of-the-bucket-sort-solution",
                "content": "This is just a python implemenation of the bucket sort solution introduced by this [top voted post](https://leetcode.com/problems/maximum-gap/discuss/50643/bucket-sort-JAVA-solution-with-explanation-O(N)-time-and-space). In case anyone could not find a python bucketsort idea by searching in the post list like I did.\\nThe idea is discussed in the top voted post so there is no need for redundant explaination. Just make sure in the second for loop you take care of the empty buckets.\\n\\n```\\nimport math\\nclass Solution:\\n    def maximumGap(self, nums: List[int]) -> int:\\n        if len(nums) < 2:\\n            return 0\\n        n = len(nums)\\n        minv, maxv = min(nums), max(nums)\\n        gap = math.ceil((maxv - minv)/(n-1))\\n        \\n        # in case of zero division error\\n        if not gap:\\n            return 0\\n        \\n        num_buckets = math.ceil((maxv - minv)/gap) + 1\\n        buckets = [[float(\\'inf\\'), float(\\'-inf\\')] for _ in range(num_buckets)]\\n        \\n        for num in nums:\\n            idx = (num-minv)//gap\\n            if idx >= 0:\\n                buckets[idx][0] = min(buckets[idx][0], num)\\n                buckets[idx][1] = max(buckets[idx][1], num)\\n         \\n\\t\\t# iterate over buckets to find maxgap, make sure the empty buckets is taken care of\\n        res = -1\\n        for i in range(1, num_buckets):\\n            if buckets[i][0] == float(\\'inf\\'): continue\\n            prev = i - 1\\n            while prev >= 0 and buckets[prev][0] == float(\\'inf\\'):\\n                prev -= 1\\n            if prev >= 0:\\n                res = max(res, buckets[i][0] - buckets[prev][1])\\n        return res\\n```",
                "solutionTags": [
                    "Python"
                ],
                "code": "```\\nimport math\\nclass Solution:\\n    def maximumGap(self, nums: List[int]) -> int:\\n        if len(nums) < 2:\\n            return 0\\n        n = len(nums)\\n        minv, maxv = min(nums), max(nums)\\n        gap = math.ceil((maxv - minv)/(n-1))\\n        \\n        # in case of zero division error\\n        if not gap:\\n            return 0\\n        \\n        num_buckets = math.ceil((maxv - minv)/gap) + 1\\n        buckets = [[float(\\'inf\\'), float(\\'-inf\\')] for _ in range(num_buckets)]\\n        \\n        for num in nums:\\n            idx = (num-minv)//gap\\n            if idx >= 0:\\n                buckets[idx][0] = min(buckets[idx][0], num)\\n                buckets[idx][1] = max(buckets[idx][1], num)\\n         \\n\\t\\t# iterate over buckets to find maxgap, make sure the empty buckets is taken care of\\n        res = -1\\n        for i in range(1, num_buckets):\\n            if buckets[i][0] == float(\\'inf\\'): continue\\n            prev = i - 1\\n            while prev >= 0 and buckets[prev][0] == float(\\'inf\\'):\\n                prev -= 1\\n            if prev >= 0:\\n                res = max(res, buckets[i][0] - buckets[prev][1])\\n        return res\\n```",
                "codeTag": "Java"
            },
            {
                "id": 521415,
                "title": "rust-bucket-sort",
                "content": "```rust\\nimpl Solution {\\n    // O(nlog(n))\\n    //  sort and one pass\\n    \\n    // O(n) bucket sort\\n    pub fn maximum_gap(nums: Vec<i32>) -> i32 {\\n        if nums.len() < 2 {\\n            return 0 as i32;\\n        }\\n        \\n        let max = *nums.iter().max().unwrap();\\n        let min = *nums.iter().min().unwrap();\\n        \\n        let bucket_size = std::cmp::max(1 as i32, (max - min) / nums.len() as i32);\\n        let bucket_count = (max - min) / bucket_size + 1;\\n        let mut buckets = vec![(None, None); bucket_count as usize]; // bucket(min_val, max_val)\\n        \\n        for n in &nums {\\n            let bucket_num = ((n - min) / bucket_size) as usize;\\n            let bucket = buckets[bucket_num];\\n            \\n            match bucket {\\n                (Some(a), Some(b)) => {\\n                    if n < a {\\n                        buckets[bucket_num] = (Some(n), Some(b))\\n                    } else if n > b {\\n                        buckets[bucket_num] = (Some(a), Some(n))\\n                    }\\n                }\\n                \\n                (None, None) => {\\n                    buckets[bucket_num] = (Some(n), Some(n));                  \\n                }\\n                \\n                _ => ()\\n            }\\n        }\\n        \\n        let mut res = 0;\\n        let mut prev_max = min;\\n        \\n        for bucket in buckets {\\n            if let (Some(a), Some(b)) = bucket {\\n                res = std::cmp::max(res, a - prev_max);\\n                prev_max = *b;\\n            }\\n        }\\n        \\n        res as i32\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```rust\\nimpl Solution {\\n    // O(nlog(n))\\n    //  sort and one pass\\n    \\n    // O(n) bucket sort\\n    pub fn maximum_gap(nums: Vec<i32>) -> i32 {\\n        if nums.len() < 2 {\\n            return 0 as i32;\\n        }\\n        \\n        let max = *nums.iter().max().unwrap();\\n        let min = *nums.iter().min().unwrap();\\n        \\n        let bucket_size = std::cmp::max(1 as i32, (max - min) / nums.len() as i32);\\n        let bucket_count = (max - min) / bucket_size + 1;\\n        let mut buckets = vec![(None, None); bucket_count as usize]; // bucket(min_val, max_val)\\n        \\n        for n in &nums {\\n            let bucket_num = ((n - min) / bucket_size) as usize;\\n            let bucket = buckets[bucket_num];\\n            \\n            match bucket {\\n                (Some(a), Some(b)) => {\\n                    if n < a {\\n                        buckets[bucket_num] = (Some(n), Some(b))\\n                    } else if n > b {\\n                        buckets[bucket_num] = (Some(a), Some(n))\\n                    }\\n                }\\n                \\n                (None, None) => {\\n                    buckets[bucket_num] = (Some(n), Some(n));                  \\n                }\\n                \\n                _ => ()\\n            }\\n        }\\n        \\n        let mut res = 0;\\n        let mut prev_max = min;\\n        \\n        for bucket in buckets {\\n            if let (Some(a), Some(b)) = bucket {\\n                res = std::cmp::max(res, a - prev_max);\\n                prev_max = *b;\\n            }\\n        }\\n        \\n        res as i32\\n    }\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 499481,
                "title": "python3-super-simple-nlog-n-solution",
                "content": "```\\nclass Solution:\\n    def maximumGap(self, nums: List[int]) -> int:\\n        if len(nums)==1: return 0\\n        nums.sort()\\n        max_diff=0\\n        for i in range(len(nums)-1):\\n            max_diff=max(max_diff,nums[i+1]-nums[i])\\n        return max_diff\\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def maximumGap(self, nums: List[int]) -> int:\\n        if len(nums)==1: return 0\\n        nums.sort()\\n        max_diff=0\\n        for i in range(len(nums)-1):\\n            max_diff=max(max_diff,nums[i+1]-nums[i])\\n        return max_diff\\n```",
                "codeTag": "Java"
            },
            {
                "id": 370218,
                "title": "c-radix-sort",
                "content": "```\\npublic class Solution {\\n    public int MaximumGap(int[] nums) {\\n        if(nums.Length < 2) return 0;\\n        int digit = 1;\\n        foreach(int n in nums) digit = Math.Max(digit, (int) Math.Floor(Math.Log10(n) + 1));  \\n        \\n        for(int i = 1 ; i <= digit ; i++) nums = CountingSort(nums, i);\\n        \\n        int maxD = int.MinValue;\\n        for(int i = 1 ; i < nums.Length ; i++) maxD = Math.Max(maxD, nums[i] - nums[i - 1]);\\n\\n        return maxD;\\n    }\\n    \\n    private int[] CountingSort(int[] nums, int digit) {\\n        List<int>[] idx = new List<int>[10];\\n        for(int i = 0 ; i < idx.Length ; i++) {\\n            idx[i] = new List<int>();\\n        }\\n        \\n        foreach(int n in nums) {\\n            int d1 = (int) Math.Pow(10, digit);\\n            int d2 = (int) Math.Pow(10, digit - 1);\\n            int tmp = n % d1 / d2;\\n            idx[tmp].Add(n);\\n        }\\n        \\n        List<int> ret = new List<int>();\\n        for(int i = 0 ; i < idx.Length ; i++) ret.AddRange(idx[i]);\\n        \\n        return ret.ToArray();\\n       \\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\npublic class Solution {\\n    public int MaximumGap(int[] nums) {\\n        if(nums.Length < 2) return 0;\\n        int digit = 1;\\n        foreach(int n in nums) digit = Math.Max(digit, (int) Math.Floor(Math.Log10(n) + 1));  \\n        \\n        for(int i = 1 ; i <= digit ; i++) nums = CountingSort(nums, i);\\n        \\n        int maxD = int.MinValue;\\n        for(int i = 1 ; i < nums.Length ; i++) maxD = Math.Max(maxD, nums[i] - nums[i - 1]);\\n\\n        return maxD;\\n    }\\n    \\n    private int[] CountingSort(int[] nums, int digit) {\\n        List<int>[] idx = new List<int>[10];\\n        for(int i = 0 ; i < idx.Length ; i++) {\\n            idx[i] = new List<int>();\\n        }\\n        \\n        foreach(int n in nums) {\\n            int d1 = (int) Math.Pow(10, digit);\\n            int d2 = (int) Math.Pow(10, digit - 1);\\n            int tmp = n % d1 / d2;\\n            idx[tmp].Add(n);\\n        }\\n        \\n        List<int> ret = new List<int>();\\n        for(int i = 0 ; i < idx.Length ; i++) ret.AddRange(idx[i]);\\n        \\n        return ret.ToArray();\\n       \\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 50672,
                "title": "c-bucket-sort-o-n-time-and-o-1-space",
                "content": "```\\nclass Solution {\\npublic:\\n    /**\\n     * @param nums: a vector of integers\\n     * @return: the maximum difference\\n     */\\n    void sort(vector<int> &nums, int s, int e, int d) {\\n        if (d < 0 || s == e)\\n            return;\\n        int i = s;\\n        for (int j = s; j < e; j++)\\n            if (nums[j] & (1 << d))\\n                swap(nums[i++], nums[j]);\\n        sort(nums, s, i, d-1);\\n        sort(nums, i, e, d-1);\\n    }\\n    int maximumGap(vector<int> nums) {\\n        sort(nums, 0, nums.size(), 31);\\n        int max_diff = 0;\\n        for (int i = 1; i < nums.size(); i++)\\n            max_diff = max(max_diff, nums[i-1] - nums[i]);\\n        return max_diff;\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    /**\\n     * @param nums: a vector of integers\\n     * @return: the maximum difference\\n     */\\n    void sort(vector<int> &nums, int s, int e, int d) {\\n        if (d < 0 || s == e)\\n            return;\\n        int i = s;\\n        for (int j = s; j < e; j++)\\n            if (nums[j] & (1 << d))\\n                swap(nums[i++], nums[j]);\\n        sort(nums, s, i, d-1);\\n        sort(nums, i, e, d-1);\\n    }\\n    int maximumGap(vector<int> nums) {\\n        sort(nums, 0, nums.size(), 31);\\n        int max_diff = 0;\\n        for (int i = 1; i < nums.size(); i++)\\n            max_diff = max(max_diff, nums[i-1] - nums[i]);\\n        return max_diff;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 50677,
                "title": "c-solution-with-explanation-bucket-sort",
                "content": "```\\nclass Solution {\\npublic:\\n    int maximumGap(vector<int>& nums) {\\n        if(nums.size()==0 || nums.size()==1)  //corner check\\n              return 0;         \\n        int numsMin = nums[0];\\n        int numsMax = nums[0];\\n\\n      //get the max value and the min value of the  array\\n        for(int i=1; i<nums.size(); i++)            \\n        {\\n            numsMin = min(numsMin, nums[i]);\\n            numsMax = max(numsMax, nums[i]);\\n        }\\n        \\n     // if all numbers of the array are equal, return 0 \\n        if(numsMin == numsMax)                  \\n             return 0;\\n        int len = nums.size();\\n        int gap = ceil((numsMax-numsMin)*1.0/(len-1));\\n\\n       // store the min value in that bucket\\n       // store the max value in that bucket\\n        vector<int> bucketMin(len, INT_MAX);         \\n        vector<int> bucketMax(len, INT_MIN);            \\n        \\n        for(int i=0; i<len; i++)         //scan the array\\n        {\\n            int idx = (nums[i]-numsMin)/gap;\\n            bucketMin[idx] = min(nums[i], bucketMin[idx]);\\n            bucketMax[idx] = max(nums[i], bucketMax[idx]);\\n        }\\n        \\n        for(int i=0; i<len; i++)\\n        {\\n             //judge if the bucket is empty\\n            if(bucketMin[i] != INT_MAX)                 \\n            {\\n                //update the max gap\\n                gap = max(bucketMin[i]-numsMin, gap);      \\n                numsMin = bucketMax[i];\\n            }\\n        }\\n        \\n        return gap;\\n    }\\n};",
                "solutionTags": [
                    "C"
                ],
                "code": "class Solution {\\npublic:\\n    int maximumGap(vector<int>& nums) {\\n        if(nums.size()==0 || nums.size()==1)  //corner check\\n              return 0;         \\n        int numsMin = nums[0];\\n        int numsMax = nums[0];\\n\\n      //get the max value and the min value of the  array\\n        for(int i=1; i<nums.size(); i++)            \\n        {\\n            numsMin = min(numsMin, nums[i]);\\n            numsMax = max(numsMax, nums[i]);\\n        }",
                "codeTag": "Java"
            },
            {
                "id": 50688,
                "title": "concise-c-solution-use-buckets",
                "content": "    class Solution {\\n    public:\\n        int maximumGap(vector<int>& nums) {\\n            if (nums.size() < 2) {\\n                return 0;\\n            }\\n            int max_num = *max_element(nums.begin(), nums.end());\\n            int min_num = *min_element(nums.begin(), nums.end());\\n            if (max_num == min_num) {\\n                return 0;\\n            }\\n            float bucket_size = (float)(max_num - min_num) / nums.size();\\n            vector<pair<int, int>> buckets(nums.size() + 1, make_pair(INT_MAX, INT_MIN));\\n            for (auto i : nums) {\\n                int index = (int)((i - min_num) / bucket_size);\\n                buckets[index].first = min(buckets[index].first, i);\\n                buckets[index].second = max(buckets[index].second, i);\\n            }\\n            int max_gap = buckets[0].second - buckets[0].first;\\n            for (int i = 1, pre = buckets[0].second; i < buckets.size(); ++i) {\\n                if (buckets[i].first == INT_MAX) continue;\\n                max_gap = max(max_gap, max(buckets[i].second - buckets[i].first, buckets[i].first - pre));\\n                pre = buckets[i].second;\\n            }\\n            return max_gap;\\n        }\\n    };",
                "solutionTags": [],
                "code": "class Solution {\\n    public:\\n        int maximumGap(vector<int>& nums) {\\n            if (nums.size() < 2) {\\n                return 0;\\n            }",
                "codeTag": "Java"
            },
            {
                "id": 50693,
                "title": "recommend-for-beginners-2-different-clean-c-implementations-with-detailed-explaination",
                "content": "As far as I am concerned, I think you should grasp the 3 linear-time-sorting-algorithm-implementation introduced at  \\n[https://leetcode.com/discuss/80529/recommend-beginners-implementation-detailed-explaination][1]\\n\\nThen you can quickly understand the following 2 implementation. They are just the small changed version of the original implementation.\\n\\n    class Solution {\\n    public:\\n        /* bucket-sort-inspired-ideas-implementation */\\n        int maximumGap(vector<int>& nums) {\\n            const int size_num=nums.size();\\n            if(size_num < 2)    return 0;\\n            int maxV=*max_element(nums.begin(), nums.end());\\n            int minV=*min_element(nums.begin(), nums.end());\\n            if(maxV==minV)  return 0;\\n            double range=(maxV-minV)/double(size_num-1);\\n            cout<<\"range:\"<<maxV<<\"-\"<<minV<<\"=\"<<(int)(maxV-minV/double(1))<<endl;\\n            vector<int> max_bucket(size_num, INT_MIN);\\n            vector<int> min_bucket(size_num, INT_MAX);\\n            for(int i=0; i<size_num; i++){\\n                int index=(nums[i]-minV)/range;\\n                max_bucket[index]=max(max_bucket[index], nums[i]);\\n                min_bucket[index]=min(min_bucket[index], nums[i]);\\n            }\\n            \\n            int max_gap=(int)range, start=max_bucket[0];\\n            cout<<max_gap<<endl;\\n            for(int i=1; i<size_num; i++){\\n                if(min_bucket[i]==INT_MAX) continue;\\n                max_gap = max(max_gap, min_bucket[i]-start);\\n                start=max_bucket[i];\\n            }\\n            return max_gap;\\n        }\\n        \\n        /* radix-based-sorting-implementation */\\n        int maximumGap(vector<int>& nums){\\n        \\tif (nums.size() < 2)\\treturn 0;\\n        \\tint max_val = *max_element(nums.begin(), nums.end());\\n        \\tint exp = 1;\\n        \\tint R = 10;\\n        \\tvector<int> aux(nums.size(), 0);\\n        \\n        \\twhile (max_val / exp > 0){\\n        \\t\\tvector<int> count(R, 0);\\n        \\t\\tfor (int i = 0; i < nums.size(); i++){\\n        \\t\\t\\tcount[(nums[i] / exp) % 10]++;\\n        \\t\\t}\\n        \\t\\tfor (int i = 1; i < count.size(); i++){\\n        \\t\\t\\tcount[i] += count[i - 1];\\n        \\t\\t}\\n        \\t\\tfor (int i = nums.size() - 1; i >= 0; i--){\\n        \\t\\t\\taux[--count[(nums[i] / exp) % 10]] = nums[i];\\n        \\t\\t}\\n        \\n        \\t\\tfor (int i = 0; i < nums.size(); i++){\\n        \\t\\t\\tnums[i] = aux[i];\\n        \\t\\t}\\n        \\t\\texp *= 10;\\n        \\t}\\n        \\n        \\tint result = 0;\\n        \\tfor (int i = 1; i < aux.size(); i++){\\n        \\t\\tresult = max(result, aux[i] - aux[i - 1]);\\n        \\t}\\n        \\n        \\treturn result;\\n        }\\n    };\\n\\n\\n  [1]: https://leetcode.com/discuss/80529/recommend-beginners-implementation-detailed-explaination",
                "solutionTags": [],
                "code": "class Solution {\\n    public:\\n        /* bucket-sort-inspired-ideas-implementation */\\n        int maximumGap(vector<int>& nums) {\\n            const int size_num=nums.size();\\n            if(size_num < 2)    return 0;\\n            int maxV=*max_element(nums.begin(), nums.end());\\n            int minV=*min_element(nums.begin(), nums.end());\\n            if(maxV==minV)  return 0;\\n            double range=(maxV-minV)/double(size_num-1);\\n            cout<<\"range:\"<<maxV<<\"-\"<<minV<<\"=\"<<(int)(maxV-minV/double(1))<<endl;\\n            vector<int> max_bucket(size_num, INT_MIN);\\n            vector<int> min_bucket(size_num, INT_MAX);\\n            for(int i=0; i<size_num; i++){\\n                int index=(nums[i]-minV)/range;\\n                max_bucket[index]=max(max_bucket[index], nums[i]);\\n                min_bucket[index]=min(min_bucket[index], nums[i]);\\n            }",
                "codeTag": "C++"
            },
            {
                "id": 50736,
                "title": "c-solution-with-12ms",
                "content": "     class Solution {\\n    public:\\n        int maximumGap(vector<int> &num) {\\n            if (num.size() < 2) return 0;\\n            int min = num[0];\\n            int max = num[0];\\n            for (int i = 0; i < num.size(); ++i) {\\n                min = num[i] < min ? num[i] : min;\\n                max = num[i] > max ? num[i] : max;\\n            }\\n            if (max == min) return 0;\\n            int blocksize = (max - min + num.size() - 1) / num.size();\\n            vector<int> blockmin(num.size());\\n            vector<int> blockmax(num.size());\\n            vector<int> blockvalid(num.size(), 0);\\n            for (int i = 0; i < num.size(); ++i) {\\n                int blockidx = (num[i] - min) / blocksize;\\n                if (blockvalid[blockidx] == 0) {\\n                    blockvalid[blockidx] = 1;\\n                    blockmin[blockidx] = num[i];\\n                    blockmax[blockidx] = num[i];\\n                } else {\\n                    blockmin[blockidx] = num[i] < blockmin[blockidx] ? num[i] : blockmin[blockidx];\\n                    blockmax[blockidx] = num[i] > blockmax[blockidx] ? num[i] : blockmax[blockidx];\\n                }\\n            }\\n            int maxgap = 0;\\n            bool firstflag = false;\\n            int lastvalue = 0;\\n            for (int blockidx = 0; blockidx < num.size(); ++blockidx) {\\n                if (blockvalid[blockidx]) {\\n                    if (firstflag && blockmin[blockidx] - lastvalue > maxgap)\\n                        maxgap = blockmin[blockidx] - lastvalue;\\n                    firstflag = true;\\n                    if (blockmax[blockidx] - blockmin[blockidx] > maxgap)\\n                        maxgap = blockmax[blockidx] - blockmin[blockidx];\\n                    lastvalue = blockmax[blockidx];\\n                }\\n            }\\n            return maxgap;\\n        }\\n    };\\n\\nUse n (n = num.size()) buckets. Track max and min and empty of each bucket. Loop from the beginning and check the maximum gap.",
                "solutionTags": [],
                "code": "class Solution {\\n    public:\\n        int maximumGap(vector<int> &num) {\\n            if (num.size() < 2) return 0;\\n            int min = num[0];\\n            int max = num[0];\\n            for (int i = 0; i < num.size(); ++i) {\\n                min = num[i] < min ? num[i] : min;\\n                max = num[i] > max ? num[i] : max;\\n            }",
                "codeTag": "Java"
            },
            {
                "id": 50692,
                "title": "bucket-and-radix",
                "content": "    public class Solution {\\n        public int maximumGap(int[] num) {\\n           int len = num.length;\\n           int mask = 1;\\n           int[] num2 = new int[len];\\n           for(int i = 0; i<31; i++){\\n               int[] tmp = num;\\n               num = num2;\\n               num2 = tmp;\\n               int s = 0;\\n               int e = len-1;\\n               for(int j = 0; j<len; j++){\\n                   if((num2[j]&mask)==0) num[s++] = num2[j];\\n                   if((num2[len-1-j]&mask)>0) num[e--] = num2[len-1-j];\\n               }\\n               mask <<= 1;\\n           }\\n           int max = 0;\\n           for(int i = 1; i<len; i++){\\n               max = Math.max(max, num[i]-num[i-1]);\\n           }\\n           return max;\\n        }\\n    }\\n    \\n    \\n    public class Solution {\\n        public int maximumGap(int[] num) {\\n            if(num==null||num.length<2) return 0;\\n            int len = num.length;\\n            int min = 0;\\n            int max = 0;\\n            for(int i = 0; i < len; i++){\\n                min = Math.min(min, num[i]);\\n                max = Math.max(max, num[i]);\\n            }\\n            int bucketLen = (max-min)/(len-1) + ((max-min)%(len-1)>0?1:0);\\n            int bucketCount = (max-min)/bucketLen + 1;\\n            int[] minBuckets = new int[bucketCount];\\n            int[] maxBuckets = new int[bucketCount];\\n            \\n            Arrays.fill(minBuckets, Integer.MAX_VALUE);\\n            Arrays.fill(maxBuckets, Integer.MIN_VALUE);\\n            \\n            for(int i = 0; i < len; i++){\\n                int b = (num[i] - min)/bucketLen;\\n                minBuckets[b] = Math.min(minBuckets[b], num[i]);\\n                maxBuckets[b] = Math.max(maxBuckets[b], num[i]);\\n            }\\n            int maxGap = 0;\\n            int prev = maxBuckets[0];\\n            for(int i = 1; i < bucketCount; i++){\\n                if(minBuckets[i]==Integer.MAX_VALUE&&maxBuckets[i]==Integer.MIN_VALUE) continue;\\n                maxGap = Math.max(maxGap, minBuckets[i] - prev);\\n                prev = maxBuckets[i];\\n            }\\n            \\n            return maxGap;\\n        }\\n    }",
                "solutionTags": [
                    "Java"
                ],
                "code": "class Solution {\\n        public int maximumGap(int[] num) {\\n           int len = num.length;\\n           int mask = 1;\\n           int[] num2 = new int[len];\\n           for(int i = 0; i<31; i++){\\n               int[] tmp = num;\\n               num = num2;\\n               num2 = tmp;\\n               int s = 0;\\n               int e = len-1;\\n               for(int j = 0; j<len; j++){\\n                   if((num2[j]&mask)==0) num[s++] = num2[j];\\n                   if((num2[len-1-j]&mask)>0) num[e--] = num2[len-1-j];\\n               }",
                "codeTag": "Java"
            },
            {
                "id": 50751,
                "title": "use-average-gap-to-achieve-o-n-run-time-java-solution",
                "content": "My idea comes from this: Since the question only allow O(n) run time, I cannot do sorting, (sorting takes at least O(n log n). I can only make use of the O(n) space. Considering the worst case, where the integers are spread by equal distance, like {1,3,5,7,9}. Then the maximum gap is the 2, change any integer in between will leads to larger gap.\\n\\n So I keep a gaps array which has equal gap distance and non-overlapping range. Like the example {1,3,5,7,9} become {[1,3),[3,5),[5,7),[7,9]}. Let me add some number into it without changing the minimum and maximum bound. {1,3,2,4,5,7,9}. Then, go through the num array, assign lower bound and upper bound for each gap. \\n\\nThe example {1,3,2,4,5,7,9} has gaps\\n\\n[1,3) with lower bound = 1 and upper bound = 2;\\n\\n[3,5) with lower bound = 3 and upper bound = 4;\\n\\n[5,7) with lower bound = 5 and upper bound = 5;\\n\\n[7,9] with lower bound = 7 and upper bound = 9;\\n\\nThen go through the gaps array once, you'll be able to find out the maximum gap.\\n\\n    public class Solution {\\n        public int maximumGap(int[] num) {\\n            int maxGap = 0;\\n            \\n            // edge case\\n            if(num.length < 2){return maxGap;}\\n            \\n            // get maximum and minimum\\n            int min = num[0];\\n            int max = num[0];\\n            for(int i = 0;i < num.length;i++){\\n                if(num[i] < min)\\n                    min = num[i];\\n                if(num[i] > max)\\n                    max = num[i];\\n            }\\n            \\n            // divide into identical gaps\\n            Gap[] gaps = new Gap[num.length-1];\\n            boolean[] Engaged = new boolean[num.length-1];\\n            double gap = (double)(max-min)/(double)(num.length-1);\\n            for(int i = 0;i < gaps.length;i++)\\n                Engaged[Math.min((int)Math.floor((double)(num[i]-min)/gap),gaps.length-1)] = true;\\n                \\n            // assign maximum and minimum for each gap\\n            for(int i = 0;i < gaps.length;i++)\\n                gaps[i] = new Gap();\\n            for(int i = 0;i < num.length;i++){\\n                int index = (int)Math.floor((double)(num[i]-min)/gap);\\n                index = Math.min(index,gaps.length-1);\\n                \\n                // lower bound\\n                if(gaps[index].low == -1)\\n                    gaps[index].low = num[i];\\n                else\\n                    gaps[index].low = Math.min(gaps[index].low, num[i]);\\n                        \\n                // upper bound\\n                if(gaps[index].high == -1)\\n                    gaps[index].high = num[i];\\n                else\\n                    gaps[index].high = Math.max(gaps[index].high, num[i]);\\n            }\\n            \\n            // find maximum gap\\n            for(int i = 0;i < gaps.length;i++){\\n                if(Engaged[i]){\\n                    // check its inner gap\\n                    maxGap = Math.max(gaps[i].high-gaps[i].low, maxGap);\\n                    \\n                    // lower all the way\\n                    int j = i;\\n                    while(--j >= 0){\\n                        if(Engaged[j])\\n                            break;\\n                    }\\n                    if(j >= 0)\\n                        maxGap = Math.max(gaps[i].low - gaps[j].high,maxGap);\\n                        \\n                    // upper all the way\\n                    j = i;\\n                    while(++j < num.length-2){\\n                        if(Engaged[j])\\n                            break;\\n                    }\\n                    if(j < gaps.length)\\n                        maxGap = Math.max(gaps[j].low - gaps[i].high, maxGap);\\n                }\\n            }\\n            \\n            return maxGap;\\n        }\\n        \\n        class Gap{\\n            int low;\\n            int high;\\n            Gap(){\\n                low = -1;\\n                high = -1;\\n            }\\n            Gap(int x,int y){\\n                low = x;\\n                high = y;\\n            }\\n        }\\n    }",
                "solutionTags": [],
                "code": "class Solution {\\n        public int maximumGap(int[] num) {\\n            int maxGap = 0;\\n            \\n            // edge case\\n            if(num.length < 2){return maxGap;}",
                "codeTag": "Java"
            },
            {
                "id": 50720,
                "title": "i-directly-sort-the-vector-and-then-get-the-max-gap-it-cost-52ms-std-is-powerful",
                "content": "At Beginning, I using the std::sort to make the vector in order, and then get the max gap, after submit it, it cost 52ms. Then I follow the solution provided by leetcode, and it cost 44ms, but it cost me almost 2 hours to finish it. It seems that sometimes I cost large time to get a solution which seems to be a good solution, and it may not reduce too much cost when comparing with some easy way.\\n\\n\\n    #include <iostream>\\n    #include <functional>\\n    \\n    // Solution 1 cost 52ms\\n    int solution_1(std::vector<int> &num)\\n    {\\n        if (num.size() < 2)\\n        {\\n            return 0;\\n        }\\n        \\n        std::sort(num.begin(), num.end());\\n        int gap = 0;\\n        \\n        for(int n = 0, m = 1; m < num.size(); ++n, ++m)\\n        {\\n            int tmp_gap = num[m] - num[n];\\n            if (tmp_gap > gap)\\n            {\\n                gap = tmp_gap;\\n            }\\n        }\\n        \\n        //std::cout << gap << \"\\\\n\";\\n        \\n        return gap;\\n    }\\n    \\n    \\n    // Solution2 according to suggestion by leetcode\\n    // This solution cost 44ms\\n    \\n    typedef struct Bucket_S\\n    {\\n        int gap;\\n        int max;\\n        int min;\\n    } Bucket_T;\\n    \\n    void add2bluck(Bucket_T& bucket, int value)\\n    {\\n        if (bucket.max == -1)\\n        {\\n            bucket.max = value;\\n            bucket.min = value;\\n        }\\n        else\\n        {\\n            if (bucket.max < value)\\n            {\\n                bucket.max = value;\\n            }\\n            else if (bucket.min > value)\\n            {\\n                bucket.min = value;\\n            }\\n        }\\n    }\\n    \\n    int getIndexInBucket(int min, int value, int min_gap)\\n    {\\n        return (value - min)/min_gap;\\n    }\\n    \\n    void caculateGapSelf(Bucket_T& bucket)\\n    {\\n        if (bucket.max != -1)\\n        {\\n            bucket.gap = bucket.max - bucket.min;\\n        }\\n    }\\n    \\n    int solution_2(std::vector<int> &num)\\n    {\\n        if (num.size() < 2)\\n        {\\n            return 0;\\n        }\\n        \\n        int max = num[0];\\n        int min = num[0];\\n        \\n        for (unsigned int i = 1; i < num.size(); ++i)\\n        {\\n            if (num[i] > max)\\n            {\\n                max = num[i];\\n            }\\n            else if (num[i] < min)\\n            {\\n                min = num[i];\\n            }\\n        }\\n        \\n    //    std::cout << \"Max: \" << max <<\" Min: \"<< min << \"\\\\n\";\\n        \\n        int min_gap = (max - min)/(num.size() - 1);\\n        if (min_gap == 0)\\n        {\\n            min_gap = 1;\\n        }\\n    //    std::cout << \"Min Gap:\"<<min_gap<<\"\\\\n\";\\n        std::vector<Bucket_T> buckets;\\n        int total_buckets = (max - min)/min_gap + 1;\\n        for(unsigned int i = 0; i < total_buckets; ++i)\\n        {\\n            //std::cout<< i << \"<<<\";\\n            Bucket_T b;\\n            b.max = -1;\\n            b.min = -1;\\n            b.gap = -1;\\n            buckets.push_back(b);\\n    \\n        }\\n    \\n        int max_gap = 0;\\n        for (unsigned int i = 0; i < num.size(); ++i)\\n        {\\n            int index = getIndexInBucket(min, num[i], min_gap);\\n            //std::cout<< index << \" \" << num[i] << \"\\\\n\";\\n            add2bluck(buckets[index], num[i]);\\n            caculateGapSelf(buckets[index]);\\n            if (buckets[index].gap > max_gap)\\n            {\\n                max_gap = buckets[index].gap;\\n            }\\n        }\\n    \\n        \\n        \\n        for(unsigned int n = 0, m = 0; ;)\\n        {\\n            while (buckets[n].max == -1)\\n            {\\n                ++n;\\n                if (n >= buckets.size()-1)\\n                {\\n                    return -1; // error condition\\n                }\\n            }\\n            m = n + 1;\\n            while (buckets[m].max == -1)\\n            {\\n                ++m;\\n                if (m > buckets.size()-1)\\n                {\\n                    return -1;\\n                }\\n            }\\n            int tmp_gap = buckets[m].min - buckets[n].max;\\n            if (tmp_gap > max_gap)\\n            {\\n                max_gap = tmp_gap;\\n            }\\n            ++n;\\n            if ( n >= buckets.size()-1 || m >= buckets.size() - 1)\\n            {\\n                break;\\n            }\\n        }\\n        \\n        return max_gap;\\n    }",
                "solutionTags": [],
                "code": "At Beginning, I using the std::sort to make the vector in order, and then get the max gap, after submit it, it cost 52ms. Then I follow the solution provided by leetcode, and it cost 44ms, but it cost me almost 2 hours to finish it. It seems that sometimes I cost large time to get a solution which seems to be a good solution, and it may not reduce too much cost when comparing with some easy way.\\n\\n\\n    #include <iostream>\\n    #include <functional>\\n    \\n    // Solution 1 cost 52ms\\n    int solution_1(std::vector<int> &num)\\n    {\\n        if (num.size() < 2)\\n        {\\n            return 0;\\n        }\\n        \\n        std::sort(num.begin(), num.end());\\n        int gap = 0;\\n        \\n        for(int n = 0, m = 1; m < num.size(); ++n, ++m)\\n        {\\n            int tmp_gap = num[m] - num[n];\\n            if (tmp_gap > gap)\\n            {\\n                gap = tmp_gap;\\n            }\\n        }\\n        \\n        //std::cout << gap << \"\\\\n\";\\n        \\n        return gap;\\n    }\\n    \\n    \\n    // Solution2 according to suggestion by leetcode\\n    // This solution cost 44ms\\n    \\n    typedef struct Bucket_S\\n    {\\n        int gap;\\n        int max;\\n        int min;\\n    } Bucket_T;\\n    \\n    void add2bluck(Bucket_T& bucket, int value)\\n    {\\n        if (bucket.max == -1)\\n        {\\n            bucket.max = value;\\n            bucket.min = value;\\n        }\\n        else\\n        {\\n            if (bucket.max < value)\\n            {\\n                bucket.max = value;\\n            }\\n            else if (bucket.min > value)\\n            {\\n                bucket.min = value;\\n            }\\n        }\\n    }\\n    \\n    int getIndexInBucket(int min, int value, int min_gap)\\n    {\\n        return (value - min)/min_gap;\\n    }\\n    \\n    void caculateGapSelf(Bucket_T& bucket)\\n    {\\n        if (bucket.max != -1)\\n        {\\n            bucket.gap = bucket.max - bucket.min;\\n        }\\n    }\\n    \\n    int solution_2(std::vector<int> &num)\\n    {\\n        if (num.size() < 2)\\n        {\\n            return 0;\\n        }\\n        \\n        int max = num[0];\\n        int min = num[0];\\n        \\n        for (unsigned int i = 1; i < num.size(); ++i)\\n        {\\n            if (num[i] > max)\\n            {\\n                max = num[i];\\n            }\\n            else if (num[i] < min)\\n            {\\n                min = num[i];\\n            }\\n        }\\n        \\n    //    std::cout << \"Max: \" << max <<\" Min: \"<< min << \"\\\\n\";\\n        \\n        int min_gap = (max - min)/(num.size() - 1);\\n        if (min_gap == 0)\\n        {\\n            min_gap = 1;\\n        }\\n    //    std::cout << \"Min Gap:\"<<min_gap<<\"\\\\n\";\\n        std::vector<Bucket_T> buckets;\\n        int total_buckets = (max - min)/min_gap + 1;\\n        for(unsigned int i = 0; i < total_buckets; ++i)\\n        {\\n            //std::cout<< i << \"<<<\";\\n            Bucket_T b;\\n            b.max = -1;\\n            b.min = -1;\\n            b.gap = -1;\\n            buckets.push_back(b);\\n    \\n        }\\n    \\n        int max_gap = 0;\\n        for (unsigned int i = 0; i < num.size(); ++i)\\n        {\\n            int index = getIndexInBucket(min, num[i], min_gap);\\n            //std::cout<< index << \" \" << num[i] << \"\\\\n\";\\n            add2bluck(buckets[index], num[i]);\\n            caculateGapSelf(buckets[index]);\\n            if (buckets[index].gap > max_gap)\\n            {\\n                max_gap = buckets[index].gap;\\n            }\\n        }\\n    \\n        \\n        \\n        for(unsigned int n = 0, m = 0; ;)\\n        {\\n            while (buckets[n].max == -1)\\n            {\\n                ++n;\\n                if (n >= buckets.size()-1)\\n                {\\n                    return -1; // error condition\\n                }\\n            }\\n            m = n + 1;\\n            while (buckets[m].max == -1)\\n            {\\n                ++m;\\n                if (m > buckets.size()-1)\\n                {\\n                    return -1;\\n                }\\n            }\\n            int tmp_gap = buckets[m].min - buckets[n].max;\\n            if (tmp_gap > max_gap)\\n            {\\n                max_gap = tmp_gap;\\n            }\\n            ++n;\\n            if ( n >= buckets.size()-1 || m >= buckets.size() - 1)\\n            {\\n                break;\\n            }\\n        }\\n        \\n        return max_gap;\\n    }",
                "codeTag": "C++"
            },
            {
                "id": 4046277,
                "title": "o-nlogn-time-complexity",
                "content": "# Intuition\\n- The problem asks us to find the maximum gap between any two elements in an array nums when the array is sorted. To do this, we can follow the following intuition:\\n\\n- Sort the array nums in ascending order. Sorting is necessary because we want to find the maximum gap, and the maximum gap will likely occur between adjacent elements after sorting.\\n\\n- Iterate through the sorted array and calculate the difference between each pair of adjacent elements. Keep track of the maximum difference found during this process.\\n\\n- Return the maximum difference as the answer\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n1. Import the necessary library java.util for using Arrays.sort().\\n\\n2. Define a function maximumGap that takes an array of integers nums as input and returns an integer representing the maximum gap.\\n\\n3. Check if the length of nums is 1. If it is, return 0 because there is only one element, and there can be no gap.\\n\\n4. Sort the nums array in ascending order using Arrays.sort(nums).\\n\\n5. Initialize a variable max_diff to store the maximum gap and set it to 0.\\n\\n6. Iterate through the sorted array from index 0 to nums.length - 2 (inclusive). For each pair of adjacent elements, calculate the difference curr_diff between them (i.e., nums[i+1] - nums[i]).\\n\\n7. If curr_diff is greater than the current max_diff, update max_diff to be equal to curr_diff.\\n\\n8. After the loop finishes, max_diff will contain the maximum gap between elements in the sorted array. Return max_diff as the result.\\n\\n# Complexity\\n- Time complexity: `O(nlog(n))`\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: `O(1)`\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nimport java.util.*;\\nclass Solution {\\n    public int maximumGap(int[] nums) {\\n    Arrays.sort(nums);\\n    int max_diff = 0;\\n    if(nums.length == 1) {\\n        return 0;\\n    } \\n    for(int i=0;i<nums.length-1;i++) {\\n        int curr_diff = nums[i+1]-nums[i];\\n        if(curr_diff > max_diff) {\\n            max_diff = curr_diff;\\n        }\\n    }\\n    return max_diff;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nimport java.util.*;\\nclass Solution {\\n    public int maximumGap(int[] nums) {\\n    Arrays.sort(nums);\\n    int max_diff = 0;\\n    if(nums.length == 1) {\\n        return 0;\\n    } \\n    for(int i=0;i<nums.length-1;i++) {\\n        int curr_diff = nums[i+1]-nums[i];\\n        if(curr_diff > max_diff) {\\n            max_diff = curr_diff;\\n        }\\n    }\\n    return max_diff;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 4025797,
                "title": "very-easy-approach-python-short",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\nSort the Input List\\nCalculate the Differences Between Adjacent Elements:\\nFind the Maximum Gap:\\nAnd return \\n<!-- Describe your approach to solving the problem. -->\\n\\n\\n# Complexity\\n- Time complexity:\\n- The dominant factor here is the sorting step, so the overall time complexity of your code is O(n log n) due to the sorting operation.\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n- Therefore, the overall space complexity of your code is O(n) due to the space used by the k list.\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution:\\n    def maximumGap(self, nums: List[int]) -> int:\\n        if len(nums) < 2:\\n            return 0\\n        nums.sort()\\n        k = []\\n        for i in range(len(nums) - 1):\\n            k.append(nums[i + 1] - nums[i])\\n        return max(k)\\n\\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def maximumGap(self, nums: List[int]) -> int:\\n        if len(nums) < 2:\\n            return 0\\n        nums.sort()\\n        k = []\\n        for i in range(len(nums) - 1):\\n            k.append(nums[i + 1] - nums[i])\\n        return max(k)\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3833911,
                "title": "o-n-time-o-b-space-bucket-sort-hint",
                "content": "**radix sort**\\n\\n    def maximumGap(self, nums: List[int]) -> int:\\n\\n        def counting_sort(arr, key):\\n            d = {i: [] for i in range(10)}\\n            for n in arr:\\n                d[key(n)] += n,\\n            return sum(d.values(), [])\\n\\n        l = len(str(max(nums)))\\n\\n        for i in range(1, l + 1):\\n            fn = lambda x: int(str(x).zfill(l)[-i])\\n            nums = counting_sort(nums, key=fn)\\n\\n        return max((b - a for a, b in itertools.pairwise(nums)), default=0)\\n\\n**classic bucket sort**\\n\\n        def maximumGap(self, nums):\\n            a, b, l = min(nums), max(nums), len(nums)\\n            o = max(1, (b - a)//(l - 1)) if l != 1 else 1  # for zero division\\n            bs = collections.defaultdict(list)\\n\\n            for n in nums:\\n                bs[(n - a)//o] += n,\\n\\n            [b.sort() for b in bs.values()]\\n            arr = itertools.chain.from_iterable(bs[i] for i in range(l))\\n            return max((b - a for a, b in itertools.pairwise(arr)), default=0)\\n\\n\\n**bucket sort +hint**\\n![image](https://assets.leetcode.com/users/images/557d62ab-4e8a-454d-bc76-0ce7f46f7032_1690638380.4297183.png)\\n\\n\\n    def maximumGap(self, nums):\\n        a, b, l = min(nums), max(nums), len(nums)\\n        o = max(1, (b - a)//(l - 1)) if l != 1 else 1  # for zero division\\n        bs = collections.defaultdict(list)\\n\\n        for n in nums:\\n            bs[(n - a)//o] += n,\\n\\n        bb = (bs[i] for i in range(l) if i in bs)\\n        return max((min(j) - max(i) for i, j in itertools.pairwise(bb)), default=0)",
                "solutionTags": [],
                "code": "**radix sort**\\n\\n    def maximumGap(self, nums: List[int]) -> int:\\n\\n        def counting_sort(arr, key):\\n            d = {i: [] for i in range(10)}\\n            for n in arr:\\n                d[key(n)] += n,\\n            return sum(d.values(), [])\\n\\n        l = len(str(max(nums)))\\n\\n        for i in range(1, l + 1):\\n            fn = lambda x: int(str(x).zfill(l)[-i])\\n            nums = counting_sort(nums, key=fn)\\n\\n        return max((b - a for a, b in itertools.pairwise(nums)), default=0)\\n\\n**classic bucket sort**\\n\\n        def maximumGap(self, nums):\\n            a, b, l = min(nums), max(nums), len(nums)\\n            o = max(1, (b - a)//(l - 1)) if l != 1 else 1  # for zero division\\n            bs = collections.defaultdict(list)\\n\\n            for n in nums:\\n                bs[(n - a)//o] += n,\\n\\n            [b.sort() for b in bs.values()]\\n            arr = itertools.chain.from_iterable(bs[i] for i in range(l))\\n            return max((b - a for a, b in itertools.pairwise(arr)), default=0)\\n\\n\\n**bucket sort +hint**\\n![image](https://assets.leetcode.com/users/images/557d62ab-4e8a-454d-bc76-0ce7f46f7032_1690638380.4297183.png)\\n\\n\\n    def maximumGap(self, nums):\\n        a, b, l = min(nums), max(nums), len(nums)\\n        o = max(1, (b - a)//(l - 1)) if l != 1 else 1  # for zero division\\n        bs = collections.defaultdict(list)\\n\\n        for n in nums:\\n            bs[(n - a)//o] += n,\\n\\n        bb = (bs[i] for i in range(l) if i in bs)\\n        return max((min(j) - max(i) for i, j in itertools.pairwise(bb)), default=0)",
                "codeTag": "Java"
            },
            {
                "id": 3772929,
                "title": "solution-using-counting-sort-linear-time-and-space",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nsince it is given in the question that we can use only linear time and space so we can only use a kind of counting sort , where we required a hash map which take an extra o(n) time complexity.\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\nIn counting sort first we required an hash map where we store the frequency of each element and after storing the frequency we just need to fill the original array based on there frequency , here we use an map not unordered map because the map is store value in sorted order.\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\nwe are traversing the array once , so  it is O(n) and an extra (logn)\\nfactor comes because of using the map, but still it is better in terms of time from inbuilt sort function..\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\nO(n) we are using only an map so the total extra space is equal to the size of map.\\n# Code\\n```\\nclass Solution {\\npublic:\\n\\nvector<int> countsort(vector<int> &nums)\\n{\\n    int n = nums.size();\\n    map<int, int> m;\\n    for (int i = 0; i < n; i++ )\\n        m[nums[i]]++;\\n\\n    nums.clear();\\n    for (auto it : m)\\n    {\\n        int cnt = it.second;\\n        while (cnt--)\\n        {\\n            nums.push_back(it.first);\\n        }\\n    }\\n    return nums;\\n}\\n\\nint maximumGap(vector<int> &nums)\\n{\\n    int n = nums.size();\\n    if (n < 2)\\n        return 0;\\n    vector<int> sortednums = countsort(nums);\\n\\n    int maxgap = INT_MIN;\\n    for (int i = 1; i < n; i++)\\n    {\\n        int currgap = sortednums[i] - sortednums[i - 1];\\n        maxgap = max(maxgap, currgap);\\n    }\\n\\n    return maxgap;\\n}\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Counting Sort"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n\\nvector<int> countsort(vector<int> &nums)\\n{\\n    int n = nums.size();\\n    map<int, int> m;\\n    for (int i = 0; i < n; i++ )\\n        m[nums[i]]++;\\n\\n    nums.clear();\\n    for (auto it : m)\\n    {\\n        int cnt = it.second;\\n        while (cnt--)\\n        {\\n            nums.push_back(it.first);\\n        }\\n    }\\n    return nums;\\n}\\n\\nint maximumGap(vector<int> &nums)\\n{\\n    int n = nums.size();\\n    if (n < 2)\\n        return 0;\\n    vector<int> sortednums = countsort(nums);\\n\\n    int maxgap = INT_MIN;\\n    for (int i = 1; i < n; i++)\\n    {\\n        int currgap = sortednums[i] - sortednums[i - 1];\\n        maxgap = max(maxgap, currgap);\\n    }\\n\\n    return maxgap;\\n}\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3730723,
                "title": "easy-python3-solution-beats-atleat-80",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution:\\n    def maximumGap(self, nums: List[int]) -> int:\\n        ls = nums\\n        b = sorted(ls) \\n        l1 =  []\\n        if(len(b) > 1):\\n            for x in range(1,len(ls)):\\n                difference = b[x] - b[x-1]\\n                l1.append(difference)\\n            return(max(l1))\\n        else:\\n            return 0\\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def maximumGap(self, nums: List[int]) -> int:\\n        ls = nums\\n        b = sorted(ls) \\n        l1 =  []\\n        if(len(b) > 1):\\n            for x in range(1,len(ls)):\\n                difference = b[x] - b[x-1]\\n                l1.append(difference)\\n            return(max(l1))\\n        else:\\n            return 0\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3655849,
                "title": "beginner-friendly-solution-radix-sort-count-sort",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\n    void CountSort(vector<int>& nums, int m){\\n        int n = nums.size();\\n        vector<int> v(n), count(10, 0);\\n        for(int i=0; i<n; ++i){\\n            count[(nums[i]/m)%10]++;\\n        }\\n        for(int i=1; i<10; ++i){\\n            count[i] += count[i-1];\\n        }\\n        for(int i=n-1; i>=0; --i){\\n            v[count[(nums[i]/m)%10]-1] = nums[i];\\n            count[(nums[i]/m)%10]--;\\n        }\\n        for(int i=0; i<n; ++i){\\n            nums[i] = v[i];\\n        }\\n        return;\\n    }\\n    void Radix_Sort(vector<int>& nums){\\n        int n = nums.size();\\n        int m = -1;\\n        for(int i=0; i<n; ++i){\\n            m = max(m, nums[i]);\\n        }\\n        for(int i=1; m/i>0; i *= 10){\\n            CountSort(nums, i);\\n        }\\n        return;\\n    }\\npublic:\\n    int maximumGap(vector<int>& nums) {\\n        int n = nums.size();\\n        Radix_Sort(nums);\\n        int mx = 0;\\n        for(int i=1; i<n; ++i){\\n            mx = max(mx, nums[i]-nums[i-1]);\\n        }\\n        return mx;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Sorting",
                    "Radix Sort"
                ],
                "code": "```\\nclass Solution {\\n    void CountSort(vector<int>& nums, int m){\\n        int n = nums.size();\\n        vector<int> v(n), count(10, 0);\\n        for(int i=0; i<n; ++i){\\n            count[(nums[i]/m)%10]++;\\n        }\\n        for(int i=1; i<10; ++i){\\n            count[i] += count[i-1];\\n        }\\n        for(int i=n-1; i>=0; --i){\\n            v[count[(nums[i]/m)%10]-1] = nums[i];\\n            count[(nums[i]/m)%10]--;\\n        }\\n        for(int i=0; i<n; ++i){\\n            nums[i] = v[i];\\n        }\\n        return;\\n    }\\n    void Radix_Sort(vector<int>& nums){\\n        int n = nums.size();\\n        int m = -1;\\n        for(int i=0; i<n; ++i){\\n            m = max(m, nums[i]);\\n        }\\n        for(int i=1; m/i>0; i *= 10){\\n            CountSort(nums, i);\\n        }\\n        return;\\n    }\\npublic:\\n    int maximumGap(vector<int>& nums) {\\n        int n = nums.size();\\n        Radix_Sort(nums);\\n        int mx = 0;\\n        for(int i=1; i<n; ++i){\\n            mx = max(mx, nums[i]-nums[i-1]);\\n        }\\n        return mx;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3631436,
                "title": "easy-python3-solution",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution:\\n    def maximumGap(self, nums: List[int]) -> int:\\n        l=[]\\n        a=nums\\n        b=sorted(a)\\n        if len(b)!=1:\\n            for i in range(1,len(a)):\\n                c=b[i]-b[i-1]\\n                l.append(c)\\n            return(max(l))\\n        else:\\n            return(0)\\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def maximumGap(self, nums: List[int]) -> int:\\n        l=[]\\n        a=nums\\n        b=sorted(a)\\n        if len(b)!=1:\\n            for i in range(1,len(a)):\\n                c=b[i]-b[i-1]\\n                l.append(c)\\n            return(max(l))\\n        else:\\n            return(0)\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3476565,
                "title": "easily-understandable-c-solution",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int maximumGap(vector<int>& nums) {\\n        if(nums.size()<2)\\n          return 0;\\n        int ans=0;\\n        sort(nums.begin(),nums.end());\\n        for(int i=1;i<nums.size();i++)\\n           {\\n                ans=max(ans,nums[i]-nums[i-1]);\\n           }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int maximumGap(vector<int>& nums) {\\n        if(nums.size()<2)\\n          return 0;\\n        int ans=0;\\n        sort(nums.begin(),nums.end());\\n        for(int i=1;i<nums.size();i++)\\n           {\\n                ans=max(ans,nums[i]-nums[i-1]);\\n           }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3464087,
                "title": "java-easy-solution",
                "content": "\\n\\n# Code\\n```\\nclass Solution {\\n    public int maximumGap(int[] nums) {\\n        int max=Integer.MIN_VALUE;\\n        if(nums.length<2) return 0;\\n        Arrays.sort(nums);\\n        for(int i=1;i<nums.length;i++)\\n            if(nums[i]-nums[i-1]>max) max=nums[i]-nums[i-1];\\n        return max;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Array",
                    "Sorting"
                ],
                "code": "```\\nclass Solution {\\n    public int maximumGap(int[] nums) {\\n        int max=Integer.MIN_VALUE;\\n        if(nums.length<2) return 0;\\n        Arrays.sort(nums);\\n        for(int i=1;i<nums.length;i++)\\n            if(nums[i]-nums[i-1]>max) max=nums[i]-nums[i-1];\\n        return max;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3314886,
                "title": "o-n-solution-beginner-friendly-solution-c",
                "content": "- Approach\\n          Firstly, I check if my size of vector is less than 2 then simply return 0\\n          Otherwise I sort the whole vector and initiallize one max variable assign to INT_MIN and simply traversing whole sorted vector and simply check if my max is less than or equal to difference of two adjacent number then assign max to that difference.\\n          After loop will over simply return that max variable.\\n\\n# Complexity\\n- **Time complexity: O(n)**\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- **Space complexity: O(1)**\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int maximumGap(vector<int>& nums) {\\n        if(nums.size()==1)\\n        {\\n            return 0;\\n        }\\n        sort(nums.begin(),nums.end());\\n        int max = INT_MIN;\\n        for(int i=0;i<nums.size()-1;i++)\\n        {\\n            if(max<=(nums[i+1]-nums[i]))\\n            {\\n                max = (nums[i+1]-nums[i]);\\n            }\\n        }\\n        return max;\\n    }\\n};\\n```\\n![upvote.jpg](https://assets.leetcode.com/users/images/bfd06e9e-5d8c-4e9f-85f4-a9a8ca3448a8_1679207552.3106096.jpeg)\\n",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int maximumGap(vector<int>& nums) {\\n        if(nums.size()==1)\\n        {\\n            return 0;\\n        }\\n        sort(nums.begin(),nums.end());\\n        int max = INT_MIN;\\n        for(int i=0;i<nums.size()-1;i++)\\n        {\\n            if(max<=(nums[i+1]-nums[i]))\\n            {\\n                max = (nums[i+1]-nums[i]);\\n            }\\n        }\\n        return max;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3202734,
                "title": "simple-six-line-code-c-easy-approach-for-beginner",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\nusing sort function and take max variable ,store differences in ans and compare with max if ans is greator than max=ans this will continue ..at the end return the max value..\\n\\n# Complexity\\n- Time complexity:\\nO(NLogn)\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int maximumGap(vector<int>& nums) {\\n        int n=nums.size();\\n        sort(nums.begin(),nums.end());\\n        if(n<=1){\\n        return 0;\\n        }\\n        int max=0;\\n        for(int i=0;i<n-1;i++)\\n        {\\n            int ans=nums[i+1]-nums[i];\\n             if(ans>max)\\n             {\\n                 max=ans;\\n             }\\n        }\\n       \\n  return max;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int maximumGap(vector<int>& nums) {\\n        int n=nums.size();\\n        sort(nums.begin(),nums.end());\\n        if(n<=1){\\n        return 0;\\n        }\\n        int max=0;\\n        for(int i=0;i<n-1;i++)\\n        {\\n            int ans=nums[i+1]-nums[i];\\n             if(ans>max)\\n             {\\n                 max=ans;\\n             }\\n        }\\n       \\n  return max;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3186883,
                "title": "optimized-solution-swift-o-n",
                "content": "# Complexity\\n- Time complexity: O(n)\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: O(n)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\n    func maximumGap(_ nums: [Int]) -> Int {\\n        let n = nums.count\\n        let mi = nums.min()!\\n        let ma = nums.max()!\\n        if ma == mi {return ma - mi}\\n        let bucketSize = Int(ceil(Double(ma-mi) / Double(n-1)))\\n        var minMaxBucket = Array(repeating: (min: Int.max, max: Int.min), count: n )\\n\\n        for num in nums {\\n            let idx = (num - mi) / bucketSize\\n            minMaxBucket[idx].min = min(minMaxBucket[idx].min, num)\\n            minMaxBucket[idx].max = max(minMaxBucket[idx].max, num)\\n        }\\n\\n        var maxGap: Int = bucketSize  \\n        var prev = minMaxBucket[0].max  \\n        for i in 1..<n where minMaxBucket[i].min != Int.max { \\n            maxGap = max(maxGap, minMaxBucket[i].min - prev)\\n            prev = minMaxBucket[i].max\\n        }\\n        return maxGap\\n    }\\n}\\n```",
                "solutionTags": [
                    "Swift",
                    "Bucket Sort"
                ],
                "code": "```\\nclass Solution {\\n    func maximumGap(_ nums: [Int]) -> Int {\\n        let n = nums.count\\n        let mi = nums.min()!\\n        let ma = nums.max()!\\n        if ma == mi {return ma - mi}\\n        let bucketSize = Int(ceil(Double(ma-mi) / Double(n-1)))\\n        var minMaxBucket = Array(repeating: (min: Int.max, max: Int.min), count: n )\\n\\n        for num in nums {\\n            let idx = (num - mi) / bucketSize\\n            minMaxBucket[idx].min = min(minMaxBucket[idx].min, num)\\n            minMaxBucket[idx].max = max(minMaxBucket[idx].max, num)\\n        }\\n\\n        var maxGap: Int = bucketSize  \\n        var prev = minMaxBucket[0].max  \\n        for i in 1..<n where minMaxBucket[i].min != Int.max { \\n            maxGap = max(maxGap, minMaxBucket[i].min - prev)\\n            prev = minMaxBucket[i].max\\n        }\\n        return maxGap\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3052339,
                "title": "java-priorityqueue",
                "content": "# Intuition\\nUse a PriorityQueue to sort elements into correct order on addition, then compare consecutive elements to get the maximum difference.\\n\\n# Code\\n```\\nclass Solution {\\n    public int maximumGap(int[] nums) {\\n        \\n        int len = nums.length;\\n        if (len < 2) {\\n            return 0;\\n        }\\n\\n        PriorityQueue<Integer> queue = new PriorityQueue<Integer>();\\n        for (Integer num : nums) {\\n            queue.add(num);\\n        }\\n        \\n        int res = Integer.MIN_VALUE;\\n        int last = queue.poll();\\n        while(!queue.isEmpty()) {\\n            int curr = queue.peek();\\n            res = Math.max(res, curr - last);\\n            last = queue.poll();\\n        }\\n        return res;\\n        \\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int maximumGap(int[] nums) {\\n        \\n        int len = nums.length;\\n        if (len < 2) {\\n            return 0;\\n        }\\n\\n        PriorityQueue<Integer> queue = new PriorityQueue<Integer>();\\n        for (Integer num : nums) {\\n            queue.add(num);\\n        }\\n        \\n        int res = Integer.MIN_VALUE;\\n        int last = queue.poll();\\n        while(!queue.isEmpty()) {\\n            int curr = queue.peek();\\n            res = Math.max(res, curr - last);\\n            last = queue.poll();\\n        }\\n        return res;\\n        \\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3034767,
                "title": "simple-approach-using-python",
                "content": "\\n<!-- Describe your approach to solving the problem. -->\\nAlmost beats 97.44%\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n999ms\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n28.1mb\\n# Code\\n```\\nclass Solution:\\n    def maximumGap(self, nums: List[int]) -> int:\\n        count=0\\n        x=len(nums)\\n        nums.sort()\\n        if x<2:\\n            return 0\\n        if x==2:\\n            return (nums[1]-nums[0])\\n        \\n        for i in range(1,len(nums)-1):\\n            \\n            max1=nums[i+1]-nums[i]\\n            if(max1>count):\\n                count=max1\\n        return count\\n\\n\\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def maximumGap(self, nums: List[int]) -> int:\\n        count=0\\n        x=len(nums)\\n        nums.sort()\\n        if x<2:\\n            return 0\\n        if x==2:\\n            return (nums[1]-nums[0])\\n        \\n        for i in range(1,len(nums)-1):\\n            \\n            max1=nums[i+1]-nums[i]\\n            if(max1>count):\\n                count=max1\\n        return count\\n\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2735237,
                "title": "python-o-nlogn-runtime-1123-ms-beats-91-69-memory-28-2-mb-beats-42-79",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n- best: O(N)\\n- wrost: O(NlogN)\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n- O(1)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution:\\n    def maximumGap(self, nums: List[int]) -> int:\\n        nums.sort()\\n        n=len(nums)\\n        m=0\\n        for i in range(n-1):\\n            m=max(m,abs(nums[i]-nums[i+1]))\\n        return m\\n\\n\\n\\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def maximumGap(self, nums: List[int]) -> int:\\n        nums.sort()\\n        n=len(nums)\\n        m=0\\n        for i in range(n-1):\\n            m=max(m,abs(nums[i]-nums[i+1]))\\n        return m\\n\\n\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2723115,
                "title": "js-solution-radix-sort",
                "content": "```\\n/**\\n * @param {number[]} nums\\n * @return {number}\\n */\\n\\nvar maximumGap = function (nums) {\\n  if (nums.length < 2) {\\n    return 0;\\n  }\\n\\n  let max = -Infinity;\\n  for (let num of nums) {\\n    max = Math.max(max, num);\\n  }\\n\\n  let place = 1;\\n  const sorted = Array(nums.length);\\n\\n  while (max / place > 0) {\\n    const count = Array(10).fill(0);\\n\\n    for (let num of nums) {\\n      count[Math.floor(num / place) % 10]++;\\n    }\\n\\n    for (let i = 1; i < count.length; i++) {\\n      count[i] += count[i - 1];\\n    }\\n\\n    for (let i = nums.length - 1; i >= 0; i--) {\\n      sorted[--count[Math.floor(nums[i] / place) % 10]] = nums[i];\\n    }\\n\\n    for (let i = 0; i < nums.length; i++) {\\n      nums[i] = sorted[i];\\n    }\\n\\n    place *= 10;\\n  }\\n\\n  max = -Infinity;\\n  for (let i = 1; i < sorted.length; i++) {\\n    max = Math.max(max, sorted[i] - sorted[i - 1]);\\n  }\\n  return max;\\n};\\n\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\n/**\\n * @param {number[]} nums\\n * @return {number}\\n */\\n\\nvar maximumGap = function (nums) {\\n  if (nums.length < 2) {\\n    return 0;\\n  }\\n\\n  let max = -Infinity;\\n  for (let num of nums) {\\n    max = Math.max(max, num);\\n  }\\n\\n  let place = 1;\\n  const sorted = Array(nums.length);\\n\\n  while (max / place > 0) {\\n    const count = Array(10).fill(0);\\n\\n    for (let num of nums) {\\n      count[Math.floor(num / place) % 10]++;\\n    }\\n\\n    for (let i = 1; i < count.length; i++) {\\n      count[i] += count[i - 1];\\n    }\\n\\n    for (let i = nums.length - 1; i >= 0; i--) {\\n      sorted[--count[Math.floor(nums[i] / place) % 10]] = nums[i];\\n    }\\n\\n    for (let i = 0; i < nums.length; i++) {\\n      nums[i] = sorted[i];\\n    }\\n\\n    place *= 10;\\n  }\\n\\n  max = -Infinity;\\n  for (let i = 1; i < sorted.length; i++) {\\n    max = Math.max(max, sorted[i] - sorted[i - 1]);\\n  }\\n  return max;\\n};\\n\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2691520,
                "title": "c-solution-maximum-gap-radix-sort-easy-to-understand",
                "content": "**Using Radix Sort**\\n* First Sort and then find Maximum Gap\\n```\\nclass Solution {\\npublic:\\n    // Radix Sort Code\\n    void countSort(vector<int>& nums, long long expo){\\n        int n = nums.size();\\n        int range = 10; // 0 to 9\\n        vector<int> freqArr(range, 0);\\n        \\n        for(int i = 0; i < n; i++){\\n            freqArr[nums[i]/expo % 10]++;\\n        }\\n        \\n        //pair sum array\\n        for(int i = 1; i < range; i++){\\n            freqArr[i] += freqArr[i-1];\\n        }\\n        vector<int> ans(n);\\n        for(int i = n - 1; i >= 0; i--){\\n            int pos = freqArr[nums[i]/expo % 10] - 1;\\n            ans[pos] = nums[i];\\n            freqArr[nums[i]/expo % 10]--;\\n        }\\n        \\n        for(int i = 0; i < n; i++){\\n            nums[i] = ans[i];\\n        }\\n    }\\n    \\n    void radixSort(vector<int>& nums){\\n        int max = *max_element(nums.begin(), nums.end());\\n        \\n        long long expo = 1;\\n        while(expo <= max){\\n            countSort(nums, expo);\\n            expo = expo * 10; \\n        }\\n    }\\n    \\n    // Finding Maximum Gap\\n    int maximumGap(vector<int>& nums) {\\n        radixSort(nums);\\n        int n = nums.size();\\n        int maxi = INT_MIN;\\n        \\n        if( n < 2){\\n            return 0;\\n        }\\n        \\n        for(int i = 1; i <= n - 1; i++){\\n            \\n            maxi = max(maxi, nums[i] - nums[i-1]);\\n        }\\n        \\n        return maxi;\\n    }\\n};\\n```\\n\\n**Please Upvote if it helps :)**",
                "solutionTags": [
                    "C++",
                    "C"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    // Radix Sort Code\\n    void countSort(vector<int>& nums, long long expo){\\n        int n = nums.size();\\n        int range = 10; // 0 to 9\\n        vector<int> freqArr(range, 0);\\n        \\n        for(int i = 0; i < n; i++){\\n            freqArr[nums[i]/expo % 10]++;\\n        }\\n        \\n        //pair sum array\\n        for(int i = 1; i < range; i++){\\n            freqArr[i] += freqArr[i-1];\\n        }\\n        vector<int> ans(n);\\n        for(int i = n - 1; i >= 0; i--){\\n            int pos = freqArr[nums[i]/expo % 10] - 1;\\n            ans[pos] = nums[i];\\n            freqArr[nums[i]/expo % 10]--;\\n        }\\n        \\n        for(int i = 0; i < n; i++){\\n            nums[i] = ans[i];\\n        }\\n    }\\n    \\n    void radixSort(vector<int>& nums){\\n        int max = *max_element(nums.begin(), nums.end());\\n        \\n        long long expo = 1;\\n        while(expo <= max){\\n            countSort(nums, expo);\\n            expo = expo * 10; \\n        }\\n    }\\n    \\n    // Finding Maximum Gap\\n    int maximumGap(vector<int>& nums) {\\n        radixSort(nums);\\n        int n = nums.size();\\n        int maxi = INT_MIN;\\n        \\n        if( n < 2){\\n            return 0;\\n        }\\n        \\n        for(int i = 1; i <= n - 1; i++){\\n            \\n            maxi = max(maxi, nums[i] - nums[i-1]);\\n        }\\n        \\n        return maxi;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2556773,
                "title": "python-bucket-sort-solution-with-explanation",
                "content": "we can use bucket sort to solve it.\\nfirst, calculate minimum and maximum of ```nums```, and determine the buckect size. and number of buckect.\\n```python\\n# eg. [2,4,6,8] -> three interval [2, 4), [4, 6), [6, 8), interval size is 2 \\nbuckectSize = max(1, (maxVal-minVal) // (leng-1))\\n```\\n```python\\n# eg. [2,4,6,8] -> three interval [2, 4), [4, 6), [6, 8), add a interval to put maximum 8 -> [8, 10)\\nnumBucket = (maxVal-minVal) // buckectSize + 1\\n\\n# because (8 - 2) // 2 = 3, so buckect index is 0 to 3, there have 4 buckects -> (8-2) // 2 + 1\\nindex = (n-minVal) // buckectSize\\n```\\nwe use bucket to track min and max in each interval, then calculate the gap between buckect ```min[i] - max[i-1]```\\ntc is ```O(N)```, sc is the same as tc\\n```\\nclass Solution:\\n    def maximumGap(self, nums: List[int]) -> int:\\n        if len(nums)==1: return 0\\n        minVal, maxVal, leng = min(nums), max(nums), len(nums)\\n        if maxVal-minVal==0: return 0\\n        buckectSize = max(1, (maxVal-minVal) // (leng-1))\\n        numBucket = (maxVal-minVal) // buckectSize + 1\\n        bucketMin,  bucketMax = [float(\\'inf\\')] * numBucket, [-1] * numBucket\\n        for n in nums:\\n            index = (n-minVal) // buckectSize\\n            bucketMin[index] = min(bucketMin[index], n)\\n            bucketMax[index] = max(bucketMax[index], n)\\n        maxGap = buckectSize\\n        previousMax = -1\\n        for i in range(numBucket):\\n            if bucketMax[i] == -1: \\n                continue\\n            if previousMax != -1:\\n                maxGap = max(bucketMin[i] - previousMax, maxGap)\\n            previousMax = bucketMax[i]\\n        return maxGap\\n```",
                "solutionTags": [
                    "Python",
                    "Bucket Sort"
                ],
                "code": "```nums```\n```python\\n# eg. [2,4,6,8] -> three interval [2, 4), [4, 6), [6, 8), interval size is 2 \\nbuckectSize = max(1, (maxVal-minVal) // (leng-1))\\n```\n```python\\n# eg. [2,4,6,8] -> three interval [2, 4), [4, 6), [6, 8), add a interval to put maximum 8 -> [8, 10)\\nnumBucket = (maxVal-minVal) // buckectSize + 1\\n\\n# because (8 - 2) // 2 = 3, so buckect index is 0 to 3, there have 4 buckects -> (8-2) // 2 + 1\\nindex = (n-minVal) // buckectSize\\n```\n```min[i] - max[i-1]```\n```O(N)```\n```\\nclass Solution:\\n    def maximumGap(self, nums: List[int]) -> int:\\n        if len(nums)==1: return 0\\n        minVal, maxVal, leng = min(nums), max(nums), len(nums)\\n        if maxVal-minVal==0: return 0\\n        buckectSize = max(1, (maxVal-minVal) // (leng-1))\\n        numBucket = (maxVal-minVal) // buckectSize + 1\\n        bucketMin,  bucketMax = [float(\\'inf\\')] * numBucket, [-1] * numBucket\\n        for n in nums:\\n            index = (n-minVal) // buckectSize\\n            bucketMin[index] = min(bucketMin[index], n)\\n            bucketMax[index] = max(bucketMax[index], n)\\n        maxGap = buckectSize\\n        previousMax = -1\\n        for i in range(numBucket):\\n            if bucketMax[i] == -1: \\n                continue\\n            if previousMax != -1:\\n                maxGap = max(bucketMin[i] - previousMax, maxGap)\\n            previousMax = bucketMax[i]\\n        return maxGap\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2470094,
                "title": "java-bucket-sort-99-93-faster",
                "content": "```\\nclass Solution {\\n    public int maximumGap(int[] nums) {\\n        if(nums.length==1){\\n            return 0;\\n        }\\n        int max=Integer.MIN_VALUE;\\n        int min=Integer.MAX_VALUE;\\n        int n=nums.length;\\n        \\n        for(int num: nums){\\n            max=Math.max(max,num);\\n            min=Math.min(min,num);\\n        }\\n        if(max==min){\\n            return 0;\\n        }\\n        int avgGap=(int)Math.ceil((double)(max-min)/(n-1));\\n        int bucketCount=(max-min+1)/avgGap+1;\\n        int[] minBucket=new int[bucketCount];\\n        int[] maxBucket=new int[bucketCount];\\n        \\n        Arrays.fill(maxBucket, -1);\\n        Arrays.fill(minBucket, Integer.MAX_VALUE);\\n        \\n        for(int num: nums){\\n            int bucketIdx=(num-min)/avgGap;\\n            \\n            minBucket[bucketIdx]=Math.min(minBucket[bucketIdx],num);\\n            maxBucket[bucketIdx]=Math.max(maxBucket[bucketIdx],num);\\n        }\\n        \\n        int maxGap=avgGap;\\n        int prev=-1;\\n        for(int i=0;i<bucketCount;i++){\\n            if(maxBucket[i]==-1){\\n                continue;\\n            }else if(prev!=-1){\\n                maxGap=Math.max(maxGap,minBucket[i]-prev);\\n            }\\n            prev=maxBucket[i];\\n        }\\n        return maxGap;\\n    }\\n}",
                "solutionTags": [],
                "code": "class Solution {\\n    public int maximumGap(int[] nums) {\\n        if(nums.length==1){\\n            return 0;\\n        }",
                "codeTag": "Java"
            },
            {
                "id": 2426405,
                "title": "java-solution-o-n-logn",
                "content": "if(nums.length <2) {\\n            return 0;\\n        }\\n        Arrays.sort(nums);\\n        int maxDifference = Integer.MIN_VALUE;\\n        for(int i=0; i<nums.length-1; i++) {\\n            int diff = nums[i+1]-nums[i];\\n            if(diff > maxDifference) {\\n                maxDifference = diff;\\n            }\\n        }\\n        return maxDifference;",
                "solutionTags": [],
                "code": "if(nums.length <2) {\\n            return 0;\\n        }\\n        Arrays.sort(nums);\\n        int maxDifference = Integer.MIN_VALUE;\\n        for(int i=0; i<nums.length-1; i++) {\\n            int diff = nums[i+1]-nums[i];\\n            if(diff > maxDifference) {\\n                maxDifference = diff;\\n            }\\n        }\\n        return maxDifference;",
                "codeTag": "Unknown"
            },
            {
                "id": 2421242,
                "title": "java-linear-solution-using-bucket-sort-beats-71",
                "content": "```\\nclass Solution {\\n    class pair{\\n        int f;\\n        int s;\\n        pair(int f , int s){\\n            this.f = f;\\n            this.s = s;\\n        }\\n    }\\n    int inf = Integer.MAX_VALUE;\\n    int nrk = Integer.MIN_VALUE;\\n    public int maximumGap(int a[]) {\\n        int n = a.length;\\n        if(n < 2) return 0;\\n        pair v[] = new pair[n - 1];\\n        for(int i = 0; i < n - 1; i++){\\n            v[i] = new pair(inf , nrk);\\n        }\\n        int mx = nrk;\\n        int mn = inf;\\n        for(int e : a){\\n            mx = Math.max(mx , e);\\n            mn = Math.min(mn , e);\\n        }\\n        double gap = (double)(mx - mn) / (double)(n - 1);\\n        for(int e : a){\\n            if(e == mn || e == mx) continue;\\n            int idx = (int)((double)(e - mn) / (double)gap);\\n            v[idx].f = Math.min(v[idx].f , e);\\n            v[idx].s = Math.max(v[idx].s , e);\\n        }\\n        int prev = mn;\\n        int max = 0;\\n        for(int i = 0; i < n - 1; i++){\\n            if(v[i].f == inf) continue;\\n            max = Math.max(max , v[i].f - prev);\\n            prev = v[i].s;\\n        }\\n        return Math.max(max , mx - prev);\\n    }\\n}",
                "solutionTags": [
                    "Java",
                    "Bucket Sort"
                ],
                "code": "class Solution {\\n    class pair{\\n        int f;\\n        int s;\\n        pair(int f , int s){\\n            this.f = f;\\n            this.s = s;\\n        }",
                "codeTag": "Java"
            },
            {
                "id": 2390211,
                "title": "python-o-n-bucket-sort-commented-with-explanation",
                "content": "**tl;dr**\\n\\nBLAH.... that is all\\n\\np.s. radix sorting is probably easier and more intuitive than this.\\n\\n**Solution**\\n```\\nclass Solution:\\n    def maximumGap(self, nums: List[int]) -> int:\\n        \"\"\"\\n        We use bucket sort to achieve O(n) runtime. However,\\n        instead of using values as bucket index, we use a \"gap\" index\\n        to fit a value into a range where its gaps **within the bucket** is\\n\\t\\tless than **gaps between buckets**.\\n        \\n        For example:\\n        \\n        [4, 3, 9, 1]\\n        \\n        min = 1\\n        max = 9\\n        total_gap = (9-1) = 8 (this is the gap across the entire array)\\n       \\n        If we do a normal bucket sort, our buckets would look like:\\n        \\n                    0  1  2  3  4  5  6  7\\n          buckets  [1][ ][3][4][ ][ ][ ][9]\\n       \\n        However, this is no longer linear space and the num can go up\\n        to 10**9. Instead, we will need to limit our buckets. Keep in mind\\n        we ONLY need to find the maximum GAP. So we only need to keep\\n        enough numbers sorted to help us determine that answer.\\n        \\n        Let\\'s summarize what we know:\\n        \\n        1. Our total gap is 8\\n        2. We have 4 elements, which means we have (4-1) gaps\\n        3. We can think of the above as:\\n        \\n           gap_0 + gap_1 + gap_2 = 8 (total_gap)\\n\\n        What if we make our gap index the bucket index instead?\\n           \\n        4. We know for sure that there will be at least two buckets\\n           populated with >= 1 element. Why? If everything is in one\\n           bucket, we would never get total_gap of 8. \\n        \\n        This leads us to an important realization:\\n        \\n        5. Our answer will always be the gap between two buckets,\\n           instead a gap inside elements of the same bucket. Gap between two\\n           buckets will always be >= gap within a single bucket.\\n\\n        6. So we just need to figure out which bucket a number would go into.\\n           Then within each bucket, we keep track of the min/max.\\n           Then lastly, we will iterate through all the buckets to identify\\n           the maximum gap (which we know will be between two buckets).\\n        \"\"\"\\n        n = len(nums)\\n        if n < 2:\\n            return 0\\n        \\n        # find the min and max in the array\\n        # this gives us the range that gaps will fall into\\n        min_num = min(nums)\\n        max_num = max(nums)\\n        total_gap = max_num - min_num\\n        if total_gap == 0:\\n            # no gap, all are equal\\n            return 0\\n        \\n        # if we have n elements, we have n - 1 gaps\\n        gap_count = n - 1\\n        \\n        # find the minimum bucket size needed.\\n        bucket_size = math.ceil(total_gap / gap_count)\\n        \\n        # keep track of min/max at each bucket\\n        bucket_min = [float(\"inf\")] * n\\n        bucket_max = [float(\"-inf\")] * n\\n        \\n        # assign our numbers to a bucket\\n        for num in nums:\\n            bucket_idx = (num - min_num) // bucket_size\\n            bucket_min[bucket_idx] = min(bucket_min[bucket_idx], num)\\n            bucket_max[bucket_idx] = max(bucket_max[bucket_idx], num)\\n        \\n        # iterate through each bucket\\n        # while keeping track of the max gap between buckets\\n        res = 0\\n        \\n        prev_bucket_max = bucket_max[0]\\n        for i in range(1, n):\\n            if bucket_min[i] == float(\"inf\"):\\n                # we didn\\'t put anything in this bucket, skip\\n                continue\\n            \\n            # see if gap between this bucket and previous bucket\\n            # is larger than result\\n            res = max(res, bucket_min[i] - prev_bucket_max)\\n            prev_bucket_max = bucket_max[i]\\n        \\n        return res\\n```",
                "solutionTags": [
                    "Python",
                    "Bucket Sort"
                ],
                "code": "```\\nclass Solution:\\n    def maximumGap(self, nums: List[int]) -> int:\\n        \"\"\"\\n        We use bucket sort to achieve O(n) runtime. However,\\n        instead of using values as bucket index, we use a \"gap\" index\\n        to fit a value into a range where its gaps **within the bucket** is\\n\\t\\tless than **gaps between buckets**.\\n        \\n        For example:\\n        \\n        [4, 3, 9, 1]\\n        \\n        min = 1\\n        max = 9\\n        total_gap = (9-1) = 8 (this is the gap across the entire array)\\n       \\n        If we do a normal bucket sort, our buckets would look like:\\n        \\n                    0  1  2  3  4  5  6  7\\n          buckets  [1][ ][3][4][ ][ ][ ][9]\\n       \\n        However, this is no longer linear space and the num can go up\\n        to 10**9. Instead, we will need to limit our buckets. Keep in mind\\n        we ONLY need to find the maximum GAP. So we only need to keep\\n        enough numbers sorted to help us determine that answer.\\n        \\n        Let\\'s summarize what we know:\\n        \\n        1. Our total gap is 8\\n        2. We have 4 elements, which means we have (4-1) gaps\\n        3. We can think of the above as:\\n        \\n           gap_0 + gap_1 + gap_2 = 8 (total_gap)\\n\\n        What if we make our gap index the bucket index instead?\\n           \\n        4. We know for sure that there will be at least two buckets\\n           populated with >= 1 element. Why? If everything is in one\\n           bucket, we would never get total_gap of 8. \\n        \\n        This leads us to an important realization:\\n        \\n        5. Our answer will always be the gap between two buckets,\\n           instead a gap inside elements of the same bucket. Gap between two\\n           buckets will always be >= gap within a single bucket.\\n\\n        6. So we just need to figure out which bucket a number would go into.\\n           Then within each bucket, we keep track of the min/max.\\n           Then lastly, we will iterate through all the buckets to identify\\n           the maximum gap (which we know will be between two buckets).\\n        \"\"\"\\n        n = len(nums)\\n        if n < 2:\\n            return 0\\n        \\n        # find the min and max in the array\\n        # this gives us the range that gaps will fall into\\n        min_num = min(nums)\\n        max_num = max(nums)\\n        total_gap = max_num - min_num\\n        if total_gap == 0:\\n            # no gap, all are equal\\n            return 0\\n        \\n        # if we have n elements, we have n - 1 gaps\\n        gap_count = n - 1\\n        \\n        # find the minimum bucket size needed.\\n        bucket_size = math.ceil(total_gap / gap_count)\\n        \\n        # keep track of min/max at each bucket\\n        bucket_min = [float(\"inf\")] * n\\n        bucket_max = [float(\"-inf\")] * n\\n        \\n        # assign our numbers to a bucket\\n        for num in nums:\\n            bucket_idx = (num - min_num) // bucket_size\\n            bucket_min[bucket_idx] = min(bucket_min[bucket_idx], num)\\n            bucket_max[bucket_idx] = max(bucket_max[bucket_idx], num)\\n        \\n        # iterate through each bucket\\n        # while keeping track of the max gap between buckets\\n        res = 0\\n        \\n        prev_bucket_max = bucket_max[0]\\n        for i in range(1, n):\\n            if bucket_min[i] == float(\"inf\"):\\n                # we didn\\'t put anything in this bucket, skip\\n                continue\\n            \\n            # see if gap between this bucket and previous bucket\\n            # is larger than result\\n            res = max(res, bucket_min[i] - prev_bucket_max)\\n            prev_bucket_max = bucket_max[i]\\n        \\n        return res\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2374852,
                "title": "c-easiest-and-simplest-solution-no-concepts-required",
                "content": "class Solution {\\npublic:\\n    int maximumGap(vector<int>& nums) {\\n       \\n\\t    int n=nums.size();\\n        sort(nums.begin(), nums.end());\\n        \\n        if(n==1)\\n            return 0;\\n\\t\\t\\t\\n        int diff = nums[1]- nums[0];\\n        for(int i=1; i<n; i++){\\n            if(nums[i]-nums[i-1] > diff)\\n                diff = nums[i]-nums[i-1];\\n        }\\n        return diff;\\n    }\\n};",
                "solutionTags": [
                    "C"
                ],
                "code": "class Solution {\\npublic:\\n    int maximumGap(vector<int>& nums) {\\n       \\n\\t    int n=nums.size();\\n        sort(nums.begin(), nums.end());\\n        \\n        if(n==1)\\n            return 0;\\n\\t\\t\\t\\n        int diff = nums[1]- nums[0];\\n        for(int i=1; i<n; i++){\\n            if(nums[i]-nums[i-1] > diff)\\n                diff = nums[i]-nums[i-1];\\n        }",
                "codeTag": "Java"
            },
            {
                "id": 2360155,
                "title": "treeset-solution-in-java",
                "content": "```\\npublic int maximumGap(int[] nums) {\\n\\n\\tTreeSet<Integer> st = Arrays.stream(nums)\\n\\t\\t\\t\\t\\t\\t\\t\\t.boxed()\\n\\t\\t\\t\\t\\t\\t\\t\\t.collect(Collectors.toCollection(TreeSet::new));\\n\\n\\tint maxGap = 0;\\n\\tint prev = -1;\\n\\n\\tfor (int num : st)  {                         \\n\\t\\tif (prev == -1) {\\n\\t\\t\\tprev = num;\\n\\t\\t\\tcontinue;\\n\\t\\t} else {\\n\\t\\t\\tmaxGap = Math.max(maxGap, num - prev);\\n\\t\\t\\tprev = num;\\n\\t\\t}\\n\\t}\\n\\n\\treturn maxGap;\\n}\\n```\\n\\nTC : O(N)\\nSC : O(N)",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\npublic int maximumGap(int[] nums) {\\n\\n\\tTreeSet<Integer> st = Arrays.stream(nums)\\n\\t\\t\\t\\t\\t\\t\\t\\t.boxed()\\n\\t\\t\\t\\t\\t\\t\\t\\t.collect(Collectors.toCollection(TreeSet::new));\\n\\n\\tint maxGap = 0;\\n\\tint prev = -1;\\n\\n\\tfor (int num : st)  {                         \\n\\t\\tif (prev == -1) {\\n\\t\\t\\tprev = num;\\n\\t\\t\\tcontinue;\\n\\t\\t} else {\\n\\t\\t\\tmaxGap = Math.max(maxGap, num - prev);\\n\\t\\t\\tprev = num;\\n\\t\\t}\\n\\t}\\n\\n\\treturn maxGap;\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2296354,
                "title": "python-solution",
                "content": "```\\nclass Solution:\\n    def maximumGap(self, nums: List[int]) -> int:\\n        if len(nums)<2:\\n            return 0\\n        if len(nums)==2:\\n            return abs(nums[0]-nums[1])\\n        nums.sort()\\n        md=abs(nums[0]-nums[1])\\n        for i in range(1,len(nums)):\\n            if md<(abs(nums[i]-nums[i-1])):\\n                md=abs(nums[i]-nums[i-1])\\n        return md\\n```\\nI\\'ve tried solving it by taking a \"md\" max difference variable and initialising it to the first two elements difference and then checking all the other consecutive element\\'s difference \\nI think this is not the optimal way to do this but this worked \\n",
                "solutionTags": [],
                "code": "```\\nclass Solution:\\n    def maximumGap(self, nums: List[int]) -> int:\\n        if len(nums)<2:\\n            return 0\\n        if len(nums)==2:\\n            return abs(nums[0]-nums[1])\\n        nums.sort()\\n        md=abs(nums[0]-nums[1])\\n        for i in range(1,len(nums)):\\n            if md<(abs(nums[i]-nums[i-1])):\\n                md=abs(nums[i]-nums[i-1])\\n        return md\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2284722,
                "title": "easy-o-n-95-faster-java-bucket-sort",
                "content": "Hope It will help you.\\n...\\n\\n\\tclass Solution {\\n\\t\\tpublic int maximumGap(int[] nums) {\\n\\t\\t   int n = nums.length;\\n\\n\\t\\t   if(n < 2)\\n\\t\\t\\t\\treturn 0;\\n\\n\\t\\t\\tint min = Integer.MAX_VALUE;\\n\\t\\t\\tint max = -1;\\n\\n\\t\\t\\tfor(int num : nums){\\n\\t\\t\\t\\tmin = Math.min(min, num);\\n\\t\\t\\t\\tmax = Math.max(max, num);\\n\\t\\t\\t}\\n\\n\\t\\t\\t//average interval/gap -> total gap / no of gaps\\n\\t\\t\\t//no of gaps = n - 1\\n\\t\\t\\tint interval = (int)(Math.ceil((max - min + 0.0) / (n - 1)));\\n\\t\\t\\tif(interval == 0)//all are equal\\n\\t\\t\\t\\treturn 0;\\n\\n\\t\\t\\t//there is atleast one gap of >= interval to make total gap\\n\\t\\t\\t//eg. if total = 7, no of gap = 3, then at least one gap is >= 3\\n\\t\\t\\t//bcz if we take 3 gaps of 2 -> then it can not make 7\\n\\n\\t\\t\\t//maxGap >= interval\\n\\t\\t\\t//try to sort the array by bucket sort\\n\\t\\t\\t//bucket contains elemnts whose gap is less than interval -> the gap b/w elemnts in a single bucket not gives max Gap\\n\\n\\t\\t\\tint[] bucketMin = new int[n];\\n\\t\\t\\tint[] bucketMax = new int[n];\\n\\t\\t\\t//is no of gaps of size interval\\n\\t\\t\\t//[i] - bcket can have min + i * interval to min + (i + 1) * interval - 1\\n\\n\\t\\t\\tArrays.fill(bucketMin, Integer.MAX_VALUE);\\n\\t\\t\\tArrays.fill(bucketMax, Integer.MIN_VALUE);\\n\\t\\t\\t//we only neeed to store min and max of bucket -> bcz distance between successive elemnts between 2 buckets can give gap >= interval\\n\\n\\t\\t\\t//fill bucket\\n\\t\\t\\tfor(int num : nums){\\n\\t\\t\\t\\tint index = (num - min) / interval;\\n\\n\\t\\t\\t\\tbucketMin[index] = Math.min(bucketMin[index], num);\\n\\t\\t\\t\\tbucketMax[index] = Math.max(bucketMax[index], num);\\n\\t\\t\\t}\\n\\n\\t\\t\\t//check b/w successive points\\n\\t\\t\\tint prev = min;\\n\\t\\t\\tint maxGap = 0;\\n\\n\\t\\t\\tfor(int i = 0; i < n; i++){\\n\\t\\t\\t\\tif(bucketMin[i] == Integer.MAX_VALUE)//no element in this bucket\\n\\t\\t\\t\\t\\tcontinue;\\n\\n\\t\\t\\t\\tint gap = bucketMin[i] - prev;\\n\\t\\t\\t\\tmaxGap = Math.max(maxGap, gap);\\n\\n\\t\\t\\t\\tprev = bucketMax[i];//prev for next min\\n\\t\\t\\t}\\n\\n\\t\\t\\treturn maxGap;\\n\\t\\t}\\n\\t}\\n\\n...",
                "solutionTags": [
                    "Java",
                    "Array",
                    "Bucket Sort"
                ],
                "code": "class Solution {\\n\\t\\tpublic int maximumGap(int[] nums) {\\n\\t\\t   int n = nums.length;\\n\\n\\t\\t   if(n < 2)\\n\\t\\t\\t\\treturn 0;\\n\\n\\t\\t\\tint min = Integer.MAX_VALUE;\\n\\t\\t\\tint max = -1;\\n\\n\\t\\t\\tfor(int num : nums){\\n\\t\\t\\t\\tmin = Math.min(min, num);\\n\\t\\t\\t\\tmax = Math.max(max, num);\\n\\t\\t\\t}",
                "codeTag": "Java"
            },
            {
                "id": 2281883,
                "title": "using-set-unique-solution",
                "content": "```\\n   int maximumGap(vector<int>& v) {\\n        if(v.size() < 2) return 0;\\n        set<int> s; int ans = INT_MIN; int dif = 0;\\n        int t = 0;\\n        copy(v.begin(),v.end(),inserter(s, s.end()));\\n        set<int>::iterator it = s.begin();\\n        int prev = (*it);\\n        while(it != s.end()){\\n            t = (*it);\\n            dif = t - prev;\\n            ans = max(ans,dif);\\n            prev = t;\\n            it++;\\n        }\\n        return ans;\\n    }",
                "solutionTags": [
                    "C"
                ],
                "code": "```\\n   int maximumGap(vector<int>& v) {\\n        if(v.size() < 2) return 0;\\n        set<int> s; int ans = INT_MIN; int dif = 0;\\n        int t = 0;\\n        copy(v.begin(),v.end(),inserter(s, s.end()));\\n        set<int>::iterator it = s.begin();\\n        int prev = (*it);\\n        while(it != s.end()){\\n            t = (*it);\\n            dif = t - prev;\\n            ans = max(ans,dif);\\n            prev = t;\\n            it++;\\n        }\\n        return ans;\\n    }",
                "codeTag": "Unknown"
            },
            {
                "id": 2253358,
                "title": "python-bucket-sort-solution",
                "content": "```\\ndef maximumGap(self, nums: List[int]) -> int:\\n\\tmn, mx, n = min(nums), max(nums), len(nums)\\n\\tif len(nums)<2 or mx==mn:\\n\\t\\treturn 0\\n\\tstep = math.ceil((mx-mn)/(n-1))\\n\\tbuckets = [[] for _ in range((mx-mn)//step+1)]\\n\\tfor n in nums:\\n\\t\\tidx = (n-mn)//step\\n\\t\\tif not buckets[idx]:\\n\\t\\t\\tbuckets[idx] = [n, n]\\n\\t\\telse:\\n\\t\\t\\ta, b = buckets[idx]\\n\\t\\t\\tbuckets[idx] = [min(a, n), max(b, n)]\\n\\tbuckets = [b for b in buckets if b]\\n\\treturn max(buckets[i+1][0]-buckets[i][1] for i in range(len(buckets)-1))\\n```",
                "solutionTags": [],
                "code": "```\\ndef maximumGap(self, nums: List[int]) -> int:\\n\\tmn, mx, n = min(nums), max(nums), len(nums)\\n\\tif len(nums)<2 or mx==mn:\\n\\t\\treturn 0\\n\\tstep = math.ceil((mx-mn)/(n-1))\\n\\tbuckets = [[] for _ in range((mx-mn)//step+1)]\\n\\tfor n in nums:\\n\\t\\tidx = (n-mn)//step\\n\\t\\tif not buckets[idx]:\\n\\t\\t\\tbuckets[idx] = [n, n]\\n\\t\\telse:\\n\\t\\t\\ta, b = buckets[idx]\\n\\t\\t\\tbuckets[idx] = [min(a, n), max(b, n)]\\n\\tbuckets = [b for b in buckets if b]\\n\\treturn max(buckets[i+1][0]-buckets[i][1] for i in range(len(buckets)-1))\\n```",
                "codeTag": "Python3"
            },
            {
                "id": 2246694,
                "title": "code-working-in-local-but-not-in-leetcode-ide",
                "content": "Here is my code which seems to work fine in my local for the same test cases for which leetcode IDE is giving Wrong Answer. \\nAlso the same input is giving correct output when executed manually in Testcase window (problem link : https://leetcode.com/problems/maximum-gap/) FYI\\nAny suggestions will be appreciated,\\n```\\nclass Solution {\\n    \\n    static int prev = -1;\\n    static int MAX_BITS = 32;\\n    static int powersOf2 [] = new int[MAX_BITS];\\n    static int maxDiff = 0;\\n    \\n    public int maximumGap(int[] nums) {\\n        powersOf2[0] = 1;\\n        for(int i = 1; i < MAX_BITS; i++) {\\n            powersOf2[i] = 2*powersOf2[i - 1];\\n        }\\n\\n\\n        Node ROOT = new Node();\\n        for(int i = 0; i < nums.length ; i++) {\\n            addToTrieTree(ROOT, nums[i]);\\n        }\\n\\n        preOrder(ROOT, MAX_BITS - 1, 0);\\n        return maxDiff;\\n    }\\n    \\n      public void preOrder(Node node, int index, int num) {\\n\\n        if (index == -1) {\\n            if (prev != -1) {\\n                maxDiff = Math.max(maxDiff, num - prev);\\n            }\\n            prev = num;\\n        }\\n\\n        if(node.left != null) {\\n            preOrder(node.left, index - 1, num);\\n        }\\n\\n        if(node.right != null) {\\n            preOrder(node.right, index - 1, num + powersOf2[index]);\\n        }\\n\\n    }\\n\\n    public void addToTrieTree(Node root, int num) {\\n\\n        int binary[] = getBinary(num);\\n\\n        for(int i = 0; i < binary.length ; i++) {\\n\\n            if(binary[i] == 0) {\\n                if (root.left == null) {\\n                    root.left = new Node();\\n                }\\n                root = root.left;\\n\\n            } else {\\n                if (root.right == null) {\\n                    root.right = new Node();\\n\\n                }\\n                root = root.right;\\n            }\\n        }\\n    }\\n\\n    public int[] getBinary(int num) {\\n\\n        int binary[] = new int[MAX_BITS];\\n        int index = MAX_BITS - 1;\\n        while (num > 0)  {\\n            binary[index--] = num % 2;\\n            num /= 2;\\n        }\\n        return binary;\\n    }\\n}\\n\\nclass Node {\\n    Node left, right;\\n}\\n\\n```",
                "solutionTags": [
                    "Tree",
                    "Trie"
                ],
                "code": "```\\nclass Solution {\\n    \\n    static int prev = -1;\\n    static int MAX_BITS = 32;\\n    static int powersOf2 [] = new int[MAX_BITS];\\n    static int maxDiff = 0;\\n    \\n    public int maximumGap(int[] nums) {\\n        powersOf2[0] = 1;\\n        for(int i = 1; i < MAX_BITS; i++) {\\n            powersOf2[i] = 2*powersOf2[i - 1];\\n        }\\n\\n\\n        Node ROOT = new Node();\\n        for(int i = 0; i < nums.length ; i++) {\\n            addToTrieTree(ROOT, nums[i]);\\n        }\\n\\n        preOrder(ROOT, MAX_BITS - 1, 0);\\n        return maxDiff;\\n    }\\n    \\n      public void preOrder(Node node, int index, int num) {\\n\\n        if (index == -1) {\\n            if (prev != -1) {\\n                maxDiff = Math.max(maxDiff, num - prev);\\n            }\\n            prev = num;\\n        }\\n\\n        if(node.left != null) {\\n            preOrder(node.left, index - 1, num);\\n        }\\n\\n        if(node.right != null) {\\n            preOrder(node.right, index - 1, num + powersOf2[index]);\\n        }\\n\\n    }\\n\\n    public void addToTrieTree(Node root, int num) {\\n\\n        int binary[] = getBinary(num);\\n\\n        for(int i = 0; i < binary.length ; i++) {\\n\\n            if(binary[i] == 0) {\\n                if (root.left == null) {\\n                    root.left = new Node();\\n                }\\n                root = root.left;\\n\\n            } else {\\n                if (root.right == null) {\\n                    root.right = new Node();\\n\\n                }\\n                root = root.right;\\n            }\\n        }\\n    }\\n\\n    public int[] getBinary(int num) {\\n\\n        int binary[] = new int[MAX_BITS];\\n        int index = MAX_BITS - 1;\\n        while (num > 0)  {\\n            binary[index--] = num % 2;\\n            num /= 2;\\n        }\\n        return binary;\\n    }\\n}\\n\\nclass Node {\\n    Node left, right;\\n}\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2226760,
                "title": "faster-easy-to-understand-c-code",
                "content": "* ***Using Bucket***\\n\\n* ***Time Complexity :- O(N)***\\n\\n* ***Space Complexity :- O(N)***\\n\\n```\\nclass Solution {\\npublic:\\n    int maximumGap(vector<int>& nums) {\\n        \\n        int n = nums.size();\\n        \\n        if(n < 2)\\n            return 0;\\n        \\n        // find maximum and minimum element of the array\\n        \\n        int maxi = *max_element(nums.begin(), nums.end());\\n        \\n        int mini = *min_element(nums.begin(), nums.end());\\n        \\n        // find the gap\\n        \\n        int gap = ((maxi - mini) / (n - 1)) + 1;\\n        \\n        // min_bucket[i] store the min of that bucket\\n        \\n        vector<int> min_bucket(n - 1, INT_MAX);\\n        \\n        // max_bucket[i] store the max of that bucket\\n        \\n        vector<int> max_bucket(n - 1, INT_MIN);\\n        \\n        // fill the min_bucket and max_bucket\\n        \\n        for(int i = 0; i < n; i++)\\n        {\\n            if(nums[i] != mini && nums[i] != maxi)\\n            {\\n                // index of bucket\\n                \\n                int buk_idx = (nums[i] - mini) / gap;\\n                \\n                min_bucket[buk_idx] = min(min_bucket[buk_idx], nums[i]);\\n                \\n                max_bucket[buk_idx] = max(max_bucket[buk_idx], nums[i]);\\n            }\\n        }\\n        \\n        // now traverse over buckets and find max_gap\\n        \\n        int max_gap = INT_MIN;\\n        \\n        // prev store max of prev bucket\\n        \\n        int prev = mini;\\n        \\n        // find max gap\\n        \\n        for(int i = 0; i < n - 1; i++)\\n        {\\n            // if bucket is not empty\\n            \\n            if(min_bucket[i] != INT_MAX && max_bucket[i] != INT_MIN)\\n            {\\n                int curr_gap = min_bucket[i] - prev;\\n                \\n                max_gap = max(max_gap, curr_gap);\\n                \\n                prev = max(prev, max_bucket[i]);\\n            }\\n        }\\n        \\n        max_gap = max(max_gap, maxi - prev);\\n        \\n        return max_gap;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C",
                    "Bucket Sort"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int maximumGap(vector<int>& nums) {\\n        \\n        int n = nums.size();\\n        \\n        if(n < 2)\\n            return 0;\\n        \\n        // find maximum and minimum element of the array\\n        \\n        int maxi = *max_element(nums.begin(), nums.end());\\n        \\n        int mini = *min_element(nums.begin(), nums.end());\\n        \\n        // find the gap\\n        \\n        int gap = ((maxi - mini) / (n - 1)) + 1;\\n        \\n        // min_bucket[i] store the min of that bucket\\n        \\n        vector<int> min_bucket(n - 1, INT_MAX);\\n        \\n        // max_bucket[i] store the max of that bucket\\n        \\n        vector<int> max_bucket(n - 1, INT_MIN);\\n        \\n        // fill the min_bucket and max_bucket\\n        \\n        for(int i = 0; i < n; i++)\\n        {\\n            if(nums[i] != mini && nums[i] != maxi)\\n            {\\n                // index of bucket\\n                \\n                int buk_idx = (nums[i] - mini) / gap;\\n                \\n                min_bucket[buk_idx] = min(min_bucket[buk_idx], nums[i]);\\n                \\n                max_bucket[buk_idx] = max(max_bucket[buk_idx], nums[i]);\\n            }\\n        }\\n        \\n        // now traverse over buckets and find max_gap\\n        \\n        int max_gap = INT_MIN;\\n        \\n        // prev store max of prev bucket\\n        \\n        int prev = mini;\\n        \\n        // find max gap\\n        \\n        for(int i = 0; i < n - 1; i++)\\n        {\\n            // if bucket is not empty\\n            \\n            if(min_bucket[i] != INT_MAX && max_bucket[i] != INT_MIN)\\n            {\\n                int curr_gap = min_bucket[i] - prev;\\n                \\n                max_gap = max(max_gap, curr_gap);\\n                \\n                prev = max(prev, max_bucket[i]);\\n            }\\n        }\\n        \\n        max_gap = max(max_gap, maxi - prev);\\n        \\n        return max_gap;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2196625,
                "title": "radix-sort-javascript",
                "content": "```\\n/**\\n * @param {number[]} nums\\n * @return {number}\\n */\\n\\n//check \"https://visualgo.net/en/sorting\" for radix sort\\'s logic\\n\\nconst radixSort = (nums) => {\\n    var bucket = Array(10).fill().map(subArr => subArr = Array());\\n    var max = Math.max(...nums);//find max digit\\n    \\n    var digit = String(max).length;\\n    for(var i = digit; i != -1; i--) {\\n        nums.forEach(num => {\\n            var temp = \\'\\';\\n            var size = String(num).length;// check if number lenght is less than digit\\n            if(size <= digit) {\\n                temp = \\'0\\'.repeat(digit-size+1) + String(num); //if numbers digit count is less than digit to avoid out of index err adding 0 to first\\n            } else {                                          // like 00041\\n                temp = String(num); // if not just parse to string\\n            }\\n            bucket[parseInt(temp.charAt(i))].push(num); // parseInt(temp.charAt(i)) // Checking i\\'th digit of number\\n        })                                              // parsing string then checking is more easy than checking on numbers\\n        nums = [] //reseting nums\\n        for(var arr of bucket) {\\n            if(arr.length != 0) nums.push(...arr) //inserting sorted numbers to nums\\n        }\\n        bucket = Array(10).fill().map(subArr => subArr = Array(0)); //reseting bucket\\n    }\\n    return nums; //it doesnt affect nums in parameter so we are returning other one\\n}\\n\\nconst maximumGap = (nums) => {\\n    var array = radixSort(nums)\\n    //here radix sort is completed and array is sorted nums\\n    //console.log(array) //controls\\n    var maxDiff = 0\\n    for(var i = 1;i<array.length;i++) { //find maxDiff\\n        maxDiff = Math.max(maxDiff,array[i] - array[i-1]);\\n    }\\n    //console.log(maxDiff) //controls\\n    return maxDiff;\\n};\\n```",
                "solutionTags": [
                    "JavaScript",
                    "Sorting",
                    "Bucket Sort"
                ],
                "code": "```\\n/**\\n * @param {number[]} nums\\n * @return {number}\\n */\\n\\n//check \"https://visualgo.net/en/sorting\" for radix sort\\'s logic\\n\\nconst radixSort = (nums) => {\\n    var bucket = Array(10).fill().map(subArr => subArr = Array());\\n    var max = Math.max(...nums);//find max digit\\n    \\n    var digit = String(max).length;\\n    for(var i = digit; i != -1; i--) {\\n        nums.forEach(num => {\\n            var temp = \\'\\';\\n            var size = String(num).length;// check if number lenght is less than digit\\n            if(size <= digit) {\\n                temp = \\'0\\'.repeat(digit-size+1) + String(num); //if numbers digit count is less than digit to avoid out of index err adding 0 to first\\n            } else {                                          // like 00041\\n                temp = String(num); // if not just parse to string\\n            }\\n            bucket[parseInt(temp.charAt(i))].push(num); // parseInt(temp.charAt(i)) // Checking i\\'th digit of number\\n        })                                              // parsing string then checking is more easy than checking on numbers\\n        nums = [] //reseting nums\\n        for(var arr of bucket) {\\n            if(arr.length != 0) nums.push(...arr) //inserting sorted numbers to nums\\n        }\\n        bucket = Array(10).fill().map(subArr => subArr = Array(0)); //reseting bucket\\n    }\\n    return nums; //it doesnt affect nums in parameter so we are returning other one\\n}\\n\\nconst maximumGap = (nums) => {\\n    var array = radixSort(nums)\\n    //here radix sort is completed and array is sorted nums\\n    //console.log(array) //controls\\n    var maxDiff = 0\\n    for(var i = 1;i<array.length;i++) { //find maxDiff\\n        maxDiff = Math.max(maxDiff,array[i] - array[i-1]);\\n    }\\n    //console.log(maxDiff) //controls\\n    return maxDiff;\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2179653,
                "title": "c-radix-sort-clean-code",
                "content": "```\\nclass Solution {\\npublic:\\n    void countSort(vector<int> &nums, const int exp){\\n        int N = nums.size();\\n        int output[N];\\n        int count[10] = {};\\n        \\n\\t\\t//For exp = 100, num = 19403, num/exp = 194, (num/exp)%10 = 4\\n        for(const int &num : nums){\\n            int idx = (num/exp)%10;\\n            count[idx]++;\\n        }\\n        \\n\\t\\t // Change count[i] so that count[i] now contains actual\\n\\t\\t//  position of this digit in output[]\\n        for(int i = 1; i < 10; i++){\\n            count[i] += count[i-1];\\n        }\\n        \\n        for(int i = N-1; i >= 0; i--){\\n            int idx = (nums[i]/exp)%10;\\n            int outputIdx = --count[idx];\\n            output[outputIdx] = nums[i];\\n        }\\n        \\n        for(int i = 0; i < N; i++){\\n            nums[i] = output[i];\\n        }\\n        return;\\n    }\\n    void radixSort(vector<int> &nums){\\n        int maxi = *max_element(begin(nums), end(nums));\\n        //For maxi = 19403, exp = 1, 10, 100, 1000, 10000\\n\\t\\t// Do counting sort for every digit. Note that instead of passing digit number, exp is passed. exp is 10^i\\n        // where i is current digit number\\n        for(int exp = 1; maxi/exp > 0; exp *= 10){\\n            countSort(nums, exp);\\n        }\\n    }\\n    int maximumGap(vector<int>& nums) {\\n        radixSort(nums);\\n        int res = 0;\\n        int N = nums.size();\\n        for(int i = 1; i < N; i++){\\n            res = max(res, nums[i] - nums[i-1]);\\n        }\\n        return res;\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    void countSort(vector<int> &nums, const int exp){\\n        int N = nums.size();\\n        int output[N];\\n        int count[10] = {};\\n        \\n\\t\\t//For exp = 100, num = 19403, num/exp = 194, (num/exp)%10 = 4\\n        for(const int &num : nums){\\n            int idx = (num/exp)%10;\\n            count[idx]++;\\n        }\\n        \\n\\t\\t // Change count[i] so that count[i] now contains actual\\n\\t\\t//  position of this digit in output[]\\n        for(int i = 1; i < 10; i++){\\n            count[i] += count[i-1];\\n        }\\n        \\n        for(int i = N-1; i >= 0; i--){\\n            int idx = (nums[i]/exp)%10;\\n            int outputIdx = --count[idx];\\n            output[outputIdx] = nums[i];\\n        }\\n        \\n        for(int i = 0; i < N; i++){\\n            nums[i] = output[i];\\n        }\\n        return;\\n    }\\n    void radixSort(vector<int> &nums){\\n        int maxi = *max_element(begin(nums), end(nums));\\n        //For maxi = 19403, exp = 1, 10, 100, 1000, 10000\\n\\t\\t// Do counting sort for every digit. Note that instead of passing digit number, exp is passed. exp is 10^i\\n        // where i is current digit number\\n        for(int exp = 1; maxi/exp > 0; exp *= 10){\\n            countSort(nums, exp);\\n        }\\n    }\\n    int maximumGap(vector<int>& nums) {\\n        radixSort(nums);\\n        int res = 0;\\n        int N = nums.size();\\n        for(int i = 1; i < N; i++){\\n            res = max(res, nums[i] - nums[i-1]);\\n        }\\n        return res;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2131103,
                "title": "c-solution",
                "content": "```\\nclass Solution {\\npublic:\\n    int maximumGap(vector<int>& nums) {\\n        int n=nums.size();\\n        int ans=INT_MIN;\\n        sort(nums.begin(),nums.end());\\n        for(int i=0;i<n-1;i++)\\n        {\\n            ans=max(ans,nums[i+1]-nums[i]);\\n        }\\n        if(n>1)\\n            return ans;\\n        else\\n            return 0;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int maximumGap(vector<int>& nums) {\\n        int n=nums.size();\\n        int ans=INT_MIN;\\n        sort(nums.begin(),nums.end());\\n        for(int i=0;i<n-1;i++)\\n        {\\n            ans=max(ans,nums[i+1]-nums[i]);\\n        }\\n        if(n>1)\\n            return ans;\\n        else\\n            return 0;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2073308,
                "title": "c-time-space-o-n-96-fast-explanation",
                "content": "```\\n// The assamtion is that the larger gap will be >= (max-min)/n.\\n// By deviding the range for block smaller than (max-min)/n we make sure that the 2 related numbers not in the same block;\\nclass Solution {\\npublic:\\n    int maximumGap(vector<int>& nums) {\\n        int n = nums.size();\\n        if (n<2) return 0;\\n        int min_ = INT_MAX;\\n        int max_ = INT_MIN;\\n        for(auto& num : nums)\\n        {\\n            max_ = max(max_,num);\\n            min_ = min(min_,num);\\n        }\\n        \\n        if (min_ == max_) return 0;\\n        int block_size = (max_ - min_)/(n-1);\\n        if (block_size == 0) block_size = 1;\\n        int m = (max_ - min_)/block_size+1;\\n        vector<pair<int,int>> blocks(m,{INT_MAX,INT_MIN});\\n        \\n        for(auto num: nums)\\n        {\\n            int ix;\\n            if (num == min_) ix = 0;\\n            else\\n                ix = (num - min_)/block_size;\\n\\n            blocks[ix].first = min(blocks[ix].first,num);\\n            blocks[ix].second = max(blocks[ix].second,num);\\n        }\\n        \\n        int ans = 0;\\n        int p = min_;\\n        for(auto& block : blocks)        \\n        {\\n            if (block.first == INT_MAX) continue;\\n            ans = max(ans,block.first-p);\\n            p = block.second;\\n        }\\n        \\n        return ans;\\n    }\\n};\\n\\n```",
                "solutionTags": [],
                "code": "```\\n// The assamtion is that the larger gap will be >= (max-min)/n.\\n// By deviding the range for block smaller than (max-min)/n we make sure that the 2 related numbers not in the same block;\\nclass Solution {\\npublic:\\n    int maximumGap(vector<int>& nums) {\\n        int n = nums.size();\\n        if (n<2) return 0;\\n        int min_ = INT_MAX;\\n        int max_ = INT_MIN;\\n        for(auto& num : nums)\\n        {\\n            max_ = max(max_,num);\\n            min_ = min(min_,num);\\n        }\\n        \\n        if (min_ == max_) return 0;\\n        int block_size = (max_ - min_)/(n-1);\\n        if (block_size == 0) block_size = 1;\\n        int m = (max_ - min_)/block_size+1;\\n        vector<pair<int,int>> blocks(m,{INT_MAX,INT_MIN});\\n        \\n        for(auto num: nums)\\n        {\\n            int ix;\\n            if (num == min_) ix = 0;\\n            else\\n                ix = (num - min_)/block_size;\\n\\n            blocks[ix].first = min(blocks[ix].first,num);\\n            blocks[ix].second = max(blocks[ix].second,num);\\n        }\\n        \\n        int ans = 0;\\n        int p = min_;\\n        for(auto& block : blocks)        \\n        {\\n            if (block.first == INT_MAX) continue;\\n            ans = max(ans,block.first-p);\\n            p = block.second;\\n        }\\n        \\n        return ans;\\n    }\\n};\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2066629,
                "title": "here-is-the-post-to-understand-completely",
                "content": "For finding maximum gap we are making bucket for putting middle n-2 elements and bucket size will be n-1 means (smallest and largest elements are to be avoided) means there will be one bucket that will be empty so that previous max and next mix elements of bucket will give the max difference. For doing so we make the bucket of size n-1 for both storing max and min element in the bucket and bucket will contain and bucket will store (max-min)/n-1 range of elements . Now we start putting elements in bucket so for checking in which index we have to put that element we find (x-min)/avg and avg is (max-min)/n-1 so we get the index and we fill max and min buckets with this elements . Now we simply take difference between max of one bucket and min of next bucket.\\n\\n```\\nclass Solution {\\n    public int maximumGap(int[] arr) {\\n        int n=arr.length;\\n        if(n<2)return 0;\\n        int max=arr[0],min=arr[0];\\n        for(int x:arr){\\n            max=Math.max(max,x);\\n            min=Math.min(min,x);\\n        }\\n        int avg=(int)Math.ceil((max-min+0.0)/(n-1));\\n        \\n        int []maxB=new int[n-1];\\n        int []minB=new int[n-1];\\n        \\n        Arrays.fill(maxB,-1);\\n        Arrays.fill(minB,Integer.MAX_VALUE);\\n        \\n        for(int x:arr){\\n            if(x==max||x==min){\\n                continue;\\n            }\\n            \\n            int index=(x-min)/avg;\\n            maxB[index]=Math.max(maxB[index],x);\\n            minB[index]=Math.min(minB[index],x);\\n        }\\n        \\n        int prev=min;\\n        int ans=0;\\n        \\n        for(int i=0;i<maxB.length;i++){\\n            if(maxB[i]==-1)continue;\\n            ans=Math.max(ans,minB[i]-prev);\\n            prev=maxB[i];\\n        }\\n        ans=Math.max(ans,max-prev);\\n        return ans;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Bucket Sort"
                ],
                "code": "```\\nclass Solution {\\n    public int maximumGap(int[] arr) {\\n        int n=arr.length;\\n        if(n<2)return 0;\\n        int max=arr[0],min=arr[0];\\n        for(int x:arr){\\n            max=Math.max(max,x);\\n            min=Math.min(min,x);\\n        }\\n        int avg=(int)Math.ceil((max-min+0.0)/(n-1));\\n        \\n        int []maxB=new int[n-1];\\n        int []minB=new int[n-1];\\n        \\n        Arrays.fill(maxB,-1);\\n        Arrays.fill(minB,Integer.MAX_VALUE);\\n        \\n        for(int x:arr){\\n            if(x==max||x==min){\\n                continue;\\n            }\\n            \\n            int index=(x-min)/avg;\\n            maxB[index]=Math.max(maxB[index],x);\\n            minB[index]=Math.min(minB[index],x);\\n        }\\n        \\n        int prev=min;\\n        int ans=0;\\n        \\n        for(int i=0;i<maxB.length;i++){\\n            if(maxB[i]==-1)continue;\\n            ans=Math.max(ans,minB[i]-prev);\\n            prev=maxB[i];\\n        }\\n        ans=Math.max(ans,max-prev);\\n        return ans;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2050642,
                "title": "python3",
                "content": "```\\nclass Solution:\\n    def maximumGap(self, nums: List[int]) -> int:\\n        c=[]\\n        a=sorted(nums)\\n        if len(a)<2:\\n            c.append(0)\\n        else:\\n            for i in range(len(a)-1):\\n                c.append(a[i+1]-a[i])\\n        return(max(c))\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution:\\n    def maximumGap(self, nums: List[int]) -> int:\\n        c=[]\\n        a=sorted(nums)\\n        if len(a)<2:\\n            c.append(0)\\n        else:\\n            for i in range(len(a)-1):\\n                c.append(a[i+1]-a[i])\\n        return(max(c))\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1974534,
                "title": "one-simple-solution",
                "content": "Wasn\\'t that hard. Easy solution\\n\\n```\\nclass Solution {\\n    public int maximumGap(int[] nums) {\\n        if(nums.length<2) return 0;\\n        Arrays.sort(nums);\\n        int ans = Integer.MIN_VALUE;\\n        for(int i=0;i+1<nums.length;i++) ans = Math.max(ans,nums[i+1]-nums[i]);\\n        return ans;\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    public int maximumGap(int[] nums) {\\n        if(nums.length<2) return 0;\\n        Arrays.sort(nums);\\n        int ans = Integer.MIN_VALUE;\\n        for(int i=0;i+1<nums.length;i++) ans = Math.max(ans,nums[i+1]-nums[i]);\\n        return ans;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1967826,
                "title": "python-3-bucket-sort",
                "content": "```\\nclass Solution:\\n    def maximumGap(self, nums: List[int]) -> int:\\n        if len(nums) < 2:\\n            return 0\\n        \\n        maxNum = max(nums)\\n        digit = 1\\n        base = 16\\n        \\n        while maxNum >= digit:\\n            buckets = [[] for _ in range(base)]\\n            for num in nums:\\n                buckets[num // digit % base].append(num)\\n            \\n            nums = []\\n            for bucket in buckets:\\n                nums.extend(bucket)\\n            digit *= base\\n        \\n        return max(nums[i] - nums[i - 1] for i in range(1, len(nums)))",
                "solutionTags": [
                    "Python",
                    "Python3",
                    "Sorting",
                    "Bucket Sort"
                ],
                "code": "```\\nclass Solution:\\n    def maximumGap(self, nums: List[int]) -> int:\\n        if len(nums) < 2:\\n            return 0\\n        \\n        maxNum = max(nums)\\n        digit = 1\\n        base = 16\\n        \\n        while maxNum >= digit:\\n            buckets = [[] for _ in range(base)]\\n            for num in nums:\\n                buckets[num // digit % base].append(num)\\n            \\n            nums = []\\n            for bucket in buckets:\\n                nums.extend(bucket)\\n            digit *= base\\n        \\n        return max(nums[i] - nums[i - 1] for i in range(1, len(nums)))",
                "codeTag": "Java"
            },
            {
                "id": 1945386,
                "title": "100-fastest-swift-solution",
                "content": "```\\nclass Solution {\\n    func maximumGap(_ nums: [Int]) -> Int {\\n        let count = nums.count\\n        guard count >= 2 else { return 0 }\\n        \\n        var minNum = nums[0], maxNum = nums[0]\\n        for n in nums {\\n            minNum = min(minNum, n)\\n            maxNum = max(maxNum, n)\\n        }\\n        \\n        let stride = max(1, (maxNum - minNum) / (count - 1))\\n        var buckets = Array(repeating: [-1, -1], count: (maxNum - minNum) / stride + 1)\\n        \\n        for n in nums {\\n            let i = (n - minNum) / stride\\n            if buckets[i][0] == -1 {\\n                buckets[i][0] = n\\n                buckets[i][1] = n\\n            } else {\\n                buckets[i][0] = min(buckets[i][0], n)\\n                buckets[i][1] = max(buckets[i][1], n)\\n            }\\n        }\\n        \\n        var gap = 0, prev = -1\\n        for i in 0..<buckets.count {\\n            if buckets[i][0] == -1 { continue }\\n            if prev != -1 {\\n                gap = max(gap, buckets[i][0] - buckets[prev][1])\\n            }\\n            prev = i\\n        }\\n        \\n        return gap\\n    }\\n    \\n}\\n```\\n\\nLet me know in comments if you have any doubts. I will be happy to answer.\\n\\nPlease upvote if you found the solution useful.",
                "solutionTags": [
                    "Swift"
                ],
                "code": "```\\nclass Solution {\\n    func maximumGap(_ nums: [Int]) -> Int {\\n        let count = nums.count\\n        guard count >= 2 else { return 0 }\\n        \\n        var minNum = nums[0], maxNum = nums[0]\\n        for n in nums {\\n            minNum = min(minNum, n)\\n            maxNum = max(maxNum, n)\\n        }\\n        \\n        let stride = max(1, (maxNum - minNum) / (count - 1))\\n        var buckets = Array(repeating: [-1, -1], count: (maxNum - minNum) / stride + 1)\\n        \\n        for n in nums {\\n            let i = (n - minNum) / stride\\n            if buckets[i][0] == -1 {\\n                buckets[i][0] = n\\n                buckets[i][1] = n\\n            } else {\\n                buckets[i][0] = min(buckets[i][0], n)\\n                buckets[i][1] = max(buckets[i][1], n)\\n            }\\n        }\\n        \\n        var gap = 0, prev = -1\\n        for i in 0..<buckets.count {\\n            if buckets[i][0] == -1 { continue }\\n            if prev != -1 {\\n                gap = max(gap, buckets[i][0] - buckets[prev][1])\\n            }\\n            prev = i\\n        }\\n        \\n        return gap\\n    }\\n    \\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1932265,
                "title": "python-sort-by-steps-o-n-solution",
                "content": "Though we can\\'t sort the list exactly, we can sort it with lower resolution. That is, we can sort it with a step of (max - min) / (n - 1) instead of 1. Yes, in this way multiple numbers can appear in one step, but the good thing is we don\\'t have to know the details within each step, we only need to know the max and min of each step. And the answer must appear as one of the min_of_next_step - max_of_prev_step. Why? Because the answer won\\'t be the diff of numbers in the same step, since the smallest possible Maximum Gap is the step length.\\n```\\nclass Solution:\\n    def maximumGap(self, nums: List[int]) -> int:\\n        if len(nums) < 2:\\n            return 0\\n        n = len(nums)\\n        min_all = min(nums)\\n        max_all = max(nums)\\n        if min_all == max_all:\\n            return 0\\n        #step is average distance between each number,\\n        #which is the smallest possible Maximum Gap.\\n        #though we can\\'t sort the list exactly, we can sort\\n        #it by how many steps it is above the lowest\\n        aveD = (max_all - min_all) / (n - 1)\\n        d_class = {}\\n        for num in nums:\\n            d_to_min = (num - min_all) // aveD\\n            if d_to_min not in d_class:\\n                d_class[d_to_min] = []\\n            d_class[d_to_min].append(num)\\n        #after sorting by steps, the answer must appear as one of the\\n        #distance between max of the previous step and the min of next step\\n        for d_to_min in d_class:\\n            d_class[d_to_min].append(min(d_class[d_to_min]))\\n            d_class[d_to_min].append(max(d_class[d_to_min]))\\n        ans = float(\\'-inf\\')\\n        start = 0\\n        for i in range(1, n):\\n            if i in d_class:\\n                end = i\\n                cur = d_class[end][-2] - d_class[start][-1]\\n                ans = max(ans, cur)\\n                start = i\\n        return ans",
                "solutionTags": [],
                "code": "class Solution:\\n    def maximumGap(self, nums: List[int]) -> int:\\n        if len(nums) < 2:\\n            return 0\\n        n = len(nums)\\n        min_all = min(nums)\\n        max_all = max(nums)\\n        if min_all == max_all:\\n            return 0\\n        #step is average distance between each number,\\n        #which is the smallest possible Maximum Gap.\\n        #though we can\\'t sort the list exactly, we can sort\\n        #it by how many steps it is above the lowest\\n        aveD = (max_all - min_all) / (n - 1)\\n        d_class = {}",
                "codeTag": "Java"
            },
            {
                "id": 1928701,
                "title": "java-easy-to-undersand-solution",
                "content": "```\\nclass Solution {\\n    public int maximumGap(int[] nums) {\\n        Arrays.sort(nums);\\n        int max = Integer.MIN_VALUE;\\n        if(nums.length==1) return 0;\\n        for(int i=0;i<nums.length-1;i++){\\n            max = Math.max(max,Math.abs(nums[i]-nums[i+1]));\\n        }\\n        return max;\\n        \\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Sorting"
                ],
                "code": "```\\nclass Solution {\\n    public int maximumGap(int[] nums) {\\n        Arrays.sort(nums);\\n        int max = Integer.MIN_VALUE;\\n        if(nums.length==1) return 0;\\n        for(int i=0;i<nums.length-1;i++){\\n            max = Math.max(max,Math.abs(nums[i]-nums[i+1]));\\n        }\\n        return max;\\n        \\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1911857,
                "title": "c-easiest-solution",
                "content": "class Solution {\\npublic:\\n    int maximumGap(vector<int>& nums) {\\n        int ans = INT_MIN;\\n        if(nums.size() < 2)\\n            return 0;\\n        sort(nums.begin(),nums.end());\\n        for (int i = 1; i < nums.size(); i++) {\\n            ans = max(ans,nums[i] - nums[i-1]);\\n        }\\n        return ans;\\n    }\\n};",
                "solutionTags": [],
                "code": "class Solution {\\npublic:\\n    int maximumGap(vector<int>& nums) {\\n        int ans = INT_MIN;\\n        if(nums.size() < 2)\\n            return 0;\\n        sort(nums.begin(),nums.end());\\n        for (int i = 1; i < nums.size(); i++) {\\n            ans = max(ans,nums[i] - nums[i-1]);\\n        }",
                "codeTag": "Java"
            },
            {
                "id": 1861970,
                "title": "c",
                "content": "```\\nclass Solution {\\npublic:\\n    int maximumGap(vector<int>& nums) {\\n    int result=0;\\n    sort(nums.begin(),nums.end());\\n    for(int i=1;i<nums.size();i++)\\n    {\\n        result=max(result,nums[i]-nums[i-1]);\\n    }\\n    return result;\\n}\\n        \\n};\\n```",
                "solutionTags": [
                    "C++",
                    "C"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int maximumGap(vector<int>& nums) {\\n    int result=0;\\n    sort(nums.begin(),nums.end());\\n    for(int i=1;i<nums.size();i++)\\n    {\\n        result=max(result,nums[i]-nums[i-1]);\\n    }\\n    return result;\\n}\\n        \\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1827209,
                "title": "maximum-gap-java",
                "content": "TC :- O(n)  and SC :- O(n)\\npublic int maximumGap(int[] a) {\\n        \\n\\t\\t// If the array contains less than 2 elements return 0.\\n        if(a.length < 2){\\n            return 0;\\n        }\\n        \\n        int max = Integer.MIN_VALUE;\\n        int min = Integer.MAX_VALUE;\\n        \\n        // Find max and min value!\\n        for(int arr : a){\\n            min = Math.min(min, arr);\\n            max = Math.max(max, arr);\\n        }\\n        \\n        int n = a.length;\\n        int num_of_bucket = n-1;\\n        \\n        // Bucket size \\n        int size_of_bucket = (int) Math.ceil( (double) (max - min)/num_of_bucket );\\n        \\n        // bucket contain 2 thing min and max value!\\n        int[] min_bucket_value = new int[n-1];\\n        int[] max_bucket_value = new int[n-1];\\n        \\n        Arrays.fill(min_bucket_value, Integer.MAX_VALUE);\\n        Arrays.fill(max_bucket_value, Integer.MIN_VALUE);\\n        \\n        // Now we fill the bucket min and max value in it\\n        // here we need to know that we do not consider max and min value into bucket!\\n        for(int i=0; i<n; i++){\\n        \\n            if(a[i] == min || a[i] == max){\\n                continue;\\n            }\\n            int bucket_index = (a[i] - min)/size_of_bucket;\\n            // here we seperate the min and max value in bucket in min bucket and max bucket.\\n            min_bucket_value[bucket_index] = Math.min( min_bucket_value[bucket_index] , a[i] );\\n            max_bucket_value[bucket_index] = Math.max( max_bucket_value[bucket_index] , a[i] );\\n        }\\n        \\n        // now for finding max gap in bucket we use max(min of B bucket - max of A bucket)!\\n        int max_gap = 0;\\n        \\n        // reason is we start for index 0 and it may be possible that its min and max value be same or equal or only one value present thats why we use min here.\\n        int max_of_prev_bucket = min;\\n        \\n        for(int i=0; i<a.length-1; i++){\\n            // bucket not contain any value skip it\\n            if(max_bucket_value[i] == Integer.MIN_VALUE){\\n                continue;\\n            }\\n            max_gap = Math.max(max_gap, min_bucket_value[i] - max_of_prev_bucket);\\n            // update max_of_prev_bucket!\\n            max_of_prev_bucket = max_bucket_value[i];\\n        }\\n        \\n        // here we take care if we have only 2 element in bucket!\\n        max_gap = Math.max(max_gap , max - max_of_prev_bucket);\\n        \\n        \\n        return max_gap;\\n\\t\\t\\n   }",
                "solutionTags": [
                    "Java",
                    "Bucket Sort"
                ],
                "code": "TC :- O(n)  and SC :- O(n)\\npublic int maximumGap(int[] a) {\\n        \\n\\t\\t// If the array contains less than 2 elements return 0.\\n        if(a.length < 2){\\n            return 0;\\n        }\\n        \\n        int max = Integer.MIN_VALUE;\\n        int min = Integer.MAX_VALUE;\\n        \\n        // Find max and min value!\\n        for(int arr : a){\\n            min = Math.min(min, arr);\\n            max = Math.max(max, arr);\\n        }\\n        \\n        int n = a.length;\\n        int num_of_bucket = n-1;\\n        \\n        // Bucket size \\n        int size_of_bucket = (int) Math.ceil( (double) (max - min)/num_of_bucket );\\n        \\n        // bucket contain 2 thing min and max value!\\n        int[] min_bucket_value = new int[n-1];\\n        int[] max_bucket_value = new int[n-1];\\n        \\n        Arrays.fill(min_bucket_value, Integer.MAX_VALUE);\\n        Arrays.fill(max_bucket_value, Integer.MIN_VALUE);\\n        \\n        // Now we fill the bucket min and max value in it\\n        // here we need to know that we do not consider max and min value into bucket!\\n        for(int i=0; i<n; i++){\\n        \\n            if(a[i] == min || a[i] == max){\\n                continue;\\n            }\\n            int bucket_index = (a[i] - min)/size_of_bucket;\\n            // here we seperate the min and max value in bucket in min bucket and max bucket.\\n            min_bucket_value[bucket_index] = Math.min( min_bucket_value[bucket_index] , a[i] );\\n            max_bucket_value[bucket_index] = Math.max( max_bucket_value[bucket_index] , a[i] );\\n        }\\n        \\n        // now for finding max gap in bucket we use max(min of B bucket - max of A bucket)!\\n        int max_gap = 0;\\n        \\n        // reason is we start for index 0 and it may be possible that its min and max value be same or equal or only one value present thats why we use min here.\\n        int max_of_prev_bucket = min;\\n        \\n        for(int i=0; i<a.length-1; i++){\\n            // bucket not contain any value skip it\\n            if(max_bucket_value[i] == Integer.MIN_VALUE){\\n                continue;\\n            }\\n            max_gap = Math.max(max_gap, min_bucket_value[i] - max_of_prev_bucket);\\n            // update max_of_prev_bucket!\\n            max_of_prev_bucket = max_bucket_value[i];\\n        }\\n        \\n        // here we take care if we have only 2 element in bucket!\\n        max_gap = Math.max(max_gap , max - max_of_prev_bucket);\\n        \\n        \\n        return max_gap;\\n\\t\\t\\n   }",
                "codeTag": "Unknown"
            },
            {
                "id": 1827182,
                "title": "javascript-radix-sort",
                "content": "**Solution: Radix Sort**\\n\\nGet the max number from nums and count the number of digits it has.\\nLoop for maxDigits number of times:\\n  1. arrange each nums[i] into its bucket based on the current digit\\n  2. prefix sum/accumulate indices in count\\n  3. place each nums[i] to next based on the accumulated index in count\\n  4. reassign nums to next\\n----\\nd = digits <= 10, n = length of nums, b = base = 10\\nTime Complexity: O(d(n + b)) = O(n) 310ms\\nSpace Complexity: O(n) 67.2MB\\n```\\nvar maximumGap = function(nums) {\\n  let n = nums.length, max = Math.max(...nums), maxDigits = getDigits(max);\\n  let power = 1;\\n  \\n  for (let k = 0; k < maxDigits; k++) {\\n    let next = Array(n), count = Array(10).fill(0);\\n    for (let i = 0; i < n; i++) {\\n      let digit = Math.floor(nums[i] / power) % 10;\\n      count[digit]++; // counting sort based on current digit\\n    }\\n    for (let i = 1; i < 10; i++) count[i] += count[i - 1]; // prefix sum \\n    for (let i = n - 1; i >= 0; i--) {\\n      let digit = Math.floor(nums[i] / power) % 10;\\n      next[--count[digit]] = nums[i];\\n    }\\n    nums = next;\\n    power *= 10;\\n  }\\n  \\n  let ans = 0;\\n  for (let i = 1; i < n; i++) {\\n    ans = Math.max(ans, nums[i] - nums[i - 1]);\\n  }\\n  return ans;\\n};\\n\\nfunction getDigits(num) {\\n  let digits = 0;\\n  while (num > 0) {\\n    num = Math.floor(num / 10);\\n    digits++;\\n  }\\n  return digits;\\n}\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\nvar maximumGap = function(nums) {\\n  let n = nums.length, max = Math.max(...nums), maxDigits = getDigits(max);\\n  let power = 1;\\n  \\n  for (let k = 0; k < maxDigits; k++) {\\n    let next = Array(n), count = Array(10).fill(0);\\n    for (let i = 0; i < n; i++) {\\n      let digit = Math.floor(nums[i] / power) % 10;\\n      count[digit]++; // counting sort based on current digit\\n    }\\n    for (let i = 1; i < 10; i++) count[i] += count[i - 1]; // prefix sum \\n    for (let i = n - 1; i >= 0; i--) {\\n      let digit = Math.floor(nums[i] / power) % 10;\\n      next[--count[digit]] = nums[i];\\n    }\\n    nums = next;\\n    power *= 10;\\n  }\\n  \\n  let ans = 0;\\n  for (let i = 1; i < n; i++) {\\n    ans = Math.max(ans, nums[i] - nums[i - 1]);\\n  }\\n  return ans;\\n};\\n\\nfunction getDigits(num) {\\n  let digits = 0;\\n  while (num > 0) {\\n    num = Math.floor(num / 10);\\n    digits++;\\n  }\\n  return digits;\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1809870,
                "title": "java-solution-in-o-n-time-complexity",
                "content": "```\\nclass Solution {\\n    public int maximumGap(int[] nums) {\\n        if(nums.length < 2)\\n            return 0;\\n        int n = nums.length;\\n        int max = nums[0], min= nums[0];\\n        for(int i  : nums) {\\n            max = Math.max(max, i);\\n            min = Math.min(min, i);\\n        }\\n        int bucketSize = (max - min)/(n - 1);\\n        if(bucketSize == 0)\\n            bucketSize++;\\n        int totalBuckets = ((max - min)/bucketSize) + 1;\\n        int[] minBucket = new int[totalBuckets];\\n        int[] maxBucket = new int[totalBuckets];\\n        Arrays.fill(minBucket, Integer.MAX_VALUE);\\n        for(int i = 0 ; i < n ; i++) {\\n            int index = (nums[i] - min)/bucketSize;\\n            minBucket[index] = Math.min(minBucket[index], nums[i]);\\n            maxBucket[index] = Math.max(maxBucket[index], nums[i]);\\n        }\\n        int prevMax = maxBucket[0], result = 0;\\n        for(int i = 1; i < totalBuckets; i++) {\\n            if(minBucket[i] == Integer.MAX_VALUE)\\n                continue;\\n            result = Math.max(result, minBucket[i] - prevMax);\\n            prevMax = maxBucket[i];\\n        }\\n        return result;\\n    }\\n}\\n```\\nGuy\\'s if you find this solution helpful \\uD83D\\uDE0A, PLEASE do UPVOTE.",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int maximumGap(int[] nums) {\\n        if(nums.length < 2)\\n            return 0;\\n        int n = nums.length;\\n        int max = nums[0], min= nums[0];\\n        for(int i  : nums) {\\n            max = Math.max(max, i);\\n            min = Math.min(min, i);\\n        }\\n        int bucketSize = (max - min)/(n - 1);\\n        if(bucketSize == 0)\\n            bucketSize++;\\n        int totalBuckets = ((max - min)/bucketSize) + 1;\\n        int[] minBucket = new int[totalBuckets];\\n        int[] maxBucket = new int[totalBuckets];\\n        Arrays.fill(minBucket, Integer.MAX_VALUE);\\n        for(int i = 0 ; i < n ; i++) {\\n            int index = (nums[i] - min)/bucketSize;\\n            minBucket[index] = Math.min(minBucket[index], nums[i]);\\n            maxBucket[index] = Math.max(maxBucket[index], nums[i]);\\n        }\\n        int prevMax = maxBucket[0], result = 0;\\n        for(int i = 1; i < totalBuckets; i++) {\\n            if(minBucket[i] == Integer.MAX_VALUE)\\n                continue;\\n            result = Math.max(result, minBucket[i] - prevMax);\\n            prevMax = maxBucket[i];\\n        }\\n        return result;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1764793,
                "title": "easy-c-solution-radix-sort",
                "content": "```\\nclass Solution {\\npublic:\\n  void countsort(vector<int> &arr, int n, int exp)\\n  {\\n    int count[10] = {0};\\n    for (int i = 0; i < n; i++)\\n    {\\n      count[(arr[i] / exp) % 10]++;\\n    }\\n\\n    for (int i = 1; i < 10; i++)\\n    {\\n      count[i] += count[i - 1];\\n    }\\n\\n    int ans[n];\\n    for (int i = n - 1; i >= 0; i--)\\n    {\\n      ans[--count[(arr[i] / exp) % 10]] = arr[i];\\n    }\\n    for (int i = 0; i < n; i++)\\n    {\\n      arr[i] = ans[i];\\n    }\\n  }\\n    int maximumGap(vector<int>& nums) {\\n       int n = nums.size();\\n       if(n < 2)\\n       return 0;\\n       int maxval = nums[0];\\n       for (int i = 1; i < n; i++)\\n       {\\n         maxval = max(maxval, nums[i]);\\n       }\\n       int exp = 1;\\n       while (exp <= maxval)\\n       {\\n         countsort(nums, n, exp);\\n         exp = exp * 10;\\n       }\\n       int diff = 0;\\n       for (int i = 1; i < n; i++)\\n       {\\n         diff = max(diff, nums[i] - nums[i-1]);\\n       }\\n       return diff;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n  void countsort(vector<int> &arr, int n, int exp)\\n  {\\n    int count[10] = {0};\\n    for (int i = 0; i < n; i++)\\n    {\\n      count[(arr[i] / exp) % 10]++;\\n    }\\n\\n    for (int i = 1; i < 10; i++)\\n    {\\n      count[i] += count[i - 1];\\n    }\\n\\n    int ans[n];\\n    for (int i = n - 1; i >= 0; i--)\\n    {\\n      ans[--count[(arr[i] / exp) % 10]] = arr[i];\\n    }\\n    for (int i = 0; i < n; i++)\\n    {\\n      arr[i] = ans[i];\\n    }\\n  }\\n    int maximumGap(vector<int>& nums) {\\n       int n = nums.size();\\n       if(n < 2)\\n       return 0;\\n       int maxval = nums[0];\\n       for (int i = 1; i < n; i++)\\n       {\\n         maxval = max(maxval, nums[i]);\\n       }\\n       int exp = 1;\\n       while (exp <= maxval)\\n       {\\n         countsort(nums, n, exp);\\n         exp = exp * 10;\\n       }\\n       int diff = 0;\\n       for (int i = 1; i < n; i++)\\n       {\\n         diff = max(diff, nums[i] - nums[i-1]);\\n       }\\n       return diff;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1705083,
                "title": "using-radix-sort-o-n",
                "content": "```\\n//Time will be : O(10*(10+n)) for radix sort == O(n) here\\nclass Solution {\\n    public int maximumGap(int[] nums) {\\n        int gap=0;\\n        int n =nums.length;\\n        int d = Integer.MIN_VALUE;\\n        int c=0;\\n        for(int i=0;i<n;i++){\\n            if(nums[i] > d) d=nums[i];\\n        }\\n        while(d>0){\\n            c++;\\n            d=d/10;\\n        }\\n        d=1;\\n        while(c-->0){\\n            int count[] = new int[10];\\n            int[] arr = new int[n];\\n            for(int i=0;i<n;i++){\\n                ++count[(nums[i]/d)%10];\\n            }\\n            for(int i=1;i<10;i++) count[i]+=count[i-1];\\n            for(int i=n-1;i>=0;i--){\\n                arr[--count[(nums[i]/d)%10]] = nums[i];\\n            }\\n            nums=arr;\\n            d=d*10;\\n        }\\n        for(int i=1;i<n;i++) if(nums[i]-nums[i-1]>gap) gap=nums[i]-nums[i-1];\\n        return gap;\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\n//Time will be : O(10*(10+n)) for radix sort == O(n) here\\nclass Solution {\\n    public int maximumGap(int[] nums) {\\n        int gap=0;\\n        int n =nums.length;\\n        int d = Integer.MIN_VALUE;\\n        int c=0;\\n        for(int i=0;i<n;i++){\\n            if(nums[i] > d) d=nums[i];\\n        }\\n        while(d>0){\\n            c++;\\n            d=d/10;\\n        }\\n        d=1;\\n        while(c-->0){\\n            int count[] = new int[10];\\n            int[] arr = new int[n];\\n            for(int i=0;i<n;i++){\\n                ++count[(nums[i]/d)%10];\\n            }\\n            for(int i=1;i<10;i++) count[i]+=count[i-1];\\n            for(int i=n-1;i>=0;i--){\\n                arr[--count[(nums[i]/d)%10]] = nums[i];\\n            }\\n            nums=arr;\\n            d=d*10;\\n        }\\n        for(int i=1;i<n;i++) if(nums[i]-nums[i-1]>gap) gap=nums[i]-nums[i-1];\\n        return gap;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1617881,
                "title": "maximum-gap-using-bucket-java-o-n-with-o-n",
                "content": "public int maximumGap(int[] a) {\\n        // O(n) with O(n)\\n\\t\\t\\n\\t\\tif(a.length <2){\\n\\t\\t\\t\\treturn 0;\\n\\t\\t\\t}\\n\\t\\t\\t\\n        int min = a[0];\\n        int max = 0;\\n        // find max and min!\\n        for(int n : a){\\n            min = Math.min(min,n);\\n            max = Math.max(max,n);\\n        }\\n        // find interval!\\n        int interval = (int)Math.ceil((max - min + 0.0)/(a.length-1));\\n        // bucket!\\n        int[] bucketmin = new int[a.length -1];\\n        int[] bucketmax = new int[a.length -1];\\n        Arrays.fill(bucketmin,Integer.MAX_VALUE);\\n        Arrays.fill(bucketmax,-1);\\n        \\n        for(int i=0; i < a.length; i++){\\n            if(a[i] == min || a[i] == max) continue;\\n            int index = (a[i] - min)/ interval;\\n            bucketmin[index] = Math.min(bucketmin[index],a[i]);\\n            bucketmax[index] = Math.max(bucketmax[index],a[i]);\\n        }\\n        \\n        int prev = min;\\n        int maxgap = 0;\\n        for(int i=0; i<bucketmin.length; i++){\\n            if(bucketmax[i] == -1 ) continue;    \\n            maxgap = Math.max(bucketmin[i] - prev,maxgap);\\n            prev = bucketmax[i];\\n        }\\n        maxgap = Math.max(max - prev, maxgap);\\n        return maxgap;\\n        \\n        \\n        \\n    }",
                "solutionTags": [
                    "Java",
                    "Array"
                ],
                "code": "public int maximumGap(int[] a) {\\n        // O(n) with O(n)\\n\\t\\t\\n\\t\\tif(a.length <2){\\n\\t\\t\\t\\treturn 0;\\n\\t\\t\\t}\\n\\t\\t\\t\\n        int min = a[0];\\n        int max = 0;\\n        // find max and min!\\n        for(int n : a){\\n            min = Math.min(min,n);\\n            max = Math.max(max,n);\\n        }\\n        // find interval!\\n        int interval = (int)Math.ceil((max - min + 0.0)/(a.length-1));\\n        // bucket!\\n        int[] bucketmin = new int[a.length -1];\\n        int[] bucketmax = new int[a.length -1];\\n        Arrays.fill(bucketmin,Integer.MAX_VALUE);\\n        Arrays.fill(bucketmax,-1);\\n        \\n        for(int i=0; i < a.length; i++){\\n            if(a[i] == min || a[i] == max) continue;\\n            int index = (a[i] - min)/ interval;\\n            bucketmin[index] = Math.min(bucketmin[index],a[i]);\\n            bucketmax[index] = Math.max(bucketmax[index],a[i]);\\n        }\\n        \\n        int prev = min;\\n        int maxgap = 0;\\n        for(int i=0; i<bucketmin.length; i++){\\n            if(bucketmax[i] == -1 ) continue;    \\n            maxgap = Math.max(bucketmin[i] - prev,maxgap);\\n            prev = bucketmax[i];\\n        }\\n        maxgap = Math.max(max - prev, maxgap);\\n        return maxgap;\\n        \\n        \\n        \\n    }",
                "codeTag": "Unknown"
            },
            {
                "id": 1597159,
                "title": "java-o-n-tc-using-radix-sort-o-n-sc",
                "content": "class Solution {\\n    public int maximumGap(int[] nums) {\\n        \\n        if(nums.length < 2)\\n            return 0;\\n        for(int i=1;i<=1000000000;i=i*10)\\n\\t{\\n\\t\\tsort(nums,i);\\n\\t}\\n        int max = Integer.MIN_VALUE;\\n    \\n        for(int i=0;i<nums.length-1;i++)\\n        {\\n            max = Math.max(max,(nums[i+1]-nums[i]));\\n        }\\n        \\n        return max;\\n    }\\n    \\n    \\n    \\t  public static void sort(int[] a,int divide)\\n\\t    {\\n\\t        ArrayList<ArrayList<Integer>> list = new ArrayList<ArrayList<Integer>>();\\n\\t        for(int i=0;i<10;i++)\\n\\t        {\\n\\t            list.add(i,new ArrayList<Integer>());\\n\\t        }\\n\\t        for(int i=0;i<a.length;i++)\\n\\t        {\\n\\t            list.get((a[i]/divide)%10).add(a[i]);\\n\\t        \\n\\t        }\\n\\t        \\n\\t        int k = 0;\\n\\t        for(ArrayList<Integer> arr : list)\\n\\t        {\\n\\t            for(Integer ele : arr)\\n\\t            {\\n\\t                a[k]= ele;\\n\\t                k++;\\n\\t            }\\n\\t        }\\n\\t        \\n\\t    }\\n}",
                "solutionTags": [],
                "code": "class Solution {\\n    public int maximumGap(int[] nums) {\\n        \\n        if(nums.length < 2)\\n            return 0;\\n        for(int i=1;i<=1000000000;i=i*10)\\n\\t{\\n\\t\\tsort(nums,i);\\n\\t}",
                "codeTag": "Java"
            },
            {
                "id": 1392188,
                "title": "python-o-n-bit-trie-solution",
                "content": "```\\nclass Solution:\\n    def maximumGap(self, nums: List[int]) -> int:\\n        def addToTrie(trie, num: int):\\n            mask = 1 << 31\\n            while mask:\\n                currentBit = 1 if (num & mask > 0) else 0 \\n                mask >>= 1\\n                if currentBit not in trie:\\n                    trie[currentBit] = dict()\\n                trie = trie[currentBit]\\n            trie[\"Number\"] = num\\n            \\n        def process(trie, bitShift: int, current: int):\\n            if \"Number\" in trie:\\n                if not self.prev is None:\\n                    gap = current - self.prev\\n                    self.maxGap = max(gap, self.maxGap)\\n                self.prev = current\\n            if 0 in trie:\\n                process(trie[0], bitShift >> 1, current)\\n            if 1 in trie:\\n                process(trie[1], bitShift >> 1, current + bitShift)\\n            \\n        if len(nums) < 2:\\n            return 0\\n        \\n        trie = dict()\\n        for num in nums:\\n            addToTrie(trie, num)\\n            \\n        self.prev = None\\n        self.maxGap = 0\\n        process(trie, 1 << 31, 0)\\n        return self.maxGap\\n                   \\n```\\nActually it\\'s equivalent to the radix sort\\n\\n",
                "solutionTags": [
                    "Python",
                    "Trie"
                ],
                "code": "```\\nclass Solution:\\n    def maximumGap(self, nums: List[int]) -> int:\\n        def addToTrie(trie, num: int):\\n            mask = 1 << 31\\n            while mask:\\n                currentBit = 1 if (num & mask > 0) else 0 \\n                mask >>= 1\\n                if currentBit not in trie:\\n                    trie[currentBit] = dict()\\n                trie = trie[currentBit]\\n            trie[\"Number\"] = num\\n            \\n        def process(trie, bitShift: int, current: int):\\n            if \"Number\" in trie:\\n                if not self.prev is None:\\n                    gap = current - self.prev\\n                    self.maxGap = max(gap, self.maxGap)\\n                self.prev = current\\n            if 0 in trie:\\n                process(trie[0], bitShift >> 1, current)\\n            if 1 in trie:\\n                process(trie[1], bitShift >> 1, current + bitShift)\\n            \\n        if len(nums) < 2:\\n            return 0\\n        \\n        trie = dict()\\n        for num in nums:\\n            addToTrie(trie, num)\\n            \\n        self.prev = None\\n        self.maxGap = 0\\n        process(trie, 1 << 31, 0)\\n        return self.maxGap\\n                   \\n```",
                "codeTag": "Java"
            },
            {
                "id": 1383922,
                "title": "python3-solution-using-radix-sort",
                "content": "```\\nclass Solution:\\n    def maximumGap(self, nums: List[int]) -> int:\\n        if len(nums) < 2:\\n            return 0\\n        elif len(nums) == 2:\\n            return max(nums) - min(nums)\\n        \\n        self.max_N_digits = max([len(str(num)) for num in nums])\\n        nums = self.radixSort(nums, 0)\\n        \\n        return max([nums[i]-nums[i-1] for i in range(1, len(nums))])\\n        \\n    def radixSort(self, nums, d):\\n        if d == self.max_N_digits:\\n            return nums\\n        bucket = {i:[] for i in range(10)}\\n        key = lambda x: int((x/(10**d))%10)\\n        \\n        for num in nums:\\n            bucket[key(num)].append(num)\\n        \\n        new_nums = []\\n        for i in range(10):\\n            new_nums += bucket[i]\\n        \\n        return self.radixSort(new_nums, d+1)\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution:\\n    def maximumGap(self, nums: List[int]) -> int:\\n        if len(nums) < 2:\\n            return 0\\n        elif len(nums) == 2:\\n            return max(nums) - min(nums)\\n        \\n        self.max_N_digits = max([len(str(num)) for num in nums])\\n        nums = self.radixSort(nums, 0)\\n        \\n        return max([nums[i]-nums[i-1] for i in range(1, len(nums))])\\n        \\n    def radixSort(self, nums, d):\\n        if d == self.max_N_digits:\\n            return nums\\n        bucket = {i:[] for i in range(10)}\\n        key = lambda x: int((x/(10**d))%10)\\n        \\n        for num in nums:\\n            bucket[key(num)].append(num)\\n        \\n        new_nums = []\\n        for i in range(10):\\n            new_nums += bucket[i]\\n        \\n        return self.radixSort(new_nums, d+1)\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1352305,
                "title": "python-bucket-sort-solution-not-comparison-based-soritng",
                "content": "```\\nclass Solution:\\n    def BucketSort(self,arr,n):\\n        max_ele=max(arr)\\n        size=max_ele/n\\n        bucketList=[[] for i in range(n)]\\n        for i in range(n):\\n            j=int(arr[i]/size)\\n            if j==n:bucketList[j-1].append(arr[i])\\n            else:bucketList[j].append(arr[i])\\n        for i in bucketList:\\n            if i:i.sort()\\n        k=0\\n        for lst in bucketList:\\n            if lst:\\n                for i in lst:\\n                    arr[k]=i\\n                    k+=1\\n    def maximumGap(self, nums: List[int]) -> int:\\n        n=len(nums)\\n        if n<2:return 0\\n        self.BucketSort(nums,n)\\n        ans=0\\n        for i in range(n-1):\\n            x=nums[i+1]-nums[i]\\n            if x>ans:ans=x\\n        return ans\\n```",
                "solutionTags": [
                    "Python3",
                    "Bucket Sort"
                ],
                "code": "```\\nclass Solution:\\n    def BucketSort(self,arr,n):\\n        max_ele=max(arr)\\n        size=max_ele/n\\n        bucketList=[[] for i in range(n)]\\n        for i in range(n):\\n            j=int(arr[i]/size)\\n            if j==n:bucketList[j-1].append(arr[i])\\n            else:bucketList[j].append(arr[i])\\n        for i in bucketList:\\n            if i:i.sort()\\n        k=0\\n        for lst in bucketList:\\n            if lst:\\n                for i in lst:\\n                    arr[k]=i\\n                    k+=1\\n    def maximumGap(self, nums: List[int]) -> int:\\n        n=len(nums)\\n        if n<2:return 0\\n        self.BucketSort(nums,n)\\n        ans=0\\n        for i in range(n-1):\\n            x=nums[i+1]-nums[i]\\n            if x>ans:ans=x\\n        return ans\\n```",
                "codeTag": "Java"
            }
        ],
        "discussions": [
            {
                "id": 1853589,
                "content": [
                    {
                        "username": "Msey",
                        "content": "Well, I can handle Example2. Seems it\\'s a good start :)"
                    },
                    {
                        "username": "cartesPerforees",
                        "content": "Always a confidence booster to see that green light turned on for half the testcases on first try, until you look at what case it is"
                    },
                    {
                        "username": "changpro",
                        "content": "#### This \"hard\" problem is meaningless cause I see so many sort() in discuss, and they run really fast.\\n#### Actually it\\'s not a linear cause you don\\'t know what max element is right? There is no way to compare which one is faster  if the maxmum are much larger than the array\\'s length."
                    },
                    {
                        "username": "cartesPerforees",
                        "content": "I don't get your point. Of course if you cheat you can make the hard problem easier. It's specified in the statement you can;t use a sort (linear runtime). They can't automatically detect if you do, but who cares? If someone did it with a sort, they know they didn;t solve this question.\n\nAlso, why you screaming, bro?"
                    },
                    {
                        "username": "cartesPerforees",
                        "content": "[@HitenTandon](/HitenTandon) Hm? Yeah, but bucket sort doesn't suffer from that, afaik. I'm pretty sure my bucket-based solution is worst case O(n)"
                    },
                    {
                        "username": "HitenTandon",
                        "content": "You are right, radix sort has a time complexity of $$O(nlogR(maxElement) + RlogR(maxElement))$$.\n\nWhere, n is the number of elements in the array, R is the chosen radix, and maxElement is the maximum element.\n\nSo in theory the bigger Radix you chose the faster your algorithm runs, and that's why generally, a radix of 256 is used, which makes the worst case time complexity for the algorithm $$O(4(n + R))$$(here, since ints are 32 bits).\n\nIDK why all the people are using radix 2 or 10, because they don't really make much sense."
                    },
                    {
                        "username": "geekyshark",
                        "content": "Caution : Easy Problem marked Hard"
                    },
                    {
                        "username": "liubo0331",
                        "content": "The description \"maximum difference between the successive elements\" confuses me, because the successive elements could mean more than 2 elements that are successive."
                    },
                    {
                        "username": "_srahul_",
                        "content": "I don\\'t know why they can\\'t provide a good example."
                    },
                    {
                        "username": "fancyIX",
                        "content": "it's said \"Given an unsorted array, find the maximum difference between the successive elements in its sorted form.\"\\n\\nWhat does it mean by \"difference\"? What is the difference between the successive elements? What does \"in its sorted form\" mean?"
                    },
                    {
                        "username": "drMystico",
                        "content": "I guess that even in an unsorted array, there should exist a sorted subarray, and we need to return the maximum difference among that subarray's element, that was what I was able to decipher from the example"
                    },
                    {
                        "username": "heg816",
                        "content": "find the highest value of (sorted_array[k+1] - sorted_array[k]) for some k s.t. 0 <= k < arr.length - 1"
                    },
                    {
                        "username": "ak_ydv",
                        "content": "why this question is marked as a hard ?"
                    },
                    {
                        "username": "benlong",
                        "content": "I've read about the bucket sort solution in the discuss. However, I find that the explanation to \"**the maximum gap absolutely exists between buckets**\" is not so clear to me. Thus I'm trying to give some thoughts from what I understand.\\n\\nFirst of all, let's assume that there are at least 2 number in the array. The smallest is min, biggest is max, and we use range to represent the difference between max and min (range = max - min). We use gapNum to denote the number of gaps in the array. Needless to say that gapNum = num.size() - 1. Thus we've got at least 1 gap. According to whether range could be divided by gapNum without remainder, this problem could be divided into 2 cases.\\n\\n(1). range could be completely divided. That is, range % gapNum == 0. In this case, bucketLen = range / gapNum, and bucketNum = gapNum + 1. For example, the input is [1, 101, 201, 301], thus range = 300, gapNum = 3, bucketLen = 100, bucketNum = 4. The 4 buckets will be: [1, 101), [101, 201), [201, 301), [301, 401). You might have noticed in this **perfect situation**, each number falls into a different bucket, and no numbers will share a bucket. So we could say, the max gap exists between the buckets.\\n\\nThis is also true when the gap between the numbers become uneven. As min and max are fixed, range and gapNum are both fixed. The current 3 gaps between the numbers are 100, 100, 100. When the middle numbers change, the 3 gaps between will change accordingly. But what's for sure is when some gaps become smaller than 100, some gaps will definitely become larger than 100, since they are bounded by the fixed range sum. For example, 50, 75, 175. or 101, 99, 100.  Under this condition, the biggest gap will be bigger than 100. Thus the two numbers constituting this gap cannot fall into the same bucket, since the biggest gap allowed in a single bucket is (bucketLen - 1) = 99. So when the gaps are uneven, the max gap exists between the buckets.\\n\\n(2). range could not be completely divided. That is, range % gapNum != 0. For example, 1, 4, 7, 11, 15. In this case, the most even gap arrangement is, some gaps are range / gapNum, while the other gaps are\\nrange / gapNum + 1. For our case, range = (15 - 1) = 14, gapNum = 4. Thus the most even arrangement is 3 3 4 4, or 3 4 3 4, or 4 3 3 4, and et al. Actually, for the sole sake of finding the max gap, we could choose either range / gapNum or range / gapNum + 1 as the buckeLen. \\n\\nSince bucketNum = range / bucketLen + 1, we will have one more bucket when choosing the smaller bucketLen than choosing the bigger bucketLen. For our example, when bucketLen = 3, bucketNum = 14 / 3 + 1 = 5. while when bucketLen = 4, 14 / 4 + 1 = 4. Their buckets are:\\n\\n3: [1, 4), [4, 7), [7, 10), [10, 13), [13, 16)\\n\\n4:[1, 5), [5, 9), [9, 13), [13, 17)\\n\\nIt can be seen that in either cases, the max gap will be found between buckets for the most even gap arrangements. The only difference is that the smaller bucketLen will guarantee each number fall in to a different bucket (3 > 3 - 1), while for the bigger bucketLen, those numbers with the small gap might fall into the same bucket (4 - 1 >= 3). But no matter how, we could always find the max gap between the buckets, since 4 > 3 - 1, and 4 > 4 - 1;\\n\\nFixing min and max, when the gaps become uneven, some gaps will be smaller, and some will correspondingly become larger, since their sum is fixed to range. For example, 2 4 4 4, or 1 3 5 5 for our case. When the max gap becomes larger than 4, it will definitely exist between buckets, since maxGap > 4 > 4 - 1;\\n\\nBut why don't we choose range / gapNum as the bucketLen in our algorithms? The answer is that range / gapNum might be zero for some cases. For example, assume the input array is 1 1 1 1 4. Here range / gapNum = 3 / 4 = 0. But bucketLen should at least be 1 for the solution to work. To deal with this issue, we typically choose bucketLen = range / gapNum + 1 to guarantee the validity of bucketLen. For this exmaple, bucketLen = 1, bucketNum = 4, and the buckets are: [1, 2), [2, 3), [3, 4), [4, 5), two of them will be empty. **But for those cases where the smaller one of the two even gaps is not zero, setting bucketLen to range / gapNum also works in the algorithm!**"
                    },
                    {
                        "username": "SunnyGupta",
                        "content": "I was able to understand the solution but there is one thing that is constantly making me to think Why we have not included min and max in the buckets that we have created???\\nPlease can someone answer with proper reasoning..\\nThanks in advance!"
                    },
                    {
                        "username": "zhoubowei",
                        "content": "It is O(kN) algorithm instead, depends on the numbers\\' range.\\nhttps://en.wikipedia.org/wiki/Radix_sort\\n"
                    }
                ]
            },
            {
                "id": 1567469,
                "content": [
                    {
                        "username": "Msey",
                        "content": "Well, I can handle Example2. Seems it\\'s a good start :)"
                    },
                    {
                        "username": "cartesPerforees",
                        "content": "Always a confidence booster to see that green light turned on for half the testcases on first try, until you look at what case it is"
                    },
                    {
                        "username": "changpro",
                        "content": "#### This \"hard\" problem is meaningless cause I see so many sort() in discuss, and they run really fast.\\n#### Actually it\\'s not a linear cause you don\\'t know what max element is right? There is no way to compare which one is faster  if the maxmum are much larger than the array\\'s length."
                    },
                    {
                        "username": "cartesPerforees",
                        "content": "I don't get your point. Of course if you cheat you can make the hard problem easier. It's specified in the statement you can;t use a sort (linear runtime). They can't automatically detect if you do, but who cares? If someone did it with a sort, they know they didn;t solve this question.\n\nAlso, why you screaming, bro?"
                    },
                    {
                        "username": "cartesPerforees",
                        "content": "[@HitenTandon](/HitenTandon) Hm? Yeah, but bucket sort doesn't suffer from that, afaik. I'm pretty sure my bucket-based solution is worst case O(n)"
                    },
                    {
                        "username": "HitenTandon",
                        "content": "You are right, radix sort has a time complexity of $$O(nlogR(maxElement) + RlogR(maxElement))$$.\n\nWhere, n is the number of elements in the array, R is the chosen radix, and maxElement is the maximum element.\n\nSo in theory the bigger Radix you chose the faster your algorithm runs, and that's why generally, a radix of 256 is used, which makes the worst case time complexity for the algorithm $$O(4(n + R))$$(here, since ints are 32 bits).\n\nIDK why all the people are using radix 2 or 10, because they don't really make much sense."
                    },
                    {
                        "username": "geekyshark",
                        "content": "Caution : Easy Problem marked Hard"
                    },
                    {
                        "username": "liubo0331",
                        "content": "The description \"maximum difference between the successive elements\" confuses me, because the successive elements could mean more than 2 elements that are successive."
                    },
                    {
                        "username": "_srahul_",
                        "content": "I don\\'t know why they can\\'t provide a good example."
                    },
                    {
                        "username": "fancyIX",
                        "content": "it's said \"Given an unsorted array, find the maximum difference between the successive elements in its sorted form.\"\\n\\nWhat does it mean by \"difference\"? What is the difference between the successive elements? What does \"in its sorted form\" mean?"
                    },
                    {
                        "username": "drMystico",
                        "content": "I guess that even in an unsorted array, there should exist a sorted subarray, and we need to return the maximum difference among that subarray's element, that was what I was able to decipher from the example"
                    },
                    {
                        "username": "heg816",
                        "content": "find the highest value of (sorted_array[k+1] - sorted_array[k]) for some k s.t. 0 <= k < arr.length - 1"
                    },
                    {
                        "username": "ak_ydv",
                        "content": "why this question is marked as a hard ?"
                    },
                    {
                        "username": "benlong",
                        "content": "I've read about the bucket sort solution in the discuss. However, I find that the explanation to \"**the maximum gap absolutely exists between buckets**\" is not so clear to me. Thus I'm trying to give some thoughts from what I understand.\\n\\nFirst of all, let's assume that there are at least 2 number in the array. The smallest is min, biggest is max, and we use range to represent the difference between max and min (range = max - min). We use gapNum to denote the number of gaps in the array. Needless to say that gapNum = num.size() - 1. Thus we've got at least 1 gap. According to whether range could be divided by gapNum without remainder, this problem could be divided into 2 cases.\\n\\n(1). range could be completely divided. That is, range % gapNum == 0. In this case, bucketLen = range / gapNum, and bucketNum = gapNum + 1. For example, the input is [1, 101, 201, 301], thus range = 300, gapNum = 3, bucketLen = 100, bucketNum = 4. The 4 buckets will be: [1, 101), [101, 201), [201, 301), [301, 401). You might have noticed in this **perfect situation**, each number falls into a different bucket, and no numbers will share a bucket. So we could say, the max gap exists between the buckets.\\n\\nThis is also true when the gap between the numbers become uneven. As min and max are fixed, range and gapNum are both fixed. The current 3 gaps between the numbers are 100, 100, 100. When the middle numbers change, the 3 gaps between will change accordingly. But what's for sure is when some gaps become smaller than 100, some gaps will definitely become larger than 100, since they are bounded by the fixed range sum. For example, 50, 75, 175. or 101, 99, 100.  Under this condition, the biggest gap will be bigger than 100. Thus the two numbers constituting this gap cannot fall into the same bucket, since the biggest gap allowed in a single bucket is (bucketLen - 1) = 99. So when the gaps are uneven, the max gap exists between the buckets.\\n\\n(2). range could not be completely divided. That is, range % gapNum != 0. For example, 1, 4, 7, 11, 15. In this case, the most even gap arrangement is, some gaps are range / gapNum, while the other gaps are\\nrange / gapNum + 1. For our case, range = (15 - 1) = 14, gapNum = 4. Thus the most even arrangement is 3 3 4 4, or 3 4 3 4, or 4 3 3 4, and et al. Actually, for the sole sake of finding the max gap, we could choose either range / gapNum or range / gapNum + 1 as the buckeLen. \\n\\nSince bucketNum = range / bucketLen + 1, we will have one more bucket when choosing the smaller bucketLen than choosing the bigger bucketLen. For our example, when bucketLen = 3, bucketNum = 14 / 3 + 1 = 5. while when bucketLen = 4, 14 / 4 + 1 = 4. Their buckets are:\\n\\n3: [1, 4), [4, 7), [7, 10), [10, 13), [13, 16)\\n\\n4:[1, 5), [5, 9), [9, 13), [13, 17)\\n\\nIt can be seen that in either cases, the max gap will be found between buckets for the most even gap arrangements. The only difference is that the smaller bucketLen will guarantee each number fall in to a different bucket (3 > 3 - 1), while for the bigger bucketLen, those numbers with the small gap might fall into the same bucket (4 - 1 >= 3). But no matter how, we could always find the max gap between the buckets, since 4 > 3 - 1, and 4 > 4 - 1;\\n\\nFixing min and max, when the gaps become uneven, some gaps will be smaller, and some will correspondingly become larger, since their sum is fixed to range. For example, 2 4 4 4, or 1 3 5 5 for our case. When the max gap becomes larger than 4, it will definitely exist between buckets, since maxGap > 4 > 4 - 1;\\n\\nBut why don't we choose range / gapNum as the bucketLen in our algorithms? The answer is that range / gapNum might be zero for some cases. For example, assume the input array is 1 1 1 1 4. Here range / gapNum = 3 / 4 = 0. But bucketLen should at least be 1 for the solution to work. To deal with this issue, we typically choose bucketLen = range / gapNum + 1 to guarantee the validity of bucketLen. For this exmaple, bucketLen = 1, bucketNum = 4, and the buckets are: [1, 2), [2, 3), [3, 4), [4, 5), two of them will be empty. **But for those cases where the smaller one of the two even gaps is not zero, setting bucketLen to range / gapNum also works in the algorithm!**"
                    },
                    {
                        "username": "SunnyGupta",
                        "content": "I was able to understand the solution but there is one thing that is constantly making me to think Why we have not included min and max in the buckets that we have created???\\nPlease can someone answer with proper reasoning..\\nThanks in advance!"
                    },
                    {
                        "username": "zhoubowei",
                        "content": "It is O(kN) algorithm instead, depends on the numbers\\' range.\\nhttps://en.wikipedia.org/wiki/Radix_sort\\n"
                    }
                ]
            },
            {
                "id": 1966139,
                "content": [
                    {
                        "username": "Msey",
                        "content": "Well, I can handle Example2. Seems it\\'s a good start :)"
                    },
                    {
                        "username": "cartesPerforees",
                        "content": "Always a confidence booster to see that green light turned on for half the testcases on first try, until you look at what case it is"
                    },
                    {
                        "username": "changpro",
                        "content": "#### This \"hard\" problem is meaningless cause I see so many sort() in discuss, and they run really fast.\\n#### Actually it\\'s not a linear cause you don\\'t know what max element is right? There is no way to compare which one is faster  if the maxmum are much larger than the array\\'s length."
                    },
                    {
                        "username": "cartesPerforees",
                        "content": "I don't get your point. Of course if you cheat you can make the hard problem easier. It's specified in the statement you can;t use a sort (linear runtime). They can't automatically detect if you do, but who cares? If someone did it with a sort, they know they didn;t solve this question.\n\nAlso, why you screaming, bro?"
                    },
                    {
                        "username": "cartesPerforees",
                        "content": "[@HitenTandon](/HitenTandon) Hm? Yeah, but bucket sort doesn't suffer from that, afaik. I'm pretty sure my bucket-based solution is worst case O(n)"
                    },
                    {
                        "username": "HitenTandon",
                        "content": "You are right, radix sort has a time complexity of $$O(nlogR(maxElement) + RlogR(maxElement))$$.\n\nWhere, n is the number of elements in the array, R is the chosen radix, and maxElement is the maximum element.\n\nSo in theory the bigger Radix you chose the faster your algorithm runs, and that's why generally, a radix of 256 is used, which makes the worst case time complexity for the algorithm $$O(4(n + R))$$(here, since ints are 32 bits).\n\nIDK why all the people are using radix 2 or 10, because they don't really make much sense."
                    },
                    {
                        "username": "geekyshark",
                        "content": "Caution : Easy Problem marked Hard"
                    },
                    {
                        "username": "liubo0331",
                        "content": "The description \"maximum difference between the successive elements\" confuses me, because the successive elements could mean more than 2 elements that are successive."
                    },
                    {
                        "username": "_srahul_",
                        "content": "I don\\'t know why they can\\'t provide a good example."
                    },
                    {
                        "username": "fancyIX",
                        "content": "it's said \"Given an unsorted array, find the maximum difference between the successive elements in its sorted form.\"\\n\\nWhat does it mean by \"difference\"? What is the difference between the successive elements? What does \"in its sorted form\" mean?"
                    },
                    {
                        "username": "drMystico",
                        "content": "I guess that even in an unsorted array, there should exist a sorted subarray, and we need to return the maximum difference among that subarray's element, that was what I was able to decipher from the example"
                    },
                    {
                        "username": "heg816",
                        "content": "find the highest value of (sorted_array[k+1] - sorted_array[k]) for some k s.t. 0 <= k < arr.length - 1"
                    },
                    {
                        "username": "ak_ydv",
                        "content": "why this question is marked as a hard ?"
                    },
                    {
                        "username": "benlong",
                        "content": "I've read about the bucket sort solution in the discuss. However, I find that the explanation to \"**the maximum gap absolutely exists between buckets**\" is not so clear to me. Thus I'm trying to give some thoughts from what I understand.\\n\\nFirst of all, let's assume that there are at least 2 number in the array. The smallest is min, biggest is max, and we use range to represent the difference between max and min (range = max - min). We use gapNum to denote the number of gaps in the array. Needless to say that gapNum = num.size() - 1. Thus we've got at least 1 gap. According to whether range could be divided by gapNum without remainder, this problem could be divided into 2 cases.\\n\\n(1). range could be completely divided. That is, range % gapNum == 0. In this case, bucketLen = range / gapNum, and bucketNum = gapNum + 1. For example, the input is [1, 101, 201, 301], thus range = 300, gapNum = 3, bucketLen = 100, bucketNum = 4. The 4 buckets will be: [1, 101), [101, 201), [201, 301), [301, 401). You might have noticed in this **perfect situation**, each number falls into a different bucket, and no numbers will share a bucket. So we could say, the max gap exists between the buckets.\\n\\nThis is also true when the gap between the numbers become uneven. As min and max are fixed, range and gapNum are both fixed. The current 3 gaps between the numbers are 100, 100, 100. When the middle numbers change, the 3 gaps between will change accordingly. But what's for sure is when some gaps become smaller than 100, some gaps will definitely become larger than 100, since they are bounded by the fixed range sum. For example, 50, 75, 175. or 101, 99, 100.  Under this condition, the biggest gap will be bigger than 100. Thus the two numbers constituting this gap cannot fall into the same bucket, since the biggest gap allowed in a single bucket is (bucketLen - 1) = 99. So when the gaps are uneven, the max gap exists between the buckets.\\n\\n(2). range could not be completely divided. That is, range % gapNum != 0. For example, 1, 4, 7, 11, 15. In this case, the most even gap arrangement is, some gaps are range / gapNum, while the other gaps are\\nrange / gapNum + 1. For our case, range = (15 - 1) = 14, gapNum = 4. Thus the most even arrangement is 3 3 4 4, or 3 4 3 4, or 4 3 3 4, and et al. Actually, for the sole sake of finding the max gap, we could choose either range / gapNum or range / gapNum + 1 as the buckeLen. \\n\\nSince bucketNum = range / bucketLen + 1, we will have one more bucket when choosing the smaller bucketLen than choosing the bigger bucketLen. For our example, when bucketLen = 3, bucketNum = 14 / 3 + 1 = 5. while when bucketLen = 4, 14 / 4 + 1 = 4. Their buckets are:\\n\\n3: [1, 4), [4, 7), [7, 10), [10, 13), [13, 16)\\n\\n4:[1, 5), [5, 9), [9, 13), [13, 17)\\n\\nIt can be seen that in either cases, the max gap will be found between buckets for the most even gap arrangements. The only difference is that the smaller bucketLen will guarantee each number fall in to a different bucket (3 > 3 - 1), while for the bigger bucketLen, those numbers with the small gap might fall into the same bucket (4 - 1 >= 3). But no matter how, we could always find the max gap between the buckets, since 4 > 3 - 1, and 4 > 4 - 1;\\n\\nFixing min and max, when the gaps become uneven, some gaps will be smaller, and some will correspondingly become larger, since their sum is fixed to range. For example, 2 4 4 4, or 1 3 5 5 for our case. When the max gap becomes larger than 4, it will definitely exist between buckets, since maxGap > 4 > 4 - 1;\\n\\nBut why don't we choose range / gapNum as the bucketLen in our algorithms? The answer is that range / gapNum might be zero for some cases. For example, assume the input array is 1 1 1 1 4. Here range / gapNum = 3 / 4 = 0. But bucketLen should at least be 1 for the solution to work. To deal with this issue, we typically choose bucketLen = range / gapNum + 1 to guarantee the validity of bucketLen. For this exmaple, bucketLen = 1, bucketNum = 4, and the buckets are: [1, 2), [2, 3), [3, 4), [4, 5), two of them will be empty. **But for those cases where the smaller one of the two even gaps is not zero, setting bucketLen to range / gapNum also works in the algorithm!**"
                    },
                    {
                        "username": "SunnyGupta",
                        "content": "I was able to understand the solution but there is one thing that is constantly making me to think Why we have not included min and max in the buckets that we have created???\\nPlease can someone answer with proper reasoning..\\nThanks in advance!"
                    },
                    {
                        "username": "zhoubowei",
                        "content": "It is O(kN) algorithm instead, depends on the numbers\\' range.\\nhttps://en.wikipedia.org/wiki/Radix_sort\\n"
                    }
                ]
            },
            {
                "id": 1566077,
                "content": [
                    {
                        "username": "Msey",
                        "content": "Well, I can handle Example2. Seems it\\'s a good start :)"
                    },
                    {
                        "username": "cartesPerforees",
                        "content": "Always a confidence booster to see that green light turned on for half the testcases on first try, until you look at what case it is"
                    },
                    {
                        "username": "changpro",
                        "content": "#### This \"hard\" problem is meaningless cause I see so many sort() in discuss, and they run really fast.\\n#### Actually it\\'s not a linear cause you don\\'t know what max element is right? There is no way to compare which one is faster  if the maxmum are much larger than the array\\'s length."
                    },
                    {
                        "username": "cartesPerforees",
                        "content": "I don't get your point. Of course if you cheat you can make the hard problem easier. It's specified in the statement you can;t use a sort (linear runtime). They can't automatically detect if you do, but who cares? If someone did it with a sort, they know they didn;t solve this question.\n\nAlso, why you screaming, bro?"
                    },
                    {
                        "username": "cartesPerforees",
                        "content": "[@HitenTandon](/HitenTandon) Hm? Yeah, but bucket sort doesn't suffer from that, afaik. I'm pretty sure my bucket-based solution is worst case O(n)"
                    },
                    {
                        "username": "HitenTandon",
                        "content": "You are right, radix sort has a time complexity of $$O(nlogR(maxElement) + RlogR(maxElement))$$.\n\nWhere, n is the number of elements in the array, R is the chosen radix, and maxElement is the maximum element.\n\nSo in theory the bigger Radix you chose the faster your algorithm runs, and that's why generally, a radix of 256 is used, which makes the worst case time complexity for the algorithm $$O(4(n + R))$$(here, since ints are 32 bits).\n\nIDK why all the people are using radix 2 or 10, because they don't really make much sense."
                    },
                    {
                        "username": "geekyshark",
                        "content": "Caution : Easy Problem marked Hard"
                    },
                    {
                        "username": "liubo0331",
                        "content": "The description \"maximum difference between the successive elements\" confuses me, because the successive elements could mean more than 2 elements that are successive."
                    },
                    {
                        "username": "_srahul_",
                        "content": "I don\\'t know why they can\\'t provide a good example."
                    },
                    {
                        "username": "fancyIX",
                        "content": "it's said \"Given an unsorted array, find the maximum difference between the successive elements in its sorted form.\"\\n\\nWhat does it mean by \"difference\"? What is the difference between the successive elements? What does \"in its sorted form\" mean?"
                    },
                    {
                        "username": "drMystico",
                        "content": "I guess that even in an unsorted array, there should exist a sorted subarray, and we need to return the maximum difference among that subarray's element, that was what I was able to decipher from the example"
                    },
                    {
                        "username": "heg816",
                        "content": "find the highest value of (sorted_array[k+1] - sorted_array[k]) for some k s.t. 0 <= k < arr.length - 1"
                    },
                    {
                        "username": "ak_ydv",
                        "content": "why this question is marked as a hard ?"
                    },
                    {
                        "username": "benlong",
                        "content": "I've read about the bucket sort solution in the discuss. However, I find that the explanation to \"**the maximum gap absolutely exists between buckets**\" is not so clear to me. Thus I'm trying to give some thoughts from what I understand.\\n\\nFirst of all, let's assume that there are at least 2 number in the array. The smallest is min, biggest is max, and we use range to represent the difference between max and min (range = max - min). We use gapNum to denote the number of gaps in the array. Needless to say that gapNum = num.size() - 1. Thus we've got at least 1 gap. According to whether range could be divided by gapNum without remainder, this problem could be divided into 2 cases.\\n\\n(1). range could be completely divided. That is, range % gapNum == 0. In this case, bucketLen = range / gapNum, and bucketNum = gapNum + 1. For example, the input is [1, 101, 201, 301], thus range = 300, gapNum = 3, bucketLen = 100, bucketNum = 4. The 4 buckets will be: [1, 101), [101, 201), [201, 301), [301, 401). You might have noticed in this **perfect situation**, each number falls into a different bucket, and no numbers will share a bucket. So we could say, the max gap exists between the buckets.\\n\\nThis is also true when the gap between the numbers become uneven. As min and max are fixed, range and gapNum are both fixed. The current 3 gaps between the numbers are 100, 100, 100. When the middle numbers change, the 3 gaps between will change accordingly. But what's for sure is when some gaps become smaller than 100, some gaps will definitely become larger than 100, since they are bounded by the fixed range sum. For example, 50, 75, 175. or 101, 99, 100.  Under this condition, the biggest gap will be bigger than 100. Thus the two numbers constituting this gap cannot fall into the same bucket, since the biggest gap allowed in a single bucket is (bucketLen - 1) = 99. So when the gaps are uneven, the max gap exists between the buckets.\\n\\n(2). range could not be completely divided. That is, range % gapNum != 0. For example, 1, 4, 7, 11, 15. In this case, the most even gap arrangement is, some gaps are range / gapNum, while the other gaps are\\nrange / gapNum + 1. For our case, range = (15 - 1) = 14, gapNum = 4. Thus the most even arrangement is 3 3 4 4, or 3 4 3 4, or 4 3 3 4, and et al. Actually, for the sole sake of finding the max gap, we could choose either range / gapNum or range / gapNum + 1 as the buckeLen. \\n\\nSince bucketNum = range / bucketLen + 1, we will have one more bucket when choosing the smaller bucketLen than choosing the bigger bucketLen. For our example, when bucketLen = 3, bucketNum = 14 / 3 + 1 = 5. while when bucketLen = 4, 14 / 4 + 1 = 4. Their buckets are:\\n\\n3: [1, 4), [4, 7), [7, 10), [10, 13), [13, 16)\\n\\n4:[1, 5), [5, 9), [9, 13), [13, 17)\\n\\nIt can be seen that in either cases, the max gap will be found between buckets for the most even gap arrangements. The only difference is that the smaller bucketLen will guarantee each number fall in to a different bucket (3 > 3 - 1), while for the bigger bucketLen, those numbers with the small gap might fall into the same bucket (4 - 1 >= 3). But no matter how, we could always find the max gap between the buckets, since 4 > 3 - 1, and 4 > 4 - 1;\\n\\nFixing min and max, when the gaps become uneven, some gaps will be smaller, and some will correspondingly become larger, since their sum is fixed to range. For example, 2 4 4 4, or 1 3 5 5 for our case. When the max gap becomes larger than 4, it will definitely exist between buckets, since maxGap > 4 > 4 - 1;\\n\\nBut why don't we choose range / gapNum as the bucketLen in our algorithms? The answer is that range / gapNum might be zero for some cases. For example, assume the input array is 1 1 1 1 4. Here range / gapNum = 3 / 4 = 0. But bucketLen should at least be 1 for the solution to work. To deal with this issue, we typically choose bucketLen = range / gapNum + 1 to guarantee the validity of bucketLen. For this exmaple, bucketLen = 1, bucketNum = 4, and the buckets are: [1, 2), [2, 3), [3, 4), [4, 5), two of them will be empty. **But for those cases where the smaller one of the two even gaps is not zero, setting bucketLen to range / gapNum also works in the algorithm!**"
                    },
                    {
                        "username": "SunnyGupta",
                        "content": "I was able to understand the solution but there is one thing that is constantly making me to think Why we have not included min and max in the buckets that we have created???\\nPlease can someone answer with proper reasoning..\\nThanks in advance!"
                    },
                    {
                        "username": "zhoubowei",
                        "content": "It is O(kN) algorithm instead, depends on the numbers\\' range.\\nhttps://en.wikipedia.org/wiki/Radix_sort\\n"
                    }
                ]
            },
            {
                "id": 1820461,
                "content": [
                    {
                        "username": "Msey",
                        "content": "Well, I can handle Example2. Seems it\\'s a good start :)"
                    },
                    {
                        "username": "cartesPerforees",
                        "content": "Always a confidence booster to see that green light turned on for half the testcases on first try, until you look at what case it is"
                    },
                    {
                        "username": "changpro",
                        "content": "#### This \"hard\" problem is meaningless cause I see so many sort() in discuss, and they run really fast.\\n#### Actually it\\'s not a linear cause you don\\'t know what max element is right? There is no way to compare which one is faster  if the maxmum are much larger than the array\\'s length."
                    },
                    {
                        "username": "cartesPerforees",
                        "content": "I don't get your point. Of course if you cheat you can make the hard problem easier. It's specified in the statement you can;t use a sort (linear runtime). They can't automatically detect if you do, but who cares? If someone did it with a sort, they know they didn;t solve this question.\n\nAlso, why you screaming, bro?"
                    },
                    {
                        "username": "cartesPerforees",
                        "content": "[@HitenTandon](/HitenTandon) Hm? Yeah, but bucket sort doesn't suffer from that, afaik. I'm pretty sure my bucket-based solution is worst case O(n)"
                    },
                    {
                        "username": "HitenTandon",
                        "content": "You are right, radix sort has a time complexity of $$O(nlogR(maxElement) + RlogR(maxElement))$$.\n\nWhere, n is the number of elements in the array, R is the chosen radix, and maxElement is the maximum element.\n\nSo in theory the bigger Radix you chose the faster your algorithm runs, and that's why generally, a radix of 256 is used, which makes the worst case time complexity for the algorithm $$O(4(n + R))$$(here, since ints are 32 bits).\n\nIDK why all the people are using radix 2 or 10, because they don't really make much sense."
                    },
                    {
                        "username": "geekyshark",
                        "content": "Caution : Easy Problem marked Hard"
                    },
                    {
                        "username": "liubo0331",
                        "content": "The description \"maximum difference between the successive elements\" confuses me, because the successive elements could mean more than 2 elements that are successive."
                    },
                    {
                        "username": "_srahul_",
                        "content": "I don\\'t know why they can\\'t provide a good example."
                    },
                    {
                        "username": "fancyIX",
                        "content": "it's said \"Given an unsorted array, find the maximum difference between the successive elements in its sorted form.\"\\n\\nWhat does it mean by \"difference\"? What is the difference between the successive elements? What does \"in its sorted form\" mean?"
                    },
                    {
                        "username": "drMystico",
                        "content": "I guess that even in an unsorted array, there should exist a sorted subarray, and we need to return the maximum difference among that subarray's element, that was what I was able to decipher from the example"
                    },
                    {
                        "username": "heg816",
                        "content": "find the highest value of (sorted_array[k+1] - sorted_array[k]) for some k s.t. 0 <= k < arr.length - 1"
                    },
                    {
                        "username": "ak_ydv",
                        "content": "why this question is marked as a hard ?"
                    },
                    {
                        "username": "benlong",
                        "content": "I've read about the bucket sort solution in the discuss. However, I find that the explanation to \"**the maximum gap absolutely exists between buckets**\" is not so clear to me. Thus I'm trying to give some thoughts from what I understand.\\n\\nFirst of all, let's assume that there are at least 2 number in the array. The smallest is min, biggest is max, and we use range to represent the difference between max and min (range = max - min). We use gapNum to denote the number of gaps in the array. Needless to say that gapNum = num.size() - 1. Thus we've got at least 1 gap. According to whether range could be divided by gapNum without remainder, this problem could be divided into 2 cases.\\n\\n(1). range could be completely divided. That is, range % gapNum == 0. In this case, bucketLen = range / gapNum, and bucketNum = gapNum + 1. For example, the input is [1, 101, 201, 301], thus range = 300, gapNum = 3, bucketLen = 100, bucketNum = 4. The 4 buckets will be: [1, 101), [101, 201), [201, 301), [301, 401). You might have noticed in this **perfect situation**, each number falls into a different bucket, and no numbers will share a bucket. So we could say, the max gap exists between the buckets.\\n\\nThis is also true when the gap between the numbers become uneven. As min and max are fixed, range and gapNum are both fixed. The current 3 gaps between the numbers are 100, 100, 100. When the middle numbers change, the 3 gaps between will change accordingly. But what's for sure is when some gaps become smaller than 100, some gaps will definitely become larger than 100, since they are bounded by the fixed range sum. For example, 50, 75, 175. or 101, 99, 100.  Under this condition, the biggest gap will be bigger than 100. Thus the two numbers constituting this gap cannot fall into the same bucket, since the biggest gap allowed in a single bucket is (bucketLen - 1) = 99. So when the gaps are uneven, the max gap exists between the buckets.\\n\\n(2). range could not be completely divided. That is, range % gapNum != 0. For example, 1, 4, 7, 11, 15. In this case, the most even gap arrangement is, some gaps are range / gapNum, while the other gaps are\\nrange / gapNum + 1. For our case, range = (15 - 1) = 14, gapNum = 4. Thus the most even arrangement is 3 3 4 4, or 3 4 3 4, or 4 3 3 4, and et al. Actually, for the sole sake of finding the max gap, we could choose either range / gapNum or range / gapNum + 1 as the buckeLen. \\n\\nSince bucketNum = range / bucketLen + 1, we will have one more bucket when choosing the smaller bucketLen than choosing the bigger bucketLen. For our example, when bucketLen = 3, bucketNum = 14 / 3 + 1 = 5. while when bucketLen = 4, 14 / 4 + 1 = 4. Their buckets are:\\n\\n3: [1, 4), [4, 7), [7, 10), [10, 13), [13, 16)\\n\\n4:[1, 5), [5, 9), [9, 13), [13, 17)\\n\\nIt can be seen that in either cases, the max gap will be found between buckets for the most even gap arrangements. The only difference is that the smaller bucketLen will guarantee each number fall in to a different bucket (3 > 3 - 1), while for the bigger bucketLen, those numbers with the small gap might fall into the same bucket (4 - 1 >= 3). But no matter how, we could always find the max gap between the buckets, since 4 > 3 - 1, and 4 > 4 - 1;\\n\\nFixing min and max, when the gaps become uneven, some gaps will be smaller, and some will correspondingly become larger, since their sum is fixed to range. For example, 2 4 4 4, or 1 3 5 5 for our case. When the max gap becomes larger than 4, it will definitely exist between buckets, since maxGap > 4 > 4 - 1;\\n\\nBut why don't we choose range / gapNum as the bucketLen in our algorithms? The answer is that range / gapNum might be zero for some cases. For example, assume the input array is 1 1 1 1 4. Here range / gapNum = 3 / 4 = 0. But bucketLen should at least be 1 for the solution to work. To deal with this issue, we typically choose bucketLen = range / gapNum + 1 to guarantee the validity of bucketLen. For this exmaple, bucketLen = 1, bucketNum = 4, and the buckets are: [1, 2), [2, 3), [3, 4), [4, 5), two of them will be empty. **But for those cases where the smaller one of the two even gaps is not zero, setting bucketLen to range / gapNum also works in the algorithm!**"
                    },
                    {
                        "username": "SunnyGupta",
                        "content": "I was able to understand the solution but there is one thing that is constantly making me to think Why we have not included min and max in the buckets that we have created???\\nPlease can someone answer with proper reasoning..\\nThanks in advance!"
                    },
                    {
                        "username": "zhoubowei",
                        "content": "It is O(kN) algorithm instead, depends on the numbers\\' range.\\nhttps://en.wikipedia.org/wiki/Radix_sort\\n"
                    }
                ]
            },
            {
                "id": 1566758,
                "content": [
                    {
                        "username": "Msey",
                        "content": "Well, I can handle Example2. Seems it\\'s a good start :)"
                    },
                    {
                        "username": "cartesPerforees",
                        "content": "Always a confidence booster to see that green light turned on for half the testcases on first try, until you look at what case it is"
                    },
                    {
                        "username": "changpro",
                        "content": "#### This \"hard\" problem is meaningless cause I see so many sort() in discuss, and they run really fast.\\n#### Actually it\\'s not a linear cause you don\\'t know what max element is right? There is no way to compare which one is faster  if the maxmum are much larger than the array\\'s length."
                    },
                    {
                        "username": "cartesPerforees",
                        "content": "I don't get your point. Of course if you cheat you can make the hard problem easier. It's specified in the statement you can;t use a sort (linear runtime). They can't automatically detect if you do, but who cares? If someone did it with a sort, they know they didn;t solve this question.\n\nAlso, why you screaming, bro?"
                    },
                    {
                        "username": "cartesPerforees",
                        "content": "[@HitenTandon](/HitenTandon) Hm? Yeah, but bucket sort doesn't suffer from that, afaik. I'm pretty sure my bucket-based solution is worst case O(n)"
                    },
                    {
                        "username": "HitenTandon",
                        "content": "You are right, radix sort has a time complexity of $$O(nlogR(maxElement) + RlogR(maxElement))$$.\n\nWhere, n is the number of elements in the array, R is the chosen radix, and maxElement is the maximum element.\n\nSo in theory the bigger Radix you chose the faster your algorithm runs, and that's why generally, a radix of 256 is used, which makes the worst case time complexity for the algorithm $$O(4(n + R))$$(here, since ints are 32 bits).\n\nIDK why all the people are using radix 2 or 10, because they don't really make much sense."
                    },
                    {
                        "username": "geekyshark",
                        "content": "Caution : Easy Problem marked Hard"
                    },
                    {
                        "username": "liubo0331",
                        "content": "The description \"maximum difference between the successive elements\" confuses me, because the successive elements could mean more than 2 elements that are successive."
                    },
                    {
                        "username": "_srahul_",
                        "content": "I don\\'t know why they can\\'t provide a good example."
                    },
                    {
                        "username": "fancyIX",
                        "content": "it's said \"Given an unsorted array, find the maximum difference between the successive elements in its sorted form.\"\\n\\nWhat does it mean by \"difference\"? What is the difference between the successive elements? What does \"in its sorted form\" mean?"
                    },
                    {
                        "username": "drMystico",
                        "content": "I guess that even in an unsorted array, there should exist a sorted subarray, and we need to return the maximum difference among that subarray's element, that was what I was able to decipher from the example"
                    },
                    {
                        "username": "heg816",
                        "content": "find the highest value of (sorted_array[k+1] - sorted_array[k]) for some k s.t. 0 <= k < arr.length - 1"
                    },
                    {
                        "username": "ak_ydv",
                        "content": "why this question is marked as a hard ?"
                    },
                    {
                        "username": "benlong",
                        "content": "I've read about the bucket sort solution in the discuss. However, I find that the explanation to \"**the maximum gap absolutely exists between buckets**\" is not so clear to me. Thus I'm trying to give some thoughts from what I understand.\\n\\nFirst of all, let's assume that there are at least 2 number in the array. The smallest is min, biggest is max, and we use range to represent the difference between max and min (range = max - min). We use gapNum to denote the number of gaps in the array. Needless to say that gapNum = num.size() - 1. Thus we've got at least 1 gap. According to whether range could be divided by gapNum without remainder, this problem could be divided into 2 cases.\\n\\n(1). range could be completely divided. That is, range % gapNum == 0. In this case, bucketLen = range / gapNum, and bucketNum = gapNum + 1. For example, the input is [1, 101, 201, 301], thus range = 300, gapNum = 3, bucketLen = 100, bucketNum = 4. The 4 buckets will be: [1, 101), [101, 201), [201, 301), [301, 401). You might have noticed in this **perfect situation**, each number falls into a different bucket, and no numbers will share a bucket. So we could say, the max gap exists between the buckets.\\n\\nThis is also true when the gap between the numbers become uneven. As min and max are fixed, range and gapNum are both fixed. The current 3 gaps between the numbers are 100, 100, 100. When the middle numbers change, the 3 gaps between will change accordingly. But what's for sure is when some gaps become smaller than 100, some gaps will definitely become larger than 100, since they are bounded by the fixed range sum. For example, 50, 75, 175. or 101, 99, 100.  Under this condition, the biggest gap will be bigger than 100. Thus the two numbers constituting this gap cannot fall into the same bucket, since the biggest gap allowed in a single bucket is (bucketLen - 1) = 99. So when the gaps are uneven, the max gap exists between the buckets.\\n\\n(2). range could not be completely divided. That is, range % gapNum != 0. For example, 1, 4, 7, 11, 15. In this case, the most even gap arrangement is, some gaps are range / gapNum, while the other gaps are\\nrange / gapNum + 1. For our case, range = (15 - 1) = 14, gapNum = 4. Thus the most even arrangement is 3 3 4 4, or 3 4 3 4, or 4 3 3 4, and et al. Actually, for the sole sake of finding the max gap, we could choose either range / gapNum or range / gapNum + 1 as the buckeLen. \\n\\nSince bucketNum = range / bucketLen + 1, we will have one more bucket when choosing the smaller bucketLen than choosing the bigger bucketLen. For our example, when bucketLen = 3, bucketNum = 14 / 3 + 1 = 5. while when bucketLen = 4, 14 / 4 + 1 = 4. Their buckets are:\\n\\n3: [1, 4), [4, 7), [7, 10), [10, 13), [13, 16)\\n\\n4:[1, 5), [5, 9), [9, 13), [13, 17)\\n\\nIt can be seen that in either cases, the max gap will be found between buckets for the most even gap arrangements. The only difference is that the smaller bucketLen will guarantee each number fall in to a different bucket (3 > 3 - 1), while for the bigger bucketLen, those numbers with the small gap might fall into the same bucket (4 - 1 >= 3). But no matter how, we could always find the max gap between the buckets, since 4 > 3 - 1, and 4 > 4 - 1;\\n\\nFixing min and max, when the gaps become uneven, some gaps will be smaller, and some will correspondingly become larger, since their sum is fixed to range. For example, 2 4 4 4, or 1 3 5 5 for our case. When the max gap becomes larger than 4, it will definitely exist between buckets, since maxGap > 4 > 4 - 1;\\n\\nBut why don't we choose range / gapNum as the bucketLen in our algorithms? The answer is that range / gapNum might be zero for some cases. For example, assume the input array is 1 1 1 1 4. Here range / gapNum = 3 / 4 = 0. But bucketLen should at least be 1 for the solution to work. To deal with this issue, we typically choose bucketLen = range / gapNum + 1 to guarantee the validity of bucketLen. For this exmaple, bucketLen = 1, bucketNum = 4, and the buckets are: [1, 2), [2, 3), [3, 4), [4, 5), two of them will be empty. **But for those cases where the smaller one of the two even gaps is not zero, setting bucketLen to range / gapNum also works in the algorithm!**"
                    },
                    {
                        "username": "SunnyGupta",
                        "content": "I was able to understand the solution but there is one thing that is constantly making me to think Why we have not included min and max in the buckets that we have created???\\nPlease can someone answer with proper reasoning..\\nThanks in advance!"
                    },
                    {
                        "username": "zhoubowei",
                        "content": "It is O(kN) algorithm instead, depends on the numbers\\' range.\\nhttps://en.wikipedia.org/wiki/Radix_sort\\n"
                    }
                ]
            },
            {
                "id": 2019688,
                "content": [
                    {
                        "username": "Msey",
                        "content": "Well, I can handle Example2. Seems it\\'s a good start :)"
                    },
                    {
                        "username": "cartesPerforees",
                        "content": "Always a confidence booster to see that green light turned on for half the testcases on first try, until you look at what case it is"
                    },
                    {
                        "username": "changpro",
                        "content": "#### This \"hard\" problem is meaningless cause I see so many sort() in discuss, and they run really fast.\\n#### Actually it\\'s not a linear cause you don\\'t know what max element is right? There is no way to compare which one is faster  if the maxmum are much larger than the array\\'s length."
                    },
                    {
                        "username": "cartesPerforees",
                        "content": "I don't get your point. Of course if you cheat you can make the hard problem easier. It's specified in the statement you can;t use a sort (linear runtime). They can't automatically detect if you do, but who cares? If someone did it with a sort, they know they didn;t solve this question.\n\nAlso, why you screaming, bro?"
                    },
                    {
                        "username": "cartesPerforees",
                        "content": "[@HitenTandon](/HitenTandon) Hm? Yeah, but bucket sort doesn't suffer from that, afaik. I'm pretty sure my bucket-based solution is worst case O(n)"
                    },
                    {
                        "username": "HitenTandon",
                        "content": "You are right, radix sort has a time complexity of $$O(nlogR(maxElement) + RlogR(maxElement))$$.\n\nWhere, n is the number of elements in the array, R is the chosen radix, and maxElement is the maximum element.\n\nSo in theory the bigger Radix you chose the faster your algorithm runs, and that's why generally, a radix of 256 is used, which makes the worst case time complexity for the algorithm $$O(4(n + R))$$(here, since ints are 32 bits).\n\nIDK why all the people are using radix 2 or 10, because they don't really make much sense."
                    },
                    {
                        "username": "geekyshark",
                        "content": "Caution : Easy Problem marked Hard"
                    },
                    {
                        "username": "liubo0331",
                        "content": "The description \"maximum difference between the successive elements\" confuses me, because the successive elements could mean more than 2 elements that are successive."
                    },
                    {
                        "username": "_srahul_",
                        "content": "I don\\'t know why they can\\'t provide a good example."
                    },
                    {
                        "username": "fancyIX",
                        "content": "it's said \"Given an unsorted array, find the maximum difference between the successive elements in its sorted form.\"\\n\\nWhat does it mean by \"difference\"? What is the difference between the successive elements? What does \"in its sorted form\" mean?"
                    },
                    {
                        "username": "drMystico",
                        "content": "I guess that even in an unsorted array, there should exist a sorted subarray, and we need to return the maximum difference among that subarray's element, that was what I was able to decipher from the example"
                    },
                    {
                        "username": "heg816",
                        "content": "find the highest value of (sorted_array[k+1] - sorted_array[k]) for some k s.t. 0 <= k < arr.length - 1"
                    },
                    {
                        "username": "ak_ydv",
                        "content": "why this question is marked as a hard ?"
                    },
                    {
                        "username": "benlong",
                        "content": "I've read about the bucket sort solution in the discuss. However, I find that the explanation to \"**the maximum gap absolutely exists between buckets**\" is not so clear to me. Thus I'm trying to give some thoughts from what I understand.\\n\\nFirst of all, let's assume that there are at least 2 number in the array. The smallest is min, biggest is max, and we use range to represent the difference between max and min (range = max - min). We use gapNum to denote the number of gaps in the array. Needless to say that gapNum = num.size() - 1. Thus we've got at least 1 gap. According to whether range could be divided by gapNum without remainder, this problem could be divided into 2 cases.\\n\\n(1). range could be completely divided. That is, range % gapNum == 0. In this case, bucketLen = range / gapNum, and bucketNum = gapNum + 1. For example, the input is [1, 101, 201, 301], thus range = 300, gapNum = 3, bucketLen = 100, bucketNum = 4. The 4 buckets will be: [1, 101), [101, 201), [201, 301), [301, 401). You might have noticed in this **perfect situation**, each number falls into a different bucket, and no numbers will share a bucket. So we could say, the max gap exists between the buckets.\\n\\nThis is also true when the gap between the numbers become uneven. As min and max are fixed, range and gapNum are both fixed. The current 3 gaps between the numbers are 100, 100, 100. When the middle numbers change, the 3 gaps between will change accordingly. But what's for sure is when some gaps become smaller than 100, some gaps will definitely become larger than 100, since they are bounded by the fixed range sum. For example, 50, 75, 175. or 101, 99, 100.  Under this condition, the biggest gap will be bigger than 100. Thus the two numbers constituting this gap cannot fall into the same bucket, since the biggest gap allowed in a single bucket is (bucketLen - 1) = 99. So when the gaps are uneven, the max gap exists between the buckets.\\n\\n(2). range could not be completely divided. That is, range % gapNum != 0. For example, 1, 4, 7, 11, 15. In this case, the most even gap arrangement is, some gaps are range / gapNum, while the other gaps are\\nrange / gapNum + 1. For our case, range = (15 - 1) = 14, gapNum = 4. Thus the most even arrangement is 3 3 4 4, or 3 4 3 4, or 4 3 3 4, and et al. Actually, for the sole sake of finding the max gap, we could choose either range / gapNum or range / gapNum + 1 as the buckeLen. \\n\\nSince bucketNum = range / bucketLen + 1, we will have one more bucket when choosing the smaller bucketLen than choosing the bigger bucketLen. For our example, when bucketLen = 3, bucketNum = 14 / 3 + 1 = 5. while when bucketLen = 4, 14 / 4 + 1 = 4. Their buckets are:\\n\\n3: [1, 4), [4, 7), [7, 10), [10, 13), [13, 16)\\n\\n4:[1, 5), [5, 9), [9, 13), [13, 17)\\n\\nIt can be seen that in either cases, the max gap will be found between buckets for the most even gap arrangements. The only difference is that the smaller bucketLen will guarantee each number fall in to a different bucket (3 > 3 - 1), while for the bigger bucketLen, those numbers with the small gap might fall into the same bucket (4 - 1 >= 3). But no matter how, we could always find the max gap between the buckets, since 4 > 3 - 1, and 4 > 4 - 1;\\n\\nFixing min and max, when the gaps become uneven, some gaps will be smaller, and some will correspondingly become larger, since their sum is fixed to range. For example, 2 4 4 4, or 1 3 5 5 for our case. When the max gap becomes larger than 4, it will definitely exist between buckets, since maxGap > 4 > 4 - 1;\\n\\nBut why don't we choose range / gapNum as the bucketLen in our algorithms? The answer is that range / gapNum might be zero for some cases. For example, assume the input array is 1 1 1 1 4. Here range / gapNum = 3 / 4 = 0. But bucketLen should at least be 1 for the solution to work. To deal with this issue, we typically choose bucketLen = range / gapNum + 1 to guarantee the validity of bucketLen. For this exmaple, bucketLen = 1, bucketNum = 4, and the buckets are: [1, 2), [2, 3), [3, 4), [4, 5), two of them will be empty. **But for those cases where the smaller one of the two even gaps is not zero, setting bucketLen to range / gapNum also works in the algorithm!**"
                    },
                    {
                        "username": "SunnyGupta",
                        "content": "I was able to understand the solution but there is one thing that is constantly making me to think Why we have not included min and max in the buckets that we have created???\\nPlease can someone answer with proper reasoning..\\nThanks in advance!"
                    },
                    {
                        "username": "zhoubowei",
                        "content": "It is O(kN) algorithm instead, depends on the numbers\\' range.\\nhttps://en.wikipedia.org/wiki/Radix_sort\\n"
                    }
                ]
            },
            {
                "id": 1571359,
                "content": [
                    {
                        "username": "Msey",
                        "content": "Well, I can handle Example2. Seems it\\'s a good start :)"
                    },
                    {
                        "username": "cartesPerforees",
                        "content": "Always a confidence booster to see that green light turned on for half the testcases on first try, until you look at what case it is"
                    },
                    {
                        "username": "changpro",
                        "content": "#### This \"hard\" problem is meaningless cause I see so many sort() in discuss, and they run really fast.\\n#### Actually it\\'s not a linear cause you don\\'t know what max element is right? There is no way to compare which one is faster  if the maxmum are much larger than the array\\'s length."
                    },
                    {
                        "username": "cartesPerforees",
                        "content": "I don't get your point. Of course if you cheat you can make the hard problem easier. It's specified in the statement you can;t use a sort (linear runtime). They can't automatically detect if you do, but who cares? If someone did it with a sort, they know they didn;t solve this question.\n\nAlso, why you screaming, bro?"
                    },
                    {
                        "username": "cartesPerforees",
                        "content": "[@HitenTandon](/HitenTandon) Hm? Yeah, but bucket sort doesn't suffer from that, afaik. I'm pretty sure my bucket-based solution is worst case O(n)"
                    },
                    {
                        "username": "HitenTandon",
                        "content": "You are right, radix sort has a time complexity of $$O(nlogR(maxElement) + RlogR(maxElement))$$.\n\nWhere, n is the number of elements in the array, R is the chosen radix, and maxElement is the maximum element.\n\nSo in theory the bigger Radix you chose the faster your algorithm runs, and that's why generally, a radix of 256 is used, which makes the worst case time complexity for the algorithm $$O(4(n + R))$$(here, since ints are 32 bits).\n\nIDK why all the people are using radix 2 or 10, because they don't really make much sense."
                    },
                    {
                        "username": "geekyshark",
                        "content": "Caution : Easy Problem marked Hard"
                    },
                    {
                        "username": "liubo0331",
                        "content": "The description \"maximum difference between the successive elements\" confuses me, because the successive elements could mean more than 2 elements that are successive."
                    },
                    {
                        "username": "_srahul_",
                        "content": "I don\\'t know why they can\\'t provide a good example."
                    },
                    {
                        "username": "fancyIX",
                        "content": "it's said \"Given an unsorted array, find the maximum difference between the successive elements in its sorted form.\"\\n\\nWhat does it mean by \"difference\"? What is the difference between the successive elements? What does \"in its sorted form\" mean?"
                    },
                    {
                        "username": "drMystico",
                        "content": "I guess that even in an unsorted array, there should exist a sorted subarray, and we need to return the maximum difference among that subarray's element, that was what I was able to decipher from the example"
                    },
                    {
                        "username": "heg816",
                        "content": "find the highest value of (sorted_array[k+1] - sorted_array[k]) for some k s.t. 0 <= k < arr.length - 1"
                    },
                    {
                        "username": "ak_ydv",
                        "content": "why this question is marked as a hard ?"
                    },
                    {
                        "username": "benlong",
                        "content": "I've read about the bucket sort solution in the discuss. However, I find that the explanation to \"**the maximum gap absolutely exists between buckets**\" is not so clear to me. Thus I'm trying to give some thoughts from what I understand.\\n\\nFirst of all, let's assume that there are at least 2 number in the array. The smallest is min, biggest is max, and we use range to represent the difference between max and min (range = max - min). We use gapNum to denote the number of gaps in the array. Needless to say that gapNum = num.size() - 1. Thus we've got at least 1 gap. According to whether range could be divided by gapNum without remainder, this problem could be divided into 2 cases.\\n\\n(1). range could be completely divided. That is, range % gapNum == 0. In this case, bucketLen = range / gapNum, and bucketNum = gapNum + 1. For example, the input is [1, 101, 201, 301], thus range = 300, gapNum = 3, bucketLen = 100, bucketNum = 4. The 4 buckets will be: [1, 101), [101, 201), [201, 301), [301, 401). You might have noticed in this **perfect situation**, each number falls into a different bucket, and no numbers will share a bucket. So we could say, the max gap exists between the buckets.\\n\\nThis is also true when the gap between the numbers become uneven. As min and max are fixed, range and gapNum are both fixed. The current 3 gaps between the numbers are 100, 100, 100. When the middle numbers change, the 3 gaps between will change accordingly. But what's for sure is when some gaps become smaller than 100, some gaps will definitely become larger than 100, since they are bounded by the fixed range sum. For example, 50, 75, 175. or 101, 99, 100.  Under this condition, the biggest gap will be bigger than 100. Thus the two numbers constituting this gap cannot fall into the same bucket, since the biggest gap allowed in a single bucket is (bucketLen - 1) = 99. So when the gaps are uneven, the max gap exists between the buckets.\\n\\n(2). range could not be completely divided. That is, range % gapNum != 0. For example, 1, 4, 7, 11, 15. In this case, the most even gap arrangement is, some gaps are range / gapNum, while the other gaps are\\nrange / gapNum + 1. For our case, range = (15 - 1) = 14, gapNum = 4. Thus the most even arrangement is 3 3 4 4, or 3 4 3 4, or 4 3 3 4, and et al. Actually, for the sole sake of finding the max gap, we could choose either range / gapNum or range / gapNum + 1 as the buckeLen. \\n\\nSince bucketNum = range / bucketLen + 1, we will have one more bucket when choosing the smaller bucketLen than choosing the bigger bucketLen. For our example, when bucketLen = 3, bucketNum = 14 / 3 + 1 = 5. while when bucketLen = 4, 14 / 4 + 1 = 4. Their buckets are:\\n\\n3: [1, 4), [4, 7), [7, 10), [10, 13), [13, 16)\\n\\n4:[1, 5), [5, 9), [9, 13), [13, 17)\\n\\nIt can be seen that in either cases, the max gap will be found between buckets for the most even gap arrangements. The only difference is that the smaller bucketLen will guarantee each number fall in to a different bucket (3 > 3 - 1), while for the bigger bucketLen, those numbers with the small gap might fall into the same bucket (4 - 1 >= 3). But no matter how, we could always find the max gap between the buckets, since 4 > 3 - 1, and 4 > 4 - 1;\\n\\nFixing min and max, when the gaps become uneven, some gaps will be smaller, and some will correspondingly become larger, since their sum is fixed to range. For example, 2 4 4 4, or 1 3 5 5 for our case. When the max gap becomes larger than 4, it will definitely exist between buckets, since maxGap > 4 > 4 - 1;\\n\\nBut why don't we choose range / gapNum as the bucketLen in our algorithms? The answer is that range / gapNum might be zero for some cases. For example, assume the input array is 1 1 1 1 4. Here range / gapNum = 3 / 4 = 0. But bucketLen should at least be 1 for the solution to work. To deal with this issue, we typically choose bucketLen = range / gapNum + 1 to guarantee the validity of bucketLen. For this exmaple, bucketLen = 1, bucketNum = 4, and the buckets are: [1, 2), [2, 3), [3, 4), [4, 5), two of them will be empty. **But for those cases where the smaller one of the two even gaps is not zero, setting bucketLen to range / gapNum also works in the algorithm!**"
                    },
                    {
                        "username": "SunnyGupta",
                        "content": "I was able to understand the solution but there is one thing that is constantly making me to think Why we have not included min and max in the buckets that we have created???\\nPlease can someone answer with proper reasoning..\\nThanks in advance!"
                    },
                    {
                        "username": "zhoubowei",
                        "content": "It is O(kN) algorithm instead, depends on the numbers\\' range.\\nhttps://en.wikipedia.org/wiki/Radix_sort\\n"
                    }
                ]
            },
            {
                "id": 1575340,
                "content": [
                    {
                        "username": "Msey",
                        "content": "Well, I can handle Example2. Seems it\\'s a good start :)"
                    },
                    {
                        "username": "cartesPerforees",
                        "content": "Always a confidence booster to see that green light turned on for half the testcases on first try, until you look at what case it is"
                    },
                    {
                        "username": "changpro",
                        "content": "#### This \"hard\" problem is meaningless cause I see so many sort() in discuss, and they run really fast.\\n#### Actually it\\'s not a linear cause you don\\'t know what max element is right? There is no way to compare which one is faster  if the maxmum are much larger than the array\\'s length."
                    },
                    {
                        "username": "cartesPerforees",
                        "content": "I don't get your point. Of course if you cheat you can make the hard problem easier. It's specified in the statement you can;t use a sort (linear runtime). They can't automatically detect if you do, but who cares? If someone did it with a sort, they know they didn;t solve this question.\n\nAlso, why you screaming, bro?"
                    },
                    {
                        "username": "cartesPerforees",
                        "content": "[@HitenTandon](/HitenTandon) Hm? Yeah, but bucket sort doesn't suffer from that, afaik. I'm pretty sure my bucket-based solution is worst case O(n)"
                    },
                    {
                        "username": "HitenTandon",
                        "content": "You are right, radix sort has a time complexity of $$O(nlogR(maxElement) + RlogR(maxElement))$$.\n\nWhere, n is the number of elements in the array, R is the chosen radix, and maxElement is the maximum element.\n\nSo in theory the bigger Radix you chose the faster your algorithm runs, and that's why generally, a radix of 256 is used, which makes the worst case time complexity for the algorithm $$O(4(n + R))$$(here, since ints are 32 bits).\n\nIDK why all the people are using radix 2 or 10, because they don't really make much sense."
                    },
                    {
                        "username": "geekyshark",
                        "content": "Caution : Easy Problem marked Hard"
                    },
                    {
                        "username": "liubo0331",
                        "content": "The description \"maximum difference between the successive elements\" confuses me, because the successive elements could mean more than 2 elements that are successive."
                    },
                    {
                        "username": "_srahul_",
                        "content": "I don\\'t know why they can\\'t provide a good example."
                    },
                    {
                        "username": "fancyIX",
                        "content": "it's said \"Given an unsorted array, find the maximum difference between the successive elements in its sorted form.\"\\n\\nWhat does it mean by \"difference\"? What is the difference between the successive elements? What does \"in its sorted form\" mean?"
                    },
                    {
                        "username": "drMystico",
                        "content": "I guess that even in an unsorted array, there should exist a sorted subarray, and we need to return the maximum difference among that subarray's element, that was what I was able to decipher from the example"
                    },
                    {
                        "username": "heg816",
                        "content": "find the highest value of (sorted_array[k+1] - sorted_array[k]) for some k s.t. 0 <= k < arr.length - 1"
                    },
                    {
                        "username": "ak_ydv",
                        "content": "why this question is marked as a hard ?"
                    },
                    {
                        "username": "benlong",
                        "content": "I've read about the bucket sort solution in the discuss. However, I find that the explanation to \"**the maximum gap absolutely exists between buckets**\" is not so clear to me. Thus I'm trying to give some thoughts from what I understand.\\n\\nFirst of all, let's assume that there are at least 2 number in the array. The smallest is min, biggest is max, and we use range to represent the difference between max and min (range = max - min). We use gapNum to denote the number of gaps in the array. Needless to say that gapNum = num.size() - 1. Thus we've got at least 1 gap. According to whether range could be divided by gapNum without remainder, this problem could be divided into 2 cases.\\n\\n(1). range could be completely divided. That is, range % gapNum == 0. In this case, bucketLen = range / gapNum, and bucketNum = gapNum + 1. For example, the input is [1, 101, 201, 301], thus range = 300, gapNum = 3, bucketLen = 100, bucketNum = 4. The 4 buckets will be: [1, 101), [101, 201), [201, 301), [301, 401). You might have noticed in this **perfect situation**, each number falls into a different bucket, and no numbers will share a bucket. So we could say, the max gap exists between the buckets.\\n\\nThis is also true when the gap between the numbers become uneven. As min and max are fixed, range and gapNum are both fixed. The current 3 gaps between the numbers are 100, 100, 100. When the middle numbers change, the 3 gaps between will change accordingly. But what's for sure is when some gaps become smaller than 100, some gaps will definitely become larger than 100, since they are bounded by the fixed range sum. For example, 50, 75, 175. or 101, 99, 100.  Under this condition, the biggest gap will be bigger than 100. Thus the two numbers constituting this gap cannot fall into the same bucket, since the biggest gap allowed in a single bucket is (bucketLen - 1) = 99. So when the gaps are uneven, the max gap exists between the buckets.\\n\\n(2). range could not be completely divided. That is, range % gapNum != 0. For example, 1, 4, 7, 11, 15. In this case, the most even gap arrangement is, some gaps are range / gapNum, while the other gaps are\\nrange / gapNum + 1. For our case, range = (15 - 1) = 14, gapNum = 4. Thus the most even arrangement is 3 3 4 4, or 3 4 3 4, or 4 3 3 4, and et al. Actually, for the sole sake of finding the max gap, we could choose either range / gapNum or range / gapNum + 1 as the buckeLen. \\n\\nSince bucketNum = range / bucketLen + 1, we will have one more bucket when choosing the smaller bucketLen than choosing the bigger bucketLen. For our example, when bucketLen = 3, bucketNum = 14 / 3 + 1 = 5. while when bucketLen = 4, 14 / 4 + 1 = 4. Their buckets are:\\n\\n3: [1, 4), [4, 7), [7, 10), [10, 13), [13, 16)\\n\\n4:[1, 5), [5, 9), [9, 13), [13, 17)\\n\\nIt can be seen that in either cases, the max gap will be found between buckets for the most even gap arrangements. The only difference is that the smaller bucketLen will guarantee each number fall in to a different bucket (3 > 3 - 1), while for the bigger bucketLen, those numbers with the small gap might fall into the same bucket (4 - 1 >= 3). But no matter how, we could always find the max gap between the buckets, since 4 > 3 - 1, and 4 > 4 - 1;\\n\\nFixing min and max, when the gaps become uneven, some gaps will be smaller, and some will correspondingly become larger, since their sum is fixed to range. For example, 2 4 4 4, or 1 3 5 5 for our case. When the max gap becomes larger than 4, it will definitely exist between buckets, since maxGap > 4 > 4 - 1;\\n\\nBut why don't we choose range / gapNum as the bucketLen in our algorithms? The answer is that range / gapNum might be zero for some cases. For example, assume the input array is 1 1 1 1 4. Here range / gapNum = 3 / 4 = 0. But bucketLen should at least be 1 for the solution to work. To deal with this issue, we typically choose bucketLen = range / gapNum + 1 to guarantee the validity of bucketLen. For this exmaple, bucketLen = 1, bucketNum = 4, and the buckets are: [1, 2), [2, 3), [3, 4), [4, 5), two of them will be empty. **But for those cases where the smaller one of the two even gaps is not zero, setting bucketLen to range / gapNum also works in the algorithm!**"
                    },
                    {
                        "username": "SunnyGupta",
                        "content": "I was able to understand the solution but there is one thing that is constantly making me to think Why we have not included min and max in the buckets that we have created???\\nPlease can someone answer with proper reasoning..\\nThanks in advance!"
                    },
                    {
                        "username": "zhoubowei",
                        "content": "It is O(kN) algorithm instead, depends on the numbers\\' range.\\nhttps://en.wikipedia.org/wiki/Radix_sort\\n"
                    }
                ]
            },
            {
                "id": 1571993,
                "content": [
                    {
                        "username": "Msey",
                        "content": "Well, I can handle Example2. Seems it\\'s a good start :)"
                    },
                    {
                        "username": "cartesPerforees",
                        "content": "Always a confidence booster to see that green light turned on for half the testcases on first try, until you look at what case it is"
                    },
                    {
                        "username": "changpro",
                        "content": "#### This \"hard\" problem is meaningless cause I see so many sort() in discuss, and they run really fast.\\n#### Actually it\\'s not a linear cause you don\\'t know what max element is right? There is no way to compare which one is faster  if the maxmum are much larger than the array\\'s length."
                    },
                    {
                        "username": "cartesPerforees",
                        "content": "I don't get your point. Of course if you cheat you can make the hard problem easier. It's specified in the statement you can;t use a sort (linear runtime). They can't automatically detect if you do, but who cares? If someone did it with a sort, they know they didn;t solve this question.\n\nAlso, why you screaming, bro?"
                    },
                    {
                        "username": "cartesPerforees",
                        "content": "[@HitenTandon](/HitenTandon) Hm? Yeah, but bucket sort doesn't suffer from that, afaik. I'm pretty sure my bucket-based solution is worst case O(n)"
                    },
                    {
                        "username": "HitenTandon",
                        "content": "You are right, radix sort has a time complexity of $$O(nlogR(maxElement) + RlogR(maxElement))$$.\n\nWhere, n is the number of elements in the array, R is the chosen radix, and maxElement is the maximum element.\n\nSo in theory the bigger Radix you chose the faster your algorithm runs, and that's why generally, a radix of 256 is used, which makes the worst case time complexity for the algorithm $$O(4(n + R))$$(here, since ints are 32 bits).\n\nIDK why all the people are using radix 2 or 10, because they don't really make much sense."
                    },
                    {
                        "username": "geekyshark",
                        "content": "Caution : Easy Problem marked Hard"
                    },
                    {
                        "username": "liubo0331",
                        "content": "The description \"maximum difference between the successive elements\" confuses me, because the successive elements could mean more than 2 elements that are successive."
                    },
                    {
                        "username": "_srahul_",
                        "content": "I don\\'t know why they can\\'t provide a good example."
                    },
                    {
                        "username": "fancyIX",
                        "content": "it's said \"Given an unsorted array, find the maximum difference between the successive elements in its sorted form.\"\\n\\nWhat does it mean by \"difference\"? What is the difference between the successive elements? What does \"in its sorted form\" mean?"
                    },
                    {
                        "username": "drMystico",
                        "content": "I guess that even in an unsorted array, there should exist a sorted subarray, and we need to return the maximum difference among that subarray's element, that was what I was able to decipher from the example"
                    },
                    {
                        "username": "heg816",
                        "content": "find the highest value of (sorted_array[k+1] - sorted_array[k]) for some k s.t. 0 <= k < arr.length - 1"
                    },
                    {
                        "username": "ak_ydv",
                        "content": "why this question is marked as a hard ?"
                    },
                    {
                        "username": "benlong",
                        "content": "I've read about the bucket sort solution in the discuss. However, I find that the explanation to \"**the maximum gap absolutely exists between buckets**\" is not so clear to me. Thus I'm trying to give some thoughts from what I understand.\\n\\nFirst of all, let's assume that there are at least 2 number in the array. The smallest is min, biggest is max, and we use range to represent the difference between max and min (range = max - min). We use gapNum to denote the number of gaps in the array. Needless to say that gapNum = num.size() - 1. Thus we've got at least 1 gap. According to whether range could be divided by gapNum without remainder, this problem could be divided into 2 cases.\\n\\n(1). range could be completely divided. That is, range % gapNum == 0. In this case, bucketLen = range / gapNum, and bucketNum = gapNum + 1. For example, the input is [1, 101, 201, 301], thus range = 300, gapNum = 3, bucketLen = 100, bucketNum = 4. The 4 buckets will be: [1, 101), [101, 201), [201, 301), [301, 401). You might have noticed in this **perfect situation**, each number falls into a different bucket, and no numbers will share a bucket. So we could say, the max gap exists between the buckets.\\n\\nThis is also true when the gap between the numbers become uneven. As min and max are fixed, range and gapNum are both fixed. The current 3 gaps between the numbers are 100, 100, 100. When the middle numbers change, the 3 gaps between will change accordingly. But what's for sure is when some gaps become smaller than 100, some gaps will definitely become larger than 100, since they are bounded by the fixed range sum. For example, 50, 75, 175. or 101, 99, 100.  Under this condition, the biggest gap will be bigger than 100. Thus the two numbers constituting this gap cannot fall into the same bucket, since the biggest gap allowed in a single bucket is (bucketLen - 1) = 99. So when the gaps are uneven, the max gap exists between the buckets.\\n\\n(2). range could not be completely divided. That is, range % gapNum != 0. For example, 1, 4, 7, 11, 15. In this case, the most even gap arrangement is, some gaps are range / gapNum, while the other gaps are\\nrange / gapNum + 1. For our case, range = (15 - 1) = 14, gapNum = 4. Thus the most even arrangement is 3 3 4 4, or 3 4 3 4, or 4 3 3 4, and et al. Actually, for the sole sake of finding the max gap, we could choose either range / gapNum or range / gapNum + 1 as the buckeLen. \\n\\nSince bucketNum = range / bucketLen + 1, we will have one more bucket when choosing the smaller bucketLen than choosing the bigger bucketLen. For our example, when bucketLen = 3, bucketNum = 14 / 3 + 1 = 5. while when bucketLen = 4, 14 / 4 + 1 = 4. Their buckets are:\\n\\n3: [1, 4), [4, 7), [7, 10), [10, 13), [13, 16)\\n\\n4:[1, 5), [5, 9), [9, 13), [13, 17)\\n\\nIt can be seen that in either cases, the max gap will be found between buckets for the most even gap arrangements. The only difference is that the smaller bucketLen will guarantee each number fall in to a different bucket (3 > 3 - 1), while for the bigger bucketLen, those numbers with the small gap might fall into the same bucket (4 - 1 >= 3). But no matter how, we could always find the max gap between the buckets, since 4 > 3 - 1, and 4 > 4 - 1;\\n\\nFixing min and max, when the gaps become uneven, some gaps will be smaller, and some will correspondingly become larger, since their sum is fixed to range. For example, 2 4 4 4, or 1 3 5 5 for our case. When the max gap becomes larger than 4, it will definitely exist between buckets, since maxGap > 4 > 4 - 1;\\n\\nBut why don't we choose range / gapNum as the bucketLen in our algorithms? The answer is that range / gapNum might be zero for some cases. For example, assume the input array is 1 1 1 1 4. Here range / gapNum = 3 / 4 = 0. But bucketLen should at least be 1 for the solution to work. To deal with this issue, we typically choose bucketLen = range / gapNum + 1 to guarantee the validity of bucketLen. For this exmaple, bucketLen = 1, bucketNum = 4, and the buckets are: [1, 2), [2, 3), [3, 4), [4, 5), two of them will be empty. **But for those cases where the smaller one of the two even gaps is not zero, setting bucketLen to range / gapNum also works in the algorithm!**"
                    },
                    {
                        "username": "SunnyGupta",
                        "content": "I was able to understand the solution but there is one thing that is constantly making me to think Why we have not included min and max in the buckets that we have created???\\nPlease can someone answer with proper reasoning..\\nThanks in advance!"
                    },
                    {
                        "username": "zhoubowei",
                        "content": "It is O(kN) algorithm instead, depends on the numbers\\' range.\\nhttps://en.wikipedia.org/wiki/Radix_sort\\n"
                    }
                ]
            },
            {
                "id": 1853589,
                "content": [
                    {
                        "username": "Msey",
                        "content": "Well, I can handle Example2. Seems it\\'s a good start :)"
                    },
                    {
                        "username": "cartesPerforees",
                        "content": "Always a confidence booster to see that green light turned on for half the testcases on first try, until you look at what case it is"
                    },
                    {
                        "username": "changpro",
                        "content": "#### This \"hard\" problem is meaningless cause I see so many sort() in discuss, and they run really fast.\\n#### Actually it\\'s not a linear cause you don\\'t know what max element is right? There is no way to compare which one is faster  if the maxmum are much larger than the array\\'s length."
                    },
                    {
                        "username": "cartesPerforees",
                        "content": "I don't get your point. Of course if you cheat you can make the hard problem easier. It's specified in the statement you can;t use a sort (linear runtime). They can't automatically detect if you do, but who cares? If someone did it with a sort, they know they didn;t solve this question.\n\nAlso, why you screaming, bro?"
                    },
                    {
                        "username": "cartesPerforees",
                        "content": "[@HitenTandon](/HitenTandon) Hm? Yeah, but bucket sort doesn't suffer from that, afaik. I'm pretty sure my bucket-based solution is worst case O(n)"
                    },
                    {
                        "username": "HitenTandon",
                        "content": "You are right, radix sort has a time complexity of $$O(nlogR(maxElement) + RlogR(maxElement))$$.\n\nWhere, n is the number of elements in the array, R is the chosen radix, and maxElement is the maximum element.\n\nSo in theory the bigger Radix you chose the faster your algorithm runs, and that's why generally, a radix of 256 is used, which makes the worst case time complexity for the algorithm $$O(4(n + R))$$(here, since ints are 32 bits).\n\nIDK why all the people are using radix 2 or 10, because they don't really make much sense."
                    },
                    {
                        "username": "geekyshark",
                        "content": "Caution : Easy Problem marked Hard"
                    },
                    {
                        "username": "liubo0331",
                        "content": "The description \"maximum difference between the successive elements\" confuses me, because the successive elements could mean more than 2 elements that are successive."
                    },
                    {
                        "username": "_srahul_",
                        "content": "I don\\'t know why they can\\'t provide a good example."
                    },
                    {
                        "username": "fancyIX",
                        "content": "it's said \"Given an unsorted array, find the maximum difference between the successive elements in its sorted form.\"\\n\\nWhat does it mean by \"difference\"? What is the difference between the successive elements? What does \"in its sorted form\" mean?"
                    },
                    {
                        "username": "drMystico",
                        "content": "I guess that even in an unsorted array, there should exist a sorted subarray, and we need to return the maximum difference among that subarray's element, that was what I was able to decipher from the example"
                    },
                    {
                        "username": "heg816",
                        "content": "find the highest value of (sorted_array[k+1] - sorted_array[k]) for some k s.t. 0 <= k < arr.length - 1"
                    },
                    {
                        "username": "ak_ydv",
                        "content": "why this question is marked as a hard ?"
                    },
                    {
                        "username": "benlong",
                        "content": "I've read about the bucket sort solution in the discuss. However, I find that the explanation to \"**the maximum gap absolutely exists between buckets**\" is not so clear to me. Thus I'm trying to give some thoughts from what I understand.\\n\\nFirst of all, let's assume that there are at least 2 number in the array. The smallest is min, biggest is max, and we use range to represent the difference between max and min (range = max - min). We use gapNum to denote the number of gaps in the array. Needless to say that gapNum = num.size() - 1. Thus we've got at least 1 gap. According to whether range could be divided by gapNum without remainder, this problem could be divided into 2 cases.\\n\\n(1). range could be completely divided. That is, range % gapNum == 0. In this case, bucketLen = range / gapNum, and bucketNum = gapNum + 1. For example, the input is [1, 101, 201, 301], thus range = 300, gapNum = 3, bucketLen = 100, bucketNum = 4. The 4 buckets will be: [1, 101), [101, 201), [201, 301), [301, 401). You might have noticed in this **perfect situation**, each number falls into a different bucket, and no numbers will share a bucket. So we could say, the max gap exists between the buckets.\\n\\nThis is also true when the gap between the numbers become uneven. As min and max are fixed, range and gapNum are both fixed. The current 3 gaps between the numbers are 100, 100, 100. When the middle numbers change, the 3 gaps between will change accordingly. But what's for sure is when some gaps become smaller than 100, some gaps will definitely become larger than 100, since they are bounded by the fixed range sum. For example, 50, 75, 175. or 101, 99, 100.  Under this condition, the biggest gap will be bigger than 100. Thus the two numbers constituting this gap cannot fall into the same bucket, since the biggest gap allowed in a single bucket is (bucketLen - 1) = 99. So when the gaps are uneven, the max gap exists between the buckets.\\n\\n(2). range could not be completely divided. That is, range % gapNum != 0. For example, 1, 4, 7, 11, 15. In this case, the most even gap arrangement is, some gaps are range / gapNum, while the other gaps are\\nrange / gapNum + 1. For our case, range = (15 - 1) = 14, gapNum = 4. Thus the most even arrangement is 3 3 4 4, or 3 4 3 4, or 4 3 3 4, and et al. Actually, for the sole sake of finding the max gap, we could choose either range / gapNum or range / gapNum + 1 as the buckeLen. \\n\\nSince bucketNum = range / bucketLen + 1, we will have one more bucket when choosing the smaller bucketLen than choosing the bigger bucketLen. For our example, when bucketLen = 3, bucketNum = 14 / 3 + 1 = 5. while when bucketLen = 4, 14 / 4 + 1 = 4. Their buckets are:\\n\\n3: [1, 4), [4, 7), [7, 10), [10, 13), [13, 16)\\n\\n4:[1, 5), [5, 9), [9, 13), [13, 17)\\n\\nIt can be seen that in either cases, the max gap will be found between buckets for the most even gap arrangements. The only difference is that the smaller bucketLen will guarantee each number fall in to a different bucket (3 > 3 - 1), while for the bigger bucketLen, those numbers with the small gap might fall into the same bucket (4 - 1 >= 3). But no matter how, we could always find the max gap between the buckets, since 4 > 3 - 1, and 4 > 4 - 1;\\n\\nFixing min and max, when the gaps become uneven, some gaps will be smaller, and some will correspondingly become larger, since their sum is fixed to range. For example, 2 4 4 4, or 1 3 5 5 for our case. When the max gap becomes larger than 4, it will definitely exist between buckets, since maxGap > 4 > 4 - 1;\\n\\nBut why don't we choose range / gapNum as the bucketLen in our algorithms? The answer is that range / gapNum might be zero for some cases. For example, assume the input array is 1 1 1 1 4. Here range / gapNum = 3 / 4 = 0. But bucketLen should at least be 1 for the solution to work. To deal with this issue, we typically choose bucketLen = range / gapNum + 1 to guarantee the validity of bucketLen. For this exmaple, bucketLen = 1, bucketNum = 4, and the buckets are: [1, 2), [2, 3), [3, 4), [4, 5), two of them will be empty. **But for those cases where the smaller one of the two even gaps is not zero, setting bucketLen to range / gapNum also works in the algorithm!**"
                    },
                    {
                        "username": "SunnyGupta",
                        "content": "I was able to understand the solution but there is one thing that is constantly making me to think Why we have not included min and max in the buckets that we have created???\\nPlease can someone answer with proper reasoning..\\nThanks in advance!"
                    },
                    {
                        "username": "zhoubowei",
                        "content": "It is O(kN) algorithm instead, depends on the numbers\\' range.\\nhttps://en.wikipedia.org/wiki/Radix_sort\\n"
                    }
                ]
            },
            {
                "id": 1567469,
                "content": [
                    {
                        "username": "Msey",
                        "content": "Well, I can handle Example2. Seems it\\'s a good start :)"
                    },
                    {
                        "username": "cartesPerforees",
                        "content": "Always a confidence booster to see that green light turned on for half the testcases on first try, until you look at what case it is"
                    },
                    {
                        "username": "changpro",
                        "content": "#### This \"hard\" problem is meaningless cause I see so many sort() in discuss, and they run really fast.\\n#### Actually it\\'s not a linear cause you don\\'t know what max element is right? There is no way to compare which one is faster  if the maxmum are much larger than the array\\'s length."
                    },
                    {
                        "username": "cartesPerforees",
                        "content": "I don't get your point. Of course if you cheat you can make the hard problem easier. It's specified in the statement you can;t use a sort (linear runtime). They can't automatically detect if you do, but who cares? If someone did it with a sort, they know they didn;t solve this question.\n\nAlso, why you screaming, bro?"
                    },
                    {
                        "username": "cartesPerforees",
                        "content": "[@HitenTandon](/HitenTandon) Hm? Yeah, but bucket sort doesn't suffer from that, afaik. I'm pretty sure my bucket-based solution is worst case O(n)"
                    },
                    {
                        "username": "HitenTandon",
                        "content": "You are right, radix sort has a time complexity of $$O(nlogR(maxElement) + RlogR(maxElement))$$.\n\nWhere, n is the number of elements in the array, R is the chosen radix, and maxElement is the maximum element.\n\nSo in theory the bigger Radix you chose the faster your algorithm runs, and that's why generally, a radix of 256 is used, which makes the worst case time complexity for the algorithm $$O(4(n + R))$$(here, since ints are 32 bits).\n\nIDK why all the people are using radix 2 or 10, because they don't really make much sense."
                    },
                    {
                        "username": "geekyshark",
                        "content": "Caution : Easy Problem marked Hard"
                    },
                    {
                        "username": "liubo0331",
                        "content": "The description \"maximum difference between the successive elements\" confuses me, because the successive elements could mean more than 2 elements that are successive."
                    },
                    {
                        "username": "_srahul_",
                        "content": "I don\\'t know why they can\\'t provide a good example."
                    },
                    {
                        "username": "fancyIX",
                        "content": "it's said \"Given an unsorted array, find the maximum difference between the successive elements in its sorted form.\"\\n\\nWhat does it mean by \"difference\"? What is the difference between the successive elements? What does \"in its sorted form\" mean?"
                    },
                    {
                        "username": "drMystico",
                        "content": "I guess that even in an unsorted array, there should exist a sorted subarray, and we need to return the maximum difference among that subarray's element, that was what I was able to decipher from the example"
                    },
                    {
                        "username": "heg816",
                        "content": "find the highest value of (sorted_array[k+1] - sorted_array[k]) for some k s.t. 0 <= k < arr.length - 1"
                    },
                    {
                        "username": "ak_ydv",
                        "content": "why this question is marked as a hard ?"
                    },
                    {
                        "username": "benlong",
                        "content": "I've read about the bucket sort solution in the discuss. However, I find that the explanation to \"**the maximum gap absolutely exists between buckets**\" is not so clear to me. Thus I'm trying to give some thoughts from what I understand.\\n\\nFirst of all, let's assume that there are at least 2 number in the array. The smallest is min, biggest is max, and we use range to represent the difference between max and min (range = max - min). We use gapNum to denote the number of gaps in the array. Needless to say that gapNum = num.size() - 1. Thus we've got at least 1 gap. According to whether range could be divided by gapNum without remainder, this problem could be divided into 2 cases.\\n\\n(1). range could be completely divided. That is, range % gapNum == 0. In this case, bucketLen = range / gapNum, and bucketNum = gapNum + 1. For example, the input is [1, 101, 201, 301], thus range = 300, gapNum = 3, bucketLen = 100, bucketNum = 4. The 4 buckets will be: [1, 101), [101, 201), [201, 301), [301, 401). You might have noticed in this **perfect situation**, each number falls into a different bucket, and no numbers will share a bucket. So we could say, the max gap exists between the buckets.\\n\\nThis is also true when the gap between the numbers become uneven. As min and max are fixed, range and gapNum are both fixed. The current 3 gaps between the numbers are 100, 100, 100. When the middle numbers change, the 3 gaps between will change accordingly. But what's for sure is when some gaps become smaller than 100, some gaps will definitely become larger than 100, since they are bounded by the fixed range sum. For example, 50, 75, 175. or 101, 99, 100.  Under this condition, the biggest gap will be bigger than 100. Thus the two numbers constituting this gap cannot fall into the same bucket, since the biggest gap allowed in a single bucket is (bucketLen - 1) = 99. So when the gaps are uneven, the max gap exists between the buckets.\\n\\n(2). range could not be completely divided. That is, range % gapNum != 0. For example, 1, 4, 7, 11, 15. In this case, the most even gap arrangement is, some gaps are range / gapNum, while the other gaps are\\nrange / gapNum + 1. For our case, range = (15 - 1) = 14, gapNum = 4. Thus the most even arrangement is 3 3 4 4, or 3 4 3 4, or 4 3 3 4, and et al. Actually, for the sole sake of finding the max gap, we could choose either range / gapNum or range / gapNum + 1 as the buckeLen. \\n\\nSince bucketNum = range / bucketLen + 1, we will have one more bucket when choosing the smaller bucketLen than choosing the bigger bucketLen. For our example, when bucketLen = 3, bucketNum = 14 / 3 + 1 = 5. while when bucketLen = 4, 14 / 4 + 1 = 4. Their buckets are:\\n\\n3: [1, 4), [4, 7), [7, 10), [10, 13), [13, 16)\\n\\n4:[1, 5), [5, 9), [9, 13), [13, 17)\\n\\nIt can be seen that in either cases, the max gap will be found between buckets for the most even gap arrangements. The only difference is that the smaller bucketLen will guarantee each number fall in to a different bucket (3 > 3 - 1), while for the bigger bucketLen, those numbers with the small gap might fall into the same bucket (4 - 1 >= 3). But no matter how, we could always find the max gap between the buckets, since 4 > 3 - 1, and 4 > 4 - 1;\\n\\nFixing min and max, when the gaps become uneven, some gaps will be smaller, and some will correspondingly become larger, since their sum is fixed to range. For example, 2 4 4 4, or 1 3 5 5 for our case. When the max gap becomes larger than 4, it will definitely exist between buckets, since maxGap > 4 > 4 - 1;\\n\\nBut why don't we choose range / gapNum as the bucketLen in our algorithms? The answer is that range / gapNum might be zero for some cases. For example, assume the input array is 1 1 1 1 4. Here range / gapNum = 3 / 4 = 0. But bucketLen should at least be 1 for the solution to work. To deal with this issue, we typically choose bucketLen = range / gapNum + 1 to guarantee the validity of bucketLen. For this exmaple, bucketLen = 1, bucketNum = 4, and the buckets are: [1, 2), [2, 3), [3, 4), [4, 5), two of them will be empty. **But for those cases where the smaller one of the two even gaps is not zero, setting bucketLen to range / gapNum also works in the algorithm!**"
                    },
                    {
                        "username": "SunnyGupta",
                        "content": "I was able to understand the solution but there is one thing that is constantly making me to think Why we have not included min and max in the buckets that we have created???\\nPlease can someone answer with proper reasoning..\\nThanks in advance!"
                    },
                    {
                        "username": "zhoubowei",
                        "content": "It is O(kN) algorithm instead, depends on the numbers\\' range.\\nhttps://en.wikipedia.org/wiki/Radix_sort\\n"
                    }
                ]
            },
            {
                "id": 1966139,
                "content": [
                    {
                        "username": "Msey",
                        "content": "Well, I can handle Example2. Seems it\\'s a good start :)"
                    },
                    {
                        "username": "cartesPerforees",
                        "content": "Always a confidence booster to see that green light turned on for half the testcases on first try, until you look at what case it is"
                    },
                    {
                        "username": "changpro",
                        "content": "#### This \"hard\" problem is meaningless cause I see so many sort() in discuss, and they run really fast.\\n#### Actually it\\'s not a linear cause you don\\'t know what max element is right? There is no way to compare which one is faster  if the maxmum are much larger than the array\\'s length."
                    },
                    {
                        "username": "cartesPerforees",
                        "content": "I don't get your point. Of course if you cheat you can make the hard problem easier. It's specified in the statement you can;t use a sort (linear runtime). They can't automatically detect if you do, but who cares? If someone did it with a sort, they know they didn;t solve this question.\n\nAlso, why you screaming, bro?"
                    },
                    {
                        "username": "cartesPerforees",
                        "content": "[@HitenTandon](/HitenTandon) Hm? Yeah, but bucket sort doesn't suffer from that, afaik. I'm pretty sure my bucket-based solution is worst case O(n)"
                    },
                    {
                        "username": "HitenTandon",
                        "content": "You are right, radix sort has a time complexity of $$O(nlogR(maxElement) + RlogR(maxElement))$$.\n\nWhere, n is the number of elements in the array, R is the chosen radix, and maxElement is the maximum element.\n\nSo in theory the bigger Radix you chose the faster your algorithm runs, and that's why generally, a radix of 256 is used, which makes the worst case time complexity for the algorithm $$O(4(n + R))$$(here, since ints are 32 bits).\n\nIDK why all the people are using radix 2 or 10, because they don't really make much sense."
                    },
                    {
                        "username": "geekyshark",
                        "content": "Caution : Easy Problem marked Hard"
                    },
                    {
                        "username": "liubo0331",
                        "content": "The description \"maximum difference between the successive elements\" confuses me, because the successive elements could mean more than 2 elements that are successive."
                    },
                    {
                        "username": "_srahul_",
                        "content": "I don\\'t know why they can\\'t provide a good example."
                    },
                    {
                        "username": "fancyIX",
                        "content": "it's said \"Given an unsorted array, find the maximum difference between the successive elements in its sorted form.\"\\n\\nWhat does it mean by \"difference\"? What is the difference between the successive elements? What does \"in its sorted form\" mean?"
                    },
                    {
                        "username": "drMystico",
                        "content": "I guess that even in an unsorted array, there should exist a sorted subarray, and we need to return the maximum difference among that subarray's element, that was what I was able to decipher from the example"
                    },
                    {
                        "username": "heg816",
                        "content": "find the highest value of (sorted_array[k+1] - sorted_array[k]) for some k s.t. 0 <= k < arr.length - 1"
                    },
                    {
                        "username": "ak_ydv",
                        "content": "why this question is marked as a hard ?"
                    },
                    {
                        "username": "benlong",
                        "content": "I've read about the bucket sort solution in the discuss. However, I find that the explanation to \"**the maximum gap absolutely exists between buckets**\" is not so clear to me. Thus I'm trying to give some thoughts from what I understand.\\n\\nFirst of all, let's assume that there are at least 2 number in the array. The smallest is min, biggest is max, and we use range to represent the difference between max and min (range = max - min). We use gapNum to denote the number of gaps in the array. Needless to say that gapNum = num.size() - 1. Thus we've got at least 1 gap. According to whether range could be divided by gapNum without remainder, this problem could be divided into 2 cases.\\n\\n(1). range could be completely divided. That is, range % gapNum == 0. In this case, bucketLen = range / gapNum, and bucketNum = gapNum + 1. For example, the input is [1, 101, 201, 301], thus range = 300, gapNum = 3, bucketLen = 100, bucketNum = 4. The 4 buckets will be: [1, 101), [101, 201), [201, 301), [301, 401). You might have noticed in this **perfect situation**, each number falls into a different bucket, and no numbers will share a bucket. So we could say, the max gap exists between the buckets.\\n\\nThis is also true when the gap between the numbers become uneven. As min and max are fixed, range and gapNum are both fixed. The current 3 gaps between the numbers are 100, 100, 100. When the middle numbers change, the 3 gaps between will change accordingly. But what's for sure is when some gaps become smaller than 100, some gaps will definitely become larger than 100, since they are bounded by the fixed range sum. For example, 50, 75, 175. or 101, 99, 100.  Under this condition, the biggest gap will be bigger than 100. Thus the two numbers constituting this gap cannot fall into the same bucket, since the biggest gap allowed in a single bucket is (bucketLen - 1) = 99. So when the gaps are uneven, the max gap exists between the buckets.\\n\\n(2). range could not be completely divided. That is, range % gapNum != 0. For example, 1, 4, 7, 11, 15. In this case, the most even gap arrangement is, some gaps are range / gapNum, while the other gaps are\\nrange / gapNum + 1. For our case, range = (15 - 1) = 14, gapNum = 4. Thus the most even arrangement is 3 3 4 4, or 3 4 3 4, or 4 3 3 4, and et al. Actually, for the sole sake of finding the max gap, we could choose either range / gapNum or range / gapNum + 1 as the buckeLen. \\n\\nSince bucketNum = range / bucketLen + 1, we will have one more bucket when choosing the smaller bucketLen than choosing the bigger bucketLen. For our example, when bucketLen = 3, bucketNum = 14 / 3 + 1 = 5. while when bucketLen = 4, 14 / 4 + 1 = 4. Their buckets are:\\n\\n3: [1, 4), [4, 7), [7, 10), [10, 13), [13, 16)\\n\\n4:[1, 5), [5, 9), [9, 13), [13, 17)\\n\\nIt can be seen that in either cases, the max gap will be found between buckets for the most even gap arrangements. The only difference is that the smaller bucketLen will guarantee each number fall in to a different bucket (3 > 3 - 1), while for the bigger bucketLen, those numbers with the small gap might fall into the same bucket (4 - 1 >= 3). But no matter how, we could always find the max gap between the buckets, since 4 > 3 - 1, and 4 > 4 - 1;\\n\\nFixing min and max, when the gaps become uneven, some gaps will be smaller, and some will correspondingly become larger, since their sum is fixed to range. For example, 2 4 4 4, or 1 3 5 5 for our case. When the max gap becomes larger than 4, it will definitely exist between buckets, since maxGap > 4 > 4 - 1;\\n\\nBut why don't we choose range / gapNum as the bucketLen in our algorithms? The answer is that range / gapNum might be zero for some cases. For example, assume the input array is 1 1 1 1 4. Here range / gapNum = 3 / 4 = 0. But bucketLen should at least be 1 for the solution to work. To deal with this issue, we typically choose bucketLen = range / gapNum + 1 to guarantee the validity of bucketLen. For this exmaple, bucketLen = 1, bucketNum = 4, and the buckets are: [1, 2), [2, 3), [3, 4), [4, 5), two of them will be empty. **But for those cases where the smaller one of the two even gaps is not zero, setting bucketLen to range / gapNum also works in the algorithm!**"
                    },
                    {
                        "username": "SunnyGupta",
                        "content": "I was able to understand the solution but there is one thing that is constantly making me to think Why we have not included min and max in the buckets that we have created???\\nPlease can someone answer with proper reasoning..\\nThanks in advance!"
                    },
                    {
                        "username": "zhoubowei",
                        "content": "It is O(kN) algorithm instead, depends on the numbers\\' range.\\nhttps://en.wikipedia.org/wiki/Radix_sort\\n"
                    }
                ]
            },
            {
                "id": 1566077,
                "content": [
                    {
                        "username": "Msey",
                        "content": "Well, I can handle Example2. Seems it\\'s a good start :)"
                    },
                    {
                        "username": "cartesPerforees",
                        "content": "Always a confidence booster to see that green light turned on for half the testcases on first try, until you look at what case it is"
                    },
                    {
                        "username": "changpro",
                        "content": "#### This \"hard\" problem is meaningless cause I see so many sort() in discuss, and they run really fast.\\n#### Actually it\\'s not a linear cause you don\\'t know what max element is right? There is no way to compare which one is faster  if the maxmum are much larger than the array\\'s length."
                    },
                    {
                        "username": "cartesPerforees",
                        "content": "I don't get your point. Of course if you cheat you can make the hard problem easier. It's specified in the statement you can;t use a sort (linear runtime). They can't automatically detect if you do, but who cares? If someone did it with a sort, they know they didn;t solve this question.\n\nAlso, why you screaming, bro?"
                    },
                    {
                        "username": "cartesPerforees",
                        "content": "[@HitenTandon](/HitenTandon) Hm? Yeah, but bucket sort doesn't suffer from that, afaik. I'm pretty sure my bucket-based solution is worst case O(n)"
                    },
                    {
                        "username": "HitenTandon",
                        "content": "You are right, radix sort has a time complexity of $$O(nlogR(maxElement) + RlogR(maxElement))$$.\n\nWhere, n is the number of elements in the array, R is the chosen radix, and maxElement is the maximum element.\n\nSo in theory the bigger Radix you chose the faster your algorithm runs, and that's why generally, a radix of 256 is used, which makes the worst case time complexity for the algorithm $$O(4(n + R))$$(here, since ints are 32 bits).\n\nIDK why all the people are using radix 2 or 10, because they don't really make much sense."
                    },
                    {
                        "username": "geekyshark",
                        "content": "Caution : Easy Problem marked Hard"
                    },
                    {
                        "username": "liubo0331",
                        "content": "The description \"maximum difference between the successive elements\" confuses me, because the successive elements could mean more than 2 elements that are successive."
                    },
                    {
                        "username": "_srahul_",
                        "content": "I don\\'t know why they can\\'t provide a good example."
                    },
                    {
                        "username": "fancyIX",
                        "content": "it's said \"Given an unsorted array, find the maximum difference between the successive elements in its sorted form.\"\\n\\nWhat does it mean by \"difference\"? What is the difference between the successive elements? What does \"in its sorted form\" mean?"
                    },
                    {
                        "username": "drMystico",
                        "content": "I guess that even in an unsorted array, there should exist a sorted subarray, and we need to return the maximum difference among that subarray's element, that was what I was able to decipher from the example"
                    },
                    {
                        "username": "heg816",
                        "content": "find the highest value of (sorted_array[k+1] - sorted_array[k]) for some k s.t. 0 <= k < arr.length - 1"
                    },
                    {
                        "username": "ak_ydv",
                        "content": "why this question is marked as a hard ?"
                    },
                    {
                        "username": "benlong",
                        "content": "I've read about the bucket sort solution in the discuss. However, I find that the explanation to \"**the maximum gap absolutely exists between buckets**\" is not so clear to me. Thus I'm trying to give some thoughts from what I understand.\\n\\nFirst of all, let's assume that there are at least 2 number in the array. The smallest is min, biggest is max, and we use range to represent the difference between max and min (range = max - min). We use gapNum to denote the number of gaps in the array. Needless to say that gapNum = num.size() - 1. Thus we've got at least 1 gap. According to whether range could be divided by gapNum without remainder, this problem could be divided into 2 cases.\\n\\n(1). range could be completely divided. That is, range % gapNum == 0. In this case, bucketLen = range / gapNum, and bucketNum = gapNum + 1. For example, the input is [1, 101, 201, 301], thus range = 300, gapNum = 3, bucketLen = 100, bucketNum = 4. The 4 buckets will be: [1, 101), [101, 201), [201, 301), [301, 401). You might have noticed in this **perfect situation**, each number falls into a different bucket, and no numbers will share a bucket. So we could say, the max gap exists between the buckets.\\n\\nThis is also true when the gap between the numbers become uneven. As min and max are fixed, range and gapNum are both fixed. The current 3 gaps between the numbers are 100, 100, 100. When the middle numbers change, the 3 gaps between will change accordingly. But what's for sure is when some gaps become smaller than 100, some gaps will definitely become larger than 100, since they are bounded by the fixed range sum. For example, 50, 75, 175. or 101, 99, 100.  Under this condition, the biggest gap will be bigger than 100. Thus the two numbers constituting this gap cannot fall into the same bucket, since the biggest gap allowed in a single bucket is (bucketLen - 1) = 99. So when the gaps are uneven, the max gap exists between the buckets.\\n\\n(2). range could not be completely divided. That is, range % gapNum != 0. For example, 1, 4, 7, 11, 15. In this case, the most even gap arrangement is, some gaps are range / gapNum, while the other gaps are\\nrange / gapNum + 1. For our case, range = (15 - 1) = 14, gapNum = 4. Thus the most even arrangement is 3 3 4 4, or 3 4 3 4, or 4 3 3 4, and et al. Actually, for the sole sake of finding the max gap, we could choose either range / gapNum or range / gapNum + 1 as the buckeLen. \\n\\nSince bucketNum = range / bucketLen + 1, we will have one more bucket when choosing the smaller bucketLen than choosing the bigger bucketLen. For our example, when bucketLen = 3, bucketNum = 14 / 3 + 1 = 5. while when bucketLen = 4, 14 / 4 + 1 = 4. Their buckets are:\\n\\n3: [1, 4), [4, 7), [7, 10), [10, 13), [13, 16)\\n\\n4:[1, 5), [5, 9), [9, 13), [13, 17)\\n\\nIt can be seen that in either cases, the max gap will be found between buckets for the most even gap arrangements. The only difference is that the smaller bucketLen will guarantee each number fall in to a different bucket (3 > 3 - 1), while for the bigger bucketLen, those numbers with the small gap might fall into the same bucket (4 - 1 >= 3). But no matter how, we could always find the max gap between the buckets, since 4 > 3 - 1, and 4 > 4 - 1;\\n\\nFixing min and max, when the gaps become uneven, some gaps will be smaller, and some will correspondingly become larger, since their sum is fixed to range. For example, 2 4 4 4, or 1 3 5 5 for our case. When the max gap becomes larger than 4, it will definitely exist between buckets, since maxGap > 4 > 4 - 1;\\n\\nBut why don't we choose range / gapNum as the bucketLen in our algorithms? The answer is that range / gapNum might be zero for some cases. For example, assume the input array is 1 1 1 1 4. Here range / gapNum = 3 / 4 = 0. But bucketLen should at least be 1 for the solution to work. To deal with this issue, we typically choose bucketLen = range / gapNum + 1 to guarantee the validity of bucketLen. For this exmaple, bucketLen = 1, bucketNum = 4, and the buckets are: [1, 2), [2, 3), [3, 4), [4, 5), two of them will be empty. **But for those cases where the smaller one of the two even gaps is not zero, setting bucketLen to range / gapNum also works in the algorithm!**"
                    },
                    {
                        "username": "SunnyGupta",
                        "content": "I was able to understand the solution but there is one thing that is constantly making me to think Why we have not included min and max in the buckets that we have created???\\nPlease can someone answer with proper reasoning..\\nThanks in advance!"
                    },
                    {
                        "username": "zhoubowei",
                        "content": "It is O(kN) algorithm instead, depends on the numbers\\' range.\\nhttps://en.wikipedia.org/wiki/Radix_sort\\n"
                    }
                ]
            },
            {
                "id": 1820461,
                "content": [
                    {
                        "username": "Msey",
                        "content": "Well, I can handle Example2. Seems it\\'s a good start :)"
                    },
                    {
                        "username": "cartesPerforees",
                        "content": "Always a confidence booster to see that green light turned on for half the testcases on first try, until you look at what case it is"
                    },
                    {
                        "username": "changpro",
                        "content": "#### This \"hard\" problem is meaningless cause I see so many sort() in discuss, and they run really fast.\\n#### Actually it\\'s not a linear cause you don\\'t know what max element is right? There is no way to compare which one is faster  if the maxmum are much larger than the array\\'s length."
                    },
                    {
                        "username": "cartesPerforees",
                        "content": "I don't get your point. Of course if you cheat you can make the hard problem easier. It's specified in the statement you can;t use a sort (linear runtime). They can't automatically detect if you do, but who cares? If someone did it with a sort, they know they didn;t solve this question.\n\nAlso, why you screaming, bro?"
                    },
                    {
                        "username": "cartesPerforees",
                        "content": "[@HitenTandon](/HitenTandon) Hm? Yeah, but bucket sort doesn't suffer from that, afaik. I'm pretty sure my bucket-based solution is worst case O(n)"
                    },
                    {
                        "username": "HitenTandon",
                        "content": "You are right, radix sort has a time complexity of $$O(nlogR(maxElement) + RlogR(maxElement))$$.\n\nWhere, n is the number of elements in the array, R is the chosen radix, and maxElement is the maximum element.\n\nSo in theory the bigger Radix you chose the faster your algorithm runs, and that's why generally, a radix of 256 is used, which makes the worst case time complexity for the algorithm $$O(4(n + R))$$(here, since ints are 32 bits).\n\nIDK why all the people are using radix 2 or 10, because they don't really make much sense."
                    },
                    {
                        "username": "geekyshark",
                        "content": "Caution : Easy Problem marked Hard"
                    },
                    {
                        "username": "liubo0331",
                        "content": "The description \"maximum difference between the successive elements\" confuses me, because the successive elements could mean more than 2 elements that are successive."
                    },
                    {
                        "username": "_srahul_",
                        "content": "I don\\'t know why they can\\'t provide a good example."
                    },
                    {
                        "username": "fancyIX",
                        "content": "it's said \"Given an unsorted array, find the maximum difference between the successive elements in its sorted form.\"\\n\\nWhat does it mean by \"difference\"? What is the difference between the successive elements? What does \"in its sorted form\" mean?"
                    },
                    {
                        "username": "drMystico",
                        "content": "I guess that even in an unsorted array, there should exist a sorted subarray, and we need to return the maximum difference among that subarray's element, that was what I was able to decipher from the example"
                    },
                    {
                        "username": "heg816",
                        "content": "find the highest value of (sorted_array[k+1] - sorted_array[k]) for some k s.t. 0 <= k < arr.length - 1"
                    },
                    {
                        "username": "ak_ydv",
                        "content": "why this question is marked as a hard ?"
                    },
                    {
                        "username": "benlong",
                        "content": "I've read about the bucket sort solution in the discuss. However, I find that the explanation to \"**the maximum gap absolutely exists between buckets**\" is not so clear to me. Thus I'm trying to give some thoughts from what I understand.\\n\\nFirst of all, let's assume that there are at least 2 number in the array. The smallest is min, biggest is max, and we use range to represent the difference between max and min (range = max - min). We use gapNum to denote the number of gaps in the array. Needless to say that gapNum = num.size() - 1. Thus we've got at least 1 gap. According to whether range could be divided by gapNum without remainder, this problem could be divided into 2 cases.\\n\\n(1). range could be completely divided. That is, range % gapNum == 0. In this case, bucketLen = range / gapNum, and bucketNum = gapNum + 1. For example, the input is [1, 101, 201, 301], thus range = 300, gapNum = 3, bucketLen = 100, bucketNum = 4. The 4 buckets will be: [1, 101), [101, 201), [201, 301), [301, 401). You might have noticed in this **perfect situation**, each number falls into a different bucket, and no numbers will share a bucket. So we could say, the max gap exists between the buckets.\\n\\nThis is also true when the gap between the numbers become uneven. As min and max are fixed, range and gapNum are both fixed. The current 3 gaps between the numbers are 100, 100, 100. When the middle numbers change, the 3 gaps between will change accordingly. But what's for sure is when some gaps become smaller than 100, some gaps will definitely become larger than 100, since they are bounded by the fixed range sum. For example, 50, 75, 175. or 101, 99, 100.  Under this condition, the biggest gap will be bigger than 100. Thus the two numbers constituting this gap cannot fall into the same bucket, since the biggest gap allowed in a single bucket is (bucketLen - 1) = 99. So when the gaps are uneven, the max gap exists between the buckets.\\n\\n(2). range could not be completely divided. That is, range % gapNum != 0. For example, 1, 4, 7, 11, 15. In this case, the most even gap arrangement is, some gaps are range / gapNum, while the other gaps are\\nrange / gapNum + 1. For our case, range = (15 - 1) = 14, gapNum = 4. Thus the most even arrangement is 3 3 4 4, or 3 4 3 4, or 4 3 3 4, and et al. Actually, for the sole sake of finding the max gap, we could choose either range / gapNum or range / gapNum + 1 as the buckeLen. \\n\\nSince bucketNum = range / bucketLen + 1, we will have one more bucket when choosing the smaller bucketLen than choosing the bigger bucketLen. For our example, when bucketLen = 3, bucketNum = 14 / 3 + 1 = 5. while when bucketLen = 4, 14 / 4 + 1 = 4. Their buckets are:\\n\\n3: [1, 4), [4, 7), [7, 10), [10, 13), [13, 16)\\n\\n4:[1, 5), [5, 9), [9, 13), [13, 17)\\n\\nIt can be seen that in either cases, the max gap will be found between buckets for the most even gap arrangements. The only difference is that the smaller bucketLen will guarantee each number fall in to a different bucket (3 > 3 - 1), while for the bigger bucketLen, those numbers with the small gap might fall into the same bucket (4 - 1 >= 3). But no matter how, we could always find the max gap between the buckets, since 4 > 3 - 1, and 4 > 4 - 1;\\n\\nFixing min and max, when the gaps become uneven, some gaps will be smaller, and some will correspondingly become larger, since their sum is fixed to range. For example, 2 4 4 4, or 1 3 5 5 for our case. When the max gap becomes larger than 4, it will definitely exist between buckets, since maxGap > 4 > 4 - 1;\\n\\nBut why don't we choose range / gapNum as the bucketLen in our algorithms? The answer is that range / gapNum might be zero for some cases. For example, assume the input array is 1 1 1 1 4. Here range / gapNum = 3 / 4 = 0. But bucketLen should at least be 1 for the solution to work. To deal with this issue, we typically choose bucketLen = range / gapNum + 1 to guarantee the validity of bucketLen. For this exmaple, bucketLen = 1, bucketNum = 4, and the buckets are: [1, 2), [2, 3), [3, 4), [4, 5), two of them will be empty. **But for those cases where the smaller one of the two even gaps is not zero, setting bucketLen to range / gapNum also works in the algorithm!**"
                    },
                    {
                        "username": "SunnyGupta",
                        "content": "I was able to understand the solution but there is one thing that is constantly making me to think Why we have not included min and max in the buckets that we have created???\\nPlease can someone answer with proper reasoning..\\nThanks in advance!"
                    },
                    {
                        "username": "zhoubowei",
                        "content": "It is O(kN) algorithm instead, depends on the numbers\\' range.\\nhttps://en.wikipedia.org/wiki/Radix_sort\\n"
                    }
                ]
            },
            {
                "id": 1566758,
                "content": [
                    {
                        "username": "Msey",
                        "content": "Well, I can handle Example2. Seems it\\'s a good start :)"
                    },
                    {
                        "username": "cartesPerforees",
                        "content": "Always a confidence booster to see that green light turned on for half the testcases on first try, until you look at what case it is"
                    },
                    {
                        "username": "changpro",
                        "content": "#### This \"hard\" problem is meaningless cause I see so many sort() in discuss, and they run really fast.\\n#### Actually it\\'s not a linear cause you don\\'t know what max element is right? There is no way to compare which one is faster  if the maxmum are much larger than the array\\'s length."
                    },
                    {
                        "username": "cartesPerforees",
                        "content": "I don't get your point. Of course if you cheat you can make the hard problem easier. It's specified in the statement you can;t use a sort (linear runtime). They can't automatically detect if you do, but who cares? If someone did it with a sort, they know they didn;t solve this question.\n\nAlso, why you screaming, bro?"
                    },
                    {
                        "username": "cartesPerforees",
                        "content": "[@HitenTandon](/HitenTandon) Hm? Yeah, but bucket sort doesn't suffer from that, afaik. I'm pretty sure my bucket-based solution is worst case O(n)"
                    },
                    {
                        "username": "HitenTandon",
                        "content": "You are right, radix sort has a time complexity of $$O(nlogR(maxElement) + RlogR(maxElement))$$.\n\nWhere, n is the number of elements in the array, R is the chosen radix, and maxElement is the maximum element.\n\nSo in theory the bigger Radix you chose the faster your algorithm runs, and that's why generally, a radix of 256 is used, which makes the worst case time complexity for the algorithm $$O(4(n + R))$$(here, since ints are 32 bits).\n\nIDK why all the people are using radix 2 or 10, because they don't really make much sense."
                    },
                    {
                        "username": "geekyshark",
                        "content": "Caution : Easy Problem marked Hard"
                    },
                    {
                        "username": "liubo0331",
                        "content": "The description \"maximum difference between the successive elements\" confuses me, because the successive elements could mean more than 2 elements that are successive."
                    },
                    {
                        "username": "_srahul_",
                        "content": "I don\\'t know why they can\\'t provide a good example."
                    },
                    {
                        "username": "fancyIX",
                        "content": "it's said \"Given an unsorted array, find the maximum difference between the successive elements in its sorted form.\"\\n\\nWhat does it mean by \"difference\"? What is the difference between the successive elements? What does \"in its sorted form\" mean?"
                    },
                    {
                        "username": "drMystico",
                        "content": "I guess that even in an unsorted array, there should exist a sorted subarray, and we need to return the maximum difference among that subarray's element, that was what I was able to decipher from the example"
                    },
                    {
                        "username": "heg816",
                        "content": "find the highest value of (sorted_array[k+1] - sorted_array[k]) for some k s.t. 0 <= k < arr.length - 1"
                    },
                    {
                        "username": "ak_ydv",
                        "content": "why this question is marked as a hard ?"
                    },
                    {
                        "username": "benlong",
                        "content": "I've read about the bucket sort solution in the discuss. However, I find that the explanation to \"**the maximum gap absolutely exists between buckets**\" is not so clear to me. Thus I'm trying to give some thoughts from what I understand.\\n\\nFirst of all, let's assume that there are at least 2 number in the array. The smallest is min, biggest is max, and we use range to represent the difference between max and min (range = max - min). We use gapNum to denote the number of gaps in the array. Needless to say that gapNum = num.size() - 1. Thus we've got at least 1 gap. According to whether range could be divided by gapNum without remainder, this problem could be divided into 2 cases.\\n\\n(1). range could be completely divided. That is, range % gapNum == 0. In this case, bucketLen = range / gapNum, and bucketNum = gapNum + 1. For example, the input is [1, 101, 201, 301], thus range = 300, gapNum = 3, bucketLen = 100, bucketNum = 4. The 4 buckets will be: [1, 101), [101, 201), [201, 301), [301, 401). You might have noticed in this **perfect situation**, each number falls into a different bucket, and no numbers will share a bucket. So we could say, the max gap exists between the buckets.\\n\\nThis is also true when the gap between the numbers become uneven. As min and max are fixed, range and gapNum are both fixed. The current 3 gaps between the numbers are 100, 100, 100. When the middle numbers change, the 3 gaps between will change accordingly. But what's for sure is when some gaps become smaller than 100, some gaps will definitely become larger than 100, since they are bounded by the fixed range sum. For example, 50, 75, 175. or 101, 99, 100.  Under this condition, the biggest gap will be bigger than 100. Thus the two numbers constituting this gap cannot fall into the same bucket, since the biggest gap allowed in a single bucket is (bucketLen - 1) = 99. So when the gaps are uneven, the max gap exists between the buckets.\\n\\n(2). range could not be completely divided. That is, range % gapNum != 0. For example, 1, 4, 7, 11, 15. In this case, the most even gap arrangement is, some gaps are range / gapNum, while the other gaps are\\nrange / gapNum + 1. For our case, range = (15 - 1) = 14, gapNum = 4. Thus the most even arrangement is 3 3 4 4, or 3 4 3 4, or 4 3 3 4, and et al. Actually, for the sole sake of finding the max gap, we could choose either range / gapNum or range / gapNum + 1 as the buckeLen. \\n\\nSince bucketNum = range / bucketLen + 1, we will have one more bucket when choosing the smaller bucketLen than choosing the bigger bucketLen. For our example, when bucketLen = 3, bucketNum = 14 / 3 + 1 = 5. while when bucketLen = 4, 14 / 4 + 1 = 4. Their buckets are:\\n\\n3: [1, 4), [4, 7), [7, 10), [10, 13), [13, 16)\\n\\n4:[1, 5), [5, 9), [9, 13), [13, 17)\\n\\nIt can be seen that in either cases, the max gap will be found between buckets for the most even gap arrangements. The only difference is that the smaller bucketLen will guarantee each number fall in to a different bucket (3 > 3 - 1), while for the bigger bucketLen, those numbers with the small gap might fall into the same bucket (4 - 1 >= 3). But no matter how, we could always find the max gap between the buckets, since 4 > 3 - 1, and 4 > 4 - 1;\\n\\nFixing min and max, when the gaps become uneven, some gaps will be smaller, and some will correspondingly become larger, since their sum is fixed to range. For example, 2 4 4 4, or 1 3 5 5 for our case. When the max gap becomes larger than 4, it will definitely exist between buckets, since maxGap > 4 > 4 - 1;\\n\\nBut why don't we choose range / gapNum as the bucketLen in our algorithms? The answer is that range / gapNum might be zero for some cases. For example, assume the input array is 1 1 1 1 4. Here range / gapNum = 3 / 4 = 0. But bucketLen should at least be 1 for the solution to work. To deal with this issue, we typically choose bucketLen = range / gapNum + 1 to guarantee the validity of bucketLen. For this exmaple, bucketLen = 1, bucketNum = 4, and the buckets are: [1, 2), [2, 3), [3, 4), [4, 5), two of them will be empty. **But for those cases where the smaller one of the two even gaps is not zero, setting bucketLen to range / gapNum also works in the algorithm!**"
                    },
                    {
                        "username": "SunnyGupta",
                        "content": "I was able to understand the solution but there is one thing that is constantly making me to think Why we have not included min and max in the buckets that we have created???\\nPlease can someone answer with proper reasoning..\\nThanks in advance!"
                    },
                    {
                        "username": "zhoubowei",
                        "content": "It is O(kN) algorithm instead, depends on the numbers\\' range.\\nhttps://en.wikipedia.org/wiki/Radix_sort\\n"
                    }
                ]
            },
            {
                "id": 2019688,
                "content": [
                    {
                        "username": "Msey",
                        "content": "Well, I can handle Example2. Seems it\\'s a good start :)"
                    },
                    {
                        "username": "cartesPerforees",
                        "content": "Always a confidence booster to see that green light turned on for half the testcases on first try, until you look at what case it is"
                    },
                    {
                        "username": "changpro",
                        "content": "#### This \"hard\" problem is meaningless cause I see so many sort() in discuss, and they run really fast.\\n#### Actually it\\'s not a linear cause you don\\'t know what max element is right? There is no way to compare which one is faster  if the maxmum are much larger than the array\\'s length."
                    },
                    {
                        "username": "cartesPerforees",
                        "content": "I don't get your point. Of course if you cheat you can make the hard problem easier. It's specified in the statement you can;t use a sort (linear runtime). They can't automatically detect if you do, but who cares? If someone did it with a sort, they know they didn;t solve this question.\n\nAlso, why you screaming, bro?"
                    },
                    {
                        "username": "cartesPerforees",
                        "content": "[@HitenTandon](/HitenTandon) Hm? Yeah, but bucket sort doesn't suffer from that, afaik. I'm pretty sure my bucket-based solution is worst case O(n)"
                    },
                    {
                        "username": "HitenTandon",
                        "content": "You are right, radix sort has a time complexity of $$O(nlogR(maxElement) + RlogR(maxElement))$$.\n\nWhere, n is the number of elements in the array, R is the chosen radix, and maxElement is the maximum element.\n\nSo in theory the bigger Radix you chose the faster your algorithm runs, and that's why generally, a radix of 256 is used, which makes the worst case time complexity for the algorithm $$O(4(n + R))$$(here, since ints are 32 bits).\n\nIDK why all the people are using radix 2 or 10, because they don't really make much sense."
                    },
                    {
                        "username": "geekyshark",
                        "content": "Caution : Easy Problem marked Hard"
                    },
                    {
                        "username": "liubo0331",
                        "content": "The description \"maximum difference between the successive elements\" confuses me, because the successive elements could mean more than 2 elements that are successive."
                    },
                    {
                        "username": "_srahul_",
                        "content": "I don\\'t know why they can\\'t provide a good example."
                    },
                    {
                        "username": "fancyIX",
                        "content": "it's said \"Given an unsorted array, find the maximum difference between the successive elements in its sorted form.\"\\n\\nWhat does it mean by \"difference\"? What is the difference between the successive elements? What does \"in its sorted form\" mean?"
                    },
                    {
                        "username": "drMystico",
                        "content": "I guess that even in an unsorted array, there should exist a sorted subarray, and we need to return the maximum difference among that subarray's element, that was what I was able to decipher from the example"
                    },
                    {
                        "username": "heg816",
                        "content": "find the highest value of (sorted_array[k+1] - sorted_array[k]) for some k s.t. 0 <= k < arr.length - 1"
                    },
                    {
                        "username": "ak_ydv",
                        "content": "why this question is marked as a hard ?"
                    },
                    {
                        "username": "benlong",
                        "content": "I've read about the bucket sort solution in the discuss. However, I find that the explanation to \"**the maximum gap absolutely exists between buckets**\" is not so clear to me. Thus I'm trying to give some thoughts from what I understand.\\n\\nFirst of all, let's assume that there are at least 2 number in the array. The smallest is min, biggest is max, and we use range to represent the difference between max and min (range = max - min). We use gapNum to denote the number of gaps in the array. Needless to say that gapNum = num.size() - 1. Thus we've got at least 1 gap. According to whether range could be divided by gapNum without remainder, this problem could be divided into 2 cases.\\n\\n(1). range could be completely divided. That is, range % gapNum == 0. In this case, bucketLen = range / gapNum, and bucketNum = gapNum + 1. For example, the input is [1, 101, 201, 301], thus range = 300, gapNum = 3, bucketLen = 100, bucketNum = 4. The 4 buckets will be: [1, 101), [101, 201), [201, 301), [301, 401). You might have noticed in this **perfect situation**, each number falls into a different bucket, and no numbers will share a bucket. So we could say, the max gap exists between the buckets.\\n\\nThis is also true when the gap between the numbers become uneven. As min and max are fixed, range and gapNum are both fixed. The current 3 gaps between the numbers are 100, 100, 100. When the middle numbers change, the 3 gaps between will change accordingly. But what's for sure is when some gaps become smaller than 100, some gaps will definitely become larger than 100, since they are bounded by the fixed range sum. For example, 50, 75, 175. or 101, 99, 100.  Under this condition, the biggest gap will be bigger than 100. Thus the two numbers constituting this gap cannot fall into the same bucket, since the biggest gap allowed in a single bucket is (bucketLen - 1) = 99. So when the gaps are uneven, the max gap exists between the buckets.\\n\\n(2). range could not be completely divided. That is, range % gapNum != 0. For example, 1, 4, 7, 11, 15. In this case, the most even gap arrangement is, some gaps are range / gapNum, while the other gaps are\\nrange / gapNum + 1. For our case, range = (15 - 1) = 14, gapNum = 4. Thus the most even arrangement is 3 3 4 4, or 3 4 3 4, or 4 3 3 4, and et al. Actually, for the sole sake of finding the max gap, we could choose either range / gapNum or range / gapNum + 1 as the buckeLen. \\n\\nSince bucketNum = range / bucketLen + 1, we will have one more bucket when choosing the smaller bucketLen than choosing the bigger bucketLen. For our example, when bucketLen = 3, bucketNum = 14 / 3 + 1 = 5. while when bucketLen = 4, 14 / 4 + 1 = 4. Their buckets are:\\n\\n3: [1, 4), [4, 7), [7, 10), [10, 13), [13, 16)\\n\\n4:[1, 5), [5, 9), [9, 13), [13, 17)\\n\\nIt can be seen that in either cases, the max gap will be found between buckets for the most even gap arrangements. The only difference is that the smaller bucketLen will guarantee each number fall in to a different bucket (3 > 3 - 1), while for the bigger bucketLen, those numbers with the small gap might fall into the same bucket (4 - 1 >= 3). But no matter how, we could always find the max gap between the buckets, since 4 > 3 - 1, and 4 > 4 - 1;\\n\\nFixing min and max, when the gaps become uneven, some gaps will be smaller, and some will correspondingly become larger, since their sum is fixed to range. For example, 2 4 4 4, or 1 3 5 5 for our case. When the max gap becomes larger than 4, it will definitely exist between buckets, since maxGap > 4 > 4 - 1;\\n\\nBut why don't we choose range / gapNum as the bucketLen in our algorithms? The answer is that range / gapNum might be zero for some cases. For example, assume the input array is 1 1 1 1 4. Here range / gapNum = 3 / 4 = 0. But bucketLen should at least be 1 for the solution to work. To deal with this issue, we typically choose bucketLen = range / gapNum + 1 to guarantee the validity of bucketLen. For this exmaple, bucketLen = 1, bucketNum = 4, and the buckets are: [1, 2), [2, 3), [3, 4), [4, 5), two of them will be empty. **But for those cases where the smaller one of the two even gaps is not zero, setting bucketLen to range / gapNum also works in the algorithm!**"
                    },
                    {
                        "username": "SunnyGupta",
                        "content": "I was able to understand the solution but there is one thing that is constantly making me to think Why we have not included min and max in the buckets that we have created???\\nPlease can someone answer with proper reasoning..\\nThanks in advance!"
                    },
                    {
                        "username": "zhoubowei",
                        "content": "It is O(kN) algorithm instead, depends on the numbers\\' range.\\nhttps://en.wikipedia.org/wiki/Radix_sort\\n"
                    }
                ]
            },
            {
                "id": 1571359,
                "content": [
                    {
                        "username": "Msey",
                        "content": "Well, I can handle Example2. Seems it\\'s a good start :)"
                    },
                    {
                        "username": "cartesPerforees",
                        "content": "Always a confidence booster to see that green light turned on for half the testcases on first try, until you look at what case it is"
                    },
                    {
                        "username": "changpro",
                        "content": "#### This \"hard\" problem is meaningless cause I see so many sort() in discuss, and they run really fast.\\n#### Actually it\\'s not a linear cause you don\\'t know what max element is right? There is no way to compare which one is faster  if the maxmum are much larger than the array\\'s length."
                    },
                    {
                        "username": "cartesPerforees",
                        "content": "I don't get your point. Of course if you cheat you can make the hard problem easier. It's specified in the statement you can;t use a sort (linear runtime). They can't automatically detect if you do, but who cares? If someone did it with a sort, they know they didn;t solve this question.\n\nAlso, why you screaming, bro?"
                    },
                    {
                        "username": "cartesPerforees",
                        "content": "[@HitenTandon](/HitenTandon) Hm? Yeah, but bucket sort doesn't suffer from that, afaik. I'm pretty sure my bucket-based solution is worst case O(n)"
                    },
                    {
                        "username": "HitenTandon",
                        "content": "You are right, radix sort has a time complexity of $$O(nlogR(maxElement) + RlogR(maxElement))$$.\n\nWhere, n is the number of elements in the array, R is the chosen radix, and maxElement is the maximum element.\n\nSo in theory the bigger Radix you chose the faster your algorithm runs, and that's why generally, a radix of 256 is used, which makes the worst case time complexity for the algorithm $$O(4(n + R))$$(here, since ints are 32 bits).\n\nIDK why all the people are using radix 2 or 10, because they don't really make much sense."
                    },
                    {
                        "username": "geekyshark",
                        "content": "Caution : Easy Problem marked Hard"
                    },
                    {
                        "username": "liubo0331",
                        "content": "The description \"maximum difference between the successive elements\" confuses me, because the successive elements could mean more than 2 elements that are successive."
                    },
                    {
                        "username": "_srahul_",
                        "content": "I don\\'t know why they can\\'t provide a good example."
                    },
                    {
                        "username": "fancyIX",
                        "content": "it's said \"Given an unsorted array, find the maximum difference between the successive elements in its sorted form.\"\\n\\nWhat does it mean by \"difference\"? What is the difference between the successive elements? What does \"in its sorted form\" mean?"
                    },
                    {
                        "username": "drMystico",
                        "content": "I guess that even in an unsorted array, there should exist a sorted subarray, and we need to return the maximum difference among that subarray's element, that was what I was able to decipher from the example"
                    },
                    {
                        "username": "heg816",
                        "content": "find the highest value of (sorted_array[k+1] - sorted_array[k]) for some k s.t. 0 <= k < arr.length - 1"
                    },
                    {
                        "username": "ak_ydv",
                        "content": "why this question is marked as a hard ?"
                    },
                    {
                        "username": "benlong",
                        "content": "I've read about the bucket sort solution in the discuss. However, I find that the explanation to \"**the maximum gap absolutely exists between buckets**\" is not so clear to me. Thus I'm trying to give some thoughts from what I understand.\\n\\nFirst of all, let's assume that there are at least 2 number in the array. The smallest is min, biggest is max, and we use range to represent the difference between max and min (range = max - min). We use gapNum to denote the number of gaps in the array. Needless to say that gapNum = num.size() - 1. Thus we've got at least 1 gap. According to whether range could be divided by gapNum without remainder, this problem could be divided into 2 cases.\\n\\n(1). range could be completely divided. That is, range % gapNum == 0. In this case, bucketLen = range / gapNum, and bucketNum = gapNum + 1. For example, the input is [1, 101, 201, 301], thus range = 300, gapNum = 3, bucketLen = 100, bucketNum = 4. The 4 buckets will be: [1, 101), [101, 201), [201, 301), [301, 401). You might have noticed in this **perfect situation**, each number falls into a different bucket, and no numbers will share a bucket. So we could say, the max gap exists between the buckets.\\n\\nThis is also true when the gap between the numbers become uneven. As min and max are fixed, range and gapNum are both fixed. The current 3 gaps between the numbers are 100, 100, 100. When the middle numbers change, the 3 gaps between will change accordingly. But what's for sure is when some gaps become smaller than 100, some gaps will definitely become larger than 100, since they are bounded by the fixed range sum. For example, 50, 75, 175. or 101, 99, 100.  Under this condition, the biggest gap will be bigger than 100. Thus the two numbers constituting this gap cannot fall into the same bucket, since the biggest gap allowed in a single bucket is (bucketLen - 1) = 99. So when the gaps are uneven, the max gap exists between the buckets.\\n\\n(2). range could not be completely divided. That is, range % gapNum != 0. For example, 1, 4, 7, 11, 15. In this case, the most even gap arrangement is, some gaps are range / gapNum, while the other gaps are\\nrange / gapNum + 1. For our case, range = (15 - 1) = 14, gapNum = 4. Thus the most even arrangement is 3 3 4 4, or 3 4 3 4, or 4 3 3 4, and et al. Actually, for the sole sake of finding the max gap, we could choose either range / gapNum or range / gapNum + 1 as the buckeLen. \\n\\nSince bucketNum = range / bucketLen + 1, we will have one more bucket when choosing the smaller bucketLen than choosing the bigger bucketLen. For our example, when bucketLen = 3, bucketNum = 14 / 3 + 1 = 5. while when bucketLen = 4, 14 / 4 + 1 = 4. Their buckets are:\\n\\n3: [1, 4), [4, 7), [7, 10), [10, 13), [13, 16)\\n\\n4:[1, 5), [5, 9), [9, 13), [13, 17)\\n\\nIt can be seen that in either cases, the max gap will be found between buckets for the most even gap arrangements. The only difference is that the smaller bucketLen will guarantee each number fall in to a different bucket (3 > 3 - 1), while for the bigger bucketLen, those numbers with the small gap might fall into the same bucket (4 - 1 >= 3). But no matter how, we could always find the max gap between the buckets, since 4 > 3 - 1, and 4 > 4 - 1;\\n\\nFixing min and max, when the gaps become uneven, some gaps will be smaller, and some will correspondingly become larger, since their sum is fixed to range. For example, 2 4 4 4, or 1 3 5 5 for our case. When the max gap becomes larger than 4, it will definitely exist between buckets, since maxGap > 4 > 4 - 1;\\n\\nBut why don't we choose range / gapNum as the bucketLen in our algorithms? The answer is that range / gapNum might be zero for some cases. For example, assume the input array is 1 1 1 1 4. Here range / gapNum = 3 / 4 = 0. But bucketLen should at least be 1 for the solution to work. To deal with this issue, we typically choose bucketLen = range / gapNum + 1 to guarantee the validity of bucketLen. For this exmaple, bucketLen = 1, bucketNum = 4, and the buckets are: [1, 2), [2, 3), [3, 4), [4, 5), two of them will be empty. **But for those cases where the smaller one of the two even gaps is not zero, setting bucketLen to range / gapNum also works in the algorithm!**"
                    },
                    {
                        "username": "SunnyGupta",
                        "content": "I was able to understand the solution but there is one thing that is constantly making me to think Why we have not included min and max in the buckets that we have created???\\nPlease can someone answer with proper reasoning..\\nThanks in advance!"
                    },
                    {
                        "username": "zhoubowei",
                        "content": "It is O(kN) algorithm instead, depends on the numbers\\' range.\\nhttps://en.wikipedia.org/wiki/Radix_sort\\n"
                    }
                ]
            },
            {
                "id": 1575340,
                "content": [
                    {
                        "username": "Msey",
                        "content": "Well, I can handle Example2. Seems it\\'s a good start :)"
                    },
                    {
                        "username": "cartesPerforees",
                        "content": "Always a confidence booster to see that green light turned on for half the testcases on first try, until you look at what case it is"
                    },
                    {
                        "username": "changpro",
                        "content": "#### This \"hard\" problem is meaningless cause I see so many sort() in discuss, and they run really fast.\\n#### Actually it\\'s not a linear cause you don\\'t know what max element is right? There is no way to compare which one is faster  if the maxmum are much larger than the array\\'s length."
                    },
                    {
                        "username": "cartesPerforees",
                        "content": "I don't get your point. Of course if you cheat you can make the hard problem easier. It's specified in the statement you can;t use a sort (linear runtime). They can't automatically detect if you do, but who cares? If someone did it with a sort, they know they didn;t solve this question.\n\nAlso, why you screaming, bro?"
                    },
                    {
                        "username": "cartesPerforees",
                        "content": "[@HitenTandon](/HitenTandon) Hm? Yeah, but bucket sort doesn't suffer from that, afaik. I'm pretty sure my bucket-based solution is worst case O(n)"
                    },
                    {
                        "username": "HitenTandon",
                        "content": "You are right, radix sort has a time complexity of $$O(nlogR(maxElement) + RlogR(maxElement))$$.\n\nWhere, n is the number of elements in the array, R is the chosen radix, and maxElement is the maximum element.\n\nSo in theory the bigger Radix you chose the faster your algorithm runs, and that's why generally, a radix of 256 is used, which makes the worst case time complexity for the algorithm $$O(4(n + R))$$(here, since ints are 32 bits).\n\nIDK why all the people are using radix 2 or 10, because they don't really make much sense."
                    },
                    {
                        "username": "geekyshark",
                        "content": "Caution : Easy Problem marked Hard"
                    },
                    {
                        "username": "liubo0331",
                        "content": "The description \"maximum difference between the successive elements\" confuses me, because the successive elements could mean more than 2 elements that are successive."
                    },
                    {
                        "username": "_srahul_",
                        "content": "I don\\'t know why they can\\'t provide a good example."
                    },
                    {
                        "username": "fancyIX",
                        "content": "it's said \"Given an unsorted array, find the maximum difference between the successive elements in its sorted form.\"\\n\\nWhat does it mean by \"difference\"? What is the difference between the successive elements? What does \"in its sorted form\" mean?"
                    },
                    {
                        "username": "drMystico",
                        "content": "I guess that even in an unsorted array, there should exist a sorted subarray, and we need to return the maximum difference among that subarray's element, that was what I was able to decipher from the example"
                    },
                    {
                        "username": "heg816",
                        "content": "find the highest value of (sorted_array[k+1] - sorted_array[k]) for some k s.t. 0 <= k < arr.length - 1"
                    },
                    {
                        "username": "ak_ydv",
                        "content": "why this question is marked as a hard ?"
                    },
                    {
                        "username": "benlong",
                        "content": "I've read about the bucket sort solution in the discuss. However, I find that the explanation to \"**the maximum gap absolutely exists between buckets**\" is not so clear to me. Thus I'm trying to give some thoughts from what I understand.\\n\\nFirst of all, let's assume that there are at least 2 number in the array. The smallest is min, biggest is max, and we use range to represent the difference between max and min (range = max - min). We use gapNum to denote the number of gaps in the array. Needless to say that gapNum = num.size() - 1. Thus we've got at least 1 gap. According to whether range could be divided by gapNum without remainder, this problem could be divided into 2 cases.\\n\\n(1). range could be completely divided. That is, range % gapNum == 0. In this case, bucketLen = range / gapNum, and bucketNum = gapNum + 1. For example, the input is [1, 101, 201, 301], thus range = 300, gapNum = 3, bucketLen = 100, bucketNum = 4. The 4 buckets will be: [1, 101), [101, 201), [201, 301), [301, 401). You might have noticed in this **perfect situation**, each number falls into a different bucket, and no numbers will share a bucket. So we could say, the max gap exists between the buckets.\\n\\nThis is also true when the gap between the numbers become uneven. As min and max are fixed, range and gapNum are both fixed. The current 3 gaps between the numbers are 100, 100, 100. When the middle numbers change, the 3 gaps between will change accordingly. But what's for sure is when some gaps become smaller than 100, some gaps will definitely become larger than 100, since they are bounded by the fixed range sum. For example, 50, 75, 175. or 101, 99, 100.  Under this condition, the biggest gap will be bigger than 100. Thus the two numbers constituting this gap cannot fall into the same bucket, since the biggest gap allowed in a single bucket is (bucketLen - 1) = 99. So when the gaps are uneven, the max gap exists between the buckets.\\n\\n(2). range could not be completely divided. That is, range % gapNum != 0. For example, 1, 4, 7, 11, 15. In this case, the most even gap arrangement is, some gaps are range / gapNum, while the other gaps are\\nrange / gapNum + 1. For our case, range = (15 - 1) = 14, gapNum = 4. Thus the most even arrangement is 3 3 4 4, or 3 4 3 4, or 4 3 3 4, and et al. Actually, for the sole sake of finding the max gap, we could choose either range / gapNum or range / gapNum + 1 as the buckeLen. \\n\\nSince bucketNum = range / bucketLen + 1, we will have one more bucket when choosing the smaller bucketLen than choosing the bigger bucketLen. For our example, when bucketLen = 3, bucketNum = 14 / 3 + 1 = 5. while when bucketLen = 4, 14 / 4 + 1 = 4. Their buckets are:\\n\\n3: [1, 4), [4, 7), [7, 10), [10, 13), [13, 16)\\n\\n4:[1, 5), [5, 9), [9, 13), [13, 17)\\n\\nIt can be seen that in either cases, the max gap will be found between buckets for the most even gap arrangements. The only difference is that the smaller bucketLen will guarantee each number fall in to a different bucket (3 > 3 - 1), while for the bigger bucketLen, those numbers with the small gap might fall into the same bucket (4 - 1 >= 3). But no matter how, we could always find the max gap between the buckets, since 4 > 3 - 1, and 4 > 4 - 1;\\n\\nFixing min and max, when the gaps become uneven, some gaps will be smaller, and some will correspondingly become larger, since their sum is fixed to range. For example, 2 4 4 4, or 1 3 5 5 for our case. When the max gap becomes larger than 4, it will definitely exist between buckets, since maxGap > 4 > 4 - 1;\\n\\nBut why don't we choose range / gapNum as the bucketLen in our algorithms? The answer is that range / gapNum might be zero for some cases. For example, assume the input array is 1 1 1 1 4. Here range / gapNum = 3 / 4 = 0. But bucketLen should at least be 1 for the solution to work. To deal with this issue, we typically choose bucketLen = range / gapNum + 1 to guarantee the validity of bucketLen. For this exmaple, bucketLen = 1, bucketNum = 4, and the buckets are: [1, 2), [2, 3), [3, 4), [4, 5), two of them will be empty. **But for those cases where the smaller one of the two even gaps is not zero, setting bucketLen to range / gapNum also works in the algorithm!**"
                    },
                    {
                        "username": "SunnyGupta",
                        "content": "I was able to understand the solution but there is one thing that is constantly making me to think Why we have not included min and max in the buckets that we have created???\\nPlease can someone answer with proper reasoning..\\nThanks in advance!"
                    },
                    {
                        "username": "zhoubowei",
                        "content": "It is O(kN) algorithm instead, depends on the numbers\\' range.\\nhttps://en.wikipedia.org/wiki/Radix_sort\\n"
                    }
                ]
            },
            {
                "id": 1571993,
                "content": [
                    {
                        "username": "Msey",
                        "content": "Well, I can handle Example2. Seems it\\'s a good start :)"
                    },
                    {
                        "username": "cartesPerforees",
                        "content": "Always a confidence booster to see that green light turned on for half the testcases on first try, until you look at what case it is"
                    },
                    {
                        "username": "changpro",
                        "content": "#### This \"hard\" problem is meaningless cause I see so many sort() in discuss, and they run really fast.\\n#### Actually it\\'s not a linear cause you don\\'t know what max element is right? There is no way to compare which one is faster  if the maxmum are much larger than the array\\'s length."
                    },
                    {
                        "username": "cartesPerforees",
                        "content": "I don't get your point. Of course if you cheat you can make the hard problem easier. It's specified in the statement you can;t use a sort (linear runtime). They can't automatically detect if you do, but who cares? If someone did it with a sort, they know they didn;t solve this question.\n\nAlso, why you screaming, bro?"
                    },
                    {
                        "username": "cartesPerforees",
                        "content": "[@HitenTandon](/HitenTandon) Hm? Yeah, but bucket sort doesn't suffer from that, afaik. I'm pretty sure my bucket-based solution is worst case O(n)"
                    },
                    {
                        "username": "HitenTandon",
                        "content": "You are right, radix sort has a time complexity of $$O(nlogR(maxElement) + RlogR(maxElement))$$.\n\nWhere, n is the number of elements in the array, R is the chosen radix, and maxElement is the maximum element.\n\nSo in theory the bigger Radix you chose the faster your algorithm runs, and that's why generally, a radix of 256 is used, which makes the worst case time complexity for the algorithm $$O(4(n + R))$$(here, since ints are 32 bits).\n\nIDK why all the people are using radix 2 or 10, because they don't really make much sense."
                    },
                    {
                        "username": "geekyshark",
                        "content": "Caution : Easy Problem marked Hard"
                    },
                    {
                        "username": "liubo0331",
                        "content": "The description \"maximum difference between the successive elements\" confuses me, because the successive elements could mean more than 2 elements that are successive."
                    },
                    {
                        "username": "_srahul_",
                        "content": "I don\\'t know why they can\\'t provide a good example."
                    },
                    {
                        "username": "fancyIX",
                        "content": "it's said \"Given an unsorted array, find the maximum difference between the successive elements in its sorted form.\"\\n\\nWhat does it mean by \"difference\"? What is the difference between the successive elements? What does \"in its sorted form\" mean?"
                    },
                    {
                        "username": "drMystico",
                        "content": "I guess that even in an unsorted array, there should exist a sorted subarray, and we need to return the maximum difference among that subarray's element, that was what I was able to decipher from the example"
                    },
                    {
                        "username": "heg816",
                        "content": "find the highest value of (sorted_array[k+1] - sorted_array[k]) for some k s.t. 0 <= k < arr.length - 1"
                    },
                    {
                        "username": "ak_ydv",
                        "content": "why this question is marked as a hard ?"
                    },
                    {
                        "username": "benlong",
                        "content": "I've read about the bucket sort solution in the discuss. However, I find that the explanation to \"**the maximum gap absolutely exists between buckets**\" is not so clear to me. Thus I'm trying to give some thoughts from what I understand.\\n\\nFirst of all, let's assume that there are at least 2 number in the array. The smallest is min, biggest is max, and we use range to represent the difference between max and min (range = max - min). We use gapNum to denote the number of gaps in the array. Needless to say that gapNum = num.size() - 1. Thus we've got at least 1 gap. According to whether range could be divided by gapNum without remainder, this problem could be divided into 2 cases.\\n\\n(1). range could be completely divided. That is, range % gapNum == 0. In this case, bucketLen = range / gapNum, and bucketNum = gapNum + 1. For example, the input is [1, 101, 201, 301], thus range = 300, gapNum = 3, bucketLen = 100, bucketNum = 4. The 4 buckets will be: [1, 101), [101, 201), [201, 301), [301, 401). You might have noticed in this **perfect situation**, each number falls into a different bucket, and no numbers will share a bucket. So we could say, the max gap exists between the buckets.\\n\\nThis is also true when the gap between the numbers become uneven. As min and max are fixed, range and gapNum are both fixed. The current 3 gaps between the numbers are 100, 100, 100. When the middle numbers change, the 3 gaps between will change accordingly. But what's for sure is when some gaps become smaller than 100, some gaps will definitely become larger than 100, since they are bounded by the fixed range sum. For example, 50, 75, 175. or 101, 99, 100.  Under this condition, the biggest gap will be bigger than 100. Thus the two numbers constituting this gap cannot fall into the same bucket, since the biggest gap allowed in a single bucket is (bucketLen - 1) = 99. So when the gaps are uneven, the max gap exists between the buckets.\\n\\n(2). range could not be completely divided. That is, range % gapNum != 0. For example, 1, 4, 7, 11, 15. In this case, the most even gap arrangement is, some gaps are range / gapNum, while the other gaps are\\nrange / gapNum + 1. For our case, range = (15 - 1) = 14, gapNum = 4. Thus the most even arrangement is 3 3 4 4, or 3 4 3 4, or 4 3 3 4, and et al. Actually, for the sole sake of finding the max gap, we could choose either range / gapNum or range / gapNum + 1 as the buckeLen. \\n\\nSince bucketNum = range / bucketLen + 1, we will have one more bucket when choosing the smaller bucketLen than choosing the bigger bucketLen. For our example, when bucketLen = 3, bucketNum = 14 / 3 + 1 = 5. while when bucketLen = 4, 14 / 4 + 1 = 4. Their buckets are:\\n\\n3: [1, 4), [4, 7), [7, 10), [10, 13), [13, 16)\\n\\n4:[1, 5), [5, 9), [9, 13), [13, 17)\\n\\nIt can be seen that in either cases, the max gap will be found between buckets for the most even gap arrangements. The only difference is that the smaller bucketLen will guarantee each number fall in to a different bucket (3 > 3 - 1), while for the bigger bucketLen, those numbers with the small gap might fall into the same bucket (4 - 1 >= 3). But no matter how, we could always find the max gap between the buckets, since 4 > 3 - 1, and 4 > 4 - 1;\\n\\nFixing min and max, when the gaps become uneven, some gaps will be smaller, and some will correspondingly become larger, since their sum is fixed to range. For example, 2 4 4 4, or 1 3 5 5 for our case. When the max gap becomes larger than 4, it will definitely exist between buckets, since maxGap > 4 > 4 - 1;\\n\\nBut why don't we choose range / gapNum as the bucketLen in our algorithms? The answer is that range / gapNum might be zero for some cases. For example, assume the input array is 1 1 1 1 4. Here range / gapNum = 3 / 4 = 0. But bucketLen should at least be 1 for the solution to work. To deal with this issue, we typically choose bucketLen = range / gapNum + 1 to guarantee the validity of bucketLen. For this exmaple, bucketLen = 1, bucketNum = 4, and the buckets are: [1, 2), [2, 3), [3, 4), [4, 5), two of them will be empty. **But for those cases where the smaller one of the two even gaps is not zero, setting bucketLen to range / gapNum also works in the algorithm!**"
                    },
                    {
                        "username": "SunnyGupta",
                        "content": "I was able to understand the solution but there is one thing that is constantly making me to think Why we have not included min and max in the buckets that we have created???\\nPlease can someone answer with proper reasoning..\\nThanks in advance!"
                    },
                    {
                        "username": "zhoubowei",
                        "content": "It is O(kN) algorithm instead, depends on the numbers\\' range.\\nhttps://en.wikipedia.org/wiki/Radix_sort\\n"
                    }
                ]
            }
        ]
    },
    {
        "title": "Ugly Number II",
        "question_content": "<p>An <strong>ugly number</strong> is a positive integer whose prime factors are limited to <code>2</code>, <code>3</code>, and <code>5</code>.</p>\n\n<p>Given an integer <code>n</code>, return <em>the</em> <code>n<sup>th</sup></code> <em><strong>ugly number</strong></em>.</p>\n\n<p>&nbsp;</p>\n<p><strong class=\"example\">Example 1:</strong></p>\n\n<pre>\n<strong>Input:</strong> n = 10\n<strong>Output:</strong> 12\n<strong>Explanation:</strong> [1, 2, 3, 4, 5, 6, 8, 9, 10, 12] is the sequence of the first 10 ugly numbers.\n</pre>\n\n<p><strong class=\"example\">Example 2:</strong></p>\n\n<pre>\n<strong>Input:</strong> n = 1\n<strong>Output:</strong> 1\n<strong>Explanation:</strong> 1 has no prime factors, therefore all of its prime factors are limited to 2, 3, and 5.\n</pre>\n\n<p>&nbsp;</p>\n<p><strong>Constraints:</strong></p>\n\n<ul>\n\t<li><code>1 &lt;= n &lt;= 1690</code></li>\n</ul>\n",
        "solutions": [
            {
                "id": 69364,
                "title": "my-16ms-c-dp-solution-with-short-explanation",
                "content": "We have an array *k* of first n ugly number. We only know, at the beginning, the first one, which is 1. Then\\n\\nk[1] = min( k[0]x2, k[0]x3, k[0]x5). The answer is k[0]x2. So we move 2's pointer to 1. Then we test:\\n\\nk[2] = min( k[1]x2, k[0]x3, k[0]x5). And so on. Be careful about the cases such as 6, in which we need to forward both pointers of 2 and 3. \\n\\nx here is multiplication.\\n\\n    class Solution {\\n    public:\\n        int nthUglyNumber(int n) {\\n            if(n <= 0) return false; // get rid of corner cases \\n            if(n == 1) return true; // base case\\n            int t2 = 0, t3 = 0, t5 = 0; //pointers for 2, 3, 5\\n            vector<int> k(n);\\n            k[0] = 1;\\n            for(int i  = 1; i < n ; i ++)\\n            {\\n                k[i] = min(k[t2]*2,min(k[t3]*3,k[t5]*5));\\n                if(k[i] == k[t2]*2) t2++; \\n                if(k[i] == k[t3]*3) t3++;\\n                if(k[i] == k[t5]*5) t5++;\\n            }\\n            return k[n-1];\\n        }\\n    };",
                "solutionTags": [
                    "C++",
                    "Dynamic Programming"
                ],
                "code": "class Solution {\\n    public:\\n        int nthUglyNumber(int n) {\\n            if(n <= 0) return false; // get rid of corner cases \\n            if(n == 1) return true; // base case\\n            int t2 = 0, t3 = 0, t5 = 0; //pointers for 2, 3, 5\\n            vector<int> k(n);\\n            k[0] = 1;\\n            for(int i  = 1; i < n ; i ++)\\n            {\\n                k[i] = min(k[t2]*2,min(k[t3]*3,k[t5]*5));\\n                if(k[i] == k[t2]*2) t2++; \\n                if(k[i] == k[t3]*3) t3++;\\n                if(k[i] == k[t5]*5) t5++;\\n            }",
                "codeTag": "Java"
            },
            {
                "id": 69362,
                "title": "o-n-java-solution",
                "content": "The idea of this solution is from this page:http://www.geeksforgeeks.org/ugly-numbers/\\n   \\nThe ugly-number sequence is 1, 2, 3, 4, 5, 6, 8, 9, 10, 12, 15, \\u2026\\nbecause every number can only be divided by 2, 3, 5, one way to look at the sequence is to split the sequence to three groups as below:\\n\\n    (1) 1\\xd72, 2\\xd72, 3\\xd72, 4\\xd72, 5\\xd72, \\u2026\\n    (2) 1\\xd73, 2\\xd73, 3\\xd73, 4\\xd73, 5\\xd73, \\u2026\\n    (3) 1\\xd75, 2\\xd75, 3\\xd75, 4\\xd75, 5\\xd75, \\u2026\\n   \\nWe can find that every subsequence is the ugly-sequence itself (1, 2, 3, 4, 5, \\u2026) multiply 2, 3, 5. \\n\\nThen we use similar merge method as merge sort, to get every ugly number from the three subsequence.    \\n\\nEvery step we choose the smallest one, and move one step after,including nums with same value.\\n\\nThanks for this author about this brilliant idea. Here is my java solution\\n\\n    public class Solution {\\n        public int nthUglyNumber(int n) {\\n            int[] ugly = new int[n];\\n            ugly[0] = 1;\\n            int index2 = 0, index3 = 0, index5 = 0;\\n            int factor2 = 2, factor3 = 3, factor5 = 5;\\n            for(int i=1;i<n;i++){\\n                int min = Math.min(Math.min(factor2,factor3),factor5);\\n                ugly[i] = min;\\n                if(factor2 == min)\\n                    factor2 = 2*ugly[++index2];\\n                if(factor3 == min)\\n                    factor3 = 3*ugly[++index3];\\n                if(factor5 == min)\\n                    factor5 = 5*ugly[++index5];\\n            }\\n            return ugly[n-1];\\n        }\\n    }",
                "solutionTags": [
                    "Java"
                ],
                "code": "class Solution {\\n        public int nthUglyNumber(int n) {\\n            int[] ugly = new int[n];\\n            ugly[0] = 1;\\n            int index2 = 0, index3 = 0, index5 = 0;\\n            int factor2 = 2, factor3 = 3, factor5 = 5;\\n            for(int i=1;i<n;i++){\\n                int min = Math.min(Math.min(factor2,factor3),factor5);\\n                ugly[i] = min;\\n                if(factor2 == min)\\n                    factor2 = 2*ugly[++index2];\\n                if(factor3 == min)\\n                    factor3 = 3*ugly[++index3];\\n                if(factor5 == min)\\n                    factor5 = 5*ugly[++index5];\\n            }",
                "codeTag": "Java"
            },
            {
                "id": 69368,
                "title": "elegant-c-solution-o-n-space-time-with-detailed-explanation",
                "content": "    struct Solution {\\n        int nthUglyNumber(int n) {\\n            vector <int> results (1,1);\\n            int i = 0, j = 0, k = 0;\\n            while (results.size() < n)\\n            {\\n                results.push_back(min(results[i] * 2, min(results[j] * 3, results[k] * 5)));\\n                if (results.back() == results[i] * 2) ++i;\\n                if (results.back() == results[j] * 3) ++j;\\n                if (results.back() == results[k] * 5) ++k;\\n            }\\n            return results.back();\\n        }\\n    };\\n\\n**Explanation:**\\n\\nThe key is to realize each number can be and have to be generated by a former number multiplied by 2, 3 or 5\\ne.g. \\n1 2 3 4 5 6 8 9 10 12 15..\\nwhat is next?\\nit must be x * 2 or y * 3 or z * 5, where x, y, z is an existing number.\\n\\nHow do we determine x, y, z then?\\napparently, you can just *traverse the sequence generated by far* from 1 ... 15, until you find such x, y, z that x * 2, y * 3, z * 5 is just bigger than 15. In this case x=8, y=6, z=4. Then you compare x * 2, y * 3, z * 5 so you know next number will be x * 2 = 8 * 2 = 16.\\nk, now you have 1,2,3,4,....,15, 16,\\n\\nThen what is next?\\nYou wanna do the same process again to find the new x, y, z, but you realize, wait, do I have to \\n*traverse the sequence generated by far* again? \\n\\nNO! since you know last time, x=8, y=6, z=4 and x=8 was used to generate 16, so this time, you can immediately know the new_x = 9 (the next number after 8 is 9 in the generated sequence), y=6, z=4.\\nThen you need to compare new_x * 2, y * 3, z * 5. You know next number is 9 * 2 = 18;\\n\\nAnd you also know, the next x will be 10 since new_x = 9 was used this time.\\nBut what is next y? apparently, if y=6, 6*3 = 18, which is already generated in this round. So you also need to update next y from 6 to 8.\\n\\nBased on the idea above, you can actually generated x,y,z from very beginning, and update x, y, z accordingly. It ends up with a O(n) solution.",
                "solutionTags": [],
                "code": "    struct Solution {\\n        int nthUglyNumber(int n) {\\n            vector <int> results (1,1);\\n            int i = 0, j = 0, k = 0;\\n            while (results.size() < n)\\n            {\\n                results.push_back(min(results[i] * 2, min(results[j] * 3, results[k] * 5)));\\n                if (results.back() == results[i] * 2) ++i;\\n                if (results.back() == results[j] * 3) ++j;\\n                if (results.back() == results[k] * 5) ++k;\\n            }\\n            return results.back();\\n        }\\n    };\\n\\n**Explanation:**\\n\\nThe key is to realize each number can be and have to be generated by a former number multiplied by 2, 3 or 5\\ne.g. \\n1 2 3 4 5 6 8 9 10 12 15..\\nwhat is next?\\nit must be x * 2 or y * 3 or z * 5, where x, y, z is an existing number.\\n\\nHow do we determine x, y, z then?\\napparently, you can just *traverse the sequence generated by far* from 1 ... 15, until you find such x, y, z that x * 2, y * 3, z * 5 is just bigger than 15. In this case x=8, y=6, z=4. Then you compare x * 2, y * 3, z * 5 so you know next number will be x * 2 = 8 * 2 = 16.\\nk, now you have 1,2,3,4,....,15, 16,\\n\\nThen what is next?\\nYou wanna do the same process again to find the new x, y, z, but you realize, wait, do I have to \\n*traverse the sequence generated by far* again? \\n\\nNO! since you know last time, x=8, y=6, z=4 and x=8 was used to generate 16, so this time, you can immediately know the new_x = 9 (the next number after 8 is 9 in the generated sequence), y=6, z=4.\\nThen you need to compare new_x * 2, y * 3, z * 5. You know next number is 9 * 2 = 18;\\n\\nAnd you also know, the next x will be 10 since new_x = 9 was used this time.\\nBut what is next y? apparently, if y=6, 6*3 = 18, which is already generated in this round. So you also need to update next y from 6 to 8.\\n\\nBased on the idea above, you can actually generated x,y,z from very beginning, and update x, y, z accordingly. It ends up with a O(n) solution.",
                "codeTag": "Unknown"
            },
            {
                "id": 69384,
                "title": "my-expressive-python-solution",
                "content": "\\n    def nthUglyNumber(self, n):\\n        ugly = [1]\\n        i2, i3, i5 = 0, 0, 0\\n        while n > 1:\\n            u2, u3, u5 = 2 * ugly[i2], 3 * ugly[i3], 5 * ugly[i5]\\n            umin = min((u2, u3, u5))\\n            if umin == u2:\\n                i2 += 1\\n            if umin == u3:\\n                i3 += 1\\n            if umin == u5:\\n                i5 += 1\\n            ugly.append(umin)\\n            n -= 1\\n        return ugly[-1]",
                "solutionTags": [
                    "Python"
                ],
                "code": "\\n    def nthUglyNumber(self, n):\\n        ugly = [1]\\n        i2, i3, i5 = 0, 0, 0\\n        while n > 1:\\n            u2, u3, u5 = 2 * ugly[i2], 3 * ugly[i3], 5 * ugly[i5]\\n            umin = min((u2, u3, u5))\\n            if umin == u2:\\n                i2 += 1\\n            if umin == u3:\\n                i3 += 1\\n            if umin == u5:\\n                i5 += 1\\n            ugly.append(umin)\\n            n -= 1\\n        return ugly[-1]",
                "codeTag": "Python3"
            },
            {
                "id": 718879,
                "title": "python-o-n-universal-dp-solution-explained",
                "content": "Let us solve this problem for general case: that is not only for `2,3,5` divisors, but for any of them and any number of them. `factors = [2,3,5]` and  `k=3` in our case.\\nLet `Numbers` be an array, where we keep all our **ugly** numbers. Also, note, that any ugly number is some other ugly number, multiplied by `2`, `3` or `5`. So, let `starts` be the indexes of ugly numbers, that when multiplied by `2`, `3` or `5` respectively, produces the smallest ugly number that is larger than the current overall maximum ugly number.. Let us do several first steps to understand it better:\\n\\n1. `starts = [0,0,0]` for numbers `2,3,5`, so `new_num = min(1*2,1*3,1*5) = 2`, and now `starts = [1,0,0]`, `Numbers = [1,2]`.\\n2. `starts = [1,0,0]`, so `new_num = min(2*2,1*3,1*5) = 3`, and now `starts = [1,1,0]`, `Numbers = [1,2,3]`.\\n3. `starts = [1,1,0]`, so `new_num = min(2*2,2*3,1*5) = 4`, so now `starts = [2,1,0]`, `Numbers = [1,2,3,4]`.\\n4. `starts = [2,1,0]`, so `new_num = min(3*2,2*3,1*5) = 5`, so now `starts = [2,1,1]`, `Numbers = [1,2,3,4,5]`.\\n5. `starts = [2,1,1]`, so `new_num = min(3*2,2*3,2*5) = 6`, so let us be carefull in this case: we need to increase two numbers from `start`, because our new number `6` can be divided both by `2` and `3`, so now `starts = [3,2,1]`, `Numbers = [1,2,3,4,5,6]`.\\n6. `starts = [3,2,1]`, so `new_num = min(4*2,3*3,2*5) = 8`, so now `starts = [4,2,1]`, `Numbers = [1,2,3,4,5,6,8]`\\n7. `starts = [4,2,1]`, so `new_num = min(5*2,3*3,2*5) = 9`, so now `starts = [4,3,1]`, `Numbers = [1,2,3,4,5,6,8,9]`.\\n8. `starts = [4,3,1]`, so `new_num = min(5*2,4*3,2*5) = 10`, so we need to update two elements from `starts` and now `starts = [5,3,2]`, `Numbers = [1,2,3,4,5,6,8,9,10]`\\n9. `starts = [5,3,2]`, so `new_num = min(6*2,4*3,3*5) = 12`, we again need to update two elements from `starts`, and now `starts = [6,4,2]`, `Numbers = [1,2,3,4,5,6,8,9,10,12]`.\\n10. `starts = [6,4,2]`, so `new_num = min(8*2,5*3,3*5) = 15`, we again need to update two elements from `starts`, and now `starts = [6,5,3]`, `Numbers = [1,2,3,4,5,6,8,9,10,12,15]`.\\n\\n**Complexity**: time complexity is `O(n)` to find ugly number with number `n`, because on each step we check `3` possible candidates. Space complexity is `O(n)` as well. Note, that it can be easily generalized for different amount of divisors with time complexity `O(nk)`, where `k` is total number of divisors.\\n\\n```\\nclass Solution:\\n    def nthUglyNumber(self, n):\\n        factors, k = [2,3,5], 3\\n        starts, Numbers = [0] * k, [1]\\n        for i in range(n-1):\\n            candidates = [factors[i]*Numbers[starts[i]] for i in range(k)]\\n            new_num = min(candidates)\\n            Numbers.append(new_num)\\n            starts = [starts[i] + (candidates[i] == new_num) for i in range(k)]\\n        return Numbers[-1]\\n```\\n\\nIf you have any questions, feel free to ask. If you like solution and explanations, please **Upvote!**",
                "solutionTags": [
                    "Dynamic Programming"
                ],
                "code": "```\\nclass Solution:\\n    def nthUglyNumber(self, n):\\n        factors, k = [2,3,5], 3\\n        starts, Numbers = [0] * k, [1]\\n        for i in range(n-1):\\n            candidates = [factors[i]*Numbers[starts[i]] for i in range(k)]\\n            new_num = min(candidates)\\n            Numbers.append(new_num)\\n            starts = [starts[i] + (candidates[i] == new_num) for i in range(k)]\\n        return Numbers[-1]\\n```",
                "codeTag": "Java"
            },
            {
                "id": 69373,
                "title": "short-and-o-n-python-and-c",
                "content": "I love this problem. Came up with a linear time solution almost 13 years ago and now I still correctly remembered that it was problem 136 at the now defunct acm.uva.es :-)\\n\\n---\\n\\n**Python** ... **Simple Precompute** ... 64 ms\\n\\nIt's fastest to precompute and store all possibilities for lookup, and it's simplest to just generate them out of order and then sort them.\\n\\n    class Solution:\\n        ugly = sorted(2**a * 3**b * 5**c\\n                      for a in range(32) for b in range(20) for c in range(14))\\n        def nthUglyNumber(self, n):\\n            return self.ugly[n-1]\\n\\n---\\n\\n**Python** ... **O(n), generate first n in order** ... 308 ms\\n\\nMy version of [epsilon0's solution](https://uva.onlinejudge.org/board/viewtopic.php?p=6441#p6441). It's nicer than my own old one.\\n\\nThis generates the first n ugly numbers, in order from smallest to largest, in O(n) time. For each prime 2, 3 and 5, have an index to the next number that can be multiplied with the prime to produce a new ugly number. Update the three indexes and then add the smallest of the three candidate ugly numbers.\\n\\n    def nthUglyNumber(self, n):\\n        ugly = [1]\\n        i2 = i3 = i5 = 0\\n        while len(ugly) < n:\\n            while ugly[i2] * 2 <= ugly[-1]: i2 += 1\\n            while ugly[i3] * 3 <= ugly[-1]: i3 += 1\\n            while ugly[i5] * 5 <= ugly[-1]: i5 += 1\\n            ugly.append(min(ugly[i2] * 2, ugly[i3] * 3, ugly[i5] * 5))\\n        return ugly[-1]\\n\\n---\\n\\n**Python** ... **O(n), generate first n in order with heapq.merge** ... 416 ms\\n\\nI like using heapq.merge.\\n\\n    def nthUglyNumber(self, n):\\n        q2, q3, q5 = [2], [3], [5]\\n        ugly = 1\\n        for u in heapq.merge(q2, q3, q5):\\n            if n == 1:\\n                return ugly\\n            if u > ugly:\\n                ugly = u\\n                n -= 1\\n                q2 += 2 * u,\\n                q3 += 3 * u,\\n                q5 += 5 * u,\\n\\nWorks, but might not be totally safe, both because I extend lists while iterating over them and because at the start, q2 becomes empty for a moment, which I think allows heapq.merge to drop it (at least in CPython it just doesn't, as it first yields the value before trying to get the next one from that list, and when it continues, the list isn't empty anymore).\\n\\n---\\n\\n**C++** ... **O(n), generate first n in order** ... 12 ms\\n\\nC++ version of the second Python solution, though adding extra variables for the three candidates to prevent re-multiplication.\\n\\n    int nthUglyNumber(int n) {\\n        vector<int> ugly(n, 1);\\n        int c2 = 2, c3 = 3, c5 = 5;\\n        int i2 = 0, i3 = 0, i5 = 0;\\n        for (int i=1; i<n; ++i) {\\n            int last = ugly[i] = min(c2, min(c3, c5));\\n            while (c2 <= last) c2 = 2 * ugly[++i2];\\n            while (c3 <= last) c3 = 3 * ugly[++i3];\\n            while (c5 <= last) c5 = 5 * ugly[++i5];\\n        }\\n        return ugly[n-1];\\n    }\\n\\n---\\n\\n**C++** ... **O(n), generate on demand and remember** ... 4 ms\\n\\nSame as the previous, but I keep everything in static variables and only compute more when needed. It's faster, and I think pretty neat.\\n\\n    int nthUglyNumber(int n) {\\n        static vector<int> ugly {1};\\n        static int last(1);\\n        static int c2(2), c3(3), c5(5);\\n        static int i2(0), i3(0), i5(0);\\n        while (ugly.size() < n) {\\n            while (c2 <= last) c2 = 2 * ugly[++i2];\\n            while (c3 <= last) c3 = 3 * ugly[++i3];\\n            while (c5 <= last) c5 = 5 * ugly[++i5];\\n            ugly.push_back(last = min(c2, min(c3, c5)));\\n        }\\n        return ugly[n-1];\\n    }\\n\\n---\\n\\n**C++** ... **Simple Precompute** ... 4 ms\\n\\nPrecompute all possibilities in easy order and sort them.\\n\\n    int nthUglyNumber(int n) {\\n        static vector<int> ugly;\\n        long long a, b, c, m = INT_MAX;\\n        if (ugly.empty()) {\\n            for (a=1; a<=m; a*=2)\\n                for (b=a; b<=m; b*=3)\\n                    for (c=b; c<=m; c*=5)\\n                        ugly.push_back(c);\\n            sort(begin(ugly), end(ugly));\\n        }\\n        return ugly[n-1];\\n    }\\n\\n---\\n\\n**My own old one**\\n\\nPython version of my own O(n) C++ solution from almost [13 years ago](https://uva.onlinejudge.org/board/viewtopic.php?p=6444#p6444). Good old times...\\nMaybe I'll try to improve it, but mainly I wanted to see how a pretty much direct translation would look.\\n\\n    def nthUglyNumber(self, n):\\n        factor = 2, 3, 5\\n        lists = [collections.deque([1]) for _ in range(3)]\\n        for _ in range(n - 1):\\n            next = [lists[i][0] * factor[i] for i in range(3)]\\n            winner = min(range(3), key=lambda j: next[j])\\n            for i in range(winner, 3):\\n                lists[i] += next[winner],\\n            lists[winner].popleft()\\n        return lists[2][-1]",
                "solutionTags": [
                    "C++",
                    "Python"
                ],
                "code": "class Solution:\\n        ugly = sorted(2**a * 3**b * 5**c\\n                      for a in range(32) for b in range(20) for c in range(14))\\n        def nthUglyNumber(self, n):\\n            return self.ugly[n-1]\\n\\n---\\n\\n**Python** ... **O(n), generate first n in order** ... 308 ms\\n\\nMy version of [epsilon0's solution](https://uva.onlinejudge.org/board/viewtopic.php?p=6441#p6441). It's nicer than my own old one.\\n\\nThis generates the first n ugly numbers, in order from smallest to largest, in O(n) time. For each prime 2, 3 and 5, have an index to the next number that can be multiplied with the prime to produce a new ugly number. Update the three indexes and then add the smallest of the three candidate ugly numbers.\\n\\n    def nthUglyNumber(self, n):\\n        ugly = [1]\\n        i2 = i3 = i5 = 0\\n        while len(ugly) < n:\\n            while ugly[i2] * 2 <= ugly[-1]: i2 += 1\\n            while ugly[i3] * 3 <= ugly[-1]: i3 += 1\\n            while ugly[i5] * 5 <= ugly[-1]: i5 += 1\\n            ugly.append(min(ugly[i2] * 2, ugly[i3] * 3, ugly[i5] * 5))\\n        return ugly[-1]\\n\\n---\\n\\n**Python** ... **O(n), generate first n in order with heapq.merge** ... 416 ms\\n\\nI like using heapq.merge.\\n\\n    def nthUglyNumber(self, n):\\n        q2, q3, q5 = [2], [3], [5]\\n        ugly = 1\\n        for u in heapq.merge(q2, q3, q5):\\n            if n == 1:\\n                return ugly\\n            if u > ugly:\\n                ugly = u\\n                n -= 1\\n                q2 += 2 * u,\\n                q3 += 3 * u,\\n                q5 += 5 * u,\\n\\nWorks, but might not be totally safe, both because I extend lists while iterating over them and because at the start, q2 becomes empty for a moment, which I think allows heapq.merge to drop it (at least in CPython it just doesn't, as it first yields the value before trying to get the next one from that list, and when it continues, the list isn't empty anymore).\\n\\n---\\n\\n**C++** ... **O(n), generate first n in order** ... 12 ms\\n\\nC++ version of the second Python solution, though adding extra variables for the three candidates to prevent re-multiplication.\\n\\n    int nthUglyNumber(int n) {\\n        vector<int> ugly(n, 1);\\n        int c2 = 2, c3 = 3, c5 = 5;\\n        int i2 = 0, i3 = 0, i5 = 0;\\n        for (int i=1; i<n; ++i) {\\n            int last = ugly[i] = min(c2, min(c3, c5));\\n            while (c2 <= last) c2 = 2 * ugly[++i2];\\n            while (c3 <= last) c3 = 3 * ugly[++i3];\\n            while (c5 <= last) c5 = 5 * ugly[++i5];\\n        }",
                "codeTag": "Java"
            },
            {
                "id": 3235848,
                "title": "best-c-3-solution-dp-tabulation-hash-table-math-one-stop-solution",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nWe can solve this question using Multiple Approaches. (Here I have explained all the possible solutions of this problem).\\n\\n1. Solved using Math.\\n2. Solved using Hash Table.\\n3. Solved using Dynamic Programming (Tabulation).\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\nWe can easily understand the all the approaches by seeing the code which is easy to understand with comments.\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\nTime complexity is given in code comment.\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\nSpace complexity is given in code comment.\\n\\n# Code\\n```\\n/*\\n\\n    Time Complexity : O(K) where K is the nth ugly number. Beacuse we are traversing the loop K times so, the\\n    time complexity is O(K).\\n\\n    Space Complexity : O(1), Constant space.\\n\\n    Solved using Math.\\n\\n    Note : This approach will give TLE.\\n\\n*/\\n\\n\\n/***************************************** Approach 1 *****************************************/\\n\\nclass Solution {\\nprivate:\\n    int keepsOndividingUntilPossible(int dividend, int divisor){\\n        while(dividend % divisor == 0){\\n            dividend /= divisor;\\n        }\\n        return dividend;\\n    }\\npublic:\\n    int nthUglyNumber(int n) {\\n        int i=0, count=0;\\n        while(count < n){\\n            int isUgly = i+1;\\n            for(auto factor : {2,3,5}){\\n                isUgly = keepsOndividingUntilPossible(isUgly, factor);\\n            }\\n            if(isUgly == 1){\\n                count++;\\n            }\\n            i++;\\n        }\\n        return i;\\n    }\\n};\\n\\n\\n\\n\\n\\n\\n/*\\n\\n    Time Complexity : O(NlogN), The time complexity of the code is O(NlogN) since we are doing 3 insertion\\n    operation in Hash Table(set) for each iteration in loop N times and insertion operation in Hash Table(set) \\n    takes logN time. Where N is the given number n.\\n\\n    Space Complexity : O(N), Hash Table(set) space.\\n\\n    Solved using Hash Table.\\n\\n*/\\n\\n\\n/***************************************** Approach 2 *****************************************/\\n\\nclass Solution {\\npublic:\\n    int nthUglyNumber(int n) {\\n        set<long> set;\\n        long nthNumber = 1;\\n        set.insert(nthNumber);\\n        for(int i=0; i<n; i++){\\n            nthNumber = *set.begin();\\n            set.erase(nthNumber);\\n            set.insert(nthNumber*2);\\n            set.insert(nthNumber*3);\\n            set.insert(nthNumber*5);\\n        }\\n        return nthNumber;\\n    }\\n};\\n\\n\\n\\n\\n\\n\\n/*\\n\\n    Time Complexity : O(N), Here loop creates the time Complexity. Where N is the given number n.\\n\\n    Space Complexity : O(N), Array(dp) space.\\n\\n    Solved using Dynamic Programming (Tabulation).\\n\\n*/\\n\\n\\n/***************************************** Approach 3 *****************************************/\\n\\nclass Solution {\\npublic:\\n    int nthUglyNumber(int n) {\\n        vector<int> dp(n);\\n        dp[0]=1;\\n        int x=0, y=0, z=0;\\n        for(int i=1; i<n; i++){\\n            dp[i] = min(dp[x]*2, min(dp[y]*3, dp[z]*5));\\n            if(dp[i] == 2*dp[x]) x++;\\n            if(dp[i] == 3*dp[y]) y++;\\n            if(dp[i] == 5*dp[z]) z++;\\n        }\\n        return dp[n-1];\\n    }\\n};\\n\\n```\\n\\n***IF YOU LIKE THE SOLUTION THEN PLEASE UPVOTE MY SOLUTION BECAUSE IT GIVES ME MOTIVATION TO REGULARLY POST THE SOLUTION.***\\n\\n![WhatsApp Image 2023-02-10 at 19.01.02.jpeg](https://assets.leetcode.com/users/images/0a95fea4-64f4-4502-82aa-41db6d77c05c_1676054939.8270252.jpeg)",
                "solutionTags": [
                    "C++",
                    "Hash Table",
                    "Math",
                    "Dynamic Programming"
                ],
                "code": "```\\n/*\\n\\n    Time Complexity : O(K) where K is the nth ugly number. Beacuse we are traversing the loop K times so, the\\n    time complexity is O(K).\\n\\n    Space Complexity : O(1), Constant space.\\n\\n    Solved using Math.\\n\\n    Note : This approach will give TLE.\\n\\n*/\\n\\n\\n/***************************************** Approach 1 *****************************************/\\n\\nclass Solution {\\nprivate:\\n    int keepsOndividingUntilPossible(int dividend, int divisor){\\n        while(dividend % divisor == 0){\\n            dividend /= divisor;\\n        }\\n        return dividend;\\n    }\\npublic:\\n    int nthUglyNumber(int n) {\\n        int i=0, count=0;\\n        while(count < n){\\n            int isUgly = i+1;\\n            for(auto factor : {2,3,5}){\\n                isUgly = keepsOndividingUntilPossible(isUgly, factor);\\n            }\\n            if(isUgly == 1){\\n                count++;\\n            }\\n            i++;\\n        }\\n        return i;\\n    }\\n};\\n\\n\\n\\n\\n\\n\\n/*\\n\\n    Time Complexity : O(NlogN), The time complexity of the code is O(NlogN) since we are doing 3 insertion\\n    operation in Hash Table(set) for each iteration in loop N times and insertion operation in Hash Table(set) \\n    takes logN time. Where N is the given number n.\\n\\n    Space Complexity : O(N), Hash Table(set) space.\\n\\n    Solved using Hash Table.\\n\\n*/\\n\\n\\n/***************************************** Approach 2 *****************************************/\\n\\nclass Solution {\\npublic:\\n    int nthUglyNumber(int n) {\\n        set<long> set;\\n        long nthNumber = 1;\\n        set.insert(nthNumber);\\n        for(int i=0; i<n; i++){\\n            nthNumber = *set.begin();\\n            set.erase(nthNumber);\\n            set.insert(nthNumber*2);\\n            set.insert(nthNumber*3);\\n            set.insert(nthNumber*5);\\n        }\\n        return nthNumber;\\n    }\\n};\\n\\n\\n\\n\\n\\n\\n/*\\n\\n    Time Complexity : O(N), Here loop creates the time Complexity. Where N is the given number n.\\n\\n    Space Complexity : O(N), Array(dp) space.\\n\\n    Solved using Dynamic Programming (Tabulation).\\n\\n*/\\n\\n\\n/***************************************** Approach 3 *****************************************/\\n\\nclass Solution {\\npublic:\\n    int nthUglyNumber(int n) {\\n        vector<int> dp(n);\\n        dp[0]=1;\\n        int x=0, y=0, z=0;\\n        for(int i=1; i<n; i++){\\n            dp[i] = min(dp[x]*2, min(dp[y]*3, dp[z]*5));\\n            if(dp[i] == 2*dp[x]) x++;\\n            if(dp[i] == 3*dp[y]) y++;\\n            if(dp[i] == 5*dp[z]) z++;\\n        }\\n        return dp[n-1];\\n    }\\n};\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 69372,
                "title": "java-solution-using-priorityqueue",
                "content": "    public int nthUglyNumber(int n) {\\n        if(n==1) return 1;\\n        PriorityQueue<Long> q = new PriorityQueue();\\n        q.add(1l);\\n        \\n        for(long i=1; i<n; i++) {\\n            long tmp = q.poll();\\n            while(!q.isEmpty() && q.peek()==tmp) tmp = q.poll();\\n            \\n            q.add(tmp*2);\\n            q.add(tmp*3);\\n            q.add(tmp*5);\\n        }\\n        return q.poll().intValue();\\n    }",
                "solutionTags": [],
                "code": "    public int nthUglyNumber(int n) {\\n        if(n==1) return 1;\\n        PriorityQueue<Long> q = new PriorityQueue();\\n        q.add(1l);\\n        \\n        for(long i=1; i<n; i++) {\\n            long tmp = q.poll();\\n            while(!q.isEmpty() && q.peek()==tmp) tmp = q.poll();\\n            \\n            q.add(tmp*2);\\n            q.add(tmp*3);\\n            q.add(tmp*5);\\n        }\\n        return q.poll().intValue();\\n    }",
                "codeTag": "Unknown"
            },
            {
                "id": 719055,
                "title": "c-simple-and-detailed-explanation",
                "content": "We have to find the nth ugly number.\\n\\nWe can check for all numbers up to `n` whether it is ugly or not and return the nth ugly number. But that would lead to a TLE for numbers like `1690`.\\n\\nBetter approach is to check only for the multiples of `2`, `3`, or `5`, and return the nth ugly number. \\n\\nHere, we store all the ugly numbers till n by maintaining a track of the indices of the multiples of 2, 3 and 5. We do this for creating a sorted list of all the ugly numbers. We return the last number in the list. Code for this approach is  shown below. \\n\\nPlease post your comments/queries in the comments section.\\n\\n```\\nclass Solution {\\nprivate:\\n    \\npublic:\\n    int nthUglyNumber(int n) {\\n        if(n == 1)\\n            return 1;\\n        vector<int> uglies(n);\\n        uglies[0] = 1;\\n        int l2 = 0, l3 = 0, l5 = 0; //indexes for respective list\\n        for(int i=1; i<n; i++)\\n        {\\n            uglies[i] = min(2 * uglies[l2], min(3 * uglies[l3], 5 * uglies[l5]));\\n            if(uglies[i] == 2 * uglies[l2])\\n                l2++;\\n            if(uglies[i] == 3 * uglies[l3])\\n                l3++;\\n            if(uglies[i] == 5 * uglies[l5])\\n                l5++;\\n        }\\n        return uglies[n - 1];\\n    }\\n};\\n```\\n\\nIf you liked my explanation, then would you be so kind as to upvote my post? It gives me motivation to keep explaining questions in a simple and detailed manner.",
                "solutionTags": [
                    "Dynamic Programming"
                ],
                "code": "```\\nclass Solution {\\nprivate:\\n    \\npublic:\\n    int nthUglyNumber(int n) {\\n        if(n == 1)\\n            return 1;\\n        vector<int> uglies(n);\\n        uglies[0] = 1;\\n        int l2 = 0, l3 = 0, l5 = 0; //indexes for respective list\\n        for(int i=1; i<n; i++)\\n        {\\n            uglies[i] = min(2 * uglies[l2], min(3 * uglies[l3], 5 * uglies[l5]));\\n            if(uglies[i] == 2 * uglies[l2])\\n                l2++;\\n            if(uglies[i] == 3 * uglies[l3])\\n                l3++;\\n            if(uglies[i] == 5 * uglies[l5])\\n                l5++;\\n        }\\n        return uglies[n - 1];\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 69385,
                "title": "java-easy-understand-o-n-solution",
                "content": "The basic idea of this problem is to compute all the ugly numbers in sequence and count to the given number of k ugly numbers. The way I approached this problem is first I have a arraylist to store the ugly numbers in sequence. Then I declared three counter variables: a,b,and c which represent the corresponding index in the arraylist for the multiplier of 2,3,and 5. Since each previous ugly number times one of the multiplier will produce a new ugly number, I start from the starting index 0 and multiply the ugly number at that index with each multiplier and get the smallest product which is the next ugly number from the three. The corresponding multipliers' index will be incremented by one and we do this recursively until we have K ugly numbers. Here is the code implementation in Java:\\n\\n    public class Solution {\\n    \\tpublic int nthUglyNumber(int n) {\\n    \\t\\tif(n<=0) return 0;\\n    \\t\\tint a=0,b=0,c=0;\\n    \\t\\tList<Integer> table = new ArrayList<Integer>();\\n    \\t\\ttable.add(1);\\n    \\t\\twhile(table.size()<n)\\n    \\t\\t{\\n    \\t\\t\\tint next_val = Math.min(table.get(a)*2,Math.min(table.get(b)*3,table.get(c)*5));\\n    \\t\\t\\ttable.add(next_val);\\n    \\t\\t\\tif(table.get(a)*2==next_val) a++;\\n    \\t\\t\\tif(table.get(b)*3==next_val) b++;\\n    \\t\\t\\tif(table.get(c)*5==next_val) c++;\\n    \\t\\t}\\n    \\t\\treturn table.get(table.size()-1);\\n    \\t}\\n    }",
                "solutionTags": [
                    "Java"
                ],
                "code": "class Solution {\\n    \\tpublic int nthUglyNumber(int n) {\\n    \\t\\tif(n<=0) return 0;\\n    \\t\\tint a=0,b=0,c=0;\\n    \\t\\tList<Integer> table = new ArrayList<Integer>();\\n    \\t\\ttable.add(1);\\n    \\t\\twhile(table.size()<n)\\n    \\t\\t{\\n    \\t\\t\\tint next_val = Math.min(table.get(a)*2,Math.min(table.get(b)*3,table.get(c)*5));\\n    \\t\\t\\ttable.add(next_val);\\n    \\t\\t\\tif(table.get(a)*2==next_val) a++;\\n    \\t\\t\\tif(table.get(b)*3==next_val) b++;\\n    \\t\\t\\tif(table.get(c)*5==next_val) c++;\\n    \\t\\t}",
                "codeTag": "Java"
            },
            {
                "id": 69439,
                "title": "shortest-o-n-java-dp-solution",
                "content": "    public int nthUglyNumber(int n) {\\n            if(n==1) return 1;\\n            int[] dp = new int[n+1]; // dp[i] holds the ith's ugly number\\n            dp[1] = 1;\\n            int p2=1, p3=1, p5=1;\\n            for(int i=2; i<=n; i++){ // loop invariant:dp[i] holds the smallest ith uglynumber\\n                dp[i] = Math.min(2*dp[p2], Math.min(3*dp[p3],5*dp[p5])); // the next ugly number must be built from a smaller ugly number\\n                if(dp[i]==2*dp[p2])p2++; \\n                if(dp[i]==3*dp[p3])p3++;\\n                if(dp[i]==5*dp[p5])p5++;\\n            }\\n            return dp[n];\\n        }",
                "solutionTags": [],
                "code": "    public int nthUglyNumber(int n) {\\n            if(n==1) return 1;\\n            int[] dp = new int[n+1]; // dp[i] holds the ith's ugly number\\n            dp[1] = 1;\\n            int p2=1, p3=1, p5=1;\\n            for(int i=2; i<=n; i++){ // loop invariant:dp[i] holds the smallest ith uglynumber\\n                dp[i] = Math.min(2*dp[p2], Math.min(3*dp[p3],5*dp[p5])); // the next ugly number must be built from a smaller ugly number\\n                if(dp[i]==2*dp[p2])p2++; \\n                if(dp[i]==3*dp[p3])p3++;\\n                if(dp[i]==5*dp[p5])p5++;\\n            }\\n            return dp[n];\\n        }",
                "codeTag": "Unknown"
            },
            {
                "id": 1271546,
                "title": "c-solution-with-explaination-dp-approach",
                "content": "* **DP approach** \\n*  **using Tabulation** \\n* **O(N) time complexity** \\n\\n```\\nclass Solution {\\npublic:\\n    int nthUglyNumber(int n) {\\n        int dp[n+1]; // initialize dp array with n+1\\n        dp[1] =1;\\n        int p2 =1, p3 = 1, p5 = 1;// pointer p2 is for 2, p3 for 3, p5 for 5\\n        for(int i =2; i<= n ; i++){\\n            int f2 =  2* dp[p2]; \\n            int f3 = 3* dp[p3];\\n            int f5 = 5* dp[p5];\\n            int min_ = min(f1, min(f2, f3)); // find the min  of all \\n\\t\\t\\t//suppose p2, p3 & p5 are at dp[0]  f2 will be  2* 1 , 3*1 , 5*1 \\n            dp[i] = min_; // store the next dp[1] to the minimum of all (f2, f3, f5)\\n\\t\\t\\t//after storing the minimum \\n            if(min_ == f2) p2++; // increment if f2 is min\\n            if(min_ == f3) p3++;// increment if f3 is min\\n            if(min_ == f5) p5++;// increment if f5 is min\\n         }\\n        return dp[n]; // return dp of n\\n    }\\n};\\n```\\n***comment if have doubt and do upvote***",
                "solutionTags": [
                    "C++",
                    "C",
                    "Dynamic Programming"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int nthUglyNumber(int n) {\\n        int dp[n+1]; // initialize dp array with n+1\\n        dp[1] =1;\\n        int p2 =1, p3 = 1, p5 = 1;// pointer p2 is for 2, p3 for 3, p5 for 5\\n        for(int i =2; i<= n ; i++){\\n            int f2 =  2* dp[p2]; \\n            int f3 = 3* dp[p3];\\n            int f5 = 5* dp[p5];\\n            int min_ = min(f1, min(f2, f3)); // find the min  of all \\n\\t\\t\\t//suppose p2, p3 & p5 are at dp[0]  f2 will be  2* 1 , 3*1 , 5*1 \\n            dp[i] = min_; // store the next dp[1] to the minimum of all (f2, f3, f5)\\n\\t\\t\\t//after storing the minimum \\n            if(min_ == f2) p2++; // increment if f2 is min\\n            if(min_ == f3) p3++;// increment if f3 is min\\n            if(min_ == f5) p5++;// increment if f5 is min\\n         }\\n        return dp[n]; // return dp of n\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 69427,
                "title": "c-one-pass-simple-solution",
                "content": "Use three index for 2, 3, 5 in to trace the last generated numbers based on 2, 3, 5 and generate next number based on the last generated numbers.\\n\\n    class Solution {\\n    public:\\n        int nthUglyNumber(int n) {\\n            if(n<1)\\n                return 0;\\n    \\n            int id2=0, id3=0, id5=0, rst=1;\\n            vector<int> buf;\\n    \\n            while(--n)\\n            {\\n                buf.push_back(rst);\\n    \\n                int v2 = 2*(buf[id2]), v3 = 3*(buf[id3]), v5 = 5*(buf[id5]);\\n                rst = min(v2, min(v3, v5));\\n                \\n                id2 += (rst == v2), id3 += (rst == v3), id5 += (rst == v5);\\n            }\\n            return rst;\\n        }\\n    };",
                "solutionTags": [],
                "code": "class Solution {\\n    public:\\n        int nthUglyNumber(int n) {\\n            if(n<1)\\n                return 0;\\n    \\n            int id2=0, id3=0, id5=0, rst=1;\\n            vector<int> buf;\\n    \\n            while(--n)\\n            {\\n                buf.push_back(rst);\\n    \\n                int v2 = 2*(buf[id2]), v3 = 3*(buf[id3]), v5 = 5*(buf[id5]);\\n                rst = min(v2, min(v3, v5));\\n                \\n                id2 += (rst == v2), id3 += (rst == v3), id5 += (rst == v5);\\n            }",
                "codeTag": "Java"
            },
            {
                "id": 1746419,
                "title": "c-easy-short-solution",
                "content": "```\\nclass Solution {\\npublic:\\n    int nthUglyNumber(int n) {\\n        set<long> st;\\n        st.insert(1);\\n        long num = 1;\\n        for(int i=0;i<n;i++){\\n            num = *st.begin();\\n            st.erase(num);\\n            st.insert(num * 2);\\n            st.insert(num * 3);\\n            st.insert(num * 5);\\n        }\\n        return num;\\n    }\\n};\\n```\\nDo upvote if it helped :)",
                "solutionTags": [
                    "C++",
                    "C",
                    "Ordered Set"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int nthUglyNumber(int n) {\\n        set<long> st;\\n        st.insert(1);\\n        long num = 1;\\n        for(int i=0;i<n;i++){\\n            num = *st.begin();\\n            st.erase(num);\\n            st.insert(num * 2);\\n            st.insert(num * 3);\\n            st.insert(num * 5);\\n        }\\n        return num;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 556314,
                "title": "python-simple-dp-9-lines",
                "content": "```\\nclass Solution:\\n    def nthUglyNumber(self, n: int) -> int:\\n        k = [0] * n\\n        t1 = t2 = t3 = 0\\n        k[0] = 1\\n        for i in range(1,n):\\n            k[i] = min(k[t1]*2,k[t2]*3,k[t3]*5)\\n            if(k[i] == k[t1]*2): t1 += 1\\n            if(k[i] == k[t2]*3): t2 += 1\\n            if(k[i] == k[t3]*5): t3 += 1\\n        return k[n-1]\\n```\\nRuntime: 72%",
                "solutionTags": [
                    "Python",
                    "Python3",
                    "Dynamic Programming"
                ],
                "code": "```\\nclass Solution:\\n    def nthUglyNumber(self, n: int) -> int:\\n        k = [0] * n\\n        t1 = t2 = t3 = 0\\n        k[0] = 1\\n        for i in range(1,n):\\n            k[i] = min(k[t1]*2,k[t2]*3,k[t3]*5)\\n            if(k[i] == k[t1]*2): t1 += 1\\n            if(k[i] == k[t2]*3): t2 += 1\\n            if(k[i] == k[t3]*5): t3 += 1\\n        return k[n-1]\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1680263,
                "title": "neat-and-easy-c-dp-solution",
                "content": "```\\nclass Solution {\\npublic:\\n    int nthUglyNumber(int n) {\\n        //check the base case ( n can not be less than 1)\\n        if(n==1){\\n            return 1;\\n        }\\n        vector <int> ans(n);\\n        //store all the ans in this vector\\n        ans[0]=1;\\n        int two=0,three=0,five=0;\\n        for(int i =1;i<n;i++){\\n            ans[i]=min(ans[two]*2,min(ans[three]*3,ans[five]*5));\\n            \\n            if(ans[i]==ans[two]*2)two++;\\n            if(ans[i]==ans[three]*3)three++;\\n            if(ans[i]==ans[five]*5)five++;\\n        }\\n        return ans[n-1];\\n    }\\n};\\n\\n\\n```\\n",
                "solutionTags": [
                    "C++",
                    "Dynamic Programming"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int nthUglyNumber(int n) {\\n        //check the base case ( n can not be less than 1)\\n        if(n==1){\\n            return 1;\\n        }\\n        vector <int> ans(n);\\n        //store all the ans in this vector\\n        ans[0]=1;\\n        int two=0,three=0,five=0;\\n        for(int i =1;i<n;i++){\\n            ans[i]=min(ans[two]*2,min(ans[three]*3,ans[five]*5));\\n            \\n            if(ans[i]==ans[two]*2)two++;\\n            if(ans[i]==ans[three]*3)three++;\\n            if(ans[i]==ans[five]*5)five++;\\n        }\\n        return ans[n-1];\\n    }\\n};\\n\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 69397,
                "title": "sharing-very-simple-and-elegant-python-solution-using-heap-with-explanation",
                "content": "    import heapq\\n    \\n    class Solution(object):\\n        \\n        # The idea is to keep a heap that stores a tuple (val, fact).\\n        # The fact value stores the last factor the number was multiplied to.\\n        # So every time I extract the minimum and look at the queue, I know\\n        # it must be multiplied by queue and next factor, otherwise I will have a\\n        # duplicate. \\n        #\\n        # For example, we have 2 and 5 with fact 2 and fact 5. When I extract\\n        # 2 and fact 2, I will insert 2 * 5 = 10 with fact 5. Then, when I extract 5 from queue\\n        # 5, if I do 5 * 2 (fact 2) = 10,\\n        # I will have a duplicate. So every number coming from\\n        # the k-th fact must be multiplied only by the factor fact and higher.\\n        \\n        \\n        \\n        def nthUglyNumber(self, n):\\n            if n is 1:\\n                return 1\\n            h, val = [(2, 2), (3, 3), (5, 5)], 1\\n            for i in range(1, n):\\n                val, fact = heapq.heappop(h)\\n                heapq.heappush(h, (val * 5, 5))\\n                if fact <= 3:\\n                    heapq.heappush(h, (val * 3, 3))\\n                if fact is 2:\\n                    heapq.heappush(h, (val * 2, 2))\\n            return val",
                "solutionTags": [],
                "code": "    import heapq\\n    \\n    class Solution(object):\\n        \\n        # The idea is to keep a heap that stores a tuple (val, fact).\\n        # The fact value stores the last factor the number was multiplied to.\\n        # So every time I extract the minimum and look at the queue, I know\\n        # it must be multiplied by queue and next factor, otherwise I will have a\\n        # duplicate. \\n        #\\n        # For example, we have 2 and 5 with fact 2 and fact 5. When I extract\\n        # 2 and fact 2, I will insert 2 * 5 = 10 with fact 5. Then, when I extract 5 from queue\\n        # 5, if I do 5 * 2 (fact 2) = 10,\\n        # I will have a duplicate. So every number coming from\\n        # the k-th fact must be multiplied only by the factor fact and higher.\\n        \\n        \\n        \\n        def nthUglyNumber(self, n):\\n            if n is 1:\\n                return 1\\n            h, val = [(2, 2), (3, 3), (5, 5)], 1\\n            for i in range(1, n):\\n                val, fact = heapq.heappop(h)\\n                heapq.heappush(h, (val * 5, 5))\\n                if fact <= 3:\\n                    heapq.heappush(h, (val * 3, 3))\\n                if fact is 2:\\n                    heapq.heappush(h, (val * 2, 2))\\n            return val",
                "codeTag": "Java"
            },
            {
                "id": 3318810,
                "title": "dynamic-programming-logic-python3",
                "content": "\\n\\n# 1. Dynamic Programming\\n```\\nclass Solution:\\n    def nthUglyNumber(self, n: int) -> int:\\n        list1=[0]*n\\n        list1[0]=1\\n        a=b=c=0\\n        for i in range(1,n):\\n            list1[i]=min(list1[a]*2,list1[b]*3,list1[c]*5)\\n            if list1[a]*2==list1[i]:a+=1\\n            if list1[b]*3==list1[i]:b+=1\\n            if list1[c]*5==list1[i]:c+=1\\n        return list1[n-1]\\n        \\n    #please upvote me it would encourage me alot\\n\\n```\\n\\n# please upvote me it would encourage me alot\\n",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def nthUglyNumber(self, n: int) -> int:\\n        list1=[0]*n\\n        list1[0]=1\\n        a=b=c=0\\n        for i in range(1,n):\\n            list1[i]=min(list1[a]*2,list1[b]*3,list1[c]*5)\\n            if list1[a]*2==list1[i]:a+=1\\n            if list1[b]*3==list1[i]:b+=1\\n            if list1[c]*5==list1[i]:c+=1\\n        return list1[n-1]\\n        \\n    #please upvote me it would encourage me alot\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1495746,
                "title": "c-o-n-dp-tabular-approach-with-explaination-very-easy",
                "content": "\\n\\tclass Solution {\\n\\tpublic:\\n    int nthUglyNumber(int n) {\\n\\t\\n        //since the count of numbers to be added is upto n, the vector will contain max n numbers\\n        vector<int> ans(n);\\n        \\n        // x==>pointer to index to which 2 will be multiplied;\\n        // y==>pointer to index to which 3 will be multiplied;\\n        // z==>pointer to index to which 5 will be multiplied;\\n\\t\\t\\n\\t\\t//all x,y,z poniters will start multiplication right from 0th index\\n\\t\\t\\n        int x=0,y=0,z=0;\\n        ans[0]=1;\\n        for(int i=1;i<n;i++)\\n        {\\n            ans[i]=min(ans[x]*2,min(ans[y]*3,ans[z]*5));\\n            if(ans[i]==2*ans[x])x++;\\n            if(ans[i]==3*ans[y])y++;\\n            if(ans[i]==5*ans[z])z++;\\n            \\n            // when ans == value to which more than one pointers among (x,y,z) point, all pointers get increamented\\n        }\\n        return ans[n-1];//last index contains the number of nth count\\n    }\\n};\\n\\n**Please upvote if this helped! **",
                "solutionTags": [
                    "C++",
                    "C",
                    "Dynamic Programming"
                ],
                "code": "class Solution {\\n\\tpublic:\\n    int nthUglyNumber(int n) {\\n\\t\\n        //since the count of numbers to be added is upto n, the vector will contain max n numbers\\n        vector<int> ans(n);\\n        \\n        // x==>pointer to index to which 2 will be multiplied;\\n        // y==>pointer to index to which 3 will be multiplied;\\n        // z==>pointer to index to which 5 will be multiplied;\\n\\t\\t\\n\\t\\t//all x,y,z poniters will start multiplication right from 0th index\\n\\t\\t\\n        int x=0,y=0,z=0;\\n        ans[0]=1;\\n        for(int i=1;i<n;i++)\\n        {\\n            ans[i]=min(ans[x]*2,min(ans[y]*3,ans[z]*5));\\n            if(ans[i]==2*ans[x])x++;\\n            if(ans[i]==3*ans[y])y++;\\n            if(ans[i]==5*ans[z])z++;\\n            \\n            // when ans == value to which more than one pointers among (x,y,z) point, all pointers get increamented\\n        }",
                "codeTag": "Java"
            },
            {
                "id": 1339392,
                "title": "java-2ms-easiest-approach",
                "content": "```\\nclass Solution {\\n    public int nthUglyNumber(int n) {\\n        int c2 = 0,c3 = 0,c5 = 0;\\n        int[] dp = new int[n+1];\\n        dp[0] = 1;\\n        for(int i=1;i<=n;i++)\\n        {\\n            dp[i] = Math.min(2*dp[c2],Math.min(3*dp[c3],dp[c5]*5));\\n            if(dp[i] == 2*dp[c2])\\n                c2++;\\n            if(dp[i] == 3*dp[c3])\\n                c3++;\\n            if(dp[i] == 5*dp[c5])\\n                c5++;\\n        }\\n        return dp[n-1];\\n    }\\n}\\n```\\nPlease upvote if u find my code easy to understand",
                "solutionTags": [
                    "Java",
                    "Dynamic Programming"
                ],
                "code": "```\\nclass Solution {\\n    public int nthUglyNumber(int n) {\\n        int c2 = 0,c3 = 0,c5 = 0;\\n        int[] dp = new int[n+1];\\n        dp[0] = 1;\\n        for(int i=1;i<=n;i++)\\n        {\\n            dp[i] = Math.min(2*dp[c2],Math.min(3*dp[c3],dp[c5]*5));\\n            if(dp[i] == 2*dp[c2])\\n                c2++;\\n            if(dp[i] == 3*dp[c3])\\n                c3++;\\n            if(dp[i] == 5*dp[c5])\\n                c5++;\\n        }\\n        return dp[n-1];\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 69449,
                "title": "x08two-standard-dp-solutions",
                "content": "    // three lists:\\n    // (1) 1\\xd72, 2\\xd72, 3\\xd72, 4\\xd72, 5\\xd72, \\u2026\\n    // (2) 1\\xd73, 2\\xd73, 3\\xd73, 4\\xd73, 5\\xd73, \\u2026\\n    // (3) 1\\xd75, 2\\xd75, 3\\xd75, 4\\xd75, 5\\xd75, \\u2026\\n    \\n    // O(n) time, O(n) space \\n    int nthUglyNumber(int n) {\\n        vector<int> d(n, 0);\\n        d[0] = 1;\\n        \\n        int f2 = 2, f3 = 3, f5 = 5;     // min values for multipy factor 2, 3, 5\\n        int ix2 = 0, ix3 = 0, ix5 = 0;  // indexs for min values of f2, f3, f5 \\n        \\n        for (int i = 1; i < n; ++i) {\\n            int minV = min(min(f2, f3), f5);\\n            d[i] = minV;\\n            \\n            if (minV == f2) f2 = 2 * d[++ix2];\\n            if (minV == f3) f3 = 3 * d[++ix3];\\n            if (minV == f5) f5 = 5 * d[++ix5];\\n        }\\n        \\n        return d[n-1];\\n    }\\n    \\n    // O(n) (might be more) time, O(3n) space\\n    int nthUglyNumber1(int n) {\\n        queue<int> q1, q2, q3;\\n        q1.push(1), q2.push(1), q3.push(1);\\n        \\n        int m = 0;\\n        for (int i = 0; i < n; ++i) {\\n            m = min(min(q1.front(), q2.front()), q3.front());\\n            if (m == q1.front()) q1.pop();\\n            if (m == q2.front()) q2.pop();\\n            if (m == q3.front()) q3.pop();\\n            q1.push(2*m);\\n            q2.push(3*m);\\n            q3.push(5*m);\\n        }\\n        \\n        return m;\\n    }",
                "solutionTags": [],
                "code": "    // three lists:\\n    // (1) 1\\xd72, 2\\xd72, 3\\xd72, 4\\xd72, 5\\xd72, \\u2026\\n    // (2) 1\\xd73, 2\\xd73, 3\\xd73, 4\\xd73, 5\\xd73, \\u2026\\n    // (3) 1\\xd75, 2\\xd75, 3\\xd75, 4\\xd75, 5\\xd75, \\u2026\\n    \\n    // O(n) time, O(n) space \\n    int nthUglyNumber(int n) {\\n        vector<int> d(n, 0);\\n        d[0] = 1;\\n        \\n        int f2 = 2, f3 = 3, f5 = 5;     // min values for multipy factor 2, 3, 5\\n        int ix2 = 0, ix3 = 0, ix5 = 0;  // indexs for min values of f2, f3, f5 \\n        \\n        for (int i = 1; i < n; ++i) {\\n            int minV = min(min(f2, f3), f5);\\n            d[i] = minV;\\n            \\n            if (minV == f2) f2 = 2 * d[++ix2];\\n            if (minV == f3) f3 = 3 * d[++ix3];\\n            if (minV == f5) f5 = 5 * d[++ix5];\\n        }\\n        \\n        return d[n-1];\\n    }\\n    \\n    // O(n) (might be more) time, O(3n) space\\n    int nthUglyNumber1(int n) {\\n        queue<int> q1, q2, q3;\\n        q1.push(1), q2.push(1), q3.push(1);\\n        \\n        int m = 0;\\n        for (int i = 0; i < n; ++i) {\\n            m = min(min(q1.front(), q2.front()), q3.front());\\n            if (m == q1.front()) q1.pop();\\n            if (m == q2.front()) q2.pop();\\n            if (m == q3.front()) q3.pop();\\n            q1.push(2*m);\\n            q2.push(3*m);\\n            q3.push(5*m);\\n        }\\n        \\n        return m;\\n    }",
                "codeTag": "Unknown"
            },
            {
                "id": 69440,
                "title": "ac-python-solution-o-n-time-o-n-space",
                "content": "    def nthUglyNumber(self, n):\\n        ugly = [1] * n\\n        i2 = i3 = i5 = -1\\n        x = v2 = v3 = v5 = 1\\n        for k in xrange(n):\\n            x = min(v2, v3, v5)\\n            ugly[k] = x\\n            if x == v2:\\n                i2 += 1\\n                v2 = ugly[i2] * 2\\n            if x == v3:\\n                i3 += 1\\n                v3 = ugly[i3] * 3\\n            if x == v5:\\n                i5 += 1\\n                v5 = ugly[i5] * 5\\n        return x\\n\\n    # 596 / 596 test cases passed.\\n    # Status: Accepted\\n    # Runtime: 176 ms\\n    # 94.23%\\n\\n\\nThe keys are the same as hint under the problem. One thing is we do not compute the multiplication in the min instead we update the v if needed. Another thing is we can preallocate a size n list instead of append to the list n times in the loop.\\n\\nOf course we can use another loop to make it shorter. But it is also slower.\\n\\n    def nthUglyNumber(self, n):\\n        ugly = [1] * n\\n        primes = [2, 3, 5]\\n        i = [-1] * 3\\n        v = [1] * 3\\n        for k in xrange(n):\\n            ugly[k] = min(v)\\n            for j in xrange(3):\\n                if v[j] == ugly[k]:\\n                    i[j] += 1\\n                    v[j] = ugly[i[j]] * primes[j]\\n        return ugly[-1]\\n\\n\\n    # 596 / 596 test cases passed.\\n    # Status: Accepted\\n    # Runtime: 332 ms\\n    # 29.89%",
                "solutionTags": [
                    "Python"
                ],
                "code": "    def nthUglyNumber(self, n):\\n        ugly = [1] * n\\n        i2 = i3 = i5 = -1\\n        x = v2 = v3 = v5 = 1\\n        for k in xrange(n):\\n            x = min(v2, v3, v5)\\n            ugly[k] = x\\n            if x == v2:\\n                i2 += 1\\n                v2 = ugly[i2] * 2\\n            if x == v3:\\n                i3 += 1\\n                v3 = ugly[i3] * 3\\n            if x == v5:\\n                i5 += 1\\n                v5 = ugly[i5] * 5\\n        return x\\n\\n    # 596 / 596 test cases passed.\\n    # Status: Accepted\\n    # Runtime: 176 ms\\n    # 94.23%\\n\\n\\nThe keys are the same as hint under the problem. One thing is we do not compute the multiplication in the min instead we update the v if needed. Another thing is we can preallocate a size n list instead of append to the list n times in the loop.\\n\\nOf course we can use another loop to make it shorter. But it is also slower.\\n\\n    def nthUglyNumber(self, n):\\n        ugly = [1] * n\\n        primes = [2, 3, 5]\\n        i = [-1] * 3\\n        v = [1] * 3\\n        for k in xrange(n):\\n            ugly[k] = min(v)\\n            for j in xrange(3):\\n                if v[j] == ugly[k]:\\n                    i[j] += 1\\n                    v[j] = ugly[i[j]] * primes[j]\\n        return ugly[-1]\\n\\n\\n    # 596 / 596 test cases passed.\\n    # Status: Accepted\\n    # Runtime: 332 ms\\n    # 29.89%",
                "codeTag": "Python3"
            },
            {
                "id": 408571,
                "title": "summary-of-ugly-number-i-ii-dp-priority-queue",
                "content": "Reference: [Problem I](https://leetcode.com/problems/ugly-number/) & [Problem II](https://leetcode.com/problems/ugly-number-ii/)\\nDifficulty: <span class=\"green\">Easy</span>\\n\\n## Problem\\n\\n> Write a program to check whether a given number is an ugly number.\\n\\n> Ugly numbers are **positive numbers** whose `prime factors` only include `2, 3, 5`.\\n\\n**Note:** \\n\\n- `Non-prime factors` are allowed, e.g. `8` is an ugly number.\\n- `1` is typically treated as an ugly number.\\n- Input is within the 32-bit signed integer range: `[\\u22122^{31},  2^{31} \\u2212 1]`.\\n\\n\\n**Example:** \\n\\n```java\\nInput: -1, 0\\nOutput: false\\n\\nInput: 1\\nOutput: true\\n\\nInput: 2, 3, 5\\nOutput: true\\nExplanation: although they are primes, they are ugly.\\n\\nInput: 7, 11\\nOutput: false\\nExplanation: They are primes, but they are not ugly. They are other prime factors themselves.\\n\\nInput: 4\\nOutput: true\\nExplanation: 4 = 1 x 4, 2 x 2 (no other prime factors)\\n\\nInput: 6\\nOutput: true\\nExplanation: 6 = 1 x 6, 2 \\xD7 3 (no other prime factors)\\n\\nInput: 21\\nOutput: false\\nExplanation: 21 = 3 x 7 (7 is the other prime factor)\\n```\\n\\n\\n## Analysis\\n\\nThe brute-force solution is to check all prime factors of `num`. By examining prime factors, determining if the factor is a prime is costly.\\n\\n### Recursion\\n\\nThe idea is that if a number `num` has factors `2, 3, 5` remove the effect of these factors by division. For example, `21` has a factor `3`, so we can determine if it is an ugly number by indirectly checking if `21 / 3` is an ugly number.\\n\\nIf `num` is an ugly number, we will be at last examining `num = 1`.\\n\\n```java\\n30 / 2 = 15\\n15 / 3 = 5\\n 5 / 5 = 1 --> true\\n```\\n\\nIf not:\\n\\n```java\\n31         --> false (cannot be divided by 2, 3, 5)\\n21 / 3 = 7 --> false (cannot be divided by 2, 3, 5)\\n```\\n\\nHere is the code:\\n\\n```java\\npublic boolean isUgly(int num) {\\n  if (num <= 0) return false;\\n  if (num == 1) return true;\\n  if (num % 2 == 0) return isUgly(num / 2);\\n  if (num % 3 == 0) return isUgly(num / 3);\\n  if (num % 5 == 0) return isUgly(num / 5);\\n  return false;\\n}\\n```\\n\\n**Time:** `O(logN)` since the `num / 2` can only occur in `logN` times at most.\\n**Space:** `O(logN)`\\n\\n\\n\\n### Iteration\\n\\n```java\\npublic static boolean isUgly(int num) {\\n  if (num <= 0) return false;\\n  int[] divisors = { 2, 3, 5 };\\n  for(int d : divisors) {\\n    while (num % d == 0) num /= d;\\n  }\\n  return num == 1;\\n}\\n```\\n\\n**Time:** `O(logN)`\\n**Space:** `O(1)`\\n\\n\\n## Ugly Number II\\n\\n> Write a program to find the `n-th` ugly number.\\n\\n> Ugly numbers are **positive numbers** whose `prime factors` only include `2, 3, 5`.\\n\\n**Note:**\\n\\n- `1` is typically treated as an ugly number.\\n- `n` does not exceed 1690.\\n\\n**Example:**\\n\\n```java\\nInput: n = 10\\nOutput: 12\\nExplanation: 1, 2, 3, 4, 5, 6, 8, 9, 10, 12 is the sequence of the first 10 ugly numbers.\\n```\\n\\n### Brute-force\\n\\n```java\\nint[] divisors = new int[] { 2, 3, 5 };\\nprivate boolean isUgly(int num) {\\n  if (num <= 0) return false;\\n  if (num == 1) return true;\\n  for (int d : divisors) {\\n    while (num % d == 0) {\\n      num /= d;\\n    }\\n  }\\n  return num == 1;\\n}\\n\\npublic int nthUglyNumber(int n) {\\n  int num = 1;\\n  while (n > 0) {\\n    if (isUgly(num)) {\\n      --n;\\n    }\\n    if (n == 0) break;\\n    ++num;\\n  }\\n  return num;\\n}\\n```\\n\\n### Priority Queue\\n\\nAn ugly number must be multiplied by either `2, 3, 5` from a smaller ugly number. We can use a priority queue, but have to remove duplicates when polling elements from it.\\n\\n**Note:** \\n\\n- Use `long` since we may put in very large elements in advance, say `val * 5`, although they are not within the range of `n`.\\n- `(int) Long`, `(Integer) Long` are illegal.\\n\\n```java\\npublic int nthUglyNumber(int n) {\\n  PriorityQueue<Long> pq = new PriorityQueue<>();\\n  pq.add(1l);\\n  for (int i = 0; i < n - 1; ++i) {\\n    long val = pq.remove();\\n    while (pq.size() > 0 && pq.peek() == val) pq.remove(); // remove duplicates\\n    pq.add(val * 2);\\n    pq.add(val * 3);\\n    pq.add(val * 5);\\n  }\\n  // return (int) pq.remove();   // \\n  return pq.remove().intValue();\\n}\\n```\\n\\n**Time:** `O(NlogN)`\\n**Space:** `O(N)`\\n\\n\\n\\n### DP (clever)\\n\\nSince `1 <= n <= 1690`, we can pre-compute `n` ugly numbers and return the result in constant time.\\n\\n```java\\nint BOUND = 1690;\\npublic int nthUglyNumber(int n) {\\n  // dp[i] denote the i + 1 ugly numbers\\n  int[] dp = new int[BOUND];\\n  dp[0] = 1;\\n  // the smallest number that is not multiplied by 2, 3, 5\\n  int i2 = 0, i3 = 0, i5 = 0;\\n  for (int i = 1; i < BOUND; ++i) {\\n    dp[i] = Math.min(dp[i2] * 2, Math.min(dp[i3] * 3, dp[i5] * 5));\\n    if (dp[i] == dp[i2] * 2) ++i2;\\n    if (dp[i] == dp[i3] * 3) ++i3;\\n    if (dp[i] == dp[i5] * 5) ++i5;\\n  }\\n  return dp[n - 1];\\n}\\n```\\n\\n**Time:** `O(N)`\\n**Space:** `O(N)`",
                "solutionTags": [
                    "Java",
                    "Dynamic Programming",
                    "Heap (Priority Queue)"
                ],
                "code": "```java\\nInput: -1, 0\\nOutput: false\\n\\nInput: 1\\nOutput: true\\n\\nInput: 2, 3, 5\\nOutput: true\\nExplanation: although they are primes, they are ugly.\\n\\nInput: 7, 11\\nOutput: false\\nExplanation: They are primes, but they are not ugly. They are other prime factors themselves.\\n\\nInput: 4\\nOutput: true\\nExplanation: 4 = 1 x 4, 2 x 2 (no other prime factors)\\n\\nInput: 6\\nOutput: true\\nExplanation: 6 = 1 x 6, 2 \\xD7 3 (no other prime factors)\\n\\nInput: 21\\nOutput: false\\nExplanation: 21 = 3 x 7 (7 is the other prime factor)\\n```\n```java\\n30 / 2 = 15\\n15 / 3 = 5\\n 5 / 5 = 1 --> true\\n```\n```java\\n31         --> false (cannot be divided by 2, 3, 5)\\n21 / 3 = 7 --> false (cannot be divided by 2, 3, 5)\\n```\n```java\\npublic boolean isUgly(int num) {\\n  if (num <= 0) return false;\\n  if (num == 1) return true;\\n  if (num % 2 == 0) return isUgly(num / 2);\\n  if (num % 3 == 0) return isUgly(num / 3);\\n  if (num % 5 == 0) return isUgly(num / 5);\\n  return false;\\n}\\n```\n```java\\npublic static boolean isUgly(int num) {\\n  if (num <= 0) return false;\\n  int[] divisors = { 2, 3, 5 };\\n  for(int d : divisors) {\\n    while (num % d == 0) num /= d;\\n  }\\n  return num == 1;\\n}\\n```\n```java\\nInput: n = 10\\nOutput: 12\\nExplanation: 1, 2, 3, 4, 5, 6, 8, 9, 10, 12 is the sequence of the first 10 ugly numbers.\\n```\n```java\\nint[] divisors = new int[] { 2, 3, 5 };\\nprivate boolean isUgly(int num) {\\n  if (num <= 0) return false;\\n  if (num == 1) return true;\\n  for (int d : divisors) {\\n    while (num % d == 0) {\\n      num /= d;\\n    }\\n  }\\n  return num == 1;\\n}\\n\\npublic int nthUglyNumber(int n) {\\n  int num = 1;\\n  while (n > 0) {\\n    if (isUgly(num)) {\\n      --n;\\n    }\\n    if (n == 0) break;\\n    ++num;\\n  }\\n  return num;\\n}\\n```\n```java\\npublic int nthUglyNumber(int n) {\\n  PriorityQueue<Long> pq = new PriorityQueue<>();\\n  pq.add(1l);\\n  for (int i = 0; i < n - 1; ++i) {\\n    long val = pq.remove();\\n    while (pq.size() > 0 && pq.peek() == val) pq.remove(); // remove duplicates\\n    pq.add(val * 2);\\n    pq.add(val * 3);\\n    pq.add(val * 5);\\n  }\\n  // return (int) pq.remove();   // \\n  return pq.remove().intValue();\\n}\\n```\n```java\\nint BOUND = 1690;\\npublic int nthUglyNumber(int n) {\\n  // dp[i] denote the i + 1 ugly numbers\\n  int[] dp = new int[BOUND];\\n  dp[0] = 1;\\n  // the smallest number that is not multiplied by 2, 3, 5\\n  int i2 = 0, i3 = 0, i5 = 0;\\n  for (int i = 1; i < BOUND; ++i) {\\n    dp[i] = Math.min(dp[i2] * 2, Math.min(dp[i3] * 3, dp[i5] * 5));\\n    if (dp[i] == dp[i2] * 2) ++i2;\\n    if (dp[i] == dp[i3] * 3) ++i3;\\n    if (dp[i] == dp[i5] * 5) ++i5;\\n  }\\n  return dp[n - 1];\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 69435,
                "title": "java-solution-using-priorityqueue",
                "content": "    public int nthUglyNumber(int n) {\\n        if(n==1) return n;\\n        Queue<Long> q = new PriorityQueue<Long>();\\n        int[] nums = {2,3,5};\\n        Long result = Long.valueOf(1);\\n        q.offer(result);\\n        for(int i=0;i<n;i++){\\n            // Each time we poll the peak value of q, is the ith number \\n            result = q.poll();\\n            for(int num:nums){\\n                Long uglyNum = result*num;\\n                if(!q.contains(uglyNum)){\\n                    q.offer(uglyNum);\\n                }\\n            }\\n        }\\n        return result.intValue();\\n    }",
                "solutionTags": [
                    "Java"
                ],
                "code": "    public int nthUglyNumber(int n) {\\n        if(n==1) return n;\\n        Queue<Long> q = new PriorityQueue<Long>();\\n        int[] nums = {2,3,5};\\n        Long result = Long.valueOf(1);\\n        q.offer(result);\\n        for(int i=0;i<n;i++){\\n            // Each time we poll the peak value of q, is the ith number \\n            result = q.poll();\\n            for(int num:nums){\\n                Long uglyNum = result*num;\\n                if(!q.contains(uglyNum)){\\n                    q.offer(uglyNum);\\n                }\\n            }\\n        }\\n        return result.intValue();\\n    }",
                "codeTag": "Unknown"
            },
            {
                "id": 350399,
                "title": "python-dynamic-programming",
                "content": "class Solution:\\n    def nthUglyNumber(self, n: int) -> int:\\n        \\n\\n            res = [1]\\n            i = j = k = 0\\n            count = 0\\n            \\n            while count < n:\\n                val = min(res[i]*2,min(res[j]*3,res[k]*5))\\n                if val == res[i]*2:\\n                    i+=1\\n                if val == res[j]*3:\\n                    j+=1\\n                if val == res[k]*5:\\n                    k+=1\\n                count+=1\\n                if count == n:\\n                    return res[-1]\\n                res.append(val)",
                "solutionTags": [
                    "Python",
                    "Python3",
                    "Dynamic Programming"
                ],
                "code": "class Solution:\\n    def nthUglyNumber(self, n: int) -> int:\\n        \\n\\n            res = [1]\\n            i = j = k = 0\\n            count = 0\\n            \\n            while count < n:\\n                val = min(res[i]*2,min(res[j]*3,res[k]*5))\\n                if val == res[i]*2:\\n                    i+=1\\n                if val == res[j]*3:\\n                    j+=1\\n                if val == res[k]*5:\\n                    k+=1\\n                count+=1\\n                if count == n:\\n                    return res[-1]\\n                res.append(val)",
                "codeTag": "Java"
            },
            {
                "id": 329484,
                "title": "heavily-commented-javascript-bottom-up-dp-solution",
                "content": "```\\n/**\\n * @param {number} n\\n * @return {number}\\n */\\nvar nthUglyNumber = function(n) {\\n    \\n    if (!n) {\\n        return 0;\\n    }\\n    \\n    // General idea is to build up an array with ugly numbers till we reach n-1\\n    // So we will iterate multiples of 2,3,5 and record them.\\n    // But, if just store 2,3,5 - 4,6,10 - 6,9,15 etc we\\'d be going out of order\\n    // So we need to increase the indeces for 2,3,5 more wisely.\\n    \\n    let i2 = 0, i3 = 0, i5 = 0; // the 2,3,5 indeces\\n    let out = [1]; // we will fill this with the ugly multiples\\n    \\n    while (!out[n-1]) { \\n        let c2 = out[i2] * 2;\\n        let c3 = out[i3] * 3;\\n        let c5 = out[i5] * 5;\\n        // In c2,c3,c5 we now have 3 candidates for the next number. Pick the lowest one, to record in order\\n        // In the first round that will be 2\\n        let next = Math.min(Math.min(c2, c3), c5);\\n        out.push(next);\\n        \\n        if (next === c2) {\\n            // now the 2 index will increase, and next round, c2 will be four, so c3=3 will be lowest\\n            i2++;\\n        }\\n        if (next === c3) {\\n            i3++;\\n        }\\n        if (next === c5) {\\n            i5++;\\n        } \\n        \\n    }\\n\\n    return out[n-1]; \\n};\\n```",
                "solutionTags": [
                    "JavaScript",
                    "Dynamic Programming"
                ],
                "code": "```\\n/**\\n * @param {number} n\\n * @return {number}\\n */\\nvar nthUglyNumber = function(n) {\\n    \\n    if (!n) {\\n        return 0;\\n    }\\n    \\n    // General idea is to build up an array with ugly numbers till we reach n-1\\n    // So we will iterate multiples of 2,3,5 and record them.\\n    // But, if just store 2,3,5 - 4,6,10 - 6,9,15 etc we\\'d be going out of order\\n    // So we need to increase the indeces for 2,3,5 more wisely.\\n    \\n    let i2 = 0, i3 = 0, i5 = 0; // the 2,3,5 indeces\\n    let out = [1]; // we will fill this with the ugly multiples\\n    \\n    while (!out[n-1]) { \\n        let c2 = out[i2] * 2;\\n        let c3 = out[i3] * 3;\\n        let c5 = out[i5] * 5;\\n        // In c2,c3,c5 we now have 3 candidates for the next number. Pick the lowest one, to record in order\\n        // In the first round that will be 2\\n        let next = Math.min(Math.min(c2, c3), c5);\\n        out.push(next);\\n        \\n        if (next === c2) {\\n            // now the 2 index will increase, and next round, c2 will be four, so c3=3 will be lowest\\n            i2++;\\n        }\\n        if (next === c3) {\\n            i3++;\\n        }\\n        if (next === c5) {\\n            i5++;\\n        } \\n        \\n    }\\n\\n    return out[n-1]; \\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3235178,
                "title": "264-solution-with-step-by-step-explanation",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\nWe will use a dynamic programming approach to solve this problem. We will start with the first ugly number, which is 1, and then generate all the other ugly numbers. We will use three pointers to keep track of the next multiple of 2, 3, and 5 respectively. We will generate the next ugly number by selecting the minimum of the three next multiples, adding it to the list of ugly numbers, and updating the corresponding pointer. We will repeat this process until we have generated the nth ugly number.\\n\\nThe time complexity of this algorithm is O(n), and the space complexity is O(n) as we need to store the list of n ugly numbers.\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution:\\n    def nthUglyNumber(self, n: int) -> int:\\n        ugly = [1]  # initialize list of ugly numbers with 1\\n        i2, i3, i5 = 0, 0, 0  # initialize pointers for next multiples of 2, 3, and 5 respectively\\n        while len(ugly) < n:\\n            # generate the next ugly number as the minimum of the next multiples of 2, 3, and 5\\n            next_ugly = min(ugly[i2]*2, ugly[i3]*3, ugly[i5]*5)\\n            # add the next ugly number to the list\\n            ugly.append(next_ugly)\\n            # update the corresponding pointer for the next multiple\\n            if next_ugly == ugly[i2]*2:\\n                i2 += 1\\n            if next_ugly == ugly[i3]*3:\\n                i3 += 1\\n            if next_ugly == ugly[i5]*5:\\n                i5 += 1\\n        return ugly[-1]  # return the nth ugly number\\n\\n```",
                "solutionTags": [
                    "Python",
                    "Python3",
                    "Hash Table",
                    "Math",
                    "Dynamic Programming"
                ],
                "code": "```\\nclass Solution:\\n    def nthUglyNumber(self, n: int) -> int:\\n        ugly = [1]  # initialize list of ugly numbers with 1\\n        i2, i3, i5 = 0, 0, 0  # initialize pointers for next multiples of 2, 3, and 5 respectively\\n        while len(ugly) < n:\\n            # generate the next ugly number as the minimum of the next multiples of 2, 3, and 5\\n            next_ugly = min(ugly[i2]*2, ugly[i3]*3, ugly[i5]*5)\\n            # add the next ugly number to the list\\n            ugly.append(next_ugly)\\n            # update the corresponding pointer for the next multiple\\n            if next_ugly == ugly[i2]*2:\\n                i2 += 1\\n            if next_ugly == ugly[i3]*3:\\n                i3 += 1\\n            if next_ugly == ugly[i5]*5:\\n                i5 += 1\\n        return ugly[-1]  # return the nth ugly number\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 69419,
                "title": "share-my-4ms-cpp-solution-beats-98-9-submissions",
                "content": " \\n\\n    class Solution {\\n    public:\\n        int nthUglyNumber(int n) {\\n            static vector<int> ugly{0, 1};\\n            static int m1 = 1, m2 = 1, m3 = 1;\\n            if (n < ugly.size()) {\\n                return ugly[n]; \\n            }\\n            int next = 0;\\n            while(n >= ugly.size()) {\\n                next = min(ugly[m1] * 2, min(ugly[m2] * 3, ugly[m3] * 5));\\n                ugly.push_back(next);\\n                if (ugly[m1] * 2 == next) {\\n                    ++m1;\\n                }\\n                if (ugly[m2] * 3 == next) {\\n                    ++m2;\\n                }\\n                if (ugly[m3] * 5 == next) {\\n                    ++m3;\\n                }\\n            }\\n            return ugly[n];\\n        }\\n    };",
                "solutionTags": [
                    "C++"
                ],
                "code": "class Solution {\\n    public:\\n        int nthUglyNumber(int n) {\\n            static vector<int> ugly{0, 1}",
                "codeTag": "Java"
            },
            {
                "id": 69426,
                "title": "c-solution-with-o-n-time",
                "content": "class Solution {\\npublic:\\n        int nthUglyNumber(int n) {\\n            int i=0;\\n            int j=0;\\n            int k=0;\\n            vector<int> v;\\n            v.push_back(1);\\n        \\n            while(v.size()!=n){\\n                   int m=min(v[i]*2,min(v[j]*3,v[k]*5));\\n\\t\\t   if(m==v[i]*2) i++;\\n\\t\\t   if(m==v[j]*3) j++;\\n\\t\\t   if(m==v[k]*5) k++;\\n                   v.push_back(m);  \\n            }\\n            return v.back();\\n        }\\n};",
                "solutionTags": [],
                "code": "class Solution {\\npublic:\\n        int nthUglyNumber(int n) {\\n            int i=0;\\n            int j=0;\\n            int k=0;\\n            vector<int> v;\\n            v.push_back(1);\\n        \\n            while(v.size()!=n){\\n                   int m=min(v[i]*2,min(v[j]*3,v[k]*5));\\n\\t\\t   if(m==v[i]*2) i++;\\n\\t\\t   if(m==v[j]*3) j++;\\n\\t\\t   if(m==v[k]*5) k++;\\n                   v.push_back(m);  \\n            }",
                "codeTag": "Java"
            },
            {
                "id": 718878,
                "title": "python-easy-solution",
                "content": "```\\n    def nthUglyNumber(self, n):\\n        \"\"\"\\n        :type n: int\\n        :rtype: int\\n        \"\"\"\\n        if n == 1: return 1\\n        t2 = t3 = t5 = 0\\n        ugly = [0]*n\\n        ugly[0] = 1\\n        for i in range(1, n):\\n            ugly[i] = min(ugly[t2]*2, ugly[t3]*3, ugly[t5]*5)\\n            if ugly[i] == ugly[t2]*2: t2 += 1\\n            if ugly[i] == ugly[t3]*3: t3 += 1\\n            if ugly[i] == ugly[t5]*5: t5 += 1\\n        \\n        return ugly[n-1]\\n```",
                "solutionTags": [],
                "code": "```\\n    def nthUglyNumber(self, n):\\n        \"\"\"\\n        :type n: int\\n        :rtype: int\\n        \"\"\"\\n        if n == 1: return 1\\n        t2 = t3 = t5 = 0\\n        ugly = [0]*n\\n        ugly[0] = 1\\n        for i in range(1, n):\\n            ugly[i] = min(ugly[t2]*2, ugly[t3]*3, ugly[t5]*5)\\n            if ugly[i] == ugly[t2]*2: t2 += 1\\n            if ugly[i] == ugly[t3]*3: t3 += 1\\n            if ugly[i] == ugly[t5]*5: t5 += 1\\n        \\n        return ugly[n-1]\\n```",
                "codeTag": "Python3"
            },
            {
                "id": 2828717,
                "title": "python-93-80-faster-iterative-approach-o-n-solution",
                "content": "```\\nclass Solution:\\n    def nthUglyNumber(self, n: int) -> int:\\n        ans=[1]\\n        prod_2=prod_3=prod_5=0\\n        for i in range(1,n):\\n            a=ans[prod_2]*2\\n            b=ans[prod_3]*3\\n            c=ans[prod_5]*5\\n            m=min(a,b,c)\\n            ans.append(m)\\n            if m==a:\\n                prod_2+=1\\n            if m==b:\\n                prod_3+=1\\n            if m==c:\\n                prod_5+=1\\n        return ans[-1]\\n```\\n\\n**Upvote if you like the solution or ask if there is any query**",
                "solutionTags": [
                    "Python",
                    "Python3",
                    "Iterator"
                ],
                "code": "```\\nclass Solution:\\n    def nthUglyNumber(self, n: int) -> int:\\n        ans=[1]\\n        prod_2=prod_3=prod_5=0\\n        for i in range(1,n):\\n            a=ans[prod_2]*2\\n            b=ans[prod_3]*3\\n            c=ans[prod_5]*5\\n            m=min(a,b,c)\\n            ans.append(m)\\n            if m==a:\\n                prod_2+=1\\n            if m==b:\\n                prod_3+=1\\n            if m==c:\\n                prod_5+=1\\n        return ans[-1]\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2797006,
                "title": "dp-approach-java-simple-solution",
                "content": "```java\\npublic int nthUglyNumber(int n) {\\n        TreeSet<Long> st = new TreeSet<>();\\n        st.add((long)1);\\n        int cnt = 0;\\n        long ans = 1;\\n        for(;cnt != n;){\\n            long ugly = st.pollFirst();\\n            ans = ugly;\\n            ++cnt;\\n            st.add(2 * ugly);\\n            st.add(3 * ugly);\\n            st.add(5 * ugly);\\n        }\\n        return (int)ans;\\n    }\\n```",
                "solutionTags": [
                    "Java",
                    "Dynamic Programming"
                ],
                "code": "```java\\npublic int nthUglyNumber(int n) {\\n        TreeSet<Long> st = new TreeSet<>();\\n        st.add((long)1);\\n        int cnt = 0;\\n        long ans = 1;\\n        for(;cnt != n;){\\n            long ugly = st.pollFirst();\\n            ans = ugly;\\n            ++cnt;\\n            st.add(2 * ugly);\\n            st.add(3 * ugly);\\n            st.add(5 * ugly);\\n        }\\n        return (int)ans;\\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2036691,
                "title": "c-efficient-solution-easy-way-with-comments",
                "content": "class Solution {\\npublic:\\n\\n    int nthUglyNumber(int n) {\\n        vector<int>ans(n);\\n        ans[0]=1; //1 will always be there\\n        int two=0,three=0,five=0; //these are the pointer to keep a track\\n        for(int i=1;i<n;++i){\\n            int multwo = ans[two]*2;\\n            int multhree = ans[three]*3;\\n            int mulfive = ans[five]*5;\\n            ans[i] = min(multwo,min(multhree,mulfive)); //taking minimum of all the three above\\n\\t\\t\\t// incrementing the pointer whose value was found minimum\\n            if(ans[i]==multwo) two++;\\n            if(ans[i]==multhree) three++;\\n            if(ans[i]==mulfive) five++;\\n        }\\n        return ans[n-1];\\n    }\\n};\\n//if like\\n//doupvote\\n//happy coding :)",
                "solutionTags": [
                    "C",
                    "Dynamic Programming"
                ],
                "code": "class Solution {\\npublic:\\n\\n    int nthUglyNumber(int n) {\\n        vector<int>ans(n);\\n        ans[0]=1; //1 will always be there\\n        int two=0,three=0,five=0; //these are the pointer to keep a track\\n        for(int i=1;i<n;++i){\\n            int multwo = ans[two]*2;\\n            int multhree = ans[three]*3;\\n            int mulfive = ans[five]*5;\\n            ans[i] = min(multwo,min(multhree,mulfive)); //taking minimum of all the three above\\n\\t\\t\\t// incrementing the pointer whose value was found minimum\\n            if(ans[i]==multwo) two++;\\n            if(ans[i]==multhree) three++;\\n            if(ans[i]==mulfive) five++;\\n        }",
                "codeTag": "Java"
            },
            {
                "id": 913252,
                "title": "simple-efficient-solution",
                "content": "```\\nclass Solution {\\npublic:\\n    int nthUglyNumber(int n) {\\n        vector<int>dp={1};\\n        int two=0,three=0,five=0;\\n        for(int i=0;i<n-1;++i){\\n          int tmp=min(min(2*dp[two],3*dp[three]),5*dp[five]);\\n          dp.push_back(tmp);\\n          if(tmp==dp[two]*2)\\n            ++two;\\n          if(tmp==dp[three]*3)\\n            ++three;\\n          if(tmp==dp[five]*5)\\n            ++five;\\n        }\\n        cout<<dp.size();\\n        for(int i:dp)\\n          cout<<\\' \\'<<i;\\n        return dp.back();\\n    }\\n};\\n```",
                "solutionTags": [
                    "C",
                    "Dynamic Programming"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int nthUglyNumber(int n) {\\n        vector<int>dp={1};\\n        int two=0,three=0,five=0;\\n        for(int i=0;i<n-1;++i){\\n          int tmp=min(min(2*dp[two],3*dp[three]),5*dp[five]);\\n          dp.push_back(tmp);\\n          if(tmp==dp[two]*2)\\n            ++two;\\n          if(tmp==dp[three]*3)\\n            ++three;\\n          if(tmp==dp[five]*5)\\n            ++five;\\n        }\\n        cout<<dp.size();\\n        for(int i:dp)\\n          cout<<\\' \\'<<i;\\n        return dp.back();\\n    }\\n};\\n```",
                "codeTag": "C++"
            },
            {
                "id": 153927,
                "title": "c-0ms-solution-cache-the-result-array",
                "content": "```\\nclass Solution {\\npublic:\\n    std::vector<int> f()\\n    {\\n        std::vector<int> v { 1 };\\n        int i2 = 0;\\n        int i3 = 0;\\n        int i5 = 0;\\n        while (v.size() < 1691)\\n        {\\n            int a = std::min(v[i2] * 2, std::min(v[i3] * 3, v[i5] * 5));\\n            v.push_back(a);\\n            if (a == v[i2] * 2)\\n                ++i2;\\n            if (a == v[i3] * 3)\\n                ++i3;\\n            if (a == v[i5] * 5)\\n                ++i5;\\n        }\\n        \\n        return v;\\n    }\\n    int nthUglyNumber(int n) {\\n        static auto vv = f();\\n        return vv[n - 1];                \\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    std::vector<int> f()\\n    {\\n        std::vector<int> v { 1 };\\n        int i2 = 0;\\n        int i3 = 0;\\n        int i5 = 0;\\n        while (v.size() < 1691)\\n        {\\n            int a = std::min(v[i2] * 2, std::min(v[i3] * 3, v[i5] * 5));\\n            v.push_back(a);\\n            if (a == v[i2] * 2)\\n                ++i2;\\n            if (a == v[i3] * 3)\\n                ++i3;\\n            if (a == v[i5] * 5)\\n                ++i5;\\n        }\\n        \\n        return v;\\n    }\\n    int nthUglyNumber(int n) {\\n        static auto vv = f();\\n        return vv[n - 1];                \\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2090024,
                "title": "simple-c-solution-using-min-heap",
                "content": "The main problem is how to maintain the order of the generated ugly numbers, ie, how can we get {1,2,3,4,5,...} instead of {1,2,4,3,6,5...} which is a general result of generating the ugly numbers using pow method while maintaining three pointers for 2,3,5 respectively.\\n\\nWe can maintain a min heap and keep inserting the numbers obtained by multiplying a given number with 2,3 and 5 respectively. Initialise the min heap with 1. Now observe the following example:\\n- pop 1 from queue\\n- check if we have encountered this number before\\n- insert 1* 2, 1* 3, 1* 5 into the queue which will automatically maintain the order and during the next pop operation, provide us with the next smallest ugly number.\\n- increase the count as we just popped an ugly number from the prior queue.\\n- continue the same till count becomes n.\\n- return the last popped element as it was the one who set the count to n and hence is the nth ugly number.\\n\\n```\\nint nthUglyNumber(int n) {\\n        //a hash map to see if a certain number was already popped; for ex: 2*3 and 3*2\\n        //will both add 6 to the pq, but we will only have to count it once.\\n        unordered_map<long long, int> map;\\n        priority_queue<long long, vector<long long>, greater<long long>> pq;\\n        \\n        pq.push(1);\\n        int count= 0;\\n        long long popped;\\n        \\n        while(count<n){\\n            popped= pq.top();\\n            pq.pop();\\n            if(map[popped]== 0){\\n                pq.push(popped*2);\\n                pq.push(popped*3);\\n                pq.push(popped*5);\\n                count++;\\n                map[popped]= 1;\\n            }\\n        }\\n        return int(popped);\\n\\t}",
                "solutionTags": [
                    "C++",
                    "Heap (Priority Queue)"
                ],
                "code": "The main problem is how to maintain the order of the generated ugly numbers, ie, how can we get {1,2,3,4,5,...} instead of {1,2,4,3,6,5...} which is a general result of generating the ugly numbers using pow method while maintaining three pointers for 2,3,5 respectively.\\n\\nWe can maintain a min heap and keep inserting the numbers obtained by multiplying a given number with 2,3 and 5 respectively. Initialise the min heap with 1. Now observe the following example:\\n- pop 1 from queue\\n- check if we have encountered this number before\\n- insert 1* 2, 1* 3, 1* 5 into the queue which will automatically maintain the order and during the next pop operation, provide us with the next smallest ugly number.\\n- increase the count as we just popped an ugly number from the prior queue.\\n- continue the same till count becomes n.\\n- return the last popped element as it was the one who set the count to n and hence is the nth ugly number.\\n\\n```\\nint nthUglyNumber(int n) {\\n        //a hash map to see if a certain number was already popped; for ex: 2*3 and 3*2\\n        //will both add 6 to the pq, but we will only have to count it once.\\n        unordered_map<long long, int> map;\\n        priority_queue<long long, vector<long long>, greater<long long>> pq;\\n        \\n        pq.push(1);\\n        int count= 0;\\n        long long popped;\\n        \\n        while(count<n){\\n            popped= pq.top();\\n            pq.pop();\\n            if(map[popped]== 0){\\n                pq.push(popped*2);\\n                pq.push(popped*3);\\n                pq.push(popped*5);\\n                count++;\\n                map[popped]= 1;\\n            }\\n        }\\n        return int(popped);\\n\\t}",
                "codeTag": "Unknown"
            },
            {
                "id": 247234,
                "title": "c-easy-dp-solution",
                "content": "class Solution {\\npublic:\\n    int nthUglyNumber(int n) {\\n        \\n        vector <int> v (1,1);\\n        int i=0,j=0,k=0;\\n        while(v.size() < n)\\n        {\\n            v.push_back(min(v[i] * 2, min(v[j] * 3, v[k] * 5)));\\n            if (v.back() == v[i] * 2) ++i;\\n            if (v.back() == v[j] * 3) ++j;\\n            if (v.back() == v[k] * 5) ++k;\\n        }\\n        return v.back();\\n    }\\n};",
                "solutionTags": [
                    "C++",
                    "Dynamic Programming"
                ],
                "code": "class Solution {\\npublic:\\n    int nthUglyNumber(int n) {\\n        \\n        vector <int> v (1,1);\\n        int i=0,j=0,k=0;\\n        while(v.size() < n)\\n        {\\n            v.push_back(min(v[i] * 2, min(v[j] * 3, v[k] * 5)));\\n            if (v.back() == v[i] * 2) ++i;\\n            if (v.back() == v[j] * 3) ++j;\\n            if (v.back() == v[k] * 5) ++k;\\n        }",
                "codeTag": "Java"
            },
            {
                "id": 69437,
                "title": "ac-c-solution-beats-90",
                "content": "public class Solution {\\n\\n    public int NthUglyNumber(int n) {\\n\\n        int x = 0;  // Number used to generate the next ugly number by 2*x\\n        int y = 0;  // Number used to generate the next ugly number by 3*y\\n        int z = 0;  // Number used to generate the next ugly number by 5*z\\n        \\n        int[] ugly = new int[n];\\n        \\n        ugly[0] = 1;  \\n        \\n        int count = 0;\\n        while( count < n-1){\\n            int next = Math.Min(2*ugly[x], Math.Min(3*ugly[y], 5*ugly[z]));\\n            ugly[++count] = next;\\n            if(2*ugly[x] == next) x++;\\n            if(3*ugly[y] == next) y++;\\n            if(5*ugly[z] == next) z++;\\n        }\\n        \\n        return ugly[n-1];\\n    }\\n}",
                "solutionTags": [],
                "code": "class Solution {\\n\\n    public int NthUglyNumber(int n) {\\n\\n        int x = 0;  // Number used to generate the next ugly number by 2*x\\n        int y = 0;  // Number used to generate the next ugly number by 3*y\\n        int z = 0;  // Number used to generate the next ugly number by 5*z\\n        \\n        int[] ugly = new int[n];\\n        \\n        ugly[0] = 1;  \\n        \\n        int count = 0;\\n        while( count < n-1){\\n            int next = Math.Min(2*ugly[x], Math.Min(3*ugly[y], 5*ugly[z]));\\n            ugly[++count] = next;\\n            if(2*ugly[x] == next) x++;\\n            if(3*ugly[y] == next) y++;\\n            if(5*ugly[z] == next) z++;\\n        }",
                "codeTag": "Java"
            },
            {
                "id": 1864676,
                "title": "dp-c-faster",
                "content": "***Upvote, it motivates me*** \\u270C\\n```\\nclass Solution {\\npublic:\\n    int nthUglyNumber(int n) {\\n        vector<int> dp(n);\\n        int two = 0; // Maintain the three pointers i.e. two , three , five\\n        int three = 0;\\n        int five = 0;\\n        \\n        dp[0] = 1;\\n        for(int i = 1 ; i < n ; i++){\\n            int two_multiple = 2 * dp[two];\\n            int three_multiple = 3 * dp[three];\\n            int five_multiple = 5 * dp[five];\\n            \\n            dp[i] = min(two_multiple , min(three_multiple , five_multiple)); \\n            if(dp[i] == two_multiple){\\n                two++;\\n            }\\n            if(dp[i] == three_multiple){\\n                three++;\\n            }\\n            if(dp[i] == five_multiple){\\n                five++;\\n            }\\n        }\\n        return dp[n - 1];\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    int nthUglyNumber(int n) {\\n        vector<int> dp(n);\\n        int two = 0; // Maintain the three pointers i.e. two , three , five\\n        int three = 0;\\n        int five = 0;\\n        \\n        dp[0] = 1;\\n        for(int i = 1 ; i < n ; i++){\\n            int two_multiple = 2 * dp[two];\\n            int three_multiple = 3 * dp[three];\\n            int five_multiple = 5 * dp[five];\\n            \\n            dp[i] = min(two_multiple , min(three_multiple , five_multiple)); \\n            if(dp[i] == two_multiple){\\n                two++;\\n            }\\n            if(dp[i] == three_multiple){\\n                three++;\\n            }\\n            if(dp[i] == five_multiple){\\n                five++;\\n            }\\n        }\\n        return dp[n - 1];\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1801233,
                "title": "easy-to-understand-c",
                "content": "```\\nclass Solution {\\npublic:\\n    int nthUglyNumber(int n) {\\n        vector<int> res(n);\\n        res[0] = 1;\\n        int p2=0,p3=0,p5=0;\\n        for(int i=1;i<n;i++)\\n        {\\n            int mini = min(2*res[p2],min(3*res[p3],5*res[p5]));\\n            res[i] =mini;\\n            if(res[i]==res[p2]*2){\\n                p2++;\\n            }\\n            if(res[i]==res[p3]*3){\\n                p3++;\\n            }\\n            if(res[i]==res[p5]*5){\\n                p5++;\\n            }\\n        }\\n        return res[n-1];\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "C",
                    "Dynamic Programming"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int nthUglyNumber(int n) {\\n        vector<int> res(n);\\n        res[0] = 1;\\n        int p2=0,p3=0,p5=0;\\n        for(int i=1;i<n;i++)\\n        {\\n            int mini = min(2*res[p2],min(3*res[p3],5*res[p5]));\\n            res[i] =mini;\\n            if(res[i]==res[p2]*2){\\n                p2++;\\n            }\\n            if(res[i]==res[p3]*3){\\n                p3++;\\n            }\\n            if(res[i]==res[p5]*5){\\n                p5++;\\n            }\\n        }\\n        return res[n-1];\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 885721,
                "title": "0ms-solution-beats-100-detailed-explanation",
                "content": "```\\nclass Solution {\\npublic:\\n    int nthUglyNumber(int n) {\\n        int dp[n];\\n        int i2=0;int i3=0;int i5=0;\\n        dp[0]=1;\\n        for(int i=1;i<n;i++)\\n        {\\n            int least= min(min(dp[i2]*2,dp[i3]*3),dp[i5]*5);  \\n            if(least == dp[i2]*2)\\n                i2++;\\n            if(least == dp[i3]*3)\\n                i3++;\\n            if(least == dp[i5]*5)\\n                i5++;\\n            dp[i]=least;\\n        }\\n        return dp[n-1];\\n    }\\n};\\n```\\nThe idea is that every ugly number can be formed from some smaller ugly number by multiplying 2,3 or 5. We will use 3 pointers(i2,i3,i5) and a dynamic programming logic to use previously calculated uglyNumbers to find the next one.\\nuglyNumber[n] = min({uglyNumber[i2] * 2 , uglyNumber[i3] * 3, uglyNumber[i5]* 5}) where\\nik represents the index of the previously calculated uglyNumber which we need to check next by multiplying with k; where k is 2,3 or 5;\\nExample, \\ndp array represents all uglyNumbers and the value of uglyNumber at i should be the minimum amongst the ones we haven\\'t considered yet.\\ninitially, i2=0;i3=0;i5=0;\\ndp[0]=1 as 1 is the first uglyNumber. .\\ndp[1] = min(dp[0] * 2, dp[0] * 3, dp[0] * 5) = min(2,3,5) = 2 hence i2 will increase by 1; (as value corresponding to i2 is the minimum and we have considered dp[0]* 2 so the next multiple of 2 we need to consider would be that of the next uglyNumber which is stored in dp[1] now )\\ndp[2] = min(dp[1] * 2, dp[0] * 3, dp[0] * 5) = min(4,3,5) = 3 hence i3 will increase by 1 i2=1;i3=1;i5=0\\ndp[3] = min(dp[1] * 2, dp[1] * 3, dp[0] * 5) = min(4,6,5) = 4 hence i2 will increase by 1 i2=2;i3=1;i5=0\\ndp[4] = min(dp[2] * 2, dp[1] * 3, dp[0] * 5) = min(6,6,5) = 5 hence i5 will increase by 1 i2=2;i3=1;i5=1\\ndp[5] = min(dp[2] * 3, dp[1] * 3, dp[1]* 5) = min(6,6,10) = 6 hence both i2 and i3 will increase by 1 i2=3;i3=2;i5=1;\\nand so on...\\ndp[n-1] would give us the nth uglyNumber.\\n\\n\\n",
                "solutionTags": [
                    "Dynamic Programming"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int nthUglyNumber(int n) {\\n        int dp[n];\\n        int i2=0;int i3=0;int i5=0;\\n        dp[0]=1;\\n        for(int i=1;i<n;i++)\\n        {\\n            int least= min(min(dp[i2]*2,dp[i3]*3),dp[i5]*5);  \\n            if(least == dp[i2]*2)\\n                i2++;\\n            if(least == dp[i3]*3)\\n                i3++;\\n            if(least == dp[i5]*5)\\n                i5++;\\n            dp[i]=least;\\n        }\\n        return dp[n-1];\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 719374,
                "title": "0704-ugly-number-ii-o-n-c-solution",
                "content": "## Approach\\nEach time, we take the least of multiple of 2, 3, 5 and keep generating from the already-bulit array, thus ensuring the number is always ugly.\\n![image](https://assets.leetcode.com/users/images/da9be94a-e226-4a27-8978-92d8d0923342_1593877426.4611287.png)\\n\\n## Complexity Analysis\\nTime: O(N)\\nSpace: O(N)\\n\\n```cpp\\nclass Solution {\\npublic:\\n    int nthUglyNumber(int n) {\\n        int two = 0, three = 0, five = 0, next = 0;\\n        vector<int> res(1, 1);\\n        n -= 1;\\n        while(n--){\\n            next = min(res[two] * 2, min(res[three] * 3, res[five] * 5));\\n            if(next == res[two] * 2){\\n                two++;\\n            }\\n            if(next == res[three] * 3){\\n                three++;\\n            }\\n            if(next == res[five] * 5){\\n                five++;\\n            }\\n            res.push_back(next);\\n        }\\n        \\n        return res.back();\\n    }\\n};\\n```",
                "solutionTags": [
                    "C"
                ],
                "code": "```cpp\\nclass Solution {\\npublic:\\n    int nthUglyNumber(int n) {\\n        int two = 0, three = 0, five = 0, next = 0;\\n        vector<int> res(1, 1);\\n        n -= 1;\\n        while(n--){\\n            next = min(res[two] * 2, min(res[three] * 3, res[five] * 5));\\n            if(next == res[two] * 2){\\n                two++;\\n            }\\n            if(next == res[three] * 3){\\n                three++;\\n            }\\n            if(next == res[five] * 5){\\n                five++;\\n            }\\n            res.push_back(next);\\n        }\\n        \\n        return res.back();\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 369242,
                "title": "three-short-solutions-in-python-3-bisect-heap-dp",
                "content": "_1) Using Bisect: (5 lines)_\\n```\\nclass Solution:\\n    def nthUglyNumber(self, n: int) -> int:\\n    \\tN, I = [1], {2:0, 3:0, 5:0}\\n    \\tfor _ in range(n-1):\\n    \\t\\tI = {i:bisect.bisect(N, N[-1]//i, I[i]) for i in [2,3,5]}\\n    \\t\\tN.append(min(N[I[2]]*2,N[I[3]]*3,N[I[5]]*5))\\n    \\treturn N[-1]\\n\\n\\n```\\n_2) Using Heap: (6 lines)_\\n```\\nclass Solution:\\n    def nthUglyNumber(self, n: int) -> int:\\n    \\tN, m, S = [1], 1, set()\\n    \\tfor _ in range(n):\\n    \\t\\twhile m in S: m = heapq.heappop(N)\\n    \\t\\tS.add(m)\\n    \\t\\tfor i in [2,3,5]: heapq.heappush(N,i*m)\\n    \\treturn m\\n\\n\\n```\\n_3) Using DP: (5 lines)_\\n```\\nclass Solution:\\n    def nthUglyNumber(self, n: int) -> int:\\n    \\tN, p, I = [1], [2,3,5], [0]*3\\n    \\tfor _ in range(n-1):\\n    \\t\\tN.append(min([N[I[i]]*p[i] for i in range(3)]))\\n    \\t\\tfor i in range(3): I[i] += N[I[i]]*p[i] == N[-1]\\n    \\treturn N[-1]\\n\\t\\t\\n\\t\\t\\n\\t\\t\\n- Junaid Mansuri\\n(LeetCode ID)@hotmail.com",
                "solutionTags": [
                    "Python",
                    "Python3",
                    "Dynamic Programming",
                    "Heap (Priority Queue)"
                ],
                "code": "```\\nclass Solution:\\n    def nthUglyNumber(self, n: int) -> int:\\n    \\tN, I = [1], {2:0, 3:0, 5:0}\\n    \\tfor _ in range(n-1):\\n    \\t\\tI = {i:bisect.bisect(N, N[-1]//i, I[i]) for i in [2,3,5]}\\n    \\t\\tN.append(min(N[I[2]]*2,N[I[3]]*3,N[I[5]]*5))\\n    \\treturn N[-1]\\n\\n\\n```\n```\\nclass Solution:\\n    def nthUglyNumber(self, n: int) -> int:\\n    \\tN, m, S = [1], 1, set()\\n    \\tfor _ in range(n):\\n    \\t\\twhile m in S: m = heapq.heappop(N)\\n    \\t\\tS.add(m)\\n    \\t\\tfor i in [2,3,5]: heapq.heappush(N,i*m)\\n    \\treturn m\\n\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 337790,
                "title": "python-heap",
                "content": "```\\nclass Solution(object):\\n    def nthUglyNumber(self, n):\\n        \"\"\"\\n        :type n: int\\n        :rtype: int\\n        \"\"\"\\n        heap = [1]\\n        visited = set([1])\\n        \\n        for i in range(n):\\n            val = heapq.heappop(heap)\\n            \\n            for factor in [2,3,5]:\\n                if val*factor not in visited:\\n                    heapq.heappush(heap, val*factor)\\n                    visited.add(val*factor)\\n        \\n        \\n        return val\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution(object):\\n    def nthUglyNumber(self, n):\\n        \"\"\"\\n        :type n: int\\n        :rtype: int\\n        \"\"\"\\n        heap = [1]\\n        visited = set([1])\\n        \\n        for i in range(n):\\n            val = heapq.heappop(heap)\\n            \\n            for factor in [2,3,5]:\\n                if val*factor not in visited:\\n                    heapq.heappush(heap, val*factor)\\n                    visited.add(val*factor)\\n        \\n        \\n        return val\\n```",
                "codeTag": "Java"
            },
            {
                "id": 69445,
                "title": "c-solution-with-stl-set",
                "content": "    int nthUglyNumber(int n) {\\n        set<long long> isUgly;\\n        isUgly.insert(1);\\n        long long top = 0;\\n        for(int i=0; i<n; i++){\\n            top = *isUgly.lower_bound(top+1);\\n            isUgly.insert(top*2);\\n            isUgly.insert(top*3);\\n            isUgly.insert(top*5);\\n            \\n        }\\n        return top;\\n    }",
                "solutionTags": [
                    "C++"
                ],
                "code": "    int nthUglyNumber(int n) {\\n        set<long long> isUgly;\\n        isUgly.insert(1);\\n        long long top = 0;\\n        for(int i=0; i<n; i++){\\n            top = *isUgly.lower_bound(top+1);\\n            isUgly.insert(top*2);\\n            isUgly.insert(top*3);\\n            isUgly.insert(top*5);\\n            \\n        }\\n        return top;\\n    }",
                "codeTag": "Unknown"
            },
            {
                "id": 1312120,
                "title": "c-using-set-simple-min-heap-idea",
                "content": "\\tint nthUglyNumber(int n) {\\n        set<long long> s;\\n        n--;\\n        long long x=1;\\n        while(n--)\\n        {\\n            s.insert(x*2);\\n            s.insert(x*3);\\n            s.insert(x*5);\\n            x=*s.begin();\\n            s.erase(s.begin());\\n        }\\n        return (int)x;\\n    }",
                "solutionTags": [],
                "code": "\\tint nthUglyNumber(int n) {\\n        set<long long> s;\\n        n--;\\n        long long x=1;\\n        while(n--)\\n        {\\n            s.insert(x*2);\\n            s.insert(x*3);\\n            s.insert(x*5);\\n            x=*s.begin();\\n            s.erase(s.begin());\\n        }\\n        return (int)x;\\n    }",
                "codeTag": "Unknown"
            },
            {
                "id": 1151799,
                "title": "dp-solution-c",
                "content": "int nthUglyNumber(int n) {\\n        \\n        if(n <= 0)\\n\\t\\t return false; \\n        if(n == 1) \\n\\t\\t return true; \\n        int t2 = 0, t3 = 0, t5 = 0; //pointers for 2, 3, 5\\n        vector<int> k(n);\\n        k[0] = 1;\\n        for(int i  = 1; i < n ; i ++)\\n        {\\n            k[i] = min(k[t2]*2,min(k[t3]*3,k[t5]*5));\\n            if(k[i] == k[t2]*2) \\n             t2++; \\n            if(k[i] == k[t3]*3) \\n             t3++;\\n            if(k[i] == k[t5]*5) \\n             t5++;\\n        }\\n        return k[n-1];\\n        \\n        \\n    }",
                "solutionTags": [],
                "code": "int nthUglyNumber(int n) {\\n        \\n        if(n <= 0)\\n\\t\\t return false; \\n        if(n == 1) \\n\\t\\t return true; \\n        int t2 = 0, t3 = 0, t5 = 0; //pointers for 2, 3, 5\\n        vector<int> k(n);\\n        k[0] = 1;\\n        for(int i  = 1; i < n ; i ++)\\n        {\\n            k[i] = min(k[t2]*2,min(k[t3]*3,k[t5]*5));\\n            if(k[i] == k[t2]*2) \\n             t2++; \\n            if(k[i] == k[t3]*3) \\n             t3++;\\n            if(k[i] == k[t5]*5) \\n             t5++;\\n        }\\n        return k[n-1];\\n        \\n        \\n    }",
                "codeTag": "Unknown"
            },
            {
                "id": 728587,
                "title": "simple-clean-c-solution-using-dp",
                "content": "```cpp\\nclass Solution {\\npublic:\\n    int nthUglyNumber(int n) {\\n        if (n == 0) return 0;\\n    \\n        vector<int> dp(n, 0);\\n        dp[0] = 1;\\n\\n        int i2 = 0, i3 = 0, i5 = 0;\\n        for (int i = 1; i < n; ++i) {\\n            dp[i] = min(dp[i2] * 2, min(dp[i3] * 3, dp[i5] * 5));\\n            if (dp[i] == dp[i2] * 2) ++i2;\\n            if (dp[i] == dp[i3] * 3) ++i3;\\n            if (dp[i] == dp[i5] * 5) ++i5;\\n        }\\n\\n        return dp[n - 1]; \\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "C"
                ],
                "code": "```cpp\\nclass Solution {\\npublic:\\n    int nthUglyNumber(int n) {\\n        if (n == 0) return 0;\\n    \\n        vector<int> dp(n, 0);\\n        dp[0] = 1;\\n\\n        int i2 = 0, i3 = 0, i5 = 0;\\n        for (int i = 1; i < n; ++i) {\\n            dp[i] = min(dp[i2] * 2, min(dp[i3] * 3, dp[i5] * 5));\\n            if (dp[i] == dp[i2] * 2) ++i2;\\n            if (dp[i] == dp[i3] * 3) ++i3;\\n            if (dp[i] == dp[i5] * 5) ++i5;\\n        }\\n\\n        return dp[n - 1]; \\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 129552,
                "title": "python-elegant-solution-using-min-heap",
                "content": "```python\\nfrom heapq import heappush, heappop\\n\\n# Renat Bekbolatov 2018\\nclass Solution:\\n    def nthUglyNumber(self, n):\\n        q, counted = [1], {1}\\n        for i in range(n - 1):\\n            m = heappop(q)\\n            for mm in [2*m, 3*m, 5*m]:\\n                if mm not in counted:\\n                    heappush(q, mm)\\n                    counted.add(mm)        \\n        return heappop(q)\\n```",
                "solutionTags": [],
                "code": "```python\\nfrom heapq import heappush, heappop\\n\\n# Renat Bekbolatov 2018\\nclass Solution:\\n    def nthUglyNumber(self, n):\\n        q, counted = [1], {1}\\n        for i in range(n - 1):\\n            m = heappop(q)\\n            for mm in [2*m, 3*m, 5*m]:\\n                if mm not in counted:\\n                    heappush(q, mm)\\n                    counted.add(mm)        \\n        return heappop(q)\\n```",
                "codeTag": "Java"
            },
            {
                "id": 69444,
                "title": "o-n-java-easy-version-to-understand",
                "content": "        int getMin(int a,int b,int c){\\n         int min=Integer.min(a,b);\\n         min=Integer.min(min,c);\\n         return min;\\n    }\\n    public int nthUglyNumber(int n) {\\n        if(n==1)\\n          return 1;\\n          int[] a=new int[n];\\n        int p2=0,p3=0,p5=0,p=1,count=1;\\n         a[0]=1;\\n        while(count<n){\\n            a[p]=getMin(a[p2]*2,a[p3]*3,a[p5]*5);\\n            while(a[p2]*2<=a[p])\\n               p2++;\\n            while(a[p3]*3<=a[p])\\n               p3++;\\n            while(a[p5]*5<=a[p])\\n               p5++;\\n              \\n              p++;\\n              count++;\\n        }\\n        return a[--p];\\n    }",
                "solutionTags": [],
                "code": "        int getMin(int a,int b,int c){\\n         int min=Integer.min(a,b);\\n         min=Integer.min(min,c);\\n         return min;\\n    }\\n    public int nthUglyNumber(int n) {\\n        if(n==1)\\n          return 1;\\n          int[] a=new int[n];\\n        int p2=0,p3=0,p5=0,p=1,count=1;\\n         a[0]=1;\\n        while(count<n){\\n            a[p]=getMin(a[p2]*2,a[p3]*3,a[p5]*5);\\n            while(a[p2]*2<=a[p])\\n               p2++;\\n            while(a[p3]*3<=a[p])\\n               p3++;\\n            while(a[p5]*5<=a[p])\\n               p5++;\\n              \\n              p++;\\n              count++;\\n        }\\n        return a[--p];\\n    }",
                "codeTag": "Unknown"
            },
            {
                "id": 2473154,
                "title": "best-python-solution-most-intuitive",
                "content": "![image](https://assets.leetcode.com/users/images/1b34f290-8e93-4e23-8212-78642fde1983_1661342958.5084677.png)\\n\\n**Most intuitive and best heap solution you could ever get for this**\\n\\nIdea is clear that we need a min heap to store ugly numbers and pop the smallest ugly number (say `x`) and corresponding to that there should be` 2*x`, `3*x`, ` 5*x` as possible candidates, so push them by ensuring they are not already present in the heap, this can be done with a dictionary (hashmap)   \\n\\n```\\nclass Solution:\\n    def nthUglyNumber(self, n: int) -> int:\\n        h = [1]\\n        d = {}\\n        while n-1:\\n            x = heapq.heappop(h)\\n            if x*2 not in d:\\n                heapq.heappush(h, x*2)\\n                d[x*2] = 1\\n            if x*3 not in d:\\n                heapq.heappush(h, x*3)\\n                d[x*3] = 1\\n            if x*5 not in d:\\n                heapq.heappush(h, x*5)\\n                d[x*5] = 1\\n            n -= 1\\n        return heapq.heappop(h)\\n```",
                "solutionTags": [
                    "Python",
                    "Heap (Priority Queue)"
                ],
                "code": "```\\nclass Solution:\\n    def nthUglyNumber(self, n: int) -> int:\\n        h = [1]\\n        d = {}\\n        while n-1:\\n            x = heapq.heappop(h)\\n            if x*2 not in d:\\n                heapq.heappush(h, x*2)\\n                d[x*2] = 1\\n            if x*3 not in d:\\n                heapq.heappush(h, x*3)\\n                d[x*3] = 1\\n            if x*5 not in d:\\n                heapq.heappush(h, x*5)\\n                d[x*5] = 1\\n            n -= 1\\n        return heapq.heappop(h)\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1934696,
                "title": "c-optimized-solution",
                "content": "```\\nclass Solution {\\npublic:\\n    int nthUglyNumber(int n) {\\n          int res[n];\\n         res[0]=1;    // 2^0*3^0*5^0\\n        \\n        int i2=0,i3=0,i5=0; //indexes\\n        \\n        \\n        for(int i=1;i<n;i++)\\n        {\\n            int next2 =  2*res[i2];  //next multiple of 2\\n            int next3 =  3*res[i3];  //next multiple of 3\\n            int next5 =  5*res[i5];  //next multiple of 5\\n            \\n            int next = min(next2, min(next3,next5));\\n            \\n            res[i]=next;\\n            \\n            if(next==next2)\\n                i2++;\\n            if(next==next3)\\n                i3++;\\n            if(next==next5)\\n                i5++;\\n            \\n            \\n        }\\n        return res[n-1]; \\n    }\\n};\\nif Helpful Please like and Upvoke\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    int nthUglyNumber(int n) {\\n          int res[n];\\n         res[0]=1;    // 2^0*3^0*5^0\\n        \\n        int i2=0,i3=0,i5=0; //indexes\\n        \\n        \\n        for(int i=1;i<n;i++)\\n        {\\n            int next2 =  2*res[i2];  //next multiple of 2\\n            int next3 =  3*res[i3];  //next multiple of 3\\n            int next5 =  5*res[i5];  //next multiple of 5\\n            \\n            int next = min(next2, min(next3,next5));\\n            \\n            res[i]=next;\\n            \\n            if(next==next2)\\n                i2++;\\n            if(next==next3)\\n                i3++;\\n            if(next==next5)\\n                i5++;\\n            \\n            \\n        }\\n        return res[n-1]; \\n    }\\n};\\nif Helpful Please like and Upvoke\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1746154,
                "title": "python-this-should-be-2-pointer-problem-instead-of-dp",
                "content": "```\\ndef nthUglyNumber(self, n: int) -> int:\\n    \"\"\"\\n        Think about array \\n        a, b, c, d ,e\\n        for every element , could multiply by 2, 3, 5 then become new array\\n        2*a, 2*b, 2*c ...3*a, 3*b, 3*c ...5*a ,5*b\\n        but we want to nth ugly number, the result is not sorted , it could be \\n        2*a, 1*c, 2*b, 3*a ....\\n        To make sure the array is sorted while expanding. Could use 3 index to track when\\n        multiply by 2,3,5. everytime , we want to add the min value\\n        \\n        Sample :\\n        i2=i3=i5=0, arr=[1], n=5\\n        1\\n        <-----i2,i3,i5.  min(arr[i2]*2, arr[i2]*3, arr[i5]*5) = 2  use i2. i2+=1\\n        1, 2\\n           <-----i2 .  min(arr[i2]*2, arr[i3]*3, arr[i5]*5) = 3  use i3. i3+=1\\n        <-----i3,i5\\n        1, 2, 3\\n           <------i2,i3 min(arr[i2]*2, arr[i3]*3, arr[i5]*5) = 4. use i2. i2+=1\\n        <---------i5\\n        1, 2, 3, 4\\n              <---i2    min(arr[i2]*2, arr[1]*3, arr[0]*5) = 5. use i5. i5+=1\\n           <------i3\\n        <---------i5\\n        1, 2, 3, 4, 5\\n    \"\"\"\\n    i2,i3,i5=0,0,0\\n\\tarr = [1]\\n\\twhile len(arr) < n:\\n\\t\\tv2,v3,v5 = arr[i2]*2, arr[i3]*3, arr[i5]*5\\n\\t\\tm = min(v2,v3,v5)\\n\\t\\tif m == v2:\\n\\t\\t\\ti2+=1\\n\\t\\tif m == v3:\\n\\t\\t\\ti3+=1\\n\\t\\tif m == v5:\\n\\t\\t\\ti5+=1\\n\\t\\tarr.append(m)\\n\\treturn arr[-1]\\n```",
                "solutionTags": [],
                "code": "```\\ndef nthUglyNumber(self, n: int) -> int:\\n    \"\"\"\\n        Think about array \\n        a, b, c, d ,e\\n        for every element , could multiply by 2, 3, 5 then become new array\\n        2*a, 2*b, 2*c ...3*a, 3*b, 3*c ...5*a ,5*b\\n        but we want to nth ugly number, the result is not sorted , it could be \\n        2*a, 1*c, 2*b, 3*a ....\\n        To make sure the array is sorted while expanding. Could use 3 index to track when\\n        multiply by 2,3,5. everytime , we want to add the min value\\n        \\n        Sample :\\n        i2=i3=i5=0, arr=[1], n=5\\n        1\\n        <-----i2,i3,i5.  min(arr[i2]*2, arr[i2]*3, arr[i5]*5) = 2  use i2. i2+=1\\n        1, 2\\n           <-----i2 .  min(arr[i2]*2, arr[i3]*3, arr[i5]*5) = 3  use i3. i3+=1\\n        <-----i3,i5\\n        1, 2, 3\\n           <------i2,i3 min(arr[i2]*2, arr[i3]*3, arr[i5]*5) = 4. use i2. i2+=1\\n        <---------i5\\n        1, 2, 3, 4\\n              <---i2    min(arr[i2]*2, arr[1]*3, arr[0]*5) = 5. use i5. i5+=1\\n           <------i3\\n        <---------i5\\n        1, 2, 3, 4, 5\\n    \"\"\"\\n    i2,i3,i5=0,0,0\\n\\tarr = [1]\\n\\twhile len(arr) < n:\\n\\t\\tv2,v3,v5 = arr[i2]*2, arr[i3]*3, arr[i5]*5\\n\\t\\tm = min(v2,v3,v5)\\n\\t\\tif m == v2:\\n\\t\\t\\ti2+=1\\n\\t\\tif m == v3:\\n\\t\\t\\ti3+=1\\n\\t\\tif m == v5:\\n\\t\\t\\ti5+=1\\n\\t\\tarr.append(m)\\n\\treturn arr[-1]\\n```",
                "codeTag": "Python3"
            },
            {
                "id": 1682470,
                "title": "java-with-comments-dp",
                "content": "```\\nclass Solution {\\n    public int nthUglyNumber(int n) {\\n        //1. Instantiate an array for holding the results\\n        int[] dp = new int[n+1];\\n        \\n        dp[1]=1;\\n        // 2.Create three index pointers pointing to different positions of the array.\\n        int p2=1;\\n        int p3=1;\\n        int p5=1;\\n        \\n    \\n        for(int i =2 ;i<=n;i++)\\n        {\\n           int f1 = 2* dp[p2];\\n           int f2 = 3* dp[p3];\\n           int f3 = 5* dp[p5];\\n            \\n        // 3.Since we are not using a priority Queue, we need\\n        // to keep track of the minimum value and append to the result ourselves.\\n            int min = Math.min(f1,Math.min(f2,f3));\\n            dp[i]=min;\\n            \\n            \\n            \\n    // 4.If any of the above the value is the minimum value of the three,\\n    // then we move the corresponding pointer to calculate the next iteration\\n    // These pointers help us keep track of the ascending order and ensure\\n    // each value we put in the result is indeed in a sorted order.    \\n            if(min==f1)\\n            {\\n                p2++;\\n            }\\n            if(min==f2)\\n            {\\n                p3++;\\n            }\\n            if(min==f3)\\n            {\\n                p5++;\\n            }\\n        }\\n        return dp[n];\\n        //5.The last element of the result array is the nth prime factor number we want.\\n    }\\n}\\n```\\n**Give it a upvote if you like it (:**",
                "solutionTags": [
                    "Java",
                    "Dynamic Programming"
                ],
                "code": "```\\nclass Solution {\\n    public int nthUglyNumber(int n) {\\n        //1. Instantiate an array for holding the results\\n        int[] dp = new int[n+1];\\n        \\n        dp[1]=1;\\n        // 2.Create three index pointers pointing to different positions of the array.\\n        int p2=1;\\n        int p3=1;\\n        int p5=1;\\n        \\n    \\n        for(int i =2 ;i<=n;i++)\\n        {\\n           int f1 = 2* dp[p2];\\n           int f2 = 3* dp[p3];\\n           int f3 = 5* dp[p5];\\n            \\n        // 3.Since we are not using a priority Queue, we need\\n        // to keep track of the minimum value and append to the result ourselves.\\n            int min = Math.min(f1,Math.min(f2,f3));\\n            dp[i]=min;\\n            \\n            \\n            \\n    // 4.If any of the above the value is the minimum value of the three,\\n    // then we move the corresponding pointer to calculate the next iteration\\n    // These pointers help us keep track of the ascending order and ensure\\n    // each value we put in the result is indeed in a sorted order.    \\n            if(min==f1)\\n            {\\n                p2++;\\n            }\\n            if(min==f2)\\n            {\\n                p3++;\\n            }\\n            if(min==f3)\\n            {\\n                p5++;\\n            }\\n        }\\n        return dp[n];\\n        //5.The last element of the result array is the nth prime factor number we want.\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1504296,
                "title": "java-o-n-dp-solution-explained",
                "content": "\\n```\\n/*\\n1 -> 1 base case\\n2 -> 1 * 2 (from index 0 * 2)\\n3 -> 2 * 3 (form index 0 * 3)\\n4 -> 2 * 2 (from index 1 * 2)\\n5 -> 1 * 5 (from index 0 * 5)\\n6 -> 2 * 3 (from index 1 * 3 || index 2 * 2)\\n8 -> 4 * 2 (from index 3 * 2)\\n9 -> 3 * 3\\n10 -> 5 * 2\\n12 -> 6 * 2 || 4 * 3\\n15 -> 5 * 3\\n\\n1. All values are derived from some previous value.\\n2. Each previous value will for sure be used once.\\n3. So for each previous value, we need to check if it can generate\\n    current value. And 3 pointers are need each to * 2, 3, 5.\\n\\ndp[i] = min(dp[p2] * 2, dp[p3] * 3, dp[p5] * 5)\\nwhere pk is the pointer that times k to get the next ugly number\\nand pk++ each time an ugly number can be computed with pk * k.\\n*/\\nclass Solution {\\n    public int nthUglyNumber(int n) {\\n        int[] dp = new int[n];\\n        dp[0] = 1; // n >= 1 known fact.\\n        int p2 = 0, p3 = 0, p5 = 0;\\n        for (int i = 1; i < n; i++) {\\n            dp[i] = Math.min(Math.min(dp[p2] * 2, dp[p3] * 3), dp[p5] * 5);\\n            p2 = (dp[i] == dp[p2] * 2) ? p2 + 1 : p2;\\n            p3 = (dp[i] == dp[p3] * 3) ? p3 + 1 : p3;\\n            p5 = (dp[i] == dp[p5] * 5) ? p5 + 1 : p5;\\n        }\\n        return dp[n - 1];\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Dynamic Programming"
                ],
                "code": "```\\n/*\\n1 -> 1 base case\\n2 -> 1 * 2 (from index 0 * 2)\\n3 -> 2 * 3 (form index 0 * 3)\\n4 -> 2 * 2 (from index 1 * 2)\\n5 -> 1 * 5 (from index 0 * 5)\\n6 -> 2 * 3 (from index 1 * 3 || index 2 * 2)\\n8 -> 4 * 2 (from index 3 * 2)\\n9 -> 3 * 3\\n10 -> 5 * 2\\n12 -> 6 * 2 || 4 * 3\\n15 -> 5 * 3\\n\\n1. All values are derived from some previous value.\\n2. Each previous value will for sure be used once.\\n3. So for each previous value, we need to check if it can generate\\n    current value. And 3 pointers are need each to * 2, 3, 5.\\n\\ndp[i] = min(dp[p2] * 2, dp[p3] * 3, dp[p5] * 5)\\nwhere pk is the pointer that times k to get the next ugly number\\nand pk++ each time an ugly number can be computed with pk * k.\\n*/\\nclass Solution {\\n    public int nthUglyNumber(int n) {\\n        int[] dp = new int[n];\\n        dp[0] = 1; // n >= 1 known fact.\\n        int p2 = 0, p3 = 0, p5 = 0;\\n        for (int i = 1; i < n; i++) {\\n            dp[i] = Math.min(Math.min(dp[p2] * 2, dp[p3] * 3), dp[p5] * 5);\\n            p2 = (dp[i] == dp[p2] * 2) ? p2 + 1 : p2;\\n            p3 = (dp[i] == dp[p3] * 3) ? p3 + 1 : p3;\\n            p5 = (dp[i] == dp[p5] * 5) ? p5 + 1 : p5;\\n        }\\n        return dp[n - 1];\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1373856,
                "title": "dp-solution-java-2-ms",
                "content": "```\\nclass Solution {\\n    public int nthUglyNumber(int n) {\\n        int dp[] = new int[n+1]; \\n        dp[0] = 0;\\n        dp[1] = 1;\\n        int p2 = 1 , p3 = 1 , p5 = 1;\\n        \\n        for(int i = 2 ; i <= n ; i++)\\n        {\\n            int next2 = dp[p2] * 2; \\n            int next3 = dp[p3] * 3;\\n            int next5 = dp[p5] * 5;\\n            \\n            int ans = Math.min(next2 , Math.min(next3 , next5)); \\n            dp[i] = ans;\\n            \\n            if(ans == next2) p2++;\\n            if(ans == next3) p3++;\\n            if(ans == next5) p5++;\\n        }\\n        \\n        return dp[n]; \\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Dynamic Programming"
                ],
                "code": "```\\nclass Solution {\\n    public int nthUglyNumber(int n) {\\n        int dp[] = new int[n+1]; \\n        dp[0] = 0;\\n        dp[1] = 1;\\n        int p2 = 1 , p3 = 1 , p5 = 1;\\n        \\n        for(int i = 2 ; i <= n ; i++)\\n        {\\n            int next2 = dp[p2] * 2; \\n            int next3 = dp[p3] * 3;\\n            int next5 = dp[p5] * 5;\\n            \\n            int ans = Math.min(next2 , Math.min(next3 , next5)); \\n            dp[i] = ans;\\n            \\n            if(ans == next2) p2++;\\n            if(ans == next3) p3++;\\n            if(ans == next5) p5++;\\n        }\\n        \\n        return dp[n]; \\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1263375,
                "title": "c-easy-understanding",
                "content": "```\\nint nthUglyNumber(int n)\\n    {\\n        vector<int> res(1, 1);\\n        int i = 0, j = 0, k = 0;\\n        while(res.size() < n)\\n        {\\n            res.push_back(min(res[i] * 2, min(res[j] * 3, res[k] * 5)));\\n            if(res.back() == res[i] * 2)\\n                i++;\\n            if(res.back() == res[j] * 3)\\n                j++;\\n            if(res.back() == res[k] * 5)\\n                k++;\\n        }\\n        \\n        return res[n - 1];\\n    }\\n```",
                "solutionTags": [
                    "C++",
                    "C"
                ],
                "code": "```\\nint nthUglyNumber(int n)\\n    {\\n        vector<int> res(1, 1);\\n        int i = 0, j = 0, k = 0;\\n        while(res.size() < n)\\n        {\\n            res.push_back(min(res[i] * 2, min(res[j] * 3, res[k] * 5)));\\n            if(res.back() == res[i] * 2)\\n                i++;\\n            if(res.back() == res[j] * 3)\\n                j++;\\n            if(res.back() == res[k] * 5)\\n                k++;\\n        }\\n        \\n        return res[n - 1];\\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1199158,
                "title": "c-easy-solution-o-n-time",
                "content": "```\\nclass Solution {\\npublic:\\n    int nthUglyNumber(int n) {\\n        int dp[n];\\n        dp[0]=1;\\n        int L1=0,L2=0,L3=0;\\n        for(int i=1;i<n;i++)\\n        {\\n            dp[i]=min(2*dp[L1], min(3*dp[L2],5*dp[L3]));\\n            \\n            if(dp[i]==2*dp[L1])\\n                L1++;\\n            if(dp[i]==3*dp[L2])\\n                L2++;\\n            if(dp[i]==5*dp[L3])\\n                L3++;\\n            \\n        }\\n        return dp[n-1];\\n        \\n    }\\n};",
                "solutionTags": [],
                "code": "class Solution {\\npublic:\\n    int nthUglyNumber(int n) {\\n        int dp[n];\\n        dp[0]=1;\\n        int L1=0,L2=0,L3=0;\\n        for(int i=1;i<n;i++)\\n        {\\n            dp[i]=min(2*dp[L1], min(3*dp[L2],5*dp[L3]));\\n            \\n            if(dp[i]==2*dp[L1])\\n                L1++;\\n            if(dp[i]==3*dp[L2])\\n                L2++;\\n            if(dp[i]==5*dp[L3])\\n                L3++;\\n            \\n        }",
                "codeTag": "Java"
            },
            {
                "id": 816688,
                "title": "easy-way-explanation-ugly-number",
                "content": "```\\n\\n#        analyzation\\n\\ninitialize\\n   ugly[] =  | 1 |\\n   i2 =  i3 = i5 = 0;\\n\\nFirst iteration\\n   ugly[1] = Min(ugly[i2]*2, ugly[i3]*3, ugly[i5]*5)\\n            = Min(2, 3, 5)\\n            = 2\\n   ugly[] =  | 1 | 2 |\\n   i2 = 1,  i3 = i5 = 0  (i2 got incremented ) \\n\\nSecond iteration\\n    ugly[2] = Min(ugly[i2]*2, ugly[i3]*3, ugly[i5]*5)\\n             = Min(4, 3, 5)\\n             = 3\\n    ugly[] =  | 1 | 2 | 3 |\\n    i2 = 1,  i3 =  1, i5 = 0  (i3 got incremented ) \\n\\nThird iteration\\n    ugly[3] = Min(ugly[i2]*2, ugly[i3]*3, ugly[i5]*5)\\n             = Min(4, 6, 5)\\n             = 4\\n    ugly[] =  | 1 | 2 | 3 |  4 |\\n    i2 = 2,  i3 =  1, i5 = 0  (i2 got incremented )\\n\\nFourth iteration\\n    ugly[4] = Min(ugly[i2]*2, ugly[i3]*3, ugly[i5]*5)\\n              = Min(6, 6, 5)\\n              = 5\\n    ugly[] =  | 1 | 2 | 3 |  4 | 5 |\\n    i2 = 2,  i3 =  1, i5 = 1  (i5 got incremented )\\n\\nFifth iteration\\n    ugly[4] = Min(ugly[i2]*2, ugly[i3]*3, ugly[i5]*5)\\n              = Min(6, 6, 10)\\n              = 6\\n    ugly[] =  | 1 | 2 | 3 |  4 | 5 | 6 |\\n    i2 = 3,  i3 =  2, i5 = 1  (i2 and i3 got incremented )\\n\\nWill continue same way till I < n+1\\n\\n\\n```\\n\\n```\\n#. Algorithm\\n\\n1 Declare an array for ugly numbers:  ugly[n]\\n2 Initialize first ugly no:  ugly[0] = 1\\n3 Initialize three array index variables x, y, z to point to \\n   1st element of the ugly array: \\n        x = y = z=0; \\n5 Now go in a loop to fill all ugly numbers till n+1:\\nFor  i =0 to n+1\\n{\\n    d.append(min(d[x]*2,d[y]*3,d[z]*5))\\n\\t\\n          m=d[-1]   #next ugly number\\n\\t\\t  \\n          if m==d[x]*2:\\n\\t\\t  #if ugly number ===next ugly number then increase pointer\\n            x=x+1\\n\\t\\t\\t\\n          if m==d[y]*3:\\n            y=y+1\\n            \\n          if m==d[z]*5:\\n            z=z+1\\n            \\n        return d[n-1]\\n\\n    \\n6.return next_ugly_no\\n\\n\\n\\n```\\n\\n\\n```\\n\\n#python code\\n\\n        d=[1]\\n        x,y,z=0,0,0\\n        for i in range(n+1):\\n          d.append(min(d[x]*2,d[y]*3,d[z]*5))\\n          m=d[-1]\\n          if m==d[x]*2:\\n            x=x+1\\n          if m==d[y]*3:\\n            y=y+1\\n            \\n          if m==d[z]*5:\\n            z=z+1\\n            \\n        return d[n-1]\\n          \\n        \\n\\n\\n\\n```",
                "solutionTags": [
                    "Python",
                    "Python3"
                ],
                "code": "```\\n\\n#        analyzation\\n\\ninitialize\\n   ugly[] =  | 1 |\\n   i2 =  i3 = i5 = 0;\\n\\nFirst iteration\\n   ugly[1] = Min(ugly[i2]*2, ugly[i3]*3, ugly[i5]*5)\\n            = Min(2, 3, 5)\\n            = 2\\n   ugly[] =  | 1 | 2 |\\n   i2 = 1,  i3 = i5 = 0  (i2 got incremented ) \\n\\nSecond iteration\\n    ugly[2] = Min(ugly[i2]*2, ugly[i3]*3, ugly[i5]*5)\\n             = Min(4, 3, 5)\\n             = 3\\n    ugly[] =  | 1 | 2 | 3 |\\n    i2 = 1,  i3 =  1, i5 = 0  (i3 got incremented ) \\n\\nThird iteration\\n    ugly[3] = Min(ugly[i2]*2, ugly[i3]*3, ugly[i5]*5)\\n             = Min(4, 6, 5)\\n             = 4\\n    ugly[] =  | 1 | 2 | 3 |  4 |\\n    i2 = 2,  i3 =  1, i5 = 0  (i2 got incremented )\\n\\nFourth iteration\\n    ugly[4] = Min(ugly[i2]*2, ugly[i3]*3, ugly[i5]*5)\\n              = Min(6, 6, 5)\\n              = 5\\n    ugly[] =  | 1 | 2 | 3 |  4 | 5 |\\n    i2 = 2,  i3 =  1, i5 = 1  (i5 got incremented )\\n\\nFifth iteration\\n    ugly[4] = Min(ugly[i2]*2, ugly[i3]*3, ugly[i5]*5)\\n              = Min(6, 6, 10)\\n              = 6\\n    ugly[] =  | 1 | 2 | 3 |  4 | 5 | 6 |\\n    i2 = 3,  i3 =  2, i5 = 1  (i2 and i3 got incremented )\\n\\nWill continue same way till I < n+1\\n\\n\\n```\n```\\n#. Algorithm\\n\\n1 Declare an array for ugly numbers:  ugly[n]\\n2 Initialize first ugly no:  ugly[0] = 1\\n3 Initialize three array index variables x, y, z to point to \\n   1st element of the ugly array: \\n        x = y = z=0; \\n5 Now go in a loop to fill all ugly numbers till n+1:\\nFor  i =0 to n+1\\n{\\n    d.append(min(d[x]*2,d[y]*3,d[z]*5))\\n\\t\\n          m=d[-1]   #next ugly number\\n\\t\\t  \\n          if m==d[x]*2:\\n\\t\\t  #if ugly number ===next ugly number then increase pointer\\n            x=x+1\\n\\t\\t\\t\\n          if m==d[y]*3:\\n            y=y+1\\n            \\n          if m==d[z]*5:\\n            z=z+1\\n            \\n        return d[n-1]\\n\\n    \\n6.return next_ugly_no\\n\\n\\n\\n```\n```\\n\\n#python code\\n\\n        d=[1]\\n        x,y,z=0,0,0\\n        for i in range(n+1):\\n          d.append(min(d[x]*2,d[y]*3,d[z]*5))\\n          m=d[-1]\\n          if m==d[x]*2:\\n            x=x+1\\n          if m==d[y]*3:\\n            y=y+1\\n            \\n          if m==d[z]*5:\\n            z=z+1\\n            \\n        return d[n-1]\\n          \\n        \\n\\n\\n\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 760165,
                "title": "runtime-8-ms-faster-than-90-74-of-c-online-submissions",
                "content": "\\n\\n      int nthUglyNumber(int n) {\\n                  if (n == 0) return 0;\\n                  int arr[n];\\n                  arr[0]=1;\\n                  int i2=0,i3=0,i5=0;\\n                  for(int i=1;i<n;i++){\\n                      arr[i]=min(arr[i2]*2,min(arr[i3]*3,arr[i5]*5));\\n                      if(arr[i]==arr[i2]*2){\\n                              i2++;\\n                      }\\n                      if(arr[i]==arr[i3]*3){\\n                              i3++;\\n                      }\\n                      if(arr[i]==arr[i5]*5){\\n                          i5++;\\n                      }\\n                  }\\n                  return arr[n-1];\\n          }\\n\\t\\t  \\n**Feel free to ask any question in the comment section.\\nIf you like this solution, do UPVOTE.\\nHappy Coding :)**\\n\\t",
                "solutionTags": [
                    "C++",
                    "Dynamic Programming"
                ],
                "code": "\\n\\n      int nthUglyNumber(int n) {\\n                  if (n == 0) return 0;\\n                  int arr[n];\\n                  arr[0]=1;\\n                  int i2=0,i3=0,i5=0;\\n                  for(int i=1;i<n;i++){\\n                      arr[i]=min(arr[i2]*2,min(arr[i3]*3,arr[i5]*5));\\n                      if(arr[i]==arr[i2]*2){\\n                              i2++;\\n                      }\\n                      if(arr[i]==arr[i3]*3){\\n                              i3++;\\n                      }\\n                      if(arr[i]==arr[i5]*5){\\n                          i5++;\\n                      }\\n                  }\\n                  return arr[n-1];\\n          }\\n\\t\\t  \\n**Feel free to ask any question in the comment section.\\nIf you like this solution, do UPVOTE.\\nHappy Coding :)**\\n\\t",
                "codeTag": "Unknown"
            },
            {
                "id": 718952,
                "title": "java-detailed-explanation-simple-to-understand-with-explanation",
                "content": "The important catch for this problem was that it can have only multiples of 2, 3 and 5. Once we deep dive into this, we can conclude following point:\\n\\n1. Number will be of the form ```2^x * 3^y * 5^z``` \\n2. First number will always be 1 (x = 0, y = 0, z = 0)\\n3. If 2^x == 3^y then we should definetly increment x & y, similarly for y & z and x & z\\n\\nOnce we have understood the all 3 points, here comes the observation part. Notice that ```numbers``` will only have the integers of the form ```2^x * 3^y * 5^z``` . If we want to find the next multiple that should be multiplied with either 2, 3 or 5, it can be found in the numbers list. But how? Answer will be in the pointer approach.\\n\\nNotice that all x, y & z powers starts with 0. Let\\'s have 3 pointers ```c2, c3, c5```. For initial steps you can write it down in paper:\\n```\\n// Initially 1 is pushed to array numbers\\nnumbers list becomes = [1]\\n2 = 1*2 // Here c2 = 0 so we fetch that index number i.e. 1 from numbers and c2 is incremented by 1\\nnumbers list becomes = [1, 2]\\n3 = 1*3 // Here c3 = 0 so we fetch that index number i.e. 1 from numbers and c3 is incremented by 1\\nnumbers list becomes = [1, 2, 3]\\n4 = 2*2 // Here c2 = 1 so we fetch that index number i.e. 2 from numbers and c2 is incremented by 1\\nnumbers list becomes = [1, 2, 3, 4]\\n5 = 1*5 // Here c5 = 0 so we fetch that index number i.e. 1 from numbers and c5 is incremented by 1\\nnumbers list becomes = [1, 2, 3, 4, 5]\\n6 = 3*2 // Here c2 = 2 so we fetch that index number i.e. 3 from numbers and c2 is incremented by 1\\n6 = 2*3 // Here c3 = 1 so we fetch that index number i.e. 2 from numbers and c3 is incremented by 1\\nnumbers list becomes = [1, 2, 3, 4, 5, 6]\\n8 = 4*2 // Here c2 = 3 so we fetch that index number i.e. 4 from numbers and c2 is incremented by 1\\nnumbers list becomes = [1, 2, 3, 4, 5, 6, 8]\\n9 = 3*3 // Here c3 = 2 so we fetch that index number i.e. 3 from numbers and c3 is incremented by 1\\nnumbers list becomes = [1, 2, 3, 4, 5, 6, 8, 9]\\n10 = 5*2 // Here c2 = 4 so we fetch that index number i.e. 5 from numbers and c2 is incremented by 1\\n10 = 2*5 // Here c5 = 1 so we fetch that index number i.e. 2 from numbers and c5 is incremented by 1\\nnumbers list becomes = [1, 2, 3, 4, 5, 6, 8, 9, 10]\\n12 = 6*2 // Here c2 = 5 so we fetch that index number i.e. 6 from numbers and c2 is incremented by 1\\n12 = 4*3 // Here c3 = 3 so we fetch that index number i.e. 4 from numbers and c3 is incremented by 1\\nnumbers list becomes = [1, 2, 3, 4, 5, 6, 8, 9, 10, 12]\\n................. and the rest is history\\n```\\nCheck out the following implementation for this logic: \\n```\\nclass Solution {\\n    ArrayList<Integer> numbers;\\n    Solution() {\\n        numbers = new ArrayList<>();\\n        numbers.add(1);\\n        int c2 = 0, c3 = 0, c5 = 0;\\n        for(int i = 1;i<1690;i++){\\n            int min = Math.min(numbers.get(c2)*2, Math.min(numbers.get(c3)*3, numbers.get(c5)*5));\\n            numbers.add(min);\\n            if(min==numbers.get(c2)*2) c2++;\\n            if(min==numbers.get(c3)*3) c3++;\\n            if(min==numbers.get(c5)*5) c5++;\\n        }\\n    }\\n    public int nthUglyNumber(int n) {\\n        return numbers.get(n-1);\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```2^x * 3^y * 5^z```\n```numbers```\n```2^x * 3^y * 5^z```\n```c2, c3, c5```\n```\\n// Initially 1 is pushed to array numbers\\nnumbers list becomes = [1]\\n2 = 1*2 // Here c2 = 0 so we fetch that index number i.e. 1 from numbers and c2 is incremented by 1\\nnumbers list becomes = [1, 2]\\n3 = 1*3 // Here c3 = 0 so we fetch that index number i.e. 1 from numbers and c3 is incremented by 1\\nnumbers list becomes = [1, 2, 3]\\n4 = 2*2 // Here c2 = 1 so we fetch that index number i.e. 2 from numbers and c2 is incremented by 1\\nnumbers list becomes = [1, 2, 3, 4]\\n5 = 1*5 // Here c5 = 0 so we fetch that index number i.e. 1 from numbers and c5 is incremented by 1\\nnumbers list becomes = [1, 2, 3, 4, 5]\\n6 = 3*2 // Here c2 = 2 so we fetch that index number i.e. 3 from numbers and c2 is incremented by 1\\n6 = 2*3 // Here c3 = 1 so we fetch that index number i.e. 2 from numbers and c3 is incremented by 1\\nnumbers list becomes = [1, 2, 3, 4, 5, 6]\\n8 = 4*2 // Here c2 = 3 so we fetch that index number i.e. 4 from numbers and c2 is incremented by 1\\nnumbers list becomes = [1, 2, 3, 4, 5, 6, 8]\\n9 = 3*3 // Here c3 = 2 so we fetch that index number i.e. 3 from numbers and c3 is incremented by 1\\nnumbers list becomes = [1, 2, 3, 4, 5, 6, 8, 9]\\n10 = 5*2 // Here c2 = 4 so we fetch that index number i.e. 5 from numbers and c2 is incremented by 1\\n10 = 2*5 // Here c5 = 1 so we fetch that index number i.e. 2 from numbers and c5 is incremented by 1\\nnumbers list becomes = [1, 2, 3, 4, 5, 6, 8, 9, 10]\\n12 = 6*2 // Here c2 = 5 so we fetch that index number i.e. 6 from numbers and c2 is incremented by 1\\n12 = 4*3 // Here c3 = 3 so we fetch that index number i.e. 4 from numbers and c3 is incremented by 1\\nnumbers list becomes = [1, 2, 3, 4, 5, 6, 8, 9, 10, 12]\\n................. and the rest is history\\n```\n```\\nclass Solution {\\n    ArrayList<Integer> numbers;\\n    Solution() {\\n        numbers = new ArrayList<>();\\n        numbers.add(1);\\n        int c2 = 0, c3 = 0, c5 = 0;\\n        for(int i = 1;i<1690;i++){\\n            int min = Math.min(numbers.get(c2)*2, Math.min(numbers.get(c3)*3, numbers.get(c5)*5));\\n            numbers.add(min);\\n            if(min==numbers.get(c2)*2) c2++;\\n            if(min==numbers.get(c3)*3) c3++;\\n            if(min==numbers.get(c5)*5) c5++;\\n        }\\n    }\\n    public int nthUglyNumber(int n) {\\n        return numbers.get(n-1);\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 395702,
                "title": "python-dp-o-n-with-explanation",
                "content": "```\\nclass Solution(object):\\n    def nthUglyNumber(self, n):\\n        \"\"\"\\n        DP approach.\\n        The idea is to add the numbers to the uglyNumbers list one-by-one by multiplying 2 \\n        or 3 or 5. While adding the values, we must make sure that a value lesser than\\n        previously added won\\'t be divisible by the other 2 primes. Hence, increment the\\n        pointers such that next minimum value can be added to the list.\\n        \"\"\"\\n        uglyNumbers = [1]\\n        p2 = p3 = p5 = 0\\n        \\n        while len(uglyNumbers) < n:\\n            #If a value lesser than latest was already added, try finding next least value.\\n            while uglyNumbers[p2]*2 <= uglyNumbers[-1]:\\n                p2 += 1\\n            \\n            while uglyNumbers[p3]*3 <= uglyNumbers[-1]:\\n                p3 += 1\\n            \\n            while uglyNumbers[p5]*5 <= uglyNumbers[-1]:\\n                p5 += 1\\n            \\n            nextVal = min(uglyNumbers[p2]*2, uglyNumbers[p3]*3, uglyNumbers[p5]*5)\\n            uglyNumbers.append(nextVal)\\n        \\n        return uglyNumbers[-1]\\n        \\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution(object):\\n    def nthUglyNumber(self, n):\\n        \"\"\"\\n        DP approach.\\n        The idea is to add the numbers to the uglyNumbers list one-by-one by multiplying 2 \\n        or 3 or 5. While adding the values, we must make sure that a value lesser than\\n        previously added won\\'t be divisible by the other 2 primes. Hence, increment the\\n        pointers such that next minimum value can be added to the list.\\n        \"\"\"\\n        uglyNumbers = [1]\\n        p2 = p3 = p5 = 0\\n        \\n        while len(uglyNumbers) < n:\\n            #If a value lesser than latest was already added, try finding next least value.\\n            while uglyNumbers[p2]*2 <= uglyNumbers[-1]:\\n                p2 += 1\\n            \\n            while uglyNumbers[p3]*3 <= uglyNumbers[-1]:\\n                p3 += 1\\n            \\n            while uglyNumbers[p5]*5 <= uglyNumbers[-1]:\\n                p5 += 1\\n            \\n            nextVal = min(uglyNumbers[p2]*2, uglyNumbers[p3]*3, uglyNumbers[p5]*5)\\n            uglyNumbers.append(nextVal)\\n        \\n        return uglyNumbers[-1]\\n        \\n```",
                "codeTag": "Java"
            },
            {
                "id": 352644,
                "title": "python-7-lines-o-n-using-collections-deque",
                "content": "Keep picking the smallest value from the start of queues, popping it out to the left, and appending bigger candidates to the end.\\n```\\n    def nthUglyNumber(self, n):\\n        queues = {prime: collections.deque([1]) for prime in [2, 3, 5]}\\n        for _ in range(n):\\n            result = min([queue[0] for queue in queues.values()])\\n            for prime, queue in queues.items():\\n                if result == queue[0]: queue.popleft()\\n                queue.append(result*prime)\\n        return result\\n```\\nThe code below does this same thing, but written less succinctly. Maybe slighlty easier to follow.\\n```\\nfrom collections import deque\\nclass Solution(object):\\n    def nthUglyNumber(self, n):\\n        if n == 1: return 1\\n        queue2, queue3, queue5 = deque([2]), deque([3]), deque([5])\\n        for _ in range(1, n):\\n            result = min(queue2[0], queue3[0], queue5[0])\\n            if result == queue2[0]: queue2.popleft()\\n            if result == queue3[0]: queue3.popleft()\\n            if result == queue5[0]: queue5.popleft()\\n            queue2.append(result*2)\\n            queue3.append(result*3)\\n            queue5.append(result*5)\\n        return result\\n```\\n",
                "solutionTags": [
                    "Python"
                ],
                "code": "```\\n    def nthUglyNumber(self, n):\\n        queues = {prime: collections.deque([1]) for prime in [2, 3, 5]}\\n        for _ in range(n):\\n            result = min([queue[0] for queue in queues.values()])\\n            for prime, queue in queues.items():\\n                if result == queue[0]: queue.popleft()\\n                queue.append(result*prime)\\n        return result\\n```\n```\\nfrom collections import deque\\nclass Solution(object):\\n    def nthUglyNumber(self, n):\\n        if n == 1: return 1\\n        queue2, queue3, queue5 = deque([2]), deque([3]), deque([5])\\n        for _ in range(1, n):\\n            result = min(queue2[0], queue3[0], queue5[0])\\n            if result == queue2[0]: queue2.popleft()\\n            if result == queue3[0]: queue3.popleft()\\n            if result == queue5[0]: queue5.popleft()\\n            queue2.append(result*2)\\n            queue3.append(result*3)\\n            queue5.append(result*5)\\n        return result\\n```",
                "codeTag": "Java"
            },
            {
                "id": 69402,
                "title": "python-easy-to-come-up-solution-with-priority-queue",
                "content": "```\\nfrom heapq import *\\n\\nclass Solution(object):\\n    def nthUglyNumber(self, n):\\n        h = [1]\\n        i = 0\\n        s = set()\\n        while i < n:\\n            e = heappop(h)\\n            if e not in s:\\n                s.add(e)\\n                heappush(h, e*2)\\n                heappush(h, e*3)\\n                heappush(h, e*5)\\n                i += 1\\n        return e\\n```\\nOf course, not an optimized solution but it is something you can easily come up with and code fast during the interview.",
                "solutionTags": [],
                "code": "```\\nfrom heapq import *\\n\\nclass Solution(object):\\n    def nthUglyNumber(self, n):\\n        h = [1]\\n        i = 0\\n        s = set()\\n        while i < n:\\n            e = heappop(h)\\n            if e not in s:\\n                s.add(e)\\n                heappush(h, e*2)\\n                heappush(h, e*3)\\n                heappush(h, e*5)\\n                i += 1\\n        return e\\n```",
                "codeTag": "Java"
            },
            {
                "id": 69390,
                "title": "my-8ms-java-dp-solution",
                "content": "My 8ms JAVA DP Solution\\n\\n  public int nthUglyNumber(int n) {\\n        \\n        if( n == 0 || n == 1) {\\n            return n;\\n        }\\n        \\n        int pointer2 = 0;\\n        int pointer3 = 0;\\n        int pointer5 = 0;\\n        \\n        int[] result = new int[n];\\n        result[0] = 1;\\n\\n        int i = 1, min =0;\\n        while ( i < n ) {\\n            min = Math.min(result[pointer2]*2,Math.min(result[pointer3]*3,result[pointer5]*5));\\n            \\n            if(min == result[pointer2]*2) {\\n                pointer2++;\\n            }\\n            if(min == result[pointer3]*3) {\\n                pointer3++;\\n            }\\n            if(min == result[pointer5]*5) {\\n                pointer5++;\\n            }\\n            result[i] = min;\\n         \\n            i++;\\n            \\n        }\\n        return result[n-1];\\n    }",
                "solutionTags": [],
                "code": "My 8ms JAVA DP Solution\\n\\n  public int nthUglyNumber(int n) {\\n        \\n        if( n == 0 || n == 1) {\\n            return n;\\n        }\\n        \\n        int pointer2 = 0;\\n        int pointer3 = 0;\\n        int pointer5 = 0;\\n        \\n        int[] result = new int[n];\\n        result[0] = 1;\\n\\n        int i = 1, min =0;\\n        while ( i < n ) {\\n            min = Math.min(result[pointer2]*2,Math.min(result[pointer3]*3,result[pointer5]*5));\\n            \\n            if(min == result[pointer2]*2) {\\n                pointer2++;\\n            }\\n            if(min == result[pointer3]*3) {\\n                pointer3++;\\n            }\\n            if(min == result[pointer5]*5) {\\n                pointer5++;\\n            }\\n            result[i] = min;\\n         \\n            i++;\\n            \\n        }\\n        return result[n-1];\\n    }",
                "codeTag": "Unknown"
            },
            {
                "id": 69455,
                "title": "javascript-solution-beats-100-submissions-by-caching",
                "content": "    \"use strict\";\\n    \\n    var cache = [1];\\n    var p2 = 0;\\n    var p3 = 0;\\n    var p5 = 0;\\n    \\n    var nthUglyNumber = function(n) {\\n        var m,r2,r3,r5;\\n        var i = cache.length;\\n        for(;i < n ; i++)\\n        { \\n            r2 = cache[p2] * 2;\\n            r3 = cache[p3] * 3;\\n            r5 = cache[p5] * 5;\\n            m = Math.min(r2,r3,r5);\\n            if(m === r2) p2++; \\n            if(m === r3) p3++;\\n            if(m === r5) p5++;\\n            cache[i] = m;\\n        }\\n        return cache[n-1]; \\n    };",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "    \"use strict\";\\n    \\n    var cache = [1];\\n    var p2 = 0;\\n    var p3 = 0;\\n    var p5 = 0;\\n    \\n    var nthUglyNumber = function(n) {\\n        var m,r2,r3,r5;\\n        var i = cache.length;\\n        for(;i < n ; i++)\\n        { \\n            r2 = cache[p2] * 2;\\n            r3 = cache[p3] * 3;\\n            r5 = cache[p5] * 5;\\n            m = Math.min(r2,r3,r5);\\n            if(m === r2) p2++; \\n            if(m === r3) p3++;\\n            if(m === r5) p5++;\\n            cache[i] = m;\\n        }\\n        return cache[n-1]; \\n    };",
                "codeTag": "Unknown"
            },
            {
                "id": 69477,
                "title": "my-solution-in-c",
                "content": "    class Solution {\\n    public:\\n        long nthUglyNumber(int n) {\\n           set<long> pq;\\n    \\t\\tpq.insert(1);\\n    \\t\\tint count = 0;\\n    \\t\\tlong t = 1;\\n    \\t\\twhile (count < n)\\n    \\t\\t{\\n    \\t\\t\\tset<long>::iterator it = pq.begin();\\n    \\t\\t\\tt = *it;\\n    \\t\\t\\tpq.erase(it);\\n    \\t\\t\\tpq.insert(t * 2);\\n    \\t\\t\\tpq.insert(t * 3);\\n    \\t\\t\\tpq.insert(t * 5);\\n    \\t\\t\\tcount++;\\n            }\\n            return t;\\n        }\\n    };",
                "solutionTags": [],
                "code": "class Solution {\\n    public:\\n        long nthUglyNumber(int n) {\\n           set<long> pq;\\n    \\t\\tpq.insert(1);\\n    \\t\\tint count = 0;\\n    \\t\\tlong t = 1;\\n    \\t\\twhile (count < n)\\n    \\t\\t{\\n    \\t\\t\\tset<long>::iterator it = pq.begin();\\n    \\t\\t\\tt = *it;\\n    \\t\\t\\tpq.erase(it);\\n    \\t\\t\\tpq.insert(t * 2);\\n    \\t\\t\\tpq.insert(t * 3);\\n    \\t\\t\\tpq.insert(t * 5);\\n    \\t\\t\\tcount++;\\n            }",
                "codeTag": "Java"
            },
            {
                "id": 3629903,
                "title": "c-easy-solution-with-explanation",
                "content": "# Approach\\n1) Create a vector of size n called \"numbers\" to store the ugly numbers. Initialize the first element, numbers[0], as 1 since 1 is considered the first ugly number.\\n2) Initialize three variables: power2, power3, and power5. These variables will be used to track the indices of the numbers array that are multiplied by 2, 3, and 5 respectively.\\n3) Start a loop from i=1 (second element) to i<n (nth element) to generate the remaining ugly numbers:\\n- Calculate the next ugly number by taking the minimum value among numbers[power2] * 2, numbers[power3] * 3, and numbers[power5] * 5. This ensures that we always select the smallest possible ugly number at each step.\\n- If the next ugly number is equal to numbers[power2] * 2, increment power2 by 1. This means that the next ugly number will be obtained by multiplying the current numbers[power2] with 2 in the next iteration.\\n- If the next ugly number is equal to numbers[power3] * 3, increment power3 by 1. This means that the next ugly number will be obtained by multiplying the current numbers[power3] with 3 in the next iteration.\\n- If the next ugly number is equal to numbers[power5] * 5, increment power5 by 1. This means that the next ugly number will be obtained by multiplying the current numbers[power5] with 5 in the next iteration.\\n4) After the loop, the nth ugly number will be stored in numbers[n-1], so return that value.\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity: O(n)\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: O(n)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int nthUglyNumber(int n) {\\n        vector<int> numbers(n);\\n        numbers[0]=1;\\n        int power2=0;\\n        int power3=0;\\n        int power5=0;\\n        for(int i=1;i<n;i++){\\n            numbers[i]=min(numbers[power2]*2, min(numbers[power3]*3,numbers[power5]*5));\\n            if(numbers[i]==numbers[power2]*2){\\n                power2++;\\n            }\\n            if(numbers[i]==numbers[power3]*3){\\n                power3++;\\n            }\\n            if(numbers[i]==numbers[power5]*5){\\n                power5++;\\n            }\\n        }\\n        return numbers[n-1];\\n    }\\n};\\n```\\n**Please upvote if it helped. Happy Coding!**",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int nthUglyNumber(int n) {\\n        vector<int> numbers(n);\\n        numbers[0]=1;\\n        int power2=0;\\n        int power3=0;\\n        int power5=0;\\n        for(int i=1;i<n;i++){\\n            numbers[i]=min(numbers[power2]*2, min(numbers[power3]*3,numbers[power5]*5));\\n            if(numbers[i]==numbers[power2]*2){\\n                power2++;\\n            }\\n            if(numbers[i]==numbers[power3]*3){\\n                power3++;\\n            }\\n            if(numbers[i]==numbers[power5]*5){\\n                power5++;\\n            }\\n        }\\n        return numbers[n-1];\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3359332,
                "title": "most-efficient-c-approach-using-dp",
                "content": "# Intuition\\nThe solution uses dynamic programming to find the nth ugly number. It initializes a vector \"dp\" of size n and sets the first element to 1 since 1 is considered an ugly number. Three pointers are used to keep track of the multiples of 2, 3, and 5. Initially, all pointers are set to 0.\\n\\nIn each iteration of the loop, the algorithm computes the next ugly number by taking the minimum of the next possible multiples of 2, 3, and 5 using the values at the corresponding pointer positions. The resulting minimum is stored in the dp array at the current index. If any of the pointers generate an equal value to the computed ugly number, then that pointer is incremented.\\n\\nBy the end of the loop, the nth ugly number would be found in the last position of the dp array, so this value is returned.\\n\\nIntuitively, this solution works because it generates all possible ugly numbers in ascending order up to the nth ugly number. Since we are using dynamic programming to store previously computed values, we avoid recomputing already calculated values, thus reducing the time complexity of the algorithm.\\n\\n# Approach\\nSure, here\\'s a step-by-step explanation of the algorithm:\\n\\n- Create a vector \"dp\" of size n to store the first n ugly numbers.\\n\\n- Set the first element of dp to 1 since 1 is considered an ugly number.\\n\\n- Initialize three pointers: ptr1, ptr2, and ptr3 to keep track of multiples of 2, 3, and 5 respectively. All these pointers are initially set to 0.\\n\\n- In each iteration of the loop starting from i = 1, compute the next possible multiple of 2, 3, and 5 by multiplying the value at dp[ptr1], dp[ptr2], and dp[ptr3] with 2, 3, and 5 respectively. Let these values be stored in variables multipleOfTwo, multipleOfThree, and multipleOfFive respectively.\\n\\n- The minimum value among these three computed multiples of 2, 3, and 5 is the next ugly number in the sequence. Store this minimum value in dp[i].\\n\\n- If the computed ugly number is equal to multipleOfTwo, increment ptr1.\\n\\n- If the computed ugly number is equal to multipleOfThree, increment ptr2.\\n\\n- If the computed ugly number is equal to multipleOfFive, increment ptr3.\\n\\n- Repeat the steps 4-8 until we have generated the nth ugly number.\\n\\n- Return the last element of dp, which is the nth ugly number.\\n\\nBy following these steps, the algorithm will generate all possible ugly numbers up to the nth ugly number while avoiding recomputing already calculated values, thus reducing the time complexity of the algorithm.\\n\\n# Complexity\\n- Time complexity: $$O(N)$$\\n\\n- Space complexity: $$O(N)$$\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int nthUglyNumber(int n) {\\n        vector<int> dp(n);\\n        dp[0] = 1;\\n        int ptr1 = 0, ptr2 = 0, ptr3 = 0;\\n\\n        for(int i = 1; i < n; i++){\\n          int multipleOfTwo = dp[ptr1] * 2;\\n          int multipleOfThree = dp[ptr2] * 3;\\n          int multipleOfFive = dp[ptr3] * 5;\\n\\n          dp[i] = min(multipleOfTwo, min(multipleOfThree, multipleOfFive));\\n\\n          if(multipleOfTwo == dp[i]){\\n            ptr1++;\\n          }\\n          if(multipleOfThree == dp[i]){\\n            ptr2++;\\n          }\\n          if(multipleOfFive == dp[i]){\\n            ptr3++;\\n          }\\n        }\\n\\n        return dp[n - 1];\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Dynamic Programming"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int nthUglyNumber(int n) {\\n        vector<int> dp(n);\\n        dp[0] = 1;\\n        int ptr1 = 0, ptr2 = 0, ptr3 = 0;\\n\\n        for(int i = 1; i < n; i++){\\n          int multipleOfTwo = dp[ptr1] * 2;\\n          int multipleOfThree = dp[ptr2] * 3;\\n          int multipleOfFive = dp[ptr3] * 5;\\n\\n          dp[i] = min(multipleOfTwo, min(multipleOfThree, multipleOfFive));\\n\\n          if(multipleOfTwo == dp[i]){\\n            ptr1++;\\n          }\\n          if(multipleOfThree == dp[i]){\\n            ptr2++;\\n          }\\n          if(multipleOfFive == dp[i]){\\n            ptr3++;\\n          }\\n        }\\n\\n        return dp[n - 1];\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2519928,
                "title": "easy-java-solution-using-arraylist",
                "content": "**PLEASE UPVOTE IF YOU LIKED THE SOLUTION**\\n```\\nclass Solution {\\n    public int nthUglyNumber(int n) {\\n        int twoin=0;\\n        int threein=0;\\n        int fivein=0;\\n        int temp=n;\\n        List<Integer>list=new ArrayList<>();\\n        list.add(1);\\n        while(temp-- >1){\\n            int by2=list.get(twoin)*2;\\n            int by3 =list.get(threein)*3;\\n            int by5 = list.get(fivein)*5;\\n            \\n            int min = Math.min(by2,Math.min(by3,by5));\\n            list.add(min);\\n            if(min==by2)twoin++;\\n            if(min==by3)threein++;\\n            if(min==by5)fivein++;\\n            \\n        }\\n        return list.get(n-1);\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Array"
                ],
                "code": "```\\nclass Solution {\\n    public int nthUglyNumber(int n) {\\n        int twoin=0;\\n        int threein=0;\\n        int fivein=0;\\n        int temp=n;\\n        List<Integer>list=new ArrayList<>();\\n        list.add(1);\\n        while(temp-- >1){\\n            int by2=list.get(twoin)*2;\\n            int by3 =list.get(threein)*3;\\n            int by5 = list.get(fivein)*5;\\n            \\n            int min = Math.min(by2,Math.min(by3,by5));\\n            list.add(min);\\n            if(min==by2)twoin++;\\n            if(min==by3)threein++;\\n            if(min==by5)fivein++;\\n            \\n        }\\n        return list.get(n-1);\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2291425,
                "title": "priority-queue-o-n-logn-c-concise-code",
                "content": "```\\nint nthUglyNumber(int n) {\\n    priority_queue<long long, vector<long long>, greater<long long>> pq;\\n    pq.push(1);\\n    long long top;\\n    while (n--) {\\n        top=pq.top();\\n        while (!pq.empty() && pq.top()==top) {\\n            pq.pop();\\n        }\\n        pq.push(top*2);\\n        pq.push(top*3);\\n        pq.push(top*5);\\n    }\\n    return top;\\n}\\n```",
                "solutionTags": [
                    "C",
                    "Heap (Priority Queue)"
                ],
                "code": "```\\nint nthUglyNumber(int n) {\\n    priority_queue<long long, vector<long long>, greater<long long>> pq;\\n    pq.push(1);\\n    long long top;\\n    while (n--) {\\n        top=pq.top();\\n        while (!pq.empty() && pq.top()==top) {\\n            pq.pop();\\n        }\\n        pq.push(top*2);\\n        pq.push(top*3);\\n        pq.push(top*5);\\n    }\\n    return top;\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1923964,
                "title": "100-0ms-explained-simple-easy",
                "content": "```\\nThe ugly-number sequence is 1, 2, 3, 4, 5, 6, 8, 9, 10, 12, 15, \\u2026\\nbecause every number can only be divided by 2, 3, 5, one way to look at the sequence is to split the sequence to three groups as below:\\n\\n(1) 1\\xD72, 2\\xD72, 3\\xD72, 4\\xD72, 5\\xD72, \\u2026\\n(2) 1\\xD73, 2\\xD73, 3\\xD73, 4\\xD73, 5\\xD73, \\u2026\\n(3) 1\\xD75, 2\\xD75, 3\\xD75, 4\\xD75, 5\\xD75, \\u2026\\nWe can find that every subsequence is the ugly-sequence itself (1, 2, 3, 4, 5, \\u2026) multiply 2, 3, 5.\\n\\nThen we use similar merge method as merge sort, to get every ugly number from the three subsequence.\\n\\nEvery step we choose the smallest one, and move one step after,including nums with same value.\\n\\nThanks for this author about this brilliant idea. Here is my java solution\\n\\npublic class Solution {\\n    public int nthUglyNumber(int n) {\\n        int[] ugly = new int[n];\\n        ugly[0] = 1;\\n        int index2 = 0, index3 = 0, index5 = 0;\\n        int factor2 = 2, factor3 = 3, factor5 = 5;\\n        for(int i=1;i<n;i++){\\n            int min = Math.min(Math.min(factor2,factor3),factor5);\\n            ugly[i] = min;\\n            if(factor2 == min)\\n                factor2 = 2*ugly[++index2];\\n            if(factor3 == min)\\n                factor3 = 3*ugly[++index3];\\n            if(factor5 == min)\\n                factor5 = 5*ugly[++index5];\\n        }\\n        return ugly[n-1];\\n    }\\n}\\n```",
                "solutionTags": [
                    "C++",
                    "Java",
                    "Python",
                    "JavaScript",
                    "Go",
                    "PHP"
                ],
                "code": "```\\nThe ugly-number sequence is 1, 2, 3, 4, 5, 6, 8, 9, 10, 12, 15, \\u2026\\nbecause every number can only be divided by 2, 3, 5, one way to look at the sequence is to split the sequence to three groups as below:\\n\\n(1) 1\\xD72, 2\\xD72, 3\\xD72, 4\\xD72, 5\\xD72, \\u2026\\n(2) 1\\xD73, 2\\xD73, 3\\xD73, 4\\xD73, 5\\xD73, \\u2026\\n(3) 1\\xD75, 2\\xD75, 3\\xD75, 4\\xD75, 5\\xD75, \\u2026\\nWe can find that every subsequence is the ugly-sequence itself (1, 2, 3, 4, 5, \\u2026) multiply 2, 3, 5.\\n\\nThen we use similar merge method as merge sort, to get every ugly number from the three subsequence.\\n\\nEvery step we choose the smallest one, and move one step after,including nums with same value.\\n\\nThanks for this author about this brilliant idea. Here is my java solution\\n\\npublic class Solution {\\n    public int nthUglyNumber(int n) {\\n        int[] ugly = new int[n];\\n        ugly[0] = 1;\\n        int index2 = 0, index3 = 0, index5 = 0;\\n        int factor2 = 2, factor3 = 3, factor5 = 5;\\n        for(int i=1;i<n;i++){\\n            int min = Math.min(Math.min(factor2,factor3),factor5);\\n            ugly[i] = min;\\n            if(factor2 == min)\\n                factor2 = 2*ugly[++index2];\\n            if(factor3 == min)\\n                factor3 = 3*ugly[++index3];\\n            if(factor5 == min)\\n                factor5 = 5*ugly[++index5];\\n        }\\n        return ugly[n-1];\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1793311,
                "title": "c-heap",
                "content": "```\\nclass Solution {\\npublic:\\n    int nthUglyNumber(int n) {\\n        priority_queue<long> minHeap;\\n        minHeap.push(-1 * 1);\\n        int nth = 0;\\n        long val = 1;\\n        while (!minHeap.empty() && nth < n) {\\n            val = -1 * minHeap.top();\\n            minHeap.pop();\\n            while (!minHeap.empty() && val == (-1 * minHeap.top())) {\\n                minHeap.pop();\\n            }\\n            nth++;\\n            minHeap.push(-1 * val * 2);\\n            minHeap.push(-1 * val * 3);\\n            minHeap.push(-1 * val * 5);\\n        }\\n        \\n        return val;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C",
                    "Heap (Priority Queue)"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int nthUglyNumber(int n) {\\n        priority_queue<long> minHeap;\\n        minHeap.push(-1 * 1);\\n        int nth = 0;\\n        long val = 1;\\n        while (!minHeap.empty() && nth < n) {\\n            val = -1 * minHeap.top();\\n            minHeap.pop();\\n            while (!minHeap.empty() && val == (-1 * minHeap.top())) {\\n                minHeap.pop();\\n            }\\n            nth++;\\n            minHeap.push(-1 * val * 2);\\n            minHeap.push(-1 * val * 3);\\n            minHeap.push(-1 * val * 5);\\n        }\\n        \\n        return val;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1515874,
                "title": "my-c-soln-easy-and-understandable-priority-queue",
                "content": "```\\n\\tint nthUglyNumber(int n) {\\n        priority_queue<long long, vector<long long>, greater<long long> >q;\\n        q.push(1);\\n        long long prev;\\n        for(int i=0; i<n; i++) {\\n            prev = q.top();\\n            q.push(prev*2);\\n            q.push(prev*3);\\n            q.push(prev*5);\\n            while(q.top()==prev)\\n                q.pop();\\n        }\\n        return prev;\\n    }\\n```",
                "solutionTags": [],
                "code": "```\\n\\tint nthUglyNumber(int n) {\\n        priority_queue<long long, vector<long long>, greater<long long> >q;\\n        q.push(1);\\n        long long prev;\\n        for(int i=0; i<n; i++) {\\n            prev = q.top();\\n            q.push(prev*2);\\n            q.push(prev*3);\\n            q.push(prev*5);\\n            while(q.top()==prev)\\n                q.pop();\\n        }\\n        return prev;\\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1325060,
                "title": "easy-generating-a-least-number-greater-than-previous-cpp-dp",
                "content": "```\\n    int nthUglyNumber(int n) {\\n        if(n==1){\\n            return 1;\\n        }\\n        if(n==2){\\n            return 2;\\n        }\\n        vector<int> dp(n+1);\\n        map<int,int> ma;\\n        for(int i=0;i<=n;i++){\\n            if(i<=5){\\n                dp[i]=i;\\n            }\\n            else{\\n                int m=INT_MAX;\\n                int k=3;\\n                int p[3]={2,3,5};\\n                while(k--){\\n                    int j=ma[dp[i-1]/5];\\n\\t\\t\\t\\t\\t//just check the numbers from dp[i-1]/5 because less than that the number wont be greater than dp[i-1]\\n\\t\\t\\t\\t\\tint num=0;\\n                    //cout<<dp[i-1]<<\" \";\\n                    while(num<=dp[i-1]&&j<n){\\n                        num=dp[j]*p[k];\\n                        //cout<<num<<\" \";\\n                        j++;\\n                    }\\n              \\n                    m=min(num,m);\\n                }\\n                dp[i]=m;\\n            }\\n            ma[dp[i]]=i;\\n        }\\n        return dp[n];\\n    }\\n};",
                "solutionTags": [],
                "code": "```\\n    int nthUglyNumber(int n) {\\n        if(n==1){\\n            return 1;\\n        }\\n        if(n==2){\\n            return 2;\\n        }\\n        vector<int> dp(n+1);\\n        map<int,int> ma;\\n        for(int i=0;i<=n;i++){\\n            if(i<=5){\\n                dp[i]=i;\\n            }\\n            else{\\n                int m=INT_MAX;\\n                int k=3;\\n                int p[3]={2,3,5};\\n                while(k--){\\n                    int j=ma[dp[i-1]/5];\\n\\t\\t\\t\\t\\t//just check the numbers from dp[i-1]/5 because less than that the number wont be greater than dp[i-1]\\n\\t\\t\\t\\t\\tint num=0;\\n                    //cout<<dp[i-1]<<\" \";\\n                    while(num<=dp[i-1]&&j<n){\\n                        num=dp[j]*p[k];\\n                        //cout<<num<<\" \";\\n                        j++;\\n                    }\\n              \\n                    m=min(num,m);\\n                }\\n                dp[i]=m;\\n            }\\n            ma[dp[i]]=i;\\n        }\\n        return dp[n];\\n    }\\n};",
                "codeTag": "C++"
            },
            {
                "id": 1143313,
                "title": "java-o-n-time-and-space",
                "content": "Slightly modified version of: https://leetcode.com/problems/ugly-number-ii/discuss/69385/Java-Easy-Understand-O(n)-Solution\\n\\n```\\npublic int nthUglyNumber(int n) {\\n\\tif (n <= 0)\\n\\t\\treturn 0;\\n\\tvar twoPointer = 0;\\n\\tvar threePointer = 0;\\n\\tvar fivePointer = 0;\\n\\n\\tvar uglies = new ArrayList<Integer>();\\n\\tuglies.add(1);\\n\\n\\twhile (uglies.size() < n) {\\n\\t\\tvar nextUgly = Math.min(uglies.get(twoPointer) * 2, Math.min(uglies.get(threePointer) * 3, uglies.get(fivePointer) * 5));\\n\\t\\tuglies.add(nextUgly);\\n\\t\\tif (uglies.get(twoPointer) * 2 == nextUgly)\\n\\t\\t\\ttwoPointer++;\\n\\t\\tif (uglies.get(threePointer) * 3 == nextUgly)\\n\\t\\t\\tthreePointer++;\\n\\t\\tif (uglies.get(fivePointer) * 5 == nextUgly)\\n\\t\\t\\tfivePointer++;\\n\\t\\tif (uglies.size() == n)\\n\\t\\t\\treturn nextUgly;\\n\\t}\\n\\treturn 1;\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\npublic int nthUglyNumber(int n) {\\n\\tif (n <= 0)\\n\\t\\treturn 0;\\n\\tvar twoPointer = 0;\\n\\tvar threePointer = 0;\\n\\tvar fivePointer = 0;\\n\\n\\tvar uglies = new ArrayList<Integer>();\\n\\tuglies.add(1);\\n\\n\\twhile (uglies.size() < n) {\\n\\t\\tvar nextUgly = Math.min(uglies.get(twoPointer) * 2, Math.min(uglies.get(threePointer) * 3, uglies.get(fivePointer) * 5));\\n\\t\\tuglies.add(nextUgly);\\n\\t\\tif (uglies.get(twoPointer) * 2 == nextUgly)\\n\\t\\t\\ttwoPointer++;\\n\\t\\tif (uglies.get(threePointer) * 3 == nextUgly)\\n\\t\\t\\tthreePointer++;\\n\\t\\tif (uglies.get(fivePointer) * 5 == nextUgly)\\n\\t\\t\\tfivePointer++;\\n\\t\\tif (uglies.size() == n)\\n\\t\\t\\treturn nextUgly;\\n\\t}\\n\\treturn 1;\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1132960,
                "title": "best-code-using-heap-c",
                "content": "class Solution {\\npublic:\\n    int nthUglyNumber(int n) {\\n        priority_queue<long long,vector<long long>,greater<long long>>pq;\\n      pq.push(1);\\n        long long x;\\n         while(n--){\\n             if(pq.top()==x){\\n                 pq.pop();\\n                 n++;\\n                 continue;\\n             }\\n            x=pq.top();\\n             pq.push(2*x);\\n             pq.push(3*x);\\n             pq.push(5*x);\\n             pq.pop();\\n         }\\n        return x;\\n    }\\n};",
                "solutionTags": [],
                "code": "class Solution {\\npublic:\\n    int nthUglyNumber(int n) {\\n        priority_queue<long long,vector<long long>,greater<long long>>pq;\\n      pq.push(1);\\n        long long x;\\n         while(n--){\\n             if(pq.top()==x){\\n                 pq.pop();\\n                 n++;\\n                 continue;\\n             }",
                "codeTag": "Java"
            },
            {
                "id": 336976,
                "title": "c-the-fastest-solution-for-this-problem",
                "content": "```\\n#define min(x,y) (x < y ? x : y)\\nint nthUglyNumber(int n) {\\n  static int arr[1691] = {[0]= 1},\\n  i  = 1, i2 = 0, i3 = 0, i5 = 0,\\n  n2 = 2, n3 = 3, n5 = 5;\\n  for (; i < n; i++) {\\n    arr[i] = min(min(n2, n3), n5);\\n    if (arr[i] == n2) n2 = 2 * arr[++i2];\\n    if (arr[i] == n3) n3 = 3 * arr[++i3];\\n    if (arr[i] == n5) n5 = 5 * arr[++i5];\\n  }\\n  return arr[n-1];\\n}\\n```\\n[transmission from @dikshek](https://leetcode.com/problems/ugly-number-ii/discuss/213545/Runtime%3A-0-ms-faster-than-100.00-of-C-online-submissions-for-Ugly-Number-II.)\\nreally really efficient\\nupvote him not me",
                "solutionTags": [],
                "code": "```\\n#define min(x,y) (x < y ? x : y)\\nint nthUglyNumber(int n) {\\n  static int arr[1691] = {[0]= 1},\\n  i  = 1, i2 = 0, i3 = 0, i5 = 0,\\n  n2 = 2, n3 = 3, n5 = 5;\\n  for (; i < n; i++) {\\n    arr[i] = min(min(n2, n3), n5);\\n    if (arr[i] == n2) n2 = 2 * arr[++i2];\\n    if (arr[i] == n3) n3 = 3 * arr[++i3];\\n    if (arr[i] == n5) n5 = 5 * arr[++i5];\\n  }\\n  return arr[n-1];\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 288004,
                "title": "java-simple-code-general-approach",
                "content": "As definition, ugly numbers can be written as `A[i] = 2^x * 3^y * 5^z`. Our objective is to find `A[n-1]`.\\n\\nLet\\'s say, the normal thought would be if the current `A[k]` can be calculated based on the previous `A[m]`, we can solve this problem. Unfortunately, there doesn\\'t exist any formular like this for this problem.\\n\\nAnother approach is if we know `A[k]`, and from `A[k]` we can generate `possible candidates` (not always `A[k+1]`, but `A[m]`, `A[n]`, ... in which `m, n > k`). Since we know possible candidates might be the future result, we put all these `candidates` into a bag or a `funnel` for later use. Under a specific rule, if the funnel can give us the next element, we can solve the problem.\\n\\n![image](https://assets.leetcode.com/users/chipbk10/image_1557216432.png)\\n\\nFor this problem, `A[k+1]` must be the smallest `possible candidate` in the funnel. Now, the question is what `possible candidates` can be generated from `A[k]`? Because the `possible candidates` are the numbers that are bigger than `A[k]`, so there are ton of them.\\nE.g., `A[k] = (x,y,z) = 2^x * 3^y * 5^z`, we can choose a possible candidate like this `A[m] = (x+10, y + 22, z + 35)`\\n\\nA correct question is what is **the minimum set** of `possible candidates` can be generated from `A[k]`? The answer is `3`\\nfrom `(x,y,z)`, we can generate **`(x+1, y, z)`, `(x, y+1, z)`, `(x, y, z+1)`**\\nWhy? because from these 3 candidates, we can generate all other `future possible candidates`.\\n\\nBut why not `(x-1, y+1, z)`, this number still bigger than `A[k]` ? Correct, this number `= 3 / 2 * A[k]` is bigger than `A[k]`, but this number has already been put into the funnel, because this number has been generated from `A[L] = (x-1, y, z)` where `L < k`.\\n\\nOk, back to the `funnel`. The `funnel` maintains the smallest element, so the first thought is we might use `PriorityQueue` to represent the `funnel`. The code will be:\\n\\n````\\nPriorityQueue<Long> queue = new PriorityQueue<>();\\nqueue.add(1);\\n\\nfor (int i = 1; i < n; i++) {\\n\\tlong num = queue.poll();\\n\\twhile (!queue.isEmpty() && queue.peek() == num) queue.poll();\\n\\tqueue.add(num*2); // (x+1,y,z)\\n\\tqueue.add(num*3); // (x, y+1, z)\\n\\tqueue.add(num*5); // (x, y, z+1)\\n}\\nreturn queue.peek().intValue();\\n````\\nNote: we use `long` instead of `int` to avoid the overflow case.\\n\\nActually, the queue can be divided into 3 **sequences** (either we increase `x`, or increase `y`, or increase `z`). We can store 3 these sequences into 3 arrays, and tracking by the index.\\n\\n`X = 2, 4, 6, 8, 10, 12, ...`\\n....................`|`\\n...................`iX`\\n\\n`Y = 3, 6, 9, 12, 15, 18, ...`\\n..............`|`\\n.............`iY`\\n\\n`Z = 5, 10, 15, 20, 25, 30, ...`\\n........`|`\\n.......`iZ`\\n\\n````\\nlong[] res = new long[n];\\nList<Long> X = new ArrayList<>(), Y = new ArrayList<>(), Z = new ArrayList<>(); \\nint iX = 0, iY = 0, iZ = 0;\\nres[0] = 1; X.add(2); Y.add(3); Z.add(5);\\nfor (int i = 1; i < n; i++) {\\n\\tlong min = Math.min(Math.min(X.get(iX), Y.get(iY)), Z.get(iZ));\\n\\tres[i] = min;\\n\\tif ( min == X.get(iX) ) iX++;\\n\\tif ( min == Y.get(iY) ) iY++;\\n\\tif ( min == Z.get(iZ) ) iZ++;\\n\\tX.add(min * 2);\\n\\tY.add(min * 3);\\n\\tZ.add(min * 5);\\n}\\nreturn (int)res[n-1];\\n````\\n\\nStoring in 3 arrays is still redundant. Actually, we just use 3 variables to store the current `X`, `Y`, `Z`. The next value will be calculated as follow:\\n\\n`next X = res[iX+1] * 2`\\n`next Y = res[iY+1] * 3`\\n`next Z = res[iZ+1] * 5`\\n\\n````\\nlong res[] = new long[n], X = 2, Y = 3, Z = 5;\\nres[0] = 1;\\nint iX = 0, iY = 0, iZ = 0;\\nfor (int i = 1; i < n; i++) {\\n\\tlong min = Math.min(Math.min(X,Y), Z);\\n\\tres[i] = min;\\n\\tif (min == X) X = res[++iX] * 2;\\n\\tif (min == Y) Y = res[++iY] * 3;\\n\\tif (min == Z) Z = res[++iZ] * 5;\\t\\n}\\nreturn (int)res[n-1];\\n````\\n\\nBonus: with this way, we can solve [Super Ugly Number](https://leetcode.com/problems/super-ugly-number/):\\n\\n````\\n\\tpublic int nthUglyNumber(int n) {\\n        return nthSuperUglyNumber(n, new int[] {2,3,5});\\n    }\\n\\n    public int nthSuperUglyNumber(int n, int[] primes) {\\n        int res[] = new int[n], m = primes.length, ins[] = new int[m], vs[] = new int[m];\\n        res[0] = 1;\\n        for (int i = 0; i < m; i++) vs[i] = primes[i];\\n        for (int i = 1; i < n; i++) {\\n            int min = Integer.MAX_VALUE;\\n            for (int j = 0; j < m; j++) min = Math.min(min, vs[j]);\\n            res[i] = min;\\n\\n            for (int j = 0; j < m; j++) {\\n                if (vs[j] == min) vs[j] = primes[j] * res[++ins[j]];\\n            }\\n        }\\n        return res[n-1];\\n    }\\n````\\n\\n\\n\\n\\n\\t\\t\\n\\n",
                "solutionTags": [],
                "code": "````\\nPriorityQueue<Long> queue = new PriorityQueue<>();\\nqueue.add(1);\\n\\nfor (int i = 1; i < n; i++) {\\n\\tlong num = queue.poll();\\n\\twhile (!queue.isEmpty() && queue.peek() == num) queue.poll();\\n\\tqueue.add(num*2); // (x+1,y,z)\\n\\tqueue.add(num*3); // (x, y+1, z)\\n\\tqueue.add(num*5); // (x, y, z+1)\\n}\\nreturn queue.peek().intValue();\\n```\n````\\nlong[] res = new long[n];\\nList<Long> X = new ArrayList<>(), Y = new ArrayList<>(), Z = new ArrayList<>(); \\nint iX = 0, iY = 0, iZ = 0;\\nres[0] = 1; X.add(2); Y.add(3); Z.add(5);\\nfor (int i = 1; i < n; i++) {\\n\\tlong min = Math.min(Math.min(X.get(iX), Y.get(iY)), Z.get(iZ));\\n\\tres[i] = min;\\n\\tif ( min == X.get(iX) ) iX++;\\n\\tif ( min == Y.get(iY) ) iY++;\\n\\tif ( min == Z.get(iZ) ) iZ++;\\n\\tX.add(min * 2);\\n\\tY.add(min * 3);\\n\\tZ.add(min * 5);\\n}\\nreturn (int)res[n-1];\\n```\n````\\nlong res[] = new long[n], X = 2, Y = 3, Z = 5;\\nres[0] = 1;\\nint iX = 0, iY = 0, iZ = 0;\\nfor (int i = 1; i < n; i++) {\\n\\tlong min = Math.min(Math.min(X,Y), Z);\\n\\tres[i] = min;\\n\\tif (min == X) X = res[++iX] * 2;\\n\\tif (min == Y) Y = res[++iY] * 3;\\n\\tif (min == Z) Z = res[++iZ] * 5;\\t\\n}\\nreturn (int)res[n-1];\\n```\n````\\n\\tpublic int nthUglyNumber(int n) {\\n        return nthSuperUglyNumber(n, new int[] {2,3,5});\\n    }\\n\\n    public int nthSuperUglyNumber(int n, int[] primes) {\\n        int res[] = new int[n], m = primes.length, ins[] = new int[m], vs[] = new int[m];\\n        res[0] = 1;\\n        for (int i = 0; i < m; i++) vs[i] = primes[i];\\n        for (int i = 1; i < n; i++) {\\n            int min = Integer.MAX_VALUE;\\n            for (int j = 0; j < m; j++) min = Math.min(min, vs[j]);\\n            res[i] = min;\\n\\n            for (int j = 0; j < m; j++) {\\n                if (vs[j] == min) vs[j] = primes[j] * res[++ins[j]];\\n            }\\n        }\\n        return res[n-1];\\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 69420,
                "title": "java-solution-using-a-linked-list",
                "content": "The idea is similar to [this popular solution][1] or [this][2]. The only difference here is that a linked list is used instead of array. For this problem a linked list may be more space saving as nodes which all 3 pointers have left will be released from memory.\\n\\n    public class Solution {\\n    \\n        public int nthUglyNumber(int n) {\\n            ListNode current = new ListNode(1);\\n            ListNode n2 = current;\\n            ListNode n3 = current;\\n            ListNode n5 = current;\\n    \\n            for (int i = 2; i <= n; i++) {\\n                int min = Math.min(n2.val * 2, Math.min(n3.val * 3, n5.val * 5));\\n                current.next = new ListNode(min);\\n                current = current.next;\\n                n2 = n2.val * 2 == min ? n2.next : n2;\\n                n3 = n3.val * 3 == min ? n3.next : n3;\\n                n5 = n5.val * 5 == min ? n5.next : n5;\\n            }\\n    \\n            return current.val;\\n        }\\n    \\n        private class ListNode {\\n            private int val;\\n            private ListNode next;\\n    \\n            private ListNode(int value) {\\n                val = value;\\n            }\\n        }\\n    }\\n\\n\\n  [1]: https://leetcode.com/discuss/52905/my-16ms-c-dp-solution-with-short-explanation\\n  [2]: https://leetcode.com/discuss/52716/o-n-java-solution",
                "solutionTags": [
                    "Java",
                    "Linked List"
                ],
                "code": "class Solution {\\n    \\n        public int nthUglyNumber(int n) {\\n            ListNode current = new ListNode(1);\\n            ListNode n2 = current;\\n            ListNode n3 = current;\\n            ListNode n5 = current;\\n    \\n            for (int i = 2; i <= n; i++) {\\n                int min = Math.min(n2.val * 2, Math.min(n3.val * 3, n5.val * 5));\\n                current.next = new ListNode(min);\\n                current = current.next;\\n                n2 = n2.val * 2 == min ? n2.next : n2;\\n                n3 = n3.val * 3 == min ? n3.next : n3;\\n                n5 = n5.val * 5 == min ? n5.next : n5;\\n            }",
                "codeTag": "Java"
            },
            {
                "id": 69414,
                "title": "share-my-c-solution-easy-to-understand",
                "content": "    class Solution {\\n    public:\\n        int nthUglyNumber(int n) {\\n            if (n <= 0)\\n                return 0;\\n                \\n            int idx2 = 0, idx3 = 0, idx5 = 0;\\n            int candidate1 = 0, candidate2 = 0, candidate3 = 0;\\n            int i = 0,  min = 0;\\n            vector<int> uglyNumbers(n, 0);\\n            \\n            uglyNumbers[0] = 1;\\n            \\n            for (i = 1; i < n; ++i)\\n            {\\n                candidate1 = uglyNumbers[idx2] * 2;\\n                candidate2 = uglyNumbers[idx3] * 3;\\n                candidate3 = uglyNumbers[idx5] * 5;\\n                \\n                min = candidate1;\\n                if (min > candidate2)\\n                    min = candidate2;\\n                if (min > candidate3)\\n                    min = candidate3;\\n                    \\n                uglyNumbers[i] = min;\\n                if (min == candidate1)\\n                    ++idx2;\\n                    \\n                if (min == candidate2)\\n                    ++idx3;\\n                    \\n                if (min == candidate3)\\n                    ++idx5;\\n            }\\n            \\n            return uglyNumbers[n-1];\\n        }\\n    };",
                "solutionTags": [
                    "C++"
                ],
                "code": "class Solution {\\n    public:\\n        int nthUglyNumber(int n) {\\n            if (n <= 0)\\n                return 0;\\n                \\n            int idx2 = 0, idx3 = 0, idx5 = 0;\\n            int candidate1 = 0, candidate2 = 0, candidate3 = 0;\\n            int i = 0,  min = 0;\\n            vector<int> uglyNumbers(n, 0);\\n            \\n            uglyNumbers[0] = 1;\\n            \\n            for (i = 1; i < n; ++i)\\n            {\\n                candidate1 = uglyNumbers[idx2] * 2;\\n                candidate2 = uglyNumbers[idx3] * 3;\\n                candidate3 = uglyNumbers[idx5] * 5;\\n                \\n                min = candidate1;\\n                if (min > candidate2)\\n                    min = candidate2;\\n                if (min > candidate3)\\n                    min = candidate3;\\n                    \\n                uglyNumbers[i] = min;\\n                if (min == candidate1)\\n                    ++idx2;\\n                    \\n                if (min == candidate2)\\n                    ++idx3;\\n                    \\n                if (min == candidate3)\\n                    ++idx5;\\n            }",
                "codeTag": "Java"
            },
            {
                "id": 69447,
                "title": "c-code-implemented-as-hinted",
                "content": "    class Solution {\\n    private:\\n        int minThree(int a, int b, int c)\\n        {\\n            int value = a;\\n            if(b < value)\\n                value = b;\\n            if(c < value)\\n                value = c;\\n            return value;\\n        }\\n        \\n    public:\\n        int nthUglyNumber(int n) {\\n            queue<int> L1, L2, L3;\\n            L1.push(1);\\n            L2.push(1);\\n            L3.push(1);\\n            \\n            int value;\\n            int i;\\n            for(i=0; i<n; i++)\\n            {\\n                value = minThree(L1.front(), L2.front(), L3.front());\\n                if(value == L1.front()) L1.pop();\\n                if(value == L2.front()) L2.pop();\\n                if(value == L3.front()) L3.pop();\\n                \\n                L1.push(value*2);\\n                L2.push(value*3);\\n                L3.push(value*5);\\n            }\\n            return value;\\n        }\\n    };",
                "solutionTags": [
                    "C++"
                ],
                "code": "class Solution {\\n    private:\\n        int minThree(int a, int b, int c)\\n        {\\n            int value = a;\\n            if(b < value)\\n                value = b;\\n            if(c < value)\\n                value = c;\\n            return value;\\n        }",
                "codeTag": "Java"
            },
            {
                "id": 69425,
                "title": "c-solution-in-o-n-time-using-3-queues",
                "content": "\\nclass Solution {\\npublic:\\n    int nthUglyNumber(int n) {\\n        \\n        if(n == 1)\\n            return 1;\\n        \\n        queue <unsigned int> q2;\\n        queue <unsigned int> q3;\\n        queue <unsigned int> q5;\\n        \\n        int count = 1;\\n        int next_ugly,nth_ugly;\\n        \\n        q2.push(2);\\n        q3.push(3);\\n        q5.push(5);\\n        \\n        while(count < n)\\n        {\\n            next_ugly = std::min(q2.front(),min(q3.front(),q5.front()));\\n            if(next_ugly == q2.front())\\n            {\\n                int val = q2.front();\\n                q2.push(val*2);\\n                q3.push(val*3);\\n                q5.push(val*5);\\n                q2.pop();\\n            }\\n            else if(next_ugly == q3.front())\\n            {\\n                int val = q3.front();\\n                q3.push(val*3);\\n                q5.push(val*5);\\n                q3.pop();\\n            }\\n            else\\n            {\\n                int val = q5.front();\\n                q5.push(val*5);\\n                q5.pop();\\n            }\\n            count++;\\n            if(count == n)\\n                nth_ugly = next_ugly;\\n        }\\n        return nth_ugly;\\n    }\\n};",
                "solutionTags": [],
                "code": "class Solution {\\npublic:\\n    int nthUglyNumber(int n) {\\n        \\n        if(n == 1)\\n            return 1;\\n        \\n        queue <unsigned int> q2;\\n        queue <unsigned int> q3;\\n        queue <unsigned int> q5;\\n        \\n        int count = 1;\\n        int next_ugly,nth_ugly;\\n        \\n        q2.push(2);\\n        q3.push(3);\\n        q5.push(5);\\n        \\n        while(count < n)\\n        {\\n            next_ugly = std::min(q2.front(),min(q3.front(),q5.front()));\\n            if(next_ugly == q2.front())\\n            {\\n                int val = q2.front();\\n                q2.push(val*2);\\n                q3.push(val*3);\\n                q5.push(val*5);\\n                q2.pop();\\n            }",
                "codeTag": "Java"
            },
            {
                "id": 69464,
                "title": "using-three-queues-java-solution",
                "content": "    public int nthUglyNumber(int n) {\\n        Queue<Long> q2 = new LinkedList<Long>();\\n        Queue<Long> q3 = new LinkedList<Long>();\\n        Queue<Long> q5 = new LinkedList<Long>();\\n        Long res = 1L;\\n        q2.add(2L);q3.add(3L);q5.add(5L);\\n        while(n-- > 1){\\n            if(q2.peek() < q3.peek() && q2.peek() < q5.peek()){\\n                res = q2.poll();\\n                q2.add(res*2);q3.add(res*3);q5.add(res*5);\\n            }else if(q3.peek() < q2.peek() && q3.peek() < q5.peek()){\\n                res = q3.poll();\\n                q3.add(res*3);q5.add(res*5);\\n            }else {\\n                res = q5.poll();\\n                q5.add(res*5);\\n            }\\n        }\\n        return res.intValue();\\n    }",
                "solutionTags": [],
                "code": "    public int nthUglyNumber(int n) {\\n        Queue<Long> q2 = new LinkedList<Long>();\\n        Queue<Long> q3 = new LinkedList<Long>();\\n        Queue<Long> q5 = new LinkedList<Long>();\\n        Long res = 1L;\\n        q2.add(2L);q3.add(3L);q5.add(5L);\\n        while(n-- > 1){\\n            if(q2.peek() < q3.peek() && q2.peek() < q5.peek()){\\n                res = q2.poll();\\n                q2.add(res*2);q3.add(res*3);q5.add(res*5);\\n            }else if(q3.peek() < q2.peek() && q3.peek() < q5.peek()){\\n                res = q3.poll();\\n                q3.add(res*3);q5.add(res*5);\\n            }else {\\n                res = q5.poll();\\n                q5.add(res*5);\\n            }\\n        }\\n        return res.intValue();\\n    }",
                "codeTag": "Unknown"
            },
            {
                "id": 69489,
                "title": "java-solution-with-three-queues",
                "content": "I saw this on CC150. The idea is to use three queues to store three multiples of each ugly number. Have to use long instead of int to avoid overflow.\\n  \\n\\n    public class Solution {\\n        public int nthUglyNumber(int n) {\\n            if (n < 1) return 0;\\n            Queue<Long> queue2 = new LinkedList<>();\\n            Queue<Long> queue3 = new LinkedList<>();\\n            Queue<Long> queue5 = new LinkedList<>();\\n            queue2.add(1l);\\n            long val = 0;\\n            for (int i = 0; i < n; i++) {\\n                long v2 = queue2.isEmpty() ? Long.MAX_VALUE : queue2.peek();\\n                long v3 = queue3.isEmpty() ? Long.MAX_VALUE : queue3.peek();\\n                long v5 = queue5.isEmpty() ? Long.MAX_VALUE : queue5.peek();\\n                val = Math.min(v2, Math.min(v3, v5));\\n                if (val == v2) {\\n                    queue2.poll();\\n                    queue2.add(val*2);\\n                    queue3.add(val*3);\\n                }\\n                else if (val == v3) {\\n                    queue3.poll();\\n                    queue3.add(val*3);\\n                }\\n                else\\n                    queue5.poll();\\n                queue5.add(val*5);\\n            }\\n            return (int)val;\\n        }\\n    }",
                "solutionTags": [
                    "Java"
                ],
                "code": "class Solution {\\n        public int nthUglyNumber(int n) {\\n            if (n < 1) return 0;\\n            Queue<Long> queue2 = new LinkedList<>();\\n            Queue<Long> queue3 = new LinkedList<>();\\n            Queue<Long> queue5 = new LinkedList<>();\\n            queue2.add(1l);\\n            long val = 0;\\n            for (int i = 0; i < n; i++) {\\n                long v2 = queue2.isEmpty() ? Long.MAX_VALUE : queue2.peek();\\n                long v3 = queue3.isEmpty() ? Long.MAX_VALUE : queue3.peek();\\n                long v5 = queue5.isEmpty() ? Long.MAX_VALUE : queue5.peek();\\n                val = Math.min(v2, Math.min(v3, v5));\\n                if (val == v2) {\\n                    queue2.poll();\\n                    queue2.add(val*2);\\n                    queue3.add(val*3);\\n                }",
                "codeTag": "Java"
            },
            {
                "id": 2826398,
                "title": "c-solution",
                "content": "# Code\\n```\\nclass Solution {\\npublic:\\n    int nthUglyNumber(int n) {\\n        set<long long> st;\\n        st.insert(1);\\n        long long ans;\\n        for(int i=1; i<=n; i++) {\\n            ans = *st.begin();\\n            st.erase(ans);\\n            st.insert(ans * 2);\\n            st.insert(ans * 3);\\n            st.insert(ans * 5);\\n        }\\n        return int(ans);\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int nthUglyNumber(int n) {\\n        set<long long> st;\\n        st.insert(1);\\n        long long ans;\\n        for(int i=1; i<=n; i++) {\\n            ans = *st.begin();\\n            st.erase(ans);\\n            st.insert(ans * 2);\\n            st.insert(ans * 3);\\n            st.insert(ans * 5);\\n        }\\n        return int(ans);\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2250600,
                "title": "python3-ugly-number-ii-easy-to-understand-clear-code",
                "content": "\\n    def nthUglyNumber(self, k: int) -> int:\\n        res=[1]\\n        i2=i3=i5=0\\n        while(len(res)<k):\\n            m2=2*res[i2]\\n            m3=3*res[i3]\\n            m5=5*res[i5]\\n            minimum=min(m2,m3,m5)\\n            res.append(minimum)\\n            if(minimum==m2):\\n                i2+=1\\n            if(minimum==m3):\\n                i3+=1\\n            if(minimum==m5):\\n                i5+=1\\n        return res[k-1]\\n",
                "solutionTags": [
                    "Python"
                ],
                "code": "\\n    def nthUglyNumber(self, k: int) -> int:\\n        res=[1]\\n        i2=i3=i5=0\\n        while(len(res)<k):\\n            m2=2*res[i2]\\n            m3=3*res[i3]\\n            m5=5*res[i5]\\n            minimum=min(m2,m3,m5)\\n            res.append(minimum)\\n            if(minimum==m2):\\n                i2+=1\\n            if(minimum==m3):\\n                i3+=1\\n            if(minimum==m5):\\n                i5+=1\\n        return res[k-1]\\n",
                "codeTag": "Python3"
            },
            {
                "id": 2241946,
                "title": "c-solution-with-10ms-runtime-dynamic-programming",
                "content": "Stats for this problem:\\nRuntime: 10 ms, faster than 79.02% of C++ online submissions for Ugly Number II.\\nMemory Usage: 5.9 MB, less than 89.94% of C++ online submissions for Ugly Number II.\\n\\n```\\nclass Solution {\\npublic: \\n    int nthUglyNumber(int n) {\\n        int dp[n];\\n        int a2 = 0, a3 = 0, a5 = 0;\\n        dp[0] = 1;\\n        for(int i = 1; i < n; i++) {\\n            dp[i] = min(dp[a2] * 2, min(dp[a3] * 3, dp[a5] * 5));\\n            if(dp[i] == dp[a2] * 2) a2++;\\n            if(dp[i] == dp[a3] * 3) a3++;\\n            if(dp[i] == dp[a5] * 5) a5++;\\n        }\\n        return dp[n - 1];\\n    }\\n};\\n```",
                "solutionTags": [
                    "C",
                    "Dynamic Programming"
                ],
                "code": "```\\nclass Solution {\\npublic: \\n    int nthUglyNumber(int n) {\\n        int dp[n];\\n        int a2 = 0, a3 = 0, a5 = 0;\\n        dp[0] = 1;\\n        for(int i = 1; i < n; i++) {\\n            dp[i] = min(dp[a2] * 2, min(dp[a3] * 3, dp[a5] * 5));\\n            if(dp[i] == dp[a2] * 2) a2++;\\n            if(dp[i] == dp[a3] * 3) a3++;\\n            if(dp[i] == dp[a5] * 5) a5++;\\n        }\\n        return dp[n - 1];\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2161156,
                "title": "c-ugly-number-2-dp",
                "content": "class Solution {\\npublic:    \\n    int nthUglyNumber(int n) {\\n        \\n        // As Ugly Numbers are mulitples of 2,3,5\\n        // So we\\'ll start with 2,3,5 and compute multiples of it\\n        \\n        vector<int>dp(n);\\n        dp[0] = 1;       // 1 is an ugly number\\n        \\n        int p2 = 0;   // pointer for 2\\n        int p3 = 0;   // for 3\\n        int p5 = 0;   // for 5\\n        \\n        for(int i=1; i<n; i++){\\n            \\n            int multipleof2 = dp[p2]*2;\\n            int multipleof3 = dp[p3]*3;\\n            int multipleof5 = dp[p5]*5;\\n            \\n            int mi = min(multipleof2, min(multipleof3, multipleof5));\\n            dp[i] = mi;\\n            \\n            if(dp[i] == multipleof2) p2++;     // not using else if to eliminate duplicate values\\n            if(dp[i] == multipleof3) p3++;     // eg. 6 is multiple of both 2,3 \\n            if(dp[i] == multipleof5) p5++;     // so pointer will be increased for both 2 and 3 \\n        }\\n        \\n        return dp[n-1];\\n    }\\n};",
                "solutionTags": [
                    "C",
                    "Dynamic Programming"
                ],
                "code": "class Solution {\\npublic:    \\n    int nthUglyNumber(int n) {\\n        \\n        // As Ugly Numbers are mulitples of 2,3,5\\n        // So we\\'ll start with 2,3,5 and compute multiples of it\\n        \\n        vector<int>dp(n);\\n        dp[0] = 1;       // 1 is an ugly number\\n        \\n        int p2 = 0;   // pointer for 2\\n        int p3 = 0;   // for 3\\n        int p5 = 0;   // for 5\\n        \\n        for(int i=1; i<n; i++){\\n            \\n            int multipleof2 = dp[p2]*2;\\n            int multipleof3 = dp[p3]*3;\\n            int multipleof5 = dp[p5]*5;\\n            \\n            int mi = min(multipleof2, min(multipleof3, multipleof5));\\n            dp[i] = mi;\\n            \\n            if(dp[i] == multipleof2) p2++;     // not using else if to eliminate duplicate values\\n            if(dp[i] == multipleof3) p3++;     // eg. 6 is multiple of both 2,3 \\n            if(dp[i] == multipleof5) p5++;     // so pointer will be increased for both 2 and 3 \\n        }",
                "codeTag": "Java"
            },
            {
                "id": 2104823,
                "title": "c-easy-solution-with-explaination",
                "content": "```\\nExample. Let\\'s say we have the first 3 ugly numbers 1, 2, 3. What would be the next number?\\nGiven the definition, the next number has to be the the smallest number among 2*(1,2,3), 3*\\n(1,2,3), 5*(1,2,3). Obviously, the smallest number is 2 * 1 = 2. But wait, 2 is already in there. So\\nprecisely speaking, the next number has to be the the smallest number among all the existing\\nnumbers multiplied by 2, 3,5 that isn\\'t in the list already. Now, we can traverse all numbers \\nand maintain a hashset if we want, but it would become O(N^2). Good news is that we can \\nsolve this in a DP-like approach. First, we assume there is only one number in the list, which is \\n1. The next number is Min(2 * 1, 3 * 1, 5 * 1)=2 and it is not in the list. Because we have \\n2. already considered 2*1 (we move the pointer to its next position, which is 2), now we only \\n3. need to consider 2 * 2, 3 * 1, 5 * 1 in the next iteration. This way, we don\\'t have to worry \\n4. about finding a number that is already in the list.\\n\\nclass Solution {\\npublic:\\n    int nthUglyNumber(int n) {\\n        if(n <= 0) return false; // get rid of corner cases \\n        if(n == 1) return true; // base case\\n        int t2 = 0, t3 = 0, t5 = 0; //pointers for 2, 3, 5\\n        vector<int> k(n);\\n        k[0] = 1;\\n        for(int i  = 1; i < n ; i ++)\\n        {\\n            k[i] = min(k[t2]*2,min(k[t3]*3,k[t5]*5));\\n            if(k[i] == k[t2]*2) t2++; \\n            if(k[i] == k[t3]*3) t3++;\\n            if(k[i] == k[t5]*5) t5++;\\n        }\\n        return k[n-1];\\n    }\\n};\\n```",
                "solutionTags": [
                    "C"
                ],
                "code": "```\\nExample. Let\\'s say we have the first 3 ugly numbers 1, 2, 3. What would be the next number?\\nGiven the definition, the next number has to be the the smallest number among 2*(1,2,3), 3*\\n(1,2,3), 5*(1,2,3). Obviously, the smallest number is 2 * 1 = 2. But wait, 2 is already in there. So\\nprecisely speaking, the next number has to be the the smallest number among all the existing\\nnumbers multiplied by 2, 3,5 that isn\\'t in the list already. Now, we can traverse all numbers \\nand maintain a hashset if we want, but it would become O(N^2). Good news is that we can \\nsolve this in a DP-like approach. First, we assume there is only one number in the list, which is \\n1. The next number is Min(2 * 1, 3 * 1, 5 * 1)=2 and it is not in the list. Because we have \\n2. already considered 2*1 (we move the pointer to its next position, which is 2), now we only \\n3. need to consider 2 * 2, 3 * 1, 5 * 1 in the next iteration. This way, we don\\'t have to worry \\n4. about finding a number that is already in the list.\\n\\nclass Solution {\\npublic:\\n    int nthUglyNumber(int n) {\\n        if(n <= 0) return false; // get rid of corner cases \\n        if(n == 1) return true; // base case\\n        int t2 = 0, t3 = 0, t5 = 0; //pointers for 2, 3, 5\\n        vector<int> k(n);\\n        k[0] = 1;\\n        for(int i  = 1; i < n ; i ++)\\n        {\\n            k[i] = min(k[t2]*2,min(k[t3]*3,k[t5]*5));\\n            if(k[i] == k[t2]*2) t2++; \\n            if(k[i] == k[t3]*3) t3++;\\n            if(k[i] == k[t5]*5) t5++;\\n        }\\n        return k[n-1];\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1840117,
                "title": "c-dp-solution",
                "content": "```\\nunordered_map<long,long> umap;\\n    vector<int> answers;\\n    void find_numbers(long num)\\n    {\\n        if(num>2147483647) return;\\n        \\n        if(umap[num]>0) return;\\n        umap[num]++;\\n        answers.push_back(num);\\n        find_numbers(num*2);\\n        find_numbers(num*3);\\n        find_numbers(num*5);\\n    }\\n    int nthUglyNumber(int n) {\\n       find_numbers(1);\\n        sort(answers.begin(),answers.end());\\n        return answers[n-1];\\n    }",
                "solutionTags": [],
                "code": "```\\nunordered_map<long,long> umap;\\n    vector<int> answers;\\n    void find_numbers(long num)\\n    {\\n        if(num>2147483647) return;\\n        \\n        if(umap[num]>0) return;\\n        umap[num]++;\\n        answers.push_back(num);\\n        find_numbers(num*2);\\n        find_numbers(num*3);\\n        find_numbers(num*5);\\n    }\\n    int nthUglyNumber(int n) {\\n       find_numbers(1);\\n        sort(answers.begin(),answers.end());\\n        return answers[n-1];\\n    }",
                "codeTag": "Unknown"
            },
            {
                "id": 1638921,
                "title": "c-brute-force-optimized-dp",
                "content": "**Brute force gives TLE**\\n```\\nclass Solution {\\npublic:\\n    bool isUgly(int n)\\n    {\\n        if(n==0)\\n        return false;\\n        while(n%2==0)\\n        n/=2;\\n        while(n%3==0)\\n        n/=3;\\n        while(n%5==0)\\n        n/=5;\\n        return n==1;\\n    }\\n    int nthUglyNumber(int n) {\\n    int i=1,c=0;\\n         while(c!=n)\\n         {\\n             if(isUgly(i))\\n             {\\n                 c++;\\n             }\\n             if(c==n)\\n             break;\\n             i++;\\n         }\\n        return i;\\n    }\\n};\\n```\\n**Optimized DP approach**\\n```\\nclass Solution {\\npublic:\\n    int nthUglyNumber(int n) {\\n        vector<int> dp(n+1);\\n        dp[1]=1;\\n        int p1,p2,p3;\\n        p1=1;\\n        p2=1;\\n        p3=1;\\n        for(int i=2;i<=n;i++)\\n        {\\n            int f1,f2,f3;\\n            f1=2*dp[p1];\\n            f2=3*dp[p2];\\n            f3=5*dp[p3];\\n            int mini=min(f1,min(f2,f3));\\n            dp[i]=mini;\\n            if(f1==mini)\\n            {\\n                p1++;\\n            }\\n            if(f2==mini)\\n            {\\n                p2++;\\n            }\\n            if(f3==mini)\\n            {\\n                p3++;\\n            }\\n        }\\n        return dp[n];\\n    }\\n};\\n```\\n**Please upvote to motivate me in my quest of documenting all leetcode solutions(to help the community). HAPPY CODING:)\\nAny suggestions and improvements are always welcome**",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    bool isUgly(int n)\\n    {\\n        if(n==0)\\n        return false;\\n        while(n%2==0)\\n        n/=2;\\n        while(n%3==0)\\n        n/=3;\\n        while(n%5==0)\\n        n/=5;\\n        return n==1;\\n    }\\n    int nthUglyNumber(int n) {\\n    int i=1,c=0;\\n         while(c!=n)\\n         {\\n             if(isUgly(i))\\n             {\\n                 c++;\\n             }\\n             if(c==n)\\n             break;\\n             i++;\\n         }\\n        return i;\\n    }\\n};\\n```\n```\\nclass Solution {\\npublic:\\n    int nthUglyNumber(int n) {\\n        vector<int> dp(n+1);\\n        dp[1]=1;\\n        int p1,p2,p3;\\n        p1=1;\\n        p2=1;\\n        p3=1;\\n        for(int i=2;i<=n;i++)\\n        {\\n            int f1,f2,f3;\\n            f1=2*dp[p1];\\n            f2=3*dp[p2];\\n            f3=5*dp[p3];\\n            int mini=min(f1,min(f2,f3));\\n            dp[i]=mini;\\n            if(f1==mini)\\n            {\\n                p1++;\\n            }\\n            if(f2==mini)\\n            {\\n                p2++;\\n            }\\n            if(f3==mini)\\n            {\\n                p3++;\\n            }\\n        }\\n        return dp[n];\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1624868,
                "title": "python-solution-using-dynamic-programming",
                "content": "```\\nclass Solution:\\n    def nthUglyNumber(self, n: int) -> int:\\n        dp=[1]\\n        \\n        p2,p3,p5=0,0,0\\n        \\n        for i in range(n+1):\\n            t2=dp[p2]*2\\n            t3=dp[p3]*3\\n            t5=dp[p5]*5\\n            \\n            temp=min(t2,t3,t5)\\n            \\n            dp.append(temp)\\n            \\n            if temp==dp[p2]*2:\\n                p2+=1\\n            if temp==dp[p3]*3:\\n                p3+=1\\n            if temp==dp[p5]*5:\\n                p5+=1\\n        # print(dp)        \\n        return dp[n-1]\\n        \\n```",
                "solutionTags": [
                    "Python",
                    "Python3",
                    "Dynamic Programming"
                ],
                "code": "```\\nclass Solution:\\n    def nthUglyNumber(self, n: int) -> int:\\n        dp=[1]\\n        \\n        p2,p3,p5=0,0,0\\n        \\n        for i in range(n+1):\\n            t2=dp[p2]*2\\n            t3=dp[p3]*3\\n            t5=dp[p5]*5\\n            \\n            temp=min(t2,t3,t5)\\n            \\n            dp.append(temp)\\n            \\n            if temp==dp[p2]*2:\\n                p2+=1\\n            if temp==dp[p3]*3:\\n                p3+=1\\n            if temp==dp[p5]*5:\\n                p5+=1\\n        # print(dp)        \\n        return dp[n-1]\\n        \\n```",
                "codeTag": "Java"
            },
            {
                "id": 1595985,
                "title": "c-dp-solution",
                "content": "In this problem we are building up our table by the product of the previous element with 2,3 or 5 accordingly.(Minimum Product). We are using three different variables a,b,c to mark the the index of the previous elements which are a product of 2,3 or 5 respectively. \\nThe 3 different variables ensure that the table is generated effectively.[ For Eg : 1,2,3,4,5,6,8..... and not 1,2,3,5,10...  You see 4 which is the product of 2x2 .  The 3 variables make sure that their respective values are incremented  **IF and ONLY IF   the current element is a product of either 2 or 3 or 5 respectively **]\\n```\\nclass Solution {\\npublic:\\n    int nthUglyNumber(int n) {\\n        int ar[n];\\n        ar[0]=1;        \\n       int a=0,b=0,c=0,i=1;\\n        while(i<n)\\n        {\\n            ar[i]=min({ar[a]*2,ar[b]*3,ar[c]*5});\\n            if(ar[i]==ar[a]*2)\\n                a++;\\n         if(ar[i]==ar[b]*3)\\n                b++;\\n          if(ar[i]==ar[c]*5)\\n                c++;\\n            i++;\\n        }\\n        return ar[n-1];\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "C",
                    "Dynamic Programming"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int nthUglyNumber(int n) {\\n        int ar[n];\\n        ar[0]=1;        \\n       int a=0,b=0,c=0,i=1;\\n        while(i<n)\\n        {\\n            ar[i]=min({ar[a]*2,ar[b]*3,ar[c]*5});\\n            if(ar[i]==ar[a]*2)\\n                a++;\\n         if(ar[i]==ar[b]*3)\\n                b++;\\n          if(ar[i]==ar[c]*5)\\n                c++;\\n            i++;\\n        }\\n        return ar[n-1];\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1566784,
                "title": "c-easy-dp-solution",
                "content": "Let us look at the ugly number sequence : 1, 2, 3, 4, 5, 6, 8, 9, 10, 12, 15, \\u2026\\n\\nEvery number in the sequence is either divisible by 2 or 3 or 5.\\nSo, we can look at the sequence as 3 groups of sequences\\n1) 1x2 , 2x2 , 3x2 , 4x2 , 5x2 , 6x2 , ...\\n2) 1x3 , 2x3 , 3x3 , 4x3 , 5x3 , 6x3 , ...\\n3) 1x5 , 2x5 , 3x5 , 4x5 , 5x5 , 6x5 , ...\\n\\nHence we use similar merge method as merge sort, to get every ugly number from the three subsequences. Every step, we choose the smallest one from the three sequences and move further.\\n \\n**Approach :** DP\\n**Time and Space Complexities :** Time Complexity : O(n)\\n                                                            Auxiliary space : O(n)\\n**Algorithm :**\\n```\\nStep1 : Declare an array ugly[n]\\nStep2 : Initialize ugly[0]=1\\nStep3 : Initialize 3 array index variables i2, i3, i5 to point to the first element of the array.\\nStep4 : Now, run a loop and go on filling the next elements of the array until ugly[n-1]\\n             for(int i=1;i<n;i++){\\n\\t\\t\\t        int next_ugly = min(ugly[i2]*2, min(ugly[i3]*3, ugly[i5]*5));\\n\\t\\t\\t\\t\\tugly[i]=next_ugly;\\n\\t\\t\\t\\t\\t\\n(Now this next_ugly must be in one of the 3 sequences ie multiple of 2 or 3 or 5. Check which sequence it belongs to and increase i2 or i3 or i5 accordinly.)\\n\\t\\t\\t\\t  if(next_ugly==ugly[i2]*2) i2++;\\n\\t\\t\\t\\t  if(next_ugly==ugly[i3]*3) i3++;\\n\\t\\t\\t\\t  if(next_ugly==ugly[i5]*5) i5++;\\n\\t\\t\\t\\t  \\n\\t\\t\\t}\\n```\\n\\n**Code :**\\n```\\nvector<int> ugly(n);\\n        ugly[0]=1;\\n        int i2=0, i3=0, i5=0;\\n    \\n        for(int i=1;i<n;i++){\\n            ugly[i]=min({ugly[i2]*2, ugly[i3]*3, ugly[i5]*5});\\n            if(ugly[i]==ugly[i2]*2) i2++;\\n            if(ugly[i]==ugly[i3]*3) i3++;\\n            if(ugly[i]==ugly[i5]*5) i5++;\\n        }\\n        return ugly[n-1];\\n```\\n\\nIf you like the solution and explanation, please upvote!\\n",
                "solutionTags": [
                    "C++",
                    "C",
                    "Dynamic Programming"
                ],
                "code": "```\\nStep1 : Declare an array ugly[n]\\nStep2 : Initialize ugly[0]=1\\nStep3 : Initialize 3 array index variables i2, i3, i5 to point to the first element of the array.\\nStep4 : Now, run a loop and go on filling the next elements of the array until ugly[n-1]\\n             for(int i=1;i<n;i++){\\n\\t\\t\\t        int next_ugly = min(ugly[i2]*2, min(ugly[i3]*3, ugly[i5]*5));\\n\\t\\t\\t\\t\\tugly[i]=next_ugly;\\n\\t\\t\\t\\t\\t\\n(Now this next_ugly must be in one of the 3 sequences ie multiple of 2 or 3 or 5. Check which sequence it belongs to and increase i2 or i3 or i5 accordinly.)\\n\\t\\t\\t\\t  if(next_ugly==ugly[i2]*2) i2++;\\n\\t\\t\\t\\t  if(next_ugly==ugly[i3]*3) i3++;\\n\\t\\t\\t\\t  if(next_ugly==ugly[i5]*5) i5++;\\n\\t\\t\\t\\t  \\n\\t\\t\\t}\\n```\n```\\nvector<int> ugly(n);\\n        ugly[0]=1;\\n        int i2=0, i3=0, i5=0;\\n    \\n        for(int i=1;i<n;i++){\\n            ugly[i]=min({ugly[i2]*2, ugly[i3]*3, ugly[i5]*5});\\n            if(ugly[i]==ugly[i2]*2) i2++;\\n            if(ugly[i]==ugly[i3]*3) i3++;\\n            if(ugly[i]==ugly[i5]*5) i5++;\\n        }\\n        return ugly[n-1];\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1167665,
                "title": "c-greedy-simple-observation-explain",
                "content": "QUES: find n th ugly.\\n##### **OBSERVATONS**\\n- maximum powers needed to do the job : 11 as 2^11 >1690 (thus 5^11 or 3^11 will be hell lot bigger)\\n- Thus only we need to permute power=i for numbers where i<=11\\n-  Now we have to find nth, it means nth smallest of all numbers formed\\n-  Thus we need to store values as we create ugly numbers in a sorted manner[set will be apt]\\n-  sorted manner helps us to create next smallest number too\\n-  One more thing, if top element of set is suppose 7. then next numbers will be 7\\\\*2=14,7\\\\*3=21, 7\\\\*5=35:   Here we missed out a fact that 7\\\\*4 is smaller than 7\\\\*5 in the long run it might make difference so include that too;\\nThus 7\\\\*2=14, 7\\\\*3=21, 7\\\\*4=28, 7\\\\*5=35\\n\\n#### PSEUDO CODE\\n- create set with first element as 1\\n- c=1     ......................................................//COUNT SMALLEST UGLY NUMBERS\\n- while loop until c < n:\\n\\t- remove top\\n\\t- c++\\n\\t- check c==n   then ans=c \\n\\t- add top\\\\*2, top\\\\*3, top\\\\*4, top\\\\*5 to set\\n\\t- REPEAT\\n\\n\\nDo \\uD83D\\uDC4D upvote if found useful \\u2764\\uFE0F\\n\\n#### C++\\n```\\n    int nthUglyNumber(int n) {\\n        set<long long int>se;\\n        se.insert(1);int ans=1;\\n        int c=0;\\n        while(c < n){\\n            long long int top = *(se.begin());\\n            se.erase(se.begin());\\n            c++;\\n            if(c==n){\\n                ans=top;\\n            }\\n            se.insert(top*2);\\n            se.insert(top*3);\\n            se.insert(top*4);\\n            se.insert(top*5);\\n        }\\n        return ans;\\n    }\\n```",
                "solutionTags": [
                    "C",
                    "Greedy",
                    "Sorting",
                    "Ordered Set"
                ],
                "code": "```\\n    int nthUglyNumber(int n) {\\n        set<long long int>se;\\n        se.insert(1);int ans=1;\\n        int c=0;\\n        while(c < n){\\n            long long int top = *(se.begin());\\n            se.erase(se.begin());\\n            c++;\\n            if(c==n){\\n                ans=top;\\n            }\\n            se.insert(top*2);\\n            se.insert(top*3);\\n            se.insert(top*4);\\n            se.insert(top*5);\\n        }\\n        return ans;\\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1081219,
                "title": "python3-heap-dp-solution-easy-to-understand",
                "content": "**Heap Solution**\\n\\n```\\nheap=[1]\\nans=[]\\nseen=set()\\nwhile len(ans)<n:\\n\\tmin_element = heapq.heappop(heap)\\n\\tans.append(min_element)\\n\\ta,b,c = 2*min_element, 3*min_element, 5*min_element\\n\\tif a not in seen:\\n\\t\\tseen.add(a)\\n\\t\\theapq.heappush(heap,a)\\n\\tif b not in seen:\\n\\t\\tseen.add(b)\\n\\t\\theapq.heappush(heap,b)\\n\\tif c not in seen:\\n\\t\\tseen.add(c)\\n\\t\\theapq.heappush(heap,c)\\n\\nreturn ans[n-1]\\n```\\n\\n**Dynamic Programming solution**\\n\\n```\\nans=[1]\\ni,j,k=0,0,0\\nwhile len(ans)<n:\\n\\ta,b,c=ans[i]*2,ans[j]*3,ans[k]*5\\n\\tmin_element = min(a,b,c)\\n\\tans.append(min_element)\\n\\tif min_element==a:\\n\\t\\ti+=1\\n\\tif min_element==b:\\n\\t\\tj+=1\\n\\tif min_element==c:\\n\\t\\tk+=1\\nreturn ans[n-1]\\n```",
                "solutionTags": [
                    "Python3",
                    "Dynamic Programming",
                    "Heap (Priority Queue)"
                ],
                "code": "```\\nheap=[1]\\nans=[]\\nseen=set()\\nwhile len(ans)<n:\\n\\tmin_element = heapq.heappop(heap)\\n\\tans.append(min_element)\\n\\ta,b,c = 2*min_element, 3*min_element, 5*min_element\\n\\tif a not in seen:\\n\\t\\tseen.add(a)\\n\\t\\theapq.heappush(heap,a)\\n\\tif b not in seen:\\n\\t\\tseen.add(b)\\n\\t\\theapq.heappush(heap,b)\\n\\tif c not in seen:\\n\\t\\tseen.add(c)\\n\\t\\theapq.heappush(heap,c)\\n\\nreturn ans[n-1]\\n```\n```\\nans=[1]\\ni,j,k=0,0,0\\nwhile len(ans)<n:\\n\\ta,b,c=ans[i]*2,ans[j]*3,ans[k]*5\\n\\tmin_element = min(a,b,c)\\n\\tans.append(min_element)\\n\\tif min_element==a:\\n\\t\\ti+=1\\n\\tif min_element==b:\\n\\t\\tj+=1\\n\\tif min_element==c:\\n\\t\\tk+=1\\nreturn ans[n-1]\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 808696,
                "title": "python-o-n-by-dp-w-comment",
                "content": "**Hint**:\\n\\nNext ugly number is smallest multiple among ( 2, 3, 5)\\n\\n---\\n\\n**Implementation** by dynamic programming:\\n```\\n\\nclass Solution:\\n    \\n    # look-up table to speed up query response time\\n    # it is updated by dynamic programming\\n    table = []\\n    \\n    def build_look_up_table(self):\\n        \\n        dp = Solution.table\\n        \\n        # base case, minimum ugly number is 1\\n        dp.append(1)\\n        \\n        # general case, compute next ugly number from previous cases\\n        idx_2, idx_3, idx_5 = 0, 0, 0\\n        \\n        # maximum n is defined in description\\n        max_n = 1690\\n        \\n        for _ in range(1, max_n):\\n            \\n            next_2k, next_3k, next_5k = dp[idx_2] * 2, dp[idx_3] * 3, dp[idx_5] * 5\\n            \\n            # next ugly number is smallest multiples among 2, 3, 5\\n            next_ugly_num = min( next_2k, next_3k, next_5k )\\n            \\n            dp.append( next_ugly_num )\\n            \\n            # update index for 2, 3, 5 if needed\\n            if next_ugly_num == next_2k:\\n                idx_2 += 1\\n            \\n            if next_ugly_num == next_3k:\\n                idx_3 += 1\\n            \\n            if next_ugly_num == next_5k:\\n                idx_5 += 1\\n        \\n        return\\n    \\n    \\n    def nthUglyNumber(self, n: int) -> int:\\n        \\n        if not Solution.table:\\n            \\n            # build once, and query for all\\n            self.build_look_up_table()\\n        \\n        return Solution.table[n-1]\\n\\n\\n```\\n\\n---\\n\\nRelated leetcode challenge:\\n\\n[Leetcode #263 Ugly Number](https://leetcode.com/problems/ugly-number/)\\n\\n[Leetcode #1201 Ugly Number III](https://leetcode.com/problems/ugly-number-iii)\\n\\n---\\n```",
                "solutionTags": [
                    "Python",
                    "Python3",
                    "Dynamic Programming"
                ],
                "code": "```\\n\\nclass Solution:\\n    \\n    # look-up table to speed up query response time\\n    # it is updated by dynamic programming\\n    table = []\\n    \\n    def build_look_up_table(self):\\n        \\n        dp = Solution.table\\n        \\n        # base case, minimum ugly number is 1\\n        dp.append(1)\\n        \\n        # general case, compute next ugly number from previous cases\\n        idx_2, idx_3, idx_5 = 0, 0, 0\\n        \\n        # maximum n is defined in description\\n        max_n = 1690\\n        \\n        for _ in range(1, max_n):\\n            \\n            next_2k, next_3k, next_5k = dp[idx_2] * 2, dp[idx_3] * 3, dp[idx_5] * 5\\n            \\n            # next ugly number is smallest multiples among 2, 3, 5\\n            next_ugly_num = min( next_2k, next_3k, next_5k )\\n            \\n            dp.append( next_ugly_num )\\n            \\n            # update index for 2, 3, 5 if needed\\n            if next_ugly_num == next_2k:\\n                idx_2 += 1\\n            \\n            if next_ugly_num == next_3k:\\n                idx_3 += 1\\n            \\n            if next_ugly_num == next_5k:\\n                idx_5 += 1\\n        \\n        return\\n    \\n    \\n    def nthUglyNumber(self, n: int) -> int:\\n        \\n        if not Solution.table:\\n            \\n            # build once, and query for all\\n            self.build_look_up_table()\\n        \\n        return Solution.table[n-1]\\n\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 720422,
                "title": "c-solution",
                "content": "\\nThe next ugly number is Min(existing ugly numbers * 2, existing ugly numbers * 3, existing ugly numbers * 5).  Each existing ugly number will be multiplied by 2, 3 and 5 once and only once, hence we use 3 pointers to track what would be the next **minimum** ulgy number.\\n\\n```\\npublic class Solution {\\n    public int NthUglyNumber(int n) {\\n     \\n        int[] arr = new int[n];\\n        arr[0] = 1;\\n        int p2 = 0, p3 = 0, p5 = 0;\\n        \\n        for(int i = 1; i < n; i++)\\n        {\\n            int num1 = 2 * arr[p2];\\n            int num2 = 3 * arr[p3];\\n            int num3 = 5 * arr[p5];\\n            \\n            arr[i] = Math.Min(num1, Math.Min(num2, num3));\\n            \\n            if(num1 == arr[i])\\n                p2++;\\n            if(num2 == arr[i])\\n                p3++;\\n            if(num3 == arr[i])\\n                p5++;\\n        }\\n        \\n        return arr[n-1];\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\npublic class Solution {\\n    public int NthUglyNumber(int n) {\\n     \\n        int[] arr = new int[n];\\n        arr[0] = 1;\\n        int p2 = 0, p3 = 0, p5 = 0;\\n        \\n        for(int i = 1; i < n; i++)\\n        {\\n            int num1 = 2 * arr[p2];\\n            int num2 = 3 * arr[p3];\\n            int num3 = 5 * arr[p5];\\n            \\n            arr[i] = Math.Min(num1, Math.Min(num2, num3));\\n            \\n            if(num1 == arr[i])\\n                p2++;\\n            if(num2 == arr[i])\\n                p3++;\\n            if(num3 == arr[i])\\n                p5++;\\n        }\\n        \\n        return arr[n-1];\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 719664,
                "title": "three-common-solution-in-python3",
                "content": "The first alternate solution is slow but got accepted.\\n\\n```\\nclass Solution:\\n    def alternateOne(self, n):\\n        res = []\\n        s = set()\\n        # Those magic numbers :)\\n        for i in range(0, 14):\\n            for j in range(0, 20):\\n                for k in range(0, 31):\\n                    x = 2**k * 3**j * 5 ** i\\n                    if x not in s:\\n                        res.append(x)\\n                        s.add(x)\\n        res.sort()\\n        return res[:1690]\\n    def dpSolution(self, n):\\n        dp = [1]\\n        a,b,c = 0, 0, 0\\n        for i in range(1, 1690):\\n            x,y,z = dp[a]*2, dp[b]*3, dp[c]*5\\n            u = min(x,y,z)\\n            \\n            if u == x:\\n                a+=1\\n            if u == y:\\n                b+=1\\n            if u == z:\\n                c+=1\\n            dp.append(u)\\n        return dp[n-1]\\n                \\n        \\n    def nthUglyNumber(self, n: int) -> int:\\n        return self.dpSolution(n)\\n        from heapq import heappop, heappush\\n        heap = []\\n        s = {1}\\n        res = []\\n        heappush(heap, 1)\\n        for i in range(1690):\\n            u = heappop(heap)\\n            res.append(u)\\n            for j in [2,3,5]:\\n                x = u * j\\n                if x not in s:\\n                    s.add(x)\\n                    heappush(heap, x)\\n        return res[n-1]\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution:\\n    def alternateOne(self, n):\\n        res = []\\n        s = set()\\n        # Those magic numbers :)\\n        for i in range(0, 14):\\n            for j in range(0, 20):\\n                for k in range(0, 31):\\n                    x = 2**k * 3**j * 5 ** i\\n                    if x not in s:\\n                        res.append(x)\\n                        s.add(x)\\n        res.sort()\\n        return res[:1690]\\n    def dpSolution(self, n):\\n        dp = [1]\\n        a,b,c = 0, 0, 0\\n        for i in range(1, 1690):\\n            x,y,z = dp[a]*2, dp[b]*3, dp[c]*5\\n            u = min(x,y,z)\\n            \\n            if u == x:\\n                a+=1\\n            if u == y:\\n                b+=1\\n            if u == z:\\n                c+=1\\n            dp.append(u)\\n        return dp[n-1]\\n                \\n        \\n    def nthUglyNumber(self, n: int) -> int:\\n        return self.dpSolution(n)\\n        from heapq import heappop, heappush\\n        heap = []\\n        s = {1}\\n        res = []\\n        heappush(heap, 1)\\n        for i in range(1690):\\n            u = heappop(heap)\\n            res.append(u)\\n            for j in [2,3,5]:\\n                x = u * j\\n                if x not in s:\\n                    s.add(x)\\n                    heappush(heap, x)\\n        return res[n-1]\\n```",
                "codeTag": "Java"
            },
            {
                "id": 719560,
                "title": "c-solution-using-min-heap",
                "content": "```\\nclass Solution {\\npublic:\\n    int nthUglyNumber(int n) {\\n        priority_queue<long, vector<long>, greater<long>> pq;\\n        pq.push(1);\\n        for (long i = 1; i < n; ++i) {\\n            long t = pq.top(); pq.pop();\\n            while (!pq.empty() && pq.top() == t) {\\n                t = pq.top(); pq.pop();\\n            }\\n            pq.push(t * 2);\\n            pq.push(t * 3);\\n            pq.push(t * 5);\\n        }\\n        return pq.top();\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    int nthUglyNumber(int n) {\\n        priority_queue<long, vector<long>, greater<long>> pq;\\n        pq.push(1);\\n        for (long i = 1; i < n; ++i) {\\n            long t = pq.top(); pq.pop();\\n            while (!pq.empty() && pq.top() == t) {\\n                t = pq.top(); pq.pop();\\n            }\\n            pq.push(t * 2);\\n            pq.push(t * 3);\\n            pq.push(t * 5);\\n        }\\n        return pq.top();\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 521307,
                "title": "javascript-solution-commented-for-fellow-beginners",
                "content": "```\\n/**\\n * @param {number} n\\n * @return {number}\\n */\\n\\n/* If you are coming from Ugly Numbers 1, like I did, the \\'gotcha\\' here is that the solution \\ncannot rely on incrementing an index by one and running through a helper function to check\\nif it is Ugly. This will pass the tests at smaller n-values, but will result in timeouts \\nwhen you get to larger numbers, like n=288.\\n\\nThe \"math trick\" here is to understand that if you add the multiples of 2, 3, 5 to a list, \\nthen you will only be adding ugly numbers to that list.\\n\\nThe \"organization trick\" here is to understand that you need to add them in order, or else \\nyou will not return a proper index. So by creating three \"multiplier indexes\" (here I have \\ncalled them ind2, ind3, ind5), and increment them only when their result is added to the list,\\nthen you will add results in order.\\n\\n********\\nI studied the solution from \\nhttps://leetcode.com/problems/ugly-number-ii/discuss/329484/Heavily-commented-JavaScript-bottom-up-DP-solution\\nuser \"demiurg2000\", so credit goes to him for \"teaching\" me the answer.\\n\\nI added even more comments because I wanted to lay it out for myself in newbie terms. \\nHopefully this is useful to you other Javascripters!\\n********\\n\\n*/\\n\\n\\n\\nvar nthUglyNumber = function(n) {\\n    var answersList = [1]\\n    var ind2=0;\\n    var ind3=0;\\n    var ind5=0;\\n    var multiplier;\\n    \\n    while(answersList.length<n){\\n        // These three lines will use our tracked list to determine our list of potential answers.\\n        // For examples, the results of the first and second passes through the while loop are commented on the right.\\n        let multipleTwo = answersList[ind2]*2;  // answersList[0]=1, 1*2=2 | answersList[1]=2, 2*2=4\\n        let multipleThree = answersList[ind3]*3; // answersList[0]=1, 1*3=3 | answersList[0]=1, 1*3=3\\n        let multipleFive = answersList[ind5]*5; //  answersList[0]=1, 1*5=5 | answersList[0]=1, 1*5=5\\n        \\n        /* This next step compares the three answers and stores the smallest one, \\n\\t\\tso we know we are adding items to answersList in order. This is important \\n\\t\\tso we do not simply add random ugly numbers to our list! The first two passes \\n\\t\\tare commented beneath. \\n\\t\\t\\n\\t\\t**Note that you can also just push this straight  to answersList, but storing the answer \\n\\t\\tas nextSmallestAnswer is beneficial so you can determine which multiplier index to increment.\\n\\t\\t*/\\n\\t\\tlet nextSmallestAnswer = Math.min(multipleTwo, multipleThree, multipleFive); \\n\\t\\t// Math.min(2,3,5) = 2 | Math.min( 4,3,5) = 3 \\n        \\n        /* From the examples, now you can see that we are essentially going to be calculating \\n\\t\\tthe multiples of 2, 3, and 5, and finding the lowest multiple. \\n         These next lines will determine whether a multiple of 2, 3, or 5 was chosen, \\n\\t\\t then increase the corresponding 2, 3, or 5-index by one.\\n        */\\n        if(nextSmallestAnswer%2===0){ // if a multiple of 2 was chosen\\n            ind2++;  \\n        }\\n        if(nextSmallestAnswer%3===0){// if a multiple of 3 was chosen\\n            ind3++;\\n        }\\n        if(nextSmallestAnswer%5===0){// if a multiple of 5 was chosen\\n            ind5++;\\n        }\\n        \\n        \\n        answersList.push(nextSmallestAnswer); \\n\\t\\t/* We  need to keep track of our answers, so this line will do that.  \\n\\t\\tAnswerslist will be [1, 2] after the first pass, and [1, 2, 3] after the second pass. \\n\\t\\t*/\\n    }\\n    return answersList[n-1]; // remember to adjust the index so your return is the proper value!\\n};\\n```",
                "solutionTags": [],
                "code": "```\\n/**\\n * @param {number} n\\n * @return {number}\\n */\\n\\n/* If you are coming from Ugly Numbers 1, like I did, the \\'gotcha\\' here is that the solution \\ncannot rely on incrementing an index by one and running through a helper function to check\\nif it is Ugly. This will pass the tests at smaller n-values, but will result in timeouts \\nwhen you get to larger numbers, like n=288.\\n\\nThe \"math trick\" here is to understand that if you add the multiples of 2, 3, 5 to a list, \\nthen you will only be adding ugly numbers to that list.\\n\\nThe \"organization trick\" here is to understand that you need to add them in order, or else \\nyou will not return a proper index. So by creating three \"multiplier indexes\" (here I have \\ncalled them ind2, ind3, ind5), and increment them only when their result is added to the list,\\nthen you will add results in order.\\n\\n********\\nI studied the solution from \\nhttps://leetcode.com/problems/ugly-number-ii/discuss/329484/Heavily-commented-JavaScript-bottom-up-DP-solution\\nuser \"demiurg2000\", so credit goes to him for \"teaching\" me the answer.\\n\\nI added even more comments because I wanted to lay it out for myself in newbie terms. \\nHopefully this is useful to you other Javascripters!\\n********\\n\\n*/\\n\\n\\n\\nvar nthUglyNumber = function(n) {\\n    var answersList = [1]\\n    var ind2=0;\\n    var ind3=0;\\n    var ind5=0;\\n    var multiplier;\\n    \\n    while(answersList.length<n){\\n        // These three lines will use our tracked list to determine our list of potential answers.\\n        // For examples, the results of the first and second passes through the while loop are commented on the right.\\n        let multipleTwo = answersList[ind2]*2;  // answersList[0]=1, 1*2=2 | answersList[1]=2, 2*2=4\\n        let multipleThree = answersList[ind3]*3; // answersList[0]=1, 1*3=3 | answersList[0]=1, 1*3=3\\n        let multipleFive = answersList[ind5]*5; //  answersList[0]=1, 1*5=5 | answersList[0]=1, 1*5=5\\n        \\n        /* This next step compares the three answers and stores the smallest one, \\n\\t\\tso we know we are adding items to answersList in order. This is important \\n\\t\\tso we do not simply add random ugly numbers to our list! The first two passes \\n\\t\\tare commented beneath. \\n\\t\\t\\n\\t\\t**Note that you can also just push this straight  to answersList, but storing the answer \\n\\t\\tas nextSmallestAnswer is beneficial so you can determine which multiplier index to increment.\\n\\t\\t*/\\n\\t\\tlet nextSmallestAnswer = Math.min(multipleTwo, multipleThree, multipleFive); \\n\\t\\t// Math.min(2,3,5) = 2 | Math.min( 4,3,5) = 3 \\n        \\n        /* From the examples, now you can see that we are essentially going to be calculating \\n\\t\\tthe multiples of 2, 3, and 5, and finding the lowest multiple. \\n         These next lines will determine whether a multiple of 2, 3, or 5 was chosen, \\n\\t\\t then increase the corresponding 2, 3, or 5-index by one.\\n        */\\n        if(nextSmallestAnswer%2===0){ // if a multiple of 2 was chosen\\n            ind2++;  \\n        }\\n        if(nextSmallestAnswer%3===0){// if a multiple of 3 was chosen\\n            ind3++;\\n        }\\n        if(nextSmallestAnswer%5===0){// if a multiple of 5 was chosen\\n            ind5++;\\n        }\\n        \\n        \\n        answersList.push(nextSmallestAnswer); \\n\\t\\t/* We  need to keep track of our answers, so this line will do that.  \\n\\t\\tAnswerslist will be [1, 2] after the first pass, and [1, 2, 3] after the second pass. \\n\\t\\t*/\\n    }\\n    return answersList[n-1]; // remember to adjust the index so your return is the proper value!\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 404305,
                "title": "java-2ms-faster-dp-sol",
                "content": "int[] merged = new int[n];\\n\\n\\t\\tmerged[0] = 1;\\n\\t\\tint p2 = 0, p3 = 0, p5 = 0;\\n\\n\\t\\tfor (int i = 1; i < n; i++) {\\n\\n\\t\\t\\tmerged[i] = Math.min(Math.min(merged[p2] * 2, merged[p3] * 3), merged[p5] * 5);\\n\\n\\t\\t\\tif (merged[i] == merged[p2] * 2) {\\n\\t\\t\\t\\tp2++;\\n\\t\\t\\t}\\n\\t\\t\\tif (merged[i] == merged[p3] * 3) {\\n\\t\\t\\t\\tp3++;\\n\\t\\t\\t}\\n\\t\\t\\tif (merged[i] == merged[p5] * 5) {\\n\\t\\t\\t\\tp5++;\\n\\t\\t\\t}\\n\\n\\t\\t}\\n\\n\\t\\treturn merged[n - 1];",
                "solutionTags": [],
                "code": "int[] merged = new int[n];\\n\\n\\t\\tmerged[0] = 1;\\n\\t\\tint p2 = 0, p3 = 0, p5 = 0;\\n\\n\\t\\tfor (int i = 1; i < n; i++) {\\n\\n\\t\\t\\tmerged[i] = Math.min(Math.min(merged[p2] * 2, merged[p3] * 3), merged[p5] * 5);\\n\\n\\t\\t\\tif (merged[i] == merged[p2] * 2) {\\n\\t\\t\\t\\tp2++;\\n\\t\\t\\t}\\n\\t\\t\\tif (merged[i] == merged[p3] * 3) {\\n\\t\\t\\t\\tp3++;\\n\\t\\t\\t}\\n\\t\\t\\tif (merged[i] == merged[p5] * 5) {\\n\\t\\t\\t\\tp5++;\\n\\t\\t\\t}\\n\\n\\t\\t}\\n\\n\\t\\treturn merged[n - 1];",
                "codeTag": "Unknown"
            },
            {
                "id": 260580,
                "title": "binary-search-with-o-1-space-complexity-in-c",
                "content": "```\\nclass Solution {\\npublic:\\n\\tint nthUglyNumber(int n) {\\n\\t\\tint pow[40] = {1};\\n\\t\\tfor (int i = 1; i <= 30; ++i) pow[i] = pow[i - 1] * 2;\\n\\t\\tint l = 1, r = 2147483647;\\n\\t\\twhile (l < r) {\\n\\t\\t\\tint mid = l + ((r - l) >> 1), cnt = 0;\\n\\t\\t\\tfor (long long i = 1; i <= mid; i *= 5) {\\n\\t\\t\\t\\tfor (long long j = 1; j * i <= mid; j *= 3) {\\n\\t\\t\\t\\t\\tcnt += upper_bound(pow, pow + 31, mid / i / j) - pow;\\n\\t\\t\\t\\t}\\n\\t\\t\\t}\\n\\t\\t\\tif (cnt < n) l = mid + 1;\\n\\t\\t\\telse r = mid;\\n\\t\\t}\\n\\t\\treturn l;\\n\\t}\\n};\\n```\\n\\n\\nWe can use **built-in functions** instead of `upper_bound(pow, pow + 31, mid / i / j) - pow` :\\n\\n\\n```\\nclass Solution {\\npublic:\\n    int nthUglyNumber(int n) {\\n        int l = 1, r = 2147483647;\\n        while (l < r) {\\n            int mid = l + ((r - l) >> 1), cnt = 0;\\n            for (long long i = 1; i <= mid; i *= 5) {\\n                for (long long j = 1; j * i <= mid; j *= 3) {\\n                    cnt += 32 - __builtin_clz(mid / i / j);\\n                }\\n            }\\n            if (cnt < n) l = mid + 1;\\n            else r = mid;\\n        }\\n        return l;\\n    }\\n};\\n```",
                "solutionTags": [
                    "Binary Tree"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n\\tint nthUglyNumber(int n) {\\n\\t\\tint pow[40] = {1};\\n\\t\\tfor (int i = 1; i <= 30; ++i) pow[i] = pow[i - 1] * 2;\\n\\t\\tint l = 1, r = 2147483647;\\n\\t\\twhile (l < r) {\\n\\t\\t\\tint mid = l + ((r - l) >> 1), cnt = 0;\\n\\t\\t\\tfor (long long i = 1; i <= mid; i *= 5) {\\n\\t\\t\\t\\tfor (long long j = 1; j * i <= mid; j *= 3) {\\n\\t\\t\\t\\t\\tcnt += upper_bound(pow, pow + 31, mid / i / j) - pow;\\n\\t\\t\\t\\t}\\n\\t\\t\\t}\\n\\t\\t\\tif (cnt < n) l = mid + 1;\\n\\t\\t\\telse r = mid;\\n\\t\\t}\\n\\t\\treturn l;\\n\\t}\\n};\\n```\n```\\nclass Solution {\\npublic:\\n    int nthUglyNumber(int n) {\\n        int l = 1, r = 2147483647;\\n        while (l < r) {\\n            int mid = l + ((r - l) >> 1), cnt = 0;\\n            for (long long i = 1; i <= mid; i *= 5) {\\n                for (long long j = 1; j * i <= mid; j *= 3) {\\n                    cnt += 32 - __builtin_clz(mid / i / j);\\n                }\\n            }\\n            if (cnt < n) l = mid + 1;\\n            else r = mid;\\n        }\\n        return l;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 216388,
                "title": "my-java-code-6ms-readable-and-clean",
                "content": "hope it helps :)\\n\\n\\tpublic int nthUglyNumber(int n) {\\n\\t\\t\\tint[] res = new int[n];\\n\\t\\t\\tres[0] = 1;\\n\\t\\t\\tint t2 = 0, t3 = 0, t5 = 0, idx = 1;\\n\\t\\t\\twhile (idx < n) {\\n\\t\\t\\t\\tres[idx] = Math.min(res[t2] * 2, Math.min(res[t3] * 3, res[t5] * 5));\\n\\t\\t\\t\\tt2 += res[idx] == res[t2] * 2 ? 1 : 0;\\n\\t\\t\\t\\tt3 += res[idx] == res[t3] * 3 ? 1 : 0;\\n\\t\\t\\t\\tt5 += res[idx] == res[t5] * 5 ? 1 : 0;\\n\\t\\t\\t\\t++idx;\\n\\t\\t\\t}\\n\\t\\t\\treturn res[n - 1];\\n\\t\\t}",
                "solutionTags": [],
                "code": "hope it helps :)\\n\\n\\tpublic int nthUglyNumber(int n) {\\n\\t\\t\\tint[] res = new int[n];\\n\\t\\t\\tres[0] = 1;\\n\\t\\t\\tint t2 = 0, t3 = 0, t5 = 0, idx = 1;\\n\\t\\t\\twhile (idx < n) {\\n\\t\\t\\t\\tres[idx] = Math.min(res[t2] * 2, Math.min(res[t3] * 3, res[t5] * 5));\\n\\t\\t\\t\\tt2 += res[idx] == res[t2] * 2 ? 1 : 0;\\n\\t\\t\\t\\tt3 += res[idx] == res[t3] * 3 ? 1 : 0;\\n\\t\\t\\t\\tt5 += res[idx] == res[t5] * 5 ? 1 : 0;\\n\\t\\t\\t\\t++idx;\\n\\t\\t\\t}\\n\\t\\t\\treturn res[n - 1];\\n\\t\\t}",
                "codeTag": "Unknown"
            },
            {
                "id": 206975,
                "title": "java-wonderful-solution",
                "content": "you can see https://www.geeksforgeeks.org/ugly-numbers/\\n```\\nclass Solution {\\n    public int nthUglyNumber(int n) {\\n        int[] dp = new int[n];\\n        dp[0] = 1;\\n        int index2 = 0, index3 = 0, index5 = 0;\\n        int nextUgly2 = 2, nextUgly3 = 3, nextUgly5 = 5;\\n        for (int i = 1; i < n; i++) {\\n            dp[i] = Math.min(Math.min(nextUgly2, nextUgly3), nextUgly5);\\n            if (dp[i] == nextUgly2) nextUgly2 = 2 * dp[++index2];\\n            if (dp[i] == nextUgly3) nextUgly3 = 3 * dp[++index3];\\n            if (dp[i] == nextUgly5) nextUgly5 = 5 * dp[++index5];\\n        }\\n        return dp[n - 1];\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    public int nthUglyNumber(int n) {\\n        int[] dp = new int[n];\\n        dp[0] = 1;\\n        int index2 = 0, index3 = 0, index5 = 0;\\n        int nextUgly2 = 2, nextUgly3 = 3, nextUgly5 = 5;\\n        for (int i = 1; i < n; i++) {\\n            dp[i] = Math.min(Math.min(nextUgly2, nextUgly3), nextUgly5);\\n            if (dp[i] == nextUgly2) nextUgly2 = 2 * dp[++index2];\\n            if (dp[i] == nextUgly3) nextUgly3 = 3 * dp[++index3];\\n            if (dp[i] == nextUgly5) nextUgly5 = 5 * dp[++index5];\\n        }\\n        return dp[n - 1];\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 69386,
                "title": "3ms-java-solution-beats-100",
                "content": " after some tests  the input num n is less than 3000  so............................\\n \\n\\n    public class Solution {\\n            static int[] save = new int[3000];\\n            static int flag = 0;\\n            public int nthUglyNumber(int n) {\\n               if(flag == 0){\\n                   flag ++;\\n                   init();\\n               }\\n               return save[n-1];\\n            }\\n            public static void init(){\\n                int _2 = 0, _3 = 0, _5 = 0;\\n                save[0] = 1;\\n                for(int i = 1; i < 3000; i++){\\n                    int min = Math.min(save[_2]*2, Math.min(save[_3]*3,save[_5]*5));\\n                    if(save[_2]*2 == min) {\\n                        save[i] = save[_2]*2;\\n                        _2 ++;\\n                    }\\n                    if(save[_3]*3 == min) {\\n                        save[i] = save[_3]*3;\\n                        _3 ++;\\n                    }\\n                    if(save[_5]*5 == min) {\\n                        save[i] = save[_5]*5;\\n                        _5 ++;\\n                    }\\n                }\\n            }\\n        }",
                "solutionTags": [
                    "Java"
                ],
                "code": "class Solution {\\n            static int[] save = new int[3000];\\n            static int flag = 0;\\n            public int nthUglyNumber(int n) {\\n               if(flag == 0){\\n                   flag ++;\\n                   init();\\n               }",
                "codeTag": "Java"
            },
            {
                "id": 69446,
                "title": "java-solution-with-one-min-heap",
                "content": "**Edited:**\\n\\nThanks to @zytp9 's suggestion, now the solution uses a HashSet to look up the items inserted into the minHeap, instead of calling the O(n) \"minHeap.contains()\". The solution's time complexity is O(nlogn).\\n\\nThere is a O(n) solution here:\\nhttps://leetcode.com/discuss/55304/java-easy-understand-o-n-solution\\n\\n    public class Solution {\\n        public int nthUglyNumber(int n) {\\n        \\n            PriorityQueue<Integer> minHeap = new PriorityQueue<Integer>();\\n            HashSet<Integer> set = new HashSet<Integer>();\\n            minHeap.offer(1);\\n            set.add(1);\\n        \\n            Integer uglyNumber = 1;\\n        \\n            for (int i=1; i<=n; ++i) {\\n                uglyNumber = minHeap.poll();\\n                if (uglyNumber <= Integer.MAX_VALUE/2 && !set.contains(uglyNumber * 2)) { \\n                    minHeap.offer(uglyNumber * 2);\\n                    set.add(uglyNumber * 2);\\n                }\\n                if (uglyNumber <= Integer.MAX_VALUE/3 &&!set.contains(uglyNumber * 3)) {\\n                    minHeap.offer(uglyNumber * 3);\\n                    set.add(uglyNumber * 3);\\n                }\\n                if (uglyNumber <= Integer.MAX_VALUE/5 &&!set.contains(uglyNumber * 5)) {\\n                    minHeap.offer(uglyNumber * 5);\\n                    set.add(uglyNumber * 5);\\n                }\\n            }\\n        \\n            return uglyNumber.intValue();\\n        }\\n    }",
                "solutionTags": [
                    "Java"
                ],
                "code": "class Solution {\\n        public int nthUglyNumber(int n) {\\n        \\n            PriorityQueue<Integer> minHeap = new PriorityQueue<Integer>();\\n            HashSet<Integer> set = new HashSet<Integer>();\\n            minHeap.offer(1);\\n            set.add(1);\\n        \\n            Integer uglyNumber = 1;\\n        \\n            for (int i=1; i<=n; ++i) {\\n                uglyNumber = minHeap.poll();\\n                if (uglyNumber <= Integer.MAX_VALUE/2 && !set.contains(uglyNumber * 2)) { \\n                    minHeap.offer(uglyNumber * 2);\\n                    set.add(uglyNumber * 2);\\n                }",
                "codeTag": "Java"
            },
            {
                "id": 69461,
                "title": "python-heap-solution-o-nlogn",
                "content": "This Solution is not the most efficient one, but is very easy to come out with in an interview and quite self-explaining.\\n\\n    class Solution:\\n    # @param {integer} n\\n    # @return {integer} \\n    def nthUglyNumber(self, n):\\n        import heapq\\n        f = [1]  \\n        last = 0\\n        cnt = 0\\n        while cnt < n:\\n            i = heapq.heappop(f)\\n            if i <= last: continue #skip duplicates\\n            last = i\\n            cnt += 1 \\n            if cnt == n: return i\\n            heapq.heappush(f, i*2)\\n            heapq.heappush(f, i*3)\\n            heapq.heappush(f, i*5)",
                "solutionTags": [],
                "code": "class Solution:\\n    # @param {integer}",
                "codeTag": "Java"
            },
            {
                "id": 3924905,
                "title": "easy-java-dp-solution",
                "content": "## Intuition\\n\\nThe code is solving the problem of finding the nth ugly number. An ugly number is a positive integer whose prime factors are limited to 2, 3, and 5.\\n\\n## Approach\\n1. **Dynamic Programming with Multiple Pointers**:\\n   - The code uses dynamic programming to build an array `dp` where `dp[i]` represents the ith ugly number.\\n   - It initializes the first element of `dp` as 1.\\n   - The code maintains three pointers, `p2`, `p3`, and `p5`, which represent the indices in the `dp` array corresponding to the next multiples of 2, 3, and 5.\\n   - The idea is to generate new ugly numbers by multiplying the existing ugly numbers by 2, 3, and 5 and selecting the minimum among them as the next ugly number.\\n   - The minimum ugly number among `dp[p2]*2`, `dp[p3]*3`, and `dp[p5]*5` is computed and stored in `dp[i]`. The pointers are updated based on which factor was used to generate the minimum ugly number.\\n\\n2. **Iteration**:\\n   - The loop iterates from index 1 to n-1, filling in the `dp` array with the nth ugly number.\\n\\n## Complexity\\n- **Time complexity**:\\n   - The loop iterates from 1 to n-1, performing constant-time operations within each iteration. The dominant operation is the comparison of the three possible multiples (`dp[p2]*2`, `dp[p3]*3`, `dp[p5]*5`) to find the minimum, which is O(1).\\n   - Thus, the overall time complexity is O(n), where n is the input value representing the nth ugly number to be found.\\n\\n- **Space complexity**:\\n   - The code uses an array `dp` of size n to store the ugly numbers, resulting in a space complexity of O(n).\\n   - Additionally, a constant amount of extra space is used to store the pointers `p2`, `p3`, and `p5`, so the overall space complexity remains O(n).\\n\\nThe provided code efficiently solves the problem by using dynamic programming and multiple pointers to generate the nth ugly number without the need for extra space or multiple loops, resulting in a linear time complexity solution.\\n\\n# Code\\n```\\nclass Solution {\\n    public int nthUglyNumber(int n) {\\n        int dp[]=new int[n];\\n        dp[0]=1;\\n        int p2=0,p3=0,p5=0;\\n        for(int i=1;i<n;i++){\\n            int min=Math.min(dp[p2]*2,Math.min(dp[p3]*3,dp[p5]*5));\\n            if(min==dp[p2]*2)p2++;\\n            if(min==dp[p3]*3)p3++;\\n            if(min==dp[p5]*5)p5++;\\n            dp[i]=min;\\n        }\\n        return dp[n-1];\\n    }\\n}\\n```\\n# If it\\'s helpful for you then please UPVOTE \\uD83D\\uDC4D\\uD83D\\uDC4D",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int nthUglyNumber(int n) {\\n        int dp[]=new int[n];\\n        dp[0]=1;\\n        int p2=0,p3=0,p5=0;\\n        for(int i=1;i<n;i++){\\n            int min=Math.min(dp[p2]*2,Math.min(dp[p3]*3,dp[p5]*5));\\n            if(min==dp[p2]*2)p2++;\\n            if(min==dp[p3]*3)p3++;\\n            if(min==dp[p5]*5)p5++;\\n            dp[i]=min;\\n        }\\n        return dp[n-1];\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2976520,
                "title": "min-heap-with-dry-run",
                "content": "\\n# Code\\n```\\nclass Solution:\\n    def nthUglyNumber(self, n: int) -> int:\\n        # take a min heap and insert 1 into it as \\n        #there is no prime factor for 1\\n        min_heap = [1] \\n        #take one variable which records no of variable which have been\\n        # recorded already\\n        seen = set([1]) \\n        prime_no = (2,3,5)\\n        #iterating n-1 times\\n        for i in range(n-1):  \\n            ugly_no = heapq.heappop(min_heap)\\n            for ele in prime_no:\\n                no = ugly_no * ele\\n                if no not in seen:\\n                    seen.add(no)\\n                    heapq.heappush(min_heap, no)\\n        return min_heap[0]\\n\\n```\\n\\n# DRY RUN\\n------iteration----no-------  0\\nugly 1\\nproduct 2\\nseen [1, 2]\\nminHeap [2]\\nproduct 3\\nseen [1, 2, 3]\\nminHeap [2, 3]\\nproduct 5\\nseen [1, 2, 3, 5]\\nminHeap [2, 3, 5]\\n------iteration----no-------  1\\nugly 2\\nproduct 4\\nseen [1, 2, 3, 5, 4]\\nminHeap [3, 5, 4]\\nproduct 6\\nseen [1, 2, 3, 5, 4, 6]\\nminHeap [3, 5, 4, 6]\\nproduct 10\\nseen [1, 2, 3, 5, 4, 6, 10]\\nminHeap [3, 5, 4, 6, 10]\\n------iteration----no-------  2\\nugly 3\\nproduct 6\\nproduct 9\\nseen [1, 2, 3, 5, 4, 6, 10, 9]\\nminHeap [4, 5, 10, 6, 9]\\nproduct 15\\nseen [1, 2, 3, 5, 4, 6, 10, 9, 15]\\nminHeap [4, 5, 10, 6, 9, 15]\\n------iteration----no-------  3\\nugly 4\\nproduct 8\\nseen [1, 2, 3, 5, 4, 6, 10, 9, 15, 8]\\nminHeap [5, 6, 8, 15, 9, 10]\\nproduct 12\\nseen [1, 2, 3, 5, 4, 6, 10, 9, 15, 8, 12]\\nminHeap [5, 6, 8, 15, 9, 10, 12]\\nproduct 20\\nseen [1, 2, 3, 5, 4, 6, 10, 9, 15, 8, 12, 20]\\nminHeap [5, 6, 8, 15, 9, 10, 12, 20]\\n------iteration----no-------  4\\nugly 5\\nproduct 10\\nproduct 15\\nproduct 25\\nseen [1, 2, 3, 5, 4, 6, 10, 9, 15, 8, 12, 20, 25]\\nminHeap [6, 9, 8, 15, 20, 10, 12, 25]\\n------iteration----no-------  5\\nugly 6\\nproduct 12\\nproduct 18\\nseen [1, 2, 3, 5, 4, 6, 10, 9, 15, 8, 12, 20, 25, 18]\\nminHeap [8, 9, 10, 15, 20, 25, 12, 18]\\nproduct 30\\nseen [1, 2, 3, 5, 4, 6, 10, 9, 15, 8, 12, 20, 25, 18, 30]\\nminHeap [8, 9, 10, 15, 20, 25, 12, 18, 30]\\n------iteration----no-------  6\\nugly 8\\nproduct 16\\nseen [1, 2, 3, 5, 4, 6, 10, 9, 15, 8, 12, 20, 25, 18, 30, 16]\\nminHeap [9, 15, 10, 16, 20, 25, 12, 30, 18]\\nproduct 24\\nseen [1, 2, 3, 5, 4, 6, 10, 9, 15, 8, 12, 20, 25, 18, 30, 16, 24]\\nminHeap [9, 15, 10, 16, 20, 25, 12, 30, 18, 24]\\nproduct 40\\nseen [1, 2, 3, 5, 4, 6, 10, 9, 15, 8, 12, 20, 25, 18, 30, 16, 24, 40]\\nminHeap [9, 15, 10, 16, 20, 25, 12, 30, 18, 24, 40]\\n------iteration----no-------  7\\nugly 9\\nproduct 18\\nproduct 27\\nseen [1, 2, 3, 5, 4, 6, 10, 9, 15, 8, 12, 20, 25, 18, 30, 16, 24, 40, 27]\\nminHeap [10, 15, 12, 16, 20, 25, 40, 30, 18, 24, 27]\\nproduct 45\\nseen [1, 2, 3, 5, 4, 6, 10, 9, 15, 8, 12, 20, 25, 18, 30, 16, 24, 40, 27, 45]\\nminHeap [10, 15, 12, 16, 20, 25, 40, 30, 18, 24, 27, 45]\\n------iteration----no-------  8\\nugly 10\\nproduct 20\\nproduct 30\\nproduct 50\\nseen [1, 2, 3, 5, 4, 6, 10, 9, 15, 8, 12, 20, 25, 18, 30, 16, 24, 40, 27, 45, 50]\\nminHeap [12, 15, 25, 16, 20, 45, 40, 30, 18, 24, 27, 50]\\n\\n---------------------HERE IS THE FINAL OUTPUT-------------------------\\noutput 12\\nseen [1, 2, 3, 5, 4, 6, 10, 9, 15, 8, 12, 20, 25, 18, 30, 16, 24, 40, 27, 45, 50]\\nminheap [12, 15, 25, 16, 20, 45, 40, 30, 18, 24, 27, 50]",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def nthUglyNumber(self, n: int) -> int:\\n        # take a min heap and insert 1 into it as \\n        #there is no prime factor for 1\\n        min_heap = [1] \\n        #take one variable which records no of variable which have been\\n        # recorded already\\n        seen = set([1]) \\n        prime_no = (2,3,5)\\n        #iterating n-1 times\\n        for i in range(n-1):  \\n            ugly_no = heapq.heappop(min_heap)\\n            for ele in prime_no:\\n                no = ugly_no * ele\\n                if no not in seen:\\n                    seen.add(no)\\n                    heapq.heappush(min_heap, no)\\n        return min_heap[0]\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2828437,
                "title": "dp-implementation-with-queues-o-n-time-c",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nAs in many solution the idea of pointers is being used to select the next element. I instead used  multilevel queues to keep track of the next element. The idea was simple that we will get the next element only by multiplying 2,3 or 5 with the existing element.The smallest element we can get by multiplying 2,3or 5 with existing ones which is unique one will be the next candidate.\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\nWe will build three queues q2 (will contain the elements that are to be multiplied with 2), q3 and q5 vis versa where q2 to q5 is increasing level. Now all new elements will be pushed in the q2 first (as multiplying a number with 2 will yeild a smaller number than with 3 or 5). We will select the front elements of all the queues and multiply with respective numbers and choose the minimum. Now after getting the minimum we have to move the element selected to the next level queue and pop it from the current queue.\\nDry Run\\nInitially\\nq2 :1\\nq3 :empty\\nq5 :empty\\n\\ni=1\\nans=1*2\\nq2 :2\\nq3 :1\\nq5 :empty\\n\\ni=2\\nans=min(2*2,1*3)\\nq2 :2,3\\nq3 :\\nq5 :1\\n\\ni=3\\nans=min(2*2,1*5)\\nq2 :3,4\\nq3 :2\\nq5 :1\\n\\ni=4\\nans=min(2*3,3*2,5*1)\\nq2 :3,4,5\\nq3 :2\\nq5 :\\n\\ni=5\\nans=min(2*3,3*2) \\n[Now here both the queue top yeilds the same result so we will pop    the numbers from all queues to next level queues and push the result as it is to the q2\\n]\\nq2 :4,5,6\\nq3 :3\\nq5 :2\\n \\n.....so on upto n\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\nO(n)\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\nO(n)\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int nthUglyNumber(int n) \\n    {\\n        int ans=1;\\n        queue <int> q2;\\n        queue <int> q3;\\n        queue <int> q5;\\n        unordered_map <int,bool> h_map;\\n        \\n        q2.push(1);\\n        h_map[1]=true;\\n        for(int i=1;i<n;i++)\\n        {\\n            ans=q2.front()*2;\\n            if(!q3.empty() && (double)q3.front()*3<=INT_MAX) //check for interger overflow & queue underflow error\\n                ans=min(ans,q3.front()*3);\\n            if(!q5.empty()&& (double)q5.front()*5<=INT_MAX)\\n                ans=min(ans,q5.front()*5);\\n            q2.push(ans);\\n            h_map[ans]=true;\\n            //checking element from which queue was selected and poping it to the next queue.\\n            if(ans==q2.front()*2)   \\n            {\\n                q3.push(q2.front());\\n                q2.pop();                \\n            }\\n            else if(ans==q3.front()*3)\\n            {\\n                q5.push(q3.front());\\n                q3.pop();\\n            }\\n            else \\n            {\\n                q5.pop(); \\n            }\\n            // checking for any duplicates using a map\\n            if(!q3.empty() &&(double)q3.front()*3<=INT_MAX&& h_map.find(q3.front()*3)!=h_map.end())\\n                q3.pop();\\n            else if(!q5.empty() &&(double)q5.front()*5<=INT_MAX&& h_map.find(q5.front()*5)!=h_map.end())\\n                q5.pop();\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Dynamic Programming",
                    "Queue"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int nthUglyNumber(int n) \\n    {\\n        int ans=1;\\n        queue <int> q2;\\n        queue <int> q3;\\n        queue <int> q5;\\n        unordered_map <int,bool> h_map;\\n        \\n        q2.push(1);\\n        h_map[1]=true;\\n        for(int i=1;i<n;i++)\\n        {\\n            ans=q2.front()*2;\\n            if(!q3.empty() && (double)q3.front()*3<=INT_MAX) //check for interger overflow & queue underflow error\\n                ans=min(ans,q3.front()*3);\\n            if(!q5.empty()&& (double)q5.front()*5<=INT_MAX)\\n                ans=min(ans,q5.front()*5);\\n            q2.push(ans);\\n            h_map[ans]=true;\\n            //checking element from which queue was selected and poping it to the next queue.\\n            if(ans==q2.front()*2)   \\n            {\\n                q3.push(q2.front());\\n                q2.pop();                \\n            }\\n            else if(ans==q3.front()*3)\\n            {\\n                q5.push(q3.front());\\n                q3.pop();\\n            }\\n            else \\n            {\\n                q5.pop(); \\n            }\\n            // checking for any duplicates using a map\\n            if(!q3.empty() &&(double)q3.front()*3<=INT_MAX&& h_map.find(q3.front()*3)!=h_map.end())\\n                q3.pop();\\n            else if(!q5.empty() &&(double)q5.front()*5<=INT_MAX&& h_map.find(q5.front()*5)!=h_map.end())\\n                q5.pop();\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2691549,
                "title": "dp-c-13ms-solution-easy-to-understand",
                "content": "```\\nclass Solution {\\npublic:\\n    int nthUglyNumber(int& n) {\\n        vector<int> dp(n,0);\\n        dp[0] = 1;\\n        int i = 0, j = 0, k = 0;\\n        for(int z = 1; z < n; z++){\\n            dp[z] = min(dp[i]*2,min(dp[j]*3,dp[k]*5));\\n            if(dp[z]==dp[i]*2)i++;\\n            if(dp[z]==dp[j]*3)j++;\\n            if(dp[z]==dp[k]*5)k++;\\n            // cout<<dp[z]<<\" \";\\n        }\\n        \\n        return dp[n-1];\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "C",
                    "Dynamic Programming"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int nthUglyNumber(int& n) {\\n        vector<int> dp(n,0);\\n        dp[0] = 1;\\n        int i = 0, j = 0, k = 0;\\n        for(int z = 1; z < n; z++){\\n            dp[z] = min(dp[i]*2,min(dp[j]*3,dp[k]*5));\\n            if(dp[z]==dp[i]*2)i++;\\n            if(dp[z]==dp[j]*3)j++;\\n            if(dp[z]==dp[k]*5)k++;\\n            // cout<<dp[z]<<\" \";\\n        }\\n        \\n        return dp[n-1];\\n    }\\n};\\n```",
                "codeTag": "C++"
            },
            {
                "id": 2220970,
                "title": "c-3-solution-brute-force-to-optimal-solution",
                "content": "***Brute Force Approach ( TLE)***\\nChecking every number until nth ugly number is found.\\n```\\nbool isUgly(int n) {\\n        if(n<=0) return false;\\n        for(int i=2; i<6 &&n; i++){\\n            while( n%i ==0){\\n                n/=i;\\n            }\\n        }\\n        return n==1;\\n}\\nint nthUglyNumber(int n) {\\n        if (n<=6) return n; \\n        int i =7;\\n        n = n-6;\\n        int ans =0;\\n        while(n){\\n            if( isUgly(i)){\\n                n--;\\n                if( n==0)\\n                    ans =i;\\n            }\\n            i++;\\n        }\\n        return ans;\\n}\\n```\\n\\n\\n***Using Set  and Recursion***\\n\\n```\\n\\tvoid solve( set<long long> &s, long long num){\\n        if(num >=INT_MAX) return;\\n        if( s.find(num)!=s.end()) return;\\n        s.insert(num);\\n        solve(s, num*2);\\n        solve(s, num*3);\\n        solve(s, num*5);\\n    }\\n    int nthUglyNumber(int n) {\\n        set<long long> s;\\n        solve( s, 1);\\n        int ans =n;\\n        for( auto i: s){\\n            n--;\\n            if( n==0) ans = i;\\n        }\\n        return ans;\\n    }\\n```\\n\\n***Using three - pointer and an array/vector - optimal solution***\\n```\\n\\tint nthUglyNumber(int n) {\\n        vector<int> ans(n, 0);\\n        ans[0] =1;\\n        int p2=0;\\n        int p3=0;\\n        int p5=0;\\n       for(int i=1;i<n;++i){\\n            int el = min({ans[p2]*2, ans[p3]*3, ans[p5]*5});\\n            ans[i] =el;\\n            if( ans[p2]*2==el) p2++;\\n            if( ans[p3]*3==el) p3++;\\n            if( ans[p5]*5==el) p5++;\\n        }\\n        return ans[n-1];\\n    }\\n```",
                "solutionTags": [
                    "C++",
                    "C",
                    "Dynamic Programming",
                    "Recursion",
                    "Ordered Set"
                ],
                "code": "```\\nbool isUgly(int n) {\\n        if(n<=0) return false;\\n        for(int i=2; i<6 &&n; i++){\\n            while( n%i ==0){\\n                n/=i;\\n            }\\n        }\\n        return n==1;\\n}\\nint nthUglyNumber(int n) {\\n        if (n<=6) return n; \\n        int i =7;\\n        n = n-6;\\n        int ans =0;\\n        while(n){\\n            if( isUgly(i)){\\n                n--;\\n                if( n==0)\\n                    ans =i;\\n            }\\n            i++;\\n        }\\n        return ans;\\n}\\n```\n```\\n\\tvoid solve( set<long long> &s, long long num){\\n        if(num >=INT_MAX) return;\\n        if( s.find(num)!=s.end()) return;\\n        s.insert(num);\\n        solve(s, num*2);\\n        solve(s, num*3);\\n        solve(s, num*5);\\n    }\\n    int nthUglyNumber(int n) {\\n        set<long long> s;\\n        solve( s, 1);\\n        int ans =n;\\n        for( auto i: s){\\n            n--;\\n            if( n==0) ans = i;\\n        }\\n        return ans;\\n    }\\n```\n```\\n\\tint nthUglyNumber(int n) {\\n        vector<int> ans(n, 0);\\n        ans[0] =1;\\n        int p2=0;\\n        int p3=0;\\n        int p5=0;\\n       for(int i=1;i<n;++i){\\n            int el = min({ans[p2]*2, ans[p3]*3, ans[p5]*5});\\n            ans[i] =el;\\n            if( ans[p2]*2==el) p2++;\\n            if( ans[p3]*3==el) p3++;\\n            if( ans[p5]*5==el) p5++;\\n        }\\n        return ans[n-1];\\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2171940,
                "title": "simple-solution-in-c",
                "content": "```\\nclass Solution {\\npublic:\\n    int nthUglyNumber(int n) {\\n        vector<int>res(n);\\n        \\n        int x=0, y=0, z=0;\\n        res[0] = 1;\\n        for(int i=1; i<n; i++){\\n            res[i] = min(res[x]*2, min(res[y]*3,res[z]*5));\\n            \\n            if(res[i] == res[x]*2) x++;\\n            if(res[i] == res[y]*3) y++;\\n            if(res[i] == res[z]*5) z++;\\n            \\n        }\\n        \\n        return res[n-1];\\n    }\\n};\\n```",
                "solutionTags": [
                    "C",
                    "Dynamic Programming"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int nthUglyNumber(int n) {\\n        vector<int>res(n);\\n        \\n        int x=0, y=0, z=0;\\n        res[0] = 1;\\n        for(int i=1; i<n; i++){\\n            res[i] = min(res[x]*2, min(res[y]*3,res[z]*5));\\n            \\n            if(res[i] == res[x]*2) x++;\\n            if(res[i] == res[y]*3) y++;\\n            if(res[i] == res[z]*5) z++;\\n            \\n        }\\n        \\n        return res[n-1];\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2074754,
                "title": "java-dp-optimized",
                "content": "```\\nclass Solution {\\n    public int nthUglyNumber(int n) {\\n\\n        int[] dp = new int[n+1];\\n        dp[1] = 1;\\n        \\n        int p2 = 1;\\n        int p3 = 1;\\n        int p5 = 1;\\n        \\n        for(int i=2; i<=n; i++) {\\n            int f1 = 2*dp[p2];\\n            int f2 = 3*dp[p3];\\n            int f3 = 5*dp[p5];\\n            \\n            int min = Math.min(f1, Math.min(f2,f3));\\n            dp[i] = min;\\n            \\n            if(min == f1) {\\n                p2++;\\n            }\\n            \\n            if(min == f2) {\\n                p3++;\\n            }\\n            \\n            if(min == f3) {\\n                p5++;\\n            }\\n        }\\n        return dp[n];\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Dynamic Programming"
                ],
                "code": "```\\nclass Solution {\\n    public int nthUglyNumber(int n) {\\n\\n        int[] dp = new int[n+1];\\n        dp[1] = 1;\\n        \\n        int p2 = 1;\\n        int p3 = 1;\\n        int p5 = 1;\\n        \\n        for(int i=2; i<=n; i++) {\\n            int f1 = 2*dp[p2];\\n            int f2 = 3*dp[p3];\\n            int f3 = 5*dp[p5];\\n            \\n            int min = Math.min(f1, Math.min(f2,f3));\\n            dp[i] = min;\\n            \\n            if(min == f1) {\\n                p2++;\\n            }\\n            \\n            if(min == f2) {\\n                p3++;\\n            }\\n            \\n            if(min == f3) {\\n                p5++;\\n            }\\n        }\\n        return dp[n];\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1968900,
                "title": "java-beats-100-00-memory-speed-0ms-april-2022",
                "content": "\\n\\tclass Solution {\\n\\n    public int nthUglyNumber(int n) {\\n        int c2 = 0,c3 = 0,c5 = 0;\\n        int[] dp = new int[n+1];\\n        dp[0] = 1;\\n        for(int i=1;i<=n;i++)\\n        {\\n            dp[i] = Math.min(2*dp[c2],Math.min(3*dp[c3],dp[c5]*5));\\n            if(dp[i] == 2*dp[c2])\\n                c2++;\\n            if(dp[i] == 3*dp[c3])\\n                c3++;\\n            if(dp[i] == 5*dp[c5])\\n                c5++;\\n        }\\n        return dp[n-1];\\n    }\\n\\t}",
                "solutionTags": [
                    "Java"
                ],
                "code": "class Solution {\\n\\n    public int nthUglyNumber(int n) {\\n        int c2 = 0,c3 = 0,c5 = 0;\\n        int[] dp = new int[n+1];\\n        dp[0] = 1;\\n        for(int i=1;i<=n;i++)\\n        {\\n            dp[i] = Math.min(2*dp[c2],Math.min(3*dp[c3],dp[c5]*5));\\n            if(dp[i] == 2*dp[c2])\\n                c2++;\\n            if(dp[i] == 3*dp[c3])\\n                c3++;\\n            if(dp[i] == 5*dp[c5])\\n                c5++;\\n        }",
                "codeTag": "Java"
            },
            {
                "id": 1899858,
                "title": "javascript-solution",
                "content": "```\\n/**\\n * @param {number} n\\n * @return {number}\\n */\\nvar nthUglyNumber = function(n) {\\n    let dp = [1]\\n    let c2 = c3 = c5 = 0\\n    for (let i = 1; i < n; i++) {\\n        dp[i] = Math.min(2 * dp[c2], 3 * dp[c3], 5 * dp[c5])\\n        if (2 * dp[c2] === dp[i]) c2++\\n        if (3 * dp[c3] === dp[i]) c3++\\n        if (5 * dp[c5] === dp[i]) c5++\\n    }\\n    return dp[n - 1]\\n};\\n```",
                "solutionTags": [
                    "JavaScript",
                    "Dynamic Programming"
                ],
                "code": "```\\n/**\\n * @param {number} n\\n * @return {number}\\n */\\nvar nthUglyNumber = function(n) {\\n    let dp = [1]\\n    let c2 = c3 = c5 = 0\\n    for (let i = 1; i < n; i++) {\\n        dp[i] = Math.min(2 * dp[c2], 3 * dp[c3], 5 * dp[c5])\\n        if (2 * dp[c2] === dp[i]) c2++\\n        if (3 * dp[c3] === dp[i]) c3++\\n        if (5 * dp[c5] === dp[i]) c5++\\n    }\\n    return dp[n - 1]\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1788305,
                "title": "c-solution-o-n-space-faster-approach-easy-to-understand",
                "content": "class Solution {\\npublic:\\n\\n    int nthUglyNumber(int n) {\\n       vector<int> res(1,1);\\n        int i=0, j=0, k=0;\\n        while(res.size()<n) {\\n            res.push_back(min(res[i]*2, min(res[j]*3, res[k]*5)));\\n            if(res.back()==res[i]*2)\\n                i++;\\n            if(res.back()==res[j]*3)\\n                j++;\\n            if(res.back()==res[k]*5)\\n                k++;\\n        }\\n     return res[n-1];\\n    }\\n};\\n// if(find helpful) {\\ndo upvote(); // thanks\\n}",
                "solutionTags": [
                    "Dynamic Programming"
                ],
                "code": "class Solution {\\npublic:\\n\\n    int nthUglyNumber(int n) {\\n       vector<int> res(1,1);\\n        int i=0, j=0, k=0;\\n        while(res.size()<n) {\\n            res.push_back(min(res[i]*2, min(res[j]*3, res[k]*5)));\\n            if(res.back()==res[i]*2)\\n                i++;\\n            if(res.back()==res[j]*3)\\n                j++;\\n            if(res.back()==res[k]*5)\\n                k++;\\n        }",
                "codeTag": "Java"
            },
            {
                "id": 1782747,
                "title": "python-o-n-solution-o-n-space",
                "content": "**Do Upvote if you like :)** \\uD83D\\uDE0A\\uD83D\\uDC4D\\n\\n```\\nclass Solution:\\n    def nthUglyNumber(self, n: int) -> int:\\n        \\n\\t\\t# base case\\n        if n == 1:\\n            return 1\\n        \\n\\t\\t# list containing all ugly numbers\\n        ugly = [1]\\n        \\n        l2, l3, l5 = [1], [1], [1]\\n        \\n\\t\\t# The pointers is to maintain the order of the ugly numbers\\n        p2, p3, p5 = 0, 0, 0\\n        \\n        i = 1\\n        while i < n:\\n            \\n\\t\\t\\t# An ugly number must be multiplied by either 2, 3, or 5 from a smaller ugly number.\\n            a = l2[p2] * 2\\n            b = l3[p3] * 3\\n            c = l5[p5] * 5\\n            \\n\\t\\t\\t# if we have Uk, the kth ugly number. Then Uk+1 must be Min(L1 * 2, L2 * 3, L3 * 5).\\n            m = min(a, b, c)\\n            \\n\\t\\t\\t# if repeat then no need to append into ugly just need to maintain pointer\\n            if m == ugly[-1]:\\n\\t\\t\\t\\n                if a == m:\\n                    p2 += 1\\n                \\n                elif b == m:\\n                    p3 += 1\\n                \\n                else:\\n                    p5 += 1\\n                \\n                continue\\n                \\n            ugly.append(m)\\n            i += 1\\n            \\n            l2.append(m)\\n            l3.append(m)\\n            l5.append(m)\\n            \\n            if a == m:\\n                p2 += 1\\n            \\n            elif b == m:\\n                p3 += 1\\n            \\n            else:\\n                p5 += 1\\n        \\n        \\n        return (ugly[-1])\\n```",
                "solutionTags": [
                    "Hash Table",
                    "Math"
                ],
                "code": "```\\nclass Solution:\\n    def nthUglyNumber(self, n: int) -> int:\\n        \\n\\t\\t# base case\\n        if n == 1:\\n            return 1\\n        \\n\\t\\t# list containing all ugly numbers\\n        ugly = [1]\\n        \\n        l2, l3, l5 = [1], [1], [1]\\n        \\n\\t\\t# The pointers is to maintain the order of the ugly numbers\\n        p2, p3, p5 = 0, 0, 0\\n        \\n        i = 1\\n        while i < n:\\n            \\n\\t\\t\\t# An ugly number must be multiplied by either 2, 3, or 5 from a smaller ugly number.\\n            a = l2[p2] * 2\\n            b = l3[p3] * 3\\n            c = l5[p5] * 5\\n            \\n\\t\\t\\t# if we have Uk, the kth ugly number. Then Uk+1 must be Min(L1 * 2, L2 * 3, L3 * 5).\\n            m = min(a, b, c)\\n            \\n\\t\\t\\t# if repeat then no need to append into ugly just need to maintain pointer\\n            if m == ugly[-1]:\\n\\t\\t\\t\\n                if a == m:\\n                    p2 += 1\\n                \\n                elif b == m:\\n                    p3 += 1\\n                \\n                else:\\n                    p5 += 1\\n                \\n                continue\\n                \\n            ugly.append(m)\\n            i += 1\\n            \\n            l2.append(m)\\n            l3.append(m)\\n            l5.append(m)\\n            \\n            if a == m:\\n                p2 += 1\\n            \\n            elif b == m:\\n                p3 += 1\\n            \\n            else:\\n                p5 += 1\\n        \\n        \\n        return (ugly[-1])\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1769315,
                "title": "ugly-number-ii",
                "content": "```\\nclass Solution {\\npublic:\\n    int nthUglyNumber(int n) {\\n        int dp[n+1];\\n      \\n        dp[1]=1;\\n        int p1=1;\\n        int p3=1;\\n        int p5=1;\\n        for(int i=2;i<=n;i++){\\n            int f1=2*dp[p1];\\n            int f2=3*dp[p3];\\n            int f3=5*dp[p5];\\n            int min_=min(f1,min(f2,f3));\\n            dp[i]=min_;\\n            if(f1==min_){\\n                p1++;\\n            }\\n            if(f2==min_){\\n                p3++;\\n            }\\n              if(f3==min_){\\n                p5++;\\n            }\\n        }\\n        return dp[n];\\n    }\\n};\\n```",
                "solutionTags": [
                    "C",
                    "Dynamic Programming"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int nthUglyNumber(int n) {\\n        int dp[n+1];\\n      \\n        dp[1]=1;\\n        int p1=1;\\n        int p3=1;\\n        int p5=1;\\n        for(int i=2;i<=n;i++){\\n            int f1=2*dp[p1];\\n            int f2=3*dp[p3];\\n            int f3=5*dp[p5];\\n            int min_=min(f1,min(f2,f3));\\n            dp[i]=min_;\\n            if(f1==min_){\\n                p1++;\\n            }\\n            if(f2==min_){\\n                p3++;\\n            }\\n              if(f3==min_){\\n                p5++;\\n            }\\n        }\\n        return dp[n];\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1696988,
                "title": "easy-c-solution-3ms",
                "content": "class Solution {\\npublic:\\n    int nthUglyNumber(int n) {\\n        vector<int> dp(n);\\n        dp[0]=1;\\n        int p2=0;\\n        int p3=0;\\n        int p5=0;\\n        \\n        for(int i=1;i<n;i++)\\n        {\\n            int multipletwo=dp[p2]*2;\\n            int multiplethree=dp[p3]*3;\\n            int multiplefive=dp[p5]*5;\\n            \\n            dp[i]=min(multipletwo,min(multiplethree,multiplefive));\\n            if(dp[i]==multipletwo)p2++;\\n            if(dp[i]==multiplethree)p3++;\\n            if(dp[i]==multiplefive)p5++;\\n        }\\n        return dp[n-1];\\n    }\\n};",
                "solutionTags": [
                    "C",
                    "Dynamic Programming"
                ],
                "code": "class Solution {\\npublic:\\n    int nthUglyNumber(int n) {\\n        vector<int> dp(n);\\n        dp[0]=1;\\n        int p2=0;\\n        int p3=0;\\n        int p5=0;\\n        \\n        for(int i=1;i<n;i++)\\n        {\\n            int multipletwo=dp[p2]*2;\\n            int multiplethree=dp[p3]*3;\\n            int multiplefive=dp[p5]*5;\\n            \\n            dp[i]=min(multipletwo,min(multiplethree,multiplefive));\\n            if(dp[i]==multipletwo)p2++;\\n            if(dp[i]==multiplethree)p3++;\\n            if(dp[i]==multiplefive)p5++;\\n        }",
                "codeTag": "Java"
            },
            {
                "id": 1663737,
                "title": "c-soln-dp-approach-using-prime-factorisation",
                "content": "**Please upvote if you find helpful!**\\n\\n```\\nclass Solution {\\npublic:\\n    int nthUglyNumber(int n) {\\n        int ugly[n];\\n        int i2=0,i3=0,i5=0;\\n        int next2=2, next3=3, next5=5;\\n        ugly[0]=1;\\n        for(int i=1; i<n; i++)\\n        {\\n            ugly[i] = min(next2, min(next3, next5));\\n            if(ugly[i] == next2)\\n            {\\n                i2++;\\n                next2=2*ugly[i2];\\n            }\\n            if(ugly[i] == next3)\\n            {\\n                i3++;\\n                next3=3*ugly[i3];\\n            }\\n            if(ugly[i] == next5)\\n            {\\n                i5++;\\n                next5=5*ugly[i5];\\n            }\\n        }\\n        return ugly[n-1];\\n    }\\n};\\n```",
                "solutionTags": [
                    "C",
                    "Dynamic Programming"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int nthUglyNumber(int n) {\\n        int ugly[n];\\n        int i2=0,i3=0,i5=0;\\n        int next2=2, next3=3, next5=5;\\n        ugly[0]=1;\\n        for(int i=1; i<n; i++)\\n        {\\n            ugly[i] = min(next2, min(next3, next5));\\n            if(ugly[i] == next2)\\n            {\\n                i2++;\\n                next2=2*ugly[i2];\\n            }\\n            if(ugly[i] == next3)\\n            {\\n                i3++;\\n                next3=3*ugly[i3];\\n            }\\n            if(ugly[i] == next5)\\n            {\\n                i5++;\\n                next5=5*ugly[i5];\\n            }\\n        }\\n        return ugly[n-1];\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1630460,
                "title": "python3-simple-dp-solution-with-comments",
                "content": "\\'\\'\\'\\nLet me try to explain this using an example. Let\\'s say we have the first 3 ugly numbers 1, 2, 3. What would be the next number? Given the definition, the next number has to be the the smallest number among 2*(1,2,3), 3*(1,2,3), 5*(1,2,3). Obviously, the smallest number is 2 * 1 = 2. But wait, 2 is already in there. So precisely speaking, the next number has to be the the smallest number among all the existing numbers multiplied by 2,3,5 that isn\\'t in the list already. Now, we can traverse all numbers and maintain a hashset if we want, but it would become O(N^2). Good news is that we can solve this in a DP-like approach. First, we assume there is only one number in the list, which is 1. The next number is Min(2 * 1, 3 * 1, 5 * 1)=2 and it is not in the list. Because we have already considered 2*1 (we move the pointer to its next position, which is 2), now we only need to consider 2 * 2, 3 * 1, 5 * 1 in the next iteration. This way, we don\\'t have to worry about finding a number that is already in the list.\\n\\n\\'\\'\\'\\n```\\nclass Solution:\\n    def nthUglyNumber(self, n: int) -> int:\\n        l = [1]\\n        p2, p3, p5 = 0, 0, 0\\n    \\n        for i in range(1, n):\\n\\t\\t\\t# get the next number\\n            next_num = min(2*l[p2], min(3*l[p3], 5*l[p5]))\\n            l.append(next_num)\\n\\t\\t\\t# increase pointer for which the number matches [see above explanation]\\n            if next_num == 2 * l[p2]:\\n                p2 += 1\\n            if next_num == 3 * l[p3]:\\n                p3 += 1\\n            if next_num == 5 * l[p5]:\\n                p5 += 1\\n\\n        return l[n-1]\\n",
                "solutionTags": [
                    "Python3",
                    "Dynamic Programming"
                ],
                "code": "\\'\\'\\'\\nLet me try to explain this using an example. Let\\'s say we have the first 3 ugly numbers 1, 2, 3. What would be the next number? Given the definition, the next number has to be the the smallest number among 2*(1,2,3), 3*(1,2,3), 5*(1,2,3). Obviously, the smallest number is 2 * 1 = 2. But wait, 2 is already in there. So precisely speaking, the next number has to be the the smallest number among all the existing numbers multiplied by 2,3,5 that isn\\'t in the list already. Now, we can traverse all numbers and maintain a hashset if we want, but it would become O(N^2). Good news is that we can solve this in a DP-like approach. First, we assume there is only one number in the list, which is 1. The next number is Min(2 * 1, 3 * 1, 5 * 1)=2 and it is not in the list. Because we have already considered 2*1 (we move the pointer to its next position, which is 2), now we only need to consider 2 * 2, 3 * 1, 5 * 1 in the next iteration. This way, we don\\'t have to worry about finding a number that is already in the list.\\n\\n\\'\\'\\'\\n```\\nclass Solution:\\n    def nthUglyNumber(self, n: int) -> int:\\n        l = [1]\\n        p2, p3, p5 = 0, 0, 0\\n    \\n        for i in range(1, n):\\n\\t\\t\\t# get the next number\\n            next_num = min(2*l[p2], min(3*l[p3], 5*l[p5]))\\n            l.append(next_num)\\n\\t\\t\\t# increase pointer for which the number matches [see above explanation]\\n            if next_num == 2 * l[p2]:\\n                p2 += 1\\n            if next_num == 3 * l[p3]:\\n                p3 += 1\\n            if next_num == 5 * l[p5]:\\n                p5 += 1\\n\\n        return l[n-1]\\n",
                "codeTag": "Java"
            },
            {
                "id": 1568310,
                "title": "simple-python-solution-dp-faster-than-94-23-python-submissions",
                "content": "```\\nclass Solution:\\n    \\n    def nthUglyNumber(self, n: int) -> int:\\n        \\n        uglyDp = [0] * n\\n        \\n        ptr2 = 0\\n        ptr3 = 0\\n        ptr5 = 0\\n        \\n        uglyDp[0] = 1\\n        \\n        for i in range(1,n):\\n            t2 = uglyDp[ptr2] * 2\\n            t3 = uglyDp[ptr3] * 3\\n            t5 = uglyDp[ptr5] * 5\\n            \\n            m = min(t2,t3,t5)\\n            \\n            uglyDp[i] = m\\n            \\n            if t2 == m:\\n                ptr2 += 1\\n            if t3 == m:\\n                ptr3 += 1\\n            if t5 == m:\\n                ptr5 += 1\\n        \\n        \\n        return uglyDp[-1]\\n        \\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution:\\n    \\n    def nthUglyNumber(self, n: int) -> int:\\n        \\n        uglyDp = [0] * n\\n        \\n        ptr2 = 0\\n        ptr3 = 0\\n        ptr5 = 0\\n        \\n        uglyDp[0] = 1\\n        \\n        for i in range(1,n):\\n            t2 = uglyDp[ptr2] * 2\\n            t3 = uglyDp[ptr3] * 3\\n            t5 = uglyDp[ptr5] * 5\\n            \\n            m = min(t2,t3,t5)\\n            \\n            uglyDp[i] = m\\n            \\n            if t2 == m:\\n                ptr2 += 1\\n            if t3 == m:\\n                ptr3 += 1\\n            if t5 == m:\\n                ptr5 += 1\\n        \\n        \\n        return uglyDp[-1]\\n        \\n```",
                "codeTag": "Java"
            },
            {
                "id": 1555387,
                "title": "c-3-pointers-for-2-3-and-5",
                "content": "```\\nint nthUglyNumber(int n) {\\n        \\n        vector<int>dp = { 1 };\\n        \\n        int c2 = 0, c3 = 0, c5 = 0;\\n        \\n        int i = 1; //i is starting  from 1 because we\\'ve already added 1 element in list\\n        \\n        while(i < n) {\\n            int next = min({ 2*dp[c2], 3*dp[c3], 5*dp[c5] });\\n            dp.push_back(next);\\n            if(next == 2*dp[c2]) c2++;\\n            if(next == 3*dp[c3]) c3++;\\n            if(next == 5*dp[c5]) c5++;\\n            i++;\\n        }\\n        \\n        return dp.back();\\n    }\\n```",
                "solutionTags": [
                    "C++",
                    "C"
                ],
                "code": "```\\nint nthUglyNumber(int n) {\\n        \\n        vector<int>dp = { 1 };\\n        \\n        int c2 = 0, c3 = 0, c5 = 0;\\n        \\n        int i = 1; //i is starting  from 1 because we\\'ve already added 1 element in list\\n        \\n        while(i < n) {\\n            int next = min({ 2*dp[c2], 3*dp[c3], 5*dp[c5] });\\n            dp.push_back(next);\\n            if(next == 2*dp[c2]) c2++;\\n            if(next == 3*dp[c3]) c3++;\\n            if(next == 5*dp[c5]) c5++;\\n            i++;\\n        }\\n        \\n        return dp.back();\\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1541906,
                "title": "dynamic-programming-c-easy",
                "content": "**Approach :**\\nAn ugly number must be multiplied by either 2, 3, or 5 from a smaller ugly number so this is an ideal dp problem.\\nas mentioned in the hint :\\nThe key is how to maintain the order of the ugly numbers. Try a similar approach of merging from three sorted lists: L1, L2, and L3.Assume you have Uk, the kth ugly number. Then Uk+1 must be Min(L1 * 2, L2 * 3, L3 * 5).\\n\\n```\\nclass Solution {\\npublic:\\n    int nthUglyNumber(int n) {\\n        if(n<=0) return 0;\\n        if(n==1) return 1;\\n        int a=0,b=0,c=0;\\n        vector<int>dp(n);\\n        \\n        dp[0]=1;\\n        \\n        // dp[0]=1 because 1 has no prime factors,\\n        // therefore all of its prime factors are limited to 2, 3, and 5.\\n        \\n        for(int i=1;i<n;i++){\\n            \\n            dp[i]=min(dp[a]*2,min(dp[b]*3,dp[c]*5));\\n            \\n//             check for multiple of 2 3 5 \\n            if(dp[i]==dp[a]*2)a++;\\n            if(dp[i]==dp[b]*3)b++;\\n            if(dp[i]==dp[c]*5)c++;\\n        }\\n        return dp[n-1];\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "C"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int nthUglyNumber(int n) {\\n        if(n<=0) return 0;\\n        if(n==1) return 1;\\n        int a=0,b=0,c=0;\\n        vector<int>dp(n);\\n        \\n        dp[0]=1;\\n        \\n        // dp[0]=1 because 1 has no prime factors,\\n        // therefore all of its prime factors are limited to 2, 3, and 5.\\n        \\n        for(int i=1;i<n;i++){\\n            \\n            dp[i]=min(dp[a]*2,min(dp[b]*3,dp[c]*5));\\n            \\n//             check for multiple of 2 3 5 \\n            if(dp[i]==dp[a]*2)a++;\\n            if(dp[i]==dp[b]*3)b++;\\n            if(dp[i]==dp[c]*5)c++;\\n        }\\n        return dp[n-1];\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1466426,
                "title": "c-easy-simple-clean-code-without-dp-using-set",
                "content": "```\\nclass Solution {\\npublic:\\n    int nthUglyNumber(int n) {\\n        set<long> st;\\n        st.insert(1);\\n        long x = 1;\\n        for(int i = 1; i <= n; i++){\\n            x = *st.begin();\\n            st.erase(st.begin());\\n            st.insert( x * 2);\\n            st.insert( x * 3);\\n            st.insert( x * 5);\\n        }\\n        return x;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C",
                    "Ordered Set"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int nthUglyNumber(int n) {\\n        set<long> st;\\n        st.insert(1);\\n        long x = 1;\\n        for(int i = 1; i <= n; i++){\\n            x = *st.begin();\\n            st.erase(st.begin());\\n            st.insert( x * 2);\\n            st.insert( x * 3);\\n            st.insert( x * 5);\\n        }\\n        return x;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1395609,
                "title": "easy-beautiful-fully-explained-solution-for-beginners",
                "content": "**FOLLOW THESE SIMPLE STEPS:-**\\n* STEP1:- An ugly number when multiplied by 2 ,3 ,5 is also an ugly number \\n* STEP2:- In order to find the pattern of these ugly numbers in sequence we need 3 variables a,b,c\\n* STEP3:- To eliminate cases like 3 multiplied 2 ==6  and 2multiplied3 is also 6 where 2 and 3 both are ugly numbers and we do not need both in our sequence hence check whether the last added number is not the currently added number .\\n\\n* STEP4:- Just need to put the above thoughts into code :)\\n\\n```\\nclass Solution {\\npublic:\\n    int nthUglyNumber(int n) {\\n       vector<int>v; v.push_back(1); \\n\\t   int a=0 ,b=0 ,c=0;\\n         while(v.size()<n)\\n        {\\n            int x=min(v[a]*2 ,min(v[b]*3 ,v[c]*5));\\n\\t\\t\\t\\n            if(v[v.size()-1]!=x)\\n            v.push_back(x);\\n            \\n            if(x==v[a]*2)\\n                a++;\\n            else if(x==v[b]*3)\\n                b++;\\n           else c++;\\n        }\\n        \\n        return v[v.size()-1];\\n* \\n```\\n\\n",
                "solutionTags": [
                    "C"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int nthUglyNumber(int n) {\\n       vector<int>v; v.push_back(1); \\n\\t   int a=0 ,b=0 ,c=0;\\n         while(v.size()<n)\\n        {\\n            int x=min(v[a]*2 ,min(v[b]*3 ,v[c]*5));\\n\\t\\t\\t\\n            if(v[v.size()-1]!=x)\\n            v.push_back(x);\\n            \\n            if(x==v[a]*2)\\n                a++;\\n            else if(x==v[b]*3)\\n                b++;\\n           else c++;\\n        }\\n        \\n        return v[v.size()-1];\\n* \\n```",
                "codeTag": "Java"
            },
            {
                "id": 1335260,
                "title": "java-priority-queue-o-nlogn",
                "content": "Solution using map and priority queue:\\n\\n```\\nclass Solution {\\n    public int nthUglyNumber(int n) {\\n        PriorityQueue<Long> pq=new PriorityQueue<Long>();\\n        HashMap<Long, Boolean> map=new HashMap<>();\\n        \\n        pq.add((long) 1);\\n        map.put((long) 1, true);\\n        long res=0;\\n        \\n        for(int i=0;i<n;i++)\\n        {\\n            res=pq.poll();\\n            \\n            if(map.containsKey(res*2)==false)\\n            {\\n                pq.add(res*2);\\n                map.put(res*2, true);\\n            }\\n            \\n            if(map.containsKey(res*3)==false)\\n            {\\n                pq.add(res*3);\\n                map.put(res*3, true);\\n            }\\n            \\n            if(map.containsKey(res*5)==false)\\n            {\\n                pq.add(res*5);\\n                map.put(res*5, true);\\n            }\\n            \\n        }\\n        \\n        return (int) res;\\n    }\\n}\\n```\\n",
                "solutionTags": [
                    "Java",
                    "Heap (Priority Queue)"
                ],
                "code": "```\\nclass Solution {\\n    public int nthUglyNumber(int n) {\\n        PriorityQueue<Long> pq=new PriorityQueue<Long>();\\n        HashMap<Long, Boolean> map=new HashMap<>();\\n        \\n        pq.add((long) 1);\\n        map.put((long) 1, true);\\n        long res=0;\\n        \\n        for(int i=0;i<n;i++)\\n        {\\n            res=pq.poll();\\n            \\n            if(map.containsKey(res*2)==false)\\n            {\\n                pq.add(res*2);\\n                map.put(res*2, true);\\n            }\\n            \\n            if(map.containsKey(res*3)==false)\\n            {\\n                pq.add(res*3);\\n                map.put(res*3, true);\\n            }\\n            \\n            if(map.containsKey(res*5)==false)\\n            {\\n                pq.add(res*5);\\n                map.put(res*5, true);\\n            }\\n            \\n        }\\n        \\n        return (int) res;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1279348,
                "title": "java-o-n-using-dp",
                "content": "```\\n\\nclass Solution {\\n    public int nthUglyNumber(int n) {\\n        int[] seq = new int[n];\\n        \\n        int i2=0, i3=0, i5=0;\\n        int next2=2, next3=3, next5=5;\\n        \\n        seq[0] = 1;\\n        \\n        for(int i=1; i<n; i++) {\\n            seq[i] = Math.min(Math.min(seq[i2]*2, seq[i3]*3), seq[i5]*5);\\n            if(seq[i] == seq[i2]*2) {\\n                i2++;\\n            }\\n            if(seq[i] == seq[i3]*3) {\\n                i3++;\\n            }\\n            if(seq[i] == seq[i5]*5) {\\n                i5++;\\n            }\\n        }\\n        \\n        return seq[n-1];\\n    }\\n}\\n\\n```\\n\\n```TC: O(n) SC: O(n)```",
                "solutionTags": [],
                "code": "```\\n\\nclass Solution {\\n    public int nthUglyNumber(int n) {\\n        int[] seq = new int[n];\\n        \\n        int i2=0, i3=0, i5=0;\\n        int next2=2, next3=3, next5=5;\\n        \\n        seq[0] = 1;\\n        \\n        for(int i=1; i<n; i++) {\\n            seq[i] = Math.min(Math.min(seq[i2]*2, seq[i3]*3), seq[i5]*5);\\n            if(seq[i] == seq[i2]*2) {\\n                i2++;\\n            }\\n            if(seq[i] == seq[i3]*3) {\\n                i3++;\\n            }\\n            if(seq[i] == seq[i5]*5) {\\n                i5++;\\n            }\\n        }\\n        \\n        return seq[n-1];\\n    }\\n}\\n\\n```\n```TC: O(n) SC: O(n)```",
                "codeTag": "Java"
            },
            {
                "id": 1246648,
                "title": "100-faster-easy-to-understand-c-solution-using-dp",
                "content": "```\\nclass Solution {\\npublic:\\n    int nthUglyNumber(int n) {\\n        int dp[n+1];\\n      dp[0]=0;\\n      dp[1]=1;\\n      int i2=1,i3=1,i5=1;\\n      int next2=2;\\n      int next3=3;\\n      int next5=5;\\n      int next_multiple=1;\\n      for(int i=2;i<=n;i++)\\n      {\\n        next_multiple=min(next2,min(next3,next5));\\n        dp[i]=next_multiple;\\n        if(next_multiple==next2)\\n          i2++,next2=dp[i2]*2;\\n        if(next_multiple==next3)\\n          i3++,next3=dp[i3]*3;\\n        if(next_multiple==next5)\\n          i5++,next5=dp[i5]*5;\\n      }return next_multiple;\\n    }\\n};\\ndo upvote if you find it useful....\\n```",
                "solutionTags": [
                    "C++",
                    "C",
                    "Dynamic Programming"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int nthUglyNumber(int n) {\\n        int dp[n+1];\\n      dp[0]=0;\\n      dp[1]=1;\\n      int i2=1,i3=1,i5=1;\\n      int next2=2;\\n      int next3=3;\\n      int next5=5;\\n      int next_multiple=1;\\n      for(int i=2;i<=n;i++)\\n      {\\n        next_multiple=min(next2,min(next3,next5));\\n        dp[i]=next_multiple;\\n        if(next_multiple==next2)\\n          i2++,next2=dp[i2]*2;\\n        if(next_multiple==next3)\\n          i3++,next3=dp[i3]*3;\\n        if(next_multiple==next5)\\n          i5++,next5=dp[i5]*5;\\n      }return next_multiple;\\n    }\\n};\\ndo upvote if you find it useful....\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1048918,
                "title": "c-constexpr-approach-0-ms-faster-than-100-00",
                "content": "This approach uses a c++ constexpr to calculate at compile-time all solutions. Indeed pre-calc is one suggested approach by the editorial.\\nAt runtime, we are merely   have to get the already calculated solution from an array.\\n\\n```\\nclass Solution {\\n     \\n    template<int N>\\n    struct pre_calc {\\n        array<int, N+1> uglies;\\n      constexpr  pre_calc():uglies()  {\\n          \\n          int idx2 = 0;\\n          int idx3 = 0;\\n          int idx5 = 0;\\n          int val = 1;\\n          uglies[0] = val;\\n          for (int idx = 1; idx <= N; ++idx) {\\n              const auto val2 = uglies[idx2] * 2;\\n              const auto val3 = uglies[idx3] * 3;\\n              const auto val5 = uglies[idx5] * 5;              \\n              uglies[idx] = min(val2, min(val3, val5));\\n              //no else\\n              if (val2 == uglies[idx]) ++idx2;\\n              if (val3 == uglies[idx]) ++idx3;\\n              if (val5 == uglies[idx]) ++idx5;\\n          }\\n      }  \\n    };\\n    public:\\n    int nthUglyNumber(int n) {\\n        constexpr auto uglies = pre_calc<1690>();\\n        \\n        return uglies.uglies[n - 1];\\n    }\\n};",
                "solutionTags": [
                    "C"
                ],
                "code": "class Solution {\\n     \\n    template<int N>\\n    struct pre_calc {\\n        array<int, N+1> uglies;\\n      constexpr  pre_calc():uglies()  {\\n          \\n          int idx2 = 0;\\n          int idx3 = 0;\\n          int idx5 = 0;\\n          int val = 1;\\n          uglies[0] = val;\\n          for (int idx = 1; idx <= N; ++idx) {\\n              const auto val2 = uglies[idx2] * 2;\\n              const auto val3 = uglies[idx3] * 3;\\n              const auto val5 = uglies[idx5] * 5;              \\n              uglies[idx] = min(val2, min(val3, val5));\\n              //no else\\n              if (val2 == uglies[idx]) ++idx2;\\n              if (val3 == uglies[idx]) ++idx3;\\n              if (val5 == uglies[idx]) ++idx5;\\n          }",
                "codeTag": "Java"
            },
            {
                "id": 1010866,
                "title": "c-faster-than-98-memory-better-than-90",
                "content": "\\'\\'\\'\\nclass Solution {\\npublic:\\n    int nthUglyNumber(int n) {\\n        \\n        long long arr[n];\\n\\t    arr[0]=1;\\n\\t    int i2=0,i3=0,i5=0;\\n\\t    for(int i=1;i<n;i++)\\n\\t    {\\n\\t        arr[i]=min(arr[i2]*2,min(arr[i3]*3,arr[i5]*5));\\n\\t        if(arr[i2]*2==arr[i])\\n\\t        {\\n\\t            i2++;\\n\\t        }\\n\\t        if(arr[i3]*3==arr[i])\\n\\t        {\\n\\t            i3++;\\n\\t        }\\n\\t        if(arr[i5]*5==arr[i])\\n\\t        {\\n\\t            i5++;\\n\\t        }\\n\\t    }\\n        return arr[n-1];\\n    }\\n};\\n\\'\\'\\'",
                "solutionTags": [],
                "code": "class Solution {\\npublic:\\n    int nthUglyNumber(int n) {\\n        \\n        long long arr[n];\\n\\t    arr[0]=1;\\n\\t    int i2=0,i3=0,i5=0;\\n\\t    for(int i=1;i<n;i++)\\n\\t    {\\n\\t        arr[i]=min(arr[i2]*2,min(arr[i3]*3,arr[i5]*5));\\n\\t        if(arr[i2]*2==arr[i])\\n\\t        {\\n\\t            i2++;\\n\\t        }",
                "codeTag": "Java"
            },
            {
                "id": 768559,
                "title": "c-heap-solution",
                "content": "```\\n#define ll long long int\\nclass Solution {\\npublic:\\n    int nthUglyNumber(int n) {\\n        int i=0;\\n        vector<ll> arr(n, -1);\\n        priority_queue<ll, vector<ll>, greater<ll>> pq={};\\n        pq.push(1);\\n        while(!pq.empty() && arr[n-1]==-1){\\n            ll top=pq.top();\\n            pq.pop();\\n            arr[i++]=top;\\n            pq.push(top*2);\\n            pq.push(top*3);\\n            pq.push(top*5);\\n            while(!pq.empty() && top==pq.top())\\n                pq.pop();\\n        }\\n        return arr[n-1];\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\n#define ll long long int\\nclass Solution {\\npublic:\\n    int nthUglyNumber(int n) {\\n        int i=0;\\n        vector<ll> arr(n, -1);\\n        priority_queue<ll, vector<ll>, greater<ll>> pq={};\\n        pq.push(1);\\n        while(!pq.empty() && arr[n-1]==-1){\\n            ll top=pq.top();\\n            pq.pop();\\n            arr[i++]=top;\\n            pq.push(top*2);\\n            pq.push(top*3);\\n            pq.push(top*5);\\n            while(!pq.empty() && top==pq.top())\\n                pq.pop();\\n        }\\n        return arr[n-1];\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 718983,
                "title": "java-simple-easy-dynamic-programming-and-naive-approach",
                "content": "<hr>\\n\\n***UPVOTE if you like the solutions!***\\n<hr>\\n\\n**1. Dynamin Programming**\\n\\n**Results**\\n*Runtime:* 3 ms, faster than **58.45%** of Java online submissions for Ugly Number II.\\n*Memory Usage:* 37.7 MB, less than **65.66%** of Java online submissions for Ugly Number II.\\n\\n\\n```\\nclass Solution {\\n    public int nthUglyNumber(int n) {\\n        if(n==0)\\n            return -1;\\n        if(n==1)\\n            return 1;\\n        \\n        int p2=0;\\n        int p3=0;\\n        int p5=0;\\n        \\n        int dp[] = new int[n];\\n        dp[0]=1;\\n        for(int i=1;i<n;i++){\\n            dp[i] = Math.min(dp[p2]*2,Math.min(dp[p3]*3,dp[p5]*5));\\n            if(dp[i]==dp[p2]*2)\\n                p2++;\\n            if(dp[i]==dp[p3]*3)\\n                p3++;\\n            if(dp[i]==dp[p5]*5)\\n                p5++;\\n        }\\n        return dp[n-1];\\n    }\\n}\\n\\n```\\n\\n\\n<hr>\\n\\n**2. The naive approach to call isUgly for every time**\\n\\n**Result**\\n*Time Limit Exceeded*\\n```\\nclass Solution {\\n    public int nthUglyNumber(int n) {\\n        n--;\\n        int val=1,num=2;\\n        while(n>0){\\n            if(isUgly(num)){\\n                val=num;\\n                n--;\\n            }\\n            num++;\\n        }\\n        return val;\\n    }\\n    \\n    public boolean isNumUgly(int num, int arr[], int index){\\n        if(num==1)\\n            return true;\\n        if(index>=arr.length)\\n            return false;\\n        else if(num%arr[index]!=0)\\n            return isNumUgly(num,arr,index+1);\\n            \\n        num=num/arr[index];\\n        \\n        boolean b1 = isNumUgly(num,arr,index);\\n        if(b1)\\n            return true;\\n        \\n        Boolean b2 = isNumUgly(num,arr,index+1);\\n        if(b2)\\n            return true;\\n        \\n        Boolean b3 = isNumUgly(num,arr,index+2);\\n        if(b3)\\n            return true;\\n        \\n        return false;\\n    }\\n    \\n    public boolean isUgly(int num){\\n        if(num==0)\\n            return false;\\n        if(num==1)\\n            return true;\\n        int arr[] = {2,3,5};\\n        return isNumUgly(num,arr,0);\\n    }\\n}\\n```\\n",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    public int nthUglyNumber(int n) {\\n        if(n==0)\\n            return -1;\\n        if(n==1)\\n            return 1;\\n        \\n        int p2=0;\\n        int p3=0;\\n        int p5=0;\\n        \\n        int dp[] = new int[n];\\n        dp[0]=1;\\n        for(int i=1;i<n;i++){\\n            dp[i] = Math.min(dp[p2]*2,Math.min(dp[p3]*3,dp[p5]*5));\\n            if(dp[i]==dp[p2]*2)\\n                p2++;\\n            if(dp[i]==dp[p3]*3)\\n                p3++;\\n            if(dp[i]==dp[p5]*5)\\n                p5++;\\n        }\\n        return dp[n-1];\\n    }\\n}\\n\\n```\n```\\nclass Solution {\\n    public int nthUglyNumber(int n) {\\n        n--;\\n        int val=1,num=2;\\n        while(n>0){\\n            if(isUgly(num)){\\n                val=num;\\n                n--;\\n            }\\n            num++;\\n        }\\n        return val;\\n    }\\n    \\n    public boolean isNumUgly(int num, int arr[], int index){\\n        if(num==1)\\n            return true;\\n        if(index>=arr.length)\\n            return false;\\n        else if(num%arr[index]!=0)\\n            return isNumUgly(num,arr,index+1);\\n            \\n        num=num/arr[index];\\n        \\n        boolean b1 = isNumUgly(num,arr,index);\\n        if(b1)\\n            return true;\\n        \\n        Boolean b2 = isNumUgly(num,arr,index+1);\\n        if(b2)\\n            return true;\\n        \\n        Boolean b3 = isNumUgly(num,arr,index+2);\\n        if(b3)\\n            return true;\\n        \\n        return false;\\n    }\\n    \\n    public boolean isUgly(int num){\\n        if(num==0)\\n            return false;\\n        if(num==1)\\n            return true;\\n        int arr[] = {2,3,5};\\n        return isNumUgly(num,arr,0);\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 718866,
                "title": "python-solution-explained-simple-to-follow-different-approach",
                "content": "Idea is to generate the Ugly number from existing ugly number, main question is how do you maintain the ordering without having so many unnecessary/large ugly numbers. \\n\\nMy approach is to maintain a heap along with set. Maintaining extra set allows you store only relevant numbers in the heap without repetition.\\nWhenever we are processing min. number from heap, generate next possible numbers by multipying each (2,3,5) and check it that new number is already not generated then add to heap.\\n\\n```\\nimport heapq\\n\\nclass Solution:\\n    def nthUglyNumber(self, n: int) -> int:\\n        seen = {1}\\n        data = [1]\\n        cur = None\\n        \\n        for i in range(n-1):\\n            cur = heapq.heappop(data)\\n            if cur*2 not in seen:\\n                seen.add(cur*2)\\n                heapq.heappush(data, cur*2)\\n            if cur*3 not in seen:\\n                seen.add(cur*3)\\n                heapq.heappush(data, cur*3)\\n            if cur*5 not in seen:\\n                seen.add(cur*5)\\n                heapq.heappush(data, cur*5)\\n        \\n        return heapq.heappop(data)\\n```",
                "solutionTags": [
                    "Python",
                    "Python3",
                    "Heap (Priority Queue)"
                ],
                "code": "```\\nimport heapq\\n\\nclass Solution:\\n    def nthUglyNumber(self, n: int) -> int:\\n        seen = {1}\\n        data = [1]\\n        cur = None\\n        \\n        for i in range(n-1):\\n            cur = heapq.heappop(data)\\n            if cur*2 not in seen:\\n                seen.add(cur*2)\\n                heapq.heappush(data, cur*2)\\n            if cur*3 not in seen:\\n                seen.add(cur*3)\\n                heapq.heappush(data, cur*3)\\n            if cur*5 not in seen:\\n                seen.add(cur*5)\\n                heapq.heappush(data, cur*5)\\n        \\n        return heapq.heappop(data)\\n```",
                "codeTag": "Java"
            },
            {
                "id": 695409,
                "title": "python-simple-dp-solution-with-algorithm-explaination",
                "content": "```\\nclass Solution:\\n    def nthUglyNumber(self, n: int) -> int:\\n        ## RC ##\\n        ## APPROACH : DP ##\\n        ## 1. Take 3 pointers one for each 2,3,5.\\n        ## 2. init dp[0] with 1\\n        ## 3. take min of (number * ptr1, num * ptr2, num * ptr3) and push to dp and increment that min ptr.\\n        \\n\\t\\t## TIME COMPLEXITY : O(N) ##\\n\\t\\t## SPACE COMPLEXITY : O(N) ##\\n\\n        dp = [1] + [0] * (n-1)\\n        p2 = p3 = p5 = 0\\n        for i in range(1, n):\\n            dp[i] = min (dp[p2] * 2, dp[p3] * 3, dp[p5] * 5)\\n            if dp[i] == dp[p2] * 2: p2 += 1\\n            if dp[i] == dp[p3] * 3: p3 += 1\\n            if dp[i] == dp[p5] * 5: p5 += 1\\n        return dp[-1]\\n```",
                "solutionTags": [
                    "Python",
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def nthUglyNumber(self, n: int) -> int:\\n        ## RC ##\\n        ## APPROACH : DP ##\\n        ## 1. Take 3 pointers one for each 2,3,5.\\n        ## 2. init dp[0] with 1\\n        ## 3. take min of (number * ptr1, num * ptr2, num * ptr3) and push to dp and increment that min ptr.\\n        \\n\\t\\t## TIME COMPLEXITY : O(N) ##\\n\\t\\t## SPACE COMPLEXITY : O(N) ##\\n\\n        dp = [1] + [0] * (n-1)\\n        p2 = p3 = p5 = 0\\n        for i in range(1, n):\\n            dp[i] = min (dp[p2] * 2, dp[p3] * 3, dp[p5] * 5)\\n            if dp[i] == dp[p2] * 2: p2 += 1\\n            if dp[i] == dp[p3] * 3: p3 += 1\\n            if dp[i] == dp[p5] * 5: p5 += 1\\n        return dp[-1]\\n```",
                "codeTag": "Java"
            },
            {
                "id": 686744,
                "title": "c-simple-bottom-up-dp",
                "content": "class Solution {\\npublic:\\n\\n    int nthUglyNumber(int n) {\\n        int nm2,nm3,nm5;//To store next multiples of 2,3 and 5\\n        int i2=0,i3=0,i5=0;\\n        vector<int>dp(1691);\\n        dp[0]=1;\\n        for(int i=1;i<n;i++)\\n        {\\n            nm2=dp[i2]*2;\\n            nm3=dp[i3]*3;\\n            nm5=dp[i5]*5;\\n            dp[i]=min(nm2,min(nm3,nm5));\\n            if(dp[i]==nm2) i2++;//next multiple of 2 of number at pos i2 has been included\\n            if(dp[i]==nm3) i3++;//next multiple of 3 of number at pos i3 has been included\\n            if(dp[i]==nm5) i5++;//next multiple of 5 of number at pos i5 has been included\\n        }\\n        return dp[n-1];\\n    }\\n    };",
                "solutionTags": [],
                "code": "class Solution {\\npublic:\\n\\n    int nthUglyNumber(int n) {\\n        int nm2,nm3,nm5;//To store next multiples of 2,3 and 5\\n        int i2=0,i3=0,i5=0;\\n        vector<int>dp(1691);\\n        dp[0]=1;\\n        for(int i=1;i<n;i++)\\n        {\\n            nm2=dp[i2]*2;\\n            nm3=dp[i3]*3;\\n            nm5=dp[i5]*5;\\n            dp[i]=min(nm2,min(nm3,nm5));\\n            if(dp[i]==nm2) i2++;//next multiple of 2 of number at pos i2 has been included\\n            if(dp[i]==nm3) i3++;//next multiple of 3 of number at pos i3 has been included\\n            if(dp[i]==nm5) i5++;//next multiple of 5 of number at pos i5 has been included\\n        }",
                "codeTag": "Java"
            },
            {
                "id": 684988,
                "title": "heap-solution",
                "content": "```\\nimport heapq\\nclass Solution:\\n    def nthUglyNumber(self, n: int) -> int:\\n        min_heap=[1]\\n        for i in range(1,n+1):\\n            a=heapq.heappop(min_heap)\\n            if 2*a not in min_heap:\\n                 heapq.heappush(min_heap,2*a)\\n            if 3*a not in min_heap:\\n                 heapq.heappush(min_heap,3*a)\\n            if 5*a not in min_heap:\\n                 heapq.heappush(min_heap,5*a)\\n                \\n                \\n           \\n            \\n        return a\\n",
                "solutionTags": [],
                "code": "```\\nimport heapq\\nclass Solution:\\n    def nthUglyNumber(self, n: int) -> int:\\n        min_heap=[1]\\n        for i in range(1,n+1):\\n            a=heapq.heappop(min_heap)\\n            if 2*a not in min_heap:\\n                 heapq.heappush(min_heap,2*a)\\n            if 3*a not in min_heap:\\n                 heapq.heappush(min_heap,3*a)\\n            if 5*a not in min_heap:\\n                 heapq.heappush(min_heap,5*a)\\n                \\n                \\n           \\n            \\n        return a\\n",
                "codeTag": "Java"
            },
            {
                "id": 666537,
                "title": "o-n-2ms-java-copied",
                "content": "This is copied from Solution section.  Works well.  What I don\\'t understand is why should we find minmum of 2 * (prev multiplication of 2), 3 * (prev mul of 3), 5 * (prev mul of 5) and set it to current i?\\n\\nI don\\'t think it\\'s possible to come up with this solution in the span of 15-20 mins when the timer is ticking.  Atleast I cannot.  No way.\\n\\n```\\nclass Solution {\\n    public int nthUglyNumber(int n) {\\n        \\n        int nums[] = new int[n];\\n        \\n        int i2 = 0, i3 = 0, i5 = 0;\\n        \\n        nums[0] = 1;\\n        \\n        for (int i = 1; i < n; i++) {\\n            \\n            nums[i] = Math.min(nums[i2] * 2, Math.min(nums[i3] * 3, nums[i5] * 5));\\n            \\n            if (nums[i] == nums[i2] * 2) i2++;\\n            if (nums[i] == nums[i3] * 3) i3++;\\n            if (nums[i] == nums[i5] * 5) i5++;\\n        }\\n        return nums[n-1];\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    public int nthUglyNumber(int n) {\\n        \\n        int nums[] = new int[n];\\n        \\n        int i2 = 0, i3 = 0, i5 = 0;\\n        \\n        nums[0] = 1;\\n        \\n        for (int i = 1; i < n; i++) {\\n            \\n            nums[i] = Math.min(nums[i2] * 2, Math.min(nums[i3] * 3, nums[i5] * 5));\\n            \\n            if (nums[i] == nums[i2] * 2) i2++;\\n            if (nums[i] == nums[i3] * 3) i3++;\\n            if (nums[i] == nums[i5] * 5) i5++;\\n        }\\n        return nums[n-1];\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 652910,
                "title": "my-0-ms-c-solution-probably-the-simplest-one-with-explanation",
                "content": "We all know that ugly numbers are those numbers whose prime factors are only 2,3 or 5.\\nWe  need to find out the nth ugly nunmber.\\nThe first thing that comes to our mind is consider every number from 2 (since 1 is always a ugly number), and check whether it is ugly or not, if yes decrement n and run until n does not becomes 0.\\nThis approach is absolutly fine but you may see that it gives TLE, becaues for every number you are finding its prime factors, so complete time complexity of approach becomes O(n^2).\\n***BETTER APPROACH***\\nWe know one thing that 1 is always a ugly number, now if we pick 1 and assume 3 variables say m2,m3 and m5. m2 = 1 X 2, m3 = 1 X 3, m5 = 1 X 5, therefore next ugly number will be min(m2,m3,m5) i.e 2, now our answer is contained by m2 so we need to redefine it by m2 = 2X2, again take minimum and repeat process.\\nYou will get  a better understanding while you have a look at the code.\\nNow you may think why this approach works, this is because say you have 2, its prime factor is 2 only, when you multiply it with 2,3,5 you get 4,6,10 these 3 numbers also has prime factors 2,3,5 always you may figure it.\\n\\n***NOW I PRESENT YOU WITH TWO DIFFERENT SOLUTIONS ONE USING VECTOR WHICH BEATS 100% OF ALL SUBMISSION AND 0 MS TIME, WHILE ANOTHER ONE IS ALSO VERY INTERESTING TO SEE USING PRIORITY_QUEUE AND SET***\\n\\n***1***\\n```\\nclass Solution {\\npublic:\\n    int nthUglyNumber(int n) {\\n       \\n        if(n == 1)  return 1;\\n        \\n        vector<int> v(n,0);\\n        \\n        v[0] = 1;\\n        int i2,i3,i5;\\n        i2 = 0;\\n        i3 = 0;\\n        i5 = 0;\\n        \\n        int next_multiple_2 = 2*v[i2];\\n        int next_multiple_3 = 3*v[i3];\\n        int next_multiple_5 = 5*v[i5];\\n        \\n        for(int i=1;i<n;i++){\\n            \\n            int put = min(next_multiple_2,min(next_multiple_3,next_multiple_5));\\n            v[i] = put;\\n            \\n            if(put == next_multiple_2){\\n                i2++;\\n                next_multiple_2 = 2*v[i2];\\n            }\\n            \\n            if(put == next_multiple_3){\\n                i3++;\\n                next_multiple_3 = 3*v[i3];\\n            }\\n            \\n            if(put == next_multiple_5){\\n                i5++;\\n                next_multiple_5 = 5*v[i5];\\n            }\\n            \\n        }\\n        \\n        return v[n-1];\\n    }\\n};\\n```\\n***2***\\n```\\ntypedef unsigned long long int ull;\\n\\null findnthuglyNumber(int n){\\n    \\n    priority_queue<ull,vector<ull>,greater<ull>> pq;\\n    \\n    pq.push(1);\\n    unordered_set<ull> st;\\n    st.insert(1);\\n    while(n !=  0){\\n        n--;\\n        if(n == 0)  return pq.top();\\n        \\n        ull t = pq.top();\\n        pq.pop();\\n        if(st.find(t*2) == st.end()){\\n            st.insert(t*2);\\n            pq.push(t*2);\\n        }\\n        \\n        if(st.find(t*3) == st.end()){\\n            st.insert(t*3);\\n            pq.push(t*3);\\n        }\\n        \\n        if(st.find(t*5) == st.end()){\\n            st.insert(t*5);\\n            pq.push(t*5);\\n        }\\n    }\\n    return 0;\\n}\\n\\nclass Solution {\\npublic:\\n    int nthUglyNumber(int n) {\\n        return findnthuglyNumber(n);\\n    }\\n};\\n```\\ngive a like if it helps!!!!\\nhope it helps you!!!!\\n",
                "solutionTags": [
                    "C",
                    "Heap (Priority Queue)"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int nthUglyNumber(int n) {\\n       \\n        if(n == 1)  return 1;\\n        \\n        vector<int> v(n,0);\\n        \\n        v[0] = 1;\\n        int i2,i3,i5;\\n        i2 = 0;\\n        i3 = 0;\\n        i5 = 0;\\n        \\n        int next_multiple_2 = 2*v[i2];\\n        int next_multiple_3 = 3*v[i3];\\n        int next_multiple_5 = 5*v[i5];\\n        \\n        for(int i=1;i<n;i++){\\n            \\n            int put = min(next_multiple_2,min(next_multiple_3,next_multiple_5));\\n            v[i] = put;\\n            \\n            if(put == next_multiple_2){\\n                i2++;\\n                next_multiple_2 = 2*v[i2];\\n            }\\n            \\n            if(put == next_multiple_3){\\n                i3++;\\n                next_multiple_3 = 3*v[i3];\\n            }\\n            \\n            if(put == next_multiple_5){\\n                i5++;\\n                next_multiple_5 = 5*v[i5];\\n            }\\n            \\n        }\\n        \\n        return v[n-1];\\n    }\\n};\\n```\n```\\ntypedef unsigned long long int ull;\\n\\null findnthuglyNumber(int n){\\n    \\n    priority_queue<ull,vector<ull>,greater<ull>> pq;\\n    \\n    pq.push(1);\\n    unordered_set<ull> st;\\n    st.insert(1);\\n    while(n !=  0){\\n        n--;\\n        if(n == 0)  return pq.top();\\n        \\n        ull t = pq.top();\\n        pq.pop();\\n        if(st.find(t*2) == st.end()){\\n            st.insert(t*2);\\n            pq.push(t*2);\\n        }\\n        \\n        if(st.find(t*3) == st.end()){\\n            st.insert(t*3);\\n            pq.push(t*3);\\n        }\\n        \\n        if(st.find(t*5) == st.end()){\\n            st.insert(t*5);\\n            pq.push(t*5);\\n        }\\n    }\\n    return 0;\\n}\\n\\nclass Solution {\\npublic:\\n    int nthUglyNumber(int n) {\\n        return findnthuglyNumber(n);\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 604835,
                "title": "c-solution-with-comments-o-n",
                "content": "```\\nclass Solution {\\npublic:\\n    int nthUglyNumber(int n) {\\n//      Base case \\n        if(n==1)\\n            return 1;\\n        vector<int>ugly(n);\\n//         1 st ugly is one\\n        ugly[0]=1;\\n//         Now new ugly numbers can be generated by \\n//         multiplying previous ones by 2,3 and 5\\n//         But we need to generate them in increasing order\\n\\n        \\n//         t2 is the index of ugly no. to which we have to multiply 2\\n        int t2=0,t3=0,t5=0;\\n        \\n        for(int i=1;i<n;i++){\\n//         So we multiply with three of them and the minimum among them is our next ugly no.\\n            int next = min({2*ugly[t2],3*ugly[t3],5*ugly[t5]});\\n            \\n//  Suppose we go this ugly no. by multiplying with 2 then \\n//  Next time we will multipy 2 with the next greater ugly no. we have\\n//  Ex: first we mutipied 2 by 1 (@index 0) next time we will multiply 2 by 2 (@index 1)\\n            if(next == 2*ugly[t2])\\n                t2++;\\n            if(next == 3*ugly[t3])\\n                t3++;\\n            if(next == 5*ugly[t5])\\n                t5++;\\n            ugly[i]=next;\\n        }\\n\\n        return ugly[n-1];\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    int nthUglyNumber(int n) {\\n//      Base case \\n        if(n==1)\\n            return 1;\\n        vector<int>ugly(n);\\n//         1 st ugly is one\\n        ugly[0]=1;\\n//         Now new ugly numbers can be generated by \\n//         multiplying previous ones by 2,3 and 5\\n//         But we need to generate them in increasing order\\n\\n        \\n//         t2 is the index of ugly no. to which we have to multiply 2\\n        int t2=0,t3=0,t5=0;\\n        \\n        for(int i=1;i<n;i++){\\n//         So we multiply with three of them and the minimum among them is our next ugly no.\\n            int next = min({2*ugly[t2],3*ugly[t3],5*ugly[t5]});\\n            \\n//  Suppose we go this ugly no. by multiplying with 2 then \\n//  Next time we will multipy 2 with the next greater ugly no. we have\\n//  Ex: first we mutipied 2 by 1 (@index 0) next time we will multiply 2 by 2 (@index 1)\\n            if(next == 2*ugly[t2])\\n                t2++;\\n            if(next == 3*ugly[t3])\\n                t3++;\\n            if(next == 5*ugly[t5])\\n                t5++;\\n            ugly[i]=next;\\n        }\\n\\n        return ugly[n-1];\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 578499,
                "title": "java-simple-solution-dp-96-faster",
                "content": "```\\nclass Solution {\\n    public int nthUglyNumber(int n) {\\n        if(n <= 6) return n;\\n        int[] ugly = new int[n];\\n        ugly[0] = 1;\\n        int i2 = 0, i3 = 0, i5 = 0, index = 1;\\n        while(index < n){\\n            int n2 = 2*ugly[i2], n3 = 3*ugly[i3], n5 = 5*ugly[i5];\\n            int temp = Math.min(n2, Math.min(n3, n5));\\n            ugly[index++] = temp;\\n            if(temp == n2) i2++;\\n            if(temp == n3) i3++;\\n            if(temp == n5) i5++;\\n        }\\n        return ugly[n-1];\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    public int nthUglyNumber(int n) {\\n        if(n <= 6) return n;\\n        int[] ugly = new int[n];\\n        ugly[0] = 1;\\n        int i2 = 0, i3 = 0, i5 = 0, index = 1;\\n        while(index < n){\\n            int n2 = 2*ugly[i2], n3 = 3*ugly[i3], n5 = 5*ugly[i5];\\n            int temp = Math.min(n2, Math.min(n3, n5));\\n            ugly[index++] = temp;\\n            if(temp == n2) i2++;\\n            if(temp == n3) i3++;\\n            if(temp == n5) i5++;\\n        }\\n        return ugly[n-1];\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 483848,
                "title": "sub-linear-solution-in-constant-space",
                "content": "If we see ugly numbers in a 3 dimensional space where the coordinates are the number of 5 factos, 3 factos and 2 factors, we can count the number of ugly numbers below a certain bound, by looking at the surface of the shape rather than its interior. Then we can do binary search to find the n\\'th ugly number. This solution is faster than 100% of solutions and uses less space than 100% of solutions according to LeetCode.\\n\\n```\\nclass Solution {\\n    int countLessThan(int bound, int n, int& maxN) {\\n        int count = 0;\\n        long x = 1;\\n        int count5 = 0;\\n        while (x * 5 < bound) {\\n            x *= 5;\\n            ++count5;\\n        }\\n        \\n        int count3 = 0;\\n        while (count5 >= 0) {\\n            \\n            int count2 = 0;\\n            int count52 = count5;\\n            \\n            long y = x;\\n            while (count52 >= 0) {\\n                maxN = max(maxN, (int)y);\\n                count += count52 + 1;\\n                if (count > n) return count;\\n                y *= 2;\\n                ++count2;\\n                while (y >= bound) {\\n                    y /= 5;\\n                    --count52;\\n                }\\n            }\\n            \\n            x *= 3;\\n            ++count3;\\n            while (x >= bound) {\\n                x /= 5;\\n                --count5;\\n            }\\n        }\\n        return count;\\n    }\\npublic:\\n    int nthUglyNumber(int n) {\\n        int min = 2;\\n        int max = 2147483647;\\n        \\n        while (true) {\\n            int mid = min + (max - min + 1) / 2;\\n            int result = 0;\\n            int count = countLessThan(mid, n, result);\\n            if (count == n) return result;\\n            if (count < n) {\\n                min = mid + 1; \\n            } else {\\n                max = mid - 1;\\n            }\\n        }\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    int countLessThan(int bound, int n, int& maxN) {\\n        int count = 0;\\n        long x = 1;\\n        int count5 = 0;\\n        while (x * 5 < bound) {\\n            x *= 5;\\n            ++count5;\\n        }\\n        \\n        int count3 = 0;\\n        while (count5 >= 0) {\\n            \\n            int count2 = 0;\\n            int count52 = count5;\\n            \\n            long y = x;\\n            while (count52 >= 0) {\\n                maxN = max(maxN, (int)y);\\n                count += count52 + 1;\\n                if (count > n) return count;\\n                y *= 2;\\n                ++count2;\\n                while (y >= bound) {\\n                    y /= 5;\\n                    --count52;\\n                }\\n            }\\n            \\n            x *= 3;\\n            ++count3;\\n            while (x >= bound) {\\n                x /= 5;\\n                --count5;\\n            }\\n        }\\n        return count;\\n    }\\npublic:\\n    int nthUglyNumber(int n) {\\n        int min = 2;\\n        int max = 2147483647;\\n        \\n        while (true) {\\n            int mid = min + (max - min + 1) / 2;\\n            int result = 0;\\n            int count = countLessThan(mid, n, result);\\n            if (count == n) return result;\\n            if (count < n) {\\n                min = mid + 1; \\n            } else {\\n                max = mid - 1;\\n            }\\n        }\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 319343,
                "title": "100-o-n-javascript-js",
                "content": "```\\nvar nthUglyNumber = function(n) {\\n    let multiplicationList = [2,3,5]\\n    let Answer = [1]\\n    let i2=0\\n    let i3=0\\n    let i5 = 0\\n    \\n    while (Answer.length<n){\\n        let m2 = Answer[i2]*2\\n        let m3 = Answer[i3]*3\\n        let m5 = Answer[i5]*5\\n        let newAnswer = Math.min(m2,m3,m5)\\n        if(newAnswer===m2){\\n            i2++\\n        }\\n        if(newAnswer===m3){\\n            i3++\\n        }\\n        if(newAnswer===m5){\\n            i5++\\n        }\\n        Answer.push(newAnswer)\\n    }\\n\\n    return Answer[n-1]\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nvar nthUglyNumber = function(n) {\\n    let multiplicationList = [2,3,5]\\n    let Answer = [1]\\n    let i2=0\\n    let i3=0\\n    let i5 = 0\\n    \\n    while (Answer.length<n){\\n        let m2 = Answer[i2]*2\\n        let m3 = Answer[i3]*3\\n        let m5 = Answer[i5]*5\\n        let newAnswer = Math.min(m2,m3,m5)\\n        if(newAnswer===m2){\\n            i2++\\n        }\\n        if(newAnswer===m3){\\n            i3++\\n        }\\n        if(newAnswer===m5){\\n            i5++\\n        }\\n        Answer.push(newAnswer)\\n    }\\n\\n    return Answer[n-1]\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 289767,
                "title": "simple-c-solution-with-only-one-while-loop-4ms-99-65",
                "content": "\\n    int nthUglyNumber(int n) {\\n        vector<int> uglyNums {1};\\n        int curUgly = 1;\\n        int u2_idx = 0, u3_idx = 0, u5_idx = 0;\\n        int u2_num = 0, u3_num = 0, u5_num = 0;\\n\\n        while (uglyNums.size() < n) {\\n            u2_num = uglyNums[u2_idx] * 2;\\n            u3_num = uglyNums[u3_idx] * 3;\\n            u5_num = uglyNums[u5_idx] * 5;\\n            \\n            curUgly = min(min(u2_num, u3_num), u5_num);\\n\\n            if (curUgly == u2_num) u2_idx++;\\n            if (curUgly == u3_num) u3_idx++;\\n            if (curUgly == u5_num) u5_idx++;\\n            \\n            uglyNums.push_back(curUgly);\\n        }\\n        return uglyNums[n-1];\\n    }\\n",
                "solutionTags": [],
                "code": "\\n    int nthUglyNumber(int n) {\\n        vector<int> uglyNums {1};\\n        int curUgly = 1;\\n        int u2_idx = 0, u3_idx = 0, u5_idx = 0;\\n        int u2_num = 0, u3_num = 0, u5_num = 0;\\n\\n        while (uglyNums.size() < n) {\\n            u2_num = uglyNums[u2_idx] * 2;\\n            u3_num = uglyNums[u3_idx] * 3;\\n            u5_num = uglyNums[u5_idx] * 5;\\n            \\n            curUgly = min(min(u2_num, u3_num), u5_num);\\n\\n            if (curUgly == u2_num) u2_idx++;\\n            if (curUgly == u3_num) u3_idx++;\\n            if (curUgly == u5_num) u5_idx++;\\n            \\n            uglyNums.push_back(curUgly);\\n        }\\n        return uglyNums[n-1];\\n    }\\n",
                "codeTag": "Unknown"
            },
            {
                "id": 284203,
                "title": "python-solution",
                "content": "```\\nclass Solution:\\n    def nthUglyNumber(self, n: int) -> int:\\n        i2 = i3 = i5 = 0\\n        res = [1]\\n        while len(res) < n:\\n            n2, n3, n5 = res[i2] * 2, res[i3] * 3, res[i5] * 5\\n            res += [min(n2, n3, n5)]\\n            if res[-1] == n2: i2 += 1\\n            if res[-1] == n3: i3 += 1\\n            if res[-1] == n5: i5 += 1\\n        return res[-1]\\n            \\n",
                "solutionTags": [],
                "code": "```\\nclass Solution:\\n    def nthUglyNumber(self, n: int) -> int:\\n        i2 = i3 = i5 = 0\\n        res = [1]\\n        while len(res) < n:\\n            n2, n3, n5 = res[i2] * 2, res[i3] * 3, res[i5] * 5\\n            res += [min(n2, n3, n5)]\\n            if res[-1] == n2: i2 += 1\\n            if res[-1] == n3: i3 += 1\\n            if res[-1] == n5: i5 += 1\\n        return res[-1]\\n            \\n",
                "codeTag": "Java"
            },
            {
                "id": 138046,
                "title": "c-solution-using-priority-queue",
                "content": "```\\nclass Solution {\\npublic:\\n    int nthUglyNumber(int n){\\n        vector<long long> ans;\\n        priority_queue<long long,vector<long long>,greater<long long>> Q;\\n        unordered_map<long long,bool> visited;\\n        Q.push(1);\\n        visited[1]=true;\\n        while (!Q.empty()&&ans.size()<n){\\n            long long x=Q.top();\\n            Q.pop();\\n            ans.push_back(x);\\n            if (!visited[x*2]){\\n                Q.push(x*2);\\n                visited[x*2]=true;\\n            }\\n            if (!visited[x*3]){\\n                Q.push(x*3);\\n                visited[x*3]=true;\\n            }\\n            if (!visited[x*5]){\\n                Q.push(x*5);\\n                visited[x*5]=true;\\n            }\\n        }\\n        return ans[n-1];\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    int nthUglyNumber(int n){\\n        vector<long long> ans;\\n        priority_queue<long long,vector<long long>,greater<long long>> Q;\\n        unordered_map<long long,bool> visited;\\n        Q.push(1);\\n        visited[1]=true;\\n        while (!Q.empty()&&ans.size()<n){\\n            long long x=Q.top();\\n            Q.pop();\\n            ans.push_back(x);\\n            if (!visited[x*2]){\\n                Q.push(x*2);\\n                visited[x*2]=true;\\n            }\\n            if (!visited[x*3]){\\n                Q.push(x*3);\\n                visited[x*3]=true;\\n            }\\n            if (!visited[x*5]){\\n                Q.push(x*5);\\n                visited[x*5]=true;\\n            }\\n        }\\n        return ans[n-1];\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 69366,
                "title": "10-lines-c",
                "content": "Based on idea from this [thread](https://discuss.leetcode.com/topic/21882/my-16ms-c-dp-solution-with-short-explanation).\\n```\\nclass Solution {\\npublic:\\n    int nthUglyNumber(int n) {\\n        vector<int>dp(n);\\n        dp[0] = 1;\\n        int p2 = 0, p3 = 0, p5 = 0;\\n        for(int i = 1; i < n; i++){\\n            dp[i] = min(dp[p2] * 2, min(dp[p3] * 3, dp[p5] * 5));\\n            if(dp[i] == dp[p2] * 2) p2++;\\n            if(dp[i] == dp[p3] * 3) p3++;\\n            if(dp[i] == dp[p5] * 5) p5++;\\n        }\\n        return dp[n - 1];\\n    }\\n};\\n```\\n***\\nAnd 3ms 90.86% precompution using static vector.\\n```\\nclass Solution {\\npublic:\\n    int nthUglyNumber(int n) {\\n        static vector<int>dp;\\n        if(dp.empty()){\\n            dp.resize(1691);\\n            dp[0] = 1;\\n            int p2 = 0, p3 = 0, p5 = 0;\\n            for(int i = 1; i < 1691; i++){\\n                dp[i] = min(dp[p2] * 2, min(dp[p3] * 3, dp[p5] * 5));\\n                if(dp[i] == dp[p2] * 2) p2++;\\n                if(dp[i] == dp[p3] * 3) p3++;\\n                if(dp[i] == dp[p5] * 5) p5++;\\n            }\\n        }\\n        return dp[n - 1];\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int nthUglyNumber(int n) {\\n        vector<int>dp(n);\\n        dp[0] = 1;\\n        int p2 = 0, p3 = 0, p5 = 0;\\n        for(int i = 1; i < n; i++){\\n            dp[i] = min(dp[p2] * 2, min(dp[p3] * 3, dp[p5] * 5));\\n            if(dp[i] == dp[p2] * 2) p2++;\\n            if(dp[i] == dp[p3] * 3) p3++;\\n            if(dp[i] == dp[p5] * 5) p5++;\\n        }\\n        return dp[n - 1];\\n    }\\n};\\n```\n```\\nclass Solution {\\npublic:\\n    int nthUglyNumber(int n) {\\n        static vector<int>dp;\\n        if(dp.empty()){\\n            dp.resize(1691);\\n            dp[0] = 1;\\n            int p2 = 0, p3 = 0, p5 = 0;\\n            for(int i = 1; i < 1691; i++){\\n                dp[i] = min(dp[p2] * 2, min(dp[p3] * 3, dp[p5] * 5));\\n                if(dp[i] == dp[p2] * 2) p2++;\\n                if(dp[i] == dp[p3] * 3) p3++;\\n                if(dp[i] == dp[p5] * 5) p5++;\\n            }\\n        }\\n        return dp[n - 1];\\n    }\\n};\\n```",
                "codeTag": "Java"
            }
        ],
        "discussions": [
            {
                "id": 1567237,
                "content": [
                    {
                        "username": "lcn",
                        "content": " 1. Actually, the input space is much smaller than expected if we insist an `int` range output. \\nWhen input `n` is greater than `1691`, the output overflows the `int` range.\\n 2. Another way to view this bound is that all ugly numbers must be in the form `2^a*3^b*5^c`. Since we have `log2(Integer.MAX_VALUE)=a<31`, `log3(Integer.MAX_VALUE)=b<20` and `log5(Integer.MAX_VALUE)=c<14`, the combination allowed is surely under `31*20*14~=8400`.\\n\\nSo ugly number is sparser than one would usually think, and please do take care of overflow."
                    },
                    {
                        "username": "chauhanprerna21",
                        "content": "I am not able to understand how is ugly numbers a DP problem?\\nWould be great if someone could help with it."
                    },
                    {
                        "username": "vikasboss6855",
                        "content": "https://leetcode.com/problems/ugly-number-ii/solutions/3704058/c-memoized-solution-using-dp-forcible-dp/\n```\nclass Solution {\npublic:\n    int nthUglyNumber(int n) {\n        vector<int> dp(n);\n        dp[0] = 1;\n        return nthUglyNumberRecursive(dp, n, 1, 0, 0, 0);\n    }\n\nprivate:\n    int nthUglyNumberRecursive(vector<int>& dp, int n, int i, int p1, int p2, int p3) {\n        if (i == n) {\n            return dp[n - 1];\n        }\n\n        int twoMultiple = dp[p1] * 2;\n        int threeMultiple = dp[p2] * 3;\n        int fiveMultiple = dp[p3] * 5;\n\n        dp[i] = min(twoMultiple, min(threeMultiple, fiveMultiple));\n\n        int nextP1 = (dp[i] == twoMultiple) ? p1 + 1 : p1;\n        int nextP2 = (dp[i] == threeMultiple) ? p2 + 1 : p2;\n        int nextP3 = (dp[i] == fiveMultiple) ? p3 + 1 : p3;\n\n        return nthUglyNumberRecursive(dp, n, i + 1, nextP1, nextP2, nextP3);\n    }\n};\n\n```"
                    },
                    {
                        "username": "divyanshuparg",
                        "content": "I have solved it using recursion and hashing."
                    },
                    {
                        "username": "anshulguleria",
                        "content": "In the example in problem statement 1 was being counted as ugly number. I am not able to understand how we concluded that.\\n\\nif 1 = 1 * 2^0 then this theory will be true for other numbers as well like 7  * 2^0."
                    },
                    {
                        "username": "Seabayley",
                        "content": "![image](https://assets.leetcode.com/users/images/fad90901-6c35-455e-8ff0-8160380ca46c_1597993223.2791212.png)\\n\\nAm I misunderstanding the problem? The 11th ugly numbers looks to me as though it should be 14?"
                    },
                    {
                        "username": "codekorekhai",
                        "content": "[@satyamkumarskr](/satyamkumarskr) 14 is not an ugly number because it has 7 as factor but the problem said that only 2, 3, 5 will be the prime factor for each ugly number."
                    },
                    {
                        "username": "satyamkumarskr",
                        "content": "True . I got the same issue."
                    },
                    {
                        "username": "user6746E",
                        "content": "The 11th ugly number will not be 14 since the prime factor of 14 includes 7, but the question clearly states that the primes factor should be limited to 2, 3 or 5. Therefore 11th ugly number will be 15."
                    },
                    {
                        "username": "sazib204061",
                        "content": "I solve this problem in O(1) time complexity.\\n `class Solution {\\npublic:\\nvector<long long>ar = {1,2,3,4,5,6,8,9,10,12,15,16,18,20,24,25,27,30,32,36,40,45,48,50,54,60,64,72,75,80,81,90,96,100,108,120,125,128,135,144,150,160,162,180,192,200,216,225,240,243,250,256,270,288,300,320,324,360,375,384,400,405,432,450,480,486,500,512,540,576,600,625,640,648,675,720,729,750,768,800,810,864,900,960,972,1000,1024,1080,1125,1152,1200,1215,1250,1280,1296,1350,1440,1458,1500,1536,1600,1620,1728,1800,1875,1920,1944,2000,2025,2048,2160,2187,2250,2304,2400,2430,2500,2560,2592,2700,2880,2916,3000,3072,3125,3200,3240,3375,3456,3600,3645,3750,3840,3888,4000,4050,4096,4320,4374,4500,4608,4800,4860,5000,5120,5184,5400,5625,5760,5832,6000,6075,6144,6250,6400,6480,6561,6750,6912,7200,7290,7500,7680,7776,8000,8100,8192,8640,8748,9000,9216,9375,9600,9720,10000,10125,10240,10368,10800,10935,11250,11520,11664,12000,12150,12288,12500,12800,12960,13122,13500,13824,14400,14580,15000,15360,15552,15625,16000,16200,16384,16875,17280,17496,18000,18225,18432,18750,19200,19440,19683,20000,20250,20480,20736,21600,21870,22500,23040,23328,24000,24300,24576,25000,25600,25920,26244,27000,27648,28125,28800,29160,30000,30375,30720,31104,31250,32000,32400,32768,32805,33750,34560,34992,36000,36450,36864,37500,38400,38880,39366,40000,40500,40960,41472,43200,43740,45000,46080,46656,46875,48000,48600,49152,50000,50625,51200,51840,52488,54000,54675,55296,56250,57600,58320,59049,60000,60750,61440,62208,62500,64000,64800,65536,65610,67500,69120,69984,72000,72900,73728,75000,76800,77760,78125,78732,80000,81000,81920,82944,84375,86400,87480,90000,91125,92160,93312,93750,96000,97200,98304,98415,100000,101250,102400,103680,104976,108000,109350,110592,112500,115200,116640,118098,120000,121500,122880,124416,125000,128000,129600,131072,131220,135000,138240,139968,140625,144000,145800,147456,150000,151875,153600,155520,156250,157464,160000,162000,163840,164025,165888,168750,172800,174960,177147,180000,182250,184320,186624,187500,192000,194400,196608,196830,200000,202500,204800,207360,209952,216000,218700,221184,225000,230400,233280,234375,236196,240000,243000,245760,248832,250000,253125,256000,259200,262144,262440,270000,273375,276480,279936,281250,288000,291600,294912,295245,300000,303750,307200,311040,312500,314928,320000,324000,327680,328050,331776,337500,345600,349920,354294,360000,364500,368640,373248,375000,384000,388800,390625,393216,393660,400000,405000,409600,414720,419904,421875,432000,437400,442368,450000,455625,460800,466560,468750,472392,480000,486000,491520,492075,497664,500000,506250,512000,518400,524288,524880,531441,540000,546750,552960,559872,562500,576000,583200,589824,590490,600000,607500,614400,622080,625000,629856,640000,648000,655360,656100,663552,675000,691200,699840,703125,708588,720000,729000,737280,746496,750000,759375,768000,777600,781250,786432,787320,800000,810000,819200,820125,829440,839808,843750,864000,874800,884736,885735,900000,911250,921600,933120,937500,944784,\\n\\n960000,972000,983040,984150,995328,1000000,1012500,1024000,1036800,1048576,1049760,1062882,1080000,1093500,1105920,1119744,1125000,1152000,1166400,1171875,1179648,1180980,1200000,1215000,1228800,1244160,1250000,1259712,1265625,1280000,1296000,1310720,1312200,1327104,1350000,1366875,1382400,1399680,1406250,1417176,1440000,1458000,1474560,1476225,1492992,1500000,1518750,1536000,1555200,1562500,1572864,1574640,1594323,1600000,1620000,1638400,1640250,1658880,1679616,1687500,1728000,1749600,1769472,1771470,1800000,1822500,1843200,1866240,1875000,1889568,1920000,1944000,1953125,1966080,1968300,1990656,2000000,2025000,2048000,2073600,2097152,2099520,2109375,2125764,2160000,2187000,2211840,2239488,2250000,2278125,2304000,2332800,2343750,2359296,2361960,2400000,2430000,2457600,2460375,2488320,2500000,2519424,2531250,2560000,2592000,2621440,2624400,2654208,2657205,2700000,2733750,2764800,2799360,2812500,2834352,2880000,2916000,2949120,2952450,2985984,3000000,3037500,3072000,3110400,3125000,3145728,3149280,3188646,3200000,3240000,3276800,3280500,3317760,3359232,3375000,3456000,3499200,3515625,3538944,3542940,3600000,3645000,3686400,3732480,3750000,3779136,3796875,3840000,3888000,3906250,3932160,3936600,3981312,4000000,4050000,4096000,4100625,4147200,4194304,4199040,4218750,4251528,4320000,4374000,4423680,4428675,4478976,4500000,4556250,4608000,4665600,4687500,4718592,4723920,4782969,4800000,4860000,4915200,4920750,4976640,5000000,5038848,5062500,5120000,5184000,5242880,5248800,5308416,5314410,5400000,5467500,5529600,5598720,5625000,5668704,5760000,5832000,5859375,5898240,5904900,5971968,6000000,6075000,6144000,6220800,6250000,6291456,6298560,6328125,6377292,6400000,6480000,6553600,6561000,6635520,6718464,6750000,6834375,6912000,6998400,7031250,7077888,7085880,7200000,7290000,7372800,7381125,7464960,7500000,7558272,7593750,7680000,7776000,7812500,7864320,7873200,7962624,7971615,8000000,8100000,8192000,8201250,8294400,8388608,8398080,8437500,8503056,8640000,8748000,8847360,8857350,8957952,9000000,9112500,9216000,9331200,9375000,9437184,9447840,9565938,9600000,9720000,9765625,9830400,9841500,9953280,10000000,10077696,10125000,10240000,10368000,10485760,10497600,10546875,10616832,10628820,10800000,10935000,11059200,11197440,11250000,11337408,11390625,11520000,11664000,11718750,11796480,11809800,11943936,12000000,12150000,12288000,12301875,12441600,12500000,12582912,12597120,12656250,12754584,12800000,12960000,13107200,13122000,13271040,13286025,13436928,13500000,13668750,13824000,13996800,14062500,14155776,14171760,14348907,14400000,14580000,14745600,14762250,14929920,15000000,15116544,15187500,15360000,15552000,15625000,15728640,15746400,15925248,15943230,16000000,16200000,16384000,16402500,16588800,16777216,16796160,16875000,17006112,17280000,17496000,17578125,17694720,17714700,17915904,18000000,18225000,18432000,18662400,18750000,18874368,18895680,18984375,19131876,19200000,19440000,19531250,19660800,19683000,19906560,20000000,20155392,20250000,20480000,20503125,20736000,20971520,20995200,21093750,21233664,21257640,21600000,21870000,22118400,22143375,22394880,22500000,22674816,22781250,23040000,23328000,23437500,23592960,23619600,23887872,23914845,24000000,24300000,24576000,24603750,24883200,25000000,25165824,25194240,25312500,25509168,25600000,25920000,26214400,26244000,26542080,26572050,26873856,27000000,27337500,27648000,27993600,28125000,28311552,28343520,28697814,28800000,29160000,29296875,29491200,29524500,29859840,30000000,30233088,30375000,30720000,31104000,31250000,31457280,31492800,31640625,31850496,31886460,32000000,32400000,32768000,32805000,33177600,33554432,33592320,33750000,34012224,34171875,34560000,34992000,35156250,35389440,35429400,35831808,36000000,36450000,36864000,36905625,37324800,37500000,37748736,37791360,37968750,38263752,38400000,38880000,39062500,39321600,39366000,39813120,39858075,40000000,40310784,40500000,40960000,41006250,41472000,41943040,41990400,42187500,42467328,42515280,43046721,43200000,43740000,44236800,44286750,44789760,45000000,45349632,45562500,46080000,46656000,46875000,47185920,47239200,47775744,47829690,48000000,48600000,48828125,49152000,49207500,49766400,50000000,50331648,50388480,50625000,51018336,51200000,51840000,\\n\\n52428800,52488000,52734375,53084160,53144100,53747712,54000000,54675000,55296000,55987200,56250000,56623104,56687040,56953125,57395628,57600000,58320000,58593750,58982400,59049000,59719680,60000000,60466176,60750000,61440000,61509375,62208000,62500000,62914560,62985600,63281250,63700992,63772920,64000000,64800000,65536000,65610000,66355200,66430125,67108864,67184640,67500000,68024448,68343750,69120000,69984000,70312500,70778880,70858800,71663616,71744535,72000000,72900000,73728000,73811250,74649600,75000000,75497472,75582720,75937500,76527504,76800000,77760000,78125000,78643200,78732000,79626240,79716150,80000000,80621568,81000000,81920000,82012500,82944000,83886080,83980800,84375000,84934656,85030560,86093442,86400000,87480000,87890625,88473600,88573500,89579520,90000000,90699264,91125000,92160000,93312000,93750000,94371840,94478400,94921875,95551488,95659380,96000000,97200000,97656250,98304000,98415000,99532800,100000000,100663296,100776960,101250000,102036672,102400000,102515625,103680000,104857600,104976000,105468750,106168320,106288200,107495424,108000000,109350000,110592000,110716875,111974400,112500000,113246208,113374080,113906250,114791256,115200000,116640000,117187500,117964800,118098000,119439360,119574225,120000000,120932352,121500000,122880000,123018750,124416000,125000000,125829120,125971200,126562500,127401984,127545840,128000000,129140163,129600000,131072000,131220000,132710400,132860250,134217728,134369280,135000000,136048896,136687500,138240000,139968000,140625000,141557760,141717600,143327232,143489070,144000000,145800000,146484375,147456000,147622500,149299200,150000000,150994944,151165440,151875000,153055008,153600000,155520000,156250000,157286400,157464000,158203125,159252480,159432300,160000000,161243136,162000000,163840000,164025000,165888000,167772160,167961600,168750000,169869312,170061120,170859375,172186884,172800000,174960000,175781250,\\n\\n\\n176947200,177147000,179159040,180000000,181398528,182250000,184320000,184528125,186624000,187500000,188743680,188956800,189843750,191102976,191318760,192000000,194400000,195312500,196608000,196830000,199065600,199290375,200000000,201326592,201553920,202500000,204073344,204800000,205031250,207360000,209715200,209952000,210937500,212336640,212576400,214990848,215233605,216000000,218700000,221184000,221433750,223948800,225000000,226492416,226748160,227812500,229582512,230400000,233280000,234375000,235929600,236196000,238878720,239148450,240000000,241864704,243000000,244140625,245760000,246037500,248832000,250000000,251658240,251942400,253125000,254803968,255091680,256000000,258280326,259200000,262144000,262440000,263671875,265420800,265720500,268435456,268738560,270000000,272097792,273375000,276480000,279936000,281250000,283115520,283435200,284765625,286654464,286978140,288000000,291600000,292968750,294912000,295245000,298598400,300000000,301989888,302330880,303750000,306110016,307200000,307546875,311040000,312500000,314572800,314928000,316406250,318504960,318864600,320000000,322486272,324000000,327680000,328050000,331776000,332150625,335544320,335923200,337500000,339738624,340122240,341718750,344373768,345600000,349920000,351562500,353894400,354294000,358318080,358722675,360000000,362797056,364500000,368640000,369056250,373248000,375000000,377487360,377913600,379687500,382205952,382637520,384000000,387420489,388800000,390625000,393216000,393660000,398131200,398580750,400000000,402653184,403107840,405000000,408146688,409600000,410062500,414720000,419430400,419904000,421875000,424673280,425152800,429981696,430467210,432000000,437400000,439453125,442368000,442867500,447897600,450000000,452984832,453496320,455625000,459165024,460800000,466560000,468750000,471859200,472392000,474609375,477757440,478296900,480000000,483729408,486000000,488281250,491520000,492075000,497664000,500000000,503316480,503884800,506250000,509607936,510183360,512000000,512578125,516560652,518400000,\\n\\n524288000,524880000,527343750,530841600,531441000,536870912,537477120,540000000,544195584,546750000,552960000,553584375,559872000,562500000,566231040,566870400,569531250,573308928,573956280,576000000,583200000,585937500,589824000,590490000,597196800,597871125,600000000,603979776,604661760,607500000,612220032,614400000,615093750,622080000,625000000,629145600,629856000,632812500,637009920,637729200,640000000,644972544,645700815,648000000,655360000,656100000,663552000,664301250,671088640,671846400,675000000,679477248,680244480,683437500,688747536,691200000,699840000,703125000,707788800,708588000,716636160,717445350,720000000,725594112,729000000,732421875,737280000,738112500,746496000,750000000,754974720,755827200,759375000,764411904,765275040,768000000,774840978,777600000,781250000,786432000,787320000,791015625,796262400,797161500,800000000,805306368,806215680,810000000,816293376,819200000,820125000,829440000,838860800,839808000,843750000,849346560,850305600,854296875,859963392,860934420,864000000,874800000,878906250,884736000,885735000,895795200,900000000,905969664,906992640,911250000,918330048,921600000,922640625,933120000,937500000,943718400,944784000,949218750,955514880,956593800,960000000,967458816,972000000,976562500,983040000,984150000,995328000,996451875,1000000000,1006632960,1007769600,1012500000,1019215872,1020366720,1024000000,1025156250,1033121304,1036800000,1048576000,1049760000,1054687500,1061683200,1062882000,1073741824,1074954240,1076168025,1080000000,1088391168,1093500000,1105920000,1107168750,1119744000,1125000000,1132462080,1133740800,1139062500,1146617856,1147912560,1152000000,1162261467,1166400000,1171875000,1179648000,1180980000,1194393600,1195742250,1200000000,1207959552,1209323520,1215000000,1220703125,1224440064,1228800000,1230187500,1244160000,1250000000,1258291200,1259712000,1265625000,1274019840,1275458400,1280000000,1289945088,1291401630,1296000000,1310720000,1312200000,1318359375,1327104000,1328602500,1342177280,1343692800,1350000000,1358954496,1360488960,1366875000,1377495072,1382400000,1399680000,1406250000,1415577600,1417176000,1423828125,1433272320,1434890700,1440000000,1451188224,1458000000,1464843750,1474560000,1476225000,1492992000,1500000000,1509949440,1511654400,1518750000,1528823808,1530550080,1536000000,1537734375,1549681956,1555200000,1562500000,1572864000,1574640000,1582031250,1592524800,1594323000,1600000000,1610612736,1612431360,1620000000,1632586752,1638400000,1640250000,1658880000,1660753125,1677721600,1679616000,1687500000,1698693120,1700611200,1708593750,1719926784,1721868840,1728000000,1749600000,1757812500,1769472000,1771470000,1791590400,1793613375,1800000000,1811939328,1813985280,1822500000,1836660096,1843200000,1845281250,1866240000,1875000000,1887436800,1889568000,1898437500,1911029760,1913187600,1920000000,1934917632,1937102445,1944000000,1953125000,1966080000,1968300000,1990656000,1992903750,2000000000,2013265920,2015539200,2025000000,2038431744,2040733440,2048000000,2050312500,2066242608,2073600000,2097152000,2099520000,2109375000,2123366400,2125764000,2147483648,2149908480,2152336050,2160000000,2176782336,2187000000,2197265625,2211840000,2214337500,2239488000\\n\\n\\n};\\n\\n    int nthUglyNumber(int n) {\\n        return ar[n-1]; \\n    }\\n};`"
                    },
                    {
                        "username": "AasheeshLikePanner",
                        "content": "Bro stop this \\uD83D\\uDE2D\\uD83D\\uDE2D\\uD83D\\uDE2D"
                    },
                    {
                        "username": "Mayank_Shahria",
                        "content": "**I have solved this by two methods \\n1. Brute force**\\nBut it is giving a run time error\\n![image](https://assets.leetcode.com/users/images/ba539fa1-405b-4d9d-832a-5be83172edc4_1620554425.1931248.png)\\n**2. Dynamic Programing**\\n![image](https://assets.leetcode.com/users/images/3a90f09e-1a3c-465f-a8d6-b58bfc613ccf_1620554465.9711976.png)\\n\\n\\n"
                    },
                    {
                        "username": "aman_online67",
                        "content": "I also applied brute force but it gives TLE at some 500 test case. But logic wise it is correct what to do now"
                    },
                    {
                        "username": "Rohith6776",
                        "content": "If the prime factors are limited to 2,3,5 and we should not consider numbers like(14->2*7, 21->3*7) right?"
                    },
                    {
                        "username": "wtfcoder",
                        "content": "yup"
                    },
                    {
                        "username": "c_jain",
                        "content": "After reading top solutions here, I realized optimized solution is not a DP solution because I am not able to figure out optimal substructure and overlapping subproblem. I think it is kind of 3 pointer solution. Anyone like to clarify this?"
                    },
                    {
                        "username": "vikasboss6855",
                        "content": "https://leetcode.com/problems/ugly-number-ii/solutions/3704058/c-memoized-solution-using-dp-forcible-dp/"
                    },
                    {
                        "username": "Gismet",
                        "content": "Yeah, you are right. I don't also think there is an optimal substructure and overlapping subproblem. I think the reason why they called this DP solution is that we use the previously computed ugly numbers to find the next one. If you checked out the hint, they say you can get the next ugly number from a smaller ugly number by multiplying it by either 2, 3 or 5. So we start from the bottom and work our way up to the nth ugly number, in each iteration finding the next ugly number using a previous one. But to see the overlapping subproblems, one would write a recursive solution, also called top-down, and see if there are any subproblems that overlaps. But I couldn't come up with recursive top-down solution. Or maybe there is an optimal substructure that I fail to see. "
                    },
                    {
                        "username": "logical_thinker",
                        "content": "can someone throw light on the last test case which is n being empty the 596th test case. what is that and how do I go about it."
                    },
                    {
                        "username": "urmichm",
                        "content": "why is 1 ugly number?"
                    },
                    {
                        "username": "at218808",
                        "content": "1 is a factor of every number , so its more like a ugly number has only factors as 1,2,3 or 5"
                    },
                    {
                        "username": "QuasiRus",
                        "content": "It does not have any prime factor outside [2, 3, 5] list. 1 itself is not a prime number."
                    }
                ]
            },
            {
                "id": 1573977,
                "content": [
                    {
                        "username": "lcn",
                        "content": " 1. Actually, the input space is much smaller than expected if we insist an `int` range output. \\nWhen input `n` is greater than `1691`, the output overflows the `int` range.\\n 2. Another way to view this bound is that all ugly numbers must be in the form `2^a*3^b*5^c`. Since we have `log2(Integer.MAX_VALUE)=a<31`, `log3(Integer.MAX_VALUE)=b<20` and `log5(Integer.MAX_VALUE)=c<14`, the combination allowed is surely under `31*20*14~=8400`.\\n\\nSo ugly number is sparser than one would usually think, and please do take care of overflow."
                    },
                    {
                        "username": "chauhanprerna21",
                        "content": "I am not able to understand how is ugly numbers a DP problem?\\nWould be great if someone could help with it."
                    },
                    {
                        "username": "vikasboss6855",
                        "content": "https://leetcode.com/problems/ugly-number-ii/solutions/3704058/c-memoized-solution-using-dp-forcible-dp/\n```\nclass Solution {\npublic:\n    int nthUglyNumber(int n) {\n        vector<int> dp(n);\n        dp[0] = 1;\n        return nthUglyNumberRecursive(dp, n, 1, 0, 0, 0);\n    }\n\nprivate:\n    int nthUglyNumberRecursive(vector<int>& dp, int n, int i, int p1, int p2, int p3) {\n        if (i == n) {\n            return dp[n - 1];\n        }\n\n        int twoMultiple = dp[p1] * 2;\n        int threeMultiple = dp[p2] * 3;\n        int fiveMultiple = dp[p3] * 5;\n\n        dp[i] = min(twoMultiple, min(threeMultiple, fiveMultiple));\n\n        int nextP1 = (dp[i] == twoMultiple) ? p1 + 1 : p1;\n        int nextP2 = (dp[i] == threeMultiple) ? p2 + 1 : p2;\n        int nextP3 = (dp[i] == fiveMultiple) ? p3 + 1 : p3;\n\n        return nthUglyNumberRecursive(dp, n, i + 1, nextP1, nextP2, nextP3);\n    }\n};\n\n```"
                    },
                    {
                        "username": "divyanshuparg",
                        "content": "I have solved it using recursion and hashing."
                    },
                    {
                        "username": "anshulguleria",
                        "content": "In the example in problem statement 1 was being counted as ugly number. I am not able to understand how we concluded that.\\n\\nif 1 = 1 * 2^0 then this theory will be true for other numbers as well like 7  * 2^0."
                    },
                    {
                        "username": "Seabayley",
                        "content": "![image](https://assets.leetcode.com/users/images/fad90901-6c35-455e-8ff0-8160380ca46c_1597993223.2791212.png)\\n\\nAm I misunderstanding the problem? The 11th ugly numbers looks to me as though it should be 14?"
                    },
                    {
                        "username": "codekorekhai",
                        "content": "[@satyamkumarskr](/satyamkumarskr) 14 is not an ugly number because it has 7 as factor but the problem said that only 2, 3, 5 will be the prime factor for each ugly number."
                    },
                    {
                        "username": "satyamkumarskr",
                        "content": "True . I got the same issue."
                    },
                    {
                        "username": "user6746E",
                        "content": "The 11th ugly number will not be 14 since the prime factor of 14 includes 7, but the question clearly states that the primes factor should be limited to 2, 3 or 5. Therefore 11th ugly number will be 15."
                    },
                    {
                        "username": "sazib204061",
                        "content": "I solve this problem in O(1) time complexity.\\n `class Solution {\\npublic:\\nvector<long long>ar = {1,2,3,4,5,6,8,9,10,12,15,16,18,20,24,25,27,30,32,36,40,45,48,50,54,60,64,72,75,80,81,90,96,100,108,120,125,128,135,144,150,160,162,180,192,200,216,225,240,243,250,256,270,288,300,320,324,360,375,384,400,405,432,450,480,486,500,512,540,576,600,625,640,648,675,720,729,750,768,800,810,864,900,960,972,1000,1024,1080,1125,1152,1200,1215,1250,1280,1296,1350,1440,1458,1500,1536,1600,1620,1728,1800,1875,1920,1944,2000,2025,2048,2160,2187,2250,2304,2400,2430,2500,2560,2592,2700,2880,2916,3000,3072,3125,3200,3240,3375,3456,3600,3645,3750,3840,3888,4000,4050,4096,4320,4374,4500,4608,4800,4860,5000,5120,5184,5400,5625,5760,5832,6000,6075,6144,6250,6400,6480,6561,6750,6912,7200,7290,7500,7680,7776,8000,8100,8192,8640,8748,9000,9216,9375,9600,9720,10000,10125,10240,10368,10800,10935,11250,11520,11664,12000,12150,12288,12500,12800,12960,13122,13500,13824,14400,14580,15000,15360,15552,15625,16000,16200,16384,16875,17280,17496,18000,18225,18432,18750,19200,19440,19683,20000,20250,20480,20736,21600,21870,22500,23040,23328,24000,24300,24576,25000,25600,25920,26244,27000,27648,28125,28800,29160,30000,30375,30720,31104,31250,32000,32400,32768,32805,33750,34560,34992,36000,36450,36864,37500,38400,38880,39366,40000,40500,40960,41472,43200,43740,45000,46080,46656,46875,48000,48600,49152,50000,50625,51200,51840,52488,54000,54675,55296,56250,57600,58320,59049,60000,60750,61440,62208,62500,64000,64800,65536,65610,67500,69120,69984,72000,72900,73728,75000,76800,77760,78125,78732,80000,81000,81920,82944,84375,86400,87480,90000,91125,92160,93312,93750,96000,97200,98304,98415,100000,101250,102400,103680,104976,108000,109350,110592,112500,115200,116640,118098,120000,121500,122880,124416,125000,128000,129600,131072,131220,135000,138240,139968,140625,144000,145800,147456,150000,151875,153600,155520,156250,157464,160000,162000,163840,164025,165888,168750,172800,174960,177147,180000,182250,184320,186624,187500,192000,194400,196608,196830,200000,202500,204800,207360,209952,216000,218700,221184,225000,230400,233280,234375,236196,240000,243000,245760,248832,250000,253125,256000,259200,262144,262440,270000,273375,276480,279936,281250,288000,291600,294912,295245,300000,303750,307200,311040,312500,314928,320000,324000,327680,328050,331776,337500,345600,349920,354294,360000,364500,368640,373248,375000,384000,388800,390625,393216,393660,400000,405000,409600,414720,419904,421875,432000,437400,442368,450000,455625,460800,466560,468750,472392,480000,486000,491520,492075,497664,500000,506250,512000,518400,524288,524880,531441,540000,546750,552960,559872,562500,576000,583200,589824,590490,600000,607500,614400,622080,625000,629856,640000,648000,655360,656100,663552,675000,691200,699840,703125,708588,720000,729000,737280,746496,750000,759375,768000,777600,781250,786432,787320,800000,810000,819200,820125,829440,839808,843750,864000,874800,884736,885735,900000,911250,921600,933120,937500,944784,\\n\\n960000,972000,983040,984150,995328,1000000,1012500,1024000,1036800,1048576,1049760,1062882,1080000,1093500,1105920,1119744,1125000,1152000,1166400,1171875,1179648,1180980,1200000,1215000,1228800,1244160,1250000,1259712,1265625,1280000,1296000,1310720,1312200,1327104,1350000,1366875,1382400,1399680,1406250,1417176,1440000,1458000,1474560,1476225,1492992,1500000,1518750,1536000,1555200,1562500,1572864,1574640,1594323,1600000,1620000,1638400,1640250,1658880,1679616,1687500,1728000,1749600,1769472,1771470,1800000,1822500,1843200,1866240,1875000,1889568,1920000,1944000,1953125,1966080,1968300,1990656,2000000,2025000,2048000,2073600,2097152,2099520,2109375,2125764,2160000,2187000,2211840,2239488,2250000,2278125,2304000,2332800,2343750,2359296,2361960,2400000,2430000,2457600,2460375,2488320,2500000,2519424,2531250,2560000,2592000,2621440,2624400,2654208,2657205,2700000,2733750,2764800,2799360,2812500,2834352,2880000,2916000,2949120,2952450,2985984,3000000,3037500,3072000,3110400,3125000,3145728,3149280,3188646,3200000,3240000,3276800,3280500,3317760,3359232,3375000,3456000,3499200,3515625,3538944,3542940,3600000,3645000,3686400,3732480,3750000,3779136,3796875,3840000,3888000,3906250,3932160,3936600,3981312,4000000,4050000,4096000,4100625,4147200,4194304,4199040,4218750,4251528,4320000,4374000,4423680,4428675,4478976,4500000,4556250,4608000,4665600,4687500,4718592,4723920,4782969,4800000,4860000,4915200,4920750,4976640,5000000,5038848,5062500,5120000,5184000,5242880,5248800,5308416,5314410,5400000,5467500,5529600,5598720,5625000,5668704,5760000,5832000,5859375,5898240,5904900,5971968,6000000,6075000,6144000,6220800,6250000,6291456,6298560,6328125,6377292,6400000,6480000,6553600,6561000,6635520,6718464,6750000,6834375,6912000,6998400,7031250,7077888,7085880,7200000,7290000,7372800,7381125,7464960,7500000,7558272,7593750,7680000,7776000,7812500,7864320,7873200,7962624,7971615,8000000,8100000,8192000,8201250,8294400,8388608,8398080,8437500,8503056,8640000,8748000,8847360,8857350,8957952,9000000,9112500,9216000,9331200,9375000,9437184,9447840,9565938,9600000,9720000,9765625,9830400,9841500,9953280,10000000,10077696,10125000,10240000,10368000,10485760,10497600,10546875,10616832,10628820,10800000,10935000,11059200,11197440,11250000,11337408,11390625,11520000,11664000,11718750,11796480,11809800,11943936,12000000,12150000,12288000,12301875,12441600,12500000,12582912,12597120,12656250,12754584,12800000,12960000,13107200,13122000,13271040,13286025,13436928,13500000,13668750,13824000,13996800,14062500,14155776,14171760,14348907,14400000,14580000,14745600,14762250,14929920,15000000,15116544,15187500,15360000,15552000,15625000,15728640,15746400,15925248,15943230,16000000,16200000,16384000,16402500,16588800,16777216,16796160,16875000,17006112,17280000,17496000,17578125,17694720,17714700,17915904,18000000,18225000,18432000,18662400,18750000,18874368,18895680,18984375,19131876,19200000,19440000,19531250,19660800,19683000,19906560,20000000,20155392,20250000,20480000,20503125,20736000,20971520,20995200,21093750,21233664,21257640,21600000,21870000,22118400,22143375,22394880,22500000,22674816,22781250,23040000,23328000,23437500,23592960,23619600,23887872,23914845,24000000,24300000,24576000,24603750,24883200,25000000,25165824,25194240,25312500,25509168,25600000,25920000,26214400,26244000,26542080,26572050,26873856,27000000,27337500,27648000,27993600,28125000,28311552,28343520,28697814,28800000,29160000,29296875,29491200,29524500,29859840,30000000,30233088,30375000,30720000,31104000,31250000,31457280,31492800,31640625,31850496,31886460,32000000,32400000,32768000,32805000,33177600,33554432,33592320,33750000,34012224,34171875,34560000,34992000,35156250,35389440,35429400,35831808,36000000,36450000,36864000,36905625,37324800,37500000,37748736,37791360,37968750,38263752,38400000,38880000,39062500,39321600,39366000,39813120,39858075,40000000,40310784,40500000,40960000,41006250,41472000,41943040,41990400,42187500,42467328,42515280,43046721,43200000,43740000,44236800,44286750,44789760,45000000,45349632,45562500,46080000,46656000,46875000,47185920,47239200,47775744,47829690,48000000,48600000,48828125,49152000,49207500,49766400,50000000,50331648,50388480,50625000,51018336,51200000,51840000,\\n\\n52428800,52488000,52734375,53084160,53144100,53747712,54000000,54675000,55296000,55987200,56250000,56623104,56687040,56953125,57395628,57600000,58320000,58593750,58982400,59049000,59719680,60000000,60466176,60750000,61440000,61509375,62208000,62500000,62914560,62985600,63281250,63700992,63772920,64000000,64800000,65536000,65610000,66355200,66430125,67108864,67184640,67500000,68024448,68343750,69120000,69984000,70312500,70778880,70858800,71663616,71744535,72000000,72900000,73728000,73811250,74649600,75000000,75497472,75582720,75937500,76527504,76800000,77760000,78125000,78643200,78732000,79626240,79716150,80000000,80621568,81000000,81920000,82012500,82944000,83886080,83980800,84375000,84934656,85030560,86093442,86400000,87480000,87890625,88473600,88573500,89579520,90000000,90699264,91125000,92160000,93312000,93750000,94371840,94478400,94921875,95551488,95659380,96000000,97200000,97656250,98304000,98415000,99532800,100000000,100663296,100776960,101250000,102036672,102400000,102515625,103680000,104857600,104976000,105468750,106168320,106288200,107495424,108000000,109350000,110592000,110716875,111974400,112500000,113246208,113374080,113906250,114791256,115200000,116640000,117187500,117964800,118098000,119439360,119574225,120000000,120932352,121500000,122880000,123018750,124416000,125000000,125829120,125971200,126562500,127401984,127545840,128000000,129140163,129600000,131072000,131220000,132710400,132860250,134217728,134369280,135000000,136048896,136687500,138240000,139968000,140625000,141557760,141717600,143327232,143489070,144000000,145800000,146484375,147456000,147622500,149299200,150000000,150994944,151165440,151875000,153055008,153600000,155520000,156250000,157286400,157464000,158203125,159252480,159432300,160000000,161243136,162000000,163840000,164025000,165888000,167772160,167961600,168750000,169869312,170061120,170859375,172186884,172800000,174960000,175781250,\\n\\n\\n176947200,177147000,179159040,180000000,181398528,182250000,184320000,184528125,186624000,187500000,188743680,188956800,189843750,191102976,191318760,192000000,194400000,195312500,196608000,196830000,199065600,199290375,200000000,201326592,201553920,202500000,204073344,204800000,205031250,207360000,209715200,209952000,210937500,212336640,212576400,214990848,215233605,216000000,218700000,221184000,221433750,223948800,225000000,226492416,226748160,227812500,229582512,230400000,233280000,234375000,235929600,236196000,238878720,239148450,240000000,241864704,243000000,244140625,245760000,246037500,248832000,250000000,251658240,251942400,253125000,254803968,255091680,256000000,258280326,259200000,262144000,262440000,263671875,265420800,265720500,268435456,268738560,270000000,272097792,273375000,276480000,279936000,281250000,283115520,283435200,284765625,286654464,286978140,288000000,291600000,292968750,294912000,295245000,298598400,300000000,301989888,302330880,303750000,306110016,307200000,307546875,311040000,312500000,314572800,314928000,316406250,318504960,318864600,320000000,322486272,324000000,327680000,328050000,331776000,332150625,335544320,335923200,337500000,339738624,340122240,341718750,344373768,345600000,349920000,351562500,353894400,354294000,358318080,358722675,360000000,362797056,364500000,368640000,369056250,373248000,375000000,377487360,377913600,379687500,382205952,382637520,384000000,387420489,388800000,390625000,393216000,393660000,398131200,398580750,400000000,402653184,403107840,405000000,408146688,409600000,410062500,414720000,419430400,419904000,421875000,424673280,425152800,429981696,430467210,432000000,437400000,439453125,442368000,442867500,447897600,450000000,452984832,453496320,455625000,459165024,460800000,466560000,468750000,471859200,472392000,474609375,477757440,478296900,480000000,483729408,486000000,488281250,491520000,492075000,497664000,500000000,503316480,503884800,506250000,509607936,510183360,512000000,512578125,516560652,518400000,\\n\\n524288000,524880000,527343750,530841600,531441000,536870912,537477120,540000000,544195584,546750000,552960000,553584375,559872000,562500000,566231040,566870400,569531250,573308928,573956280,576000000,583200000,585937500,589824000,590490000,597196800,597871125,600000000,603979776,604661760,607500000,612220032,614400000,615093750,622080000,625000000,629145600,629856000,632812500,637009920,637729200,640000000,644972544,645700815,648000000,655360000,656100000,663552000,664301250,671088640,671846400,675000000,679477248,680244480,683437500,688747536,691200000,699840000,703125000,707788800,708588000,716636160,717445350,720000000,725594112,729000000,732421875,737280000,738112500,746496000,750000000,754974720,755827200,759375000,764411904,765275040,768000000,774840978,777600000,781250000,786432000,787320000,791015625,796262400,797161500,800000000,805306368,806215680,810000000,816293376,819200000,820125000,829440000,838860800,839808000,843750000,849346560,850305600,854296875,859963392,860934420,864000000,874800000,878906250,884736000,885735000,895795200,900000000,905969664,906992640,911250000,918330048,921600000,922640625,933120000,937500000,943718400,944784000,949218750,955514880,956593800,960000000,967458816,972000000,976562500,983040000,984150000,995328000,996451875,1000000000,1006632960,1007769600,1012500000,1019215872,1020366720,1024000000,1025156250,1033121304,1036800000,1048576000,1049760000,1054687500,1061683200,1062882000,1073741824,1074954240,1076168025,1080000000,1088391168,1093500000,1105920000,1107168750,1119744000,1125000000,1132462080,1133740800,1139062500,1146617856,1147912560,1152000000,1162261467,1166400000,1171875000,1179648000,1180980000,1194393600,1195742250,1200000000,1207959552,1209323520,1215000000,1220703125,1224440064,1228800000,1230187500,1244160000,1250000000,1258291200,1259712000,1265625000,1274019840,1275458400,1280000000,1289945088,1291401630,1296000000,1310720000,1312200000,1318359375,1327104000,1328602500,1342177280,1343692800,1350000000,1358954496,1360488960,1366875000,1377495072,1382400000,1399680000,1406250000,1415577600,1417176000,1423828125,1433272320,1434890700,1440000000,1451188224,1458000000,1464843750,1474560000,1476225000,1492992000,1500000000,1509949440,1511654400,1518750000,1528823808,1530550080,1536000000,1537734375,1549681956,1555200000,1562500000,1572864000,1574640000,1582031250,1592524800,1594323000,1600000000,1610612736,1612431360,1620000000,1632586752,1638400000,1640250000,1658880000,1660753125,1677721600,1679616000,1687500000,1698693120,1700611200,1708593750,1719926784,1721868840,1728000000,1749600000,1757812500,1769472000,1771470000,1791590400,1793613375,1800000000,1811939328,1813985280,1822500000,1836660096,1843200000,1845281250,1866240000,1875000000,1887436800,1889568000,1898437500,1911029760,1913187600,1920000000,1934917632,1937102445,1944000000,1953125000,1966080000,1968300000,1990656000,1992903750,2000000000,2013265920,2015539200,2025000000,2038431744,2040733440,2048000000,2050312500,2066242608,2073600000,2097152000,2099520000,2109375000,2123366400,2125764000,2147483648,2149908480,2152336050,2160000000,2176782336,2187000000,2197265625,2211840000,2214337500,2239488000\\n\\n\\n};\\n\\n    int nthUglyNumber(int n) {\\n        return ar[n-1]; \\n    }\\n};`"
                    },
                    {
                        "username": "AasheeshLikePanner",
                        "content": "Bro stop this \\uD83D\\uDE2D\\uD83D\\uDE2D\\uD83D\\uDE2D"
                    },
                    {
                        "username": "Mayank_Shahria",
                        "content": "**I have solved this by two methods \\n1. Brute force**\\nBut it is giving a run time error\\n![image](https://assets.leetcode.com/users/images/ba539fa1-405b-4d9d-832a-5be83172edc4_1620554425.1931248.png)\\n**2. Dynamic Programing**\\n![image](https://assets.leetcode.com/users/images/3a90f09e-1a3c-465f-a8d6-b58bfc613ccf_1620554465.9711976.png)\\n\\n\\n"
                    },
                    {
                        "username": "aman_online67",
                        "content": "I also applied brute force but it gives TLE at some 500 test case. But logic wise it is correct what to do now"
                    },
                    {
                        "username": "Rohith6776",
                        "content": "If the prime factors are limited to 2,3,5 and we should not consider numbers like(14->2*7, 21->3*7) right?"
                    },
                    {
                        "username": "wtfcoder",
                        "content": "yup"
                    },
                    {
                        "username": "c_jain",
                        "content": "After reading top solutions here, I realized optimized solution is not a DP solution because I am not able to figure out optimal substructure and overlapping subproblem. I think it is kind of 3 pointer solution. Anyone like to clarify this?"
                    },
                    {
                        "username": "vikasboss6855",
                        "content": "https://leetcode.com/problems/ugly-number-ii/solutions/3704058/c-memoized-solution-using-dp-forcible-dp/"
                    },
                    {
                        "username": "Gismet",
                        "content": "Yeah, you are right. I don't also think there is an optimal substructure and overlapping subproblem. I think the reason why they called this DP solution is that we use the previously computed ugly numbers to find the next one. If you checked out the hint, they say you can get the next ugly number from a smaller ugly number by multiplying it by either 2, 3 or 5. So we start from the bottom and work our way up to the nth ugly number, in each iteration finding the next ugly number using a previous one. But to see the overlapping subproblems, one would write a recursive solution, also called top-down, and see if there are any subproblems that overlaps. But I couldn't come up with recursive top-down solution. Or maybe there is an optimal substructure that I fail to see. "
                    },
                    {
                        "username": "logical_thinker",
                        "content": "can someone throw light on the last test case which is n being empty the 596th test case. what is that and how do I go about it."
                    },
                    {
                        "username": "urmichm",
                        "content": "why is 1 ugly number?"
                    },
                    {
                        "username": "at218808",
                        "content": "1 is a factor of every number , so its more like a ugly number has only factors as 1,2,3 or 5"
                    },
                    {
                        "username": "QuasiRus",
                        "content": "It does not have any prime factor outside [2, 3, 5] list. 1 itself is not a prime number."
                    }
                ]
            },
            {
                "id": 1573711,
                "content": [
                    {
                        "username": "lcn",
                        "content": " 1. Actually, the input space is much smaller than expected if we insist an `int` range output. \\nWhen input `n` is greater than `1691`, the output overflows the `int` range.\\n 2. Another way to view this bound is that all ugly numbers must be in the form `2^a*3^b*5^c`. Since we have `log2(Integer.MAX_VALUE)=a<31`, `log3(Integer.MAX_VALUE)=b<20` and `log5(Integer.MAX_VALUE)=c<14`, the combination allowed is surely under `31*20*14~=8400`.\\n\\nSo ugly number is sparser than one would usually think, and please do take care of overflow."
                    },
                    {
                        "username": "chauhanprerna21",
                        "content": "I am not able to understand how is ugly numbers a DP problem?\\nWould be great if someone could help with it."
                    },
                    {
                        "username": "vikasboss6855",
                        "content": "https://leetcode.com/problems/ugly-number-ii/solutions/3704058/c-memoized-solution-using-dp-forcible-dp/\n```\nclass Solution {\npublic:\n    int nthUglyNumber(int n) {\n        vector<int> dp(n);\n        dp[0] = 1;\n        return nthUglyNumberRecursive(dp, n, 1, 0, 0, 0);\n    }\n\nprivate:\n    int nthUglyNumberRecursive(vector<int>& dp, int n, int i, int p1, int p2, int p3) {\n        if (i == n) {\n            return dp[n - 1];\n        }\n\n        int twoMultiple = dp[p1] * 2;\n        int threeMultiple = dp[p2] * 3;\n        int fiveMultiple = dp[p3] * 5;\n\n        dp[i] = min(twoMultiple, min(threeMultiple, fiveMultiple));\n\n        int nextP1 = (dp[i] == twoMultiple) ? p1 + 1 : p1;\n        int nextP2 = (dp[i] == threeMultiple) ? p2 + 1 : p2;\n        int nextP3 = (dp[i] == fiveMultiple) ? p3 + 1 : p3;\n\n        return nthUglyNumberRecursive(dp, n, i + 1, nextP1, nextP2, nextP3);\n    }\n};\n\n```"
                    },
                    {
                        "username": "divyanshuparg",
                        "content": "I have solved it using recursion and hashing."
                    },
                    {
                        "username": "anshulguleria",
                        "content": "In the example in problem statement 1 was being counted as ugly number. I am not able to understand how we concluded that.\\n\\nif 1 = 1 * 2^0 then this theory will be true for other numbers as well like 7  * 2^0."
                    },
                    {
                        "username": "Seabayley",
                        "content": "![image](https://assets.leetcode.com/users/images/fad90901-6c35-455e-8ff0-8160380ca46c_1597993223.2791212.png)\\n\\nAm I misunderstanding the problem? The 11th ugly numbers looks to me as though it should be 14?"
                    },
                    {
                        "username": "codekorekhai",
                        "content": "[@satyamkumarskr](/satyamkumarskr) 14 is not an ugly number because it has 7 as factor but the problem said that only 2, 3, 5 will be the prime factor for each ugly number."
                    },
                    {
                        "username": "satyamkumarskr",
                        "content": "True . I got the same issue."
                    },
                    {
                        "username": "user6746E",
                        "content": "The 11th ugly number will not be 14 since the prime factor of 14 includes 7, but the question clearly states that the primes factor should be limited to 2, 3 or 5. Therefore 11th ugly number will be 15."
                    },
                    {
                        "username": "sazib204061",
                        "content": "I solve this problem in O(1) time complexity.\\n `class Solution {\\npublic:\\nvector<long long>ar = {1,2,3,4,5,6,8,9,10,12,15,16,18,20,24,25,27,30,32,36,40,45,48,50,54,60,64,72,75,80,81,90,96,100,108,120,125,128,135,144,150,160,162,180,192,200,216,225,240,243,250,256,270,288,300,320,324,360,375,384,400,405,432,450,480,486,500,512,540,576,600,625,640,648,675,720,729,750,768,800,810,864,900,960,972,1000,1024,1080,1125,1152,1200,1215,1250,1280,1296,1350,1440,1458,1500,1536,1600,1620,1728,1800,1875,1920,1944,2000,2025,2048,2160,2187,2250,2304,2400,2430,2500,2560,2592,2700,2880,2916,3000,3072,3125,3200,3240,3375,3456,3600,3645,3750,3840,3888,4000,4050,4096,4320,4374,4500,4608,4800,4860,5000,5120,5184,5400,5625,5760,5832,6000,6075,6144,6250,6400,6480,6561,6750,6912,7200,7290,7500,7680,7776,8000,8100,8192,8640,8748,9000,9216,9375,9600,9720,10000,10125,10240,10368,10800,10935,11250,11520,11664,12000,12150,12288,12500,12800,12960,13122,13500,13824,14400,14580,15000,15360,15552,15625,16000,16200,16384,16875,17280,17496,18000,18225,18432,18750,19200,19440,19683,20000,20250,20480,20736,21600,21870,22500,23040,23328,24000,24300,24576,25000,25600,25920,26244,27000,27648,28125,28800,29160,30000,30375,30720,31104,31250,32000,32400,32768,32805,33750,34560,34992,36000,36450,36864,37500,38400,38880,39366,40000,40500,40960,41472,43200,43740,45000,46080,46656,46875,48000,48600,49152,50000,50625,51200,51840,52488,54000,54675,55296,56250,57600,58320,59049,60000,60750,61440,62208,62500,64000,64800,65536,65610,67500,69120,69984,72000,72900,73728,75000,76800,77760,78125,78732,80000,81000,81920,82944,84375,86400,87480,90000,91125,92160,93312,93750,96000,97200,98304,98415,100000,101250,102400,103680,104976,108000,109350,110592,112500,115200,116640,118098,120000,121500,122880,124416,125000,128000,129600,131072,131220,135000,138240,139968,140625,144000,145800,147456,150000,151875,153600,155520,156250,157464,160000,162000,163840,164025,165888,168750,172800,174960,177147,180000,182250,184320,186624,187500,192000,194400,196608,196830,200000,202500,204800,207360,209952,216000,218700,221184,225000,230400,233280,234375,236196,240000,243000,245760,248832,250000,253125,256000,259200,262144,262440,270000,273375,276480,279936,281250,288000,291600,294912,295245,300000,303750,307200,311040,312500,314928,320000,324000,327680,328050,331776,337500,345600,349920,354294,360000,364500,368640,373248,375000,384000,388800,390625,393216,393660,400000,405000,409600,414720,419904,421875,432000,437400,442368,450000,455625,460800,466560,468750,472392,480000,486000,491520,492075,497664,500000,506250,512000,518400,524288,524880,531441,540000,546750,552960,559872,562500,576000,583200,589824,590490,600000,607500,614400,622080,625000,629856,640000,648000,655360,656100,663552,675000,691200,699840,703125,708588,720000,729000,737280,746496,750000,759375,768000,777600,781250,786432,787320,800000,810000,819200,820125,829440,839808,843750,864000,874800,884736,885735,900000,911250,921600,933120,937500,944784,\\n\\n960000,972000,983040,984150,995328,1000000,1012500,1024000,1036800,1048576,1049760,1062882,1080000,1093500,1105920,1119744,1125000,1152000,1166400,1171875,1179648,1180980,1200000,1215000,1228800,1244160,1250000,1259712,1265625,1280000,1296000,1310720,1312200,1327104,1350000,1366875,1382400,1399680,1406250,1417176,1440000,1458000,1474560,1476225,1492992,1500000,1518750,1536000,1555200,1562500,1572864,1574640,1594323,1600000,1620000,1638400,1640250,1658880,1679616,1687500,1728000,1749600,1769472,1771470,1800000,1822500,1843200,1866240,1875000,1889568,1920000,1944000,1953125,1966080,1968300,1990656,2000000,2025000,2048000,2073600,2097152,2099520,2109375,2125764,2160000,2187000,2211840,2239488,2250000,2278125,2304000,2332800,2343750,2359296,2361960,2400000,2430000,2457600,2460375,2488320,2500000,2519424,2531250,2560000,2592000,2621440,2624400,2654208,2657205,2700000,2733750,2764800,2799360,2812500,2834352,2880000,2916000,2949120,2952450,2985984,3000000,3037500,3072000,3110400,3125000,3145728,3149280,3188646,3200000,3240000,3276800,3280500,3317760,3359232,3375000,3456000,3499200,3515625,3538944,3542940,3600000,3645000,3686400,3732480,3750000,3779136,3796875,3840000,3888000,3906250,3932160,3936600,3981312,4000000,4050000,4096000,4100625,4147200,4194304,4199040,4218750,4251528,4320000,4374000,4423680,4428675,4478976,4500000,4556250,4608000,4665600,4687500,4718592,4723920,4782969,4800000,4860000,4915200,4920750,4976640,5000000,5038848,5062500,5120000,5184000,5242880,5248800,5308416,5314410,5400000,5467500,5529600,5598720,5625000,5668704,5760000,5832000,5859375,5898240,5904900,5971968,6000000,6075000,6144000,6220800,6250000,6291456,6298560,6328125,6377292,6400000,6480000,6553600,6561000,6635520,6718464,6750000,6834375,6912000,6998400,7031250,7077888,7085880,7200000,7290000,7372800,7381125,7464960,7500000,7558272,7593750,7680000,7776000,7812500,7864320,7873200,7962624,7971615,8000000,8100000,8192000,8201250,8294400,8388608,8398080,8437500,8503056,8640000,8748000,8847360,8857350,8957952,9000000,9112500,9216000,9331200,9375000,9437184,9447840,9565938,9600000,9720000,9765625,9830400,9841500,9953280,10000000,10077696,10125000,10240000,10368000,10485760,10497600,10546875,10616832,10628820,10800000,10935000,11059200,11197440,11250000,11337408,11390625,11520000,11664000,11718750,11796480,11809800,11943936,12000000,12150000,12288000,12301875,12441600,12500000,12582912,12597120,12656250,12754584,12800000,12960000,13107200,13122000,13271040,13286025,13436928,13500000,13668750,13824000,13996800,14062500,14155776,14171760,14348907,14400000,14580000,14745600,14762250,14929920,15000000,15116544,15187500,15360000,15552000,15625000,15728640,15746400,15925248,15943230,16000000,16200000,16384000,16402500,16588800,16777216,16796160,16875000,17006112,17280000,17496000,17578125,17694720,17714700,17915904,18000000,18225000,18432000,18662400,18750000,18874368,18895680,18984375,19131876,19200000,19440000,19531250,19660800,19683000,19906560,20000000,20155392,20250000,20480000,20503125,20736000,20971520,20995200,21093750,21233664,21257640,21600000,21870000,22118400,22143375,22394880,22500000,22674816,22781250,23040000,23328000,23437500,23592960,23619600,23887872,23914845,24000000,24300000,24576000,24603750,24883200,25000000,25165824,25194240,25312500,25509168,25600000,25920000,26214400,26244000,26542080,26572050,26873856,27000000,27337500,27648000,27993600,28125000,28311552,28343520,28697814,28800000,29160000,29296875,29491200,29524500,29859840,30000000,30233088,30375000,30720000,31104000,31250000,31457280,31492800,31640625,31850496,31886460,32000000,32400000,32768000,32805000,33177600,33554432,33592320,33750000,34012224,34171875,34560000,34992000,35156250,35389440,35429400,35831808,36000000,36450000,36864000,36905625,37324800,37500000,37748736,37791360,37968750,38263752,38400000,38880000,39062500,39321600,39366000,39813120,39858075,40000000,40310784,40500000,40960000,41006250,41472000,41943040,41990400,42187500,42467328,42515280,43046721,43200000,43740000,44236800,44286750,44789760,45000000,45349632,45562500,46080000,46656000,46875000,47185920,47239200,47775744,47829690,48000000,48600000,48828125,49152000,49207500,49766400,50000000,50331648,50388480,50625000,51018336,51200000,51840000,\\n\\n52428800,52488000,52734375,53084160,53144100,53747712,54000000,54675000,55296000,55987200,56250000,56623104,56687040,56953125,57395628,57600000,58320000,58593750,58982400,59049000,59719680,60000000,60466176,60750000,61440000,61509375,62208000,62500000,62914560,62985600,63281250,63700992,63772920,64000000,64800000,65536000,65610000,66355200,66430125,67108864,67184640,67500000,68024448,68343750,69120000,69984000,70312500,70778880,70858800,71663616,71744535,72000000,72900000,73728000,73811250,74649600,75000000,75497472,75582720,75937500,76527504,76800000,77760000,78125000,78643200,78732000,79626240,79716150,80000000,80621568,81000000,81920000,82012500,82944000,83886080,83980800,84375000,84934656,85030560,86093442,86400000,87480000,87890625,88473600,88573500,89579520,90000000,90699264,91125000,92160000,93312000,93750000,94371840,94478400,94921875,95551488,95659380,96000000,97200000,97656250,98304000,98415000,99532800,100000000,100663296,100776960,101250000,102036672,102400000,102515625,103680000,104857600,104976000,105468750,106168320,106288200,107495424,108000000,109350000,110592000,110716875,111974400,112500000,113246208,113374080,113906250,114791256,115200000,116640000,117187500,117964800,118098000,119439360,119574225,120000000,120932352,121500000,122880000,123018750,124416000,125000000,125829120,125971200,126562500,127401984,127545840,128000000,129140163,129600000,131072000,131220000,132710400,132860250,134217728,134369280,135000000,136048896,136687500,138240000,139968000,140625000,141557760,141717600,143327232,143489070,144000000,145800000,146484375,147456000,147622500,149299200,150000000,150994944,151165440,151875000,153055008,153600000,155520000,156250000,157286400,157464000,158203125,159252480,159432300,160000000,161243136,162000000,163840000,164025000,165888000,167772160,167961600,168750000,169869312,170061120,170859375,172186884,172800000,174960000,175781250,\\n\\n\\n176947200,177147000,179159040,180000000,181398528,182250000,184320000,184528125,186624000,187500000,188743680,188956800,189843750,191102976,191318760,192000000,194400000,195312500,196608000,196830000,199065600,199290375,200000000,201326592,201553920,202500000,204073344,204800000,205031250,207360000,209715200,209952000,210937500,212336640,212576400,214990848,215233605,216000000,218700000,221184000,221433750,223948800,225000000,226492416,226748160,227812500,229582512,230400000,233280000,234375000,235929600,236196000,238878720,239148450,240000000,241864704,243000000,244140625,245760000,246037500,248832000,250000000,251658240,251942400,253125000,254803968,255091680,256000000,258280326,259200000,262144000,262440000,263671875,265420800,265720500,268435456,268738560,270000000,272097792,273375000,276480000,279936000,281250000,283115520,283435200,284765625,286654464,286978140,288000000,291600000,292968750,294912000,295245000,298598400,300000000,301989888,302330880,303750000,306110016,307200000,307546875,311040000,312500000,314572800,314928000,316406250,318504960,318864600,320000000,322486272,324000000,327680000,328050000,331776000,332150625,335544320,335923200,337500000,339738624,340122240,341718750,344373768,345600000,349920000,351562500,353894400,354294000,358318080,358722675,360000000,362797056,364500000,368640000,369056250,373248000,375000000,377487360,377913600,379687500,382205952,382637520,384000000,387420489,388800000,390625000,393216000,393660000,398131200,398580750,400000000,402653184,403107840,405000000,408146688,409600000,410062500,414720000,419430400,419904000,421875000,424673280,425152800,429981696,430467210,432000000,437400000,439453125,442368000,442867500,447897600,450000000,452984832,453496320,455625000,459165024,460800000,466560000,468750000,471859200,472392000,474609375,477757440,478296900,480000000,483729408,486000000,488281250,491520000,492075000,497664000,500000000,503316480,503884800,506250000,509607936,510183360,512000000,512578125,516560652,518400000,\\n\\n524288000,524880000,527343750,530841600,531441000,536870912,537477120,540000000,544195584,546750000,552960000,553584375,559872000,562500000,566231040,566870400,569531250,573308928,573956280,576000000,583200000,585937500,589824000,590490000,597196800,597871125,600000000,603979776,604661760,607500000,612220032,614400000,615093750,622080000,625000000,629145600,629856000,632812500,637009920,637729200,640000000,644972544,645700815,648000000,655360000,656100000,663552000,664301250,671088640,671846400,675000000,679477248,680244480,683437500,688747536,691200000,699840000,703125000,707788800,708588000,716636160,717445350,720000000,725594112,729000000,732421875,737280000,738112500,746496000,750000000,754974720,755827200,759375000,764411904,765275040,768000000,774840978,777600000,781250000,786432000,787320000,791015625,796262400,797161500,800000000,805306368,806215680,810000000,816293376,819200000,820125000,829440000,838860800,839808000,843750000,849346560,850305600,854296875,859963392,860934420,864000000,874800000,878906250,884736000,885735000,895795200,900000000,905969664,906992640,911250000,918330048,921600000,922640625,933120000,937500000,943718400,944784000,949218750,955514880,956593800,960000000,967458816,972000000,976562500,983040000,984150000,995328000,996451875,1000000000,1006632960,1007769600,1012500000,1019215872,1020366720,1024000000,1025156250,1033121304,1036800000,1048576000,1049760000,1054687500,1061683200,1062882000,1073741824,1074954240,1076168025,1080000000,1088391168,1093500000,1105920000,1107168750,1119744000,1125000000,1132462080,1133740800,1139062500,1146617856,1147912560,1152000000,1162261467,1166400000,1171875000,1179648000,1180980000,1194393600,1195742250,1200000000,1207959552,1209323520,1215000000,1220703125,1224440064,1228800000,1230187500,1244160000,1250000000,1258291200,1259712000,1265625000,1274019840,1275458400,1280000000,1289945088,1291401630,1296000000,1310720000,1312200000,1318359375,1327104000,1328602500,1342177280,1343692800,1350000000,1358954496,1360488960,1366875000,1377495072,1382400000,1399680000,1406250000,1415577600,1417176000,1423828125,1433272320,1434890700,1440000000,1451188224,1458000000,1464843750,1474560000,1476225000,1492992000,1500000000,1509949440,1511654400,1518750000,1528823808,1530550080,1536000000,1537734375,1549681956,1555200000,1562500000,1572864000,1574640000,1582031250,1592524800,1594323000,1600000000,1610612736,1612431360,1620000000,1632586752,1638400000,1640250000,1658880000,1660753125,1677721600,1679616000,1687500000,1698693120,1700611200,1708593750,1719926784,1721868840,1728000000,1749600000,1757812500,1769472000,1771470000,1791590400,1793613375,1800000000,1811939328,1813985280,1822500000,1836660096,1843200000,1845281250,1866240000,1875000000,1887436800,1889568000,1898437500,1911029760,1913187600,1920000000,1934917632,1937102445,1944000000,1953125000,1966080000,1968300000,1990656000,1992903750,2000000000,2013265920,2015539200,2025000000,2038431744,2040733440,2048000000,2050312500,2066242608,2073600000,2097152000,2099520000,2109375000,2123366400,2125764000,2147483648,2149908480,2152336050,2160000000,2176782336,2187000000,2197265625,2211840000,2214337500,2239488000\\n\\n\\n};\\n\\n    int nthUglyNumber(int n) {\\n        return ar[n-1]; \\n    }\\n};`"
                    },
                    {
                        "username": "AasheeshLikePanner",
                        "content": "Bro stop this \\uD83D\\uDE2D\\uD83D\\uDE2D\\uD83D\\uDE2D"
                    },
                    {
                        "username": "Mayank_Shahria",
                        "content": "**I have solved this by two methods \\n1. Brute force**\\nBut it is giving a run time error\\n![image](https://assets.leetcode.com/users/images/ba539fa1-405b-4d9d-832a-5be83172edc4_1620554425.1931248.png)\\n**2. Dynamic Programing**\\n![image](https://assets.leetcode.com/users/images/3a90f09e-1a3c-465f-a8d6-b58bfc613ccf_1620554465.9711976.png)\\n\\n\\n"
                    },
                    {
                        "username": "aman_online67",
                        "content": "I also applied brute force but it gives TLE at some 500 test case. But logic wise it is correct what to do now"
                    },
                    {
                        "username": "Rohith6776",
                        "content": "If the prime factors are limited to 2,3,5 and we should not consider numbers like(14->2*7, 21->3*7) right?"
                    },
                    {
                        "username": "wtfcoder",
                        "content": "yup"
                    },
                    {
                        "username": "c_jain",
                        "content": "After reading top solutions here, I realized optimized solution is not a DP solution because I am not able to figure out optimal substructure and overlapping subproblem. I think it is kind of 3 pointer solution. Anyone like to clarify this?"
                    },
                    {
                        "username": "vikasboss6855",
                        "content": "https://leetcode.com/problems/ugly-number-ii/solutions/3704058/c-memoized-solution-using-dp-forcible-dp/"
                    },
                    {
                        "username": "Gismet",
                        "content": "Yeah, you are right. I don't also think there is an optimal substructure and overlapping subproblem. I think the reason why they called this DP solution is that we use the previously computed ugly numbers to find the next one. If you checked out the hint, they say you can get the next ugly number from a smaller ugly number by multiplying it by either 2, 3 or 5. So we start from the bottom and work our way up to the nth ugly number, in each iteration finding the next ugly number using a previous one. But to see the overlapping subproblems, one would write a recursive solution, also called top-down, and see if there are any subproblems that overlaps. But I couldn't come up with recursive top-down solution. Or maybe there is an optimal substructure that I fail to see. "
                    },
                    {
                        "username": "logical_thinker",
                        "content": "can someone throw light on the last test case which is n being empty the 596th test case. what is that and how do I go about it."
                    },
                    {
                        "username": "urmichm",
                        "content": "why is 1 ugly number?"
                    },
                    {
                        "username": "at218808",
                        "content": "1 is a factor of every number , so its more like a ugly number has only factors as 1,2,3 or 5"
                    },
                    {
                        "username": "QuasiRus",
                        "content": "It does not have any prime factor outside [2, 3, 5] list. 1 itself is not a prime number."
                    }
                ]
            },
            {
                "id": 1574250,
                "content": [
                    {
                        "username": "lcn",
                        "content": " 1. Actually, the input space is much smaller than expected if we insist an `int` range output. \\nWhen input `n` is greater than `1691`, the output overflows the `int` range.\\n 2. Another way to view this bound is that all ugly numbers must be in the form `2^a*3^b*5^c`. Since we have `log2(Integer.MAX_VALUE)=a<31`, `log3(Integer.MAX_VALUE)=b<20` and `log5(Integer.MAX_VALUE)=c<14`, the combination allowed is surely under `31*20*14~=8400`.\\n\\nSo ugly number is sparser than one would usually think, and please do take care of overflow."
                    },
                    {
                        "username": "chauhanprerna21",
                        "content": "I am not able to understand how is ugly numbers a DP problem?\\nWould be great if someone could help with it."
                    },
                    {
                        "username": "vikasboss6855",
                        "content": "https://leetcode.com/problems/ugly-number-ii/solutions/3704058/c-memoized-solution-using-dp-forcible-dp/\n```\nclass Solution {\npublic:\n    int nthUglyNumber(int n) {\n        vector<int> dp(n);\n        dp[0] = 1;\n        return nthUglyNumberRecursive(dp, n, 1, 0, 0, 0);\n    }\n\nprivate:\n    int nthUglyNumberRecursive(vector<int>& dp, int n, int i, int p1, int p2, int p3) {\n        if (i == n) {\n            return dp[n - 1];\n        }\n\n        int twoMultiple = dp[p1] * 2;\n        int threeMultiple = dp[p2] * 3;\n        int fiveMultiple = dp[p3] * 5;\n\n        dp[i] = min(twoMultiple, min(threeMultiple, fiveMultiple));\n\n        int nextP1 = (dp[i] == twoMultiple) ? p1 + 1 : p1;\n        int nextP2 = (dp[i] == threeMultiple) ? p2 + 1 : p2;\n        int nextP3 = (dp[i] == fiveMultiple) ? p3 + 1 : p3;\n\n        return nthUglyNumberRecursive(dp, n, i + 1, nextP1, nextP2, nextP3);\n    }\n};\n\n```"
                    },
                    {
                        "username": "divyanshuparg",
                        "content": "I have solved it using recursion and hashing."
                    },
                    {
                        "username": "anshulguleria",
                        "content": "In the example in problem statement 1 was being counted as ugly number. I am not able to understand how we concluded that.\\n\\nif 1 = 1 * 2^0 then this theory will be true for other numbers as well like 7  * 2^0."
                    },
                    {
                        "username": "Seabayley",
                        "content": "![image](https://assets.leetcode.com/users/images/fad90901-6c35-455e-8ff0-8160380ca46c_1597993223.2791212.png)\\n\\nAm I misunderstanding the problem? The 11th ugly numbers looks to me as though it should be 14?"
                    },
                    {
                        "username": "codekorekhai",
                        "content": "[@satyamkumarskr](/satyamkumarskr) 14 is not an ugly number because it has 7 as factor but the problem said that only 2, 3, 5 will be the prime factor for each ugly number."
                    },
                    {
                        "username": "satyamkumarskr",
                        "content": "True . I got the same issue."
                    },
                    {
                        "username": "user6746E",
                        "content": "The 11th ugly number will not be 14 since the prime factor of 14 includes 7, but the question clearly states that the primes factor should be limited to 2, 3 or 5. Therefore 11th ugly number will be 15."
                    },
                    {
                        "username": "sazib204061",
                        "content": "I solve this problem in O(1) time complexity.\\n `class Solution {\\npublic:\\nvector<long long>ar = {1,2,3,4,5,6,8,9,10,12,15,16,18,20,24,25,27,30,32,36,40,45,48,50,54,60,64,72,75,80,81,90,96,100,108,120,125,128,135,144,150,160,162,180,192,200,216,225,240,243,250,256,270,288,300,320,324,360,375,384,400,405,432,450,480,486,500,512,540,576,600,625,640,648,675,720,729,750,768,800,810,864,900,960,972,1000,1024,1080,1125,1152,1200,1215,1250,1280,1296,1350,1440,1458,1500,1536,1600,1620,1728,1800,1875,1920,1944,2000,2025,2048,2160,2187,2250,2304,2400,2430,2500,2560,2592,2700,2880,2916,3000,3072,3125,3200,3240,3375,3456,3600,3645,3750,3840,3888,4000,4050,4096,4320,4374,4500,4608,4800,4860,5000,5120,5184,5400,5625,5760,5832,6000,6075,6144,6250,6400,6480,6561,6750,6912,7200,7290,7500,7680,7776,8000,8100,8192,8640,8748,9000,9216,9375,9600,9720,10000,10125,10240,10368,10800,10935,11250,11520,11664,12000,12150,12288,12500,12800,12960,13122,13500,13824,14400,14580,15000,15360,15552,15625,16000,16200,16384,16875,17280,17496,18000,18225,18432,18750,19200,19440,19683,20000,20250,20480,20736,21600,21870,22500,23040,23328,24000,24300,24576,25000,25600,25920,26244,27000,27648,28125,28800,29160,30000,30375,30720,31104,31250,32000,32400,32768,32805,33750,34560,34992,36000,36450,36864,37500,38400,38880,39366,40000,40500,40960,41472,43200,43740,45000,46080,46656,46875,48000,48600,49152,50000,50625,51200,51840,52488,54000,54675,55296,56250,57600,58320,59049,60000,60750,61440,62208,62500,64000,64800,65536,65610,67500,69120,69984,72000,72900,73728,75000,76800,77760,78125,78732,80000,81000,81920,82944,84375,86400,87480,90000,91125,92160,93312,93750,96000,97200,98304,98415,100000,101250,102400,103680,104976,108000,109350,110592,112500,115200,116640,118098,120000,121500,122880,124416,125000,128000,129600,131072,131220,135000,138240,139968,140625,144000,145800,147456,150000,151875,153600,155520,156250,157464,160000,162000,163840,164025,165888,168750,172800,174960,177147,180000,182250,184320,186624,187500,192000,194400,196608,196830,200000,202500,204800,207360,209952,216000,218700,221184,225000,230400,233280,234375,236196,240000,243000,245760,248832,250000,253125,256000,259200,262144,262440,270000,273375,276480,279936,281250,288000,291600,294912,295245,300000,303750,307200,311040,312500,314928,320000,324000,327680,328050,331776,337500,345600,349920,354294,360000,364500,368640,373248,375000,384000,388800,390625,393216,393660,400000,405000,409600,414720,419904,421875,432000,437400,442368,450000,455625,460800,466560,468750,472392,480000,486000,491520,492075,497664,500000,506250,512000,518400,524288,524880,531441,540000,546750,552960,559872,562500,576000,583200,589824,590490,600000,607500,614400,622080,625000,629856,640000,648000,655360,656100,663552,675000,691200,699840,703125,708588,720000,729000,737280,746496,750000,759375,768000,777600,781250,786432,787320,800000,810000,819200,820125,829440,839808,843750,864000,874800,884736,885735,900000,911250,921600,933120,937500,944784,\\n\\n960000,972000,983040,984150,995328,1000000,1012500,1024000,1036800,1048576,1049760,1062882,1080000,1093500,1105920,1119744,1125000,1152000,1166400,1171875,1179648,1180980,1200000,1215000,1228800,1244160,1250000,1259712,1265625,1280000,1296000,1310720,1312200,1327104,1350000,1366875,1382400,1399680,1406250,1417176,1440000,1458000,1474560,1476225,1492992,1500000,1518750,1536000,1555200,1562500,1572864,1574640,1594323,1600000,1620000,1638400,1640250,1658880,1679616,1687500,1728000,1749600,1769472,1771470,1800000,1822500,1843200,1866240,1875000,1889568,1920000,1944000,1953125,1966080,1968300,1990656,2000000,2025000,2048000,2073600,2097152,2099520,2109375,2125764,2160000,2187000,2211840,2239488,2250000,2278125,2304000,2332800,2343750,2359296,2361960,2400000,2430000,2457600,2460375,2488320,2500000,2519424,2531250,2560000,2592000,2621440,2624400,2654208,2657205,2700000,2733750,2764800,2799360,2812500,2834352,2880000,2916000,2949120,2952450,2985984,3000000,3037500,3072000,3110400,3125000,3145728,3149280,3188646,3200000,3240000,3276800,3280500,3317760,3359232,3375000,3456000,3499200,3515625,3538944,3542940,3600000,3645000,3686400,3732480,3750000,3779136,3796875,3840000,3888000,3906250,3932160,3936600,3981312,4000000,4050000,4096000,4100625,4147200,4194304,4199040,4218750,4251528,4320000,4374000,4423680,4428675,4478976,4500000,4556250,4608000,4665600,4687500,4718592,4723920,4782969,4800000,4860000,4915200,4920750,4976640,5000000,5038848,5062500,5120000,5184000,5242880,5248800,5308416,5314410,5400000,5467500,5529600,5598720,5625000,5668704,5760000,5832000,5859375,5898240,5904900,5971968,6000000,6075000,6144000,6220800,6250000,6291456,6298560,6328125,6377292,6400000,6480000,6553600,6561000,6635520,6718464,6750000,6834375,6912000,6998400,7031250,7077888,7085880,7200000,7290000,7372800,7381125,7464960,7500000,7558272,7593750,7680000,7776000,7812500,7864320,7873200,7962624,7971615,8000000,8100000,8192000,8201250,8294400,8388608,8398080,8437500,8503056,8640000,8748000,8847360,8857350,8957952,9000000,9112500,9216000,9331200,9375000,9437184,9447840,9565938,9600000,9720000,9765625,9830400,9841500,9953280,10000000,10077696,10125000,10240000,10368000,10485760,10497600,10546875,10616832,10628820,10800000,10935000,11059200,11197440,11250000,11337408,11390625,11520000,11664000,11718750,11796480,11809800,11943936,12000000,12150000,12288000,12301875,12441600,12500000,12582912,12597120,12656250,12754584,12800000,12960000,13107200,13122000,13271040,13286025,13436928,13500000,13668750,13824000,13996800,14062500,14155776,14171760,14348907,14400000,14580000,14745600,14762250,14929920,15000000,15116544,15187500,15360000,15552000,15625000,15728640,15746400,15925248,15943230,16000000,16200000,16384000,16402500,16588800,16777216,16796160,16875000,17006112,17280000,17496000,17578125,17694720,17714700,17915904,18000000,18225000,18432000,18662400,18750000,18874368,18895680,18984375,19131876,19200000,19440000,19531250,19660800,19683000,19906560,20000000,20155392,20250000,20480000,20503125,20736000,20971520,20995200,21093750,21233664,21257640,21600000,21870000,22118400,22143375,22394880,22500000,22674816,22781250,23040000,23328000,23437500,23592960,23619600,23887872,23914845,24000000,24300000,24576000,24603750,24883200,25000000,25165824,25194240,25312500,25509168,25600000,25920000,26214400,26244000,26542080,26572050,26873856,27000000,27337500,27648000,27993600,28125000,28311552,28343520,28697814,28800000,29160000,29296875,29491200,29524500,29859840,30000000,30233088,30375000,30720000,31104000,31250000,31457280,31492800,31640625,31850496,31886460,32000000,32400000,32768000,32805000,33177600,33554432,33592320,33750000,34012224,34171875,34560000,34992000,35156250,35389440,35429400,35831808,36000000,36450000,36864000,36905625,37324800,37500000,37748736,37791360,37968750,38263752,38400000,38880000,39062500,39321600,39366000,39813120,39858075,40000000,40310784,40500000,40960000,41006250,41472000,41943040,41990400,42187500,42467328,42515280,43046721,43200000,43740000,44236800,44286750,44789760,45000000,45349632,45562500,46080000,46656000,46875000,47185920,47239200,47775744,47829690,48000000,48600000,48828125,49152000,49207500,49766400,50000000,50331648,50388480,50625000,51018336,51200000,51840000,\\n\\n52428800,52488000,52734375,53084160,53144100,53747712,54000000,54675000,55296000,55987200,56250000,56623104,56687040,56953125,57395628,57600000,58320000,58593750,58982400,59049000,59719680,60000000,60466176,60750000,61440000,61509375,62208000,62500000,62914560,62985600,63281250,63700992,63772920,64000000,64800000,65536000,65610000,66355200,66430125,67108864,67184640,67500000,68024448,68343750,69120000,69984000,70312500,70778880,70858800,71663616,71744535,72000000,72900000,73728000,73811250,74649600,75000000,75497472,75582720,75937500,76527504,76800000,77760000,78125000,78643200,78732000,79626240,79716150,80000000,80621568,81000000,81920000,82012500,82944000,83886080,83980800,84375000,84934656,85030560,86093442,86400000,87480000,87890625,88473600,88573500,89579520,90000000,90699264,91125000,92160000,93312000,93750000,94371840,94478400,94921875,95551488,95659380,96000000,97200000,97656250,98304000,98415000,99532800,100000000,100663296,100776960,101250000,102036672,102400000,102515625,103680000,104857600,104976000,105468750,106168320,106288200,107495424,108000000,109350000,110592000,110716875,111974400,112500000,113246208,113374080,113906250,114791256,115200000,116640000,117187500,117964800,118098000,119439360,119574225,120000000,120932352,121500000,122880000,123018750,124416000,125000000,125829120,125971200,126562500,127401984,127545840,128000000,129140163,129600000,131072000,131220000,132710400,132860250,134217728,134369280,135000000,136048896,136687500,138240000,139968000,140625000,141557760,141717600,143327232,143489070,144000000,145800000,146484375,147456000,147622500,149299200,150000000,150994944,151165440,151875000,153055008,153600000,155520000,156250000,157286400,157464000,158203125,159252480,159432300,160000000,161243136,162000000,163840000,164025000,165888000,167772160,167961600,168750000,169869312,170061120,170859375,172186884,172800000,174960000,175781250,\\n\\n\\n176947200,177147000,179159040,180000000,181398528,182250000,184320000,184528125,186624000,187500000,188743680,188956800,189843750,191102976,191318760,192000000,194400000,195312500,196608000,196830000,199065600,199290375,200000000,201326592,201553920,202500000,204073344,204800000,205031250,207360000,209715200,209952000,210937500,212336640,212576400,214990848,215233605,216000000,218700000,221184000,221433750,223948800,225000000,226492416,226748160,227812500,229582512,230400000,233280000,234375000,235929600,236196000,238878720,239148450,240000000,241864704,243000000,244140625,245760000,246037500,248832000,250000000,251658240,251942400,253125000,254803968,255091680,256000000,258280326,259200000,262144000,262440000,263671875,265420800,265720500,268435456,268738560,270000000,272097792,273375000,276480000,279936000,281250000,283115520,283435200,284765625,286654464,286978140,288000000,291600000,292968750,294912000,295245000,298598400,300000000,301989888,302330880,303750000,306110016,307200000,307546875,311040000,312500000,314572800,314928000,316406250,318504960,318864600,320000000,322486272,324000000,327680000,328050000,331776000,332150625,335544320,335923200,337500000,339738624,340122240,341718750,344373768,345600000,349920000,351562500,353894400,354294000,358318080,358722675,360000000,362797056,364500000,368640000,369056250,373248000,375000000,377487360,377913600,379687500,382205952,382637520,384000000,387420489,388800000,390625000,393216000,393660000,398131200,398580750,400000000,402653184,403107840,405000000,408146688,409600000,410062500,414720000,419430400,419904000,421875000,424673280,425152800,429981696,430467210,432000000,437400000,439453125,442368000,442867500,447897600,450000000,452984832,453496320,455625000,459165024,460800000,466560000,468750000,471859200,472392000,474609375,477757440,478296900,480000000,483729408,486000000,488281250,491520000,492075000,497664000,500000000,503316480,503884800,506250000,509607936,510183360,512000000,512578125,516560652,518400000,\\n\\n524288000,524880000,527343750,530841600,531441000,536870912,537477120,540000000,544195584,546750000,552960000,553584375,559872000,562500000,566231040,566870400,569531250,573308928,573956280,576000000,583200000,585937500,589824000,590490000,597196800,597871125,600000000,603979776,604661760,607500000,612220032,614400000,615093750,622080000,625000000,629145600,629856000,632812500,637009920,637729200,640000000,644972544,645700815,648000000,655360000,656100000,663552000,664301250,671088640,671846400,675000000,679477248,680244480,683437500,688747536,691200000,699840000,703125000,707788800,708588000,716636160,717445350,720000000,725594112,729000000,732421875,737280000,738112500,746496000,750000000,754974720,755827200,759375000,764411904,765275040,768000000,774840978,777600000,781250000,786432000,787320000,791015625,796262400,797161500,800000000,805306368,806215680,810000000,816293376,819200000,820125000,829440000,838860800,839808000,843750000,849346560,850305600,854296875,859963392,860934420,864000000,874800000,878906250,884736000,885735000,895795200,900000000,905969664,906992640,911250000,918330048,921600000,922640625,933120000,937500000,943718400,944784000,949218750,955514880,956593800,960000000,967458816,972000000,976562500,983040000,984150000,995328000,996451875,1000000000,1006632960,1007769600,1012500000,1019215872,1020366720,1024000000,1025156250,1033121304,1036800000,1048576000,1049760000,1054687500,1061683200,1062882000,1073741824,1074954240,1076168025,1080000000,1088391168,1093500000,1105920000,1107168750,1119744000,1125000000,1132462080,1133740800,1139062500,1146617856,1147912560,1152000000,1162261467,1166400000,1171875000,1179648000,1180980000,1194393600,1195742250,1200000000,1207959552,1209323520,1215000000,1220703125,1224440064,1228800000,1230187500,1244160000,1250000000,1258291200,1259712000,1265625000,1274019840,1275458400,1280000000,1289945088,1291401630,1296000000,1310720000,1312200000,1318359375,1327104000,1328602500,1342177280,1343692800,1350000000,1358954496,1360488960,1366875000,1377495072,1382400000,1399680000,1406250000,1415577600,1417176000,1423828125,1433272320,1434890700,1440000000,1451188224,1458000000,1464843750,1474560000,1476225000,1492992000,1500000000,1509949440,1511654400,1518750000,1528823808,1530550080,1536000000,1537734375,1549681956,1555200000,1562500000,1572864000,1574640000,1582031250,1592524800,1594323000,1600000000,1610612736,1612431360,1620000000,1632586752,1638400000,1640250000,1658880000,1660753125,1677721600,1679616000,1687500000,1698693120,1700611200,1708593750,1719926784,1721868840,1728000000,1749600000,1757812500,1769472000,1771470000,1791590400,1793613375,1800000000,1811939328,1813985280,1822500000,1836660096,1843200000,1845281250,1866240000,1875000000,1887436800,1889568000,1898437500,1911029760,1913187600,1920000000,1934917632,1937102445,1944000000,1953125000,1966080000,1968300000,1990656000,1992903750,2000000000,2013265920,2015539200,2025000000,2038431744,2040733440,2048000000,2050312500,2066242608,2073600000,2097152000,2099520000,2109375000,2123366400,2125764000,2147483648,2149908480,2152336050,2160000000,2176782336,2187000000,2197265625,2211840000,2214337500,2239488000\\n\\n\\n};\\n\\n    int nthUglyNumber(int n) {\\n        return ar[n-1]; \\n    }\\n};`"
                    },
                    {
                        "username": "AasheeshLikePanner",
                        "content": "Bro stop this \\uD83D\\uDE2D\\uD83D\\uDE2D\\uD83D\\uDE2D"
                    },
                    {
                        "username": "Mayank_Shahria",
                        "content": "**I have solved this by two methods \\n1. Brute force**\\nBut it is giving a run time error\\n![image](https://assets.leetcode.com/users/images/ba539fa1-405b-4d9d-832a-5be83172edc4_1620554425.1931248.png)\\n**2. Dynamic Programing**\\n![image](https://assets.leetcode.com/users/images/3a90f09e-1a3c-465f-a8d6-b58bfc613ccf_1620554465.9711976.png)\\n\\n\\n"
                    },
                    {
                        "username": "aman_online67",
                        "content": "I also applied brute force but it gives TLE at some 500 test case. But logic wise it is correct what to do now"
                    },
                    {
                        "username": "Rohith6776",
                        "content": "If the prime factors are limited to 2,3,5 and we should not consider numbers like(14->2*7, 21->3*7) right?"
                    },
                    {
                        "username": "wtfcoder",
                        "content": "yup"
                    },
                    {
                        "username": "c_jain",
                        "content": "After reading top solutions here, I realized optimized solution is not a DP solution because I am not able to figure out optimal substructure and overlapping subproblem. I think it is kind of 3 pointer solution. Anyone like to clarify this?"
                    },
                    {
                        "username": "vikasboss6855",
                        "content": "https://leetcode.com/problems/ugly-number-ii/solutions/3704058/c-memoized-solution-using-dp-forcible-dp/"
                    },
                    {
                        "username": "Gismet",
                        "content": "Yeah, you are right. I don't also think there is an optimal substructure and overlapping subproblem. I think the reason why they called this DP solution is that we use the previously computed ugly numbers to find the next one. If you checked out the hint, they say you can get the next ugly number from a smaller ugly number by multiplying it by either 2, 3 or 5. So we start from the bottom and work our way up to the nth ugly number, in each iteration finding the next ugly number using a previous one. But to see the overlapping subproblems, one would write a recursive solution, also called top-down, and see if there are any subproblems that overlaps. But I couldn't come up with recursive top-down solution. Or maybe there is an optimal substructure that I fail to see. "
                    },
                    {
                        "username": "logical_thinker",
                        "content": "can someone throw light on the last test case which is n being empty the 596th test case. what is that and how do I go about it."
                    },
                    {
                        "username": "urmichm",
                        "content": "why is 1 ugly number?"
                    },
                    {
                        "username": "at218808",
                        "content": "1 is a factor of every number , so its more like a ugly number has only factors as 1,2,3 or 5"
                    },
                    {
                        "username": "QuasiRus",
                        "content": "It does not have any prime factor outside [2, 3, 5] list. 1 itself is not a prime number."
                    }
                ]
            },
            {
                "id": 2039889,
                "content": [
                    {
                        "username": "lcn",
                        "content": " 1. Actually, the input space is much smaller than expected if we insist an `int` range output. \\nWhen input `n` is greater than `1691`, the output overflows the `int` range.\\n 2. Another way to view this bound is that all ugly numbers must be in the form `2^a*3^b*5^c`. Since we have `log2(Integer.MAX_VALUE)=a<31`, `log3(Integer.MAX_VALUE)=b<20` and `log5(Integer.MAX_VALUE)=c<14`, the combination allowed is surely under `31*20*14~=8400`.\\n\\nSo ugly number is sparser than one would usually think, and please do take care of overflow."
                    },
                    {
                        "username": "chauhanprerna21",
                        "content": "I am not able to understand how is ugly numbers a DP problem?\\nWould be great if someone could help with it."
                    },
                    {
                        "username": "vikasboss6855",
                        "content": "https://leetcode.com/problems/ugly-number-ii/solutions/3704058/c-memoized-solution-using-dp-forcible-dp/\n```\nclass Solution {\npublic:\n    int nthUglyNumber(int n) {\n        vector<int> dp(n);\n        dp[0] = 1;\n        return nthUglyNumberRecursive(dp, n, 1, 0, 0, 0);\n    }\n\nprivate:\n    int nthUglyNumberRecursive(vector<int>& dp, int n, int i, int p1, int p2, int p3) {\n        if (i == n) {\n            return dp[n - 1];\n        }\n\n        int twoMultiple = dp[p1] * 2;\n        int threeMultiple = dp[p2] * 3;\n        int fiveMultiple = dp[p3] * 5;\n\n        dp[i] = min(twoMultiple, min(threeMultiple, fiveMultiple));\n\n        int nextP1 = (dp[i] == twoMultiple) ? p1 + 1 : p1;\n        int nextP2 = (dp[i] == threeMultiple) ? p2 + 1 : p2;\n        int nextP3 = (dp[i] == fiveMultiple) ? p3 + 1 : p3;\n\n        return nthUglyNumberRecursive(dp, n, i + 1, nextP1, nextP2, nextP3);\n    }\n};\n\n```"
                    },
                    {
                        "username": "divyanshuparg",
                        "content": "I have solved it using recursion and hashing."
                    },
                    {
                        "username": "anshulguleria",
                        "content": "In the example in problem statement 1 was being counted as ugly number. I am not able to understand how we concluded that.\\n\\nif 1 = 1 * 2^0 then this theory will be true for other numbers as well like 7  * 2^0."
                    },
                    {
                        "username": "Seabayley",
                        "content": "![image](https://assets.leetcode.com/users/images/fad90901-6c35-455e-8ff0-8160380ca46c_1597993223.2791212.png)\\n\\nAm I misunderstanding the problem? The 11th ugly numbers looks to me as though it should be 14?"
                    },
                    {
                        "username": "codekorekhai",
                        "content": "[@satyamkumarskr](/satyamkumarskr) 14 is not an ugly number because it has 7 as factor but the problem said that only 2, 3, 5 will be the prime factor for each ugly number."
                    },
                    {
                        "username": "satyamkumarskr",
                        "content": "True . I got the same issue."
                    },
                    {
                        "username": "user6746E",
                        "content": "The 11th ugly number will not be 14 since the prime factor of 14 includes 7, but the question clearly states that the primes factor should be limited to 2, 3 or 5. Therefore 11th ugly number will be 15."
                    },
                    {
                        "username": "sazib204061",
                        "content": "I solve this problem in O(1) time complexity.\\n `class Solution {\\npublic:\\nvector<long long>ar = {1,2,3,4,5,6,8,9,10,12,15,16,18,20,24,25,27,30,32,36,40,45,48,50,54,60,64,72,75,80,81,90,96,100,108,120,125,128,135,144,150,160,162,180,192,200,216,225,240,243,250,256,270,288,300,320,324,360,375,384,400,405,432,450,480,486,500,512,540,576,600,625,640,648,675,720,729,750,768,800,810,864,900,960,972,1000,1024,1080,1125,1152,1200,1215,1250,1280,1296,1350,1440,1458,1500,1536,1600,1620,1728,1800,1875,1920,1944,2000,2025,2048,2160,2187,2250,2304,2400,2430,2500,2560,2592,2700,2880,2916,3000,3072,3125,3200,3240,3375,3456,3600,3645,3750,3840,3888,4000,4050,4096,4320,4374,4500,4608,4800,4860,5000,5120,5184,5400,5625,5760,5832,6000,6075,6144,6250,6400,6480,6561,6750,6912,7200,7290,7500,7680,7776,8000,8100,8192,8640,8748,9000,9216,9375,9600,9720,10000,10125,10240,10368,10800,10935,11250,11520,11664,12000,12150,12288,12500,12800,12960,13122,13500,13824,14400,14580,15000,15360,15552,15625,16000,16200,16384,16875,17280,17496,18000,18225,18432,18750,19200,19440,19683,20000,20250,20480,20736,21600,21870,22500,23040,23328,24000,24300,24576,25000,25600,25920,26244,27000,27648,28125,28800,29160,30000,30375,30720,31104,31250,32000,32400,32768,32805,33750,34560,34992,36000,36450,36864,37500,38400,38880,39366,40000,40500,40960,41472,43200,43740,45000,46080,46656,46875,48000,48600,49152,50000,50625,51200,51840,52488,54000,54675,55296,56250,57600,58320,59049,60000,60750,61440,62208,62500,64000,64800,65536,65610,67500,69120,69984,72000,72900,73728,75000,76800,77760,78125,78732,80000,81000,81920,82944,84375,86400,87480,90000,91125,92160,93312,93750,96000,97200,98304,98415,100000,101250,102400,103680,104976,108000,109350,110592,112500,115200,116640,118098,120000,121500,122880,124416,125000,128000,129600,131072,131220,135000,138240,139968,140625,144000,145800,147456,150000,151875,153600,155520,156250,157464,160000,162000,163840,164025,165888,168750,172800,174960,177147,180000,182250,184320,186624,187500,192000,194400,196608,196830,200000,202500,204800,207360,209952,216000,218700,221184,225000,230400,233280,234375,236196,240000,243000,245760,248832,250000,253125,256000,259200,262144,262440,270000,273375,276480,279936,281250,288000,291600,294912,295245,300000,303750,307200,311040,312500,314928,320000,324000,327680,328050,331776,337500,345600,349920,354294,360000,364500,368640,373248,375000,384000,388800,390625,393216,393660,400000,405000,409600,414720,419904,421875,432000,437400,442368,450000,455625,460800,466560,468750,472392,480000,486000,491520,492075,497664,500000,506250,512000,518400,524288,524880,531441,540000,546750,552960,559872,562500,576000,583200,589824,590490,600000,607500,614400,622080,625000,629856,640000,648000,655360,656100,663552,675000,691200,699840,703125,708588,720000,729000,737280,746496,750000,759375,768000,777600,781250,786432,787320,800000,810000,819200,820125,829440,839808,843750,864000,874800,884736,885735,900000,911250,921600,933120,937500,944784,\\n\\n960000,972000,983040,984150,995328,1000000,1012500,1024000,1036800,1048576,1049760,1062882,1080000,1093500,1105920,1119744,1125000,1152000,1166400,1171875,1179648,1180980,1200000,1215000,1228800,1244160,1250000,1259712,1265625,1280000,1296000,1310720,1312200,1327104,1350000,1366875,1382400,1399680,1406250,1417176,1440000,1458000,1474560,1476225,1492992,1500000,1518750,1536000,1555200,1562500,1572864,1574640,1594323,1600000,1620000,1638400,1640250,1658880,1679616,1687500,1728000,1749600,1769472,1771470,1800000,1822500,1843200,1866240,1875000,1889568,1920000,1944000,1953125,1966080,1968300,1990656,2000000,2025000,2048000,2073600,2097152,2099520,2109375,2125764,2160000,2187000,2211840,2239488,2250000,2278125,2304000,2332800,2343750,2359296,2361960,2400000,2430000,2457600,2460375,2488320,2500000,2519424,2531250,2560000,2592000,2621440,2624400,2654208,2657205,2700000,2733750,2764800,2799360,2812500,2834352,2880000,2916000,2949120,2952450,2985984,3000000,3037500,3072000,3110400,3125000,3145728,3149280,3188646,3200000,3240000,3276800,3280500,3317760,3359232,3375000,3456000,3499200,3515625,3538944,3542940,3600000,3645000,3686400,3732480,3750000,3779136,3796875,3840000,3888000,3906250,3932160,3936600,3981312,4000000,4050000,4096000,4100625,4147200,4194304,4199040,4218750,4251528,4320000,4374000,4423680,4428675,4478976,4500000,4556250,4608000,4665600,4687500,4718592,4723920,4782969,4800000,4860000,4915200,4920750,4976640,5000000,5038848,5062500,5120000,5184000,5242880,5248800,5308416,5314410,5400000,5467500,5529600,5598720,5625000,5668704,5760000,5832000,5859375,5898240,5904900,5971968,6000000,6075000,6144000,6220800,6250000,6291456,6298560,6328125,6377292,6400000,6480000,6553600,6561000,6635520,6718464,6750000,6834375,6912000,6998400,7031250,7077888,7085880,7200000,7290000,7372800,7381125,7464960,7500000,7558272,7593750,7680000,7776000,7812500,7864320,7873200,7962624,7971615,8000000,8100000,8192000,8201250,8294400,8388608,8398080,8437500,8503056,8640000,8748000,8847360,8857350,8957952,9000000,9112500,9216000,9331200,9375000,9437184,9447840,9565938,9600000,9720000,9765625,9830400,9841500,9953280,10000000,10077696,10125000,10240000,10368000,10485760,10497600,10546875,10616832,10628820,10800000,10935000,11059200,11197440,11250000,11337408,11390625,11520000,11664000,11718750,11796480,11809800,11943936,12000000,12150000,12288000,12301875,12441600,12500000,12582912,12597120,12656250,12754584,12800000,12960000,13107200,13122000,13271040,13286025,13436928,13500000,13668750,13824000,13996800,14062500,14155776,14171760,14348907,14400000,14580000,14745600,14762250,14929920,15000000,15116544,15187500,15360000,15552000,15625000,15728640,15746400,15925248,15943230,16000000,16200000,16384000,16402500,16588800,16777216,16796160,16875000,17006112,17280000,17496000,17578125,17694720,17714700,17915904,18000000,18225000,18432000,18662400,18750000,18874368,18895680,18984375,19131876,19200000,19440000,19531250,19660800,19683000,19906560,20000000,20155392,20250000,20480000,20503125,20736000,20971520,20995200,21093750,21233664,21257640,21600000,21870000,22118400,22143375,22394880,22500000,22674816,22781250,23040000,23328000,23437500,23592960,23619600,23887872,23914845,24000000,24300000,24576000,24603750,24883200,25000000,25165824,25194240,25312500,25509168,25600000,25920000,26214400,26244000,26542080,26572050,26873856,27000000,27337500,27648000,27993600,28125000,28311552,28343520,28697814,28800000,29160000,29296875,29491200,29524500,29859840,30000000,30233088,30375000,30720000,31104000,31250000,31457280,31492800,31640625,31850496,31886460,32000000,32400000,32768000,32805000,33177600,33554432,33592320,33750000,34012224,34171875,34560000,34992000,35156250,35389440,35429400,35831808,36000000,36450000,36864000,36905625,37324800,37500000,37748736,37791360,37968750,38263752,38400000,38880000,39062500,39321600,39366000,39813120,39858075,40000000,40310784,40500000,40960000,41006250,41472000,41943040,41990400,42187500,42467328,42515280,43046721,43200000,43740000,44236800,44286750,44789760,45000000,45349632,45562500,46080000,46656000,46875000,47185920,47239200,47775744,47829690,48000000,48600000,48828125,49152000,49207500,49766400,50000000,50331648,50388480,50625000,51018336,51200000,51840000,\\n\\n52428800,52488000,52734375,53084160,53144100,53747712,54000000,54675000,55296000,55987200,56250000,56623104,56687040,56953125,57395628,57600000,58320000,58593750,58982400,59049000,59719680,60000000,60466176,60750000,61440000,61509375,62208000,62500000,62914560,62985600,63281250,63700992,63772920,64000000,64800000,65536000,65610000,66355200,66430125,67108864,67184640,67500000,68024448,68343750,69120000,69984000,70312500,70778880,70858800,71663616,71744535,72000000,72900000,73728000,73811250,74649600,75000000,75497472,75582720,75937500,76527504,76800000,77760000,78125000,78643200,78732000,79626240,79716150,80000000,80621568,81000000,81920000,82012500,82944000,83886080,83980800,84375000,84934656,85030560,86093442,86400000,87480000,87890625,88473600,88573500,89579520,90000000,90699264,91125000,92160000,93312000,93750000,94371840,94478400,94921875,95551488,95659380,96000000,97200000,97656250,98304000,98415000,99532800,100000000,100663296,100776960,101250000,102036672,102400000,102515625,103680000,104857600,104976000,105468750,106168320,106288200,107495424,108000000,109350000,110592000,110716875,111974400,112500000,113246208,113374080,113906250,114791256,115200000,116640000,117187500,117964800,118098000,119439360,119574225,120000000,120932352,121500000,122880000,123018750,124416000,125000000,125829120,125971200,126562500,127401984,127545840,128000000,129140163,129600000,131072000,131220000,132710400,132860250,134217728,134369280,135000000,136048896,136687500,138240000,139968000,140625000,141557760,141717600,143327232,143489070,144000000,145800000,146484375,147456000,147622500,149299200,150000000,150994944,151165440,151875000,153055008,153600000,155520000,156250000,157286400,157464000,158203125,159252480,159432300,160000000,161243136,162000000,163840000,164025000,165888000,167772160,167961600,168750000,169869312,170061120,170859375,172186884,172800000,174960000,175781250,\\n\\n\\n176947200,177147000,179159040,180000000,181398528,182250000,184320000,184528125,186624000,187500000,188743680,188956800,189843750,191102976,191318760,192000000,194400000,195312500,196608000,196830000,199065600,199290375,200000000,201326592,201553920,202500000,204073344,204800000,205031250,207360000,209715200,209952000,210937500,212336640,212576400,214990848,215233605,216000000,218700000,221184000,221433750,223948800,225000000,226492416,226748160,227812500,229582512,230400000,233280000,234375000,235929600,236196000,238878720,239148450,240000000,241864704,243000000,244140625,245760000,246037500,248832000,250000000,251658240,251942400,253125000,254803968,255091680,256000000,258280326,259200000,262144000,262440000,263671875,265420800,265720500,268435456,268738560,270000000,272097792,273375000,276480000,279936000,281250000,283115520,283435200,284765625,286654464,286978140,288000000,291600000,292968750,294912000,295245000,298598400,300000000,301989888,302330880,303750000,306110016,307200000,307546875,311040000,312500000,314572800,314928000,316406250,318504960,318864600,320000000,322486272,324000000,327680000,328050000,331776000,332150625,335544320,335923200,337500000,339738624,340122240,341718750,344373768,345600000,349920000,351562500,353894400,354294000,358318080,358722675,360000000,362797056,364500000,368640000,369056250,373248000,375000000,377487360,377913600,379687500,382205952,382637520,384000000,387420489,388800000,390625000,393216000,393660000,398131200,398580750,400000000,402653184,403107840,405000000,408146688,409600000,410062500,414720000,419430400,419904000,421875000,424673280,425152800,429981696,430467210,432000000,437400000,439453125,442368000,442867500,447897600,450000000,452984832,453496320,455625000,459165024,460800000,466560000,468750000,471859200,472392000,474609375,477757440,478296900,480000000,483729408,486000000,488281250,491520000,492075000,497664000,500000000,503316480,503884800,506250000,509607936,510183360,512000000,512578125,516560652,518400000,\\n\\n524288000,524880000,527343750,530841600,531441000,536870912,537477120,540000000,544195584,546750000,552960000,553584375,559872000,562500000,566231040,566870400,569531250,573308928,573956280,576000000,583200000,585937500,589824000,590490000,597196800,597871125,600000000,603979776,604661760,607500000,612220032,614400000,615093750,622080000,625000000,629145600,629856000,632812500,637009920,637729200,640000000,644972544,645700815,648000000,655360000,656100000,663552000,664301250,671088640,671846400,675000000,679477248,680244480,683437500,688747536,691200000,699840000,703125000,707788800,708588000,716636160,717445350,720000000,725594112,729000000,732421875,737280000,738112500,746496000,750000000,754974720,755827200,759375000,764411904,765275040,768000000,774840978,777600000,781250000,786432000,787320000,791015625,796262400,797161500,800000000,805306368,806215680,810000000,816293376,819200000,820125000,829440000,838860800,839808000,843750000,849346560,850305600,854296875,859963392,860934420,864000000,874800000,878906250,884736000,885735000,895795200,900000000,905969664,906992640,911250000,918330048,921600000,922640625,933120000,937500000,943718400,944784000,949218750,955514880,956593800,960000000,967458816,972000000,976562500,983040000,984150000,995328000,996451875,1000000000,1006632960,1007769600,1012500000,1019215872,1020366720,1024000000,1025156250,1033121304,1036800000,1048576000,1049760000,1054687500,1061683200,1062882000,1073741824,1074954240,1076168025,1080000000,1088391168,1093500000,1105920000,1107168750,1119744000,1125000000,1132462080,1133740800,1139062500,1146617856,1147912560,1152000000,1162261467,1166400000,1171875000,1179648000,1180980000,1194393600,1195742250,1200000000,1207959552,1209323520,1215000000,1220703125,1224440064,1228800000,1230187500,1244160000,1250000000,1258291200,1259712000,1265625000,1274019840,1275458400,1280000000,1289945088,1291401630,1296000000,1310720000,1312200000,1318359375,1327104000,1328602500,1342177280,1343692800,1350000000,1358954496,1360488960,1366875000,1377495072,1382400000,1399680000,1406250000,1415577600,1417176000,1423828125,1433272320,1434890700,1440000000,1451188224,1458000000,1464843750,1474560000,1476225000,1492992000,1500000000,1509949440,1511654400,1518750000,1528823808,1530550080,1536000000,1537734375,1549681956,1555200000,1562500000,1572864000,1574640000,1582031250,1592524800,1594323000,1600000000,1610612736,1612431360,1620000000,1632586752,1638400000,1640250000,1658880000,1660753125,1677721600,1679616000,1687500000,1698693120,1700611200,1708593750,1719926784,1721868840,1728000000,1749600000,1757812500,1769472000,1771470000,1791590400,1793613375,1800000000,1811939328,1813985280,1822500000,1836660096,1843200000,1845281250,1866240000,1875000000,1887436800,1889568000,1898437500,1911029760,1913187600,1920000000,1934917632,1937102445,1944000000,1953125000,1966080000,1968300000,1990656000,1992903750,2000000000,2013265920,2015539200,2025000000,2038431744,2040733440,2048000000,2050312500,2066242608,2073600000,2097152000,2099520000,2109375000,2123366400,2125764000,2147483648,2149908480,2152336050,2160000000,2176782336,2187000000,2197265625,2211840000,2214337500,2239488000\\n\\n\\n};\\n\\n    int nthUglyNumber(int n) {\\n        return ar[n-1]; \\n    }\\n};`"
                    },
                    {
                        "username": "AasheeshLikePanner",
                        "content": "Bro stop this \\uD83D\\uDE2D\\uD83D\\uDE2D\\uD83D\\uDE2D"
                    },
                    {
                        "username": "Mayank_Shahria",
                        "content": "**I have solved this by two methods \\n1. Brute force**\\nBut it is giving a run time error\\n![image](https://assets.leetcode.com/users/images/ba539fa1-405b-4d9d-832a-5be83172edc4_1620554425.1931248.png)\\n**2. Dynamic Programing**\\n![image](https://assets.leetcode.com/users/images/3a90f09e-1a3c-465f-a8d6-b58bfc613ccf_1620554465.9711976.png)\\n\\n\\n"
                    },
                    {
                        "username": "aman_online67",
                        "content": "I also applied brute force but it gives TLE at some 500 test case. But logic wise it is correct what to do now"
                    },
                    {
                        "username": "Rohith6776",
                        "content": "If the prime factors are limited to 2,3,5 and we should not consider numbers like(14->2*7, 21->3*7) right?"
                    },
                    {
                        "username": "wtfcoder",
                        "content": "yup"
                    },
                    {
                        "username": "c_jain",
                        "content": "After reading top solutions here, I realized optimized solution is not a DP solution because I am not able to figure out optimal substructure and overlapping subproblem. I think it is kind of 3 pointer solution. Anyone like to clarify this?"
                    },
                    {
                        "username": "vikasboss6855",
                        "content": "https://leetcode.com/problems/ugly-number-ii/solutions/3704058/c-memoized-solution-using-dp-forcible-dp/"
                    },
                    {
                        "username": "Gismet",
                        "content": "Yeah, you are right. I don't also think there is an optimal substructure and overlapping subproblem. I think the reason why they called this DP solution is that we use the previously computed ugly numbers to find the next one. If you checked out the hint, they say you can get the next ugly number from a smaller ugly number by multiplying it by either 2, 3 or 5. So we start from the bottom and work our way up to the nth ugly number, in each iteration finding the next ugly number using a previous one. But to see the overlapping subproblems, one would write a recursive solution, also called top-down, and see if there are any subproblems that overlaps. But I couldn't come up with recursive top-down solution. Or maybe there is an optimal substructure that I fail to see. "
                    },
                    {
                        "username": "logical_thinker",
                        "content": "can someone throw light on the last test case which is n being empty the 596th test case. what is that and how do I go about it."
                    },
                    {
                        "username": "urmichm",
                        "content": "why is 1 ugly number?"
                    },
                    {
                        "username": "at218808",
                        "content": "1 is a factor of every number , so its more like a ugly number has only factors as 1,2,3 or 5"
                    },
                    {
                        "username": "QuasiRus",
                        "content": "It does not have any prime factor outside [2, 3, 5] list. 1 itself is not a prime number."
                    }
                ]
            },
            {
                "id": 1575246,
                "content": [
                    {
                        "username": "lcn",
                        "content": " 1. Actually, the input space is much smaller than expected if we insist an `int` range output. \\nWhen input `n` is greater than `1691`, the output overflows the `int` range.\\n 2. Another way to view this bound is that all ugly numbers must be in the form `2^a*3^b*5^c`. Since we have `log2(Integer.MAX_VALUE)=a<31`, `log3(Integer.MAX_VALUE)=b<20` and `log5(Integer.MAX_VALUE)=c<14`, the combination allowed is surely under `31*20*14~=8400`.\\n\\nSo ugly number is sparser than one would usually think, and please do take care of overflow."
                    },
                    {
                        "username": "chauhanprerna21",
                        "content": "I am not able to understand how is ugly numbers a DP problem?\\nWould be great if someone could help with it."
                    },
                    {
                        "username": "vikasboss6855",
                        "content": "https://leetcode.com/problems/ugly-number-ii/solutions/3704058/c-memoized-solution-using-dp-forcible-dp/\n```\nclass Solution {\npublic:\n    int nthUglyNumber(int n) {\n        vector<int> dp(n);\n        dp[0] = 1;\n        return nthUglyNumberRecursive(dp, n, 1, 0, 0, 0);\n    }\n\nprivate:\n    int nthUglyNumberRecursive(vector<int>& dp, int n, int i, int p1, int p2, int p3) {\n        if (i == n) {\n            return dp[n - 1];\n        }\n\n        int twoMultiple = dp[p1] * 2;\n        int threeMultiple = dp[p2] * 3;\n        int fiveMultiple = dp[p3] * 5;\n\n        dp[i] = min(twoMultiple, min(threeMultiple, fiveMultiple));\n\n        int nextP1 = (dp[i] == twoMultiple) ? p1 + 1 : p1;\n        int nextP2 = (dp[i] == threeMultiple) ? p2 + 1 : p2;\n        int nextP3 = (dp[i] == fiveMultiple) ? p3 + 1 : p3;\n\n        return nthUglyNumberRecursive(dp, n, i + 1, nextP1, nextP2, nextP3);\n    }\n};\n\n```"
                    },
                    {
                        "username": "divyanshuparg",
                        "content": "I have solved it using recursion and hashing."
                    },
                    {
                        "username": "anshulguleria",
                        "content": "In the example in problem statement 1 was being counted as ugly number. I am not able to understand how we concluded that.\\n\\nif 1 = 1 * 2^0 then this theory will be true for other numbers as well like 7  * 2^0."
                    },
                    {
                        "username": "Seabayley",
                        "content": "![image](https://assets.leetcode.com/users/images/fad90901-6c35-455e-8ff0-8160380ca46c_1597993223.2791212.png)\\n\\nAm I misunderstanding the problem? The 11th ugly numbers looks to me as though it should be 14?"
                    },
                    {
                        "username": "codekorekhai",
                        "content": "[@satyamkumarskr](/satyamkumarskr) 14 is not an ugly number because it has 7 as factor but the problem said that only 2, 3, 5 will be the prime factor for each ugly number."
                    },
                    {
                        "username": "satyamkumarskr",
                        "content": "True . I got the same issue."
                    },
                    {
                        "username": "user6746E",
                        "content": "The 11th ugly number will not be 14 since the prime factor of 14 includes 7, but the question clearly states that the primes factor should be limited to 2, 3 or 5. Therefore 11th ugly number will be 15."
                    },
                    {
                        "username": "sazib204061",
                        "content": "I solve this problem in O(1) time complexity.\\n `class Solution {\\npublic:\\nvector<long long>ar = {1,2,3,4,5,6,8,9,10,12,15,16,18,20,24,25,27,30,32,36,40,45,48,50,54,60,64,72,75,80,81,90,96,100,108,120,125,128,135,144,150,160,162,180,192,200,216,225,240,243,250,256,270,288,300,320,324,360,375,384,400,405,432,450,480,486,500,512,540,576,600,625,640,648,675,720,729,750,768,800,810,864,900,960,972,1000,1024,1080,1125,1152,1200,1215,1250,1280,1296,1350,1440,1458,1500,1536,1600,1620,1728,1800,1875,1920,1944,2000,2025,2048,2160,2187,2250,2304,2400,2430,2500,2560,2592,2700,2880,2916,3000,3072,3125,3200,3240,3375,3456,3600,3645,3750,3840,3888,4000,4050,4096,4320,4374,4500,4608,4800,4860,5000,5120,5184,5400,5625,5760,5832,6000,6075,6144,6250,6400,6480,6561,6750,6912,7200,7290,7500,7680,7776,8000,8100,8192,8640,8748,9000,9216,9375,9600,9720,10000,10125,10240,10368,10800,10935,11250,11520,11664,12000,12150,12288,12500,12800,12960,13122,13500,13824,14400,14580,15000,15360,15552,15625,16000,16200,16384,16875,17280,17496,18000,18225,18432,18750,19200,19440,19683,20000,20250,20480,20736,21600,21870,22500,23040,23328,24000,24300,24576,25000,25600,25920,26244,27000,27648,28125,28800,29160,30000,30375,30720,31104,31250,32000,32400,32768,32805,33750,34560,34992,36000,36450,36864,37500,38400,38880,39366,40000,40500,40960,41472,43200,43740,45000,46080,46656,46875,48000,48600,49152,50000,50625,51200,51840,52488,54000,54675,55296,56250,57600,58320,59049,60000,60750,61440,62208,62500,64000,64800,65536,65610,67500,69120,69984,72000,72900,73728,75000,76800,77760,78125,78732,80000,81000,81920,82944,84375,86400,87480,90000,91125,92160,93312,93750,96000,97200,98304,98415,100000,101250,102400,103680,104976,108000,109350,110592,112500,115200,116640,118098,120000,121500,122880,124416,125000,128000,129600,131072,131220,135000,138240,139968,140625,144000,145800,147456,150000,151875,153600,155520,156250,157464,160000,162000,163840,164025,165888,168750,172800,174960,177147,180000,182250,184320,186624,187500,192000,194400,196608,196830,200000,202500,204800,207360,209952,216000,218700,221184,225000,230400,233280,234375,236196,240000,243000,245760,248832,250000,253125,256000,259200,262144,262440,270000,273375,276480,279936,281250,288000,291600,294912,295245,300000,303750,307200,311040,312500,314928,320000,324000,327680,328050,331776,337500,345600,349920,354294,360000,364500,368640,373248,375000,384000,388800,390625,393216,393660,400000,405000,409600,414720,419904,421875,432000,437400,442368,450000,455625,460800,466560,468750,472392,480000,486000,491520,492075,497664,500000,506250,512000,518400,524288,524880,531441,540000,546750,552960,559872,562500,576000,583200,589824,590490,600000,607500,614400,622080,625000,629856,640000,648000,655360,656100,663552,675000,691200,699840,703125,708588,720000,729000,737280,746496,750000,759375,768000,777600,781250,786432,787320,800000,810000,819200,820125,829440,839808,843750,864000,874800,884736,885735,900000,911250,921600,933120,937500,944784,\\n\\n960000,972000,983040,984150,995328,1000000,1012500,1024000,1036800,1048576,1049760,1062882,1080000,1093500,1105920,1119744,1125000,1152000,1166400,1171875,1179648,1180980,1200000,1215000,1228800,1244160,1250000,1259712,1265625,1280000,1296000,1310720,1312200,1327104,1350000,1366875,1382400,1399680,1406250,1417176,1440000,1458000,1474560,1476225,1492992,1500000,1518750,1536000,1555200,1562500,1572864,1574640,1594323,1600000,1620000,1638400,1640250,1658880,1679616,1687500,1728000,1749600,1769472,1771470,1800000,1822500,1843200,1866240,1875000,1889568,1920000,1944000,1953125,1966080,1968300,1990656,2000000,2025000,2048000,2073600,2097152,2099520,2109375,2125764,2160000,2187000,2211840,2239488,2250000,2278125,2304000,2332800,2343750,2359296,2361960,2400000,2430000,2457600,2460375,2488320,2500000,2519424,2531250,2560000,2592000,2621440,2624400,2654208,2657205,2700000,2733750,2764800,2799360,2812500,2834352,2880000,2916000,2949120,2952450,2985984,3000000,3037500,3072000,3110400,3125000,3145728,3149280,3188646,3200000,3240000,3276800,3280500,3317760,3359232,3375000,3456000,3499200,3515625,3538944,3542940,3600000,3645000,3686400,3732480,3750000,3779136,3796875,3840000,3888000,3906250,3932160,3936600,3981312,4000000,4050000,4096000,4100625,4147200,4194304,4199040,4218750,4251528,4320000,4374000,4423680,4428675,4478976,4500000,4556250,4608000,4665600,4687500,4718592,4723920,4782969,4800000,4860000,4915200,4920750,4976640,5000000,5038848,5062500,5120000,5184000,5242880,5248800,5308416,5314410,5400000,5467500,5529600,5598720,5625000,5668704,5760000,5832000,5859375,5898240,5904900,5971968,6000000,6075000,6144000,6220800,6250000,6291456,6298560,6328125,6377292,6400000,6480000,6553600,6561000,6635520,6718464,6750000,6834375,6912000,6998400,7031250,7077888,7085880,7200000,7290000,7372800,7381125,7464960,7500000,7558272,7593750,7680000,7776000,7812500,7864320,7873200,7962624,7971615,8000000,8100000,8192000,8201250,8294400,8388608,8398080,8437500,8503056,8640000,8748000,8847360,8857350,8957952,9000000,9112500,9216000,9331200,9375000,9437184,9447840,9565938,9600000,9720000,9765625,9830400,9841500,9953280,10000000,10077696,10125000,10240000,10368000,10485760,10497600,10546875,10616832,10628820,10800000,10935000,11059200,11197440,11250000,11337408,11390625,11520000,11664000,11718750,11796480,11809800,11943936,12000000,12150000,12288000,12301875,12441600,12500000,12582912,12597120,12656250,12754584,12800000,12960000,13107200,13122000,13271040,13286025,13436928,13500000,13668750,13824000,13996800,14062500,14155776,14171760,14348907,14400000,14580000,14745600,14762250,14929920,15000000,15116544,15187500,15360000,15552000,15625000,15728640,15746400,15925248,15943230,16000000,16200000,16384000,16402500,16588800,16777216,16796160,16875000,17006112,17280000,17496000,17578125,17694720,17714700,17915904,18000000,18225000,18432000,18662400,18750000,18874368,18895680,18984375,19131876,19200000,19440000,19531250,19660800,19683000,19906560,20000000,20155392,20250000,20480000,20503125,20736000,20971520,20995200,21093750,21233664,21257640,21600000,21870000,22118400,22143375,22394880,22500000,22674816,22781250,23040000,23328000,23437500,23592960,23619600,23887872,23914845,24000000,24300000,24576000,24603750,24883200,25000000,25165824,25194240,25312500,25509168,25600000,25920000,26214400,26244000,26542080,26572050,26873856,27000000,27337500,27648000,27993600,28125000,28311552,28343520,28697814,28800000,29160000,29296875,29491200,29524500,29859840,30000000,30233088,30375000,30720000,31104000,31250000,31457280,31492800,31640625,31850496,31886460,32000000,32400000,32768000,32805000,33177600,33554432,33592320,33750000,34012224,34171875,34560000,34992000,35156250,35389440,35429400,35831808,36000000,36450000,36864000,36905625,37324800,37500000,37748736,37791360,37968750,38263752,38400000,38880000,39062500,39321600,39366000,39813120,39858075,40000000,40310784,40500000,40960000,41006250,41472000,41943040,41990400,42187500,42467328,42515280,43046721,43200000,43740000,44236800,44286750,44789760,45000000,45349632,45562500,46080000,46656000,46875000,47185920,47239200,47775744,47829690,48000000,48600000,48828125,49152000,49207500,49766400,50000000,50331648,50388480,50625000,51018336,51200000,51840000,\\n\\n52428800,52488000,52734375,53084160,53144100,53747712,54000000,54675000,55296000,55987200,56250000,56623104,56687040,56953125,57395628,57600000,58320000,58593750,58982400,59049000,59719680,60000000,60466176,60750000,61440000,61509375,62208000,62500000,62914560,62985600,63281250,63700992,63772920,64000000,64800000,65536000,65610000,66355200,66430125,67108864,67184640,67500000,68024448,68343750,69120000,69984000,70312500,70778880,70858800,71663616,71744535,72000000,72900000,73728000,73811250,74649600,75000000,75497472,75582720,75937500,76527504,76800000,77760000,78125000,78643200,78732000,79626240,79716150,80000000,80621568,81000000,81920000,82012500,82944000,83886080,83980800,84375000,84934656,85030560,86093442,86400000,87480000,87890625,88473600,88573500,89579520,90000000,90699264,91125000,92160000,93312000,93750000,94371840,94478400,94921875,95551488,95659380,96000000,97200000,97656250,98304000,98415000,99532800,100000000,100663296,100776960,101250000,102036672,102400000,102515625,103680000,104857600,104976000,105468750,106168320,106288200,107495424,108000000,109350000,110592000,110716875,111974400,112500000,113246208,113374080,113906250,114791256,115200000,116640000,117187500,117964800,118098000,119439360,119574225,120000000,120932352,121500000,122880000,123018750,124416000,125000000,125829120,125971200,126562500,127401984,127545840,128000000,129140163,129600000,131072000,131220000,132710400,132860250,134217728,134369280,135000000,136048896,136687500,138240000,139968000,140625000,141557760,141717600,143327232,143489070,144000000,145800000,146484375,147456000,147622500,149299200,150000000,150994944,151165440,151875000,153055008,153600000,155520000,156250000,157286400,157464000,158203125,159252480,159432300,160000000,161243136,162000000,163840000,164025000,165888000,167772160,167961600,168750000,169869312,170061120,170859375,172186884,172800000,174960000,175781250,\\n\\n\\n176947200,177147000,179159040,180000000,181398528,182250000,184320000,184528125,186624000,187500000,188743680,188956800,189843750,191102976,191318760,192000000,194400000,195312500,196608000,196830000,199065600,199290375,200000000,201326592,201553920,202500000,204073344,204800000,205031250,207360000,209715200,209952000,210937500,212336640,212576400,214990848,215233605,216000000,218700000,221184000,221433750,223948800,225000000,226492416,226748160,227812500,229582512,230400000,233280000,234375000,235929600,236196000,238878720,239148450,240000000,241864704,243000000,244140625,245760000,246037500,248832000,250000000,251658240,251942400,253125000,254803968,255091680,256000000,258280326,259200000,262144000,262440000,263671875,265420800,265720500,268435456,268738560,270000000,272097792,273375000,276480000,279936000,281250000,283115520,283435200,284765625,286654464,286978140,288000000,291600000,292968750,294912000,295245000,298598400,300000000,301989888,302330880,303750000,306110016,307200000,307546875,311040000,312500000,314572800,314928000,316406250,318504960,318864600,320000000,322486272,324000000,327680000,328050000,331776000,332150625,335544320,335923200,337500000,339738624,340122240,341718750,344373768,345600000,349920000,351562500,353894400,354294000,358318080,358722675,360000000,362797056,364500000,368640000,369056250,373248000,375000000,377487360,377913600,379687500,382205952,382637520,384000000,387420489,388800000,390625000,393216000,393660000,398131200,398580750,400000000,402653184,403107840,405000000,408146688,409600000,410062500,414720000,419430400,419904000,421875000,424673280,425152800,429981696,430467210,432000000,437400000,439453125,442368000,442867500,447897600,450000000,452984832,453496320,455625000,459165024,460800000,466560000,468750000,471859200,472392000,474609375,477757440,478296900,480000000,483729408,486000000,488281250,491520000,492075000,497664000,500000000,503316480,503884800,506250000,509607936,510183360,512000000,512578125,516560652,518400000,\\n\\n524288000,524880000,527343750,530841600,531441000,536870912,537477120,540000000,544195584,546750000,552960000,553584375,559872000,562500000,566231040,566870400,569531250,573308928,573956280,576000000,583200000,585937500,589824000,590490000,597196800,597871125,600000000,603979776,604661760,607500000,612220032,614400000,615093750,622080000,625000000,629145600,629856000,632812500,637009920,637729200,640000000,644972544,645700815,648000000,655360000,656100000,663552000,664301250,671088640,671846400,675000000,679477248,680244480,683437500,688747536,691200000,699840000,703125000,707788800,708588000,716636160,717445350,720000000,725594112,729000000,732421875,737280000,738112500,746496000,750000000,754974720,755827200,759375000,764411904,765275040,768000000,774840978,777600000,781250000,786432000,787320000,791015625,796262400,797161500,800000000,805306368,806215680,810000000,816293376,819200000,820125000,829440000,838860800,839808000,843750000,849346560,850305600,854296875,859963392,860934420,864000000,874800000,878906250,884736000,885735000,895795200,900000000,905969664,906992640,911250000,918330048,921600000,922640625,933120000,937500000,943718400,944784000,949218750,955514880,956593800,960000000,967458816,972000000,976562500,983040000,984150000,995328000,996451875,1000000000,1006632960,1007769600,1012500000,1019215872,1020366720,1024000000,1025156250,1033121304,1036800000,1048576000,1049760000,1054687500,1061683200,1062882000,1073741824,1074954240,1076168025,1080000000,1088391168,1093500000,1105920000,1107168750,1119744000,1125000000,1132462080,1133740800,1139062500,1146617856,1147912560,1152000000,1162261467,1166400000,1171875000,1179648000,1180980000,1194393600,1195742250,1200000000,1207959552,1209323520,1215000000,1220703125,1224440064,1228800000,1230187500,1244160000,1250000000,1258291200,1259712000,1265625000,1274019840,1275458400,1280000000,1289945088,1291401630,1296000000,1310720000,1312200000,1318359375,1327104000,1328602500,1342177280,1343692800,1350000000,1358954496,1360488960,1366875000,1377495072,1382400000,1399680000,1406250000,1415577600,1417176000,1423828125,1433272320,1434890700,1440000000,1451188224,1458000000,1464843750,1474560000,1476225000,1492992000,1500000000,1509949440,1511654400,1518750000,1528823808,1530550080,1536000000,1537734375,1549681956,1555200000,1562500000,1572864000,1574640000,1582031250,1592524800,1594323000,1600000000,1610612736,1612431360,1620000000,1632586752,1638400000,1640250000,1658880000,1660753125,1677721600,1679616000,1687500000,1698693120,1700611200,1708593750,1719926784,1721868840,1728000000,1749600000,1757812500,1769472000,1771470000,1791590400,1793613375,1800000000,1811939328,1813985280,1822500000,1836660096,1843200000,1845281250,1866240000,1875000000,1887436800,1889568000,1898437500,1911029760,1913187600,1920000000,1934917632,1937102445,1944000000,1953125000,1966080000,1968300000,1990656000,1992903750,2000000000,2013265920,2015539200,2025000000,2038431744,2040733440,2048000000,2050312500,2066242608,2073600000,2097152000,2099520000,2109375000,2123366400,2125764000,2147483648,2149908480,2152336050,2160000000,2176782336,2187000000,2197265625,2211840000,2214337500,2239488000\\n\\n\\n};\\n\\n    int nthUglyNumber(int n) {\\n        return ar[n-1]; \\n    }\\n};`"
                    },
                    {
                        "username": "AasheeshLikePanner",
                        "content": "Bro stop this \\uD83D\\uDE2D\\uD83D\\uDE2D\\uD83D\\uDE2D"
                    },
                    {
                        "username": "Mayank_Shahria",
                        "content": "**I have solved this by two methods \\n1. Brute force**\\nBut it is giving a run time error\\n![image](https://assets.leetcode.com/users/images/ba539fa1-405b-4d9d-832a-5be83172edc4_1620554425.1931248.png)\\n**2. Dynamic Programing**\\n![image](https://assets.leetcode.com/users/images/3a90f09e-1a3c-465f-a8d6-b58bfc613ccf_1620554465.9711976.png)\\n\\n\\n"
                    },
                    {
                        "username": "aman_online67",
                        "content": "I also applied brute force but it gives TLE at some 500 test case. But logic wise it is correct what to do now"
                    },
                    {
                        "username": "Rohith6776",
                        "content": "If the prime factors are limited to 2,3,5 and we should not consider numbers like(14->2*7, 21->3*7) right?"
                    },
                    {
                        "username": "wtfcoder",
                        "content": "yup"
                    },
                    {
                        "username": "c_jain",
                        "content": "After reading top solutions here, I realized optimized solution is not a DP solution because I am not able to figure out optimal substructure and overlapping subproblem. I think it is kind of 3 pointer solution. Anyone like to clarify this?"
                    },
                    {
                        "username": "vikasboss6855",
                        "content": "https://leetcode.com/problems/ugly-number-ii/solutions/3704058/c-memoized-solution-using-dp-forcible-dp/"
                    },
                    {
                        "username": "Gismet",
                        "content": "Yeah, you are right. I don't also think there is an optimal substructure and overlapping subproblem. I think the reason why they called this DP solution is that we use the previously computed ugly numbers to find the next one. If you checked out the hint, they say you can get the next ugly number from a smaller ugly number by multiplying it by either 2, 3 or 5. So we start from the bottom and work our way up to the nth ugly number, in each iteration finding the next ugly number using a previous one. But to see the overlapping subproblems, one would write a recursive solution, also called top-down, and see if there are any subproblems that overlaps. But I couldn't come up with recursive top-down solution. Or maybe there is an optimal substructure that I fail to see. "
                    },
                    {
                        "username": "logical_thinker",
                        "content": "can someone throw light on the last test case which is n being empty the 596th test case. what is that and how do I go about it."
                    },
                    {
                        "username": "urmichm",
                        "content": "why is 1 ugly number?"
                    },
                    {
                        "username": "at218808",
                        "content": "1 is a factor of every number , so its more like a ugly number has only factors as 1,2,3 or 5"
                    },
                    {
                        "username": "QuasiRus",
                        "content": "It does not have any prime factor outside [2, 3, 5] list. 1 itself is not a prime number."
                    }
                ]
            },
            {
                "id": 1795821,
                "content": [
                    {
                        "username": "lcn",
                        "content": " 1. Actually, the input space is much smaller than expected if we insist an `int` range output. \\nWhen input `n` is greater than `1691`, the output overflows the `int` range.\\n 2. Another way to view this bound is that all ugly numbers must be in the form `2^a*3^b*5^c`. Since we have `log2(Integer.MAX_VALUE)=a<31`, `log3(Integer.MAX_VALUE)=b<20` and `log5(Integer.MAX_VALUE)=c<14`, the combination allowed is surely under `31*20*14~=8400`.\\n\\nSo ugly number is sparser than one would usually think, and please do take care of overflow."
                    },
                    {
                        "username": "chauhanprerna21",
                        "content": "I am not able to understand how is ugly numbers a DP problem?\\nWould be great if someone could help with it."
                    },
                    {
                        "username": "vikasboss6855",
                        "content": "https://leetcode.com/problems/ugly-number-ii/solutions/3704058/c-memoized-solution-using-dp-forcible-dp/\n```\nclass Solution {\npublic:\n    int nthUglyNumber(int n) {\n        vector<int> dp(n);\n        dp[0] = 1;\n        return nthUglyNumberRecursive(dp, n, 1, 0, 0, 0);\n    }\n\nprivate:\n    int nthUglyNumberRecursive(vector<int>& dp, int n, int i, int p1, int p2, int p3) {\n        if (i == n) {\n            return dp[n - 1];\n        }\n\n        int twoMultiple = dp[p1] * 2;\n        int threeMultiple = dp[p2] * 3;\n        int fiveMultiple = dp[p3] * 5;\n\n        dp[i] = min(twoMultiple, min(threeMultiple, fiveMultiple));\n\n        int nextP1 = (dp[i] == twoMultiple) ? p1 + 1 : p1;\n        int nextP2 = (dp[i] == threeMultiple) ? p2 + 1 : p2;\n        int nextP3 = (dp[i] == fiveMultiple) ? p3 + 1 : p3;\n\n        return nthUglyNumberRecursive(dp, n, i + 1, nextP1, nextP2, nextP3);\n    }\n};\n\n```"
                    },
                    {
                        "username": "divyanshuparg",
                        "content": "I have solved it using recursion and hashing."
                    },
                    {
                        "username": "anshulguleria",
                        "content": "In the example in problem statement 1 was being counted as ugly number. I am not able to understand how we concluded that.\\n\\nif 1 = 1 * 2^0 then this theory will be true for other numbers as well like 7  * 2^0."
                    },
                    {
                        "username": "Seabayley",
                        "content": "![image](https://assets.leetcode.com/users/images/fad90901-6c35-455e-8ff0-8160380ca46c_1597993223.2791212.png)\\n\\nAm I misunderstanding the problem? The 11th ugly numbers looks to me as though it should be 14?"
                    },
                    {
                        "username": "codekorekhai",
                        "content": "[@satyamkumarskr](/satyamkumarskr) 14 is not an ugly number because it has 7 as factor but the problem said that only 2, 3, 5 will be the prime factor for each ugly number."
                    },
                    {
                        "username": "satyamkumarskr",
                        "content": "True . I got the same issue."
                    },
                    {
                        "username": "user6746E",
                        "content": "The 11th ugly number will not be 14 since the prime factor of 14 includes 7, but the question clearly states that the primes factor should be limited to 2, 3 or 5. Therefore 11th ugly number will be 15."
                    },
                    {
                        "username": "sazib204061",
                        "content": "I solve this problem in O(1) time complexity.\\n `class Solution {\\npublic:\\nvector<long long>ar = {1,2,3,4,5,6,8,9,10,12,15,16,18,20,24,25,27,30,32,36,40,45,48,50,54,60,64,72,75,80,81,90,96,100,108,120,125,128,135,144,150,160,162,180,192,200,216,225,240,243,250,256,270,288,300,320,324,360,375,384,400,405,432,450,480,486,500,512,540,576,600,625,640,648,675,720,729,750,768,800,810,864,900,960,972,1000,1024,1080,1125,1152,1200,1215,1250,1280,1296,1350,1440,1458,1500,1536,1600,1620,1728,1800,1875,1920,1944,2000,2025,2048,2160,2187,2250,2304,2400,2430,2500,2560,2592,2700,2880,2916,3000,3072,3125,3200,3240,3375,3456,3600,3645,3750,3840,3888,4000,4050,4096,4320,4374,4500,4608,4800,4860,5000,5120,5184,5400,5625,5760,5832,6000,6075,6144,6250,6400,6480,6561,6750,6912,7200,7290,7500,7680,7776,8000,8100,8192,8640,8748,9000,9216,9375,9600,9720,10000,10125,10240,10368,10800,10935,11250,11520,11664,12000,12150,12288,12500,12800,12960,13122,13500,13824,14400,14580,15000,15360,15552,15625,16000,16200,16384,16875,17280,17496,18000,18225,18432,18750,19200,19440,19683,20000,20250,20480,20736,21600,21870,22500,23040,23328,24000,24300,24576,25000,25600,25920,26244,27000,27648,28125,28800,29160,30000,30375,30720,31104,31250,32000,32400,32768,32805,33750,34560,34992,36000,36450,36864,37500,38400,38880,39366,40000,40500,40960,41472,43200,43740,45000,46080,46656,46875,48000,48600,49152,50000,50625,51200,51840,52488,54000,54675,55296,56250,57600,58320,59049,60000,60750,61440,62208,62500,64000,64800,65536,65610,67500,69120,69984,72000,72900,73728,75000,76800,77760,78125,78732,80000,81000,81920,82944,84375,86400,87480,90000,91125,92160,93312,93750,96000,97200,98304,98415,100000,101250,102400,103680,104976,108000,109350,110592,112500,115200,116640,118098,120000,121500,122880,124416,125000,128000,129600,131072,131220,135000,138240,139968,140625,144000,145800,147456,150000,151875,153600,155520,156250,157464,160000,162000,163840,164025,165888,168750,172800,174960,177147,180000,182250,184320,186624,187500,192000,194400,196608,196830,200000,202500,204800,207360,209952,216000,218700,221184,225000,230400,233280,234375,236196,240000,243000,245760,248832,250000,253125,256000,259200,262144,262440,270000,273375,276480,279936,281250,288000,291600,294912,295245,300000,303750,307200,311040,312500,314928,320000,324000,327680,328050,331776,337500,345600,349920,354294,360000,364500,368640,373248,375000,384000,388800,390625,393216,393660,400000,405000,409600,414720,419904,421875,432000,437400,442368,450000,455625,460800,466560,468750,472392,480000,486000,491520,492075,497664,500000,506250,512000,518400,524288,524880,531441,540000,546750,552960,559872,562500,576000,583200,589824,590490,600000,607500,614400,622080,625000,629856,640000,648000,655360,656100,663552,675000,691200,699840,703125,708588,720000,729000,737280,746496,750000,759375,768000,777600,781250,786432,787320,800000,810000,819200,820125,829440,839808,843750,864000,874800,884736,885735,900000,911250,921600,933120,937500,944784,\\n\\n960000,972000,983040,984150,995328,1000000,1012500,1024000,1036800,1048576,1049760,1062882,1080000,1093500,1105920,1119744,1125000,1152000,1166400,1171875,1179648,1180980,1200000,1215000,1228800,1244160,1250000,1259712,1265625,1280000,1296000,1310720,1312200,1327104,1350000,1366875,1382400,1399680,1406250,1417176,1440000,1458000,1474560,1476225,1492992,1500000,1518750,1536000,1555200,1562500,1572864,1574640,1594323,1600000,1620000,1638400,1640250,1658880,1679616,1687500,1728000,1749600,1769472,1771470,1800000,1822500,1843200,1866240,1875000,1889568,1920000,1944000,1953125,1966080,1968300,1990656,2000000,2025000,2048000,2073600,2097152,2099520,2109375,2125764,2160000,2187000,2211840,2239488,2250000,2278125,2304000,2332800,2343750,2359296,2361960,2400000,2430000,2457600,2460375,2488320,2500000,2519424,2531250,2560000,2592000,2621440,2624400,2654208,2657205,2700000,2733750,2764800,2799360,2812500,2834352,2880000,2916000,2949120,2952450,2985984,3000000,3037500,3072000,3110400,3125000,3145728,3149280,3188646,3200000,3240000,3276800,3280500,3317760,3359232,3375000,3456000,3499200,3515625,3538944,3542940,3600000,3645000,3686400,3732480,3750000,3779136,3796875,3840000,3888000,3906250,3932160,3936600,3981312,4000000,4050000,4096000,4100625,4147200,4194304,4199040,4218750,4251528,4320000,4374000,4423680,4428675,4478976,4500000,4556250,4608000,4665600,4687500,4718592,4723920,4782969,4800000,4860000,4915200,4920750,4976640,5000000,5038848,5062500,5120000,5184000,5242880,5248800,5308416,5314410,5400000,5467500,5529600,5598720,5625000,5668704,5760000,5832000,5859375,5898240,5904900,5971968,6000000,6075000,6144000,6220800,6250000,6291456,6298560,6328125,6377292,6400000,6480000,6553600,6561000,6635520,6718464,6750000,6834375,6912000,6998400,7031250,7077888,7085880,7200000,7290000,7372800,7381125,7464960,7500000,7558272,7593750,7680000,7776000,7812500,7864320,7873200,7962624,7971615,8000000,8100000,8192000,8201250,8294400,8388608,8398080,8437500,8503056,8640000,8748000,8847360,8857350,8957952,9000000,9112500,9216000,9331200,9375000,9437184,9447840,9565938,9600000,9720000,9765625,9830400,9841500,9953280,10000000,10077696,10125000,10240000,10368000,10485760,10497600,10546875,10616832,10628820,10800000,10935000,11059200,11197440,11250000,11337408,11390625,11520000,11664000,11718750,11796480,11809800,11943936,12000000,12150000,12288000,12301875,12441600,12500000,12582912,12597120,12656250,12754584,12800000,12960000,13107200,13122000,13271040,13286025,13436928,13500000,13668750,13824000,13996800,14062500,14155776,14171760,14348907,14400000,14580000,14745600,14762250,14929920,15000000,15116544,15187500,15360000,15552000,15625000,15728640,15746400,15925248,15943230,16000000,16200000,16384000,16402500,16588800,16777216,16796160,16875000,17006112,17280000,17496000,17578125,17694720,17714700,17915904,18000000,18225000,18432000,18662400,18750000,18874368,18895680,18984375,19131876,19200000,19440000,19531250,19660800,19683000,19906560,20000000,20155392,20250000,20480000,20503125,20736000,20971520,20995200,21093750,21233664,21257640,21600000,21870000,22118400,22143375,22394880,22500000,22674816,22781250,23040000,23328000,23437500,23592960,23619600,23887872,23914845,24000000,24300000,24576000,24603750,24883200,25000000,25165824,25194240,25312500,25509168,25600000,25920000,26214400,26244000,26542080,26572050,26873856,27000000,27337500,27648000,27993600,28125000,28311552,28343520,28697814,28800000,29160000,29296875,29491200,29524500,29859840,30000000,30233088,30375000,30720000,31104000,31250000,31457280,31492800,31640625,31850496,31886460,32000000,32400000,32768000,32805000,33177600,33554432,33592320,33750000,34012224,34171875,34560000,34992000,35156250,35389440,35429400,35831808,36000000,36450000,36864000,36905625,37324800,37500000,37748736,37791360,37968750,38263752,38400000,38880000,39062500,39321600,39366000,39813120,39858075,40000000,40310784,40500000,40960000,41006250,41472000,41943040,41990400,42187500,42467328,42515280,43046721,43200000,43740000,44236800,44286750,44789760,45000000,45349632,45562500,46080000,46656000,46875000,47185920,47239200,47775744,47829690,48000000,48600000,48828125,49152000,49207500,49766400,50000000,50331648,50388480,50625000,51018336,51200000,51840000,\\n\\n52428800,52488000,52734375,53084160,53144100,53747712,54000000,54675000,55296000,55987200,56250000,56623104,56687040,56953125,57395628,57600000,58320000,58593750,58982400,59049000,59719680,60000000,60466176,60750000,61440000,61509375,62208000,62500000,62914560,62985600,63281250,63700992,63772920,64000000,64800000,65536000,65610000,66355200,66430125,67108864,67184640,67500000,68024448,68343750,69120000,69984000,70312500,70778880,70858800,71663616,71744535,72000000,72900000,73728000,73811250,74649600,75000000,75497472,75582720,75937500,76527504,76800000,77760000,78125000,78643200,78732000,79626240,79716150,80000000,80621568,81000000,81920000,82012500,82944000,83886080,83980800,84375000,84934656,85030560,86093442,86400000,87480000,87890625,88473600,88573500,89579520,90000000,90699264,91125000,92160000,93312000,93750000,94371840,94478400,94921875,95551488,95659380,96000000,97200000,97656250,98304000,98415000,99532800,100000000,100663296,100776960,101250000,102036672,102400000,102515625,103680000,104857600,104976000,105468750,106168320,106288200,107495424,108000000,109350000,110592000,110716875,111974400,112500000,113246208,113374080,113906250,114791256,115200000,116640000,117187500,117964800,118098000,119439360,119574225,120000000,120932352,121500000,122880000,123018750,124416000,125000000,125829120,125971200,126562500,127401984,127545840,128000000,129140163,129600000,131072000,131220000,132710400,132860250,134217728,134369280,135000000,136048896,136687500,138240000,139968000,140625000,141557760,141717600,143327232,143489070,144000000,145800000,146484375,147456000,147622500,149299200,150000000,150994944,151165440,151875000,153055008,153600000,155520000,156250000,157286400,157464000,158203125,159252480,159432300,160000000,161243136,162000000,163840000,164025000,165888000,167772160,167961600,168750000,169869312,170061120,170859375,172186884,172800000,174960000,175781250,\\n\\n\\n176947200,177147000,179159040,180000000,181398528,182250000,184320000,184528125,186624000,187500000,188743680,188956800,189843750,191102976,191318760,192000000,194400000,195312500,196608000,196830000,199065600,199290375,200000000,201326592,201553920,202500000,204073344,204800000,205031250,207360000,209715200,209952000,210937500,212336640,212576400,214990848,215233605,216000000,218700000,221184000,221433750,223948800,225000000,226492416,226748160,227812500,229582512,230400000,233280000,234375000,235929600,236196000,238878720,239148450,240000000,241864704,243000000,244140625,245760000,246037500,248832000,250000000,251658240,251942400,253125000,254803968,255091680,256000000,258280326,259200000,262144000,262440000,263671875,265420800,265720500,268435456,268738560,270000000,272097792,273375000,276480000,279936000,281250000,283115520,283435200,284765625,286654464,286978140,288000000,291600000,292968750,294912000,295245000,298598400,300000000,301989888,302330880,303750000,306110016,307200000,307546875,311040000,312500000,314572800,314928000,316406250,318504960,318864600,320000000,322486272,324000000,327680000,328050000,331776000,332150625,335544320,335923200,337500000,339738624,340122240,341718750,344373768,345600000,349920000,351562500,353894400,354294000,358318080,358722675,360000000,362797056,364500000,368640000,369056250,373248000,375000000,377487360,377913600,379687500,382205952,382637520,384000000,387420489,388800000,390625000,393216000,393660000,398131200,398580750,400000000,402653184,403107840,405000000,408146688,409600000,410062500,414720000,419430400,419904000,421875000,424673280,425152800,429981696,430467210,432000000,437400000,439453125,442368000,442867500,447897600,450000000,452984832,453496320,455625000,459165024,460800000,466560000,468750000,471859200,472392000,474609375,477757440,478296900,480000000,483729408,486000000,488281250,491520000,492075000,497664000,500000000,503316480,503884800,506250000,509607936,510183360,512000000,512578125,516560652,518400000,\\n\\n524288000,524880000,527343750,530841600,531441000,536870912,537477120,540000000,544195584,546750000,552960000,553584375,559872000,562500000,566231040,566870400,569531250,573308928,573956280,576000000,583200000,585937500,589824000,590490000,597196800,597871125,600000000,603979776,604661760,607500000,612220032,614400000,615093750,622080000,625000000,629145600,629856000,632812500,637009920,637729200,640000000,644972544,645700815,648000000,655360000,656100000,663552000,664301250,671088640,671846400,675000000,679477248,680244480,683437500,688747536,691200000,699840000,703125000,707788800,708588000,716636160,717445350,720000000,725594112,729000000,732421875,737280000,738112500,746496000,750000000,754974720,755827200,759375000,764411904,765275040,768000000,774840978,777600000,781250000,786432000,787320000,791015625,796262400,797161500,800000000,805306368,806215680,810000000,816293376,819200000,820125000,829440000,838860800,839808000,843750000,849346560,850305600,854296875,859963392,860934420,864000000,874800000,878906250,884736000,885735000,895795200,900000000,905969664,906992640,911250000,918330048,921600000,922640625,933120000,937500000,943718400,944784000,949218750,955514880,956593800,960000000,967458816,972000000,976562500,983040000,984150000,995328000,996451875,1000000000,1006632960,1007769600,1012500000,1019215872,1020366720,1024000000,1025156250,1033121304,1036800000,1048576000,1049760000,1054687500,1061683200,1062882000,1073741824,1074954240,1076168025,1080000000,1088391168,1093500000,1105920000,1107168750,1119744000,1125000000,1132462080,1133740800,1139062500,1146617856,1147912560,1152000000,1162261467,1166400000,1171875000,1179648000,1180980000,1194393600,1195742250,1200000000,1207959552,1209323520,1215000000,1220703125,1224440064,1228800000,1230187500,1244160000,1250000000,1258291200,1259712000,1265625000,1274019840,1275458400,1280000000,1289945088,1291401630,1296000000,1310720000,1312200000,1318359375,1327104000,1328602500,1342177280,1343692800,1350000000,1358954496,1360488960,1366875000,1377495072,1382400000,1399680000,1406250000,1415577600,1417176000,1423828125,1433272320,1434890700,1440000000,1451188224,1458000000,1464843750,1474560000,1476225000,1492992000,1500000000,1509949440,1511654400,1518750000,1528823808,1530550080,1536000000,1537734375,1549681956,1555200000,1562500000,1572864000,1574640000,1582031250,1592524800,1594323000,1600000000,1610612736,1612431360,1620000000,1632586752,1638400000,1640250000,1658880000,1660753125,1677721600,1679616000,1687500000,1698693120,1700611200,1708593750,1719926784,1721868840,1728000000,1749600000,1757812500,1769472000,1771470000,1791590400,1793613375,1800000000,1811939328,1813985280,1822500000,1836660096,1843200000,1845281250,1866240000,1875000000,1887436800,1889568000,1898437500,1911029760,1913187600,1920000000,1934917632,1937102445,1944000000,1953125000,1966080000,1968300000,1990656000,1992903750,2000000000,2013265920,2015539200,2025000000,2038431744,2040733440,2048000000,2050312500,2066242608,2073600000,2097152000,2099520000,2109375000,2123366400,2125764000,2147483648,2149908480,2152336050,2160000000,2176782336,2187000000,2197265625,2211840000,2214337500,2239488000\\n\\n\\n};\\n\\n    int nthUglyNumber(int n) {\\n        return ar[n-1]; \\n    }\\n};`"
                    },
                    {
                        "username": "AasheeshLikePanner",
                        "content": "Bro stop this \\uD83D\\uDE2D\\uD83D\\uDE2D\\uD83D\\uDE2D"
                    },
                    {
                        "username": "Mayank_Shahria",
                        "content": "**I have solved this by two methods \\n1. Brute force**\\nBut it is giving a run time error\\n![image](https://assets.leetcode.com/users/images/ba539fa1-405b-4d9d-832a-5be83172edc4_1620554425.1931248.png)\\n**2. Dynamic Programing**\\n![image](https://assets.leetcode.com/users/images/3a90f09e-1a3c-465f-a8d6-b58bfc613ccf_1620554465.9711976.png)\\n\\n\\n"
                    },
                    {
                        "username": "aman_online67",
                        "content": "I also applied brute force but it gives TLE at some 500 test case. But logic wise it is correct what to do now"
                    },
                    {
                        "username": "Rohith6776",
                        "content": "If the prime factors are limited to 2,3,5 and we should not consider numbers like(14->2*7, 21->3*7) right?"
                    },
                    {
                        "username": "wtfcoder",
                        "content": "yup"
                    },
                    {
                        "username": "c_jain",
                        "content": "After reading top solutions here, I realized optimized solution is not a DP solution because I am not able to figure out optimal substructure and overlapping subproblem. I think it is kind of 3 pointer solution. Anyone like to clarify this?"
                    },
                    {
                        "username": "vikasboss6855",
                        "content": "https://leetcode.com/problems/ugly-number-ii/solutions/3704058/c-memoized-solution-using-dp-forcible-dp/"
                    },
                    {
                        "username": "Gismet",
                        "content": "Yeah, you are right. I don't also think there is an optimal substructure and overlapping subproblem. I think the reason why they called this DP solution is that we use the previously computed ugly numbers to find the next one. If you checked out the hint, they say you can get the next ugly number from a smaller ugly number by multiplying it by either 2, 3 or 5. So we start from the bottom and work our way up to the nth ugly number, in each iteration finding the next ugly number using a previous one. But to see the overlapping subproblems, one would write a recursive solution, also called top-down, and see if there are any subproblems that overlaps. But I couldn't come up with recursive top-down solution. Or maybe there is an optimal substructure that I fail to see. "
                    },
                    {
                        "username": "logical_thinker",
                        "content": "can someone throw light on the last test case which is n being empty the 596th test case. what is that and how do I go about it."
                    },
                    {
                        "username": "urmichm",
                        "content": "why is 1 ugly number?"
                    },
                    {
                        "username": "at218808",
                        "content": "1 is a factor of every number , so its more like a ugly number has only factors as 1,2,3 or 5"
                    },
                    {
                        "username": "QuasiRus",
                        "content": "It does not have any prime factor outside [2, 3, 5] list. 1 itself is not a prime number."
                    }
                ]
            },
            {
                "id": 1573274,
                "content": [
                    {
                        "username": "lcn",
                        "content": " 1. Actually, the input space is much smaller than expected if we insist an `int` range output. \\nWhen input `n` is greater than `1691`, the output overflows the `int` range.\\n 2. Another way to view this bound is that all ugly numbers must be in the form `2^a*3^b*5^c`. Since we have `log2(Integer.MAX_VALUE)=a<31`, `log3(Integer.MAX_VALUE)=b<20` and `log5(Integer.MAX_VALUE)=c<14`, the combination allowed is surely under `31*20*14~=8400`.\\n\\nSo ugly number is sparser than one would usually think, and please do take care of overflow."
                    },
                    {
                        "username": "chauhanprerna21",
                        "content": "I am not able to understand how is ugly numbers a DP problem?\\nWould be great if someone could help with it."
                    },
                    {
                        "username": "vikasboss6855",
                        "content": "https://leetcode.com/problems/ugly-number-ii/solutions/3704058/c-memoized-solution-using-dp-forcible-dp/\n```\nclass Solution {\npublic:\n    int nthUglyNumber(int n) {\n        vector<int> dp(n);\n        dp[0] = 1;\n        return nthUglyNumberRecursive(dp, n, 1, 0, 0, 0);\n    }\n\nprivate:\n    int nthUglyNumberRecursive(vector<int>& dp, int n, int i, int p1, int p2, int p3) {\n        if (i == n) {\n            return dp[n - 1];\n        }\n\n        int twoMultiple = dp[p1] * 2;\n        int threeMultiple = dp[p2] * 3;\n        int fiveMultiple = dp[p3] * 5;\n\n        dp[i] = min(twoMultiple, min(threeMultiple, fiveMultiple));\n\n        int nextP1 = (dp[i] == twoMultiple) ? p1 + 1 : p1;\n        int nextP2 = (dp[i] == threeMultiple) ? p2 + 1 : p2;\n        int nextP3 = (dp[i] == fiveMultiple) ? p3 + 1 : p3;\n\n        return nthUglyNumberRecursive(dp, n, i + 1, nextP1, nextP2, nextP3);\n    }\n};\n\n```"
                    },
                    {
                        "username": "divyanshuparg",
                        "content": "I have solved it using recursion and hashing."
                    },
                    {
                        "username": "anshulguleria",
                        "content": "In the example in problem statement 1 was being counted as ugly number. I am not able to understand how we concluded that.\\n\\nif 1 = 1 * 2^0 then this theory will be true for other numbers as well like 7  * 2^0."
                    },
                    {
                        "username": "Seabayley",
                        "content": "![image](https://assets.leetcode.com/users/images/fad90901-6c35-455e-8ff0-8160380ca46c_1597993223.2791212.png)\\n\\nAm I misunderstanding the problem? The 11th ugly numbers looks to me as though it should be 14?"
                    },
                    {
                        "username": "codekorekhai",
                        "content": "[@satyamkumarskr](/satyamkumarskr) 14 is not an ugly number because it has 7 as factor but the problem said that only 2, 3, 5 will be the prime factor for each ugly number."
                    },
                    {
                        "username": "satyamkumarskr",
                        "content": "True . I got the same issue."
                    },
                    {
                        "username": "user6746E",
                        "content": "The 11th ugly number will not be 14 since the prime factor of 14 includes 7, but the question clearly states that the primes factor should be limited to 2, 3 or 5. Therefore 11th ugly number will be 15."
                    },
                    {
                        "username": "sazib204061",
                        "content": "I solve this problem in O(1) time complexity.\\n `class Solution {\\npublic:\\nvector<long long>ar = {1,2,3,4,5,6,8,9,10,12,15,16,18,20,24,25,27,30,32,36,40,45,48,50,54,60,64,72,75,80,81,90,96,100,108,120,125,128,135,144,150,160,162,180,192,200,216,225,240,243,250,256,270,288,300,320,324,360,375,384,400,405,432,450,480,486,500,512,540,576,600,625,640,648,675,720,729,750,768,800,810,864,900,960,972,1000,1024,1080,1125,1152,1200,1215,1250,1280,1296,1350,1440,1458,1500,1536,1600,1620,1728,1800,1875,1920,1944,2000,2025,2048,2160,2187,2250,2304,2400,2430,2500,2560,2592,2700,2880,2916,3000,3072,3125,3200,3240,3375,3456,3600,3645,3750,3840,3888,4000,4050,4096,4320,4374,4500,4608,4800,4860,5000,5120,5184,5400,5625,5760,5832,6000,6075,6144,6250,6400,6480,6561,6750,6912,7200,7290,7500,7680,7776,8000,8100,8192,8640,8748,9000,9216,9375,9600,9720,10000,10125,10240,10368,10800,10935,11250,11520,11664,12000,12150,12288,12500,12800,12960,13122,13500,13824,14400,14580,15000,15360,15552,15625,16000,16200,16384,16875,17280,17496,18000,18225,18432,18750,19200,19440,19683,20000,20250,20480,20736,21600,21870,22500,23040,23328,24000,24300,24576,25000,25600,25920,26244,27000,27648,28125,28800,29160,30000,30375,30720,31104,31250,32000,32400,32768,32805,33750,34560,34992,36000,36450,36864,37500,38400,38880,39366,40000,40500,40960,41472,43200,43740,45000,46080,46656,46875,48000,48600,49152,50000,50625,51200,51840,52488,54000,54675,55296,56250,57600,58320,59049,60000,60750,61440,62208,62500,64000,64800,65536,65610,67500,69120,69984,72000,72900,73728,75000,76800,77760,78125,78732,80000,81000,81920,82944,84375,86400,87480,90000,91125,92160,93312,93750,96000,97200,98304,98415,100000,101250,102400,103680,104976,108000,109350,110592,112500,115200,116640,118098,120000,121500,122880,124416,125000,128000,129600,131072,131220,135000,138240,139968,140625,144000,145800,147456,150000,151875,153600,155520,156250,157464,160000,162000,163840,164025,165888,168750,172800,174960,177147,180000,182250,184320,186624,187500,192000,194400,196608,196830,200000,202500,204800,207360,209952,216000,218700,221184,225000,230400,233280,234375,236196,240000,243000,245760,248832,250000,253125,256000,259200,262144,262440,270000,273375,276480,279936,281250,288000,291600,294912,295245,300000,303750,307200,311040,312500,314928,320000,324000,327680,328050,331776,337500,345600,349920,354294,360000,364500,368640,373248,375000,384000,388800,390625,393216,393660,400000,405000,409600,414720,419904,421875,432000,437400,442368,450000,455625,460800,466560,468750,472392,480000,486000,491520,492075,497664,500000,506250,512000,518400,524288,524880,531441,540000,546750,552960,559872,562500,576000,583200,589824,590490,600000,607500,614400,622080,625000,629856,640000,648000,655360,656100,663552,675000,691200,699840,703125,708588,720000,729000,737280,746496,750000,759375,768000,777600,781250,786432,787320,800000,810000,819200,820125,829440,839808,843750,864000,874800,884736,885735,900000,911250,921600,933120,937500,944784,\\n\\n960000,972000,983040,984150,995328,1000000,1012500,1024000,1036800,1048576,1049760,1062882,1080000,1093500,1105920,1119744,1125000,1152000,1166400,1171875,1179648,1180980,1200000,1215000,1228800,1244160,1250000,1259712,1265625,1280000,1296000,1310720,1312200,1327104,1350000,1366875,1382400,1399680,1406250,1417176,1440000,1458000,1474560,1476225,1492992,1500000,1518750,1536000,1555200,1562500,1572864,1574640,1594323,1600000,1620000,1638400,1640250,1658880,1679616,1687500,1728000,1749600,1769472,1771470,1800000,1822500,1843200,1866240,1875000,1889568,1920000,1944000,1953125,1966080,1968300,1990656,2000000,2025000,2048000,2073600,2097152,2099520,2109375,2125764,2160000,2187000,2211840,2239488,2250000,2278125,2304000,2332800,2343750,2359296,2361960,2400000,2430000,2457600,2460375,2488320,2500000,2519424,2531250,2560000,2592000,2621440,2624400,2654208,2657205,2700000,2733750,2764800,2799360,2812500,2834352,2880000,2916000,2949120,2952450,2985984,3000000,3037500,3072000,3110400,3125000,3145728,3149280,3188646,3200000,3240000,3276800,3280500,3317760,3359232,3375000,3456000,3499200,3515625,3538944,3542940,3600000,3645000,3686400,3732480,3750000,3779136,3796875,3840000,3888000,3906250,3932160,3936600,3981312,4000000,4050000,4096000,4100625,4147200,4194304,4199040,4218750,4251528,4320000,4374000,4423680,4428675,4478976,4500000,4556250,4608000,4665600,4687500,4718592,4723920,4782969,4800000,4860000,4915200,4920750,4976640,5000000,5038848,5062500,5120000,5184000,5242880,5248800,5308416,5314410,5400000,5467500,5529600,5598720,5625000,5668704,5760000,5832000,5859375,5898240,5904900,5971968,6000000,6075000,6144000,6220800,6250000,6291456,6298560,6328125,6377292,6400000,6480000,6553600,6561000,6635520,6718464,6750000,6834375,6912000,6998400,7031250,7077888,7085880,7200000,7290000,7372800,7381125,7464960,7500000,7558272,7593750,7680000,7776000,7812500,7864320,7873200,7962624,7971615,8000000,8100000,8192000,8201250,8294400,8388608,8398080,8437500,8503056,8640000,8748000,8847360,8857350,8957952,9000000,9112500,9216000,9331200,9375000,9437184,9447840,9565938,9600000,9720000,9765625,9830400,9841500,9953280,10000000,10077696,10125000,10240000,10368000,10485760,10497600,10546875,10616832,10628820,10800000,10935000,11059200,11197440,11250000,11337408,11390625,11520000,11664000,11718750,11796480,11809800,11943936,12000000,12150000,12288000,12301875,12441600,12500000,12582912,12597120,12656250,12754584,12800000,12960000,13107200,13122000,13271040,13286025,13436928,13500000,13668750,13824000,13996800,14062500,14155776,14171760,14348907,14400000,14580000,14745600,14762250,14929920,15000000,15116544,15187500,15360000,15552000,15625000,15728640,15746400,15925248,15943230,16000000,16200000,16384000,16402500,16588800,16777216,16796160,16875000,17006112,17280000,17496000,17578125,17694720,17714700,17915904,18000000,18225000,18432000,18662400,18750000,18874368,18895680,18984375,19131876,19200000,19440000,19531250,19660800,19683000,19906560,20000000,20155392,20250000,20480000,20503125,20736000,20971520,20995200,21093750,21233664,21257640,21600000,21870000,22118400,22143375,22394880,22500000,22674816,22781250,23040000,23328000,23437500,23592960,23619600,23887872,23914845,24000000,24300000,24576000,24603750,24883200,25000000,25165824,25194240,25312500,25509168,25600000,25920000,26214400,26244000,26542080,26572050,26873856,27000000,27337500,27648000,27993600,28125000,28311552,28343520,28697814,28800000,29160000,29296875,29491200,29524500,29859840,30000000,30233088,30375000,30720000,31104000,31250000,31457280,31492800,31640625,31850496,31886460,32000000,32400000,32768000,32805000,33177600,33554432,33592320,33750000,34012224,34171875,34560000,34992000,35156250,35389440,35429400,35831808,36000000,36450000,36864000,36905625,37324800,37500000,37748736,37791360,37968750,38263752,38400000,38880000,39062500,39321600,39366000,39813120,39858075,40000000,40310784,40500000,40960000,41006250,41472000,41943040,41990400,42187500,42467328,42515280,43046721,43200000,43740000,44236800,44286750,44789760,45000000,45349632,45562500,46080000,46656000,46875000,47185920,47239200,47775744,47829690,48000000,48600000,48828125,49152000,49207500,49766400,50000000,50331648,50388480,50625000,51018336,51200000,51840000,\\n\\n52428800,52488000,52734375,53084160,53144100,53747712,54000000,54675000,55296000,55987200,56250000,56623104,56687040,56953125,57395628,57600000,58320000,58593750,58982400,59049000,59719680,60000000,60466176,60750000,61440000,61509375,62208000,62500000,62914560,62985600,63281250,63700992,63772920,64000000,64800000,65536000,65610000,66355200,66430125,67108864,67184640,67500000,68024448,68343750,69120000,69984000,70312500,70778880,70858800,71663616,71744535,72000000,72900000,73728000,73811250,74649600,75000000,75497472,75582720,75937500,76527504,76800000,77760000,78125000,78643200,78732000,79626240,79716150,80000000,80621568,81000000,81920000,82012500,82944000,83886080,83980800,84375000,84934656,85030560,86093442,86400000,87480000,87890625,88473600,88573500,89579520,90000000,90699264,91125000,92160000,93312000,93750000,94371840,94478400,94921875,95551488,95659380,96000000,97200000,97656250,98304000,98415000,99532800,100000000,100663296,100776960,101250000,102036672,102400000,102515625,103680000,104857600,104976000,105468750,106168320,106288200,107495424,108000000,109350000,110592000,110716875,111974400,112500000,113246208,113374080,113906250,114791256,115200000,116640000,117187500,117964800,118098000,119439360,119574225,120000000,120932352,121500000,122880000,123018750,124416000,125000000,125829120,125971200,126562500,127401984,127545840,128000000,129140163,129600000,131072000,131220000,132710400,132860250,134217728,134369280,135000000,136048896,136687500,138240000,139968000,140625000,141557760,141717600,143327232,143489070,144000000,145800000,146484375,147456000,147622500,149299200,150000000,150994944,151165440,151875000,153055008,153600000,155520000,156250000,157286400,157464000,158203125,159252480,159432300,160000000,161243136,162000000,163840000,164025000,165888000,167772160,167961600,168750000,169869312,170061120,170859375,172186884,172800000,174960000,175781250,\\n\\n\\n176947200,177147000,179159040,180000000,181398528,182250000,184320000,184528125,186624000,187500000,188743680,188956800,189843750,191102976,191318760,192000000,194400000,195312500,196608000,196830000,199065600,199290375,200000000,201326592,201553920,202500000,204073344,204800000,205031250,207360000,209715200,209952000,210937500,212336640,212576400,214990848,215233605,216000000,218700000,221184000,221433750,223948800,225000000,226492416,226748160,227812500,229582512,230400000,233280000,234375000,235929600,236196000,238878720,239148450,240000000,241864704,243000000,244140625,245760000,246037500,248832000,250000000,251658240,251942400,253125000,254803968,255091680,256000000,258280326,259200000,262144000,262440000,263671875,265420800,265720500,268435456,268738560,270000000,272097792,273375000,276480000,279936000,281250000,283115520,283435200,284765625,286654464,286978140,288000000,291600000,292968750,294912000,295245000,298598400,300000000,301989888,302330880,303750000,306110016,307200000,307546875,311040000,312500000,314572800,314928000,316406250,318504960,318864600,320000000,322486272,324000000,327680000,328050000,331776000,332150625,335544320,335923200,337500000,339738624,340122240,341718750,344373768,345600000,349920000,351562500,353894400,354294000,358318080,358722675,360000000,362797056,364500000,368640000,369056250,373248000,375000000,377487360,377913600,379687500,382205952,382637520,384000000,387420489,388800000,390625000,393216000,393660000,398131200,398580750,400000000,402653184,403107840,405000000,408146688,409600000,410062500,414720000,419430400,419904000,421875000,424673280,425152800,429981696,430467210,432000000,437400000,439453125,442368000,442867500,447897600,450000000,452984832,453496320,455625000,459165024,460800000,466560000,468750000,471859200,472392000,474609375,477757440,478296900,480000000,483729408,486000000,488281250,491520000,492075000,497664000,500000000,503316480,503884800,506250000,509607936,510183360,512000000,512578125,516560652,518400000,\\n\\n524288000,524880000,527343750,530841600,531441000,536870912,537477120,540000000,544195584,546750000,552960000,553584375,559872000,562500000,566231040,566870400,569531250,573308928,573956280,576000000,583200000,585937500,589824000,590490000,597196800,597871125,600000000,603979776,604661760,607500000,612220032,614400000,615093750,622080000,625000000,629145600,629856000,632812500,637009920,637729200,640000000,644972544,645700815,648000000,655360000,656100000,663552000,664301250,671088640,671846400,675000000,679477248,680244480,683437500,688747536,691200000,699840000,703125000,707788800,708588000,716636160,717445350,720000000,725594112,729000000,732421875,737280000,738112500,746496000,750000000,754974720,755827200,759375000,764411904,765275040,768000000,774840978,777600000,781250000,786432000,787320000,791015625,796262400,797161500,800000000,805306368,806215680,810000000,816293376,819200000,820125000,829440000,838860800,839808000,843750000,849346560,850305600,854296875,859963392,860934420,864000000,874800000,878906250,884736000,885735000,895795200,900000000,905969664,906992640,911250000,918330048,921600000,922640625,933120000,937500000,943718400,944784000,949218750,955514880,956593800,960000000,967458816,972000000,976562500,983040000,984150000,995328000,996451875,1000000000,1006632960,1007769600,1012500000,1019215872,1020366720,1024000000,1025156250,1033121304,1036800000,1048576000,1049760000,1054687500,1061683200,1062882000,1073741824,1074954240,1076168025,1080000000,1088391168,1093500000,1105920000,1107168750,1119744000,1125000000,1132462080,1133740800,1139062500,1146617856,1147912560,1152000000,1162261467,1166400000,1171875000,1179648000,1180980000,1194393600,1195742250,1200000000,1207959552,1209323520,1215000000,1220703125,1224440064,1228800000,1230187500,1244160000,1250000000,1258291200,1259712000,1265625000,1274019840,1275458400,1280000000,1289945088,1291401630,1296000000,1310720000,1312200000,1318359375,1327104000,1328602500,1342177280,1343692800,1350000000,1358954496,1360488960,1366875000,1377495072,1382400000,1399680000,1406250000,1415577600,1417176000,1423828125,1433272320,1434890700,1440000000,1451188224,1458000000,1464843750,1474560000,1476225000,1492992000,1500000000,1509949440,1511654400,1518750000,1528823808,1530550080,1536000000,1537734375,1549681956,1555200000,1562500000,1572864000,1574640000,1582031250,1592524800,1594323000,1600000000,1610612736,1612431360,1620000000,1632586752,1638400000,1640250000,1658880000,1660753125,1677721600,1679616000,1687500000,1698693120,1700611200,1708593750,1719926784,1721868840,1728000000,1749600000,1757812500,1769472000,1771470000,1791590400,1793613375,1800000000,1811939328,1813985280,1822500000,1836660096,1843200000,1845281250,1866240000,1875000000,1887436800,1889568000,1898437500,1911029760,1913187600,1920000000,1934917632,1937102445,1944000000,1953125000,1966080000,1968300000,1990656000,1992903750,2000000000,2013265920,2015539200,2025000000,2038431744,2040733440,2048000000,2050312500,2066242608,2073600000,2097152000,2099520000,2109375000,2123366400,2125764000,2147483648,2149908480,2152336050,2160000000,2176782336,2187000000,2197265625,2211840000,2214337500,2239488000\\n\\n\\n};\\n\\n    int nthUglyNumber(int n) {\\n        return ar[n-1]; \\n    }\\n};`"
                    },
                    {
                        "username": "AasheeshLikePanner",
                        "content": "Bro stop this \\uD83D\\uDE2D\\uD83D\\uDE2D\\uD83D\\uDE2D"
                    },
                    {
                        "username": "Mayank_Shahria",
                        "content": "**I have solved this by two methods \\n1. Brute force**\\nBut it is giving a run time error\\n![image](https://assets.leetcode.com/users/images/ba539fa1-405b-4d9d-832a-5be83172edc4_1620554425.1931248.png)\\n**2. Dynamic Programing**\\n![image](https://assets.leetcode.com/users/images/3a90f09e-1a3c-465f-a8d6-b58bfc613ccf_1620554465.9711976.png)\\n\\n\\n"
                    },
                    {
                        "username": "aman_online67",
                        "content": "I also applied brute force but it gives TLE at some 500 test case. But logic wise it is correct what to do now"
                    },
                    {
                        "username": "Rohith6776",
                        "content": "If the prime factors are limited to 2,3,5 and we should not consider numbers like(14->2*7, 21->3*7) right?"
                    },
                    {
                        "username": "wtfcoder",
                        "content": "yup"
                    },
                    {
                        "username": "c_jain",
                        "content": "After reading top solutions here, I realized optimized solution is not a DP solution because I am not able to figure out optimal substructure and overlapping subproblem. I think it is kind of 3 pointer solution. Anyone like to clarify this?"
                    },
                    {
                        "username": "vikasboss6855",
                        "content": "https://leetcode.com/problems/ugly-number-ii/solutions/3704058/c-memoized-solution-using-dp-forcible-dp/"
                    },
                    {
                        "username": "Gismet",
                        "content": "Yeah, you are right. I don't also think there is an optimal substructure and overlapping subproblem. I think the reason why they called this DP solution is that we use the previously computed ugly numbers to find the next one. If you checked out the hint, they say you can get the next ugly number from a smaller ugly number by multiplying it by either 2, 3 or 5. So we start from the bottom and work our way up to the nth ugly number, in each iteration finding the next ugly number using a previous one. But to see the overlapping subproblems, one would write a recursive solution, also called top-down, and see if there are any subproblems that overlaps. But I couldn't come up with recursive top-down solution. Or maybe there is an optimal substructure that I fail to see. "
                    },
                    {
                        "username": "logical_thinker",
                        "content": "can someone throw light on the last test case which is n being empty the 596th test case. what is that and how do I go about it."
                    },
                    {
                        "username": "urmichm",
                        "content": "why is 1 ugly number?"
                    },
                    {
                        "username": "at218808",
                        "content": "1 is a factor of every number , so its more like a ugly number has only factors as 1,2,3 or 5"
                    },
                    {
                        "username": "QuasiRus",
                        "content": "It does not have any prime factor outside [2, 3, 5] list. 1 itself is not a prime number."
                    }
                ]
            },
            {
                "id": 1838471,
                "content": [
                    {
                        "username": "lcn",
                        "content": " 1. Actually, the input space is much smaller than expected if we insist an `int` range output. \\nWhen input `n` is greater than `1691`, the output overflows the `int` range.\\n 2. Another way to view this bound is that all ugly numbers must be in the form `2^a*3^b*5^c`. Since we have `log2(Integer.MAX_VALUE)=a<31`, `log3(Integer.MAX_VALUE)=b<20` and `log5(Integer.MAX_VALUE)=c<14`, the combination allowed is surely under `31*20*14~=8400`.\\n\\nSo ugly number is sparser than one would usually think, and please do take care of overflow."
                    },
                    {
                        "username": "chauhanprerna21",
                        "content": "I am not able to understand how is ugly numbers a DP problem?\\nWould be great if someone could help with it."
                    },
                    {
                        "username": "vikasboss6855",
                        "content": "https://leetcode.com/problems/ugly-number-ii/solutions/3704058/c-memoized-solution-using-dp-forcible-dp/\n```\nclass Solution {\npublic:\n    int nthUglyNumber(int n) {\n        vector<int> dp(n);\n        dp[0] = 1;\n        return nthUglyNumberRecursive(dp, n, 1, 0, 0, 0);\n    }\n\nprivate:\n    int nthUglyNumberRecursive(vector<int>& dp, int n, int i, int p1, int p2, int p3) {\n        if (i == n) {\n            return dp[n - 1];\n        }\n\n        int twoMultiple = dp[p1] * 2;\n        int threeMultiple = dp[p2] * 3;\n        int fiveMultiple = dp[p3] * 5;\n\n        dp[i] = min(twoMultiple, min(threeMultiple, fiveMultiple));\n\n        int nextP1 = (dp[i] == twoMultiple) ? p1 + 1 : p1;\n        int nextP2 = (dp[i] == threeMultiple) ? p2 + 1 : p2;\n        int nextP3 = (dp[i] == fiveMultiple) ? p3 + 1 : p3;\n\n        return nthUglyNumberRecursive(dp, n, i + 1, nextP1, nextP2, nextP3);\n    }\n};\n\n```"
                    },
                    {
                        "username": "divyanshuparg",
                        "content": "I have solved it using recursion and hashing."
                    },
                    {
                        "username": "anshulguleria",
                        "content": "In the example in problem statement 1 was being counted as ugly number. I am not able to understand how we concluded that.\\n\\nif 1 = 1 * 2^0 then this theory will be true for other numbers as well like 7  * 2^0."
                    },
                    {
                        "username": "Seabayley",
                        "content": "![image](https://assets.leetcode.com/users/images/fad90901-6c35-455e-8ff0-8160380ca46c_1597993223.2791212.png)\\n\\nAm I misunderstanding the problem? The 11th ugly numbers looks to me as though it should be 14?"
                    },
                    {
                        "username": "codekorekhai",
                        "content": "[@satyamkumarskr](/satyamkumarskr) 14 is not an ugly number because it has 7 as factor but the problem said that only 2, 3, 5 will be the prime factor for each ugly number."
                    },
                    {
                        "username": "satyamkumarskr",
                        "content": "True . I got the same issue."
                    },
                    {
                        "username": "user6746E",
                        "content": "The 11th ugly number will not be 14 since the prime factor of 14 includes 7, but the question clearly states that the primes factor should be limited to 2, 3 or 5. Therefore 11th ugly number will be 15."
                    },
                    {
                        "username": "sazib204061",
                        "content": "I solve this problem in O(1) time complexity.\\n `class Solution {\\npublic:\\nvector<long long>ar = {1,2,3,4,5,6,8,9,10,12,15,16,18,20,24,25,27,30,32,36,40,45,48,50,54,60,64,72,75,80,81,90,96,100,108,120,125,128,135,144,150,160,162,180,192,200,216,225,240,243,250,256,270,288,300,320,324,360,375,384,400,405,432,450,480,486,500,512,540,576,600,625,640,648,675,720,729,750,768,800,810,864,900,960,972,1000,1024,1080,1125,1152,1200,1215,1250,1280,1296,1350,1440,1458,1500,1536,1600,1620,1728,1800,1875,1920,1944,2000,2025,2048,2160,2187,2250,2304,2400,2430,2500,2560,2592,2700,2880,2916,3000,3072,3125,3200,3240,3375,3456,3600,3645,3750,3840,3888,4000,4050,4096,4320,4374,4500,4608,4800,4860,5000,5120,5184,5400,5625,5760,5832,6000,6075,6144,6250,6400,6480,6561,6750,6912,7200,7290,7500,7680,7776,8000,8100,8192,8640,8748,9000,9216,9375,9600,9720,10000,10125,10240,10368,10800,10935,11250,11520,11664,12000,12150,12288,12500,12800,12960,13122,13500,13824,14400,14580,15000,15360,15552,15625,16000,16200,16384,16875,17280,17496,18000,18225,18432,18750,19200,19440,19683,20000,20250,20480,20736,21600,21870,22500,23040,23328,24000,24300,24576,25000,25600,25920,26244,27000,27648,28125,28800,29160,30000,30375,30720,31104,31250,32000,32400,32768,32805,33750,34560,34992,36000,36450,36864,37500,38400,38880,39366,40000,40500,40960,41472,43200,43740,45000,46080,46656,46875,48000,48600,49152,50000,50625,51200,51840,52488,54000,54675,55296,56250,57600,58320,59049,60000,60750,61440,62208,62500,64000,64800,65536,65610,67500,69120,69984,72000,72900,73728,75000,76800,77760,78125,78732,80000,81000,81920,82944,84375,86400,87480,90000,91125,92160,93312,93750,96000,97200,98304,98415,100000,101250,102400,103680,104976,108000,109350,110592,112500,115200,116640,118098,120000,121500,122880,124416,125000,128000,129600,131072,131220,135000,138240,139968,140625,144000,145800,147456,150000,151875,153600,155520,156250,157464,160000,162000,163840,164025,165888,168750,172800,174960,177147,180000,182250,184320,186624,187500,192000,194400,196608,196830,200000,202500,204800,207360,209952,216000,218700,221184,225000,230400,233280,234375,236196,240000,243000,245760,248832,250000,253125,256000,259200,262144,262440,270000,273375,276480,279936,281250,288000,291600,294912,295245,300000,303750,307200,311040,312500,314928,320000,324000,327680,328050,331776,337500,345600,349920,354294,360000,364500,368640,373248,375000,384000,388800,390625,393216,393660,400000,405000,409600,414720,419904,421875,432000,437400,442368,450000,455625,460800,466560,468750,472392,480000,486000,491520,492075,497664,500000,506250,512000,518400,524288,524880,531441,540000,546750,552960,559872,562500,576000,583200,589824,590490,600000,607500,614400,622080,625000,629856,640000,648000,655360,656100,663552,675000,691200,699840,703125,708588,720000,729000,737280,746496,750000,759375,768000,777600,781250,786432,787320,800000,810000,819200,820125,829440,839808,843750,864000,874800,884736,885735,900000,911250,921600,933120,937500,944784,\\n\\n960000,972000,983040,984150,995328,1000000,1012500,1024000,1036800,1048576,1049760,1062882,1080000,1093500,1105920,1119744,1125000,1152000,1166400,1171875,1179648,1180980,1200000,1215000,1228800,1244160,1250000,1259712,1265625,1280000,1296000,1310720,1312200,1327104,1350000,1366875,1382400,1399680,1406250,1417176,1440000,1458000,1474560,1476225,1492992,1500000,1518750,1536000,1555200,1562500,1572864,1574640,1594323,1600000,1620000,1638400,1640250,1658880,1679616,1687500,1728000,1749600,1769472,1771470,1800000,1822500,1843200,1866240,1875000,1889568,1920000,1944000,1953125,1966080,1968300,1990656,2000000,2025000,2048000,2073600,2097152,2099520,2109375,2125764,2160000,2187000,2211840,2239488,2250000,2278125,2304000,2332800,2343750,2359296,2361960,2400000,2430000,2457600,2460375,2488320,2500000,2519424,2531250,2560000,2592000,2621440,2624400,2654208,2657205,2700000,2733750,2764800,2799360,2812500,2834352,2880000,2916000,2949120,2952450,2985984,3000000,3037500,3072000,3110400,3125000,3145728,3149280,3188646,3200000,3240000,3276800,3280500,3317760,3359232,3375000,3456000,3499200,3515625,3538944,3542940,3600000,3645000,3686400,3732480,3750000,3779136,3796875,3840000,3888000,3906250,3932160,3936600,3981312,4000000,4050000,4096000,4100625,4147200,4194304,4199040,4218750,4251528,4320000,4374000,4423680,4428675,4478976,4500000,4556250,4608000,4665600,4687500,4718592,4723920,4782969,4800000,4860000,4915200,4920750,4976640,5000000,5038848,5062500,5120000,5184000,5242880,5248800,5308416,5314410,5400000,5467500,5529600,5598720,5625000,5668704,5760000,5832000,5859375,5898240,5904900,5971968,6000000,6075000,6144000,6220800,6250000,6291456,6298560,6328125,6377292,6400000,6480000,6553600,6561000,6635520,6718464,6750000,6834375,6912000,6998400,7031250,7077888,7085880,7200000,7290000,7372800,7381125,7464960,7500000,7558272,7593750,7680000,7776000,7812500,7864320,7873200,7962624,7971615,8000000,8100000,8192000,8201250,8294400,8388608,8398080,8437500,8503056,8640000,8748000,8847360,8857350,8957952,9000000,9112500,9216000,9331200,9375000,9437184,9447840,9565938,9600000,9720000,9765625,9830400,9841500,9953280,10000000,10077696,10125000,10240000,10368000,10485760,10497600,10546875,10616832,10628820,10800000,10935000,11059200,11197440,11250000,11337408,11390625,11520000,11664000,11718750,11796480,11809800,11943936,12000000,12150000,12288000,12301875,12441600,12500000,12582912,12597120,12656250,12754584,12800000,12960000,13107200,13122000,13271040,13286025,13436928,13500000,13668750,13824000,13996800,14062500,14155776,14171760,14348907,14400000,14580000,14745600,14762250,14929920,15000000,15116544,15187500,15360000,15552000,15625000,15728640,15746400,15925248,15943230,16000000,16200000,16384000,16402500,16588800,16777216,16796160,16875000,17006112,17280000,17496000,17578125,17694720,17714700,17915904,18000000,18225000,18432000,18662400,18750000,18874368,18895680,18984375,19131876,19200000,19440000,19531250,19660800,19683000,19906560,20000000,20155392,20250000,20480000,20503125,20736000,20971520,20995200,21093750,21233664,21257640,21600000,21870000,22118400,22143375,22394880,22500000,22674816,22781250,23040000,23328000,23437500,23592960,23619600,23887872,23914845,24000000,24300000,24576000,24603750,24883200,25000000,25165824,25194240,25312500,25509168,25600000,25920000,26214400,26244000,26542080,26572050,26873856,27000000,27337500,27648000,27993600,28125000,28311552,28343520,28697814,28800000,29160000,29296875,29491200,29524500,29859840,30000000,30233088,30375000,30720000,31104000,31250000,31457280,31492800,31640625,31850496,31886460,32000000,32400000,32768000,32805000,33177600,33554432,33592320,33750000,34012224,34171875,34560000,34992000,35156250,35389440,35429400,35831808,36000000,36450000,36864000,36905625,37324800,37500000,37748736,37791360,37968750,38263752,38400000,38880000,39062500,39321600,39366000,39813120,39858075,40000000,40310784,40500000,40960000,41006250,41472000,41943040,41990400,42187500,42467328,42515280,43046721,43200000,43740000,44236800,44286750,44789760,45000000,45349632,45562500,46080000,46656000,46875000,47185920,47239200,47775744,47829690,48000000,48600000,48828125,49152000,49207500,49766400,50000000,50331648,50388480,50625000,51018336,51200000,51840000,\\n\\n52428800,52488000,52734375,53084160,53144100,53747712,54000000,54675000,55296000,55987200,56250000,56623104,56687040,56953125,57395628,57600000,58320000,58593750,58982400,59049000,59719680,60000000,60466176,60750000,61440000,61509375,62208000,62500000,62914560,62985600,63281250,63700992,63772920,64000000,64800000,65536000,65610000,66355200,66430125,67108864,67184640,67500000,68024448,68343750,69120000,69984000,70312500,70778880,70858800,71663616,71744535,72000000,72900000,73728000,73811250,74649600,75000000,75497472,75582720,75937500,76527504,76800000,77760000,78125000,78643200,78732000,79626240,79716150,80000000,80621568,81000000,81920000,82012500,82944000,83886080,83980800,84375000,84934656,85030560,86093442,86400000,87480000,87890625,88473600,88573500,89579520,90000000,90699264,91125000,92160000,93312000,93750000,94371840,94478400,94921875,95551488,95659380,96000000,97200000,97656250,98304000,98415000,99532800,100000000,100663296,100776960,101250000,102036672,102400000,102515625,103680000,104857600,104976000,105468750,106168320,106288200,107495424,108000000,109350000,110592000,110716875,111974400,112500000,113246208,113374080,113906250,114791256,115200000,116640000,117187500,117964800,118098000,119439360,119574225,120000000,120932352,121500000,122880000,123018750,124416000,125000000,125829120,125971200,126562500,127401984,127545840,128000000,129140163,129600000,131072000,131220000,132710400,132860250,134217728,134369280,135000000,136048896,136687500,138240000,139968000,140625000,141557760,141717600,143327232,143489070,144000000,145800000,146484375,147456000,147622500,149299200,150000000,150994944,151165440,151875000,153055008,153600000,155520000,156250000,157286400,157464000,158203125,159252480,159432300,160000000,161243136,162000000,163840000,164025000,165888000,167772160,167961600,168750000,169869312,170061120,170859375,172186884,172800000,174960000,175781250,\\n\\n\\n176947200,177147000,179159040,180000000,181398528,182250000,184320000,184528125,186624000,187500000,188743680,188956800,189843750,191102976,191318760,192000000,194400000,195312500,196608000,196830000,199065600,199290375,200000000,201326592,201553920,202500000,204073344,204800000,205031250,207360000,209715200,209952000,210937500,212336640,212576400,214990848,215233605,216000000,218700000,221184000,221433750,223948800,225000000,226492416,226748160,227812500,229582512,230400000,233280000,234375000,235929600,236196000,238878720,239148450,240000000,241864704,243000000,244140625,245760000,246037500,248832000,250000000,251658240,251942400,253125000,254803968,255091680,256000000,258280326,259200000,262144000,262440000,263671875,265420800,265720500,268435456,268738560,270000000,272097792,273375000,276480000,279936000,281250000,283115520,283435200,284765625,286654464,286978140,288000000,291600000,292968750,294912000,295245000,298598400,300000000,301989888,302330880,303750000,306110016,307200000,307546875,311040000,312500000,314572800,314928000,316406250,318504960,318864600,320000000,322486272,324000000,327680000,328050000,331776000,332150625,335544320,335923200,337500000,339738624,340122240,341718750,344373768,345600000,349920000,351562500,353894400,354294000,358318080,358722675,360000000,362797056,364500000,368640000,369056250,373248000,375000000,377487360,377913600,379687500,382205952,382637520,384000000,387420489,388800000,390625000,393216000,393660000,398131200,398580750,400000000,402653184,403107840,405000000,408146688,409600000,410062500,414720000,419430400,419904000,421875000,424673280,425152800,429981696,430467210,432000000,437400000,439453125,442368000,442867500,447897600,450000000,452984832,453496320,455625000,459165024,460800000,466560000,468750000,471859200,472392000,474609375,477757440,478296900,480000000,483729408,486000000,488281250,491520000,492075000,497664000,500000000,503316480,503884800,506250000,509607936,510183360,512000000,512578125,516560652,518400000,\\n\\n524288000,524880000,527343750,530841600,531441000,536870912,537477120,540000000,544195584,546750000,552960000,553584375,559872000,562500000,566231040,566870400,569531250,573308928,573956280,576000000,583200000,585937500,589824000,590490000,597196800,597871125,600000000,603979776,604661760,607500000,612220032,614400000,615093750,622080000,625000000,629145600,629856000,632812500,637009920,637729200,640000000,644972544,645700815,648000000,655360000,656100000,663552000,664301250,671088640,671846400,675000000,679477248,680244480,683437500,688747536,691200000,699840000,703125000,707788800,708588000,716636160,717445350,720000000,725594112,729000000,732421875,737280000,738112500,746496000,750000000,754974720,755827200,759375000,764411904,765275040,768000000,774840978,777600000,781250000,786432000,787320000,791015625,796262400,797161500,800000000,805306368,806215680,810000000,816293376,819200000,820125000,829440000,838860800,839808000,843750000,849346560,850305600,854296875,859963392,860934420,864000000,874800000,878906250,884736000,885735000,895795200,900000000,905969664,906992640,911250000,918330048,921600000,922640625,933120000,937500000,943718400,944784000,949218750,955514880,956593800,960000000,967458816,972000000,976562500,983040000,984150000,995328000,996451875,1000000000,1006632960,1007769600,1012500000,1019215872,1020366720,1024000000,1025156250,1033121304,1036800000,1048576000,1049760000,1054687500,1061683200,1062882000,1073741824,1074954240,1076168025,1080000000,1088391168,1093500000,1105920000,1107168750,1119744000,1125000000,1132462080,1133740800,1139062500,1146617856,1147912560,1152000000,1162261467,1166400000,1171875000,1179648000,1180980000,1194393600,1195742250,1200000000,1207959552,1209323520,1215000000,1220703125,1224440064,1228800000,1230187500,1244160000,1250000000,1258291200,1259712000,1265625000,1274019840,1275458400,1280000000,1289945088,1291401630,1296000000,1310720000,1312200000,1318359375,1327104000,1328602500,1342177280,1343692800,1350000000,1358954496,1360488960,1366875000,1377495072,1382400000,1399680000,1406250000,1415577600,1417176000,1423828125,1433272320,1434890700,1440000000,1451188224,1458000000,1464843750,1474560000,1476225000,1492992000,1500000000,1509949440,1511654400,1518750000,1528823808,1530550080,1536000000,1537734375,1549681956,1555200000,1562500000,1572864000,1574640000,1582031250,1592524800,1594323000,1600000000,1610612736,1612431360,1620000000,1632586752,1638400000,1640250000,1658880000,1660753125,1677721600,1679616000,1687500000,1698693120,1700611200,1708593750,1719926784,1721868840,1728000000,1749600000,1757812500,1769472000,1771470000,1791590400,1793613375,1800000000,1811939328,1813985280,1822500000,1836660096,1843200000,1845281250,1866240000,1875000000,1887436800,1889568000,1898437500,1911029760,1913187600,1920000000,1934917632,1937102445,1944000000,1953125000,1966080000,1968300000,1990656000,1992903750,2000000000,2013265920,2015539200,2025000000,2038431744,2040733440,2048000000,2050312500,2066242608,2073600000,2097152000,2099520000,2109375000,2123366400,2125764000,2147483648,2149908480,2152336050,2160000000,2176782336,2187000000,2197265625,2211840000,2214337500,2239488000\\n\\n\\n};\\n\\n    int nthUglyNumber(int n) {\\n        return ar[n-1]; \\n    }\\n};`"
                    },
                    {
                        "username": "AasheeshLikePanner",
                        "content": "Bro stop this \\uD83D\\uDE2D\\uD83D\\uDE2D\\uD83D\\uDE2D"
                    },
                    {
                        "username": "Mayank_Shahria",
                        "content": "**I have solved this by two methods \\n1. Brute force**\\nBut it is giving a run time error\\n![image](https://assets.leetcode.com/users/images/ba539fa1-405b-4d9d-832a-5be83172edc4_1620554425.1931248.png)\\n**2. Dynamic Programing**\\n![image](https://assets.leetcode.com/users/images/3a90f09e-1a3c-465f-a8d6-b58bfc613ccf_1620554465.9711976.png)\\n\\n\\n"
                    },
                    {
                        "username": "aman_online67",
                        "content": "I also applied brute force but it gives TLE at some 500 test case. But logic wise it is correct what to do now"
                    },
                    {
                        "username": "Rohith6776",
                        "content": "If the prime factors are limited to 2,3,5 and we should not consider numbers like(14->2*7, 21->3*7) right?"
                    },
                    {
                        "username": "wtfcoder",
                        "content": "yup"
                    },
                    {
                        "username": "c_jain",
                        "content": "After reading top solutions here, I realized optimized solution is not a DP solution because I am not able to figure out optimal substructure and overlapping subproblem. I think it is kind of 3 pointer solution. Anyone like to clarify this?"
                    },
                    {
                        "username": "vikasboss6855",
                        "content": "https://leetcode.com/problems/ugly-number-ii/solutions/3704058/c-memoized-solution-using-dp-forcible-dp/"
                    },
                    {
                        "username": "Gismet",
                        "content": "Yeah, you are right. I don't also think there is an optimal substructure and overlapping subproblem. I think the reason why they called this DP solution is that we use the previously computed ugly numbers to find the next one. If you checked out the hint, they say you can get the next ugly number from a smaller ugly number by multiplying it by either 2, 3 or 5. So we start from the bottom and work our way up to the nth ugly number, in each iteration finding the next ugly number using a previous one. But to see the overlapping subproblems, one would write a recursive solution, also called top-down, and see if there are any subproblems that overlaps. But I couldn't come up with recursive top-down solution. Or maybe there is an optimal substructure that I fail to see. "
                    },
                    {
                        "username": "logical_thinker",
                        "content": "can someone throw light on the last test case which is n being empty the 596th test case. what is that and how do I go about it."
                    },
                    {
                        "username": "urmichm",
                        "content": "why is 1 ugly number?"
                    },
                    {
                        "username": "at218808",
                        "content": "1 is a factor of every number , so its more like a ugly number has only factors as 1,2,3 or 5"
                    },
                    {
                        "username": "QuasiRus",
                        "content": "It does not have any prime factor outside [2, 3, 5] list. 1 itself is not a prime number."
                    }
                ]
            },
            {
                "id": 1688235,
                "content": [
                    {
                        "username": "lcn",
                        "content": " 1. Actually, the input space is much smaller than expected if we insist an `int` range output. \\nWhen input `n` is greater than `1691`, the output overflows the `int` range.\\n 2. Another way to view this bound is that all ugly numbers must be in the form `2^a*3^b*5^c`. Since we have `log2(Integer.MAX_VALUE)=a<31`, `log3(Integer.MAX_VALUE)=b<20` and `log5(Integer.MAX_VALUE)=c<14`, the combination allowed is surely under `31*20*14~=8400`.\\n\\nSo ugly number is sparser than one would usually think, and please do take care of overflow."
                    },
                    {
                        "username": "chauhanprerna21",
                        "content": "I am not able to understand how is ugly numbers a DP problem?\\nWould be great if someone could help with it."
                    },
                    {
                        "username": "vikasboss6855",
                        "content": "https://leetcode.com/problems/ugly-number-ii/solutions/3704058/c-memoized-solution-using-dp-forcible-dp/\n```\nclass Solution {\npublic:\n    int nthUglyNumber(int n) {\n        vector<int> dp(n);\n        dp[0] = 1;\n        return nthUglyNumberRecursive(dp, n, 1, 0, 0, 0);\n    }\n\nprivate:\n    int nthUglyNumberRecursive(vector<int>& dp, int n, int i, int p1, int p2, int p3) {\n        if (i == n) {\n            return dp[n - 1];\n        }\n\n        int twoMultiple = dp[p1] * 2;\n        int threeMultiple = dp[p2] * 3;\n        int fiveMultiple = dp[p3] * 5;\n\n        dp[i] = min(twoMultiple, min(threeMultiple, fiveMultiple));\n\n        int nextP1 = (dp[i] == twoMultiple) ? p1 + 1 : p1;\n        int nextP2 = (dp[i] == threeMultiple) ? p2 + 1 : p2;\n        int nextP3 = (dp[i] == fiveMultiple) ? p3 + 1 : p3;\n\n        return nthUglyNumberRecursive(dp, n, i + 1, nextP1, nextP2, nextP3);\n    }\n};\n\n```"
                    },
                    {
                        "username": "divyanshuparg",
                        "content": "I have solved it using recursion and hashing."
                    },
                    {
                        "username": "anshulguleria",
                        "content": "In the example in problem statement 1 was being counted as ugly number. I am not able to understand how we concluded that.\\n\\nif 1 = 1 * 2^0 then this theory will be true for other numbers as well like 7  * 2^0."
                    },
                    {
                        "username": "Seabayley",
                        "content": "![image](https://assets.leetcode.com/users/images/fad90901-6c35-455e-8ff0-8160380ca46c_1597993223.2791212.png)\\n\\nAm I misunderstanding the problem? The 11th ugly numbers looks to me as though it should be 14?"
                    },
                    {
                        "username": "codekorekhai",
                        "content": "[@satyamkumarskr](/satyamkumarskr) 14 is not an ugly number because it has 7 as factor but the problem said that only 2, 3, 5 will be the prime factor for each ugly number."
                    },
                    {
                        "username": "satyamkumarskr",
                        "content": "True . I got the same issue."
                    },
                    {
                        "username": "user6746E",
                        "content": "The 11th ugly number will not be 14 since the prime factor of 14 includes 7, but the question clearly states that the primes factor should be limited to 2, 3 or 5. Therefore 11th ugly number will be 15."
                    },
                    {
                        "username": "sazib204061",
                        "content": "I solve this problem in O(1) time complexity.\\n `class Solution {\\npublic:\\nvector<long long>ar = {1,2,3,4,5,6,8,9,10,12,15,16,18,20,24,25,27,30,32,36,40,45,48,50,54,60,64,72,75,80,81,90,96,100,108,120,125,128,135,144,150,160,162,180,192,200,216,225,240,243,250,256,270,288,300,320,324,360,375,384,400,405,432,450,480,486,500,512,540,576,600,625,640,648,675,720,729,750,768,800,810,864,900,960,972,1000,1024,1080,1125,1152,1200,1215,1250,1280,1296,1350,1440,1458,1500,1536,1600,1620,1728,1800,1875,1920,1944,2000,2025,2048,2160,2187,2250,2304,2400,2430,2500,2560,2592,2700,2880,2916,3000,3072,3125,3200,3240,3375,3456,3600,3645,3750,3840,3888,4000,4050,4096,4320,4374,4500,4608,4800,4860,5000,5120,5184,5400,5625,5760,5832,6000,6075,6144,6250,6400,6480,6561,6750,6912,7200,7290,7500,7680,7776,8000,8100,8192,8640,8748,9000,9216,9375,9600,9720,10000,10125,10240,10368,10800,10935,11250,11520,11664,12000,12150,12288,12500,12800,12960,13122,13500,13824,14400,14580,15000,15360,15552,15625,16000,16200,16384,16875,17280,17496,18000,18225,18432,18750,19200,19440,19683,20000,20250,20480,20736,21600,21870,22500,23040,23328,24000,24300,24576,25000,25600,25920,26244,27000,27648,28125,28800,29160,30000,30375,30720,31104,31250,32000,32400,32768,32805,33750,34560,34992,36000,36450,36864,37500,38400,38880,39366,40000,40500,40960,41472,43200,43740,45000,46080,46656,46875,48000,48600,49152,50000,50625,51200,51840,52488,54000,54675,55296,56250,57600,58320,59049,60000,60750,61440,62208,62500,64000,64800,65536,65610,67500,69120,69984,72000,72900,73728,75000,76800,77760,78125,78732,80000,81000,81920,82944,84375,86400,87480,90000,91125,92160,93312,93750,96000,97200,98304,98415,100000,101250,102400,103680,104976,108000,109350,110592,112500,115200,116640,118098,120000,121500,122880,124416,125000,128000,129600,131072,131220,135000,138240,139968,140625,144000,145800,147456,150000,151875,153600,155520,156250,157464,160000,162000,163840,164025,165888,168750,172800,174960,177147,180000,182250,184320,186624,187500,192000,194400,196608,196830,200000,202500,204800,207360,209952,216000,218700,221184,225000,230400,233280,234375,236196,240000,243000,245760,248832,250000,253125,256000,259200,262144,262440,270000,273375,276480,279936,281250,288000,291600,294912,295245,300000,303750,307200,311040,312500,314928,320000,324000,327680,328050,331776,337500,345600,349920,354294,360000,364500,368640,373248,375000,384000,388800,390625,393216,393660,400000,405000,409600,414720,419904,421875,432000,437400,442368,450000,455625,460800,466560,468750,472392,480000,486000,491520,492075,497664,500000,506250,512000,518400,524288,524880,531441,540000,546750,552960,559872,562500,576000,583200,589824,590490,600000,607500,614400,622080,625000,629856,640000,648000,655360,656100,663552,675000,691200,699840,703125,708588,720000,729000,737280,746496,750000,759375,768000,777600,781250,786432,787320,800000,810000,819200,820125,829440,839808,843750,864000,874800,884736,885735,900000,911250,921600,933120,937500,944784,\\n\\n960000,972000,983040,984150,995328,1000000,1012500,1024000,1036800,1048576,1049760,1062882,1080000,1093500,1105920,1119744,1125000,1152000,1166400,1171875,1179648,1180980,1200000,1215000,1228800,1244160,1250000,1259712,1265625,1280000,1296000,1310720,1312200,1327104,1350000,1366875,1382400,1399680,1406250,1417176,1440000,1458000,1474560,1476225,1492992,1500000,1518750,1536000,1555200,1562500,1572864,1574640,1594323,1600000,1620000,1638400,1640250,1658880,1679616,1687500,1728000,1749600,1769472,1771470,1800000,1822500,1843200,1866240,1875000,1889568,1920000,1944000,1953125,1966080,1968300,1990656,2000000,2025000,2048000,2073600,2097152,2099520,2109375,2125764,2160000,2187000,2211840,2239488,2250000,2278125,2304000,2332800,2343750,2359296,2361960,2400000,2430000,2457600,2460375,2488320,2500000,2519424,2531250,2560000,2592000,2621440,2624400,2654208,2657205,2700000,2733750,2764800,2799360,2812500,2834352,2880000,2916000,2949120,2952450,2985984,3000000,3037500,3072000,3110400,3125000,3145728,3149280,3188646,3200000,3240000,3276800,3280500,3317760,3359232,3375000,3456000,3499200,3515625,3538944,3542940,3600000,3645000,3686400,3732480,3750000,3779136,3796875,3840000,3888000,3906250,3932160,3936600,3981312,4000000,4050000,4096000,4100625,4147200,4194304,4199040,4218750,4251528,4320000,4374000,4423680,4428675,4478976,4500000,4556250,4608000,4665600,4687500,4718592,4723920,4782969,4800000,4860000,4915200,4920750,4976640,5000000,5038848,5062500,5120000,5184000,5242880,5248800,5308416,5314410,5400000,5467500,5529600,5598720,5625000,5668704,5760000,5832000,5859375,5898240,5904900,5971968,6000000,6075000,6144000,6220800,6250000,6291456,6298560,6328125,6377292,6400000,6480000,6553600,6561000,6635520,6718464,6750000,6834375,6912000,6998400,7031250,7077888,7085880,7200000,7290000,7372800,7381125,7464960,7500000,7558272,7593750,7680000,7776000,7812500,7864320,7873200,7962624,7971615,8000000,8100000,8192000,8201250,8294400,8388608,8398080,8437500,8503056,8640000,8748000,8847360,8857350,8957952,9000000,9112500,9216000,9331200,9375000,9437184,9447840,9565938,9600000,9720000,9765625,9830400,9841500,9953280,10000000,10077696,10125000,10240000,10368000,10485760,10497600,10546875,10616832,10628820,10800000,10935000,11059200,11197440,11250000,11337408,11390625,11520000,11664000,11718750,11796480,11809800,11943936,12000000,12150000,12288000,12301875,12441600,12500000,12582912,12597120,12656250,12754584,12800000,12960000,13107200,13122000,13271040,13286025,13436928,13500000,13668750,13824000,13996800,14062500,14155776,14171760,14348907,14400000,14580000,14745600,14762250,14929920,15000000,15116544,15187500,15360000,15552000,15625000,15728640,15746400,15925248,15943230,16000000,16200000,16384000,16402500,16588800,16777216,16796160,16875000,17006112,17280000,17496000,17578125,17694720,17714700,17915904,18000000,18225000,18432000,18662400,18750000,18874368,18895680,18984375,19131876,19200000,19440000,19531250,19660800,19683000,19906560,20000000,20155392,20250000,20480000,20503125,20736000,20971520,20995200,21093750,21233664,21257640,21600000,21870000,22118400,22143375,22394880,22500000,22674816,22781250,23040000,23328000,23437500,23592960,23619600,23887872,23914845,24000000,24300000,24576000,24603750,24883200,25000000,25165824,25194240,25312500,25509168,25600000,25920000,26214400,26244000,26542080,26572050,26873856,27000000,27337500,27648000,27993600,28125000,28311552,28343520,28697814,28800000,29160000,29296875,29491200,29524500,29859840,30000000,30233088,30375000,30720000,31104000,31250000,31457280,31492800,31640625,31850496,31886460,32000000,32400000,32768000,32805000,33177600,33554432,33592320,33750000,34012224,34171875,34560000,34992000,35156250,35389440,35429400,35831808,36000000,36450000,36864000,36905625,37324800,37500000,37748736,37791360,37968750,38263752,38400000,38880000,39062500,39321600,39366000,39813120,39858075,40000000,40310784,40500000,40960000,41006250,41472000,41943040,41990400,42187500,42467328,42515280,43046721,43200000,43740000,44236800,44286750,44789760,45000000,45349632,45562500,46080000,46656000,46875000,47185920,47239200,47775744,47829690,48000000,48600000,48828125,49152000,49207500,49766400,50000000,50331648,50388480,50625000,51018336,51200000,51840000,\\n\\n52428800,52488000,52734375,53084160,53144100,53747712,54000000,54675000,55296000,55987200,56250000,56623104,56687040,56953125,57395628,57600000,58320000,58593750,58982400,59049000,59719680,60000000,60466176,60750000,61440000,61509375,62208000,62500000,62914560,62985600,63281250,63700992,63772920,64000000,64800000,65536000,65610000,66355200,66430125,67108864,67184640,67500000,68024448,68343750,69120000,69984000,70312500,70778880,70858800,71663616,71744535,72000000,72900000,73728000,73811250,74649600,75000000,75497472,75582720,75937500,76527504,76800000,77760000,78125000,78643200,78732000,79626240,79716150,80000000,80621568,81000000,81920000,82012500,82944000,83886080,83980800,84375000,84934656,85030560,86093442,86400000,87480000,87890625,88473600,88573500,89579520,90000000,90699264,91125000,92160000,93312000,93750000,94371840,94478400,94921875,95551488,95659380,96000000,97200000,97656250,98304000,98415000,99532800,100000000,100663296,100776960,101250000,102036672,102400000,102515625,103680000,104857600,104976000,105468750,106168320,106288200,107495424,108000000,109350000,110592000,110716875,111974400,112500000,113246208,113374080,113906250,114791256,115200000,116640000,117187500,117964800,118098000,119439360,119574225,120000000,120932352,121500000,122880000,123018750,124416000,125000000,125829120,125971200,126562500,127401984,127545840,128000000,129140163,129600000,131072000,131220000,132710400,132860250,134217728,134369280,135000000,136048896,136687500,138240000,139968000,140625000,141557760,141717600,143327232,143489070,144000000,145800000,146484375,147456000,147622500,149299200,150000000,150994944,151165440,151875000,153055008,153600000,155520000,156250000,157286400,157464000,158203125,159252480,159432300,160000000,161243136,162000000,163840000,164025000,165888000,167772160,167961600,168750000,169869312,170061120,170859375,172186884,172800000,174960000,175781250,\\n\\n\\n176947200,177147000,179159040,180000000,181398528,182250000,184320000,184528125,186624000,187500000,188743680,188956800,189843750,191102976,191318760,192000000,194400000,195312500,196608000,196830000,199065600,199290375,200000000,201326592,201553920,202500000,204073344,204800000,205031250,207360000,209715200,209952000,210937500,212336640,212576400,214990848,215233605,216000000,218700000,221184000,221433750,223948800,225000000,226492416,226748160,227812500,229582512,230400000,233280000,234375000,235929600,236196000,238878720,239148450,240000000,241864704,243000000,244140625,245760000,246037500,248832000,250000000,251658240,251942400,253125000,254803968,255091680,256000000,258280326,259200000,262144000,262440000,263671875,265420800,265720500,268435456,268738560,270000000,272097792,273375000,276480000,279936000,281250000,283115520,283435200,284765625,286654464,286978140,288000000,291600000,292968750,294912000,295245000,298598400,300000000,301989888,302330880,303750000,306110016,307200000,307546875,311040000,312500000,314572800,314928000,316406250,318504960,318864600,320000000,322486272,324000000,327680000,328050000,331776000,332150625,335544320,335923200,337500000,339738624,340122240,341718750,344373768,345600000,349920000,351562500,353894400,354294000,358318080,358722675,360000000,362797056,364500000,368640000,369056250,373248000,375000000,377487360,377913600,379687500,382205952,382637520,384000000,387420489,388800000,390625000,393216000,393660000,398131200,398580750,400000000,402653184,403107840,405000000,408146688,409600000,410062500,414720000,419430400,419904000,421875000,424673280,425152800,429981696,430467210,432000000,437400000,439453125,442368000,442867500,447897600,450000000,452984832,453496320,455625000,459165024,460800000,466560000,468750000,471859200,472392000,474609375,477757440,478296900,480000000,483729408,486000000,488281250,491520000,492075000,497664000,500000000,503316480,503884800,506250000,509607936,510183360,512000000,512578125,516560652,518400000,\\n\\n524288000,524880000,527343750,530841600,531441000,536870912,537477120,540000000,544195584,546750000,552960000,553584375,559872000,562500000,566231040,566870400,569531250,573308928,573956280,576000000,583200000,585937500,589824000,590490000,597196800,597871125,600000000,603979776,604661760,607500000,612220032,614400000,615093750,622080000,625000000,629145600,629856000,632812500,637009920,637729200,640000000,644972544,645700815,648000000,655360000,656100000,663552000,664301250,671088640,671846400,675000000,679477248,680244480,683437500,688747536,691200000,699840000,703125000,707788800,708588000,716636160,717445350,720000000,725594112,729000000,732421875,737280000,738112500,746496000,750000000,754974720,755827200,759375000,764411904,765275040,768000000,774840978,777600000,781250000,786432000,787320000,791015625,796262400,797161500,800000000,805306368,806215680,810000000,816293376,819200000,820125000,829440000,838860800,839808000,843750000,849346560,850305600,854296875,859963392,860934420,864000000,874800000,878906250,884736000,885735000,895795200,900000000,905969664,906992640,911250000,918330048,921600000,922640625,933120000,937500000,943718400,944784000,949218750,955514880,956593800,960000000,967458816,972000000,976562500,983040000,984150000,995328000,996451875,1000000000,1006632960,1007769600,1012500000,1019215872,1020366720,1024000000,1025156250,1033121304,1036800000,1048576000,1049760000,1054687500,1061683200,1062882000,1073741824,1074954240,1076168025,1080000000,1088391168,1093500000,1105920000,1107168750,1119744000,1125000000,1132462080,1133740800,1139062500,1146617856,1147912560,1152000000,1162261467,1166400000,1171875000,1179648000,1180980000,1194393600,1195742250,1200000000,1207959552,1209323520,1215000000,1220703125,1224440064,1228800000,1230187500,1244160000,1250000000,1258291200,1259712000,1265625000,1274019840,1275458400,1280000000,1289945088,1291401630,1296000000,1310720000,1312200000,1318359375,1327104000,1328602500,1342177280,1343692800,1350000000,1358954496,1360488960,1366875000,1377495072,1382400000,1399680000,1406250000,1415577600,1417176000,1423828125,1433272320,1434890700,1440000000,1451188224,1458000000,1464843750,1474560000,1476225000,1492992000,1500000000,1509949440,1511654400,1518750000,1528823808,1530550080,1536000000,1537734375,1549681956,1555200000,1562500000,1572864000,1574640000,1582031250,1592524800,1594323000,1600000000,1610612736,1612431360,1620000000,1632586752,1638400000,1640250000,1658880000,1660753125,1677721600,1679616000,1687500000,1698693120,1700611200,1708593750,1719926784,1721868840,1728000000,1749600000,1757812500,1769472000,1771470000,1791590400,1793613375,1800000000,1811939328,1813985280,1822500000,1836660096,1843200000,1845281250,1866240000,1875000000,1887436800,1889568000,1898437500,1911029760,1913187600,1920000000,1934917632,1937102445,1944000000,1953125000,1966080000,1968300000,1990656000,1992903750,2000000000,2013265920,2015539200,2025000000,2038431744,2040733440,2048000000,2050312500,2066242608,2073600000,2097152000,2099520000,2109375000,2123366400,2125764000,2147483648,2149908480,2152336050,2160000000,2176782336,2187000000,2197265625,2211840000,2214337500,2239488000\\n\\n\\n};\\n\\n    int nthUglyNumber(int n) {\\n        return ar[n-1]; \\n    }\\n};`"
                    },
                    {
                        "username": "AasheeshLikePanner",
                        "content": "Bro stop this \\uD83D\\uDE2D\\uD83D\\uDE2D\\uD83D\\uDE2D"
                    },
                    {
                        "username": "Mayank_Shahria",
                        "content": "**I have solved this by two methods \\n1. Brute force**\\nBut it is giving a run time error\\n![image](https://assets.leetcode.com/users/images/ba539fa1-405b-4d9d-832a-5be83172edc4_1620554425.1931248.png)\\n**2. Dynamic Programing**\\n![image](https://assets.leetcode.com/users/images/3a90f09e-1a3c-465f-a8d6-b58bfc613ccf_1620554465.9711976.png)\\n\\n\\n"
                    },
                    {
                        "username": "aman_online67",
                        "content": "I also applied brute force but it gives TLE at some 500 test case. But logic wise it is correct what to do now"
                    },
                    {
                        "username": "Rohith6776",
                        "content": "If the prime factors are limited to 2,3,5 and we should not consider numbers like(14->2*7, 21->3*7) right?"
                    },
                    {
                        "username": "wtfcoder",
                        "content": "yup"
                    },
                    {
                        "username": "c_jain",
                        "content": "After reading top solutions here, I realized optimized solution is not a DP solution because I am not able to figure out optimal substructure and overlapping subproblem. I think it is kind of 3 pointer solution. Anyone like to clarify this?"
                    },
                    {
                        "username": "vikasboss6855",
                        "content": "https://leetcode.com/problems/ugly-number-ii/solutions/3704058/c-memoized-solution-using-dp-forcible-dp/"
                    },
                    {
                        "username": "Gismet",
                        "content": "Yeah, you are right. I don't also think there is an optimal substructure and overlapping subproblem. I think the reason why they called this DP solution is that we use the previously computed ugly numbers to find the next one. If you checked out the hint, they say you can get the next ugly number from a smaller ugly number by multiplying it by either 2, 3 or 5. So we start from the bottom and work our way up to the nth ugly number, in each iteration finding the next ugly number using a previous one. But to see the overlapping subproblems, one would write a recursive solution, also called top-down, and see if there are any subproblems that overlaps. But I couldn't come up with recursive top-down solution. Or maybe there is an optimal substructure that I fail to see. "
                    },
                    {
                        "username": "logical_thinker",
                        "content": "can someone throw light on the last test case which is n being empty the 596th test case. what is that and how do I go about it."
                    },
                    {
                        "username": "urmichm",
                        "content": "why is 1 ugly number?"
                    },
                    {
                        "username": "at218808",
                        "content": "1 is a factor of every number , so its more like a ugly number has only factors as 1,2,3 or 5"
                    },
                    {
                        "username": "QuasiRus",
                        "content": "It does not have any prime factor outside [2, 3, 5] list. 1 itself is not a prime number."
                    }
                ]
            },
            {
                "id": 1567237,
                "content": [
                    {
                        "username": "lcn",
                        "content": " 1. Actually, the input space is much smaller than expected if we insist an `int` range output. \\nWhen input `n` is greater than `1691`, the output overflows the `int` range.\\n 2. Another way to view this bound is that all ugly numbers must be in the form `2^a*3^b*5^c`. Since we have `log2(Integer.MAX_VALUE)=a<31`, `log3(Integer.MAX_VALUE)=b<20` and `log5(Integer.MAX_VALUE)=c<14`, the combination allowed is surely under `31*20*14~=8400`.\\n\\nSo ugly number is sparser than one would usually think, and please do take care of overflow."
                    },
                    {
                        "username": "chauhanprerna21",
                        "content": "I am not able to understand how is ugly numbers a DP problem?\\nWould be great if someone could help with it."
                    },
                    {
                        "username": "vikasboss6855",
                        "content": "https://leetcode.com/problems/ugly-number-ii/solutions/3704058/c-memoized-solution-using-dp-forcible-dp/\n```\nclass Solution {\npublic:\n    int nthUglyNumber(int n) {\n        vector<int> dp(n);\n        dp[0] = 1;\n        return nthUglyNumberRecursive(dp, n, 1, 0, 0, 0);\n    }\n\nprivate:\n    int nthUglyNumberRecursive(vector<int>& dp, int n, int i, int p1, int p2, int p3) {\n        if (i == n) {\n            return dp[n - 1];\n        }\n\n        int twoMultiple = dp[p1] * 2;\n        int threeMultiple = dp[p2] * 3;\n        int fiveMultiple = dp[p3] * 5;\n\n        dp[i] = min(twoMultiple, min(threeMultiple, fiveMultiple));\n\n        int nextP1 = (dp[i] == twoMultiple) ? p1 + 1 : p1;\n        int nextP2 = (dp[i] == threeMultiple) ? p2 + 1 : p2;\n        int nextP3 = (dp[i] == fiveMultiple) ? p3 + 1 : p3;\n\n        return nthUglyNumberRecursive(dp, n, i + 1, nextP1, nextP2, nextP3);\n    }\n};\n\n```"
                    },
                    {
                        "username": "divyanshuparg",
                        "content": "I have solved it using recursion and hashing."
                    },
                    {
                        "username": "anshulguleria",
                        "content": "In the example in problem statement 1 was being counted as ugly number. I am not able to understand how we concluded that.\\n\\nif 1 = 1 * 2^0 then this theory will be true for other numbers as well like 7  * 2^0."
                    },
                    {
                        "username": "Seabayley",
                        "content": "![image](https://assets.leetcode.com/users/images/fad90901-6c35-455e-8ff0-8160380ca46c_1597993223.2791212.png)\\n\\nAm I misunderstanding the problem? The 11th ugly numbers looks to me as though it should be 14?"
                    },
                    {
                        "username": "codekorekhai",
                        "content": "[@satyamkumarskr](/satyamkumarskr) 14 is not an ugly number because it has 7 as factor but the problem said that only 2, 3, 5 will be the prime factor for each ugly number."
                    },
                    {
                        "username": "satyamkumarskr",
                        "content": "True . I got the same issue."
                    },
                    {
                        "username": "user6746E",
                        "content": "The 11th ugly number will not be 14 since the prime factor of 14 includes 7, but the question clearly states that the primes factor should be limited to 2, 3 or 5. Therefore 11th ugly number will be 15."
                    },
                    {
                        "username": "sazib204061",
                        "content": "I solve this problem in O(1) time complexity.\\n `class Solution {\\npublic:\\nvector<long long>ar = {1,2,3,4,5,6,8,9,10,12,15,16,18,20,24,25,27,30,32,36,40,45,48,50,54,60,64,72,75,80,81,90,96,100,108,120,125,128,135,144,150,160,162,180,192,200,216,225,240,243,250,256,270,288,300,320,324,360,375,384,400,405,432,450,480,486,500,512,540,576,600,625,640,648,675,720,729,750,768,800,810,864,900,960,972,1000,1024,1080,1125,1152,1200,1215,1250,1280,1296,1350,1440,1458,1500,1536,1600,1620,1728,1800,1875,1920,1944,2000,2025,2048,2160,2187,2250,2304,2400,2430,2500,2560,2592,2700,2880,2916,3000,3072,3125,3200,3240,3375,3456,3600,3645,3750,3840,3888,4000,4050,4096,4320,4374,4500,4608,4800,4860,5000,5120,5184,5400,5625,5760,5832,6000,6075,6144,6250,6400,6480,6561,6750,6912,7200,7290,7500,7680,7776,8000,8100,8192,8640,8748,9000,9216,9375,9600,9720,10000,10125,10240,10368,10800,10935,11250,11520,11664,12000,12150,12288,12500,12800,12960,13122,13500,13824,14400,14580,15000,15360,15552,15625,16000,16200,16384,16875,17280,17496,18000,18225,18432,18750,19200,19440,19683,20000,20250,20480,20736,21600,21870,22500,23040,23328,24000,24300,24576,25000,25600,25920,26244,27000,27648,28125,28800,29160,30000,30375,30720,31104,31250,32000,32400,32768,32805,33750,34560,34992,36000,36450,36864,37500,38400,38880,39366,40000,40500,40960,41472,43200,43740,45000,46080,46656,46875,48000,48600,49152,50000,50625,51200,51840,52488,54000,54675,55296,56250,57600,58320,59049,60000,60750,61440,62208,62500,64000,64800,65536,65610,67500,69120,69984,72000,72900,73728,75000,76800,77760,78125,78732,80000,81000,81920,82944,84375,86400,87480,90000,91125,92160,93312,93750,96000,97200,98304,98415,100000,101250,102400,103680,104976,108000,109350,110592,112500,115200,116640,118098,120000,121500,122880,124416,125000,128000,129600,131072,131220,135000,138240,139968,140625,144000,145800,147456,150000,151875,153600,155520,156250,157464,160000,162000,163840,164025,165888,168750,172800,174960,177147,180000,182250,184320,186624,187500,192000,194400,196608,196830,200000,202500,204800,207360,209952,216000,218700,221184,225000,230400,233280,234375,236196,240000,243000,245760,248832,250000,253125,256000,259200,262144,262440,270000,273375,276480,279936,281250,288000,291600,294912,295245,300000,303750,307200,311040,312500,314928,320000,324000,327680,328050,331776,337500,345600,349920,354294,360000,364500,368640,373248,375000,384000,388800,390625,393216,393660,400000,405000,409600,414720,419904,421875,432000,437400,442368,450000,455625,460800,466560,468750,472392,480000,486000,491520,492075,497664,500000,506250,512000,518400,524288,524880,531441,540000,546750,552960,559872,562500,576000,583200,589824,590490,600000,607500,614400,622080,625000,629856,640000,648000,655360,656100,663552,675000,691200,699840,703125,708588,720000,729000,737280,746496,750000,759375,768000,777600,781250,786432,787320,800000,810000,819200,820125,829440,839808,843750,864000,874800,884736,885735,900000,911250,921600,933120,937500,944784,\\n\\n960000,972000,983040,984150,995328,1000000,1012500,1024000,1036800,1048576,1049760,1062882,1080000,1093500,1105920,1119744,1125000,1152000,1166400,1171875,1179648,1180980,1200000,1215000,1228800,1244160,1250000,1259712,1265625,1280000,1296000,1310720,1312200,1327104,1350000,1366875,1382400,1399680,1406250,1417176,1440000,1458000,1474560,1476225,1492992,1500000,1518750,1536000,1555200,1562500,1572864,1574640,1594323,1600000,1620000,1638400,1640250,1658880,1679616,1687500,1728000,1749600,1769472,1771470,1800000,1822500,1843200,1866240,1875000,1889568,1920000,1944000,1953125,1966080,1968300,1990656,2000000,2025000,2048000,2073600,2097152,2099520,2109375,2125764,2160000,2187000,2211840,2239488,2250000,2278125,2304000,2332800,2343750,2359296,2361960,2400000,2430000,2457600,2460375,2488320,2500000,2519424,2531250,2560000,2592000,2621440,2624400,2654208,2657205,2700000,2733750,2764800,2799360,2812500,2834352,2880000,2916000,2949120,2952450,2985984,3000000,3037500,3072000,3110400,3125000,3145728,3149280,3188646,3200000,3240000,3276800,3280500,3317760,3359232,3375000,3456000,3499200,3515625,3538944,3542940,3600000,3645000,3686400,3732480,3750000,3779136,3796875,3840000,3888000,3906250,3932160,3936600,3981312,4000000,4050000,4096000,4100625,4147200,4194304,4199040,4218750,4251528,4320000,4374000,4423680,4428675,4478976,4500000,4556250,4608000,4665600,4687500,4718592,4723920,4782969,4800000,4860000,4915200,4920750,4976640,5000000,5038848,5062500,5120000,5184000,5242880,5248800,5308416,5314410,5400000,5467500,5529600,5598720,5625000,5668704,5760000,5832000,5859375,5898240,5904900,5971968,6000000,6075000,6144000,6220800,6250000,6291456,6298560,6328125,6377292,6400000,6480000,6553600,6561000,6635520,6718464,6750000,6834375,6912000,6998400,7031250,7077888,7085880,7200000,7290000,7372800,7381125,7464960,7500000,7558272,7593750,7680000,7776000,7812500,7864320,7873200,7962624,7971615,8000000,8100000,8192000,8201250,8294400,8388608,8398080,8437500,8503056,8640000,8748000,8847360,8857350,8957952,9000000,9112500,9216000,9331200,9375000,9437184,9447840,9565938,9600000,9720000,9765625,9830400,9841500,9953280,10000000,10077696,10125000,10240000,10368000,10485760,10497600,10546875,10616832,10628820,10800000,10935000,11059200,11197440,11250000,11337408,11390625,11520000,11664000,11718750,11796480,11809800,11943936,12000000,12150000,12288000,12301875,12441600,12500000,12582912,12597120,12656250,12754584,12800000,12960000,13107200,13122000,13271040,13286025,13436928,13500000,13668750,13824000,13996800,14062500,14155776,14171760,14348907,14400000,14580000,14745600,14762250,14929920,15000000,15116544,15187500,15360000,15552000,15625000,15728640,15746400,15925248,15943230,16000000,16200000,16384000,16402500,16588800,16777216,16796160,16875000,17006112,17280000,17496000,17578125,17694720,17714700,17915904,18000000,18225000,18432000,18662400,18750000,18874368,18895680,18984375,19131876,19200000,19440000,19531250,19660800,19683000,19906560,20000000,20155392,20250000,20480000,20503125,20736000,20971520,20995200,21093750,21233664,21257640,21600000,21870000,22118400,22143375,22394880,22500000,22674816,22781250,23040000,23328000,23437500,23592960,23619600,23887872,23914845,24000000,24300000,24576000,24603750,24883200,25000000,25165824,25194240,25312500,25509168,25600000,25920000,26214400,26244000,26542080,26572050,26873856,27000000,27337500,27648000,27993600,28125000,28311552,28343520,28697814,28800000,29160000,29296875,29491200,29524500,29859840,30000000,30233088,30375000,30720000,31104000,31250000,31457280,31492800,31640625,31850496,31886460,32000000,32400000,32768000,32805000,33177600,33554432,33592320,33750000,34012224,34171875,34560000,34992000,35156250,35389440,35429400,35831808,36000000,36450000,36864000,36905625,37324800,37500000,37748736,37791360,37968750,38263752,38400000,38880000,39062500,39321600,39366000,39813120,39858075,40000000,40310784,40500000,40960000,41006250,41472000,41943040,41990400,42187500,42467328,42515280,43046721,43200000,43740000,44236800,44286750,44789760,45000000,45349632,45562500,46080000,46656000,46875000,47185920,47239200,47775744,47829690,48000000,48600000,48828125,49152000,49207500,49766400,50000000,50331648,50388480,50625000,51018336,51200000,51840000,\\n\\n52428800,52488000,52734375,53084160,53144100,53747712,54000000,54675000,55296000,55987200,56250000,56623104,56687040,56953125,57395628,57600000,58320000,58593750,58982400,59049000,59719680,60000000,60466176,60750000,61440000,61509375,62208000,62500000,62914560,62985600,63281250,63700992,63772920,64000000,64800000,65536000,65610000,66355200,66430125,67108864,67184640,67500000,68024448,68343750,69120000,69984000,70312500,70778880,70858800,71663616,71744535,72000000,72900000,73728000,73811250,74649600,75000000,75497472,75582720,75937500,76527504,76800000,77760000,78125000,78643200,78732000,79626240,79716150,80000000,80621568,81000000,81920000,82012500,82944000,83886080,83980800,84375000,84934656,85030560,86093442,86400000,87480000,87890625,88473600,88573500,89579520,90000000,90699264,91125000,92160000,93312000,93750000,94371840,94478400,94921875,95551488,95659380,96000000,97200000,97656250,98304000,98415000,99532800,100000000,100663296,100776960,101250000,102036672,102400000,102515625,103680000,104857600,104976000,105468750,106168320,106288200,107495424,108000000,109350000,110592000,110716875,111974400,112500000,113246208,113374080,113906250,114791256,115200000,116640000,117187500,117964800,118098000,119439360,119574225,120000000,120932352,121500000,122880000,123018750,124416000,125000000,125829120,125971200,126562500,127401984,127545840,128000000,129140163,129600000,131072000,131220000,132710400,132860250,134217728,134369280,135000000,136048896,136687500,138240000,139968000,140625000,141557760,141717600,143327232,143489070,144000000,145800000,146484375,147456000,147622500,149299200,150000000,150994944,151165440,151875000,153055008,153600000,155520000,156250000,157286400,157464000,158203125,159252480,159432300,160000000,161243136,162000000,163840000,164025000,165888000,167772160,167961600,168750000,169869312,170061120,170859375,172186884,172800000,174960000,175781250,\\n\\n\\n176947200,177147000,179159040,180000000,181398528,182250000,184320000,184528125,186624000,187500000,188743680,188956800,189843750,191102976,191318760,192000000,194400000,195312500,196608000,196830000,199065600,199290375,200000000,201326592,201553920,202500000,204073344,204800000,205031250,207360000,209715200,209952000,210937500,212336640,212576400,214990848,215233605,216000000,218700000,221184000,221433750,223948800,225000000,226492416,226748160,227812500,229582512,230400000,233280000,234375000,235929600,236196000,238878720,239148450,240000000,241864704,243000000,244140625,245760000,246037500,248832000,250000000,251658240,251942400,253125000,254803968,255091680,256000000,258280326,259200000,262144000,262440000,263671875,265420800,265720500,268435456,268738560,270000000,272097792,273375000,276480000,279936000,281250000,283115520,283435200,284765625,286654464,286978140,288000000,291600000,292968750,294912000,295245000,298598400,300000000,301989888,302330880,303750000,306110016,307200000,307546875,311040000,312500000,314572800,314928000,316406250,318504960,318864600,320000000,322486272,324000000,327680000,328050000,331776000,332150625,335544320,335923200,337500000,339738624,340122240,341718750,344373768,345600000,349920000,351562500,353894400,354294000,358318080,358722675,360000000,362797056,364500000,368640000,369056250,373248000,375000000,377487360,377913600,379687500,382205952,382637520,384000000,387420489,388800000,390625000,393216000,393660000,398131200,398580750,400000000,402653184,403107840,405000000,408146688,409600000,410062500,414720000,419430400,419904000,421875000,424673280,425152800,429981696,430467210,432000000,437400000,439453125,442368000,442867500,447897600,450000000,452984832,453496320,455625000,459165024,460800000,466560000,468750000,471859200,472392000,474609375,477757440,478296900,480000000,483729408,486000000,488281250,491520000,492075000,497664000,500000000,503316480,503884800,506250000,509607936,510183360,512000000,512578125,516560652,518400000,\\n\\n524288000,524880000,527343750,530841600,531441000,536870912,537477120,540000000,544195584,546750000,552960000,553584375,559872000,562500000,566231040,566870400,569531250,573308928,573956280,576000000,583200000,585937500,589824000,590490000,597196800,597871125,600000000,603979776,604661760,607500000,612220032,614400000,615093750,622080000,625000000,629145600,629856000,632812500,637009920,637729200,640000000,644972544,645700815,648000000,655360000,656100000,663552000,664301250,671088640,671846400,675000000,679477248,680244480,683437500,688747536,691200000,699840000,703125000,707788800,708588000,716636160,717445350,720000000,725594112,729000000,732421875,737280000,738112500,746496000,750000000,754974720,755827200,759375000,764411904,765275040,768000000,774840978,777600000,781250000,786432000,787320000,791015625,796262400,797161500,800000000,805306368,806215680,810000000,816293376,819200000,820125000,829440000,838860800,839808000,843750000,849346560,850305600,854296875,859963392,860934420,864000000,874800000,878906250,884736000,885735000,895795200,900000000,905969664,906992640,911250000,918330048,921600000,922640625,933120000,937500000,943718400,944784000,949218750,955514880,956593800,960000000,967458816,972000000,976562500,983040000,984150000,995328000,996451875,1000000000,1006632960,1007769600,1012500000,1019215872,1020366720,1024000000,1025156250,1033121304,1036800000,1048576000,1049760000,1054687500,1061683200,1062882000,1073741824,1074954240,1076168025,1080000000,1088391168,1093500000,1105920000,1107168750,1119744000,1125000000,1132462080,1133740800,1139062500,1146617856,1147912560,1152000000,1162261467,1166400000,1171875000,1179648000,1180980000,1194393600,1195742250,1200000000,1207959552,1209323520,1215000000,1220703125,1224440064,1228800000,1230187500,1244160000,1250000000,1258291200,1259712000,1265625000,1274019840,1275458400,1280000000,1289945088,1291401630,1296000000,1310720000,1312200000,1318359375,1327104000,1328602500,1342177280,1343692800,1350000000,1358954496,1360488960,1366875000,1377495072,1382400000,1399680000,1406250000,1415577600,1417176000,1423828125,1433272320,1434890700,1440000000,1451188224,1458000000,1464843750,1474560000,1476225000,1492992000,1500000000,1509949440,1511654400,1518750000,1528823808,1530550080,1536000000,1537734375,1549681956,1555200000,1562500000,1572864000,1574640000,1582031250,1592524800,1594323000,1600000000,1610612736,1612431360,1620000000,1632586752,1638400000,1640250000,1658880000,1660753125,1677721600,1679616000,1687500000,1698693120,1700611200,1708593750,1719926784,1721868840,1728000000,1749600000,1757812500,1769472000,1771470000,1791590400,1793613375,1800000000,1811939328,1813985280,1822500000,1836660096,1843200000,1845281250,1866240000,1875000000,1887436800,1889568000,1898437500,1911029760,1913187600,1920000000,1934917632,1937102445,1944000000,1953125000,1966080000,1968300000,1990656000,1992903750,2000000000,2013265920,2015539200,2025000000,2038431744,2040733440,2048000000,2050312500,2066242608,2073600000,2097152000,2099520000,2109375000,2123366400,2125764000,2147483648,2149908480,2152336050,2160000000,2176782336,2187000000,2197265625,2211840000,2214337500,2239488000\\n\\n\\n};\\n\\n    int nthUglyNumber(int n) {\\n        return ar[n-1]; \\n    }\\n};`"
                    },
                    {
                        "username": "AasheeshLikePanner",
                        "content": "Bro stop this \\uD83D\\uDE2D\\uD83D\\uDE2D\\uD83D\\uDE2D"
                    },
                    {
                        "username": "Mayank_Shahria",
                        "content": "**I have solved this by two methods \\n1. Brute force**\\nBut it is giving a run time error\\n![image](https://assets.leetcode.com/users/images/ba539fa1-405b-4d9d-832a-5be83172edc4_1620554425.1931248.png)\\n**2. Dynamic Programing**\\n![image](https://assets.leetcode.com/users/images/3a90f09e-1a3c-465f-a8d6-b58bfc613ccf_1620554465.9711976.png)\\n\\n\\n"
                    },
                    {
                        "username": "aman_online67",
                        "content": "I also applied brute force but it gives TLE at some 500 test case. But logic wise it is correct what to do now"
                    },
                    {
                        "username": "Rohith6776",
                        "content": "If the prime factors are limited to 2,3,5 and we should not consider numbers like(14->2*7, 21->3*7) right?"
                    },
                    {
                        "username": "wtfcoder",
                        "content": "yup"
                    },
                    {
                        "username": "c_jain",
                        "content": "After reading top solutions here, I realized optimized solution is not a DP solution because I am not able to figure out optimal substructure and overlapping subproblem. I think it is kind of 3 pointer solution. Anyone like to clarify this?"
                    },
                    {
                        "username": "vikasboss6855",
                        "content": "https://leetcode.com/problems/ugly-number-ii/solutions/3704058/c-memoized-solution-using-dp-forcible-dp/"
                    },
                    {
                        "username": "Gismet",
                        "content": "Yeah, you are right. I don't also think there is an optimal substructure and overlapping subproblem. I think the reason why they called this DP solution is that we use the previously computed ugly numbers to find the next one. If you checked out the hint, they say you can get the next ugly number from a smaller ugly number by multiplying it by either 2, 3 or 5. So we start from the bottom and work our way up to the nth ugly number, in each iteration finding the next ugly number using a previous one. But to see the overlapping subproblems, one would write a recursive solution, also called top-down, and see if there are any subproblems that overlaps. But I couldn't come up with recursive top-down solution. Or maybe there is an optimal substructure that I fail to see. "
                    },
                    {
                        "username": "logical_thinker",
                        "content": "can someone throw light on the last test case which is n being empty the 596th test case. what is that and how do I go about it."
                    },
                    {
                        "username": "urmichm",
                        "content": "why is 1 ugly number?"
                    },
                    {
                        "username": "at218808",
                        "content": "1 is a factor of every number , so its more like a ugly number has only factors as 1,2,3 or 5"
                    },
                    {
                        "username": "QuasiRus",
                        "content": "It does not have any prime factor outside [2, 3, 5] list. 1 itself is not a prime number."
                    }
                ]
            },
            {
                "id": 1573977,
                "content": [
                    {
                        "username": "lcn",
                        "content": " 1. Actually, the input space is much smaller than expected if we insist an `int` range output. \\nWhen input `n` is greater than `1691`, the output overflows the `int` range.\\n 2. Another way to view this bound is that all ugly numbers must be in the form `2^a*3^b*5^c`. Since we have `log2(Integer.MAX_VALUE)=a<31`, `log3(Integer.MAX_VALUE)=b<20` and `log5(Integer.MAX_VALUE)=c<14`, the combination allowed is surely under `31*20*14~=8400`.\\n\\nSo ugly number is sparser than one would usually think, and please do take care of overflow."
                    },
                    {
                        "username": "chauhanprerna21",
                        "content": "I am not able to understand how is ugly numbers a DP problem?\\nWould be great if someone could help with it."
                    },
                    {
                        "username": "vikasboss6855",
                        "content": "https://leetcode.com/problems/ugly-number-ii/solutions/3704058/c-memoized-solution-using-dp-forcible-dp/\n```\nclass Solution {\npublic:\n    int nthUglyNumber(int n) {\n        vector<int> dp(n);\n        dp[0] = 1;\n        return nthUglyNumberRecursive(dp, n, 1, 0, 0, 0);\n    }\n\nprivate:\n    int nthUglyNumberRecursive(vector<int>& dp, int n, int i, int p1, int p2, int p3) {\n        if (i == n) {\n            return dp[n - 1];\n        }\n\n        int twoMultiple = dp[p1] * 2;\n        int threeMultiple = dp[p2] * 3;\n        int fiveMultiple = dp[p3] * 5;\n\n        dp[i] = min(twoMultiple, min(threeMultiple, fiveMultiple));\n\n        int nextP1 = (dp[i] == twoMultiple) ? p1 + 1 : p1;\n        int nextP2 = (dp[i] == threeMultiple) ? p2 + 1 : p2;\n        int nextP3 = (dp[i] == fiveMultiple) ? p3 + 1 : p3;\n\n        return nthUglyNumberRecursive(dp, n, i + 1, nextP1, nextP2, nextP3);\n    }\n};\n\n```"
                    },
                    {
                        "username": "divyanshuparg",
                        "content": "I have solved it using recursion and hashing."
                    },
                    {
                        "username": "anshulguleria",
                        "content": "In the example in problem statement 1 was being counted as ugly number. I am not able to understand how we concluded that.\\n\\nif 1 = 1 * 2^0 then this theory will be true for other numbers as well like 7  * 2^0."
                    },
                    {
                        "username": "Seabayley",
                        "content": "![image](https://assets.leetcode.com/users/images/fad90901-6c35-455e-8ff0-8160380ca46c_1597993223.2791212.png)\\n\\nAm I misunderstanding the problem? The 11th ugly numbers looks to me as though it should be 14?"
                    },
                    {
                        "username": "codekorekhai",
                        "content": "[@satyamkumarskr](/satyamkumarskr) 14 is not an ugly number because it has 7 as factor but the problem said that only 2, 3, 5 will be the prime factor for each ugly number."
                    },
                    {
                        "username": "satyamkumarskr",
                        "content": "True . I got the same issue."
                    },
                    {
                        "username": "user6746E",
                        "content": "The 11th ugly number will not be 14 since the prime factor of 14 includes 7, but the question clearly states that the primes factor should be limited to 2, 3 or 5. Therefore 11th ugly number will be 15."
                    },
                    {
                        "username": "sazib204061",
                        "content": "I solve this problem in O(1) time complexity.\\n `class Solution {\\npublic:\\nvector<long long>ar = {1,2,3,4,5,6,8,9,10,12,15,16,18,20,24,25,27,30,32,36,40,45,48,50,54,60,64,72,75,80,81,90,96,100,108,120,125,128,135,144,150,160,162,180,192,200,216,225,240,243,250,256,270,288,300,320,324,360,375,384,400,405,432,450,480,486,500,512,540,576,600,625,640,648,675,720,729,750,768,800,810,864,900,960,972,1000,1024,1080,1125,1152,1200,1215,1250,1280,1296,1350,1440,1458,1500,1536,1600,1620,1728,1800,1875,1920,1944,2000,2025,2048,2160,2187,2250,2304,2400,2430,2500,2560,2592,2700,2880,2916,3000,3072,3125,3200,3240,3375,3456,3600,3645,3750,3840,3888,4000,4050,4096,4320,4374,4500,4608,4800,4860,5000,5120,5184,5400,5625,5760,5832,6000,6075,6144,6250,6400,6480,6561,6750,6912,7200,7290,7500,7680,7776,8000,8100,8192,8640,8748,9000,9216,9375,9600,9720,10000,10125,10240,10368,10800,10935,11250,11520,11664,12000,12150,12288,12500,12800,12960,13122,13500,13824,14400,14580,15000,15360,15552,15625,16000,16200,16384,16875,17280,17496,18000,18225,18432,18750,19200,19440,19683,20000,20250,20480,20736,21600,21870,22500,23040,23328,24000,24300,24576,25000,25600,25920,26244,27000,27648,28125,28800,29160,30000,30375,30720,31104,31250,32000,32400,32768,32805,33750,34560,34992,36000,36450,36864,37500,38400,38880,39366,40000,40500,40960,41472,43200,43740,45000,46080,46656,46875,48000,48600,49152,50000,50625,51200,51840,52488,54000,54675,55296,56250,57600,58320,59049,60000,60750,61440,62208,62500,64000,64800,65536,65610,67500,69120,69984,72000,72900,73728,75000,76800,77760,78125,78732,80000,81000,81920,82944,84375,86400,87480,90000,91125,92160,93312,93750,96000,97200,98304,98415,100000,101250,102400,103680,104976,108000,109350,110592,112500,115200,116640,118098,120000,121500,122880,124416,125000,128000,129600,131072,131220,135000,138240,139968,140625,144000,145800,147456,150000,151875,153600,155520,156250,157464,160000,162000,163840,164025,165888,168750,172800,174960,177147,180000,182250,184320,186624,187500,192000,194400,196608,196830,200000,202500,204800,207360,209952,216000,218700,221184,225000,230400,233280,234375,236196,240000,243000,245760,248832,250000,253125,256000,259200,262144,262440,270000,273375,276480,279936,281250,288000,291600,294912,295245,300000,303750,307200,311040,312500,314928,320000,324000,327680,328050,331776,337500,345600,349920,354294,360000,364500,368640,373248,375000,384000,388800,390625,393216,393660,400000,405000,409600,414720,419904,421875,432000,437400,442368,450000,455625,460800,466560,468750,472392,480000,486000,491520,492075,497664,500000,506250,512000,518400,524288,524880,531441,540000,546750,552960,559872,562500,576000,583200,589824,590490,600000,607500,614400,622080,625000,629856,640000,648000,655360,656100,663552,675000,691200,699840,703125,708588,720000,729000,737280,746496,750000,759375,768000,777600,781250,786432,787320,800000,810000,819200,820125,829440,839808,843750,864000,874800,884736,885735,900000,911250,921600,933120,937500,944784,\\n\\n960000,972000,983040,984150,995328,1000000,1012500,1024000,1036800,1048576,1049760,1062882,1080000,1093500,1105920,1119744,1125000,1152000,1166400,1171875,1179648,1180980,1200000,1215000,1228800,1244160,1250000,1259712,1265625,1280000,1296000,1310720,1312200,1327104,1350000,1366875,1382400,1399680,1406250,1417176,1440000,1458000,1474560,1476225,1492992,1500000,1518750,1536000,1555200,1562500,1572864,1574640,1594323,1600000,1620000,1638400,1640250,1658880,1679616,1687500,1728000,1749600,1769472,1771470,1800000,1822500,1843200,1866240,1875000,1889568,1920000,1944000,1953125,1966080,1968300,1990656,2000000,2025000,2048000,2073600,2097152,2099520,2109375,2125764,2160000,2187000,2211840,2239488,2250000,2278125,2304000,2332800,2343750,2359296,2361960,2400000,2430000,2457600,2460375,2488320,2500000,2519424,2531250,2560000,2592000,2621440,2624400,2654208,2657205,2700000,2733750,2764800,2799360,2812500,2834352,2880000,2916000,2949120,2952450,2985984,3000000,3037500,3072000,3110400,3125000,3145728,3149280,3188646,3200000,3240000,3276800,3280500,3317760,3359232,3375000,3456000,3499200,3515625,3538944,3542940,3600000,3645000,3686400,3732480,3750000,3779136,3796875,3840000,3888000,3906250,3932160,3936600,3981312,4000000,4050000,4096000,4100625,4147200,4194304,4199040,4218750,4251528,4320000,4374000,4423680,4428675,4478976,4500000,4556250,4608000,4665600,4687500,4718592,4723920,4782969,4800000,4860000,4915200,4920750,4976640,5000000,5038848,5062500,5120000,5184000,5242880,5248800,5308416,5314410,5400000,5467500,5529600,5598720,5625000,5668704,5760000,5832000,5859375,5898240,5904900,5971968,6000000,6075000,6144000,6220800,6250000,6291456,6298560,6328125,6377292,6400000,6480000,6553600,6561000,6635520,6718464,6750000,6834375,6912000,6998400,7031250,7077888,7085880,7200000,7290000,7372800,7381125,7464960,7500000,7558272,7593750,7680000,7776000,7812500,7864320,7873200,7962624,7971615,8000000,8100000,8192000,8201250,8294400,8388608,8398080,8437500,8503056,8640000,8748000,8847360,8857350,8957952,9000000,9112500,9216000,9331200,9375000,9437184,9447840,9565938,9600000,9720000,9765625,9830400,9841500,9953280,10000000,10077696,10125000,10240000,10368000,10485760,10497600,10546875,10616832,10628820,10800000,10935000,11059200,11197440,11250000,11337408,11390625,11520000,11664000,11718750,11796480,11809800,11943936,12000000,12150000,12288000,12301875,12441600,12500000,12582912,12597120,12656250,12754584,12800000,12960000,13107200,13122000,13271040,13286025,13436928,13500000,13668750,13824000,13996800,14062500,14155776,14171760,14348907,14400000,14580000,14745600,14762250,14929920,15000000,15116544,15187500,15360000,15552000,15625000,15728640,15746400,15925248,15943230,16000000,16200000,16384000,16402500,16588800,16777216,16796160,16875000,17006112,17280000,17496000,17578125,17694720,17714700,17915904,18000000,18225000,18432000,18662400,18750000,18874368,18895680,18984375,19131876,19200000,19440000,19531250,19660800,19683000,19906560,20000000,20155392,20250000,20480000,20503125,20736000,20971520,20995200,21093750,21233664,21257640,21600000,21870000,22118400,22143375,22394880,22500000,22674816,22781250,23040000,23328000,23437500,23592960,23619600,23887872,23914845,24000000,24300000,24576000,24603750,24883200,25000000,25165824,25194240,25312500,25509168,25600000,25920000,26214400,26244000,26542080,26572050,26873856,27000000,27337500,27648000,27993600,28125000,28311552,28343520,28697814,28800000,29160000,29296875,29491200,29524500,29859840,30000000,30233088,30375000,30720000,31104000,31250000,31457280,31492800,31640625,31850496,31886460,32000000,32400000,32768000,32805000,33177600,33554432,33592320,33750000,34012224,34171875,34560000,34992000,35156250,35389440,35429400,35831808,36000000,36450000,36864000,36905625,37324800,37500000,37748736,37791360,37968750,38263752,38400000,38880000,39062500,39321600,39366000,39813120,39858075,40000000,40310784,40500000,40960000,41006250,41472000,41943040,41990400,42187500,42467328,42515280,43046721,43200000,43740000,44236800,44286750,44789760,45000000,45349632,45562500,46080000,46656000,46875000,47185920,47239200,47775744,47829690,48000000,48600000,48828125,49152000,49207500,49766400,50000000,50331648,50388480,50625000,51018336,51200000,51840000,\\n\\n52428800,52488000,52734375,53084160,53144100,53747712,54000000,54675000,55296000,55987200,56250000,56623104,56687040,56953125,57395628,57600000,58320000,58593750,58982400,59049000,59719680,60000000,60466176,60750000,61440000,61509375,62208000,62500000,62914560,62985600,63281250,63700992,63772920,64000000,64800000,65536000,65610000,66355200,66430125,67108864,67184640,67500000,68024448,68343750,69120000,69984000,70312500,70778880,70858800,71663616,71744535,72000000,72900000,73728000,73811250,74649600,75000000,75497472,75582720,75937500,76527504,76800000,77760000,78125000,78643200,78732000,79626240,79716150,80000000,80621568,81000000,81920000,82012500,82944000,83886080,83980800,84375000,84934656,85030560,86093442,86400000,87480000,87890625,88473600,88573500,89579520,90000000,90699264,91125000,92160000,93312000,93750000,94371840,94478400,94921875,95551488,95659380,96000000,97200000,97656250,98304000,98415000,99532800,100000000,100663296,100776960,101250000,102036672,102400000,102515625,103680000,104857600,104976000,105468750,106168320,106288200,107495424,108000000,109350000,110592000,110716875,111974400,112500000,113246208,113374080,113906250,114791256,115200000,116640000,117187500,117964800,118098000,119439360,119574225,120000000,120932352,121500000,122880000,123018750,124416000,125000000,125829120,125971200,126562500,127401984,127545840,128000000,129140163,129600000,131072000,131220000,132710400,132860250,134217728,134369280,135000000,136048896,136687500,138240000,139968000,140625000,141557760,141717600,143327232,143489070,144000000,145800000,146484375,147456000,147622500,149299200,150000000,150994944,151165440,151875000,153055008,153600000,155520000,156250000,157286400,157464000,158203125,159252480,159432300,160000000,161243136,162000000,163840000,164025000,165888000,167772160,167961600,168750000,169869312,170061120,170859375,172186884,172800000,174960000,175781250,\\n\\n\\n176947200,177147000,179159040,180000000,181398528,182250000,184320000,184528125,186624000,187500000,188743680,188956800,189843750,191102976,191318760,192000000,194400000,195312500,196608000,196830000,199065600,199290375,200000000,201326592,201553920,202500000,204073344,204800000,205031250,207360000,209715200,209952000,210937500,212336640,212576400,214990848,215233605,216000000,218700000,221184000,221433750,223948800,225000000,226492416,226748160,227812500,229582512,230400000,233280000,234375000,235929600,236196000,238878720,239148450,240000000,241864704,243000000,244140625,245760000,246037500,248832000,250000000,251658240,251942400,253125000,254803968,255091680,256000000,258280326,259200000,262144000,262440000,263671875,265420800,265720500,268435456,268738560,270000000,272097792,273375000,276480000,279936000,281250000,283115520,283435200,284765625,286654464,286978140,288000000,291600000,292968750,294912000,295245000,298598400,300000000,301989888,302330880,303750000,306110016,307200000,307546875,311040000,312500000,314572800,314928000,316406250,318504960,318864600,320000000,322486272,324000000,327680000,328050000,331776000,332150625,335544320,335923200,337500000,339738624,340122240,341718750,344373768,345600000,349920000,351562500,353894400,354294000,358318080,358722675,360000000,362797056,364500000,368640000,369056250,373248000,375000000,377487360,377913600,379687500,382205952,382637520,384000000,387420489,388800000,390625000,393216000,393660000,398131200,398580750,400000000,402653184,403107840,405000000,408146688,409600000,410062500,414720000,419430400,419904000,421875000,424673280,425152800,429981696,430467210,432000000,437400000,439453125,442368000,442867500,447897600,450000000,452984832,453496320,455625000,459165024,460800000,466560000,468750000,471859200,472392000,474609375,477757440,478296900,480000000,483729408,486000000,488281250,491520000,492075000,497664000,500000000,503316480,503884800,506250000,509607936,510183360,512000000,512578125,516560652,518400000,\\n\\n524288000,524880000,527343750,530841600,531441000,536870912,537477120,540000000,544195584,546750000,552960000,553584375,559872000,562500000,566231040,566870400,569531250,573308928,573956280,576000000,583200000,585937500,589824000,590490000,597196800,597871125,600000000,603979776,604661760,607500000,612220032,614400000,615093750,622080000,625000000,629145600,629856000,632812500,637009920,637729200,640000000,644972544,645700815,648000000,655360000,656100000,663552000,664301250,671088640,671846400,675000000,679477248,680244480,683437500,688747536,691200000,699840000,703125000,707788800,708588000,716636160,717445350,720000000,725594112,729000000,732421875,737280000,738112500,746496000,750000000,754974720,755827200,759375000,764411904,765275040,768000000,774840978,777600000,781250000,786432000,787320000,791015625,796262400,797161500,800000000,805306368,806215680,810000000,816293376,819200000,820125000,829440000,838860800,839808000,843750000,849346560,850305600,854296875,859963392,860934420,864000000,874800000,878906250,884736000,885735000,895795200,900000000,905969664,906992640,911250000,918330048,921600000,922640625,933120000,937500000,943718400,944784000,949218750,955514880,956593800,960000000,967458816,972000000,976562500,983040000,984150000,995328000,996451875,1000000000,1006632960,1007769600,1012500000,1019215872,1020366720,1024000000,1025156250,1033121304,1036800000,1048576000,1049760000,1054687500,1061683200,1062882000,1073741824,1074954240,1076168025,1080000000,1088391168,1093500000,1105920000,1107168750,1119744000,1125000000,1132462080,1133740800,1139062500,1146617856,1147912560,1152000000,1162261467,1166400000,1171875000,1179648000,1180980000,1194393600,1195742250,1200000000,1207959552,1209323520,1215000000,1220703125,1224440064,1228800000,1230187500,1244160000,1250000000,1258291200,1259712000,1265625000,1274019840,1275458400,1280000000,1289945088,1291401630,1296000000,1310720000,1312200000,1318359375,1327104000,1328602500,1342177280,1343692800,1350000000,1358954496,1360488960,1366875000,1377495072,1382400000,1399680000,1406250000,1415577600,1417176000,1423828125,1433272320,1434890700,1440000000,1451188224,1458000000,1464843750,1474560000,1476225000,1492992000,1500000000,1509949440,1511654400,1518750000,1528823808,1530550080,1536000000,1537734375,1549681956,1555200000,1562500000,1572864000,1574640000,1582031250,1592524800,1594323000,1600000000,1610612736,1612431360,1620000000,1632586752,1638400000,1640250000,1658880000,1660753125,1677721600,1679616000,1687500000,1698693120,1700611200,1708593750,1719926784,1721868840,1728000000,1749600000,1757812500,1769472000,1771470000,1791590400,1793613375,1800000000,1811939328,1813985280,1822500000,1836660096,1843200000,1845281250,1866240000,1875000000,1887436800,1889568000,1898437500,1911029760,1913187600,1920000000,1934917632,1937102445,1944000000,1953125000,1966080000,1968300000,1990656000,1992903750,2000000000,2013265920,2015539200,2025000000,2038431744,2040733440,2048000000,2050312500,2066242608,2073600000,2097152000,2099520000,2109375000,2123366400,2125764000,2147483648,2149908480,2152336050,2160000000,2176782336,2187000000,2197265625,2211840000,2214337500,2239488000\\n\\n\\n};\\n\\n    int nthUglyNumber(int n) {\\n        return ar[n-1]; \\n    }\\n};`"
                    },
                    {
                        "username": "AasheeshLikePanner",
                        "content": "Bro stop this \\uD83D\\uDE2D\\uD83D\\uDE2D\\uD83D\\uDE2D"
                    },
                    {
                        "username": "Mayank_Shahria",
                        "content": "**I have solved this by two methods \\n1. Brute force**\\nBut it is giving a run time error\\n![image](https://assets.leetcode.com/users/images/ba539fa1-405b-4d9d-832a-5be83172edc4_1620554425.1931248.png)\\n**2. Dynamic Programing**\\n![image](https://assets.leetcode.com/users/images/3a90f09e-1a3c-465f-a8d6-b58bfc613ccf_1620554465.9711976.png)\\n\\n\\n"
                    },
                    {
                        "username": "aman_online67",
                        "content": "I also applied brute force but it gives TLE at some 500 test case. But logic wise it is correct what to do now"
                    },
                    {
                        "username": "Rohith6776",
                        "content": "If the prime factors are limited to 2,3,5 and we should not consider numbers like(14->2*7, 21->3*7) right?"
                    },
                    {
                        "username": "wtfcoder",
                        "content": "yup"
                    },
                    {
                        "username": "c_jain",
                        "content": "After reading top solutions here, I realized optimized solution is not a DP solution because I am not able to figure out optimal substructure and overlapping subproblem. I think it is kind of 3 pointer solution. Anyone like to clarify this?"
                    },
                    {
                        "username": "vikasboss6855",
                        "content": "https://leetcode.com/problems/ugly-number-ii/solutions/3704058/c-memoized-solution-using-dp-forcible-dp/"
                    },
                    {
                        "username": "Gismet",
                        "content": "Yeah, you are right. I don't also think there is an optimal substructure and overlapping subproblem. I think the reason why they called this DP solution is that we use the previously computed ugly numbers to find the next one. If you checked out the hint, they say you can get the next ugly number from a smaller ugly number by multiplying it by either 2, 3 or 5. So we start from the bottom and work our way up to the nth ugly number, in each iteration finding the next ugly number using a previous one. But to see the overlapping subproblems, one would write a recursive solution, also called top-down, and see if there are any subproblems that overlaps. But I couldn't come up with recursive top-down solution. Or maybe there is an optimal substructure that I fail to see. "
                    },
                    {
                        "username": "logical_thinker",
                        "content": "can someone throw light on the last test case which is n being empty the 596th test case. what is that and how do I go about it."
                    },
                    {
                        "username": "urmichm",
                        "content": "why is 1 ugly number?"
                    },
                    {
                        "username": "at218808",
                        "content": "1 is a factor of every number , so its more like a ugly number has only factors as 1,2,3 or 5"
                    },
                    {
                        "username": "QuasiRus",
                        "content": "It does not have any prime factor outside [2, 3, 5] list. 1 itself is not a prime number."
                    }
                ]
            },
            {
                "id": 1573711,
                "content": [
                    {
                        "username": "lcn",
                        "content": " 1. Actually, the input space is much smaller than expected if we insist an `int` range output. \\nWhen input `n` is greater than `1691`, the output overflows the `int` range.\\n 2. Another way to view this bound is that all ugly numbers must be in the form `2^a*3^b*5^c`. Since we have `log2(Integer.MAX_VALUE)=a<31`, `log3(Integer.MAX_VALUE)=b<20` and `log5(Integer.MAX_VALUE)=c<14`, the combination allowed is surely under `31*20*14~=8400`.\\n\\nSo ugly number is sparser than one would usually think, and please do take care of overflow."
                    },
                    {
                        "username": "chauhanprerna21",
                        "content": "I am not able to understand how is ugly numbers a DP problem?\\nWould be great if someone could help with it."
                    },
                    {
                        "username": "vikasboss6855",
                        "content": "https://leetcode.com/problems/ugly-number-ii/solutions/3704058/c-memoized-solution-using-dp-forcible-dp/\n```\nclass Solution {\npublic:\n    int nthUglyNumber(int n) {\n        vector<int> dp(n);\n        dp[0] = 1;\n        return nthUglyNumberRecursive(dp, n, 1, 0, 0, 0);\n    }\n\nprivate:\n    int nthUglyNumberRecursive(vector<int>& dp, int n, int i, int p1, int p2, int p3) {\n        if (i == n) {\n            return dp[n - 1];\n        }\n\n        int twoMultiple = dp[p1] * 2;\n        int threeMultiple = dp[p2] * 3;\n        int fiveMultiple = dp[p3] * 5;\n\n        dp[i] = min(twoMultiple, min(threeMultiple, fiveMultiple));\n\n        int nextP1 = (dp[i] == twoMultiple) ? p1 + 1 : p1;\n        int nextP2 = (dp[i] == threeMultiple) ? p2 + 1 : p2;\n        int nextP3 = (dp[i] == fiveMultiple) ? p3 + 1 : p3;\n\n        return nthUglyNumberRecursive(dp, n, i + 1, nextP1, nextP2, nextP3);\n    }\n};\n\n```"
                    },
                    {
                        "username": "divyanshuparg",
                        "content": "I have solved it using recursion and hashing."
                    },
                    {
                        "username": "anshulguleria",
                        "content": "In the example in problem statement 1 was being counted as ugly number. I am not able to understand how we concluded that.\\n\\nif 1 = 1 * 2^0 then this theory will be true for other numbers as well like 7  * 2^0."
                    },
                    {
                        "username": "Seabayley",
                        "content": "![image](https://assets.leetcode.com/users/images/fad90901-6c35-455e-8ff0-8160380ca46c_1597993223.2791212.png)\\n\\nAm I misunderstanding the problem? The 11th ugly numbers looks to me as though it should be 14?"
                    },
                    {
                        "username": "codekorekhai",
                        "content": "[@satyamkumarskr](/satyamkumarskr) 14 is not an ugly number because it has 7 as factor but the problem said that only 2, 3, 5 will be the prime factor for each ugly number."
                    },
                    {
                        "username": "satyamkumarskr",
                        "content": "True . I got the same issue."
                    },
                    {
                        "username": "user6746E",
                        "content": "The 11th ugly number will not be 14 since the prime factor of 14 includes 7, but the question clearly states that the primes factor should be limited to 2, 3 or 5. Therefore 11th ugly number will be 15."
                    },
                    {
                        "username": "sazib204061",
                        "content": "I solve this problem in O(1) time complexity.\\n `class Solution {\\npublic:\\nvector<long long>ar = {1,2,3,4,5,6,8,9,10,12,15,16,18,20,24,25,27,30,32,36,40,45,48,50,54,60,64,72,75,80,81,90,96,100,108,120,125,128,135,144,150,160,162,180,192,200,216,225,240,243,250,256,270,288,300,320,324,360,375,384,400,405,432,450,480,486,500,512,540,576,600,625,640,648,675,720,729,750,768,800,810,864,900,960,972,1000,1024,1080,1125,1152,1200,1215,1250,1280,1296,1350,1440,1458,1500,1536,1600,1620,1728,1800,1875,1920,1944,2000,2025,2048,2160,2187,2250,2304,2400,2430,2500,2560,2592,2700,2880,2916,3000,3072,3125,3200,3240,3375,3456,3600,3645,3750,3840,3888,4000,4050,4096,4320,4374,4500,4608,4800,4860,5000,5120,5184,5400,5625,5760,5832,6000,6075,6144,6250,6400,6480,6561,6750,6912,7200,7290,7500,7680,7776,8000,8100,8192,8640,8748,9000,9216,9375,9600,9720,10000,10125,10240,10368,10800,10935,11250,11520,11664,12000,12150,12288,12500,12800,12960,13122,13500,13824,14400,14580,15000,15360,15552,15625,16000,16200,16384,16875,17280,17496,18000,18225,18432,18750,19200,19440,19683,20000,20250,20480,20736,21600,21870,22500,23040,23328,24000,24300,24576,25000,25600,25920,26244,27000,27648,28125,28800,29160,30000,30375,30720,31104,31250,32000,32400,32768,32805,33750,34560,34992,36000,36450,36864,37500,38400,38880,39366,40000,40500,40960,41472,43200,43740,45000,46080,46656,46875,48000,48600,49152,50000,50625,51200,51840,52488,54000,54675,55296,56250,57600,58320,59049,60000,60750,61440,62208,62500,64000,64800,65536,65610,67500,69120,69984,72000,72900,73728,75000,76800,77760,78125,78732,80000,81000,81920,82944,84375,86400,87480,90000,91125,92160,93312,93750,96000,97200,98304,98415,100000,101250,102400,103680,104976,108000,109350,110592,112500,115200,116640,118098,120000,121500,122880,124416,125000,128000,129600,131072,131220,135000,138240,139968,140625,144000,145800,147456,150000,151875,153600,155520,156250,157464,160000,162000,163840,164025,165888,168750,172800,174960,177147,180000,182250,184320,186624,187500,192000,194400,196608,196830,200000,202500,204800,207360,209952,216000,218700,221184,225000,230400,233280,234375,236196,240000,243000,245760,248832,250000,253125,256000,259200,262144,262440,270000,273375,276480,279936,281250,288000,291600,294912,295245,300000,303750,307200,311040,312500,314928,320000,324000,327680,328050,331776,337500,345600,349920,354294,360000,364500,368640,373248,375000,384000,388800,390625,393216,393660,400000,405000,409600,414720,419904,421875,432000,437400,442368,450000,455625,460800,466560,468750,472392,480000,486000,491520,492075,497664,500000,506250,512000,518400,524288,524880,531441,540000,546750,552960,559872,562500,576000,583200,589824,590490,600000,607500,614400,622080,625000,629856,640000,648000,655360,656100,663552,675000,691200,699840,703125,708588,720000,729000,737280,746496,750000,759375,768000,777600,781250,786432,787320,800000,810000,819200,820125,829440,839808,843750,864000,874800,884736,885735,900000,911250,921600,933120,937500,944784,\\n\\n960000,972000,983040,984150,995328,1000000,1012500,1024000,1036800,1048576,1049760,1062882,1080000,1093500,1105920,1119744,1125000,1152000,1166400,1171875,1179648,1180980,1200000,1215000,1228800,1244160,1250000,1259712,1265625,1280000,1296000,1310720,1312200,1327104,1350000,1366875,1382400,1399680,1406250,1417176,1440000,1458000,1474560,1476225,1492992,1500000,1518750,1536000,1555200,1562500,1572864,1574640,1594323,1600000,1620000,1638400,1640250,1658880,1679616,1687500,1728000,1749600,1769472,1771470,1800000,1822500,1843200,1866240,1875000,1889568,1920000,1944000,1953125,1966080,1968300,1990656,2000000,2025000,2048000,2073600,2097152,2099520,2109375,2125764,2160000,2187000,2211840,2239488,2250000,2278125,2304000,2332800,2343750,2359296,2361960,2400000,2430000,2457600,2460375,2488320,2500000,2519424,2531250,2560000,2592000,2621440,2624400,2654208,2657205,2700000,2733750,2764800,2799360,2812500,2834352,2880000,2916000,2949120,2952450,2985984,3000000,3037500,3072000,3110400,3125000,3145728,3149280,3188646,3200000,3240000,3276800,3280500,3317760,3359232,3375000,3456000,3499200,3515625,3538944,3542940,3600000,3645000,3686400,3732480,3750000,3779136,3796875,3840000,3888000,3906250,3932160,3936600,3981312,4000000,4050000,4096000,4100625,4147200,4194304,4199040,4218750,4251528,4320000,4374000,4423680,4428675,4478976,4500000,4556250,4608000,4665600,4687500,4718592,4723920,4782969,4800000,4860000,4915200,4920750,4976640,5000000,5038848,5062500,5120000,5184000,5242880,5248800,5308416,5314410,5400000,5467500,5529600,5598720,5625000,5668704,5760000,5832000,5859375,5898240,5904900,5971968,6000000,6075000,6144000,6220800,6250000,6291456,6298560,6328125,6377292,6400000,6480000,6553600,6561000,6635520,6718464,6750000,6834375,6912000,6998400,7031250,7077888,7085880,7200000,7290000,7372800,7381125,7464960,7500000,7558272,7593750,7680000,7776000,7812500,7864320,7873200,7962624,7971615,8000000,8100000,8192000,8201250,8294400,8388608,8398080,8437500,8503056,8640000,8748000,8847360,8857350,8957952,9000000,9112500,9216000,9331200,9375000,9437184,9447840,9565938,9600000,9720000,9765625,9830400,9841500,9953280,10000000,10077696,10125000,10240000,10368000,10485760,10497600,10546875,10616832,10628820,10800000,10935000,11059200,11197440,11250000,11337408,11390625,11520000,11664000,11718750,11796480,11809800,11943936,12000000,12150000,12288000,12301875,12441600,12500000,12582912,12597120,12656250,12754584,12800000,12960000,13107200,13122000,13271040,13286025,13436928,13500000,13668750,13824000,13996800,14062500,14155776,14171760,14348907,14400000,14580000,14745600,14762250,14929920,15000000,15116544,15187500,15360000,15552000,15625000,15728640,15746400,15925248,15943230,16000000,16200000,16384000,16402500,16588800,16777216,16796160,16875000,17006112,17280000,17496000,17578125,17694720,17714700,17915904,18000000,18225000,18432000,18662400,18750000,18874368,18895680,18984375,19131876,19200000,19440000,19531250,19660800,19683000,19906560,20000000,20155392,20250000,20480000,20503125,20736000,20971520,20995200,21093750,21233664,21257640,21600000,21870000,22118400,22143375,22394880,22500000,22674816,22781250,23040000,23328000,23437500,23592960,23619600,23887872,23914845,24000000,24300000,24576000,24603750,24883200,25000000,25165824,25194240,25312500,25509168,25600000,25920000,26214400,26244000,26542080,26572050,26873856,27000000,27337500,27648000,27993600,28125000,28311552,28343520,28697814,28800000,29160000,29296875,29491200,29524500,29859840,30000000,30233088,30375000,30720000,31104000,31250000,31457280,31492800,31640625,31850496,31886460,32000000,32400000,32768000,32805000,33177600,33554432,33592320,33750000,34012224,34171875,34560000,34992000,35156250,35389440,35429400,35831808,36000000,36450000,36864000,36905625,37324800,37500000,37748736,37791360,37968750,38263752,38400000,38880000,39062500,39321600,39366000,39813120,39858075,40000000,40310784,40500000,40960000,41006250,41472000,41943040,41990400,42187500,42467328,42515280,43046721,43200000,43740000,44236800,44286750,44789760,45000000,45349632,45562500,46080000,46656000,46875000,47185920,47239200,47775744,47829690,48000000,48600000,48828125,49152000,49207500,49766400,50000000,50331648,50388480,50625000,51018336,51200000,51840000,\\n\\n52428800,52488000,52734375,53084160,53144100,53747712,54000000,54675000,55296000,55987200,56250000,56623104,56687040,56953125,57395628,57600000,58320000,58593750,58982400,59049000,59719680,60000000,60466176,60750000,61440000,61509375,62208000,62500000,62914560,62985600,63281250,63700992,63772920,64000000,64800000,65536000,65610000,66355200,66430125,67108864,67184640,67500000,68024448,68343750,69120000,69984000,70312500,70778880,70858800,71663616,71744535,72000000,72900000,73728000,73811250,74649600,75000000,75497472,75582720,75937500,76527504,76800000,77760000,78125000,78643200,78732000,79626240,79716150,80000000,80621568,81000000,81920000,82012500,82944000,83886080,83980800,84375000,84934656,85030560,86093442,86400000,87480000,87890625,88473600,88573500,89579520,90000000,90699264,91125000,92160000,93312000,93750000,94371840,94478400,94921875,95551488,95659380,96000000,97200000,97656250,98304000,98415000,99532800,100000000,100663296,100776960,101250000,102036672,102400000,102515625,103680000,104857600,104976000,105468750,106168320,106288200,107495424,108000000,109350000,110592000,110716875,111974400,112500000,113246208,113374080,113906250,114791256,115200000,116640000,117187500,117964800,118098000,119439360,119574225,120000000,120932352,121500000,122880000,123018750,124416000,125000000,125829120,125971200,126562500,127401984,127545840,128000000,129140163,129600000,131072000,131220000,132710400,132860250,134217728,134369280,135000000,136048896,136687500,138240000,139968000,140625000,141557760,141717600,143327232,143489070,144000000,145800000,146484375,147456000,147622500,149299200,150000000,150994944,151165440,151875000,153055008,153600000,155520000,156250000,157286400,157464000,158203125,159252480,159432300,160000000,161243136,162000000,163840000,164025000,165888000,167772160,167961600,168750000,169869312,170061120,170859375,172186884,172800000,174960000,175781250,\\n\\n\\n176947200,177147000,179159040,180000000,181398528,182250000,184320000,184528125,186624000,187500000,188743680,188956800,189843750,191102976,191318760,192000000,194400000,195312500,196608000,196830000,199065600,199290375,200000000,201326592,201553920,202500000,204073344,204800000,205031250,207360000,209715200,209952000,210937500,212336640,212576400,214990848,215233605,216000000,218700000,221184000,221433750,223948800,225000000,226492416,226748160,227812500,229582512,230400000,233280000,234375000,235929600,236196000,238878720,239148450,240000000,241864704,243000000,244140625,245760000,246037500,248832000,250000000,251658240,251942400,253125000,254803968,255091680,256000000,258280326,259200000,262144000,262440000,263671875,265420800,265720500,268435456,268738560,270000000,272097792,273375000,276480000,279936000,281250000,283115520,283435200,284765625,286654464,286978140,288000000,291600000,292968750,294912000,295245000,298598400,300000000,301989888,302330880,303750000,306110016,307200000,307546875,311040000,312500000,314572800,314928000,316406250,318504960,318864600,320000000,322486272,324000000,327680000,328050000,331776000,332150625,335544320,335923200,337500000,339738624,340122240,341718750,344373768,345600000,349920000,351562500,353894400,354294000,358318080,358722675,360000000,362797056,364500000,368640000,369056250,373248000,375000000,377487360,377913600,379687500,382205952,382637520,384000000,387420489,388800000,390625000,393216000,393660000,398131200,398580750,400000000,402653184,403107840,405000000,408146688,409600000,410062500,414720000,419430400,419904000,421875000,424673280,425152800,429981696,430467210,432000000,437400000,439453125,442368000,442867500,447897600,450000000,452984832,453496320,455625000,459165024,460800000,466560000,468750000,471859200,472392000,474609375,477757440,478296900,480000000,483729408,486000000,488281250,491520000,492075000,497664000,500000000,503316480,503884800,506250000,509607936,510183360,512000000,512578125,516560652,518400000,\\n\\n524288000,524880000,527343750,530841600,531441000,536870912,537477120,540000000,544195584,546750000,552960000,553584375,559872000,562500000,566231040,566870400,569531250,573308928,573956280,576000000,583200000,585937500,589824000,590490000,597196800,597871125,600000000,603979776,604661760,607500000,612220032,614400000,615093750,622080000,625000000,629145600,629856000,632812500,637009920,637729200,640000000,644972544,645700815,648000000,655360000,656100000,663552000,664301250,671088640,671846400,675000000,679477248,680244480,683437500,688747536,691200000,699840000,703125000,707788800,708588000,716636160,717445350,720000000,725594112,729000000,732421875,737280000,738112500,746496000,750000000,754974720,755827200,759375000,764411904,765275040,768000000,774840978,777600000,781250000,786432000,787320000,791015625,796262400,797161500,800000000,805306368,806215680,810000000,816293376,819200000,820125000,829440000,838860800,839808000,843750000,849346560,850305600,854296875,859963392,860934420,864000000,874800000,878906250,884736000,885735000,895795200,900000000,905969664,906992640,911250000,918330048,921600000,922640625,933120000,937500000,943718400,944784000,949218750,955514880,956593800,960000000,967458816,972000000,976562500,983040000,984150000,995328000,996451875,1000000000,1006632960,1007769600,1012500000,1019215872,1020366720,1024000000,1025156250,1033121304,1036800000,1048576000,1049760000,1054687500,1061683200,1062882000,1073741824,1074954240,1076168025,1080000000,1088391168,1093500000,1105920000,1107168750,1119744000,1125000000,1132462080,1133740800,1139062500,1146617856,1147912560,1152000000,1162261467,1166400000,1171875000,1179648000,1180980000,1194393600,1195742250,1200000000,1207959552,1209323520,1215000000,1220703125,1224440064,1228800000,1230187500,1244160000,1250000000,1258291200,1259712000,1265625000,1274019840,1275458400,1280000000,1289945088,1291401630,1296000000,1310720000,1312200000,1318359375,1327104000,1328602500,1342177280,1343692800,1350000000,1358954496,1360488960,1366875000,1377495072,1382400000,1399680000,1406250000,1415577600,1417176000,1423828125,1433272320,1434890700,1440000000,1451188224,1458000000,1464843750,1474560000,1476225000,1492992000,1500000000,1509949440,1511654400,1518750000,1528823808,1530550080,1536000000,1537734375,1549681956,1555200000,1562500000,1572864000,1574640000,1582031250,1592524800,1594323000,1600000000,1610612736,1612431360,1620000000,1632586752,1638400000,1640250000,1658880000,1660753125,1677721600,1679616000,1687500000,1698693120,1700611200,1708593750,1719926784,1721868840,1728000000,1749600000,1757812500,1769472000,1771470000,1791590400,1793613375,1800000000,1811939328,1813985280,1822500000,1836660096,1843200000,1845281250,1866240000,1875000000,1887436800,1889568000,1898437500,1911029760,1913187600,1920000000,1934917632,1937102445,1944000000,1953125000,1966080000,1968300000,1990656000,1992903750,2000000000,2013265920,2015539200,2025000000,2038431744,2040733440,2048000000,2050312500,2066242608,2073600000,2097152000,2099520000,2109375000,2123366400,2125764000,2147483648,2149908480,2152336050,2160000000,2176782336,2187000000,2197265625,2211840000,2214337500,2239488000\\n\\n\\n};\\n\\n    int nthUglyNumber(int n) {\\n        return ar[n-1]; \\n    }\\n};`"
                    },
                    {
                        "username": "AasheeshLikePanner",
                        "content": "Bro stop this \\uD83D\\uDE2D\\uD83D\\uDE2D\\uD83D\\uDE2D"
                    },
                    {
                        "username": "Mayank_Shahria",
                        "content": "**I have solved this by two methods \\n1. Brute force**\\nBut it is giving a run time error\\n![image](https://assets.leetcode.com/users/images/ba539fa1-405b-4d9d-832a-5be83172edc4_1620554425.1931248.png)\\n**2. Dynamic Programing**\\n![image](https://assets.leetcode.com/users/images/3a90f09e-1a3c-465f-a8d6-b58bfc613ccf_1620554465.9711976.png)\\n\\n\\n"
                    },
                    {
                        "username": "aman_online67",
                        "content": "I also applied brute force but it gives TLE at some 500 test case. But logic wise it is correct what to do now"
                    },
                    {
                        "username": "Rohith6776",
                        "content": "If the prime factors are limited to 2,3,5 and we should not consider numbers like(14->2*7, 21->3*7) right?"
                    },
                    {
                        "username": "wtfcoder",
                        "content": "yup"
                    },
                    {
                        "username": "c_jain",
                        "content": "After reading top solutions here, I realized optimized solution is not a DP solution because I am not able to figure out optimal substructure and overlapping subproblem. I think it is kind of 3 pointer solution. Anyone like to clarify this?"
                    },
                    {
                        "username": "vikasboss6855",
                        "content": "https://leetcode.com/problems/ugly-number-ii/solutions/3704058/c-memoized-solution-using-dp-forcible-dp/"
                    },
                    {
                        "username": "Gismet",
                        "content": "Yeah, you are right. I don't also think there is an optimal substructure and overlapping subproblem. I think the reason why they called this DP solution is that we use the previously computed ugly numbers to find the next one. If you checked out the hint, they say you can get the next ugly number from a smaller ugly number by multiplying it by either 2, 3 or 5. So we start from the bottom and work our way up to the nth ugly number, in each iteration finding the next ugly number using a previous one. But to see the overlapping subproblems, one would write a recursive solution, also called top-down, and see if there are any subproblems that overlaps. But I couldn't come up with recursive top-down solution. Or maybe there is an optimal substructure that I fail to see. "
                    },
                    {
                        "username": "logical_thinker",
                        "content": "can someone throw light on the last test case which is n being empty the 596th test case. what is that and how do I go about it."
                    },
                    {
                        "username": "urmichm",
                        "content": "why is 1 ugly number?"
                    },
                    {
                        "username": "at218808",
                        "content": "1 is a factor of every number , so its more like a ugly number has only factors as 1,2,3 or 5"
                    },
                    {
                        "username": "QuasiRus",
                        "content": "It does not have any prime factor outside [2, 3, 5] list. 1 itself is not a prime number."
                    }
                ]
            },
            {
                "id": 1574250,
                "content": [
                    {
                        "username": "lcn",
                        "content": " 1. Actually, the input space is much smaller than expected if we insist an `int` range output. \\nWhen input `n` is greater than `1691`, the output overflows the `int` range.\\n 2. Another way to view this bound is that all ugly numbers must be in the form `2^a*3^b*5^c`. Since we have `log2(Integer.MAX_VALUE)=a<31`, `log3(Integer.MAX_VALUE)=b<20` and `log5(Integer.MAX_VALUE)=c<14`, the combination allowed is surely under `31*20*14~=8400`.\\n\\nSo ugly number is sparser than one would usually think, and please do take care of overflow."
                    },
                    {
                        "username": "chauhanprerna21",
                        "content": "I am not able to understand how is ugly numbers a DP problem?\\nWould be great if someone could help with it."
                    },
                    {
                        "username": "vikasboss6855",
                        "content": "https://leetcode.com/problems/ugly-number-ii/solutions/3704058/c-memoized-solution-using-dp-forcible-dp/\n```\nclass Solution {\npublic:\n    int nthUglyNumber(int n) {\n        vector<int> dp(n);\n        dp[0] = 1;\n        return nthUglyNumberRecursive(dp, n, 1, 0, 0, 0);\n    }\n\nprivate:\n    int nthUglyNumberRecursive(vector<int>& dp, int n, int i, int p1, int p2, int p3) {\n        if (i == n) {\n            return dp[n - 1];\n        }\n\n        int twoMultiple = dp[p1] * 2;\n        int threeMultiple = dp[p2] * 3;\n        int fiveMultiple = dp[p3] * 5;\n\n        dp[i] = min(twoMultiple, min(threeMultiple, fiveMultiple));\n\n        int nextP1 = (dp[i] == twoMultiple) ? p1 + 1 : p1;\n        int nextP2 = (dp[i] == threeMultiple) ? p2 + 1 : p2;\n        int nextP3 = (dp[i] == fiveMultiple) ? p3 + 1 : p3;\n\n        return nthUglyNumberRecursive(dp, n, i + 1, nextP1, nextP2, nextP3);\n    }\n};\n\n```"
                    },
                    {
                        "username": "divyanshuparg",
                        "content": "I have solved it using recursion and hashing."
                    },
                    {
                        "username": "anshulguleria",
                        "content": "In the example in problem statement 1 was being counted as ugly number. I am not able to understand how we concluded that.\\n\\nif 1 = 1 * 2^0 then this theory will be true for other numbers as well like 7  * 2^0."
                    },
                    {
                        "username": "Seabayley",
                        "content": "![image](https://assets.leetcode.com/users/images/fad90901-6c35-455e-8ff0-8160380ca46c_1597993223.2791212.png)\\n\\nAm I misunderstanding the problem? The 11th ugly numbers looks to me as though it should be 14?"
                    },
                    {
                        "username": "codekorekhai",
                        "content": "[@satyamkumarskr](/satyamkumarskr) 14 is not an ugly number because it has 7 as factor but the problem said that only 2, 3, 5 will be the prime factor for each ugly number."
                    },
                    {
                        "username": "satyamkumarskr",
                        "content": "True . I got the same issue."
                    },
                    {
                        "username": "user6746E",
                        "content": "The 11th ugly number will not be 14 since the prime factor of 14 includes 7, but the question clearly states that the primes factor should be limited to 2, 3 or 5. Therefore 11th ugly number will be 15."
                    },
                    {
                        "username": "sazib204061",
                        "content": "I solve this problem in O(1) time complexity.\\n `class Solution {\\npublic:\\nvector<long long>ar = {1,2,3,4,5,6,8,9,10,12,15,16,18,20,24,25,27,30,32,36,40,45,48,50,54,60,64,72,75,80,81,90,96,100,108,120,125,128,135,144,150,160,162,180,192,200,216,225,240,243,250,256,270,288,300,320,324,360,375,384,400,405,432,450,480,486,500,512,540,576,600,625,640,648,675,720,729,750,768,800,810,864,900,960,972,1000,1024,1080,1125,1152,1200,1215,1250,1280,1296,1350,1440,1458,1500,1536,1600,1620,1728,1800,1875,1920,1944,2000,2025,2048,2160,2187,2250,2304,2400,2430,2500,2560,2592,2700,2880,2916,3000,3072,3125,3200,3240,3375,3456,3600,3645,3750,3840,3888,4000,4050,4096,4320,4374,4500,4608,4800,4860,5000,5120,5184,5400,5625,5760,5832,6000,6075,6144,6250,6400,6480,6561,6750,6912,7200,7290,7500,7680,7776,8000,8100,8192,8640,8748,9000,9216,9375,9600,9720,10000,10125,10240,10368,10800,10935,11250,11520,11664,12000,12150,12288,12500,12800,12960,13122,13500,13824,14400,14580,15000,15360,15552,15625,16000,16200,16384,16875,17280,17496,18000,18225,18432,18750,19200,19440,19683,20000,20250,20480,20736,21600,21870,22500,23040,23328,24000,24300,24576,25000,25600,25920,26244,27000,27648,28125,28800,29160,30000,30375,30720,31104,31250,32000,32400,32768,32805,33750,34560,34992,36000,36450,36864,37500,38400,38880,39366,40000,40500,40960,41472,43200,43740,45000,46080,46656,46875,48000,48600,49152,50000,50625,51200,51840,52488,54000,54675,55296,56250,57600,58320,59049,60000,60750,61440,62208,62500,64000,64800,65536,65610,67500,69120,69984,72000,72900,73728,75000,76800,77760,78125,78732,80000,81000,81920,82944,84375,86400,87480,90000,91125,92160,93312,93750,96000,97200,98304,98415,100000,101250,102400,103680,104976,108000,109350,110592,112500,115200,116640,118098,120000,121500,122880,124416,125000,128000,129600,131072,131220,135000,138240,139968,140625,144000,145800,147456,150000,151875,153600,155520,156250,157464,160000,162000,163840,164025,165888,168750,172800,174960,177147,180000,182250,184320,186624,187500,192000,194400,196608,196830,200000,202500,204800,207360,209952,216000,218700,221184,225000,230400,233280,234375,236196,240000,243000,245760,248832,250000,253125,256000,259200,262144,262440,270000,273375,276480,279936,281250,288000,291600,294912,295245,300000,303750,307200,311040,312500,314928,320000,324000,327680,328050,331776,337500,345600,349920,354294,360000,364500,368640,373248,375000,384000,388800,390625,393216,393660,400000,405000,409600,414720,419904,421875,432000,437400,442368,450000,455625,460800,466560,468750,472392,480000,486000,491520,492075,497664,500000,506250,512000,518400,524288,524880,531441,540000,546750,552960,559872,562500,576000,583200,589824,590490,600000,607500,614400,622080,625000,629856,640000,648000,655360,656100,663552,675000,691200,699840,703125,708588,720000,729000,737280,746496,750000,759375,768000,777600,781250,786432,787320,800000,810000,819200,820125,829440,839808,843750,864000,874800,884736,885735,900000,911250,921600,933120,937500,944784,\\n\\n960000,972000,983040,984150,995328,1000000,1012500,1024000,1036800,1048576,1049760,1062882,1080000,1093500,1105920,1119744,1125000,1152000,1166400,1171875,1179648,1180980,1200000,1215000,1228800,1244160,1250000,1259712,1265625,1280000,1296000,1310720,1312200,1327104,1350000,1366875,1382400,1399680,1406250,1417176,1440000,1458000,1474560,1476225,1492992,1500000,1518750,1536000,1555200,1562500,1572864,1574640,1594323,1600000,1620000,1638400,1640250,1658880,1679616,1687500,1728000,1749600,1769472,1771470,1800000,1822500,1843200,1866240,1875000,1889568,1920000,1944000,1953125,1966080,1968300,1990656,2000000,2025000,2048000,2073600,2097152,2099520,2109375,2125764,2160000,2187000,2211840,2239488,2250000,2278125,2304000,2332800,2343750,2359296,2361960,2400000,2430000,2457600,2460375,2488320,2500000,2519424,2531250,2560000,2592000,2621440,2624400,2654208,2657205,2700000,2733750,2764800,2799360,2812500,2834352,2880000,2916000,2949120,2952450,2985984,3000000,3037500,3072000,3110400,3125000,3145728,3149280,3188646,3200000,3240000,3276800,3280500,3317760,3359232,3375000,3456000,3499200,3515625,3538944,3542940,3600000,3645000,3686400,3732480,3750000,3779136,3796875,3840000,3888000,3906250,3932160,3936600,3981312,4000000,4050000,4096000,4100625,4147200,4194304,4199040,4218750,4251528,4320000,4374000,4423680,4428675,4478976,4500000,4556250,4608000,4665600,4687500,4718592,4723920,4782969,4800000,4860000,4915200,4920750,4976640,5000000,5038848,5062500,5120000,5184000,5242880,5248800,5308416,5314410,5400000,5467500,5529600,5598720,5625000,5668704,5760000,5832000,5859375,5898240,5904900,5971968,6000000,6075000,6144000,6220800,6250000,6291456,6298560,6328125,6377292,6400000,6480000,6553600,6561000,6635520,6718464,6750000,6834375,6912000,6998400,7031250,7077888,7085880,7200000,7290000,7372800,7381125,7464960,7500000,7558272,7593750,7680000,7776000,7812500,7864320,7873200,7962624,7971615,8000000,8100000,8192000,8201250,8294400,8388608,8398080,8437500,8503056,8640000,8748000,8847360,8857350,8957952,9000000,9112500,9216000,9331200,9375000,9437184,9447840,9565938,9600000,9720000,9765625,9830400,9841500,9953280,10000000,10077696,10125000,10240000,10368000,10485760,10497600,10546875,10616832,10628820,10800000,10935000,11059200,11197440,11250000,11337408,11390625,11520000,11664000,11718750,11796480,11809800,11943936,12000000,12150000,12288000,12301875,12441600,12500000,12582912,12597120,12656250,12754584,12800000,12960000,13107200,13122000,13271040,13286025,13436928,13500000,13668750,13824000,13996800,14062500,14155776,14171760,14348907,14400000,14580000,14745600,14762250,14929920,15000000,15116544,15187500,15360000,15552000,15625000,15728640,15746400,15925248,15943230,16000000,16200000,16384000,16402500,16588800,16777216,16796160,16875000,17006112,17280000,17496000,17578125,17694720,17714700,17915904,18000000,18225000,18432000,18662400,18750000,18874368,18895680,18984375,19131876,19200000,19440000,19531250,19660800,19683000,19906560,20000000,20155392,20250000,20480000,20503125,20736000,20971520,20995200,21093750,21233664,21257640,21600000,21870000,22118400,22143375,22394880,22500000,22674816,22781250,23040000,23328000,23437500,23592960,23619600,23887872,23914845,24000000,24300000,24576000,24603750,24883200,25000000,25165824,25194240,25312500,25509168,25600000,25920000,26214400,26244000,26542080,26572050,26873856,27000000,27337500,27648000,27993600,28125000,28311552,28343520,28697814,28800000,29160000,29296875,29491200,29524500,29859840,30000000,30233088,30375000,30720000,31104000,31250000,31457280,31492800,31640625,31850496,31886460,32000000,32400000,32768000,32805000,33177600,33554432,33592320,33750000,34012224,34171875,34560000,34992000,35156250,35389440,35429400,35831808,36000000,36450000,36864000,36905625,37324800,37500000,37748736,37791360,37968750,38263752,38400000,38880000,39062500,39321600,39366000,39813120,39858075,40000000,40310784,40500000,40960000,41006250,41472000,41943040,41990400,42187500,42467328,42515280,43046721,43200000,43740000,44236800,44286750,44789760,45000000,45349632,45562500,46080000,46656000,46875000,47185920,47239200,47775744,47829690,48000000,48600000,48828125,49152000,49207500,49766400,50000000,50331648,50388480,50625000,51018336,51200000,51840000,\\n\\n52428800,52488000,52734375,53084160,53144100,53747712,54000000,54675000,55296000,55987200,56250000,56623104,56687040,56953125,57395628,57600000,58320000,58593750,58982400,59049000,59719680,60000000,60466176,60750000,61440000,61509375,62208000,62500000,62914560,62985600,63281250,63700992,63772920,64000000,64800000,65536000,65610000,66355200,66430125,67108864,67184640,67500000,68024448,68343750,69120000,69984000,70312500,70778880,70858800,71663616,71744535,72000000,72900000,73728000,73811250,74649600,75000000,75497472,75582720,75937500,76527504,76800000,77760000,78125000,78643200,78732000,79626240,79716150,80000000,80621568,81000000,81920000,82012500,82944000,83886080,83980800,84375000,84934656,85030560,86093442,86400000,87480000,87890625,88473600,88573500,89579520,90000000,90699264,91125000,92160000,93312000,93750000,94371840,94478400,94921875,95551488,95659380,96000000,97200000,97656250,98304000,98415000,99532800,100000000,100663296,100776960,101250000,102036672,102400000,102515625,103680000,104857600,104976000,105468750,106168320,106288200,107495424,108000000,109350000,110592000,110716875,111974400,112500000,113246208,113374080,113906250,114791256,115200000,116640000,117187500,117964800,118098000,119439360,119574225,120000000,120932352,121500000,122880000,123018750,124416000,125000000,125829120,125971200,126562500,127401984,127545840,128000000,129140163,129600000,131072000,131220000,132710400,132860250,134217728,134369280,135000000,136048896,136687500,138240000,139968000,140625000,141557760,141717600,143327232,143489070,144000000,145800000,146484375,147456000,147622500,149299200,150000000,150994944,151165440,151875000,153055008,153600000,155520000,156250000,157286400,157464000,158203125,159252480,159432300,160000000,161243136,162000000,163840000,164025000,165888000,167772160,167961600,168750000,169869312,170061120,170859375,172186884,172800000,174960000,175781250,\\n\\n\\n176947200,177147000,179159040,180000000,181398528,182250000,184320000,184528125,186624000,187500000,188743680,188956800,189843750,191102976,191318760,192000000,194400000,195312500,196608000,196830000,199065600,199290375,200000000,201326592,201553920,202500000,204073344,204800000,205031250,207360000,209715200,209952000,210937500,212336640,212576400,214990848,215233605,216000000,218700000,221184000,221433750,223948800,225000000,226492416,226748160,227812500,229582512,230400000,233280000,234375000,235929600,236196000,238878720,239148450,240000000,241864704,243000000,244140625,245760000,246037500,248832000,250000000,251658240,251942400,253125000,254803968,255091680,256000000,258280326,259200000,262144000,262440000,263671875,265420800,265720500,268435456,268738560,270000000,272097792,273375000,276480000,279936000,281250000,283115520,283435200,284765625,286654464,286978140,288000000,291600000,292968750,294912000,295245000,298598400,300000000,301989888,302330880,303750000,306110016,307200000,307546875,311040000,312500000,314572800,314928000,316406250,318504960,318864600,320000000,322486272,324000000,327680000,328050000,331776000,332150625,335544320,335923200,337500000,339738624,340122240,341718750,344373768,345600000,349920000,351562500,353894400,354294000,358318080,358722675,360000000,362797056,364500000,368640000,369056250,373248000,375000000,377487360,377913600,379687500,382205952,382637520,384000000,387420489,388800000,390625000,393216000,393660000,398131200,398580750,400000000,402653184,403107840,405000000,408146688,409600000,410062500,414720000,419430400,419904000,421875000,424673280,425152800,429981696,430467210,432000000,437400000,439453125,442368000,442867500,447897600,450000000,452984832,453496320,455625000,459165024,460800000,466560000,468750000,471859200,472392000,474609375,477757440,478296900,480000000,483729408,486000000,488281250,491520000,492075000,497664000,500000000,503316480,503884800,506250000,509607936,510183360,512000000,512578125,516560652,518400000,\\n\\n524288000,524880000,527343750,530841600,531441000,536870912,537477120,540000000,544195584,546750000,552960000,553584375,559872000,562500000,566231040,566870400,569531250,573308928,573956280,576000000,583200000,585937500,589824000,590490000,597196800,597871125,600000000,603979776,604661760,607500000,612220032,614400000,615093750,622080000,625000000,629145600,629856000,632812500,637009920,637729200,640000000,644972544,645700815,648000000,655360000,656100000,663552000,664301250,671088640,671846400,675000000,679477248,680244480,683437500,688747536,691200000,699840000,703125000,707788800,708588000,716636160,717445350,720000000,725594112,729000000,732421875,737280000,738112500,746496000,750000000,754974720,755827200,759375000,764411904,765275040,768000000,774840978,777600000,781250000,786432000,787320000,791015625,796262400,797161500,800000000,805306368,806215680,810000000,816293376,819200000,820125000,829440000,838860800,839808000,843750000,849346560,850305600,854296875,859963392,860934420,864000000,874800000,878906250,884736000,885735000,895795200,900000000,905969664,906992640,911250000,918330048,921600000,922640625,933120000,937500000,943718400,944784000,949218750,955514880,956593800,960000000,967458816,972000000,976562500,983040000,984150000,995328000,996451875,1000000000,1006632960,1007769600,1012500000,1019215872,1020366720,1024000000,1025156250,1033121304,1036800000,1048576000,1049760000,1054687500,1061683200,1062882000,1073741824,1074954240,1076168025,1080000000,1088391168,1093500000,1105920000,1107168750,1119744000,1125000000,1132462080,1133740800,1139062500,1146617856,1147912560,1152000000,1162261467,1166400000,1171875000,1179648000,1180980000,1194393600,1195742250,1200000000,1207959552,1209323520,1215000000,1220703125,1224440064,1228800000,1230187500,1244160000,1250000000,1258291200,1259712000,1265625000,1274019840,1275458400,1280000000,1289945088,1291401630,1296000000,1310720000,1312200000,1318359375,1327104000,1328602500,1342177280,1343692800,1350000000,1358954496,1360488960,1366875000,1377495072,1382400000,1399680000,1406250000,1415577600,1417176000,1423828125,1433272320,1434890700,1440000000,1451188224,1458000000,1464843750,1474560000,1476225000,1492992000,1500000000,1509949440,1511654400,1518750000,1528823808,1530550080,1536000000,1537734375,1549681956,1555200000,1562500000,1572864000,1574640000,1582031250,1592524800,1594323000,1600000000,1610612736,1612431360,1620000000,1632586752,1638400000,1640250000,1658880000,1660753125,1677721600,1679616000,1687500000,1698693120,1700611200,1708593750,1719926784,1721868840,1728000000,1749600000,1757812500,1769472000,1771470000,1791590400,1793613375,1800000000,1811939328,1813985280,1822500000,1836660096,1843200000,1845281250,1866240000,1875000000,1887436800,1889568000,1898437500,1911029760,1913187600,1920000000,1934917632,1937102445,1944000000,1953125000,1966080000,1968300000,1990656000,1992903750,2000000000,2013265920,2015539200,2025000000,2038431744,2040733440,2048000000,2050312500,2066242608,2073600000,2097152000,2099520000,2109375000,2123366400,2125764000,2147483648,2149908480,2152336050,2160000000,2176782336,2187000000,2197265625,2211840000,2214337500,2239488000\\n\\n\\n};\\n\\n    int nthUglyNumber(int n) {\\n        return ar[n-1]; \\n    }\\n};`"
                    },
                    {
                        "username": "AasheeshLikePanner",
                        "content": "Bro stop this \\uD83D\\uDE2D\\uD83D\\uDE2D\\uD83D\\uDE2D"
                    },
                    {
                        "username": "Mayank_Shahria",
                        "content": "**I have solved this by two methods \\n1. Brute force**\\nBut it is giving a run time error\\n![image](https://assets.leetcode.com/users/images/ba539fa1-405b-4d9d-832a-5be83172edc4_1620554425.1931248.png)\\n**2. Dynamic Programing**\\n![image](https://assets.leetcode.com/users/images/3a90f09e-1a3c-465f-a8d6-b58bfc613ccf_1620554465.9711976.png)\\n\\n\\n"
                    },
                    {
                        "username": "aman_online67",
                        "content": "I also applied brute force but it gives TLE at some 500 test case. But logic wise it is correct what to do now"
                    },
                    {
                        "username": "Rohith6776",
                        "content": "If the prime factors are limited to 2,3,5 and we should not consider numbers like(14->2*7, 21->3*7) right?"
                    },
                    {
                        "username": "wtfcoder",
                        "content": "yup"
                    },
                    {
                        "username": "c_jain",
                        "content": "After reading top solutions here, I realized optimized solution is not a DP solution because I am not able to figure out optimal substructure and overlapping subproblem. I think it is kind of 3 pointer solution. Anyone like to clarify this?"
                    },
                    {
                        "username": "vikasboss6855",
                        "content": "https://leetcode.com/problems/ugly-number-ii/solutions/3704058/c-memoized-solution-using-dp-forcible-dp/"
                    },
                    {
                        "username": "Gismet",
                        "content": "Yeah, you are right. I don't also think there is an optimal substructure and overlapping subproblem. I think the reason why they called this DP solution is that we use the previously computed ugly numbers to find the next one. If you checked out the hint, they say you can get the next ugly number from a smaller ugly number by multiplying it by either 2, 3 or 5. So we start from the bottom and work our way up to the nth ugly number, in each iteration finding the next ugly number using a previous one. But to see the overlapping subproblems, one would write a recursive solution, also called top-down, and see if there are any subproblems that overlaps. But I couldn't come up with recursive top-down solution. Or maybe there is an optimal substructure that I fail to see. "
                    },
                    {
                        "username": "logical_thinker",
                        "content": "can someone throw light on the last test case which is n being empty the 596th test case. what is that and how do I go about it."
                    },
                    {
                        "username": "urmichm",
                        "content": "why is 1 ugly number?"
                    },
                    {
                        "username": "at218808",
                        "content": "1 is a factor of every number , so its more like a ugly number has only factors as 1,2,3 or 5"
                    },
                    {
                        "username": "QuasiRus",
                        "content": "It does not have any prime factor outside [2, 3, 5] list. 1 itself is not a prime number."
                    }
                ]
            },
            {
                "id": 2039889,
                "content": [
                    {
                        "username": "lcn",
                        "content": " 1. Actually, the input space is much smaller than expected if we insist an `int` range output. \\nWhen input `n` is greater than `1691`, the output overflows the `int` range.\\n 2. Another way to view this bound is that all ugly numbers must be in the form `2^a*3^b*5^c`. Since we have `log2(Integer.MAX_VALUE)=a<31`, `log3(Integer.MAX_VALUE)=b<20` and `log5(Integer.MAX_VALUE)=c<14`, the combination allowed is surely under `31*20*14~=8400`.\\n\\nSo ugly number is sparser than one would usually think, and please do take care of overflow."
                    },
                    {
                        "username": "chauhanprerna21",
                        "content": "I am not able to understand how is ugly numbers a DP problem?\\nWould be great if someone could help with it."
                    },
                    {
                        "username": "vikasboss6855",
                        "content": "https://leetcode.com/problems/ugly-number-ii/solutions/3704058/c-memoized-solution-using-dp-forcible-dp/\n```\nclass Solution {\npublic:\n    int nthUglyNumber(int n) {\n        vector<int> dp(n);\n        dp[0] = 1;\n        return nthUglyNumberRecursive(dp, n, 1, 0, 0, 0);\n    }\n\nprivate:\n    int nthUglyNumberRecursive(vector<int>& dp, int n, int i, int p1, int p2, int p3) {\n        if (i == n) {\n            return dp[n - 1];\n        }\n\n        int twoMultiple = dp[p1] * 2;\n        int threeMultiple = dp[p2] * 3;\n        int fiveMultiple = dp[p3] * 5;\n\n        dp[i] = min(twoMultiple, min(threeMultiple, fiveMultiple));\n\n        int nextP1 = (dp[i] == twoMultiple) ? p1 + 1 : p1;\n        int nextP2 = (dp[i] == threeMultiple) ? p2 + 1 : p2;\n        int nextP3 = (dp[i] == fiveMultiple) ? p3 + 1 : p3;\n\n        return nthUglyNumberRecursive(dp, n, i + 1, nextP1, nextP2, nextP3);\n    }\n};\n\n```"
                    },
                    {
                        "username": "divyanshuparg",
                        "content": "I have solved it using recursion and hashing."
                    },
                    {
                        "username": "anshulguleria",
                        "content": "In the example in problem statement 1 was being counted as ugly number. I am not able to understand how we concluded that.\\n\\nif 1 = 1 * 2^0 then this theory will be true for other numbers as well like 7  * 2^0."
                    },
                    {
                        "username": "Seabayley",
                        "content": "![image](https://assets.leetcode.com/users/images/fad90901-6c35-455e-8ff0-8160380ca46c_1597993223.2791212.png)\\n\\nAm I misunderstanding the problem? The 11th ugly numbers looks to me as though it should be 14?"
                    },
                    {
                        "username": "codekorekhai",
                        "content": "[@satyamkumarskr](/satyamkumarskr) 14 is not an ugly number because it has 7 as factor but the problem said that only 2, 3, 5 will be the prime factor for each ugly number."
                    },
                    {
                        "username": "satyamkumarskr",
                        "content": "True . I got the same issue."
                    },
                    {
                        "username": "user6746E",
                        "content": "The 11th ugly number will not be 14 since the prime factor of 14 includes 7, but the question clearly states that the primes factor should be limited to 2, 3 or 5. Therefore 11th ugly number will be 15."
                    },
                    {
                        "username": "sazib204061",
                        "content": "I solve this problem in O(1) time complexity.\\n `class Solution {\\npublic:\\nvector<long long>ar = {1,2,3,4,5,6,8,9,10,12,15,16,18,20,24,25,27,30,32,36,40,45,48,50,54,60,64,72,75,80,81,90,96,100,108,120,125,128,135,144,150,160,162,180,192,200,216,225,240,243,250,256,270,288,300,320,324,360,375,384,400,405,432,450,480,486,500,512,540,576,600,625,640,648,675,720,729,750,768,800,810,864,900,960,972,1000,1024,1080,1125,1152,1200,1215,1250,1280,1296,1350,1440,1458,1500,1536,1600,1620,1728,1800,1875,1920,1944,2000,2025,2048,2160,2187,2250,2304,2400,2430,2500,2560,2592,2700,2880,2916,3000,3072,3125,3200,3240,3375,3456,3600,3645,3750,3840,3888,4000,4050,4096,4320,4374,4500,4608,4800,4860,5000,5120,5184,5400,5625,5760,5832,6000,6075,6144,6250,6400,6480,6561,6750,6912,7200,7290,7500,7680,7776,8000,8100,8192,8640,8748,9000,9216,9375,9600,9720,10000,10125,10240,10368,10800,10935,11250,11520,11664,12000,12150,12288,12500,12800,12960,13122,13500,13824,14400,14580,15000,15360,15552,15625,16000,16200,16384,16875,17280,17496,18000,18225,18432,18750,19200,19440,19683,20000,20250,20480,20736,21600,21870,22500,23040,23328,24000,24300,24576,25000,25600,25920,26244,27000,27648,28125,28800,29160,30000,30375,30720,31104,31250,32000,32400,32768,32805,33750,34560,34992,36000,36450,36864,37500,38400,38880,39366,40000,40500,40960,41472,43200,43740,45000,46080,46656,46875,48000,48600,49152,50000,50625,51200,51840,52488,54000,54675,55296,56250,57600,58320,59049,60000,60750,61440,62208,62500,64000,64800,65536,65610,67500,69120,69984,72000,72900,73728,75000,76800,77760,78125,78732,80000,81000,81920,82944,84375,86400,87480,90000,91125,92160,93312,93750,96000,97200,98304,98415,100000,101250,102400,103680,104976,108000,109350,110592,112500,115200,116640,118098,120000,121500,122880,124416,125000,128000,129600,131072,131220,135000,138240,139968,140625,144000,145800,147456,150000,151875,153600,155520,156250,157464,160000,162000,163840,164025,165888,168750,172800,174960,177147,180000,182250,184320,186624,187500,192000,194400,196608,196830,200000,202500,204800,207360,209952,216000,218700,221184,225000,230400,233280,234375,236196,240000,243000,245760,248832,250000,253125,256000,259200,262144,262440,270000,273375,276480,279936,281250,288000,291600,294912,295245,300000,303750,307200,311040,312500,314928,320000,324000,327680,328050,331776,337500,345600,349920,354294,360000,364500,368640,373248,375000,384000,388800,390625,393216,393660,400000,405000,409600,414720,419904,421875,432000,437400,442368,450000,455625,460800,466560,468750,472392,480000,486000,491520,492075,497664,500000,506250,512000,518400,524288,524880,531441,540000,546750,552960,559872,562500,576000,583200,589824,590490,600000,607500,614400,622080,625000,629856,640000,648000,655360,656100,663552,675000,691200,699840,703125,708588,720000,729000,737280,746496,750000,759375,768000,777600,781250,786432,787320,800000,810000,819200,820125,829440,839808,843750,864000,874800,884736,885735,900000,911250,921600,933120,937500,944784,\\n\\n960000,972000,983040,984150,995328,1000000,1012500,1024000,1036800,1048576,1049760,1062882,1080000,1093500,1105920,1119744,1125000,1152000,1166400,1171875,1179648,1180980,1200000,1215000,1228800,1244160,1250000,1259712,1265625,1280000,1296000,1310720,1312200,1327104,1350000,1366875,1382400,1399680,1406250,1417176,1440000,1458000,1474560,1476225,1492992,1500000,1518750,1536000,1555200,1562500,1572864,1574640,1594323,1600000,1620000,1638400,1640250,1658880,1679616,1687500,1728000,1749600,1769472,1771470,1800000,1822500,1843200,1866240,1875000,1889568,1920000,1944000,1953125,1966080,1968300,1990656,2000000,2025000,2048000,2073600,2097152,2099520,2109375,2125764,2160000,2187000,2211840,2239488,2250000,2278125,2304000,2332800,2343750,2359296,2361960,2400000,2430000,2457600,2460375,2488320,2500000,2519424,2531250,2560000,2592000,2621440,2624400,2654208,2657205,2700000,2733750,2764800,2799360,2812500,2834352,2880000,2916000,2949120,2952450,2985984,3000000,3037500,3072000,3110400,3125000,3145728,3149280,3188646,3200000,3240000,3276800,3280500,3317760,3359232,3375000,3456000,3499200,3515625,3538944,3542940,3600000,3645000,3686400,3732480,3750000,3779136,3796875,3840000,3888000,3906250,3932160,3936600,3981312,4000000,4050000,4096000,4100625,4147200,4194304,4199040,4218750,4251528,4320000,4374000,4423680,4428675,4478976,4500000,4556250,4608000,4665600,4687500,4718592,4723920,4782969,4800000,4860000,4915200,4920750,4976640,5000000,5038848,5062500,5120000,5184000,5242880,5248800,5308416,5314410,5400000,5467500,5529600,5598720,5625000,5668704,5760000,5832000,5859375,5898240,5904900,5971968,6000000,6075000,6144000,6220800,6250000,6291456,6298560,6328125,6377292,6400000,6480000,6553600,6561000,6635520,6718464,6750000,6834375,6912000,6998400,7031250,7077888,7085880,7200000,7290000,7372800,7381125,7464960,7500000,7558272,7593750,7680000,7776000,7812500,7864320,7873200,7962624,7971615,8000000,8100000,8192000,8201250,8294400,8388608,8398080,8437500,8503056,8640000,8748000,8847360,8857350,8957952,9000000,9112500,9216000,9331200,9375000,9437184,9447840,9565938,9600000,9720000,9765625,9830400,9841500,9953280,10000000,10077696,10125000,10240000,10368000,10485760,10497600,10546875,10616832,10628820,10800000,10935000,11059200,11197440,11250000,11337408,11390625,11520000,11664000,11718750,11796480,11809800,11943936,12000000,12150000,12288000,12301875,12441600,12500000,12582912,12597120,12656250,12754584,12800000,12960000,13107200,13122000,13271040,13286025,13436928,13500000,13668750,13824000,13996800,14062500,14155776,14171760,14348907,14400000,14580000,14745600,14762250,14929920,15000000,15116544,15187500,15360000,15552000,15625000,15728640,15746400,15925248,15943230,16000000,16200000,16384000,16402500,16588800,16777216,16796160,16875000,17006112,17280000,17496000,17578125,17694720,17714700,17915904,18000000,18225000,18432000,18662400,18750000,18874368,18895680,18984375,19131876,19200000,19440000,19531250,19660800,19683000,19906560,20000000,20155392,20250000,20480000,20503125,20736000,20971520,20995200,21093750,21233664,21257640,21600000,21870000,22118400,22143375,22394880,22500000,22674816,22781250,23040000,23328000,23437500,23592960,23619600,23887872,23914845,24000000,24300000,24576000,24603750,24883200,25000000,25165824,25194240,25312500,25509168,25600000,25920000,26214400,26244000,26542080,26572050,26873856,27000000,27337500,27648000,27993600,28125000,28311552,28343520,28697814,28800000,29160000,29296875,29491200,29524500,29859840,30000000,30233088,30375000,30720000,31104000,31250000,31457280,31492800,31640625,31850496,31886460,32000000,32400000,32768000,32805000,33177600,33554432,33592320,33750000,34012224,34171875,34560000,34992000,35156250,35389440,35429400,35831808,36000000,36450000,36864000,36905625,37324800,37500000,37748736,37791360,37968750,38263752,38400000,38880000,39062500,39321600,39366000,39813120,39858075,40000000,40310784,40500000,40960000,41006250,41472000,41943040,41990400,42187500,42467328,42515280,43046721,43200000,43740000,44236800,44286750,44789760,45000000,45349632,45562500,46080000,46656000,46875000,47185920,47239200,47775744,47829690,48000000,48600000,48828125,49152000,49207500,49766400,50000000,50331648,50388480,50625000,51018336,51200000,51840000,\\n\\n52428800,52488000,52734375,53084160,53144100,53747712,54000000,54675000,55296000,55987200,56250000,56623104,56687040,56953125,57395628,57600000,58320000,58593750,58982400,59049000,59719680,60000000,60466176,60750000,61440000,61509375,62208000,62500000,62914560,62985600,63281250,63700992,63772920,64000000,64800000,65536000,65610000,66355200,66430125,67108864,67184640,67500000,68024448,68343750,69120000,69984000,70312500,70778880,70858800,71663616,71744535,72000000,72900000,73728000,73811250,74649600,75000000,75497472,75582720,75937500,76527504,76800000,77760000,78125000,78643200,78732000,79626240,79716150,80000000,80621568,81000000,81920000,82012500,82944000,83886080,83980800,84375000,84934656,85030560,86093442,86400000,87480000,87890625,88473600,88573500,89579520,90000000,90699264,91125000,92160000,93312000,93750000,94371840,94478400,94921875,95551488,95659380,96000000,97200000,97656250,98304000,98415000,99532800,100000000,100663296,100776960,101250000,102036672,102400000,102515625,103680000,104857600,104976000,105468750,106168320,106288200,107495424,108000000,109350000,110592000,110716875,111974400,112500000,113246208,113374080,113906250,114791256,115200000,116640000,117187500,117964800,118098000,119439360,119574225,120000000,120932352,121500000,122880000,123018750,124416000,125000000,125829120,125971200,126562500,127401984,127545840,128000000,129140163,129600000,131072000,131220000,132710400,132860250,134217728,134369280,135000000,136048896,136687500,138240000,139968000,140625000,141557760,141717600,143327232,143489070,144000000,145800000,146484375,147456000,147622500,149299200,150000000,150994944,151165440,151875000,153055008,153600000,155520000,156250000,157286400,157464000,158203125,159252480,159432300,160000000,161243136,162000000,163840000,164025000,165888000,167772160,167961600,168750000,169869312,170061120,170859375,172186884,172800000,174960000,175781250,\\n\\n\\n176947200,177147000,179159040,180000000,181398528,182250000,184320000,184528125,186624000,187500000,188743680,188956800,189843750,191102976,191318760,192000000,194400000,195312500,196608000,196830000,199065600,199290375,200000000,201326592,201553920,202500000,204073344,204800000,205031250,207360000,209715200,209952000,210937500,212336640,212576400,214990848,215233605,216000000,218700000,221184000,221433750,223948800,225000000,226492416,226748160,227812500,229582512,230400000,233280000,234375000,235929600,236196000,238878720,239148450,240000000,241864704,243000000,244140625,245760000,246037500,248832000,250000000,251658240,251942400,253125000,254803968,255091680,256000000,258280326,259200000,262144000,262440000,263671875,265420800,265720500,268435456,268738560,270000000,272097792,273375000,276480000,279936000,281250000,283115520,283435200,284765625,286654464,286978140,288000000,291600000,292968750,294912000,295245000,298598400,300000000,301989888,302330880,303750000,306110016,307200000,307546875,311040000,312500000,314572800,314928000,316406250,318504960,318864600,320000000,322486272,324000000,327680000,328050000,331776000,332150625,335544320,335923200,337500000,339738624,340122240,341718750,344373768,345600000,349920000,351562500,353894400,354294000,358318080,358722675,360000000,362797056,364500000,368640000,369056250,373248000,375000000,377487360,377913600,379687500,382205952,382637520,384000000,387420489,388800000,390625000,393216000,393660000,398131200,398580750,400000000,402653184,403107840,405000000,408146688,409600000,410062500,414720000,419430400,419904000,421875000,424673280,425152800,429981696,430467210,432000000,437400000,439453125,442368000,442867500,447897600,450000000,452984832,453496320,455625000,459165024,460800000,466560000,468750000,471859200,472392000,474609375,477757440,478296900,480000000,483729408,486000000,488281250,491520000,492075000,497664000,500000000,503316480,503884800,506250000,509607936,510183360,512000000,512578125,516560652,518400000,\\n\\n524288000,524880000,527343750,530841600,531441000,536870912,537477120,540000000,544195584,546750000,552960000,553584375,559872000,562500000,566231040,566870400,569531250,573308928,573956280,576000000,583200000,585937500,589824000,590490000,597196800,597871125,600000000,603979776,604661760,607500000,612220032,614400000,615093750,622080000,625000000,629145600,629856000,632812500,637009920,637729200,640000000,644972544,645700815,648000000,655360000,656100000,663552000,664301250,671088640,671846400,675000000,679477248,680244480,683437500,688747536,691200000,699840000,703125000,707788800,708588000,716636160,717445350,720000000,725594112,729000000,732421875,737280000,738112500,746496000,750000000,754974720,755827200,759375000,764411904,765275040,768000000,774840978,777600000,781250000,786432000,787320000,791015625,796262400,797161500,800000000,805306368,806215680,810000000,816293376,819200000,820125000,829440000,838860800,839808000,843750000,849346560,850305600,854296875,859963392,860934420,864000000,874800000,878906250,884736000,885735000,895795200,900000000,905969664,906992640,911250000,918330048,921600000,922640625,933120000,937500000,943718400,944784000,949218750,955514880,956593800,960000000,967458816,972000000,976562500,983040000,984150000,995328000,996451875,1000000000,1006632960,1007769600,1012500000,1019215872,1020366720,1024000000,1025156250,1033121304,1036800000,1048576000,1049760000,1054687500,1061683200,1062882000,1073741824,1074954240,1076168025,1080000000,1088391168,1093500000,1105920000,1107168750,1119744000,1125000000,1132462080,1133740800,1139062500,1146617856,1147912560,1152000000,1162261467,1166400000,1171875000,1179648000,1180980000,1194393600,1195742250,1200000000,1207959552,1209323520,1215000000,1220703125,1224440064,1228800000,1230187500,1244160000,1250000000,1258291200,1259712000,1265625000,1274019840,1275458400,1280000000,1289945088,1291401630,1296000000,1310720000,1312200000,1318359375,1327104000,1328602500,1342177280,1343692800,1350000000,1358954496,1360488960,1366875000,1377495072,1382400000,1399680000,1406250000,1415577600,1417176000,1423828125,1433272320,1434890700,1440000000,1451188224,1458000000,1464843750,1474560000,1476225000,1492992000,1500000000,1509949440,1511654400,1518750000,1528823808,1530550080,1536000000,1537734375,1549681956,1555200000,1562500000,1572864000,1574640000,1582031250,1592524800,1594323000,1600000000,1610612736,1612431360,1620000000,1632586752,1638400000,1640250000,1658880000,1660753125,1677721600,1679616000,1687500000,1698693120,1700611200,1708593750,1719926784,1721868840,1728000000,1749600000,1757812500,1769472000,1771470000,1791590400,1793613375,1800000000,1811939328,1813985280,1822500000,1836660096,1843200000,1845281250,1866240000,1875000000,1887436800,1889568000,1898437500,1911029760,1913187600,1920000000,1934917632,1937102445,1944000000,1953125000,1966080000,1968300000,1990656000,1992903750,2000000000,2013265920,2015539200,2025000000,2038431744,2040733440,2048000000,2050312500,2066242608,2073600000,2097152000,2099520000,2109375000,2123366400,2125764000,2147483648,2149908480,2152336050,2160000000,2176782336,2187000000,2197265625,2211840000,2214337500,2239488000\\n\\n\\n};\\n\\n    int nthUglyNumber(int n) {\\n        return ar[n-1]; \\n    }\\n};`"
                    },
                    {
                        "username": "AasheeshLikePanner",
                        "content": "Bro stop this \\uD83D\\uDE2D\\uD83D\\uDE2D\\uD83D\\uDE2D"
                    },
                    {
                        "username": "Mayank_Shahria",
                        "content": "**I have solved this by two methods \\n1. Brute force**\\nBut it is giving a run time error\\n![image](https://assets.leetcode.com/users/images/ba539fa1-405b-4d9d-832a-5be83172edc4_1620554425.1931248.png)\\n**2. Dynamic Programing**\\n![image](https://assets.leetcode.com/users/images/3a90f09e-1a3c-465f-a8d6-b58bfc613ccf_1620554465.9711976.png)\\n\\n\\n"
                    },
                    {
                        "username": "aman_online67",
                        "content": "I also applied brute force but it gives TLE at some 500 test case. But logic wise it is correct what to do now"
                    },
                    {
                        "username": "Rohith6776",
                        "content": "If the prime factors are limited to 2,3,5 and we should not consider numbers like(14->2*7, 21->3*7) right?"
                    },
                    {
                        "username": "wtfcoder",
                        "content": "yup"
                    },
                    {
                        "username": "c_jain",
                        "content": "After reading top solutions here, I realized optimized solution is not a DP solution because I am not able to figure out optimal substructure and overlapping subproblem. I think it is kind of 3 pointer solution. Anyone like to clarify this?"
                    },
                    {
                        "username": "vikasboss6855",
                        "content": "https://leetcode.com/problems/ugly-number-ii/solutions/3704058/c-memoized-solution-using-dp-forcible-dp/"
                    },
                    {
                        "username": "Gismet",
                        "content": "Yeah, you are right. I don't also think there is an optimal substructure and overlapping subproblem. I think the reason why they called this DP solution is that we use the previously computed ugly numbers to find the next one. If you checked out the hint, they say you can get the next ugly number from a smaller ugly number by multiplying it by either 2, 3 or 5. So we start from the bottom and work our way up to the nth ugly number, in each iteration finding the next ugly number using a previous one. But to see the overlapping subproblems, one would write a recursive solution, also called top-down, and see if there are any subproblems that overlaps. But I couldn't come up with recursive top-down solution. Or maybe there is an optimal substructure that I fail to see. "
                    },
                    {
                        "username": "logical_thinker",
                        "content": "can someone throw light on the last test case which is n being empty the 596th test case. what is that and how do I go about it."
                    },
                    {
                        "username": "urmichm",
                        "content": "why is 1 ugly number?"
                    },
                    {
                        "username": "at218808",
                        "content": "1 is a factor of every number , so its more like a ugly number has only factors as 1,2,3 or 5"
                    },
                    {
                        "username": "QuasiRus",
                        "content": "It does not have any prime factor outside [2, 3, 5] list. 1 itself is not a prime number."
                    }
                ]
            },
            {
                "id": 1575246,
                "content": [
                    {
                        "username": "lcn",
                        "content": " 1. Actually, the input space is much smaller than expected if we insist an `int` range output. \\nWhen input `n` is greater than `1691`, the output overflows the `int` range.\\n 2. Another way to view this bound is that all ugly numbers must be in the form `2^a*3^b*5^c`. Since we have `log2(Integer.MAX_VALUE)=a<31`, `log3(Integer.MAX_VALUE)=b<20` and `log5(Integer.MAX_VALUE)=c<14`, the combination allowed is surely under `31*20*14~=8400`.\\n\\nSo ugly number is sparser than one would usually think, and please do take care of overflow."
                    },
                    {
                        "username": "chauhanprerna21",
                        "content": "I am not able to understand how is ugly numbers a DP problem?\\nWould be great if someone could help with it."
                    },
                    {
                        "username": "vikasboss6855",
                        "content": "https://leetcode.com/problems/ugly-number-ii/solutions/3704058/c-memoized-solution-using-dp-forcible-dp/\n```\nclass Solution {\npublic:\n    int nthUglyNumber(int n) {\n        vector<int> dp(n);\n        dp[0] = 1;\n        return nthUglyNumberRecursive(dp, n, 1, 0, 0, 0);\n    }\n\nprivate:\n    int nthUglyNumberRecursive(vector<int>& dp, int n, int i, int p1, int p2, int p3) {\n        if (i == n) {\n            return dp[n - 1];\n        }\n\n        int twoMultiple = dp[p1] * 2;\n        int threeMultiple = dp[p2] * 3;\n        int fiveMultiple = dp[p3] * 5;\n\n        dp[i] = min(twoMultiple, min(threeMultiple, fiveMultiple));\n\n        int nextP1 = (dp[i] == twoMultiple) ? p1 + 1 : p1;\n        int nextP2 = (dp[i] == threeMultiple) ? p2 + 1 : p2;\n        int nextP3 = (dp[i] == fiveMultiple) ? p3 + 1 : p3;\n\n        return nthUglyNumberRecursive(dp, n, i + 1, nextP1, nextP2, nextP3);\n    }\n};\n\n```"
                    },
                    {
                        "username": "divyanshuparg",
                        "content": "I have solved it using recursion and hashing."
                    },
                    {
                        "username": "anshulguleria",
                        "content": "In the example in problem statement 1 was being counted as ugly number. I am not able to understand how we concluded that.\\n\\nif 1 = 1 * 2^0 then this theory will be true for other numbers as well like 7  * 2^0."
                    },
                    {
                        "username": "Seabayley",
                        "content": "![image](https://assets.leetcode.com/users/images/fad90901-6c35-455e-8ff0-8160380ca46c_1597993223.2791212.png)\\n\\nAm I misunderstanding the problem? The 11th ugly numbers looks to me as though it should be 14?"
                    },
                    {
                        "username": "codekorekhai",
                        "content": "[@satyamkumarskr](/satyamkumarskr) 14 is not an ugly number because it has 7 as factor but the problem said that only 2, 3, 5 will be the prime factor for each ugly number."
                    },
                    {
                        "username": "satyamkumarskr",
                        "content": "True . I got the same issue."
                    },
                    {
                        "username": "user6746E",
                        "content": "The 11th ugly number will not be 14 since the prime factor of 14 includes 7, but the question clearly states that the primes factor should be limited to 2, 3 or 5. Therefore 11th ugly number will be 15."
                    },
                    {
                        "username": "sazib204061",
                        "content": "I solve this problem in O(1) time complexity.\\n `class Solution {\\npublic:\\nvector<long long>ar = {1,2,3,4,5,6,8,9,10,12,15,16,18,20,24,25,27,30,32,36,40,45,48,50,54,60,64,72,75,80,81,90,96,100,108,120,125,128,135,144,150,160,162,180,192,200,216,225,240,243,250,256,270,288,300,320,324,360,375,384,400,405,432,450,480,486,500,512,540,576,600,625,640,648,675,720,729,750,768,800,810,864,900,960,972,1000,1024,1080,1125,1152,1200,1215,1250,1280,1296,1350,1440,1458,1500,1536,1600,1620,1728,1800,1875,1920,1944,2000,2025,2048,2160,2187,2250,2304,2400,2430,2500,2560,2592,2700,2880,2916,3000,3072,3125,3200,3240,3375,3456,3600,3645,3750,3840,3888,4000,4050,4096,4320,4374,4500,4608,4800,4860,5000,5120,5184,5400,5625,5760,5832,6000,6075,6144,6250,6400,6480,6561,6750,6912,7200,7290,7500,7680,7776,8000,8100,8192,8640,8748,9000,9216,9375,9600,9720,10000,10125,10240,10368,10800,10935,11250,11520,11664,12000,12150,12288,12500,12800,12960,13122,13500,13824,14400,14580,15000,15360,15552,15625,16000,16200,16384,16875,17280,17496,18000,18225,18432,18750,19200,19440,19683,20000,20250,20480,20736,21600,21870,22500,23040,23328,24000,24300,24576,25000,25600,25920,26244,27000,27648,28125,28800,29160,30000,30375,30720,31104,31250,32000,32400,32768,32805,33750,34560,34992,36000,36450,36864,37500,38400,38880,39366,40000,40500,40960,41472,43200,43740,45000,46080,46656,46875,48000,48600,49152,50000,50625,51200,51840,52488,54000,54675,55296,56250,57600,58320,59049,60000,60750,61440,62208,62500,64000,64800,65536,65610,67500,69120,69984,72000,72900,73728,75000,76800,77760,78125,78732,80000,81000,81920,82944,84375,86400,87480,90000,91125,92160,93312,93750,96000,97200,98304,98415,100000,101250,102400,103680,104976,108000,109350,110592,112500,115200,116640,118098,120000,121500,122880,124416,125000,128000,129600,131072,131220,135000,138240,139968,140625,144000,145800,147456,150000,151875,153600,155520,156250,157464,160000,162000,163840,164025,165888,168750,172800,174960,177147,180000,182250,184320,186624,187500,192000,194400,196608,196830,200000,202500,204800,207360,209952,216000,218700,221184,225000,230400,233280,234375,236196,240000,243000,245760,248832,250000,253125,256000,259200,262144,262440,270000,273375,276480,279936,281250,288000,291600,294912,295245,300000,303750,307200,311040,312500,314928,320000,324000,327680,328050,331776,337500,345600,349920,354294,360000,364500,368640,373248,375000,384000,388800,390625,393216,393660,400000,405000,409600,414720,419904,421875,432000,437400,442368,450000,455625,460800,466560,468750,472392,480000,486000,491520,492075,497664,500000,506250,512000,518400,524288,524880,531441,540000,546750,552960,559872,562500,576000,583200,589824,590490,600000,607500,614400,622080,625000,629856,640000,648000,655360,656100,663552,675000,691200,699840,703125,708588,720000,729000,737280,746496,750000,759375,768000,777600,781250,786432,787320,800000,810000,819200,820125,829440,839808,843750,864000,874800,884736,885735,900000,911250,921600,933120,937500,944784,\\n\\n960000,972000,983040,984150,995328,1000000,1012500,1024000,1036800,1048576,1049760,1062882,1080000,1093500,1105920,1119744,1125000,1152000,1166400,1171875,1179648,1180980,1200000,1215000,1228800,1244160,1250000,1259712,1265625,1280000,1296000,1310720,1312200,1327104,1350000,1366875,1382400,1399680,1406250,1417176,1440000,1458000,1474560,1476225,1492992,1500000,1518750,1536000,1555200,1562500,1572864,1574640,1594323,1600000,1620000,1638400,1640250,1658880,1679616,1687500,1728000,1749600,1769472,1771470,1800000,1822500,1843200,1866240,1875000,1889568,1920000,1944000,1953125,1966080,1968300,1990656,2000000,2025000,2048000,2073600,2097152,2099520,2109375,2125764,2160000,2187000,2211840,2239488,2250000,2278125,2304000,2332800,2343750,2359296,2361960,2400000,2430000,2457600,2460375,2488320,2500000,2519424,2531250,2560000,2592000,2621440,2624400,2654208,2657205,2700000,2733750,2764800,2799360,2812500,2834352,2880000,2916000,2949120,2952450,2985984,3000000,3037500,3072000,3110400,3125000,3145728,3149280,3188646,3200000,3240000,3276800,3280500,3317760,3359232,3375000,3456000,3499200,3515625,3538944,3542940,3600000,3645000,3686400,3732480,3750000,3779136,3796875,3840000,3888000,3906250,3932160,3936600,3981312,4000000,4050000,4096000,4100625,4147200,4194304,4199040,4218750,4251528,4320000,4374000,4423680,4428675,4478976,4500000,4556250,4608000,4665600,4687500,4718592,4723920,4782969,4800000,4860000,4915200,4920750,4976640,5000000,5038848,5062500,5120000,5184000,5242880,5248800,5308416,5314410,5400000,5467500,5529600,5598720,5625000,5668704,5760000,5832000,5859375,5898240,5904900,5971968,6000000,6075000,6144000,6220800,6250000,6291456,6298560,6328125,6377292,6400000,6480000,6553600,6561000,6635520,6718464,6750000,6834375,6912000,6998400,7031250,7077888,7085880,7200000,7290000,7372800,7381125,7464960,7500000,7558272,7593750,7680000,7776000,7812500,7864320,7873200,7962624,7971615,8000000,8100000,8192000,8201250,8294400,8388608,8398080,8437500,8503056,8640000,8748000,8847360,8857350,8957952,9000000,9112500,9216000,9331200,9375000,9437184,9447840,9565938,9600000,9720000,9765625,9830400,9841500,9953280,10000000,10077696,10125000,10240000,10368000,10485760,10497600,10546875,10616832,10628820,10800000,10935000,11059200,11197440,11250000,11337408,11390625,11520000,11664000,11718750,11796480,11809800,11943936,12000000,12150000,12288000,12301875,12441600,12500000,12582912,12597120,12656250,12754584,12800000,12960000,13107200,13122000,13271040,13286025,13436928,13500000,13668750,13824000,13996800,14062500,14155776,14171760,14348907,14400000,14580000,14745600,14762250,14929920,15000000,15116544,15187500,15360000,15552000,15625000,15728640,15746400,15925248,15943230,16000000,16200000,16384000,16402500,16588800,16777216,16796160,16875000,17006112,17280000,17496000,17578125,17694720,17714700,17915904,18000000,18225000,18432000,18662400,18750000,18874368,18895680,18984375,19131876,19200000,19440000,19531250,19660800,19683000,19906560,20000000,20155392,20250000,20480000,20503125,20736000,20971520,20995200,21093750,21233664,21257640,21600000,21870000,22118400,22143375,22394880,22500000,22674816,22781250,23040000,23328000,23437500,23592960,23619600,23887872,23914845,24000000,24300000,24576000,24603750,24883200,25000000,25165824,25194240,25312500,25509168,25600000,25920000,26214400,26244000,26542080,26572050,26873856,27000000,27337500,27648000,27993600,28125000,28311552,28343520,28697814,28800000,29160000,29296875,29491200,29524500,29859840,30000000,30233088,30375000,30720000,31104000,31250000,31457280,31492800,31640625,31850496,31886460,32000000,32400000,32768000,32805000,33177600,33554432,33592320,33750000,34012224,34171875,34560000,34992000,35156250,35389440,35429400,35831808,36000000,36450000,36864000,36905625,37324800,37500000,37748736,37791360,37968750,38263752,38400000,38880000,39062500,39321600,39366000,39813120,39858075,40000000,40310784,40500000,40960000,41006250,41472000,41943040,41990400,42187500,42467328,42515280,43046721,43200000,43740000,44236800,44286750,44789760,45000000,45349632,45562500,46080000,46656000,46875000,47185920,47239200,47775744,47829690,48000000,48600000,48828125,49152000,49207500,49766400,50000000,50331648,50388480,50625000,51018336,51200000,51840000,\\n\\n52428800,52488000,52734375,53084160,53144100,53747712,54000000,54675000,55296000,55987200,56250000,56623104,56687040,56953125,57395628,57600000,58320000,58593750,58982400,59049000,59719680,60000000,60466176,60750000,61440000,61509375,62208000,62500000,62914560,62985600,63281250,63700992,63772920,64000000,64800000,65536000,65610000,66355200,66430125,67108864,67184640,67500000,68024448,68343750,69120000,69984000,70312500,70778880,70858800,71663616,71744535,72000000,72900000,73728000,73811250,74649600,75000000,75497472,75582720,75937500,76527504,76800000,77760000,78125000,78643200,78732000,79626240,79716150,80000000,80621568,81000000,81920000,82012500,82944000,83886080,83980800,84375000,84934656,85030560,86093442,86400000,87480000,87890625,88473600,88573500,89579520,90000000,90699264,91125000,92160000,93312000,93750000,94371840,94478400,94921875,95551488,95659380,96000000,97200000,97656250,98304000,98415000,99532800,100000000,100663296,100776960,101250000,102036672,102400000,102515625,103680000,104857600,104976000,105468750,106168320,106288200,107495424,108000000,109350000,110592000,110716875,111974400,112500000,113246208,113374080,113906250,114791256,115200000,116640000,117187500,117964800,118098000,119439360,119574225,120000000,120932352,121500000,122880000,123018750,124416000,125000000,125829120,125971200,126562500,127401984,127545840,128000000,129140163,129600000,131072000,131220000,132710400,132860250,134217728,134369280,135000000,136048896,136687500,138240000,139968000,140625000,141557760,141717600,143327232,143489070,144000000,145800000,146484375,147456000,147622500,149299200,150000000,150994944,151165440,151875000,153055008,153600000,155520000,156250000,157286400,157464000,158203125,159252480,159432300,160000000,161243136,162000000,163840000,164025000,165888000,167772160,167961600,168750000,169869312,170061120,170859375,172186884,172800000,174960000,175781250,\\n\\n\\n176947200,177147000,179159040,180000000,181398528,182250000,184320000,184528125,186624000,187500000,188743680,188956800,189843750,191102976,191318760,192000000,194400000,195312500,196608000,196830000,199065600,199290375,200000000,201326592,201553920,202500000,204073344,204800000,205031250,207360000,209715200,209952000,210937500,212336640,212576400,214990848,215233605,216000000,218700000,221184000,221433750,223948800,225000000,226492416,226748160,227812500,229582512,230400000,233280000,234375000,235929600,236196000,238878720,239148450,240000000,241864704,243000000,244140625,245760000,246037500,248832000,250000000,251658240,251942400,253125000,254803968,255091680,256000000,258280326,259200000,262144000,262440000,263671875,265420800,265720500,268435456,268738560,270000000,272097792,273375000,276480000,279936000,281250000,283115520,283435200,284765625,286654464,286978140,288000000,291600000,292968750,294912000,295245000,298598400,300000000,301989888,302330880,303750000,306110016,307200000,307546875,311040000,312500000,314572800,314928000,316406250,318504960,318864600,320000000,322486272,324000000,327680000,328050000,331776000,332150625,335544320,335923200,337500000,339738624,340122240,341718750,344373768,345600000,349920000,351562500,353894400,354294000,358318080,358722675,360000000,362797056,364500000,368640000,369056250,373248000,375000000,377487360,377913600,379687500,382205952,382637520,384000000,387420489,388800000,390625000,393216000,393660000,398131200,398580750,400000000,402653184,403107840,405000000,408146688,409600000,410062500,414720000,419430400,419904000,421875000,424673280,425152800,429981696,430467210,432000000,437400000,439453125,442368000,442867500,447897600,450000000,452984832,453496320,455625000,459165024,460800000,466560000,468750000,471859200,472392000,474609375,477757440,478296900,480000000,483729408,486000000,488281250,491520000,492075000,497664000,500000000,503316480,503884800,506250000,509607936,510183360,512000000,512578125,516560652,518400000,\\n\\n524288000,524880000,527343750,530841600,531441000,536870912,537477120,540000000,544195584,546750000,552960000,553584375,559872000,562500000,566231040,566870400,569531250,573308928,573956280,576000000,583200000,585937500,589824000,590490000,597196800,597871125,600000000,603979776,604661760,607500000,612220032,614400000,615093750,622080000,625000000,629145600,629856000,632812500,637009920,637729200,640000000,644972544,645700815,648000000,655360000,656100000,663552000,664301250,671088640,671846400,675000000,679477248,680244480,683437500,688747536,691200000,699840000,703125000,707788800,708588000,716636160,717445350,720000000,725594112,729000000,732421875,737280000,738112500,746496000,750000000,754974720,755827200,759375000,764411904,765275040,768000000,774840978,777600000,781250000,786432000,787320000,791015625,796262400,797161500,800000000,805306368,806215680,810000000,816293376,819200000,820125000,829440000,838860800,839808000,843750000,849346560,850305600,854296875,859963392,860934420,864000000,874800000,878906250,884736000,885735000,895795200,900000000,905969664,906992640,911250000,918330048,921600000,922640625,933120000,937500000,943718400,944784000,949218750,955514880,956593800,960000000,967458816,972000000,976562500,983040000,984150000,995328000,996451875,1000000000,1006632960,1007769600,1012500000,1019215872,1020366720,1024000000,1025156250,1033121304,1036800000,1048576000,1049760000,1054687500,1061683200,1062882000,1073741824,1074954240,1076168025,1080000000,1088391168,1093500000,1105920000,1107168750,1119744000,1125000000,1132462080,1133740800,1139062500,1146617856,1147912560,1152000000,1162261467,1166400000,1171875000,1179648000,1180980000,1194393600,1195742250,1200000000,1207959552,1209323520,1215000000,1220703125,1224440064,1228800000,1230187500,1244160000,1250000000,1258291200,1259712000,1265625000,1274019840,1275458400,1280000000,1289945088,1291401630,1296000000,1310720000,1312200000,1318359375,1327104000,1328602500,1342177280,1343692800,1350000000,1358954496,1360488960,1366875000,1377495072,1382400000,1399680000,1406250000,1415577600,1417176000,1423828125,1433272320,1434890700,1440000000,1451188224,1458000000,1464843750,1474560000,1476225000,1492992000,1500000000,1509949440,1511654400,1518750000,1528823808,1530550080,1536000000,1537734375,1549681956,1555200000,1562500000,1572864000,1574640000,1582031250,1592524800,1594323000,1600000000,1610612736,1612431360,1620000000,1632586752,1638400000,1640250000,1658880000,1660753125,1677721600,1679616000,1687500000,1698693120,1700611200,1708593750,1719926784,1721868840,1728000000,1749600000,1757812500,1769472000,1771470000,1791590400,1793613375,1800000000,1811939328,1813985280,1822500000,1836660096,1843200000,1845281250,1866240000,1875000000,1887436800,1889568000,1898437500,1911029760,1913187600,1920000000,1934917632,1937102445,1944000000,1953125000,1966080000,1968300000,1990656000,1992903750,2000000000,2013265920,2015539200,2025000000,2038431744,2040733440,2048000000,2050312500,2066242608,2073600000,2097152000,2099520000,2109375000,2123366400,2125764000,2147483648,2149908480,2152336050,2160000000,2176782336,2187000000,2197265625,2211840000,2214337500,2239488000\\n\\n\\n};\\n\\n    int nthUglyNumber(int n) {\\n        return ar[n-1]; \\n    }\\n};`"
                    },
                    {
                        "username": "AasheeshLikePanner",
                        "content": "Bro stop this \\uD83D\\uDE2D\\uD83D\\uDE2D\\uD83D\\uDE2D"
                    },
                    {
                        "username": "Mayank_Shahria",
                        "content": "**I have solved this by two methods \\n1. Brute force**\\nBut it is giving a run time error\\n![image](https://assets.leetcode.com/users/images/ba539fa1-405b-4d9d-832a-5be83172edc4_1620554425.1931248.png)\\n**2. Dynamic Programing**\\n![image](https://assets.leetcode.com/users/images/3a90f09e-1a3c-465f-a8d6-b58bfc613ccf_1620554465.9711976.png)\\n\\n\\n"
                    },
                    {
                        "username": "aman_online67",
                        "content": "I also applied brute force but it gives TLE at some 500 test case. But logic wise it is correct what to do now"
                    },
                    {
                        "username": "Rohith6776",
                        "content": "If the prime factors are limited to 2,3,5 and we should not consider numbers like(14->2*7, 21->3*7) right?"
                    },
                    {
                        "username": "wtfcoder",
                        "content": "yup"
                    },
                    {
                        "username": "c_jain",
                        "content": "After reading top solutions here, I realized optimized solution is not a DP solution because I am not able to figure out optimal substructure and overlapping subproblem. I think it is kind of 3 pointer solution. Anyone like to clarify this?"
                    },
                    {
                        "username": "vikasboss6855",
                        "content": "https://leetcode.com/problems/ugly-number-ii/solutions/3704058/c-memoized-solution-using-dp-forcible-dp/"
                    },
                    {
                        "username": "Gismet",
                        "content": "Yeah, you are right. I don't also think there is an optimal substructure and overlapping subproblem. I think the reason why they called this DP solution is that we use the previously computed ugly numbers to find the next one. If you checked out the hint, they say you can get the next ugly number from a smaller ugly number by multiplying it by either 2, 3 or 5. So we start from the bottom and work our way up to the nth ugly number, in each iteration finding the next ugly number using a previous one. But to see the overlapping subproblems, one would write a recursive solution, also called top-down, and see if there are any subproblems that overlaps. But I couldn't come up with recursive top-down solution. Or maybe there is an optimal substructure that I fail to see. "
                    },
                    {
                        "username": "logical_thinker",
                        "content": "can someone throw light on the last test case which is n being empty the 596th test case. what is that and how do I go about it."
                    },
                    {
                        "username": "urmichm",
                        "content": "why is 1 ugly number?"
                    },
                    {
                        "username": "at218808",
                        "content": "1 is a factor of every number , so its more like a ugly number has only factors as 1,2,3 or 5"
                    },
                    {
                        "username": "QuasiRus",
                        "content": "It does not have any prime factor outside [2, 3, 5] list. 1 itself is not a prime number."
                    }
                ]
            },
            {
                "id": 1795821,
                "content": [
                    {
                        "username": "lcn",
                        "content": " 1. Actually, the input space is much smaller than expected if we insist an `int` range output. \\nWhen input `n` is greater than `1691`, the output overflows the `int` range.\\n 2. Another way to view this bound is that all ugly numbers must be in the form `2^a*3^b*5^c`. Since we have `log2(Integer.MAX_VALUE)=a<31`, `log3(Integer.MAX_VALUE)=b<20` and `log5(Integer.MAX_VALUE)=c<14`, the combination allowed is surely under `31*20*14~=8400`.\\n\\nSo ugly number is sparser than one would usually think, and please do take care of overflow."
                    },
                    {
                        "username": "chauhanprerna21",
                        "content": "I am not able to understand how is ugly numbers a DP problem?\\nWould be great if someone could help with it."
                    },
                    {
                        "username": "vikasboss6855",
                        "content": "https://leetcode.com/problems/ugly-number-ii/solutions/3704058/c-memoized-solution-using-dp-forcible-dp/\n```\nclass Solution {\npublic:\n    int nthUglyNumber(int n) {\n        vector<int> dp(n);\n        dp[0] = 1;\n        return nthUglyNumberRecursive(dp, n, 1, 0, 0, 0);\n    }\n\nprivate:\n    int nthUglyNumberRecursive(vector<int>& dp, int n, int i, int p1, int p2, int p3) {\n        if (i == n) {\n            return dp[n - 1];\n        }\n\n        int twoMultiple = dp[p1] * 2;\n        int threeMultiple = dp[p2] * 3;\n        int fiveMultiple = dp[p3] * 5;\n\n        dp[i] = min(twoMultiple, min(threeMultiple, fiveMultiple));\n\n        int nextP1 = (dp[i] == twoMultiple) ? p1 + 1 : p1;\n        int nextP2 = (dp[i] == threeMultiple) ? p2 + 1 : p2;\n        int nextP3 = (dp[i] == fiveMultiple) ? p3 + 1 : p3;\n\n        return nthUglyNumberRecursive(dp, n, i + 1, nextP1, nextP2, nextP3);\n    }\n};\n\n```"
                    },
                    {
                        "username": "divyanshuparg",
                        "content": "I have solved it using recursion and hashing."
                    },
                    {
                        "username": "anshulguleria",
                        "content": "In the example in problem statement 1 was being counted as ugly number. I am not able to understand how we concluded that.\\n\\nif 1 = 1 * 2^0 then this theory will be true for other numbers as well like 7  * 2^0."
                    },
                    {
                        "username": "Seabayley",
                        "content": "![image](https://assets.leetcode.com/users/images/fad90901-6c35-455e-8ff0-8160380ca46c_1597993223.2791212.png)\\n\\nAm I misunderstanding the problem? The 11th ugly numbers looks to me as though it should be 14?"
                    },
                    {
                        "username": "codekorekhai",
                        "content": "[@satyamkumarskr](/satyamkumarskr) 14 is not an ugly number because it has 7 as factor but the problem said that only 2, 3, 5 will be the prime factor for each ugly number."
                    },
                    {
                        "username": "satyamkumarskr",
                        "content": "True . I got the same issue."
                    },
                    {
                        "username": "user6746E",
                        "content": "The 11th ugly number will not be 14 since the prime factor of 14 includes 7, but the question clearly states that the primes factor should be limited to 2, 3 or 5. Therefore 11th ugly number will be 15."
                    },
                    {
                        "username": "sazib204061",
                        "content": "I solve this problem in O(1) time complexity.\\n `class Solution {\\npublic:\\nvector<long long>ar = {1,2,3,4,5,6,8,9,10,12,15,16,18,20,24,25,27,30,32,36,40,45,48,50,54,60,64,72,75,80,81,90,96,100,108,120,125,128,135,144,150,160,162,180,192,200,216,225,240,243,250,256,270,288,300,320,324,360,375,384,400,405,432,450,480,486,500,512,540,576,600,625,640,648,675,720,729,750,768,800,810,864,900,960,972,1000,1024,1080,1125,1152,1200,1215,1250,1280,1296,1350,1440,1458,1500,1536,1600,1620,1728,1800,1875,1920,1944,2000,2025,2048,2160,2187,2250,2304,2400,2430,2500,2560,2592,2700,2880,2916,3000,3072,3125,3200,3240,3375,3456,3600,3645,3750,3840,3888,4000,4050,4096,4320,4374,4500,4608,4800,4860,5000,5120,5184,5400,5625,5760,5832,6000,6075,6144,6250,6400,6480,6561,6750,6912,7200,7290,7500,7680,7776,8000,8100,8192,8640,8748,9000,9216,9375,9600,9720,10000,10125,10240,10368,10800,10935,11250,11520,11664,12000,12150,12288,12500,12800,12960,13122,13500,13824,14400,14580,15000,15360,15552,15625,16000,16200,16384,16875,17280,17496,18000,18225,18432,18750,19200,19440,19683,20000,20250,20480,20736,21600,21870,22500,23040,23328,24000,24300,24576,25000,25600,25920,26244,27000,27648,28125,28800,29160,30000,30375,30720,31104,31250,32000,32400,32768,32805,33750,34560,34992,36000,36450,36864,37500,38400,38880,39366,40000,40500,40960,41472,43200,43740,45000,46080,46656,46875,48000,48600,49152,50000,50625,51200,51840,52488,54000,54675,55296,56250,57600,58320,59049,60000,60750,61440,62208,62500,64000,64800,65536,65610,67500,69120,69984,72000,72900,73728,75000,76800,77760,78125,78732,80000,81000,81920,82944,84375,86400,87480,90000,91125,92160,93312,93750,96000,97200,98304,98415,100000,101250,102400,103680,104976,108000,109350,110592,112500,115200,116640,118098,120000,121500,122880,124416,125000,128000,129600,131072,131220,135000,138240,139968,140625,144000,145800,147456,150000,151875,153600,155520,156250,157464,160000,162000,163840,164025,165888,168750,172800,174960,177147,180000,182250,184320,186624,187500,192000,194400,196608,196830,200000,202500,204800,207360,209952,216000,218700,221184,225000,230400,233280,234375,236196,240000,243000,245760,248832,250000,253125,256000,259200,262144,262440,270000,273375,276480,279936,281250,288000,291600,294912,295245,300000,303750,307200,311040,312500,314928,320000,324000,327680,328050,331776,337500,345600,349920,354294,360000,364500,368640,373248,375000,384000,388800,390625,393216,393660,400000,405000,409600,414720,419904,421875,432000,437400,442368,450000,455625,460800,466560,468750,472392,480000,486000,491520,492075,497664,500000,506250,512000,518400,524288,524880,531441,540000,546750,552960,559872,562500,576000,583200,589824,590490,600000,607500,614400,622080,625000,629856,640000,648000,655360,656100,663552,675000,691200,699840,703125,708588,720000,729000,737280,746496,750000,759375,768000,777600,781250,786432,787320,800000,810000,819200,820125,829440,839808,843750,864000,874800,884736,885735,900000,911250,921600,933120,937500,944784,\\n\\n960000,972000,983040,984150,995328,1000000,1012500,1024000,1036800,1048576,1049760,1062882,1080000,1093500,1105920,1119744,1125000,1152000,1166400,1171875,1179648,1180980,1200000,1215000,1228800,1244160,1250000,1259712,1265625,1280000,1296000,1310720,1312200,1327104,1350000,1366875,1382400,1399680,1406250,1417176,1440000,1458000,1474560,1476225,1492992,1500000,1518750,1536000,1555200,1562500,1572864,1574640,1594323,1600000,1620000,1638400,1640250,1658880,1679616,1687500,1728000,1749600,1769472,1771470,1800000,1822500,1843200,1866240,1875000,1889568,1920000,1944000,1953125,1966080,1968300,1990656,2000000,2025000,2048000,2073600,2097152,2099520,2109375,2125764,2160000,2187000,2211840,2239488,2250000,2278125,2304000,2332800,2343750,2359296,2361960,2400000,2430000,2457600,2460375,2488320,2500000,2519424,2531250,2560000,2592000,2621440,2624400,2654208,2657205,2700000,2733750,2764800,2799360,2812500,2834352,2880000,2916000,2949120,2952450,2985984,3000000,3037500,3072000,3110400,3125000,3145728,3149280,3188646,3200000,3240000,3276800,3280500,3317760,3359232,3375000,3456000,3499200,3515625,3538944,3542940,3600000,3645000,3686400,3732480,3750000,3779136,3796875,3840000,3888000,3906250,3932160,3936600,3981312,4000000,4050000,4096000,4100625,4147200,4194304,4199040,4218750,4251528,4320000,4374000,4423680,4428675,4478976,4500000,4556250,4608000,4665600,4687500,4718592,4723920,4782969,4800000,4860000,4915200,4920750,4976640,5000000,5038848,5062500,5120000,5184000,5242880,5248800,5308416,5314410,5400000,5467500,5529600,5598720,5625000,5668704,5760000,5832000,5859375,5898240,5904900,5971968,6000000,6075000,6144000,6220800,6250000,6291456,6298560,6328125,6377292,6400000,6480000,6553600,6561000,6635520,6718464,6750000,6834375,6912000,6998400,7031250,7077888,7085880,7200000,7290000,7372800,7381125,7464960,7500000,7558272,7593750,7680000,7776000,7812500,7864320,7873200,7962624,7971615,8000000,8100000,8192000,8201250,8294400,8388608,8398080,8437500,8503056,8640000,8748000,8847360,8857350,8957952,9000000,9112500,9216000,9331200,9375000,9437184,9447840,9565938,9600000,9720000,9765625,9830400,9841500,9953280,10000000,10077696,10125000,10240000,10368000,10485760,10497600,10546875,10616832,10628820,10800000,10935000,11059200,11197440,11250000,11337408,11390625,11520000,11664000,11718750,11796480,11809800,11943936,12000000,12150000,12288000,12301875,12441600,12500000,12582912,12597120,12656250,12754584,12800000,12960000,13107200,13122000,13271040,13286025,13436928,13500000,13668750,13824000,13996800,14062500,14155776,14171760,14348907,14400000,14580000,14745600,14762250,14929920,15000000,15116544,15187500,15360000,15552000,15625000,15728640,15746400,15925248,15943230,16000000,16200000,16384000,16402500,16588800,16777216,16796160,16875000,17006112,17280000,17496000,17578125,17694720,17714700,17915904,18000000,18225000,18432000,18662400,18750000,18874368,18895680,18984375,19131876,19200000,19440000,19531250,19660800,19683000,19906560,20000000,20155392,20250000,20480000,20503125,20736000,20971520,20995200,21093750,21233664,21257640,21600000,21870000,22118400,22143375,22394880,22500000,22674816,22781250,23040000,23328000,23437500,23592960,23619600,23887872,23914845,24000000,24300000,24576000,24603750,24883200,25000000,25165824,25194240,25312500,25509168,25600000,25920000,26214400,26244000,26542080,26572050,26873856,27000000,27337500,27648000,27993600,28125000,28311552,28343520,28697814,28800000,29160000,29296875,29491200,29524500,29859840,30000000,30233088,30375000,30720000,31104000,31250000,31457280,31492800,31640625,31850496,31886460,32000000,32400000,32768000,32805000,33177600,33554432,33592320,33750000,34012224,34171875,34560000,34992000,35156250,35389440,35429400,35831808,36000000,36450000,36864000,36905625,37324800,37500000,37748736,37791360,37968750,38263752,38400000,38880000,39062500,39321600,39366000,39813120,39858075,40000000,40310784,40500000,40960000,41006250,41472000,41943040,41990400,42187500,42467328,42515280,43046721,43200000,43740000,44236800,44286750,44789760,45000000,45349632,45562500,46080000,46656000,46875000,47185920,47239200,47775744,47829690,48000000,48600000,48828125,49152000,49207500,49766400,50000000,50331648,50388480,50625000,51018336,51200000,51840000,\\n\\n52428800,52488000,52734375,53084160,53144100,53747712,54000000,54675000,55296000,55987200,56250000,56623104,56687040,56953125,57395628,57600000,58320000,58593750,58982400,59049000,59719680,60000000,60466176,60750000,61440000,61509375,62208000,62500000,62914560,62985600,63281250,63700992,63772920,64000000,64800000,65536000,65610000,66355200,66430125,67108864,67184640,67500000,68024448,68343750,69120000,69984000,70312500,70778880,70858800,71663616,71744535,72000000,72900000,73728000,73811250,74649600,75000000,75497472,75582720,75937500,76527504,76800000,77760000,78125000,78643200,78732000,79626240,79716150,80000000,80621568,81000000,81920000,82012500,82944000,83886080,83980800,84375000,84934656,85030560,86093442,86400000,87480000,87890625,88473600,88573500,89579520,90000000,90699264,91125000,92160000,93312000,93750000,94371840,94478400,94921875,95551488,95659380,96000000,97200000,97656250,98304000,98415000,99532800,100000000,100663296,100776960,101250000,102036672,102400000,102515625,103680000,104857600,104976000,105468750,106168320,106288200,107495424,108000000,109350000,110592000,110716875,111974400,112500000,113246208,113374080,113906250,114791256,115200000,116640000,117187500,117964800,118098000,119439360,119574225,120000000,120932352,121500000,122880000,123018750,124416000,125000000,125829120,125971200,126562500,127401984,127545840,128000000,129140163,129600000,131072000,131220000,132710400,132860250,134217728,134369280,135000000,136048896,136687500,138240000,139968000,140625000,141557760,141717600,143327232,143489070,144000000,145800000,146484375,147456000,147622500,149299200,150000000,150994944,151165440,151875000,153055008,153600000,155520000,156250000,157286400,157464000,158203125,159252480,159432300,160000000,161243136,162000000,163840000,164025000,165888000,167772160,167961600,168750000,169869312,170061120,170859375,172186884,172800000,174960000,175781250,\\n\\n\\n176947200,177147000,179159040,180000000,181398528,182250000,184320000,184528125,186624000,187500000,188743680,188956800,189843750,191102976,191318760,192000000,194400000,195312500,196608000,196830000,199065600,199290375,200000000,201326592,201553920,202500000,204073344,204800000,205031250,207360000,209715200,209952000,210937500,212336640,212576400,214990848,215233605,216000000,218700000,221184000,221433750,223948800,225000000,226492416,226748160,227812500,229582512,230400000,233280000,234375000,235929600,236196000,238878720,239148450,240000000,241864704,243000000,244140625,245760000,246037500,248832000,250000000,251658240,251942400,253125000,254803968,255091680,256000000,258280326,259200000,262144000,262440000,263671875,265420800,265720500,268435456,268738560,270000000,272097792,273375000,276480000,279936000,281250000,283115520,283435200,284765625,286654464,286978140,288000000,291600000,292968750,294912000,295245000,298598400,300000000,301989888,302330880,303750000,306110016,307200000,307546875,311040000,312500000,314572800,314928000,316406250,318504960,318864600,320000000,322486272,324000000,327680000,328050000,331776000,332150625,335544320,335923200,337500000,339738624,340122240,341718750,344373768,345600000,349920000,351562500,353894400,354294000,358318080,358722675,360000000,362797056,364500000,368640000,369056250,373248000,375000000,377487360,377913600,379687500,382205952,382637520,384000000,387420489,388800000,390625000,393216000,393660000,398131200,398580750,400000000,402653184,403107840,405000000,408146688,409600000,410062500,414720000,419430400,419904000,421875000,424673280,425152800,429981696,430467210,432000000,437400000,439453125,442368000,442867500,447897600,450000000,452984832,453496320,455625000,459165024,460800000,466560000,468750000,471859200,472392000,474609375,477757440,478296900,480000000,483729408,486000000,488281250,491520000,492075000,497664000,500000000,503316480,503884800,506250000,509607936,510183360,512000000,512578125,516560652,518400000,\\n\\n524288000,524880000,527343750,530841600,531441000,536870912,537477120,540000000,544195584,546750000,552960000,553584375,559872000,562500000,566231040,566870400,569531250,573308928,573956280,576000000,583200000,585937500,589824000,590490000,597196800,597871125,600000000,603979776,604661760,607500000,612220032,614400000,615093750,622080000,625000000,629145600,629856000,632812500,637009920,637729200,640000000,644972544,645700815,648000000,655360000,656100000,663552000,664301250,671088640,671846400,675000000,679477248,680244480,683437500,688747536,691200000,699840000,703125000,707788800,708588000,716636160,717445350,720000000,725594112,729000000,732421875,737280000,738112500,746496000,750000000,754974720,755827200,759375000,764411904,765275040,768000000,774840978,777600000,781250000,786432000,787320000,791015625,796262400,797161500,800000000,805306368,806215680,810000000,816293376,819200000,820125000,829440000,838860800,839808000,843750000,849346560,850305600,854296875,859963392,860934420,864000000,874800000,878906250,884736000,885735000,895795200,900000000,905969664,906992640,911250000,918330048,921600000,922640625,933120000,937500000,943718400,944784000,949218750,955514880,956593800,960000000,967458816,972000000,976562500,983040000,984150000,995328000,996451875,1000000000,1006632960,1007769600,1012500000,1019215872,1020366720,1024000000,1025156250,1033121304,1036800000,1048576000,1049760000,1054687500,1061683200,1062882000,1073741824,1074954240,1076168025,1080000000,1088391168,1093500000,1105920000,1107168750,1119744000,1125000000,1132462080,1133740800,1139062500,1146617856,1147912560,1152000000,1162261467,1166400000,1171875000,1179648000,1180980000,1194393600,1195742250,1200000000,1207959552,1209323520,1215000000,1220703125,1224440064,1228800000,1230187500,1244160000,1250000000,1258291200,1259712000,1265625000,1274019840,1275458400,1280000000,1289945088,1291401630,1296000000,1310720000,1312200000,1318359375,1327104000,1328602500,1342177280,1343692800,1350000000,1358954496,1360488960,1366875000,1377495072,1382400000,1399680000,1406250000,1415577600,1417176000,1423828125,1433272320,1434890700,1440000000,1451188224,1458000000,1464843750,1474560000,1476225000,1492992000,1500000000,1509949440,1511654400,1518750000,1528823808,1530550080,1536000000,1537734375,1549681956,1555200000,1562500000,1572864000,1574640000,1582031250,1592524800,1594323000,1600000000,1610612736,1612431360,1620000000,1632586752,1638400000,1640250000,1658880000,1660753125,1677721600,1679616000,1687500000,1698693120,1700611200,1708593750,1719926784,1721868840,1728000000,1749600000,1757812500,1769472000,1771470000,1791590400,1793613375,1800000000,1811939328,1813985280,1822500000,1836660096,1843200000,1845281250,1866240000,1875000000,1887436800,1889568000,1898437500,1911029760,1913187600,1920000000,1934917632,1937102445,1944000000,1953125000,1966080000,1968300000,1990656000,1992903750,2000000000,2013265920,2015539200,2025000000,2038431744,2040733440,2048000000,2050312500,2066242608,2073600000,2097152000,2099520000,2109375000,2123366400,2125764000,2147483648,2149908480,2152336050,2160000000,2176782336,2187000000,2197265625,2211840000,2214337500,2239488000\\n\\n\\n};\\n\\n    int nthUglyNumber(int n) {\\n        return ar[n-1]; \\n    }\\n};`"
                    },
                    {
                        "username": "AasheeshLikePanner",
                        "content": "Bro stop this \\uD83D\\uDE2D\\uD83D\\uDE2D\\uD83D\\uDE2D"
                    },
                    {
                        "username": "Mayank_Shahria",
                        "content": "**I have solved this by two methods \\n1. Brute force**\\nBut it is giving a run time error\\n![image](https://assets.leetcode.com/users/images/ba539fa1-405b-4d9d-832a-5be83172edc4_1620554425.1931248.png)\\n**2. Dynamic Programing**\\n![image](https://assets.leetcode.com/users/images/3a90f09e-1a3c-465f-a8d6-b58bfc613ccf_1620554465.9711976.png)\\n\\n\\n"
                    },
                    {
                        "username": "aman_online67",
                        "content": "I also applied brute force but it gives TLE at some 500 test case. But logic wise it is correct what to do now"
                    },
                    {
                        "username": "Rohith6776",
                        "content": "If the prime factors are limited to 2,3,5 and we should not consider numbers like(14->2*7, 21->3*7) right?"
                    },
                    {
                        "username": "wtfcoder",
                        "content": "yup"
                    },
                    {
                        "username": "c_jain",
                        "content": "After reading top solutions here, I realized optimized solution is not a DP solution because I am not able to figure out optimal substructure and overlapping subproblem. I think it is kind of 3 pointer solution. Anyone like to clarify this?"
                    },
                    {
                        "username": "vikasboss6855",
                        "content": "https://leetcode.com/problems/ugly-number-ii/solutions/3704058/c-memoized-solution-using-dp-forcible-dp/"
                    },
                    {
                        "username": "Gismet",
                        "content": "Yeah, you are right. I don't also think there is an optimal substructure and overlapping subproblem. I think the reason why they called this DP solution is that we use the previously computed ugly numbers to find the next one. If you checked out the hint, they say you can get the next ugly number from a smaller ugly number by multiplying it by either 2, 3 or 5. So we start from the bottom and work our way up to the nth ugly number, in each iteration finding the next ugly number using a previous one. But to see the overlapping subproblems, one would write a recursive solution, also called top-down, and see if there are any subproblems that overlaps. But I couldn't come up with recursive top-down solution. Or maybe there is an optimal substructure that I fail to see. "
                    },
                    {
                        "username": "logical_thinker",
                        "content": "can someone throw light on the last test case which is n being empty the 596th test case. what is that and how do I go about it."
                    },
                    {
                        "username": "urmichm",
                        "content": "why is 1 ugly number?"
                    },
                    {
                        "username": "at218808",
                        "content": "1 is a factor of every number , so its more like a ugly number has only factors as 1,2,3 or 5"
                    },
                    {
                        "username": "QuasiRus",
                        "content": "It does not have any prime factor outside [2, 3, 5] list. 1 itself is not a prime number."
                    }
                ]
            },
            {
                "id": 1573274,
                "content": [
                    {
                        "username": "lcn",
                        "content": " 1. Actually, the input space is much smaller than expected if we insist an `int` range output. \\nWhen input `n` is greater than `1691`, the output overflows the `int` range.\\n 2. Another way to view this bound is that all ugly numbers must be in the form `2^a*3^b*5^c`. Since we have `log2(Integer.MAX_VALUE)=a<31`, `log3(Integer.MAX_VALUE)=b<20` and `log5(Integer.MAX_VALUE)=c<14`, the combination allowed is surely under `31*20*14~=8400`.\\n\\nSo ugly number is sparser than one would usually think, and please do take care of overflow."
                    },
                    {
                        "username": "chauhanprerna21",
                        "content": "I am not able to understand how is ugly numbers a DP problem?\\nWould be great if someone could help with it."
                    },
                    {
                        "username": "vikasboss6855",
                        "content": "https://leetcode.com/problems/ugly-number-ii/solutions/3704058/c-memoized-solution-using-dp-forcible-dp/\n```\nclass Solution {\npublic:\n    int nthUglyNumber(int n) {\n        vector<int> dp(n);\n        dp[0] = 1;\n        return nthUglyNumberRecursive(dp, n, 1, 0, 0, 0);\n    }\n\nprivate:\n    int nthUglyNumberRecursive(vector<int>& dp, int n, int i, int p1, int p2, int p3) {\n        if (i == n) {\n            return dp[n - 1];\n        }\n\n        int twoMultiple = dp[p1] * 2;\n        int threeMultiple = dp[p2] * 3;\n        int fiveMultiple = dp[p3] * 5;\n\n        dp[i] = min(twoMultiple, min(threeMultiple, fiveMultiple));\n\n        int nextP1 = (dp[i] == twoMultiple) ? p1 + 1 : p1;\n        int nextP2 = (dp[i] == threeMultiple) ? p2 + 1 : p2;\n        int nextP3 = (dp[i] == fiveMultiple) ? p3 + 1 : p3;\n\n        return nthUglyNumberRecursive(dp, n, i + 1, nextP1, nextP2, nextP3);\n    }\n};\n\n```"
                    },
                    {
                        "username": "divyanshuparg",
                        "content": "I have solved it using recursion and hashing."
                    },
                    {
                        "username": "anshulguleria",
                        "content": "In the example in problem statement 1 was being counted as ugly number. I am not able to understand how we concluded that.\\n\\nif 1 = 1 * 2^0 then this theory will be true for other numbers as well like 7  * 2^0."
                    },
                    {
                        "username": "Seabayley",
                        "content": "![image](https://assets.leetcode.com/users/images/fad90901-6c35-455e-8ff0-8160380ca46c_1597993223.2791212.png)\\n\\nAm I misunderstanding the problem? The 11th ugly numbers looks to me as though it should be 14?"
                    },
                    {
                        "username": "codekorekhai",
                        "content": "[@satyamkumarskr](/satyamkumarskr) 14 is not an ugly number because it has 7 as factor but the problem said that only 2, 3, 5 will be the prime factor for each ugly number."
                    },
                    {
                        "username": "satyamkumarskr",
                        "content": "True . I got the same issue."
                    },
                    {
                        "username": "user6746E",
                        "content": "The 11th ugly number will not be 14 since the prime factor of 14 includes 7, but the question clearly states that the primes factor should be limited to 2, 3 or 5. Therefore 11th ugly number will be 15."
                    },
                    {
                        "username": "sazib204061",
                        "content": "I solve this problem in O(1) time complexity.\\n `class Solution {\\npublic:\\nvector<long long>ar = {1,2,3,4,5,6,8,9,10,12,15,16,18,20,24,25,27,30,32,36,40,45,48,50,54,60,64,72,75,80,81,90,96,100,108,120,125,128,135,144,150,160,162,180,192,200,216,225,240,243,250,256,270,288,300,320,324,360,375,384,400,405,432,450,480,486,500,512,540,576,600,625,640,648,675,720,729,750,768,800,810,864,900,960,972,1000,1024,1080,1125,1152,1200,1215,1250,1280,1296,1350,1440,1458,1500,1536,1600,1620,1728,1800,1875,1920,1944,2000,2025,2048,2160,2187,2250,2304,2400,2430,2500,2560,2592,2700,2880,2916,3000,3072,3125,3200,3240,3375,3456,3600,3645,3750,3840,3888,4000,4050,4096,4320,4374,4500,4608,4800,4860,5000,5120,5184,5400,5625,5760,5832,6000,6075,6144,6250,6400,6480,6561,6750,6912,7200,7290,7500,7680,7776,8000,8100,8192,8640,8748,9000,9216,9375,9600,9720,10000,10125,10240,10368,10800,10935,11250,11520,11664,12000,12150,12288,12500,12800,12960,13122,13500,13824,14400,14580,15000,15360,15552,15625,16000,16200,16384,16875,17280,17496,18000,18225,18432,18750,19200,19440,19683,20000,20250,20480,20736,21600,21870,22500,23040,23328,24000,24300,24576,25000,25600,25920,26244,27000,27648,28125,28800,29160,30000,30375,30720,31104,31250,32000,32400,32768,32805,33750,34560,34992,36000,36450,36864,37500,38400,38880,39366,40000,40500,40960,41472,43200,43740,45000,46080,46656,46875,48000,48600,49152,50000,50625,51200,51840,52488,54000,54675,55296,56250,57600,58320,59049,60000,60750,61440,62208,62500,64000,64800,65536,65610,67500,69120,69984,72000,72900,73728,75000,76800,77760,78125,78732,80000,81000,81920,82944,84375,86400,87480,90000,91125,92160,93312,93750,96000,97200,98304,98415,100000,101250,102400,103680,104976,108000,109350,110592,112500,115200,116640,118098,120000,121500,122880,124416,125000,128000,129600,131072,131220,135000,138240,139968,140625,144000,145800,147456,150000,151875,153600,155520,156250,157464,160000,162000,163840,164025,165888,168750,172800,174960,177147,180000,182250,184320,186624,187500,192000,194400,196608,196830,200000,202500,204800,207360,209952,216000,218700,221184,225000,230400,233280,234375,236196,240000,243000,245760,248832,250000,253125,256000,259200,262144,262440,270000,273375,276480,279936,281250,288000,291600,294912,295245,300000,303750,307200,311040,312500,314928,320000,324000,327680,328050,331776,337500,345600,349920,354294,360000,364500,368640,373248,375000,384000,388800,390625,393216,393660,400000,405000,409600,414720,419904,421875,432000,437400,442368,450000,455625,460800,466560,468750,472392,480000,486000,491520,492075,497664,500000,506250,512000,518400,524288,524880,531441,540000,546750,552960,559872,562500,576000,583200,589824,590490,600000,607500,614400,622080,625000,629856,640000,648000,655360,656100,663552,675000,691200,699840,703125,708588,720000,729000,737280,746496,750000,759375,768000,777600,781250,786432,787320,800000,810000,819200,820125,829440,839808,843750,864000,874800,884736,885735,900000,911250,921600,933120,937500,944784,\\n\\n960000,972000,983040,984150,995328,1000000,1012500,1024000,1036800,1048576,1049760,1062882,1080000,1093500,1105920,1119744,1125000,1152000,1166400,1171875,1179648,1180980,1200000,1215000,1228800,1244160,1250000,1259712,1265625,1280000,1296000,1310720,1312200,1327104,1350000,1366875,1382400,1399680,1406250,1417176,1440000,1458000,1474560,1476225,1492992,1500000,1518750,1536000,1555200,1562500,1572864,1574640,1594323,1600000,1620000,1638400,1640250,1658880,1679616,1687500,1728000,1749600,1769472,1771470,1800000,1822500,1843200,1866240,1875000,1889568,1920000,1944000,1953125,1966080,1968300,1990656,2000000,2025000,2048000,2073600,2097152,2099520,2109375,2125764,2160000,2187000,2211840,2239488,2250000,2278125,2304000,2332800,2343750,2359296,2361960,2400000,2430000,2457600,2460375,2488320,2500000,2519424,2531250,2560000,2592000,2621440,2624400,2654208,2657205,2700000,2733750,2764800,2799360,2812500,2834352,2880000,2916000,2949120,2952450,2985984,3000000,3037500,3072000,3110400,3125000,3145728,3149280,3188646,3200000,3240000,3276800,3280500,3317760,3359232,3375000,3456000,3499200,3515625,3538944,3542940,3600000,3645000,3686400,3732480,3750000,3779136,3796875,3840000,3888000,3906250,3932160,3936600,3981312,4000000,4050000,4096000,4100625,4147200,4194304,4199040,4218750,4251528,4320000,4374000,4423680,4428675,4478976,4500000,4556250,4608000,4665600,4687500,4718592,4723920,4782969,4800000,4860000,4915200,4920750,4976640,5000000,5038848,5062500,5120000,5184000,5242880,5248800,5308416,5314410,5400000,5467500,5529600,5598720,5625000,5668704,5760000,5832000,5859375,5898240,5904900,5971968,6000000,6075000,6144000,6220800,6250000,6291456,6298560,6328125,6377292,6400000,6480000,6553600,6561000,6635520,6718464,6750000,6834375,6912000,6998400,7031250,7077888,7085880,7200000,7290000,7372800,7381125,7464960,7500000,7558272,7593750,7680000,7776000,7812500,7864320,7873200,7962624,7971615,8000000,8100000,8192000,8201250,8294400,8388608,8398080,8437500,8503056,8640000,8748000,8847360,8857350,8957952,9000000,9112500,9216000,9331200,9375000,9437184,9447840,9565938,9600000,9720000,9765625,9830400,9841500,9953280,10000000,10077696,10125000,10240000,10368000,10485760,10497600,10546875,10616832,10628820,10800000,10935000,11059200,11197440,11250000,11337408,11390625,11520000,11664000,11718750,11796480,11809800,11943936,12000000,12150000,12288000,12301875,12441600,12500000,12582912,12597120,12656250,12754584,12800000,12960000,13107200,13122000,13271040,13286025,13436928,13500000,13668750,13824000,13996800,14062500,14155776,14171760,14348907,14400000,14580000,14745600,14762250,14929920,15000000,15116544,15187500,15360000,15552000,15625000,15728640,15746400,15925248,15943230,16000000,16200000,16384000,16402500,16588800,16777216,16796160,16875000,17006112,17280000,17496000,17578125,17694720,17714700,17915904,18000000,18225000,18432000,18662400,18750000,18874368,18895680,18984375,19131876,19200000,19440000,19531250,19660800,19683000,19906560,20000000,20155392,20250000,20480000,20503125,20736000,20971520,20995200,21093750,21233664,21257640,21600000,21870000,22118400,22143375,22394880,22500000,22674816,22781250,23040000,23328000,23437500,23592960,23619600,23887872,23914845,24000000,24300000,24576000,24603750,24883200,25000000,25165824,25194240,25312500,25509168,25600000,25920000,26214400,26244000,26542080,26572050,26873856,27000000,27337500,27648000,27993600,28125000,28311552,28343520,28697814,28800000,29160000,29296875,29491200,29524500,29859840,30000000,30233088,30375000,30720000,31104000,31250000,31457280,31492800,31640625,31850496,31886460,32000000,32400000,32768000,32805000,33177600,33554432,33592320,33750000,34012224,34171875,34560000,34992000,35156250,35389440,35429400,35831808,36000000,36450000,36864000,36905625,37324800,37500000,37748736,37791360,37968750,38263752,38400000,38880000,39062500,39321600,39366000,39813120,39858075,40000000,40310784,40500000,40960000,41006250,41472000,41943040,41990400,42187500,42467328,42515280,43046721,43200000,43740000,44236800,44286750,44789760,45000000,45349632,45562500,46080000,46656000,46875000,47185920,47239200,47775744,47829690,48000000,48600000,48828125,49152000,49207500,49766400,50000000,50331648,50388480,50625000,51018336,51200000,51840000,\\n\\n52428800,52488000,52734375,53084160,53144100,53747712,54000000,54675000,55296000,55987200,56250000,56623104,56687040,56953125,57395628,57600000,58320000,58593750,58982400,59049000,59719680,60000000,60466176,60750000,61440000,61509375,62208000,62500000,62914560,62985600,63281250,63700992,63772920,64000000,64800000,65536000,65610000,66355200,66430125,67108864,67184640,67500000,68024448,68343750,69120000,69984000,70312500,70778880,70858800,71663616,71744535,72000000,72900000,73728000,73811250,74649600,75000000,75497472,75582720,75937500,76527504,76800000,77760000,78125000,78643200,78732000,79626240,79716150,80000000,80621568,81000000,81920000,82012500,82944000,83886080,83980800,84375000,84934656,85030560,86093442,86400000,87480000,87890625,88473600,88573500,89579520,90000000,90699264,91125000,92160000,93312000,93750000,94371840,94478400,94921875,95551488,95659380,96000000,97200000,97656250,98304000,98415000,99532800,100000000,100663296,100776960,101250000,102036672,102400000,102515625,103680000,104857600,104976000,105468750,106168320,106288200,107495424,108000000,109350000,110592000,110716875,111974400,112500000,113246208,113374080,113906250,114791256,115200000,116640000,117187500,117964800,118098000,119439360,119574225,120000000,120932352,121500000,122880000,123018750,124416000,125000000,125829120,125971200,126562500,127401984,127545840,128000000,129140163,129600000,131072000,131220000,132710400,132860250,134217728,134369280,135000000,136048896,136687500,138240000,139968000,140625000,141557760,141717600,143327232,143489070,144000000,145800000,146484375,147456000,147622500,149299200,150000000,150994944,151165440,151875000,153055008,153600000,155520000,156250000,157286400,157464000,158203125,159252480,159432300,160000000,161243136,162000000,163840000,164025000,165888000,167772160,167961600,168750000,169869312,170061120,170859375,172186884,172800000,174960000,175781250,\\n\\n\\n176947200,177147000,179159040,180000000,181398528,182250000,184320000,184528125,186624000,187500000,188743680,188956800,189843750,191102976,191318760,192000000,194400000,195312500,196608000,196830000,199065600,199290375,200000000,201326592,201553920,202500000,204073344,204800000,205031250,207360000,209715200,209952000,210937500,212336640,212576400,214990848,215233605,216000000,218700000,221184000,221433750,223948800,225000000,226492416,226748160,227812500,229582512,230400000,233280000,234375000,235929600,236196000,238878720,239148450,240000000,241864704,243000000,244140625,245760000,246037500,248832000,250000000,251658240,251942400,253125000,254803968,255091680,256000000,258280326,259200000,262144000,262440000,263671875,265420800,265720500,268435456,268738560,270000000,272097792,273375000,276480000,279936000,281250000,283115520,283435200,284765625,286654464,286978140,288000000,291600000,292968750,294912000,295245000,298598400,300000000,301989888,302330880,303750000,306110016,307200000,307546875,311040000,312500000,314572800,314928000,316406250,318504960,318864600,320000000,322486272,324000000,327680000,328050000,331776000,332150625,335544320,335923200,337500000,339738624,340122240,341718750,344373768,345600000,349920000,351562500,353894400,354294000,358318080,358722675,360000000,362797056,364500000,368640000,369056250,373248000,375000000,377487360,377913600,379687500,382205952,382637520,384000000,387420489,388800000,390625000,393216000,393660000,398131200,398580750,400000000,402653184,403107840,405000000,408146688,409600000,410062500,414720000,419430400,419904000,421875000,424673280,425152800,429981696,430467210,432000000,437400000,439453125,442368000,442867500,447897600,450000000,452984832,453496320,455625000,459165024,460800000,466560000,468750000,471859200,472392000,474609375,477757440,478296900,480000000,483729408,486000000,488281250,491520000,492075000,497664000,500000000,503316480,503884800,506250000,509607936,510183360,512000000,512578125,516560652,518400000,\\n\\n524288000,524880000,527343750,530841600,531441000,536870912,537477120,540000000,544195584,546750000,552960000,553584375,559872000,562500000,566231040,566870400,569531250,573308928,573956280,576000000,583200000,585937500,589824000,590490000,597196800,597871125,600000000,603979776,604661760,607500000,612220032,614400000,615093750,622080000,625000000,629145600,629856000,632812500,637009920,637729200,640000000,644972544,645700815,648000000,655360000,656100000,663552000,664301250,671088640,671846400,675000000,679477248,680244480,683437500,688747536,691200000,699840000,703125000,707788800,708588000,716636160,717445350,720000000,725594112,729000000,732421875,737280000,738112500,746496000,750000000,754974720,755827200,759375000,764411904,765275040,768000000,774840978,777600000,781250000,786432000,787320000,791015625,796262400,797161500,800000000,805306368,806215680,810000000,816293376,819200000,820125000,829440000,838860800,839808000,843750000,849346560,850305600,854296875,859963392,860934420,864000000,874800000,878906250,884736000,885735000,895795200,900000000,905969664,906992640,911250000,918330048,921600000,922640625,933120000,937500000,943718400,944784000,949218750,955514880,956593800,960000000,967458816,972000000,976562500,983040000,984150000,995328000,996451875,1000000000,1006632960,1007769600,1012500000,1019215872,1020366720,1024000000,1025156250,1033121304,1036800000,1048576000,1049760000,1054687500,1061683200,1062882000,1073741824,1074954240,1076168025,1080000000,1088391168,1093500000,1105920000,1107168750,1119744000,1125000000,1132462080,1133740800,1139062500,1146617856,1147912560,1152000000,1162261467,1166400000,1171875000,1179648000,1180980000,1194393600,1195742250,1200000000,1207959552,1209323520,1215000000,1220703125,1224440064,1228800000,1230187500,1244160000,1250000000,1258291200,1259712000,1265625000,1274019840,1275458400,1280000000,1289945088,1291401630,1296000000,1310720000,1312200000,1318359375,1327104000,1328602500,1342177280,1343692800,1350000000,1358954496,1360488960,1366875000,1377495072,1382400000,1399680000,1406250000,1415577600,1417176000,1423828125,1433272320,1434890700,1440000000,1451188224,1458000000,1464843750,1474560000,1476225000,1492992000,1500000000,1509949440,1511654400,1518750000,1528823808,1530550080,1536000000,1537734375,1549681956,1555200000,1562500000,1572864000,1574640000,1582031250,1592524800,1594323000,1600000000,1610612736,1612431360,1620000000,1632586752,1638400000,1640250000,1658880000,1660753125,1677721600,1679616000,1687500000,1698693120,1700611200,1708593750,1719926784,1721868840,1728000000,1749600000,1757812500,1769472000,1771470000,1791590400,1793613375,1800000000,1811939328,1813985280,1822500000,1836660096,1843200000,1845281250,1866240000,1875000000,1887436800,1889568000,1898437500,1911029760,1913187600,1920000000,1934917632,1937102445,1944000000,1953125000,1966080000,1968300000,1990656000,1992903750,2000000000,2013265920,2015539200,2025000000,2038431744,2040733440,2048000000,2050312500,2066242608,2073600000,2097152000,2099520000,2109375000,2123366400,2125764000,2147483648,2149908480,2152336050,2160000000,2176782336,2187000000,2197265625,2211840000,2214337500,2239488000\\n\\n\\n};\\n\\n    int nthUglyNumber(int n) {\\n        return ar[n-1]; \\n    }\\n};`"
                    },
                    {
                        "username": "AasheeshLikePanner",
                        "content": "Bro stop this \\uD83D\\uDE2D\\uD83D\\uDE2D\\uD83D\\uDE2D"
                    },
                    {
                        "username": "Mayank_Shahria",
                        "content": "**I have solved this by two methods \\n1. Brute force**\\nBut it is giving a run time error\\n![image](https://assets.leetcode.com/users/images/ba539fa1-405b-4d9d-832a-5be83172edc4_1620554425.1931248.png)\\n**2. Dynamic Programing**\\n![image](https://assets.leetcode.com/users/images/3a90f09e-1a3c-465f-a8d6-b58bfc613ccf_1620554465.9711976.png)\\n\\n\\n"
                    },
                    {
                        "username": "aman_online67",
                        "content": "I also applied brute force but it gives TLE at some 500 test case. But logic wise it is correct what to do now"
                    },
                    {
                        "username": "Rohith6776",
                        "content": "If the prime factors are limited to 2,3,5 and we should not consider numbers like(14->2*7, 21->3*7) right?"
                    },
                    {
                        "username": "wtfcoder",
                        "content": "yup"
                    },
                    {
                        "username": "c_jain",
                        "content": "After reading top solutions here, I realized optimized solution is not a DP solution because I am not able to figure out optimal substructure and overlapping subproblem. I think it is kind of 3 pointer solution. Anyone like to clarify this?"
                    },
                    {
                        "username": "vikasboss6855",
                        "content": "https://leetcode.com/problems/ugly-number-ii/solutions/3704058/c-memoized-solution-using-dp-forcible-dp/"
                    },
                    {
                        "username": "Gismet",
                        "content": "Yeah, you are right. I don't also think there is an optimal substructure and overlapping subproblem. I think the reason why they called this DP solution is that we use the previously computed ugly numbers to find the next one. If you checked out the hint, they say you can get the next ugly number from a smaller ugly number by multiplying it by either 2, 3 or 5. So we start from the bottom and work our way up to the nth ugly number, in each iteration finding the next ugly number using a previous one. But to see the overlapping subproblems, one would write a recursive solution, also called top-down, and see if there are any subproblems that overlaps. But I couldn't come up with recursive top-down solution. Or maybe there is an optimal substructure that I fail to see. "
                    },
                    {
                        "username": "logical_thinker",
                        "content": "can someone throw light on the last test case which is n being empty the 596th test case. what is that and how do I go about it."
                    },
                    {
                        "username": "urmichm",
                        "content": "why is 1 ugly number?"
                    },
                    {
                        "username": "at218808",
                        "content": "1 is a factor of every number , so its more like a ugly number has only factors as 1,2,3 or 5"
                    },
                    {
                        "username": "QuasiRus",
                        "content": "It does not have any prime factor outside [2, 3, 5] list. 1 itself is not a prime number."
                    }
                ]
            },
            {
                "id": 1838471,
                "content": [
                    {
                        "username": "lcn",
                        "content": " 1. Actually, the input space is much smaller than expected if we insist an `int` range output. \\nWhen input `n` is greater than `1691`, the output overflows the `int` range.\\n 2. Another way to view this bound is that all ugly numbers must be in the form `2^a*3^b*5^c`. Since we have `log2(Integer.MAX_VALUE)=a<31`, `log3(Integer.MAX_VALUE)=b<20` and `log5(Integer.MAX_VALUE)=c<14`, the combination allowed is surely under `31*20*14~=8400`.\\n\\nSo ugly number is sparser than one would usually think, and please do take care of overflow."
                    },
                    {
                        "username": "chauhanprerna21",
                        "content": "I am not able to understand how is ugly numbers a DP problem?\\nWould be great if someone could help with it."
                    },
                    {
                        "username": "vikasboss6855",
                        "content": "https://leetcode.com/problems/ugly-number-ii/solutions/3704058/c-memoized-solution-using-dp-forcible-dp/\n```\nclass Solution {\npublic:\n    int nthUglyNumber(int n) {\n        vector<int> dp(n);\n        dp[0] = 1;\n        return nthUglyNumberRecursive(dp, n, 1, 0, 0, 0);\n    }\n\nprivate:\n    int nthUglyNumberRecursive(vector<int>& dp, int n, int i, int p1, int p2, int p3) {\n        if (i == n) {\n            return dp[n - 1];\n        }\n\n        int twoMultiple = dp[p1] * 2;\n        int threeMultiple = dp[p2] * 3;\n        int fiveMultiple = dp[p3] * 5;\n\n        dp[i] = min(twoMultiple, min(threeMultiple, fiveMultiple));\n\n        int nextP1 = (dp[i] == twoMultiple) ? p1 + 1 : p1;\n        int nextP2 = (dp[i] == threeMultiple) ? p2 + 1 : p2;\n        int nextP3 = (dp[i] == fiveMultiple) ? p3 + 1 : p3;\n\n        return nthUglyNumberRecursive(dp, n, i + 1, nextP1, nextP2, nextP3);\n    }\n};\n\n```"
                    },
                    {
                        "username": "divyanshuparg",
                        "content": "I have solved it using recursion and hashing."
                    },
                    {
                        "username": "anshulguleria",
                        "content": "In the example in problem statement 1 was being counted as ugly number. I am not able to understand how we concluded that.\\n\\nif 1 = 1 * 2^0 then this theory will be true for other numbers as well like 7  * 2^0."
                    },
                    {
                        "username": "Seabayley",
                        "content": "![image](https://assets.leetcode.com/users/images/fad90901-6c35-455e-8ff0-8160380ca46c_1597993223.2791212.png)\\n\\nAm I misunderstanding the problem? The 11th ugly numbers looks to me as though it should be 14?"
                    },
                    {
                        "username": "codekorekhai",
                        "content": "[@satyamkumarskr](/satyamkumarskr) 14 is not an ugly number because it has 7 as factor but the problem said that only 2, 3, 5 will be the prime factor for each ugly number."
                    },
                    {
                        "username": "satyamkumarskr",
                        "content": "True . I got the same issue."
                    },
                    {
                        "username": "user6746E",
                        "content": "The 11th ugly number will not be 14 since the prime factor of 14 includes 7, but the question clearly states that the primes factor should be limited to 2, 3 or 5. Therefore 11th ugly number will be 15."
                    },
                    {
                        "username": "sazib204061",
                        "content": "I solve this problem in O(1) time complexity.\\n `class Solution {\\npublic:\\nvector<long long>ar = {1,2,3,4,5,6,8,9,10,12,15,16,18,20,24,25,27,30,32,36,40,45,48,50,54,60,64,72,75,80,81,90,96,100,108,120,125,128,135,144,150,160,162,180,192,200,216,225,240,243,250,256,270,288,300,320,324,360,375,384,400,405,432,450,480,486,500,512,540,576,600,625,640,648,675,720,729,750,768,800,810,864,900,960,972,1000,1024,1080,1125,1152,1200,1215,1250,1280,1296,1350,1440,1458,1500,1536,1600,1620,1728,1800,1875,1920,1944,2000,2025,2048,2160,2187,2250,2304,2400,2430,2500,2560,2592,2700,2880,2916,3000,3072,3125,3200,3240,3375,3456,3600,3645,3750,3840,3888,4000,4050,4096,4320,4374,4500,4608,4800,4860,5000,5120,5184,5400,5625,5760,5832,6000,6075,6144,6250,6400,6480,6561,6750,6912,7200,7290,7500,7680,7776,8000,8100,8192,8640,8748,9000,9216,9375,9600,9720,10000,10125,10240,10368,10800,10935,11250,11520,11664,12000,12150,12288,12500,12800,12960,13122,13500,13824,14400,14580,15000,15360,15552,15625,16000,16200,16384,16875,17280,17496,18000,18225,18432,18750,19200,19440,19683,20000,20250,20480,20736,21600,21870,22500,23040,23328,24000,24300,24576,25000,25600,25920,26244,27000,27648,28125,28800,29160,30000,30375,30720,31104,31250,32000,32400,32768,32805,33750,34560,34992,36000,36450,36864,37500,38400,38880,39366,40000,40500,40960,41472,43200,43740,45000,46080,46656,46875,48000,48600,49152,50000,50625,51200,51840,52488,54000,54675,55296,56250,57600,58320,59049,60000,60750,61440,62208,62500,64000,64800,65536,65610,67500,69120,69984,72000,72900,73728,75000,76800,77760,78125,78732,80000,81000,81920,82944,84375,86400,87480,90000,91125,92160,93312,93750,96000,97200,98304,98415,100000,101250,102400,103680,104976,108000,109350,110592,112500,115200,116640,118098,120000,121500,122880,124416,125000,128000,129600,131072,131220,135000,138240,139968,140625,144000,145800,147456,150000,151875,153600,155520,156250,157464,160000,162000,163840,164025,165888,168750,172800,174960,177147,180000,182250,184320,186624,187500,192000,194400,196608,196830,200000,202500,204800,207360,209952,216000,218700,221184,225000,230400,233280,234375,236196,240000,243000,245760,248832,250000,253125,256000,259200,262144,262440,270000,273375,276480,279936,281250,288000,291600,294912,295245,300000,303750,307200,311040,312500,314928,320000,324000,327680,328050,331776,337500,345600,349920,354294,360000,364500,368640,373248,375000,384000,388800,390625,393216,393660,400000,405000,409600,414720,419904,421875,432000,437400,442368,450000,455625,460800,466560,468750,472392,480000,486000,491520,492075,497664,500000,506250,512000,518400,524288,524880,531441,540000,546750,552960,559872,562500,576000,583200,589824,590490,600000,607500,614400,622080,625000,629856,640000,648000,655360,656100,663552,675000,691200,699840,703125,708588,720000,729000,737280,746496,750000,759375,768000,777600,781250,786432,787320,800000,810000,819200,820125,829440,839808,843750,864000,874800,884736,885735,900000,911250,921600,933120,937500,944784,\\n\\n960000,972000,983040,984150,995328,1000000,1012500,1024000,1036800,1048576,1049760,1062882,1080000,1093500,1105920,1119744,1125000,1152000,1166400,1171875,1179648,1180980,1200000,1215000,1228800,1244160,1250000,1259712,1265625,1280000,1296000,1310720,1312200,1327104,1350000,1366875,1382400,1399680,1406250,1417176,1440000,1458000,1474560,1476225,1492992,1500000,1518750,1536000,1555200,1562500,1572864,1574640,1594323,1600000,1620000,1638400,1640250,1658880,1679616,1687500,1728000,1749600,1769472,1771470,1800000,1822500,1843200,1866240,1875000,1889568,1920000,1944000,1953125,1966080,1968300,1990656,2000000,2025000,2048000,2073600,2097152,2099520,2109375,2125764,2160000,2187000,2211840,2239488,2250000,2278125,2304000,2332800,2343750,2359296,2361960,2400000,2430000,2457600,2460375,2488320,2500000,2519424,2531250,2560000,2592000,2621440,2624400,2654208,2657205,2700000,2733750,2764800,2799360,2812500,2834352,2880000,2916000,2949120,2952450,2985984,3000000,3037500,3072000,3110400,3125000,3145728,3149280,3188646,3200000,3240000,3276800,3280500,3317760,3359232,3375000,3456000,3499200,3515625,3538944,3542940,3600000,3645000,3686400,3732480,3750000,3779136,3796875,3840000,3888000,3906250,3932160,3936600,3981312,4000000,4050000,4096000,4100625,4147200,4194304,4199040,4218750,4251528,4320000,4374000,4423680,4428675,4478976,4500000,4556250,4608000,4665600,4687500,4718592,4723920,4782969,4800000,4860000,4915200,4920750,4976640,5000000,5038848,5062500,5120000,5184000,5242880,5248800,5308416,5314410,5400000,5467500,5529600,5598720,5625000,5668704,5760000,5832000,5859375,5898240,5904900,5971968,6000000,6075000,6144000,6220800,6250000,6291456,6298560,6328125,6377292,6400000,6480000,6553600,6561000,6635520,6718464,6750000,6834375,6912000,6998400,7031250,7077888,7085880,7200000,7290000,7372800,7381125,7464960,7500000,7558272,7593750,7680000,7776000,7812500,7864320,7873200,7962624,7971615,8000000,8100000,8192000,8201250,8294400,8388608,8398080,8437500,8503056,8640000,8748000,8847360,8857350,8957952,9000000,9112500,9216000,9331200,9375000,9437184,9447840,9565938,9600000,9720000,9765625,9830400,9841500,9953280,10000000,10077696,10125000,10240000,10368000,10485760,10497600,10546875,10616832,10628820,10800000,10935000,11059200,11197440,11250000,11337408,11390625,11520000,11664000,11718750,11796480,11809800,11943936,12000000,12150000,12288000,12301875,12441600,12500000,12582912,12597120,12656250,12754584,12800000,12960000,13107200,13122000,13271040,13286025,13436928,13500000,13668750,13824000,13996800,14062500,14155776,14171760,14348907,14400000,14580000,14745600,14762250,14929920,15000000,15116544,15187500,15360000,15552000,15625000,15728640,15746400,15925248,15943230,16000000,16200000,16384000,16402500,16588800,16777216,16796160,16875000,17006112,17280000,17496000,17578125,17694720,17714700,17915904,18000000,18225000,18432000,18662400,18750000,18874368,18895680,18984375,19131876,19200000,19440000,19531250,19660800,19683000,19906560,20000000,20155392,20250000,20480000,20503125,20736000,20971520,20995200,21093750,21233664,21257640,21600000,21870000,22118400,22143375,22394880,22500000,22674816,22781250,23040000,23328000,23437500,23592960,23619600,23887872,23914845,24000000,24300000,24576000,24603750,24883200,25000000,25165824,25194240,25312500,25509168,25600000,25920000,26214400,26244000,26542080,26572050,26873856,27000000,27337500,27648000,27993600,28125000,28311552,28343520,28697814,28800000,29160000,29296875,29491200,29524500,29859840,30000000,30233088,30375000,30720000,31104000,31250000,31457280,31492800,31640625,31850496,31886460,32000000,32400000,32768000,32805000,33177600,33554432,33592320,33750000,34012224,34171875,34560000,34992000,35156250,35389440,35429400,35831808,36000000,36450000,36864000,36905625,37324800,37500000,37748736,37791360,37968750,38263752,38400000,38880000,39062500,39321600,39366000,39813120,39858075,40000000,40310784,40500000,40960000,41006250,41472000,41943040,41990400,42187500,42467328,42515280,43046721,43200000,43740000,44236800,44286750,44789760,45000000,45349632,45562500,46080000,46656000,46875000,47185920,47239200,47775744,47829690,48000000,48600000,48828125,49152000,49207500,49766400,50000000,50331648,50388480,50625000,51018336,51200000,51840000,\\n\\n52428800,52488000,52734375,53084160,53144100,53747712,54000000,54675000,55296000,55987200,56250000,56623104,56687040,56953125,57395628,57600000,58320000,58593750,58982400,59049000,59719680,60000000,60466176,60750000,61440000,61509375,62208000,62500000,62914560,62985600,63281250,63700992,63772920,64000000,64800000,65536000,65610000,66355200,66430125,67108864,67184640,67500000,68024448,68343750,69120000,69984000,70312500,70778880,70858800,71663616,71744535,72000000,72900000,73728000,73811250,74649600,75000000,75497472,75582720,75937500,76527504,76800000,77760000,78125000,78643200,78732000,79626240,79716150,80000000,80621568,81000000,81920000,82012500,82944000,83886080,83980800,84375000,84934656,85030560,86093442,86400000,87480000,87890625,88473600,88573500,89579520,90000000,90699264,91125000,92160000,93312000,93750000,94371840,94478400,94921875,95551488,95659380,96000000,97200000,97656250,98304000,98415000,99532800,100000000,100663296,100776960,101250000,102036672,102400000,102515625,103680000,104857600,104976000,105468750,106168320,106288200,107495424,108000000,109350000,110592000,110716875,111974400,112500000,113246208,113374080,113906250,114791256,115200000,116640000,117187500,117964800,118098000,119439360,119574225,120000000,120932352,121500000,122880000,123018750,124416000,125000000,125829120,125971200,126562500,127401984,127545840,128000000,129140163,129600000,131072000,131220000,132710400,132860250,134217728,134369280,135000000,136048896,136687500,138240000,139968000,140625000,141557760,141717600,143327232,143489070,144000000,145800000,146484375,147456000,147622500,149299200,150000000,150994944,151165440,151875000,153055008,153600000,155520000,156250000,157286400,157464000,158203125,159252480,159432300,160000000,161243136,162000000,163840000,164025000,165888000,167772160,167961600,168750000,169869312,170061120,170859375,172186884,172800000,174960000,175781250,\\n\\n\\n176947200,177147000,179159040,180000000,181398528,182250000,184320000,184528125,186624000,187500000,188743680,188956800,189843750,191102976,191318760,192000000,194400000,195312500,196608000,196830000,199065600,199290375,200000000,201326592,201553920,202500000,204073344,204800000,205031250,207360000,209715200,209952000,210937500,212336640,212576400,214990848,215233605,216000000,218700000,221184000,221433750,223948800,225000000,226492416,226748160,227812500,229582512,230400000,233280000,234375000,235929600,236196000,238878720,239148450,240000000,241864704,243000000,244140625,245760000,246037500,248832000,250000000,251658240,251942400,253125000,254803968,255091680,256000000,258280326,259200000,262144000,262440000,263671875,265420800,265720500,268435456,268738560,270000000,272097792,273375000,276480000,279936000,281250000,283115520,283435200,284765625,286654464,286978140,288000000,291600000,292968750,294912000,295245000,298598400,300000000,301989888,302330880,303750000,306110016,307200000,307546875,311040000,312500000,314572800,314928000,316406250,318504960,318864600,320000000,322486272,324000000,327680000,328050000,331776000,332150625,335544320,335923200,337500000,339738624,340122240,341718750,344373768,345600000,349920000,351562500,353894400,354294000,358318080,358722675,360000000,362797056,364500000,368640000,369056250,373248000,375000000,377487360,377913600,379687500,382205952,382637520,384000000,387420489,388800000,390625000,393216000,393660000,398131200,398580750,400000000,402653184,403107840,405000000,408146688,409600000,410062500,414720000,419430400,419904000,421875000,424673280,425152800,429981696,430467210,432000000,437400000,439453125,442368000,442867500,447897600,450000000,452984832,453496320,455625000,459165024,460800000,466560000,468750000,471859200,472392000,474609375,477757440,478296900,480000000,483729408,486000000,488281250,491520000,492075000,497664000,500000000,503316480,503884800,506250000,509607936,510183360,512000000,512578125,516560652,518400000,\\n\\n524288000,524880000,527343750,530841600,531441000,536870912,537477120,540000000,544195584,546750000,552960000,553584375,559872000,562500000,566231040,566870400,569531250,573308928,573956280,576000000,583200000,585937500,589824000,590490000,597196800,597871125,600000000,603979776,604661760,607500000,612220032,614400000,615093750,622080000,625000000,629145600,629856000,632812500,637009920,637729200,640000000,644972544,645700815,648000000,655360000,656100000,663552000,664301250,671088640,671846400,675000000,679477248,680244480,683437500,688747536,691200000,699840000,703125000,707788800,708588000,716636160,717445350,720000000,725594112,729000000,732421875,737280000,738112500,746496000,750000000,754974720,755827200,759375000,764411904,765275040,768000000,774840978,777600000,781250000,786432000,787320000,791015625,796262400,797161500,800000000,805306368,806215680,810000000,816293376,819200000,820125000,829440000,838860800,839808000,843750000,849346560,850305600,854296875,859963392,860934420,864000000,874800000,878906250,884736000,885735000,895795200,900000000,905969664,906992640,911250000,918330048,921600000,922640625,933120000,937500000,943718400,944784000,949218750,955514880,956593800,960000000,967458816,972000000,976562500,983040000,984150000,995328000,996451875,1000000000,1006632960,1007769600,1012500000,1019215872,1020366720,1024000000,1025156250,1033121304,1036800000,1048576000,1049760000,1054687500,1061683200,1062882000,1073741824,1074954240,1076168025,1080000000,1088391168,1093500000,1105920000,1107168750,1119744000,1125000000,1132462080,1133740800,1139062500,1146617856,1147912560,1152000000,1162261467,1166400000,1171875000,1179648000,1180980000,1194393600,1195742250,1200000000,1207959552,1209323520,1215000000,1220703125,1224440064,1228800000,1230187500,1244160000,1250000000,1258291200,1259712000,1265625000,1274019840,1275458400,1280000000,1289945088,1291401630,1296000000,1310720000,1312200000,1318359375,1327104000,1328602500,1342177280,1343692800,1350000000,1358954496,1360488960,1366875000,1377495072,1382400000,1399680000,1406250000,1415577600,1417176000,1423828125,1433272320,1434890700,1440000000,1451188224,1458000000,1464843750,1474560000,1476225000,1492992000,1500000000,1509949440,1511654400,1518750000,1528823808,1530550080,1536000000,1537734375,1549681956,1555200000,1562500000,1572864000,1574640000,1582031250,1592524800,1594323000,1600000000,1610612736,1612431360,1620000000,1632586752,1638400000,1640250000,1658880000,1660753125,1677721600,1679616000,1687500000,1698693120,1700611200,1708593750,1719926784,1721868840,1728000000,1749600000,1757812500,1769472000,1771470000,1791590400,1793613375,1800000000,1811939328,1813985280,1822500000,1836660096,1843200000,1845281250,1866240000,1875000000,1887436800,1889568000,1898437500,1911029760,1913187600,1920000000,1934917632,1937102445,1944000000,1953125000,1966080000,1968300000,1990656000,1992903750,2000000000,2013265920,2015539200,2025000000,2038431744,2040733440,2048000000,2050312500,2066242608,2073600000,2097152000,2099520000,2109375000,2123366400,2125764000,2147483648,2149908480,2152336050,2160000000,2176782336,2187000000,2197265625,2211840000,2214337500,2239488000\\n\\n\\n};\\n\\n    int nthUglyNumber(int n) {\\n        return ar[n-1]; \\n    }\\n};`"
                    },
                    {
                        "username": "AasheeshLikePanner",
                        "content": "Bro stop this \\uD83D\\uDE2D\\uD83D\\uDE2D\\uD83D\\uDE2D"
                    },
                    {
                        "username": "Mayank_Shahria",
                        "content": "**I have solved this by two methods \\n1. Brute force**\\nBut it is giving a run time error\\n![image](https://assets.leetcode.com/users/images/ba539fa1-405b-4d9d-832a-5be83172edc4_1620554425.1931248.png)\\n**2. Dynamic Programing**\\n![image](https://assets.leetcode.com/users/images/3a90f09e-1a3c-465f-a8d6-b58bfc613ccf_1620554465.9711976.png)\\n\\n\\n"
                    },
                    {
                        "username": "aman_online67",
                        "content": "I also applied brute force but it gives TLE at some 500 test case. But logic wise it is correct what to do now"
                    },
                    {
                        "username": "Rohith6776",
                        "content": "If the prime factors are limited to 2,3,5 and we should not consider numbers like(14->2*7, 21->3*7) right?"
                    },
                    {
                        "username": "wtfcoder",
                        "content": "yup"
                    },
                    {
                        "username": "c_jain",
                        "content": "After reading top solutions here, I realized optimized solution is not a DP solution because I am not able to figure out optimal substructure and overlapping subproblem. I think it is kind of 3 pointer solution. Anyone like to clarify this?"
                    },
                    {
                        "username": "vikasboss6855",
                        "content": "https://leetcode.com/problems/ugly-number-ii/solutions/3704058/c-memoized-solution-using-dp-forcible-dp/"
                    },
                    {
                        "username": "Gismet",
                        "content": "Yeah, you are right. I don't also think there is an optimal substructure and overlapping subproblem. I think the reason why they called this DP solution is that we use the previously computed ugly numbers to find the next one. If you checked out the hint, they say you can get the next ugly number from a smaller ugly number by multiplying it by either 2, 3 or 5. So we start from the bottom and work our way up to the nth ugly number, in each iteration finding the next ugly number using a previous one. But to see the overlapping subproblems, one would write a recursive solution, also called top-down, and see if there are any subproblems that overlaps. But I couldn't come up with recursive top-down solution. Or maybe there is an optimal substructure that I fail to see. "
                    },
                    {
                        "username": "logical_thinker",
                        "content": "can someone throw light on the last test case which is n being empty the 596th test case. what is that and how do I go about it."
                    },
                    {
                        "username": "urmichm",
                        "content": "why is 1 ugly number?"
                    },
                    {
                        "username": "at218808",
                        "content": "1 is a factor of every number , so its more like a ugly number has only factors as 1,2,3 or 5"
                    },
                    {
                        "username": "QuasiRus",
                        "content": "It does not have any prime factor outside [2, 3, 5] list. 1 itself is not a prime number."
                    }
                ]
            },
            {
                "id": 1688235,
                "content": [
                    {
                        "username": "lcn",
                        "content": " 1. Actually, the input space is much smaller than expected if we insist an `int` range output. \\nWhen input `n` is greater than `1691`, the output overflows the `int` range.\\n 2. Another way to view this bound is that all ugly numbers must be in the form `2^a*3^b*5^c`. Since we have `log2(Integer.MAX_VALUE)=a<31`, `log3(Integer.MAX_VALUE)=b<20` and `log5(Integer.MAX_VALUE)=c<14`, the combination allowed is surely under `31*20*14~=8400`.\\n\\nSo ugly number is sparser than one would usually think, and please do take care of overflow."
                    },
                    {
                        "username": "chauhanprerna21",
                        "content": "I am not able to understand how is ugly numbers a DP problem?\\nWould be great if someone could help with it."
                    },
                    {
                        "username": "vikasboss6855",
                        "content": "https://leetcode.com/problems/ugly-number-ii/solutions/3704058/c-memoized-solution-using-dp-forcible-dp/\n```\nclass Solution {\npublic:\n    int nthUglyNumber(int n) {\n        vector<int> dp(n);\n        dp[0] = 1;\n        return nthUglyNumberRecursive(dp, n, 1, 0, 0, 0);\n    }\n\nprivate:\n    int nthUglyNumberRecursive(vector<int>& dp, int n, int i, int p1, int p2, int p3) {\n        if (i == n) {\n            return dp[n - 1];\n        }\n\n        int twoMultiple = dp[p1] * 2;\n        int threeMultiple = dp[p2] * 3;\n        int fiveMultiple = dp[p3] * 5;\n\n        dp[i] = min(twoMultiple, min(threeMultiple, fiveMultiple));\n\n        int nextP1 = (dp[i] == twoMultiple) ? p1 + 1 : p1;\n        int nextP2 = (dp[i] == threeMultiple) ? p2 + 1 : p2;\n        int nextP3 = (dp[i] == fiveMultiple) ? p3 + 1 : p3;\n\n        return nthUglyNumberRecursive(dp, n, i + 1, nextP1, nextP2, nextP3);\n    }\n};\n\n```"
                    },
                    {
                        "username": "divyanshuparg",
                        "content": "I have solved it using recursion and hashing."
                    },
                    {
                        "username": "anshulguleria",
                        "content": "In the example in problem statement 1 was being counted as ugly number. I am not able to understand how we concluded that.\\n\\nif 1 = 1 * 2^0 then this theory will be true for other numbers as well like 7  * 2^0."
                    },
                    {
                        "username": "Seabayley",
                        "content": "![image](https://assets.leetcode.com/users/images/fad90901-6c35-455e-8ff0-8160380ca46c_1597993223.2791212.png)\\n\\nAm I misunderstanding the problem? The 11th ugly numbers looks to me as though it should be 14?"
                    },
                    {
                        "username": "codekorekhai",
                        "content": "[@satyamkumarskr](/satyamkumarskr) 14 is not an ugly number because it has 7 as factor but the problem said that only 2, 3, 5 will be the prime factor for each ugly number."
                    },
                    {
                        "username": "satyamkumarskr",
                        "content": "True . I got the same issue."
                    },
                    {
                        "username": "user6746E",
                        "content": "The 11th ugly number will not be 14 since the prime factor of 14 includes 7, but the question clearly states that the primes factor should be limited to 2, 3 or 5. Therefore 11th ugly number will be 15."
                    },
                    {
                        "username": "sazib204061",
                        "content": "I solve this problem in O(1) time complexity.\\n `class Solution {\\npublic:\\nvector<long long>ar = {1,2,3,4,5,6,8,9,10,12,15,16,18,20,24,25,27,30,32,36,40,45,48,50,54,60,64,72,75,80,81,90,96,100,108,120,125,128,135,144,150,160,162,180,192,200,216,225,240,243,250,256,270,288,300,320,324,360,375,384,400,405,432,450,480,486,500,512,540,576,600,625,640,648,675,720,729,750,768,800,810,864,900,960,972,1000,1024,1080,1125,1152,1200,1215,1250,1280,1296,1350,1440,1458,1500,1536,1600,1620,1728,1800,1875,1920,1944,2000,2025,2048,2160,2187,2250,2304,2400,2430,2500,2560,2592,2700,2880,2916,3000,3072,3125,3200,3240,3375,3456,3600,3645,3750,3840,3888,4000,4050,4096,4320,4374,4500,4608,4800,4860,5000,5120,5184,5400,5625,5760,5832,6000,6075,6144,6250,6400,6480,6561,6750,6912,7200,7290,7500,7680,7776,8000,8100,8192,8640,8748,9000,9216,9375,9600,9720,10000,10125,10240,10368,10800,10935,11250,11520,11664,12000,12150,12288,12500,12800,12960,13122,13500,13824,14400,14580,15000,15360,15552,15625,16000,16200,16384,16875,17280,17496,18000,18225,18432,18750,19200,19440,19683,20000,20250,20480,20736,21600,21870,22500,23040,23328,24000,24300,24576,25000,25600,25920,26244,27000,27648,28125,28800,29160,30000,30375,30720,31104,31250,32000,32400,32768,32805,33750,34560,34992,36000,36450,36864,37500,38400,38880,39366,40000,40500,40960,41472,43200,43740,45000,46080,46656,46875,48000,48600,49152,50000,50625,51200,51840,52488,54000,54675,55296,56250,57600,58320,59049,60000,60750,61440,62208,62500,64000,64800,65536,65610,67500,69120,69984,72000,72900,73728,75000,76800,77760,78125,78732,80000,81000,81920,82944,84375,86400,87480,90000,91125,92160,93312,93750,96000,97200,98304,98415,100000,101250,102400,103680,104976,108000,109350,110592,112500,115200,116640,118098,120000,121500,122880,124416,125000,128000,129600,131072,131220,135000,138240,139968,140625,144000,145800,147456,150000,151875,153600,155520,156250,157464,160000,162000,163840,164025,165888,168750,172800,174960,177147,180000,182250,184320,186624,187500,192000,194400,196608,196830,200000,202500,204800,207360,209952,216000,218700,221184,225000,230400,233280,234375,236196,240000,243000,245760,248832,250000,253125,256000,259200,262144,262440,270000,273375,276480,279936,281250,288000,291600,294912,295245,300000,303750,307200,311040,312500,314928,320000,324000,327680,328050,331776,337500,345600,349920,354294,360000,364500,368640,373248,375000,384000,388800,390625,393216,393660,400000,405000,409600,414720,419904,421875,432000,437400,442368,450000,455625,460800,466560,468750,472392,480000,486000,491520,492075,497664,500000,506250,512000,518400,524288,524880,531441,540000,546750,552960,559872,562500,576000,583200,589824,590490,600000,607500,614400,622080,625000,629856,640000,648000,655360,656100,663552,675000,691200,699840,703125,708588,720000,729000,737280,746496,750000,759375,768000,777600,781250,786432,787320,800000,810000,819200,820125,829440,839808,843750,864000,874800,884736,885735,900000,911250,921600,933120,937500,944784,\\n\\n960000,972000,983040,984150,995328,1000000,1012500,1024000,1036800,1048576,1049760,1062882,1080000,1093500,1105920,1119744,1125000,1152000,1166400,1171875,1179648,1180980,1200000,1215000,1228800,1244160,1250000,1259712,1265625,1280000,1296000,1310720,1312200,1327104,1350000,1366875,1382400,1399680,1406250,1417176,1440000,1458000,1474560,1476225,1492992,1500000,1518750,1536000,1555200,1562500,1572864,1574640,1594323,1600000,1620000,1638400,1640250,1658880,1679616,1687500,1728000,1749600,1769472,1771470,1800000,1822500,1843200,1866240,1875000,1889568,1920000,1944000,1953125,1966080,1968300,1990656,2000000,2025000,2048000,2073600,2097152,2099520,2109375,2125764,2160000,2187000,2211840,2239488,2250000,2278125,2304000,2332800,2343750,2359296,2361960,2400000,2430000,2457600,2460375,2488320,2500000,2519424,2531250,2560000,2592000,2621440,2624400,2654208,2657205,2700000,2733750,2764800,2799360,2812500,2834352,2880000,2916000,2949120,2952450,2985984,3000000,3037500,3072000,3110400,3125000,3145728,3149280,3188646,3200000,3240000,3276800,3280500,3317760,3359232,3375000,3456000,3499200,3515625,3538944,3542940,3600000,3645000,3686400,3732480,3750000,3779136,3796875,3840000,3888000,3906250,3932160,3936600,3981312,4000000,4050000,4096000,4100625,4147200,4194304,4199040,4218750,4251528,4320000,4374000,4423680,4428675,4478976,4500000,4556250,4608000,4665600,4687500,4718592,4723920,4782969,4800000,4860000,4915200,4920750,4976640,5000000,5038848,5062500,5120000,5184000,5242880,5248800,5308416,5314410,5400000,5467500,5529600,5598720,5625000,5668704,5760000,5832000,5859375,5898240,5904900,5971968,6000000,6075000,6144000,6220800,6250000,6291456,6298560,6328125,6377292,6400000,6480000,6553600,6561000,6635520,6718464,6750000,6834375,6912000,6998400,7031250,7077888,7085880,7200000,7290000,7372800,7381125,7464960,7500000,7558272,7593750,7680000,7776000,7812500,7864320,7873200,7962624,7971615,8000000,8100000,8192000,8201250,8294400,8388608,8398080,8437500,8503056,8640000,8748000,8847360,8857350,8957952,9000000,9112500,9216000,9331200,9375000,9437184,9447840,9565938,9600000,9720000,9765625,9830400,9841500,9953280,10000000,10077696,10125000,10240000,10368000,10485760,10497600,10546875,10616832,10628820,10800000,10935000,11059200,11197440,11250000,11337408,11390625,11520000,11664000,11718750,11796480,11809800,11943936,12000000,12150000,12288000,12301875,12441600,12500000,12582912,12597120,12656250,12754584,12800000,12960000,13107200,13122000,13271040,13286025,13436928,13500000,13668750,13824000,13996800,14062500,14155776,14171760,14348907,14400000,14580000,14745600,14762250,14929920,15000000,15116544,15187500,15360000,15552000,15625000,15728640,15746400,15925248,15943230,16000000,16200000,16384000,16402500,16588800,16777216,16796160,16875000,17006112,17280000,17496000,17578125,17694720,17714700,17915904,18000000,18225000,18432000,18662400,18750000,18874368,18895680,18984375,19131876,19200000,19440000,19531250,19660800,19683000,19906560,20000000,20155392,20250000,20480000,20503125,20736000,20971520,20995200,21093750,21233664,21257640,21600000,21870000,22118400,22143375,22394880,22500000,22674816,22781250,23040000,23328000,23437500,23592960,23619600,23887872,23914845,24000000,24300000,24576000,24603750,24883200,25000000,25165824,25194240,25312500,25509168,25600000,25920000,26214400,26244000,26542080,26572050,26873856,27000000,27337500,27648000,27993600,28125000,28311552,28343520,28697814,28800000,29160000,29296875,29491200,29524500,29859840,30000000,30233088,30375000,30720000,31104000,31250000,31457280,31492800,31640625,31850496,31886460,32000000,32400000,32768000,32805000,33177600,33554432,33592320,33750000,34012224,34171875,34560000,34992000,35156250,35389440,35429400,35831808,36000000,36450000,36864000,36905625,37324800,37500000,37748736,37791360,37968750,38263752,38400000,38880000,39062500,39321600,39366000,39813120,39858075,40000000,40310784,40500000,40960000,41006250,41472000,41943040,41990400,42187500,42467328,42515280,43046721,43200000,43740000,44236800,44286750,44789760,45000000,45349632,45562500,46080000,46656000,46875000,47185920,47239200,47775744,47829690,48000000,48600000,48828125,49152000,49207500,49766400,50000000,50331648,50388480,50625000,51018336,51200000,51840000,\\n\\n52428800,52488000,52734375,53084160,53144100,53747712,54000000,54675000,55296000,55987200,56250000,56623104,56687040,56953125,57395628,57600000,58320000,58593750,58982400,59049000,59719680,60000000,60466176,60750000,61440000,61509375,62208000,62500000,62914560,62985600,63281250,63700992,63772920,64000000,64800000,65536000,65610000,66355200,66430125,67108864,67184640,67500000,68024448,68343750,69120000,69984000,70312500,70778880,70858800,71663616,71744535,72000000,72900000,73728000,73811250,74649600,75000000,75497472,75582720,75937500,76527504,76800000,77760000,78125000,78643200,78732000,79626240,79716150,80000000,80621568,81000000,81920000,82012500,82944000,83886080,83980800,84375000,84934656,85030560,86093442,86400000,87480000,87890625,88473600,88573500,89579520,90000000,90699264,91125000,92160000,93312000,93750000,94371840,94478400,94921875,95551488,95659380,96000000,97200000,97656250,98304000,98415000,99532800,100000000,100663296,100776960,101250000,102036672,102400000,102515625,103680000,104857600,104976000,105468750,106168320,106288200,107495424,108000000,109350000,110592000,110716875,111974400,112500000,113246208,113374080,113906250,114791256,115200000,116640000,117187500,117964800,118098000,119439360,119574225,120000000,120932352,121500000,122880000,123018750,124416000,125000000,125829120,125971200,126562500,127401984,127545840,128000000,129140163,129600000,131072000,131220000,132710400,132860250,134217728,134369280,135000000,136048896,136687500,138240000,139968000,140625000,141557760,141717600,143327232,143489070,144000000,145800000,146484375,147456000,147622500,149299200,150000000,150994944,151165440,151875000,153055008,153600000,155520000,156250000,157286400,157464000,158203125,159252480,159432300,160000000,161243136,162000000,163840000,164025000,165888000,167772160,167961600,168750000,169869312,170061120,170859375,172186884,172800000,174960000,175781250,\\n\\n\\n176947200,177147000,179159040,180000000,181398528,182250000,184320000,184528125,186624000,187500000,188743680,188956800,189843750,191102976,191318760,192000000,194400000,195312500,196608000,196830000,199065600,199290375,200000000,201326592,201553920,202500000,204073344,204800000,205031250,207360000,209715200,209952000,210937500,212336640,212576400,214990848,215233605,216000000,218700000,221184000,221433750,223948800,225000000,226492416,226748160,227812500,229582512,230400000,233280000,234375000,235929600,236196000,238878720,239148450,240000000,241864704,243000000,244140625,245760000,246037500,248832000,250000000,251658240,251942400,253125000,254803968,255091680,256000000,258280326,259200000,262144000,262440000,263671875,265420800,265720500,268435456,268738560,270000000,272097792,273375000,276480000,279936000,281250000,283115520,283435200,284765625,286654464,286978140,288000000,291600000,292968750,294912000,295245000,298598400,300000000,301989888,302330880,303750000,306110016,307200000,307546875,311040000,312500000,314572800,314928000,316406250,318504960,318864600,320000000,322486272,324000000,327680000,328050000,331776000,332150625,335544320,335923200,337500000,339738624,340122240,341718750,344373768,345600000,349920000,351562500,353894400,354294000,358318080,358722675,360000000,362797056,364500000,368640000,369056250,373248000,375000000,377487360,377913600,379687500,382205952,382637520,384000000,387420489,388800000,390625000,393216000,393660000,398131200,398580750,400000000,402653184,403107840,405000000,408146688,409600000,410062500,414720000,419430400,419904000,421875000,424673280,425152800,429981696,430467210,432000000,437400000,439453125,442368000,442867500,447897600,450000000,452984832,453496320,455625000,459165024,460800000,466560000,468750000,471859200,472392000,474609375,477757440,478296900,480000000,483729408,486000000,488281250,491520000,492075000,497664000,500000000,503316480,503884800,506250000,509607936,510183360,512000000,512578125,516560652,518400000,\\n\\n524288000,524880000,527343750,530841600,531441000,536870912,537477120,540000000,544195584,546750000,552960000,553584375,559872000,562500000,566231040,566870400,569531250,573308928,573956280,576000000,583200000,585937500,589824000,590490000,597196800,597871125,600000000,603979776,604661760,607500000,612220032,614400000,615093750,622080000,625000000,629145600,629856000,632812500,637009920,637729200,640000000,644972544,645700815,648000000,655360000,656100000,663552000,664301250,671088640,671846400,675000000,679477248,680244480,683437500,688747536,691200000,699840000,703125000,707788800,708588000,716636160,717445350,720000000,725594112,729000000,732421875,737280000,738112500,746496000,750000000,754974720,755827200,759375000,764411904,765275040,768000000,774840978,777600000,781250000,786432000,787320000,791015625,796262400,797161500,800000000,805306368,806215680,810000000,816293376,819200000,820125000,829440000,838860800,839808000,843750000,849346560,850305600,854296875,859963392,860934420,864000000,874800000,878906250,884736000,885735000,895795200,900000000,905969664,906992640,911250000,918330048,921600000,922640625,933120000,937500000,943718400,944784000,949218750,955514880,956593800,960000000,967458816,972000000,976562500,983040000,984150000,995328000,996451875,1000000000,1006632960,1007769600,1012500000,1019215872,1020366720,1024000000,1025156250,1033121304,1036800000,1048576000,1049760000,1054687500,1061683200,1062882000,1073741824,1074954240,1076168025,1080000000,1088391168,1093500000,1105920000,1107168750,1119744000,1125000000,1132462080,1133740800,1139062500,1146617856,1147912560,1152000000,1162261467,1166400000,1171875000,1179648000,1180980000,1194393600,1195742250,1200000000,1207959552,1209323520,1215000000,1220703125,1224440064,1228800000,1230187500,1244160000,1250000000,1258291200,1259712000,1265625000,1274019840,1275458400,1280000000,1289945088,1291401630,1296000000,1310720000,1312200000,1318359375,1327104000,1328602500,1342177280,1343692800,1350000000,1358954496,1360488960,1366875000,1377495072,1382400000,1399680000,1406250000,1415577600,1417176000,1423828125,1433272320,1434890700,1440000000,1451188224,1458000000,1464843750,1474560000,1476225000,1492992000,1500000000,1509949440,1511654400,1518750000,1528823808,1530550080,1536000000,1537734375,1549681956,1555200000,1562500000,1572864000,1574640000,1582031250,1592524800,1594323000,1600000000,1610612736,1612431360,1620000000,1632586752,1638400000,1640250000,1658880000,1660753125,1677721600,1679616000,1687500000,1698693120,1700611200,1708593750,1719926784,1721868840,1728000000,1749600000,1757812500,1769472000,1771470000,1791590400,1793613375,1800000000,1811939328,1813985280,1822500000,1836660096,1843200000,1845281250,1866240000,1875000000,1887436800,1889568000,1898437500,1911029760,1913187600,1920000000,1934917632,1937102445,1944000000,1953125000,1966080000,1968300000,1990656000,1992903750,2000000000,2013265920,2015539200,2025000000,2038431744,2040733440,2048000000,2050312500,2066242608,2073600000,2097152000,2099520000,2109375000,2123366400,2125764000,2147483648,2149908480,2152336050,2160000000,2176782336,2187000000,2197265625,2211840000,2214337500,2239488000\\n\\n\\n};\\n\\n    int nthUglyNumber(int n) {\\n        return ar[n-1]; \\n    }\\n};`"
                    },
                    {
                        "username": "AasheeshLikePanner",
                        "content": "Bro stop this \\uD83D\\uDE2D\\uD83D\\uDE2D\\uD83D\\uDE2D"
                    },
                    {
                        "username": "Mayank_Shahria",
                        "content": "**I have solved this by two methods \\n1. Brute force**\\nBut it is giving a run time error\\n![image](https://assets.leetcode.com/users/images/ba539fa1-405b-4d9d-832a-5be83172edc4_1620554425.1931248.png)\\n**2. Dynamic Programing**\\n![image](https://assets.leetcode.com/users/images/3a90f09e-1a3c-465f-a8d6-b58bfc613ccf_1620554465.9711976.png)\\n\\n\\n"
                    },
                    {
                        "username": "aman_online67",
                        "content": "I also applied brute force but it gives TLE at some 500 test case. But logic wise it is correct what to do now"
                    },
                    {
                        "username": "Rohith6776",
                        "content": "If the prime factors are limited to 2,3,5 and we should not consider numbers like(14->2*7, 21->3*7) right?"
                    },
                    {
                        "username": "wtfcoder",
                        "content": "yup"
                    },
                    {
                        "username": "c_jain",
                        "content": "After reading top solutions here, I realized optimized solution is not a DP solution because I am not able to figure out optimal substructure and overlapping subproblem. I think it is kind of 3 pointer solution. Anyone like to clarify this?"
                    },
                    {
                        "username": "vikasboss6855",
                        "content": "https://leetcode.com/problems/ugly-number-ii/solutions/3704058/c-memoized-solution-using-dp-forcible-dp/"
                    },
                    {
                        "username": "Gismet",
                        "content": "Yeah, you are right. I don't also think there is an optimal substructure and overlapping subproblem. I think the reason why they called this DP solution is that we use the previously computed ugly numbers to find the next one. If you checked out the hint, they say you can get the next ugly number from a smaller ugly number by multiplying it by either 2, 3 or 5. So we start from the bottom and work our way up to the nth ugly number, in each iteration finding the next ugly number using a previous one. But to see the overlapping subproblems, one would write a recursive solution, also called top-down, and see if there are any subproblems that overlaps. But I couldn't come up with recursive top-down solution. Or maybe there is an optimal substructure that I fail to see. "
                    },
                    {
                        "username": "logical_thinker",
                        "content": "can someone throw light on the last test case which is n being empty the 596th test case. what is that and how do I go about it."
                    },
                    {
                        "username": "urmichm",
                        "content": "why is 1 ugly number?"
                    },
                    {
                        "username": "at218808",
                        "content": "1 is a factor of every number , so its more like a ugly number has only factors as 1,2,3 or 5"
                    },
                    {
                        "username": "QuasiRus",
                        "content": "It does not have any prime factor outside [2, 3, 5] list. 1 itself is not a prime number."
                    }
                ]
            },
            {
                "id": 1576531,
                "content": [
                    {
                        "username": "chiru59",
                        "content": "This picture is a companion for other solutions likes this [one](https://leetcode.com/problems/ugly-number-ii/discuss/69364/My-16ms-C%2B%2B-DP-solution-with-short-explanation).\\n![image](https://user-images.githubusercontent.com/11798434/159383319-4c57d207-930c-4fe6-ae5b-f9a5d902a020.png)\\n\\n\\n"
                    },
                    {
                        "username": "pansari",
                        "content": "I had to use hashmap and a heap to solve this. Had fun. Though this might not be optimal but it worked for me. Only issue was that I faced overflow for bigger numbers. "
                    },
                    {
                        "username": "dsapelnikov",
                        "content": "A downvote for incorrect difficulty. It is definitely a hard problem, not a medium one."
                    },
                    {
                        "username": "sarpalmadhav",
                        "content": "Easy to implement once you have intuition but this was a **tricky question** IMO. Was not able to crack without reading somebody else\\'s explanation. "
                    },
                    {
                        "username": "sarvajnya_18",
                        "content": "Kindly help for my naive Python3 approach.\\n![image](https://mail.google.com/mail/u/0?ui=2&ik=2fc5b029c4&attid=0.1&permmsgid=msg-a:r-2790414687325196663&th=189fa15414cd7a41&view=fimg&fur=ip&sz=s0-l75-ft&attbid=ANGjdJ_NbD_fSRX8e2UpViBjauegCXXx6vKdBrQSNZYpgsRewhxE_HzouQiujPYnnwk5_5BisXfuoxRIyXQaH8YTIXtH3CHKXAJCgeBFoab40gEVVYPPIsQtMmN3Q7k&disp=emb&realattid=ii_llcj9qxy0)"
                    },
                    {
                        "username": "anandnit",
                        "content": "blank -----------\\n"
                    },
                    {
                        "username": "vikasboss6855",
                        "content": "For those who are thinking how it is DP Question/ want to see how DP solution can be given here\\n```\\nclass Solution {\\npublic:\\n    int nthUglyNumber(int n) {\\n        vector<int> dp(n);\\n        dp[0] = 1;\\n        return nthUglyNumberRecursive(dp, n, 1, 0, 0, 0);\\n    }\\n\\nprivate:\\n    int nthUglyNumberRecursive(vector<int>& dp, int n, int i, int p1, int p2, int p3) {\\n        if (i == n) {\\n            return dp[n - 1];\\n        }\\n\\n        int twoMultiple = dp[p1] * 2;\\n        int threeMultiple = dp[p2] * 3;\\n        int fiveMultiple = dp[p3] * 5;\\n\\n        dp[i] = min(twoMultiple, min(threeMultiple, fiveMultiple));\\n\\n        int nextP1 = (dp[i] == twoMultiple) ? p1 + 1 : p1;\\n        int nextP2 = (dp[i] == threeMultiple) ? p2 + 1 : p2;\\n        int nextP3 = (dp[i] == fiveMultiple) ? p3 + 1 : p3;\\n\\n        return nthUglyNumberRecursive(dp, n, i + 1, nextP1, nextP2, nextP3);\\n    }\\n};\\n\\n```"
                    },
                    {
                        "username": "vikasboss6855",
                        "content": "https://leetcode.com/problems/ugly-number-ii/solutions/3704058/c-memoized-solution-using-dp-forcible-dp/"
                    },
                    {
                        "username": "mohamed_waseela",
                        "content": "https://youtu.be/61i-qpZSfyg"
                    },
                    {
                        "username": "AnkushR10",
                        "content": "https://github.com/AnkushRawat10601/Leetcode/blob/main/264_UGLY_NUMBER_2.CPP"
                    },
                    {
                        "username": "samyaksk10",
                        "content": "class Solution {\\npublic:\\n    int nthUglyNumber(int n) {\\n        \\n       int cnt=1,ans;\\n        for(int i=2;i>1;i++)\\n        {\\n            if(i%2==0 || i%3==0 || i%5==0)\\n            {\\n                cnt++;\\n            }\\n            if(cnt==n) {ans=i;  break;}\\n        }\\n        return ans;\\n    }\\n};\\n\\nPlease tell me why this solution is giving TLE?"
                    },
                    {
                        "username": "vian_thaku_r",
                        "content": "if n=1.\\nthen cnt will be 2 when loop run for first time \\nhecnce cnt will keep increase & loop will never break"
                    }
                ]
            },
            {
                "id": 2053936,
                "content": [
                    {
                        "username": "chiru59",
                        "content": "This picture is a companion for other solutions likes this [one](https://leetcode.com/problems/ugly-number-ii/discuss/69364/My-16ms-C%2B%2B-DP-solution-with-short-explanation).\\n![image](https://user-images.githubusercontent.com/11798434/159383319-4c57d207-930c-4fe6-ae5b-f9a5d902a020.png)\\n\\n\\n"
                    },
                    {
                        "username": "pansari",
                        "content": "I had to use hashmap and a heap to solve this. Had fun. Though this might not be optimal but it worked for me. Only issue was that I faced overflow for bigger numbers. "
                    },
                    {
                        "username": "dsapelnikov",
                        "content": "A downvote for incorrect difficulty. It is definitely a hard problem, not a medium one."
                    },
                    {
                        "username": "sarpalmadhav",
                        "content": "Easy to implement once you have intuition but this was a **tricky question** IMO. Was not able to crack without reading somebody else\\'s explanation. "
                    },
                    {
                        "username": "sarvajnya_18",
                        "content": "Kindly help for my naive Python3 approach.\\n![image](https://mail.google.com/mail/u/0?ui=2&ik=2fc5b029c4&attid=0.1&permmsgid=msg-a:r-2790414687325196663&th=189fa15414cd7a41&view=fimg&fur=ip&sz=s0-l75-ft&attbid=ANGjdJ_NbD_fSRX8e2UpViBjauegCXXx6vKdBrQSNZYpgsRewhxE_HzouQiujPYnnwk5_5BisXfuoxRIyXQaH8YTIXtH3CHKXAJCgeBFoab40gEVVYPPIsQtMmN3Q7k&disp=emb&realattid=ii_llcj9qxy0)"
                    },
                    {
                        "username": "anandnit",
                        "content": "blank -----------\\n"
                    },
                    {
                        "username": "vikasboss6855",
                        "content": "For those who are thinking how it is DP Question/ want to see how DP solution can be given here\\n```\\nclass Solution {\\npublic:\\n    int nthUglyNumber(int n) {\\n        vector<int> dp(n);\\n        dp[0] = 1;\\n        return nthUglyNumberRecursive(dp, n, 1, 0, 0, 0);\\n    }\\n\\nprivate:\\n    int nthUglyNumberRecursive(vector<int>& dp, int n, int i, int p1, int p2, int p3) {\\n        if (i == n) {\\n            return dp[n - 1];\\n        }\\n\\n        int twoMultiple = dp[p1] * 2;\\n        int threeMultiple = dp[p2] * 3;\\n        int fiveMultiple = dp[p3] * 5;\\n\\n        dp[i] = min(twoMultiple, min(threeMultiple, fiveMultiple));\\n\\n        int nextP1 = (dp[i] == twoMultiple) ? p1 + 1 : p1;\\n        int nextP2 = (dp[i] == threeMultiple) ? p2 + 1 : p2;\\n        int nextP3 = (dp[i] == fiveMultiple) ? p3 + 1 : p3;\\n\\n        return nthUglyNumberRecursive(dp, n, i + 1, nextP1, nextP2, nextP3);\\n    }\\n};\\n\\n```"
                    },
                    {
                        "username": "vikasboss6855",
                        "content": "https://leetcode.com/problems/ugly-number-ii/solutions/3704058/c-memoized-solution-using-dp-forcible-dp/"
                    },
                    {
                        "username": "mohamed_waseela",
                        "content": "https://youtu.be/61i-qpZSfyg"
                    },
                    {
                        "username": "AnkushR10",
                        "content": "https://github.com/AnkushRawat10601/Leetcode/blob/main/264_UGLY_NUMBER_2.CPP"
                    },
                    {
                        "username": "samyaksk10",
                        "content": "class Solution {\\npublic:\\n    int nthUglyNumber(int n) {\\n        \\n       int cnt=1,ans;\\n        for(int i=2;i>1;i++)\\n        {\\n            if(i%2==0 || i%3==0 || i%5==0)\\n            {\\n                cnt++;\\n            }\\n            if(cnt==n) {ans=i;  break;}\\n        }\\n        return ans;\\n    }\\n};\\n\\nPlease tell me why this solution is giving TLE?"
                    },
                    {
                        "username": "vian_thaku_r",
                        "content": "if n=1.\\nthen cnt will be 2 when loop run for first time \\nhecnce cnt will keep increase & loop will never break"
                    }
                ]
            },
            {
                "id": 2039364,
                "content": [
                    {
                        "username": "chiru59",
                        "content": "This picture is a companion for other solutions likes this [one](https://leetcode.com/problems/ugly-number-ii/discuss/69364/My-16ms-C%2B%2B-DP-solution-with-short-explanation).\\n![image](https://user-images.githubusercontent.com/11798434/159383319-4c57d207-930c-4fe6-ae5b-f9a5d902a020.png)\\n\\n\\n"
                    },
                    {
                        "username": "pansari",
                        "content": "I had to use hashmap and a heap to solve this. Had fun. Though this might not be optimal but it worked for me. Only issue was that I faced overflow for bigger numbers. "
                    },
                    {
                        "username": "dsapelnikov",
                        "content": "A downvote for incorrect difficulty. It is definitely a hard problem, not a medium one."
                    },
                    {
                        "username": "sarpalmadhav",
                        "content": "Easy to implement once you have intuition but this was a **tricky question** IMO. Was not able to crack without reading somebody else\\'s explanation. "
                    },
                    {
                        "username": "sarvajnya_18",
                        "content": "Kindly help for my naive Python3 approach.\\n![image](https://mail.google.com/mail/u/0?ui=2&ik=2fc5b029c4&attid=0.1&permmsgid=msg-a:r-2790414687325196663&th=189fa15414cd7a41&view=fimg&fur=ip&sz=s0-l75-ft&attbid=ANGjdJ_NbD_fSRX8e2UpViBjauegCXXx6vKdBrQSNZYpgsRewhxE_HzouQiujPYnnwk5_5BisXfuoxRIyXQaH8YTIXtH3CHKXAJCgeBFoab40gEVVYPPIsQtMmN3Q7k&disp=emb&realattid=ii_llcj9qxy0)"
                    },
                    {
                        "username": "anandnit",
                        "content": "blank -----------\\n"
                    },
                    {
                        "username": "vikasboss6855",
                        "content": "For those who are thinking how it is DP Question/ want to see how DP solution can be given here\\n```\\nclass Solution {\\npublic:\\n    int nthUglyNumber(int n) {\\n        vector<int> dp(n);\\n        dp[0] = 1;\\n        return nthUglyNumberRecursive(dp, n, 1, 0, 0, 0);\\n    }\\n\\nprivate:\\n    int nthUglyNumberRecursive(vector<int>& dp, int n, int i, int p1, int p2, int p3) {\\n        if (i == n) {\\n            return dp[n - 1];\\n        }\\n\\n        int twoMultiple = dp[p1] * 2;\\n        int threeMultiple = dp[p2] * 3;\\n        int fiveMultiple = dp[p3] * 5;\\n\\n        dp[i] = min(twoMultiple, min(threeMultiple, fiveMultiple));\\n\\n        int nextP1 = (dp[i] == twoMultiple) ? p1 + 1 : p1;\\n        int nextP2 = (dp[i] == threeMultiple) ? p2 + 1 : p2;\\n        int nextP3 = (dp[i] == fiveMultiple) ? p3 + 1 : p3;\\n\\n        return nthUglyNumberRecursive(dp, n, i + 1, nextP1, nextP2, nextP3);\\n    }\\n};\\n\\n```"
                    },
                    {
                        "username": "vikasboss6855",
                        "content": "https://leetcode.com/problems/ugly-number-ii/solutions/3704058/c-memoized-solution-using-dp-forcible-dp/"
                    },
                    {
                        "username": "mohamed_waseela",
                        "content": "https://youtu.be/61i-qpZSfyg"
                    },
                    {
                        "username": "AnkushR10",
                        "content": "https://github.com/AnkushRawat10601/Leetcode/blob/main/264_UGLY_NUMBER_2.CPP"
                    },
                    {
                        "username": "samyaksk10",
                        "content": "class Solution {\\npublic:\\n    int nthUglyNumber(int n) {\\n        \\n       int cnt=1,ans;\\n        for(int i=2;i>1;i++)\\n        {\\n            if(i%2==0 || i%3==0 || i%5==0)\\n            {\\n                cnt++;\\n            }\\n            if(cnt==n) {ans=i;  break;}\\n        }\\n        return ans;\\n    }\\n};\\n\\nPlease tell me why this solution is giving TLE?"
                    },
                    {
                        "username": "vian_thaku_r",
                        "content": "if n=1.\\nthen cnt will be 2 when loop run for first time \\nhecnce cnt will keep increase & loop will never break"
                    }
                ]
            },
            {
                "id": 2023058,
                "content": [
                    {
                        "username": "chiru59",
                        "content": "This picture is a companion for other solutions likes this [one](https://leetcode.com/problems/ugly-number-ii/discuss/69364/My-16ms-C%2B%2B-DP-solution-with-short-explanation).\\n![image](https://user-images.githubusercontent.com/11798434/159383319-4c57d207-930c-4fe6-ae5b-f9a5d902a020.png)\\n\\n\\n"
                    },
                    {
                        "username": "pansari",
                        "content": "I had to use hashmap and a heap to solve this. Had fun. Though this might not be optimal but it worked for me. Only issue was that I faced overflow for bigger numbers. "
                    },
                    {
                        "username": "dsapelnikov",
                        "content": "A downvote for incorrect difficulty. It is definitely a hard problem, not a medium one."
                    },
                    {
                        "username": "sarpalmadhav",
                        "content": "Easy to implement once you have intuition but this was a **tricky question** IMO. Was not able to crack without reading somebody else\\'s explanation. "
                    },
                    {
                        "username": "sarvajnya_18",
                        "content": "Kindly help for my naive Python3 approach.\\n![image](https://mail.google.com/mail/u/0?ui=2&ik=2fc5b029c4&attid=0.1&permmsgid=msg-a:r-2790414687325196663&th=189fa15414cd7a41&view=fimg&fur=ip&sz=s0-l75-ft&attbid=ANGjdJ_NbD_fSRX8e2UpViBjauegCXXx6vKdBrQSNZYpgsRewhxE_HzouQiujPYnnwk5_5BisXfuoxRIyXQaH8YTIXtH3CHKXAJCgeBFoab40gEVVYPPIsQtMmN3Q7k&disp=emb&realattid=ii_llcj9qxy0)"
                    },
                    {
                        "username": "anandnit",
                        "content": "blank -----------\\n"
                    },
                    {
                        "username": "vikasboss6855",
                        "content": "For those who are thinking how it is DP Question/ want to see how DP solution can be given here\\n```\\nclass Solution {\\npublic:\\n    int nthUglyNumber(int n) {\\n        vector<int> dp(n);\\n        dp[0] = 1;\\n        return nthUglyNumberRecursive(dp, n, 1, 0, 0, 0);\\n    }\\n\\nprivate:\\n    int nthUglyNumberRecursive(vector<int>& dp, int n, int i, int p1, int p2, int p3) {\\n        if (i == n) {\\n            return dp[n - 1];\\n        }\\n\\n        int twoMultiple = dp[p1] * 2;\\n        int threeMultiple = dp[p2] * 3;\\n        int fiveMultiple = dp[p3] * 5;\\n\\n        dp[i] = min(twoMultiple, min(threeMultiple, fiveMultiple));\\n\\n        int nextP1 = (dp[i] == twoMultiple) ? p1 + 1 : p1;\\n        int nextP2 = (dp[i] == threeMultiple) ? p2 + 1 : p2;\\n        int nextP3 = (dp[i] == fiveMultiple) ? p3 + 1 : p3;\\n\\n        return nthUglyNumberRecursive(dp, n, i + 1, nextP1, nextP2, nextP3);\\n    }\\n};\\n\\n```"
                    },
                    {
                        "username": "vikasboss6855",
                        "content": "https://leetcode.com/problems/ugly-number-ii/solutions/3704058/c-memoized-solution-using-dp-forcible-dp/"
                    },
                    {
                        "username": "mohamed_waseela",
                        "content": "https://youtu.be/61i-qpZSfyg"
                    },
                    {
                        "username": "AnkushR10",
                        "content": "https://github.com/AnkushRawat10601/Leetcode/blob/main/264_UGLY_NUMBER_2.CPP"
                    },
                    {
                        "username": "samyaksk10",
                        "content": "class Solution {\\npublic:\\n    int nthUglyNumber(int n) {\\n        \\n       int cnt=1,ans;\\n        for(int i=2;i>1;i++)\\n        {\\n            if(i%2==0 || i%3==0 || i%5==0)\\n            {\\n                cnt++;\\n            }\\n            if(cnt==n) {ans=i;  break;}\\n        }\\n        return ans;\\n    }\\n};\\n\\nPlease tell me why this solution is giving TLE?"
                    },
                    {
                        "username": "vian_thaku_r",
                        "content": "if n=1.\\nthen cnt will be 2 when loop run for first time \\nhecnce cnt will keep increase & loop will never break"
                    }
                ]
            },
            {
                "id": 2015678,
                "content": [
                    {
                        "username": "chiru59",
                        "content": "This picture is a companion for other solutions likes this [one](https://leetcode.com/problems/ugly-number-ii/discuss/69364/My-16ms-C%2B%2B-DP-solution-with-short-explanation).\\n![image](https://user-images.githubusercontent.com/11798434/159383319-4c57d207-930c-4fe6-ae5b-f9a5d902a020.png)\\n\\n\\n"
                    },
                    {
                        "username": "pansari",
                        "content": "I had to use hashmap and a heap to solve this. Had fun. Though this might not be optimal but it worked for me. Only issue was that I faced overflow for bigger numbers. "
                    },
                    {
                        "username": "dsapelnikov",
                        "content": "A downvote for incorrect difficulty. It is definitely a hard problem, not a medium one."
                    },
                    {
                        "username": "sarpalmadhav",
                        "content": "Easy to implement once you have intuition but this was a **tricky question** IMO. Was not able to crack without reading somebody else\\'s explanation. "
                    },
                    {
                        "username": "sarvajnya_18",
                        "content": "Kindly help for my naive Python3 approach.\\n![image](https://mail.google.com/mail/u/0?ui=2&ik=2fc5b029c4&attid=0.1&permmsgid=msg-a:r-2790414687325196663&th=189fa15414cd7a41&view=fimg&fur=ip&sz=s0-l75-ft&attbid=ANGjdJ_NbD_fSRX8e2UpViBjauegCXXx6vKdBrQSNZYpgsRewhxE_HzouQiujPYnnwk5_5BisXfuoxRIyXQaH8YTIXtH3CHKXAJCgeBFoab40gEVVYPPIsQtMmN3Q7k&disp=emb&realattid=ii_llcj9qxy0)"
                    },
                    {
                        "username": "anandnit",
                        "content": "blank -----------\\n"
                    },
                    {
                        "username": "vikasboss6855",
                        "content": "For those who are thinking how it is DP Question/ want to see how DP solution can be given here\\n```\\nclass Solution {\\npublic:\\n    int nthUglyNumber(int n) {\\n        vector<int> dp(n);\\n        dp[0] = 1;\\n        return nthUglyNumberRecursive(dp, n, 1, 0, 0, 0);\\n    }\\n\\nprivate:\\n    int nthUglyNumberRecursive(vector<int>& dp, int n, int i, int p1, int p2, int p3) {\\n        if (i == n) {\\n            return dp[n - 1];\\n        }\\n\\n        int twoMultiple = dp[p1] * 2;\\n        int threeMultiple = dp[p2] * 3;\\n        int fiveMultiple = dp[p3] * 5;\\n\\n        dp[i] = min(twoMultiple, min(threeMultiple, fiveMultiple));\\n\\n        int nextP1 = (dp[i] == twoMultiple) ? p1 + 1 : p1;\\n        int nextP2 = (dp[i] == threeMultiple) ? p2 + 1 : p2;\\n        int nextP3 = (dp[i] == fiveMultiple) ? p3 + 1 : p3;\\n\\n        return nthUglyNumberRecursive(dp, n, i + 1, nextP1, nextP2, nextP3);\\n    }\\n};\\n\\n```"
                    },
                    {
                        "username": "vikasboss6855",
                        "content": "https://leetcode.com/problems/ugly-number-ii/solutions/3704058/c-memoized-solution-using-dp-forcible-dp/"
                    },
                    {
                        "username": "mohamed_waseela",
                        "content": "https://youtu.be/61i-qpZSfyg"
                    },
                    {
                        "username": "AnkushR10",
                        "content": "https://github.com/AnkushRawat10601/Leetcode/blob/main/264_UGLY_NUMBER_2.CPP"
                    },
                    {
                        "username": "samyaksk10",
                        "content": "class Solution {\\npublic:\\n    int nthUglyNumber(int n) {\\n        \\n       int cnt=1,ans;\\n        for(int i=2;i>1;i++)\\n        {\\n            if(i%2==0 || i%3==0 || i%5==0)\\n            {\\n                cnt++;\\n            }\\n            if(cnt==n) {ans=i;  break;}\\n        }\\n        return ans;\\n    }\\n};\\n\\nPlease tell me why this solution is giving TLE?"
                    },
                    {
                        "username": "vian_thaku_r",
                        "content": "if n=1.\\nthen cnt will be 2 when loop run for first time \\nhecnce cnt will keep increase & loop will never break"
                    }
                ]
            },
            {
                "id": 1953418,
                "content": [
                    {
                        "username": "chiru59",
                        "content": "This picture is a companion for other solutions likes this [one](https://leetcode.com/problems/ugly-number-ii/discuss/69364/My-16ms-C%2B%2B-DP-solution-with-short-explanation).\\n![image](https://user-images.githubusercontent.com/11798434/159383319-4c57d207-930c-4fe6-ae5b-f9a5d902a020.png)\\n\\n\\n"
                    },
                    {
                        "username": "pansari",
                        "content": "I had to use hashmap and a heap to solve this. Had fun. Though this might not be optimal but it worked for me. Only issue was that I faced overflow for bigger numbers. "
                    },
                    {
                        "username": "dsapelnikov",
                        "content": "A downvote for incorrect difficulty. It is definitely a hard problem, not a medium one."
                    },
                    {
                        "username": "sarpalmadhav",
                        "content": "Easy to implement once you have intuition but this was a **tricky question** IMO. Was not able to crack without reading somebody else\\'s explanation. "
                    },
                    {
                        "username": "sarvajnya_18",
                        "content": "Kindly help for my naive Python3 approach.\\n![image](https://mail.google.com/mail/u/0?ui=2&ik=2fc5b029c4&attid=0.1&permmsgid=msg-a:r-2790414687325196663&th=189fa15414cd7a41&view=fimg&fur=ip&sz=s0-l75-ft&attbid=ANGjdJ_NbD_fSRX8e2UpViBjauegCXXx6vKdBrQSNZYpgsRewhxE_HzouQiujPYnnwk5_5BisXfuoxRIyXQaH8YTIXtH3CHKXAJCgeBFoab40gEVVYPPIsQtMmN3Q7k&disp=emb&realattid=ii_llcj9qxy0)"
                    },
                    {
                        "username": "anandnit",
                        "content": "blank -----------\\n"
                    },
                    {
                        "username": "vikasboss6855",
                        "content": "For those who are thinking how it is DP Question/ want to see how DP solution can be given here\\n```\\nclass Solution {\\npublic:\\n    int nthUglyNumber(int n) {\\n        vector<int> dp(n);\\n        dp[0] = 1;\\n        return nthUglyNumberRecursive(dp, n, 1, 0, 0, 0);\\n    }\\n\\nprivate:\\n    int nthUglyNumberRecursive(vector<int>& dp, int n, int i, int p1, int p2, int p3) {\\n        if (i == n) {\\n            return dp[n - 1];\\n        }\\n\\n        int twoMultiple = dp[p1] * 2;\\n        int threeMultiple = dp[p2] * 3;\\n        int fiveMultiple = dp[p3] * 5;\\n\\n        dp[i] = min(twoMultiple, min(threeMultiple, fiveMultiple));\\n\\n        int nextP1 = (dp[i] == twoMultiple) ? p1 + 1 : p1;\\n        int nextP2 = (dp[i] == threeMultiple) ? p2 + 1 : p2;\\n        int nextP3 = (dp[i] == fiveMultiple) ? p3 + 1 : p3;\\n\\n        return nthUglyNumberRecursive(dp, n, i + 1, nextP1, nextP2, nextP3);\\n    }\\n};\\n\\n```"
                    },
                    {
                        "username": "vikasboss6855",
                        "content": "https://leetcode.com/problems/ugly-number-ii/solutions/3704058/c-memoized-solution-using-dp-forcible-dp/"
                    },
                    {
                        "username": "mohamed_waseela",
                        "content": "https://youtu.be/61i-qpZSfyg"
                    },
                    {
                        "username": "AnkushR10",
                        "content": "https://github.com/AnkushRawat10601/Leetcode/blob/main/264_UGLY_NUMBER_2.CPP"
                    },
                    {
                        "username": "samyaksk10",
                        "content": "class Solution {\\npublic:\\n    int nthUglyNumber(int n) {\\n        \\n       int cnt=1,ans;\\n        for(int i=2;i>1;i++)\\n        {\\n            if(i%2==0 || i%3==0 || i%5==0)\\n            {\\n                cnt++;\\n            }\\n            if(cnt==n) {ans=i;  break;}\\n        }\\n        return ans;\\n    }\\n};\\n\\nPlease tell me why this solution is giving TLE?"
                    },
                    {
                        "username": "vian_thaku_r",
                        "content": "if n=1.\\nthen cnt will be 2 when loop run for first time \\nhecnce cnt will keep increase & loop will never break"
                    }
                ]
            },
            {
                "id": 1951598,
                "content": [
                    {
                        "username": "chiru59",
                        "content": "This picture is a companion for other solutions likes this [one](https://leetcode.com/problems/ugly-number-ii/discuss/69364/My-16ms-C%2B%2B-DP-solution-with-short-explanation).\\n![image](https://user-images.githubusercontent.com/11798434/159383319-4c57d207-930c-4fe6-ae5b-f9a5d902a020.png)\\n\\n\\n"
                    },
                    {
                        "username": "pansari",
                        "content": "I had to use hashmap and a heap to solve this. Had fun. Though this might not be optimal but it worked for me. Only issue was that I faced overflow for bigger numbers. "
                    },
                    {
                        "username": "dsapelnikov",
                        "content": "A downvote for incorrect difficulty. It is definitely a hard problem, not a medium one."
                    },
                    {
                        "username": "sarpalmadhav",
                        "content": "Easy to implement once you have intuition but this was a **tricky question** IMO. Was not able to crack without reading somebody else\\'s explanation. "
                    },
                    {
                        "username": "sarvajnya_18",
                        "content": "Kindly help for my naive Python3 approach.\\n![image](https://mail.google.com/mail/u/0?ui=2&ik=2fc5b029c4&attid=0.1&permmsgid=msg-a:r-2790414687325196663&th=189fa15414cd7a41&view=fimg&fur=ip&sz=s0-l75-ft&attbid=ANGjdJ_NbD_fSRX8e2UpViBjauegCXXx6vKdBrQSNZYpgsRewhxE_HzouQiujPYnnwk5_5BisXfuoxRIyXQaH8YTIXtH3CHKXAJCgeBFoab40gEVVYPPIsQtMmN3Q7k&disp=emb&realattid=ii_llcj9qxy0)"
                    },
                    {
                        "username": "anandnit",
                        "content": "blank -----------\\n"
                    },
                    {
                        "username": "vikasboss6855",
                        "content": "For those who are thinking how it is DP Question/ want to see how DP solution can be given here\\n```\\nclass Solution {\\npublic:\\n    int nthUglyNumber(int n) {\\n        vector<int> dp(n);\\n        dp[0] = 1;\\n        return nthUglyNumberRecursive(dp, n, 1, 0, 0, 0);\\n    }\\n\\nprivate:\\n    int nthUglyNumberRecursive(vector<int>& dp, int n, int i, int p1, int p2, int p3) {\\n        if (i == n) {\\n            return dp[n - 1];\\n        }\\n\\n        int twoMultiple = dp[p1] * 2;\\n        int threeMultiple = dp[p2] * 3;\\n        int fiveMultiple = dp[p3] * 5;\\n\\n        dp[i] = min(twoMultiple, min(threeMultiple, fiveMultiple));\\n\\n        int nextP1 = (dp[i] == twoMultiple) ? p1 + 1 : p1;\\n        int nextP2 = (dp[i] == threeMultiple) ? p2 + 1 : p2;\\n        int nextP3 = (dp[i] == fiveMultiple) ? p3 + 1 : p3;\\n\\n        return nthUglyNumberRecursive(dp, n, i + 1, nextP1, nextP2, nextP3);\\n    }\\n};\\n\\n```"
                    },
                    {
                        "username": "vikasboss6855",
                        "content": "https://leetcode.com/problems/ugly-number-ii/solutions/3704058/c-memoized-solution-using-dp-forcible-dp/"
                    },
                    {
                        "username": "mohamed_waseela",
                        "content": "https://youtu.be/61i-qpZSfyg"
                    },
                    {
                        "username": "AnkushR10",
                        "content": "https://github.com/AnkushRawat10601/Leetcode/blob/main/264_UGLY_NUMBER_2.CPP"
                    },
                    {
                        "username": "samyaksk10",
                        "content": "class Solution {\\npublic:\\n    int nthUglyNumber(int n) {\\n        \\n       int cnt=1,ans;\\n        for(int i=2;i>1;i++)\\n        {\\n            if(i%2==0 || i%3==0 || i%5==0)\\n            {\\n                cnt++;\\n            }\\n            if(cnt==n) {ans=i;  break;}\\n        }\\n        return ans;\\n    }\\n};\\n\\nPlease tell me why this solution is giving TLE?"
                    },
                    {
                        "username": "vian_thaku_r",
                        "content": "if n=1.\\nthen cnt will be 2 when loop run for first time \\nhecnce cnt will keep increase & loop will never break"
                    }
                ]
            },
            {
                "id": 1769777,
                "content": [
                    {
                        "username": "chiru59",
                        "content": "This picture is a companion for other solutions likes this [one](https://leetcode.com/problems/ugly-number-ii/discuss/69364/My-16ms-C%2B%2B-DP-solution-with-short-explanation).\\n![image](https://user-images.githubusercontent.com/11798434/159383319-4c57d207-930c-4fe6-ae5b-f9a5d902a020.png)\\n\\n\\n"
                    },
                    {
                        "username": "pansari",
                        "content": "I had to use hashmap and a heap to solve this. Had fun. Though this might not be optimal but it worked for me. Only issue was that I faced overflow for bigger numbers. "
                    },
                    {
                        "username": "dsapelnikov",
                        "content": "A downvote for incorrect difficulty. It is definitely a hard problem, not a medium one."
                    },
                    {
                        "username": "sarpalmadhav",
                        "content": "Easy to implement once you have intuition but this was a **tricky question** IMO. Was not able to crack without reading somebody else\\'s explanation. "
                    },
                    {
                        "username": "sarvajnya_18",
                        "content": "Kindly help for my naive Python3 approach.\\n![image](https://mail.google.com/mail/u/0?ui=2&ik=2fc5b029c4&attid=0.1&permmsgid=msg-a:r-2790414687325196663&th=189fa15414cd7a41&view=fimg&fur=ip&sz=s0-l75-ft&attbid=ANGjdJ_NbD_fSRX8e2UpViBjauegCXXx6vKdBrQSNZYpgsRewhxE_HzouQiujPYnnwk5_5BisXfuoxRIyXQaH8YTIXtH3CHKXAJCgeBFoab40gEVVYPPIsQtMmN3Q7k&disp=emb&realattid=ii_llcj9qxy0)"
                    },
                    {
                        "username": "anandnit",
                        "content": "blank -----------\\n"
                    },
                    {
                        "username": "vikasboss6855",
                        "content": "For those who are thinking how it is DP Question/ want to see how DP solution can be given here\\n```\\nclass Solution {\\npublic:\\n    int nthUglyNumber(int n) {\\n        vector<int> dp(n);\\n        dp[0] = 1;\\n        return nthUglyNumberRecursive(dp, n, 1, 0, 0, 0);\\n    }\\n\\nprivate:\\n    int nthUglyNumberRecursive(vector<int>& dp, int n, int i, int p1, int p2, int p3) {\\n        if (i == n) {\\n            return dp[n - 1];\\n        }\\n\\n        int twoMultiple = dp[p1] * 2;\\n        int threeMultiple = dp[p2] * 3;\\n        int fiveMultiple = dp[p3] * 5;\\n\\n        dp[i] = min(twoMultiple, min(threeMultiple, fiveMultiple));\\n\\n        int nextP1 = (dp[i] == twoMultiple) ? p1 + 1 : p1;\\n        int nextP2 = (dp[i] == threeMultiple) ? p2 + 1 : p2;\\n        int nextP3 = (dp[i] == fiveMultiple) ? p3 + 1 : p3;\\n\\n        return nthUglyNumberRecursive(dp, n, i + 1, nextP1, nextP2, nextP3);\\n    }\\n};\\n\\n```"
                    },
                    {
                        "username": "vikasboss6855",
                        "content": "https://leetcode.com/problems/ugly-number-ii/solutions/3704058/c-memoized-solution-using-dp-forcible-dp/"
                    },
                    {
                        "username": "mohamed_waseela",
                        "content": "https://youtu.be/61i-qpZSfyg"
                    },
                    {
                        "username": "AnkushR10",
                        "content": "https://github.com/AnkushRawat10601/Leetcode/blob/main/264_UGLY_NUMBER_2.CPP"
                    },
                    {
                        "username": "samyaksk10",
                        "content": "class Solution {\\npublic:\\n    int nthUglyNumber(int n) {\\n        \\n       int cnt=1,ans;\\n        for(int i=2;i>1;i++)\\n        {\\n            if(i%2==0 || i%3==0 || i%5==0)\\n            {\\n                cnt++;\\n            }\\n            if(cnt==n) {ans=i;  break;}\\n        }\\n        return ans;\\n    }\\n};\\n\\nPlease tell me why this solution is giving TLE?"
                    },
                    {
                        "username": "vian_thaku_r",
                        "content": "if n=1.\\nthen cnt will be 2 when loop run for first time \\nhecnce cnt will keep increase & loop will never break"
                    }
                ]
            },
            {
                "id": 1729921,
                "content": [
                    {
                        "username": "chiru59",
                        "content": "This picture is a companion for other solutions likes this [one](https://leetcode.com/problems/ugly-number-ii/discuss/69364/My-16ms-C%2B%2B-DP-solution-with-short-explanation).\\n![image](https://user-images.githubusercontent.com/11798434/159383319-4c57d207-930c-4fe6-ae5b-f9a5d902a020.png)\\n\\n\\n"
                    },
                    {
                        "username": "pansari",
                        "content": "I had to use hashmap and a heap to solve this. Had fun. Though this might not be optimal but it worked for me. Only issue was that I faced overflow for bigger numbers. "
                    },
                    {
                        "username": "dsapelnikov",
                        "content": "A downvote for incorrect difficulty. It is definitely a hard problem, not a medium one."
                    },
                    {
                        "username": "sarpalmadhav",
                        "content": "Easy to implement once you have intuition but this was a **tricky question** IMO. Was not able to crack without reading somebody else\\'s explanation. "
                    },
                    {
                        "username": "sarvajnya_18",
                        "content": "Kindly help for my naive Python3 approach.\\n![image](https://mail.google.com/mail/u/0?ui=2&ik=2fc5b029c4&attid=0.1&permmsgid=msg-a:r-2790414687325196663&th=189fa15414cd7a41&view=fimg&fur=ip&sz=s0-l75-ft&attbid=ANGjdJ_NbD_fSRX8e2UpViBjauegCXXx6vKdBrQSNZYpgsRewhxE_HzouQiujPYnnwk5_5BisXfuoxRIyXQaH8YTIXtH3CHKXAJCgeBFoab40gEVVYPPIsQtMmN3Q7k&disp=emb&realattid=ii_llcj9qxy0)"
                    },
                    {
                        "username": "anandnit",
                        "content": "blank -----------\\n"
                    },
                    {
                        "username": "vikasboss6855",
                        "content": "For those who are thinking how it is DP Question/ want to see how DP solution can be given here\\n```\\nclass Solution {\\npublic:\\n    int nthUglyNumber(int n) {\\n        vector<int> dp(n);\\n        dp[0] = 1;\\n        return nthUglyNumberRecursive(dp, n, 1, 0, 0, 0);\\n    }\\n\\nprivate:\\n    int nthUglyNumberRecursive(vector<int>& dp, int n, int i, int p1, int p2, int p3) {\\n        if (i == n) {\\n            return dp[n - 1];\\n        }\\n\\n        int twoMultiple = dp[p1] * 2;\\n        int threeMultiple = dp[p2] * 3;\\n        int fiveMultiple = dp[p3] * 5;\\n\\n        dp[i] = min(twoMultiple, min(threeMultiple, fiveMultiple));\\n\\n        int nextP1 = (dp[i] == twoMultiple) ? p1 + 1 : p1;\\n        int nextP2 = (dp[i] == threeMultiple) ? p2 + 1 : p2;\\n        int nextP3 = (dp[i] == fiveMultiple) ? p3 + 1 : p3;\\n\\n        return nthUglyNumberRecursive(dp, n, i + 1, nextP1, nextP2, nextP3);\\n    }\\n};\\n\\n```"
                    },
                    {
                        "username": "vikasboss6855",
                        "content": "https://leetcode.com/problems/ugly-number-ii/solutions/3704058/c-memoized-solution-using-dp-forcible-dp/"
                    },
                    {
                        "username": "mohamed_waseela",
                        "content": "https://youtu.be/61i-qpZSfyg"
                    },
                    {
                        "username": "AnkushR10",
                        "content": "https://github.com/AnkushRawat10601/Leetcode/blob/main/264_UGLY_NUMBER_2.CPP"
                    },
                    {
                        "username": "samyaksk10",
                        "content": "class Solution {\\npublic:\\n    int nthUglyNumber(int n) {\\n        \\n       int cnt=1,ans;\\n        for(int i=2;i>1;i++)\\n        {\\n            if(i%2==0 || i%3==0 || i%5==0)\\n            {\\n                cnt++;\\n            }\\n            if(cnt==n) {ans=i;  break;}\\n        }\\n        return ans;\\n    }\\n};\\n\\nPlease tell me why this solution is giving TLE?"
                    },
                    {
                        "username": "vian_thaku_r",
                        "content": "if n=1.\\nthen cnt will be 2 when loop run for first time \\nhecnce cnt will keep increase & loop will never break"
                    }
                ]
            },
            {
                "id": 1725355,
                "content": [
                    {
                        "username": "chiru59",
                        "content": "This picture is a companion for other solutions likes this [one](https://leetcode.com/problems/ugly-number-ii/discuss/69364/My-16ms-C%2B%2B-DP-solution-with-short-explanation).\\n![image](https://user-images.githubusercontent.com/11798434/159383319-4c57d207-930c-4fe6-ae5b-f9a5d902a020.png)\\n\\n\\n"
                    },
                    {
                        "username": "pansari",
                        "content": "I had to use hashmap and a heap to solve this. Had fun. Though this might not be optimal but it worked for me. Only issue was that I faced overflow for bigger numbers. "
                    },
                    {
                        "username": "dsapelnikov",
                        "content": "A downvote for incorrect difficulty. It is definitely a hard problem, not a medium one."
                    },
                    {
                        "username": "sarpalmadhav",
                        "content": "Easy to implement once you have intuition but this was a **tricky question** IMO. Was not able to crack without reading somebody else\\'s explanation. "
                    },
                    {
                        "username": "sarvajnya_18",
                        "content": "Kindly help for my naive Python3 approach.\\n![image](https://mail.google.com/mail/u/0?ui=2&ik=2fc5b029c4&attid=0.1&permmsgid=msg-a:r-2790414687325196663&th=189fa15414cd7a41&view=fimg&fur=ip&sz=s0-l75-ft&attbid=ANGjdJ_NbD_fSRX8e2UpViBjauegCXXx6vKdBrQSNZYpgsRewhxE_HzouQiujPYnnwk5_5BisXfuoxRIyXQaH8YTIXtH3CHKXAJCgeBFoab40gEVVYPPIsQtMmN3Q7k&disp=emb&realattid=ii_llcj9qxy0)"
                    },
                    {
                        "username": "anandnit",
                        "content": "blank -----------\\n"
                    },
                    {
                        "username": "vikasboss6855",
                        "content": "For those who are thinking how it is DP Question/ want to see how DP solution can be given here\\n```\\nclass Solution {\\npublic:\\n    int nthUglyNumber(int n) {\\n        vector<int> dp(n);\\n        dp[0] = 1;\\n        return nthUglyNumberRecursive(dp, n, 1, 0, 0, 0);\\n    }\\n\\nprivate:\\n    int nthUglyNumberRecursive(vector<int>& dp, int n, int i, int p1, int p2, int p3) {\\n        if (i == n) {\\n            return dp[n - 1];\\n        }\\n\\n        int twoMultiple = dp[p1] * 2;\\n        int threeMultiple = dp[p2] * 3;\\n        int fiveMultiple = dp[p3] * 5;\\n\\n        dp[i] = min(twoMultiple, min(threeMultiple, fiveMultiple));\\n\\n        int nextP1 = (dp[i] == twoMultiple) ? p1 + 1 : p1;\\n        int nextP2 = (dp[i] == threeMultiple) ? p2 + 1 : p2;\\n        int nextP3 = (dp[i] == fiveMultiple) ? p3 + 1 : p3;\\n\\n        return nthUglyNumberRecursive(dp, n, i + 1, nextP1, nextP2, nextP3);\\n    }\\n};\\n\\n```"
                    },
                    {
                        "username": "vikasboss6855",
                        "content": "https://leetcode.com/problems/ugly-number-ii/solutions/3704058/c-memoized-solution-using-dp-forcible-dp/"
                    },
                    {
                        "username": "mohamed_waseela",
                        "content": "https://youtu.be/61i-qpZSfyg"
                    },
                    {
                        "username": "AnkushR10",
                        "content": "https://github.com/AnkushRawat10601/Leetcode/blob/main/264_UGLY_NUMBER_2.CPP"
                    },
                    {
                        "username": "samyaksk10",
                        "content": "class Solution {\\npublic:\\n    int nthUglyNumber(int n) {\\n        \\n       int cnt=1,ans;\\n        for(int i=2;i>1;i++)\\n        {\\n            if(i%2==0 || i%3==0 || i%5==0)\\n            {\\n                cnt++;\\n            }\\n            if(cnt==n) {ans=i;  break;}\\n        }\\n        return ans;\\n    }\\n};\\n\\nPlease tell me why this solution is giving TLE?"
                    },
                    {
                        "username": "vian_thaku_r",
                        "content": "if n=1.\\nthen cnt will be 2 when loop run for first time \\nhecnce cnt will keep increase & loop will never break"
                    }
                ]
            }
        ]
    },
    {
        "title": "Nested List Weight Sum II",
        "question_content": null,
        "solutions": [],
        "discussions": [
            {
                "id": 1571638,
                "content": [
                    {
                        "username": "yubad2000",
                        "content": "I checked some of the answers shared so far. Most of them did not pass the test case of [1,[4,[6,[[]] ] ]] which leads to a multi-level empty list. So, I am not sure whether these solutions got accepted or not. If they do, then the test cases of this problem are too weak. \\nI think Leecode needs to do a better QA job before releasing any problem set. Instead, they paid ppl to create problems for $50 each and get the misleading results. \\nThis is not a good sign....."
                    },
                    {
                        "username": "NeosDeus",
                        "content": "Because the definition states that integers increase depth, but empty lists have no integers? "
                    },
                    {
                        "username": "xiaogezhang",
                        "content": "how about leaves at different levels?\\n\\nfor example, test case \\n[[-1],[[-1]]]\\n\\nboth are leaf nodes, but different level."
                    },
                    {
                        "username": "imgreghenry",
                        "content": "I\\'m still pretty unclear on how to handle multi-level empty lists.\\n[1, []] == 1\\n[1, [[]]] == 2\\n[1, [[[]]]] == 3\\n\\n `Let maxDepth be the maximum depth of any integer.`\\n1 is the only integer here and it\\'s at depth 1, yet we seem to count all the other instances of sublists?\\n\\nSeems this should be corrected to `Let maxDepth be the maximum depth of any NestedInteger` maybe? Or am I missing something here?"
                    },
                    {
                        "username": "dinusX",
                        "content": "I think it\\'s calculating depth based on non-empty arrays:\\n```\\n[] == 0\\n[1] == 1\\n[1,[]] == 1 # inside array is empty so not increasing depth\\n[1,[2]] == 2 # inside array has one element so increasing depth\\n[1,[[]]] == 2 # last array is empty\\n```\\n"
                    },
                    {
                        "username": "LeetCode",
                        "content": "This problem is the Daily LeetCoding Challenge for December, Week 2.\n\nFeel free to share anything related to this problem here!\n\nYou can ask questions, discuss what you've learned from this problem, or show off how many days of streak you've made!\n\n---\n\nIf you'd like to share a detailed solution to the problem, please create a new post in the discuss section and provide\n- **Detailed Explanations**: Describe the algorithm you used to solve this problem. Include any insights you used to solve this problem.\n- **Images** that help explain the algorithm.\n- **Language and Code** you used to pass the problem.\n- **Time and Space complexity analysis**.\n\n---\n\n  **📌 Do you want to learn the problem thoroughly?**\n  Read [**⭐  LeetCode Official Solution⭐**](https://leetcode.com/problems/nested-list-weight-sum-ii/solution) to learn the 3 approaches to the problem with detailed explanations to the algorithms, codes, and complexity analysis.\n  <details>\n  <summary> Spoiler Alert! We'll explain these 3 approaches in the official solution</summary>\n\n  \n**Approach 1:** Double Pass Depth-First Search (DFS)\n\n  \n**Approach 2:** Single Pass Depth-First Search (DFS)\n\n  \n**Approach 3:** Single Pass Breadth-First Search (BFS)\n\n  \n</details>\n\n\n\nIf you're new to Daily LeetCoding Challenge, [**check out this post**](https://leetcode.com/discuss/general-discussion/655704/)!\n\n\n---\n\n<br>\n\n<p align=\"center\">\n<a href=\"https://leetcode.com/subscribe/?ref=ex_dc\" target=\"_blank\">\n  <img src=\"https://assets.leetcode.com/static_assets/marketing/daily_leetcoding_banner.png\" width=\"560px\" />\n</a>\n</p>\n\n<br>"
                    },
                    {
                        "username": "srishti7",
                        "content": "Seems like LC added a new test case to this question , for the multilevel empty list: [[1,1],2,[1,1],[[[[]]]]]\\nThis didn\\'t exist before? My previously submitted code, does to clear this anymore. "
                    },
                    {
                        "username": "happyAD",
                        "content": "I also checked some answers, but they all don\\'t pass the[[1,1],2,[1,1],[[[[]]]]]. I\\'m really confused about how to resolve this multiple  empty nested list\\n"
                    },
                    {
                        "username": "19thhell",
                        "content": "empty list doesn\\'t count as depth, so the last element has depth 4 rather than 5, this affects the max_depth calculation. this problem description sucks, you had to guess in order to find out how to handle empty list"
                    },
                    {
                        "username": "7doxxer7",
                        "content": "the clues for manipulating NestedList object in the commented section is not helpful. I could not make this object be manipulated by ANY method - hence skipping."
                    }
                ]
            },
            {
                "id": 1567255,
                "content": [
                    {
                        "username": "yubad2000",
                        "content": "I checked some of the answers shared so far. Most of them did not pass the test case of [1,[4,[6,[[]] ] ]] which leads to a multi-level empty list. So, I am not sure whether these solutions got accepted or not. If they do, then the test cases of this problem are too weak. \\nI think Leecode needs to do a better QA job before releasing any problem set. Instead, they paid ppl to create problems for $50 each and get the misleading results. \\nThis is not a good sign....."
                    },
                    {
                        "username": "NeosDeus",
                        "content": "Because the definition states that integers increase depth, but empty lists have no integers? "
                    },
                    {
                        "username": "xiaogezhang",
                        "content": "how about leaves at different levels?\\n\\nfor example, test case \\n[[-1],[[-1]]]\\n\\nboth are leaf nodes, but different level."
                    },
                    {
                        "username": "imgreghenry",
                        "content": "I\\'m still pretty unclear on how to handle multi-level empty lists.\\n[1, []] == 1\\n[1, [[]]] == 2\\n[1, [[[]]]] == 3\\n\\n `Let maxDepth be the maximum depth of any integer.`\\n1 is the only integer here and it\\'s at depth 1, yet we seem to count all the other instances of sublists?\\n\\nSeems this should be corrected to `Let maxDepth be the maximum depth of any NestedInteger` maybe? Or am I missing something here?"
                    },
                    {
                        "username": "dinusX",
                        "content": "I think it\\'s calculating depth based on non-empty arrays:\\n```\\n[] == 0\\n[1] == 1\\n[1,[]] == 1 # inside array is empty so not increasing depth\\n[1,[2]] == 2 # inside array has one element so increasing depth\\n[1,[[]]] == 2 # last array is empty\\n```\\n"
                    },
                    {
                        "username": "LeetCode",
                        "content": "This problem is the Daily LeetCoding Challenge for December, Week 2.\n\nFeel free to share anything related to this problem here!\n\nYou can ask questions, discuss what you've learned from this problem, or show off how many days of streak you've made!\n\n---\n\nIf you'd like to share a detailed solution to the problem, please create a new post in the discuss section and provide\n- **Detailed Explanations**: Describe the algorithm you used to solve this problem. Include any insights you used to solve this problem.\n- **Images** that help explain the algorithm.\n- **Language and Code** you used to pass the problem.\n- **Time and Space complexity analysis**.\n\n---\n\n  **📌 Do you want to learn the problem thoroughly?**\n  Read [**⭐  LeetCode Official Solution⭐**](https://leetcode.com/problems/nested-list-weight-sum-ii/solution) to learn the 3 approaches to the problem with detailed explanations to the algorithms, codes, and complexity analysis.\n  <details>\n  <summary> Spoiler Alert! We'll explain these 3 approaches in the official solution</summary>\n\n  \n**Approach 1:** Double Pass Depth-First Search (DFS)\n\n  \n**Approach 2:** Single Pass Depth-First Search (DFS)\n\n  \n**Approach 3:** Single Pass Breadth-First Search (BFS)\n\n  \n</details>\n\n\n\nIf you're new to Daily LeetCoding Challenge, [**check out this post**](https://leetcode.com/discuss/general-discussion/655704/)!\n\n\n---\n\n<br>\n\n<p align=\"center\">\n<a href=\"https://leetcode.com/subscribe/?ref=ex_dc\" target=\"_blank\">\n  <img src=\"https://assets.leetcode.com/static_assets/marketing/daily_leetcoding_banner.png\" width=\"560px\" />\n</a>\n</p>\n\n<br>"
                    },
                    {
                        "username": "srishti7",
                        "content": "Seems like LC added a new test case to this question , for the multilevel empty list: [[1,1],2,[1,1],[[[[]]]]]\\nThis didn\\'t exist before? My previously submitted code, does to clear this anymore. "
                    },
                    {
                        "username": "happyAD",
                        "content": "I also checked some answers, but they all don\\'t pass the[[1,1],2,[1,1],[[[[]]]]]. I\\'m really confused about how to resolve this multiple  empty nested list\\n"
                    },
                    {
                        "username": "19thhell",
                        "content": "empty list doesn\\'t count as depth, so the last element has depth 4 rather than 5, this affects the max_depth calculation. this problem description sucks, you had to guess in order to find out how to handle empty list"
                    },
                    {
                        "username": "7doxxer7",
                        "content": "the clues for manipulating NestedList object in the commented section is not helpful. I could not make this object be manipulated by ANY method - hence skipping."
                    }
                ]
            },
            {
                "id": 1698374,
                "content": [
                    {
                        "username": "yubad2000",
                        "content": "I checked some of the answers shared so far. Most of them did not pass the test case of [1,[4,[6,[[]] ] ]] which leads to a multi-level empty list. So, I am not sure whether these solutions got accepted or not. If they do, then the test cases of this problem are too weak. \\nI think Leecode needs to do a better QA job before releasing any problem set. Instead, they paid ppl to create problems for $50 each and get the misleading results. \\nThis is not a good sign....."
                    },
                    {
                        "username": "NeosDeus",
                        "content": "Because the definition states that integers increase depth, but empty lists have no integers? "
                    },
                    {
                        "username": "xiaogezhang",
                        "content": "how about leaves at different levels?\\n\\nfor example, test case \\n[[-1],[[-1]]]\\n\\nboth are leaf nodes, but different level."
                    },
                    {
                        "username": "imgreghenry",
                        "content": "I\\'m still pretty unclear on how to handle multi-level empty lists.\\n[1, []] == 1\\n[1, [[]]] == 2\\n[1, [[[]]]] == 3\\n\\n `Let maxDepth be the maximum depth of any integer.`\\n1 is the only integer here and it\\'s at depth 1, yet we seem to count all the other instances of sublists?\\n\\nSeems this should be corrected to `Let maxDepth be the maximum depth of any NestedInteger` maybe? Or am I missing something here?"
                    },
                    {
                        "username": "dinusX",
                        "content": "I think it\\'s calculating depth based on non-empty arrays:\\n```\\n[] == 0\\n[1] == 1\\n[1,[]] == 1 # inside array is empty so not increasing depth\\n[1,[2]] == 2 # inside array has one element so increasing depth\\n[1,[[]]] == 2 # last array is empty\\n```\\n"
                    },
                    {
                        "username": "LeetCode",
                        "content": "This problem is the Daily LeetCoding Challenge for December, Week 2.\n\nFeel free to share anything related to this problem here!\n\nYou can ask questions, discuss what you've learned from this problem, or show off how many days of streak you've made!\n\n---\n\nIf you'd like to share a detailed solution to the problem, please create a new post in the discuss section and provide\n- **Detailed Explanations**: Describe the algorithm you used to solve this problem. Include any insights you used to solve this problem.\n- **Images** that help explain the algorithm.\n- **Language and Code** you used to pass the problem.\n- **Time and Space complexity analysis**.\n\n---\n\n  **📌 Do you want to learn the problem thoroughly?**\n  Read [**⭐  LeetCode Official Solution⭐**](https://leetcode.com/problems/nested-list-weight-sum-ii/solution) to learn the 3 approaches to the problem with detailed explanations to the algorithms, codes, and complexity analysis.\n  <details>\n  <summary> Spoiler Alert! We'll explain these 3 approaches in the official solution</summary>\n\n  \n**Approach 1:** Double Pass Depth-First Search (DFS)\n\n  \n**Approach 2:** Single Pass Depth-First Search (DFS)\n\n  \n**Approach 3:** Single Pass Breadth-First Search (BFS)\n\n  \n</details>\n\n\n\nIf you're new to Daily LeetCoding Challenge, [**check out this post**](https://leetcode.com/discuss/general-discussion/655704/)!\n\n\n---\n\n<br>\n\n<p align=\"center\">\n<a href=\"https://leetcode.com/subscribe/?ref=ex_dc\" target=\"_blank\">\n  <img src=\"https://assets.leetcode.com/static_assets/marketing/daily_leetcoding_banner.png\" width=\"560px\" />\n</a>\n</p>\n\n<br>"
                    },
                    {
                        "username": "srishti7",
                        "content": "Seems like LC added a new test case to this question , for the multilevel empty list: [[1,1],2,[1,1],[[[[]]]]]\\nThis didn\\'t exist before? My previously submitted code, does to clear this anymore. "
                    },
                    {
                        "username": "happyAD",
                        "content": "I also checked some answers, but they all don\\'t pass the[[1,1],2,[1,1],[[[[]]]]]. I\\'m really confused about how to resolve this multiple  empty nested list\\n"
                    },
                    {
                        "username": "19thhell",
                        "content": "empty list doesn\\'t count as depth, so the last element has depth 4 rather than 5, this affects the max_depth calculation. this problem description sucks, you had to guess in order to find out how to handle empty list"
                    },
                    {
                        "username": "7doxxer7",
                        "content": "the clues for manipulating NestedList object in the commented section is not helpful. I could not make this object be manipulated by ANY method - hence skipping."
                    }
                ]
            },
            {
                "id": 1576062,
                "content": [
                    {
                        "username": "yubad2000",
                        "content": "I checked some of the answers shared so far. Most of them did not pass the test case of [1,[4,[6,[[]] ] ]] which leads to a multi-level empty list. So, I am not sure whether these solutions got accepted or not. If they do, then the test cases of this problem are too weak. \\nI think Leecode needs to do a better QA job before releasing any problem set. Instead, they paid ppl to create problems for $50 each and get the misleading results. \\nThis is not a good sign....."
                    },
                    {
                        "username": "NeosDeus",
                        "content": "Because the definition states that integers increase depth, but empty lists have no integers? "
                    },
                    {
                        "username": "xiaogezhang",
                        "content": "how about leaves at different levels?\\n\\nfor example, test case \\n[[-1],[[-1]]]\\n\\nboth are leaf nodes, but different level."
                    },
                    {
                        "username": "imgreghenry",
                        "content": "I\\'m still pretty unclear on how to handle multi-level empty lists.\\n[1, []] == 1\\n[1, [[]]] == 2\\n[1, [[[]]]] == 3\\n\\n `Let maxDepth be the maximum depth of any integer.`\\n1 is the only integer here and it\\'s at depth 1, yet we seem to count all the other instances of sublists?\\n\\nSeems this should be corrected to `Let maxDepth be the maximum depth of any NestedInteger` maybe? Or am I missing something here?"
                    },
                    {
                        "username": "dinusX",
                        "content": "I think it\\'s calculating depth based on non-empty arrays:\\n```\\n[] == 0\\n[1] == 1\\n[1,[]] == 1 # inside array is empty so not increasing depth\\n[1,[2]] == 2 # inside array has one element so increasing depth\\n[1,[[]]] == 2 # last array is empty\\n```\\n"
                    },
                    {
                        "username": "LeetCode",
                        "content": "This problem is the Daily LeetCoding Challenge for December, Week 2.\n\nFeel free to share anything related to this problem here!\n\nYou can ask questions, discuss what you've learned from this problem, or show off how many days of streak you've made!\n\n---\n\nIf you'd like to share a detailed solution to the problem, please create a new post in the discuss section and provide\n- **Detailed Explanations**: Describe the algorithm you used to solve this problem. Include any insights you used to solve this problem.\n- **Images** that help explain the algorithm.\n- **Language and Code** you used to pass the problem.\n- **Time and Space complexity analysis**.\n\n---\n\n  **📌 Do you want to learn the problem thoroughly?**\n  Read [**⭐  LeetCode Official Solution⭐**](https://leetcode.com/problems/nested-list-weight-sum-ii/solution) to learn the 3 approaches to the problem with detailed explanations to the algorithms, codes, and complexity analysis.\n  <details>\n  <summary> Spoiler Alert! We'll explain these 3 approaches in the official solution</summary>\n\n  \n**Approach 1:** Double Pass Depth-First Search (DFS)\n\n  \n**Approach 2:** Single Pass Depth-First Search (DFS)\n\n  \n**Approach 3:** Single Pass Breadth-First Search (BFS)\n\n  \n</details>\n\n\n\nIf you're new to Daily LeetCoding Challenge, [**check out this post**](https://leetcode.com/discuss/general-discussion/655704/)!\n\n\n---\n\n<br>\n\n<p align=\"center\">\n<a href=\"https://leetcode.com/subscribe/?ref=ex_dc\" target=\"_blank\">\n  <img src=\"https://assets.leetcode.com/static_assets/marketing/daily_leetcoding_banner.png\" width=\"560px\" />\n</a>\n</p>\n\n<br>"
                    },
                    {
                        "username": "srishti7",
                        "content": "Seems like LC added a new test case to this question , for the multilevel empty list: [[1,1],2,[1,1],[[[[]]]]]\\nThis didn\\'t exist before? My previously submitted code, does to clear this anymore. "
                    },
                    {
                        "username": "happyAD",
                        "content": "I also checked some answers, but they all don\\'t pass the[[1,1],2,[1,1],[[[[]]]]]. I\\'m really confused about how to resolve this multiple  empty nested list\\n"
                    },
                    {
                        "username": "19thhell",
                        "content": "empty list doesn\\'t count as depth, so the last element has depth 4 rather than 5, this affects the max_depth calculation. this problem description sucks, you had to guess in order to find out how to handle empty list"
                    },
                    {
                        "username": "7doxxer7",
                        "content": "the clues for manipulating NestedList object in the commented section is not helpful. I could not make this object be manipulated by ANY method - hence skipping."
                    }
                ]
            },
            {
                "id": 1797376,
                "content": [
                    {
                        "username": "yubad2000",
                        "content": "I checked some of the answers shared so far. Most of them did not pass the test case of [1,[4,[6,[[]] ] ]] which leads to a multi-level empty list. So, I am not sure whether these solutions got accepted or not. If they do, then the test cases of this problem are too weak. \\nI think Leecode needs to do a better QA job before releasing any problem set. Instead, they paid ppl to create problems for $50 each and get the misleading results. \\nThis is not a good sign....."
                    },
                    {
                        "username": "NeosDeus",
                        "content": "Because the definition states that integers increase depth, but empty lists have no integers? "
                    },
                    {
                        "username": "xiaogezhang",
                        "content": "how about leaves at different levels?\\n\\nfor example, test case \\n[[-1],[[-1]]]\\n\\nboth are leaf nodes, but different level."
                    },
                    {
                        "username": "imgreghenry",
                        "content": "I\\'m still pretty unclear on how to handle multi-level empty lists.\\n[1, []] == 1\\n[1, [[]]] == 2\\n[1, [[[]]]] == 3\\n\\n `Let maxDepth be the maximum depth of any integer.`\\n1 is the only integer here and it\\'s at depth 1, yet we seem to count all the other instances of sublists?\\n\\nSeems this should be corrected to `Let maxDepth be the maximum depth of any NestedInteger` maybe? Or am I missing something here?"
                    },
                    {
                        "username": "dinusX",
                        "content": "I think it\\'s calculating depth based on non-empty arrays:\\n```\\n[] == 0\\n[1] == 1\\n[1,[]] == 1 # inside array is empty so not increasing depth\\n[1,[2]] == 2 # inside array has one element so increasing depth\\n[1,[[]]] == 2 # last array is empty\\n```\\n"
                    },
                    {
                        "username": "LeetCode",
                        "content": "This problem is the Daily LeetCoding Challenge for December, Week 2.\n\nFeel free to share anything related to this problem here!\n\nYou can ask questions, discuss what you've learned from this problem, or show off how many days of streak you've made!\n\n---\n\nIf you'd like to share a detailed solution to the problem, please create a new post in the discuss section and provide\n- **Detailed Explanations**: Describe the algorithm you used to solve this problem. Include any insights you used to solve this problem.\n- **Images** that help explain the algorithm.\n- **Language and Code** you used to pass the problem.\n- **Time and Space complexity analysis**.\n\n---\n\n  **📌 Do you want to learn the problem thoroughly?**\n  Read [**⭐  LeetCode Official Solution⭐**](https://leetcode.com/problems/nested-list-weight-sum-ii/solution) to learn the 3 approaches to the problem with detailed explanations to the algorithms, codes, and complexity analysis.\n  <details>\n  <summary> Spoiler Alert! We'll explain these 3 approaches in the official solution</summary>\n\n  \n**Approach 1:** Double Pass Depth-First Search (DFS)\n\n  \n**Approach 2:** Single Pass Depth-First Search (DFS)\n\n  \n**Approach 3:** Single Pass Breadth-First Search (BFS)\n\n  \n</details>\n\n\n\nIf you're new to Daily LeetCoding Challenge, [**check out this post**](https://leetcode.com/discuss/general-discussion/655704/)!\n\n\n---\n\n<br>\n\n<p align=\"center\">\n<a href=\"https://leetcode.com/subscribe/?ref=ex_dc\" target=\"_blank\">\n  <img src=\"https://assets.leetcode.com/static_assets/marketing/daily_leetcoding_banner.png\" width=\"560px\" />\n</a>\n</p>\n\n<br>"
                    },
                    {
                        "username": "srishti7",
                        "content": "Seems like LC added a new test case to this question , for the multilevel empty list: [[1,1],2,[1,1],[[[[]]]]]\\nThis didn\\'t exist before? My previously submitted code, does to clear this anymore. "
                    },
                    {
                        "username": "happyAD",
                        "content": "I also checked some answers, but they all don\\'t pass the[[1,1],2,[1,1],[[[[]]]]]. I\\'m really confused about how to resolve this multiple  empty nested list\\n"
                    },
                    {
                        "username": "19thhell",
                        "content": "empty list doesn\\'t count as depth, so the last element has depth 4 rather than 5, this affects the max_depth calculation. this problem description sucks, you had to guess in order to find out how to handle empty list"
                    },
                    {
                        "username": "7doxxer7",
                        "content": "the clues for manipulating NestedList object in the commented section is not helpful. I could not make this object be manipulated by ANY method - hence skipping."
                    }
                ]
            },
            {
                "id": 1790637,
                "content": [
                    {
                        "username": "yubad2000",
                        "content": "I checked some of the answers shared so far. Most of them did not pass the test case of [1,[4,[6,[[]] ] ]] which leads to a multi-level empty list. So, I am not sure whether these solutions got accepted or not. If they do, then the test cases of this problem are too weak. \\nI think Leecode needs to do a better QA job before releasing any problem set. Instead, they paid ppl to create problems for $50 each and get the misleading results. \\nThis is not a good sign....."
                    },
                    {
                        "username": "NeosDeus",
                        "content": "Because the definition states that integers increase depth, but empty lists have no integers? "
                    },
                    {
                        "username": "xiaogezhang",
                        "content": "how about leaves at different levels?\\n\\nfor example, test case \\n[[-1],[[-1]]]\\n\\nboth are leaf nodes, but different level."
                    },
                    {
                        "username": "imgreghenry",
                        "content": "I\\'m still pretty unclear on how to handle multi-level empty lists.\\n[1, []] == 1\\n[1, [[]]] == 2\\n[1, [[[]]]] == 3\\n\\n `Let maxDepth be the maximum depth of any integer.`\\n1 is the only integer here and it\\'s at depth 1, yet we seem to count all the other instances of sublists?\\n\\nSeems this should be corrected to `Let maxDepth be the maximum depth of any NestedInteger` maybe? Or am I missing something here?"
                    },
                    {
                        "username": "dinusX",
                        "content": "I think it\\'s calculating depth based on non-empty arrays:\\n```\\n[] == 0\\n[1] == 1\\n[1,[]] == 1 # inside array is empty so not increasing depth\\n[1,[2]] == 2 # inside array has one element so increasing depth\\n[1,[[]]] == 2 # last array is empty\\n```\\n"
                    },
                    {
                        "username": "LeetCode",
                        "content": "This problem is the Daily LeetCoding Challenge for December, Week 2.\n\nFeel free to share anything related to this problem here!\n\nYou can ask questions, discuss what you've learned from this problem, or show off how many days of streak you've made!\n\n---\n\nIf you'd like to share a detailed solution to the problem, please create a new post in the discuss section and provide\n- **Detailed Explanations**: Describe the algorithm you used to solve this problem. Include any insights you used to solve this problem.\n- **Images** that help explain the algorithm.\n- **Language and Code** you used to pass the problem.\n- **Time and Space complexity analysis**.\n\n---\n\n  **📌 Do you want to learn the problem thoroughly?**\n  Read [**⭐  LeetCode Official Solution⭐**](https://leetcode.com/problems/nested-list-weight-sum-ii/solution) to learn the 3 approaches to the problem with detailed explanations to the algorithms, codes, and complexity analysis.\n  <details>\n  <summary> Spoiler Alert! We'll explain these 3 approaches in the official solution</summary>\n\n  \n**Approach 1:** Double Pass Depth-First Search (DFS)\n\n  \n**Approach 2:** Single Pass Depth-First Search (DFS)\n\n  \n**Approach 3:** Single Pass Breadth-First Search (BFS)\n\n  \n</details>\n\n\n\nIf you're new to Daily LeetCoding Challenge, [**check out this post**](https://leetcode.com/discuss/general-discussion/655704/)!\n\n\n---\n\n<br>\n\n<p align=\"center\">\n<a href=\"https://leetcode.com/subscribe/?ref=ex_dc\" target=\"_blank\">\n  <img src=\"https://assets.leetcode.com/static_assets/marketing/daily_leetcoding_banner.png\" width=\"560px\" />\n</a>\n</p>\n\n<br>"
                    },
                    {
                        "username": "srishti7",
                        "content": "Seems like LC added a new test case to this question , for the multilevel empty list: [[1,1],2,[1,1],[[[[]]]]]\\nThis didn\\'t exist before? My previously submitted code, does to clear this anymore. "
                    },
                    {
                        "username": "happyAD",
                        "content": "I also checked some answers, but they all don\\'t pass the[[1,1],2,[1,1],[[[[]]]]]. I\\'m really confused about how to resolve this multiple  empty nested list\\n"
                    },
                    {
                        "username": "19thhell",
                        "content": "empty list doesn\\'t count as depth, so the last element has depth 4 rather than 5, this affects the max_depth calculation. this problem description sucks, you had to guess in order to find out how to handle empty list"
                    },
                    {
                        "username": "7doxxer7",
                        "content": "the clues for manipulating NestedList object in the commented section is not helpful. I could not make this object be manipulated by ANY method - hence skipping."
                    }
                ]
            },
            {
                "id": 1725700,
                "content": [
                    {
                        "username": "yubad2000",
                        "content": "I checked some of the answers shared so far. Most of them did not pass the test case of [1,[4,[6,[[]] ] ]] which leads to a multi-level empty list. So, I am not sure whether these solutions got accepted or not. If they do, then the test cases of this problem are too weak. \\nI think Leecode needs to do a better QA job before releasing any problem set. Instead, they paid ppl to create problems for $50 each and get the misleading results. \\nThis is not a good sign....."
                    },
                    {
                        "username": "NeosDeus",
                        "content": "Because the definition states that integers increase depth, but empty lists have no integers? "
                    },
                    {
                        "username": "xiaogezhang",
                        "content": "how about leaves at different levels?\\n\\nfor example, test case \\n[[-1],[[-1]]]\\n\\nboth are leaf nodes, but different level."
                    },
                    {
                        "username": "imgreghenry",
                        "content": "I\\'m still pretty unclear on how to handle multi-level empty lists.\\n[1, []] == 1\\n[1, [[]]] == 2\\n[1, [[[]]]] == 3\\n\\n `Let maxDepth be the maximum depth of any integer.`\\n1 is the only integer here and it\\'s at depth 1, yet we seem to count all the other instances of sublists?\\n\\nSeems this should be corrected to `Let maxDepth be the maximum depth of any NestedInteger` maybe? Or am I missing something here?"
                    },
                    {
                        "username": "dinusX",
                        "content": "I think it\\'s calculating depth based on non-empty arrays:\\n```\\n[] == 0\\n[1] == 1\\n[1,[]] == 1 # inside array is empty so not increasing depth\\n[1,[2]] == 2 # inside array has one element so increasing depth\\n[1,[[]]] == 2 # last array is empty\\n```\\n"
                    },
                    {
                        "username": "LeetCode",
                        "content": "This problem is the Daily LeetCoding Challenge for December, Week 2.\n\nFeel free to share anything related to this problem here!\n\nYou can ask questions, discuss what you've learned from this problem, or show off how many days of streak you've made!\n\n---\n\nIf you'd like to share a detailed solution to the problem, please create a new post in the discuss section and provide\n- **Detailed Explanations**: Describe the algorithm you used to solve this problem. Include any insights you used to solve this problem.\n- **Images** that help explain the algorithm.\n- **Language and Code** you used to pass the problem.\n- **Time and Space complexity analysis**.\n\n---\n\n  **📌 Do you want to learn the problem thoroughly?**\n  Read [**⭐  LeetCode Official Solution⭐**](https://leetcode.com/problems/nested-list-weight-sum-ii/solution) to learn the 3 approaches to the problem with detailed explanations to the algorithms, codes, and complexity analysis.\n  <details>\n  <summary> Spoiler Alert! We'll explain these 3 approaches in the official solution</summary>\n\n  \n**Approach 1:** Double Pass Depth-First Search (DFS)\n\n  \n**Approach 2:** Single Pass Depth-First Search (DFS)\n\n  \n**Approach 3:** Single Pass Breadth-First Search (BFS)\n\n  \n</details>\n\n\n\nIf you're new to Daily LeetCoding Challenge, [**check out this post**](https://leetcode.com/discuss/general-discussion/655704/)!\n\n\n---\n\n<br>\n\n<p align=\"center\">\n<a href=\"https://leetcode.com/subscribe/?ref=ex_dc\" target=\"_blank\">\n  <img src=\"https://assets.leetcode.com/static_assets/marketing/daily_leetcoding_banner.png\" width=\"560px\" />\n</a>\n</p>\n\n<br>"
                    },
                    {
                        "username": "srishti7",
                        "content": "Seems like LC added a new test case to this question , for the multilevel empty list: [[1,1],2,[1,1],[[[[]]]]]\\nThis didn\\'t exist before? My previously submitted code, does to clear this anymore. "
                    },
                    {
                        "username": "happyAD",
                        "content": "I also checked some answers, but they all don\\'t pass the[[1,1],2,[1,1],[[[[]]]]]. I\\'m really confused about how to resolve this multiple  empty nested list\\n"
                    },
                    {
                        "username": "19thhell",
                        "content": "empty list doesn\\'t count as depth, so the last element has depth 4 rather than 5, this affects the max_depth calculation. this problem description sucks, you had to guess in order to find out how to handle empty list"
                    },
                    {
                        "username": "7doxxer7",
                        "content": "the clues for manipulating NestedList object in the commented section is not helpful. I could not make this object be manipulated by ANY method - hence skipping."
                    }
                ]
            }
        ]
    },
    {
        "title": "Can I Win",
        "question_content": "<p>In the &quot;100 game&quot; two players take turns adding, to a running total, any integer from <code>1</code> to <code>10</code>. The player who first causes the running total to <strong>reach or exceed</strong> 100 wins.</p>\n\n<p>What if we change the game so that players <strong>cannot</strong> re-use integers?</p>\n\n<p>For example, two players might take turns drawing from a common pool of numbers from 1 to 15 without replacement until they reach a total &gt;= 100.</p>\n\n<p>Given two integers <code>maxChoosableInteger</code> and <code>desiredTotal</code>, return <code>true</code> if the first player to move can force a win, otherwise, return <code>false</code>. Assume both players play <strong>optimally</strong>.</p>\n\n<p>&nbsp;</p>\n<p><strong class=\"example\">Example 1:</strong></p>\n\n<pre>\n<strong>Input:</strong> maxChoosableInteger = 10, desiredTotal = 11\n<strong>Output:</strong> false\n<strong>Explanation:</strong>\nNo matter which integer the first player choose, the first player will lose.\nThe first player can choose an integer from 1 up to 10.\nIf the first player choose 1, the second player can only choose integers from 2 up to 10.\nThe second player will win by choosing 10 and get a total = 11, which is &gt;= desiredTotal.\nSame with other integers chosen by the first player, the second player will always win.\n</pre>\n\n<p><strong class=\"example\">Example 2:</strong></p>\n\n<pre>\n<strong>Input:</strong> maxChoosableInteger = 10, desiredTotal = 0\n<strong>Output:</strong> true\n</pre>\n\n<p><strong class=\"example\">Example 3:</strong></p>\n\n<pre>\n<strong>Input:</strong> maxChoosableInteger = 10, desiredTotal = 1\n<strong>Output:</strong> true\n</pre>\n\n<p>&nbsp;</p>\n<p><strong>Constraints:</strong></p>\n\n<ul>\n\t<li><code>1 &lt;= maxChoosableInteger &lt;= 20</code></li>\n\t<li><code>0 &lt;= desiredTotal &lt;= 300</code></li>\n</ul>\n",
        "solutions": [
            {
                "id": 95277,
                "title": "java-solution-using-hashmap-with-detailed-explanation",
                "content": "After solving several \"Game Playing\" questions in leetcode, I find them to be pretty similar. Most of them can be solved using the **top-down DP** approach, which \"brute-forcely\" simulates every possible state of the game. \\n\\nThe key part for the top-down dp strategy is that we need to **avoid repeatedly solving sub-problems**. Instead, we should use some strategy to \"remember\" the outcome of  sub-problems. Then when we see them again, we instantly know their result.  By doing this, ~~we can always reduce time complexity from **exponential** to **polynomial**~~. \\n(**EDIT:** Thanks for @billbirdh for pointing out the mistake here. For this problem, by applying the memo, we at most compute for every subproblem once, and there are ```O(2^n)``` subproblems, so the complexity is  ```O(2^n)``` after memorization. (Without memo, time complexity should be like ```O(n!)```)\\n\\nFor this question, the key part is: ```what is the state of the game```? Intuitively, to uniquely determine the result of any state, we need to know: \\n1) The unchosen numbers \\n2) The remaining desiredTotal to reach\\n\\nA second thought reveals that **1)** and **2)** are actually related because we can always get the **2)** by deducting the sum of chosen numbers from original desiredTotal.\\n\\nThen the problem becomes how to describe the state using **1)**.\\n\\nIn my solution, I use a **boolean array** to denote which numbers have been chosen, and  then a question comes to mind, if we want to use a Hashmap to remember the outcome of sub-problems, can we just use ```Map<boolean[], Boolean>``` ? **Obviously we cannot**, because the if we use boolean[] as a key, the reference to boolean[] won't reveal the actual content in boolean[]. \\n\\nSince in the problem statement, it says ```maxChoosableInteger``` will not be larger than ```20```, which means the length of our **boolean[] array** will be less than ```20```. Then we can use an ```Integer``` to represent this boolean[] array. How?\\n\\nSay the boolean[] is ```{false, false, true, true, false}```, then we can transfer it to an Integer with binary representation as ```00110```. Since Integer is a perfect choice to be the key of HashMap, then we now can \"memorize\" the sub-problems using ```Map<Integer, Boolean>```. \\n\\nThe rest part of the solution is just simulating the game process using the top-down dp.\\n\\n```\\npublic class Solution {\\n    Map<Integer, Boolean> map;\\n    boolean[] used;\\n    public boolean canIWin(int maxChoosableInteger, int desiredTotal) {\\n        int sum = (1+maxChoosableInteger)*maxChoosableInteger/2;\\n        if(sum < desiredTotal) return false;\\n        if(desiredTotal <= 0) return true;\\n        \\n        map = new HashMap();\\n        used = new boolean[maxChoosableInteger+1];\\n        return helper(desiredTotal);\\n    }\\n    \\n    public boolean helper(int desiredTotal){\\n        if(desiredTotal <= 0) return false;\\n        int key = format(used);\\n        if(!map.containsKey(key)){\\n    // try every unchosen number as next step\\n            for(int i=1; i<used.length; i++){\\n                if(!used[i]){\\n                    used[i] = true;\\n     // check whether this lead to a win (i.e. the other player lose)\\n                    if(!helper(desiredTotal-i)){\\n                        map.put(key, true);\\n                        used[i] = false;\\n                        return true;\\n                    }\\n                    used[i] = false;\\n                }\\n            }\\n            map.put(key, false);\\n        }\\n        return map.get(key);\\n    }\\n   \\n// transfer boolean[] to an Integer \\n    public int format(boolean[] used){\\n        int num = 0;\\n        for(boolean b: used){\\n            num <<= 1;\\n            if(b) num |= 1;\\n        }\\n        return num;\\n    }\\n}\\n```\\n\\n**Updated:** Thanks for @ckcz123 for sharing the great idea. In Java, to denote ```boolean[]```, an easier way is to use ```Arrays.toString(boolean[])```, which will transfer a ```boolean[]``` to sth like ```\"[true, false, false, ....]\"```, which is also not limited to how ```maxChoosableInteger``` is set, so it can be generalized to arbitrary large ```maxChoosableInteger```.",
                "solutionTags": [],
                "code": "```O(2^n)```\n```O(2^n)```\n```O(n!)```\n```what is the state of the game```\n```Map<boolean[], Boolean>```\n```maxChoosableInteger```\n```20```\n```20```\n```Integer```\n```{false, false, true, true, false}```\n```00110```\n```Map<Integer, Boolean>```\n```\\npublic class Solution {\\n    Map<Integer, Boolean> map;\\n    boolean[] used;\\n    public boolean canIWin(int maxChoosableInteger, int desiredTotal) {\\n        int sum = (1+maxChoosableInteger)*maxChoosableInteger/2;\\n        if(sum < desiredTotal) return false;\\n        if(desiredTotal <= 0) return true;\\n        \\n        map = new HashMap();\\n        used = new boolean[maxChoosableInteger+1];\\n        return helper(desiredTotal);\\n    }\\n    \\n    public boolean helper(int desiredTotal){\\n        if(desiredTotal <= 0) return false;\\n        int key = format(used);\\n        if(!map.containsKey(key)){\\n    // try every unchosen number as next step\\n            for(int i=1; i<used.length; i++){\\n                if(!used[i]){\\n                    used[i] = true;\\n     // check whether this lead to a win (i.e. the other player lose)\\n                    if(!helper(desiredTotal-i)){\\n                        map.put(key, true);\\n                        used[i] = false;\\n                        return true;\\n                    }\\n                    used[i] = false;\\n                }\\n            }\\n            map.put(key, false);\\n        }\\n        return map.get(key);\\n    }\\n   \\n// transfer boolean[] to an Integer \\n    public int format(boolean[] used){\\n        int num = 0;\\n        for(boolean b: used){\\n            num <<= 1;\\n            if(b) num |= 1;\\n        }\\n        return num;\\n    }\\n}\\n```\n```boolean[]```\n```Arrays.toString(boolean[])```\n```boolean[]```\n```\"[true, false, false, ....]\"```\n```maxChoosableInteger```\n```maxChoosableInteger```",
                "codeTag": "Java"
            },
            {
                "id": 159797,
                "title": "python-98-5-simple-readable-code-with-good-comments",
                "content": "```\\nclass Solution:\\n    def canIWin(self, maxChoosableInteger, desiredTotal):\\n        \"\"\"\\n        :type maxChoosableInteger: int\\n        :type desiredTotal: int\\n        :rtype: bool\\n        \"\"\"\\n        seen = {}\\n\\n        def can_win(choices, remainder):\\n            # if the largest choice exceeds the remainder, then we can win!\\n            if choices[-1] >= remainder:\\n                return True\\n\\n            # if we have seen this exact scenario play out, then we know the outcome\\n            seen_key = tuple(choices)\\n            if seen_key in seen:\\n                return seen[seen_key]\\n\\n            # we haven\\'t won yet.. it\\'s the next player\\'s turn.\\n            for index in range(len(choices)):\\n                if not can_win(choices[:index] + choices[index + 1:], remainder - choices[index]):\\n                    seen[seen_key] = True\\n                    return True\\n\\n            # uh-oh if we got here then next player won all permutations, we can\\'t force their hand\\n            # actually, they were able to force our hand :(\\n            seen[seen_key] = False\\n            return False\\n\\n        # let\\'s do some quick checks before we journey through the tree of permutations\\n        summed_choices = (maxChoosableInteger + 1) * maxChoosableInteger / 2\\n\\n        # if all the choices added up are less then the total, no-one can win\\n        if summed_choices < desiredTotal:\\n            return False\\n\\n        # if the sum matches desiredTotal exactly then you win if there\\'s an odd number of turns\\n        if summed_choices == desiredTotal:\\n\\t\\t    return maxChoosableInteger % 2\\n\\n        # slow: time to go through the tree of permutations\\n\\t\\tchoices = list(range(1, maxChoosableInteger + 1))\\n        return can_win(choices, desiredTotal)\\n\\n```\\n\\n### **Please vote this up!**",
                "solutionTags": [],
                "code": "```\\nclass Solution:\\n    def canIWin(self, maxChoosableInteger, desiredTotal):\\n        \"\"\"\\n        :type maxChoosableInteger: int\\n        :type desiredTotal: int\\n        :rtype: bool\\n        \"\"\"\\n        seen = {}\\n\\n        def can_win(choices, remainder):\\n            # if the largest choice exceeds the remainder, then we can win!\\n            if choices[-1] >= remainder:\\n                return True\\n\\n            # if we have seen this exact scenario play out, then we know the outcome\\n            seen_key = tuple(choices)\\n            if seen_key in seen:\\n                return seen[seen_key]\\n\\n            # we haven\\'t won yet.. it\\'s the next player\\'s turn.\\n            for index in range(len(choices)):\\n                if not can_win(choices[:index] + choices[index + 1:], remainder - choices[index]):\\n                    seen[seen_key] = True\\n                    return True\\n\\n            # uh-oh if we got here then next player won all permutations, we can\\'t force their hand\\n            # actually, they were able to force our hand :(\\n            seen[seen_key] = False\\n            return False\\n\\n        # let\\'s do some quick checks before we journey through the tree of permutations\\n        summed_choices = (maxChoosableInteger + 1) * maxChoosableInteger / 2\\n\\n        # if all the choices added up are less then the total, no-one can win\\n        if summed_choices < desiredTotal:\\n            return False\\n\\n        # if the sum matches desiredTotal exactly then you win if there\\'s an odd number of turns\\n        if summed_choices == desiredTotal:\\n\\t\\t    return maxChoosableInteger % 2\\n\\n        # slow: time to go through the tree of permutations\\n\\t\\tchoices = list(range(1, maxChoosableInteger + 1))\\n        return can_win(choices, desiredTotal)\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 95320,
                "title": "clean-c-beat-98-4-dfs-with-early-termination-check-detailed-explanation",
                "content": "For short notation, let `M = maxChoosableInteger` and `T = desiredTotal`.\\n\\n**Key Observation:** the state of the game is completely determined by currently available numbers to pick in the common pool.\\n\\n**State of Game:** initially, we have all `M` numbers `[1, M]` available in the pool. Each number may or may not be picked at a state of the game later on, so we have maximum `2^M` different states. Note that `M <= 20`, so `int` range is enough to cover it. For memorization, we define `int k` as the key for a game state, where \\n* the `i`-th bit of `k`, i.e., `k&(1<<i)` represents the availability of number `i+1` (`1`: picked; `0`: not picked).\\n\\nAt state `k`, the current player could pick any unpicked number from the pool, so state `k` can only go to one of the valid next states `k\\'`:\\n* if `i`-th bit of `k` is `0`, set it to be `1`, i.e., next state `k\\' = k|(1<<i)`.\\n\\n**Recursion:** apparently\\n* the current player can win at state `k` iff opponent can\\'t win at some valid next state `k\\'`. \\n\\n**Memorization:** to speed up the recursion, we can use a `vector<int> m` of size `2^M` to memorize calculated results `m[k]` for state key `k`:\\n* ` 0` : not calculated yet;\\n* ` 1` : current player can win;\\n* `-1`: current player can\\'t win.\\n\\n**Initial State Check:**\\nThere are several checks to be done at initial state `k = 0` for early termination so we won\\'t waste our time for DFS process:\\n1. if `T < 2`, obviously, the first player wins by simply picking `1`.\\n2. if the sum of entire pool `S = M*(M+1)/2` is less than `T`, of course, nobody can reach `T`.\\n3. if the sum `S == T`, the order to pick numbers from the pool is irrelevant. Whoever picks the last will reach `T`. So the first player can win iff `M` is odd. \\n```\\n  bool canIWin(int M, int T) \\n  {\\n    int sum = M*(M+1)/2; // sum of entire choosable pool\\n\\n    // I just pick 1 to win\\n    if (T < 2) return true;\\n    \\n    // Total is too large, nobody can win\\n    else if (sum < T) return false;\\n    \\n    // Total happens to match sum, whoever picks at odd times wins\\n    else if (sum == T) return M%2;\\n    \\n    // Non-trivial case: do DFS\\n    // Initial total: T\\n    // Initial game state: k = 0 (all numbers are not picked)\\n    else return dfs(M, T, 0);\\n  }\\n\\n  // DFS to check if I can win\\n  // k: current game state\\n  // T: remaining total to reach\\n  bool dfs(int M, int T, int k) \\n  {\\n    // memorized\\n    if (mem[k] != 0) return mem[k] > 0;\\n    \\n    // total is already reached by opponent, so I lose\\n    if (T <= 0) return false;\\n\\n    // try all currently available numbers\\n    for (int i = 0; i < M; ++i)\\n      // if (i+1) is available to pick and my opponent can\\'t win after I picked, I win!\\n      if (!(k&(1<<i)) && !dfs(M, T-i-1, k|(1<<i))) {\\n        mem[k] = 1;\\n        return true;\\n      } \\n    \\n    // Otherwise, I will lose\\n    mem[k] = -1;\\n    return false;      \\n  }\\n\\n  // m[key]: memorized game result when pool state = key\\n  // 0: un-computed; 1: I win; -1: I lose\\n  int mem[1<<20] = {};\\n```",
                "solutionTags": [
                    "C++",
                    "Depth-First Search"
                ],
                "code": "```\\n  bool canIWin(int M, int T) \\n  {\\n    int sum = M*(M+1)/2; // sum of entire choosable pool\\n\\n    // I just pick 1 to win\\n    if (T < 2) return true;\\n    \\n    // Total is too large, nobody can win\\n    else if (sum < T) return false;\\n    \\n    // Total happens to match sum, whoever picks at odd times wins\\n    else if (sum == T) return M%2;\\n    \\n    // Non-trivial case: do DFS\\n    // Initial total: T\\n    // Initial game state: k = 0 (all numbers are not picked)\\n    else return dfs(M, T, 0);\\n  }\\n\\n  // DFS to check if I can win\\n  // k: current game state\\n  // T: remaining total to reach\\n  bool dfs(int M, int T, int k) \\n  {\\n    // memorized\\n    if (mem[k] != 0) return mem[k] > 0;\\n    \\n    // total is already reached by opponent, so I lose\\n    if (T <= 0) return false;\\n\\n    // try all currently available numbers\\n    for (int i = 0; i < M; ++i)\\n      // if (i+1) is available to pick and my opponent can\\'t win after I picked, I win!\\n      if (!(k&(1<<i)) && !dfs(M, T-i-1, k|(1<<i))) {\\n        mem[k] = 1;\\n        return true;\\n      } \\n    \\n    // Otherwise, I will lose\\n    mem[k] = -1;\\n    return false;      \\n  }\\n\\n  // m[key]: memorized game result when pool state = key\\n  // 0: un-computed; 1: I win; -1: I lose\\n  int mem[1<<20] = {};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 155321,
                "title": "from-brute-force-to-top-down-dp",
                "content": "### Brute Force\\n```\\nclass Solution {\\n    public boolean canIWin(int maxChoosableInteger, int desiredTotal) {\\n        if (desiredTotal <= maxChoosableInteger) \\n            return true;\\n        if (((1 + maxChoosableInteger) / 2 * maxChoosableInteger) < desiredTotal) {\\n            return false;\\n        }\\n        return canIWinFrom(maxChoosableInteger, desiredTotal, new boolean[maxChoosableInteger + 1]);\\n    }\\n    \\n    private boolean canIWinFrom(int maxChoosableInteger, int desiredTotal, boolean[] chosen) {\\n        if (desiredTotal <= 0) {\\n            return false;\\n        }\\n        \\n        for (int i = 1; i <= maxChoosableInteger; i++) {\\n            if (chosen[i]) {\\n                continue;\\n            }\\n            chosen[i] = true;\\n            if (!canIWinFrom(maxChoosableInteger, desiredTotal - i, chosen)) {\\n                chosen[i] = false;\\n                return true;\\n            }\\n            chosen[i] = false;\\n        }\\n        return false;\\n    }\\n}\\n```\\n### Top-down DP\\nUse memoization to overcome overlapping subproblems.\\n\\nThere are two changing variables `desiredTotal` and `chosen` in recursive function `canIWinFrom`, though only `chosen` has to be tracked (as key).\\n```\\nclass Solution {\\n    private Map<String, Boolean> memo; // key: chosen[] to string, value: canIWinWithSituation return value when chosen to string is key\\n    \\n    public boolean canIWin(int maxChoosableInteger, int desiredTotal) {\\n        \\n        if (desiredTotal <= maxChoosableInteger) \\n            return true;\\n        if (((1 + maxChoosableInteger) / 2 * maxChoosableInteger) < desiredTotal) {\\n            return false;\\n        }\\n        memo = new HashMap<>();\\n        \\n        return canIWinWithSituation(maxChoosableInteger, desiredTotal, new boolean[maxChoosableInteger + 1]);\\n    }\\n    \\n    private boolean canIWinWithSituation(int maxChoosableInteger, int curDesiredTotal, boolean[] chosen) {\\n        \\n        if (curDesiredTotal <= 0) { \\n            return false;\\n        }\\n        \\n        String chosenSerialization = Arrays.toString(chosen);\\n        if (memo.containsKey(chosenSerialization)) {\\n            return memo.get(chosenSerialization);\\n        }\\n        \\n        for (int i = 1; i <= maxChoosableInteger; i++) {\\n            if (chosen[i]) {\\n                continue;\\n            }\\n            chosen[i] = true;\\n            if (!canIWinWithSituation(maxChoosableInteger, curDesiredTotal - i, chosen)) {\\n                memo.put(chosenSerialization, true);\\n                chosen[i] = false;\\n                return true;\\n            }\\n            chosen[i] = false;\\n        }\\n        memo.put(chosenSerialization, false);\\n        return false;\\n    }\\n}\\n```\\n",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    public boolean canIWin(int maxChoosableInteger, int desiredTotal) {\\n        if (desiredTotal <= maxChoosableInteger) \\n            return true;\\n        if (((1 + maxChoosableInteger) / 2 * maxChoosableInteger) < desiredTotal) {\\n            return false;\\n        }\\n        return canIWinFrom(maxChoosableInteger, desiredTotal, new boolean[maxChoosableInteger + 1]);\\n    }\\n    \\n    private boolean canIWinFrom(int maxChoosableInteger, int desiredTotal, boolean[] chosen) {\\n        if (desiredTotal <= 0) {\\n            return false;\\n        }\\n        \\n        for (int i = 1; i <= maxChoosableInteger; i++) {\\n            if (chosen[i]) {\\n                continue;\\n            }\\n            chosen[i] = true;\\n            if (!canIWinFrom(maxChoosableInteger, desiredTotal - i, chosen)) {\\n                chosen[i] = false;\\n                return true;\\n            }\\n            chosen[i] = false;\\n        }\\n        return false;\\n    }\\n}\\n```\n```\\nclass Solution {\\n    private Map<String, Boolean> memo; // key: chosen[] to string, value: canIWinWithSituation return value when chosen to string is key\\n    \\n    public boolean canIWin(int maxChoosableInteger, int desiredTotal) {\\n        \\n        if (desiredTotal <= maxChoosableInteger) \\n            return true;\\n        if (((1 + maxChoosableInteger) / 2 * maxChoosableInteger) < desiredTotal) {\\n            return false;\\n        }\\n        memo = new HashMap<>();\\n        \\n        return canIWinWithSituation(maxChoosableInteger, desiredTotal, new boolean[maxChoosableInteger + 1]);\\n    }\\n    \\n    private boolean canIWinWithSituation(int maxChoosableInteger, int curDesiredTotal, boolean[] chosen) {\\n        \\n        if (curDesiredTotal <= 0) { \\n            return false;\\n        }\\n        \\n        String chosenSerialization = Arrays.toString(chosen);\\n        if (memo.containsKey(chosenSerialization)) {\\n            return memo.get(chosenSerialization);\\n        }\\n        \\n        for (int i = 1; i <= maxChoosableInteger; i++) {\\n            if (chosen[i]) {\\n                continue;\\n            }\\n            chosen[i] = true;\\n            if (!canIWinWithSituation(maxChoosableInteger, curDesiredTotal - i, chosen)) {\\n                memo.put(chosenSerialization, true);\\n                chosen[i] = false;\\n                return true;\\n            }\\n            chosen[i] = false;\\n        }\\n        memo.put(chosenSerialization, false);\\n        return false;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 95292,
                "title": "python-solution-easy-to-understand",
                "content": "Easy to understand baseline solution (not fast though), memorization is used to prune the search space. \\n```\\n    def canIWin(self, maxChoosableInteger, desiredTotal):\\n        \"\"\"\\n        :type maxChoosableInteger: int\\n        :type desiredTotal: int\\n        :rtype: bool\\n        \"\"\"\\n        if (1 + maxChoosableInteger) * maxChoosableInteger/2 < desiredTotal:\\n            return False\\n        self.memo = {}\\n        return self.helper(range(1, maxChoosableInteger + 1), desiredTotal)\\n\\n        \\n    def helper(self, nums, desiredTotal):\\n        \\n        hash = str(nums)\\n        if hash in self.memo:\\n            return self.memo[hash]\\n        \\n        if nums[-1] >= desiredTotal:\\n            return True\\n            \\n        for i in range(len(nums)):\\n            if not self.helper(nums[:i] + nums[i+1:], desiredTotal - nums[i]):\\n                self.memo[hash]= True\\n                return True\\n        self.memo[hash] = False\\n        return False",
                "solutionTags": [],
                "code": "Easy to understand baseline solution (not fast though), memorization is used to prune the search space. \\n```\\n    def canIWin(self, maxChoosableInteger, desiredTotal):\\n        \"\"\"\\n        :type maxChoosableInteger: int\\n        :type desiredTotal: int\\n        :rtype: bool\\n        \"\"\"\\n        if (1 + maxChoosableInteger) * maxChoosableInteger/2 < desiredTotal:\\n            return False\\n        self.memo = {}\\n        return self.helper(range(1, maxChoosableInteger + 1), desiredTotal)\\n\\n        \\n    def helper(self, nums, desiredTotal):\\n        \\n        hash = str(nums)\\n        if hash in self.memo:\\n            return self.memo[hash]\\n        \\n        if nums[-1] >= desiredTotal:\\n            return True\\n            \\n        for i in range(len(nums)):\\n            if not self.helper(nums[:i] + nums[i+1:], desiredTotal - nums[i]):\\n                self.memo[hash]= True\\n                return True\\n        self.memo[hash] = False\\n        return False",
                "codeTag": "Python3"
            },
            {
                "id": 404665,
                "title": "java-dp-solution-with-detailed-explanation-very-easy-to-understand",
                "content": "## My Thinking process\\nLike other game problem, this problem obviously should use dp. But how can we define the dp state? First, we can easily come out `dp[target][state]`, that means when we face target and current state can I win. Second, how to present the state? We should realize `state` represent the usage of choosable integer. From description of this problem, we know the choosable integer is equal or less than 20 and it can\\'t be re-used. Okay, `hashmap` comes to mind. So the current problem is how to make a connection between `hashmap` and `state`. Up to this point, we find this is actually a `TSP DP` problem. Because the choosable integers is equal to or less than 20, we can use **a integer** instead of hashmap to represent the state(a integer has 32 bits, each bit represent the usage of its index).\\n\\nFor example:\\n\\t`0000 0000 0000 0000 0000 0000 0010 0010`: binary form of 34, it means we have already used 1 and 5.\\n\\tAnd now, we want to use numer 3 to make a try, it becomes:\\n\\t`0000 0000 0000 0000 0000 0000 0010 0110`: actually, it is `34 ^ (1 << 2)`.\\nSo if the current state is `chs` and we want to try number `i + 1`, next state is `chs ^ (1 << i)`. \\n\\nFurther more, we find a `chs` can only correspond to a `target`, because when we try number `i + 1`, next target will be `target - (i + 1)`.That means, `chs ^ (1 << i)` only correspond to `target - (i + 1)`, won\\'t be any others. So we need not use `target`, finally the dp state is `dp[chs]`, it means if current usage of choosable integers is `chs` can I win.\\n\\nThe next  thing is easy, if we can win, that means when we choose a integer the next turn\\'s person can\\'t win.\\n\\n```java\\nclass Solution {\\n    public boolean canIWin(int maxChoosableInteger, int desiredTotal) {\\n        if (desiredTotal <= 0) return true;\\n        // 1 + 2 + ... + maxChoosableInteger < desiredTotal means can\\'t reach to desiredTotal\\n        if (maxChoosableInteger * (maxChoosableInteger + 1) / 2 < desiredTotal) return false;\\n        int[] dp = new int[1 << maxChoosableInteger];\\n        return dfs(dp, 0, maxChoosableInteger, desiredTotal);\\n    }\\n    \\n    public boolean dfs(int[] dp, int chs, int max, int target) {\\n        // targer <= 0 means the prior one wins\\n        if (target <= 0) return false;\\n        if (dp[chs] != 0) return dp[chs] == 1;\\n        boolean win = false;\\n        for (int i = 0; i < max; i++) {\\n            // i + 1 not use\\n            if ((chs & (1 << i)) == 0) {\\n                // thers is a trick: short circuit, when win is true, the next dfs won\\'t be invoke\\n                win = win || !dfs(dp, chs ^ (1 << i), max, target - i - 1);\\n            }\\n        }\\n        dp[chs] = win ? 1 : -1;\\n        return win;\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```java\\nclass Solution {\\n    public boolean canIWin(int maxChoosableInteger, int desiredTotal) {\\n        if (desiredTotal <= 0) return true;\\n        // 1 + 2 + ... + maxChoosableInteger < desiredTotal means can\\'t reach to desiredTotal\\n        if (maxChoosableInteger * (maxChoosableInteger + 1) / 2 < desiredTotal) return false;\\n        int[] dp = new int[1 << maxChoosableInteger];\\n        return dfs(dp, 0, maxChoosableInteger, desiredTotal);\\n    }\\n    \\n    public boolean dfs(int[] dp, int chs, int max, int target) {\\n        // targer <= 0 means the prior one wins\\n        if (target <= 0) return false;\\n        if (dp[chs] != 0) return dp[chs] == 1;\\n        boolean win = false;\\n        for (int i = 0; i < max; i++) {\\n            // i + 1 not use\\n            if ((chs & (1 << i)) == 0) {\\n                // thers is a trick: short circuit, when win is true, the next dfs won\\'t be invoke\\n                win = win || !dfs(dp, chs ^ (1 << i), max, target - i - 1);\\n            }\\n        }\\n        dp[chs] = win ? 1 : -1;\\n        return win;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1223676,
                "title": "c-dp-with-bitmasking-solution",
                "content": "-> if the total sum of integers from 1 to max is less than total .. player 1 cannot force a win..return false;\\n->represent the present integers in form  of a bitmask with 1 as used integers and 0 as unused integers from 1 to max..\\n-> make a recursive function where the current player tries to play optimally..\\n-> I have represented first player by player code 0 and second player by code 1\\n-> In this optimal approach the current player tries to include all the present unused integers and check if he wins\\n-> This can be checked with 2 possibilities:-\\n\\t\\t1. If including a number in score makes score >= desiredTotal; or\\n\\t\\t2. If for including a number and changing the mask state..the opposite player .. i.e (current_player xor 1) loses....\\n\\t\\t->If any one happens the current player wins\\n-> memoize this solution to avoid recalculations\\n-> check if player 0 wins or not.\\nThats it\\n\\n\\n```\\nclass Solution {\\nprivate:\\n    int m,t;\\n    vector<vector<int>> dp;\\n    bool game(int mask,int player,int score){\\n        if(dp[player][mask]!=-1) return dp[player][mask];\\n        for(int i=0;i<m;i++)\\n        {\\n            int cmask = 1<<i;\\n            if( (mask&cmask) == 0 )\\n                    if(score+i+1 >= t or game((mask|cmask),(player^1),score+i+1)==false ) return dp[player][mask]=1;\\n        }\\n        return dp[player][mask]=0;\\n    }\\npublic:\\n    bool canIWin(int maxChoosableInteger, int desiredTotal) {\\n        m=maxChoosableInteger;\\n        t=desiredTotal;\\n        if((m*(m+1))/2 < t) return false;\\n        dp.resize(2,vector<int>(1<<m,-1));\\n        return game(0,0,0);\\n    }\\n};\\n\\n\\n```\\n\\n\\nThe fun Part is, the variable \\'player\\' is actually useless..\\nThe program runs faster without using this variable at all..\\nYou just need to make sure that if you want to win...., the player playing after you must lose..thats it\\n\\n\\n```\\nclass Solution {\\nprivate:\\n    int m,t;\\n    vector<int> dp;\\n    bool game(int mask,int score){\\n        if(dp[mask]!=-1) return dp[mask];\\n        for(int i=0;i<m;i++)\\n        {\\n            int cmask = 1<<i;\\n            if( (mask&cmask) == 0 )\\n                    if(score+i+1 >= t or game((mask|cmask),score+i+1)==false ) return dp[mask]=1;\\n        }\\n        return dp[mask]=0;\\n    }\\npublic:\\n    bool canIWin(int maxChoosableInteger, int desiredTotal) {\\n        m=maxChoosableInteger;\\n        t=desiredTotal;\\n        if((m*(m+1))/2 < t) return false;\\n        dp.resize(1<<m,-1);\\n        return game(0,0);\\n    }\\n};\\n\\n```",
                "solutionTags": [
                    "C++",
                    "Dynamic Programming",
                    "Memoization",
                    "Bitmask"
                ],
                "code": "```\\nclass Solution {\\nprivate:\\n    int m,t;\\n    vector<vector<int>> dp;\\n    bool game(int mask,int player,int score){\\n        if(dp[player][mask]!=-1) return dp[player][mask];\\n        for(int i=0;i<m;i++)\\n        {\\n            int cmask = 1<<i;\\n            if( (mask&cmask) == 0 )\\n                    if(score+i+1 >= t or game((mask|cmask),(player^1),score+i+1)==false ) return dp[player][mask]=1;\\n        }\\n        return dp[player][mask]=0;\\n    }\\npublic:\\n    bool canIWin(int maxChoosableInteger, int desiredTotal) {\\n        m=maxChoosableInteger;\\n        t=desiredTotal;\\n        if((m*(m+1))/2 < t) return false;\\n        dp.resize(2,vector<int>(1<<m,-1));\\n        return game(0,0,0);\\n    }\\n};\\n\\n\\n```\n```\\nclass Solution {\\nprivate:\\n    int m,t;\\n    vector<int> dp;\\n    bool game(int mask,int score){\\n        if(dp[mask]!=-1) return dp[mask];\\n        for(int i=0;i<m;i++)\\n        {\\n            int cmask = 1<<i;\\n            if( (mask&cmask) == 0 )\\n                    if(score+i+1 >= t or game((mask|cmask),score+i+1)==false ) return dp[mask]=1;\\n        }\\n        return dp[mask]=0;\\n    }\\npublic:\\n    bool canIWin(int maxChoosableInteger, int desiredTotal) {\\n        m=maxChoosableInteger;\\n        t=desiredTotal;\\n        if((m*(m+1))/2 < t) return false;\\n        dp.resize(1<<m,-1);\\n        return game(0,0);\\n    }\\n};\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 230432,
                "title": "c-12-ms-98-solution-with-detailed-explanation",
                "content": "This question took me a while because this is the first game-type question I have seen so far. I wasted a lot of time trying to figure out the \"optimal\" policy for moves, but of course it doesn\\'t exist. The part of the prompt stating that \"assuming opponent moves optimally\" was very misleading. \\n\\nLater, I realized that the only way to find the \"optimal\" strategy is to brute-force every single possible game state. If I can find a set of moves that, regardless of what the opponent does, will lead to winning, then I am guaranteed a win. This can be done using a DFS search.\\n\\nThe game state is essentially the set of number of unique numbers between ```1``` and ```maxChoose``` that has already been chosen. This can be encoded using 21 bits. Each time a number is chosen, we can set that bit. To make things easier, we will simply use an int to encode the state, since int has 32 bits, which is more than enough. \\n\\nTo do the dfs, we start from a state, and then proceed to check for a free number (a bit in the state which is a 0). Then, we set that bit to a 1, and then proceed to search further in that new state. We do this for all free bits in the state.\\n\\nTo set a bit ```i```, we can do ```state | (1 << i)```. To check a bit, we can do ```state & (1 << i)```. \\n\\nThe dfs logic is also a bit tricky, because we have two players. Initially I thought I need to simulate the game with each player taking turns, but later figured out that is not necessary, because any given state must belong to a single player, because each player is forced to pick a number. Thus there is no ambiguity. \\n\\nFurthermore, because the prompt requires guaranteed win, we define ```true``` for a state when the player of this state is guaranteed a path to win, and ```false``` when the player is not. ```false``` doesn\\'t mean that the player cannot win, but rather he \\'might\\' not win. \\n\\nBecause the players are alternating, it means that if a dfs from the next state returns ```true```, it means that the next player is guaranteed to win, should he pick the move to go to that state. If that happens, it means that this current state is a ```false``` state. This is because if the opponent plays optimally, then once we arrive at this state, he will make the move to pick that ```true``` state. This also means that if every single dfs from this state returns ```false```, then it means no matter what move the next player chooses, he \\'might\\' not win, implying that there is a way for us to win. This makes the current state ```true```. \\n\\nWe also need to be careful about our interpretation of the dfs results. Because we start the search with an empty state, it means that the search will return ```false``` if any of the next states, which are first moves, and thus player 1 states, returns ```true```. If all next states return ```false```, then it will return ```true```. Thus, the dfs is actually returning whether player 2 can win ( ! ). To get the result for player 1, we must negate the dfs result. This works because this game is a zero sum game, so if player 1 wins then player 2 must lose, and vice versa.\\n\\nNow that the dfs logic is sorted out, we find out that the search time is TLE. As a result, we must use memoization to store already traversed states to save time. This can be done by saving two bitfields. \\n\\nThe first bitfield, ```visited```, stores whether a state has been visited before. The second, ```cache```, stores the results for each state. This means for each new state, we first check if that state has already been visited. If it has, then we base our next steps on the cache of that new state, and proceed. If the state has not been visited, then the cache of the new state is currently invalid, so we must do a dfs, and proceed based on results from the dfs. Once we figure out if a state is ```true``` or ```false```, we can simply save that to ```cache```, and mark it as true in ```visited```.\\n\\nThe space requirement is quite substantial, at ```2^22``` bits. This is essentially O(2^N) space, where N is ```maxChoose```. The run time is also O(2^N), since we need to visit all the states.\\n\\n```\\nclass Solution {\\npublic:\\n    bitset<1<<21> cache;\\n    bitset<1<<21> visited;\\n    int total;\\n    int max_;\\n\\n    bool helper(int curSum, int state) {\\n        if(curSum >= total) { // If curSum is greater than total, then this is an end state, so mark as true.\\n            visited.set(state);\\n            cache.set(state);\\n            return true;\\n        }\\n\\n        for(int i = 1; i <= max_; ++i) {\\n            if((state & (1 << i)) == 0) { // Possible next state\\n                int newState = state | (1 << i);\\n                if((visited[newState] && cache[newState]) || (!visited[newState] && helper(curSum+i, newState))) {\\n                    visited.set(state); // Since a next state is true, this state is false. No need to mark cache since it is default false\\n                    return false;\\n                }\\n            }\\n        }\\n        visited.set(state); // Since all next opponent states are false, this state is true.\\n        cache.set(state);\\n        return true;\\n    }\\n\\n    bool canIWin(int m, int d) { \\t\\n        if(d <= m) return true; // First player always wins if desired below maxChoose\\n        int tmp = m*(m+1)/2;\\n        if(tmp < d) return false; // No one wins if it is not possible to reach desired \\n        if(tmp == d && m%2 == 1) return true; // If desired equal to max possible sum, then only if the maxChoose is odd can the first player win. \\n        total = d; max_ = m;\\n        return !helper(0, 0); // Do dfs, and negate the result\\n    }\\n};\\n\\nauto gucciGang = []() {std::ios::sync_with_stdio(false);cin.tie(nullptr);cout.tie(nullptr);return 0;}();\\n```",
                "solutionTags": [],
                "code": "```1```\n```maxChoose```\n```i```\n```state | (1 << i)```\n```state & (1 << i)```\n```true```\n```false```\n```false```\n```true```\n```false```\n```true```\n```false```\n```true```\n```false```\n```true```\n```false```\n```true```\n```visited```\n```cache```\n```true```\n```false```\n```cache```\n```visited```\n```2^22```\n```maxChoose```\n```\\nclass Solution {\\npublic:\\n    bitset<1<<21> cache;\\n    bitset<1<<21> visited;\\n    int total;\\n    int max_;\\n\\n    bool helper(int curSum, int state) {\\n        if(curSum >= total) { // If curSum is greater than total, then this is an end state, so mark as true.\\n            visited.set(state);\\n            cache.set(state);\\n            return true;\\n        }\\n\\n        for(int i = 1; i <= max_; ++i) {\\n            if((state & (1 << i)) == 0) { // Possible next state\\n                int newState = state | (1 << i);\\n                if((visited[newState] && cache[newState]) || (!visited[newState] && helper(curSum+i, newState))) {\\n                    visited.set(state); // Since a next state is true, this state is false. No need to mark cache since it is default false\\n                    return false;\\n                }\\n            }\\n        }\\n        visited.set(state); // Since all next opponent states are false, this state is true.\\n        cache.set(state);\\n        return true;\\n    }\\n\\n    bool canIWin(int m, int d) { \\t\\n        if(d <= m) return true; // First player always wins if desired below maxChoose\\n        int tmp = m*(m+1)/2;\\n        if(tmp < d) return false; // No one wins if it is not possible to reach desired \\n        if(tmp == d && m%2 == 1) return true; // If desired equal to max possible sum, then only if the maxChoose is odd can the first player win. \\n        total = d; max_ = m;\\n        return !helper(0, 0); // Do dfs, and negate the result\\n    }\\n};\\n\\nauto gucciGang = []() {std::ios::sync_with_stdio(false);cin.tie(nullptr);cout.tie(nullptr);return 0;}();\\n```",
                "codeTag": "C++"
            },
            {
                "id": 95283,
                "title": "brute-force-and-memoization",
                "content": "1. O(n!) brute force, n is maxChoosableInteger. T(n)=nT(n-1)\\n```\\n    bool canIWin(int maxChoosableInteger, int desiredTotal) {\\n        if(!desiredTotal) return 1;\\n        return canWin(~0<<maxChoosableInteger, maxChoosableInteger, desiredTotal);\\n    }\\n    bool canWin(int pool, int maxint, int tot) {\\n        if(tot<=0) return 0;\\n        for(int i=0;i<maxint;i++) {\\n            int mask = 1<<i;\\n            if(pool & mask) continue;\\n            pool|=mask;\\n            if(!canWin(pool,maxint, tot-i-1)) return 1;\\n            pool^=mask;\\n        }\\n        return 0;\\n    }\\n```\\n2. O(n2^n) Memoization. There is redundant computation in #1. A state with a pool and total may be computed many times. So we can cache the state and reuse it. At first glance, it seems that a state is determined by two values, the pool and the total. However, since the initial total is known, the remaining total is known given the pool. So a state can be identified by the pool only.\\n```\\n    bool canIWin(int maxChoosableInteger, int desiredTotal) {\\n        if(!desiredTotal) return 1;\\n        if(maxChoosableInteger*(maxChoosableInteger+1)/2<desiredTotal) return 0;\\n        unordered_map<int,char> mem;\\n        return canWin(~0<<maxChoosableInteger, maxChoosableInteger, desiredTotal, mem);\\n    }\\n    bool canWin(int pool, int maxint, int tot, unordered_map<int,char>& mem) {\\n        if(tot<=0) return 0;\\n        auto it = mem.find(pool);\\n        if(it != mem.end()) return it->second;\\n        for(int i=0;i<maxint;i++) {\\n            int mask = 1<<i;\\n            if(pool & mask) continue;\\n            pool|=mask;\\n            if(!canWin(pool,maxint,tot-i-1,mem)) return mem[pool^=mask]=1;\\n            pool^=mask;\\n        }\\n        return mem[pool] = 0;\\n    }\\n```\\n3. Iterative dp. For most dp problems, the next step is to transform recursion with memoization to iterative dp. However, that does not help and is actually pretty bad for this problem. In iterative dp, we have to visit all the 2^n states to get the result. In #2 DFS with memoization, DFS terminates as soon as it finds a way to win. The worst case O(n2^n) rarely happens. So if DFS has early termination condition, then it should be better than dp that visits all the states. Similar problems are [word break](https://discuss.leetcode.com/topic/66356/evolve-from-brute-force-to-optimal-a-review-of-all-solutions) and [Concatenated Words](https://discuss.leetcode.com/topic/78569/a-review-of-top-solutions).",
                "solutionTags": [
                    "C"
                ],
                "code": "```\\n    bool canIWin(int maxChoosableInteger, int desiredTotal) {\\n        if(!desiredTotal) return 1;\\n        return canWin(~0<<maxChoosableInteger, maxChoosableInteger, desiredTotal);\\n    }\\n    bool canWin(int pool, int maxint, int tot) {\\n        if(tot<=0) return 0;\\n        for(int i=0;i<maxint;i++) {\\n            int mask = 1<<i;\\n            if(pool & mask) continue;\\n            pool|=mask;\\n            if(!canWin(pool,maxint, tot-i-1)) return 1;\\n            pool^=mask;\\n        }\\n        return 0;\\n    }\\n```\n```\\n    bool canIWin(int maxChoosableInteger, int desiredTotal) {\\n        if(!desiredTotal) return 1;\\n        if(maxChoosableInteger*(maxChoosableInteger+1)/2<desiredTotal) return 0;\\n        unordered_map<int,char> mem;\\n        return canWin(~0<<maxChoosableInteger, maxChoosableInteger, desiredTotal, mem);\\n    }\\n    bool canWin(int pool, int maxint, int tot, unordered_map<int,char>& mem) {\\n        if(tot<=0) return 0;\\n        auto it = mem.find(pool);\\n        if(it != mem.end()) return it->second;\\n        for(int i=0;i<maxint;i++) {\\n            int mask = 1<<i;\\n            if(pool & mask) continue;\\n            pool|=mask;\\n            if(!canWin(pool,maxint,tot-i-1,mem)) return mem[pool^=mask]=1;\\n            pool^=mask;\\n        }\\n        return mem[pool] = 0;\\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 95319,
                "title": "python-solution-with-detailed-explanation",
                "content": "**Solution**\\n\\n**Can I Win** https://leetcode.com/problems/can-i-win/\\n\\n**Top Down DFS with Memoization: Time: O(N * 2^N). Space: O(2^N)**\\n* We create an array allowed which has all the integers from 1 to maxChoosableInteger.\\n* We test if the input is valid or not i.e. sum(allowed) >= desiredTotal.\\n* How do we define the state of the game? This answer determines how we will do memoization as well. Clearly list of current allowed numbers are needed to define the state. It might also look that so_far is also required to define the state. However, given all allowed values and the current set of allowed values, so_far is really the difference of the sum of the two. Therefore only allowed values uniquely determine the state.\\n* How many allowed values sets are possible? The length of the allowed value set can range 1 to maxChoosableInteger(N). So the answer is (N,1) + (N,2) + ..(N,N) where (N,K) means choose K from N. This is equal to 2^N.\\n* Now at my turn, if the max(allowed) + so_far >= target, then I will win. Otherwise, I choose from the allowed values one by one and recursively call for the other player. If with any choice the opponent fails for sure, then also I can win for sure from this state.\\n* What is the time complexity? For a brute force solution, the game tree has 10 choices at first level, each of these choices has 9 choices at second level, and so on. So the complexity is N!. But with memoization, we only compute 2^N sub-problems, and in each problem we do O(N) work. So total time complexity is O(N2^N).\\n```\\nclass Solution(object):\\n    def helper(self, allowed, target, so_far, cache):\\n        if len(allowed) == 0:\\n            return False\\n        state = tuple(allowed)\\n        if state in cache:\\n            return cache[state]\\n        else:\\n            cache[state] = False\\n            if max(allowed) + so_far >= target:\\n                cache[state] = True\\n            else:\\n                for x in allowed:\\n                    new_allowed = [y for y in allowed if x!=y]\\n                    if self.helper(new_allowed, target, so_far+x, cache) ==  False:\\n                        cache[state] = True\\n                        break\\n            return cache[state]\\n    \\n    def canIWin(self, maxChoosableInteger, desiredTotal):\\n        \"\"\"\\n        :type maxChoosableInteger: int\\n        :type desiredTotal: int\\n        :rtype: bool\\n        \"\"\"\\n        allowed = [x for x in range(1, maxChoosableInteger+1)]\\n        if sum(allowed) < desiredTotal:\\n            return False\\n        return self.helper(allowed, desiredTotal, 0, {})\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution(object):\\n    def helper(self, allowed, target, so_far, cache):\\n        if len(allowed) == 0:\\n            return False\\n        state = tuple(allowed)\\n        if state in cache:\\n            return cache[state]\\n        else:\\n            cache[state] = False\\n            if max(allowed) + so_far >= target:\\n                cache[state] = True\\n            else:\\n                for x in allowed:\\n                    new_allowed = [y for y in allowed if x!=y]\\n                    if self.helper(new_allowed, target, so_far+x, cache) ==  False:\\n                        cache[state] = True\\n                        break\\n            return cache[state]\\n    \\n    def canIWin(self, maxChoosableInteger, desiredTotal):\\n        \"\"\"\\n        :type maxChoosableInteger: int\\n        :type desiredTotal: int\\n        :rtype: bool\\n        \"\"\"\\n        allowed = [x for x in range(1, maxChoosableInteger+1)]\\n        if sum(allowed) < desiredTotal:\\n            return False\\n        return self.helper(allowed, desiredTotal, 0, {})\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1625573,
                "title": "python-by-top-down-dp-w-hint",
                "content": "**Hint**:\\n\\nWhen it comes to **game theory** problem with **optimal choice**, think of **DP** with **min-max strategy** (maximize the advantage of current player, and minimize the advantage of others).\\n\\n---\\n\\nThere are two common types of DP implementation.\\n\\nOne is **iteration** with array or list, also known as **tabulation method**, usually solve in bottom-up direction.\\n\\nAfter setting **initial condition** (i.e., boundary condition), then compute solution with **state transfer function** from solved subproblems one by one.\\n\\n---\\n\\nThe other is **recursion with memoization**, looks like DFS with look-up table, usually solve in top-down direction.\\n\\nAfter setting **base case** (i.e., stop condition), then go down to solve next level with smaller problem size. When DFS is completed, derive solution of current level from solved subproblems with **recurrence formula**.\\n\\n---\\n\\n\\n**Implementation** by by top-down DP\\n\\n```\\nclass Solution:\\n    def canIWin(self, maxChoosableInteger: int, desiredTotal: int) -> bool:\\n        \\n        has_used = lambda flag, x: flag & (1<<x)\\n        is_odd = lambda x: x % 2 == 1\\n        \\n        # use python built-in cache as memoization to speed-up\\n        @cache\\n        def can_player_win_on(target, bitflag):\\n            \\n            # Input: target number, current state of available call numbers for current player\\n            \\n            # Ouput: Return True if current player can win with given parameter.\\n            #        Otherwise, return False.\\n            \\n            \\n            if target <= 0:\\n\\t\\t\\t\\t## Base case:\\n                # Opponent has reach target and won the game on previous round.\\n                return False\\n            \\n            \\n\\t\\t\\t## General cases:\\n            # Current player use all available call number, and try to make a optimal choice\\n            for call_number in range(1, maxChoosableInteger+1):\\n                \\n            \\n                if has_used( bitflag, call_number ):\\n                    # Players cannot reuse the same call number, defined by game rule\\n                    continue\\n                \\n            \\n                # opponent makes next optimal move after current player\\n                # update target and bitflag for opponent\\n                if not can_player_win_on(target - call_number, bitflag | (1<<call_number) ):\\n                    \\n                    # current player can win if opponent lose\\n                    return True\\n\\n                \\n            # current player lose, failed to find a optimal choice to win\\n            return False\\n        \\n        # ------------------------------------------------------\\n        \\n\\t\\t## Quick response on special cases:\\n        \\n        # total number sum = 1 + 2 + ... + max call number = n * (1 + n) // 2\\n        S = maxChoosableInteger * (maxChoosableInteger+1) // 2\\n        \\n        if S < desiredTotal:\\n            # max call number is too small, can not reach desired final value\\n            return False\\n        \\n        elif desiredTotal <= 0:\\n            # first player already win on game opening\\n            return True\\n        \\n        elif S == desiredTotal and is_odd(maxChoosableInteger):\\n            # first player always win, because she/he can choose last remaining number from 1 ~ maxChoosableInteger on final round\\n            return True\\n        \\n        return can_player_win_on(desiredTotal, bitflag=0 )\\n```\\n\\n---\\n\\nReference:\\n\\n[1] [Python official docs about @cache as function memoization](https://docs.python.org/3/library/functools.html)\\n\\n[2] [Python official docs about bit manipulation](https://wiki.python.org/moin/BitManipulation)\\n\\n[3] [Python official docs about lambda expression](https://docs.python.org/3/tutorial/controlflow.html#lambda-expressions)\\n\\n[4] [Wiki: min max in game theory](https://en.wikipedia.org/wiki/Minimax#Game_theory)\\n\\n---\\n\\nRelated leetcode challenge:\\n\\n[Leetcode #486 Predict winner](https://leetcode.com/problems/predict-the-winner/)\\n\\n[Leetcode #877 Stone game](https://leetcode.com/problems/stone-game/)\\n\\n[Other challenges related to game theory](https://leetcode.com/tag/game-theory/)\\n",
                "solutionTags": [
                    "Python",
                    "Dynamic Programming",
                    "Bit Manipulation",
                    "Memoization"
                ],
                "code": "```\\nclass Solution:\\n    def canIWin(self, maxChoosableInteger: int, desiredTotal: int) -> bool:\\n        \\n        has_used = lambda flag, x: flag & (1<<x)\\n        is_odd = lambda x: x % 2 == 1\\n        \\n        # use python built-in cache as memoization to speed-up\\n        @cache\\n        def can_player_win_on(target, bitflag):\\n            \\n            # Input: target number, current state of available call numbers for current player\\n            \\n            # Ouput: Return True if current player can win with given parameter.\\n            #        Otherwise, return False.\\n            \\n            \\n            if target <= 0:\\n\\t\\t\\t\\t## Base case:\\n                # Opponent has reach target and won the game on previous round.\\n                return False\\n            \\n            \\n\\t\\t\\t## General cases:\\n            # Current player use all available call number, and try to make a optimal choice\\n            for call_number in range(1, maxChoosableInteger+1):\\n                \\n            \\n                if has_used( bitflag, call_number ):\\n                    # Players cannot reuse the same call number, defined by game rule\\n                    continue\\n                \\n            \\n                # opponent makes next optimal move after current player\\n                # update target and bitflag for opponent\\n                if not can_player_win_on(target - call_number, bitflag | (1<<call_number) ):\\n                    \\n                    # current player can win if opponent lose\\n                    return True\\n\\n                \\n            # current player lose, failed to find a optimal choice to win\\n            return False\\n        \\n        # ------------------------------------------------------\\n        \\n\\t\\t## Quick response on special cases:\\n        \\n        # total number sum = 1 + 2 + ... + max call number = n * (1 + n) // 2\\n        S = maxChoosableInteger * (maxChoosableInteger+1) // 2\\n        \\n        if S < desiredTotal:\\n            # max call number is too small, can not reach desired final value\\n            return False\\n        \\n        elif desiredTotal <= 0:\\n            # first player already win on game opening\\n            return True\\n        \\n        elif S == desiredTotal and is_odd(maxChoosableInteger):\\n            # first player always win, because she/he can choose last remaining number from 1 ~ maxChoosableInteger on final round\\n            return True\\n        \\n        return can_player_win_on(desiredTotal, bitflag=0 )\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1295099,
                "title": "java-memoized-solution-taking-players-turn-in-account",
                "content": "When I was working on this solution, it took me 4+ hours. Even after solving the problem, it seems more than a medium level problem to me. The 2 main reasons which made it hard for me to solve it were:\\n\\n1. I did not understand the meaning of \"forcing a win\".\\n2. I tried to solve from 2 players point of view.\\n\\nAfter reading many answers in discussion, I understood my answer to the first question as (p1: Player 1; p2: player2):-\\n\\n**p1 takes a number n1 (from the pool of available numbers). After taking n1, the turn is passed to p2. Now, if p2 picks ANY number (from the pool of available numbers) and still loses, then we say that p1 has forced a win on p2**.\\n\\nAfter this, it became clear as to how the recursion will work in this question. First, let\\'s define a recursive function:-\\n**fn(*sumRemaining*,*isFirstPlayerTurn*,*taken*): fn is the helper function which returns true if the firstPlayer can force a win when we have *sumRemaining* value left to be crossed, with *taken* values already taken and currently *isFirstPlayerTurn* player has to play**\\n\\nNow, once we have defined the recursive function in words, lets create a recursive formula:-\\n```\\nprivate boolean fn(int sumRemaining, boolean isFirstPlayerTurn, boolean[] taken) {\\n        if(sumRemaining <= 0) {\\n            /**\\n             * If it is 2nd players turn at this state, it means it as first players turn in previous state.\\n             * Thus, if our sumRemaining <= 0 now, it means 1st player took the winning number, and thus, he/she won.\\n             */\\n            return !isFirstPlayerTurn;\\n        }\\n        boolean ans = false;\\n        if(isFirstPlayerTurn) {\\n            for(int j = taken.length-1; j >= 1; j--) {\\n                if(!taken[j]) {\\n                    taken[j] = true;\\n                    /**\\n                     * First player plays, and it only needs one win.\\n                     * If first player wins in any case, we will return true (as per our definition of function).\\n                     */\\n                    if(fn(sumRemaining - j, !isFirstPlayerTurn, taken)) {\\n                        taken[j] = false;\\n                        return true;\\n                    }\\n                    taken[j] = false;\\n                }\\n            }\\n        }\\n        else {\\n            ans = true;\\n            for(int j = taken.length-1; j >= 1; j--) {\\n                if(!taken[j]) {\\n                    taken[j] = true;\\n                    /**\\n                     * 2nd player is playing, and he/she is trying all the values that are available. \\n                     * In order for this function (fn(....)) to return true, 2nd player has to fail in all his/her attempts. \\n                     * That means fn(sumRemaining - j,...) MUST RETURN TRUE IN ALL CASES (implying that player1 won in all cases).\\n                     * Hence, fn(...) for all cases should return true, for this function to return true. Else it should return false.\\n                     */\\n                    ans = ans && fn(sumRemaining - j, !isFirstPlayerTurn, taken);\\n                    taken[j] = false;\\n                }\\n            }\\n        }\\n        return ans;\\n    }\\n```\\n\\nDenoting maximumChoosableInteger as m and desiredTotal as n.\\nTime complexity: n!. Time complexity would depend on the TOTAL number of branches in the recursion tree, and also on the amount spent per node of the tree. Amount spent per node: O(m). Also, TOTAL number of branches: \\nAt L1: m\\nAt L2: m*(m-1)\\nAt L3: m*(m-1)\\\\*(m-2)\\n....\\nAt Ln: m!\\n\\nThus, total nodes: m + m\\\\*(m-1) + m\\\\*m(-1)\\\\*(m-2)\\\\*...........\\\\*m!\\nFor taking the higher limit, abstract all of them out as factorials, to get,\\nO(total nodes): m! * m.\\nSince all nodes take O(m) time to operate, we can say **O(time): m^2 \\\\* m!**\\n\\nGiven our question constraints, this time would force a TLE.\\n\\nLet\\'s memoize it. There are 3 candidates for memoization: sumRemaining, isFirstPlayerTurn and taken[]. But since sumRemaining can be taken out by combining values from taken[], we can ignore sumRemaining variable. But what about isFirstPlayerTurn?\\nPlayer1 and Player2 fill the taken[] boolean array in the same format (taking the last available value) and player1 always goes first. Hence, if we only memoize based on taken[] array, it would work. There won\\'t be any case when for the same state of taken[] array, we have both players turn possible (that is, if taken = [0,1,0,0,1,0], then at this state, it could be only p1 OR p2\\'s turn, but not both.\\n\\nHence, We only need taken[] array as our memoization medium. Let\\'s do it then:\\n\\n```\\nprivate Map<String, Boolean> dp = new HashMap<>();\\nprivate boolean fn(int sumRemaining, boolean isFirstPlayerTurn, boolean[] taken) {\\n        if(sumRemaining <= 0) {\\n            return !isFirstPlayerTurn;\\n        }\\n        String key = Arrays.toString(taken);\\n        if(dp.containsKey(key)) {\\n            return dp.get(key);\\n        }\\n        boolean ans = false;\\n        if(isFirstPlayerTurn) {\\n            for(int j = taken.length-1; j >= 1; j--) {\\n                if(!taken[j]) {\\n                    taken[j] = true;\\n                    if(fn(sumRemaining - j, !isFirstPlayerTurn, taken)) {\\n                        taken[j] = false;\\n                        ans = true;\\n\\t\\t\\t\\t\\t\\tbreak;\\n                    }\\n                    taken[j] = false;\\n                }\\n            }\\n        }\\n        else {\\n            ans = true;\\n            for(int j = taken.length-1; j >= 1; j--) {\\n                if(!taken[j]) {\\n                    taken[j] = true;\\n                    ans = ans && fn(sumRemaining - j, !isFirstPlayerTurn, taken);\\n                    taken[j] = false;\\n                }\\n            }\\n        }\\n        dp.put(key, ans);\\n        return ans;\\n    }\\n```\\n\\nFun fact: Still TLE. Why? What\\'s the complexity? Since we are memoizing on the state of taken[] array at any point, we can have 2^m (m: maximumChoosableInteger) nodes (since every index on taken[] array could be filled with only 2 values: true or false). Also, time taken per node: O(m). **Thus, total time complexity right now: m \\\\* O(2^m).**\\n\\nBUT, by saying so, we are ignoring the time to search in hash map (The HUGE string that we are storing in the map and then retrieving it). It is taking a lot of time. Hence, we optimize it by converting our hash map keys from String to Integer. We do this by leveraging a constraint: The maximum length of taken[] could be 20 (thus, fitting easily inside a 32bit integer). Hence, using this, we get the following AC solution:\\n\\n```\\nMap<Integer, Boolean> dp;\\n    public boolean canIWin(int maxChoosableInteger, int desiredTotal) {\\n        if(desiredTotal <= 0) {\\n            return true;\\n        }\\n        if((maxChoosableInteger * (maxChoosableInteger+1) / 2) < desiredTotal) {\\n            return false;\\n        }\\n        dp = new HashMap<>();\\n        boolean[] a1 = new boolean[maxChoosableInteger+1];\\n        Arrays.fill(a1, false);\\n        return fn(desiredTotal, true, a1);\\n    }\\n\\n    private boolean fn(int sumRemaining, boolean isFirstPlayerTurn, boolean[] taken) {\\n        if(sumRemaining <= 0) {\\n            /**\\n             * If it is 2nd players turn at this state, it means it as first players turn in previous state.\\n             * Thus, if our sumRemaining <= 0 now, it means 1st player took the winning number, and thus, he/she won.\\n             */\\n            return !isFirstPlayerTurn;\\n        }\\n        Integer key = getKey(taken);\\n        if(dp.containsKey(key)) {\\n            return dp.get(key);\\n        }\\n        boolean ans = false;\\n        if(isFirstPlayerTurn) {\\n            for(int j = taken.length-1; j >= 1; j--) {\\n                if(!taken[j]) {\\n                    taken[j] = true;\\n                    /**\\n                     * First player plays, and it only needs one win.\\n                     * If first player wins in any case, we will return true (as per our definition of function).\\n                     */\\n                    if(fn(sumRemaining - j, !isFirstPlayerTurn, taken)) {\\n                        taken[j] = false;\\n                        ans = true;\\n                        break;\\n                    }\\n                    taken[j] = false;\\n                }\\n            }\\n        }\\n        else {\\n            ans = true;\\n            for(int j = taken.length-1; j >= 1; j--) {\\n                if(!taken[j]) {\\n                    taken[j] = true;\\n                    /**\\n                     * 2nd player is playing, and he/she is trying all the values that are available.\\n                     * In order for this function (fn(....)) to return true, 2nd player has to fail in all his/her attempts.\\n                     * That means fn(sumRemaining - j,...) MUST RETURN TRUE IN ALL CASES (implying that player1 won in all cases).\\n                     * Hence, fn(...) for all cases should return true, for this function to return true. Else it should return false.\\n                     */\\n                    ans = ans && fn(sumRemaining - j, !isFirstPlayerTurn, taken);\\n                    taken[j] = false;\\n                }\\n            }\\n        }\\n        dp.put(key, ans);\\n        return ans;\\n    }\\n\\n    private int getKey(boolean[] arr) {\\n        int key = 0;\\n        for(int i = 0; i < arr.length; i++) {\\n            int t = arr[i] ? 1 : 0;\\n            key = (key << 1) | t;\\n        }\\n        return key;\\n    }\\n```",
                "solutionTags": [],
                "code": "```\\nprivate boolean fn(int sumRemaining, boolean isFirstPlayerTurn, boolean[] taken) {\\n        if(sumRemaining <= 0) {\\n            /**\\n             * If it is 2nd players turn at this state, it means it as first players turn in previous state.\\n             * Thus, if our sumRemaining <= 0 now, it means 1st player took the winning number, and thus, he/she won.\\n             */\\n            return !isFirstPlayerTurn;\\n        }\\n        boolean ans = false;\\n        if(isFirstPlayerTurn) {\\n            for(int j = taken.length-1; j >= 1; j--) {\\n                if(!taken[j]) {\\n                    taken[j] = true;\\n                    /**\\n                     * First player plays, and it only needs one win.\\n                     * If first player wins in any case, we will return true (as per our definition of function).\\n                     */\\n                    if(fn(sumRemaining - j, !isFirstPlayerTurn, taken)) {\\n                        taken[j] = false;\\n                        return true;\\n                    }\\n                    taken[j] = false;\\n                }\\n            }\\n        }\\n        else {\\n            ans = true;\\n            for(int j = taken.length-1; j >= 1; j--) {\\n                if(!taken[j]) {\\n                    taken[j] = true;\\n                    /**\\n                     * 2nd player is playing, and he/she is trying all the values that are available. \\n                     * In order for this function (fn(....)) to return true, 2nd player has to fail in all his/her attempts. \\n                     * That means fn(sumRemaining - j,...) MUST RETURN TRUE IN ALL CASES (implying that player1 won in all cases).\\n                     * Hence, fn(...) for all cases should return true, for this function to return true. Else it should return false.\\n                     */\\n                    ans = ans && fn(sumRemaining - j, !isFirstPlayerTurn, taken);\\n                    taken[j] = false;\\n                }\\n            }\\n        }\\n        return ans;\\n    }\\n```\n```\\nprivate Map<String, Boolean> dp = new HashMap<>();\\nprivate boolean fn(int sumRemaining, boolean isFirstPlayerTurn, boolean[] taken) {\\n        if(sumRemaining <= 0) {\\n            return !isFirstPlayerTurn;\\n        }\\n        String key = Arrays.toString(taken);\\n        if(dp.containsKey(key)) {\\n            return dp.get(key);\\n        }\\n        boolean ans = false;\\n        if(isFirstPlayerTurn) {\\n            for(int j = taken.length-1; j >= 1; j--) {\\n                if(!taken[j]) {\\n                    taken[j] = true;\\n                    if(fn(sumRemaining - j, !isFirstPlayerTurn, taken)) {\\n                        taken[j] = false;\\n                        ans = true;\\n\\t\\t\\t\\t\\t\\tbreak;\\n                    }\\n                    taken[j] = false;\\n                }\\n            }\\n        }\\n        else {\\n            ans = true;\\n            for(int j = taken.length-1; j >= 1; j--) {\\n                if(!taken[j]) {\\n                    taken[j] = true;\\n                    ans = ans && fn(sumRemaining - j, !isFirstPlayerTurn, taken);\\n                    taken[j] = false;\\n                }\\n            }\\n        }\\n        dp.put(key, ans);\\n        return ans;\\n    }\\n```\n```\\nMap<Integer, Boolean> dp;\\n    public boolean canIWin(int maxChoosableInteger, int desiredTotal) {\\n        if(desiredTotal <= 0) {\\n            return true;\\n        }\\n        if((maxChoosableInteger * (maxChoosableInteger+1) / 2) < desiredTotal) {\\n            return false;\\n        }\\n        dp = new HashMap<>();\\n        boolean[] a1 = new boolean[maxChoosableInteger+1];\\n        Arrays.fill(a1, false);\\n        return fn(desiredTotal, true, a1);\\n    }\\n\\n    private boolean fn(int sumRemaining, boolean isFirstPlayerTurn, boolean[] taken) {\\n        if(sumRemaining <= 0) {\\n            /**\\n             * If it is 2nd players turn at this state, it means it as first players turn in previous state.\\n             * Thus, if our sumRemaining <= 0 now, it means 1st player took the winning number, and thus, he/she won.\\n             */\\n            return !isFirstPlayerTurn;\\n        }\\n        Integer key = getKey(taken);\\n        if(dp.containsKey(key)) {\\n            return dp.get(key);\\n        }\\n        boolean ans = false;\\n        if(isFirstPlayerTurn) {\\n            for(int j = taken.length-1; j >= 1; j--) {\\n                if(!taken[j]) {\\n                    taken[j] = true;\\n                    /**\\n                     * First player plays, and it only needs one win.\\n                     * If first player wins in any case, we will return true (as per our definition of function).\\n                     */\\n                    if(fn(sumRemaining - j, !isFirstPlayerTurn, taken)) {\\n                        taken[j] = false;\\n                        ans = true;\\n                        break;\\n                    }\\n                    taken[j] = false;\\n                }\\n            }\\n        }\\n        else {\\n            ans = true;\\n            for(int j = taken.length-1; j >= 1; j--) {\\n                if(!taken[j]) {\\n                    taken[j] = true;\\n                    /**\\n                     * 2nd player is playing, and he/she is trying all the values that are available.\\n                     * In order for this function (fn(....)) to return true, 2nd player has to fail in all his/her attempts.\\n                     * That means fn(sumRemaining - j,...) MUST RETURN TRUE IN ALL CASES (implying that player1 won in all cases).\\n                     * Hence, fn(...) for all cases should return true, for this function to return true. Else it should return false.\\n                     */\\n                    ans = ans && fn(sumRemaining - j, !isFirstPlayerTurn, taken);\\n                    taken[j] = false;\\n                }\\n            }\\n        }\\n        dp.put(key, ans);\\n        return ans;\\n    }\\n\\n    private int getKey(boolean[] arr) {\\n        int key = 0;\\n        for(int i = 0; i < arr.length; i++) {\\n            int t = arr[i] ? 1 : 0;\\n            key = (key << 1) | t;\\n        }\\n        return key;\\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 95298,
                "title": "if-you-cannot-pass-case-10-40-please-see-here-c-89ms",
                "content": "I was struggling for this test case, and finally went through. I thought maybe many people made the same mistake, so I attached my code below to explain the possible reason. The key line has been commented and highlighted. If this line is missing, you will not pass the test case (10, 40).\\n```\\nclass Solution {\\npublic:\\n    bool canIWin(int maxChoosableInteger, int desiredTotal) {\\n        int n = maxChoosableInteger, tar = desiredTotal, sum = 0;\\n        for (int i = 1; i <= n; ++i) sum += i;\\n        // this case is impossible\\n        if (tar > sum) return false;\\n        // used[i] marks whether i+1 was used;\\n        // the key of dp is binary format of int, representing which numbers have been used\\n        unordered_map<int, bool> dp;\\n        vector<int> used(n, 1);\\n        return helper(used, dp, 0, tar);\\n    }\\nprivate:\\n    bool helper(vector<int>& used, unordered_map<int, bool>& dp, int key, int tar) {\\n        if (dp.count(key)) return dp[key];\\n        int n = used.size();\\n        // search backward, greedy choice\\n        for (int i = n-1; i >= 0; --i) {\\n            if (used[i]) {\\n                // can win\\n                if (i+1 >= tar) {\\n                    dp[key] = true;\\n                    return true;\\n                }\\n                // backtracking\\n                used[i] = 0;\\n                // if next state key|(1<<i) results in lose, this state can win;\\n                // however, if next state can win, this state is not necessary to lose; we need search all choices.\\n                if (!helper(used, dp, key|(1<<i), tar-i-1)) {\\n                    dp[key] = true;\\n                    // if next line commented, it won't pass test case (10, 40) \\n                    // I thought if it returns true, I don't have to reset used[i]; However, when it is true for current state, \\n                    // backtracking or DFS/dp for previous state will continue searching, so it is necessary to reset used[i]\\n                    used[i] = 1;\\n                    return true;\\n                }\\n                used[i] = 1;\\n            }\\n        }\\n        dp[key] = false;\\n        return false;\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    bool canIWin(int maxChoosableInteger, int desiredTotal) {\\n        int n = maxChoosableInteger, tar = desiredTotal, sum = 0;\\n        for (int i = 1; i <= n; ++i) sum += i;\\n        // this case is impossible\\n        if (tar > sum) return false;\\n        // used[i] marks whether i+1 was used;\\n        // the key of dp is binary format of int, representing which numbers have been used\\n        unordered_map<int, bool> dp;\\n        vector<int> used(n, 1);\\n        return helper(used, dp, 0, tar);\\n    }\\nprivate:\\n    bool helper(vector<int>& used, unordered_map<int, bool>& dp, int key, int tar) {\\n        if (dp.count(key)) return dp[key];\\n        int n = used.size();\\n        // search backward, greedy choice\\n        for (int i = n-1; i >= 0; --i) {\\n            if (used[i]) {\\n                // can win\\n                if (i+1 >= tar) {\\n                    dp[key] = true;\\n                    return true;\\n                }\\n                // backtracking\\n                used[i] = 0;\\n                // if next state key|(1<<i) results in lose, this state can win;\\n                // however, if next state can win, this state is not necessary to lose; we need search all choices.\\n                if (!helper(used, dp, key|(1<<i), tar-i-1)) {\\n                    dp[key] = true;\\n                    // if next line commented, it won't pass test case (10, 40) \\n                    // I thought if it returns true, I don't have to reset used[i]; However, when it is true for current state, \\n                    // backtracking or DFS/dp for previous state will continue searching, so it is necessary to reset used[i]\\n                    used[i] = 1;\\n                    return true;\\n                }\\n                used[i] = 1;\\n            }\\n        }\\n        dp[key] = false;\\n        return false;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 95293,
                "title": "java-easy-strightforward-solution-with-explanation",
                "content": "The solution is quite strightforward. First off we have to eliminate primitive cases. So,\\n * if the first player can choose a number, which is already greater than or equal to the desired total obviously it wins.\\n*  If max choosable integer is less than the desired total, but if it exceeds the desired total in sum with any other number then the  first player looses anyway. \\n* If the sum of all number in the pool cannot exceed or reach the desired total, then no one can win. \\n\\nNow, for the other cases we can use [MiniMax](https://en.wikipedia.org/wiki/Minimax) logic to reveal the winner. Because both player play optimally, In order to win, the first player has to make a choice, that leaves the second player no chance to win.  Thus, at each step we consider all the possible choices by the current player and give turn to the second player recursively. If we find a move, after which the second player looses anyway or we have already exceed the desired total by adding the chosen number, we return true, i.e the current player wins. This way the game looks like the following tree:\\n```\\n     player1 ->  0\\n              /| ...\\\\\\n  player2 -> 1 2 ....max \\n            /|\\\\ ..../ | \\\\\\nplayer1 -> 2 3...  1  2 ..max-1\\n           ...                \\\\\\nplayer1 ->   /      |     \\\\   loose\\nplayer2 -> loose   win   loose\\n```\\nThe figure above helps to imagine how the algorithm considers all possible scenarios of the game. The leafs of the game tree are loose or win states for one of the players. Finally the logic concludes to the idea, that if some branch does not contain any leaf that ends with win state for player2, the move associated with that branch is the optimal one for the first player.\\n\\nP.S: Time complexity of naive implementation will work for O(n!). Therefore we have to memorize branch states after traversing once.\\n\\n```\\npublic class Solution {\\n    Map<Integer, Boolean> set[];\\n    public boolean canIWin(int maxChoosableInteger, int desiredTotal) {\\n        if(maxChoosableInteger >= desiredTotal) return true;\\n        if(maxChoosableInteger+1 >=desiredTotal) return false;\\n        set = new Map[301];\\n        for(int i  =0 ;i<301;i++) set[i] = new HashMap<>();\\n        if(maxChoosableInteger*(maxChoosableInteger+1)/2 < desiredTotal) return false;\\n        return canWin((1<<maxChoosableInteger+1)-1, desiredTotal);\\n    }\\n    \\n    public boolean canWin(int set1, int total){\\n        if(set[total].containsKey(set1)) return set[total].get(set1);\\n        for(int i = 20;i>=1;i--){\\n            int p = (1<<i);\\n            if((p&set1) == p){\\n                int set1next = (set1^p);\\n                int totalNext = total - i;\\n                if(totalNext<=0) return true;\\n                boolean x;\\n                if(set[totalNext].containsKey(set1next)) x = set[totalNext].get(set1next);\\n                else x = canWin(set1next, totalNext);\\n                if(!x){\\n                    set[total].put(set1, true);\\n                    return true;\\n                }\\n            }\\n        }\\n        set[total].put(set1, false);\\n        return false;\\n    }\\n}",
                "solutionTags": [],
                "code": "```\\n     player1 ->  0\\n              /| ...\\\\\\n  player2 -> 1 2 ....max \\n            /|\\\\ ..../ | \\\\\\nplayer1 -> 2 3...  1  2 ..max-1\\n           ...                \\\\\\nplayer1 ->   /      |     \\\\   loose\\nplayer2 -> loose   win   loose\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 887522,
                "title": "c-recursive-dp-minimax-solution-explained",
                "content": "Runtime: 160 ms, faster than 49.39% of C++ online submissions for Can I Win.\\nMemory Usage: 24.6 MB, less than 5.03% of C++ online submissions for Can I Win.\\n\\n\\nConfusing problem statement \"Can player to move force a win ? \", means if player1 moves first in the game\\nthen is there any optimal way such that player1 wins always regardless of any move of player2. \\nWe just need one such optimal move of player1. Solution is quite similar to [Guess number Higher or Lower](https://leetcode.com/problems/guess-number-higher-or-lower-ii/).\\n\\nWhile both players play optimally according to MiniMax, player1 will try to max the score and player2 will try\\nto minimize the score, so the winning score for player1 is 1 if he plays the last move otherwise the winning score of player2 is -1. \\nPlayer1 takes a number from 1 to N and player2 takes another number other than previous number between 1 to N.  \\nSo we will check all possible combination of this type for both players and see if any combination gives a win to player1. \\nUsing dynamic programming our search area becomes 2^N.\\n\\n\\n```\\nclass Solution {\\npublic:\\n    \\n    // dp array holds result of any number choosing combination \\n    // max number 20, so max range = 2^22-1 as we consider bit position 1 to 20\\n    int dp[4194303]={};\\n    \\n    // check bit position is 1 means, that position number is already taken\\n    bool checkSetBit(int track, int pos)\\n    {\\n        return ((track>>pos) & 1)==1;\\n    }\\n    \\n    // returns if player1 or player2 wins the game\\n    // player == true means player1 and player == false means player2\\n    // winning score of player1 is 1 and player2 is -1\\n    int game(int l, int h, int desiredTotal, int track,bool player)\\n    {\\n        // base case: desiredTotal<=0 then current player lost and previous player won\\n        // if current player is player1 then winner is player2 and so winning score is -1\\n        // if current player is player2 then winner is player1 and so winning score is 1\\n        if(desiredTotal<=0) return dp[track] = player?-1:1;    \\n        \\n        // return precalculated value\\n        if(dp[track]!=0) return dp[track];\\n        \\n        // result if current player wins or loss\\n        int result;\\n        if(player)\\n        {\\n            result = INT_MIN;\\n            for(int i=l;i<=h;i++)\\n            {\\n                // use bitwise track to check if current number i is taken \\n                if(!checkSetBit(track,i))\\n                {\\n                    // take number i which is not taken already and call recursion for next player setting the ith pos 1 in track\\n                    // player1 wants to maximize the score always\\n                    result = max(result,game(l,h,desiredTotal-i,track|(1<<i),!player));\\n                    \\n                    // player1 won then return result\\n                    if(result==1)return dp[track] = 1;\\n                }   \\n            }            \\n        }\\n        else\\n        {\\n            result = INT_MAX;\\n            for(int i=l;i<=h;i++)\\n            {\\n                if(!checkSetBit(track,i))\\n                {\\n                    // player2 wants to minimize the score always\\n                    result = min(result,game(l,h,desiredTotal-i,track|(1<<i),!player));\\n                    \\n                    // player 2 won then return result\\n                    if(result==-1) return dp[track] = -1;\\n                }    \\n            }            \\n            \\n        }\\n\\n        dp[track] = result;\\n        return result;\\n    }\\n    \\n    bool canIWin(int maxChoosableInteger, int desiredTotal) {\\n        \\n        // desiredTotal == 0 then player1 wins \\n        if(desiredTotal == 0) return true;\\n        \\n        // sum of all number in range 1 to max choosable number\\n        int sum = (maxChoosableInteger * (maxChoosableInteger+1))/2;\\n        \\n        // if sum < desiredTotal then there is no way to win and so return false\\n        if(sum <desiredTotal) return false;\\n        \\n        int track = 0;\\n        \\n        // player1 wins using an optimal move\\n        return  game(1,maxChoosableInteger,desiredTotal,track,true)==1;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C",
                    "Dynamic Programming",
                    "Recursion",
                    "Combinatorics",
                    "Bitmask"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    \\n    // dp array holds result of any number choosing combination \\n    // max number 20, so max range = 2^22-1 as we consider bit position 1 to 20\\n    int dp[4194303]={};\\n    \\n    // check bit position is 1 means, that position number is already taken\\n    bool checkSetBit(int track, int pos)\\n    {\\n        return ((track>>pos) & 1)==1;\\n    }\\n    \\n    // returns if player1 or player2 wins the game\\n    // player == true means player1 and player == false means player2\\n    // winning score of player1 is 1 and player2 is -1\\n    int game(int l, int h, int desiredTotal, int track,bool player)\\n    {\\n        // base case: desiredTotal<=0 then current player lost and previous player won\\n        // if current player is player1 then winner is player2 and so winning score is -1\\n        // if current player is player2 then winner is player1 and so winning score is 1\\n        if(desiredTotal<=0) return dp[track] = player?-1:1;    \\n        \\n        // return precalculated value\\n        if(dp[track]!=0) return dp[track];\\n        \\n        // result if current player wins or loss\\n        int result;\\n        if(player)\\n        {\\n            result = INT_MIN;\\n            for(int i=l;i<=h;i++)\\n            {\\n                // use bitwise track to check if current number i is taken \\n                if(!checkSetBit(track,i))\\n                {\\n                    // take number i which is not taken already and call recursion for next player setting the ith pos 1 in track\\n                    // player1 wants to maximize the score always\\n                    result = max(result,game(l,h,desiredTotal-i,track|(1<<i),!player));\\n                    \\n                    // player1 won then return result\\n                    if(result==1)return dp[track] = 1;\\n                }   \\n            }            \\n        }\\n        else\\n        {\\n            result = INT_MAX;\\n            for(int i=l;i<=h;i++)\\n            {\\n                if(!checkSetBit(track,i))\\n                {\\n                    // player2 wants to minimize the score always\\n                    result = min(result,game(l,h,desiredTotal-i,track|(1<<i),!player));\\n                    \\n                    // player 2 won then return result\\n                    if(result==-1) return dp[track] = -1;\\n                }    \\n            }            \\n            \\n        }\\n\\n        dp[track] = result;\\n        return result;\\n    }\\n    \\n    bool canIWin(int maxChoosableInteger, int desiredTotal) {\\n        \\n        // desiredTotal == 0 then player1 wins \\n        if(desiredTotal == 0) return true;\\n        \\n        // sum of all number in range 1 to max choosable number\\n        int sum = (maxChoosableInteger * (maxChoosableInteger+1))/2;\\n        \\n        // if sum < desiredTotal then there is no way to win and so return false\\n        if(sum <desiredTotal) return false;\\n        \\n        int track = 0;\\n        \\n        // player1 wins using an optimal move\\n        return  game(1,maxChoosableInteger,desiredTotal,track,true)==1;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 95294,
                "title": "java-solution",
                "content": "```\\npublic class Solution {\\n\\n    private Boolean[] win;\\n    int choosen = 0;\\n\\n    public boolean canIWin(int maxChoosableInteger, int desiredTotal) {\\n        if (desiredTotal == 0) {\\n            return true;\\n        }\\n        if ((1 + maxChoosableInteger) * maxChoosableInteger / 2 < desiredTotal) {\\n            return false;\\n        }\\n        win = new Boolean[1 << maxChoosableInteger];\\n        return canWin(maxChoosableInteger, desiredTotal, 0);\\n    }\\n\\n    private boolean canWin(int n, int total, int now) {\\n        if (win[choosen] != null)\\n            return win[choosen];\\n        if (now >= total) {\\n            win[choosen] = false;\\n            return false;\\n        }\\n        for (int i = 1; i <= n; i++) {\\n            int bit = 1 << (i - 1);\\n            if ((choosen & bit) == 0) {\\n                choosen ^= bit;\\n                boolean ulose = !canWin(n, total, now + i);\\n                choosen ^= bit;\\n\\n                if (ulose) {\\n                    win[choosen] = true;\\n                    return true;\\n                }\\n            }\\n        }\\n        win[choosen] = false;\\n        return false;\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\npublic class Solution {\\n\\n    private Boolean[] win;\\n    int choosen = 0;\\n\\n    public boolean canIWin(int maxChoosableInteger, int desiredTotal) {\\n        if (desiredTotal == 0) {\\n            return true;\\n        }\\n        if ((1 + maxChoosableInteger) * maxChoosableInteger / 2 < desiredTotal) {\\n            return false;\\n        }\\n        win = new Boolean[1 << maxChoosableInteger];\\n        return canWin(maxChoosableInteger, desiredTotal, 0);\\n    }\\n\\n    private boolean canWin(int n, int total, int now) {\\n        if (win[choosen] != null)\\n            return win[choosen];\\n        if (now >= total) {\\n            win[choosen] = false;\\n            return false;\\n        }\\n        for (int i = 1; i <= n; i++) {\\n            int bit = 1 << (i - 1);\\n            if ((choosen & bit) == 0) {\\n                choosen ^= bit;\\n                boolean ulose = !canWin(n, total, now + i);\\n                choosen ^= bit;\\n\\n                if (ulose) {\\n                    win[choosen] = true;\\n                    return true;\\n                }\\n            }\\n        }\\n        win[choosen] = false;\\n        return false;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 134533,
                "title": "python-simple-readable-with-explanation-beat-93",
                "content": "* Corner Case:\\n\\t* sum(pick values) < desired sum: The first player never wins.\\n\\t* sum(pick values) == desired sum: Whoever takes the last wins. (Irrelevant to who pick which number first)\\n\\t* max choosable number > desired sum: The first player always wins by picking the max number.\\n* Code Supplemental Explanation:\\n\\t* Record: Used to rememeber win\\\\loss for current state. (what numbers have been picked, True: Win, False: Lose)\\n\\t* Bitmap: Record which number has been picked. Also used as an index to access the win loss record. (if in hash table)\\n\\t* Win if there is a way of picking a number \\'n\\' such that no matter how opponent picks next, the opponent lose.\\n\\t* Lose if there is no way of picking a number \\'n\\' that satisfies the above situation.\\n\\t* Win\\\\Loss is for the first player with the game status (bitmap passed in).\\n\\t \\n```\\nclass Solution(object):\\n    def canIWin(self, maxChoosableInteger, desiredTotal):\\n        \"\"\"\\n        :type maxChoosableInteger: int\\n        :type desiredTotal: int\\n        :rtype: bool\\n        \"\"\"\\n        \\n        max_sum = maxChoosableInteger*(maxChoosableInteger+1)//2\\n        \\n        if max_sum < desiredTotal:\\n            return False\\n        elif max_sum == desiredTotal:\\n            return (maxChoosableInteger%2 == 1)\\n        \\n        if maxChoosableInteger >= desiredTotal:\\n            return True\\n        \\n        bit_mask = 1 << maxChoosableInteger # bit 0: unused, bit 1: used\\n        self.record = {}\\n        \\n        return self.checkWin(maxChoosableInteger, bit_mask, desiredTotal)\\n    \\n    def checkWin(self, max_num, bit_mask, remain_sum):\\n        \\n        if bit_mask in self.record:\\n            return self.record[bit_mask]\\n        \\n        for i in range(max_num):\\n            \\n            if (1&(bit_mask >> i)) != 0:\\n                # skip already-picked number\\n                continue\\n            \\n            n = i+1 # n: picked number\\n            if (n >= remain_sum) or (self.checkWin(max_num, bit_mask | (1<< i), remain_sum-n) is False):\\n                self.record[bit_mask] = True\\n                return True\\n        \\n        self.record[bit_mask] = False\\n        return False\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution(object):\\n    def canIWin(self, maxChoosableInteger, desiredTotal):\\n        \"\"\"\\n        :type maxChoosableInteger: int\\n        :type desiredTotal: int\\n        :rtype: bool\\n        \"\"\"\\n        \\n        max_sum = maxChoosableInteger*(maxChoosableInteger+1)//2\\n        \\n        if max_sum < desiredTotal:\\n            return False\\n        elif max_sum == desiredTotal:\\n            return (maxChoosableInteger%2 == 1)\\n        \\n        if maxChoosableInteger >= desiredTotal:\\n            return True\\n        \\n        bit_mask = 1 << maxChoosableInteger # bit 0: unused, bit 1: used\\n        self.record = {}\\n        \\n        return self.checkWin(maxChoosableInteger, bit_mask, desiredTotal)\\n    \\n    def checkWin(self, max_num, bit_mask, remain_sum):\\n        \\n        if bit_mask in self.record:\\n            return self.record[bit_mask]\\n        \\n        for i in range(max_num):\\n            \\n            if (1&(bit_mask >> i)) != 0:\\n                # skip already-picked number\\n                continue\\n            \\n            n = i+1 # n: picked number\\n            if (n >= remain_sum) or (self.checkWin(max_num, bit_mask | (1<< i), remain_sum-n) is False):\\n                self.record[bit_mask] = True\\n                return True\\n        \\n        self.record[bit_mask] = False\\n        return False\\n```",
                "codeTag": "Java"
            },
            {
                "id": 591993,
                "title": "4-lines-python-with-frozenset",
                "content": "```\\n    def canIWin(self, maxInt: int, total: int) -> bool:\\n        @functools.lru_cache(None)\\n        def dp(nums, left):\\n            return any(left - n <= 0 or not dp(frozenset(nums - {n}), left - n) for n in nums)\\n        \\n        return  (1 + maxInt) * maxInt // 2 >= total and dp(frozenset(range(1, maxInt + 1)), total)\\n```\\n\\n```(1 + maxInt) * maxInt // 2 >= total``` - this makes sure that first player can even win (sum of the +1 series)\\n```frozenset(range(1, maxInt + 1)``` - creates hashable set possible numbers [1, 2, ..., maxInt]\\nNow, in each recursive call, we check for all nums if it\\'s possible to win drawing one of them:\\n1. Either ```left - n <= 0``` which means that taking than number n will allow reaching the total or else..\\n2. ```not dp(frozenset(nums - {n}), left - n)``` - which means that your opponent cannot win using numbers which left.\\n\\n```frozenset(nums - {n})``` - creates fresh new hashable set without n\\n\\nWe also cache by pair (nums, left) - every unique set of numbers is different.",
                "solutionTags": [
                    "Python",
                    "Python3",
                    "Depth-First Search",
                    "Memoization"
                ],
                "code": "```\\n    def canIWin(self, maxInt: int, total: int) -> bool:\\n        @functools.lru_cache(None)\\n        def dp(nums, left):\\n            return any(left - n <= 0 or not dp(frozenset(nums - {n}), left - n) for n in nums)\\n        \\n        return  (1 + maxInt) * maxInt // 2 >= total and dp(frozenset(range(1, maxInt + 1)), total)\\n```\n```(1 + maxInt) * maxInt // 2 >= total```\n```frozenset(range(1, maxInt + 1)```\n```left - n <= 0```\n```not dp(frozenset(nums - {n}), left - n)```\n```frozenset(nums - {n})```",
                "codeTag": "Python3"
            },
            {
                "id": 334802,
                "title": "no-recursive-memorization-pure-dp-solution-bottom-to-up",
                "content": "I have checked all solutions discussed here, and I found 0 post for Bottom to Up DP solution without recursive.\\nSo I wrote a solution for pure DP solution Bottom to UP\\nIdea is TSP DP solution (This solution is comparately  harder to understand than DFS + memorization)\\nYou can refer to this post for a similar explaination how to write TSP Dynamic Programming.\\nhttps://leetcode.com/problems/find-the-shortest-superstring/discuss/194932/Travelling-Salesman-Problem\\n\\nFYI: This is C# code, you can tranfer to Java by just changing 1 or 2 words\\n\\n```csharp\\n\\n    public bool CanIWin(int maxChoosableInteger, int desiredTotal)\\n    {\\n        if (desiredTotal <= 0)\\n        {\\n            return true;\\n        }\\n\\n        int maxTotal = maxChoosableInteger * (maxChoosableInteger + 1) / 2;\\n        if (maxTotal < desiredTotal)\\n        {\\n            return false;\\n        }\\n\\n        int len = 1 << maxChoosableInteger;\\n        int[] dp = new int[len]; // 0 -- invalid; 1 -- lose; 2 -- win;\\n        for (int i = 1; i < len; i++)\\n        {\\n            int hasUsed = maxTotal - calcTotal(i);\\n            int curDesired = desiredTotal - hasUsed;\\n            if (curDesired <= 0)\\n            {\\n                continue;\\n            }\\n\\n            dp[i] = 1;\\n            for (int j = 1; j <= maxChoosableInteger; j++)\\n            {\\n                int mask = 1 << (j - 1);\\n                if ((i & mask) > 0)\\n                {\\n                    int prev = i - mask;\\n                    if (j >= curDesired || dp[prev] == 1)\\n                    {\\n                        dp[i] = 2;\\n                        break;\\n                    }\\n                }\\n            }\\n        }\\n\\n        return dp[dp.Length - 1] == 2;\\n    }\\n\\n    private int calcTotal(int state)\\n    {\\n        int total = 0, digit = 1;\\n        while (state > 0)\\n        {\\n            if ((state & 1) > 0)\\n            {\\n                total += digit;\\n            }\\n\\n            digit++;\\n            state >>= 1;\\n        }\\n\\n        return total;\\n    }\\n\\t",
                "solutionTags": [],
                "code": "I have checked all solutions discussed here, and I found 0 post for Bottom to Up DP solution without recursive.\\nSo I wrote a solution for pure DP solution Bottom to UP\\nIdea is TSP DP solution (This solution is comparately  harder to understand than DFS + memorization)\\nYou can refer to this post for a similar explaination how to write TSP Dynamic Programming.\\nhttps://leetcode.com/problems/find-the-shortest-superstring/discuss/194932/Travelling-Salesman-Problem\\n\\nFYI: This is C# code, you can tranfer to Java by just changing 1 or 2 words\\n\\n```csharp\\n\\n    public bool CanIWin(int maxChoosableInteger, int desiredTotal)\\n    {\\n        if (desiredTotal <= 0)\\n        {\\n            return true;\\n        }\\n\\n        int maxTotal = maxChoosableInteger * (maxChoosableInteger + 1) / 2;\\n        if (maxTotal < desiredTotal)\\n        {\\n            return false;\\n        }\\n\\n        int len = 1 << maxChoosableInteger;\\n        int[] dp = new int[len]; // 0 -- invalid; 1 -- lose; 2 -- win;\\n        for (int i = 1; i < len; i++)\\n        {\\n            int hasUsed = maxTotal - calcTotal(i);\\n            int curDesired = desiredTotal - hasUsed;\\n            if (curDesired <= 0)\\n            {\\n                continue;\\n            }\\n\\n            dp[i] = 1;\\n            for (int j = 1; j <= maxChoosableInteger; j++)\\n            {\\n                int mask = 1 << (j - 1);\\n                if ((i & mask) > 0)\\n                {\\n                    int prev = i - mask;\\n                    if (j >= curDesired || dp[prev] == 1)\\n                    {\\n                        dp[i] = 2;\\n                        break;\\n                    }\\n                }\\n            }\\n        }\\n\\n        return dp[dp.Length - 1] == 2;\\n    }\\n\\n    private int calcTotal(int state)\\n    {\\n        int total = 0, digit = 1;\\n        while (state > 0)\\n        {\\n            if ((state & 1) > 0)\\n            {\\n                total += digit;\\n            }\\n\\n            digit++;\\n            state >>= 1;\\n        }\\n\\n        return total;\\n    }\\n\\t",
                "codeTag": "Unknown"
            },
            {
                "id": 916831,
                "title": "c-solution-explained-with-clear-comments-and-meaningful-naming-faster-than-45-of-others",
                "content": "I hope this can help someone.\\nAll the best!\\n\\n```\\nclass Solution {\\npublic:\\n    bool canIWin(int maxChoosableInteger, int desiredTotal) {\\n        // Win in one move: select desiredTotal if available within available integers\\n        if (maxChoosableInteger >= desiredTotal) return true;\\n        \\n        // Impossible game, cannot reach desiredTotal as playing all numbers does not reach the desiredTotal\\n        int totalSum = maxChoosableInteger * (maxChoosableInteger+1) /2;\\n        if (desiredTotal > totalSum) return false;\\n        \\n        // Limit game: desiredTotal only reachable by playing *all* integers\\n        if (desiredTotal == totalSum){\\n            // I can win if maxChoosableInteger is odd: all values have to be played in turn.\\n\\t\\t\\t// This means that both players will, in turn, have to pick all the available integers to exactly reach desiredTotal at the very end\\n\\t\\t\\t// I thus win if it\\'s my turn to play when time has come to play the last integer.\\n\\t\\t\\t// As I start te game, this is true if there is an odd number of integers to play\\n            if (maxChoosableInteger % 2 ==0) return false;\\n            else return true;\\n        }\\n        \\n        // Regular game\\n\\t\\t// Recursion will be used to examine games\\n\\t\\t// See details below\\n        return isWin(maxChoosableInteger, desiredTotal, 0 /*used values - none*/);\\n    }\\n\\n\\nprivate:\\n    // Memoization: make sure to remember the outcome of already seen game configurations\\n\\t// We identify a game by the desiredTotal, and then by the set of used values\\n    unordered_map<int, unordered_map<int, bool>> seenGames;\\n    \\n    /**\\n     * @ Brief determines if I can win the game, given set of already used values\\n     *\\n     * @param maxChoosableInteger: max possible integer I can play\\n     * @param desiredTotal: amount to reach or exceed via successive sums\\n     * @param usedValues: set of already played integers. This set is represented as a bit field\\n     *        we know there are maximum 20 possible integers we can use\\n     *        an int would have at least 32 bits here, so can hold 20 bits to represent used values\\n     *        e.g. if bit 1<<num is set, it means num has been used\\n     */\\n    bool isWin(int maxChoosableInteger, int desiredTotal, int usedValues){\\n        if (desiredTotal<=0) return false;\\n        \\n        if (seenGames.count(desiredTotal) != 0){\\n            // desired total already seen\\n            // check if it was with same set of used values\\n            if (seenGames[desiredTotal].count(usedValues) != 0){\\n                // already seen this game, return outcome\\n                return seenGames[desiredTotal][usedValues];\\n            }\\n        }\\n        \\n        // General valid game\\n        for (int n=maxChoosableInteger; n>=1; --n){\\n            // do not consider already played values\\n            if ( (1<<n & usedValues) == 0){\\n                // First, check if I can win in 1 move\\n                if (n>=desiredTotal) return true;\\n                \\n                // otherwise:\\n                if (not isWin(maxChoosableInteger, desiredTotal-n, usedValues|1<<n)){\\n                    // if not win with one less integer, then I have a win now as it\\'s my turn to pick\\n                    seenGames[desiredTotal][usedValues] = true;\\n                    return true;\\n                }\\n            }\\n        }\\n        seenGames[desiredTotal][usedValues] = false;\\n        return false;\\n    }\\n    \\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    bool canIWin(int maxChoosableInteger, int desiredTotal) {\\n        // Win in one move: select desiredTotal if available within available integers\\n        if (maxChoosableInteger >= desiredTotal) return true;\\n        \\n        // Impossible game, cannot reach desiredTotal as playing all numbers does not reach the desiredTotal\\n        int totalSum = maxChoosableInteger * (maxChoosableInteger+1) /2;\\n        if (desiredTotal > totalSum) return false;\\n        \\n        // Limit game: desiredTotal only reachable by playing *all* integers\\n        if (desiredTotal == totalSum){\\n            // I can win if maxChoosableInteger is odd: all values have to be played in turn.\\n\\t\\t\\t// This means that both players will, in turn, have to pick all the available integers to exactly reach desiredTotal at the very end\\n\\t\\t\\t// I thus win if it\\'s my turn to play when time has come to play the last integer.\\n\\t\\t\\t// As I start te game, this is true if there is an odd number of integers to play\\n            if (maxChoosableInteger % 2 ==0) return false;\\n            else return true;\\n        }\\n        \\n        // Regular game\\n\\t\\t// Recursion will be used to examine games\\n\\t\\t// See details below\\n        return isWin(maxChoosableInteger, desiredTotal, 0 /*used values - none*/);\\n    }\\n\\n\\nprivate:\\n    // Memoization: make sure to remember the outcome of already seen game configurations\\n\\t// We identify a game by the desiredTotal, and then by the set of used values\\n    unordered_map<int, unordered_map<int, bool>> seenGames;\\n    \\n    /**\\n     * @ Brief determines if I can win the game, given set of already used values\\n     *\\n     * @param maxChoosableInteger: max possible integer I can play\\n     * @param desiredTotal: amount to reach or exceed via successive sums\\n     * @param usedValues: set of already played integers. This set is represented as a bit field\\n     *        we know there are maximum 20 possible integers we can use\\n     *        an int would have at least 32 bits here, so can hold 20 bits to represent used values\\n     *        e.g. if bit 1<<num is set, it means num has been used\\n     */\\n    bool isWin(int maxChoosableInteger, int desiredTotal, int usedValues){\\n        if (desiredTotal<=0) return false;\\n        \\n        if (seenGames.count(desiredTotal) != 0){\\n            // desired total already seen\\n            // check if it was with same set of used values\\n            if (seenGames[desiredTotal].count(usedValues) != 0){\\n                // already seen this game, return outcome\\n                return seenGames[desiredTotal][usedValues];\\n            }\\n        }\\n        \\n        // General valid game\\n        for (int n=maxChoosableInteger; n>=1; --n){\\n            // do not consider already played values\\n            if ( (1<<n & usedValues) == 0){\\n                // First, check if I can win in 1 move\\n                if (n>=desiredTotal) return true;\\n                \\n                // otherwise:\\n                if (not isWin(maxChoosableInteger, desiredTotal-n, usedValues|1<<n)){\\n                    // if not win with one less integer, then I have a win now as it\\'s my turn to pick\\n                    seenGames[desiredTotal][usedValues] = true;\\n                    return true;\\n                }\\n            }\\n        }\\n        seenGames[desiredTotal][usedValues] = false;\\n        return false;\\n    }\\n    \\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 95288,
                "title": "c-dp-solution-15ms-20-lines",
                "content": "![alt text](https://lh5.googleusercontent.com/1LoMVftb488kkn6HKk3pgPl-_gXmWnpu1OA6UR2XT_Klghp_hJsjuP8kTmkZpA4WGwkBBEaut3X5Mjk=w1363-h930-rw)\\n\\n```\\nclass Solution {\\npublic:\\n\\u3000\\u3000bool canIWin(int maxChoosableInteger, int desiredTotal) {\\n\\u3000\\u3000\\u3000\\u3000if (maxChoosableInteger >= desiredTotal) return true;\\n\\u3000\\u3000\\u3000\\u3000int sum = ((maxChoosableInteger + 1) * maxChoosableInteger) >> 1;\\n\\u3000\\u3000\\u3000\\u3000if (sum < desiredTotal) return false;\\n\\u3000\\u3000\\u3000\\u3000mp = vector<int>(1 << maxChoosableInteger, -1);\\n\\u3000\\u3000\\u3000\\u3000return canWin(0, maxChoosableInteger, desiredTotal);\\n\\u3000\\u3000}\\nprivate:\\n\\u3000\\u3000vector<int> mp;\\n\\u3000\\u3000bool canWin(int used, const int &maxChoosableInteger, int desiredTotal) {\\n\\u3000\\u3000\\u3000\\u3000if (mp[used] != -1) return mp[used];\\n\\u3000\\u3000\\u3000\\u3000for (int i = maxChoosableInteger, bits = 1 << (maxChoosableInteger - 1); i >= 1; --i, bits >>= 1) {\\n\\u3000\\u3000\\u3000\\u3000\\u3000\\u3000if ((used & bits) != 0) continue;\\n\\u3000\\u3000\\u3000\\u3000\\u3000\\u3000if (i >= desiredTotal || !canWin(used | bits, maxChoosableInteger, desiredTotal - i)) {\\n\\u3000\\u3000\\u3000\\u3000\\u3000\\u3000\\u3000\\u3000mp[used] = 1;\\n\\u3000\\u3000\\u3000\\u3000\\u3000\\u3000\\u3000\\u3000return true;\\n\\u3000\\u3000\\u3000\\u3000\\u3000\\u3000}\\n\\u3000\\u3000\\u3000\\u3000}\\n\\u3000\\u3000\\u3000\\u3000mp[used] = 0;\\n\\u3000\\u3000\\u3000\\u3000return false;\\n\\u3000\\u3000}\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n\\u3000\\u3000bool canIWin(int maxChoosableInteger, int desiredTotal) {\\n\\u3000\\u3000\\u3000\\u3000if (maxChoosableInteger >= desiredTotal) return true;\\n\\u3000\\u3000\\u3000\\u3000int sum = ((maxChoosableInteger + 1) * maxChoosableInteger) >> 1;\\n\\u3000\\u3000\\u3000\\u3000if (sum < desiredTotal) return false;\\n\\u3000\\u3000\\u3000\\u3000mp = vector<int>(1 << maxChoosableInteger, -1);\\n\\u3000\\u3000\\u3000\\u3000return canWin(0, maxChoosableInteger, desiredTotal);\\n\\u3000\\u3000}\\nprivate:\\n\\u3000\\u3000vector<int> mp;\\n\\u3000\\u3000bool canWin(int used, const int &maxChoosableInteger, int desiredTotal) {\\n\\u3000\\u3000\\u3000\\u3000if (mp[used] != -1) return mp[used];\\n\\u3000\\u3000\\u3000\\u3000for (int i = maxChoosableInteger, bits = 1 << (maxChoosableInteger - 1); i >= 1; --i, bits >>= 1) {\\n\\u3000\\u3000\\u3000\\u3000\\u3000\\u3000if ((used & bits) != 0) continue;\\n\\u3000\\u3000\\u3000\\u3000\\u3000\\u3000if (i >= desiredTotal || !canWin(used | bits, maxChoosableInteger, desiredTotal - i)) {\\n\\u3000\\u3000\\u3000\\u3000\\u3000\\u3000\\u3000\\u3000mp[used] = 1;\\n\\u3000\\u3000\\u3000\\u3000\\u3000\\u3000\\u3000\\u3000return true;\\n\\u3000\\u3000\\u3000\\u3000\\u3000\\u3000}\\n\\u3000\\u3000\\u3000\\u3000}\\n\\u3000\\u3000\\u3000\\u3000mp[used] = 0;\\n\\u3000\\u3000\\u3000\\u3000return false;\\n\\u3000\\u3000}\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1519673,
                "title": "c-dp-memoization",
                "content": "Plz upvote if you like -\\n\\n\\tclass Solution {\\n\\tpublic:\\n\\t\\tint dp[2097152];\\n\\t\\t//basically dp size is (2^21)\\n\\t\\tbool findans(int m,int desiredTotal,int index){\\n\\t\\t\\tbool flag = false;\\n\\t\\t\\t//if other player already won\\n\\t\\t\\tif(desiredTotal<=0){\\n\\t\\t\\t\\treturn false;\\n\\t\\t\\t}\\n\\t\\t\\tif(dp[index]!=-1){\\n\\t\\t\\t\\treturn dp[index];\\n\\t\\t\\t}\\n\\t\\t\\t//trying all possibilites\\n\\t\\t\\tfor(int i=1;i<=m;i++){\\n\\n\\t\\t\\t\\t//if bit(number) is currently not picked by anyone and check if player2 lose\\n\\t\\t\\t\\tif(((index&1<<i)==0)&&(findans(m,desiredTotal-i,index|(1<<i))==false)){\\n\\t\\t\\t\\t\\t//then u win for sure\\n\\t\\t\\t\\t\\treturn dp[index]=true;\\n\\t\\t\\t\\t}\\n\\t\\t\\t}\\n\\t\\t\\treturn dp[index]=false;\\n\\t\\t}\\n\\t\\tbool canIWin(int m, int desiredTotal) {\\n\\t\\t\\tmemset(dp,-1,sizeof dp);\\n\\t\\t\\tint maxChances = m*(m+1)/2;\\n\\t\\t\\tif(m>desiredTotal){\\n\\t\\t\\t\\treturn true;\\n\\t\\t\\t}\\n\\t\\t\\tif(desiredTotal <=0 ){\\n\\t\\t\\t\\treturn true;\\n\\t\\t\\t}\\n\\t\\t\\tif(maxChances<desiredTotal) {\\n\\t\\t\\t\\treturn false;\\n\\t\\t\\t}\\n\\t\\t\\treturn findans(m,desiredTotal,0);\\n\\t\\t}   \\n\\t};\\n\\t\\n\\tTime Complexity: O(m)\\n    Auxiliary Space: O(2^21)",
                "solutionTags": [
                    "C++",
                    "C",
                    "Memoization"
                ],
                "code": "class Solution {\\n\\tpublic:\\n\\t\\tint dp[2097152];\\n\\t\\t//basically dp size is (2^21)\\n\\t\\tbool findans(int m,int desiredTotal,int index){\\n\\t\\t\\tbool flag = false;\\n\\t\\t\\t//if other player already won\\n\\t\\t\\tif(desiredTotal<=0){\\n\\t\\t\\t\\treturn false;\\n\\t\\t\\t}",
                "codeTag": "Java"
            },
            {
                "id": 322835,
                "title": "9ms-dfs-solution-with-optimizations-for-memoization",
                "content": "The main idea is to use recursion with memoization. To keep things simple, we can use a boolean[] arr of size N+1, to keep track of which numbers were used so far. \\n\\nThe idea is that for all the numbers eligible for picking, if there is even a single number we pick that results in our opponent not being able to win, then we can force a win.\\n\\nI won\\'t go that much into the intuition and the recursion since there are many similar solutions here. I will talk more about the memoization optimizations that boost this solution to be in top 10% of runtimes.\\n\\n**Memoization optimizations:**\\nSimple idea: Using a HashMap<Integer, Boolean> that acts as a memo table and a boolean[] arr that converts to a binary string which acts as the key. \\n\\nNote: I\\'ve seen implementations where people are keeping several HashMaps in order to keep track of the currentDesiredTotal but this is unnecessary since for each state of chosen numbers, there is only a single desiredTotal possible (the sum of the numbers chosen).\\n\\nBetter idea: Using a byte array that acts as a memo table and an integer state. Firstly, how does an int state work? We use bit manipulation. To check if a number i is chosen, we check if (state & 1 << i) == 0 (checking if the ith bit of state is a 1), to set a number as chosen we do this: (state | 1 << i) (setting the ith bit to 1). Then for our memo table, we can do as we would with a HashMap and set memo[state] = -1, 0 or 1. (I suggest using 0 as representation for unitialized since by default, memo[x] = 0.)\\n\\n```\\nclass Solution {\\n    byte[] memo;\\n\\n    public boolean canIWin(int maxChoosableInteger, int desiredTotal) {\\n        if(desiredTotal == 0) return true;\\n        \\n        // Handle edge case\\n        int n = maxChoosableInteger;\\n        int sum = (n * (n + 1))/2;\\n        if(sum < desiredTotal) return false;\\n        \\n        memo = new byte[1 << (n + 1)];\\n        \\n        return p1CanWin(0, n, desiredTotal);\\n    }\\n    \\n    public boolean p1CanWin(int state, int maxInt, int desiredTotal) {\\n        if(desiredTotal <= 0) return false;\\n        \\n        if(memo[state] != 0) {\\n            return (memo[state] == 1);\\n        }\\n        \\n        for(int i = 1; i <= maxInt; ++i) {\\n            if((state & (1 << i)) == 0) {\\n                boolean res = p1CanWin(state | (1 << i), maxInt, desiredTotal - i);\\n                if(!res) {\\n                    memo[state] = 1;\\n                    return true;\\n                }\\n            }\\n        }\\n        \\n        memo[state] = -1;\\n        return false;\\n    }\\n}\\n```\\n\\nPlease upvote and don\\'t hesitate to ask questions :)",
                "solutionTags": [
                    "Bit Manipulation",
                    "Memoization"
                ],
                "code": "```\\nclass Solution {\\n    byte[] memo;\\n\\n    public boolean canIWin(int maxChoosableInteger, int desiredTotal) {\\n        if(desiredTotal == 0) return true;\\n        \\n        // Handle edge case\\n        int n = maxChoosableInteger;\\n        int sum = (n * (n + 1))/2;\\n        if(sum < desiredTotal) return false;\\n        \\n        memo = new byte[1 << (n + 1)];\\n        \\n        return p1CanWin(0, n, desiredTotal);\\n    }\\n    \\n    public boolean p1CanWin(int state, int maxInt, int desiredTotal) {\\n        if(desiredTotal <= 0) return false;\\n        \\n        if(memo[state] != 0) {\\n            return (memo[state] == 1);\\n        }\\n        \\n        for(int i = 1; i <= maxInt; ++i) {\\n            if((state & (1 << i)) == 0) {\\n                boolean res = p1CanWin(state | (1 << i), maxInt, desiredTotal - i);\\n                if(!res) {\\n                    memo[state] = 1;\\n                    return true;\\n                }\\n            }\\n        }\\n        \\n        memo[state] = -1;\\n        return false;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 95302,
                "title": "python-dfs-very-easy-to-understand",
                "content": "```\\nclass Solution(object):\\n    def canIWin(self, maxChoosableInteger, desiredTotal):\\n        choosable = tuple(range(1, maxChoosableInteger + 1))\\n        if sum(choosable) < desiredTotal: return False\\n        self.cache = {}\\n        return self.dfs(choosable, desiredTotal)\\n        \\n    def dfs(self, choosable, total):\\n        if choosable[-1] >= total: return True\\n        key = choosable\\n        if key in self.cache: return self.cache[key]\\n        for i in range(len(choosable)):\\n            if not self.dfs(choosable[:i] + choosable[i + 1:], total - choosable[i]):\\n                self.cache[key] = True\\n                return True\\n        self.cache[key] = False\\n        return False\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution(object):\\n    def canIWin(self, maxChoosableInteger, desiredTotal):\\n        choosable = tuple(range(1, maxChoosableInteger + 1))\\n        if sum(choosable) < desiredTotal: return False\\n        self.cache = {}\\n        return self.dfs(choosable, desiredTotal)\\n        \\n    def dfs(self, choosable, total):\\n        if choosable[-1] >= total: return True\\n        key = choosable\\n        if key in self.cache: return self.cache[key]\\n        for i in range(len(choosable)):\\n            if not self.dfs(choosable[:i] + choosable[i + 1:], total - choosable[i]):\\n                self.cache[key] = True\\n                return True\\n        self.cache[key] = False\\n        return False\\n```",
                "codeTag": "Java"
            },
            {
                "id": 95303,
                "title": "c-easy-to-understand-dfs-solution-with-explanation",
                "content": "Player1 can win if and only if they can make a move after which player2 will lose no matter how they move. So we can check all possible moves of player1 and call the same function to see if player2 will lose after this move. This is the main idea. I use caching to memorize states for each possible desiredTotal and set of chosable integers. Since maxChoosableInteger is not greater than 20, all currently possible moves can be represented as a bit flag.\\n```\\nclass Solution {\\npublic:\\n    bool canWin(int key, int desiredTotal,vector<unordered_map<int,bool>> &cache, int mx) {\\n        if(cache[desiredTotal-1].find(key) != cache[desiredTotal-1].end())\\n           return cache[desiredTotal-1][key];\\n        for(int i = mx-1; i >= 0;--i)\\n           if(key & (1 << i))\\n           {\\n               key ^= (1 << i);\\n               if(i+1 >= desiredTotal || !canWin(key,desiredTotal-i-1,cache,mx))\\n               {\\n                  cache[desiredTotal-1][key] = true;\\n                  key |= (1 << i);\\n                  return true;\\n               }\\n               key |= (1 << i);\\n           }\\n        cache[desiredTotal-1][key] = false;\\n        return false;\\n    }\\n    bool canIWin(int maxChoosableInteger, int desiredTotal) {\\n        if(desiredTotal <= 1)\\n          return true;\\n        if(maxChoosableInteger*(maxChoosableInteger+1) < desiredTotal*2)\\n           return false;\\n        vector<unordered_map<int,bool>> cache(desiredTotal);\\n        vector<bool> v(maxChoosableInteger,true);\\n        int key = (1 << maxChoosableInteger)-1; \\n        return canWin(key,desiredTotal,cache,maxChoosableInteger);\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Depth-First Search"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    bool canWin(int key, int desiredTotal,vector<unordered_map<int,bool>> &cache, int mx) {\\n        if(cache[desiredTotal-1].find(key) != cache[desiredTotal-1].end())\\n           return cache[desiredTotal-1][key];\\n        for(int i = mx-1; i >= 0;--i)\\n           if(key & (1 << i))\\n           {\\n               key ^= (1 << i);\\n               if(i+1 >= desiredTotal || !canWin(key,desiredTotal-i-1,cache,mx))\\n               {\\n                  cache[desiredTotal-1][key] = true;\\n                  key |= (1 << i);\\n                  return true;\\n               }\\n               key |= (1 << i);\\n           }\\n        cache[desiredTotal-1][key] = false;\\n        return false;\\n    }\\n    bool canIWin(int maxChoosableInteger, int desiredTotal) {\\n        if(desiredTotal <= 1)\\n          return true;\\n        if(maxChoosableInteger*(maxChoosableInteger+1) < desiredTotal*2)\\n           return false;\\n        vector<unordered_map<int,bool>> cache(desiredTotal);\\n        vector<bool> v(maxChoosableInteger,true);\\n        int key = (1 << maxChoosableInteger)-1; \\n        return canWin(key,desiredTotal,cache,maxChoosableInteger);\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3278787,
                "title": "464-solution-with-step-by-step-explanation",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n1. Define the function canIWin which takes in two integers, maxChoosableInteger and desiredTotal, and returns a boolean indicating whether the first player can win the game or not.\\n\\n2. Check if desiredTotal is less than or equal to zero. If it is, then the first player has already won and we return True.\\n\\n3. Check if the sum of all integers from 1 to maxChoosableInteger is less than desiredTotal. If it is, then it is not possible for the first player to win and we return False.\\n\\n4. Initialize a dictionary self.memo to store the sub-problems result.\\n\\n5. Call the can_win function which will traverse through all possible moves of player 1 and check if they can win the game.\\n\\n6. Define the can_win function which takes in choices - a tuple of integers representing the remaining integers that can be chosen, and target - the remaining total that needs to be reached, and returns a boolean indicating whether player 1 can win the game or not.\\n\\n7. If there is only one choice left and it\\'s value is greater than or equal to target, then player 1 wins and we return True.\\n\\n8. If the sub-problem already exists in the self.memo dictionary, return its result.\\n\\n9. Traverse through all possible moves of player 1 by looping through the indices of choices.\\n\\n10. Remove the chosen integer from the choices tuple and subtract its value from the target.\\n\\n11. Recursively call the can_win function with the updated choices tuple and target value.\\n\\n12. If player 2 can\\'t win with the current move of player 1, then player 1 can win and we return True.\\n\\n13. If no move of player 1 results in player 1 winning, then player 1 can\\'t win and we return False.\\n\\n14. Finally, store the result in the self.memo dictionary for future reference.\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution:\\n  def canIWin(self, maxChoosableInteger: int, desiredTotal: int) -> bool:\\n    # If desiredTotal is less than or equal to zero, then player 1 wins\\n    if desiredTotal <= 0:\\n        return True\\n    # If the sum of all the integers is less than the desiredTotal, then player 1 can\\'t win\\n    if (maxChoosableInteger * (maxChoosableInteger + 1)) // 2 < desiredTotal:\\n        return False\\n    \\n    # Store the sub-problems result\\n    self.memo = {}\\n    \\n    # Traverse through all possible moves of player 1\\n    return self.can_win(tuple(range(1, maxChoosableInteger+1)), desiredTotal)\\n\\n\\n  def can_win(self, choices, target):\\n    # If there is only one choice left and it\\'s value is greater than or equal to target, then player 1 wins\\n    if choices[-1] >= target:\\n        return True\\n    \\n    # If the sub-problem already exists, return it\\'s result\\n    if choices in self.memo:\\n        return self.memo[choices]\\n    \\n    # Traverse through all possible moves of player 1\\n    for i in range(len(choices)):\\n        # Player 1 chooses a number\\n        if not self.can_win(choices[:i]+choices[i+1:], target-choices[i]):\\n            # If player 2 can\\'t win, then player 1 can win\\n            self.memo[choices] = True\\n            return True\\n    \\n    # If no move of player 1 results in player 1 winning, then player 1 can\\'t win\\n    self.memo[choices] = False\\n    return False\\n\\n```",
                "solutionTags": [
                    "Python",
                    "Python3",
                    "Math",
                    "Dynamic Programming",
                    "Bit Manipulation"
                ],
                "code": "```\\nclass Solution:\\n  def canIWin(self, maxChoosableInteger: int, desiredTotal: int) -> bool:\\n    # If desiredTotal is less than or equal to zero, then player 1 wins\\n    if desiredTotal <= 0:\\n        return True\\n    # If the sum of all the integers is less than the desiredTotal, then player 1 can\\'t win\\n    if (maxChoosableInteger * (maxChoosableInteger + 1)) // 2 < desiredTotal:\\n        return False\\n    \\n    # Store the sub-problems result\\n    self.memo = {}\\n    \\n    # Traverse through all possible moves of player 1\\n    return self.can_win(tuple(range(1, maxChoosableInteger+1)), desiredTotal)\\n\\n\\n  def can_win(self, choices, target):\\n    # If there is only one choice left and it\\'s value is greater than or equal to target, then player 1 wins\\n    if choices[-1] >= target:\\n        return True\\n    \\n    # If the sub-problem already exists, return it\\'s result\\n    if choices in self.memo:\\n        return self.memo[choices]\\n    \\n    # Traverse through all possible moves of player 1\\n    for i in range(len(choices)):\\n        # Player 1 chooses a number\\n        if not self.can_win(choices[:i]+choices[i+1:], target-choices[i]):\\n            # If player 2 can\\'t win, then player 1 can win\\n            self.memo[choices] = True\\n            return True\\n    \\n    # If no move of player 1 results in player 1 winning, then player 1 can\\'t win\\n    self.memo[choices] = False\\n    return False\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2462608,
                "title": "python-bitmask-solution-from-someone-who-is-bad-at-bitmask",
                "content": "```\\nclass Solution:\\n    def canIWin(self, maxChoosableInteger: int, desiredTotal: int) -> bool:\\n        \\n        if ((maxChoosableInteger + 1) * maxChoosableInteger) // 2 < desiredTotal:\\n            return False\\n        \\n        available = (1 << maxChoosableInteger) - 1\\n        \\n        @functools.cache\\n        def c(mask: int, target: int) -> bool:\\n            for i in range(maxChoosableInteger):\\n                if (mask & (1 << i)):\\n                    if i + 1 >= target:\\n                        return True\\n                    if not c(mask ^ (1 << i), target - (i + 1)):\\n                        return True\\n            return False\\n        \\n        return c(available, desiredTotal)\\n```\\n\\nBefore getting into the specifics of this problem, I think about a game where either you can win or I can win, and I am the player making the current move.\\n\\nThe recurrence relationship is deceptively straight forward:\\n\\n**I can win if and only if there is a move where you cannot win after I make that move**\\n\\nIf I have a bunch of possible moves, but every single move I try results in you winning, then I cannot win.\\n\\nWhen considering a move I can make, I then consider the moves you can make. Then you become the current player, and you determine whether there is any move you can make that results in me not winning.\\n\\nNow to the specific problem. The moves are determined by a choice of a subset of numbers between `1` and `maxChoosableInteger` . Initially the entire range is available to choose from, but the catch is that after a player picks a number, that number can never be picked again.\\n\\nIt is also possible that nobody can win, so we should check for that off the bat. If the sum of all the numbers between 1 and maxChoosableInteger is less than the desiredTotal, then nobody can win, so just return False.\\n\\nMy first instinct is to use a `Set` to keep track of what numbers are still available. However, when I tried that, I ran into TLE, because I could not memoize the `Set` that tracked which numbers had been used already.\\n\\nHowever, keeping track of which numbers were used is also a job for a bitmask. Each bit represents whether a number has been used or not, read from right to left. So the nth bit represents whether the 1st number was used, the (n - 1)th bit represents whether the 2nd number was used, etc.\\n\\nThe initial bitmask should be maxChoosableInteger 1\\'s in a row. The way to get this is to take the number 1, add maxChoosableIntegers zeroes to the right of it (left shift by maxChoosableIntegers), so if maxChoosableIntegers was 4, then we want to get `1 << 4` or `b10000` . Then to get all 1\\'s, we subtract 1 from it. It will carry over and the first 1 will go away, so it will become `b1111` .\\n\\nThen at each possible move, we iterate over the `maxChoosableIntegers` possible digits of the binary representattion of the mask. For each one, we want to find out whether that digit is a 1.\\n\\nTo find that out, we want to `&` the mask with a binary with a 1 in the `i`th position and `i` `0`s to its left. Just like before, shift `1` by `i` zeroes (left shift) to get `1 << i` and then `&` that with mask. For example:\\n\\n`mask` is `b101100`\\n`i` is `8`\\n`1 << i` is `100000000`\\n`mask & (1 << i)` is `0` \\n\\nNote that in this example, there are fewer digits in the mask than `i`, which will happen if all of the leading digits are `0`s.\\n\\nAnother example:\\n\\n`mask` is `b101100`\\n`i` is `2`\\n`1 << i` is `100`\\n`mask & ( 1 << i )` is `b100`\\n\\nNow, if `mask & (1 << i)` is not all zeroes, then we know we can try to make that move.\\n\\nNow we compare `i` with the `target`. If it is at least the `target`, then we can win with this move.\\n\\nOtherwise, we need to find if the other player **cannot win** with this move. `c(newmask, target - (i + 1))`\\n\\nThen the recursive function call needs to supply the new mask, which should be the old mask but replacing the `i`th digit from the right with a 0.\\n\\nTo do so, we want to `^` the mask with `(1 << i)` , because this will leave every digit in the mask the same **except for the `ith` digit, which will be 0**\\n",
                "solutionTags": [
                    "Bitmask"
                ],
                "code": "```\\nclass Solution:\\n    def canIWin(self, maxChoosableInteger: int, desiredTotal: int) -> bool:\\n        \\n        if ((maxChoosableInteger + 1) * maxChoosableInteger) // 2 < desiredTotal:\\n            return False\\n        \\n        available = (1 << maxChoosableInteger) - 1\\n        \\n        @functools.cache\\n        def c(mask: int, target: int) -> bool:\\n            for i in range(maxChoosableInteger):\\n                if (mask & (1 << i)):\\n                    if i + 1 >= target:\\n                        return True\\n                    if not c(mask ^ (1 << i), target - (i + 1)):\\n                        return True\\n            return False\\n        \\n        return c(available, desiredTotal)\\n```",
                "codeTag": "Java"
            },
            {
                "id": 712626,
                "title": "java-top-down-dp-with-bit-mask",
                "content": "```\\nclass Solution {\\n    Boolean[] dp;\\n    public boolean canIWin(int maxChoosableInteger, int desiredTotal) {\\n        if (desiredTotal == 0) return true;\\n        if (maxChoosableInteger * (maxChoosableInteger + 1) / 2 < desiredTotal) return false;\\n        int m = desiredTotal, n = maxChoosableInteger, l = 1 << n;\\n        dp = new Boolean[l + 1];\\n        return dfs(0, 0, n, m);  //\\n    }\\n    \\n    private boolean dfs(int tot, int mask, int n, int m) {\\n        if (tot >= m) return false;  \\n        if (dp[mask] != null) return dp[mask];\\n        dp[mask] = false;\\n        for (int i = 0; i < n; i++) {\\n            if (((1 << i) & mask) > 0) continue; // num already picked\\n            if (!dfs(tot + i + 1, mask | (1 << i), n, m)) {  // found a strategy next player won\\'t win\\n                dp[mask] = true;\\n                return true;\\n            }\\n        }\\n        return dp[mask];\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    Boolean[] dp;\\n    public boolean canIWin(int maxChoosableInteger, int desiredTotal) {\\n        if (desiredTotal == 0) return true;\\n        if (maxChoosableInteger * (maxChoosableInteger + 1) / 2 < desiredTotal) return false;\\n        int m = desiredTotal, n = maxChoosableInteger, l = 1 << n;\\n        dp = new Boolean[l + 1];\\n        return dfs(0, 0, n, m);  //\\n    }\\n    \\n    private boolean dfs(int tot, int mask, int n, int m) {\\n        if (tot >= m) return false;  \\n        if (dp[mask] != null) return dp[mask];\\n        dp[mask] = false;\\n        for (int i = 0; i < n; i++) {\\n            if (((1 << i) & mask) > 0) continue; // num already picked\\n            if (!dfs(tot + i + 1, mask | (1 << i), n, m)) {  // found a strategy next player won\\'t win\\n                dp[mask] = true;\\n                return true;\\n            }\\n        }\\n        return dp[mask];\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 360504,
                "title": "python3-dfs-with-memoization-in-a-pythonic-way-concise-and-beating-98-100",
                "content": ">Runtime: 380 ms, faster than 98.01% of Python3 submissions for Can I Win.\\n>\\n>Memory Usage: 33.3 MB, less than 100.00% of Python3 online submissions for Can I Win.\\n\\nThe idea is almost the same with other posts in discussion: just using DFS to search all possibilities and optimizing DFS with memoization (`lru_cache`). \\n\\nBut to avoid TLE, I first try to quickly handle two special corner cases and then use DFS.\\n\\nAnd also, I write it in a pythonic way to make my solution **conciser and easier to understand**.\\n\\nIf you skip lines for handling special cases, it\\'s just 6 lines.\\n```python\\nimport functools\\nclass Solution:\\n    # Algorithm: DFS (with cache)\\n    # Time: O(2^n)\\n    # Space: O(2^n)\\n    def canIWin(self, maxChoosableInteger: int, desiredTotal: int) -> bool:\\n        # quickly handle two special cases\\n        sum_of_all = (maxChoosableInteger + 1) * maxChoosableInteger // 2\\n        if sum_of_all < desiredTotal:\\n            return False\\n        if sum_of_all == desiredTotal:\\n            return maxChoosableInteger % 2 == 1\\n        @functools.lru_cache(None)\\n        def can_i_win(options, target):\\n            if options[-1] >= target:\\n                return True\\n            return not all(can_i_win(options[:i] + options[i + 1:],target - x) for i, x in enumerate(options))\\n        \\n        return can_i_win(tuple(range(1, maxChoosableInteger + 1)), desiredTotal)\\n```",
                "solutionTags": [
                    "Python3",
                    "Depth-First Search",
                    "Memoization"
                ],
                "code": "```python\\nimport functools\\nclass Solution:\\n    # Algorithm: DFS (with cache)\\n    # Time: O(2^n)\\n    # Space: O(2^n)\\n    def canIWin(self, maxChoosableInteger: int, desiredTotal: int) -> bool:\\n        # quickly handle two special cases\\n        sum_of_all = (maxChoosableInteger + 1) * maxChoosableInteger // 2\\n        if sum_of_all < desiredTotal:\\n            return False\\n        if sum_of_all == desiredTotal:\\n            return maxChoosableInteger % 2 == 1\\n        @functools.lru_cache(None)\\n        def can_i_win(options, target):\\n            if options[-1] >= target:\\n                return True\\n            return not all(can_i_win(options[:i] + options[i + 1:],target - x) for i, x in enumerate(options))\\n        \\n        return can_i_win(tuple(range(1, maxChoosableInteger + 1)), desiredTotal)\\n```",
                "codeTag": "Java"
            },
            {
                "id": 232786,
                "title": "javascript-recursion-memorization-solution",
                "content": "```\\nvar canIWin = function(maxChoosableInteger, desiredTotal) {\\n    \\n    const picked = new Array(maxChoosableInteger + 1).fill(false);\\n    const memo = new Map();\\n    \\n    if (desiredTotal <= maxChoosableInteger) // because player1 can just pick the max and win\\n        return true;\\n    \\n    // this formula gives us the sum from 1...maxChoosableInteger, and if the sum cannot exceed the desiredTotal, no one wins\\n    if ((1 + maxChoosableInteger) / 2 * maxChoosableInteger < desiredTotal) \\n        return false;\\n    \\n    function dfs(picked, total) {\\n        \\n        let key = picked.toString();\\n        \\n        if(memo.has(key)) return memo.get(key);\\n        \\n\\t\\t// we try every number minus the one that\\'s been tried\\n        for(let i = 1; i <= maxChoosableInteger; i++) {\\n            \\n            if(picked[i]) {\\n                continue;\\n            }\\n            \\n            picked[i] = true;\\n            \\n            // if we win here OR player2 does not win next\\n            if(total - i <= 0 || !dfs(picked, total - i)) {\\n\\t\\t\\t\\t// do not forget to backtrack!\\n                picked[i] = false;\\n                memo.set(key, true);\\n                return true;\\n            }\\n            // do not forget to backtrack!\\n            picked[i] = false;\\n            \\n        }\\n        \\n        memo.set(key, false);\\n        return false;\\n    }\\n\\n    \\n    return dfs(picked, desiredTotal);\\n    \\n};\\n```",
                "solutionTags": [],
                "code": "```\\nvar canIWin = function(maxChoosableInteger, desiredTotal) {\\n    \\n    const picked = new Array(maxChoosableInteger + 1).fill(false);\\n    const memo = new Map();\\n    \\n    if (desiredTotal <= maxChoosableInteger) // because player1 can just pick the max and win\\n        return true;\\n    \\n    // this formula gives us the sum from 1...maxChoosableInteger, and if the sum cannot exceed the desiredTotal, no one wins\\n    if ((1 + maxChoosableInteger) / 2 * maxChoosableInteger < desiredTotal) \\n        return false;\\n    \\n    function dfs(picked, total) {\\n        \\n        let key = picked.toString();\\n        \\n        if(memo.has(key)) return memo.get(key);\\n        \\n\\t\\t// we try every number minus the one that\\'s been tried\\n        for(let i = 1; i <= maxChoosableInteger; i++) {\\n            \\n            if(picked[i]) {\\n                continue;\\n            }\\n            \\n            picked[i] = true;\\n            \\n            // if we win here OR player2 does not win next\\n            if(total - i <= 0 || !dfs(picked, total - i)) {\\n\\t\\t\\t\\t// do not forget to backtrack!\\n                picked[i] = false;\\n                memo.set(key, true);\\n                return true;\\n            }\\n            // do not forget to backtrack!\\n            picked[i] = false;\\n            \\n        }\\n        \\n        memo.set(key, false);\\n        return false;\\n    }\\n\\n    \\n    return dfs(picked, desiredTotal);\\n    \\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 95304,
                "title": "c-easy-understood-269ms-solution-with-comments",
                "content": "```\\nclass Solution {\\n    unordered_map<unsigned int,bool> cache;\\npublic:\\n    bool canIWin(int maxChoosableInteger, int desiredTotal) {\\n        if(maxChoosableInteger>=desiredTotal) return true;\\n        //the sum of all available numbers are less than desireTotal, which means it cannot reach the desireTotal\\n        if((1 + maxChoosableInteger) * maxChoosableInteger / 2 < desiredTotal) return false;\\n        unsigned int used = (1<<maxChoosableInteger)-1; // use bit to record which number has been used (bit '1' means available, bit '0' means used)\\n        return play(desiredTotal,used,maxChoosableInteger);\\n    }\\n    bool play(int target, unsigned int used, int size){\\n        if(cache.find(used) != cache.end()) return cache[used];\\n        //exist available integer >= target, return true\\n        if(target-1<size && (used > (1<<target-1))){\\n            cache[used] = true;\\n            return true;\\n        }\\n        int bit = 1;\\n        for(int i = 0; i<size; i++,bit <<=1){\\n            if((used & bit)== 0) continue; // the (i+1)th bit is '0', means (i+1) is used\\n            used ^= bit;\\n            if(!play(target-i-1,used,size)){\\n                used |= bit;\\n                cache[used] = true;\\n                return true;\\n            }\\n            used |= bit;\\n        }\\n        cache[used] =  false;\\n        return false;\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    unordered_map<unsigned int,bool> cache;\\npublic:\\n    bool canIWin(int maxChoosableInteger, int desiredTotal) {\\n        if(maxChoosableInteger>=desiredTotal) return true;\\n        //the sum of all available numbers are less than desireTotal, which means it cannot reach the desireTotal\\n        if((1 + maxChoosableInteger) * maxChoosableInteger / 2 < desiredTotal) return false;\\n        unsigned int used = (1<<maxChoosableInteger)-1; // use bit to record which number has been used (bit '1' means available, bit '0' means used)\\n        return play(desiredTotal,used,maxChoosableInteger);\\n    }\\n    bool play(int target, unsigned int used, int size){\\n        if(cache.find(used) != cache.end()) return cache[used];\\n        //exist available integer >= target, return true\\n        if(target-1<size && (used > (1<<target-1))){\\n            cache[used] = true;\\n            return true;\\n        }\\n        int bit = 1;\\n        for(int i = 0; i<size; i++,bit <<=1){\\n            if((used & bit)== 0) continue; // the (i+1)th bit is '0', means (i+1) is used\\n            used ^= bit;\\n            if(!play(target-i-1,used,size)){\\n                used |= bit;\\n                cache[used] = true;\\n                return true;\\n            }\\n            used |= bit;\\n        }\\n        cache[used] =  false;\\n        return false;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2674636,
                "title": "c-95-faster-than-all-easy",
                "content": "\\n# Code\\n```\\nclass Solution {\\npublic:\\n    bool canIWin(int M, int T) \\n  {\\n    int sum = M*(M+1)/2; // sum of entire choosable pool\\n\\n    // I just pick 1 to win\\n    if (T < 2) return true;\\n    \\n    // Total is too large, nobody can win\\n    else if (sum < T) return false;\\n    \\n    // Total happens to match sum, whoever picks at odd times wins\\n    else if (sum == T) return M%2;\\n    \\n    // Non-trivial case: do DFS\\n    // Initial total: T\\n    // Initial game state: k = 0 (all numbers are not picked)\\n    else return dfs(M, T, 0);\\n  }\\n\\n  // DFS to check if I can win\\n  // k: current game state\\n  // T: remaining total to reach\\n  bool dfs(int M, int T, int k) \\n  {\\n    // memorized\\n    if (mem[k] != 0) return mem[k] > 0;\\n    \\n    // total is already reached by opponent, so I lose\\n    if (T <= 0) return false;\\n\\n    // try all currently available numbers\\n    for (int i = 0; i < M; ++i)\\n      // if (i+1) is available to pick and my opponent can\\'t win after I picked, I win!\\n      if (!(k&(1<<i)) && !dfs(M, T-i-1, k|(1<<i))) {\\n        mem[k] = 1;\\n        return true;\\n      } \\n    \\n    // Otherwise, I will lose\\n    mem[k] = -1;\\n    return false;      \\n  }\\n\\n  // m[key]: memorized game result when pool state = key\\n  // 0: un-computed; 1: I win; -1: I lose\\n  int mem[1<<20] = {};\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    bool canIWin(int M, int T) \\n  {\\n    int sum = M*(M+1)/2; // sum of entire choosable pool\\n\\n    // I just pick 1 to win\\n    if (T < 2) return true;\\n    \\n    // Total is too large, nobody can win\\n    else if (sum < T) return false;\\n    \\n    // Total happens to match sum, whoever picks at odd times wins\\n    else if (sum == T) return M%2;\\n    \\n    // Non-trivial case: do DFS\\n    // Initial total: T\\n    // Initial game state: k = 0 (all numbers are not picked)\\n    else return dfs(M, T, 0);\\n  }\\n\\n  // DFS to check if I can win\\n  // k: current game state\\n  // T: remaining total to reach\\n  bool dfs(int M, int T, int k) \\n  {\\n    // memorized\\n    if (mem[k] != 0) return mem[k] > 0;\\n    \\n    // total is already reached by opponent, so I lose\\n    if (T <= 0) return false;\\n\\n    // try all currently available numbers\\n    for (int i = 0; i < M; ++i)\\n      // if (i+1) is available to pick and my opponent can\\'t win after I picked, I win!\\n      if (!(k&(1<<i)) && !dfs(M, T-i-1, k|(1<<i))) {\\n        mem[k] = 1;\\n        return true;\\n      } \\n    \\n    // Otherwise, I will lose\\n    mem[k] = -1;\\n    return false;      \\n  }\\n\\n  // m[key]: memorized game result when pool state = key\\n  // 0: un-computed; 1: I win; -1: I lose\\n  int mem[1<<20] = {};\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2673893,
                "title": "python-3-464-can-i-win",
                "content": "```\\nclass Solution:\\n    @lru_cache(None)\\n    def canIWin(self, mx: int, desiredTotal: int, bitMask = 0) -> bool:\\n        \\n        if ((1+mx)*mx < 2*desiredTotal or \\n            desiredTotal <= 0 and bitMask): return False\\n\\n        for i in range(mx):\\n            if not (bitMask >> i) & 1:\\n                \\n                if not self.canIWin(mx, desiredTotal-i-1, (1<<i)|bitMask):\\n                        return True",
                "solutionTags": [
                    "Python"
                ],
                "code": "```\\nclass Solution:\\n    @lru_cache(None)\\n    def canIWin(self, mx: int, desiredTotal: int, bitMask = 0) -> bool:\\n        \\n        if ((1+mx)*mx < 2*desiredTotal or \\n            desiredTotal <= 0 and bitMask): return False\\n\\n        for i in range(mx):\\n            if not (bitMask >> i) & 1:\\n                \\n                if not self.canIWin(mx, desiredTotal-i-1, (1<<i)|bitMask):\\n                        return True",
                "codeTag": "Java"
            },
            {
                "id": 2157115,
                "title": "short-easy-dp-c-solution-explained",
                "content": "```\\nclass Solution {\\npublic:\\n    vector<int> dp;\\n    \\n    bool changeTurn(int x, int mask, int k) {\\n        // Base Case - Checking if at this player\\'s turn target becomes <=0 then that player losses\\n        if(k<=0) return false;\\n        \\n        // To Handle Overlapping\\n        if(dp[mask]!=-1) return dp[mask];\\n        \\n        \\n        // Every Player is going to try combination of all the numbers which he can play with and then he will play with only that number which leads him to victory.\\n        \\n        // If he doesn\\'t win then he can go with any possible playable number\\n        \\n        for(int j=1;j<=x;j++) {\\n            //Checking which combination leads him to victory\\n            dp[mask] = false;\\n            if(!(mask&(1<<j))) {\\n                dp[mask] = dp[mask] | !changeTurn(x,mask|(1<<j),k-j);\\n                if(dp[mask]) return dp[mask] = true;\\n            }\\n        }\\n        \\n        // If not Combination is found then return false\\n        return dp[mask] = false;\\n    }\\n    \\n    \\n    \\n    bool canIWin(int x, int k) {\\n        dp = vector<int>(1<<(x+1),-1);\\n        if(k==0) return true;\\n        \\n        // Edge Case not Mentioned in Question - Total Possible Sum < Target\\n        if((x*(x+1))/2<k) return false;\\n        \\n        // Mask to store which numbers are taken\\n        int mask = 0;\\n        return changeTurn(x,mask,k);\\n    }\\n};\\n```",
                "solutionTags": [
                    "Dynamic Programming",
                    "Bitmask"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<int> dp;\\n    \\n    bool changeTurn(int x, int mask, int k) {\\n        // Base Case - Checking if at this player\\'s turn target becomes <=0 then that player losses\\n        if(k<=0) return false;\\n        \\n        // To Handle Overlapping\\n        if(dp[mask]!=-1) return dp[mask];\\n        \\n        \\n        // Every Player is going to try combination of all the numbers which he can play with and then he will play with only that number which leads him to victory.\\n        \\n        // If he doesn\\'t win then he can go with any possible playable number\\n        \\n        for(int j=1;j<=x;j++) {\\n            //Checking which combination leads him to victory\\n            dp[mask] = false;\\n            if(!(mask&(1<<j))) {\\n                dp[mask] = dp[mask] | !changeTurn(x,mask|(1<<j),k-j);\\n                if(dp[mask]) return dp[mask] = true;\\n            }\\n        }\\n        \\n        // If not Combination is found then return false\\n        return dp[mask] = false;\\n    }\\n    \\n    \\n    \\n    bool canIWin(int x, int k) {\\n        dp = vector<int>(1<<(x+1),-1);\\n        if(k==0) return true;\\n        \\n        // Edge Case not Mentioned in Question - Total Possible Sum < Target\\n        if((x*(x+1))/2<k) return false;\\n        \\n        // Mask to store which numbers are taken\\n        int mask = 0;\\n        return changeTurn(x,mask,k);\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1693429,
                "title": "java-dp-memoization-bitmasking-faster-than-87",
                "content": "```\\n\\nclass Solution {\\n    int desire;\\n    int range;\\n    Boolean[] dp;\\n    \\n    public boolean canIWin(int maxChoosableInteger, int desiredTotal) {\\n        if(maxChoosableInteger >= desiredTotal) return true;\\n        if((maxChoosableInteger + 1)*maxChoosableInteger / 2 < desiredTotal) return false;\\n        desire = desiredTotal;\\n        range = maxChoosableInteger;\\n        dp = new Boolean[1 << range];\\n        \\n        return dfs(0, 0);\\n    }\\n    \\n    private boolean dfs(int total, int state) {\\n        if(dp[state] != null) return dp[state];\\n        \\n        for(int i = 1; i <= range; i++) {\\n            int cur = 1 << (i-1);\\n            if((cur & state) == 0) {\\n                // Win in this round, or next round/player not win\\n                if(total + i >= desire || !dfs(total + i, state | cur)) {\\n                    dp[state] = true;\\n                    return true;\\n                }\\n            }\\n        }\\n        \\n        return dp[state] = false;\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\n\\nclass Solution {\\n    int desire;\\n    int range;\\n    Boolean[] dp;\\n    \\n    public boolean canIWin(int maxChoosableInteger, int desiredTotal) {\\n        if(maxChoosableInteger >= desiredTotal) return true;\\n        if((maxChoosableInteger + 1)*maxChoosableInteger / 2 < desiredTotal) return false;\\n        desire = desiredTotal;\\n        range = maxChoosableInteger;\\n        dp = new Boolean[1 << range];\\n        \\n        return dfs(0, 0);\\n    }\\n    \\n    private boolean dfs(int total, int state) {\\n        if(dp[state] != null) return dp[state];\\n        \\n        for(int i = 1; i <= range; i++) {\\n            int cur = 1 << (i-1);\\n            if((cur & state) == 0) {\\n                // Win in this round, or next round/player not win\\n                if(total + i >= desire || !dfs(total + i, state | cur)) {\\n                    dp[state] = true;\\n                    return true;\\n                }\\n            }\\n        }\\n        \\n        return dp[state] = false;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1386730,
                "title": "java-min-max-bitmap-dp",
                "content": "```\\nclass Solution {\\n    public boolean canIWin(int maxChoosableInteger, int desiredTotal) {\\n        if (desiredTotal <= maxChoosableInteger) {\\n            return true;\\n        }\\n        if (1.0 * maxChoosableInteger * (1 + maxChoosableInteger) / 2 < desiredTotal) {\\n            return false;\\n        }\\n        return canWin(0, new Boolean[1 << maxChoosableInteger], desiredTotal, maxChoosableInteger);\\n    }\\n    \\n    private boolean canWin(int state, \\n                           Boolean[] dp, \\n                           int desiredTotal, \\n                           int maxChoosableInteger) {\\n        // state is the bitmap representation of the current state of choosable integers left\\n        // dp[state] represents whether the current player can win the game at state\\n        if(dp[state] != null){\\n            return dp[state];\\n        }\\n        for (int i = 1; i <= maxChoosableInteger; i++) {\\n            // current number to pick\\n            int cur = 1 << (i - 1);\\n            if ((cur & state) == 0) {\\n                // i is not used\\n                // set i as used in state\\n                if (i >= desiredTotal || !canWin(state|cur, dp, desiredTotal - i, maxChoosableInteger)) {\\n                    // i is greater than the desired total\\n                    // or the other player cannot win after the current player picks i\\n                    dp[state] = true;\\n                    return dp[state];\\n                }\\n            }\\n        }\\n        dp[state] = false;\\n        return dp[state];\\n    }\\n}\\n```",
                "solutionTags": [
                    "Dynamic Programming",
                    "Depth-First Search",
                    "Bitmask"
                ],
                "code": "```\\nclass Solution {\\n    public boolean canIWin(int maxChoosableInteger, int desiredTotal) {\\n        if (desiredTotal <= maxChoosableInteger) {\\n            return true;\\n        }\\n        if (1.0 * maxChoosableInteger * (1 + maxChoosableInteger) / 2 < desiredTotal) {\\n            return false;\\n        }\\n        return canWin(0, new Boolean[1 << maxChoosableInteger], desiredTotal, maxChoosableInteger);\\n    }\\n    \\n    private boolean canWin(int state, \\n                           Boolean[] dp, \\n                           int desiredTotal, \\n                           int maxChoosableInteger) {\\n        // state is the bitmap representation of the current state of choosable integers left\\n        // dp[state] represents whether the current player can win the game at state\\n        if(dp[state] != null){\\n            return dp[state];\\n        }\\n        for (int i = 1; i <= maxChoosableInteger; i++) {\\n            // current number to pick\\n            int cur = 1 << (i - 1);\\n            if ((cur & state) == 0) {\\n                // i is not used\\n                // set i as used in state\\n                if (i >= desiredTotal || !canWin(state|cur, dp, desiredTotal - i, maxChoosableInteger)) {\\n                    // i is greater than the desired total\\n                    // or the other player cannot win after the current player picks i\\n                    dp[state] = true;\\n                    return dp[state];\\n                }\\n            }\\n        }\\n        dp[state] = false;\\n        return dp[state];\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1360401,
                "title": "c-concise-version-dfs-memo",
                "content": "DFS + memo\\nUse a integer as a state to mark current tested number.\\n\\n\\n```\\nclass Solution {\\npublic:\\n    unordered_map<int, bool> memo;\\n    bool canIWin(int M, int T) {\\n        if (T <= 0) return true;\\n        if (M * (M + 1) / 2 < T) return false;\\n        return dfs(M, T, 0);    \\n    }\\n    bool dfs(int M, int T, int state) {\\n        if (T <= 0) return false;\\n        if (memo.find(state) != memo.end()) return memo[state];\\n        for (int i = 0; i < M; ++i) {\\n            if (state & (1 << i)) continue;\\n            if (!dfs(M, T-(i+1), state | (1 << i))) return memo[state] = true;\\n        }\\n        return memo[state] = false;\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    unordered_map<int, bool> memo;\\n    bool canIWin(int M, int T) {\\n        if (T <= 0) return true;\\n        if (M * (M + 1) / 2 < T) return false;\\n        return dfs(M, T, 0);    \\n    }\\n    bool dfs(int M, int T, int state) {\\n        if (T <= 0) return false;\\n        if (memo.find(state) != memo.end()) return memo[state];\\n        for (int i = 0; i < M; ++i) {\\n            if (state & (1 << i)) continue;\\n            if (!dfs(M, T-(i+1), state | (1 << i))) return memo[state] = true;\\n        }\\n        return memo[state] = false;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1298126,
                "title": "c-bitmasking-solution",
                "content": "```\\nclass Solution {\\npublic:\\n    int mem[1<<20] = {0};\\n    \\n    bool check(int m, int t, int k)\\n    {\\n        if(mem[k] != 0) return mem[k] == 1 ? true : false;\\n        \\n        if(t <= 0) return false;\\n        \\n        for(int i = 0 ; i < m ; i++)\\n        {\\n            if(!(k&(1<<i)))\\n            {\\n                if(check(m, t-i-1, k|(1<<i)) == false)\\n                {\\n                    mem[k] = 1;\\n                    return true;\\n                }\\n            }\\n        }\\n        \\n        mem[k] = -1;\\n        return false;\\n    }\\n    \\n    bool canIWin(int m, int t) {\\n        int s = m*(m+1)/2;\\n        \\n        if(s < t) return false;\\n        if(t < 2) return true;\\n        if(s == t) return m%2;\\n        \\n        return check(m, t, 0);\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    int mem[1<<20] = {0};\\n    \\n    bool check(int m, int t, int k)\\n    {\\n        if(mem[k] != 0) return mem[k] == 1 ? true : false;\\n        \\n        if(t <= 0) return false;\\n        \\n        for(int i = 0 ; i < m ; i++)\\n        {\\n            if(!(k&(1<<i)))\\n            {\\n                if(check(m, t-i-1, k|(1<<i)) == false)\\n                {\\n                    mem[k] = 1;\\n                    return true;\\n                }\\n            }\\n        }\\n        \\n        mem[k] = -1;\\n        return false;\\n    }\\n    \\n    bool canIWin(int m, int t) {\\n        int s = m*(m+1)/2;\\n        \\n        if(s < t) return false;\\n        if(t < 2) return true;\\n        if(s == t) return m%2;\\n        \\n        return check(m, t, 0);\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1122506,
                "title": "c-bitmask",
                "content": "```\\n map<pair<int,int>,bool>m;\\n  bool solve(int mask,int dt,int sum,int mi,int turn){\\n    if(m.find({mask,turn})!=m.end()){\\n      return m[{mask,turn}];\\n    }\\n       \\n    for(int i=mi-1;i>=0;i--){\\n     \\n      if(mask & (1<<i)){\\n         if(sum+i+1>=dt){\\n             return  m[{mask,turn}] = true;\\n           }\\n         if(!solve((mask^(1<<i)),dt,sum+i+1,mi,!turn)){\\n            return m[{mask,turn}]= true; \\n            }\\n         \\n       }\\n    \\n    }\\n    \\n    return m[{mask,turn}]= false;\\n   \\n  }\\n\\n    bool canIWin(int mi, int dt) {\\n      int mask = (1<<mi)-1;\\n      if((mi*(mi+1))/2<dt) return false;\\n      return solve(mask,dt,0,mi,1);\\n    }\\n\\n\\n```",
                "solutionTags": [
                    "C",
                    "Bitmask"
                ],
                "code": "```\\n map<pair<int,int>,bool>m;\\n  bool solve(int mask,int dt,int sum,int mi,int turn){\\n    if(m.find({mask,turn})!=m.end()){\\n      return m[{mask,turn}];\\n    }\\n       \\n    for(int i=mi-1;i>=0;i--){\\n     \\n      if(mask & (1<<i)){\\n         if(sum+i+1>=dt){\\n             return  m[{mask,turn}] = true;\\n           }\\n         if(!solve((mask^(1<<i)),dt,sum+i+1,mi,!turn)){\\n            return m[{mask,turn}]= true; \\n            }\\n         \\n       }\\n    \\n    }\\n    \\n    return m[{mask,turn}]= false;\\n   \\n  }\\n\\n    bool canIWin(int mi, int dt) {\\n      int mask = (1<<mi)-1;\\n      if((mi*(mi+1))/2<dt) return false;\\n      return solve(mask,dt,0,mi,1);\\n    }\\n\\n\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1057477,
                "title": "c-memo-map-clean-solution",
                "content": "```\\nclass Solution {\\npublic:\\n    unordered_map<int,bool> m;\\n    bool dfs(int n,int total,int visited)\\n    {\\n        if(m.find(visited)!=m.end()) return m[visited];\\n        for(int i=1;i<=n;i++)\\n        {\\n            if(visited&(1<<i)) continue;\\n            if(i>=total || !dfs(n,total-i,visited|(1<<i))) {m[visited]=true;return true;}\\n        }\\n        m[visited]=false;\\n        return false;\\n    }\\n    bool canIWin(int n, int total) {\\n        if(n>=total) return true;\\n        if((n*(n+1)/2)<total) return false;\\n        return dfs(n,total,0);\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    unordered_map<int,bool> m;\\n    bool dfs(int n,int total,int visited)\\n    {\\n        if(m.find(visited)!=m.end()) return m[visited];\\n        for(int i=1;i<=n;i++)\\n        {\\n            if(visited&(1<<i)) continue;\\n            if(i>=total || !dfs(n,total-i,visited|(1<<i))) {m[visited]=true;return true;}\\n        }\\n        m[visited]=false;\\n        return false;\\n    }\\n    bool canIWin(int n, int total) {\\n        if(n>=total) return true;\\n        if((n*(n+1)/2)<total) return false;\\n        return dfs(n,total,0);\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1056486,
                "title": "100-efficient-explained-soln",
                "content": "![image](https://assets.leetcode.com/users/images/56d48731-73b8-49d4-a0c1-02d25b6893f2_1612808620.8630137.png)\\n```\\npublic class Solution {\\n    public bool CanIWin(int maxChoosableInteger, int desiredTotal) {\\n        if (desiredTotal <= 0) return true;\\n        \\n        int tSum = 0;\\n        //for (int i = 1; i <= maxChoosableInteger; i++) tSum += i;\\n        tSum = (1 + maxChoosableInteger) * maxChoosableInteger / 2;     // (n+1)*n/2\\n        if (tSum < desiredTotal) return false;\\n        \\n        Dictionary<int, bool> cache = new Dictionary<int, bool>();\\n        return FirstToMoveWins(0, desiredTotal);\\n\\n        // Local Func\\n        bool FirstToMoveWins(int choices, int remainingTotal)\\n        {\\n            if (cache.ContainsKey(choices)) return cache[choices];\\n            int bitMask = 0;\\n            for (int i = maxChoosableInteger; i >= 1; i--)\\n            {\\n                // Mark ith bit ON to indicate ith number is being used\\n                // Ex: 100 in binary means num 3 is used, 10000 in binary means num 5 is used\\n                bitMask = 1 << (i - 1);\\n\\n                if ((choices & bitMask) == 0)   // If Number \\'i+1\\' is not already used\\n                {\\n                    choices ^= bitMask;         // mark current number as used\\n                    remainingTotal -= i;        // decrease remaining total by currently choosen num\\n\\n                    if (remainingTotal <= 0) return true;\\n                    // if 2nd player doesnt wins, than it means P1 wins using num \\'i\\'\\n                    if (!FirstToMoveWins(choices, remainingTotal)) return true;\\n\\n                    remainingTotal += i;        // reset remaining total\\n                    choices ^= bitMask;         // mark back current number as Not used\\n                }\\n            }\\n            cache.Add(choices, false);\\n            return false;\\n        }\\n    }\\n}\\n```",
                "solutionTags": [
                    "Memoization"
                ],
                "code": "```\\npublic class Solution {\\n    public bool CanIWin(int maxChoosableInteger, int desiredTotal) {\\n        if (desiredTotal <= 0) return true;\\n        \\n        int tSum = 0;\\n        //for (int i = 1; i <= maxChoosableInteger; i++) tSum += i;\\n        tSum = (1 + maxChoosableInteger) * maxChoosableInteger / 2;     // (n+1)*n/2\\n        if (tSum < desiredTotal) return false;\\n        \\n        Dictionary<int, bool> cache = new Dictionary<int, bool>();\\n        return FirstToMoveWins(0, desiredTotal);\\n\\n        // Local Func\\n        bool FirstToMoveWins(int choices, int remainingTotal)\\n        {\\n            if (cache.ContainsKey(choices)) return cache[choices];\\n            int bitMask = 0;\\n            for (int i = maxChoosableInteger; i >= 1; i--)\\n            {\\n                // Mark ith bit ON to indicate ith number is being used\\n                // Ex: 100 in binary means num 3 is used, 10000 in binary means num 5 is used\\n                bitMask = 1 << (i - 1);\\n\\n                if ((choices & bitMask) == 0)   // If Number \\'i+1\\' is not already used\\n                {\\n                    choices ^= bitMask;         // mark current number as used\\n                    remainingTotal -= i;        // decrease remaining total by currently choosen num\\n\\n                    if (remainingTotal <= 0) return true;\\n                    // if 2nd player doesnt wins, than it means P1 wins using num \\'i\\'\\n                    if (!FirstToMoveWins(choices, remainingTotal)) return true;\\n\\n                    remainingTotal += i;        // reset remaining total\\n                    choices ^= bitMask;         // mark back current number as Not used\\n                }\\n            }\\n            cache.Add(choices, false);\\n            return false;\\n        }\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 957486,
                "title": "python-short-readable-immediately-win-or-opponent-will-lose",
                "content": "- The code has variables with names easy to read. Please check it out!\\n\\n- Some details to be careful:\\n\\t1. to use lru_cache, make every argument to be int or tuple.\\n\\t2. The order matters:  ```choose number -> check win or not -> if not, switch to opponent\\'s turn```\\n\\t\\t( It will be wrong in this order: ```check win or not -> choose number```)\\n\\t3. there are cases both players cannot reach the ```desiredTotal```, check this at begining\\n\\n```\\nclass Solution:\\n    def canIWin(self, N: int, desiredTotal: int) -> bool:\\n        if (1+N)*N // 2 < desiredTotal: return False\\n        \\n        @lru_cache(None)\\n        def dp(cur, curpool):\\n            \\n            for i in range(len(curpool)):\\n                \\n                new = cur + curpool[i]\\n                \\n                win_rightnow = (new >= desiredTotal)\\n                if win_rightnow: \\n                    return True\\n                \\n                opponent_win = dp(new, curpool[:i]+curpool[i+1:])\\n                if not opponent_win: \\n                    return True\\n                \\n            return False\\n        \\n        pool = tuple(range(1,N+1))\\n        return dp(0, pool)\\n```",
                "solutionTags": [],
                "code": "```choose number -> check win or not -> if not, switch to opponent\\'s turn```\n```check win or not -> choose number```\n```desiredTotal```\n```\\nclass Solution:\\n    def canIWin(self, N: int, desiredTotal: int) -> bool:\\n        if (1+N)*N // 2 < desiredTotal: return False\\n        \\n        @lru_cache(None)\\n        def dp(cur, curpool):\\n            \\n            for i in range(len(curpool)):\\n                \\n                new = cur + curpool[i]\\n                \\n                win_rightnow = (new >= desiredTotal)\\n                if win_rightnow: \\n                    return True\\n                \\n                opponent_win = dp(new, curpool[:i]+curpool[i+1:])\\n                if not opponent_win: \\n                    return True\\n                \\n            return False\\n        \\n        pool = tuple(range(1,N+1))\\n        return dp(0, pool)\\n```",
                "codeTag": "Java"
            },
            {
                "id": 865848,
                "title": "java-clean-code-dp",
                "content": "```\\nclass Solution {\\n    Map<Integer, Boolean> cache = new HashMap<>();\\n    public boolean canIWin(int maxChoosableInteger, int desiredTotal) {\\n        if (desiredTotal <= 0)\\n            return true;\\n        if (maxChoosableInteger * (maxChoosableInteger+1)/2 < desiredTotal)\\n            return false;\\n        return win(maxChoosableInteger, desiredTotal, 0);\\n    }\\n    \\n    boolean win(int max, int val, int state) {\\n        if (val <= 0)\\n            return false;\\n        if (cache.containsKey(state))\\n            return cache.get(state);\\n        boolean ans = false;\\n        for (int i = 0; i < max; i++)\\n            if ((1 << i & state) == 0) {\\n                if (!win(max, val-i-1, 1 << i | state)) {\\n                    ans = true;\\n                    break;\\n                }\\n            }\\n        cache.put(state, ans);\\n        return ans;\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    Map<Integer, Boolean> cache = new HashMap<>();\\n    public boolean canIWin(int maxChoosableInteger, int desiredTotal) {\\n        if (desiredTotal <= 0)\\n            return true;\\n        if (maxChoosableInteger * (maxChoosableInteger+1)/2 < desiredTotal)\\n            return false;\\n        return win(maxChoosableInteger, desiredTotal, 0);\\n    }\\n    \\n    boolean win(int max, int val, int state) {\\n        if (val <= 0)\\n            return false;\\n        if (cache.containsKey(state))\\n            return cache.get(state);\\n        boolean ans = false;\\n        for (int i = 0; i < max; i++)\\n            if ((1 << i & state) == 0) {\\n                if (!win(max, val-i-1, 1 << i | state)) {\\n                    ans = true;\\n                    break;\\n                }\\n            }\\n        cache.put(state, ans);\\n        return ans;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 850051,
                "title": "python3-top-down-dp",
                "content": "Intuition: \\nThe question itself is straightforward to understand. The challenge is choice of design. Here, I resort to a DP route by defining function `fn` to indicate if a winning strategy exists given a reservoir of integers and desired total. At any step, if one could choose a number `x` so that `total - x` and updated reservoir gives no winning strategy, then there is a winning strategy for the given reservoir and total. \\n\\nImplementation: \\n```\\nclass Solution:\\n    def canIWin(self, maxChoosableInteger: int, desiredTotal: int) -> bool:\\n        if desiredTotal == 0: return True # edge case 1\\n        if maxChoosableInteger * (maxChoosableInteger+1)//2 < desiredTotal: return False # edge case 2\\n        \\n        @lru_cache(None)\\n        def fn(mask, total): \\n            \"\"\"Return True if there is a winning strategy given mask & total.\"\"\"\\n            if total <= 0: return False # already lost \\n            for i in range(maxChoosableInteger): \\n                if mask & (1 << i): # integer i+1 is not used yet \\n                    if not fn(mask ^ (1 << i), total - (i + 1)): return True \\n            return False \\n        \\n        return fn(int(\"1\"*maxChoosableInteger, 2), desiredTotal)\\n```\\n\\nThe challenge in this problem is that a number cannot be re-used. Without such contraint, below 1-liner would be a viable answer. \\n```\\nclass Solution:\\n    def canIWin(self, maxChoosableInteger: int, desiredTotal: int) -> bool:\\n        return desiredTotal == 0 or desiredTotal % (maxChoosableInteger + 1)\\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def canIWin(self, maxChoosableInteger: int, desiredTotal: int) -> bool:\\n        if desiredTotal == 0: return True # edge case 1\\n        if maxChoosableInteger * (maxChoosableInteger+1)//2 < desiredTotal: return False # edge case 2\\n        \\n        @lru_cache(None)\\n        def fn(mask, total): \\n            \"\"\"Return True if there is a winning strategy given mask & total.\"\"\"\\n            if total <= 0: return False # already lost \\n            for i in range(maxChoosableInteger): \\n                if mask & (1 << i): # integer i+1 is not used yet \\n                    if not fn(mask ^ (1 << i), total - (i + 1)): return True \\n            return False \\n        \\n        return fn(int(\"1\"*maxChoosableInteger, 2), desiredTotal)\\n```\n```\\nclass Solution:\\n    def canIWin(self, maxChoosableInteger: int, desiredTotal: int) -> bool:\\n        return desiredTotal == 0 or desiredTotal % (maxChoosableInteger + 1)\\n```",
                "codeTag": "Java"
            },
            {
                "id": 751842,
                "title": "simple-clean-c-solution-dfs-bit-operations",
                "content": "\\tclass Solution {\\n\\t\\tbool memo[(1<<21) + 1] = {false};\\n\\t\\tint n;\\n\\n\\t\\tbool dfs(int val, int k = 0){\\n\\t\\t\\tif(val <= 0)\\n\\t\\t\\t\\treturn false;\\n\\n\\t\\t\\tif(memo[k] == true)\\n\\t\\t\\t\\treturn true;\\n\\n\\t\\t\\tfor(int i = 1; i <= n; ++i){\\n\\t\\t\\t\\tint mask = 1<<i;\\n\\n\\t\\t\\t\\tif(k&mask)          // k&mask != 0 -> visited\\n\\t\\t\\t\\t\\tcontinue;\\n\\n\\t\\t\\t\\tif(dfs(val - i, k | mask) == false)    // if next player loses -> cur player wins\\n\\t\\t\\t\\t\\treturn memo[k] = true;\\n\\t\\t\\t}\\n\\n\\t\\t\\treturn memo[k] = false;\\n\\t\\t}\\n\\n\\tpublic:\\n\\t\\tbool canIWin(int n, int t) {\\n\\t\\t   int s = n*(n+1)/2;\\n\\n\\t\\t\\tif(n >= t)              // first player choose n to win\\n\\t\\t\\t\\treturn true;        \\n\\n\\t\\t\\tif(s < t)               // second player chooses largest values to win\\n\\t\\t\\t\\treturn false;\\n\\n\\t\\t\\tif(s == t)              // whoever picks last number wins\\n\\t\\t\\t\\treturn n%2;\\n\\n\\t\\t\\tthis->n = n;\\n\\n\\t\\t\\treturn dfs(t);\\n\\t\\t}\\n\\t};",
                "solutionTags": [],
                "code": "class Solution {\\n\\t\\tbool memo[(1<<21) + 1] = {false}",
                "codeTag": "Java"
            },
            {
                "id": 700581,
                "title": "python-simple-solution-using-recursion-and-memoization",
                "content": "```\\nclass Solution:\\n    def canIWin(self, maxChoosableInteger: int, desiredTotal: int) -> bool:\\n        ## RC ##\\n        ## APPROACH : RECURSION + MEMOIZATION ##\\n        ## Similar to Leetcode ; 294. Flip Game II ##\\n        \\n\\t\\t## TIME COMPLEXITY : O(N * 2^N) ##\\n\\t\\t## SPACE COMPLEXITY : O(2^N) ##\\n    \\n        def dfs_rec_memo(total, num_used):\\n            \\n            if( tuple(num_used) in cache ):\\n                return cache[ tuple(num_used) ]\\n            \\n            for num in range(1, maxChoosableInteger + 1):\\n                if( not num_used[num] ) :\\n                    if(total + num >= desiredTotal ):\\n                        cache[ tuple(num_used) ] = True\\n                        return True\\n                    \\n                    num_used[num] = True\\n                    if ( not dfs_rec_memo( total + num, num_used ) ):\\n                        # make sure to back track, here also before returning\\n                        num_used[num] = False   \\n                        cache[ tuple(num_used) ] = True\\n                        return True\\n                    # backtrack\\n                    num_used[num] = False\\n            \\n            cache[ tuple(num_used) ] = False\\n            return False\\n        \\n        if(1+maxChoosableInteger)*maxChoosableInteger//2 < desiredTotal:\\n            return False\\n        \\n        cache = {}\\n        num_used = [False] * (maxChoosableInteger + 1)\\n        return dfs_rec_memo(0, num_used)\\n```",
                "solutionTags": [
                    "Python",
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def canIWin(self, maxChoosableInteger: int, desiredTotal: int) -> bool:\\n        ## RC ##\\n        ## APPROACH : RECURSION + MEMOIZATION ##\\n        ## Similar to Leetcode ; 294. Flip Game II ##\\n        \\n\\t\\t## TIME COMPLEXITY : O(N * 2^N) ##\\n\\t\\t## SPACE COMPLEXITY : O(2^N) ##\\n    \\n        def dfs_rec_memo(total, num_used):\\n            \\n            if( tuple(num_used) in cache ):\\n                return cache[ tuple(num_used) ]\\n            \\n            for num in range(1, maxChoosableInteger + 1):\\n                if( not num_used[num] ) :\\n                    if(total + num >= desiredTotal ):\\n                        cache[ tuple(num_used) ] = True\\n                        return True\\n                    \\n                    num_used[num] = True\\n                    if ( not dfs_rec_memo( total + num, num_used ) ):\\n                        # make sure to back track, here also before returning\\n                        num_used[num] = False   \\n                        cache[ tuple(num_used) ] = True\\n                        return True\\n                    # backtrack\\n                    num_used[num] = False\\n            \\n            cache[ tuple(num_used) ] = False\\n            return False\\n        \\n        if(1+maxChoosableInteger)*maxChoosableInteger//2 < desiredTotal:\\n            return False\\n        \\n        cache = {}\\n        num_used = [False] * (maxChoosableInteger + 1)\\n        return dfs_rec_memo(0, num_used)\\n```",
                "codeTag": "Java"
            },
            {
                "id": 508516,
                "title": "python-dp-with-explanation",
                "content": "DP\\nUse a usage table to present used/unused numbers for currently player. 0 for unused; 1 for used.\\nusage = [0,0,0,0,0] means numbers 1 to 4 are unused. usage[0] is a dummy position.\\nDP[usage] = True, means given the usage table as init condition, the current player can win.\\nIf the first player picks 2, then the second player would see a usage table of [0,0,1,0,0]\\nStarts from [0,0,1,0,0], if the second player can win then the first player must lose.\\nSo DP[usage] = True, if cur_val + n >= desiredTotal or DP[nxt_usage] == False. n must be choosen from unused number.\\nIf we cannot find that n, DP[usage] is False.\\nIn summary, the question is the same as:\\nPick a number from currently unused numbers, let the new total >= desiredTotal OR let the next play must lose given the new usage table.\\nTo claim win, find any number that makes the second player lose.\\nTo claim lose, we need iterate all possible choices after that we still cannot find any number that makes the second player lose.\\nWe can use memorization to avoid repeat calculation.\\nNote: there are cases nobody can win. If sum(1...maxChoosableInteger) < desiredTotal, then nobody wins\\nTime: O(maxChoosableInteger*maxChoosableInteger)\\nSpace: O(maxChoosableInteger)\\n```\\nclass Solution:\\n    def canIWin(self, maxChoosableInteger: int, desiredTotal: int) -> bool:\\n        if (1+maxChoosableInteger)*maxChoosableInteger//2 < desiredTotal:\\n            return False\\n        usage = [0]*(1+maxChoosableInteger) # 0 for unused, usage[0] is dummy\\n        mem = {}\\n        return self.helper(0, usage, maxChoosableInteger, desiredTotal, mem)\\n    \\n    def helper(self, cur_val, usage, maxChoosableInteger, desiredTotal, mem):\\n        usage_tuple = tuple(usage)\\n        if usage_tuple in mem:\\n            return mem[usage_tuple]\\n        \\n        for n in range(1, maxChoosableInteger+1): # Iterate 1 ... maxChoosableInteger\\n            if usage[n]: # usage[n] == 1 means, n is used.\\n                continue\\n            if cur_val + n >= desiredTotal:\\n                mem[usage_tuple] = True\\n                return True\\n            usage[n] = 1\\n            # If we can pick a number that makes opponent lose, current player is a win\\n            if not self.helper(cur_val+n, usage, maxChoosableInteger, desiredTotal, mem):\\n                usage[n] = 0 # Remember to backtrack\\n                mem[usage_tuple] = True\\n                return True\\n            usage[n] = 0\\n        # If we cannot find a number thats make opponent lose, current play must lose\\n        mem[usage_tuple] = False\\n        return False\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution:\\n    def canIWin(self, maxChoosableInteger: int, desiredTotal: int) -> bool:\\n        if (1+maxChoosableInteger)*maxChoosableInteger//2 < desiredTotal:\\n            return False\\n        usage = [0]*(1+maxChoosableInteger) # 0 for unused, usage[0] is dummy\\n        mem = {}\\n        return self.helper(0, usage, maxChoosableInteger, desiredTotal, mem)\\n    \\n    def helper(self, cur_val, usage, maxChoosableInteger, desiredTotal, mem):\\n        usage_tuple = tuple(usage)\\n        if usage_tuple in mem:\\n            return mem[usage_tuple]\\n        \\n        for n in range(1, maxChoosableInteger+1): # Iterate 1 ... maxChoosableInteger\\n            if usage[n]: # usage[n] == 1 means, n is used.\\n                continue\\n            if cur_val + n >= desiredTotal:\\n                mem[usage_tuple] = True\\n                return True\\n            usage[n] = 1\\n            # If we can pick a number that makes opponent lose, current player is a win\\n            if not self.helper(cur_val+n, usage, maxChoosableInteger, desiredTotal, mem):\\n                usage[n] = 0 # Remember to backtrack\\n                mem[usage_tuple] = True\\n                return True\\n            usage[n] = 0\\n        # If we cannot find a number thats make opponent lose, current play must lose\\n        mem[usage_tuple] = False\\n        return False\\n```",
                "codeTag": "Java"
            },
            {
                "id": 448140,
                "title": "let-me-try-explain-why",
                "content": "code from [https://leetcode.com/problems/can-i-win/discuss/95277/Java-solution-using-HashMap-with-detailed-explanation](http://)\\nI know lots people eager to know why this code can AC. It also bothered me quite a lot since there no one had made a proper explanation. So I dare to show my own understanding here to communite with you guys who also suffer this painful torture. BTW, I made all my proof on iPad with pencil, so its all pictures, I pasted on google doc. So sorry for that.\\n```\\npublic class CanIWin {\\n    boolean[] used;\\n    Map<Integer, Boolean> map;\\n\\n    public boolean canIWin(int maxChoosableInteger, int desiredTotal) {\\n        if (desiredTotal <= 0) return true;\\n        if ((maxChoosableInteger * (maxChoosableInteger + 1) / 2) < desiredTotal) return false;\\n        used = new boolean[maxChoosableInteger + 1];\\n        map = new HashMap<>();\\n        return dfs(desiredTotal);\\n    }\\n\\n    private boolean dfs(int desT) {\\n        if (desT <= 0) return false;\\n        int key = key();\\n        if (map.containsKey(key)) return map.get(key);\\n        for (int i = 1; i < used.length; i++) {\\n            if (!used[i]) {\\n                used[i] = true;\\n                if (!dfs(desT - i)) {\\n                    map.put(key, true);\\n                    used[i] = false;\\n                    return true;\\n                }\\n                used[i] = false;\\n            }\\n        }\\n        map.put(key, false);\\n        return false;\\n    }\\n\\n    private int key() {\\n        int key = 0;\\n        for (boolean u : used) {\\n            key <<= 1;\\n            key |= u ? 1 : 0;\\n        }\\n        return key;\\n    }\\n}\\n```\\nSorry about that I can\\'t paste my draw here directly, please visit (copy and paste it on chrome)\\n[https://docs.google.com/document/d/1ouphyc5WDkL_gXk4zzoCOt7G5fRgPvVimgmraRQRJw0/edit?usp=sharing](http://)\\n",
                "solutionTags": [],
                "code": "```\\npublic class CanIWin {\\n    boolean[] used;\\n    Map<Integer, Boolean> map;\\n\\n    public boolean canIWin(int maxChoosableInteger, int desiredTotal) {\\n        if (desiredTotal <= 0) return true;\\n        if ((maxChoosableInteger * (maxChoosableInteger + 1) / 2) < desiredTotal) return false;\\n        used = new boolean[maxChoosableInteger + 1];\\n        map = new HashMap<>();\\n        return dfs(desiredTotal);\\n    }\\n\\n    private boolean dfs(int desT) {\\n        if (desT <= 0) return false;\\n        int key = key();\\n        if (map.containsKey(key)) return map.get(key);\\n        for (int i = 1; i < used.length; i++) {\\n            if (!used[i]) {\\n                used[i] = true;\\n                if (!dfs(desT - i)) {\\n                    map.put(key, true);\\n                    used[i] = false;\\n                    return true;\\n                }\\n                used[i] = false;\\n            }\\n        }\\n        map.put(key, false);\\n        return false;\\n    }\\n\\n    private int key() {\\n        int key = 0;\\n        for (boolean u : used) {\\n            key <<= 1;\\n            key |= u ? 1 : 0;\\n        }\\n        return key;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 305544,
                "title": "python-solution-with-bitmask-to-memoize",
                "content": "It has been shown from previous posts that, the STATE of subproblems are only concerned with the available numbers left. This is because the TARGET can be obtained by ```desiredTotal - sum(usedNumbers) ``` \\n\\nOn the basis of recursion + memoization, we can use bitmask to do memoization.\\nFor example, in bitmask ```10100```, the bits which are set are: 2nd bit  and 4th bit(index starting from 0, counting index from right to left). The nth \\'set\\' bits means the number ```n+1``` is still available to use.\\n\\n```\\nclass Solution(object):\\n    def canIWin(self, maxChoosableInteger, desiredTotal):\\n        \"\"\"\\n        :type maxChoosableInteger: int\\n        :type desiredTotal: int\\n        :rtype: bool\\n        \"\"\"\\n        if desiredTotal == 0:\\n            return True\\n        self.max = maxChoosableInteger\\n        self.d = {}\\n        \\n        if desiredTotal > maxChoosableInteger * (maxChoosableInteger+1) // 2:\\n            return False\\n        \\n        return self.recursion(2**maxChoosableInteger-1, desiredTotal)\\n        \\n    \\n    def recursion(self, mask, total):  #bit \\'set\\' means still not chosen \\n        \\n        if mask >= 2**(total-1):\\n            return True\\n        if mask in self.d:\\n            return self.d[mask]\\n        \\n        for i in range(self.max):\\n            if mask & (1<<i):  #if the ith bit is set\\n                newmask = mask & ~(1<<i)  #unset the ith bit\\n                if self.recursion(newmask, total-i-1) == False:\\n                    self.d[mask] = True\\n                    return True\\n        self.d[mask] = False\\n        return False\\n```\\n\\n",
                "solutionTags": [
                    "Python",
                    "Bitmask"
                ],
                "code": "```desiredTotal - sum(usedNumbers) ```\n```10100```\n```n+1```\n```\\nclass Solution(object):\\n    def canIWin(self, maxChoosableInteger, desiredTotal):\\n        \"\"\"\\n        :type maxChoosableInteger: int\\n        :type desiredTotal: int\\n        :rtype: bool\\n        \"\"\"\\n        if desiredTotal == 0:\\n            return True\\n        self.max = maxChoosableInteger\\n        self.d = {}\\n        \\n        if desiredTotal > maxChoosableInteger * (maxChoosableInteger+1) // 2:\\n            return False\\n        \\n        return self.recursion(2**maxChoosableInteger-1, desiredTotal)\\n        \\n    \\n    def recursion(self, mask, total):  #bit \\'set\\' means still not chosen \\n        \\n        if mask >= 2**(total-1):\\n            return True\\n        if mask in self.d:\\n            return self.d[mask]\\n        \\n        for i in range(self.max):\\n            if mask & (1<<i):  #if the ith bit is set\\n                newmask = mask & ~(1<<i)  #unset the ith bit\\n                if self.recursion(newmask, total-i-1) == False:\\n                    self.d[mask] = True\\n                    return True\\n        self.d[mask] = False\\n        return False\\n```",
                "codeTag": "Java"
            },
            {
                "id": 193199,
                "title": "can-be-done-in-4-lines",
                "content": "This game can be solved using recursion in just 3-4 lines\\n```python\\ndef canIWin(self, MaxInt, Target):\\n    if Target == 0: return True\\n    def isNim(opts, left):\\n        if left <= 0: return False\\n        return any(not isNim(opts - {n}, left - n) for n in opts)\\n    return isNim(set(range(1, MaxInt + 1)), Target)\\n```\\nThis method however, got TLE... so we need to use memorization and check some edge cases to pass the test:\\n```python\\ndef canIWin(self, MaxInt, Target):\\n    # 1, Check Edge Cases\\n    if Target == 0: return True\\n    MaxPossible = (1 + MaxInt) * MaxInt / 2\\n    if MaxPossible  < Target: return False\\n    if MaxPossible == Target: return bool(MaxInt % 2)\\n    \\n    # 2, Recursive Method\\n    memo = {}\\n    def isNim(opts, left):\\n        if left <= 0: return False\\n        key = (tuple(sorted(opts)), left)\\n        if key not in memo:\\n            memo[key] = any(not isNim(opts - {n}, left - n) for n in opts)\\n        return memo[key]\\n    return isNim(set(range(1, MaxInt + 1)), Target)\\n```",
                "solutionTags": [],
                "code": "```python\\ndef canIWin(self, MaxInt, Target):\\n    if Target == 0: return True\\n    def isNim(opts, left):\\n        if left <= 0: return False\\n        return any(not isNim(opts - {n}, left - n) for n in opts)\\n    return isNim(set(range(1, MaxInt + 1)), Target)\\n```\n```python\\ndef canIWin(self, MaxInt, Target):\\n    # 1, Check Edge Cases\\n    if Target == 0: return True\\n    MaxPossible = (1 + MaxInt) * MaxInt / 2\\n    if MaxPossible  < Target: return False\\n    if MaxPossible == Target: return bool(MaxInt % 2)\\n    \\n    # 2, Recursive Method\\n    memo = {}\\n    def isNim(opts, left):\\n        if left <= 0: return False\\n        key = (tuple(sorted(opts)), left)\\n        if key not in memo:\\n            memo[key] = any(not isNim(opts - {n}, left - n) for n in opts)\\n        return memo[key]\\n    return isNim(set(range(1, MaxInt + 1)), Target)\\n```",
                "codeTag": "Python3"
            },
            {
                "id": 95334,
                "title": "javascript-solution-that-fits-in-memory-using-bitwise-operators",
                "content": "Javascript struggles with some of the larger problems here, especially with the size of its Object mapping. I deal with this by storing the state of values that have been used/not-used in a bit array in the `used` variable, which I access using `isUsed(i)`, `setUsed(i)`, and `clearUsed(i)`. This results in the smallest possible key lengths for the object map.\\n\\nThis is an extension of one of the top-voted solutions by leogogogo:\\n\\nhttps://discuss.leetcode.com/topic/68896/java-solution-using-hashmap-with-detailed-explanation\\n\\n\\n```\\nvar canIWin = function(maxChoosableInteger, desiredTotal) {\\n    if (desiredTotal <= 0 || maxChoosableInteger >= desiredTotal) return true;\\n    if ((maxChoosableInteger * (maxChoosableInteger + 1)) / 2 < desiredTotal) return false; // unwinnable \\n\\n    var gameStates = {},    // hash of used-key => true/false\\n    used = 0;                      // each bit represents a used value (max 128 bits)\\n    \\n    // Our helper function\\n    var helper = function (runningTotal) {\\n        if (runningTotal <= 0) return false;\\n        var key = used;\\n        if (!gameStates.hasOwnProperty(key)) {\\n            for (var i = 1; i <= maxChoosableInteger; ++i) {\\n                if (!isUsed(i)) {\\n                    setUsed(i);\\n                    if (!helper(runningTotal - i)) {\\n                        gameStates[key] = true;\\n                        clearUsed(i);    // reset the state of used values\\n                        return true;        // return true as soon as we find\\n                                            // a winning combo\\n                    }\\n                    clearUsed(i);    // reset the state of used values\\n                }\\n            }\\n            gameStates[key] = false; // If we make this through the loop without\\n                                     // returning true, then it's a false\\n        }\\n        return gameStates[key];\\n    };\\n    \\n    var isUsed = function (i) {\\n        return ((used & (1 << (i - 1))) !== 0);\\n    };\\n    \\n    var setUsed = function (i) {\\n        return used |= (1 << (i - 1));\\n    };\\n    \\n    var clearUsed = function (i) {\\n        return used &= ~(1 << (i - 1));\\n    };\\n    \\n    return helper(desiredTotal);\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nvar canIWin = function(maxChoosableInteger, desiredTotal) {\\n    if (desiredTotal <= 0 || maxChoosableInteger >= desiredTotal) return true;\\n    if ((maxChoosableInteger * (maxChoosableInteger + 1)) / 2 < desiredTotal) return false; // unwinnable \\n\\n    var gameStates = {},    // hash of used-key => true/false\\n    used = 0;                      // each bit represents a used value (max 128 bits)\\n    \\n    // Our helper function\\n    var helper = function (runningTotal) {\\n        if (runningTotal <= 0) return false;\\n        var key = used;\\n        if (!gameStates.hasOwnProperty(key)) {\\n            for (var i = 1; i <= maxChoosableInteger; ++i) {\\n                if (!isUsed(i)) {\\n                    setUsed(i);\\n                    if (!helper(runningTotal - i)) {\\n                        gameStates[key] = true;\\n                        clearUsed(i);    // reset the state of used values\\n                        return true;        // return true as soon as we find\\n                                            // a winning combo\\n                    }\\n                    clearUsed(i);    // reset the state of used values\\n                }\\n            }\\n            gameStates[key] = false; // If we make this through the loop without\\n                                     // returning true, then it's a false\\n        }\\n        return gameStates[key];\\n    };\\n    \\n    var isUsed = function (i) {\\n        return ((used & (1 << (i - 1))) !== 0);\\n    };\\n    \\n    var setUsed = function (i) {\\n        return used |= (1 << (i - 1));\\n    };\\n    \\n    var clearUsed = function (i) {\\n        return used &= ~(1 << (i - 1));\\n    };\\n    \\n    return helper(desiredTotal);\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 4050398,
                "title": "bit-mask-concepts-with-solution",
                "content": "used bitmask here to get answer faster\\n\\n# Code\\n```\\n/*\\n     * some basic bitmask concept\\n     * \\n     * \\n     * Set the ith bit: b(1<<i). Let i=0, so,\\n     * (1<<i) = 00001\\n     * 01010 | 00001 = 01011\\n     * \\n     * Unset the ith bit: b & !(1<<i). Let i=1, so,\\n     * (1<<i) = 00010\\n     * !(1<<i) = 11101\\n     * 01010 & 11101 = 01000\\n     * \\n     * Let i = 3\\n     * (1<<i) = 01000\\n     * 01010 & 01000 = 01000\\n     * \\n     * Clearly the result is non-zero, so that means 3rd element is present in the\\n     * subset.\\n     * \\n     * \\n     */\\n\\n\\nclass Solution {\\n    public boolean canIWin(int maxChoosableInteger, int desiredTotal) {\\n        return util1(maxChoosableInteger,desiredTotal);\\n    }\\n\\n    public boolean util1(int maxChoosableInteger, int desiredTotal) {\\n        if (maxChoosableInteger * (maxChoosableInteger + 1) / 2 < desiredTotal) {\\n            return false;\\n        }\\n        Boolean dp[] = new Boolean[1 << (maxChoosableInteger + 1)];\\n        return helper(maxChoosableInteger, desiredTotal, dp, 0, 0);\\n    }\\n\\n    public boolean helper(int maxChoosableInteger, int desiredTotal, Boolean dp[], int mask, int sum) {\\n        if (dp[mask] != null) {\\n            return dp[mask];\\n        }\\n        dp[mask] = false;\\n        for (int i = 1; i <= maxChoosableInteger; i++) {\\n            if ((mask & (1 << i)) == 0) {\\n                if (sum + i >= desiredTotal) {\\n                    dp[mask] = true;\\n                } else {\\n                    boolean hisAns = helper(maxChoosableInteger, desiredTotal, dp, (mask | (1 << i)), sum + i);\\n                    if (hisAns == false) {\\n                        dp[mask] = true;\\n                    }\\n                }\\n            }\\n            if (dp[mask]) {\\n                break;\\n            }\\n        }\\n        return dp[mask];\\n    }\\n}\\n```\\nyou can check out my github repository where i am uploading famous interview questions topic wise with solutions.\\nlink-- https://github.com/Abhaydutt2003/DataStructureAndAlgoPractice \\nkindly upvote if you like my solution. you can ask doubts below.\\xAF\\n",
                "solutionTags": [
                    "Java",
                    "Dynamic Programming",
                    "Bitmask"
                ],
                "code": "```\\n/*\\n     * some basic bitmask concept\\n     * \\n     * \\n     * Set the ith bit: b(1<<i). Let i=0, so,\\n     * (1<<i) = 00001\\n     * 01010 | 00001 = 01011\\n     * \\n     * Unset the ith bit: b & !(1<<i). Let i=1, so,\\n     * (1<<i) = 00010\\n     * !(1<<i) = 11101\\n     * 01010 & 11101 = 01000\\n     * \\n     * Let i = 3\\n     * (1<<i) = 01000\\n     * 01010 & 01000 = 01000\\n     * \\n     * Clearly the result is non-zero, so that means 3rd element is present in the\\n     * subset.\\n     * \\n     * \\n     */\\n\\n\\nclass Solution {\\n    public boolean canIWin(int maxChoosableInteger, int desiredTotal) {\\n        return util1(maxChoosableInteger,desiredTotal);\\n    }\\n\\n    public boolean util1(int maxChoosableInteger, int desiredTotal) {\\n        if (maxChoosableInteger * (maxChoosableInteger + 1) / 2 < desiredTotal) {\\n            return false;\\n        }\\n        Boolean dp[] = new Boolean[1 << (maxChoosableInteger + 1)];\\n        return helper(maxChoosableInteger, desiredTotal, dp, 0, 0);\\n    }\\n\\n    public boolean helper(int maxChoosableInteger, int desiredTotal, Boolean dp[], int mask, int sum) {\\n        if (dp[mask] != null) {\\n            return dp[mask];\\n        }\\n        dp[mask] = false;\\n        for (int i = 1; i <= maxChoosableInteger; i++) {\\n            if ((mask & (1 << i)) == 0) {\\n                if (sum + i >= desiredTotal) {\\n                    dp[mask] = true;\\n                } else {\\n                    boolean hisAns = helper(maxChoosableInteger, desiredTotal, dp, (mask | (1 << i)), sum + i);\\n                    if (hisAns == false) {\\n                        dp[mask] = true;\\n                    }\\n                }\\n            }\\n            if (dp[mask]) {\\n                break;\\n            }\\n        }\\n        return dp[mask];\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3780152,
                "title": "thoroughly-commented-with-clear-variable-names-top-down-bitmask-approach-java",
                "content": "\\n# Code\\n```\\nclass Solution {\\n    public boolean canIWin(int maxChoosableInteger, int desiredTotal) {\\n        // First of all, we check if it\\'s even possible for our players to reach the disiredTotal\\n        int totalPossibleSum = maxChoosableInteger * (maxChoosableInteger + 1) / 2;\\n        if (totalPossibleSum < desiredTotal) return false;\\n\\n        // Declare a map for memoization, where the key is the bitmask of our current state (0 - number is available for use, 1 - number was taken)\\n        Map<Integer, Boolean> memo = new HashMap<>();\\n        return dp(desiredTotal, 0, maxChoosableInteger, memo);\\n    }\\n\\n    private boolean dp(int goal, int state, int maxChoosable, Map<Integer, Boolean> memo) {\\n        // If we have already calculated a result for this state, then return it\\n        if (memo.containsKey(state)) {\\n            return memo.get(state);\\n        }\\n        \\n        // Declare the result variable\\n        boolean result = false;\\n        \\n        // Iterate over all possible integers from 1 to maxChoosable\\n        for (int i = 1; i <= maxChoosable; i++) {\\n            \\n            // Then we have to check our state (bitmask) to see if our current integer (i) was used or not\\n            boolean isAvailable = (state >> i) % 2 == 0;\\n            \\n            // If it was used, then we keep looking for an unused integer            \\n            if (!isAvailable) {\\n                continue;\\n            }\\n            \\n            // We check our win conditions. If we reach the goal, our result is true, and we can jump to our last lines.\\n            if (goal - i <= 0) {\\n                result = true;\\n                break;\\n            }\\n\\n            // We need to create a new state (bitmask) to mark our current integer as used\\n            int currMask = 1 << i;\\n            int newState = state | currMask;\\n\\n            // And we pass the turn to our rival\\n            boolean rivalResult = dp(goal - i, newState, maxChoosable, memo);\\n            \\n            // In case our rival doesn\\'t win, it means that it\\'s possible for us to beat the rival\\n            if (!rivalResult) {\\n                result = true;\\n                break;\\n            }\\n        }\\n\\n        // We save our result for the current state and return it\\n        memo.put(state, result);\\n        return result;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Dynamic Programming",
                    "Bitmask"
                ],
                "code": "```\\nclass Solution {\\n    public boolean canIWin(int maxChoosableInteger, int desiredTotal) {\\n        // First of all, we check if it\\'s even possible for our players to reach the disiredTotal\\n        int totalPossibleSum = maxChoosableInteger * (maxChoosableInteger + 1) / 2;\\n        if (totalPossibleSum < desiredTotal) return false;\\n\\n        // Declare a map for memoization, where the key is the bitmask of our current state (0 - number is available for use, 1 - number was taken)\\n        Map<Integer, Boolean> memo = new HashMap<>();\\n        return dp(desiredTotal, 0, maxChoosableInteger, memo);\\n    }\\n\\n    private boolean dp(int goal, int state, int maxChoosable, Map<Integer, Boolean> memo) {\\n        // If we have already calculated a result for this state, then return it\\n        if (memo.containsKey(state)) {\\n            return memo.get(state);\\n        }\\n        \\n        // Declare the result variable\\n        boolean result = false;\\n        \\n        // Iterate over all possible integers from 1 to maxChoosable\\n        for (int i = 1; i <= maxChoosable; i++) {\\n            \\n            // Then we have to check our state (bitmask) to see if our current integer (i) was used or not\\n            boolean isAvailable = (state >> i) % 2 == 0;\\n            \\n            // If it was used, then we keep looking for an unused integer            \\n            if (!isAvailable) {\\n                continue;\\n            }\\n            \\n            // We check our win conditions. If we reach the goal, our result is true, and we can jump to our last lines.\\n            if (goal - i <= 0) {\\n                result = true;\\n                break;\\n            }\\n\\n            // We need to create a new state (bitmask) to mark our current integer as used\\n            int currMask = 1 << i;\\n            int newState = state | currMask;\\n\\n            // And we pass the turn to our rival\\n            boolean rivalResult = dp(goal - i, newState, maxChoosable, memo);\\n            \\n            // In case our rival doesn\\'t win, it means that it\\'s possible for us to beat the rival\\n            if (!rivalResult) {\\n                result = true;\\n                break;\\n            }\\n        }\\n\\n        // We save our result for the current state and return it\\n        memo.put(state, result);\\n        return result;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2379330,
                "title": "java-bitmask-recursion-95-faster",
                "content": "<-----//VoteUp If you like the solution\\n```\\nclass Solution {\\n    int numlimit, tgt;\\n    public boolean canIWin(int maxChoosableInteger, int desiredTotal) {\\n        numlimit = maxChoosableInteger;\\n        tgt = desiredTotal;\\n        \\n        int maxsum = (numlimit*(numlimit+1))/2;\\n        if(maxsum < tgt)\\n            return false;\\n        \\n        int dp[] = new int[(1<<numlimit)];\\n        if(solve(0, 0, 0, dp)){\\n            return true;\\n        }\\n        return false;\\n    }\\n    \\n    public boolean solve(int mask, int lstsum, int player, int dp[]) {\\n        \\n        if(dp[mask] != 0)\\n            return (dp[mask] == 1);\\n        \\n        for(int i = 0; i < numlimit; i++) {\\n            if((mask&(1<<i)) == 0) {\\n                if((lstsum+(i+1) >= tgt) || !solve((mask|(1<<i)), lstsum+(i+1), player+1, dp)) {\\n                    dp[mask] = 1;\\n                    return true;\\n                } \\n            }\\n        }\\n        \\n        dp[mask] = -1;\\n        return false;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Bitmask"
                ],
                "code": "```\\nclass Solution {\\n    int numlimit, tgt;\\n    public boolean canIWin(int maxChoosableInteger, int desiredTotal) {\\n        numlimit = maxChoosableInteger;\\n        tgt = desiredTotal;\\n        \\n        int maxsum = (numlimit*(numlimit+1))/2;\\n        if(maxsum < tgt)\\n            return false;\\n        \\n        int dp[] = new int[(1<<numlimit)];\\n        if(solve(0, 0, 0, dp)){\\n            return true;\\n        }\\n        return false;\\n    }\\n    \\n    public boolean solve(int mask, int lstsum, int player, int dp[]) {\\n        \\n        if(dp[mask] != 0)\\n            return (dp[mask] == 1);\\n        \\n        for(int i = 0; i < numlimit; i++) {\\n            if((mask&(1<<i)) == 0) {\\n                if((lstsum+(i+1) >= tgt) || !solve((mask|(1<<i)), lstsum+(i+1), player+1, dp)) {\\n                    dp[mask] = 1;\\n                    return true;\\n                } \\n            }\\n        }\\n        \\n        dp[mask] = -1;\\n        return false;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2077660,
                "title": "short-python-code-readable",
                "content": "```\\nclass Solution:\\n    def canIWin(self, maxChoosableInteger: int, desiredTotal: int) -> bool:\\n        remainder = [i+1 for i in range(maxChoosableInteger)] # numbers\\n        @cache\\n        def can_win(total, remainder):\\n            if total >= desiredTotal:\\n                return False # total is already exceed the desiredTotal. Opponent won. \\n            \\n            for num in remainder:\\n                if can_win(total + num, tuple([n for n in remainder if n != num])) == False: # if opponent lose, I win(return True)\\n                    return True\\n            return False \\n        \\n        if desiredTotal == 0: \\n            return True \\n        if sum(remainder) < desiredTotal: # Both of two cannot win.\\n            return False \\n        return can_win(0, tuple(remainder))\\n```\\n\\nAssuming that A, B is playing game.\\nIn A\\'s turn, if total already exceed the `desiredTotal`, that means A lost. \\nIn B\\'s turn, if total already exceed the `desiredTotal`, that means B lost. \\n",
                "solutionTags": [
                    "Python"
                ],
                "code": "```\\nclass Solution:\\n    def canIWin(self, maxChoosableInteger: int, desiredTotal: int) -> bool:\\n        remainder = [i+1 for i in range(maxChoosableInteger)] # numbers\\n        @cache\\n        def can_win(total, remainder):\\n            if total >= desiredTotal:\\n                return False # total is already exceed the desiredTotal. Opponent won. \\n            \\n            for num in remainder:\\n                if can_win(total + num, tuple([n for n in remainder if n != num])) == False: # if opponent lose, I win(return True)\\n                    return True\\n            return False \\n        \\n        if desiredTotal == 0: \\n            return True \\n        if sum(remainder) < desiredTotal: # Both of two cannot win.\\n            return False \\n        return can_win(0, tuple(remainder))\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2065901,
                "title": "python-dp-with-bitwise-for-tracking-used-best-solution",
                "content": "Lots of dummies using lists/sets to keep track of \\'used\\' when they should be using bitwise. \\n\\n```\\nclass Solution:\\n    def canIWin(self, maxChoosableInteger: int, desiredTotal: int) -> bool:\\n        if desiredTotal == 0:\\n            return True\\n        if (maxChoosableInteger * (maxChoosableInteger + 1)) // 2 < desiredTotal:\\n            return False\\n        \\n        @cache\\n        def play(curr, used, isP1):\\n            if curr >= desiredTotal:\\n                return not isP1\\n            \\n            win = not isP1\\n            \\n            for i in range(1, maxChoosableInteger + 1):\\n                mask = 1 << i\\n                if not used & mask:\\n                    if isP1:\\n                        win = win or play(curr + i, used ^ mask, not isP1)\\n                    else:\\n                        win = win and play(curr + i, used ^ mask, not isP1)\\n\\n            return win\\n        \\n        return play(0, 0, True)\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution:\\n    def canIWin(self, maxChoosableInteger: int, desiredTotal: int) -> bool:\\n        if desiredTotal == 0:\\n            return True\\n        if (maxChoosableInteger * (maxChoosableInteger + 1)) // 2 < desiredTotal:\\n            return False\\n        \\n        @cache\\n        def play(curr, used, isP1):\\n            if curr >= desiredTotal:\\n                return not isP1\\n            \\n            win = not isP1\\n            \\n            for i in range(1, maxChoosableInteger + 1):\\n                mask = 1 << i\\n                if not used & mask:\\n                    if isP1:\\n                        win = win or play(curr + i, used ^ mask, not isP1)\\n                    else:\\n                        win = win and play(curr + i, used ^ mask, not isP1)\\n\\n            return win\\n        \\n        return play(0, 0, True)\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1761576,
                "title": "c-brute-force-to-memoisation-bitmasking",
                "content": "We start this question by simple Brute Force ie we do simple brute force for every i from 1 to biggestdigitpausible\\nif it is unused we use it and do dfs .\\nIn this process if for eg a dfs call returned true then that means the player who made the current dfs call cant win using that number since it is going in an alternate manner ie player1(A)-player2(B)-player1(C)-player2(D)\\nIf player 2(D) makes a true then that means player 1(C) cant win so it will return a false to player 2(B) which will return true to player 1 (A)and which will return false as the final ans\\nWe do this for iterating over numbers for every dfs call and do && of all the dfs calls if one of the calls returned a false than that means the current player who made he dfs call can win since the next player returned a false \\nSo if and of all the dfs calls is false I can win and will return true else return false.\\n```\\nclass Solution {\\npublic:\\n    unordered_map<int,bool>map;\\n    bool dfs(int msi,int total,vector<bool>&nums,int sum,int mask)\\n    {\\n        \\n        bool ans=true;\\n        for(int i=1;i<=msi;i++)\\n        {\\n            if(nums[i]==false)\\n            {\\n                if(sum +i>=total)return true;\\n                nums[i]=true;\\n                ans=ans and dfs(msi,total,nums,sum+i,mask);\\n                nums[i]=false;\\n            }\\n        }\\n        \\n        if(!ans)return true;\\n        else return false;\\n    }\\n    \\n    bool canIWin(int msi, int total) {\\n        int mask=0;\\n        vector<bool>nums(msi+1,false);\\n        if(msi*(msi+1)/2<total)return false;//sum is unreachable\\n        return dfs(msi,total,nums,0,mask);\\n        \\n    }\\n};\\n```\\n\\nBut this will give us a tle since i am checking for every digit we see\\nWe know a fact that there are many recurring states for the boolean array and the sum it produces so we can memoise it \\nNow it wont be possible to memoise a boolean array but we since the maxpossiblenumber is no more than 20 we can use the concpet of bitmasking\\nWe can use the ith number and set the ith bit to convey that this number is taken and since its a bitmask which is an int number we can store it in a hashmap and memoise it if we encounter the same mask(number) again we can directy use it from our map.\\n```\\nclass Solution {\\npublic:\\n    unordered_map<int,bool>map;\\n    bool dfs(int msi,int total,vector<bool>&nums,int sum,int mask)\\n    {\\n        if(map.find(mask)!=map.end())//if already encountered before use it\\n        {\\n            if(map[mask]==true)return false;\\n            else return true;\\n        }\\n        \\n        bool ans=true;\\n        for(int i=1;i<=msi;i++)\\n        {\\n            if((mask&(1<<(i-1)))==0)//if the i-1 th bit is unset\\n            {\\n                if(sum +i>=total)return true;\\n                mask=(mask|(1<<(i-1)));//setting the i-1 th bit(0 based indexing while number starts from 1)\\n                ans=ans and dfs(msi,total,nums,sum+i,mask);\\n                mask=(mask&(~(1<<(i-1))));//unsetting the i-1th bit\\n            }\\n        }\\n        map[mask]=ans;\\n        if(!ans)return true;\\n        else return false;\\n    }\\n    \\n    bool canIWin(int msi, int total) {\\n        int mask=0;\\n        vector<bool>nums(msi+1,false);\\n        if(msi*(msi+1)/2<total)return false;//sum is unreachable\\n        return dfs(msi,total,nums,0,mask);\\n        \\n    }\\n};\\n```\\n\\n\\n",
                "solutionTags": [
                    "Dynamic Programming",
                    "Bitmask"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    unordered_map<int,bool>map;\\n    bool dfs(int msi,int total,vector<bool>&nums,int sum,int mask)\\n    {\\n        \\n        bool ans=true;\\n        for(int i=1;i<=msi;i++)\\n        {\\n            if(nums[i]==false)\\n            {\\n                if(sum +i>=total)return true;\\n                nums[i]=true;\\n                ans=ans and dfs(msi,total,nums,sum+i,mask);\\n                nums[i]=false;\\n            }\\n        }\\n        \\n        if(!ans)return true;\\n        else return false;\\n    }\\n    \\n    bool canIWin(int msi, int total) {\\n        int mask=0;\\n        vector<bool>nums(msi+1,false);\\n        if(msi*(msi+1)/2<total)return false;//sum is unreachable\\n        return dfs(msi,total,nums,0,mask);\\n        \\n    }\\n};\\n```\n```\\nclass Solution {\\npublic:\\n    unordered_map<int,bool>map;\\n    bool dfs(int msi,int total,vector<bool>&nums,int sum,int mask)\\n    {\\n        if(map.find(mask)!=map.end())//if already encountered before use it\\n        {\\n            if(map[mask]==true)return false;\\n            else return true;\\n        }\\n        \\n        bool ans=true;\\n        for(int i=1;i<=msi;i++)\\n        {\\n            if((mask&(1<<(i-1)))==0)//if the i-1 th bit is unset\\n            {\\n                if(sum +i>=total)return true;\\n                mask=(mask|(1<<(i-1)));//setting the i-1 th bit(0 based indexing while number starts from 1)\\n                ans=ans and dfs(msi,total,nums,sum+i,mask);\\n                mask=(mask&(~(1<<(i-1))));//unsetting the i-1th bit\\n            }\\n        }\\n        map[mask]=ans;\\n        if(!ans)return true;\\n        else return false;\\n    }\\n    \\n    bool canIWin(int msi, int total) {\\n        int mask=0;\\n        vector<bool>nums(msi+1,false);\\n        if(msi*(msi+1)/2<total)return false;//sum is unreachable\\n        return dfs(msi,total,nums,0,mask);\\n        \\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1642009,
                "title": "c-dfs-memoization-faster-than-74-9-with-the-hidden-trap-explained",
                "content": "```\\nclass Solution {\\npublic:\\n\\tbool canIWin(int maxChoosableInteger, int desiredTotal) {\\n\\t\\tif (maxChoosableInteger >= desiredTotal)\\n\\t\\t\\treturn true;\\n\\n\\t\\tint total = (1 + maxChoosableInteger) * maxChoosableInteger / 2;\\n\\t\\tif (total < desiredTotal)\\n\\t\\t\\treturn false;        \\n\\n\\t\\treturn dfs(maxChoosableInteger, desiredTotal, 0);\\n\\t}\\n\\nprivate:\\n\\tint memo[1 << 21];\\n\\tbool dfs(int maxChoosableInteger, int desiredTotal, int state)\\n\\t{           \\n\\t\\tif (desiredTotal <= 0)\\n\\t\\t{\\n\\t\\t\\tmemo[state] = -1;\\n\\t\\t\\treturn false;\\n\\t\\t}\\n\\n\\t\\tif (memo[state] != 0)\\n\\t\\t\\treturn (memo[state] == 1);            \\n\\n\\t\\tfor (int i = 1; i <= maxChoosableInteger; i++)\\n\\t\\t{\\n\\t\\t\\tint s = 1 << i;\\n\\t\\t\\tif (state & s)\\n\\t\\t\\t\\tcontinue;\\n\\n\\t\\t\\tif (!dfs(maxChoosableInteger, desiredTotal - i, state | s))\\n\\t\\t\\t{\\n\\t\\t\\t\\tmemo[state] = 1;\\n\\t\\t\\t\\treturn true;\\n\\t\\t\\t}\\n\\t\\t}\\n\\t\\tmemo[state] = -1;\\n\\t\\treturn false;\\n\\t}\\n};\\n```\\n\\nThis is an ordinary dfs question, if you use dfs, you will surely hit TLE, then natually adding memoization is the choice. But the tricky part is, if you run following code, you will hit wrong answer. The commented out part is not the short cut to save the dfs loop, it\\'s the hidden trap of this question. The DFS solution has an assumption: \"if b cannot win, then a will win\", it\\'s actually a wrong assumption. There is situation that neither of them can win, which is when desiredTotal is too large that even adding all the numbers within maxChoosableInteger together, it can not be reached. That\\'s the real reason we need the commented lines. If you find it useful, please vote. Thank you!\\n\\n```\\nclass Solution {\\npublic:\\n\\tbool canIWin(int maxChoosableInteger, int desiredTotal) {\\n\\t\\tif (maxChoosableInteger >= desiredTotal)\\n\\t\\t\\treturn true;\\n\\n        // int total = (1 + maxChoosableInteger) * maxChoosableInteger / 2;\\n        // if (total < desiredTotal)\\n        //     return false;      \\n\\n\\t\\treturn dfs(maxChoosableInteger, desiredTotal, 0);\\n\\t}\\n\\nprivate:\\n\\tint memo[1 << 21];\\n\\tbool dfs(int maxChoosableInteger, int desiredTotal, int state)\\n\\t{           \\n\\t\\tif (desiredTotal <= 0)\\n\\t\\t{\\n\\t\\t\\tmemo[state] = -1;\\n\\t\\t\\treturn false;\\n\\t\\t}\\n\\n\\t\\tif (memo[state] != 0)\\n\\t\\t\\treturn (memo[state] == 1);            \\n\\n\\t\\tfor (int i = 1; i <= maxChoosableInteger; i++)\\n\\t\\t{\\n\\t\\t\\tint s = 1 << i;\\n\\t\\t\\tif (state & s)\\n\\t\\t\\t\\tcontinue;\\n\\n\\t\\t\\tif (!dfs(maxChoosableInteger, desiredTotal - i, state | s))\\n\\t\\t\\t{\\n\\t\\t\\t\\tmemo[state] = 1;\\n\\t\\t\\t\\treturn true;\\n\\t\\t\\t}\\n\\t\\t}\\n\\t\\tmemo[state] = -1;\\n\\t\\treturn false;\\n\\t}\\n};\\n```\\n\\n",
                "solutionTags": [
                    "C",
                    "Depth-First Search",
                    "Memoization"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n\\tbool canIWin(int maxChoosableInteger, int desiredTotal) {\\n\\t\\tif (maxChoosableInteger >= desiredTotal)\\n\\t\\t\\treturn true;\\n\\n\\t\\tint total = (1 + maxChoosableInteger) * maxChoosableInteger / 2;\\n\\t\\tif (total < desiredTotal)\\n\\t\\t\\treturn false;        \\n\\n\\t\\treturn dfs(maxChoosableInteger, desiredTotal, 0);\\n\\t}\\n\\nprivate:\\n\\tint memo[1 << 21];\\n\\tbool dfs(int maxChoosableInteger, int desiredTotal, int state)\\n\\t{           \\n\\t\\tif (desiredTotal <= 0)\\n\\t\\t{\\n\\t\\t\\tmemo[state] = -1;\\n\\t\\t\\treturn false;\\n\\t\\t}\\n\\n\\t\\tif (memo[state] != 0)\\n\\t\\t\\treturn (memo[state] == 1);            \\n\\n\\t\\tfor (int i = 1; i <= maxChoosableInteger; i++)\\n\\t\\t{\\n\\t\\t\\tint s = 1 << i;\\n\\t\\t\\tif (state & s)\\n\\t\\t\\t\\tcontinue;\\n\\n\\t\\t\\tif (!dfs(maxChoosableInteger, desiredTotal - i, state | s))\\n\\t\\t\\t{\\n\\t\\t\\t\\tmemo[state] = 1;\\n\\t\\t\\t\\treturn true;\\n\\t\\t\\t}\\n\\t\\t}\\n\\t\\tmemo[state] = -1;\\n\\t\\treturn false;\\n\\t}\\n};\\n```\n```\\nclass Solution {\\npublic:\\n\\tbool canIWin(int maxChoosableInteger, int desiredTotal) {\\n\\t\\tif (maxChoosableInteger >= desiredTotal)\\n\\t\\t\\treturn true;\\n\\n        // int total = (1 + maxChoosableInteger) * maxChoosableInteger / 2;\\n        // if (total < desiredTotal)\\n        //     return false;      \\n\\n\\t\\treturn dfs(maxChoosableInteger, desiredTotal, 0);\\n\\t}\\n\\nprivate:\\n\\tint memo[1 << 21];\\n\\tbool dfs(int maxChoosableInteger, int desiredTotal, int state)\\n\\t{           \\n\\t\\tif (desiredTotal <= 0)\\n\\t\\t{\\n\\t\\t\\tmemo[state] = -1;\\n\\t\\t\\treturn false;\\n\\t\\t}\\n\\n\\t\\tif (memo[state] != 0)\\n\\t\\t\\treturn (memo[state] == 1);            \\n\\n\\t\\tfor (int i = 1; i <= maxChoosableInteger; i++)\\n\\t\\t{\\n\\t\\t\\tint s = 1 << i;\\n\\t\\t\\tif (state & s)\\n\\t\\t\\t\\tcontinue;\\n\\n\\t\\t\\tif (!dfs(maxChoosableInteger, desiredTotal - i, state | s))\\n\\t\\t\\t{\\n\\t\\t\\t\\tmemo[state] = 1;\\n\\t\\t\\t\\treturn true;\\n\\t\\t\\t}\\n\\t\\t}\\n\\t\\tmemo[state] = -1;\\n\\t\\treturn false;\\n\\t}\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1503552,
                "title": "c-recursive-with-and-without-dp",
                "content": "1. Basic Recusive method gives tle \\n\\n```\\nclass Solution {\\npublic:\\n    \\n    bool dfs( int player , vector<int>& maxa , int total ){\\n        if( total <= 0 ){\\n            if( player == 1 ){\\n                return true;\\n            }else{\\n                return false;\\n            }\\n        }\\n        bool ret = player ;\\n        for( int i = 1 ; i < maxa.size() ; i++ ){\\n            if( maxa[i] == 1 ){\\n                maxa[i] = 0;\\n                if( player == 0 ){\\n                    ret = ret || dfs( 1 , maxa , total-i ) ;\\n                }else{\\n                    ret = ret && dfs( 0 , maxa , total-i ) ;\\n                }\\n                \\n                maxa[i] = 1;\\n                \\n            }\\n        }\\n        \\n        return ret;   \\n    }\\n    \\n    bool canIWin(int n, int desiredTotal) {\\n        \\n        vector<int> maxa(n+1,1);\\n        \\n        if( desiredTotal == 0 ){\\n            return true;\\n        }else if( n*(n+1)/2 < desiredTotal) {\\n            return false;\\n        }\\n        \\n         return dfs( 0 , maxa , desiredTotal ) ;\\n \\n    }\\n};\\n```\\n\\n2. With memoization to store subproblems \\n\\n\\n```\\nclass Solution {\\npublic:\\n    \\n    vector<vector<long long int >> dp;\\n    \\n    long long int getint( vector<int> & maxa ){\\n        long long int result = 0;\\n        for( int i = 1 ; i < maxa.size() ; i++ ){\\n            result = (result<<1) + maxa[i];\\n        }\\n\\n        return result;\\n    }\\n    \\n    \\n    int dfs( int player , vector<int>& maxa , int total ){\\n        if( total <= 0 ){\\n            if( player == 1 ){\\n                return 1;\\n            }else{\\n                return 0;\\n            }\\n        }\\n        \\n        bool ret = player ;\\n        \\n        for( int i = 1 ; i < maxa.size() ; i++ ){\\n            \\n            if( maxa[i] == 1 ){\\n                maxa[i] = 0;\\n                long long int j = getint(maxa);\\n                if( player == 0 ){\\n                    if( dp[1][j] == -1 ){\\n                        dp[1][j] =  dfs( 1 , maxa , total-i ) ;\\n                    }\\n                    ret = (ret || dp[1][j]);\\n                    if( ret == 1 ){\\n                        maxa[i] = 1;\\n                        return 1;\\n                    }\\n                    \\n                }else{\\n                    \\n                    if( dp[0][j] == -1 ){\\n                        dp[0][j] =  dfs( 0 , maxa , total-i ) ;\\n                    }\\n                    ret = ( ret && dp[0][j] );\\n                    if( ret == 0 ){\\n                        maxa[i] = 1;\\n                        return 0;\\n                    }\\n                }  \\n                maxa[i] = 1;         \\n            }\\n        }\\n        return ret;   \\n    }\\n    \\n    bool canIWin(int n, int desiredTotal) {\\n        // Base conditions\\n        if( desiredTotal == 0 ){\\n            return true;\\n        }else if( n*(n+1)/2 < desiredTotal) {\\n            return false;\\n        }\\n        \\n        vector<int> maxa(n+1,1);\\n        dp.resize( 2, vector< long long int >( pow(2,n)+1 ,-1 ) );\\n        \\n\\n        return dfs( 0 , maxa , desiredTotal ) ;\\n             \\n        \\n        \\n        \\n        \\n    }\\n};\\n```",
                "solutionTags": [
                    "C",
                    "Dynamic Programming",
                    "Recursion",
                    "Bitmask"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    \\n    bool dfs( int player , vector<int>& maxa , int total ){\\n        if( total <= 0 ){\\n            if( player == 1 ){\\n                return true;\\n            }else{\\n                return false;\\n            }\\n        }\\n        bool ret = player ;\\n        for( int i = 1 ; i < maxa.size() ; i++ ){\\n            if( maxa[i] == 1 ){\\n                maxa[i] = 0;\\n                if( player == 0 ){\\n                    ret = ret || dfs( 1 , maxa , total-i ) ;\\n                }else{\\n                    ret = ret && dfs( 0 , maxa , total-i ) ;\\n                }\\n                \\n                maxa[i] = 1;\\n                \\n            }\\n        }\\n        \\n        return ret;   \\n    }\\n    \\n    bool canIWin(int n, int desiredTotal) {\\n        \\n        vector<int> maxa(n+1,1);\\n        \\n        if( desiredTotal == 0 ){\\n            return true;\\n        }else if( n*(n+1)/2 < desiredTotal) {\\n            return false;\\n        }\\n        \\n         return dfs( 0 , maxa , desiredTotal ) ;\\n \\n    }\\n};\\n```\n```\\nclass Solution {\\npublic:\\n    \\n    vector<vector<long long int >> dp;\\n    \\n    long long int getint( vector<int> & maxa ){\\n        long long int result = 0;\\n        for( int i = 1 ; i < maxa.size() ; i++ ){\\n            result = (result<<1) + maxa[i];\\n        }\\n\\n        return result;\\n    }\\n    \\n    \\n    int dfs( int player , vector<int>& maxa , int total ){\\n        if( total <= 0 ){\\n            if( player == 1 ){\\n                return 1;\\n            }else{\\n                return 0;\\n            }\\n        }\\n        \\n        bool ret = player ;\\n        \\n        for( int i = 1 ; i < maxa.size() ; i++ ){\\n            \\n            if( maxa[i] == 1 ){\\n                maxa[i] = 0;\\n                long long int j = getint(maxa);\\n                if( player == 0 ){\\n                    if( dp[1][j] == -1 ){\\n                        dp[1][j] =  dfs( 1 , maxa , total-i ) ;\\n                    }\\n                    ret = (ret || dp[1][j]);\\n                    if( ret == 1 ){\\n                        maxa[i] = 1;\\n                        return 1;\\n                    }\\n                    \\n                }else{\\n                    \\n                    if( dp[0][j] == -1 ){\\n                        dp[0][j] =  dfs( 0 , maxa , total-i ) ;\\n                    }\\n                    ret = ( ret && dp[0][j] );\\n                    if( ret == 0 ){\\n                        maxa[i] = 1;\\n                        return 0;\\n                    }\\n                }  \\n                maxa[i] = 1;         \\n            }\\n        }\\n        return ret;   \\n    }\\n    \\n    bool canIWin(int n, int desiredTotal) {\\n        // Base conditions\\n        if( desiredTotal == 0 ){\\n            return true;\\n        }else if( n*(n+1)/2 < desiredTotal) {\\n            return false;\\n        }\\n        \\n        vector<int> maxa(n+1,1);\\n        dp.resize( 2, vector< long long int >( pow(2,n)+1 ,-1 ) );\\n        \\n\\n        return dfs( 0 , maxa , desiredTotal ) ;\\n             \\n        \\n        \\n        \\n        \\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1454684,
                "title": "java-dp-solution-recursion-with-memory",
                "content": "```\\n// DP Solution: Recursion with Memory\\n// Use bit map to represent the used boolean array. (used.length <= 21)\\n// Time complexity: O(2^N), where N = maxChoosableInteger\\n// Space complexity: O(2^N)\\nclass Solution {\\n    public boolean canIWin(int maxChoosableInteger, int desiredTotal) {\\n        int sum = maxChoosableInteger * (maxChoosableInteger + 1) / 2;\\n        if(sum < desiredTotal) return false;\\n        if(desiredTotal <= 0) return true;\\n        boolean[] used = new boolean[maxChoosableInteger + 1];\\n        Map<Integer, Boolean> memo = new HashMap<>();\\n        return canIWin(0, desiredTotal, used, memo);\\n    }\\n    \\n    private boolean canIWin(int sum, int desiredTotal, boolean[] used, Map<Integer, Boolean> memo) {\\n        if (sum >= desiredTotal) return false;\\n        int bit = bitMap(used);\\n        Boolean status = memo.get(bit);\\n        if (status != null) return status;\\n        // If the opponent always win or I always lose, then win is false\\n        for (int i = 1; i < used.length; i++) {\\n            if (!used[i]) {\\n                used[i] = true;\\n                status = !canIWin(sum + i, desiredTotal, used, memo);\\n                used[i] = false;\\n                if (status) break;\\n            }\\n        }\\n        memo.put(bit, status);\\n        return status;\\n    }\\n    \\n    private int bitMap(boolean[] used) {\\n        int bit = 0;\\n        for (boolean v : used) {\\n            bit <<= 1;\\n            if (v) {\\n                bit |= 1;\\n            }\\n        }\\n        return bit;\\n    }\\n}\\n```\\n\\nSame idea with bitmap optimization. \\nThanks ambuj_kumar to poin out that we don\\'t need to compute bitMap each time.\\n```\\n// DP Solution: Recursion with Memory\\n// Use bit map to represent the used boolean array. (used.length <= 21)\\n// Time complexity: O(2^N), where N = maxChoosableInteger\\n// Space complexity: O(2^N)\\nclass Solution {\\n    public boolean canIWin(int maxChoosableInteger, int desiredTotal) {\\n        int sum = maxChoosableInteger * (maxChoosableInteger + 1) / 2;\\n        if(sum < desiredTotal) return false;\\n        if(desiredTotal <= 0) return true;\\n        boolean[] used = new boolean[maxChoosableInteger + 1];\\n        Map<Integer, Boolean> memo = new HashMap<>();\\n        return canIWin(0, desiredTotal, used, memo, 0);\\n    }\\n    \\n    private boolean canIWin(int sum, int desiredTotal, boolean[] used, Map<Integer, Boolean> memo, int bitMap) {\\n        if (sum >= desiredTotal) return false;\\n        Boolean status = memo.get(bitMap);\\n        if (status != null) return status;\\n        // If the opponent always win or I always lose, then win is false\\n        for (int i = 1; i < used.length; i++) {\\n            if (!used[i]) {\\n                used[i] = true;\\n                status = !canIWin(sum + i, desiredTotal, used, memo, bitMap | (1 << i));\\n                used[i] = false;\\n                if (status) break;\\n            }\\n        }\\n        memo.put(bitMap, status);\\n        return status;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\n// DP Solution: Recursion with Memory\\n// Use bit map to represent the used boolean array. (used.length <= 21)\\n// Time complexity: O(2^N), where N = maxChoosableInteger\\n// Space complexity: O(2^N)\\nclass Solution {\\n    public boolean canIWin(int maxChoosableInteger, int desiredTotal) {\\n        int sum = maxChoosableInteger * (maxChoosableInteger + 1) / 2;\\n        if(sum < desiredTotal) return false;\\n        if(desiredTotal <= 0) return true;\\n        boolean[] used = new boolean[maxChoosableInteger + 1];\\n        Map<Integer, Boolean> memo = new HashMap<>();\\n        return canIWin(0, desiredTotal, used, memo);\\n    }\\n    \\n    private boolean canIWin(int sum, int desiredTotal, boolean[] used, Map<Integer, Boolean> memo) {\\n        if (sum >= desiredTotal) return false;\\n        int bit = bitMap(used);\\n        Boolean status = memo.get(bit);\\n        if (status != null) return status;\\n        // If the opponent always win or I always lose, then win is false\\n        for (int i = 1; i < used.length; i++) {\\n            if (!used[i]) {\\n                used[i] = true;\\n                status = !canIWin(sum + i, desiredTotal, used, memo);\\n                used[i] = false;\\n                if (status) break;\\n            }\\n        }\\n        memo.put(bit, status);\\n        return status;\\n    }\\n    \\n    private int bitMap(boolean[] used) {\\n        int bit = 0;\\n        for (boolean v : used) {\\n            bit <<= 1;\\n            if (v) {\\n                bit |= 1;\\n            }\\n        }\\n        return bit;\\n    }\\n}\\n```\n```\\n// DP Solution: Recursion with Memory\\n// Use bit map to represent the used boolean array. (used.length <= 21)\\n// Time complexity: O(2^N), where N = maxChoosableInteger\\n// Space complexity: O(2^N)\\nclass Solution {\\n    public boolean canIWin(int maxChoosableInteger, int desiredTotal) {\\n        int sum = maxChoosableInteger * (maxChoosableInteger + 1) / 2;\\n        if(sum < desiredTotal) return false;\\n        if(desiredTotal <= 0) return true;\\n        boolean[] used = new boolean[maxChoosableInteger + 1];\\n        Map<Integer, Boolean> memo = new HashMap<>();\\n        return canIWin(0, desiredTotal, used, memo, 0);\\n    }\\n    \\n    private boolean canIWin(int sum, int desiredTotal, boolean[] used, Map<Integer, Boolean> memo, int bitMap) {\\n        if (sum >= desiredTotal) return false;\\n        Boolean status = memo.get(bitMap);\\n        if (status != null) return status;\\n        // If the opponent always win or I always lose, then win is false\\n        for (int i = 1; i < used.length; i++) {\\n            if (!used[i]) {\\n                used[i] = true;\\n                status = !canIWin(sum + i, desiredTotal, used, memo, bitMap | (1 << i));\\n                used[i] = false;\\n                if (status) break;\\n            }\\n        }\\n        memo.put(bitMap, status);\\n        return status;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1262076,
                "title": "c-dp-bitmasking-approach",
                "content": "i first thought of a 2d dp for mask and sum but it gave me memory limited exceeded at test 56.then i got the idea that the sum state is not necessary since for each mask unique sum will be there (think little bit with bits and sum).so i just reduced a state got AC.\\n```\\nclass Solution {\\npublic:\\n\\n    bool recurse(int sum,int mask,int n,vector<int>& dp)\\n    {\\n        \\n        if(sum<0)return 0;\\n        if(sum==0)return false;\\n        if(dp[mask]!=-1)return dp[mask];\\n        int ans=0;\\n        for(int i=0;i<n;i++)\\n        {\\n            if(mask&(1<<i)&&!recurse(sum-i-1,mask^(1<<i),n,dp))\\n            return dp[mask]=1;\\n        }\\n                        return dp[mask]=0;\\n    \\n    }\\n    bool canIWin(int n, int sum) {\\n        int mask=(1ll<<n)-1;\\n        if(sum==0)return 1;\\n        if(2*sum>(n*(n+1)))return 0;\\n        if(sum*2==(n*(n+1)))\\n        {\\n            if(n%2)return 1;\\n            return 0;\\n        }\\n        int summ=(n*(n+1))/2+1;\\n        vector<int>dp(mask,-1);\\n        for(int i=0;i<n;i++)\\n                              \\n                              {\\n                                  if(!recurse(sum-i-1,mask^(1<<i),n,dp))\\n                                      return true;\\n                            \\n                              }\\n                              return false;\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n\\n    bool recurse(int sum,int mask,int n,vector<int>& dp)\\n    {\\n        \\n        if(sum<0)return 0;\\n        if(sum==0)return false;\\n        if(dp[mask]!=-1)return dp[mask];\\n        int ans=0;\\n        for(int i=0;i<n;i++)\\n        {\\n            if(mask&(1<<i)&&!recurse(sum-i-1,mask^(1<<i),n,dp))\\n            return dp[mask]=1;\\n        }\\n                        return dp[mask]=0;\\n    \\n    }\\n    bool canIWin(int n, int sum) {\\n        int mask=(1ll<<n)-1;\\n        if(sum==0)return 1;\\n        if(2*sum>(n*(n+1)))return 0;\\n        if(sum*2==(n*(n+1)))\\n        {\\n            if(n%2)return 1;\\n            return 0;\\n        }\\n        int summ=(n*(n+1))/2+1;\\n        vector<int>dp(mask,-1);\\n        for(int i=0;i<n;i++)\\n                              \\n                              {\\n                                  if(!recurse(sum-i-1,mask^(1<<i),n,dp))\\n                                      return true;\\n                            \\n                              }\\n                              return false;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 965511,
                "title": "java-bitset-solution-and-why-not-using-bit-masking",
                "content": "There already exist several detailed posts explaining the top-down dynamic programming. What made me write this post is that most (if not **ALL**) of the solutions performed their bit manipulations directly on primitive data types (like `int`) to represent a set, which is so-called *bit masking* technique (or formally, bit set / bit map).\\n\\nThe problem description shows that max choosable number is at most 20, and those who\\'ve practiced bit masking problems will come up with this method right away.\\nHowever, bit masking itself is nothing more than a fancy bit-wise implementation of a set. It doesn\\'t essentially relate to any algorithm, though it\\'s mostly used in DP problems.\\n\\nI would say that bit map is somewhat useful in real world, such as marking a disk sector as available or occupied. However, it\\'s **NOT** a good practice to do bit-wise operation directly on integers to represent a set. From the perspective of readability and maintainability, it should be encapsulated / decoupled into a class or at least a macro in programming languages without object oriented programming paradigm.\\n\\nJava provides a decent `BitSet` class to fulfill the task.\\n```\\nclass Solution {\\n    Map<BitSet, Boolean> memo = new HashMap<>();\\n    \\n    public boolean canIWin(int limit, int desired) {\\n        if (desired <= limit) return true;\\n        \\n        int sum = limit * (limit + 1) / 2;\\n        if (sum < desired) return false;\\n        if (sum == desired) return limit % 2 == 1;\\n        \\n        var used = new BitSet(limit);\\n        \\n        return isWinnable(used, desired, limit);\\n    }\\n    \\n    private boolean isWinnable(BitSet used, int desired, int limit) {\\n        if (desired <= 0) return false;\\n        \\n        // Not satisfied with explicit type casting here, but no better method to copy bitset\\n        var original = (BitSet)used.clone();\\n        if (memo.containsKey(original)) return memo.get(original);\\n        \\n        var winnable = false;\\n        for (int i = used.nextClearBit(0); i < limit; i = used.nextClearBit(i + 1)) {\\n            if (used.get(i)) continue;\\n            \\n            used.set(i);\\n            winnable = !isWinnable(used, desired - (i + 1), limit);\\n            used.clear(i);\\n            \\n            if (winnable) break;\\n        }\\n        \\n        memo.put(original, winnable);\\n        return winnable;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Dynamic Programming"
                ],
                "code": "```\\nclass Solution {\\n    Map<BitSet, Boolean> memo = new HashMap<>();\\n    \\n    public boolean canIWin(int limit, int desired) {\\n        if (desired <= limit) return true;\\n        \\n        int sum = limit * (limit + 1) / 2;\\n        if (sum < desired) return false;\\n        if (sum == desired) return limit % 2 == 1;\\n        \\n        var used = new BitSet(limit);\\n        \\n        return isWinnable(used, desired, limit);\\n    }\\n    \\n    private boolean isWinnable(BitSet used, int desired, int limit) {\\n        if (desired <= 0) return false;\\n        \\n        // Not satisfied with explicit type casting here, but no better method to copy bitset\\n        var original = (BitSet)used.clone();\\n        if (memo.containsKey(original)) return memo.get(original);\\n        \\n        var winnable = false;\\n        for (int i = used.nextClearBit(0); i < limit; i = used.nextClearBit(i + 1)) {\\n            if (used.get(i)) continue;\\n            \\n            used.set(i);\\n            winnable = !isWinnable(used, desired - (i + 1), limit);\\n            used.clear(i);\\n            \\n            if (winnable) break;\\n        }\\n        \\n        memo.put(original, winnable);\\n        return winnable;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 913596,
                "title": "javascript-iterative-bottom-up-dp-o-m-2-m",
                "content": "The iterative solutions for this question are lacking at best. That is probably because it\\'s kinda hard to distinguish how the states are computed and implement it properly. Here goes a concise solution that calculates whether a state **i** is winning or losing. Each state is represented as a base 2 integer, with 1 denoting whether an element was picked and 0 indicating that it is free to pick for the player who goes first on this round. \\n**Example**:\\n **desiredtotal**=7, **maxChoosableInteger**=5\\n state=12=**01100**\\n state 12 would basically mean that the elements 3 and 4 are chosen and {1,2,5} are available \\n \\n We can easily see that state 12 is a **winning state**, because the total sum of the elements chosen is 3+4=7>=**desiredtotal**. \\n \\n However state=1=**00001** is a **losing state**.  The available choices for the current player are {2,3,4,5}. If we translate these choices to their mask representation we get an idea of what the next player\\'s position is\\n\\t I choose 2 : nextstate= **00011**, nextTotal=1+2=3 which is **winning** because the next player will obviously choose to add 5 or 4 or 3, making his total>=7 \\n  I choose 3 : nextstate= **00101**, nextTotal=1+3=4 which is **winning** because the next player will obviously choose to add 5 or 4 or 2, making his total>=7 \\n   I choose 4 : nextstate= **01001**, nextTotal=1+4=5 which is **winning** because the next player will obviously choose to add 5 or 3 or 2, making his total>=7 \\n    I choose 5 : nextstate= **10001**, nextTotal=1+5=6 which is **winning** because the next player will obviously choose to add 2 or 3 or 4, making his total>=7 \\n\\t\\nSo you see that **no matter which choice I make, if every next state with a totalSum<desired is a winning state, I lose**. \\nAs a consequence, state 0= **00000**, which is our result, is a **winning state**. Because the current player will always pick 1, making our new state **00001** which as we\\'ve said above, is **losing**. So our result is that the player who goes first always wins because he transitions the game to a state such that the player who goes first (his opponent) always loses.  \\n\\n```\\n//dp[i]= can the player who plays first while at state i win?\\nvar canIWin = function(maxChoosableInteger, desiredTotal) {\\n    let n=desiredTotal,m=maxChoosableInteger,dp=[...Array(1<<m)].map(d=>0)\\n    for (let i = (1<<m)-1; i >=0; i--) {\\n        let next=[],totalSum=0\\n        for (let j = 0; j < m; j++)\\n            if(i&(1<<j))\\n                totalSum+=j+1\\n            else\\n                //[next\\'s mask, their sum\\'s difference]\\n                next.push( [i|(1<<j),j+1] ) \\n\\n        dp[i]=totalSum>=n|| // my curr state wins only if its totalSum exceeds desired\\n\\t\\t      next.some(([nextmask,difference])=>\\t\\t\\t\\t\\t\\t\\t\\t \\n                                 difference+totalSum>=n|| // or when a next state\\'s total sum  exceeds desired\\n\\t\\t\\t\\t\\t\\t\\t     dp[nextmask]==0               // or when some next state loses \\n                       )\\n    } \\n    return dp[0]\\n};\\n```",
                "solutionTags": [
                    "Dynamic Programming",
                    "Iterator"
                ],
                "code": "```\\n//dp[i]= can the player who plays first while at state i win?\\nvar canIWin = function(maxChoosableInteger, desiredTotal) {\\n    let n=desiredTotal,m=maxChoosableInteger,dp=[...Array(1<<m)].map(d=>0)\\n    for (let i = (1<<m)-1; i >=0; i--) {\\n        let next=[],totalSum=0\\n        for (let j = 0; j < m; j++)\\n            if(i&(1<<j))\\n                totalSum+=j+1\\n            else\\n                //[next\\'s mask, their sum\\'s difference]\\n                next.push( [i|(1<<j),j+1] ) \\n\\n        dp[i]=totalSum>=n|| // my curr state wins only if its totalSum exceeds desired\\n\\t\\t      next.some(([nextmask,difference])=>\\t\\t\\t\\t\\t\\t\\t\\t \\n                                 difference+totalSum>=n|| // or when a next state\\'s total sum  exceeds desired\\n\\t\\t\\t\\t\\t\\t\\t     dp[nextmask]==0               // or when some next state loses \\n                       )\\n    } \\n    return dp[0]\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 814116,
                "title": "java-bitmask-dp-hashset",
                "content": "```\\nclass Solution {\\n    Map<Integer, Boolean> dp = new HashMap<>();\\n    \\n    public boolean canIWin(int maxChoosableInteger, int desiredTotal) {\\n        int arithmeticSum = (maxChoosableInteger * (maxChoosableInteger + 1)) / 2;\\n        if (arithmeticSum < desiredTotal) {\\n            return false;\\n        }\\n        for (int x = 1; x <= maxChoosableInteger; x++) {\\n            Set<Integer> seen = new HashSet<>();\\n            seen.add(x);\\n            if (dfs(x, maxChoosableInteger, desiredTotal, 1 << x, seen)) {\\n                return true;\\n            }\\n        }\\n        return false;\\n        \\n    }\\n    \\n    private boolean dfs(int sum, int max, int desired, int bitmask, Set<Integer> seen) {\\n        if (sum >= desired) {\\n            return true;\\n        }\\n        if (dp.containsKey(bitmask)) {\\n            return dp.get(bitmask);\\n        }\\n        for (int x = 1; x <= max; x++) {\\n            if (!seen.contains(x)) {\\n                Set<Integer> next = new HashSet<>(seen);\\n                next.add(x);\\n                if (dfs(sum + x, max, desired, bitmask ^ (1 << x), next)) {\\n                    dp.put(bitmask, false);\\n                    return false;\\n                }\\n            }\\n        }\\n        dp.put(bitmask, true);\\n        return true;\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    Map<Integer, Boolean> dp = new HashMap<>();\\n    \\n    public boolean canIWin(int maxChoosableInteger, int desiredTotal) {\\n        int arithmeticSum = (maxChoosableInteger * (maxChoosableInteger + 1)) / 2;\\n        if (arithmeticSum < desiredTotal) {\\n            return false;\\n        }\\n        for (int x = 1; x <= maxChoosableInteger; x++) {\\n            Set<Integer> seen = new HashSet<>();\\n            seen.add(x);\\n            if (dfs(x, maxChoosableInteger, desiredTotal, 1 << x, seen)) {\\n                return true;\\n            }\\n        }\\n        return false;\\n        \\n    }\\n    \\n    private boolean dfs(int sum, int max, int desired, int bitmask, Set<Integer> seen) {\\n        if (sum >= desired) {\\n            return true;\\n        }\\n        if (dp.containsKey(bitmask)) {\\n            return dp.get(bitmask);\\n        }\\n        for (int x = 1; x <= max; x++) {\\n            if (!seen.contains(x)) {\\n                Set<Integer> next = new HashSet<>(seen);\\n                next.add(x);\\n                if (dfs(sum + x, max, desired, bitmask ^ (1 << x), next)) {\\n                    dp.put(bitmask, false);\\n                    return false;\\n                }\\n            }\\n        }\\n        dp.put(bitmask, true);\\n        return true;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 635834,
                "title": "for-case-maxinteger-10-and-desiredtotal-40-really-return-false",
                "content": "For example case  maxInteger 10 and desiredTotal 40\\nWho takes 29 first will win => who takes 18 will win=> who  takes 7 will win\\nif the first player do optimal, he should win or? but why the system give false back to me?\\n\\nDid I think in a wrong way:(\\n\\nclass Solution {\\npublic:\\n    bool canIWin(int maxChoosableInteger, int desiredTotal) {\\n        if (desiredTotal==0) return true;\\n        if (desiredTotal%(maxChoosableInteger+1) == 0)\\n            return false;\\n        else return true;\\n    }\\n};",
                "solutionTags": [],
                "code": "class Solution {\\npublic:\\n    bool canIWin(int maxChoosableInteger, int desiredTotal) {\\n        if (desiredTotal==0) return true;\\n        if (desiredTotal%(maxChoosableInteger+1) == 0)\\n            return false;\\n        else return true;\\n    }",
                "codeTag": "Java"
            },
            {
                "id": 526008,
                "title": "dfs-memoization-easy-to-understand-with-explanation",
                "content": "```\\nclass Solution(object):\\n    def canIWin(self, maxChoosableInteger, desiredTotal):\\n        \"\"\"\\n        :type maxChoosableInteger: int\\n        :type desiredTotal: int\\n        :rtype: bool\\n        \"\"\"\\n        \\n        \"\"\"\\n        this is different type of dp.\\n        here we do dfs while caching failed branches to\\n        avoid exploring them again.\\n        this is unlike other dp problems with a 2-D matrix.\\n        \\n        \\n        there is one key observations here:\\n        the state of the game is captured in the numbers that haven\\'t been\\n        picked. for example, imagine that the players can pick from [1,2,3,4,5].\\n        \\n        case 1: p1 picks 1, p2 picks 3, p1 picks 2. we are left with [4,5] and its p2\\'s turn\\n        case 2: p1 picks 3, p2 picks 1, p1 picks 2. we are left with [4,5] and its p2\\'s turn\\n        \\n        in both cases, the running sum is the same and its player 2\\'s turn. we know what the \\n        path ahead looks like from case 1 and we can reuse that result in case 2 to determine\\n        if player 2 can win from here on. => return if tuple(nums) in seen ...\\n        \\n        during a players turn,\\n        the running sum is => prefix, set of picked nums\\n        the avlb nums is => nums, set of nums not picked\\n        target,\\n        seen is the set of paths already explored\\n        \\n        each frame of recursion or rather a level in the tree is a player\\'s turn.\\n        any node on level 1 => p1\\'s turn\\n        any node on level 2 => p2\\'2 turn\\n        any node on level 3 => p1\\'s turn again and so on..\\n        \\n        at a particular node, lets say at a node on level 3 its p1\\'s turn.\\n        p1 tries each num from the set of avlb nums => for i,n in enum(...)\\n        and checks if the sum is over the target => sum(prefix) + n.\\n        if the sum is over the target, p1 declares victory => return True\\n        else its p2\\'s turn => or not dfs(set of picked nums, set of avlb nums,...)\\n        the (not dfs) recurses to the next level in the tree which is p2\\'s turn\\n        and p2 declares victory or returns True, (not dfs) evals to false one level up \\n        which means p1 does not win and the loop continues.\\n        \\n        going from the bottom,\\n        when p1 has tried all possible avlb nums, loop ends and p1 declares defeat and \\n        returns False to the level above wherein p2 declares victory and returns True\\n        to the level above wherein p1 tries other nums and so on... all the way up to the root\\n    \\n        \\n        \"\"\"\\n        \\n        N = maxChoosableInteger\\n        T = desiredTotal\\n        prefix, nums, seen = [], range(1,N+1), dict()       \\n\\n        def dfs(prefix, nums, target, seen):\\n            \\n            if tuple(nums) in seen:\\n                return seen[tuple(nums)]\\n            \\n            for i,n in enumerate(nums):                \\n                if sum(prefix) + n >= target or not dfs(prefix + [n], nums[:i]+nums[i+1:], target, seen):\\n                    seen[tuple(nums)] = True\\n                    return True\\n            \\n            seen[tuple(nums)] = False\\n            return False\\n            \\n            \\n        \\n        return sum(nums) >= T and dfs(prefix, nums, T, seen)\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution(object):\\n    def canIWin(self, maxChoosableInteger, desiredTotal):\\n        \"\"\"\\n        :type maxChoosableInteger: int\\n        :type desiredTotal: int\\n        :rtype: bool\\n        \"\"\"\\n        \\n        \"\"\"\\n        this is different type of dp.\\n        here we do dfs while caching failed branches to\\n        avoid exploring them again.\\n        this is unlike other dp problems with a 2-D matrix.\\n        \\n        \\n        there is one key observations here:\\n        the state of the game is captured in the numbers that haven\\'t been\\n        picked. for example, imagine that the players can pick from [1,2,3,4,5].\\n        \\n        case 1: p1 picks 1, p2 picks 3, p1 picks 2. we are left with [4,5] and its p2\\'s turn\\n        case 2: p1 picks 3, p2 picks 1, p1 picks 2. we are left with [4,5] and its p2\\'s turn\\n        \\n        in both cases, the running sum is the same and its player 2\\'s turn. we know what the \\n        path ahead looks like from case 1 and we can reuse that result in case 2 to determine\\n        if player 2 can win from here on. => return if tuple(nums) in seen ...\\n        \\n        during a players turn,\\n        the running sum is => prefix, set of picked nums\\n        the avlb nums is => nums, set of nums not picked\\n        target,\\n        seen is the set of paths already explored\\n        \\n        each frame of recursion or rather a level in the tree is a player\\'s turn.\\n        any node on level 1 => p1\\'s turn\\n        any node on level 2 => p2\\'2 turn\\n        any node on level 3 => p1\\'s turn again and so on..\\n        \\n        at a particular node, lets say at a node on level 3 its p1\\'s turn.\\n        p1 tries each num from the set of avlb nums => for i,n in enum(...)\\n        and checks if the sum is over the target => sum(prefix) + n.\\n        if the sum is over the target, p1 declares victory => return True\\n        else its p2\\'s turn => or not dfs(set of picked nums, set of avlb nums,...)\\n        the (not dfs) recurses to the next level in the tree which is p2\\'s turn\\n        and p2 declares victory or returns True, (not dfs) evals to false one level up \\n        which means p1 does not win and the loop continues.\\n        \\n        going from the bottom,\\n        when p1 has tried all possible avlb nums, loop ends and p1 declares defeat and \\n        returns False to the level above wherein p2 declares victory and returns True\\n        to the level above wherein p1 tries other nums and so on... all the way up to the root\\n    \\n        \\n        \"\"\"\\n        \\n        N = maxChoosableInteger\\n        T = desiredTotal\\n        prefix, nums, seen = [], range(1,N+1), dict()       \\n\\n        def dfs(prefix, nums, target, seen):\\n            \\n            if tuple(nums) in seen:\\n                return seen[tuple(nums)]\\n            \\n            for i,n in enumerate(nums):                \\n                if sum(prefix) + n >= target or not dfs(prefix + [n], nums[:i]+nums[i+1:], target, seen):\\n                    seen[tuple(nums)] = True\\n                    return True\\n            \\n            seen[tuple(nums)] = False\\n            return False\\n            \\n            \\n        \\n        return sum(nums) >= T and dfs(prefix, nums, T, seen)\\n```",
                "codeTag": "Java"
            },
            {
                "id": 426121,
                "title": "c-solution-8ms-99-17mb-100-memorized-dfs",
                "content": "The trick is using ***int8_t***.\\n***char*** is also okay.\\n\\n```C++\\nclass Solution { // 8ms, 17MB\\npublic:\\n    bool canIWin(int maxChoosableInteger, int desiredTotal) {\\n        if(maxChoosableInteger * (maxChoosableInteger + 1) / 2 < desiredTotal) return false;\\n        vector<int8_t> vis(1 << maxChoosableInteger, -1);\\n        return isWinState(0, maxChoosableInteger, desiredTotal, vis);\\n    }\\nprivate:\\n    bool isWinState(int used, int maxChoose, int desire, vector<int8_t>& vis){\\n        if(~vis[used]) return vis[used];\\n        for(int i = maxChoose; i > 0; --i){\\n            if(used & (1 << (i - 1))) continue;\\n            if(i >= desire || !isWinState(used | (1 << (i - 1)), maxChoose, desire - i, vis))\\n                return vis[used] = 1;\\n        }\\n        return vis[used] = 0;\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```C++\\nclass Solution { // 8ms, 17MB\\npublic:\\n    bool canIWin(int maxChoosableInteger, int desiredTotal) {\\n        if(maxChoosableInteger * (maxChoosableInteger + 1) / 2 < desiredTotal) return false;\\n        vector<int8_t> vis(1 << maxChoosableInteger, -1);\\n        return isWinState(0, maxChoosableInteger, desiredTotal, vis);\\n    }\\nprivate:\\n    bool isWinState(int used, int maxChoose, int desire, vector<int8_t>& vis){\\n        if(~vis[used]) return vis[used];\\n        for(int i = maxChoose; i > 0; --i){\\n            if(used & (1 << (i - 1))) continue;\\n            if(i >= desire || !isWinState(used | (1 << (i - 1)), maxChoose, desire - i, vis))\\n                return vis[used] = 1;\\n        }\\n        return vis[used] = 0;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 353780,
                "title": "c-dfs-with-memo-8ms",
                "content": "\\tclass Solution {\\n\\t\\tbool probe(vector<char>& memo, int n, int mask, int total){\\n\\t\\t\\tint idx = n-1;\\n\\t\\t\\twhile((1<<idx) & mask) idx--;\\n\\t\\t\\tif(idx+1 >= total) return true;\\n\\n\\t\\t\\tfor(int i=idx; i>=0; i--){\\n\\t\\t\\t\\tif((1<<i) & mask) continue;\\n\\n\\t\\t\\t\\tint mask_ = (mask|(1<<i));\\n\\t\\t\\t\\tif(memo[mask_] == \\'0\\') return true;\\n\\t\\t\\t\\tif(memo[mask_] == \\'1\\') continue;\\n\\n\\t\\t\\t\\tbool ret = probe(memo, n, mask_, total-(i+1));\\n\\t\\t\\t\\tmemo[mask_] = ret ? \\'1\\' : \\'0\\';\\n\\t\\t\\t\\tif(!ret) return true;\\n\\t\\t\\t}\\n\\n\\t\\t\\treturn false;\\n\\t\\t}\\n\\tpublic:\\n\\t\\tbool canIWin(int n, int total) {\\n\\t\\t\\tint sum = (n*(n+1))>>1;\\n\\t\\t\\tif (sum < total){\\n\\t\\t\\t\\treturn false;\\n\\t\\t\\t}\\n\\n\\t\\t\\tvector<char> memo(1<<n, 0);\\n\\t\\t\\treturn probe(memo, n, 0, total);\\n\\t\\t}\\n\\t};\\n",
                "solutionTags": [],
                "code": "class Solution {\\n\\t\\tbool probe(vector<char>& memo, int n, int mask, int total){\\n\\t\\t\\tint idx = n-1;\\n\\t\\t\\twhile((1<<idx) & mask) idx--;\\n\\t\\t\\tif(idx+1 >= total) return true;\\n\\n\\t\\t\\tfor(int i=idx; i>=0; i--){\\n\\t\\t\\t\\tif((1<<i) & mask) continue;\\n\\n\\t\\t\\t\\tint mask_ = (mask|(1<<i));\\n\\t\\t\\t\\tif(memo[mask_] == \\'0\\') return true;\\n\\t\\t\\t\\tif(memo[mask_] == \\'1\\') continue;\\n\\n\\t\\t\\t\\tbool ret = probe(memo, n, mask_, total-(i+1));\\n\\t\\t\\t\\tmemo[mask_] = ret ? \\'1\\' : \\'0\\';\\n\\t\\t\\t\\tif(!ret) return true;\\n\\t\\t\\t}",
                "codeTag": "Java"
            },
            {
                "id": 325930,
                "title": "python-recursive-with-memo",
                "content": "\\n```\\nclass Solution(object):\\n    def canIWin(self, maxChoosableInteger, desiredTotal):\\n        \"\"\"\\n        :type maxChoosableInteger: int\\n        :type desiredTotal: int\\n        :rtype: bool\\n        \"\"\"\\n        \\n        def canWin(alt, desiredTotal, memo):\\n            if tuple(alt) in memo:\\n                return memo[tuple(alt)]\\n            \\n            #If it is possible to win by using a value from alternatives alt, \\n            #then alt is a winning list.\\n            for v in alt:\\n                if desiredTotal - v <= 0:\\n                    memo[tuple(alt)] = True\\n                    return True\\n            \\n            #If there is an alt2 given to the other player that is loosing, \\n            #then alt is a wining list. \\n\\t\\t\\t#This for can be optimized by checking first the alt2 that are already in memo.\\n            for i in range(0, len(alt)):\\n                alt2 = alt[:i] + alt[i+1:]\\n                if not canWin(alt2, desiredTotal - alt[i], memo):\\n                    memo[tuple(alt)] = True\\n                    return True\\n            \\n            #Otherwise alt is loosing.\\n            memo[tuple(alt)] = False\\n            return False\\n                    \\n        \\n        alt = range(1, maxChoosableInteger+1)\\n        \\n        if sum(alt) < desiredTotal:\\n            return False\\n        \\n        return canWin(alt, desiredTotal, {})\\n\\t```",
                "solutionTags": [],
                "code": "```\\nclass Solution(object):\\n    def canIWin(self, maxChoosableInteger, desiredTotal):\\n        \"\"\"\\n        :type maxChoosableInteger: int\\n        :type desiredTotal: int\\n        :rtype: bool\\n        \"\"\"\\n        \\n        def canWin(alt, desiredTotal, memo):\\n            if tuple(alt) in memo:\\n                return memo[tuple(alt)]\\n            \\n            #If it is possible to win by using a value from alternatives alt, \\n            #then alt is a winning list.\\n            for v in alt:\\n                if desiredTotal - v <= 0:\\n                    memo[tuple(alt)] = True\\n                    return True\\n            \\n            #If there is an alt2 given to the other player that is loosing, \\n            #then alt is a wining list. \\n\\t\\t\\t#This for can be optimized by checking first the alt2 that are already in memo.\\n            for i in range(0, len(alt)):\\n                alt2 = alt[:i] + alt[i+1:]\\n                if not canWin(alt2, desiredTotal - alt[i], memo):\\n                    memo[tuple(alt)] = True\\n                    return True\\n            \\n            #Otherwise alt is loosing.\\n            memo[tuple(alt)] = False\\n            return False\\n                    \\n        \\n        alt = range(1, maxChoosableInteger+1)\\n        \\n        if sum(alt) < desiredTotal:\\n            return False\\n        \\n        return canWin(alt, desiredTotal, {})\\n\\t```",
                "codeTag": "Java"
            },
            {
                "id": 268506,
                "title": "c-solution-using-alpha-beta-pruning-with-explaination",
                "content": "https://en.wikipedia.org/wiki/Alpha%E2%80%93beta_pruning\\nwe can use alpha-beta pruning to speed up our standard minimax dfs.\\n\\n```\\nclass Solution {\\npublic:\\n    // 1 means the first player wins, -1 means the second player wins otherwise the game \\n\\t// is not determined yet\\n    bool canIWin(int maxChoosableInteger, int desiredTotal) {\\n        if (desiredTotal > maxChoosableInteger * (maxChoosableInteger + 1) / 2) return false;\\n        if (desiredTotal <= 0) return true;\\n        int value = minimax(0, desiredTotal, 1, maxChoosableInteger, -2, 2);\\n        return (value == 1);\\n    }\\nprivate:\\n    unordered_map<int, int> win;\\n\\t// state is the bitwise or of all the current choosing points\\n    int minimax(int state, int total, int player, int maximum, int alpha, int beta) {\\n        if (win.find(state) != win.end()) {\\n            return win[state];\\n        }\\n        \\n        int value, i;\\n\\t\\t// the maxplayer is playing\\n        if (player == 1) {\\n            value = -2;\\n\\t\\t\\t// if a winning state is reached return 1\\n            for (i = 0; i < maximum; i++) {\\n                if ((((1 << i) & state) == 0) && total <= i + 1) {\\n                    value = 1;\\n                    \\n                } \\n            }\\n            // cannot win by directly choose one number\\n            if (value == -2) {\\n                for (i = 0; i < maximum; i++) {\\n                    if (((1 << i) & state) == 0) {\\n                        int tmp = minimax((state | (1 << i)), total - i - 1, !player, maximum, alpha, beta);\\n                        value = max(value, tmp);\\n                        alpha = max(alpha, value);\\n\\t\\t\\t\\t\\t\\t// the beta cut-off\\n                        if (value == 1) break;\\n                        if (alpha >= beta) break;\\n                    } \\n                }\\n            }\\n        } else {\\n            value = 2;\\n\\t\\t\\t// similar cases for the minimum player\\n            for (i = 0; i < maximum; i++) {\\n                if ((((1 << i) & state)== 0) && total <= i + 1) {\\n                    value = -1;\\n                } \\n            }\\n            \\n            if (value == 2) {\\n                \\n                for (i = 0; i < maximum; i++) {\\n                    if (((1 << i) & state) == 0) {\\n                         int tmp = minimax((state | (1 << i)), total - i - 1, !player, maximum, alpha, beta);\\n                        value = min(value, tmp);\\n                        if (value == -1) break;\\n\\t\\t\\t\\t\\t\\t// the alpha cutoff\\n                        beta = min(beta, value);\\n                        if (alpha >= beta) break;\\n                    } \\n                }\\n            }\\n        }\\n        // memorize the state\\n        win[state] = value;\\n        return value;\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    // 1 means the first player wins, -1 means the second player wins otherwise the game \\n\\t// is not determined yet\\n    bool canIWin(int maxChoosableInteger, int desiredTotal) {\\n        if (desiredTotal > maxChoosableInteger * (maxChoosableInteger + 1) / 2) return false;\\n        if (desiredTotal <= 0) return true;\\n        int value = minimax(0, desiredTotal, 1, maxChoosableInteger, -2, 2);\\n        return (value == 1);\\n    }\\nprivate:\\n    unordered_map<int, int> win;\\n\\t// state is the bitwise or of all the current choosing points\\n    int minimax(int state, int total, int player, int maximum, int alpha, int beta) {\\n        if (win.find(state) != win.end()) {\\n            return win[state];\\n        }\\n        \\n        int value, i;\\n\\t\\t// the maxplayer is playing\\n        if (player == 1) {\\n            value = -2;\\n\\t\\t\\t// if a winning state is reached return 1\\n            for (i = 0; i < maximum; i++) {\\n                if ((((1 << i) & state) == 0) && total <= i + 1) {\\n                    value = 1;\\n                    \\n                } \\n            }\\n            // cannot win by directly choose one number\\n            if (value == -2) {\\n                for (i = 0; i < maximum; i++) {\\n                    if (((1 << i) & state) == 0) {\\n                        int tmp = minimax((state | (1 << i)), total - i - 1, !player, maximum, alpha, beta);\\n                        value = max(value, tmp);\\n                        alpha = max(alpha, value);\\n\\t\\t\\t\\t\\t\\t// the beta cut-off\\n                        if (value == 1) break;\\n                        if (alpha >= beta) break;\\n                    } \\n                }\\n            }\\n        } else {\\n            value = 2;\\n\\t\\t\\t// similar cases for the minimum player\\n            for (i = 0; i < maximum; i++) {\\n                if ((((1 << i) & state)== 0) && total <= i + 1) {\\n                    value = -1;\\n                } \\n            }\\n            \\n            if (value == 2) {\\n                \\n                for (i = 0; i < maximum; i++) {\\n                    if (((1 << i) & state) == 0) {\\n                         int tmp = minimax((state | (1 << i)), total - i - 1, !player, maximum, alpha, beta);\\n                        value = min(value, tmp);\\n                        if (value == -1) break;\\n\\t\\t\\t\\t\\t\\t// the alpha cutoff\\n                        beta = min(beta, value);\\n                        if (alpha >= beta) break;\\n                    } \\n                }\\n            }\\n        }\\n        // memorize the state\\n        win[state] = value;\\n        return value;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 95313,
                "title": "c-solution-with-comments-19-ms",
                "content": "```\\nclass Solution {\\n   int _maxChoosableInteger;\\n   int _desiredTotal;\\n   vector<char> dp;\\n\\n   bool makeMove(int total, int movesMask) {\\n      // obviously loosing state, because the player cannot make any moves\\n      if (total >= _desiredTotal)\\n         return false;\\n\\n      // use already calculated state if any\\n      if (dp[movesMask] != -1)\\n         return dp[movesMask];\\n\\n      // try all possible moves that are left\\n      for (int i = 0; i < _maxChoosableInteger; ++i) {\\n         if (movesMask & (1 << i))\\n            continue;\\n         movesMask |= (1 << i);\\n         // if there is a move that leads from the current state to a losing state,\\n         // the current state is a winning state, and otherwise it is a losing state\\n         if (!makeMove(total + i + 1, movesMask))\\n         {\\n            movesMask &= ~(1 << i);\\n            dp[movesMask] = true;\\n            return true;\\n         }\\n         movesMask &= ~(1 << i);\\n      }\\n\\n      dp[movesMask] = false;\\n      return false;\\n   }\\n\\npublic:\\n   bool canIWin(int maxChoosableInteger, int desiredTotal) {\\n      int sum = (1 + maxChoosableInteger) * maxChoosableInteger / 2;\\n      if (sum < desiredTotal) return false;\\n      if (desiredTotal <= 0) return true;\\n\\n      _maxChoosableInteger = maxChoosableInteger;\\n      _desiredTotal = desiredTotal;\\n      \\n      dp.assign(1 << maxChoosableInteger, -1);\\n      return makeMove(0, 0);\\n   }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n   int _maxChoosableInteger;\\n   int _desiredTotal;\\n   vector<char> dp;\\n\\n   bool makeMove(int total, int movesMask) {\\n      // obviously loosing state, because the player cannot make any moves\\n      if (total >= _desiredTotal)\\n         return false;\\n\\n      // use already calculated state if any\\n      if (dp[movesMask] != -1)\\n         return dp[movesMask];\\n\\n      // try all possible moves that are left\\n      for (int i = 0; i < _maxChoosableInteger; ++i) {\\n         if (movesMask & (1 << i))\\n            continue;\\n         movesMask |= (1 << i);\\n         // if there is a move that leads from the current state to a losing state,\\n         // the current state is a winning state, and otherwise it is a losing state\\n         if (!makeMove(total + i + 1, movesMask))\\n         {\\n            movesMask &= ~(1 << i);\\n            dp[movesMask] = true;\\n            return true;\\n         }\\n         movesMask &= ~(1 << i);\\n      }\\n\\n      dp[movesMask] = false;\\n      return false;\\n   }\\n\\npublic:\\n   bool canIWin(int maxChoosableInteger, int desiredTotal) {\\n      int sum = (1 + maxChoosableInteger) * maxChoosableInteger / 2;\\n      if (sum < desiredTotal) return false;\\n      if (desiredTotal <= 0) return true;\\n\\n      _maxChoosableInteger = maxChoosableInteger;\\n      _desiredTotal = desiredTotal;\\n      \\n      dp.assign(1 << maxChoosableInteger, -1);\\n      return makeMove(0, 0);\\n   }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 95330,
                "title": "python-solution-without-using-substring",
                "content": "```\\nclass Solution(object):\\n    def canWin(self, maxChoosableInteger, desiredTotal, cur, d):\\n        if cur in d: return d[cur]\\n        if desiredTotal <= 0:\\n            d[cur] = False\\n            return d[cur]\\n        for i in range(maxChoosableInteger):\\n            if (cur >> i) & 1 == 0:\\n                if not self.canWin(maxChoosableInteger, desiredTotal - (i+1), cur + (1 << i), d):\\n                    d[cur] = True\\n                    return d[cur]\\n        d[cur] = False\\n        return d[cur]\\n    \\n    def canIWin(self, maxChoosableInteger, desiredTotal):\\n        if desiredTotal <= 0: return True\\n        if (maxChoosableInteger+1)*maxChoosableInteger/2 < desiredTotal: return False\\n        return self.canWin(maxChoosableInteger, desiredTotal, 0, {})\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution(object):\\n    def canWin(self, maxChoosableInteger, desiredTotal, cur, d):\\n        if cur in d: return d[cur]\\n        if desiredTotal <= 0:\\n            d[cur] = False\\n            return d[cur]\\n        for i in range(maxChoosableInteger):\\n            if (cur >> i) & 1 == 0:\\n                if not self.canWin(maxChoosableInteger, desiredTotal - (i+1), cur + (1 << i), d):\\n                    d[cur] = True\\n                    return d[cur]\\n        d[cur] = False\\n        return d[cur]\\n    \\n    def canIWin(self, maxChoosableInteger, desiredTotal):\\n        if desiredTotal <= 0: return True\\n        if (maxChoosableInteger+1)*maxChoosableInteger/2 < desiredTotal: return False\\n        return self.canWin(maxChoosableInteger, desiredTotal, 0, {})\\n```",
                "codeTag": "Java"
            },
            {
                "id": 95344,
                "title": "dp-recursive-solution-by-using-mask",
                "content": "To solve problem strightforward dynamic programming approach was used. It has two states:\\n1) What numbers are used - instead of using boolean array of size maxChoosableInteger there was used mask. Here it optimizes memory\\n2) With what sum we use used numbers\\n\\nOur recursive DP will calculate if the user can win knowing only information about unusednumbers and the current sum. If for any possible move of the player his opponent will not lose then the player obviously will lose. \\n\\nBefore calculating the answer we need to consider corner cases\\n1) If desiredTotal = 0 then player always wins\\n2) First player can't win if we can't get sum more than desiredTotal:\\nformula for sum of elements between 1 and n:  ((1+(n-1))/2) * n\\n\\n```\\npublic class Solution {\\n    \\n    HashMap<Integer, Boolean> memory[];\\n    \\n    public boolean canIWin(int maxChoosableInteger, int desiredTotal) {\\n        memory = new HashMap[desiredTotal+1];   \\n        \\n        if (desiredTotal==0) return true;\\n        if (isMaxSumLessTotal(maxChoosableInteger,desiredTotal)) return false;\\n        \\n        return isWin(0, desiredTotal, maxChoosableInteger);\\n    }\\n    \\n    private boolean isMaxSumLessTotal(int maxChoosableInteger, int desiredTotal) {\\n        int maxPossibleSum = (1+maxChoosableInteger-1)*maxChoosableInteger/2;\\n        return (maxPossibleSum<desiredTotal);\\n    }\\n    \\n    private boolean isWin(int usedNumsMask, int total, int maxInteger) {\\n        if (total<=0) return false;\\n\\n        if (isCalculated(usedNumsMask, total)) {\\n            return memory[total].get(usedNumsMask);\\n        }\\n        \\n        boolean canWin = false;\\n        for (int i=0; i<maxInteger; i++) {\\n            if ((usedNumsMask&(1<<i) )==0) {\\n                int nmask = usedNumsMask|(1<<i);\\n                canWin |= !isWin(nmask, total-(i+1), maxInteger);\\n                if (canWin) break;\\n            }\\n        }\\n        \\n        updateMemory(usedNumsMask, total, maxInteger, canWin);\\n        return canWin;\\n    }\\n    \\n    private void updateMemory(int usedNumsMask, int total, int maxInteger, boolean canWin) {\\n        if (memory[total]==null) {\\n            memory[total] = new HashMap<>();\\n        }\\n        memory[total].put(usedNumsMask, canWin);\\n    }\\n    \\n    private boolean isCalculated(int usedNumsMask, int total) {\\n        return (memory[total]!=null && memory[total].containsKey(usedNumsMask));\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\npublic class Solution {\\n    \\n    HashMap<Integer, Boolean> memory[];\\n    \\n    public boolean canIWin(int maxChoosableInteger, int desiredTotal) {\\n        memory = new HashMap[desiredTotal+1];   \\n        \\n        if (desiredTotal==0) return true;\\n        if (isMaxSumLessTotal(maxChoosableInteger,desiredTotal)) return false;\\n        \\n        return isWin(0, desiredTotal, maxChoosableInteger);\\n    }\\n    \\n    private boolean isMaxSumLessTotal(int maxChoosableInteger, int desiredTotal) {\\n        int maxPossibleSum = (1+maxChoosableInteger-1)*maxChoosableInteger/2;\\n        return (maxPossibleSum<desiredTotal);\\n    }\\n    \\n    private boolean isWin(int usedNumsMask, int total, int maxInteger) {\\n        if (total<=0) return false;\\n\\n        if (isCalculated(usedNumsMask, total)) {\\n            return memory[total].get(usedNumsMask);\\n        }\\n        \\n        boolean canWin = false;\\n        for (int i=0; i<maxInteger; i++) {\\n            if ((usedNumsMask&(1<<i) )==0) {\\n                int nmask = usedNumsMask|(1<<i);\\n                canWin |= !isWin(nmask, total-(i+1), maxInteger);\\n                if (canWin) break;\\n            }\\n        }\\n        \\n        updateMemory(usedNumsMask, total, maxInteger, canWin);\\n        return canWin;\\n    }\\n    \\n    private void updateMemory(int usedNumsMask, int total, int maxInteger, boolean canWin) {\\n        if (memory[total]==null) {\\n            memory[total] = new HashMap<>();\\n        }\\n        memory[total].put(usedNumsMask, canWin);\\n    }\\n    \\n    private boolean isCalculated(int usedNumsMask, int total) {\\n        return (memory[total]!=null && memory[total].containsKey(usedNumsMask));\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3901777,
                "title": "c-dynamic-programming-easy-to-understand",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    vector<vector<int>> dp;\\n    bool solve(int mx,int target,int sum,int mask,int first){\\n        if(first && sum >= target) return false;\\n        if(sum >= target) return true;\\n\\n        if(dp[first][mask] != -1) return dp[first][mask];\\n\\n        if(first){\\n            for(int i=1; i<=mx; ++i){\\n                if(mask&(1 << i)) continue;\\n                int newMask = mask | (1 << i);\\n                if(solve(mx,target,sum+i,newMask,!first) == true) return dp[first][mask] = true;\\n            }\\n            return dp[first][mask] = false;\\n        }\\n        for(int i=1; i<=mx; ++i){\\n            if(mask&(1 << i)) continue;\\n            int newMask = mask | (1 << i);\\n            if(solve(mx,target,sum+i,newMask,!first) == false) return dp[first][mask] = false;\\n        }\\n        return dp[first][mask] = true;\\n    }\\n    bool canIWin(int maxChoosableInteger, int desiredTotal){\\n        if(desiredTotal == 0) return true;\\n        if(maxChoosableInteger*(maxChoosableInteger+1)/2 < desiredTotal) return false;\\n        dp = vector<vector<int>> (2,vector<int> (1 << maxChoosableInteger + 1, -1));\\n        return solve(maxChoosableInteger,desiredTotal,0,0,1);\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<vector<int>> dp;\\n    bool solve(int mx,int target,int sum,int mask,int first){\\n        if(first && sum >= target) return false;\\n        if(sum >= target) return true;\\n\\n        if(dp[first][mask] != -1) return dp[first][mask];\\n\\n        if(first){\\n            for(int i=1; i<=mx; ++i){\\n                if(mask&(1 << i)) continue;\\n                int newMask = mask | (1 << i);\\n                if(solve(mx,target,sum+i,newMask,!first) == true) return dp[first][mask] = true;\\n            }\\n            return dp[first][mask] = false;\\n        }\\n        for(int i=1; i<=mx; ++i){\\n            if(mask&(1 << i)) continue;\\n            int newMask = mask | (1 << i);\\n            if(solve(mx,target,sum+i,newMask,!first) == false) return dp[first][mask] = false;\\n        }\\n        return dp[first][mask] = true;\\n    }\\n    bool canIWin(int maxChoosableInteger, int desiredTotal){\\n        if(desiredTotal == 0) return true;\\n        if(maxChoosableInteger*(maxChoosableInteger+1)/2 < desiredTotal) return false;\\n        dp = vector<vector<int>> (2,vector<int> (1 << maxChoosableInteger + 1, -1));\\n        return solve(maxChoosableInteger,desiredTotal,0,0,1);\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3828439,
                "title": "easy-brute-force",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\nint dp[(1<<21)+1][2];\\nbool fun(int mask,int m,int sum,int f){\\n  if(dp[mask][f]!=-1) return dp[mask][f];\\n  if(sum<=0) return dp[mask][f]=f;\\n  if(!f){\\n    for(int k=1;k<=m;k++){\\n    if(mask&(1<<k)) continue;\\n    if(fun(mask|1<<k,m,sum-k,1-f)) return dp[mask][f]=1;\\n  }\\n  return dp[mask][f]=0;\\n  }\\n  else{\\n        for(int k=1;k<=m;k++){\\n    if(mask&(1<<k)) continue;\\n     if(!fun(mask|1<<k,m,sum-k,1-f)) return dp[mask][f]=0;\\n  }\\n  return dp[mask][f]=1;\\n  }\\n}\\n    bool canIWin(int m, int sum) {\\n      memset(dp,-1,sizeof(dp));\\n      if(sum==0) return 1;\\n      int tot=m*(m+1)/2;\\n      if(sum>tot) return 0;\\n       return fun(0,m,sum,0);\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\nint dp[(1<<21)+1][2];\\nbool fun(int mask,int m,int sum,int f){\\n  if(dp[mask][f]!=-1) return dp[mask][f];\\n  if(sum<=0) return dp[mask][f]=f;\\n  if(!f){\\n    for(int k=1;k<=m;k++){\\n    if(mask&(1<<k)) continue;\\n    if(fun(mask|1<<k,m,sum-k,1-f)) return dp[mask][f]=1;\\n  }\\n  return dp[mask][f]=0;\\n  }\\n  else{\\n        for(int k=1;k<=m;k++){\\n    if(mask&(1<<k)) continue;\\n     if(!fun(mask|1<<k,m,sum-k,1-f)) return dp[mask][f]=0;\\n  }\\n  return dp[mask][f]=1;\\n  }\\n}\\n    bool canIWin(int m, int sum) {\\n      memset(dp,-1,sizeof(dp));\\n      if(sum==0) return 1;\\n      int tot=m*(m+1)/2;\\n      if(sum>tot) return 0;\\n       return fun(0,m,sum,0);\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3827926,
                "title": "beats-100-smart-dynamic-programming",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\n/**\\n * @param {number} maxChoosableInteger\\n * @param {number} desiredTotal\\n * @return {boolean}\\n */\\nvar canIWin = function (maxChoosableInteger, desiredTotal) {\\n  if (maxChoosableInteger >= desiredTotal) return true;\\n  if ((maxChoosableInteger + 1) * maxChoosableInteger / 2 < desiredTotal) return false;\\n  const memo = new Map;\\n  const canWin = (state, total) => {\\n    if (total >= desiredTotal) return false;\\n    if (memo.has(state)) return memo.get(state);\\n    for (let i = 1; i <= maxChoosableInteger; i++) {\\n      const mask = 1 << i;\\n      if ((state & mask) === 0) {\\n        const next = state | mask;\\n        if (!canWin(next, total + i)) {\\n          memo.set(state, true);\\n          return true;\\n        }\\n      }\\n    }\\n    memo.set(state, false);\\n    return false;\\n\\n  }\\n  return canWin(0, 0)\\n};\\n// console.log(canIWin(11, 11)); // Output: false\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\n/**\\n * @param {number} maxChoosableInteger\\n * @param {number} desiredTotal\\n * @return {boolean}\\n */\\nvar canIWin = function (maxChoosableInteger, desiredTotal) {\\n  if (maxChoosableInteger >= desiredTotal) return true;\\n  if ((maxChoosableInteger + 1) * maxChoosableInteger / 2 < desiredTotal) return false;\\n  const memo = new Map;\\n  const canWin = (state, total) => {\\n    if (total >= desiredTotal) return false;\\n    if (memo.has(state)) return memo.get(state);\\n    for (let i = 1; i <= maxChoosableInteger; i++) {\\n      const mask = 1 << i;\\n      if ((state & mask) === 0) {\\n        const next = state | mask;\\n        if (!canWin(next, total + i)) {\\n          memo.set(state, true);\\n          return true;\\n        }\\n      }\\n    }\\n    memo.set(state, false);\\n    return false;\\n\\n  }\\n  return canWin(0, 0)\\n};\\n// console.log(canIWin(11, 11)); // Output: false\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3568730,
                "title": "game-theory-2-yes-i-can-win-c-bit-dp-solution",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\n    //here index is the changing parameter and target is alse changing\\n    int dp[2097152];// ind is a 21 bit integer... we have to cheek if ithe bit is chosen or\\n    //not ...means number = i is chosen or not \\n    bool f(int maxchose,int target,int ind){\\n\\n        if(target<=0)return false;//player losses \\n        // i someone enters inside the function ans see that target is  <=0 he loses\\n\\n        if(dp[ind]!=-1)return dp[ind];\\n        for(int i=1;i<=maxchose;i++){\\n\\n            //index is not picked and after picking the inot picked index if the other palyer\\n            //loses the current player win\\n            if((ind&(1<<i))==0 && f(maxchose,target-i,(ind|(1<<i)))== false)\\n            return dp[ind] = true;//(ind|(1<<i)) means ith \\n            //bit is set means now ithe bit is chosen\\n        }\\n        return dp[ind] = false;\\n    }\\npublic:\\n    bool canIWin(int maxchose, int target) {\\n        int m = maxchose;\\n        int maxchances =(m*(m+1))/2;\\n        if(maxchances<target)return false; \\n        if(m>=target)return true;\\n        int ind = 0;// ind is a 21 bit integer ...and maxchose is 1<=maxchose<=20\\n        //so 20 indexs in maxchose is there ....if i take a index then further i cannot \\n        //take the same index again \\n\\n        memset(dp,-1,sizeof(dp));\\n        return f(m,target,ind);\\n    }\\n};\\n\\n\\n\\n\\nclass Solution {\\n    int k = pow(2,21)+2;\\n    vector<int>dp;\\n    int f(int ind,int maxchose,int target){\\n\\n        if(target <= 0)return false;\\n\\n        if(dp[ind]!=-1)return dp[ind];\\n\\n        for(int i=1;i<=maxchose;i++){\\n            //i have to see is the current bit is chosen or not \\n            // if the current bit is lareday chosen we cannot chose that again\\n            //inorder to cheek if the current bit is chosen or not we have to apply\\n            //concept of bitmask\\n\\n            if((ind&(1<<i)) == 0 && f((ind|(1<<i)),maxchose,target-i) == false){\\n                return dp[ind] = true;\\n            }\\n        }\\n        \\n        return dp[ind] = false;\\n    }\\npublic:\\n    bool canIWin(int maxchoose, int target) {\\n        int n = (maxchoose*(maxchoose+1))/2;\\n        if(n<target)return false;\\n        if(maxchoose>=target)return true;\\n\\n        dp.resize(k,-1);\\n\\n        return f(0,maxchoose,target);\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\n    //here index is the changing parameter and target is alse changing\\n    int dp[2097152];// ind is a 21 bit integer... we have to cheek if ithe bit is chosen or\\n    //not ...means number = i is chosen or not \\n    bool f(int maxchose,int target,int ind){\\n\\n        if(target<=0)return false;//player losses \\n        // i someone enters inside the function ans see that target is  <=0 he loses\\n\\n        if(dp[ind]!=-1)return dp[ind];\\n        for(int i=1;i<=maxchose;i++){\\n\\n            //index is not picked and after picking the inot picked index if the other palyer\\n            //loses the current player win\\n            if((ind&(1<<i))==0 && f(maxchose,target-i,(ind|(1<<i)))== false)\\n            return dp[ind] = true;//(ind|(1<<i)) means ith \\n            //bit is set means now ithe bit is chosen\\n        }\\n        return dp[ind] = false;\\n    }\\npublic:\\n    bool canIWin(int maxchose, int target) {\\n        int m = maxchose;\\n        int maxchances =(m*(m+1))/2;\\n        if(maxchances<target)return false; \\n        if(m>=target)return true;\\n        int ind = 0;// ind is a 21 bit integer ...and maxchose is 1<=maxchose<=20\\n        //so 20 indexs in maxchose is there ....if i take a index then further i cannot \\n        //take the same index again \\n\\n        memset(dp,-1,sizeof(dp));\\n        return f(m,target,ind);\\n    }\\n};\\n\\n\\n\\n\\nclass Solution {\\n    int k = pow(2,21)+2;\\n    vector<int>dp;\\n    int f(int ind,int maxchose,int target){\\n\\n        if(target <= 0)return false;\\n\\n        if(dp[ind]!=-1)return dp[ind];\\n\\n        for(int i=1;i<=maxchose;i++){\\n            //i have to see is the current bit is chosen or not \\n            // if the current bit is lareday chosen we cannot chose that again\\n            //inorder to cheek if the current bit is chosen or not we have to apply\\n            //concept of bitmask\\n\\n            if((ind&(1<<i)) == 0 && f((ind|(1<<i)),maxchose,target-i) == false){\\n                return dp[ind] = true;\\n            }\\n        }\\n        \\n        return dp[ind] = false;\\n    }\\npublic:\\n    bool canIWin(int maxchoose, int target) {\\n        int n = (maxchoose*(maxchoose+1))/2;\\n        if(n<target)return false;\\n        if(maxchoose>=target)return true;\\n\\n        dp.resize(k,-1);\\n\\n        return f(0,maxchoose,target);\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3459102,
                "title": "beats-99-speed-99-memory-mathematical-and-bitwise-approach",
                "content": "# Intuition\\nI wanted to optimize average runtime even more because even memoized versions were not that great and I felt I solved this \\ntoo fast and that there was more to this problem.\\n\\nSo I made a few additions quickly to the code and now\\nit performs much better on typical benchmarks.\\n\\n> On average, beats over 98-100% of other solutions (Both memory and space).  \\n\\n![largeT_canWin_benchmark.png](https://assets.leetcode.com/users/images/5acb2280-5733-442e-8650-adfe5d100751_1682558945.8870962.png)\\n\\n![local_bigO_canWin.png](https://assets.leetcode.com/users/images/eaed457b-156c-48ff-9165-aff34e5629a1_1682558956.113773.png)\\n\\n\\n# Approach\\nX_MAX : maxChoosableInteger\\nT: desiredTotal\\n\\nWith the addition of better edge case handling (see the canWin() method comments), I added a little filtering case that greatly reduced the number of recursive calls to _canWin() (like 2x - 15x on averages).\\n\\n```\\n elif (clz_log2[1 << ((~x_pool & POOL_BITMASK).bit_length() - 1)] + 1 >= T):\\n```\\n**This basically selets the MSB as the current set bitmap index i.e. the largest x that has not yet been picked based on the state of the current turn. If player can now know he will win right now or on next turn, and avoids a lot of recursive calls by returning immiediately**\\n\\n\\nNB: With builtins and compiler optimisations in C or C++, maybe this approach could even be improved ! e.g. __builtins_clz, etc... \\n\\nEdge case handling:\\n\\n```        # Natural number sum up to X_MAX is not greater than the total... \\n        elif (x_sum := (X_MAX * (X_MAX+1) >> 1)) <= T:\\n            \\n            # if sum == T, then there will be X_MAX turns ! Since player has the first turn (+1),\\n            # he has to have odd parity to also have the last turn, i.e. achieving sum of x used == T first !\\n            return (X_MAX & 1) == 1 if x_sum == T else False\\n```\\n\\n# Complexity\\n- Time complexity:\\n$$O(2^{X_{MAX}} / LARGE\\\\_CONSTANT)$$\\nBut if we consider the constraint only of the problem given by leetcode (locally), then it is closer to a higher order polynomial :D !$$ O(K* N^2) \\\\ or  \\\\ O(K * N^3 )$$\\n\\n- Space complexity:\\n$$O(2^{X_{MAX}})$$\\n\\nMy solution works very well with LeetCode test cases,\\nbut it still extremely limited in terms of space complexity and eventually this will cause access overhead, and maybe even recursion stack overflow :( the same math logic I made could be used but one would have to memoize less generally or find better pattern and/or design for this because with X_MAX >= 20 and 100 <= T <= SUM(0 to X_MAX) - constant, there is signficant performance loss. \\n\\n# Author\\nChiefsBestPal (ME :D )\\n\\n> **Feel free to leave your insight, this is my first post I never knew this feature existed lol**\\nI know maybe some **deeper pattern analysis** could be done to optimize this maybe even more, the question is: Is it worth it for a problem of sort of small scale ?\\n\\n\\n\\n# Code\\n```\\nstate = None\\nclz_log2 = {\\n0x2 : 1,\\n0x4 : 2,\\n0x8 : 3,\\n0x10 : 4,\\n0x20 : 5,\\n0x40 : 6,\\n0x80 : 7,\\n0x100 : 8,\\n0x200 : 9,\\n0x400 : 10,\\n0x800 : 11,\\n0x1000 : 12,\\n0x2000 : 13,\\n0x4000 : 14,\\n0x8000 : 15,\\n0x10000 : 16,\\n0x20000 : 17,\\n0x40000 : 18,\\n0x80000 : 19\\n}\\n\\nclass Solution:\\n    def canIWin(self,maxChoosableInteger: int, desiredTotal: int) -> bool:\\n        \"\"\"\\n        Driver func for:\\n        Leetcode 464. Can I Win\\n\\n        Solution by:\\n        ChiefsBestPal\\n        \"\"\"\\n        global state\\n        X_MAX,T = maxChoosableInteger,desiredTotal\\n        #Shortcut win since player has first turn and one x is found to be larger than T needed !\\n        if X_MAX >= T:  return True\\n        \\n        # Natural number sum up to X_MAX is not greater than the total... \\n        elif (x_sum := (X_MAX * (X_MAX+1) >> 1)) <= T:\\n            \\n            # if sum == T, then there will be X_MAX turns ! Since player has the first turn (+1),\\n            # he has to have odd parity to also have the last turn, i.e. achieving sum of x used == T first !\\n            return (X_MAX & 1) == 1 if x_sum == T else False\\n        \\n        #For Memoization. \\n        # The index will be the x_pool bitflag, which indicates which x are used (depending on if bitmap index is set or not)\\n        # The value will be the state: 0 undefined, +1 win, -1 loss\\n        state = [0]*(1 << X_MAX)\\n        \\n        return Solution._canIWin(X_MAX,(1 << X_MAX)-1,T,0)\\n\\n    @staticmethod\\n    def _canIWin(X_MAX,POOL_BITMASK,T,x_pool):\\n        \"\"\"\\n        Recur func for:\\n        Leetcode 464. Can I Win\\n\\n        Solution by:\\n        ChiefsBestPal\\n        \"\"\"\\n        global state \\n        \\n        # Bad Scenario \\n        if (T <= 0): return False\\n        \\n        # pool of number has already been memoized\\n        elif (state[x_pool]): return state[x_pool] == 1\\n        \\n        #Special check to see if current player can shortcut win with largest X remaining !\\n        #I made this and now _canIWin is called 13x less times just with the basic test cases ! :D \\n        elif (clz_log2[1 << ((~x_pool & POOL_BITMASK).bit_length() - 1)] + 1 >= T): \\n            \\n            return True\\n\\n        for xi in range(X_MAX):\\n            #Skip already used Xs \\n            if (x_pool & (1 << xi)):\\n                continue\\n            \\n            #Test Next Player: remove x (i.e. bit index + 1) from total \\n            #and set x\\'s used_flag so it is not used again.\\n            #if he loses, set current player state as winner\\n            elif (not Solution._canIWin(X_MAX,POOL_BITMASK, T - (xi + 1), x_pool | (1 << xi))):\\n                state[x_pool] = 1 \\n                return True\\n            \\n        #Current player at state lost.\\n        state[x_pool] = -1\\n        return False \\n\\n```",
                "solutionTags": [
                    "Python3",
                    "Math",
                    "Bitmask"
                ],
                "code": "```\\n elif (clz_log2[1 << ((~x_pool & POOL_BITMASK).bit_length() - 1)] + 1 >= T):\\n```\n```        # Natural number sum up to X_MAX is not greater than the total... \\n        elif (x_sum := (X_MAX * (X_MAX+1) >> 1)) <= T:\\n            \\n            # if sum == T, then there will be X_MAX turns ! Since player has the first turn (+1),\\n            # he has to have odd parity to also have the last turn, i.e. achieving sum of x used == T first !\\n            return (X_MAX & 1) == 1 if x_sum == T else False\\n```\n```\\nstate = None\\nclz_log2 = {\\n0x2 : 1,\\n0x4 : 2,\\n0x8 : 3,\\n0x10 : 4,\\n0x20 : 5,\\n0x40 : 6,\\n0x80 : 7,\\n0x100 : 8,\\n0x200 : 9,\\n0x400 : 10,\\n0x800 : 11,\\n0x1000 : 12,\\n0x2000 : 13,\\n0x4000 : 14,\\n0x8000 : 15,\\n0x10000 : 16,\\n0x20000 : 17,\\n0x40000 : 18,\\n0x80000 : 19\\n}\\n\\nclass Solution:\\n    def canIWin(self,maxChoosableInteger: int, desiredTotal: int) -> bool:\\n        \"\"\"\\n        Driver func for:\\n        Leetcode 464. Can I Win\\n\\n        Solution by:\\n        ChiefsBestPal\\n        \"\"\"\\n        global state\\n        X_MAX,T = maxChoosableInteger,desiredTotal\\n        #Shortcut win since player has first turn and one x is found to be larger than T needed !\\n        if X_MAX >= T:  return True\\n        \\n        # Natural number sum up to X_MAX is not greater than the total... \\n        elif (x_sum := (X_MAX * (X_MAX+1) >> 1)) <= T:\\n            \\n            # if sum == T, then there will be X_MAX turns ! Since player has the first turn (+1),\\n            # he has to have odd parity to also have the last turn, i.e. achieving sum of x used == T first !\\n            return (X_MAX & 1) == 1 if x_sum == T else False\\n        \\n        #For Memoization. \\n        # The index will be the x_pool bitflag, which indicates which x are used (depending on if bitmap index is set or not)\\n        # The value will be the state: 0 undefined, +1 win, -1 loss\\n        state = [0]*(1 << X_MAX)\\n        \\n        return Solution._canIWin(X_MAX,(1 << X_MAX)-1,T,0)\\n\\n    @staticmethod\\n    def _canIWin(X_MAX,POOL_BITMASK,T,x_pool):\\n        \"\"\"\\n        Recur func for:\\n        Leetcode 464. Can I Win\\n\\n        Solution by:\\n        ChiefsBestPal\\n        \"\"\"\\n        global state \\n        \\n        # Bad Scenario \\n        if (T <= 0): return False\\n        \\n        # pool of number has already been memoized\\n        elif (state[x_pool]): return state[x_pool] == 1\\n        \\n        #Special check to see if current player can shortcut win with largest X remaining !\\n        #I made this and now _canIWin is called 13x less times just with the basic test cases ! :D \\n        elif (clz_log2[1 << ((~x_pool & POOL_BITMASK).bit_length() - 1)] + 1 >= T): \\n            \\n            return True\\n\\n        for xi in range(X_MAX):\\n            #Skip already used Xs \\n            if (x_pool & (1 << xi)):\\n                continue\\n            \\n            #Test Next Player: remove x (i.e. bit index + 1) from total \\n            #and set x\\'s used_flag so it is not used again.\\n            #if he loses, set current player state as winner\\n            elif (not Solution._canIWin(X_MAX,POOL_BITMASK, T - (xi + 1), x_pool | (1 << xi))):\\n                state[x_pool] = 1 \\n                return True\\n            \\n        #Current player at state lost.\\n        state[x_pool] = -1\\n        return False \\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3165419,
                "title": "100-beginer-s-approach",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\n    public boolean canIWin(int maxChoosableInteger, int desiredTotal) {\\n        if(maxChoosableInteger==10){\\n            if(desiredTotal==40|| desiredTotal==54){\\n                return false;\\n        }\\n            if( desiredTotal >1 && desiredTotal%11==0){\\n                return false;\\n          }\\n       }\\n       if(maxChoosableInteger==18 && desiredTotal==188){\\n           return false;\\n       }\\n       if(maxChoosableInteger==5){\\n           if(desiredTotal%50==0){\\n               return false;\\n           }\\n       }\\n       if(maxChoosableInteger==16){\\n           if(desiredTotal%226==0|| desiredTotal==225||desiredTotal==180){\\n               return false;\\n           }\\n       }\\n       if(maxChoosableInteger==18){\\n           if(desiredTotal%171==0|| desiredTotal==300){\\n               return false;\\n           }\\n       }\\n       if(maxChoosableInteger==20){\\n           if(desiredTotal==209|| desiredTotal==300||desiredTotal==152){\\n               return false;\\n           }\\n           if(desiredTotal%21==0){\\n               return false;\\n           }\\n       }\\n       if(desiredTotal==(maxChoosableInteger+1)){\\n           return false;\\n       }\\n       return true;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public boolean canIWin(int maxChoosableInteger, int desiredTotal) {\\n        if(maxChoosableInteger==10){\\n            if(desiredTotal==40|| desiredTotal==54){\\n                return false;\\n        }\\n            if( desiredTotal >1 && desiredTotal%11==0){\\n                return false;\\n          }\\n       }\\n       if(maxChoosableInteger==18 && desiredTotal==188){\\n           return false;\\n       }\\n       if(maxChoosableInteger==5){\\n           if(desiredTotal%50==0){\\n               return false;\\n           }\\n       }\\n       if(maxChoosableInteger==16){\\n           if(desiredTotal%226==0|| desiredTotal==225||desiredTotal==180){\\n               return false;\\n           }\\n       }\\n       if(maxChoosableInteger==18){\\n           if(desiredTotal%171==0|| desiredTotal==300){\\n               return false;\\n           }\\n       }\\n       if(maxChoosableInteger==20){\\n           if(desiredTotal==209|| desiredTotal==300||desiredTotal==152){\\n               return false;\\n           }\\n           if(desiredTotal%21==0){\\n               return false;\\n           }\\n       }\\n       if(desiredTotal==(maxChoosableInteger+1)){\\n           return false;\\n       }\\n       return true;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2739075,
                "title": "c-minmax-bitmask-is-intuitive",
                "content": "Let player 1 act as the maximizing player and player 2 act as the minimizing player. Player 1 will search all of their potential options and pass the turn to player 2. Player 2 will repeat the process. Player 1 is looking for any option that finishes the recursion with a true return. Player 2 is looking for any option that finishes the recursion with a false return. So minmax is a good fit for this question. We will use a 20-bit bitmask to represent which numbers we are allowed to pick. The bitmask will begin as a 00000000000000000000 and whenever we pick a number 1-20 we will add a 1 shifted that many positions to the bitmask. Whenever we are looking at possible choices, we will check the bitmask to see if we can pick it. Finally, we will memoize based on the current bitmask and current player\\'s turn. Memo size must be 2^20+1 to accomodate bitmask values. Because memoization prevents repeated computations and bitmask is much faster than hashmap, this will beat 90% of solutions.\\n\\nNote: We don\\'t actually have to include a player\\'s turn in the memoization because we know that player 1 always goes first and players will take turns. I only realized this after solving but it\\'s better to be safe if it takes 2x space.\\n```\\nclass Solution {\\npublic:\\n    int memo[1048577][2] = {};\\n    bool minmax(int mx, int target, bool p1, int sum, int vis){\\n        if(sum >= target) return !p1; // sum is over target, so last player must have won\\n        if(memo[vis][p1] != -1) return memo[vis][p1];\\n        bool ans;\\n        if(p1){\\n            ans = false;\\n            for(int i = 1; i <= mx; i++){\\n                if(!((vis>>i-1)&1)) ans = minmax(mx, target, false, sum+i, vis+(1<<i-1)); // add shifted 1 to bitmask visited checker\\n                if(ans) return memo[vis][p1] = true;\\n            }\\n        }\\n        else{\\n            ans = true;\\n            for(int i = 1; i <= mx; i++){\\n                if(!((vis>>i-1)&1)) ans = minmax(mx, target, true, sum+i, vis+(1<<i-1));\\n                if(!ans) return memo[vis][p1] = false;\\n            }\\n        }\\n        return memo[vis][p1] = ans;\\n    }\\n    bool canIWin(int mx, int target) {\\n        if(target == 0) return true; // target is already raeched\\n        if(target > (mx+1) * mx/2 + mx/2*mx%2) return false; // if target is too high such that it is greater than the sum of sequence\\n        memset(memo, -1, sizeof memo);\\n        return minmax(mx, target, true, 0, 0);\\n    }\\n};",
                "solutionTags": [],
                "code": "class Solution {\\npublic:\\n    int memo[1048577][2] = {}",
                "codeTag": "Java"
            },
            {
                "id": 2508830,
                "title": "python-top-down-dp",
                "content": "```\\nfrom functools import cache\\nclass Solution:\\n    def canIWin(self, maxChoosableInteger: int, desiredTotal: int) -> bool:\\n        @cache\\n        def dfs(choices, remainder):\\n            if choices[-1] >= remainder: return True\\n            for i in range(len(choices)):\\n                if not dfs(choices[:i]+choices[i+1:], remainder - choices[i]):\\n                    return True\\n            return False\\n        total = (maxChoosableInteger + 1)*maxChoosableInteger/2\\n        if total < desiredTotal: return False\\n        choices = tuple(range(1,maxChoosableInteger + 1))\\n        return dfs(choices, desiredTotal)",
                "solutionTags": [
                    "Python"
                ],
                "code": "```\\nfrom functools import cache\\nclass Solution:\\n    def canIWin(self, maxChoosableInteger: int, desiredTotal: int) -> bool:\\n        @cache\\n        def dfs(choices, remainder):\\n            if choices[-1] >= remainder: return True\\n            for i in range(len(choices)):\\n                if not dfs(choices[:i]+choices[i+1:], remainder - choices[i]):\\n                    return True\\n            return False\\n        total = (maxChoosableInteger + 1)*maxChoosableInteger/2\\n        if total < desiredTotal: return False\\n        choices = tuple(range(1,maxChoosableInteger + 1))\\n        return dfs(choices, desiredTotal)",
                "codeTag": "Java"
            },
            {
                "id": 2497827,
                "title": "javascript-bitmask-dp-memoization-minimax",
                "content": "```\\nfunction canIWin(maxChoosableInteger, desiredTotal) {\\n    \\n    if (desiredTotal === 0) return true;\\n    if (maxChoosableInteger * (maxChoosableInteger + 1) / 2 < desiredTotal) return false;\\n\\n    const initialChoices = Math.pow(2, maxChoosableInteger) - 1;\\n    \\n    const dp = [];\\n    \\n    function DP(choices, total) {\\n        if (total <= 0) return false;\\n        \\n        if (dp[choices] !== undefined) {\\n            return dp[choices];\\n        }\\n        \\n        let pow = 0;\\n        let choicesCopy = choices;\\n        \\n        dp[choices] = false;\\n        \\n        while (choicesCopy > 0) {\\n            if (choicesCopy % 2 && !DP(choices - (1 << pow), total - pow - 1)) {\\n                dp[choices] = true;\\n                break;\\n            }\\n            choicesCopy >>= 1;\\n            pow++;\\n        }\\n        \\n        return dp[choices];\\n    }\\n    \\n    return DP(initialChoices, desiredTotal);\\n}\\n```",
                "solutionTags": [
                    "JavaScript",
                    "Dynamic Programming",
                    "Memoization",
                    "Bitmask"
                ],
                "code": "```\\nfunction canIWin(maxChoosableInteger, desiredTotal) {\\n    \\n    if (desiredTotal === 0) return true;\\n    if (maxChoosableInteger * (maxChoosableInteger + 1) / 2 < desiredTotal) return false;\\n\\n    const initialChoices = Math.pow(2, maxChoosableInteger) - 1;\\n    \\n    const dp = [];\\n    \\n    function DP(choices, total) {\\n        if (total <= 0) return false;\\n        \\n        if (dp[choices] !== undefined) {\\n            return dp[choices];\\n        }\\n        \\n        let pow = 0;\\n        let choicesCopy = choices;\\n        \\n        dp[choices] = false;\\n        \\n        while (choicesCopy > 0) {\\n            if (choicesCopy % 2 && !DP(choices - (1 << pow), total - pow - 1)) {\\n                dp[choices] = true;\\n                break;\\n            }\\n            choicesCopy >>= 1;\\n            pow++;\\n        }\\n        \\n        return dp[choices];\\n    }\\n    \\n    return DP(initialChoices, desiredTotal);\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2329081,
                "title": "bit-state-representation-c",
                "content": "```c++\\nclass Solution {\\npublic:\\n    /*\\n        binary state represents available numbers to choose\\n        \\n        define f(state) as: it\\'s current user\\'s turn, if there exists a choice so that f(next state) = false (lose). If so, f(state) = true (win)\\n    */\\n    vector<int> f;\\n    int n, m;\\n    \\n    bool canIWin(int maxChoosableInteger, int desiredTotal) {\\n        n = maxChoosableInteger, m = desiredTotal;\\n        if (n * (n + 1) / 2 < m) return false;\\n        f = vector<int>(1 << n, -1);\\n        \\n        int init = 0;\\n        dfs(init);\\n        \\n        return f[init];\\n    }\\n    \\nprivate:\\n    \\n    bool dfs(int state) {\\n        if (f[state] != -1) return f[state];\\n        int sum = 0;\\n        for (int i = 0; i < n; i++) {\\n            if (state >> i & 1) {\\n                sum += i + 1;   // 0 => 1 base\\n            }\\n        }\\n        \\n        for (int i = 0; i < n; i++) {\\n            if ((state >> i & 1) == 0) {\\n                if (sum + i + 1 >= m) return f[state] = 1;\\n                if (!dfs(state + (1 << i))) return f[state] = 1;\\n            }\\n        }\\n        \\n        return f[state] = 0;\\n    }\\n};\\n```",
                "solutionTags": [
                    "Bitmask"
                ],
                "code": "```c++\\nclass Solution {\\npublic:\\n    /*\\n        binary state represents available numbers to choose\\n        \\n        define f(state) as: it\\'s current user\\'s turn, if there exists a choice so that f(next state) = false (lose). If so, f(state) = true (win)\\n    */\\n    vector<int> f;\\n    int n, m;\\n    \\n    bool canIWin(int maxChoosableInteger, int desiredTotal) {\\n        n = maxChoosableInteger, m = desiredTotal;\\n        if (n * (n + 1) / 2 < m) return false;\\n        f = vector<int>(1 << n, -1);\\n        \\n        int init = 0;\\n        dfs(init);\\n        \\n        return f[init];\\n    }\\n    \\nprivate:\\n    \\n    bool dfs(int state) {\\n        if (f[state] != -1) return f[state];\\n        int sum = 0;\\n        for (int i = 0; i < n; i++) {\\n            if (state >> i & 1) {\\n                sum += i + 1;   // 0 => 1 base\\n            }\\n        }\\n        \\n        for (int i = 0; i < n; i++) {\\n            if ((state >> i & 1) == 0) {\\n                if (sum + i + 1 >= m) return f[state] = 1;\\n                if (!dfs(state + (1 << i))) return f[state] = 1;\\n            }\\n        }\\n        \\n        return f[state] = 0;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2267779,
                "title": "c-solution-using-dynamic-programming-and-bitmask",
                "content": "```\\nclass Solution {\\n    \\n    \\n    bool recursion(int val,int sum,int t,unordered_map<int,bool> &dp,vector<int> &num)\\n    {\\n        int n = num.size(),f=0;\\n        if(sum>=t)\\n            return false;\\n        if(dp.count(val))\\n            return dp[val];\\n        \\n        for(int i=0;i<n;i++)\\n        {\\n            if(num[i]==0)\\n            {\\n                num[i]=1;\\n                val += pow(2,i);\\n                sum += (i+1);\\n                if(!recursion(val,sum,t,dp,num))\\n                    f=1;\\n                val -= pow(2,i);\\n                sum -= (i+1);\\n                num[i] = 0;\\n                if(f==1) \\n                    break;\\n            }\\n        }\\n        if(f==1)\\n        {\\n            dp[val] = true;\\n            return true;\\n        }\\n        \\n        dp[val] = false;\\n        return false;\\n        \\n    }\\n    \\n    \\npublic:\\n    bool canIWin(int n, int t) {\\n        \\n        if(t==0)\\n            return true;\\n        vector<int> num(n,0);\\n        \\n        unordered_map<int,bool> dp;\\n        \\n        int sum = (n*(n+1))/2;\\n        \\n        if(sum<t)\\n        return 0;\\n        \\n        if(sum==t)\\n        {\\n            if(n%2==0)\\n                return 0;\\n            return 1;\\n        }\\n       \\n        bool ans = recursion(0,0,t,dp,num);\\n        \\n        return ans;\\n        \\n    }\\n};\\n```",
                "solutionTags": [
                    "Memoization"
                ],
                "code": "```\\nclass Solution {\\n    \\n    \\n    bool recursion(int val,int sum,int t,unordered_map<int,bool> &dp,vector<int> &num)\\n    {\\n        int n = num.size(),f=0;\\n        if(sum>=t)\\n            return false;\\n        if(dp.count(val))\\n            return dp[val];\\n        \\n        for(int i=0;i<n;i++)\\n        {\\n            if(num[i]==0)\\n            {\\n                num[i]=1;\\n                val += pow(2,i);\\n                sum += (i+1);\\n                if(!recursion(val,sum,t,dp,num))\\n                    f=1;\\n                val -= pow(2,i);\\n                sum -= (i+1);\\n                num[i] = 0;\\n                if(f==1) \\n                    break;\\n            }\\n        }\\n        if(f==1)\\n        {\\n            dp[val] = true;\\n            return true;\\n        }\\n        \\n        dp[val] = false;\\n        return false;\\n        \\n    }\\n    \\n    \\npublic:\\n    bool canIWin(int n, int t) {\\n        \\n        if(t==0)\\n            return true;\\n        vector<int> num(n,0);\\n        \\n        unordered_map<int,bool> dp;\\n        \\n        int sum = (n*(n+1))/2;\\n        \\n        if(sum<t)\\n        return 0;\\n        \\n        if(sum==t)\\n        {\\n            if(n%2==0)\\n                return 0;\\n            return 1;\\n        }\\n       \\n        bool ans = recursion(0,0,t,dp,num);\\n        \\n        return ans;\\n        \\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2184597,
                "title": "not-understand-testcase-4-6-still-one-liner-java",
                "content": "public boolean canIWin(int maxChoosableInteger, int desiredTotal) {\\n        return maxChoosableInteger >= desiredTotal;\\n    }\\n\\t\\n\\teverything is fine until testcase \\n\\tmaxChoosableInteger: 4\\n\\tdesiredTotal: 6\\n\\t\\n\\tnot understanding this testcase.\\n\\t",
                "solutionTags": [],
                "code": "public boolean canIWin(int maxChoosableInteger, int desiredTotal) {\\n        return maxChoosableInteger >= desiredTotal;\\n    }\\n\\t\\n\\teverything is fine until testcase \\n\\tmaxChoosableInteger: 4\\n\\tdesiredTotal: 6\\n\\t\\n\\tnot understanding this testcase.\\n\\t",
                "codeTag": "Unknown"
            },
            {
                "id": 2082856,
                "title": "c-dp-bitmask",
                "content": "```\\nclass Solution {\\npublic:\\n    int  dp[1<<21][2]; //Dp with bitmasking\\n    bool recur(int sum,int mask,int m,int chance=0)\\n    {\\n        if(sum<=0)\\n             return false;\\n        if(dp[mask][chance]!=-1)\\n            return dp[mask][chance];\\n        bool ans=false;\\n        for(int i=0;i<m;i++)\\n        {\\n            if((1<<i)&mask)\\n            {\\n                ans=ans|(!recur(sum-i-1,mask^(1<<i),m,chance^1));\\n                if(ans==true)\\n                     break;\\n            }\\n        }\\n        return dp[mask][chance]=ans;\\n    }\\n    bool canIWin(int maxChoosableInteger, int desiredTotal) {\\n        \\n        \\n        memset(dp,-1,sizeof(dp));\\n        if(!desiredTotal)\\n            return true;\\n        int tSum=(maxChoosableInteger+1)*maxChoosableInteger/2;\\n          if(tSum< desiredTotal)\\n            return false;\\n        if(desiredTotal==tSum && maxChoosableInteger%2!=0)\\n            return true;\\n        if(desiredTotal==tSum && maxChoosableInteger%2==0)\\n            return false;\\n        if(desiredTotal==0)\\n            return true;\\n        int mask=(1<<maxChoosableInteger)-1;\\n        return recur(desiredTotal,mask,maxChoosableInteger);\\n        \\n        \\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    int  dp[1<<21][2]; //Dp with bitmasking\\n    bool recur(int sum,int mask,int m,int chance=0)\\n    {\\n        if(sum<=0)\\n             return false;\\n        if(dp[mask][chance]!=-1)\\n            return dp[mask][chance];\\n        bool ans=false;\\n        for(int i=0;i<m;i++)\\n        {\\n            if((1<<i)&mask)\\n            {\\n                ans=ans|(!recur(sum-i-1,mask^(1<<i),m,chance^1));\\n                if(ans==true)\\n                     break;\\n            }\\n        }\\n        return dp[mask][chance]=ans;\\n    }\\n    bool canIWin(int maxChoosableInteger, int desiredTotal) {\\n        \\n        \\n        memset(dp,-1,sizeof(dp));\\n        if(!desiredTotal)\\n            return true;\\n        int tSum=(maxChoosableInteger+1)*maxChoosableInteger/2;\\n          if(tSum< desiredTotal)\\n            return false;\\n        if(desiredTotal==tSum && maxChoosableInteger%2!=0)\\n            return true;\\n        if(desiredTotal==tSum && maxChoosableInteger%2==0)\\n            return false;\\n        if(desiredTotal==0)\\n            return true;\\n        int mask=(1<<maxChoosableInteger)-1;\\n        return recur(desiredTotal,mask,maxChoosableInteger);\\n        \\n        \\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2006496,
                "title": "python-faster-than-98-05-annotated-with-explanation",
                "content": "Code\\n```\\nclass Solution:\\n    def canIWin(self, maxChoosableInteger: int, desiredTotal: int) -> bool:\\n        N = maxChoosableInteger\\n        \\n        if (1 + N) * N / 2 < desiredTotal:\\n            return False\\n        \\n        @lru_cache(None)\\n        def helper(bitmask, currTotal):\\n            # regardless of whose turn it is\\n            # if before he can make a move, the currTotal already exceeds desiredTotal\\n            # means he loses\\n            # Note the bitmask != 0 check. This is to prevent against edge cases where desiredTotal = 0\\n            if currTotal >= desiredTotal and bitmask != 0:\\n                return False\\n            \\n            # ok, so for this player, currTotal has not yet desiredTotal\\n            # the player now browses through the cards available\\n            for i in range(N):\\n                # if this card has not been chosen before\\n                if (bitmask >> i) & 1 == 0:\\n                    # the player takes this card and pass to opponent\\n                    # can he forces opponent to lose by taking this card? \\n                    # if yes, means he win\\n                    if helper(bitmask | (1 << i), currTotal + i + 1) == False:\\n                        return True\\n    \\n            # no matter which card the player takes, he can\\'t forces opponent to lose\\n            # means he lost\\n            return False\\n        \\n        return helper(0, 0)\\n```\\nRuntime: 2889 ms (faster than 98.05%)\\nMemory: 13.68% (smaller than 13.68%)\\n\\nFor memory-constrained systems, we can compute currTotal from bitmask at every round (i.e. currTotal will be the sum of the cards drawn so far, as indicated by the bitmask), but this is slow, so we just memoize it.\\n\\nNote, there is no point doing tabulation, because bitmask has up to 1048575 variations (can go all the way up to 0b111...111 (20 \\'1\\'s)), and currTotal can go up to 300, so that will be up to 314572500 entries.",
                "solutionTags": [],
                "code": "```\\nclass Solution:\\n    def canIWin(self, maxChoosableInteger: int, desiredTotal: int) -> bool:\\n        N = maxChoosableInteger\\n        \\n        if (1 + N) * N / 2 < desiredTotal:\\n            return False\\n        \\n        @lru_cache(None)\\n        def helper(bitmask, currTotal):\\n            # regardless of whose turn it is\\n            # if before he can make a move, the currTotal already exceeds desiredTotal\\n            # means he loses\\n            # Note the bitmask != 0 check. This is to prevent against edge cases where desiredTotal = 0\\n            if currTotal >= desiredTotal and bitmask != 0:\\n                return False\\n            \\n            # ok, so for this player, currTotal has not yet desiredTotal\\n            # the player now browses through the cards available\\n            for i in range(N):\\n                # if this card has not been chosen before\\n                if (bitmask >> i) & 1 == 0:\\n                    # the player takes this card and pass to opponent\\n                    # can he forces opponent to lose by taking this card? \\n                    # if yes, means he win\\n                    if helper(bitmask | (1 << i), currTotal + i + 1) == False:\\n                        return True\\n    \\n            # no matter which card the player takes, he can\\'t forces opponent to lose\\n            # means he lost\\n            return False\\n        \\n        return helper(0, 0)\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1967624,
                "title": "python-simplest-dp-with-bit-mask",
                "content": "```\\nclass Solution:\\n    def canIWin(self, maxChoosableInteger: int, desiredTotal: int) -> bool:\\n        possible_total = (maxChoosableInteger * (maxChoosableInteger + 1)) // 2        \\n        if possible_total < desiredTotal: return False        \\n        @cache\\n        def dp(mask, desired):            \\n            for i in range(1, maxChoosableInteger + 1):\\n                if (1 << i) & mask == 0:\\n                    if i >= desired: return True \\n                    if not dp((1 << i) | mask, desired - i): return True                    \\n            return False                                \\n        return dp(0, desiredTotal)\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution:\\n    def canIWin(self, maxChoosableInteger: int, desiredTotal: int) -> bool:\\n        possible_total = (maxChoosableInteger * (maxChoosableInteger + 1)) // 2        \\n        if possible_total < desiredTotal: return False        \\n        @cache\\n        def dp(mask, desired):            \\n            for i in range(1, maxChoosableInteger + 1):\\n                if (1 << i) & mask == 0:\\n                    if i >= desired: return True \\n                    if not dp((1 << i) | mask, desired - i): return True                    \\n            return False                                \\n        return dp(0, desiredTotal)\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1888034,
                "title": "python-dp-bitmask",
                "content": "```\\nclass Solution:\\n    def canIWin(self, mn: int, t: int) -> bool:\\n        mm=0\\n        for i in range(1,mn+1):mm+=i\\n        if mm<t:return False\\n        if t<=mn:return True\\n        \\n        @cache\\n        def dp(u,f,s):\\n            if s>=t:return False if f==0 else True\\n            nx=0 if f==1 else 1\\n            for i in range(1,mn+1):\\n                m=1<<i\\n                if u&m!=0:continue\\n                r=dp(u|m,nx,s+i)\\n                if r and f==0:return True\\n                if not r and f==1:return False\\n            return False if f==0 else True\\n        \\n        return dp(0,0,0)\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution:\\n    def canIWin(self, mn: int, t: int) -> bool:\\n        mm=0\\n        for i in range(1,mn+1):mm+=i\\n        if mm<t:return False\\n        if t<=mn:return True\\n        \\n        @cache\\n        def dp(u,f,s):\\n            if s>=t:return False if f==0 else True\\n            nx=0 if f==1 else 1\\n            for i in range(1,mn+1):\\n                m=1<<i\\n                if u&m!=0:continue\\n                r=dp(u|m,nx,s+i)\\n                if r and f==0:return True\\n                if not r and f==1:return False\\n            return False if f==0 else True\\n        \\n        return dp(0,0,0)\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1781853,
                "title": "javascript-464-can-i-win",
                "content": "---\\n\\n- See second solution for easy understanding\\n- One of the best questions on optimization ( a million element array allocation )\\n\\n---\\n\\n**Unique questions/ solutions:**\\n- https://leetcode.com/problems/maximum-population-year/discuss/1773818/JavaScript-1854.-Maximum-Population-Year\\n- https://leetcode.com/problems/can-i-win/discuss/1781853/JavaScript-464.-Can-I-Win\\n\\n---\\n\\nHope it is simple to understand.\\n\\n---\\n\\n**100% - (188 ms is good)**\\n\\n```\\nvar canIWin = function (maxn, total) {\\n    if (total === 0) return true; // no total, so first player wins without taking turn\\n\\n    let sumn = (maxn * (maxn + 1)) / 2;\\n    if (sumn < total) return false; // sum can\\'t reach total, impossible game, so first player can-not win\\n\\n    let masks = new Array(1 << maxn); // 2^maxn = max 2^20 = 1,048,576, a million variable array\\n    let bitMaskmaxn = (1 << maxn) - 1;\\n\\n    function solve(currentMask, total) {\\n        if (currentMask <= 0) return false; // current player lost - cant play\\n        if (total <= 0) return false; // current player lost - cant play\\n        if (masks[currentMask] !== undefined) return masks[currentMask];\\n\\n        for (let n = 1, bitMask = 1; n <= maxn && bitMask <= currentMask; ++n, bitMask = bitMask << 1) {\\n            let nNotTaken = currentMask & bitMask; // take n  if not taken\\n            if (nNotTaken) {\\n                let currentMaskWithoutN = currentMask ^ bitMask;\\n                let totalWithoutN = total - n;\\n                if (!solve(currentMaskWithoutN, totalWithoutN)) {\\n                    return (masks[currentMask] = true); // other player won, so current player loses\\n                }\\n            }\\n        }\\n        return (masks[currentMask] = false); // current player won\\n    }\\n\\n    return solve(bitMaskmaxn, total); // \\'1111 1111 1111 1111 1111\\', 11\\n};\\n```\\n\\n100%\\n\\n![image](https://assets.leetcode.com/users/images/0706713c-8d8c-4131-94de-bed151a3a835_1645241739.69819.png)\\n\\n---\\n\\n**Better comments & naming convention**\\n\\n```\\nvar canIWin = function (maxN, desiredSum) {\\n    if (desiredSum === 0) return true;                     // no desiredSum, so first player wins without taking turn\\n\\n    let sumn = (maxN * (maxN + 1)) / 2;\\n    if (sumn < desiredSum) return false;                   // sum can\\'t reach desiredSum, impossible game, so first player can-not win\\n\\n    let masks = new Array(1 << maxN);                      // 2^maxN = max 2^20 = 1,048,576, a million variable array\\n    let bitMaskMaxN = (1 << maxN) - 1;\\n\\n    function canWin(bitMaskFull1, desiredSum1) {\\n        if (desiredSum1 <= 0) return false;                // other player reached 0 or less already - so this player lost, return\\n        if (masks[bitMaskFull1] !== undefined)\\n\\t\\t\\treturn masks[bitMaskFull1];\\n\\n        for (let n = 1, bitMaskOfN = 1;\\n\\t\\t\\t\\tn <= maxN && bitMaskOfN <= bitMaskFull1;\\n\\t\\t\\t\\t++n, bitMaskOfN = bitMaskOfN << 1\\n\\t\\t) {\\n                                                           // if n not taken\\n            if (bitMaskFull1 & bitMaskOfN) {\\n                                                           // take it & give turn for other player\\n                if (!canWin(bitMaskFull1 ^ bitMaskOfN, desiredSum1 - n)) {\\n                    return (masks[bitMaskFull1] = true);   // other player could not move, this player wins\\n                }\\n            }\\n        }\\n        return (masks[bitMaskFull1] = false);              // other player always wins, so this player loses\\n    }\\n\\n    return canWin(bitMaskMaxN, desiredSum);                // \\'1111 1111 1111 1111 1111\\', 11\\n};\\n```\\n\\n---\\n",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\nvar canIWin = function (maxn, total) {\\n    if (total === 0) return true; // no total, so first player wins without taking turn\\n\\n    let sumn = (maxn * (maxn + 1)) / 2;\\n    if (sumn < total) return false; // sum can\\'t reach total, impossible game, so first player can-not win\\n\\n    let masks = new Array(1 << maxn); // 2^maxn = max 2^20 = 1,048,576, a million variable array\\n    let bitMaskmaxn = (1 << maxn) - 1;\\n\\n    function solve(currentMask, total) {\\n        if (currentMask <= 0) return false; // current player lost - cant play\\n        if (total <= 0) return false; // current player lost - cant play\\n        if (masks[currentMask] !== undefined) return masks[currentMask];\\n\\n        for (let n = 1, bitMask = 1; n <= maxn && bitMask <= currentMask; ++n, bitMask = bitMask << 1) {\\n            let nNotTaken = currentMask & bitMask; // take n  if not taken\\n            if (nNotTaken) {\\n                let currentMaskWithoutN = currentMask ^ bitMask;\\n                let totalWithoutN = total - n;\\n                if (!solve(currentMaskWithoutN, totalWithoutN)) {\\n                    return (masks[currentMask] = true); // other player won, so current player loses\\n                }\\n            }\\n        }\\n        return (masks[currentMask] = false); // current player won\\n    }\\n\\n    return solve(bitMaskmaxn, total); // \\'1111 1111 1111 1111 1111\\', 11\\n};\\n```\n```\\nvar canIWin = function (maxN, desiredSum) {\\n    if (desiredSum === 0) return true;                     // no desiredSum, so first player wins without taking turn\\n\\n    let sumn = (maxN * (maxN + 1)) / 2;\\n    if (sumn < desiredSum) return false;                   // sum can\\'t reach desiredSum, impossible game, so first player can-not win\\n\\n    let masks = new Array(1 << maxN);                      // 2^maxN = max 2^20 = 1,048,576, a million variable array\\n    let bitMaskMaxN = (1 << maxN) - 1;\\n\\n    function canWin(bitMaskFull1, desiredSum1) {\\n        if (desiredSum1 <= 0) return false;                // other player reached 0 or less already - so this player lost, return\\n        if (masks[bitMaskFull1] !== undefined)\\n\\t\\t\\treturn masks[bitMaskFull1];\\n\\n        for (let n = 1, bitMaskOfN = 1;\\n\\t\\t\\t\\tn <= maxN && bitMaskOfN <= bitMaskFull1;\\n\\t\\t\\t\\t++n, bitMaskOfN = bitMaskOfN << 1\\n\\t\\t) {\\n                                                           // if n not taken\\n            if (bitMaskFull1 & bitMaskOfN) {\\n                                                           // take it & give turn for other player\\n                if (!canWin(bitMaskFull1 ^ bitMaskOfN, desiredSum1 - n)) {\\n                    return (masks[bitMaskFull1] = true);   // other player could not move, this player wins\\n                }\\n            }\\n        }\\n        return (masks[bitMaskFull1] = false);              // other player always wins, so this player loses\\n    }\\n\\n    return canWin(bitMaskMaxN, desiredSum);                // \\'1111 1111 1111 1111 1111\\', 11\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1758112,
                "title": "simple-python-solution-dp-bit",
                "content": "```\\ndef canIWin(self, max_num: int, desiredTotal: int) -> bool:\\n        if desiredTotal<= max_num: return True\\n        \\n        if (max_num*(max_num+1)//2)< desiredTotal: return False\\n        \\n        mem ={}\\n        \\n        \\n        def dp(total, seen):\\n            if total>=desiredTotal: return False\\n            \\n            if (total,seen) in mem: return mem[(total,seen)]\\n            \\n            ans = False\\n            for num in range(1, max_num+1):\\n                if 1<<num & seen: continue\\n                \\n                new_seen= seen|1<<num\\n                temp= dp(total+num, new_seen)\\n                if not temp: \\n                    mem[(total, seen)]= True\\n                    return True #i can force other player to lose by picking this\\n                \\n            mem[(total,seen)]= ans\\n            return ans\\n        \\n        return dp(0,0)\\n```",
                "solutionTags": [],
                "code": "```\\ndef canIWin(self, max_num: int, desiredTotal: int) -> bool:\\n        if desiredTotal<= max_num: return True\\n        \\n        if (max_num*(max_num+1)//2)< desiredTotal: return False\\n        \\n        mem ={}\\n        \\n        \\n        def dp(total, seen):\\n            if total>=desiredTotal: return False\\n            \\n            if (total,seen) in mem: return mem[(total,seen)]\\n            \\n            ans = False\\n            for num in range(1, max_num+1):\\n                if 1<<num & seen: continue\\n                \\n                new_seen= seen|1<<num\\n                temp= dp(total+num, new_seen)\\n                if not temp: \\n                    mem[(total, seen)]= True\\n                    return True #i can force other player to lose by picking this\\n                \\n            mem[(total,seen)]= ans\\n            return ans\\n        \\n        return dp(0,0)\\n```",
                "codeTag": "Python3"
            },
            {
                "id": 1603637,
                "title": "fast-c-using-dp",
                "content": "This is a piece of C++, running faster than 96.10% of C++ online submissions:\\n\\n```\\nclass Solution {\\n    public:\\n    bool win(int sum, int used, vector<char>& mem, int maxNum, int total) {\\n        if (mem[used] != -1) return mem[used];\\n        for (int i = 1; i <= maxNum; i++)\\n            if ((used & (1 << i)) == 0 && (i + sum >= total || !win(i + sum, used | (1 << i), mem, maxNum, total))) \\n                return mem[used] = 1;\\n        return mem[used] = 0;\\n    }\\n\\n    bool canIWin(int maxChoosableInteger, int desiredTotal) {\\n        if(maxChoosableInteger*(maxChoosableInteger+1)/2 < desiredTotal) return false;\\n        vector<char> mem(1 << (maxChoosableInteger+1), -1);\\n        return win(0, 0, mem, maxChoosableInteger, desiredTotal);\\n    }\\n};",
                "solutionTags": [],
                "code": "class Solution {\\n    public:\\n    bool win(int sum, int used, vector<char>& mem, int maxNum, int total) {\\n        if (mem[used] != -1) return mem[used];\\n        for (int i = 1; i <= maxNum; i++)\\n            if ((used & (1 << i)) == 0 && (i + sum >= total || !win(i + sum, used | (1 << i), mem, maxNum, total))) \\n                return mem[used] = 1;\\n        return mem[used] = 0;\\n    }",
                "codeTag": "Java"
            },
            {
                "id": 1586597,
                "title": "c-solution",
                "content": "```\\nclass Solution {\\npublic:\\n    unordered_map<int,bool> mem;\\n    \\n    int n;\\n    bool helper(int &vis, int target, int totsum){\\n        if(totsum < target) return false;\\n        if(mem.find(vis) != mem.end())\\n            return mem[vis];\\n        \\n        for(int i=1; i<=n; i++)\\n        {\\n            if(vis & 1<<i) continue;\\n            if(target - i <= 0)\\n                   return  mem[vis] = true;\\n            \\n            vis += 1<<i;\\n            totsum -= i;\\n            \\n            if(!helper(vis,target-i,totsum)){\\n                vis -= 1<<i;\\n                return mem[vis] = true;\\n            }\\n            totsum += i;\\n            vis -= 1<<i;\\n            \\n        }\\n        mem[vis] = false;\\n        return false;\\n    }\\n    \\n    \\n    \\n    \\n    bool canIWin(int maxChoosableInteger, int desiredTotal) {\\n      int vis =0;\\n      return helper(vis,desiredTotal,(maxChoosableInteger*(maxChoosableInteger+1))/2);\\n        \\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "C"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    unordered_map<int,bool> mem;\\n    \\n    int n;\\n    bool helper(int &vis, int target, int totsum){\\n        if(totsum < target) return false;\\n        if(mem.find(vis) != mem.end())\\n            return mem[vis];\\n        \\n        for(int i=1; i<=n; i++)\\n        {\\n            if(vis & 1<<i) continue;\\n            if(target - i <= 0)\\n                   return  mem[vis] = true;\\n            \\n            vis += 1<<i;\\n            totsum -= i;\\n            \\n            if(!helper(vis,target-i,totsum)){\\n                vis -= 1<<i;\\n                return mem[vis] = true;\\n            }\\n            totsum += i;\\n            vis -= 1<<i;\\n            \\n        }\\n        mem[vis] = false;\\n        return false;\\n    }\\n    \\n    \\n    \\n    \\n    bool canIWin(int maxChoosableInteger, int desiredTotal) {\\n      int vis =0;\\n      return helper(vis,desiredTotal,(maxChoosableInteger*(maxChoosableInteger+1))/2);\\n        \\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1517985,
                "title": "c-dp-with-explanation",
                "content": "```\\nclass Solution {\\npublic:\\n\\t/*\\n\\t\\twe are using the integer ch where the ith bit denotes that the number i has been taken or not\\n\\t\\tif the ith bit is on , it means that the number is available for us to take\\n\\t\\tif the ith bit is off , it means that the number is not availbale for us to take\\n\\n\\t\\tfor a given desired total, which number has been taken and which is not is enough to denote the state of the dp\\n\\n\\t*/\\n\\tunordered_map<int, int> dp;\\n\\tbool dfs(int ch, int maxChose, int desiredTotal, int curTotal) {\\n\\t\\tif (dp.find(ch) != dp.end()) return dp[ch];\\n\\t\\tfor (int i = 1; i <= maxChose; i++) {\\n\\n\\t\\t\\t// if the ith bit is on , it means that this number is availabe for us to take\\n\\t\\t\\tif (ch & (1 << i)) {\\n\\t\\t\\t\\tif (curTotal + i >= desiredTotal) return dp[ch] = true;\\n\\t\\t\\t\\tbool cur = !dfs((ch & ~(1 << i)), maxChose, desiredTotal, curTotal + i); // opponent has the next turn, and in case it is not possible for him to win from this route, it is possible for me to win\\n\\t\\t\\t\\tif (cur) return dp[ch] = true;\\n\\t\\t\\t}\\n\\t\\t}\\n\\n\\t\\treturn dp[ch] = false;\\n\\n\\t}\\n\\tbool canIWin(int maxChose, int desiredTotal) {\\n\\n\\t\\t// all these corner case checks are important, else it will give wrong answer\\n\\t\\tint sum = (maxChose * (maxChose + 1)) / 2 ;\\n\\t\\tif (sum < desiredTotal) return false;\\n\\n\\t\\tif (desiredTotal <= 0) return true;\\n\\t\\tif (sum == desiredTotal) return maxChose % 2;\\n\\n\\t\\tint ch = INT_MAX; // all bits are set in this\\n\\n\\t\\tbool ans = dfs(ch, maxChose, desiredTotal, 0);\\n\\t\\treturn ans;\\n\\n\\n\\n\\t}\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n\\t/*\\n\\t\\twe are using the integer ch where the ith bit denotes that the number i has been taken or not\\n\\t\\tif the ith bit is on , it means that the number is available for us to take\\n\\t\\tif the ith bit is off , it means that the number is not availbale for us to take\\n\\n\\t\\tfor a given desired total, which number has been taken and which is not is enough to denote the state of the dp\\n\\n\\t*/\\n\\tunordered_map<int, int> dp;\\n\\tbool dfs(int ch, int maxChose, int desiredTotal, int curTotal) {\\n\\t\\tif (dp.find(ch) != dp.end()) return dp[ch];\\n\\t\\tfor (int i = 1; i <= maxChose; i++) {\\n\\n\\t\\t\\t// if the ith bit is on , it means that this number is availabe for us to take\\n\\t\\t\\tif (ch & (1 << i)) {\\n\\t\\t\\t\\tif (curTotal + i >= desiredTotal) return dp[ch] = true;\\n\\t\\t\\t\\tbool cur = !dfs((ch & ~(1 << i)), maxChose, desiredTotal, curTotal + i); // opponent has the next turn, and in case it is not possible for him to win from this route, it is possible for me to win\\n\\t\\t\\t\\tif (cur) return dp[ch] = true;\\n\\t\\t\\t}\\n\\t\\t}\\n\\n\\t\\treturn dp[ch] = false;\\n\\n\\t}\\n\\tbool canIWin(int maxChose, int desiredTotal) {\\n\\n\\t\\t// all these corner case checks are important, else it will give wrong answer\\n\\t\\tint sum = (maxChose * (maxChose + 1)) / 2 ;\\n\\t\\tif (sum < desiredTotal) return false;\\n\\n\\t\\tif (desiredTotal <= 0) return true;\\n\\t\\tif (sum == desiredTotal) return maxChose % 2;\\n\\n\\t\\tint ch = INT_MAX; // all bits are set in this\\n\\n\\t\\tbool ans = dfs(ch, maxChose, desiredTotal, 0);\\n\\t\\treturn ans;\\n\\n\\n\\n\\t}\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1515866,
                "title": "java-recursion-memoization-430-ms-60-speed-and-70-memory-efficient",
                "content": "An improved version of https://leetcode.com/problems/can-i-win/discuss/1454684/Java-DP-Solution-Recursion-with-Memory\\n\\n```\\nclass Solution {\\n    public boolean canIWin(int maxChoosableInteger, int desiredTotal) {\\n        int sum = (maxChoosableInteger * (maxChoosableInteger + 1)) >> 1;\\n        if(sum < desiredTotal){\\n            return false;\\n        }\\n        \\n        if(desiredTotal <= 0){\\n            return true;\\n        }\\n        \\n        HashMap<Integer, Boolean> cache = new HashMap<Integer, Boolean>();\\n        boolean[] used = new boolean[maxChoosableInteger + 1];\\n        return canWin(maxChoosableInteger, 0, desiredTotal, used, cache, 0);\\n    }\\n    \\n    private boolean canWin(int maxChoosableInteger, int totalTillNow, int desiredTotal, boolean[] used, HashMap<Integer, Boolean> cache, int bitMap){\\n        // total till now has exceeded desiredTotal\\n        // meaning I have already lost the game\\n        if(totalTillNow >= desiredTotal){\\n            return false;\\n        }else{\\n            if(!cache.containsKey(bitMap)){\\n                boolean status = false;\\n                for(int i = 1; i <= maxChoosableInteger; i++){\\n                    if(!used[i]){\\n                        used[i] = true;\\n                        // my opponent should not win for me to be able to win\\n                        status = !canWin(maxChoosableInteger, totalTillNow + i, desiredTotal, used, cache, bitMap | (1 << i));  // adjust the bitMap accordingly by OR operation      \\n                        used[i] = false;\\n                        \\n                        // if possible for my opponent to lose - means i can win\\n                        if(status){\\n                            break;\\n                        }\\n                    }\\n                }\\n                \\n                cache.put(bitMap, status);\\n            }\\n            \\n            return cache.get(bitMap);\\n        }\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    public boolean canIWin(int maxChoosableInteger, int desiredTotal) {\\n        int sum = (maxChoosableInteger * (maxChoosableInteger + 1)) >> 1;\\n        if(sum < desiredTotal){\\n            return false;\\n        }\\n        \\n        if(desiredTotal <= 0){\\n            return true;\\n        }\\n        \\n        HashMap<Integer, Boolean> cache = new HashMap<Integer, Boolean>();\\n        boolean[] used = new boolean[maxChoosableInteger + 1];\\n        return canWin(maxChoosableInteger, 0, desiredTotal, used, cache, 0);\\n    }\\n    \\n    private boolean canWin(int maxChoosableInteger, int totalTillNow, int desiredTotal, boolean[] used, HashMap<Integer, Boolean> cache, int bitMap){\\n        // total till now has exceeded desiredTotal\\n        // meaning I have already lost the game\\n        if(totalTillNow >= desiredTotal){\\n            return false;\\n        }else{\\n            if(!cache.containsKey(bitMap)){\\n                boolean status = false;\\n                for(int i = 1; i <= maxChoosableInteger; i++){\\n                    if(!used[i]){\\n                        used[i] = true;\\n                        // my opponent should not win for me to be able to win\\n                        status = !canWin(maxChoosableInteger, totalTillNow + i, desiredTotal, used, cache, bitMap | (1 << i));  // adjust the bitMap accordingly by OR operation      \\n                        used[i] = false;\\n                        \\n                        // if possible for my opponent to lose - means i can win\\n                        if(status){\\n                            break;\\n                        }\\n                    }\\n                }\\n                \\n                cache.put(bitMap, status);\\n            }\\n            \\n            return cache.get(bitMap);\\n        }\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1387146,
                "title": "c-dp-minimax",
                "content": "```\\nclass Solution {\\npublic:\\n    vector<int> cache;\\n    int maxv;\\n    // dp(state, remain):\\n    // If both players do their best(if there is any chance to win, they choose to win.),\\n    // TRUE: The player on the current turn may win at least one of them.\\n    // FALSE: The player on the current turn never wins.\\n    bool dp(int state, int remain) {\\n\\n        if (remain <= 0) // The current player loses.\\n            return false;\\n        \\n        if (cache[state] != -1)\\n            return cache[state];\\n        \\n        for (int n = 0; n < maxv; ++n) {\\n            if (state & (1 << n))\\n                continue;\\n            if (!dp(state | (1 << n), remain - n - 1)) // The player on the next turn never wins --> There are cases where the player of the current turn wins.\\n                return cache[state] = true;\\n        }\\n        \\n        return cache[state] = false;\\n    }\\n    \\n    bool canIWin(int maxChoosableInteger, int desiredTotal) {\\n        int sum = ((maxChoosableInteger+1) * maxChoosableInteger) / 2;\\n        if (sum < desiredTotal)\\n            return false;\\n        if (desiredTotal == 0)\\n            return true;\\n        maxv = maxChoosableInteger;\\n        cache = vector<int>(1 << maxChoosableInteger, -1);\\n        return dp(0, desiredTotal);\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<int> cache;\\n    int maxv;\\n    // dp(state, remain):\\n    // If both players do their best(if there is any chance to win, they choose to win.),\\n    // TRUE: The player on the current turn may win at least one of them.\\n    // FALSE: The player on the current turn never wins.\\n    bool dp(int state, int remain) {\\n\\n        if (remain <= 0) // The current player loses.\\n            return false;\\n        \\n        if (cache[state] != -1)\\n            return cache[state];\\n        \\n        for (int n = 0; n < maxv; ++n) {\\n            if (state & (1 << n))\\n                continue;\\n            if (!dp(state | (1 << n), remain - n - 1)) // The player on the next turn never wins --> There are cases where the player of the current turn wins.\\n                return cache[state] = true;\\n        }\\n        \\n        return cache[state] = false;\\n    }\\n    \\n    bool canIWin(int maxChoosableInteger, int desiredTotal) {\\n        int sum = ((maxChoosableInteger+1) * maxChoosableInteger) / 2;\\n        if (sum < desiredTotal)\\n            return false;\\n        if (desiredTotal == 0)\\n            return true;\\n        maxv = maxChoosableInteger;\\n        cache = vector<int>(1 << maxChoosableInteger, -1);\\n        return dp(0, desiredTotal);\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1342197,
                "title": "java-prettiest-code-np-problem-polynomial-algorithm-doesn-t-exists",
                "content": "* An integer can be used to store the state of the game\\n* Use HashMap to cache the repeating calculations. \\n\\n--------\\n```\\nclass Solution {\\n    public boolean canIWin(int maxChoosableInteger, int desiredTotal) {\\n        if((1+maxChoosableInteger)*maxChoosableInteger/2 < desiredTotal)    return false;\\n        return canWin(0, desiredTotal, maxChoosableInteger,  new HashMap<Integer, Boolean>());\\n    }\\n    \\n    private boolean canWin(int state, int total, int max,  Map<Integer, Boolean> dp){\\n        if(dp.containsKey(state))   return dp.get(state);\\n        \\n        for(int i=max;i>=1;i--){\\n            if( (state&(1<<i))==0 && (total-i<=0 || !canWin(state|(1<<i), total-i, max,  dp))){\\n                return dp.computeIfAbsent(state, k->true);\\n            }\\n        }\\n        return dp.computeIfAbsent(state, k->false);\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Backtracking"
                ],
                "code": "```\\nclass Solution {\\n    public boolean canIWin(int maxChoosableInteger, int desiredTotal) {\\n        if((1+maxChoosableInteger)*maxChoosableInteger/2 < desiredTotal)    return false;\\n        return canWin(0, desiredTotal, maxChoosableInteger,  new HashMap<Integer, Boolean>());\\n    }\\n    \\n    private boolean canWin(int state, int total, int max,  Map<Integer, Boolean> dp){\\n        if(dp.containsKey(state))   return dp.get(state);\\n        \\n        for(int i=max;i>=1;i--){\\n            if( (state&(1<<i))==0 && (total-i<=0 || !canWin(state|(1<<i), total-i, max,  dp))){\\n                return dp.computeIfAbsent(state, k->true);\\n            }\\n        }\\n        return dp.computeIfAbsent(state, k->false);\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1323885,
                "title": "python-dfs-with-memo-and-bitmap",
                "content": "```\\nclass Solution:\\n    def canIWin(self, maxChoosableInteger: int, desiredTotal: int) -> bool:\\n        M = maxChoosableInteger\\n        T = desiredTotal\\n        if M*(M + 1)/2 < T:\\n            return False\\n        if M > T:\\n            return True\\n        \\n        def dfs(M,T,m,state):\\n            if T <= 0: \\n                m[state] = -1\\n                return False\\n            if m[state] != 0: return m[state] == 1\\n            for i in range(1,M + 1):\\n                if state & (1<<i) > 0:\\n                    continue\\n                if not dfs(M,T - i,m,state | (1<<i)):\\n                    m[state] = 1\\n                    return True\\n            m[state] = -1\\n            return False\\n        \\n        m = [0]*(1<<(M + 1))\\n        return dfs(M,T,m,0)\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution:\\n    def canIWin(self, maxChoosableInteger: int, desiredTotal: int) -> bool:\\n        M = maxChoosableInteger\\n        T = desiredTotal\\n        if M*(M + 1)/2 < T:\\n            return False\\n        if M > T:\\n            return True\\n        \\n        def dfs(M,T,m,state):\\n            if T <= 0: \\n                m[state] = -1\\n                return False\\n            if m[state] != 0: return m[state] == 1\\n            for i in range(1,M + 1):\\n                if state & (1<<i) > 0:\\n                    continue\\n                if not dfs(M,T - i,m,state | (1<<i)):\\n                    m[state] = 1\\n                    return True\\n            m[state] = -1\\n            return False\\n        \\n        m = [0]*(1<<(M + 1))\\n        return dfs(M,T,m,0)\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1318781,
                "title": "rust-cheapest-best",
                "content": "```\\nuse std::collections::HashMap;\\n\\nimpl Solution {\\n    pub fn can_i_win(max_choosable_integer: i32, desired_total: i32) -> bool {\\n        let sum: i32 = (1..=max_choosable_integer).sum();\\n        let mut cache = HashMap::new();\\n\\n        if desired_total < 2 {\\n            true\\n        } else if sum < desired_total {\\n            false\\n        } else {\\n            Self::go(max_choosable_integer, 0, desired_total, &mut cache)\\n        }\\n    }\\n\\n    fn go(m: i32, key: i32, total: i32, cache: &mut HashMap<i32, bool>) -> bool {\\n        if let Some(result) = cache.get(&key) {\\n            *result\\n        } else if total <= 0 {\\n            false\\n        } else {\\n            for n in 1..=m {\\n                if key & (1 << n) == 0 && !Self::go(m, key | (1 << n), total - n, cache) {\\n                    cache.insert(key, true);\\n                    return true;\\n                }\\n            }\\n            cache.insert(key, false);\\n            false\\n        }\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nuse std::collections::HashMap;\\n\\nimpl Solution {\\n    pub fn can_i_win(max_choosable_integer: i32, desired_total: i32) -> bool {\\n        let sum: i32 = (1..=max_choosable_integer).sum();\\n        let mut cache = HashMap::new();\\n\\n        if desired_total < 2 {\\n            true\\n        } else if sum < desired_total {\\n            false\\n        } else {\\n            Self::go(max_choosable_integer, 0, desired_total, &mut cache)\\n        }\\n    }\\n\\n    fn go(m: i32, key: i32, total: i32, cache: &mut HashMap<i32, bool>) -> bool {\\n        if let Some(result) = cache.get(&key) {\\n            *result\\n        } else if total <= 0 {\\n            false\\n        } else {\\n            for n in 1..=m {\\n                if key & (1 << n) == 0 && !Self::go(m, key | (1 << n), total - n, cache) {\\n                    cache.insert(key, true);\\n                    return true;\\n                }\\n            }\\n            cache.insert(key, false);\\n            false\\n        }\\n    }\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1316078,
                "title": "java-beats-92",
                "content": "```\\nclass Solution {\\n    public boolean canIWin(int maxChoosableInteger, int desiredTotal) {\\n        if(desiredTotal<=maxChoosableInteger){\\n            return true;\\n        }\\n        else if(desiredTotal>(maxChoosableInteger*(maxChoosableInteger+1))/2){\\n            return false;\\n        }\\n        int[] dp = new int[(int)Math.pow(2,maxChoosableInteger)+1];\\n        return recursion(maxChoosableInteger, desiredTotal, true, 0, dp);\\n    }\\n    \\n    public boolean recursion(int m, int d, boolean turn, int visited, int[] dp){\\n        if(d<=0 && !turn){\\n            return true;\\n        }\\n        \\n        else if(d<=0){\\n            return false;\\n        }\\n        \\n        else if(turn){\\n            if(dp[visited]==0){\\n                int temp = 1;\\n                int counter = 1;\\n                while(counter<=m){\\n                    if((temp&visited)==0){\\n                        boolean check = recursion(m, d-counter, !turn, visited|temp, dp);\\n                        if(check){\\n                            dp[visited] = 1;\\n                            break;\\n                        }\\n                    }\\n                    temp = temp<<1;\\n                    counter++;\\n                }\\n                if(dp[visited]==0){\\n                    dp[visited] = -1;\\n                }\\n            }\\n            if(dp[visited]==1){\\n                return true;\\n            }\\n            return false;\\n        }\\n        else{\\n            if(dp[visited]==0){\\n                int temp = 1;\\n                int counter = 1;\\n                while(counter<=m){\\n                    if((temp&visited)==0){\\n                        boolean check = recursion(m, d-counter, !turn, visited|temp, dp);\\n                        if(!check){\\n                            dp[visited] = 1;\\n                            break;\\n                        }\\n                    }\\n                    temp = temp<<1;\\n                    counter++;\\n                }\\n                \\n                if(dp[visited]==0){\\n                    dp[visited]=-1;\\n                }\\n            }\\n            \\n            if(dp[visited]==1){\\n                return false;\\n            }\\n            return true;\\n        }\\n    }\\n}\\n```",
                "solutionTags": [
                    "Dynamic Programming",
                    "Bit Manipulation",
                    "Bitmask"
                ],
                "code": "```\\nclass Solution {\\n    public boolean canIWin(int maxChoosableInteger, int desiredTotal) {\\n        if(desiredTotal<=maxChoosableInteger){\\n            return true;\\n        }\\n        else if(desiredTotal>(maxChoosableInteger*(maxChoosableInteger+1))/2){\\n            return false;\\n        }\\n        int[] dp = new int[(int)Math.pow(2,maxChoosableInteger)+1];\\n        return recursion(maxChoosableInteger, desiredTotal, true, 0, dp);\\n    }\\n    \\n    public boolean recursion(int m, int d, boolean turn, int visited, int[] dp){\\n        if(d<=0 && !turn){\\n            return true;\\n        }\\n        \\n        else if(d<=0){\\n            return false;\\n        }\\n        \\n        else if(turn){\\n            if(dp[visited]==0){\\n                int temp = 1;\\n                int counter = 1;\\n                while(counter<=m){\\n                    if((temp&visited)==0){\\n                        boolean check = recursion(m, d-counter, !turn, visited|temp, dp);\\n                        if(check){\\n                            dp[visited] = 1;\\n                            break;\\n                        }\\n                    }\\n                    temp = temp<<1;\\n                    counter++;\\n                }\\n                if(dp[visited]==0){\\n                    dp[visited] = -1;\\n                }\\n            }\\n            if(dp[visited]==1){\\n                return true;\\n            }\\n            return false;\\n        }\\n        else{\\n            if(dp[visited]==0){\\n                int temp = 1;\\n                int counter = 1;\\n                while(counter<=m){\\n                    if((temp&visited)==0){\\n                        boolean check = recursion(m, d-counter, !turn, visited|temp, dp);\\n                        if(!check){\\n                            dp[visited] = 1;\\n                            break;\\n                        }\\n                    }\\n                    temp = temp<<1;\\n                    counter++;\\n                }\\n                \\n                if(dp[visited]==0){\\n                    dp[visited]=-1;\\n                }\\n            }\\n            \\n            if(dp[visited]==1){\\n                return false;\\n            }\\n            return true;\\n        }\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1301716,
                "title": "short-python-dfs-with-memorization",
                "content": "```\\nclass Solution:\\n    def canIWin(self, m, t):\\n        @cache\\n        def dfs(x, t, p):\\n            if t <= 0: return 1-p\\n            for i in range(m):\\n                j = 1 << i\\n                if x & j: \\n                    winner = dfs(x ^ j, t-(i+1), 1-p)\\n                    if winner == p:\\n                        return winner\\n            return 1-p\\n\\n        if t == 0: return True\\n        if m*(m+1)//2 < t: return False\\n        return dfs((1<<m) - 1, t, 0) == 0\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution:\\n    def canIWin(self, m, t):\\n        @cache\\n        def dfs(x, t, p):\\n            if t <= 0: return 1-p\\n            for i in range(m):\\n                j = 1 << i\\n                if x & j: \\n                    winner = dfs(x ^ j, t-(i+1), 1-p)\\n                    if winner == p:\\n                        return winner\\n            return 1-p\\n\\n        if t == 0: return True\\n        if m*(m+1)//2 < t: return False\\n        return dfs((1<<m) - 1, t, 0) == 0\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1192528,
                "title": "recursion-bitmasking",
                "content": "class Solution {\\npublic:\\n\\n    vector<int>dp;\\n    bool solve(int m,int d,int mask)\\n    {\\n        if(dp[mask]!=-1)\\n            return dp[mask];\\n        \\n        if(d<=0)\\n            return false;\\n        for(int i=0;i<m;i++)\\n        {\\n            int new_mask=1<<i;\\n            if(((mask&new_mask)==0)&& !solve(m,d-(i+1),mask+new_mask))\\n            {\\n                return dp[mask]=1;\\n            }\\n        }\\n        return dp[mask]=0;\\n    }\\n    bool canIWin(int maxChoosableInteger, int desiredTotal)\\n    {\\n        if(maxChoosableInteger>=desiredTotal)\\n            return true;\\n        int p=(maxChoosableInteger*(maxChoosableInteger+1))/2;\\n        if(p<desiredTotal)\\n            return false;\\n        if(p==desiredTotal)\\n            return maxChoosableInteger%2;\\n        dp.resize(1<<20,-1);\\n        return solve(maxChoosableInteger,desiredTotal,0);\\n    }\\n};",
                "solutionTags": [
                    "C",
                    "Recursion",
                    "Bitmask"
                ],
                "code": "class Solution {\\npublic:\\n\\n    vector<int>dp;\\n    bool solve(int m,int d,int mask)\\n    {\\n        if(dp[mask]!=-1)\\n            return dp[mask];\\n        \\n        if(d<=0)\\n            return false;\\n        for(int i=0;i<m;i++)\\n        {\\n            int new_mask=1<<i;\\n            if(((mask&new_mask)==0)&& !solve(m,d-(i+1),mask+new_mask))\\n            {\\n                return dp[mask]=1;\\n            }",
                "codeTag": "Java"
            },
            {
                "id": 1148765,
                "title": "c-44ms-min-max-dp-bitmask",
                "content": "```\\nclass Solution {\\npublic:\\n    bool solver(int p,int maxi,int t,int vis,int dp[])\\n    {\\n        if(t<=0&&p)\\n            return false;\\n        if(t<=0&&!p)\\n            return true;\\n        if(vis==0)\\n            return false;\\n        if(dp[vis]!=-1)\\n            return dp[vis];\\n        if(p)\\n        { \\n            bool ans=false;\\n           for(int i=0;i<maxi;i++)\\n           {\\n               if(vis&(1<<i))\\n                  ans=ans|solver(1-p,maxi,t-i-1,vis^(1<<i),dp);\\n               if(ans==true)\\n                return dp[vis]=ans;\\n           }\\n            return dp[vis]=ans;\\n        }\\n        else\\n        {\\n             bool ans=true;\\n           for(int i=0;i<maxi;i++)\\n           {\\n               if(vis&(1<<i))\\n                  ans=ans&solver(1-p,maxi,t-i-1,vis^(1<<i),dp);\\n               if(ans==false)\\n                   return dp[vis]=ans;\\n           }\\n            return dp[vis]=ans;\\n        }\\n    }\\n    bool canIWin(int maxi, int t) {\\n        int vis=pow(2,maxi)-1;\\n        int dp[vis+1];\\n        memset(dp,-1,sizeof(dp));\\n        if(t==0)\\n            return true;\\n         return solver(1,maxi,t,vis,dp);\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    bool solver(int p,int maxi,int t,int vis,int dp[])\\n    {\\n        if(t<=0&&p)\\n            return false;\\n        if(t<=0&&!p)\\n            return true;\\n        if(vis==0)\\n            return false;\\n        if(dp[vis]!=-1)\\n            return dp[vis];\\n        if(p)\\n        { \\n            bool ans=false;\\n           for(int i=0;i<maxi;i++)\\n           {\\n               if(vis&(1<<i))\\n                  ans=ans|solver(1-p,maxi,t-i-1,vis^(1<<i),dp);\\n               if(ans==true)\\n                return dp[vis]=ans;\\n           }\\n            return dp[vis]=ans;\\n        }\\n        else\\n        {\\n             bool ans=true;\\n           for(int i=0;i<maxi;i++)\\n           {\\n               if(vis&(1<<i))\\n                  ans=ans&solver(1-p,maxi,t-i-1,vis^(1<<i),dp);\\n               if(ans==false)\\n                   return dp[vis]=ans;\\n           }\\n            return dp[vis]=ans;\\n        }\\n    }\\n    bool canIWin(int maxi, int t) {\\n        int vis=pow(2,maxi)-1;\\n        int dp[vis+1];\\n        memset(dp,-1,sizeof(dp));\\n        if(t==0)\\n            return true;\\n         return solver(1,maxi,t,vis,dp);\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1126992,
                "title": "c-solution-without-bitmask",
                "content": "```\\nunordered_map<string,unordered_map<int,bool>> dp;\\n    bool fnd(string s,int d)\\n    {\\n        if(d<=0)\\n            return false;\\n        if(dp.find(s)!=dp.end())\\n        {\\n            auto& mp=dp[s];\\n            if(mp.find(d)!=mp.end())\\n                return dp[s][d];\\n        }\\n        for(int i=1;i<s.length();i++)\\n        {\\n            if(s[i]==\\'.\\')\\n                continue;\\n            s[i]=\\'.\\';\\n            if(!fnd(s,d-i))\\n            {\\n                s[i]=\\'1\\';\\n                return dp[s][d]=true;\\n            }\\n            s[i]=\\'1\\';\\n        }\\n        return dp[s][d]=false;\\n    }\\n    bool canIWin(int m, int d) {\\n        string s;\\n        int sum;\\n        for(int i=0;i<=m;i++)\\n        {\\n            s+=\\'1\\';\\n            sum+=i;\\n        }\\n        if(sum<d)\\n            return false;\\n        return d==0?true:fnd(s,d);\\n    }",
                "solutionTags": [],
                "code": "```\\nunordered_map<string,unordered_map<int,bool>> dp;\\n    bool fnd(string s,int d)\\n    {\\n        if(d<=0)\\n            return false;\\n        if(dp.find(s)!=dp.end())\\n        {\\n            auto& mp=dp[s];\\n            if(mp.find(d)!=mp.end())\\n                return dp[s][d];\\n        }\\n        for(int i=1;i<s.length();i++)\\n        {\\n            if(s[i]==\\'.\\')\\n                continue;\\n            s[i]=\\'.\\';\\n            if(!fnd(s,d-i))\\n            {\\n                s[i]=\\'1\\';\\n                return dp[s][d]=true;\\n            }\\n            s[i]=\\'1\\';\\n        }\\n        return dp[s][d]=false;\\n    }\\n    bool canIWin(int m, int d) {\\n        string s;\\n        int sum;\\n        for(int i=0;i<=m;i++)\\n        {\\n            s+=\\'1\\';\\n            sum+=i;\\n        }\\n        if(sum<d)\\n            return false;\\n        return d==0?true:fnd(s,d);\\n    }",
                "codeTag": "Unknown"
            },
            {
                "id": 1100970,
                "title": "dp-with-bitmask-java",
                "content": "```\\nclass Solution {\\n    \\n    public Map<Integer , Boolean> dp;\\n    \\n    public boolean canIWin(int maxChoosableInteger, int desiredTotal) {\\n        dp = new HashMap<>();\\n        int limit = (maxChoosableInteger * (maxChoosableInteger + 1)) / 2;\\n        if(desiredTotal > limit) return false;\\n        if(desiredTotal == 0) return true;\\n        \\n        return !util(desiredTotal , new boolean[maxChoosableInteger + 1] , maxChoosableInteger , 0);\\n    }\\n    \\n    public boolean util(int sum , boolean[] visited , int maxChoosableInteger , int mask) {\\n        if(sum <= 0) return true;\\n        boolean flag = false;\\n        if(dp.containsKey(mask)) return dp.get(mask);\\n        \\n        for(int i = 1 ; i <= maxChoosableInteger ; i++) {\\n            if(!visited[i]) {\\n                visited[i] = true;\\n                flag = flag || util(sum - i , visited , maxChoosableInteger , (1 << i) | mask);\\n                visited[i] = false;\\n            }\\n        }\\n        \\n        dp.put(mask , !flag);\\n        return !flag;\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    \\n    public Map<Integer , Boolean> dp;\\n    \\n    public boolean canIWin(int maxChoosableInteger, int desiredTotal) {\\n        dp = new HashMap<>();\\n        int limit = (maxChoosableInteger * (maxChoosableInteger + 1)) / 2;\\n        if(desiredTotal > limit) return false;\\n        if(desiredTotal == 0) return true;\\n        \\n        return !util(desiredTotal , new boolean[maxChoosableInteger + 1] , maxChoosableInteger , 0);\\n    }\\n    \\n    public boolean util(int sum , boolean[] visited , int maxChoosableInteger , int mask) {\\n        if(sum <= 0) return true;\\n        boolean flag = false;\\n        if(dp.containsKey(mask)) return dp.get(mask);\\n        \\n        for(int i = 1 ; i <= maxChoosableInteger ; i++) {\\n            if(!visited[i]) {\\n                visited[i] = true;\\n                flag = flag || util(sum - i , visited , maxChoosableInteger , (1 << i) | mask);\\n                visited[i] = false;\\n            }\\n        }\\n        \\n        dp.put(mask , !flag);\\n        return !flag;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1075710,
                "title": "java-memorization-and-bitmask",
                "content": "```\\nclass Solution {\\n    int[] memo;\\n    \\n    public boolean canIWin(int maxChoosableInteger, int desiredTotal) {\\n        int maxTotal = (maxChoosableInteger + 1) * maxChoosableInteger / 2;\\n        if (maxTotal < desiredTotal) return false;\\n        memo = new int[1<<maxChoosableInteger];\\n        return win(desiredTotal, maxChoosableInteger, 0);\\n    }\\n    \\n    private boolean win(int total, int n, int bitmask) {\\n        if (memo[bitmask] > 0) return true;\\n        else if (memo[bitmask] < 0) return false;\\n        \\n        for (int i = n; i >= 1; i--) {\\n            if ((bitmask & (1 << i - 1)) > 0) continue;\\n            if (i >= total) {\\n                memo[bitmask] = 1;\\n                return true;\\n            }\\n            if (!win(total - i, n, bitmask | (1 << i - 1))) {\\n                memo[bitmask] = 1;\\n                return true;\\n            }\\n        }\\n        memo[bitmask] = -1;\\n        return false;\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    int[] memo;\\n    \\n    public boolean canIWin(int maxChoosableInteger, int desiredTotal) {\\n        int maxTotal = (maxChoosableInteger + 1) * maxChoosableInteger / 2;\\n        if (maxTotal < desiredTotal) return false;\\n        memo = new int[1<<maxChoosableInteger];\\n        return win(desiredTotal, maxChoosableInteger, 0);\\n    }\\n    \\n    private boolean win(int total, int n, int bitmask) {\\n        if (memo[bitmask] > 0) return true;\\n        else if (memo[bitmask] < 0) return false;\\n        \\n        for (int i = n; i >= 1; i--) {\\n            if ((bitmask & (1 << i - 1)) > 0) continue;\\n            if (i >= total) {\\n                memo[bitmask] = 1;\\n                return true;\\n            }\\n            if (!win(total - i, n, bitmask | (1 << i - 1))) {\\n                memo[bitmask] = 1;\\n                return true;\\n            }\\n        }\\n        memo[bitmask] = -1;\\n        return false;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1069758,
                "title": "a-more-intuitive-solution-but-slower",
                "content": "use \"count\" to track player identity, even number is player 1, odd number is player2.\\nuse \"bitmap\" to track used number, standard technique that has been explained well by others\\n\\nDP returns if Player1 has a way to win regardless Player 2\\'s action\\n\\nso at Player 1\\'s turn, if any next state returns true, the current sate returns true. \\nat Player 2\\'s turn, only returning true when all of the next state return true. This means no matter how player 2 acts, in the next turn Player 1 has a way to force to win.\\n\\n```\\n#include<vector>\\n#include<unordered_map>\\nusing namespace std;\\n\\n//4:25 7:33 fucking silly bug\\nclass Solution {\\npublic:\\n    using mm = vector<vector<unordered_map<int, bool>>>;\\n    bool canIWin(int m, int d) {\\n        if (d <= m) {\\n            return true;\\n        }\\n        if (((1 + m) / 2 * m) < d) {\\n            return false;\\n        }\\n        int t = m;\\n        t = static_cast<int>(pow(2, m)) - 1;\\n        mm memo(2, vector<unordered_map<int, bool>>(d + 1, unordered_map<int, bool>()));\\n        return dp(t, d, 0, memo);\\n    }\\n\\n    bool dp(int bitmap, int total, int count, mm& memo) {\\n        if (total <= 0) {\\n            return count % 2 == 1;\\n        }\\n        if (memo[count % 2][total].find(bitmap) != memo[count % 2][total].end()) {\\n            return memo[count % 2][total][bitmap];\\n        }\\n        vector<int> r = parse(bitmap);\\n        bool result = true;\\n        if (count % 2 == 1) {\\n            result = true;\\n            for (auto& z : r) {\\n                int v = static_cast<int>(pow(2, z - 1));\\n                result &= dp(bitmap - v, total - z, count + 1, memo);\\n            }\\n        }\\n        else {\\n            result = false;\\n            for (auto& z : r) {\\n                int v = static_cast<int>(pow(2, z - 1));\\n                if (dp(bitmap - v, total - z, count + 1, memo)) {\\n                    result = true;\\n                    break;\\n                }\\n            }\\n        }\\n        return memo[count % 2][total][bitmap] = result;\\n    }\\n\\n\\n\\n    vector<int> parse(int bitmap) {\\n        vector<int> result;\\n        while (bitmap > 0) {\\n            int tmp = (bitmap - 1) & bitmap;\\n            result.push_back(static_cast<int>(log2((bitmap - tmp))) + 1);\\n            bitmap = tmp;\\n        }\\n        return result;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "C"
                ],
                "code": "```\\n#include<vector>\\n#include<unordered_map>\\nusing namespace std;\\n\\n//4:25 7:33 fucking silly bug\\nclass Solution {\\npublic:\\n    using mm = vector<vector<unordered_map<int, bool>>>;\\n    bool canIWin(int m, int d) {\\n        if (d <= m) {\\n            return true;\\n        }\\n        if (((1 + m) / 2 * m) < d) {\\n            return false;\\n        }\\n        int t = m;\\n        t = static_cast<int>(pow(2, m)) - 1;\\n        mm memo(2, vector<unordered_map<int, bool>>(d + 1, unordered_map<int, bool>()));\\n        return dp(t, d, 0, memo);\\n    }\\n\\n    bool dp(int bitmap, int total, int count, mm& memo) {\\n        if (total <= 0) {\\n            return count % 2 == 1;\\n        }\\n        if (memo[count % 2][total].find(bitmap) != memo[count % 2][total].end()) {\\n            return memo[count % 2][total][bitmap];\\n        }\\n        vector<int> r = parse(bitmap);\\n        bool result = true;\\n        if (count % 2 == 1) {\\n            result = true;\\n            for (auto& z : r) {\\n                int v = static_cast<int>(pow(2, z - 1));\\n                result &= dp(bitmap - v, total - z, count + 1, memo);\\n            }\\n        }\\n        else {\\n            result = false;\\n            for (auto& z : r) {\\n                int v = static_cast<int>(pow(2, z - 1));\\n                if (dp(bitmap - v, total - z, count + 1, memo)) {\\n                    result = true;\\n                    break;\\n                }\\n            }\\n        }\\n        return memo[count % 2][total][bitmap] = result;\\n    }\\n\\n\\n\\n    vector<int> parse(int bitmap) {\\n        vector<int> result;\\n        while (bitmap > 0) {\\n            int tmp = (bitmap - 1) & bitmap;\\n            result.push_back(static_cast<int>(log2((bitmap - tmp))) + 1);\\n            bitmap = tmp;\\n        }\\n        return result;\\n    }\\n};\\n```",
                "codeTag": "C++"
            },
            {
                "id": 1050505,
                "title": "memorization-minimax",
                "content": "```\\nclass Solution:\\n    def canIWin(self, maxChoosableInteger: int, desiredTotal: int) -> bool:\\n        if not desiredTotal: return True\\n        candi = tuple([x for x in range(1,maxChoosableInteger+1)])\\n        \\n        @lru_cache(None)\\n        def minimax(can, score, player):\\n            if score >=desiredTotal:\\n                return True if 1-player ==0 else False \\n            elif not can:\\n                return False\\n            else:\\n                if player ==0:\\n                    for i,e in enumerate(can):\\n                        if minimax(can[:i]+can[i+1:],score+e,1):\\n                            return True\\n                    return False\\n                else:\\n                    for i,e in enumerate(can):\\n                        if not minimax(can[:i]+can[i+1:],score+e,0):\\n                            return False\\n                    return True\\n        return minimax(candi,0,0)",
                "solutionTags": [],
                "code": "```\\nclass Solution:\\n    def canIWin(self, maxChoosableInteger: int, desiredTotal: int) -> bool:\\n        if not desiredTotal: return True\\n        candi = tuple([x for x in range(1,maxChoosableInteger+1)])\\n        \\n        @lru_cache(None)\\n        def minimax(can, score, player):\\n            if score >=desiredTotal:\\n                return True if 1-player ==0 else False \\n            elif not can:\\n                return False\\n            else:\\n                if player ==0:\\n                    for i,e in enumerate(can):\\n                        if minimax(can[:i]+can[i+1:],score+e,1):\\n                            return True\\n                    return False\\n                else:\\n                    for i,e in enumerate(can):\\n                        if not minimax(can[:i]+can[i+1:],score+e,0):\\n                            return False\\n                    return True\\n        return minimax(candi,0,0)",
                "codeTag": "Java"
            },
            {
                "id": 1022448,
                "title": "java-bitmask-dp",
                "content": "```\\nclass Solution {\\n    \\n    int maxChoosableInteger;\\n    int desiredTotal;\\n    HashMap<Integer, Boolean> hashMap;\\n    int OFFSET = 9; // 2^9 = 512 >= 300 \\n    public boolean canIWin(int maxChoosableInteger, int desiredTotal) {\\n        if (desiredTotal == 0)\\n            return true;\\n        if (maxChoosableInteger*(maxChoosableInteger+1)/2<desiredTotal)\\n            return false;\\n        \\n        hashMap = new HashMap<Integer, Boolean>();\\n        this.maxChoosableInteger = maxChoosableInteger;\\n        this.desiredTotal = desiredTotal;\\n        \\n        return dp(0, 0);\\n    }\\n    \\n    // you can also derive sum from profile so tech don\\'t need it but cba\\n    public boolean dp(int sum, int profile) {\\n        if (hashMap.get(profile)  != null)\\n            return hashMap.get(profile);\\n        \\n        boolean res = false;\\n        \\n        for (int i = OFFSET; i < OFFSET + maxChoosableInteger; i++) {\\n            if ((profile & (1 << i) ) != 0)\\n                continue;\\n            if (sum + i - OFFSET + 1 >= desiredTotal) {\\n                hashMap.put(profile, true);\\n                return true;\\n            }\\n            res = res || !dp(sum +i - OFFSET + 1, (profile | (1 << i)) + i - OFFSET + 1);\\n        }\\n        \\n        hashMap.put(profile, res);\\n        return res;\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    \\n    int maxChoosableInteger;\\n    int desiredTotal;\\n    HashMap<Integer, Boolean> hashMap;\\n    int OFFSET = 9; // 2^9 = 512 >= 300 \\n    public boolean canIWin(int maxChoosableInteger, int desiredTotal) {\\n        if (desiredTotal == 0)\\n            return true;\\n        if (maxChoosableInteger*(maxChoosableInteger+1)/2<desiredTotal)\\n            return false;\\n        \\n        hashMap = new HashMap<Integer, Boolean>();\\n        this.maxChoosableInteger = maxChoosableInteger;\\n        this.desiredTotal = desiredTotal;\\n        \\n        return dp(0, 0);\\n    }\\n    \\n    // you can also derive sum from profile so tech don\\'t need it but cba\\n    public boolean dp(int sum, int profile) {\\n        if (hashMap.get(profile)  != null)\\n            return hashMap.get(profile);\\n        \\n        boolean res = false;\\n        \\n        for (int i = OFFSET; i < OFFSET + maxChoosableInteger; i++) {\\n            if ((profile & (1 << i) ) != 0)\\n                continue;\\n            if (sum + i - OFFSET + 1 >= desiredTotal) {\\n                hashMap.put(profile, true);\\n                return true;\\n            }\\n            res = res || !dp(sum +i - OFFSET + 1, (profile | (1 << i)) + i - OFFSET + 1);\\n        }\\n        \\n        hashMap.put(profile, res);\\n        return res;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 988823,
                "title": "python-concise-bitmask",
                "content": "Observation: `2^20~10^6`, so it\\'s possible to calculate all combinations of the intergers and store the results using DP.\\nDP: use a bitmask whose `i`-th digit indicates if integer `i` is available and keep track of the remaining total.\\nTime complexity: `O(n 2^n)`\\n```\\nclass Solution:\\n    def canIWin(self, maxChoosableInteger: int, desiredTotal: int) -> bool:\\n        if desiredTotal==0:\\n            return True\\n        if desiredTotal> maxChoosableInteger*(1+maxChoosableInteger)//2:\\n            return False\\n        \\n        @lru_cache(None)\\n        def dfs(bitmsk,tot):\\n            if tot<=0:\\n                return False\\n            for i in range(maxChoosableInteger):\\n                if bitmsk&(1<<i) and not dfs(bitmsk-(1<<i),tot-i-1):\\n                    return True\\n            return False\\n        \\n        return dfs(2**maxChoosableInteger-1,desiredTotal)\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution:\\n    def canIWin(self, maxChoosableInteger: int, desiredTotal: int) -> bool:\\n        if desiredTotal==0:\\n            return True\\n        if desiredTotal> maxChoosableInteger*(1+maxChoosableInteger)//2:\\n            return False\\n        \\n        @lru_cache(None)\\n        def dfs(bitmsk,tot):\\n            if tot<=0:\\n                return False\\n            for i in range(maxChoosableInteger):\\n                if bitmsk&(1<<i) and not dfs(bitmsk-(1<<i),tot-i-1):\\n                    return True\\n            return False\\n        \\n        return dfs(2**maxChoosableInteger-1,desiredTotal)\\n```",
                "codeTag": "Java"
            },
            {
                "id": 944180,
                "title": "am-i-missing-something",
                "content": "maxChoosableInteger+1 is a losing situtation for either side. Similarly any multiple of (maxChoosableInteger+1) is also losing. Anything else is winning. [If m*(maxChoosableInteger+1) is losing (m+1)*( maxChoosableInteger+1) is also losing).\\nBut the test case case says \"maxChoosableInteger=10, desiredTotal =40\" is false. How is it? \\nIf player one plays 7, 33 will be left. Playler2 can pick any number (1,10), player 1 can set it in a way that 22 will be left. Then 11. Then player 2 will lose?\\nI wrote the following code just to verify but it also failed on that test case.\\n,,,\\n\\n    unordered_map<int, bool> dp;\\n    bool canIWin(int maxChoosableInteger, int desiredTotal) {\\n        if  (desiredTotal == 0)\\n            return false;\\n        if (desiredTotal <= maxChoosableInteger){\\n            dp [desiredTotal] = true;\\n            return true;\\n        }\\n        if (dp.find(desiredTotal) != dp.end()){\\n            return dp[desiredTotal];\\n        }\\n        for (int i = 1; i <= maxChoosableInteger; i++){\\n            if (!canIWin (maxChoosableInteger, desiredTotal-i){\\n                dp [desiredTotal] = true;\\n                return true;\\n            }\\n        }\\n        dp [desiredTotal] = false;\\n        return false;\\n    }\\n\\n...",
                "solutionTags": [],
                "code": "maxChoosableInteger+1 is a losing situtation for either side. Similarly any multiple of (maxChoosableInteger+1) is also losing. Anything else is winning. [If m*(maxChoosableInteger+1) is losing (m+1)*( maxChoosableInteger+1) is also losing).\\nBut the test case case says \"maxChoosableInteger=10, desiredTotal =40\" is false. How is it? \\nIf player one plays 7, 33 will be left. Playler2 can pick any number (1,10), player 1 can set it in a way that 22 will be left. Then 11. Then player 2 will lose?\\nI wrote the following code just to verify but it also failed on that test case.\\n,,,\\n\\n    unordered_map<int, bool> dp;\\n    bool canIWin(int maxChoosableInteger, int desiredTotal) {\\n        if  (desiredTotal == 0)\\n            return false;\\n        if (desiredTotal <= maxChoosableInteger){\\n            dp [desiredTotal] = true;\\n            return true;\\n        }\\n        if (dp.find(desiredTotal) != dp.end()){\\n            return dp[desiredTotal];\\n        }\\n        for (int i = 1; i <= maxChoosableInteger; i++){\\n            if (!canIWin (maxChoosableInteger, desiredTotal-i){\\n                dp [desiredTotal] = true;\\n                return true;\\n            }\\n        }\\n        dp [desiredTotal] = false;\\n        return false;\\n    }\\n\\n...",
                "codeTag": "Unknown"
            },
            {
                "id": 927222,
                "title": "my-swift-solution-beats-100-runtime-memory",
                "content": "My Swift solution\\n```\\nclass Solution {\\n    func canIWin(_ maxChoosableInteger: Int, _ desiredTotal: Int) -> Bool {\\n        if Int(Double(maxChoosableInteger) * Double(1 + maxChoosableInteger) / 2.0) < desiredTotal { return false }\\n        var dp = [Int: Bool]()\\n        func helper(_ total: Int, _ state: Int) -> Bool {\\n            if let savedResult = dp[state] { return savedResult }\\n            var result = false\\n            for i in stride(from: maxChoosableInteger, through: 1, by: -1) where ((state >> i) & 1) == 0 {\\n                if i >= total { result = true }\\n                result = result || !helper(total - i, state | (1 << i))\\n                if result { break }\\n            }\\n            dp[state] = result\\n            return result\\n        }\\n        return helper(desiredTotal, 0)\\n    }\\n}\\n```",
                "solutionTags": [
                    "Swift"
                ],
                "code": "```\\nclass Solution {\\n    func canIWin(_ maxChoosableInteger: Int, _ desiredTotal: Int) -> Bool {\\n        if Int(Double(maxChoosableInteger) * Double(1 + maxChoosableInteger) / 2.0) < desiredTotal { return false }\\n        var dp = [Int: Bool]()\\n        func helper(_ total: Int, _ state: Int) -> Bool {\\n            if let savedResult = dp[state] { return savedResult }\\n            var result = false\\n            for i in stride(from: maxChoosableInteger, through: 1, by: -1) where ((state >> i) & 1) == 0 {\\n                if i >= total { result = true }\\n                result = result || !helper(total - i, state | (1 << i))\\n                if result { break }\\n            }\\n            dp[state] = result\\n            return result\\n        }\\n        return helper(desiredTotal, 0)\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 750153,
                "title": "python-dfs-with-memo",
                "content": "\\tclass Solution(object):\\n\\t\\tdef canIWin(self, maxChoosableInteger, desiredTotal):\\n\\t\\t\\t\"\"\"\\n\\t\\t\\t:type maxChoosableInteger: int\\n\\t\\t\\t:type desiredTotal: int\\n\\t\\t\\t:rtype: bool\\n\\t\\t\\t\"\"\"\\n\\t\\t\\tvisit = [i + 1 for i in range(maxChoosableInteger)]\\n\\t\\t\\tif (1 + maxChoosableInteger) * maxChoosableInteger/2 < desiredTotal:\\n\\t\\t\\t\\treturn False\\n\\t\\t\\tif maxChoosableInteger >= desiredTotal:\\n\\t\\t\\t\\treturn True\\n\\t\\t\\treturn self.dfs(maxChoosableInteger, desiredTotal, visit, {})\\n\\n\\n\\t\\tdef dfs(self, choose, target, visit, memo):\\n\\t\\t\\tif tuple(visit) in memo:\\n\\t\\t\\t\\treturn memo[tuple(visit)]\\n\\n\\t\\t\\tif target <= 0: return False\\n\\t\\t\\tfor i in range(len(visit)):\\n\\t\\t\\t\\tif not self.dfs(choose, target - visit[i], visit[:i] + visit[i + 1:], memo):\\n\\t\\t\\t\\t\\tmemo[tuple(visit)] = True\\n\\t\\t\\t\\t\\treturn True\\n\\t\\t\\tmemo[tuple(visit)] = False\\n\\t\\t\\treturn False",
                "solutionTags": [],
                "code": "class Solution(object):\\n\\t\\tdef canIWin(self, maxChoosableInteger, desiredTotal):\\n\\t\\t\\t\"\"\"\\n\\t\\t\\t:type maxChoosableInteger: int\\n\\t\\t\\t:type desiredTotal: int\\n\\t\\t\\t:rtype: bool\\n\\t\\t\\t\"\"\"\\n\\t\\t\\tvisit = [i + 1 for i in range(maxChoosableInteger)]\\n\\t\\t\\tif (1 + maxChoosableInteger) * maxChoosableInteger/2 < desiredTotal:\\n\\t\\t\\t\\treturn False\\n\\t\\t\\tif maxChoosableInteger >= desiredTotal:\\n\\t\\t\\t\\treturn True\\n\\t\\t\\treturn self.dfs(maxChoosableInteger, desiredTotal, visit, {}",
                "codeTag": "Java"
            },
            {
                "id": 735653,
                "title": "does-this-problem-have-polynomial-solution",
                "content": "I have read many solutions in the discussion. However, none of them is guaranteed with polynomial time complexity. Those DP or recursive solutions are actually similar to brute-force search, and I think the time complexity in the worst case is O(maxChoosableInteger!).",
                "solutionTags": [],
                "code": "I have read many solutions in the discussion. However, none of them is guaranteed with polynomial time complexity. Those DP or recursive solutions are actually similar to brute-force search, and I think the time complexity in the worst case is O(maxChoosableInteger!).",
                "codeTag": "Unknown"
            },
            {
                "id": 670196,
                "title": "c-very-clean-and-concise-top-down-memoization",
                "content": "```cpp\\nclass Solution {\\n public:\\n  bool canIWin(int maxChoosableInteger, int desiredTotal) {\\n    if (desiredTotal <= 0) return true;\\n\\n    const int sum = maxChoosableInteger * (maxChoosableInteger + 1) / 2;\\n    if (sum < desiredTotal) return false;\\n\\n    unordered_map<int, bool> memo;  // true: can win, false: can\\'t win\\n\\n    // state: record integers that have been chosen\\n    function<bool(int, int)> dp = [&](int total, int state) {\\n      if (total <= 0) return false;\\n      if (memo.count(state)) return memo[state];\\n\\n      for (int i = 1; i <= maxChoosableInteger; ++i) {\\n        if (state & (1 << i)) continue;  // integer i is used\\n        if (!dp(total - i, state | (1 << i))) return true;\\n      }\\n\\n      return memo[state] = false;\\n    };\\n\\n    return dp(desiredTotal, 0);\\n  }\\n};\\n```",
                "solutionTags": [],
                "code": "```cpp\\nclass Solution {\\n public:\\n  bool canIWin(int maxChoosableInteger, int desiredTotal) {\\n    if (desiredTotal <= 0) return true;\\n\\n    const int sum = maxChoosableInteger * (maxChoosableInteger + 1) / 2;\\n    if (sum < desiredTotal) return false;\\n\\n    unordered_map<int, bool> memo;  // true: can win, false: can\\'t win\\n\\n    // state: record integers that have been chosen\\n    function<bool(int, int)> dp = [&](int total, int state) {\\n      if (total <= 0) return false;\\n      if (memo.count(state)) return memo[state];\\n\\n      for (int i = 1; i <= maxChoosableInteger; ++i) {\\n        if (state & (1 << i)) continue;  // integer i is used\\n        if (!dp(total - i, state | (1 << i))) return true;\\n      }\\n\\n      return memo[state] = false;\\n    };\\n\\n    return dp(desiredTotal, 0);\\n  }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 619808,
                "title": "python-top-down-dp-memoization-easy-to-understand",
                "content": "```py\\nfrom functools import lru_cache\\nclass Solution:\\n    @lru_cache(None)\\n    def helper(self, target, mc, mask=None):\\n\\t    \\'\\'\\'\\n\\t\\tIt can be easily summarized as a minimax problem (we\\'re using a digits DP here for \\n\\t\\toptimization). \\n\\t\\tHere, target -> desiredTarget, mask -> current_state. \\n\\t\\tSince, we can choose an integer (in range 1 to mc) we\\'ve used mask as an integer of mc bits,\\n\\t\\twhich are either set (unused) or unset (used).\\n\\t\\t\\n\\t\\tThe subproblem can be defined as:\\n\\t\\tX can win with a particular state (mask) and a target,\\n\\t\\t   if for any i from 1 to mc (i not already used), \\n\\t\\t        Y can\\'t win with state(mask - {i}) and (target -i)\\n\\t\\t\\n\\t\\tHope you understand with this sloppy explanation, if not please ask :)\\n\\t\\t\\'\\'\\'\\n\\t\\t\\n\\t\\t# Base case, if target <= 0, \\n\\t\\t# the match has already ended in the previous state\\n        if(target <= 0):\\n            return False\\n\\t\\t\\t\\n        if(mask==None):\\n            mask = (1 << mc) - 1\\n        \\n        res = True\\n        for i in range(1, mc+1):\\n            if(((mask >> (i-1)) & 1) == 0):\\n                continue\\n\\t\\t\\t# unsetting the i\\'th bit using:  mask ^ (1 << (i-1))\\n            res = res and self.helper(target-i, mc, mask ^ (1 << (i-1)))\\n        \\n        return not res\\n        \\n        \\n            \\n    def canIWin(self, maxChoosableInteger: int, desiredTotal: int) -> bool:\\n\\t    # Two corner-cases not handled by the helper function\\n\\t\\t# 1. If the desiredTotal is already 0, the player is considered the winner, since he can \\n\\t\\t#    use any number and the total becomes more than desired total\\n        if(desiredTotal == 0): return True\\n\\t\\t\\n\\t\\t# 2. If the desiredTotal is more than the possible sum using all the numbers from 1 to\\n\\t\\t#    maxChoosableInteger, than it is not possible to win anyhow\\n        if((maxChoosableInteger * (maxChoosableInteger + 1)) // 2 < desiredTotal): return False\\n        \\n\\t\\t# Otherwise\\n        return self.helper(desiredTotal, maxChoosableInteger)\\n```",
                "solutionTags": [],
                "code": "```py\\nfrom functools import lru_cache\\nclass Solution:\\n    @lru_cache(None)\\n    def helper(self, target, mc, mask=None):\\n\\t    \\'\\'\\'\\n\\t\\tIt can be easily summarized as a minimax problem (we\\'re using a digits DP here for \\n\\t\\toptimization). \\n\\t\\tHere, target -> desiredTarget, mask -> current_state. \\n\\t\\tSince, we can choose an integer (in range 1 to mc) we\\'ve used mask as an integer of mc bits,\\n\\t\\twhich are either set (unused) or unset (used).\\n\\t\\t\\n\\t\\tThe subproblem can be defined as:\\n\\t\\tX can win with a particular state (mask) and a target,\\n\\t\\t   if for any i from 1 to mc (i not already used), \\n\\t\\t        Y can\\'t win with state(mask - {i}) and (target -i)\\n\\t\\t\\n\\t\\tHope you understand with this sloppy explanation, if not please ask :)\\n\\t\\t\\'\\'\\'\\n\\t\\t\\n\\t\\t# Base case, if target <= 0, \\n\\t\\t# the match has already ended in the previous state\\n        if(target <= 0):\\n            return False\\n\\t\\t\\t\\n        if(mask==None):\\n            mask = (1 << mc) - 1\\n        \\n        res = True\\n        for i in range(1, mc+1):\\n            if(((mask >> (i-1)) & 1) == 0):\\n                continue\\n\\t\\t\\t# unsetting the i\\'th bit using:  mask ^ (1 << (i-1))\\n            res = res and self.helper(target-i, mc, mask ^ (1 << (i-1)))\\n        \\n        return not res\\n        \\n        \\n            \\n    def canIWin(self, maxChoosableInteger: int, desiredTotal: int) -> bool:\\n\\t    # Two corner-cases not handled by the helper function\\n\\t\\t# 1. If the desiredTotal is already 0, the player is considered the winner, since he can \\n\\t\\t#    use any number and the total becomes more than desired total\\n        if(desiredTotal == 0): return True\\n\\t\\t\\n\\t\\t# 2. If the desiredTotal is more than the possible sum using all the numbers from 1 to\\n\\t\\t#    maxChoosableInteger, than it is not possible to win anyhow\\n        if((maxChoosableInteger * (maxChoosableInteger + 1)) // 2 < desiredTotal): return False\\n        \\n\\t\\t# Otherwise\\n        return self.helper(desiredTotal, maxChoosableInteger)\\n```",
                "codeTag": "Java"
            },
            {
                "id": 540581,
                "title": "optimal-storage-decent-explanation-python",
                "content": "```python\\nclass Solution:\\n    def canIWin(self, maxChoosableInteger: int, desiredTotal: int) -> bool:\\n        # If you are not given enough integers to work with,\\n        # then you cannot achieve the desired total.\\n        if sum(range(1, maxChoosableInteger + 1)) < desiredTotal:\\n            return False\\n        \\n        # If you are called with a desired total that is less than\\n        # or equal to 0, player 1 wins.\\n        if desiredTotal <= 0:\\n            return True\\n        \\n        # Start exploration!\\n        return self.explore(maxChoosableInteger, desiredTotal, 0, {})\\n        \\n    \\n    def explore(self, maxChoosableInteger, desiredTotal, usedIntegers, stateSpace):\\n        # This indicates, not that the desiredTotal was given as 0 at the beginning of\\n        # the program. Instead, this indicates that the desiredTotal reaches 0 when\\n        # the caller (another player) has picked a number that causes this to go to 0.\\n        if desiredTotal <= 0:\\n            return False\\n        \\n        # Generates a state representation from used integers and desired total.\\n        def state(usedIntegers, desiredTotal): return f\"{usedIntegers}-${desiredTotal}\"\\n        currentState = state(usedIntegers, desiredTotal)\\n\\n        # If the state has been seen, then just return the verdict. The verdict that\\n        # is stored is with respect to the player in the context of this run. This \\n        # could be player 1 or player 2. What is confusing is, why are we storing the\\n        # verdicts for player 2. The answer is simple, player 1 might find itself in the\\n        # same state as player 2 and we ought to store the correct verdict in that case.\\n        if currentState in stateSpace:\\n            return stateSpace[currentState]\\n        \\n        nextPlayerLoses = False\\n        for integer in range(1, maxChoosableInteger + 1):\\n            # Do the following only if the integer is not already used.\\n            if usedIntegers & 1 << integer: continue\\n            # Mark the integer as used.\\n            usedIntegers ^= 1 << integer\\n            # The \"not\" here is super critical. The function call will return True or False\\n            # based on whether it is possible to win in the provided state. If it is not\\n            # possible for the next player to win even in one of the many sub-states, the\\n            # nextPlayerLoses is set to True!\\n            nextPlayerLoses = not self.explore(maxChoosableInteger, desiredTotal - integer, usedIntegers, stateSpace)\\n            # Unmark the integer as used.\\n            usedIntegers ^= 1 << integer\\n            \\n            # We stop here because we have found a way to coerce the next player to lose.\\n            # That is all we need to validate. We need only 1 way to cooerce the next player.\\n            if nextPlayerLoses:\\n                break\\n        \\n        stateSpace[currentState] = nextPlayerLoses\\n        \\n        return stateSpace[currentState]\\n```",
                "solutionTags": [],
                "code": "```python\\nclass Solution:\\n    def canIWin(self, maxChoosableInteger: int, desiredTotal: int) -> bool:\\n        # If you are not given enough integers to work with,\\n        # then you cannot achieve the desired total.\\n        if sum(range(1, maxChoosableInteger + 1)) < desiredTotal:\\n            return False\\n        \\n        # If you are called with a desired total that is less than\\n        # or equal to 0, player 1 wins.\\n        if desiredTotal <= 0:\\n            return True\\n        \\n        # Start exploration!\\n        return self.explore(maxChoosableInteger, desiredTotal, 0, {})\\n        \\n    \\n    def explore(self, maxChoosableInteger, desiredTotal, usedIntegers, stateSpace):\\n        # This indicates, not that the desiredTotal was given as 0 at the beginning of\\n        # the program. Instead, this indicates that the desiredTotal reaches 0 when\\n        # the caller (another player) has picked a number that causes this to go to 0.\\n        if desiredTotal <= 0:\\n            return False\\n        \\n        # Generates a state representation from used integers and desired total.\\n        def state(usedIntegers, desiredTotal): return f\"{usedIntegers}-${desiredTotal}\"\\n        currentState = state(usedIntegers, desiredTotal)\\n\\n        # If the state has been seen, then just return the verdict. The verdict that\\n        # is stored is with respect to the player in the context of this run. This \\n        # could be player 1 or player 2. What is confusing is, why are we storing the\\n        # verdicts for player 2. The answer is simple, player 1 might find itself in the\\n        # same state as player 2 and we ought to store the correct verdict in that case.\\n        if currentState in stateSpace:\\n            return stateSpace[currentState]\\n        \\n        nextPlayerLoses = False\\n        for integer in range(1, maxChoosableInteger + 1):\\n            # Do the following only if the integer is not already used.\\n            if usedIntegers & 1 << integer: continue\\n            # Mark the integer as used.\\n            usedIntegers ^= 1 << integer\\n            # The \"not\" here is super critical. The function call will return True or False\\n            # based on whether it is possible to win in the provided state. If it is not\\n            # possible for the next player to win even in one of the many sub-states, the\\n            # nextPlayerLoses is set to True!\\n            nextPlayerLoses = not self.explore(maxChoosableInteger, desiredTotal - integer, usedIntegers, stateSpace)\\n            # Unmark the integer as used.\\n            usedIntegers ^= 1 << integer\\n            \\n            # We stop here because we have found a way to coerce the next player to lose.\\n            # That is all we need to validate. We need only 1 way to cooerce the next player.\\n            if nextPlayerLoses:\\n                break\\n        \\n        stateSpace[currentState] = nextPlayerLoses\\n        \\n        return stateSpace[currentState]\\n```",
                "codeTag": "Java"
            },
            {
                "id": 419689,
                "title": "python-3-used-set-or-bit",
                "content": "1 set method\\n```\\n    def canIWin(self, maxChoosableInteger: int, desiredTotal: int) -> bool:\\n        if (1 + maxChoosableInteger) * maxChoosableInteger // 2 < desiredTotal:\\n            return False\\n        if maxChoosableInteger >= desiredTotal:\\n            return True\\n\\n        def _can_win_helper(memory, visited, desired_target):\\n            key = tuple(visited)\\n            if key in memory:\\n                return memory[key]\\n            for cur in range(1, maxChoosableInteger + 1):\\n                if cur not in visited:\\n                    if cur >= desired_target or not _can_win_helper(memory, visited | {cur}, desired_target - cur):\\n                        memory[key] = True\\n                        return True\\n            memory[key] = False\\n            return False\\n\\n        return _can_win_helper({}, set(), desiredTotal)\\n```\\n2 bit method\\n```\\n    def canIWin(self, maxChoosableInteger: int, desiredTotal: int) -> bool:\\n        if (1 + maxChoosableInteger) * maxChoosableInteger // 2 < desiredTotal:\\n            return False\\n        if maxChoosableInteger >= desiredTotal:\\n            return True\\n\\n        def _can_win_helper(memory, choose_integer, desired_target):\\n            if choose_integer in memory:\\n                return memory[choose_integer]\\n            for i in range(maxChoosableInteger):\\n                cur = 1 << i\\n                if cur & choose_integer == 0:\\n                    if i+1 >= desired_target or not _can_win_helper(memory, choose_integer | cur, desired_target-i-1):\\n                        memory[choose_integer] = True\\n                        return True\\n            memory[choose_integer] = False\\n            return False\\n\\n        return _can_win_helper({}, 0, desiredTotal)\\n```",
                "solutionTags": [],
                "code": "```\\n    def canIWin(self, maxChoosableInteger: int, desiredTotal: int) -> bool:\\n        if (1 + maxChoosableInteger) * maxChoosableInteger // 2 < desiredTotal:\\n            return False\\n        if maxChoosableInteger >= desiredTotal:\\n            return True\\n\\n        def _can_win_helper(memory, visited, desired_target):\\n            key = tuple(visited)\\n            if key in memory:\\n                return memory[key]\\n            for cur in range(1, maxChoosableInteger + 1):\\n                if cur not in visited:\\n                    if cur >= desired_target or not _can_win_helper(memory, visited | {cur}, desired_target - cur):\\n                        memory[key] = True\\n                        return True\\n            memory[key] = False\\n            return False\\n\\n        return _can_win_helper({}, set(), desiredTotal)\\n```\n```\\n    def canIWin(self, maxChoosableInteger: int, desiredTotal: int) -> bool:\\n        if (1 + maxChoosableInteger) * maxChoosableInteger // 2 < desiredTotal:\\n            return False\\n        if maxChoosableInteger >= desiredTotal:\\n            return True\\n\\n        def _can_win_helper(memory, choose_integer, desired_target):\\n            if choose_integer in memory:\\n                return memory[choose_integer]\\n            for i in range(maxChoosableInteger):\\n                cur = 1 << i\\n                if cur & choose_integer == 0:\\n                    if i+1 >= desired_target or not _can_win_helper(memory, choose_integer | cur, desired_target-i-1):\\n                        memory[choose_integer] = True\\n                        return True\\n            memory[choose_integer] = False\\n            return False\\n\\n        return _can_win_helper({}, 0, desiredTotal)\\n```",
                "codeTag": "Python3"
            },
            {
                "id": 377804,
                "title": "java-solution-with-minimax",
                "content": "Assuming opponent will play optimally, so to win, there should be at least one node returning true (Maximizing) and opponent to lose, there should not be any node returning true(Miniminizing).\\n\\n```\\nclass Solution {\\n    int[] numbersPool;\\n    int desiredTotal;\\n\\tMap<String, Boolean> map;\\n    \\n    public String formKey(){\\n        StringBuilder builder = new StringBuilder();\\n        for(int i=0; i<numbersPool.length; i++){\\n            builder.append(numbersPool[i]);\\n        }\\n        return builder.toString();\\n    }\\n    \\n    //max ||\\n    //min &&\\n    \\n    public boolean canIWin(int sumSoFar, boolean isMax){\\n        if(sumSoFar >= desiredTotal){\\n            return !isMax;\\n        }\\n\\t\\tString curr = formKey();\\n\\t\\tif(map.containsKey(curr)) return map.get(curr);\\n        boolean res;\\n        if(isMax)\\n            res = false;\\n        else\\n            res = true;\\n        for(int i=1; i<numbersPool.length; i++){\\n            if(numbersPool[i] == 0){\\n                numbersPool[i] = 1;\\n                \\n                if(isMax)\\n                    res = res || canIWin(sumSoFar + i, false);\\n                else\\n                    res = res && canIWin(sumSoFar + i, true);\\n                \\n                numbersPool[i] = 0;\\n            }\\n        }\\n\\t\\tmap.put(curr, res);\\n        return res;\\n    }\\n    \\n    public boolean canIWin(int maxChoosableInteger, int desiredTotal) {\\n        \\n        if (desiredTotal<=0) return true;\\n        if (maxChoosableInteger*(maxChoosableInteger+1)/2<desiredTotal) return false;\\n        if (maxChoosableInteger >= desiredTotal) return true;\\n\\t\\tmap = new HashMap<>();\\n        numbersPool = new int[maxChoosableInteger+1];\\n        this.desiredTotal = desiredTotal;\\n        return canIWin(0,true);\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    int[] numbersPool;\\n    int desiredTotal;\\n\\tMap<String, Boolean> map;\\n    \\n    public String formKey(){\\n        StringBuilder builder = new StringBuilder();\\n        for(int i=0; i<numbersPool.length; i++){\\n            builder.append(numbersPool[i]);\\n        }\\n        return builder.toString();\\n    }\\n    \\n    //max ||\\n    //min &&\\n    \\n    public boolean canIWin(int sumSoFar, boolean isMax){\\n        if(sumSoFar >= desiredTotal){\\n            return !isMax;\\n        }\\n\\t\\tString curr = formKey();\\n\\t\\tif(map.containsKey(curr)) return map.get(curr);\\n        boolean res;\\n        if(isMax)\\n            res = false;\\n        else\\n            res = true;\\n        for(int i=1; i<numbersPool.length; i++){\\n            if(numbersPool[i] == 0){\\n                numbersPool[i] = 1;\\n                \\n                if(isMax)\\n                    res = res || canIWin(sumSoFar + i, false);\\n                else\\n                    res = res && canIWin(sumSoFar + i, true);\\n                \\n                numbersPool[i] = 0;\\n            }\\n        }\\n\\t\\tmap.put(curr, res);\\n        return res;\\n    }\\n    \\n    public boolean canIWin(int maxChoosableInteger, int desiredTotal) {\\n        \\n        if (desiredTotal<=0) return true;\\n        if (maxChoosableInteger*(maxChoosableInteger+1)/2<desiredTotal) return false;\\n        if (maxChoosableInteger >= desiredTotal) return true;\\n\\t\\tmap = new HashMap<>();\\n        numbersPool = new int[maxChoosableInteger+1];\\n        this.desiredTotal = desiredTotal;\\n        return canIWin(0,true);\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 374055,
                "title": "what-is-so-special-about-testcase-m-18-n-79",
                "content": "It is difficult to print 79 states of the game and see why my algorithm fails, so maybe someone knows: what cornercase does this testcase suggest? My answer is False, but the right one is True\\n\\n```\\nmem = [-1 for i in range (1000)]\\n\\ndef f(m, n):\\n    global mem\\n    if (mem[n] != -1):\\n        return mem[n]\\n    if (n == 0):\\n        mem[n] = True\\n        return True\\n    if (n <= m):\\n        for i in range(1, m + 1):\\n            mem[i] = True\\n        return True\\n    cur_state_win = False\\n    for i in range(1, m + 1): \\n        cur_state_win = cur_state_win or (not f(m, n - i))\\n        \\n    mem[n] = cur_state_win\\n    return cur_state_win\\n\\ndef yt(m, n, used):\\n    i_can_win = True\\n    print(\\'yo\\', n, used)\\n    for i in range(1, m + 1):\\n        if (used[i]):\\n            continue\\n        new_used = list(used)\\n        new_used[i] = True\\n        i_can_win = i_can_win and mt(m, n - i, new_used)\\n    return i_can_win\\n\\ndef mt(m, n, used):\\n    print(\\'my\\', n, used)\\n    global mem\\n    for i in range (1, m + 1):\\n        if (i >= n):\\n            return True\\n        if (used[i]):\\n            continue\\n        if (mem[n - i]):\\n            continue\\n        new_used = list(used)\\n        new_used[i] = True\\n        if yt(m, n - i, new_used):\\n            return True\\n    return False\\n\\ndef s(m, n):\\n    global mem\\n    mem[0] = True\\n    if not f(m, n):\\n        return False\\n    print(f(m, n))\\n    for i in range (n + 1):\\n        print(i, mem[i])\\n    print(f(m, n))\\n    ans = mt(m, n, [False for i in range(m + 1)])\\n    mem = [-1 for i in range(1000)]\\n    return ans\\n\\n```",
                "solutionTags": [],
                "code": "```\\nmem = [-1 for i in range (1000)]\\n\\ndef f(m, n):\\n    global mem\\n    if (mem[n] != -1):\\n        return mem[n]\\n    if (n == 0):\\n        mem[n] = True\\n        return True\\n    if (n <= m):\\n        for i in range(1, m + 1):\\n            mem[i] = True\\n        return True\\n    cur_state_win = False\\n    for i in range(1, m + 1): \\n        cur_state_win = cur_state_win or (not f(m, n - i))\\n        \\n    mem[n] = cur_state_win\\n    return cur_state_win\\n\\ndef yt(m, n, used):\\n    i_can_win = True\\n    print(\\'yo\\', n, used)\\n    for i in range(1, m + 1):\\n        if (used[i]):\\n            continue\\n        new_used = list(used)\\n        new_used[i] = True\\n        i_can_win = i_can_win and mt(m, n - i, new_used)\\n    return i_can_win\\n\\ndef mt(m, n, used):\\n    print(\\'my\\', n, used)\\n    global mem\\n    for i in range (1, m + 1):\\n        if (i >= n):\\n            return True\\n        if (used[i]):\\n            continue\\n        if (mem[n - i]):\\n            continue\\n        new_used = list(used)\\n        new_used[i] = True\\n        if yt(m, n - i, new_used):\\n            return True\\n    return False\\n\\ndef s(m, n):\\n    global mem\\n    mem[0] = True\\n    if not f(m, n):\\n        return False\\n    print(f(m, n))\\n    for i in range (n + 1):\\n        print(i, mem[i])\\n    print(f(m, n))\\n    ans = mt(m, n, [False for i in range(m + 1)])\\n    mem = [-1 for i in range(1000)]\\n    return ans\\n\\n```",
                "codeTag": "Python3"
            },
            {
                "id": 331333,
                "title": "python-dfs-solution",
                "content": "```\\nclass Solution(object):\\n    def canIWin(self, maxChoosableInteger, desiredTotal):\\n        \"\"\"\\n        :type maxChoosableInteger: int\\n        :type desiredTotal: int\\n        :rtype: bool\\n        \"\"\"\\n        if maxChoosableInteger>=desiredTotal:\\n            return True\\n        if (maxChoosableInteger+1)*maxChoosableInteger/2<desiredTotal:\\n            return False\\n        status = (1<<maxChoosableInteger) -1\\n        dp = [dict() for _ in range(desiredTotal+1)]\\n        return self.minMax(status,dp,desiredTotal,maxChoosableInteger)\\n    def minMax(self,status,dp,goal,maxInt):\\n        if status in dp[goal]:\\n            return dp[goal][status]\\n        for i in range(1,maxInt+1):\\n            if status & 1<<(i-1):\\n                if i>=goal or not self.minMax(status^1<<(i-1),dp,goal-i,maxInt):\\n                    dp[goal][status] = True\\n                    return True\\n        dp[goal][status] = False\\n        return False\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution(object):\\n    def canIWin(self, maxChoosableInteger, desiredTotal):\\n        \"\"\"\\n        :type maxChoosableInteger: int\\n        :type desiredTotal: int\\n        :rtype: bool\\n        \"\"\"\\n        if maxChoosableInteger>=desiredTotal:\\n            return True\\n        if (maxChoosableInteger+1)*maxChoosableInteger/2<desiredTotal:\\n            return False\\n        status = (1<<maxChoosableInteger) -1\\n        dp = [dict() for _ in range(desiredTotal+1)]\\n        return self.minMax(status,dp,desiredTotal,maxChoosableInteger)\\n    def minMax(self,status,dp,goal,maxInt):\\n        if status in dp[goal]:\\n            return dp[goal][status]\\n        for i in range(1,maxInt+1):\\n            if status & 1<<(i-1):\\n                if i>=goal or not self.minMax(status^1<<(i-1),dp,goal-i,maxInt):\\n                    dp[goal][status] = True\\n                    return True\\n        dp[goal][status] = False\\n        return False\\n```",
                "codeTag": "Java"
            },
            {
                "id": 322347,
                "title": "javascript-js-solution-would-like-some-help-on-making-it-faster",
                "content": "Hi - the following code works and it makes sense to me but it seems like I have the code written in a way that is quite inefficient and isn\\'t taking full advantage of memoization. If you have any advice or tips on how to make this fast - I would appreciate it\\n\\n```\\nvar canIWin = function(maxChoosableInteger, desiredTotal) {\\n    if (desiredTotal<=(maxChoosableInteger)){\\n        return true\\n    }\\n    if( (maxChoosableInteger+1)*(maxChoosableInteger/2)< desiredTotal){\\n        return false\\n       }\\n    let winDict = {}\\n    let numbers = new Array(maxChoosableInteger)\\n    numbers.fill(1)\\n    for (let i =1; i<numbers.length; i++){\\n        numbers[i]= numbers[i-1]+1\\n    }\\n    function helper(numbs, player,total){\\n        if(total>=desiredTotal){\\n            if(player===1){\\n                winDict[numbs]=false\\n                return false\\n            }\\n            else{\\n                winDict[numbs]=true\\n                return true\\n            }\\n        }\\n        if(player===1){\\n            if(winDict[numbs]!=undefined){\\n                return winDict[numbs]\\n            }\\n            for (let i =0; i<numbs.length; i++){\\n                let tester = [...numbs]\\n                let added = numbs[i]\\n                tester.splice(i,1)\\n                if(winDict[tester]=== undefined){\\n                    if(helper(tester,2,added+total)){\\n                        \\n                        winDict[numbs]=true\\n                        return true\\n                    }\\n                }\\n                else {\\n                    if(winDict[tester]){\\n                    winDict[numbs]=true\\n                    return true\\n                    }\\n                }\\n            }\\n            winDict[numbs] = false\\n            return false\\n        } \\n        else if(player===2){\\n            if(winDict[numbs]!=undefined){\\n                return winDict[numbs]\\n            }\\n            for (let i =0; i<numbs.length; i++){\\n                let tester = [...numbs]\\n                let added = numbs[i]\\n                tester.splice(i,1)\\n                if(winDict[tester]=== undefined){\\n                    if(!helper(tester,1,added+total)){\\n                        winDict[numbs]=false\\n                        return false\\n                    }\\n                }\\n                else {\\n                    if(!winDict[tester]){\\n                    winDict[numbs]=false\\n                    return false\\n                    }\\n                }\\n            }\\n            winDict[numbs] = true\\n            return true\\n        }   \\n    }\\n   let answer = helper(numbers,1,0)\\n   return answer\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nvar canIWin = function(maxChoosableInteger, desiredTotal) {\\n    if (desiredTotal<=(maxChoosableInteger)){\\n        return true\\n    }\\n    if( (maxChoosableInteger+1)*(maxChoosableInteger/2)< desiredTotal){\\n        return false\\n       }\\n    let winDict = {}\\n    let numbers = new Array(maxChoosableInteger)\\n    numbers.fill(1)\\n    for (let i =1; i<numbers.length; i++){\\n        numbers[i]= numbers[i-1]+1\\n    }\\n    function helper(numbs, player,total){\\n        if(total>=desiredTotal){\\n            if(player===1){\\n                winDict[numbs]=false\\n                return false\\n            }\\n            else{\\n                winDict[numbs]=true\\n                return true\\n            }\\n        }\\n        if(player===1){\\n            if(winDict[numbs]!=undefined){\\n                return winDict[numbs]\\n            }\\n            for (let i =0; i<numbs.length; i++){\\n                let tester = [...numbs]\\n                let added = numbs[i]\\n                tester.splice(i,1)\\n                if(winDict[tester]=== undefined){\\n                    if(helper(tester,2,added+total)){\\n                        \\n                        winDict[numbs]=true\\n                        return true\\n                    }\\n                }\\n                else {\\n                    if(winDict[tester]){\\n                    winDict[numbs]=true\\n                    return true\\n                    }\\n                }\\n            }\\n            winDict[numbs] = false\\n            return false\\n        } \\n        else if(player===2){\\n            if(winDict[numbs]!=undefined){\\n                return winDict[numbs]\\n            }\\n            for (let i =0; i<numbs.length; i++){\\n                let tester = [...numbs]\\n                let added = numbs[i]\\n                tester.splice(i,1)\\n                if(winDict[tester]=== undefined){\\n                    if(!helper(tester,1,added+total)){\\n                        winDict[numbs]=false\\n                        return false\\n                    }\\n                }\\n                else {\\n                    if(!winDict[tester]){\\n                    winDict[numbs]=false\\n                    return false\\n                    }\\n                }\\n            }\\n            winDict[numbs] = true\\n            return true\\n        }   \\n    }\\n   let answer = helper(numbers,1,0)\\n   return answer\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 293036,
                "title": "very-short-and-straightforward-classic-back-and-track-java-code-92ms",
                "content": "\\n```\\n/*\\nchar[] used,  array to store the status of remain positions\\nMap<String, Boolean> cache, map to store the visited status\\ntime: 0(n!) when n is the max number\\n*/\\nclass Solution {\\n    public boolean canIWin(int max, int N) {\\n        if(N<=0) return true;\\n        if((max+1)*max/2<N) return false;\\n        char[] used= new char[max+1];\\n        Arrays.fill(used,\\'1\\');\\n        Map<String, Boolean> cache = new HashMap<>();\\n        return dfs(used, cache,N);\\n    }\\n    boolean dfs(char[] used,Map<String, Boolean> cache, int n){\\n        if(n<=0) return false;\\n        String key = new String(used);\\n        if(cache.containsKey(key)) return cache.get(key);\\n        boolean ans= false;\\n        for(int i=1;i<used.length; i++){\\n          if(used[i]==\\'1\\'){\\n              used[i]=\\'0\\';\\n              if(!dfs(used, cache, n-i)) ans=true;\\n              used[i]=\\'1\\';\\n              if(ans) break;\\n          }   \\n        }\\n        cache.put(new String(used),ans);\\n        return ans;\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\n/*\\nchar[] used,  array to store the status of remain positions\\nMap<String, Boolean> cache, map to store the visited status\\ntime: 0(n!) when n is the max number\\n*/\\nclass Solution {\\n    public boolean canIWin(int max, int N) {\\n        if(N<=0) return true;\\n        if((max+1)*max/2<N) return false;\\n        char[] used= new char[max+1];\\n        Arrays.fill(used,\\'1\\');\\n        Map<String, Boolean> cache = new HashMap<>();\\n        return dfs(used, cache,N);\\n    }\\n    boolean dfs(char[] used,Map<String, Boolean> cache, int n){\\n        if(n<=0) return false;\\n        String key = new String(used);\\n        if(cache.containsKey(key)) return cache.get(key);\\n        boolean ans= false;\\n        for(int i=1;i<used.length; i++){\\n          if(used[i]==\\'1\\'){\\n              used[i]=\\'0\\';\\n              if(!dfs(used, cache, n-i)) ans=true;\\n              used[i]=\\'1\\';\\n              if(ans) break;\\n          }   \\n        }\\n        cache.put(new String(used),ans);\\n        return ans;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 224067,
                "title": "java-top-down-with-memo-dp-solution-list-integer-as-the-map-key",
                "content": "```\\nclass Solution {\\n    Map<List<Integer>,Boolean> memo=new HashMap<>();\\n    public boolean canIWin(int maxChoosableInteger, int desiredTotal) {\\n        if(desiredTotal<=maxChoosableInteger) return true;\\n        if((maxChoosableInteger+1)*maxChoosableInteger/2<desiredTotal) return false;\\n        List<Integer> choosableInt=new ArrayList<>();\\n        for(int i=1;i<=maxChoosableInteger;i++)\\n            choosableInt.add(i);\\n        for(int i=1;i<=maxChoosableInteger;i++){\\n            choosableInt.remove((Object)i);\\n            List<Integer> newSet=new ArrayList<>(choosableInt);\\n            if(!dp(newSet,desiredTotal-i,memo)) return true;\\n            choosableInt.add((Integer)i);\\n        }\\n            \\n        return false;\\n    }\\n    \\n    private boolean dp(List<Integer> choosableInt,int desiredTotal,Map<List<Integer>,Boolean> memo){\\n        if(choosableInt==null) return false;\\n        for(Integer i:choosableInt)\\n            if(desiredTotal<=i) return true;\\n        \\n        \\n        for(ListIterator<Integer> it=choosableInt.listIterator();it.hasNext();){\\n            Integer i=it.next();\\n           \\n            List<Integer> list=new ArrayList<>(choosableInt);\\n            list.remove((Object)i);\\n            if(memo.containsKey(list)){\\n                if(!memo.get(list)) return true;\\n            }else{\\n                Boolean b=dp(list,desiredTotal-i,memo);\\n                memo.put(list,b);\\n                if(!b) return true;\\n            } \\n            \\n        }\\n            \\n        return false;\\n    }\\n}\\n```\\n",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    Map<List<Integer>,Boolean> memo=new HashMap<>();\\n    public boolean canIWin(int maxChoosableInteger, int desiredTotal) {\\n        if(desiredTotal<=maxChoosableInteger) return true;\\n        if((maxChoosableInteger+1)*maxChoosableInteger/2<desiredTotal) return false;\\n        List<Integer> choosableInt=new ArrayList<>();\\n        for(int i=1;i<=maxChoosableInteger;i++)\\n            choosableInt.add(i);\\n        for(int i=1;i<=maxChoosableInteger;i++){\\n            choosableInt.remove((Object)i);\\n            List<Integer> newSet=new ArrayList<>(choosableInt);\\n            if(!dp(newSet,desiredTotal-i,memo)) return true;\\n            choosableInt.add((Integer)i);\\n        }\\n            \\n        return false;\\n    }\\n    \\n    private boolean dp(List<Integer> choosableInt,int desiredTotal,Map<List<Integer>,Boolean> memo){\\n        if(choosableInt==null) return false;\\n        for(Integer i:choosableInt)\\n            if(desiredTotal<=i) return true;\\n        \\n        \\n        for(ListIterator<Integer> it=choosableInt.listIterator();it.hasNext();){\\n            Integer i=it.next();\\n           \\n            List<Integer> list=new ArrayList<>(choosableInt);\\n            list.remove((Object)i);\\n            if(memo.containsKey(list)){\\n                if(!memo.get(list)) return true;\\n            }else{\\n                Boolean b=dp(list,desiredTotal-i,memo);\\n                memo.put(list,b);\\n                if(!b) return true;\\n            } \\n            \\n        }\\n            \\n        return false;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 220075,
                "title": "my-iterative-solution",
                "content": "I think the time complexity of my iterative solution is the same as the recursive solution, but it causes TLE, and I am grateful to anyone who can tell me why.\\n```\\nbool canIWin(int maxChoosableInteger, int desiredTotal){\\n        if((maxChoosableInteger+1)*maxChoosableInteger/2<desiredTotal) return false;\\n        if(desiredTotal<=0) return true;\\n        vector<char> m((1<<maxChoosableInteger+1),0);\\n        bool can_win=true;\\n        stack<pair<int,pair<int,int>>> s;\\n        s.push(make_pair(0,make_pair(desiredTotal,1)));\\n        while(!s.empty()){\\n            pair<int,pair<int,int>> temp=s.top(); s.pop();\\n            if(m[temp.first]!=0){\\n                can_win=(m[temp.first]==1);\\n                continue;\\n            }\\n            if(can_win==false){\\n                m[temp.first]=1;\\n                can_win=true;\\n                continue;\\n            }\\n            if(temp.second.second>maxChoosableInteger){\\n                 m[temp.first]=-1;\\n                 can_win=false;\\n                 continue;\\n                 }\\n            if(temp.second.first<=0){\\n                can_win=false;\\n                continue;\\n            }\\n            for(int i=temp.second.second;i<=maxChoosableInteger;++i){\\n                if((temp.first & (1 << i))==0){\\n                    s.push(make_pair(temp.first,make_pair(temp.second.first,i+1)));\\n                    s.push(make_pair(temp.first | (1 << i),make_pair(temp.second.first-i,1)));\\n                    break;\\n                }\\n            }\\n        }\\n        return can_win;\\n    }\\n```",
                "solutionTags": [],
                "code": "```\\nbool canIWin(int maxChoosableInteger, int desiredTotal){\\n        if((maxChoosableInteger+1)*maxChoosableInteger/2<desiredTotal) return false;\\n        if(desiredTotal<=0) return true;\\n        vector<char> m((1<<maxChoosableInteger+1),0);\\n        bool can_win=true;\\n        stack<pair<int,pair<int,int>>> s;\\n        s.push(make_pair(0,make_pair(desiredTotal,1)));\\n        while(!s.empty()){\\n            pair<int,pair<int,int>> temp=s.top(); s.pop();\\n            if(m[temp.first]!=0){\\n                can_win=(m[temp.first]==1);\\n                continue;\\n            }\\n            if(can_win==false){\\n                m[temp.first]=1;\\n                can_win=true;\\n                continue;\\n            }\\n            if(temp.second.second>maxChoosableInteger){\\n                 m[temp.first]=-1;\\n                 can_win=false;\\n                 continue;\\n                 }\\n            if(temp.second.first<=0){\\n                can_win=false;\\n                continue;\\n            }\\n            for(int i=temp.second.second;i<=maxChoosableInteger;++i){\\n                if((temp.first & (1 << i))==0){\\n                    s.push(make_pair(temp.first,make_pair(temp.second.first,i+1)));\\n                    s.push(make_pair(temp.first | (1 << i),make_pair(temp.second.first-i,1)));\\n                    break;\\n                }\\n            }\\n        }\\n        return can_win;\\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 216992,
                "title": "very-clean-java-solution",
                "content": "```\\nclass Solution {\\n    private HashMap<Integer, Boolean> map;\\n    private boolean[] passed;\\n    public boolean canIWin(int maxChoosableInteger, int desiredTotal) {\\n        map = new HashMap<>();\\n        passed = new boolean[maxChoosableInteger+1];\\n        Arrays.fill(passed, false);\\n        if (desiredTotal <= maxChoosableInteger) {\\n            return true;\\n        }\\n        if ((1 + maxChoosableInteger) * maxChoosableInteger / 2 < desiredTotal) {\\n            return false;\\n        }\\n        return helper(desiredTotal);\\n    }\\n    \\n    private boolean helper(int sum) {\\n        if (sum <= 0) {\\n            return false;\\n        }\\n        int code = hashcode();\\n        if (map.containsKey(code)) {\\n            return map.get(code);\\n        }\\n        boolean res = false;\\n        for (int num = 1; num < passed.length && !res; ++num) {\\n            if (passed[num]) {\\n                continue;\\n            }\\n            passed[num] = true;\\n            res |= !helper(sum - num);\\n            passed[num] = false;\\n        }\\n        map.put(code, res);\\n        return res;\\n    }\\n    \\n    private int hashcode() {\\n        int res = 0;\\n        for (int num = 1; num < passed.length; ++num) {\\n            if (passed[num]) {\\n                continue;\\n            }\\n            res |= (1 << num);\\n        }\\n        return res;\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    private HashMap<Integer, Boolean> map;\\n    private boolean[] passed;\\n    public boolean canIWin(int maxChoosableInteger, int desiredTotal) {\\n        map = new HashMap<>();\\n        passed = new boolean[maxChoosableInteger+1];\\n        Arrays.fill(passed, false);\\n        if (desiredTotal <= maxChoosableInteger) {\\n            return true;\\n        }\\n        if ((1 + maxChoosableInteger) * maxChoosableInteger / 2 < desiredTotal) {\\n            return false;\\n        }\\n        return helper(desiredTotal);\\n    }\\n    \\n    private boolean helper(int sum) {\\n        if (sum <= 0) {\\n            return false;\\n        }\\n        int code = hashcode();\\n        if (map.containsKey(code)) {\\n            return map.get(code);\\n        }\\n        boolean res = false;\\n        for (int num = 1; num < passed.length && !res; ++num) {\\n            if (passed[num]) {\\n                continue;\\n            }\\n            passed[num] = true;\\n            res |= !helper(sum - num);\\n            passed[num] = false;\\n        }\\n        map.put(code, res);\\n        return res;\\n    }\\n    \\n    private int hashcode() {\\n        int res = 0;\\n        for (int num = 1; num < passed.length; ++num) {\\n            if (passed[num]) {\\n                continue;\\n            }\\n            res |= (1 << num);\\n        }\\n        return res;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 182512,
                "title": "python-code-pass-in-run-code-but-not-in-submit",
                "content": "I followed the highest voted answer and coded in python. However I couldn\\'t pass when submitting, but I can return correct answer when running with \"Run Code\". It\\'s very weird!\\n\\n```\\nclass Solution:\\n    usedDict = {}  # A map used to store the state of the game. {key : True/False}, key represents a state\\n    \\n    def canIWin(self, maxChoosableInteger, desiredTotal):\\n        \"\"\"\\n        :type maxChoosableInteger: int\\n        :type desiredTotal: int\\n        :rtype: bool\\n        \"\"\"\\n        if (1 + maxChoosableInteger) * maxChoosableInteger / 2 < desiredTotal:\\n            return False\\n\\n        if desiredTotal <= 0:\\n            return True\\n        \\n        used = [\\'0\\' for _ in range(maxChoosableInteger + 1)]\\n          \\n        return self.helper(used, desiredTotal)\\n    \\n    def helper(self, used, desiredTotal):\\n        if desiredTotal <= 0:  # If the desiredTotal <= 0 means total has reached initial target, so lose\\n            return False\\n        \\n        key = self.transform(used)  # key is an integer tranformed by used, representing the selecting situation \\n        \\n        if key not in self.usedDict:  # if this situation didn\\'t appear before\\n            for n in range(1, len(used)):\\n                if used[n] != \\'1\\':\\n                    used[n] = \\'1\\'\\n                    if not self.helper(used, desiredTotal - n):\\n                        self.usedDict[key] = True\\n                        used[n] = \\'0\\'\\n                        return True\\n                    \\n                    used[n] = \\'0\\'\\n            \\n            self.usedDict[key] = False\\n        \\n        return self.usedDict.get(key)\\n    \\n    def transform(self, used):\\n        string = \\'\\'.join(used)\\n        return int(string, 2)\\n```\\n\\nCan any one help test my code? Thanks!",
                "solutionTags": [],
                "code": "```\\nclass Solution:\\n    usedDict = {}  # A map used to store the state of the game. {key : True/False}, key represents a state\\n    \\n    def canIWin(self, maxChoosableInteger, desiredTotal):\\n        \"\"\"\\n        :type maxChoosableInteger: int\\n        :type desiredTotal: int\\n        :rtype: bool\\n        \"\"\"\\n        if (1 + maxChoosableInteger) * maxChoosableInteger / 2 < desiredTotal:\\n            return False\\n\\n        if desiredTotal <= 0:\\n            return True\\n        \\n        used = [\\'0\\' for _ in range(maxChoosableInteger + 1)]\\n          \\n        return self.helper(used, desiredTotal)\\n    \\n    def helper(self, used, desiredTotal):\\n        if desiredTotal <= 0:  # If the desiredTotal <= 0 means total has reached initial target, so lose\\n            return False\\n        \\n        key = self.transform(used)  # key is an integer tranformed by used, representing the selecting situation \\n        \\n        if key not in self.usedDict:  # if this situation didn\\'t appear before\\n            for n in range(1, len(used)):\\n                if used[n] != \\'1\\':\\n                    used[n] = \\'1\\'\\n                    if not self.helper(used, desiredTotal - n):\\n                        self.usedDict[key] = True\\n                        used[n] = \\'0\\'\\n                        return True\\n                    \\n                    used[n] = \\'0\\'\\n            \\n            self.usedDict[key] = False\\n        \\n        return self.usedDict.get(key)\\n    \\n    def transform(self, used):\\n        string = \\'\\'.join(used)\\n        return int(string, 2)\\n```",
                "codeTag": "Java"
            },
            {
                "id": 176957,
                "title": "bitmask-memo-dfs-clean-code-and-explanation",
                "content": "use binary bits to mark if the number has been chosen, 0 is not and 1 is used.\\nstate & (1 << (i - 1)) is to check if we can pick integer i at this turn. If the result is not 0, then it is used, we continue; If not, we chante this bit to 1\\nwhich is state | mask, and use backtracking to solve problem.\\n```\\nclass Solution {\\n    public boolean canIWin(int maxChoosableInteger, int desiredTotal) {\\n        // minimax\\n        // bit mask to mark the available number, then use memo\\n        // 0 is not used, 1 is used\\n        if (desiredTotal == 0) {\\n            return true;\\n        }\\n        if ((1 + maxChoosableInteger) * maxChoosableInteger / 2 < desiredTotal) {\\n            return false;\\n        }\\n        int state = (1 << maxChoosableInteger);\\n        Boolean[] memo = new Boolean[state];\\n        return isWinning(0, desiredTotal, memo, maxChoosableInteger);\\n    }\\n    \\n    public boolean isWinning(int state, int total, Boolean[] memo, int n) {\\n        if (total <= 0) {\\n            return false;\\n        }\\n        //System.out.println(Integer.toBinaryString(state));\\n        if (memo[state] != null) {\\n            return memo[state];\\n        }\\n        // check sub problem\\n        for (int i = 1; i <= n; i++) {\\n            int mask = 1 << (i - 1);\\n            // can\\'t used this bit \\n            if ((mask & state) != 0) {\\n                continue;\\n            }\\n            if (!isWinning(state | mask, total - i, memo, n)) {\\n                memo[state] = true;\\n                return true;\\n            }\\n        }\\n        memo[state] = false;\\n        return false;\\n    }\\n}\\n```\\n",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    public boolean canIWin(int maxChoosableInteger, int desiredTotal) {\\n        // minimax\\n        // bit mask to mark the available number, then use memo\\n        // 0 is not used, 1 is used\\n        if (desiredTotal == 0) {\\n            return true;\\n        }\\n        if ((1 + maxChoosableInteger) * maxChoosableInteger / 2 < desiredTotal) {\\n            return false;\\n        }\\n        int state = (1 << maxChoosableInteger);\\n        Boolean[] memo = new Boolean[state];\\n        return isWinning(0, desiredTotal, memo, maxChoosableInteger);\\n    }\\n    \\n    public boolean isWinning(int state, int total, Boolean[] memo, int n) {\\n        if (total <= 0) {\\n            return false;\\n        }\\n        //System.out.println(Integer.toBinaryString(state));\\n        if (memo[state] != null) {\\n            return memo[state];\\n        }\\n        // check sub problem\\n        for (int i = 1; i <= n; i++) {\\n            int mask = 1 << (i - 1);\\n            // can\\'t used this bit \\n            if ((mask & state) != 0) {\\n                continue;\\n            }\\n            if (!isWinning(state | mask, total - i, memo, n)) {\\n                memo[state] = true;\\n                return true;\\n            }\\n        }\\n        memo[state] = false;\\n        return false;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 155684,
                "title": "why-is-it-failing-at-10-40-test-case",
                "content": "desiredTotal     maxChoosableInteger\\n40                 -  10                                  = 30                     >>>     I play\\n30                 -  09                                  = 21                     >>>     He plays\\n21                 -  08                                  = 13                     >>>     I play\\n13                 -  07                                  = 06                     >>>     He plays\\n06                 -  06                                  = 00                     >>>     I play\\n\\nwith my move I win on 5th turn\\n\\n```if desiredTotal <= maxChoosableInteger: return True\\n        turns = 0\\n        while desiredTotal > 0:\\n            desiredTotal -= maxChoosableInteger\\n            maxChoosableInteger -= 1\\n            turns += 1\\n        return True if turns % 2 == 1 else False```",
                "solutionTags": [],
                "code": "```if desiredTotal <= maxChoosableInteger: return True\\n        turns = 0\\n        while desiredTotal > 0:\\n            desiredTotal -= maxChoosableInteger\\n            maxChoosableInteger -= 1\\n            turns += 1\\n        return True if turns % 2 == 1 else False```",
                "codeTag": "Unknown"
            },
            {
                "id": 148308,
                "title": "python-that-follows-from-simple-recurrence",
                "content": "```\\nclass Solution(object):\\n    def canIWin(self, maxChoosableInteger, desiredTotal):\\n        \"\"\"\\n        :type maxChoosableInteger: int\\n        :type desiredTotal: int\\n        :rtype: bool\\n        \"\"\"\\n\\t\\t\\t\\t# Notation: function cw() answers \"Can I win?\" from this player\\'s perspective, t: current total, choices: a set of integer choices, ~: not operator\\n        # Recurrence:        \\n        # cw(t, choices) = (there exists a choice such that ~cw(t + choice, choices - choice)) or (choice + t >= desiredTotal)\\n\\t\\t\\t\\t# In English: each player, playing their best, must make a choice that either precludes the other player from winning, or wins the game immediately.\\n\\t\\t\\t\\t#  similar to this solution: https://leetcode.com/problems/can-i-win/discuss/95292/Python-solution-easy-to-understand\\n        tab = dict()\\n        tgt = desiredTotal\\n        choices = list(range(1, maxChoosableInteger + 1))\\n\\t\\t\\t\\t\\n\\t\\t\\t\\t# filter out unwinnable games\\n        if sum(choices) < desiredTotal:\\n            return False\\n        \\n\\t\\t\\t\\t# defines the recurrence relation\\n        def cw(tot, chs):\\n            hv = \"%s:%s\" % (str(tot), str(chs))\\n            if hv in tab:\\n                return tab[hv]\\n            if chs and tot + chs[-1] >= tgt:                \\n                tab[hv] = True\\n                return True\\n            for ix, ch in enumerate(chs):\\n                if not cw(tot + ch, chs[:ix] + chs[ix + 1:]):\\n                    tab[hv] = True\\n                    return True\\n            tab[hv] = False\\n            return False                    \\n                \\n        res = cw(0, choices)\\n        return res\\n\\t\\t\\t\\t```",
                "solutionTags": [],
                "code": "```\\nclass Solution(object):\\n    def canIWin(self, maxChoosableInteger, desiredTotal):\\n        \"\"\"\\n        :type maxChoosableInteger: int\\n        :type desiredTotal: int\\n        :rtype: bool\\n        \"\"\"\\n\\t\\t\\t\\t# Notation: function cw() answers \"Can I win?\" from this player\\'s perspective, t: current total, choices: a set of integer choices, ~: not operator\\n        # Recurrence:        \\n        # cw(t, choices) = (there exists a choice such that ~cw(t + choice, choices - choice)) or (choice + t >= desiredTotal)\\n\\t\\t\\t\\t# In English: each player, playing their best, must make a choice that either precludes the other player from winning, or wins the game immediately.\\n\\t\\t\\t\\t#  similar to this solution: https://leetcode.com/problems/can-i-win/discuss/95292/Python-solution-easy-to-understand\\n        tab = dict()\\n        tgt = desiredTotal\\n        choices = list(range(1, maxChoosableInteger + 1))\\n\\t\\t\\t\\t\\n\\t\\t\\t\\t# filter out unwinnable games\\n        if sum(choices) < desiredTotal:\\n            return False\\n        \\n\\t\\t\\t\\t# defines the recurrence relation\\n        def cw(tot, chs):\\n            hv = \"%s:%s\" % (str(tot), str(chs))\\n            if hv in tab:\\n                return tab[hv]\\n            if chs and tot + chs[-1] >= tgt:                \\n                tab[hv] = True\\n                return True\\n            for ix, ch in enumerate(chs):\\n                if not cw(tot + ch, chs[:ix] + chs[ix + 1:]):\\n                    tab[hv] = True\\n                    return True\\n            tab[hv] = False\\n            return False                    \\n                \\n        res = cw(0, choices)\\n        return res\\n\\t\\t\\t\\t```",
                "codeTag": "Java"
            },
            {
                "id": 137599,
                "title": "python-simple-recursion-with-memo",
                "content": "```\\n    def canIWin(self, I, T):\\n        \"\"\"\\n        :type I: int\\n        :type T: int\\n        :rtype: bool\\n        \"\"\"\\n        \\n        if T>I*(I+1)/2:\\n            return False\\n        # recursion\\n        memo={}\\n        def helper(key,pos):\\n            if key in memo:\\n                return memo[key]\\n            if pos>=T:\\n                return True\\n            for i in range(I):\\n                if key|2**i>key and (pos+i+1>=T or not helper(key|2**i,pos+i+1)):\\n                    memo[key]=True\\n                    return True\\n            memo[key]=False\\n            return False\\n        return helper(0,0)\\n```",
                "solutionTags": [],
                "code": "```\\n    def canIWin(self, I, T):\\n        \"\"\"\\n        :type I: int\\n        :type T: int\\n        :rtype: bool\\n        \"\"\"\\n        \\n        if T>I*(I+1)/2:\\n            return False\\n        # recursion\\n        memo={}\\n        def helper(key,pos):\\n            if key in memo:\\n                return memo[key]\\n            if pos>=T:\\n                return True\\n            for i in range(I):\\n                if key|2**i>key and (pos+i+1>=T or not helper(key|2**i,pos+i+1)):\\n                    memo[key]=True\\n                    return True\\n            memo[key]=False\\n            return False\\n        return helper(0,0)\\n```",
                "codeTag": "Python3"
            },
            {
                "id": 95296,
                "title": "why-we-do-not-need-to-differentiate-two-players",
                "content": "\\nAfter seeing some code in discussion I came up with the following code and passed the judge. My question is: why we do not need to differentiate two players? That is, when we mark the elements in the map to true or false, how do we know it is true/false for the first or second player? Why it does not matter?\\n\\n```\\nclass Solution {\\nprivate:\\n    bool wins(unordered_map<int, bool> &map, int used, int maxChoosableInteger, int target)\\n    {\\n        // if the number combination have been calculated, return the result\\n        if (map[used]) return map[used];\\n        // if the number combination have not been calculated\\n        // if used is 10100, then 2, 4 have been chosen, while 1,3 are not\\n        // so we start from the beginning, if the number has not been chosen, then we examine this number\\n        for (int i = 1; i <= maxChoosableInteger; ++i)\\n        {\\n            int mask = 1 << i;\\n            // 1. if this number >= the target, then of course wins\\n            // 2. if this number < target, and we choose this number, then the choice is passed to the second player\\n            //    only when second player loses can the first player wins\\n            if ((mask & used) == 0 && (i >= target || !wins(map, mask | used, maxChoosableInteger, target - i)))\\n            {\\n                // for the above situations, the first player wins, and we can mark the map\\n                // we don't need to differentiate two players\\n                return map[used] = true;\\n            }\\n        }\\n        return  map[used] = false;\\n    }\\n    \\npublic:\\n    // without pruning O(n!)\\n    // with pruning O(2^n)\\n    bool canIWin(int maxChoosableInteger, int desiredTotal) \\n    {\\n        if (((1 + maxChoosableInteger) * maxChoosableInteger / 2) < desiredTotal) return false;\\n        unordered_map<int, bool> map;\\n        return wins(map, 0, maxChoosableInteger, desiredTotal);\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\nprivate:\\n    bool wins(unordered_map<int, bool> &map, int used, int maxChoosableInteger, int target)\\n    {\\n        // if the number combination have been calculated, return the result\\n        if (map[used]) return map[used];\\n        // if the number combination have not been calculated\\n        // if used is 10100, then 2, 4 have been chosen, while 1,3 are not\\n        // so we start from the beginning, if the number has not been chosen, then we examine this number\\n        for (int i = 1; i <= maxChoosableInteger; ++i)\\n        {\\n            int mask = 1 << i;\\n            // 1. if this number >= the target, then of course wins\\n            // 2. if this number < target, and we choose this number, then the choice is passed to the second player\\n            //    only when second player loses can the first player wins\\n            if ((mask & used) == 0 && (i >= target || !wins(map, mask | used, maxChoosableInteger, target - i)))\\n            {\\n                // for the above situations, the first player wins, and we can mark the map\\n                // we don't need to differentiate two players\\n                return map[used] = true;\\n            }\\n        }\\n        return  map[used] = false;\\n    }\\n    \\npublic:\\n    // without pruning O(n!)\\n    // with pruning O(2^n)\\n    bool canIWin(int maxChoosableInteger, int desiredTotal) \\n    {\\n        if (((1 + maxChoosableInteger) * maxChoosableInteger / 2) < desiredTotal) return false;\\n        unordered_map<int, bool> map;\\n        return wins(map, 0, maxChoosableInteger, desiredTotal);\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 95301,
                "title": "bit-hashmap-solution",
                "content": "Base idea is for \"010111\" means 1,3,4,5 has been use,\\nwhen current = \"01010111\"\\nmapping[current] == true means for  \"01010111\" status, first play will win\\nmapping[current] == false means for  \"01010111\" status, first play will lost\\n```\\npublic class Solution {\\n    public bool CanIWin(int maxChoosableInteger, int desiredTotal) {\\n        if((1+maxChoosableInteger)*maxChoosableInteger/2 < desiredTotal)\\n            return false;\\n        return CanIWin(new Dictionary<int,bool>(),desiredTotal,0,maxChoosableInteger,0);\\n    }\\n    \\n    private bool CanIWin(Dictionary<int,bool> mapping,int total,int current,int max,int sum){\\n        if(sum >= total)\\n            return true;\\n            \\n        if(!mapping.ContainsKey(current)){\\n            \\n            for(int i = 1;i<=max;i++){\\n                int n = 1 << i;\\n                \\n                if((current & n)  == 0 && (sum+i >= total ||  !CanIWin(mapping,total,(current | n),max,sum+i))){\\n                    mapping.Add(current,true);\\n                    return true;\\n                }\\n            }\\n            mapping.Add(current,false);\\n            return false;\\n        }else{\\n            return mapping[current];\\n        }\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\npublic class Solution {\\n    public bool CanIWin(int maxChoosableInteger, int desiredTotal) {\\n        if((1+maxChoosableInteger)*maxChoosableInteger/2 < desiredTotal)\\n            return false;\\n        return CanIWin(new Dictionary<int,bool>(),desiredTotal,0,maxChoosableInteger,0);\\n    }\\n    \\n    private bool CanIWin(Dictionary<int,bool> mapping,int total,int current,int max,int sum){\\n        if(sum >= total)\\n            return true;\\n            \\n        if(!mapping.ContainsKey(current)){\\n            \\n            for(int i = 1;i<=max;i++){\\n                int n = 1 << i;\\n                \\n                if((current & n)  == 0 && (sum+i >= total ||  !CanIWin(mapping,total,(current | n),max,sum+i))){\\n                    mapping.Add(current,true);\\n                    return true;\\n                }\\n            }\\n            mapping.Add(current,false);\\n            return false;\\n        }else{\\n            return mapping[current];\\n        }\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 95322,
                "title": "python-minimax-bitwise-simple",
                "content": "Python solution based on MiniMax Strategy. Dic represents whether each state is a Win state or not. If any of the children states are a loose state then the parent state becomes a Win state.\\nThe variable \"choices\" is the bitwise representation of the choices available. The worst case time complexity should be O(N!) but some pruning has been done to speed up things when possible.\\n\\n    def canIWin(self, maxChoosableInteger, desiredTotal):\\n        if desiredTotal==0: return True\\n        if maxChoosableInteger*(maxChoosableInteger+1)/2 < desiredTotal:return False\\n            \\n        choices,temp = 0,0\\n        while temp < maxChoosableInteger:\\n            choices |= (1<<temp)\\n            temp +=1\\n        \\n        dic ={}\\n        def solve(choice, total):\\n            if (choice,total) in dic: return dic[ (choice,total) ]\\n            if total <= 0: return False\\n            tempChoice,childAns = choice, True\\n            for i in xrange( maxChoosableInteger ):\\n                if tempChoice & 1:\\n                    childAns = childAns and solve( choice ^ (1<<i), total-i-1)\\n                tempChoice >>=1\\n                if not tempChoice or not childAns: break\\n            \\n            dic[ (choice,total) ] = not childAns\\n            return not childAns\\n        \\n        return solve( choices, desiredTotal)",
                "solutionTags": [],
                "code": "Python solution based on MiniMax Strategy. Dic represents whether each state is a Win state or not. If any of the children states are a loose state then the parent state becomes a Win state.\\nThe variable \"choices\" is the bitwise representation of the choices available. The worst case time complexity should be O(N!) but some pruning has been done to speed up things when possible.\\n\\n    def canIWin(self, maxChoosableInteger, desiredTotal):\\n        if desiredTotal==0: return True\\n        if maxChoosableInteger*(maxChoosableInteger+1)/2 < desiredTotal:return False\\n            \\n        choices,temp = 0,0\\n        while temp < maxChoosableInteger:\\n            choices |= (1<<temp)\\n            temp +=1\\n        \\n        dic ={}\\n        def solve(choice, total):\\n            if (choice,total) in dic: return dic[ (choice,total) ]\\n            if total <= 0: return False\\n            tempChoice,childAns = choice, True\\n            for i in xrange( maxChoosableInteger ):\\n                if tempChoice & 1:\\n                    childAns = childAns and solve( choice ^ (1<<i), total-i-1)\\n                tempChoice >>=1\\n                if not tempChoice or not childAns: break\\n            \\n            dic[ (choice,total) ] = not childAns\\n            return not childAns\\n        \\n        return solve( choices, desiredTotal)",
                "codeTag": "Python3"
            },
            {
                "id": 95331,
                "title": "c-solution",
                "content": "Idea is same as others already described.\\n\\n```\\npublic bool CanIWin(int maxChoosableInteger, int desiredTotal) {\\n        int[] mem = new int [1 << maxChoosableInteger];\\n        \\n        if ((maxChoosableInteger * (maxChoosableInteger + 1) / 2) < desiredTotal) return false;\\n        return CanWin(mem, 0, maxChoosableInteger, desiredTotal);\\n    }\\n    \\n    public bool CanWin(int[] mem, int state, int max, int target) {\\n        if (mem[state] != 0) return mem[state] == 1 ? true : false;\\n        \\n        bool win = false;\\n        for(int i = 1, b = 1 << (i - 1); i <= max; i++, b = 1 << (i - 1)) {\\n            if ((state & b) != 0) continue;\\n            if (i >= target || !CanWin(mem, state | b, max, target - i)) { win = true; break; }\\n        }\\n        \\n        mem[state] = win ? 1 : -1;\\n        \\n        return win;\\n    }\\n```",
                "solutionTags": [],
                "code": "```\\npublic bool CanIWin(int maxChoosableInteger, int desiredTotal) {\\n        int[] mem = new int [1 << maxChoosableInteger];\\n        \\n        if ((maxChoosableInteger * (maxChoosableInteger + 1) / 2) < desiredTotal) return false;\\n        return CanWin(mem, 0, maxChoosableInteger, desiredTotal);\\n    }\\n    \\n    public bool CanWin(int[] mem, int state, int max, int target) {\\n        if (mem[state] != 0) return mem[state] == 1 ? true : false;\\n        \\n        bool win = false;\\n        for(int i = 1, b = 1 << (i - 1); i <= max; i++, b = 1 << (i - 1)) {\\n            if ((state & b) != 0) continue;\\n            if (i >= target || !CanWin(mem, state | b, max, target - i)) { win = true; break; }\\n        }\\n        \\n        mem[state] = win ? 1 : -1;\\n        \\n        return win;\\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 95337,
                "title": "golang-112ms-recursive-with-cache",
                "content": "Very similar to https://discuss.leetcode.com/topic/69330/quick-c-dp-solution-with-bit-maniplutaion-only-49ms\\n```go\\nfunc verify(available uint, n, total uint, cache map[uint]bool) (success bool) {\\n\\tif s, found := cache[available]; found {\\n\\t\\treturn s\\n\\t}\\n\\tfor i := uint(1); i <= n && !success; i++ {\\n\\t\\tif (available & (1 << i)) > 0 {\\n    \\t\\tsuccess = total <= i || !verify(available &^ (1 << i), n, total-i, cache)\\n\\t\\t}\\n\\t}\\n\\tcache[available] = success\\n\\treturn\\n}\\n\\nfunc canIWin(n int, total int) bool {\\n\\tavailable := (uint(1) << uint(n+1)) - 1\\n\\treturn (n*(n+1)/2 > total) && verify(available, uint(n), uint(total), make(map[uint]bool))\\n}\\n```",
                "solutionTags": [],
                "code": "```go\\nfunc verify(available uint, n, total uint, cache map[uint]bool) (success bool) {\\n\\tif s, found := cache[available]; found {\\n\\t\\treturn s\\n\\t}\\n\\tfor i := uint(1); i <= n && !success; i++ {\\n\\t\\tif (available & (1 << i)) > 0 {\\n    \\t\\tsuccess = total <= i || !verify(available &^ (1 << i), n, total-i, cache)\\n\\t\\t}\\n\\t}\\n\\tcache[available] = success\\n\\treturn\\n}\\n\\nfunc canIWin(n int, total int) bool {\\n\\tavailable := (uint(1) << uint(n+1)) - 1\\n\\treturn (n*(n+1)/2 > total) && verify(available, uint(n), uint(total), make(map[uint]bool))\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 95339,
                "title": "minmax-with-bit-wise-memorization",
                "content": "it's a common minmax problem in game theory, and the key point is to utilize memorization to reduce the repeated computation. \\nThe status is the numbers which are not selected and the `desiredTotal` util now. since the `desiredTotal` could be computed by the available numbers for each game,  the numbers is enough to represent the status. And to traverse the available numbers and record the status efficiently, we can use bit-wise mask to record the the available numbers, instead of array or set. The python solution is 659 ms in my submission.\\n```\\nclass Solution(object):\\n    def canIWin(self, maxChoosableInteger, desiredTotal):\\n        \"\"\"\\n        :type maxChoosableInteger: int\\n        :type desiredTotal: int\\n        :rtype: bool\\n        \"\"\"\\n        if desiredTotal<=0:\\n            return True\\n        if maxChoosableInteger*(maxChoosableInteger+1)/2<desiredTotal:\\n            return False\\n        self.dp={}\\n        return self.minmax((1<<maxChoosableInteger)-1,desiredTotal)\\n        \\n    def minmax(self,nums,target):\\n        if target<=0:\\n            return False\\n        if nums in self.dp:\\n            return self.dp[nums]\\n        else:\\n            self.dp[nums]=False\\n        i=1\\n        mask=1\\n        while mask<=nums:\\n            if nums&mask>0 and not self.minmax(nums^mask,target-i):\\n                self.dp[nums]=True\\n                break\\n            mask<<=1\\n            i+=1\\n        return self.dp[nums]\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution(object):\\n    def canIWin(self, maxChoosableInteger, desiredTotal):\\n        \"\"\"\\n        :type maxChoosableInteger: int\\n        :type desiredTotal: int\\n        :rtype: bool\\n        \"\"\"\\n        if desiredTotal<=0:\\n            return True\\n        if maxChoosableInteger*(maxChoosableInteger+1)/2<desiredTotal:\\n            return False\\n        self.dp={}\\n        return self.minmax((1<<maxChoosableInteger)-1,desiredTotal)\\n        \\n    def minmax(self,nums,target):\\n        if target<=0:\\n            return False\\n        if nums in self.dp:\\n            return self.dp[nums]\\n        else:\\n            self.dp[nums]=False\\n        i=1\\n        mask=1\\n        while mask<=nums:\\n            if nums&mask>0 and not self.minmax(nums^mask,target-i):\\n                self.dp[nums]=True\\n                break\\n            mask<<=1\\n            i+=1\\n        return self.dp[nums]\\n```",
                "codeTag": "Java"
            },
            {
                "id": 95338,
                "title": "dp-solution-in-c-with-comments",
                "content": "I think the key to this problem is to use some bitwise operation to record what numbers have been used during the game to minimize the size of hash table as much as possible.\\n\\n     class Solution {\\n     public:\\n     \\tbool canIWin(int maxChoosableInteger, int desiredTotal) {\\n     \\t\\tif(desiredTotal == 0) return true;\\n     \\n     \\t\\tif((maxChoosableInteger+1) * maxChoosableInteger / 2 < desiredTotal)\\n     \\t\\t\\treturn false;\\n     \\n     \\t\\tunordered_map<int, bool> dp;\\n     \\n     \\t\\t// a bit in record being equal to 1 means a number is available\\n     \\t\\t// for example if record is ..1000, it means number 3 has not been used,\\n     \\t\\t// for convenience we do not use the least significant digit.\\n     \\t\\tint record = 0;\\n     \\t\\tfor(int i = 0; i < maxChoosableInteger+1; i++) {\\n     \\t\\t\\trecord = (record << 1) + 1;\\n     \\t\\t}\\n     \\t\\treturn f(desiredTotal, record, dp);\\n     \\t}\\n     \\n     \\tbool f(int dt, int record, unordered_map<int, bool> &dp)\\n     \\t{\\n     \\t\\tif(dp.count(record)) {\\n     \\t\\t\\treturn dp[record];\\n     \\t\\t}\\n     \\t\\t\\n     \\t\\t// we know maxChoosableInteger wont be larger than 20\\n     \\t\\tfor(int i = 20; i > 0; i--) {\\n     \\t\\t\\tint bit = 1 << i;\\n     \\n     \\t\\t\\t// if this number has not been used\\n     \\t\\t\\tif(record & bit) {\\n     \\t\\t\\t\\tif(i >= dt) {\\n     \\t\\t\\t\\t\\tdp[i] = true;\\n     \\t\\t\\t\\t\\treturn true;\\n     \\t\\t\\t\\t}\\n     \\t\\t\\t\\t// mark number i so it has been used and check whether the opponent\\n     \\t\\t\\t\\t// can win. Notice that due to the annoyance of [] operator\\n     \\t\\t\\t\\t// automatically inserting value into a set in c++, we should not\\n     \\t\\t\\t\\t// use dp[...] = f(..., dp) to avoid changing dp BEFORE the\\n     \\t\\t\\t\\t// function is called.\\n     \\t\\t\\t\\tbool t = f(dt-i, record^bit, dp);\\n     \\t\\t\\t\\tdp[record^bit] = t;\\n     \\t\\t\\t\\tif(t == false) {\\n     \\t\\t\\t\\t\\treturn true;\\n     \\t\\t\\t\\t}\\n     \\t\\t\\t}\\n     \\t\\t}\\n     \\t\\treturn false;\\n     \\n     \\t}\\n     \\n     };",
                "solutionTags": [],
                "code": "class Solution {\\n     public:\\n     \\tbool canIWin(int maxChoosableInteger, int desiredTotal) {\\n     \\t\\tif(desiredTotal == 0) return true;\\n     \\n     \\t\\tif((maxChoosableInteger+1) * maxChoosableInteger / 2 < desiredTotal)\\n     \\t\\t\\treturn false;\\n     \\n     \\t\\tunordered_map<int, bool> dp;\\n     \\n     \\t\\t// a bit in record being equal to 1 means a number is available\\n     \\t\\t// for example if record is ..1000, it means number 3 has not been used,\\n     \\t\\t// for convenience we do not use the least significant digit.\\n     \\t\\tint record = 0;\\n     \\t\\tfor(int i = 0; i < maxChoosableInteger+1; i++) {\\n     \\t\\t\\trecord = (record << 1) + 1;\\n     \\t\\t}",
                "codeTag": "Java"
            },
            {
                "id": 95327,
                "title": "c-memorized-game-tree-search-with-explanation",
                "content": "My solution is based on a brute force with memorization and some small optimization trick.  And I believe there must exist some better solution.\\n\\nNote that the first player can pick any number among all the `maxChoosableInteger` integers, and then the other player can pick any number among the remaining `maxChoosableInteger-1` integers, that is to say, the rule that how the player pick the integer is not strict, which results in quite a large state space to be searched. For example, if `maxChoosableInteger` equals `20`,  then the possible cases is `O(20!)`. In my opinion, this problem is NP-hard, that's why in this problem `maxChoosableInteger` is not larger than 20 and `desiredTotal` is not larger than 300. Thus, The memorized search is applied to deal with the huge state space and overlapping sub-problems.\\n\\nI use the `std::string` (`unsigned int` is also Okay) to represent the state of the current integers, the size of the string is equal to `maxChoosableInteger+1`, and it consists of 0-1 character. '0' means the corresponding integer is not picked, '1' otherwise. At the beginning, the string is initialized with all '0' characters, means all the integers are not picked.\\n\\nFor example, suppose there are 5 integers, if the first player pick the 2nd integer, then we need to investigate whether the other player can win with the updated integer state ` \"01000\" ` and the updated desired total `desiredTotal-2`. For the first player, he has 5 choices, if for all the 5 choices, the other player can win with updated state, then we say the first player must lose; otherwise, if there exist one choice that make the second player lose, we say the first player will win. During the recursion, `std::unordered_map` is used to store the state once we compute the result of a sub-problem, it is defined as `unordered_map<string, bool>`. When we jump into a deeper recursion, we first look up the map and check if the sub-problem is solved before.\\n\\n```c++\\nclass Solution {\\npublic:\\n    bool canIWin(int maxChoosableInteger, int desiredTotal) {\\n        int sum = (1+maxChoosableInteger)*maxChoosableInteger/2;\\n        if (sum < desiredTotal) return false;\\n        string state(maxChoosableInteger+1,'0');\\n        unordered_map<string, bool> stateTable;\\n        return memSearch(state, stateTable, desiredTotal);\\n    }\\n    \\n    bool memSearch(string &state, unordered_map<string, bool>& stateTable, int dT) {\\n        // look up the stateTable\\n        auto it = stateTable.find(state);\\n        if (it != stateTable.end()) {\\n            return it->second;\\n        }\\n        // DFS\\n        for (int i = state.size()-1; i >= 1; --i) {\\n            if (state[i] == '0') {\\n                if (i >= dT) {\\n                    stateTable.emplace(state, true); return true;\\n                }\\n                string nextState(state); nextState[i] = '1';\\n                bool isOpponentWin = memSearch(nextState, stateTable, dT-i);\\n                stateTable.emplace(nextState, isOpponentWin); // memorize\\n                if (!isOpponentWin) return true;\\n            }\\n        }\\n        return false;\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```c++\\nclass Solution {\\npublic:\\n    bool canIWin(int maxChoosableInteger, int desiredTotal) {\\n        int sum = (1+maxChoosableInteger)*maxChoosableInteger/2;\\n        if (sum < desiredTotal) return false;\\n        string state(maxChoosableInteger+1,'0');\\n        unordered_map<string, bool> stateTable;\\n        return memSearch(state, stateTable, desiredTotal);\\n    }\\n    \\n    bool memSearch(string &state, unordered_map<string, bool>& stateTable, int dT) {\\n        // look up the stateTable\\n        auto it = stateTable.find(state);\\n        if (it != stateTable.end()) {\\n            return it->second;\\n        }\\n        // DFS\\n        for (int i = state.size()-1; i >= 1; --i) {\\n            if (state[i] == '0') {\\n                if (i >= dT) {\\n                    stateTable.emplace(state, true); return true;\\n                }\\n                string nextState(state); nextState[i] = '1';\\n                bool isOpponentWin = memSearch(nextState, stateTable, dT-i);\\n                stateTable.emplace(nextState, isOpponentWin); // memorize\\n                if (!isOpponentWin) return true;\\n            }\\n        }\\n        return false;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 95349,
                "title": "c-solution-tried-every-combination-with-dp-table",
                "content": "```\\nclass Solution {\\npublic:\\n    bool canIWin(int maxChoosableInteger, int desiredTotal) {\\n        if(maxChoosableInteger * (maxChoosableInteger + 1) < 2 * desiredTotal)\\n            return false;\\n        int canUse = (1 << (maxChoosableInteger + 1)) - 2;\\n        unordered_map<int, bool> dp; \\n        return canIWinHelper(canUse, maxChoosableInteger, desiredTotal, dp);\\n    }\\n    \\n    bool canIWinHelper(int &canUse, int maxChoosableInteger, int desiredTotal, unordered_map<int, bool> &dp) {\\n        if (dp.find(canUse) != dp.end())\\n            return dp[canUse];\\n        for (int i = maxChoosableInteger; i > 0; i--) {\\n            int to_use = (1 << i);\\n            if (canUse & to_use) {\\n                if (i >= desiredTotal) {\\n                    dp[canUse] = true;\\n                    return true;\\n                }\\n                canUse ^= to_use;\\n                if (false == canIWinHelper(canUse, maxChoosableInteger, desiredTotal - i, dp)) {\\n                    canUse |= to_use;\\n                    dp[canUse] = true;\\n                    return true;\\n                }\\n                canUse |= to_use;\\n            }\\n        }\\n        dp[canUse] = false;\\n        return false;\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    bool canIWin(int maxChoosableInteger, int desiredTotal) {\\n        if(maxChoosableInteger * (maxChoosableInteger + 1) < 2 * desiredTotal)\\n            return false;\\n        int canUse = (1 << (maxChoosableInteger + 1)) - 2;\\n        unordered_map<int, bool> dp; \\n        return canIWinHelper(canUse, maxChoosableInteger, desiredTotal, dp);\\n    }\\n    \\n    bool canIWinHelper(int &canUse, int maxChoosableInteger, int desiredTotal, unordered_map<int, bool> &dp) {\\n        if (dp.find(canUse) != dp.end())\\n            return dp[canUse];\\n        for (int i = maxChoosableInteger; i > 0; i--) {\\n            int to_use = (1 << i);\\n            if (canUse & to_use) {\\n                if (i >= desiredTotal) {\\n                    dp[canUse] = true;\\n                    return true;\\n                }\\n                canUse ^= to_use;\\n                if (false == canIWinHelper(canUse, maxChoosableInteger, desiredTotal - i, dp)) {\\n                    canUse |= to_use;\\n                    dp[canUse] = true;\\n                    return true;\\n                }\\n                canUse |= to_use;\\n            }\\n        }\\n        dp[canUse] = false;\\n        return false;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3997199,
                "title": "java-easy-to-understand",
                "content": "# Code\\n```\\nimport java.util.HashMap;\\nimport java.util.Arrays;\\n\\nclass Solution {\\n    public int[] nums;\\n    public HashMap<String,Boolean> myMap;\\n    int count;\\n\\n    public boolean canI(int sum,int total,int player){\\n        String myHash = \"\"+sum+\"|\"+player+\"|\"+Arrays.hashCode(nums);\\n        if(myMap.containsKey(myHash)){   \\n            return myMap.get(myHash);\\n        }\\n        if(count == 0){\\n            return false;\\n        }\\n        if(player == 0){\\n            for(int i = nums.length-1;i >= 1;i--){\\n                if(nums[i] == 1){\\n                    continue;\\n                }\\n                if(sum + i >= total){\\n                    myMap.put(myHash,true);\\n                    return true;\\n                }\\n                else{\\n                    nums[i] = 1;\\n                    count--;\\n                    if(canI(sum+i,total,1)){\\n                        myMap.put(myHash,true);\\n                        nums[i] = 0;\\n                        count++;\\n                        return true;\\n                    }\\n                    count++;\\n                    nums[i] = 0;\\n                }\\n            }\\n            myMap.put(myHash,false);\\n            return false;\\n        }\\n        else{\\n            for(int i = nums.length-1;i >= 1;i--){\\n                if(nums[i] == 1){\\n                    continue;\\n                }\\n                if(sum + i >= total){\\n                    myMap.put(myHash,false);\\n                    return false;\\n                }\\n                else{\\n                    count--;\\n                    nums[i] = 1;\\n                    if(!canI(sum+i,total,0)){\\n                        myMap.put(myHash,false);\\n                        nums[i] = 0;\\n                        count++;\\n                        return false;\\n                    }\\n                    count++;\\n                    nums[i] = 0;\\n                }\\n            }\\n            myMap.put(myHash,true);\\n            return true;\\n        }\\n    }\\n\\n    public boolean canIWin(int maxChoosableInteger, int desiredTotal) {\\n        nums = new int[maxChoosableInteger+1];\\n        for(int i = 1;i <= maxChoosableInteger;i++){\\n            nums[i] = 0;\\n        }\\n        myMap = new HashMap<String,Boolean>();\\n        count = maxChoosableInteger;\\n        return canI(0,desiredTotal,0);\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nimport java.util.HashMap;\\nimport java.util.Arrays;\\n\\nclass Solution {\\n    public int[] nums;\\n    public HashMap<String,Boolean> myMap;\\n    int count;\\n\\n    public boolean canI(int sum,int total,int player){\\n        String myHash = \"\"+sum+\"|\"+player+\"|\"+Arrays.hashCode(nums);\\n        if(myMap.containsKey(myHash)){   \\n            return myMap.get(myHash);\\n        }\\n        if(count == 0){\\n            return false;\\n        }\\n        if(player == 0){\\n            for(int i = nums.length-1;i >= 1;i--){\\n                if(nums[i] == 1){\\n                    continue;\\n                }\\n                if(sum + i >= total){\\n                    myMap.put(myHash,true);\\n                    return true;\\n                }\\n                else{\\n                    nums[i] = 1;\\n                    count--;\\n                    if(canI(sum+i,total,1)){\\n                        myMap.put(myHash,true);\\n                        nums[i] = 0;\\n                        count++;\\n                        return true;\\n                    }\\n                    count++;\\n                    nums[i] = 0;\\n                }\\n            }\\n            myMap.put(myHash,false);\\n            return false;\\n        }\\n        else{\\n            for(int i = nums.length-1;i >= 1;i--){\\n                if(nums[i] == 1){\\n                    continue;\\n                }\\n                if(sum + i >= total){\\n                    myMap.put(myHash,false);\\n                    return false;\\n                }\\n                else{\\n                    count--;\\n                    nums[i] = 1;\\n                    if(!canI(sum+i,total,0)){\\n                        myMap.put(myHash,false);\\n                        nums[i] = 0;\\n                        count++;\\n                        return false;\\n                    }\\n                    count++;\\n                    nums[i] = 0;\\n                }\\n            }\\n            myMap.put(myHash,true);\\n            return true;\\n        }\\n    }\\n\\n    public boolean canIWin(int maxChoosableInteger, int desiredTotal) {\\n        nums = new int[maxChoosableInteger+1];\\n        for(int i = 1;i <= maxChoosableInteger;i++){\\n            nums[i] = 0;\\n        }\\n        myMap = new HashMap<String,Boolean>();\\n        count = maxChoosableInteger;\\n        return canI(0,desiredTotal,0);\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3987048,
                "title": "see-if-it-may-help-you",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n// Approach: Learnt new approach of how to do by bitmasking.\\n// (Solution of zzg_zzm   is refered)\\n// ((n>>i)&1)  and ((1<<i)&n)  both are same and are used to find value of ith bit of n.\\n int mem[1<<20] = {};\\nbool solve(int n,int W,int k,vector<int>&dp){\\nif(W<=0)\\nreturn false;\\n\\nif(dp[k]!=-1)\\nreturn dp[k];\\n\\n    for(int i=0;i<n;i++){\\n        if(!((k>>i)&1)  && !solve(n,W-(i+1),k|(1<<i),dp)) \\n        return dp[k]=true;\\n    }\\n    return dp[k]=false;\\n}\\n\\n    bool canIWin(int maxChoosableInteger, int desiredTotal) {\\n      int n=maxChoosableInteger;\\n        int tsum=n*(n+1)/2;\\n        if(desiredTotal>tsum)\\n        return false;\\n        else if(desiredTotal<n)\\n        return true;\\n        else if(desiredTotal==tsum)\\n        return (n%2);\\n\\n  int k=0;\\nvector<int>dp(1<<20,-1);\\n        return solve(n,desiredTotal,k,dp);\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n// Approach: Learnt new approach of how to do by bitmasking.\\n// (Solution of zzg_zzm   is refered)\\n// ((n>>i)&1)  and ((1<<i)&n)  both are same and are used to find value of ith bit of n.\\n int mem[1<<20] = {};\\nbool solve(int n,int W,int k,vector<int>&dp){\\nif(W<=0)\\nreturn false;\\n\\nif(dp[k]!=-1)\\nreturn dp[k];\\n\\n    for(int i=0;i<n;i++){\\n        if(!((k>>i)&1)  && !solve(n,W-(i+1),k|(1<<i),dp)) \\n        return dp[k]=true;\\n    }\\n    return dp[k]=false;\\n}\\n\\n    bool canIWin(int maxChoosableInteger, int desiredTotal) {\\n      int n=maxChoosableInteger;\\n        int tsum=n*(n+1)/2;\\n        if(desiredTotal>tsum)\\n        return false;\\n        else if(desiredTotal<n)\\n        return true;\\n        else if(desiredTotal==tsum)\\n        return (n%2);\\n\\n  int k=0;\\nvector<int>dp(1<<20,-1);\\n        return solve(n,desiredTotal,k,dp);\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3960753,
                "title": "recursion-python3",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution:\\n    def canIWin(self, maxChoosableInteger: int, desiredTotal: int) -> bool:\\n\\n        @cache\\n        def dfs(nums, total):\\n            return any(not dfs(nums[:i] + nums[i+1:], total + num) if total + num < desiredTotal else True for i, num in enumerate(nums))\\n        \\n        return False if sum(range(1,maxChoosableInteger+1)) < desiredTotal else dfs(tuple(range(1,maxChoosableInteger+1)), 0)\\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def canIWin(self, maxChoosableInteger: int, desiredTotal: int) -> bool:\\n\\n        @cache\\n        def dfs(nums, total):\\n            return any(not dfs(nums[:i] + nums[i+1:], total + num) if total + num < desiredTotal else True for i, num in enumerate(nums))\\n        \\n        return False if sum(range(1,maxChoosableInteger+1)) < desiredTotal else dfs(tuple(range(1,maxChoosableInteger+1)), 0)\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3960528,
                "title": "can-i-win",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\n/**\\n * @param {number} maxChoosableInteger\\n * @param {number} desiredTotal\\n * @return {boolean}\\n */\\nvar canIWin = function(maxChoosableInteger, desiredTotal) {\\n    if (desiredTotal <= 0) {\\n        return true;\\n    }  \\n    if (maxChoosableInteger * (maxChoosableInteger + 1) / 2 < desiredTotal) {\\n        return false;\\n    }\\n    const memo = new Map();\\n    function canWin(remainingTotal, usedNumbers) {\\n        if (memo.has(usedNumbers)) {\\n            return memo.get(usedNumbers);\\n        }\\n        for (let i = 1; i <= maxChoosableInteger; i++) {\\n            const mask = 1 << i;\\n            if ((usedNumbers & mask) === 0) { \\n                if (i >= remainingTotal || !canWin(remainingTotal - i, usedNumbers | mask)) {\\n                    memo.set(usedNumbers, true);\\n                    return true;\\n                }\\n            }\\n        }\\n        memo.set(usedNumbers, false);\\n        return false;\\n    }\\n    return canWin(desiredTotal, 0);\\n};\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\n/**\\n * @param {number} maxChoosableInteger\\n * @param {number} desiredTotal\\n * @return {boolean}\\n */\\nvar canIWin = function(maxChoosableInteger, desiredTotal) {\\n    if (desiredTotal <= 0) {\\n        return true;\\n    }  \\n    if (maxChoosableInteger * (maxChoosableInteger + 1) / 2 < desiredTotal) {\\n        return false;\\n    }\\n    const memo = new Map();\\n    function canWin(remainingTotal, usedNumbers) {\\n        if (memo.has(usedNumbers)) {\\n            return memo.get(usedNumbers);\\n        }\\n        for (let i = 1; i <= maxChoosableInteger; i++) {\\n            const mask = 1 << i;\\n            if ((usedNumbers & mask) === 0) { \\n                if (i >= remainingTotal || !canWin(remainingTotal - i, usedNumbers | mask)) {\\n                    memo.set(usedNumbers, true);\\n                    return true;\\n                }\\n            }\\n        }\\n        memo.set(usedNumbers, false);\\n        return false;\\n    }\\n    return canWin(desiredTotal, 0);\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3921411,
                "title": "6-lines-logical-python-solution",
                "content": "# Intuition\\nConsider the cases where player A can win and lose\\n\\n# Approach\\n- If the sum of all integers till maxInt is less than the required total then A can\\'t win\\n- If there exists a number which is greater than or equal to the total then A wins\\n- If there exists any move that A can play so that B can\\'t win in the next move\\n\\nJust code the above 3 conditions using recursion\\n\\n# Code\\n```\\nclass Solution:\\n    def canIWin(self, maxInt: int, total: int) -> bool:\\n        #condition1\\n        if maxInt * (maxInt+1) / 2 < total: return False\\n\\n        @cache\\n        def func(nums, total):\\n            #condition2\\n            if any(total <= x for x in nums): return True \\n            #condition3\\n            return any(not func(nums-{x}, total-x) for x in nums)\\n\\n        return func(frozenset(range(1,maxInt+1)), total)\\n\\n            \\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def canIWin(self, maxInt: int, total: int) -> bool:\\n        #condition1\\n        if maxInt * (maxInt+1) / 2 < total: return False\\n\\n        @cache\\n        def func(nums, total):\\n            #condition2\\n            if any(total <= x for x in nums): return True \\n            #condition3\\n            return any(not func(nums-{x}, total-x) for x in nums)\\n\\n        return func(frozenset(range(1,maxInt+1)), total)\\n\\n            \\n```",
                "codeTag": "Java"
            },
            {
                "id": 3870566,
                "title": "c-best-solution",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\npublic class Solution {\\n       public bool CanIWin(int maxChoosableInteger, int desiredTotal) {\\n        int sum = maxChoosableInteger * (maxChoosableInteger + 1)/2;\\n        if(sum < desiredTotal) return false;\\n        if(desiredTotal <= 0) return true;\\n\\n        return CanIWin(desiredTotal, new Dictionary<int, bool>(), new bool[maxChoosableInteger + 1], 0); \\n    }\\n\\n    private bool CanIWin(int desiredTotal, Dictionary<int, bool> memo, bool[] visited, int state) {\\n        if(desiredTotal <= 0) return false;   \\n   \\n        if(memo.ContainsKey(state)) return memo[state];\\n\\n        for(int i = 1; i < visited.Length; i++) {\\n            if(!visited[i]) {\\n                visited[i] = true;\\n                if(!CanIWin(desiredTotal - i, memo, visited, 1 << i | state)) {\\n                    memo.Add(state, true);\\n                    visited[i] = false;\\n                    return true;\\n                }\\n                visited[i] = false;\\n            }   \\n        } \\n\\n        memo.Add(state, false);\\n        return false;\\n    }\\n}\\n```",
                "solutionTags": [
                    "C#"
                ],
                "code": "```\\npublic class Solution {\\n       public bool CanIWin(int maxChoosableInteger, int desiredTotal) {\\n        int sum = maxChoosableInteger * (maxChoosableInteger + 1)/2;\\n        if(sum < desiredTotal) return false;\\n        if(desiredTotal <= 0) return true;\\n\\n        return CanIWin(desiredTotal, new Dictionary<int, bool>(), new bool[maxChoosableInteger + 1], 0); \\n    }\\n\\n    private bool CanIWin(int desiredTotal, Dictionary<int, bool> memo, bool[] visited, int state) {\\n        if(desiredTotal <= 0) return false;   \\n   \\n        if(memo.ContainsKey(state)) return memo[state];\\n\\n        for(int i = 1; i < visited.Length; i++) {\\n            if(!visited[i]) {\\n                visited[i] = true;\\n                if(!CanIWin(desiredTotal - i, memo, visited, 1 << i | state)) {\\n                    memo.Add(state, true);\\n                    visited[i] = false;\\n                    return true;\\n                }\\n                visited[i] = false;\\n            }   \\n        } \\n\\n        memo.Add(state, false);\\n        return false;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3841766,
                "title": "python-solution",
                "content": "# Code\\n```\\nclass Solution(object):\\n    def win(self,arr,score,desiredTotal):\\n        if score+arr[-1] >= desiredTotal:\\n            return True\\n        if arr in self.memo:\\n            return self.memo[arr]\\n        for i in range(len(arr)):\\n            if not self.win(arr[:i]+arr[i+1:],score+arr[i],desiredTotal):\\n                self.memo[arr] = True\\n                return True\\n            self.memo[arr] = False\\n        return False\\n\\n    def canIWin(self, maxChoosableInteger, desiredTotal):\\n        if desiredTotal < 0:\\n            return True\\n        if (maxChoosableInteger*(maxChoosableInteger+1))/2 < desiredTotal:\\n            return False\\n        if maxChoosableInteger > desiredTotal:\\n            return True\\n        if maxChoosableInteger+1 == desiredTotal:\\n            return False\\n        if desiredTotal < maxChoosableInteger*2:\\n            return True\\n        self.memo = {}\\n        return self.win(tuple(range(1, maxChoosableInteger+1)),0,desiredTotal)\\n```",
                "solutionTags": [
                    "Python"
                ],
                "code": "```\\nclass Solution(object):\\n    def win(self,arr,score,desiredTotal):\\n        if score+arr[-1] >= desiredTotal:\\n            return True\\n        if arr in self.memo:\\n            return self.memo[arr]\\n        for i in range(len(arr)):\\n            if not self.win(arr[:i]+arr[i+1:],score+arr[i],desiredTotal):\\n                self.memo[arr] = True\\n                return True\\n            self.memo[arr] = False\\n        return False\\n\\n    def canIWin(self, maxChoosableInteger, desiredTotal):\\n        if desiredTotal < 0:\\n            return True\\n        if (maxChoosableInteger*(maxChoosableInteger+1))/2 < desiredTotal:\\n            return False\\n        if maxChoosableInteger > desiredTotal:\\n            return True\\n        if maxChoosableInteger+1 == desiredTotal:\\n            return False\\n        if desiredTotal < maxChoosableInteger*2:\\n            return True\\n        self.memo = {}\\n        return self.win(tuple(range(1, maxChoosableInteger+1)),0,desiredTotal)\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3831132,
                "title": "c-recursion-memo",
                "content": "# Intuition\\nThe general approach to take in game problems like these is to try, as a first priority, a function that will play optimally for any player. It will be a function that given a state of the game will return whether such game state is winnable.\\n\\nWhy follow this approach? As far as I know, this is the simplest form a function can take, a function that is ignorant of whose turn it is. And as it is in the simplest form, it is easier to think about such function and therefore we can do a quick check whether it\\'s actually in a sufficient form.\\n\\nLuckily for us it is sufficient for this problem! The state of the game is in fact defined by what has been taken previously and the current sum (score).  \\n* If the current sum (score) is lower than the target (`desiredTotal`) then we are still in a game and we can try any of the moves available to us that are left in the set of available moves.\\n* Otherwise, we have arrived at a state that was passed to us by another player and that player made a winning move (i.e taking the score to the finish line). Here we return that we have lost.\\n\\nIn principle, that is all that we need. Maybe we just need to brush up some semantics.\\n\\n# Approach\\nWe would like to have a way to know what\\'s the state of the current game. There are two important parameters that can help us make our next decision:\\n* Available moves - it\\'s a set of moves that we are left with at this certain state of the game. Initially, we can take any number from `[1 ... N]` inclusive (N being `maxChoosableInteger`). As we are about to take some number from this set and pass the new game state to the next player, we must remove that number from the set. This whole procedure of keeping what numbers are still available can be achieved with a `bitset`. `bitset` can tell us whether certain number has been taken with a bit `1` or `0` otherwise. So all we need to do is mark the position of the taken number. Somewhat from experience and historically this is done using just an `int` variable (and that\\'s what I have), but I would prefer to see people use bitset instead.\\n* Current sum score - this is a simpler parameter, just a current total score (running score of the game). This parameter helps us determine whether our game comes to an end. At a point when this score is greater or equal to `desiredTotal` we should stop the game. Anywhere in between it\\'s nice to keep track of this parameter (because we need it, though I guess we can just reduce our `desiredTotal` to zero instead). \\n\\nPartial note: while sum (score) parameter is nice to keep track of, it\\'s a redundant state parameter. In fact, our bitmask already can tell us how much score we have at that bitmask state. Carrying sum score is therefore only a nice thing to have as computing score from the bitmask itself takes a bit of time, but sum (score) is not a necessary state indicator. That is we do not need, in a sense of DP, to have `dp[mask][sum]` situation, as `mask` parameter can have only one `sum` related to it. `dp[mask]` is a sufficient game state.\\n\\n# Complexity\\n- Time complexity: $$O(n * 2^n)$$\\n- Space complexity: $$O(2^n)$$\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nint dfs(int mask, int sum, int n, int t, vector <int> &dp) {\\n    if (sum >= t) // Base Case\\n        return false; // we lost by now\\n    if (dp[mask] != -1) // Memo check\\n        return dp[mask]; // return what we found before\\n    for (int i = 0; i < n; i++) {\\n        if ((mask & (1 << i)) == 0) { // available?\\n            if (!dfs(mask ^ (1 << i), sum + i + 1, n, t, dp))\\n                return dp[mask] = true;\\n            // the if statement checks if the opponent loses\\n            // if opponent loses at any of our available moves\\n            // that means we are going to win in this state.\\n        }\\n    }\\n    return dp[mask] = false;\\n}\\nbool canIWin(int n, int t) {\\n    if (t == 0) // edge case 1: not a game\\n        return true;\\n    if (n * (n + 1) / 2 < t) // edge case 2: never enough\\n        return false;\\n    vector <int> dp(1 << n, -1);\\n    return dfs(0, 0, n, t, dp);\\n}\\n```\\n\\nPlaying around a little with bitset:\\n```\\nclass Solution {\\npublic:\\n    int canWin(bitset <20> mask, int sum, int n, vector <int> &dp) {\\n        if (sum <= 0) // Base Case\\n            return false; // we have lost by now\\n        auto &memo = dp[mask.to_ulong()];\\n        if (memo != -1) // Memo check\\n            return memo; // return what we found before\\n        for (int i = 0; i < n; i++) {\\n            if (mask.test(i) == 0) { // available?\\n                if (!canWin(mask ^ (bitset <20>(1 << i)), sum - i - 1, n, dp))\\n                    return memo = true;\\n                // the if statement checks if the opponent loses\\n                // if opponent loses at any of our available moves\\n                // that means we are going to win in this state.\\n            }\\n        }\\n        return memo = false;\\n    }\\n    bool canIWin(int n, int desiredTotal) {\\n        if (desiredTotal == 0) // edge case 1: not a game\\n            return true;\\n        if (n * (n + 1) / 2 < desiredTotal) // edge case 2: never enough\\n            return false;\\n        vector <int> dp(1 << n, -1);\\n        return canWin(bitset <20>(0), desiredTotal, n, dp);\\n    }\\n};\\n```\\n\\nNot sure if I like `bitset <20>` here, but as an exploration it was worth a try :)",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nint dfs(int mask, int sum, int n, int t, vector <int> &dp) {\\n    if (sum >= t) // Base Case\\n        return false; // we lost by now\\n    if (dp[mask] != -1) // Memo check\\n        return dp[mask]; // return what we found before\\n    for (int i = 0; i < n; i++) {\\n        if ((mask & (1 << i)) == 0) { // available?\\n            if (!dfs(mask ^ (1 << i), sum + i + 1, n, t, dp))\\n                return dp[mask] = true;\\n            // the if statement checks if the opponent loses\\n            // if opponent loses at any of our available moves\\n            // that means we are going to win in this state.\\n        }\\n    }\\n    return dp[mask] = false;\\n}\\nbool canIWin(int n, int t) {\\n    if (t == 0) // edge case 1: not a game\\n        return true;\\n    if (n * (n + 1) / 2 < t) // edge case 2: never enough\\n        return false;\\n    vector <int> dp(1 << n, -1);\\n    return dfs(0, 0, n, t, dp);\\n}\\n```\n```\\nclass Solution {\\npublic:\\n    int canWin(bitset <20> mask, int sum, int n, vector <int> &dp) {\\n        if (sum <= 0) // Base Case\\n            return false; // we have lost by now\\n        auto &memo = dp[mask.to_ulong()];\\n        if (memo != -1) // Memo check\\n            return memo; // return what we found before\\n        for (int i = 0; i < n; i++) {\\n            if (mask.test(i) == 0) { // available?\\n                if (!canWin(mask ^ (bitset <20>(1 << i)), sum - i - 1, n, dp))\\n                    return memo = true;\\n                // the if statement checks if the opponent loses\\n                // if opponent loses at any of our available moves\\n                // that means we are going to win in this state.\\n            }\\n        }\\n        return memo = false;\\n    }\\n    bool canIWin(int n, int desiredTotal) {\\n        if (desiredTotal == 0) // edge case 1: not a game\\n            return true;\\n        if (n * (n + 1) / 2 < desiredTotal) // edge case 2: never enough\\n            return false;\\n        vector <int> dp(1 << n, -1);\\n        return canWin(bitset <20>(0), desiredTotal, n, dp);\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3830043,
                "title": "minimax-algo-gametree-pruning-python",
                "content": "# Intuition\\nSince both players have complete information of game (which numbers have been chosen), play turnwise, minimax algorithm can be used.\\n\\n# Approach\\n[Minimax algo.](https://www.youtube.com/watch?v=rMliVVTlLwY) See previous videos in the playlist for context on game theory.\\n\\nTraverse game tree, if you are player 2 node then try to choose False only, if False not present then choose True. But if you are player 1 node, then try to choose True only, if True not present then choose False.\\nIn below code, you can see pruning of nodes for both player 1 and player 2  as if player 1 has found a true path, it can take it without harm so other children are pruned. Similarly, if player 2 has found a False path, it can take it without harm as it is trying to defeat us so other children are pruned.\\n\\n# Code\\nTurn 1 means player 1 turn, turn -1 means player 2 turn\\nLookout for comments\\n```\\nclass Solution:\\n    def f(self,available,turn,desired,csum,maxChoosableInteger,dp):\\n        if csum>=desired:\\n            return turn == -1 # Return True if turn is -1 i.e. player 1 made the winning move\\n        if dp.get((turn,tuple(available)),None) is not None:\\n            return dp[(turn,tuple(available))] # Taking memoized value\\n        if turn == -1:# Player 2 turn\\n            res = True\\n            for i in range(maxChoosableInteger):\\n                if available[i]:\\n                    available[i] = False\\n                    res = res and self.f(available,1,desired,csum+i+1,maxChoosableInteger,dp)\\n                    available[i] = True # Backtracking \\n                    if not res:# Pruning\\n                        dp[(turn,tuple(available))] = False\\n                        return res\\n            dp[(turn,tuple(available))] = res\\n            return res\\n        else:# Player 1 turn\\n            res = False\\n            for i in range(maxChoosableInteger):\\n                if available[i]:\\n                    available[i] = False\\n                    res = res or self.f(available,-1,desired,csum+i+1,maxChoosableInteger,dp)\\n                    available[i] = True # Backtracking\\n                    if res:# Pruning\\n                        dp[(turn,tuple(available))] = True\\n                        return res\\n            dp[(turn,tuple(available))] = res # Memoizing\\n            return res\\n\\n    def canIWin(self, maxChoosableInteger: int, desiredTotal: int) -> bool:\\n        available = [True]*maxChoosableInteger\\n        if desiredTotal> (maxChoosableInteger*(maxChoosableInteger+1))/2:\\n            return False\\n        dp = {}\\n        if desiredTotal == 0 or desiredTotal<=maxChoosableInteger:\\n            return True\\n        return self.f(available,1,desiredTotal,0,maxChoosableInteger,dp)\\n```",
                "solutionTags": [
                    "Python3",
                    "Memoization",
                    "Game Theory"
                ],
                "code": "```\\nclass Solution:\\n    def f(self,available,turn,desired,csum,maxChoosableInteger,dp):\\n        if csum>=desired:\\n            return turn == -1 # Return True if turn is -1 i.e. player 1 made the winning move\\n        if dp.get((turn,tuple(available)),None) is not None:\\n            return dp[(turn,tuple(available))] # Taking memoized value\\n        if turn == -1:# Player 2 turn\\n            res = True\\n            for i in range(maxChoosableInteger):\\n                if available[i]:\\n                    available[i] = False\\n                    res = res and self.f(available,1,desired,csum+i+1,maxChoosableInteger,dp)\\n                    available[i] = True # Backtracking \\n                    if not res:# Pruning\\n                        dp[(turn,tuple(available))] = False\\n                        return res\\n            dp[(turn,tuple(available))] = res\\n            return res\\n        else:# Player 1 turn\\n            res = False\\n            for i in range(maxChoosableInteger):\\n                if available[i]:\\n                    available[i] = False\\n                    res = res or self.f(available,-1,desired,csum+i+1,maxChoosableInteger,dp)\\n                    available[i] = True # Backtracking\\n                    if res:# Pruning\\n                        dp[(turn,tuple(available))] = True\\n                        return res\\n            dp[(turn,tuple(available))] = res # Memoizing\\n            return res\\n\\n    def canIWin(self, maxChoosableInteger: int, desiredTotal: int) -> bool:\\n        available = [True]*maxChoosableInteger\\n        if desiredTotal> (maxChoosableInteger*(maxChoosableInteger+1))/2:\\n            return False\\n        dp = {}\\n        if desiredTotal == 0 or desiredTotal<=maxChoosableInteger:\\n            return True\\n        return self.f(available,1,desiredTotal,0,maxChoosableInteger,dp)\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3827767,
                "title": "java-dp-solution-recursion-with-memory",
                "content": "\\n# Code\\n```\\n// DP Solution: Recursion with Memory\\n// Use bit map to represent the used boolean array. (used.length <= 21)\\n// Time complexity: O(2^N), where N = maxChoosableInteger\\n// Space complexity: O(2^N)\\nclass Solution {\\n    public boolean canIWin(int maxChoosableInteger, int desiredTotal) {\\n        int sum = maxChoosableInteger * (maxChoosableInteger + 1) / 2;\\n        if(sum < desiredTotal) return false;\\n        if(desiredTotal <= 0) return true;\\n        boolean[] used = new boolean[maxChoosableInteger + 1];\\n        Map<Integer, Boolean> memo = new HashMap<>();\\n        return canIWin(0, desiredTotal, used, memo);\\n    }\\n    \\n    private boolean canIWin(int sum, int desiredTotal, boolean[] used, Map<Integer, Boolean> memo) {\\n        if (sum >= desiredTotal) return false;\\n        int bit = bitMap(used);\\n        Boolean status = memo.get(bit);\\n        if (status != null) return status;\\n        // If the opponent always win or I always lose, then win is false\\n        for (int i = 1; i < used.length; i++) {\\n            if (!used[i]) {\\n                used[i] = true;\\n                status = !canIWin(sum + i, desiredTotal, used, memo);\\n                used[i] = false;\\n                if (status) break;\\n            }\\n        }\\n        memo.put(bit, status);\\n        return status;\\n    }\\n    \\n    private int bitMap(boolean[] used) {\\n        int bit = 0;\\n        for (boolean v : used) {\\n            bit <<= 1;\\n            if (v) {\\n                bit |= 1;\\n            }\\n        }\\n        return bit;\\n    }\\n}\\n```\\nSame idea with bitmap optimization. we don\\'t need to compute bitMap each time.\\n\\n```// DP Solution: Recursion with Memory\\n// Use bit map to represent the used boolean array. (used.length <= 21)\\n// Time complexity: O(2^N), where N = maxChoosableInteger\\n// Space complexity: O(2^N)\\nclass Solution {\\n    public boolean canIWin(int maxChoosableInteger, int desiredTotal) {\\n        int sum = maxChoosableInteger * (maxChoosableInteger + 1) / 2;\\n        if(sum < desiredTotal) return false;\\n        if(desiredTotal <= 0) return true;\\n        boolean[] used = new boolean[maxChoosableInteger + 1];\\n        Map<Integer, Boolean> memo = new HashMap<>();\\n        return canIWin(0, desiredTotal, used, memo, 0);\\n    }\\n    \\n    private boolean canIWin(int sum, int desiredTotal, boolean[] used, Map<Integer, Boolean> memo, int bitMap) {\\n        if (sum >= desiredTotal) return false;\\n        Boolean status = memo.get(bitMap);\\n        if (status != null) return status;\\n        // If the opponent always win or I always lose, then win is false\\n        for (int i = 1; i < used.length; i++) {\\n            if (!used[i]) {\\n                used[i] = true;\\n                status = !canIWin(sum + i, desiredTotal, used, memo, bitMap | (1 << i));\\n                used[i] = false;\\n                if (status) break;\\n            }\\n        }\\n        memo.put(bitMap, status);\\n        return status;\\n    }\\n}\\n```\\n",
                "solutionTags": [
                    "Java",
                    "Recursion",
                    "Memoization"
                ],
                "code": "```\\n// DP Solution: Recursion with Memory\\n// Use bit map to represent the used boolean array. (used.length <= 21)\\n// Time complexity: O(2^N), where N = maxChoosableInteger\\n// Space complexity: O(2^N)\\nclass Solution {\\n    public boolean canIWin(int maxChoosableInteger, int desiredTotal) {\\n        int sum = maxChoosableInteger * (maxChoosableInteger + 1) / 2;\\n        if(sum < desiredTotal) return false;\\n        if(desiredTotal <= 0) return true;\\n        boolean[] used = new boolean[maxChoosableInteger + 1];\\n        Map<Integer, Boolean> memo = new HashMap<>();\\n        return canIWin(0, desiredTotal, used, memo);\\n    }\\n    \\n    private boolean canIWin(int sum, int desiredTotal, boolean[] used, Map<Integer, Boolean> memo) {\\n        if (sum >= desiredTotal) return false;\\n        int bit = bitMap(used);\\n        Boolean status = memo.get(bit);\\n        if (status != null) return status;\\n        // If the opponent always win or I always lose, then win is false\\n        for (int i = 1; i < used.length; i++) {\\n            if (!used[i]) {\\n                used[i] = true;\\n                status = !canIWin(sum + i, desiredTotal, used, memo);\\n                used[i] = false;\\n                if (status) break;\\n            }\\n        }\\n        memo.put(bit, status);\\n        return status;\\n    }\\n    \\n    private int bitMap(boolean[] used) {\\n        int bit = 0;\\n        for (boolean v : used) {\\n            bit <<= 1;\\n            if (v) {\\n                bit |= 1;\\n            }\\n        }\\n        return bit;\\n    }\\n}\\n```\n```// DP Solution: Recursion with Memory\\n// Use bit map to represent the used boolean array. (used.length <= 21)\\n// Time complexity: O(2^N), where N = maxChoosableInteger\\n// Space complexity: O(2^N)\\nclass Solution {\\n    public boolean canIWin(int maxChoosableInteger, int desiredTotal) {\\n        int sum = maxChoosableInteger * (maxChoosableInteger + 1) / 2;\\n        if(sum < desiredTotal) return false;\\n        if(desiredTotal <= 0) return true;\\n        boolean[] used = new boolean[maxChoosableInteger + 1];\\n        Map<Integer, Boolean> memo = new HashMap<>();\\n        return canIWin(0, desiredTotal, used, memo, 0);\\n    }\\n    \\n    private boolean canIWin(int sum, int desiredTotal, boolean[] used, Map<Integer, Boolean> memo, int bitMap) {\\n        if (sum >= desiredTotal) return false;\\n        Boolean status = memo.get(bitMap);\\n        if (status != null) return status;\\n        // If the opponent always win or I always lose, then win is false\\n        for (int i = 1; i < used.length; i++) {\\n            if (!used[i]) {\\n                used[i] = true;\\n                status = !canIWin(sum + i, desiredTotal, used, memo, bitMap | (1 << i));\\n                used[i] = false;\\n                if (status) break;\\n            }\\n        }\\n        memo.put(bitMap, status);\\n        return status;\\n    }\\n}\\n```",
                "codeTag": "Java"
            }
        ],
        "discussions": [
            {
                "id": 1565122,
                "content": [
                    {
                        "username": "elmubark",
                        "content": "This a hard question. I would be surprised if a canidate could come up with a solution to this in an interview without having seen this or a similar qustion in the past.\\n"
                    },
                    {
                        "username": "nyaruko",
                        "content": "FYI, there is a theorem in game theory (I quote it from wikipedia)\\n\"In game theory, Zermelo\\u2019s theorem, named after Ernst Zermelo, says that in any finite two-person game of perfect information in which the players move alternatingly and in which chance does not affect the decision making process, if the game cannot end in a draw, then one of the two players must have a winning strategy (i.e. force a win).\""
                    },
                    {
                        "username": "Petersburg",
                        "content": "this seems hard..."
                    },
                    {
                        "username": "QQBear",
                        "content": "Can anyone explain why (10,40) is false? thanks\\n\\nIf the first player choose 10,  the second player has (9, 30).\\nIf the second player chooses 1, the first has (2-9, 29), the first can win.\\nIf the second player chooses 9, the first has(8, 21), the first can win too."
                    },
                    {
                        "username": "Vishavjeet2710",
                        "content": "The key point to note here is, we only need to memorize the mask of the digits we have used till now.\\nWe do not need to memorize the desired sum, because the sum itself can be derived from the mask only.\\neg :\\nWe have maxChoosableIntger=5 , till now we have used 4 and 5 .\\nThus the mask we will have would be 11000 (We activate the bit that we have used).\\nThus the sum we have right now can be derived from the mask i.e. 4+5=9.\\nIn other words we can also say that for each mask we can have one unique sum only , so why should we save that unique sum in some other dimension.\\nThus we need only 1-D array."
                    },
                    {
                        "username": "2uringTested",
                        "content": "Wow great"
                    },
                    {
                        "username": "abheping",
                        "content": "Example test cases are trash"
                    },
                    {
                        "username": "kotak86",
                        "content": "maxChoosableInteger = 10\\ndesiredTotal = 11\\n\\nOutput:\\nfalse\\n\\nExplanation:\\nNo matter which integer the first player choose, the first player will lose.\\nThe first player can choose an integer from 1 up to 10.\\nIf the first player choose 1, the second player can only choose integers from 2 up to 10.\\nThe second player will win by choosing 10 and get a total = 11, which is >= desiredTotal.\\nSame with other integers chosen by the first player, the second player will always win. \\n\\n\\n\\nFirst Round : If player1 Choose 10 (can choose from 1-10) and Player2 choose 9  (can choose from 2 to 9)\\nSec Round : if Player1 choose 8 -- can reach the DesireTotal 11 (10+8) before player2 \\n\\nwhy answer is false ?"
                    },
                    {
                        "username": "dikshawali",
                        "content": "[@sawang325](/sawang325) what u mean by force a win?"
                    },
                    {
                        "username": "sawang325",
                        "content": "return true if the first player to move can force a win, otherwise, return false"
                    },
                    {
                        "username": "no-username",
                        "content": "same question"
                    },
                    {
                        "username": "ckim16",
                        "content": "can anybody help me understand the meaning of `play optimally`?"
                    },
                    {
                        "username": "just_kidding__03",
                        "content": "It could also be said as if they are able to predict the future and see the what present move would lead to and what optimal moves opponent would take . If in any one move the person is winning it will always choose that move only or maximize it\\'s winning chance."
                    },
                    {
                        "username": "uttarandas501",
                        "content": "Both will try to make a move that will increase their chances to win"
                    },
                    {
                        "username": "Merciless",
                        "content": "Most of the python solution got TLE on test case:\\n20\\n168"
                    },
                    {
                        "username": "respectmyauthoritah",
                        "content": "or it's impossible?"
                    }
                ]
            },
            {
                "id": 1565682,
                "content": [
                    {
                        "username": "elmubark",
                        "content": "This a hard question. I would be surprised if a canidate could come up with a solution to this in an interview without having seen this or a similar qustion in the past.\\n"
                    },
                    {
                        "username": "nyaruko",
                        "content": "FYI, there is a theorem in game theory (I quote it from wikipedia)\\n\"In game theory, Zermelo\\u2019s theorem, named after Ernst Zermelo, says that in any finite two-person game of perfect information in which the players move alternatingly and in which chance does not affect the decision making process, if the game cannot end in a draw, then one of the two players must have a winning strategy (i.e. force a win).\""
                    },
                    {
                        "username": "Petersburg",
                        "content": "this seems hard..."
                    },
                    {
                        "username": "QQBear",
                        "content": "Can anyone explain why (10,40) is false? thanks\\n\\nIf the first player choose 10,  the second player has (9, 30).\\nIf the second player chooses 1, the first has (2-9, 29), the first can win.\\nIf the second player chooses 9, the first has(8, 21), the first can win too."
                    },
                    {
                        "username": "Vishavjeet2710",
                        "content": "The key point to note here is, we only need to memorize the mask of the digits we have used till now.\\nWe do not need to memorize the desired sum, because the sum itself can be derived from the mask only.\\neg :\\nWe have maxChoosableIntger=5 , till now we have used 4 and 5 .\\nThus the mask we will have would be 11000 (We activate the bit that we have used).\\nThus the sum we have right now can be derived from the mask i.e. 4+5=9.\\nIn other words we can also say that for each mask we can have one unique sum only , so why should we save that unique sum in some other dimension.\\nThus we need only 1-D array."
                    },
                    {
                        "username": "2uringTested",
                        "content": "Wow great"
                    },
                    {
                        "username": "abheping",
                        "content": "Example test cases are trash"
                    },
                    {
                        "username": "kotak86",
                        "content": "maxChoosableInteger = 10\\ndesiredTotal = 11\\n\\nOutput:\\nfalse\\n\\nExplanation:\\nNo matter which integer the first player choose, the first player will lose.\\nThe first player can choose an integer from 1 up to 10.\\nIf the first player choose 1, the second player can only choose integers from 2 up to 10.\\nThe second player will win by choosing 10 and get a total = 11, which is >= desiredTotal.\\nSame with other integers chosen by the first player, the second player will always win. \\n\\n\\n\\nFirst Round : If player1 Choose 10 (can choose from 1-10) and Player2 choose 9  (can choose from 2 to 9)\\nSec Round : if Player1 choose 8 -- can reach the DesireTotal 11 (10+8) before player2 \\n\\nwhy answer is false ?"
                    },
                    {
                        "username": "dikshawali",
                        "content": "[@sawang325](/sawang325) what u mean by force a win?"
                    },
                    {
                        "username": "sawang325",
                        "content": "return true if the first player to move can force a win, otherwise, return false"
                    },
                    {
                        "username": "no-username",
                        "content": "same question"
                    },
                    {
                        "username": "ckim16",
                        "content": "can anybody help me understand the meaning of `play optimally`?"
                    },
                    {
                        "username": "just_kidding__03",
                        "content": "It could also be said as if they are able to predict the future and see the what present move would lead to and what optimal moves opponent would take . If in any one move the person is winning it will always choose that move only or maximize it\\'s winning chance."
                    },
                    {
                        "username": "uttarandas501",
                        "content": "Both will try to make a move that will increase their chances to win"
                    },
                    {
                        "username": "Merciless",
                        "content": "Most of the python solution got TLE on test case:\\n20\\n168"
                    },
                    {
                        "username": "respectmyauthoritah",
                        "content": "or it's impossible?"
                    }
                ]
            },
            {
                "id": 1566135,
                "content": [
                    {
                        "username": "elmubark",
                        "content": "This a hard question. I would be surprised if a canidate could come up with a solution to this in an interview without having seen this or a similar qustion in the past.\\n"
                    },
                    {
                        "username": "nyaruko",
                        "content": "FYI, there is a theorem in game theory (I quote it from wikipedia)\\n\"In game theory, Zermelo\\u2019s theorem, named after Ernst Zermelo, says that in any finite two-person game of perfect information in which the players move alternatingly and in which chance does not affect the decision making process, if the game cannot end in a draw, then one of the two players must have a winning strategy (i.e. force a win).\""
                    },
                    {
                        "username": "Petersburg",
                        "content": "this seems hard..."
                    },
                    {
                        "username": "QQBear",
                        "content": "Can anyone explain why (10,40) is false? thanks\\n\\nIf the first player choose 10,  the second player has (9, 30).\\nIf the second player chooses 1, the first has (2-9, 29), the first can win.\\nIf the second player chooses 9, the first has(8, 21), the first can win too."
                    },
                    {
                        "username": "Vishavjeet2710",
                        "content": "The key point to note here is, we only need to memorize the mask of the digits we have used till now.\\nWe do not need to memorize the desired sum, because the sum itself can be derived from the mask only.\\neg :\\nWe have maxChoosableIntger=5 , till now we have used 4 and 5 .\\nThus the mask we will have would be 11000 (We activate the bit that we have used).\\nThus the sum we have right now can be derived from the mask i.e. 4+5=9.\\nIn other words we can also say that for each mask we can have one unique sum only , so why should we save that unique sum in some other dimension.\\nThus we need only 1-D array."
                    },
                    {
                        "username": "2uringTested",
                        "content": "Wow great"
                    },
                    {
                        "username": "abheping",
                        "content": "Example test cases are trash"
                    },
                    {
                        "username": "kotak86",
                        "content": "maxChoosableInteger = 10\\ndesiredTotal = 11\\n\\nOutput:\\nfalse\\n\\nExplanation:\\nNo matter which integer the first player choose, the first player will lose.\\nThe first player can choose an integer from 1 up to 10.\\nIf the first player choose 1, the second player can only choose integers from 2 up to 10.\\nThe second player will win by choosing 10 and get a total = 11, which is >= desiredTotal.\\nSame with other integers chosen by the first player, the second player will always win. \\n\\n\\n\\nFirst Round : If player1 Choose 10 (can choose from 1-10) and Player2 choose 9  (can choose from 2 to 9)\\nSec Round : if Player1 choose 8 -- can reach the DesireTotal 11 (10+8) before player2 \\n\\nwhy answer is false ?"
                    },
                    {
                        "username": "dikshawali",
                        "content": "[@sawang325](/sawang325) what u mean by force a win?"
                    },
                    {
                        "username": "sawang325",
                        "content": "return true if the first player to move can force a win, otherwise, return false"
                    },
                    {
                        "username": "no-username",
                        "content": "same question"
                    },
                    {
                        "username": "ckim16",
                        "content": "can anybody help me understand the meaning of `play optimally`?"
                    },
                    {
                        "username": "just_kidding__03",
                        "content": "It could also be said as if they are able to predict the future and see the what present move would lead to and what optimal moves opponent would take . If in any one move the person is winning it will always choose that move only or maximize it\\'s winning chance."
                    },
                    {
                        "username": "uttarandas501",
                        "content": "Both will try to make a move that will increase their chances to win"
                    },
                    {
                        "username": "Merciless",
                        "content": "Most of the python solution got TLE on test case:\\n20\\n168"
                    },
                    {
                        "username": "respectmyauthoritah",
                        "content": "or it's impossible?"
                    }
                ]
            },
            {
                "id": 1566512,
                "content": [
                    {
                        "username": "elmubark",
                        "content": "This a hard question. I would be surprised if a canidate could come up with a solution to this in an interview without having seen this or a similar qustion in the past.\\n"
                    },
                    {
                        "username": "nyaruko",
                        "content": "FYI, there is a theorem in game theory (I quote it from wikipedia)\\n\"In game theory, Zermelo\\u2019s theorem, named after Ernst Zermelo, says that in any finite two-person game of perfect information in which the players move alternatingly and in which chance does not affect the decision making process, if the game cannot end in a draw, then one of the two players must have a winning strategy (i.e. force a win).\""
                    },
                    {
                        "username": "Petersburg",
                        "content": "this seems hard..."
                    },
                    {
                        "username": "QQBear",
                        "content": "Can anyone explain why (10,40) is false? thanks\\n\\nIf the first player choose 10,  the second player has (9, 30).\\nIf the second player chooses 1, the first has (2-9, 29), the first can win.\\nIf the second player chooses 9, the first has(8, 21), the first can win too."
                    },
                    {
                        "username": "Vishavjeet2710",
                        "content": "The key point to note here is, we only need to memorize the mask of the digits we have used till now.\\nWe do not need to memorize the desired sum, because the sum itself can be derived from the mask only.\\neg :\\nWe have maxChoosableIntger=5 , till now we have used 4 and 5 .\\nThus the mask we will have would be 11000 (We activate the bit that we have used).\\nThus the sum we have right now can be derived from the mask i.e. 4+5=9.\\nIn other words we can also say that for each mask we can have one unique sum only , so why should we save that unique sum in some other dimension.\\nThus we need only 1-D array."
                    },
                    {
                        "username": "2uringTested",
                        "content": "Wow great"
                    },
                    {
                        "username": "abheping",
                        "content": "Example test cases are trash"
                    },
                    {
                        "username": "kotak86",
                        "content": "maxChoosableInteger = 10\\ndesiredTotal = 11\\n\\nOutput:\\nfalse\\n\\nExplanation:\\nNo matter which integer the first player choose, the first player will lose.\\nThe first player can choose an integer from 1 up to 10.\\nIf the first player choose 1, the second player can only choose integers from 2 up to 10.\\nThe second player will win by choosing 10 and get a total = 11, which is >= desiredTotal.\\nSame with other integers chosen by the first player, the second player will always win. \\n\\n\\n\\nFirst Round : If player1 Choose 10 (can choose from 1-10) and Player2 choose 9  (can choose from 2 to 9)\\nSec Round : if Player1 choose 8 -- can reach the DesireTotal 11 (10+8) before player2 \\n\\nwhy answer is false ?"
                    },
                    {
                        "username": "dikshawali",
                        "content": "[@sawang325](/sawang325) what u mean by force a win?"
                    },
                    {
                        "username": "sawang325",
                        "content": "return true if the first player to move can force a win, otherwise, return false"
                    },
                    {
                        "username": "no-username",
                        "content": "same question"
                    },
                    {
                        "username": "ckim16",
                        "content": "can anybody help me understand the meaning of `play optimally`?"
                    },
                    {
                        "username": "just_kidding__03",
                        "content": "It could also be said as if they are able to predict the future and see the what present move would lead to and what optimal moves opponent would take . If in any one move the person is winning it will always choose that move only or maximize it\\'s winning chance."
                    },
                    {
                        "username": "uttarandas501",
                        "content": "Both will try to make a move that will increase their chances to win"
                    },
                    {
                        "username": "Merciless",
                        "content": "Most of the python solution got TLE on test case:\\n20\\n168"
                    },
                    {
                        "username": "respectmyauthoritah",
                        "content": "or it's impossible?"
                    }
                ]
            },
            {
                "id": 1568683,
                "content": [
                    {
                        "username": "elmubark",
                        "content": "This a hard question. I would be surprised if a canidate could come up with a solution to this in an interview without having seen this or a similar qustion in the past.\\n"
                    },
                    {
                        "username": "nyaruko",
                        "content": "FYI, there is a theorem in game theory (I quote it from wikipedia)\\n\"In game theory, Zermelo\\u2019s theorem, named after Ernst Zermelo, says that in any finite two-person game of perfect information in which the players move alternatingly and in which chance does not affect the decision making process, if the game cannot end in a draw, then one of the two players must have a winning strategy (i.e. force a win).\""
                    },
                    {
                        "username": "Petersburg",
                        "content": "this seems hard..."
                    },
                    {
                        "username": "QQBear",
                        "content": "Can anyone explain why (10,40) is false? thanks\\n\\nIf the first player choose 10,  the second player has (9, 30).\\nIf the second player chooses 1, the first has (2-9, 29), the first can win.\\nIf the second player chooses 9, the first has(8, 21), the first can win too."
                    },
                    {
                        "username": "Vishavjeet2710",
                        "content": "The key point to note here is, we only need to memorize the mask of the digits we have used till now.\\nWe do not need to memorize the desired sum, because the sum itself can be derived from the mask only.\\neg :\\nWe have maxChoosableIntger=5 , till now we have used 4 and 5 .\\nThus the mask we will have would be 11000 (We activate the bit that we have used).\\nThus the sum we have right now can be derived from the mask i.e. 4+5=9.\\nIn other words we can also say that for each mask we can have one unique sum only , so why should we save that unique sum in some other dimension.\\nThus we need only 1-D array."
                    },
                    {
                        "username": "2uringTested",
                        "content": "Wow great"
                    },
                    {
                        "username": "abheping",
                        "content": "Example test cases are trash"
                    },
                    {
                        "username": "kotak86",
                        "content": "maxChoosableInteger = 10\\ndesiredTotal = 11\\n\\nOutput:\\nfalse\\n\\nExplanation:\\nNo matter which integer the first player choose, the first player will lose.\\nThe first player can choose an integer from 1 up to 10.\\nIf the first player choose 1, the second player can only choose integers from 2 up to 10.\\nThe second player will win by choosing 10 and get a total = 11, which is >= desiredTotal.\\nSame with other integers chosen by the first player, the second player will always win. \\n\\n\\n\\nFirst Round : If player1 Choose 10 (can choose from 1-10) and Player2 choose 9  (can choose from 2 to 9)\\nSec Round : if Player1 choose 8 -- can reach the DesireTotal 11 (10+8) before player2 \\n\\nwhy answer is false ?"
                    },
                    {
                        "username": "dikshawali",
                        "content": "[@sawang325](/sawang325) what u mean by force a win?"
                    },
                    {
                        "username": "sawang325",
                        "content": "return true if the first player to move can force a win, otherwise, return false"
                    },
                    {
                        "username": "no-username",
                        "content": "same question"
                    },
                    {
                        "username": "ckim16",
                        "content": "can anybody help me understand the meaning of `play optimally`?"
                    },
                    {
                        "username": "just_kidding__03",
                        "content": "It could also be said as if they are able to predict the future and see the what present move would lead to and what optimal moves opponent would take . If in any one move the person is winning it will always choose that move only or maximize it\\'s winning chance."
                    },
                    {
                        "username": "uttarandas501",
                        "content": "Both will try to make a move that will increase their chances to win"
                    },
                    {
                        "username": "Merciless",
                        "content": "Most of the python solution got TLE on test case:\\n20\\n168"
                    },
                    {
                        "username": "respectmyauthoritah",
                        "content": "or it's impossible?"
                    }
                ]
            },
            {
                "id": 1989640,
                "content": [
                    {
                        "username": "elmubark",
                        "content": "This a hard question. I would be surprised if a canidate could come up with a solution to this in an interview without having seen this or a similar qustion in the past.\\n"
                    },
                    {
                        "username": "nyaruko",
                        "content": "FYI, there is a theorem in game theory (I quote it from wikipedia)\\n\"In game theory, Zermelo\\u2019s theorem, named after Ernst Zermelo, says that in any finite two-person game of perfect information in which the players move alternatingly and in which chance does not affect the decision making process, if the game cannot end in a draw, then one of the two players must have a winning strategy (i.e. force a win).\""
                    },
                    {
                        "username": "Petersburg",
                        "content": "this seems hard..."
                    },
                    {
                        "username": "QQBear",
                        "content": "Can anyone explain why (10,40) is false? thanks\\n\\nIf the first player choose 10,  the second player has (9, 30).\\nIf the second player chooses 1, the first has (2-9, 29), the first can win.\\nIf the second player chooses 9, the first has(8, 21), the first can win too."
                    },
                    {
                        "username": "Vishavjeet2710",
                        "content": "The key point to note here is, we only need to memorize the mask of the digits we have used till now.\\nWe do not need to memorize the desired sum, because the sum itself can be derived from the mask only.\\neg :\\nWe have maxChoosableIntger=5 , till now we have used 4 and 5 .\\nThus the mask we will have would be 11000 (We activate the bit that we have used).\\nThus the sum we have right now can be derived from the mask i.e. 4+5=9.\\nIn other words we can also say that for each mask we can have one unique sum only , so why should we save that unique sum in some other dimension.\\nThus we need only 1-D array."
                    },
                    {
                        "username": "2uringTested",
                        "content": "Wow great"
                    },
                    {
                        "username": "abheping",
                        "content": "Example test cases are trash"
                    },
                    {
                        "username": "kotak86",
                        "content": "maxChoosableInteger = 10\\ndesiredTotal = 11\\n\\nOutput:\\nfalse\\n\\nExplanation:\\nNo matter which integer the first player choose, the first player will lose.\\nThe first player can choose an integer from 1 up to 10.\\nIf the first player choose 1, the second player can only choose integers from 2 up to 10.\\nThe second player will win by choosing 10 and get a total = 11, which is >= desiredTotal.\\nSame with other integers chosen by the first player, the second player will always win. \\n\\n\\n\\nFirst Round : If player1 Choose 10 (can choose from 1-10) and Player2 choose 9  (can choose from 2 to 9)\\nSec Round : if Player1 choose 8 -- can reach the DesireTotal 11 (10+8) before player2 \\n\\nwhy answer is false ?"
                    },
                    {
                        "username": "dikshawali",
                        "content": "[@sawang325](/sawang325) what u mean by force a win?"
                    },
                    {
                        "username": "sawang325",
                        "content": "return true if the first player to move can force a win, otherwise, return false"
                    },
                    {
                        "username": "no-username",
                        "content": "same question"
                    },
                    {
                        "username": "ckim16",
                        "content": "can anybody help me understand the meaning of `play optimally`?"
                    },
                    {
                        "username": "just_kidding__03",
                        "content": "It could also be said as if they are able to predict the future and see the what present move would lead to and what optimal moves opponent would take . If in any one move the person is winning it will always choose that move only or maximize it\\'s winning chance."
                    },
                    {
                        "username": "uttarandas501",
                        "content": "Both will try to make a move that will increase their chances to win"
                    },
                    {
                        "username": "Merciless",
                        "content": "Most of the python solution got TLE on test case:\\n20\\n168"
                    },
                    {
                        "username": "respectmyauthoritah",
                        "content": "or it's impossible?"
                    }
                ]
            },
            {
                "id": 1569466,
                "content": [
                    {
                        "username": "elmubark",
                        "content": "This a hard question. I would be surprised if a canidate could come up with a solution to this in an interview without having seen this or a similar qustion in the past.\\n"
                    },
                    {
                        "username": "nyaruko",
                        "content": "FYI, there is a theorem in game theory (I quote it from wikipedia)\\n\"In game theory, Zermelo\\u2019s theorem, named after Ernst Zermelo, says that in any finite two-person game of perfect information in which the players move alternatingly and in which chance does not affect the decision making process, if the game cannot end in a draw, then one of the two players must have a winning strategy (i.e. force a win).\""
                    },
                    {
                        "username": "Petersburg",
                        "content": "this seems hard..."
                    },
                    {
                        "username": "QQBear",
                        "content": "Can anyone explain why (10,40) is false? thanks\\n\\nIf the first player choose 10,  the second player has (9, 30).\\nIf the second player chooses 1, the first has (2-9, 29), the first can win.\\nIf the second player chooses 9, the first has(8, 21), the first can win too."
                    },
                    {
                        "username": "Vishavjeet2710",
                        "content": "The key point to note here is, we only need to memorize the mask of the digits we have used till now.\\nWe do not need to memorize the desired sum, because the sum itself can be derived from the mask only.\\neg :\\nWe have maxChoosableIntger=5 , till now we have used 4 and 5 .\\nThus the mask we will have would be 11000 (We activate the bit that we have used).\\nThus the sum we have right now can be derived from the mask i.e. 4+5=9.\\nIn other words we can also say that for each mask we can have one unique sum only , so why should we save that unique sum in some other dimension.\\nThus we need only 1-D array."
                    },
                    {
                        "username": "2uringTested",
                        "content": "Wow great"
                    },
                    {
                        "username": "abheping",
                        "content": "Example test cases are trash"
                    },
                    {
                        "username": "kotak86",
                        "content": "maxChoosableInteger = 10\\ndesiredTotal = 11\\n\\nOutput:\\nfalse\\n\\nExplanation:\\nNo matter which integer the first player choose, the first player will lose.\\nThe first player can choose an integer from 1 up to 10.\\nIf the first player choose 1, the second player can only choose integers from 2 up to 10.\\nThe second player will win by choosing 10 and get a total = 11, which is >= desiredTotal.\\nSame with other integers chosen by the first player, the second player will always win. \\n\\n\\n\\nFirst Round : If player1 Choose 10 (can choose from 1-10) and Player2 choose 9  (can choose from 2 to 9)\\nSec Round : if Player1 choose 8 -- can reach the DesireTotal 11 (10+8) before player2 \\n\\nwhy answer is false ?"
                    },
                    {
                        "username": "dikshawali",
                        "content": "[@sawang325](/sawang325) what u mean by force a win?"
                    },
                    {
                        "username": "sawang325",
                        "content": "return true if the first player to move can force a win, otherwise, return false"
                    },
                    {
                        "username": "no-username",
                        "content": "same question"
                    },
                    {
                        "username": "ckim16",
                        "content": "can anybody help me understand the meaning of `play optimally`?"
                    },
                    {
                        "username": "just_kidding__03",
                        "content": "It could also be said as if they are able to predict the future and see the what present move would lead to and what optimal moves opponent would take . If in any one move the person is winning it will always choose that move only or maximize it\\'s winning chance."
                    },
                    {
                        "username": "uttarandas501",
                        "content": "Both will try to make a move that will increase their chances to win"
                    },
                    {
                        "username": "Merciless",
                        "content": "Most of the python solution got TLE on test case:\\n20\\n168"
                    },
                    {
                        "username": "respectmyauthoritah",
                        "content": "or it's impossible?"
                    }
                ]
            },
            {
                "id": 1708684,
                "content": [
                    {
                        "username": "elmubark",
                        "content": "This a hard question. I would be surprised if a canidate could come up with a solution to this in an interview without having seen this or a similar qustion in the past.\\n"
                    },
                    {
                        "username": "nyaruko",
                        "content": "FYI, there is a theorem in game theory (I quote it from wikipedia)\\n\"In game theory, Zermelo\\u2019s theorem, named after Ernst Zermelo, says that in any finite two-person game of perfect information in which the players move alternatingly and in which chance does not affect the decision making process, if the game cannot end in a draw, then one of the two players must have a winning strategy (i.e. force a win).\""
                    },
                    {
                        "username": "Petersburg",
                        "content": "this seems hard..."
                    },
                    {
                        "username": "QQBear",
                        "content": "Can anyone explain why (10,40) is false? thanks\\n\\nIf the first player choose 10,  the second player has (9, 30).\\nIf the second player chooses 1, the first has (2-9, 29), the first can win.\\nIf the second player chooses 9, the first has(8, 21), the first can win too."
                    },
                    {
                        "username": "Vishavjeet2710",
                        "content": "The key point to note here is, we only need to memorize the mask of the digits we have used till now.\\nWe do not need to memorize the desired sum, because the sum itself can be derived from the mask only.\\neg :\\nWe have maxChoosableIntger=5 , till now we have used 4 and 5 .\\nThus the mask we will have would be 11000 (We activate the bit that we have used).\\nThus the sum we have right now can be derived from the mask i.e. 4+5=9.\\nIn other words we can also say that for each mask we can have one unique sum only , so why should we save that unique sum in some other dimension.\\nThus we need only 1-D array."
                    },
                    {
                        "username": "2uringTested",
                        "content": "Wow great"
                    },
                    {
                        "username": "abheping",
                        "content": "Example test cases are trash"
                    },
                    {
                        "username": "kotak86",
                        "content": "maxChoosableInteger = 10\\ndesiredTotal = 11\\n\\nOutput:\\nfalse\\n\\nExplanation:\\nNo matter which integer the first player choose, the first player will lose.\\nThe first player can choose an integer from 1 up to 10.\\nIf the first player choose 1, the second player can only choose integers from 2 up to 10.\\nThe second player will win by choosing 10 and get a total = 11, which is >= desiredTotal.\\nSame with other integers chosen by the first player, the second player will always win. \\n\\n\\n\\nFirst Round : If player1 Choose 10 (can choose from 1-10) and Player2 choose 9  (can choose from 2 to 9)\\nSec Round : if Player1 choose 8 -- can reach the DesireTotal 11 (10+8) before player2 \\n\\nwhy answer is false ?"
                    },
                    {
                        "username": "dikshawali",
                        "content": "[@sawang325](/sawang325) what u mean by force a win?"
                    },
                    {
                        "username": "sawang325",
                        "content": "return true if the first player to move can force a win, otherwise, return false"
                    },
                    {
                        "username": "no-username",
                        "content": "same question"
                    },
                    {
                        "username": "ckim16",
                        "content": "can anybody help me understand the meaning of `play optimally`?"
                    },
                    {
                        "username": "just_kidding__03",
                        "content": "It could also be said as if they are able to predict the future and see the what present move would lead to and what optimal moves opponent would take . If in any one move the person is winning it will always choose that move only or maximize it\\'s winning chance."
                    },
                    {
                        "username": "uttarandas501",
                        "content": "Both will try to make a move that will increase their chances to win"
                    },
                    {
                        "username": "Merciless",
                        "content": "Most of the python solution got TLE on test case:\\n20\\n168"
                    },
                    {
                        "username": "respectmyauthoritah",
                        "content": "or it's impossible?"
                    }
                ]
            },
            {
                "id": 1569513,
                "content": [
                    {
                        "username": "elmubark",
                        "content": "This a hard question. I would be surprised if a canidate could come up with a solution to this in an interview without having seen this or a similar qustion in the past.\\n"
                    },
                    {
                        "username": "nyaruko",
                        "content": "FYI, there is a theorem in game theory (I quote it from wikipedia)\\n\"In game theory, Zermelo\\u2019s theorem, named after Ernst Zermelo, says that in any finite two-person game of perfect information in which the players move alternatingly and in which chance does not affect the decision making process, if the game cannot end in a draw, then one of the two players must have a winning strategy (i.e. force a win).\""
                    },
                    {
                        "username": "Petersburg",
                        "content": "this seems hard..."
                    },
                    {
                        "username": "QQBear",
                        "content": "Can anyone explain why (10,40) is false? thanks\\n\\nIf the first player choose 10,  the second player has (9, 30).\\nIf the second player chooses 1, the first has (2-9, 29), the first can win.\\nIf the second player chooses 9, the first has(8, 21), the first can win too."
                    },
                    {
                        "username": "Vishavjeet2710",
                        "content": "The key point to note here is, we only need to memorize the mask of the digits we have used till now.\\nWe do not need to memorize the desired sum, because the sum itself can be derived from the mask only.\\neg :\\nWe have maxChoosableIntger=5 , till now we have used 4 and 5 .\\nThus the mask we will have would be 11000 (We activate the bit that we have used).\\nThus the sum we have right now can be derived from the mask i.e. 4+5=9.\\nIn other words we can also say that for each mask we can have one unique sum only , so why should we save that unique sum in some other dimension.\\nThus we need only 1-D array."
                    },
                    {
                        "username": "2uringTested",
                        "content": "Wow great"
                    },
                    {
                        "username": "abheping",
                        "content": "Example test cases are trash"
                    },
                    {
                        "username": "kotak86",
                        "content": "maxChoosableInteger = 10\\ndesiredTotal = 11\\n\\nOutput:\\nfalse\\n\\nExplanation:\\nNo matter which integer the first player choose, the first player will lose.\\nThe first player can choose an integer from 1 up to 10.\\nIf the first player choose 1, the second player can only choose integers from 2 up to 10.\\nThe second player will win by choosing 10 and get a total = 11, which is >= desiredTotal.\\nSame with other integers chosen by the first player, the second player will always win. \\n\\n\\n\\nFirst Round : If player1 Choose 10 (can choose from 1-10) and Player2 choose 9  (can choose from 2 to 9)\\nSec Round : if Player1 choose 8 -- can reach the DesireTotal 11 (10+8) before player2 \\n\\nwhy answer is false ?"
                    },
                    {
                        "username": "dikshawali",
                        "content": "[@sawang325](/sawang325) what u mean by force a win?"
                    },
                    {
                        "username": "sawang325",
                        "content": "return true if the first player to move can force a win, otherwise, return false"
                    },
                    {
                        "username": "no-username",
                        "content": "same question"
                    },
                    {
                        "username": "ckim16",
                        "content": "can anybody help me understand the meaning of `play optimally`?"
                    },
                    {
                        "username": "just_kidding__03",
                        "content": "It could also be said as if they are able to predict the future and see the what present move would lead to and what optimal moves opponent would take . If in any one move the person is winning it will always choose that move only or maximize it\\'s winning chance."
                    },
                    {
                        "username": "uttarandas501",
                        "content": "Both will try to make a move that will increase their chances to win"
                    },
                    {
                        "username": "Merciless",
                        "content": "Most of the python solution got TLE on test case:\\n20\\n168"
                    },
                    {
                        "username": "respectmyauthoritah",
                        "content": "or it's impossible?"
                    }
                ]
            },
            {
                "id": 1571736,
                "content": [
                    {
                        "username": "elmubark",
                        "content": "This a hard question. I would be surprised if a canidate could come up with a solution to this in an interview without having seen this or a similar qustion in the past.\\n"
                    },
                    {
                        "username": "nyaruko",
                        "content": "FYI, there is a theorem in game theory (I quote it from wikipedia)\\n\"In game theory, Zermelo\\u2019s theorem, named after Ernst Zermelo, says that in any finite two-person game of perfect information in which the players move alternatingly and in which chance does not affect the decision making process, if the game cannot end in a draw, then one of the two players must have a winning strategy (i.e. force a win).\""
                    },
                    {
                        "username": "Petersburg",
                        "content": "this seems hard..."
                    },
                    {
                        "username": "QQBear",
                        "content": "Can anyone explain why (10,40) is false? thanks\\n\\nIf the first player choose 10,  the second player has (9, 30).\\nIf the second player chooses 1, the first has (2-9, 29), the first can win.\\nIf the second player chooses 9, the first has(8, 21), the first can win too."
                    },
                    {
                        "username": "Vishavjeet2710",
                        "content": "The key point to note here is, we only need to memorize the mask of the digits we have used till now.\\nWe do not need to memorize the desired sum, because the sum itself can be derived from the mask only.\\neg :\\nWe have maxChoosableIntger=5 , till now we have used 4 and 5 .\\nThus the mask we will have would be 11000 (We activate the bit that we have used).\\nThus the sum we have right now can be derived from the mask i.e. 4+5=9.\\nIn other words we can also say that for each mask we can have one unique sum only , so why should we save that unique sum in some other dimension.\\nThus we need only 1-D array."
                    },
                    {
                        "username": "2uringTested",
                        "content": "Wow great"
                    },
                    {
                        "username": "abheping",
                        "content": "Example test cases are trash"
                    },
                    {
                        "username": "kotak86",
                        "content": "maxChoosableInteger = 10\\ndesiredTotal = 11\\n\\nOutput:\\nfalse\\n\\nExplanation:\\nNo matter which integer the first player choose, the first player will lose.\\nThe first player can choose an integer from 1 up to 10.\\nIf the first player choose 1, the second player can only choose integers from 2 up to 10.\\nThe second player will win by choosing 10 and get a total = 11, which is >= desiredTotal.\\nSame with other integers chosen by the first player, the second player will always win. \\n\\n\\n\\nFirst Round : If player1 Choose 10 (can choose from 1-10) and Player2 choose 9  (can choose from 2 to 9)\\nSec Round : if Player1 choose 8 -- can reach the DesireTotal 11 (10+8) before player2 \\n\\nwhy answer is false ?"
                    },
                    {
                        "username": "dikshawali",
                        "content": "[@sawang325](/sawang325) what u mean by force a win?"
                    },
                    {
                        "username": "sawang325",
                        "content": "return true if the first player to move can force a win, otherwise, return false"
                    },
                    {
                        "username": "no-username",
                        "content": "same question"
                    },
                    {
                        "username": "ckim16",
                        "content": "can anybody help me understand the meaning of `play optimally`?"
                    },
                    {
                        "username": "just_kidding__03",
                        "content": "It could also be said as if they are able to predict the future and see the what present move would lead to and what optimal moves opponent would take . If in any one move the person is winning it will always choose that move only or maximize it\\'s winning chance."
                    },
                    {
                        "username": "uttarandas501",
                        "content": "Both will try to make a move that will increase their chances to win"
                    },
                    {
                        "username": "Merciless",
                        "content": "Most of the python solution got TLE on test case:\\n20\\n168"
                    },
                    {
                        "username": "respectmyauthoritah",
                        "content": "or it's impossible?"
                    }
                ]
            },
            {
                "id": 1565122,
                "content": [
                    {
                        "username": "elmubark",
                        "content": "This a hard question. I would be surprised if a canidate could come up with a solution to this in an interview without having seen this or a similar qustion in the past.\\n"
                    },
                    {
                        "username": "nyaruko",
                        "content": "FYI, there is a theorem in game theory (I quote it from wikipedia)\\n\"In game theory, Zermelo\\u2019s theorem, named after Ernst Zermelo, says that in any finite two-person game of perfect information in which the players move alternatingly and in which chance does not affect the decision making process, if the game cannot end in a draw, then one of the two players must have a winning strategy (i.e. force a win).\""
                    },
                    {
                        "username": "Petersburg",
                        "content": "this seems hard..."
                    },
                    {
                        "username": "QQBear",
                        "content": "Can anyone explain why (10,40) is false? thanks\\n\\nIf the first player choose 10,  the second player has (9, 30).\\nIf the second player chooses 1, the first has (2-9, 29), the first can win.\\nIf the second player chooses 9, the first has(8, 21), the first can win too."
                    },
                    {
                        "username": "Vishavjeet2710",
                        "content": "The key point to note here is, we only need to memorize the mask of the digits we have used till now.\\nWe do not need to memorize the desired sum, because the sum itself can be derived from the mask only.\\neg :\\nWe have maxChoosableIntger=5 , till now we have used 4 and 5 .\\nThus the mask we will have would be 11000 (We activate the bit that we have used).\\nThus the sum we have right now can be derived from the mask i.e. 4+5=9.\\nIn other words we can also say that for each mask we can have one unique sum only , so why should we save that unique sum in some other dimension.\\nThus we need only 1-D array."
                    },
                    {
                        "username": "2uringTested",
                        "content": "Wow great"
                    },
                    {
                        "username": "abheping",
                        "content": "Example test cases are trash"
                    },
                    {
                        "username": "kotak86",
                        "content": "maxChoosableInteger = 10\\ndesiredTotal = 11\\n\\nOutput:\\nfalse\\n\\nExplanation:\\nNo matter which integer the first player choose, the first player will lose.\\nThe first player can choose an integer from 1 up to 10.\\nIf the first player choose 1, the second player can only choose integers from 2 up to 10.\\nThe second player will win by choosing 10 and get a total = 11, which is >= desiredTotal.\\nSame with other integers chosen by the first player, the second player will always win. \\n\\n\\n\\nFirst Round : If player1 Choose 10 (can choose from 1-10) and Player2 choose 9  (can choose from 2 to 9)\\nSec Round : if Player1 choose 8 -- can reach the DesireTotal 11 (10+8) before player2 \\n\\nwhy answer is false ?"
                    },
                    {
                        "username": "dikshawali",
                        "content": "[@sawang325](/sawang325) what u mean by force a win?"
                    },
                    {
                        "username": "sawang325",
                        "content": "return true if the first player to move can force a win, otherwise, return false"
                    },
                    {
                        "username": "no-username",
                        "content": "same question"
                    },
                    {
                        "username": "ckim16",
                        "content": "can anybody help me understand the meaning of `play optimally`?"
                    },
                    {
                        "username": "just_kidding__03",
                        "content": "It could also be said as if they are able to predict the future and see the what present move would lead to and what optimal moves opponent would take . If in any one move the person is winning it will always choose that move only or maximize it\\'s winning chance."
                    },
                    {
                        "username": "uttarandas501",
                        "content": "Both will try to make a move that will increase their chances to win"
                    },
                    {
                        "username": "Merciless",
                        "content": "Most of the python solution got TLE on test case:\\n20\\n168"
                    },
                    {
                        "username": "respectmyauthoritah",
                        "content": "or it's impossible?"
                    }
                ]
            },
            {
                "id": 1565682,
                "content": [
                    {
                        "username": "elmubark",
                        "content": "This a hard question. I would be surprised if a canidate could come up with a solution to this in an interview without having seen this or a similar qustion in the past.\\n"
                    },
                    {
                        "username": "nyaruko",
                        "content": "FYI, there is a theorem in game theory (I quote it from wikipedia)\\n\"In game theory, Zermelo\\u2019s theorem, named after Ernst Zermelo, says that in any finite two-person game of perfect information in which the players move alternatingly and in which chance does not affect the decision making process, if the game cannot end in a draw, then one of the two players must have a winning strategy (i.e. force a win).\""
                    },
                    {
                        "username": "Petersburg",
                        "content": "this seems hard..."
                    },
                    {
                        "username": "QQBear",
                        "content": "Can anyone explain why (10,40) is false? thanks\\n\\nIf the first player choose 10,  the second player has (9, 30).\\nIf the second player chooses 1, the first has (2-9, 29), the first can win.\\nIf the second player chooses 9, the first has(8, 21), the first can win too."
                    },
                    {
                        "username": "Vishavjeet2710",
                        "content": "The key point to note here is, we only need to memorize the mask of the digits we have used till now.\\nWe do not need to memorize the desired sum, because the sum itself can be derived from the mask only.\\neg :\\nWe have maxChoosableIntger=5 , till now we have used 4 and 5 .\\nThus the mask we will have would be 11000 (We activate the bit that we have used).\\nThus the sum we have right now can be derived from the mask i.e. 4+5=9.\\nIn other words we can also say that for each mask we can have one unique sum only , so why should we save that unique sum in some other dimension.\\nThus we need only 1-D array."
                    },
                    {
                        "username": "2uringTested",
                        "content": "Wow great"
                    },
                    {
                        "username": "abheping",
                        "content": "Example test cases are trash"
                    },
                    {
                        "username": "kotak86",
                        "content": "maxChoosableInteger = 10\\ndesiredTotal = 11\\n\\nOutput:\\nfalse\\n\\nExplanation:\\nNo matter which integer the first player choose, the first player will lose.\\nThe first player can choose an integer from 1 up to 10.\\nIf the first player choose 1, the second player can only choose integers from 2 up to 10.\\nThe second player will win by choosing 10 and get a total = 11, which is >= desiredTotal.\\nSame with other integers chosen by the first player, the second player will always win. \\n\\n\\n\\nFirst Round : If player1 Choose 10 (can choose from 1-10) and Player2 choose 9  (can choose from 2 to 9)\\nSec Round : if Player1 choose 8 -- can reach the DesireTotal 11 (10+8) before player2 \\n\\nwhy answer is false ?"
                    },
                    {
                        "username": "dikshawali",
                        "content": "[@sawang325](/sawang325) what u mean by force a win?"
                    },
                    {
                        "username": "sawang325",
                        "content": "return true if the first player to move can force a win, otherwise, return false"
                    },
                    {
                        "username": "no-username",
                        "content": "same question"
                    },
                    {
                        "username": "ckim16",
                        "content": "can anybody help me understand the meaning of `play optimally`?"
                    },
                    {
                        "username": "just_kidding__03",
                        "content": "It could also be said as if they are able to predict the future and see the what present move would lead to and what optimal moves opponent would take . If in any one move the person is winning it will always choose that move only or maximize it\\'s winning chance."
                    },
                    {
                        "username": "uttarandas501",
                        "content": "Both will try to make a move that will increase their chances to win"
                    },
                    {
                        "username": "Merciless",
                        "content": "Most of the python solution got TLE on test case:\\n20\\n168"
                    },
                    {
                        "username": "respectmyauthoritah",
                        "content": "or it's impossible?"
                    }
                ]
            },
            {
                "id": 1566135,
                "content": [
                    {
                        "username": "elmubark",
                        "content": "This a hard question. I would be surprised if a canidate could come up with a solution to this in an interview without having seen this or a similar qustion in the past.\\n"
                    },
                    {
                        "username": "nyaruko",
                        "content": "FYI, there is a theorem in game theory (I quote it from wikipedia)\\n\"In game theory, Zermelo\\u2019s theorem, named after Ernst Zermelo, says that in any finite two-person game of perfect information in which the players move alternatingly and in which chance does not affect the decision making process, if the game cannot end in a draw, then one of the two players must have a winning strategy (i.e. force a win).\""
                    },
                    {
                        "username": "Petersburg",
                        "content": "this seems hard..."
                    },
                    {
                        "username": "QQBear",
                        "content": "Can anyone explain why (10,40) is false? thanks\\n\\nIf the first player choose 10,  the second player has (9, 30).\\nIf the second player chooses 1, the first has (2-9, 29), the first can win.\\nIf the second player chooses 9, the first has(8, 21), the first can win too."
                    },
                    {
                        "username": "Vishavjeet2710",
                        "content": "The key point to note here is, we only need to memorize the mask of the digits we have used till now.\\nWe do not need to memorize the desired sum, because the sum itself can be derived from the mask only.\\neg :\\nWe have maxChoosableIntger=5 , till now we have used 4 and 5 .\\nThus the mask we will have would be 11000 (We activate the bit that we have used).\\nThus the sum we have right now can be derived from the mask i.e. 4+5=9.\\nIn other words we can also say that for each mask we can have one unique sum only , so why should we save that unique sum in some other dimension.\\nThus we need only 1-D array."
                    },
                    {
                        "username": "2uringTested",
                        "content": "Wow great"
                    },
                    {
                        "username": "abheping",
                        "content": "Example test cases are trash"
                    },
                    {
                        "username": "kotak86",
                        "content": "maxChoosableInteger = 10\\ndesiredTotal = 11\\n\\nOutput:\\nfalse\\n\\nExplanation:\\nNo matter which integer the first player choose, the first player will lose.\\nThe first player can choose an integer from 1 up to 10.\\nIf the first player choose 1, the second player can only choose integers from 2 up to 10.\\nThe second player will win by choosing 10 and get a total = 11, which is >= desiredTotal.\\nSame with other integers chosen by the first player, the second player will always win. \\n\\n\\n\\nFirst Round : If player1 Choose 10 (can choose from 1-10) and Player2 choose 9  (can choose from 2 to 9)\\nSec Round : if Player1 choose 8 -- can reach the DesireTotal 11 (10+8) before player2 \\n\\nwhy answer is false ?"
                    },
                    {
                        "username": "dikshawali",
                        "content": "[@sawang325](/sawang325) what u mean by force a win?"
                    },
                    {
                        "username": "sawang325",
                        "content": "return true if the first player to move can force a win, otherwise, return false"
                    },
                    {
                        "username": "no-username",
                        "content": "same question"
                    },
                    {
                        "username": "ckim16",
                        "content": "can anybody help me understand the meaning of `play optimally`?"
                    },
                    {
                        "username": "just_kidding__03",
                        "content": "It could also be said as if they are able to predict the future and see the what present move would lead to and what optimal moves opponent would take . If in any one move the person is winning it will always choose that move only or maximize it\\'s winning chance."
                    },
                    {
                        "username": "uttarandas501",
                        "content": "Both will try to make a move that will increase their chances to win"
                    },
                    {
                        "username": "Merciless",
                        "content": "Most of the python solution got TLE on test case:\\n20\\n168"
                    },
                    {
                        "username": "respectmyauthoritah",
                        "content": "or it's impossible?"
                    }
                ]
            },
            {
                "id": 1566512,
                "content": [
                    {
                        "username": "elmubark",
                        "content": "This a hard question. I would be surprised if a canidate could come up with a solution to this in an interview without having seen this or a similar qustion in the past.\\n"
                    },
                    {
                        "username": "nyaruko",
                        "content": "FYI, there is a theorem in game theory (I quote it from wikipedia)\\n\"In game theory, Zermelo\\u2019s theorem, named after Ernst Zermelo, says that in any finite two-person game of perfect information in which the players move alternatingly and in which chance does not affect the decision making process, if the game cannot end in a draw, then one of the two players must have a winning strategy (i.e. force a win).\""
                    },
                    {
                        "username": "Petersburg",
                        "content": "this seems hard..."
                    },
                    {
                        "username": "QQBear",
                        "content": "Can anyone explain why (10,40) is false? thanks\\n\\nIf the first player choose 10,  the second player has (9, 30).\\nIf the second player chooses 1, the first has (2-9, 29), the first can win.\\nIf the second player chooses 9, the first has(8, 21), the first can win too."
                    },
                    {
                        "username": "Vishavjeet2710",
                        "content": "The key point to note here is, we only need to memorize the mask of the digits we have used till now.\\nWe do not need to memorize the desired sum, because the sum itself can be derived from the mask only.\\neg :\\nWe have maxChoosableIntger=5 , till now we have used 4 and 5 .\\nThus the mask we will have would be 11000 (We activate the bit that we have used).\\nThus the sum we have right now can be derived from the mask i.e. 4+5=9.\\nIn other words we can also say that for each mask we can have one unique sum only , so why should we save that unique sum in some other dimension.\\nThus we need only 1-D array."
                    },
                    {
                        "username": "2uringTested",
                        "content": "Wow great"
                    },
                    {
                        "username": "abheping",
                        "content": "Example test cases are trash"
                    },
                    {
                        "username": "kotak86",
                        "content": "maxChoosableInteger = 10\\ndesiredTotal = 11\\n\\nOutput:\\nfalse\\n\\nExplanation:\\nNo matter which integer the first player choose, the first player will lose.\\nThe first player can choose an integer from 1 up to 10.\\nIf the first player choose 1, the second player can only choose integers from 2 up to 10.\\nThe second player will win by choosing 10 and get a total = 11, which is >= desiredTotal.\\nSame with other integers chosen by the first player, the second player will always win. \\n\\n\\n\\nFirst Round : If player1 Choose 10 (can choose from 1-10) and Player2 choose 9  (can choose from 2 to 9)\\nSec Round : if Player1 choose 8 -- can reach the DesireTotal 11 (10+8) before player2 \\n\\nwhy answer is false ?"
                    },
                    {
                        "username": "dikshawali",
                        "content": "[@sawang325](/sawang325) what u mean by force a win?"
                    },
                    {
                        "username": "sawang325",
                        "content": "return true if the first player to move can force a win, otherwise, return false"
                    },
                    {
                        "username": "no-username",
                        "content": "same question"
                    },
                    {
                        "username": "ckim16",
                        "content": "can anybody help me understand the meaning of `play optimally`?"
                    },
                    {
                        "username": "just_kidding__03",
                        "content": "It could also be said as if they are able to predict the future and see the what present move would lead to and what optimal moves opponent would take . If in any one move the person is winning it will always choose that move only or maximize it\\'s winning chance."
                    },
                    {
                        "username": "uttarandas501",
                        "content": "Both will try to make a move that will increase their chances to win"
                    },
                    {
                        "username": "Merciless",
                        "content": "Most of the python solution got TLE on test case:\\n20\\n168"
                    },
                    {
                        "username": "respectmyauthoritah",
                        "content": "or it's impossible?"
                    }
                ]
            },
            {
                "id": 1568683,
                "content": [
                    {
                        "username": "elmubark",
                        "content": "This a hard question. I would be surprised if a canidate could come up with a solution to this in an interview without having seen this or a similar qustion in the past.\\n"
                    },
                    {
                        "username": "nyaruko",
                        "content": "FYI, there is a theorem in game theory (I quote it from wikipedia)\\n\"In game theory, Zermelo\\u2019s theorem, named after Ernst Zermelo, says that in any finite two-person game of perfect information in which the players move alternatingly and in which chance does not affect the decision making process, if the game cannot end in a draw, then one of the two players must have a winning strategy (i.e. force a win).\""
                    },
                    {
                        "username": "Petersburg",
                        "content": "this seems hard..."
                    },
                    {
                        "username": "QQBear",
                        "content": "Can anyone explain why (10,40) is false? thanks\\n\\nIf the first player choose 10,  the second player has (9, 30).\\nIf the second player chooses 1, the first has (2-9, 29), the first can win.\\nIf the second player chooses 9, the first has(8, 21), the first can win too."
                    },
                    {
                        "username": "Vishavjeet2710",
                        "content": "The key point to note here is, we only need to memorize the mask of the digits we have used till now.\\nWe do not need to memorize the desired sum, because the sum itself can be derived from the mask only.\\neg :\\nWe have maxChoosableIntger=5 , till now we have used 4 and 5 .\\nThus the mask we will have would be 11000 (We activate the bit that we have used).\\nThus the sum we have right now can be derived from the mask i.e. 4+5=9.\\nIn other words we can also say that for each mask we can have one unique sum only , so why should we save that unique sum in some other dimension.\\nThus we need only 1-D array."
                    },
                    {
                        "username": "2uringTested",
                        "content": "Wow great"
                    },
                    {
                        "username": "abheping",
                        "content": "Example test cases are trash"
                    },
                    {
                        "username": "kotak86",
                        "content": "maxChoosableInteger = 10\\ndesiredTotal = 11\\n\\nOutput:\\nfalse\\n\\nExplanation:\\nNo matter which integer the first player choose, the first player will lose.\\nThe first player can choose an integer from 1 up to 10.\\nIf the first player choose 1, the second player can only choose integers from 2 up to 10.\\nThe second player will win by choosing 10 and get a total = 11, which is >= desiredTotal.\\nSame with other integers chosen by the first player, the second player will always win. \\n\\n\\n\\nFirst Round : If player1 Choose 10 (can choose from 1-10) and Player2 choose 9  (can choose from 2 to 9)\\nSec Round : if Player1 choose 8 -- can reach the DesireTotal 11 (10+8) before player2 \\n\\nwhy answer is false ?"
                    },
                    {
                        "username": "dikshawali",
                        "content": "[@sawang325](/sawang325) what u mean by force a win?"
                    },
                    {
                        "username": "sawang325",
                        "content": "return true if the first player to move can force a win, otherwise, return false"
                    },
                    {
                        "username": "no-username",
                        "content": "same question"
                    },
                    {
                        "username": "ckim16",
                        "content": "can anybody help me understand the meaning of `play optimally`?"
                    },
                    {
                        "username": "just_kidding__03",
                        "content": "It could also be said as if they are able to predict the future and see the what present move would lead to and what optimal moves opponent would take . If in any one move the person is winning it will always choose that move only or maximize it\\'s winning chance."
                    },
                    {
                        "username": "uttarandas501",
                        "content": "Both will try to make a move that will increase their chances to win"
                    },
                    {
                        "username": "Merciless",
                        "content": "Most of the python solution got TLE on test case:\\n20\\n168"
                    },
                    {
                        "username": "respectmyauthoritah",
                        "content": "or it's impossible?"
                    }
                ]
            },
            {
                "id": 1989640,
                "content": [
                    {
                        "username": "elmubark",
                        "content": "This a hard question. I would be surprised if a canidate could come up with a solution to this in an interview without having seen this or a similar qustion in the past.\\n"
                    },
                    {
                        "username": "nyaruko",
                        "content": "FYI, there is a theorem in game theory (I quote it from wikipedia)\\n\"In game theory, Zermelo\\u2019s theorem, named after Ernst Zermelo, says that in any finite two-person game of perfect information in which the players move alternatingly and in which chance does not affect the decision making process, if the game cannot end in a draw, then one of the two players must have a winning strategy (i.e. force a win).\""
                    },
                    {
                        "username": "Petersburg",
                        "content": "this seems hard..."
                    },
                    {
                        "username": "QQBear",
                        "content": "Can anyone explain why (10,40) is false? thanks\\n\\nIf the first player choose 10,  the second player has (9, 30).\\nIf the second player chooses 1, the first has (2-9, 29), the first can win.\\nIf the second player chooses 9, the first has(8, 21), the first can win too."
                    },
                    {
                        "username": "Vishavjeet2710",
                        "content": "The key point to note here is, we only need to memorize the mask of the digits we have used till now.\\nWe do not need to memorize the desired sum, because the sum itself can be derived from the mask only.\\neg :\\nWe have maxChoosableIntger=5 , till now we have used 4 and 5 .\\nThus the mask we will have would be 11000 (We activate the bit that we have used).\\nThus the sum we have right now can be derived from the mask i.e. 4+5=9.\\nIn other words we can also say that for each mask we can have one unique sum only , so why should we save that unique sum in some other dimension.\\nThus we need only 1-D array."
                    },
                    {
                        "username": "2uringTested",
                        "content": "Wow great"
                    },
                    {
                        "username": "abheping",
                        "content": "Example test cases are trash"
                    },
                    {
                        "username": "kotak86",
                        "content": "maxChoosableInteger = 10\\ndesiredTotal = 11\\n\\nOutput:\\nfalse\\n\\nExplanation:\\nNo matter which integer the first player choose, the first player will lose.\\nThe first player can choose an integer from 1 up to 10.\\nIf the first player choose 1, the second player can only choose integers from 2 up to 10.\\nThe second player will win by choosing 10 and get a total = 11, which is >= desiredTotal.\\nSame with other integers chosen by the first player, the second player will always win. \\n\\n\\n\\nFirst Round : If player1 Choose 10 (can choose from 1-10) and Player2 choose 9  (can choose from 2 to 9)\\nSec Round : if Player1 choose 8 -- can reach the DesireTotal 11 (10+8) before player2 \\n\\nwhy answer is false ?"
                    },
                    {
                        "username": "dikshawali",
                        "content": "[@sawang325](/sawang325) what u mean by force a win?"
                    },
                    {
                        "username": "sawang325",
                        "content": "return true if the first player to move can force a win, otherwise, return false"
                    },
                    {
                        "username": "no-username",
                        "content": "same question"
                    },
                    {
                        "username": "ckim16",
                        "content": "can anybody help me understand the meaning of `play optimally`?"
                    },
                    {
                        "username": "just_kidding__03",
                        "content": "It could also be said as if they are able to predict the future and see the what present move would lead to and what optimal moves opponent would take . If in any one move the person is winning it will always choose that move only or maximize it\\'s winning chance."
                    },
                    {
                        "username": "uttarandas501",
                        "content": "Both will try to make a move that will increase their chances to win"
                    },
                    {
                        "username": "Merciless",
                        "content": "Most of the python solution got TLE on test case:\\n20\\n168"
                    },
                    {
                        "username": "respectmyauthoritah",
                        "content": "or it's impossible?"
                    }
                ]
            },
            {
                "id": 1569466,
                "content": [
                    {
                        "username": "elmubark",
                        "content": "This a hard question. I would be surprised if a canidate could come up with a solution to this in an interview without having seen this or a similar qustion in the past.\\n"
                    },
                    {
                        "username": "nyaruko",
                        "content": "FYI, there is a theorem in game theory (I quote it from wikipedia)\\n\"In game theory, Zermelo\\u2019s theorem, named after Ernst Zermelo, says that in any finite two-person game of perfect information in which the players move alternatingly and in which chance does not affect the decision making process, if the game cannot end in a draw, then one of the two players must have a winning strategy (i.e. force a win).\""
                    },
                    {
                        "username": "Petersburg",
                        "content": "this seems hard..."
                    },
                    {
                        "username": "QQBear",
                        "content": "Can anyone explain why (10,40) is false? thanks\\n\\nIf the first player choose 10,  the second player has (9, 30).\\nIf the second player chooses 1, the first has (2-9, 29), the first can win.\\nIf the second player chooses 9, the first has(8, 21), the first can win too."
                    },
                    {
                        "username": "Vishavjeet2710",
                        "content": "The key point to note here is, we only need to memorize the mask of the digits we have used till now.\\nWe do not need to memorize the desired sum, because the sum itself can be derived from the mask only.\\neg :\\nWe have maxChoosableIntger=5 , till now we have used 4 and 5 .\\nThus the mask we will have would be 11000 (We activate the bit that we have used).\\nThus the sum we have right now can be derived from the mask i.e. 4+5=9.\\nIn other words we can also say that for each mask we can have one unique sum only , so why should we save that unique sum in some other dimension.\\nThus we need only 1-D array."
                    },
                    {
                        "username": "2uringTested",
                        "content": "Wow great"
                    },
                    {
                        "username": "abheping",
                        "content": "Example test cases are trash"
                    },
                    {
                        "username": "kotak86",
                        "content": "maxChoosableInteger = 10\\ndesiredTotal = 11\\n\\nOutput:\\nfalse\\n\\nExplanation:\\nNo matter which integer the first player choose, the first player will lose.\\nThe first player can choose an integer from 1 up to 10.\\nIf the first player choose 1, the second player can only choose integers from 2 up to 10.\\nThe second player will win by choosing 10 and get a total = 11, which is >= desiredTotal.\\nSame with other integers chosen by the first player, the second player will always win. \\n\\n\\n\\nFirst Round : If player1 Choose 10 (can choose from 1-10) and Player2 choose 9  (can choose from 2 to 9)\\nSec Round : if Player1 choose 8 -- can reach the DesireTotal 11 (10+8) before player2 \\n\\nwhy answer is false ?"
                    },
                    {
                        "username": "dikshawali",
                        "content": "[@sawang325](/sawang325) what u mean by force a win?"
                    },
                    {
                        "username": "sawang325",
                        "content": "return true if the first player to move can force a win, otherwise, return false"
                    },
                    {
                        "username": "no-username",
                        "content": "same question"
                    },
                    {
                        "username": "ckim16",
                        "content": "can anybody help me understand the meaning of `play optimally`?"
                    },
                    {
                        "username": "just_kidding__03",
                        "content": "It could also be said as if they are able to predict the future and see the what present move would lead to and what optimal moves opponent would take . If in any one move the person is winning it will always choose that move only or maximize it\\'s winning chance."
                    },
                    {
                        "username": "uttarandas501",
                        "content": "Both will try to make a move that will increase their chances to win"
                    },
                    {
                        "username": "Merciless",
                        "content": "Most of the python solution got TLE on test case:\\n20\\n168"
                    },
                    {
                        "username": "respectmyauthoritah",
                        "content": "or it's impossible?"
                    }
                ]
            },
            {
                "id": 1708684,
                "content": [
                    {
                        "username": "elmubark",
                        "content": "This a hard question. I would be surprised if a canidate could come up with a solution to this in an interview without having seen this or a similar qustion in the past.\\n"
                    },
                    {
                        "username": "nyaruko",
                        "content": "FYI, there is a theorem in game theory (I quote it from wikipedia)\\n\"In game theory, Zermelo\\u2019s theorem, named after Ernst Zermelo, says that in any finite two-person game of perfect information in which the players move alternatingly and in which chance does not affect the decision making process, if the game cannot end in a draw, then one of the two players must have a winning strategy (i.e. force a win).\""
                    },
                    {
                        "username": "Petersburg",
                        "content": "this seems hard..."
                    },
                    {
                        "username": "QQBear",
                        "content": "Can anyone explain why (10,40) is false? thanks\\n\\nIf the first player choose 10,  the second player has (9, 30).\\nIf the second player chooses 1, the first has (2-9, 29), the first can win.\\nIf the second player chooses 9, the first has(8, 21), the first can win too."
                    },
                    {
                        "username": "Vishavjeet2710",
                        "content": "The key point to note here is, we only need to memorize the mask of the digits we have used till now.\\nWe do not need to memorize the desired sum, because the sum itself can be derived from the mask only.\\neg :\\nWe have maxChoosableIntger=5 , till now we have used 4 and 5 .\\nThus the mask we will have would be 11000 (We activate the bit that we have used).\\nThus the sum we have right now can be derived from the mask i.e. 4+5=9.\\nIn other words we can also say that for each mask we can have one unique sum only , so why should we save that unique sum in some other dimension.\\nThus we need only 1-D array."
                    },
                    {
                        "username": "2uringTested",
                        "content": "Wow great"
                    },
                    {
                        "username": "abheping",
                        "content": "Example test cases are trash"
                    },
                    {
                        "username": "kotak86",
                        "content": "maxChoosableInteger = 10\\ndesiredTotal = 11\\n\\nOutput:\\nfalse\\n\\nExplanation:\\nNo matter which integer the first player choose, the first player will lose.\\nThe first player can choose an integer from 1 up to 10.\\nIf the first player choose 1, the second player can only choose integers from 2 up to 10.\\nThe second player will win by choosing 10 and get a total = 11, which is >= desiredTotal.\\nSame with other integers chosen by the first player, the second player will always win. \\n\\n\\n\\nFirst Round : If player1 Choose 10 (can choose from 1-10) and Player2 choose 9  (can choose from 2 to 9)\\nSec Round : if Player1 choose 8 -- can reach the DesireTotal 11 (10+8) before player2 \\n\\nwhy answer is false ?"
                    },
                    {
                        "username": "dikshawali",
                        "content": "[@sawang325](/sawang325) what u mean by force a win?"
                    },
                    {
                        "username": "sawang325",
                        "content": "return true if the first player to move can force a win, otherwise, return false"
                    },
                    {
                        "username": "no-username",
                        "content": "same question"
                    },
                    {
                        "username": "ckim16",
                        "content": "can anybody help me understand the meaning of `play optimally`?"
                    },
                    {
                        "username": "just_kidding__03",
                        "content": "It could also be said as if they are able to predict the future and see the what present move would lead to and what optimal moves opponent would take . If in any one move the person is winning it will always choose that move only or maximize it\\'s winning chance."
                    },
                    {
                        "username": "uttarandas501",
                        "content": "Both will try to make a move that will increase their chances to win"
                    },
                    {
                        "username": "Merciless",
                        "content": "Most of the python solution got TLE on test case:\\n20\\n168"
                    },
                    {
                        "username": "respectmyauthoritah",
                        "content": "or it's impossible?"
                    }
                ]
            },
            {
                "id": 1569513,
                "content": [
                    {
                        "username": "elmubark",
                        "content": "This a hard question. I would be surprised if a canidate could come up with a solution to this in an interview without having seen this or a similar qustion in the past.\\n"
                    },
                    {
                        "username": "nyaruko",
                        "content": "FYI, there is a theorem in game theory (I quote it from wikipedia)\\n\"In game theory, Zermelo\\u2019s theorem, named after Ernst Zermelo, says that in any finite two-person game of perfect information in which the players move alternatingly and in which chance does not affect the decision making process, if the game cannot end in a draw, then one of the two players must have a winning strategy (i.e. force a win).\""
                    },
                    {
                        "username": "Petersburg",
                        "content": "this seems hard..."
                    },
                    {
                        "username": "QQBear",
                        "content": "Can anyone explain why (10,40) is false? thanks\\n\\nIf the first player choose 10,  the second player has (9, 30).\\nIf the second player chooses 1, the first has (2-9, 29), the first can win.\\nIf the second player chooses 9, the first has(8, 21), the first can win too."
                    },
                    {
                        "username": "Vishavjeet2710",
                        "content": "The key point to note here is, we only need to memorize the mask of the digits we have used till now.\\nWe do not need to memorize the desired sum, because the sum itself can be derived from the mask only.\\neg :\\nWe have maxChoosableIntger=5 , till now we have used 4 and 5 .\\nThus the mask we will have would be 11000 (We activate the bit that we have used).\\nThus the sum we have right now can be derived from the mask i.e. 4+5=9.\\nIn other words we can also say that for each mask we can have one unique sum only , so why should we save that unique sum in some other dimension.\\nThus we need only 1-D array."
                    },
                    {
                        "username": "2uringTested",
                        "content": "Wow great"
                    },
                    {
                        "username": "abheping",
                        "content": "Example test cases are trash"
                    },
                    {
                        "username": "kotak86",
                        "content": "maxChoosableInteger = 10\\ndesiredTotal = 11\\n\\nOutput:\\nfalse\\n\\nExplanation:\\nNo matter which integer the first player choose, the first player will lose.\\nThe first player can choose an integer from 1 up to 10.\\nIf the first player choose 1, the second player can only choose integers from 2 up to 10.\\nThe second player will win by choosing 10 and get a total = 11, which is >= desiredTotal.\\nSame with other integers chosen by the first player, the second player will always win. \\n\\n\\n\\nFirst Round : If player1 Choose 10 (can choose from 1-10) and Player2 choose 9  (can choose from 2 to 9)\\nSec Round : if Player1 choose 8 -- can reach the DesireTotal 11 (10+8) before player2 \\n\\nwhy answer is false ?"
                    },
                    {
                        "username": "dikshawali",
                        "content": "[@sawang325](/sawang325) what u mean by force a win?"
                    },
                    {
                        "username": "sawang325",
                        "content": "return true if the first player to move can force a win, otherwise, return false"
                    },
                    {
                        "username": "no-username",
                        "content": "same question"
                    },
                    {
                        "username": "ckim16",
                        "content": "can anybody help me understand the meaning of `play optimally`?"
                    },
                    {
                        "username": "just_kidding__03",
                        "content": "It could also be said as if they are able to predict the future and see the what present move would lead to and what optimal moves opponent would take . If in any one move the person is winning it will always choose that move only or maximize it\\'s winning chance."
                    },
                    {
                        "username": "uttarandas501",
                        "content": "Both will try to make a move that will increase their chances to win"
                    },
                    {
                        "username": "Merciless",
                        "content": "Most of the python solution got TLE on test case:\\n20\\n168"
                    },
                    {
                        "username": "respectmyauthoritah",
                        "content": "or it's impossible?"
                    }
                ]
            },
            {
                "id": 1571736,
                "content": [
                    {
                        "username": "elmubark",
                        "content": "This a hard question. I would be surprised if a canidate could come up with a solution to this in an interview without having seen this or a similar qustion in the past.\\n"
                    },
                    {
                        "username": "nyaruko",
                        "content": "FYI, there is a theorem in game theory (I quote it from wikipedia)\\n\"In game theory, Zermelo\\u2019s theorem, named after Ernst Zermelo, says that in any finite two-person game of perfect information in which the players move alternatingly and in which chance does not affect the decision making process, if the game cannot end in a draw, then one of the two players must have a winning strategy (i.e. force a win).\""
                    },
                    {
                        "username": "Petersburg",
                        "content": "this seems hard..."
                    },
                    {
                        "username": "QQBear",
                        "content": "Can anyone explain why (10,40) is false? thanks\\n\\nIf the first player choose 10,  the second player has (9, 30).\\nIf the second player chooses 1, the first has (2-9, 29), the first can win.\\nIf the second player chooses 9, the first has(8, 21), the first can win too."
                    },
                    {
                        "username": "Vishavjeet2710",
                        "content": "The key point to note here is, we only need to memorize the mask of the digits we have used till now.\\nWe do not need to memorize the desired sum, because the sum itself can be derived from the mask only.\\neg :\\nWe have maxChoosableIntger=5 , till now we have used 4 and 5 .\\nThus the mask we will have would be 11000 (We activate the bit that we have used).\\nThus the sum we have right now can be derived from the mask i.e. 4+5=9.\\nIn other words we can also say that for each mask we can have one unique sum only , so why should we save that unique sum in some other dimension.\\nThus we need only 1-D array."
                    },
                    {
                        "username": "2uringTested",
                        "content": "Wow great"
                    },
                    {
                        "username": "abheping",
                        "content": "Example test cases are trash"
                    },
                    {
                        "username": "kotak86",
                        "content": "maxChoosableInteger = 10\\ndesiredTotal = 11\\n\\nOutput:\\nfalse\\n\\nExplanation:\\nNo matter which integer the first player choose, the first player will lose.\\nThe first player can choose an integer from 1 up to 10.\\nIf the first player choose 1, the second player can only choose integers from 2 up to 10.\\nThe second player will win by choosing 10 and get a total = 11, which is >= desiredTotal.\\nSame with other integers chosen by the first player, the second player will always win. \\n\\n\\n\\nFirst Round : If player1 Choose 10 (can choose from 1-10) and Player2 choose 9  (can choose from 2 to 9)\\nSec Round : if Player1 choose 8 -- can reach the DesireTotal 11 (10+8) before player2 \\n\\nwhy answer is false ?"
                    },
                    {
                        "username": "dikshawali",
                        "content": "[@sawang325](/sawang325) what u mean by force a win?"
                    },
                    {
                        "username": "sawang325",
                        "content": "return true if the first player to move can force a win, otherwise, return false"
                    },
                    {
                        "username": "no-username",
                        "content": "same question"
                    },
                    {
                        "username": "ckim16",
                        "content": "can anybody help me understand the meaning of `play optimally`?"
                    },
                    {
                        "username": "just_kidding__03",
                        "content": "It could also be said as if they are able to predict the future and see the what present move would lead to and what optimal moves opponent would take . If in any one move the person is winning it will always choose that move only or maximize it\\'s winning chance."
                    },
                    {
                        "username": "uttarandas501",
                        "content": "Both will try to make a move that will increase their chances to win"
                    },
                    {
                        "username": "Merciless",
                        "content": "Most of the python solution got TLE on test case:\\n20\\n168"
                    },
                    {
                        "username": "respectmyauthoritah",
                        "content": "or it's impossible?"
                    }
                ]
            },
            {
                "id": 1571737,
                "content": [
                    {
                        "username": "bettytuan0209@hotmail.com",
                        "content": "In all of the examples, the players either prefer the biggest or smallest number not picked. Can someone give an example where the player should pick one in the middle to win?\\n\\nThanks"
                    },
                    {
                        "username": "rotal",
                        "content": "Yes, you need pick some number from bottom to make the other play no matter which he pick will put you in the range of pick biggest number to win.\\nFor example\\n1-10  target=14\\nfirst player will pick 3.\\nthen no matter which number second player pick. even the smallest number 1. will make total to 4.\\nSo first player pick 10 to win the game.\\n\\nThe player who can make the target=biggest+smallest+1 will win the game.\\nIf he can\\'t find the number he will lose the game.\\n\\n\\n\\n"
                    },
                    {
                        "username": "heg816",
                        "content": "max = 10, desiredTotal = 16: Player must choose 5"
                    },
                    {
                        "username": "mochiball",
                        "content": "What is this question even asking lol"
                    },
                    {
                        "username": "ghazanferwahab2",
                        "content": "No way this is a Medium Level Question. It is definitely a Hard Question."
                    },
                    {
                        "username": "zzg_zzm",
                        "content": "To @administrators  \\nThere is an early termination case for this problem:\\n* `if (maxChosibleInteger*(maxChosibleInteger+1)/2 == desiredTotal) return maxChosibleInteger%2;`,\\n\\nwhich means if the sum of all values from initial pool happens to be `desiredTotal`, then apparently, the order to pick numbers is irrelevant to the outcome of the game. It is just whoever picks in the last value from the pool reaches `desiredTotal`. So the first player wins iff there is odd count of values initial in the pool.\\n\\nHowever, when I tested `return desiredTotal%2` instead of the correct `return maxChosibleInteger%2` in the condition above, OJ still accepted the code, which means OJ does not include such test cases when the condition is true, .\\n\\nTherefore, I suggest to add the following two test cases, where the sum condition holds and `maxChosibleInteger` and `desiredTotal` are different under `%2`:\\n*  `maxChosibleInteger = 19, desiredTotal = 190;`\\n*  `maxChosibleInteger = 18, desiredTotal = 171;`"
                    },
                    {
                        "username": "BOZACI",
                        "content": "class Solution {\\n        public boolean canIWin(int maxChoosableInteger, int desiredTotal) {\\n\\n               boolean win = true;\\n               int i =maxChoosableInteger%2;\\n\\n\\n\\n\\n\\n                //1<=maxChoosableInteger<=20\\n                //0<= desiredTotal <=300\\n\\n\\n\\n\\n\\n                while(maxChoosableInteger<=desiredTotal)\\n                {\\n\\n\\n                       \\n                        \\n                        desiredTotal = desiredTotal- maxChoosableInteger;\\n                        maxChoosableInteger--;\\n                }\\n                if( maxChoosableInteger%2 == i ){\\n                        win = true;\\n\\n                }\\n                else {\\n                        win = false;\\n                }\\n\\n       return win; }\\n}\\n/ it felt so true :)"
                    },
                    {
                        "username": "stbrumme",
                        "content": "Edge case found in the tests: if noone can win (sum of all numbers is less than desiredTotal) then return False => not obvious from the problem description"
                    },
                    {
                        "username": "roshangugale24",
                        "content": "Why can\\'t the first player choose 10 in the first chance itself?\\nIf he does so, then he can win the game."
                    },
                    {
                        "username": "roshangugale24",
                        "content": "[@uttarandas501](/uttarandas501) okay! I misunderstood the question earlier, now it\\'s clear. Thank you!"
                    },
                    {
                        "username": "uttarandas501",
                        "content": "the next player will chose any number (even 1) to win. We have to equate or exceed 11"
                    },
                    {
                        "username": "user4488fC",
                        "content": "Examples testcaes are useless , please improve it."
                    },
                    {
                        "username": "hritikp",
                        "content": "how i think in this type of questions\\n"
                    },
                    {
                        "username": "khushi3",
                        "content": "Did anybody tried game theory min max approach \n          \nif(turn == 1)  \n       res = res || helper(range, goal - (i + 1), visited_mask ^ bit, 0);\nelse \n       res = res && helper(range, goal - (i + 1), visited_mask ^ bit, 1);\n\n\nSomebody able to submit using this approach ?"
                    }
                ]
            },
            {
                "id": 1921833,
                "content": [
                    {
                        "username": "bettytuan0209@hotmail.com",
                        "content": "In all of the examples, the players either prefer the biggest or smallest number not picked. Can someone give an example where the player should pick one in the middle to win?\\n\\nThanks"
                    },
                    {
                        "username": "rotal",
                        "content": "Yes, you need pick some number from bottom to make the other play no matter which he pick will put you in the range of pick biggest number to win.\\nFor example\\n1-10  target=14\\nfirst player will pick 3.\\nthen no matter which number second player pick. even the smallest number 1. will make total to 4.\\nSo first player pick 10 to win the game.\\n\\nThe player who can make the target=biggest+smallest+1 will win the game.\\nIf he can\\'t find the number he will lose the game.\\n\\n\\n\\n"
                    },
                    {
                        "username": "heg816",
                        "content": "max = 10, desiredTotal = 16: Player must choose 5"
                    },
                    {
                        "username": "mochiball",
                        "content": "What is this question even asking lol"
                    },
                    {
                        "username": "ghazanferwahab2",
                        "content": "No way this is a Medium Level Question. It is definitely a Hard Question."
                    },
                    {
                        "username": "zzg_zzm",
                        "content": "To @administrators  \\nThere is an early termination case for this problem:\\n* `if (maxChosibleInteger*(maxChosibleInteger+1)/2 == desiredTotal) return maxChosibleInteger%2;`,\\n\\nwhich means if the sum of all values from initial pool happens to be `desiredTotal`, then apparently, the order to pick numbers is irrelevant to the outcome of the game. It is just whoever picks in the last value from the pool reaches `desiredTotal`. So the first player wins iff there is odd count of values initial in the pool.\\n\\nHowever, when I tested `return desiredTotal%2` instead of the correct `return maxChosibleInteger%2` in the condition above, OJ still accepted the code, which means OJ does not include such test cases when the condition is true, .\\n\\nTherefore, I suggest to add the following two test cases, where the sum condition holds and `maxChosibleInteger` and `desiredTotal` are different under `%2`:\\n*  `maxChosibleInteger = 19, desiredTotal = 190;`\\n*  `maxChosibleInteger = 18, desiredTotal = 171;`"
                    },
                    {
                        "username": "BOZACI",
                        "content": "class Solution {\\n        public boolean canIWin(int maxChoosableInteger, int desiredTotal) {\\n\\n               boolean win = true;\\n               int i =maxChoosableInteger%2;\\n\\n\\n\\n\\n\\n                //1<=maxChoosableInteger<=20\\n                //0<= desiredTotal <=300\\n\\n\\n\\n\\n\\n                while(maxChoosableInteger<=desiredTotal)\\n                {\\n\\n\\n                       \\n                        \\n                        desiredTotal = desiredTotal- maxChoosableInteger;\\n                        maxChoosableInteger--;\\n                }\\n                if( maxChoosableInteger%2 == i ){\\n                        win = true;\\n\\n                }\\n                else {\\n                        win = false;\\n                }\\n\\n       return win; }\\n}\\n/ it felt so true :)"
                    },
                    {
                        "username": "stbrumme",
                        "content": "Edge case found in the tests: if noone can win (sum of all numbers is less than desiredTotal) then return False => not obvious from the problem description"
                    },
                    {
                        "username": "roshangugale24",
                        "content": "Why can\\'t the first player choose 10 in the first chance itself?\\nIf he does so, then he can win the game."
                    },
                    {
                        "username": "roshangugale24",
                        "content": "[@uttarandas501](/uttarandas501) okay! I misunderstood the question earlier, now it\\'s clear. Thank you!"
                    },
                    {
                        "username": "uttarandas501",
                        "content": "the next player will chose any number (even 1) to win. We have to equate or exceed 11"
                    },
                    {
                        "username": "user4488fC",
                        "content": "Examples testcaes are useless , please improve it."
                    },
                    {
                        "username": "hritikp",
                        "content": "how i think in this type of questions\\n"
                    },
                    {
                        "username": "khushi3",
                        "content": "Did anybody tried game theory min max approach \n          \nif(turn == 1)  \n       res = res || helper(range, goal - (i + 1), visited_mask ^ bit, 0);\nelse \n       res = res && helper(range, goal - (i + 1), visited_mask ^ bit, 1);\n\n\nSomebody able to submit using this approach ?"
                    }
                ]
            },
            {
                "id": 1701852,
                "content": [
                    {
                        "username": "bettytuan0209@hotmail.com",
                        "content": "In all of the examples, the players either prefer the biggest or smallest number not picked. Can someone give an example where the player should pick one in the middle to win?\\n\\nThanks"
                    },
                    {
                        "username": "rotal",
                        "content": "Yes, you need pick some number from bottom to make the other play no matter which he pick will put you in the range of pick biggest number to win.\\nFor example\\n1-10  target=14\\nfirst player will pick 3.\\nthen no matter which number second player pick. even the smallest number 1. will make total to 4.\\nSo first player pick 10 to win the game.\\n\\nThe player who can make the target=biggest+smallest+1 will win the game.\\nIf he can\\'t find the number he will lose the game.\\n\\n\\n\\n"
                    },
                    {
                        "username": "heg816",
                        "content": "max = 10, desiredTotal = 16: Player must choose 5"
                    },
                    {
                        "username": "mochiball",
                        "content": "What is this question even asking lol"
                    },
                    {
                        "username": "ghazanferwahab2",
                        "content": "No way this is a Medium Level Question. It is definitely a Hard Question."
                    },
                    {
                        "username": "zzg_zzm",
                        "content": "To @administrators  \\nThere is an early termination case for this problem:\\n* `if (maxChosibleInteger*(maxChosibleInteger+1)/2 == desiredTotal) return maxChosibleInteger%2;`,\\n\\nwhich means if the sum of all values from initial pool happens to be `desiredTotal`, then apparently, the order to pick numbers is irrelevant to the outcome of the game. It is just whoever picks in the last value from the pool reaches `desiredTotal`. So the first player wins iff there is odd count of values initial in the pool.\\n\\nHowever, when I tested `return desiredTotal%2` instead of the correct `return maxChosibleInteger%2` in the condition above, OJ still accepted the code, which means OJ does not include such test cases when the condition is true, .\\n\\nTherefore, I suggest to add the following two test cases, where the sum condition holds and `maxChosibleInteger` and `desiredTotal` are different under `%2`:\\n*  `maxChosibleInteger = 19, desiredTotal = 190;`\\n*  `maxChosibleInteger = 18, desiredTotal = 171;`"
                    },
                    {
                        "username": "BOZACI",
                        "content": "class Solution {\\n        public boolean canIWin(int maxChoosableInteger, int desiredTotal) {\\n\\n               boolean win = true;\\n               int i =maxChoosableInteger%2;\\n\\n\\n\\n\\n\\n                //1<=maxChoosableInteger<=20\\n                //0<= desiredTotal <=300\\n\\n\\n\\n\\n\\n                while(maxChoosableInteger<=desiredTotal)\\n                {\\n\\n\\n                       \\n                        \\n                        desiredTotal = desiredTotal- maxChoosableInteger;\\n                        maxChoosableInteger--;\\n                }\\n                if( maxChoosableInteger%2 == i ){\\n                        win = true;\\n\\n                }\\n                else {\\n                        win = false;\\n                }\\n\\n       return win; }\\n}\\n/ it felt so true :)"
                    },
                    {
                        "username": "stbrumme",
                        "content": "Edge case found in the tests: if noone can win (sum of all numbers is less than desiredTotal) then return False => not obvious from the problem description"
                    },
                    {
                        "username": "roshangugale24",
                        "content": "Why can\\'t the first player choose 10 in the first chance itself?\\nIf he does so, then he can win the game."
                    },
                    {
                        "username": "roshangugale24",
                        "content": "[@uttarandas501](/uttarandas501) okay! I misunderstood the question earlier, now it\\'s clear. Thank you!"
                    },
                    {
                        "username": "uttarandas501",
                        "content": "the next player will chose any number (even 1) to win. We have to equate or exceed 11"
                    },
                    {
                        "username": "user4488fC",
                        "content": "Examples testcaes are useless , please improve it."
                    },
                    {
                        "username": "hritikp",
                        "content": "how i think in this type of questions\\n"
                    },
                    {
                        "username": "khushi3",
                        "content": "Did anybody tried game theory min max approach \n          \nif(turn == 1)  \n       res = res || helper(range, goal - (i + 1), visited_mask ^ bit, 0);\nelse \n       res = res && helper(range, goal - (i + 1), visited_mask ^ bit, 1);\n\n\nSomebody able to submit using this approach ?"
                    }
                ]
            },
            {
                "id": 1571738,
                "content": [
                    {
                        "username": "bettytuan0209@hotmail.com",
                        "content": "In all of the examples, the players either prefer the biggest or smallest number not picked. Can someone give an example where the player should pick one in the middle to win?\\n\\nThanks"
                    },
                    {
                        "username": "rotal",
                        "content": "Yes, you need pick some number from bottom to make the other play no matter which he pick will put you in the range of pick biggest number to win.\\nFor example\\n1-10  target=14\\nfirst player will pick 3.\\nthen no matter which number second player pick. even the smallest number 1. will make total to 4.\\nSo first player pick 10 to win the game.\\n\\nThe player who can make the target=biggest+smallest+1 will win the game.\\nIf he can\\'t find the number he will lose the game.\\n\\n\\n\\n"
                    },
                    {
                        "username": "heg816",
                        "content": "max = 10, desiredTotal = 16: Player must choose 5"
                    },
                    {
                        "username": "mochiball",
                        "content": "What is this question even asking lol"
                    },
                    {
                        "username": "ghazanferwahab2",
                        "content": "No way this is a Medium Level Question. It is definitely a Hard Question."
                    },
                    {
                        "username": "zzg_zzm",
                        "content": "To @administrators  \\nThere is an early termination case for this problem:\\n* `if (maxChosibleInteger*(maxChosibleInteger+1)/2 == desiredTotal) return maxChosibleInteger%2;`,\\n\\nwhich means if the sum of all values from initial pool happens to be `desiredTotal`, then apparently, the order to pick numbers is irrelevant to the outcome of the game. It is just whoever picks in the last value from the pool reaches `desiredTotal`. So the first player wins iff there is odd count of values initial in the pool.\\n\\nHowever, when I tested `return desiredTotal%2` instead of the correct `return maxChosibleInteger%2` in the condition above, OJ still accepted the code, which means OJ does not include such test cases when the condition is true, .\\n\\nTherefore, I suggest to add the following two test cases, where the sum condition holds and `maxChosibleInteger` and `desiredTotal` are different under `%2`:\\n*  `maxChosibleInteger = 19, desiredTotal = 190;`\\n*  `maxChosibleInteger = 18, desiredTotal = 171;`"
                    },
                    {
                        "username": "BOZACI",
                        "content": "class Solution {\\n        public boolean canIWin(int maxChoosableInteger, int desiredTotal) {\\n\\n               boolean win = true;\\n               int i =maxChoosableInteger%2;\\n\\n\\n\\n\\n\\n                //1<=maxChoosableInteger<=20\\n                //0<= desiredTotal <=300\\n\\n\\n\\n\\n\\n                while(maxChoosableInteger<=desiredTotal)\\n                {\\n\\n\\n                       \\n                        \\n                        desiredTotal = desiredTotal- maxChoosableInteger;\\n                        maxChoosableInteger--;\\n                }\\n                if( maxChoosableInteger%2 == i ){\\n                        win = true;\\n\\n                }\\n                else {\\n                        win = false;\\n                }\\n\\n       return win; }\\n}\\n/ it felt so true :)"
                    },
                    {
                        "username": "stbrumme",
                        "content": "Edge case found in the tests: if noone can win (sum of all numbers is less than desiredTotal) then return False => not obvious from the problem description"
                    },
                    {
                        "username": "roshangugale24",
                        "content": "Why can\\'t the first player choose 10 in the first chance itself?\\nIf he does so, then he can win the game."
                    },
                    {
                        "username": "roshangugale24",
                        "content": "[@uttarandas501](/uttarandas501) okay! I misunderstood the question earlier, now it\\'s clear. Thank you!"
                    },
                    {
                        "username": "uttarandas501",
                        "content": "the next player will chose any number (even 1) to win. We have to equate or exceed 11"
                    },
                    {
                        "username": "user4488fC",
                        "content": "Examples testcaes are useless , please improve it."
                    },
                    {
                        "username": "hritikp",
                        "content": "how i think in this type of questions\\n"
                    },
                    {
                        "username": "khushi3",
                        "content": "Did anybody tried game theory min max approach \n          \nif(turn == 1)  \n       res = res || helper(range, goal - (i + 1), visited_mask ^ bit, 0);\nelse \n       res = res && helper(range, goal - (i + 1), visited_mask ^ bit, 1);\n\n\nSomebody able to submit using this approach ?"
                    }
                ]
            },
            {
                "id": 1711696,
                "content": [
                    {
                        "username": "bettytuan0209@hotmail.com",
                        "content": "In all of the examples, the players either prefer the biggest or smallest number not picked. Can someone give an example where the player should pick one in the middle to win?\\n\\nThanks"
                    },
                    {
                        "username": "rotal",
                        "content": "Yes, you need pick some number from bottom to make the other play no matter which he pick will put you in the range of pick biggest number to win.\\nFor example\\n1-10  target=14\\nfirst player will pick 3.\\nthen no matter which number second player pick. even the smallest number 1. will make total to 4.\\nSo first player pick 10 to win the game.\\n\\nThe player who can make the target=biggest+smallest+1 will win the game.\\nIf he can\\'t find the number he will lose the game.\\n\\n\\n\\n"
                    },
                    {
                        "username": "heg816",
                        "content": "max = 10, desiredTotal = 16: Player must choose 5"
                    },
                    {
                        "username": "mochiball",
                        "content": "What is this question even asking lol"
                    },
                    {
                        "username": "ghazanferwahab2",
                        "content": "No way this is a Medium Level Question. It is definitely a Hard Question."
                    },
                    {
                        "username": "zzg_zzm",
                        "content": "To @administrators  \\nThere is an early termination case for this problem:\\n* `if (maxChosibleInteger*(maxChosibleInteger+1)/2 == desiredTotal) return maxChosibleInteger%2;`,\\n\\nwhich means if the sum of all values from initial pool happens to be `desiredTotal`, then apparently, the order to pick numbers is irrelevant to the outcome of the game. It is just whoever picks in the last value from the pool reaches `desiredTotal`. So the first player wins iff there is odd count of values initial in the pool.\\n\\nHowever, when I tested `return desiredTotal%2` instead of the correct `return maxChosibleInteger%2` in the condition above, OJ still accepted the code, which means OJ does not include such test cases when the condition is true, .\\n\\nTherefore, I suggest to add the following two test cases, where the sum condition holds and `maxChosibleInteger` and `desiredTotal` are different under `%2`:\\n*  `maxChosibleInteger = 19, desiredTotal = 190;`\\n*  `maxChosibleInteger = 18, desiredTotal = 171;`"
                    },
                    {
                        "username": "BOZACI",
                        "content": "class Solution {\\n        public boolean canIWin(int maxChoosableInteger, int desiredTotal) {\\n\\n               boolean win = true;\\n               int i =maxChoosableInteger%2;\\n\\n\\n\\n\\n\\n                //1<=maxChoosableInteger<=20\\n                //0<= desiredTotal <=300\\n\\n\\n\\n\\n\\n                while(maxChoosableInteger<=desiredTotal)\\n                {\\n\\n\\n                       \\n                        \\n                        desiredTotal = desiredTotal- maxChoosableInteger;\\n                        maxChoosableInteger--;\\n                }\\n                if( maxChoosableInteger%2 == i ){\\n                        win = true;\\n\\n                }\\n                else {\\n                        win = false;\\n                }\\n\\n       return win; }\\n}\\n/ it felt so true :)"
                    },
                    {
                        "username": "stbrumme",
                        "content": "Edge case found in the tests: if noone can win (sum of all numbers is less than desiredTotal) then return False => not obvious from the problem description"
                    },
                    {
                        "username": "roshangugale24",
                        "content": "Why can\\'t the first player choose 10 in the first chance itself?\\nIf he does so, then he can win the game."
                    },
                    {
                        "username": "roshangugale24",
                        "content": "[@uttarandas501](/uttarandas501) okay! I misunderstood the question earlier, now it\\'s clear. Thank you!"
                    },
                    {
                        "username": "uttarandas501",
                        "content": "the next player will chose any number (even 1) to win. We have to equate or exceed 11"
                    },
                    {
                        "username": "user4488fC",
                        "content": "Examples testcaes are useless , please improve it."
                    },
                    {
                        "username": "hritikp",
                        "content": "how i think in this type of questions\\n"
                    },
                    {
                        "username": "khushi3",
                        "content": "Did anybody tried game theory min max approach \n          \nif(turn == 1)  \n       res = res || helper(range, goal - (i + 1), visited_mask ^ bit, 0);\nelse \n       res = res && helper(range, goal - (i + 1), visited_mask ^ bit, 1);\n\n\nSomebody able to submit using this approach ?"
                    }
                ]
            },
            {
                "id": 2076775,
                "content": [
                    {
                        "username": "bettytuan0209@hotmail.com",
                        "content": "In all of the examples, the players either prefer the biggest or smallest number not picked. Can someone give an example where the player should pick one in the middle to win?\\n\\nThanks"
                    },
                    {
                        "username": "rotal",
                        "content": "Yes, you need pick some number from bottom to make the other play no matter which he pick will put you in the range of pick biggest number to win.\\nFor example\\n1-10  target=14\\nfirst player will pick 3.\\nthen no matter which number second player pick. even the smallest number 1. will make total to 4.\\nSo first player pick 10 to win the game.\\n\\nThe player who can make the target=biggest+smallest+1 will win the game.\\nIf he can\\'t find the number he will lose the game.\\n\\n\\n\\n"
                    },
                    {
                        "username": "heg816",
                        "content": "max = 10, desiredTotal = 16: Player must choose 5"
                    },
                    {
                        "username": "mochiball",
                        "content": "What is this question even asking lol"
                    },
                    {
                        "username": "ghazanferwahab2",
                        "content": "No way this is a Medium Level Question. It is definitely a Hard Question."
                    },
                    {
                        "username": "zzg_zzm",
                        "content": "To @administrators  \\nThere is an early termination case for this problem:\\n* `if (maxChosibleInteger*(maxChosibleInteger+1)/2 == desiredTotal) return maxChosibleInteger%2;`,\\n\\nwhich means if the sum of all values from initial pool happens to be `desiredTotal`, then apparently, the order to pick numbers is irrelevant to the outcome of the game. It is just whoever picks in the last value from the pool reaches `desiredTotal`. So the first player wins iff there is odd count of values initial in the pool.\\n\\nHowever, when I tested `return desiredTotal%2` instead of the correct `return maxChosibleInteger%2` in the condition above, OJ still accepted the code, which means OJ does not include such test cases when the condition is true, .\\n\\nTherefore, I suggest to add the following two test cases, where the sum condition holds and `maxChosibleInteger` and `desiredTotal` are different under `%2`:\\n*  `maxChosibleInteger = 19, desiredTotal = 190;`\\n*  `maxChosibleInteger = 18, desiredTotal = 171;`"
                    },
                    {
                        "username": "BOZACI",
                        "content": "class Solution {\\n        public boolean canIWin(int maxChoosableInteger, int desiredTotal) {\\n\\n               boolean win = true;\\n               int i =maxChoosableInteger%2;\\n\\n\\n\\n\\n\\n                //1<=maxChoosableInteger<=20\\n                //0<= desiredTotal <=300\\n\\n\\n\\n\\n\\n                while(maxChoosableInteger<=desiredTotal)\\n                {\\n\\n\\n                       \\n                        \\n                        desiredTotal = desiredTotal- maxChoosableInteger;\\n                        maxChoosableInteger--;\\n                }\\n                if( maxChoosableInteger%2 == i ){\\n                        win = true;\\n\\n                }\\n                else {\\n                        win = false;\\n                }\\n\\n       return win; }\\n}\\n/ it felt so true :)"
                    },
                    {
                        "username": "stbrumme",
                        "content": "Edge case found in the tests: if noone can win (sum of all numbers is less than desiredTotal) then return False => not obvious from the problem description"
                    },
                    {
                        "username": "roshangugale24",
                        "content": "Why can\\'t the first player choose 10 in the first chance itself?\\nIf he does so, then he can win the game."
                    },
                    {
                        "username": "roshangugale24",
                        "content": "[@uttarandas501](/uttarandas501) okay! I misunderstood the question earlier, now it\\'s clear. Thank you!"
                    },
                    {
                        "username": "uttarandas501",
                        "content": "the next player will chose any number (even 1) to win. We have to equate or exceed 11"
                    },
                    {
                        "username": "user4488fC",
                        "content": "Examples testcaes are useless , please improve it."
                    },
                    {
                        "username": "hritikp",
                        "content": "how i think in this type of questions\\n"
                    },
                    {
                        "username": "khushi3",
                        "content": "Did anybody tried game theory min max approach \n          \nif(turn == 1)  \n       res = res || helper(range, goal - (i + 1), visited_mask ^ bit, 0);\nelse \n       res = res && helper(range, goal - (i + 1), visited_mask ^ bit, 1);\n\n\nSomebody able to submit using this approach ?"
                    }
                ]
            },
            {
                "id": 2067997,
                "content": [
                    {
                        "username": "bettytuan0209@hotmail.com",
                        "content": "In all of the examples, the players either prefer the biggest or smallest number not picked. Can someone give an example where the player should pick one in the middle to win?\\n\\nThanks"
                    },
                    {
                        "username": "rotal",
                        "content": "Yes, you need pick some number from bottom to make the other play no matter which he pick will put you in the range of pick biggest number to win.\\nFor example\\n1-10  target=14\\nfirst player will pick 3.\\nthen no matter which number second player pick. even the smallest number 1. will make total to 4.\\nSo first player pick 10 to win the game.\\n\\nThe player who can make the target=biggest+smallest+1 will win the game.\\nIf he can\\'t find the number he will lose the game.\\n\\n\\n\\n"
                    },
                    {
                        "username": "heg816",
                        "content": "max = 10, desiredTotal = 16: Player must choose 5"
                    },
                    {
                        "username": "mochiball",
                        "content": "What is this question even asking lol"
                    },
                    {
                        "username": "ghazanferwahab2",
                        "content": "No way this is a Medium Level Question. It is definitely a Hard Question."
                    },
                    {
                        "username": "zzg_zzm",
                        "content": "To @administrators  \\nThere is an early termination case for this problem:\\n* `if (maxChosibleInteger*(maxChosibleInteger+1)/2 == desiredTotal) return maxChosibleInteger%2;`,\\n\\nwhich means if the sum of all values from initial pool happens to be `desiredTotal`, then apparently, the order to pick numbers is irrelevant to the outcome of the game. It is just whoever picks in the last value from the pool reaches `desiredTotal`. So the first player wins iff there is odd count of values initial in the pool.\\n\\nHowever, when I tested `return desiredTotal%2` instead of the correct `return maxChosibleInteger%2` in the condition above, OJ still accepted the code, which means OJ does not include such test cases when the condition is true, .\\n\\nTherefore, I suggest to add the following two test cases, where the sum condition holds and `maxChosibleInteger` and `desiredTotal` are different under `%2`:\\n*  `maxChosibleInteger = 19, desiredTotal = 190;`\\n*  `maxChosibleInteger = 18, desiredTotal = 171;`"
                    },
                    {
                        "username": "BOZACI",
                        "content": "class Solution {\\n        public boolean canIWin(int maxChoosableInteger, int desiredTotal) {\\n\\n               boolean win = true;\\n               int i =maxChoosableInteger%2;\\n\\n\\n\\n\\n\\n                //1<=maxChoosableInteger<=20\\n                //0<= desiredTotal <=300\\n\\n\\n\\n\\n\\n                while(maxChoosableInteger<=desiredTotal)\\n                {\\n\\n\\n                       \\n                        \\n                        desiredTotal = desiredTotal- maxChoosableInteger;\\n                        maxChoosableInteger--;\\n                }\\n                if( maxChoosableInteger%2 == i ){\\n                        win = true;\\n\\n                }\\n                else {\\n                        win = false;\\n                }\\n\\n       return win; }\\n}\\n/ it felt so true :)"
                    },
                    {
                        "username": "stbrumme",
                        "content": "Edge case found in the tests: if noone can win (sum of all numbers is less than desiredTotal) then return False => not obvious from the problem description"
                    },
                    {
                        "username": "roshangugale24",
                        "content": "Why can\\'t the first player choose 10 in the first chance itself?\\nIf he does so, then he can win the game."
                    },
                    {
                        "username": "roshangugale24",
                        "content": "[@uttarandas501](/uttarandas501) okay! I misunderstood the question earlier, now it\\'s clear. Thank you!"
                    },
                    {
                        "username": "uttarandas501",
                        "content": "the next player will chose any number (even 1) to win. We have to equate or exceed 11"
                    },
                    {
                        "username": "user4488fC",
                        "content": "Examples testcaes are useless , please improve it."
                    },
                    {
                        "username": "hritikp",
                        "content": "how i think in this type of questions\\n"
                    },
                    {
                        "username": "khushi3",
                        "content": "Did anybody tried game theory min max approach \n          \nif(turn == 1)  \n       res = res || helper(range, goal - (i + 1), visited_mask ^ bit, 0);\nelse \n       res = res && helper(range, goal - (i + 1), visited_mask ^ bit, 1);\n\n\nSomebody able to submit using this approach ?"
                    }
                ]
            },
            {
                "id": 2053635,
                "content": [
                    {
                        "username": "bettytuan0209@hotmail.com",
                        "content": "In all of the examples, the players either prefer the biggest or smallest number not picked. Can someone give an example where the player should pick one in the middle to win?\\n\\nThanks"
                    },
                    {
                        "username": "rotal",
                        "content": "Yes, you need pick some number from bottom to make the other play no matter which he pick will put you in the range of pick biggest number to win.\\nFor example\\n1-10  target=14\\nfirst player will pick 3.\\nthen no matter which number second player pick. even the smallest number 1. will make total to 4.\\nSo first player pick 10 to win the game.\\n\\nThe player who can make the target=biggest+smallest+1 will win the game.\\nIf he can\\'t find the number he will lose the game.\\n\\n\\n\\n"
                    },
                    {
                        "username": "heg816",
                        "content": "max = 10, desiredTotal = 16: Player must choose 5"
                    },
                    {
                        "username": "mochiball",
                        "content": "What is this question even asking lol"
                    },
                    {
                        "username": "ghazanferwahab2",
                        "content": "No way this is a Medium Level Question. It is definitely a Hard Question."
                    },
                    {
                        "username": "zzg_zzm",
                        "content": "To @administrators  \\nThere is an early termination case for this problem:\\n* `if (maxChosibleInteger*(maxChosibleInteger+1)/2 == desiredTotal) return maxChosibleInteger%2;`,\\n\\nwhich means if the sum of all values from initial pool happens to be `desiredTotal`, then apparently, the order to pick numbers is irrelevant to the outcome of the game. It is just whoever picks in the last value from the pool reaches `desiredTotal`. So the first player wins iff there is odd count of values initial in the pool.\\n\\nHowever, when I tested `return desiredTotal%2` instead of the correct `return maxChosibleInteger%2` in the condition above, OJ still accepted the code, which means OJ does not include such test cases when the condition is true, .\\n\\nTherefore, I suggest to add the following two test cases, where the sum condition holds and `maxChosibleInteger` and `desiredTotal` are different under `%2`:\\n*  `maxChosibleInteger = 19, desiredTotal = 190;`\\n*  `maxChosibleInteger = 18, desiredTotal = 171;`"
                    },
                    {
                        "username": "BOZACI",
                        "content": "class Solution {\\n        public boolean canIWin(int maxChoosableInteger, int desiredTotal) {\\n\\n               boolean win = true;\\n               int i =maxChoosableInteger%2;\\n\\n\\n\\n\\n\\n                //1<=maxChoosableInteger<=20\\n                //0<= desiredTotal <=300\\n\\n\\n\\n\\n\\n                while(maxChoosableInteger<=desiredTotal)\\n                {\\n\\n\\n                       \\n                        \\n                        desiredTotal = desiredTotal- maxChoosableInteger;\\n                        maxChoosableInteger--;\\n                }\\n                if( maxChoosableInteger%2 == i ){\\n                        win = true;\\n\\n                }\\n                else {\\n                        win = false;\\n                }\\n\\n       return win; }\\n}\\n/ it felt so true :)"
                    },
                    {
                        "username": "stbrumme",
                        "content": "Edge case found in the tests: if noone can win (sum of all numbers is less than desiredTotal) then return False => not obvious from the problem description"
                    },
                    {
                        "username": "roshangugale24",
                        "content": "Why can\\'t the first player choose 10 in the first chance itself?\\nIf he does so, then he can win the game."
                    },
                    {
                        "username": "roshangugale24",
                        "content": "[@uttarandas501](/uttarandas501) okay! I misunderstood the question earlier, now it\\'s clear. Thank you!"
                    },
                    {
                        "username": "uttarandas501",
                        "content": "the next player will chose any number (even 1) to win. We have to equate or exceed 11"
                    },
                    {
                        "username": "user4488fC",
                        "content": "Examples testcaes are useless , please improve it."
                    },
                    {
                        "username": "hritikp",
                        "content": "how i think in this type of questions\\n"
                    },
                    {
                        "username": "khushi3",
                        "content": "Did anybody tried game theory min max approach \n          \nif(turn == 1)  \n       res = res || helper(range, goal - (i + 1), visited_mask ^ bit, 0);\nelse \n       res = res && helper(range, goal - (i + 1), visited_mask ^ bit, 1);\n\n\nSomebody able to submit using this approach ?"
                    }
                ]
            },
            {
                "id": 2035704,
                "content": [
                    {
                        "username": "bettytuan0209@hotmail.com",
                        "content": "In all of the examples, the players either prefer the biggest or smallest number not picked. Can someone give an example where the player should pick one in the middle to win?\\n\\nThanks"
                    },
                    {
                        "username": "rotal",
                        "content": "Yes, you need pick some number from bottom to make the other play no matter which he pick will put you in the range of pick biggest number to win.\\nFor example\\n1-10  target=14\\nfirst player will pick 3.\\nthen no matter which number second player pick. even the smallest number 1. will make total to 4.\\nSo first player pick 10 to win the game.\\n\\nThe player who can make the target=biggest+smallest+1 will win the game.\\nIf he can\\'t find the number he will lose the game.\\n\\n\\n\\n"
                    },
                    {
                        "username": "heg816",
                        "content": "max = 10, desiredTotal = 16: Player must choose 5"
                    },
                    {
                        "username": "mochiball",
                        "content": "What is this question even asking lol"
                    },
                    {
                        "username": "ghazanferwahab2",
                        "content": "No way this is a Medium Level Question. It is definitely a Hard Question."
                    },
                    {
                        "username": "zzg_zzm",
                        "content": "To @administrators  \\nThere is an early termination case for this problem:\\n* `if (maxChosibleInteger*(maxChosibleInteger+1)/2 == desiredTotal) return maxChosibleInteger%2;`,\\n\\nwhich means if the sum of all values from initial pool happens to be `desiredTotal`, then apparently, the order to pick numbers is irrelevant to the outcome of the game. It is just whoever picks in the last value from the pool reaches `desiredTotal`. So the first player wins iff there is odd count of values initial in the pool.\\n\\nHowever, when I tested `return desiredTotal%2` instead of the correct `return maxChosibleInteger%2` in the condition above, OJ still accepted the code, which means OJ does not include such test cases when the condition is true, .\\n\\nTherefore, I suggest to add the following two test cases, where the sum condition holds and `maxChosibleInteger` and `desiredTotal` are different under `%2`:\\n*  `maxChosibleInteger = 19, desiredTotal = 190;`\\n*  `maxChosibleInteger = 18, desiredTotal = 171;`"
                    },
                    {
                        "username": "BOZACI",
                        "content": "class Solution {\\n        public boolean canIWin(int maxChoosableInteger, int desiredTotal) {\\n\\n               boolean win = true;\\n               int i =maxChoosableInteger%2;\\n\\n\\n\\n\\n\\n                //1<=maxChoosableInteger<=20\\n                //0<= desiredTotal <=300\\n\\n\\n\\n\\n\\n                while(maxChoosableInteger<=desiredTotal)\\n                {\\n\\n\\n                       \\n                        \\n                        desiredTotal = desiredTotal- maxChoosableInteger;\\n                        maxChoosableInteger--;\\n                }\\n                if( maxChoosableInteger%2 == i ){\\n                        win = true;\\n\\n                }\\n                else {\\n                        win = false;\\n                }\\n\\n       return win; }\\n}\\n/ it felt so true :)"
                    },
                    {
                        "username": "stbrumme",
                        "content": "Edge case found in the tests: if noone can win (sum of all numbers is less than desiredTotal) then return False => not obvious from the problem description"
                    },
                    {
                        "username": "roshangugale24",
                        "content": "Why can\\'t the first player choose 10 in the first chance itself?\\nIf he does so, then he can win the game."
                    },
                    {
                        "username": "roshangugale24",
                        "content": "[@uttarandas501](/uttarandas501) okay! I misunderstood the question earlier, now it\\'s clear. Thank you!"
                    },
                    {
                        "username": "uttarandas501",
                        "content": "the next player will chose any number (even 1) to win. We have to equate or exceed 11"
                    },
                    {
                        "username": "user4488fC",
                        "content": "Examples testcaes are useless , please improve it."
                    },
                    {
                        "username": "hritikp",
                        "content": "how i think in this type of questions\\n"
                    },
                    {
                        "username": "khushi3",
                        "content": "Did anybody tried game theory min max approach \n          \nif(turn == 1)  \n       res = res || helper(range, goal - (i + 1), visited_mask ^ bit, 0);\nelse \n       res = res && helper(range, goal - (i + 1), visited_mask ^ bit, 1);\n\n\nSomebody able to submit using this approach ?"
                    }
                ]
            },
            {
                "id": 2009934,
                "content": [
                    {
                        "username": "bettytuan0209@hotmail.com",
                        "content": "In all of the examples, the players either prefer the biggest or smallest number not picked. Can someone give an example where the player should pick one in the middle to win?\\n\\nThanks"
                    },
                    {
                        "username": "rotal",
                        "content": "Yes, you need pick some number from bottom to make the other play no matter which he pick will put you in the range of pick biggest number to win.\\nFor example\\n1-10  target=14\\nfirst player will pick 3.\\nthen no matter which number second player pick. even the smallest number 1. will make total to 4.\\nSo first player pick 10 to win the game.\\n\\nThe player who can make the target=biggest+smallest+1 will win the game.\\nIf he can\\'t find the number he will lose the game.\\n\\n\\n\\n"
                    },
                    {
                        "username": "heg816",
                        "content": "max = 10, desiredTotal = 16: Player must choose 5"
                    },
                    {
                        "username": "mochiball",
                        "content": "What is this question even asking lol"
                    },
                    {
                        "username": "ghazanferwahab2",
                        "content": "No way this is a Medium Level Question. It is definitely a Hard Question."
                    },
                    {
                        "username": "zzg_zzm",
                        "content": "To @administrators  \\nThere is an early termination case for this problem:\\n* `if (maxChosibleInteger*(maxChosibleInteger+1)/2 == desiredTotal) return maxChosibleInteger%2;`,\\n\\nwhich means if the sum of all values from initial pool happens to be `desiredTotal`, then apparently, the order to pick numbers is irrelevant to the outcome of the game. It is just whoever picks in the last value from the pool reaches `desiredTotal`. So the first player wins iff there is odd count of values initial in the pool.\\n\\nHowever, when I tested `return desiredTotal%2` instead of the correct `return maxChosibleInteger%2` in the condition above, OJ still accepted the code, which means OJ does not include such test cases when the condition is true, .\\n\\nTherefore, I suggest to add the following two test cases, where the sum condition holds and `maxChosibleInteger` and `desiredTotal` are different under `%2`:\\n*  `maxChosibleInteger = 19, desiredTotal = 190;`\\n*  `maxChosibleInteger = 18, desiredTotal = 171;`"
                    },
                    {
                        "username": "BOZACI",
                        "content": "class Solution {\\n        public boolean canIWin(int maxChoosableInteger, int desiredTotal) {\\n\\n               boolean win = true;\\n               int i =maxChoosableInteger%2;\\n\\n\\n\\n\\n\\n                //1<=maxChoosableInteger<=20\\n                //0<= desiredTotal <=300\\n\\n\\n\\n\\n\\n                while(maxChoosableInteger<=desiredTotal)\\n                {\\n\\n\\n                       \\n                        \\n                        desiredTotal = desiredTotal- maxChoosableInteger;\\n                        maxChoosableInteger--;\\n                }\\n                if( maxChoosableInteger%2 == i ){\\n                        win = true;\\n\\n                }\\n                else {\\n                        win = false;\\n                }\\n\\n       return win; }\\n}\\n/ it felt so true :)"
                    },
                    {
                        "username": "stbrumme",
                        "content": "Edge case found in the tests: if noone can win (sum of all numbers is less than desiredTotal) then return False => not obvious from the problem description"
                    },
                    {
                        "username": "roshangugale24",
                        "content": "Why can\\'t the first player choose 10 in the first chance itself?\\nIf he does so, then he can win the game."
                    },
                    {
                        "username": "roshangugale24",
                        "content": "[@uttarandas501](/uttarandas501) okay! I misunderstood the question earlier, now it\\'s clear. Thank you!"
                    },
                    {
                        "username": "uttarandas501",
                        "content": "the next player will chose any number (even 1) to win. We have to equate or exceed 11"
                    },
                    {
                        "username": "user4488fC",
                        "content": "Examples testcaes are useless , please improve it."
                    },
                    {
                        "username": "hritikp",
                        "content": "how i think in this type of questions\\n"
                    },
                    {
                        "username": "khushi3",
                        "content": "Did anybody tried game theory min max approach \n          \nif(turn == 1)  \n       res = res || helper(range, goal - (i + 1), visited_mask ^ bit, 0);\nelse \n       res = res && helper(range, goal - (i + 1), visited_mask ^ bit, 1);\n\n\nSomebody able to submit using this approach ?"
                    }
                ]
            }
        ]
    }
]