[
    {
        "title": "Search in Rotated Sorted Array",
        "question_content": "There is an integer array nums sorted in ascending order (with distinct values).\nPrior to being passed to your function, nums is possibly rotated at an unknown pivot index k (1 <= k < nums.length) such that the resulting array is [nums[k], nums[k+1], ..., nums[n-1], nums[0], nums[1], ..., nums[k-1]] (0-indexed). For example, [0,1,2,4,5,6,7] might be rotated at pivot index 3 and become [4,5,6,7,0,1,2].\nGiven the array nums after the possible rotation and an integer target, return the index of target if it is in nums, or -1 if it is not in nums.\nYou must write an algorithm with O(log n) runtime complexity.\n&nbsp;\nExample 1:\nInput: nums = [4,5,6,7,0,1,2], target = 0\nOutput: 4\nExample 2:\nInput: nums = [4,5,6,7,0,1,2], target = 3\nOutput: -1\nExample 3:\nInput: nums = [1], target = 0\nOutput: -1\n&nbsp;\nConstraints:\n\n\t1 <= nums.length <= 5000\n\t-104 <= nums[i] <= 104\n\tAll values of nums are unique.\n\tnums is an ascending array that is possibly rotated.\n\t-104 <= target <= 104",
        "solutions": [
            {
                "id": 14425,
                "title": "concise-o-log-n-binary-search-solution",
                "content": "    class Solution {\\n    public:\\n        int search(int A[], int n, int target) {\\n            int lo=0,hi=n-1;\\n            // find the index of the smallest value using binary search.\\n            // Loop will terminate since mid < hi, and lo or hi will shrink by at least 1.\\n            // Proof by contradiction that mid < hi: if mid==hi, then lo==hi and loop would have been terminated.\\n            while(lo<hi){\\n                int mid=(lo+hi)/2;\\n                if(A[mid]>A[hi]) lo=mid+1;\\n                else hi=mid;\\n            }\\n            // lo==hi is the index of the smallest value and also the number of places rotated.\\n            int rot=lo;\\n            lo=0;hi=n-1;\\n            // The usual binary search and accounting for rotation.\\n            while(lo<=hi){\\n                int mid=(lo+hi)/2;\\n                int realmid=(mid+rot)%n;\\n                if(A[realmid]==target)return realmid;\\n                if(A[realmid]<target)lo=mid+1;\\n                else hi=mid-1;\\n            }\\n            return -1;\\n        }\\n    };",
                "solutionTags": [],
                "code": "class Solution {\\n    public:\\n        int search(int A[], int n, int target) {\\n            int lo=0,hi=n-1;\\n            // find the index of the smallest value using binary search.\\n            // Loop will terminate since mid < hi, and lo or hi will shrink by at least 1.\\n            // Proof by contradiction that mid < hi: if mid==hi, then lo==hi and loop would have been terminated.\\n            while(lo<hi){\\n                int mid=(lo+hi)/2;\\n                if(A[mid]>A[hi]) lo=mid+1;\\n                else hi=mid;\\n            }",
                "codeTag": "Java"
            },
            {
                "id": 14435,
                "title": "clever-idea-making-it-simple",
                "content": "This very nice idea is from [rantos22\\'s solution](https://leetcode.com/problems/search-in-rotated-sorted-array/discuss/14443/C++-4-lines-4ms) who sadly only commented *\"You are not expected to understand that :)\"*, which I guess is the reason it\\'s now it\\'s hidden among the most downvoted solutions. I present an explanation and a more usual implementation.\\n\\n---\\n\\n**Explanation**\\n\\nLet\\'s say `nums` looks like this: [12, 13, 14, 15, 16, 17, 18, 19, 0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11]\\n\\nBecause it\\'s not fully sorted, we can\\'t do normal binary search. But here comes the trick:\\n\\n- If target is let\\'s say 14, then we adjust `nums` to this, where \"inf\" means infinity:  \\n[12, 13, 14, 15, 16, 17, 18, 19, inf, inf, inf, inf, inf, inf, inf, inf, inf, inf, inf, inf]  \\n\\n- If target is let\\'s say 7, then we adjust `nums` to this:  \\n[-inf, -inf, -inf, -inf, -inf, -inf, -inf, -inf, 0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11]\\n\\nAnd then we can simply do ordinary binary search.\\n\\nOf course we don\\'t actually adjust the whole array but instead adjust only on the fly only the elements we look at. And the adjustment is done by comparing both the target and the actual element against nums[0].\\n\\n---\\n\\n**Code**\\n\\nIf `nums[mid]` and `target` are *\"on the same side\"* of `nums[0]`, we just take `nums[mid]`. Otherwise we use -infinity or +infinity as needed.\\n\\n    int search(vector<int>& nums, int target) {\\n        int lo = 0, hi = nums.size();\\n        while (lo < hi) {\\n            int mid = (lo + hi) / 2;\\n            \\n            double num = (nums[mid] < nums[0]) == (target < nums[0])\\n                       ? nums[mid]\\n                       : target < nums[0] ? -INFINITY : INFINITY;\\n                       \\n            if (num < target)\\n                lo = mid + 1;\\n            else if (num > target)\\n                hi = mid;\\n            else\\n                return mid;\\n        }\\n        return -1;\\n    }",
                "solutionTags": [],
                "code": "This very nice idea is from [rantos22\\'s solution](https://leetcode.com/problems/search-in-rotated-sorted-array/discuss/14443/C++-4-lines-4ms) who sadly only commented *\"You are not expected to understand that :)\"*, which I guess is the reason it\\'s now it\\'s hidden among the most downvoted solutions. I present an explanation and a more usual implementation.\\n\\n---\\n\\n**Explanation**\\n\\nLet\\'s say `nums` looks like this: [12, 13, 14, 15, 16, 17, 18, 19, 0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11]\\n\\nBecause it\\'s not fully sorted, we can\\'t do normal binary search. But here comes the trick:\\n\\n- If target is let\\'s say 14, then we adjust `nums` to this, where \"inf\" means infinity:  \\n[12, 13, 14, 15, 16, 17, 18, 19, inf, inf, inf, inf, inf, inf, inf, inf, inf, inf, inf, inf]  \\n\\n- If target is let\\'s say 7, then we adjust `nums` to this:  \\n[-inf, -inf, -inf, -inf, -inf, -inf, -inf, -inf, 0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11]\\n\\nAnd then we can simply do ordinary binary search.\\n\\nOf course we don\\'t actually adjust the whole array but instead adjust only on the fly only the elements we look at. And the adjustment is done by comparing both the target and the actual element against nums[0].\\n\\n---\\n\\n**Code**\\n\\nIf `nums[mid]` and `target` are *\"on the same side\"* of `nums[0]`, we just take `nums[mid]`. Otherwise we use -infinity or +infinity as needed.\\n\\n    int search(vector<int>& nums, int target) {\\n        int lo = 0, hi = nums.size();\\n        while (lo < hi) {\\n            int mid = (lo + hi) / 2;\\n            \\n            double num = (nums[mid] < nums[0]) == (target < nums[0])\\n                       ? nums[mid]\\n                       : target < nums[0] ? -INFINITY : INFINITY;\\n                       \\n            if (num < target)\\n                lo = mid + 1;\\n            else if (num > target)\\n                hi = mid;\\n            else\\n                return mid;\\n        }\\n        return -1;\\n    }",
                "codeTag": "Unknown"
            },
            {
                "id": 14436,
                "title": "revised-binary-search",
                "content": "    public class Solution {\\n    public int search(int[] A, int target) {\\n        int lo = 0;\\n        int hi = A.length - 1;\\n        while (lo < hi) {\\n            int mid = (lo + hi) / 2;\\n            if (A[mid] == target) return mid;\\n            \\n            if (A[lo] <= A[mid]) {\\n                if (target >= A[lo] && target < A[mid]) {\\n                    hi = mid - 1;\\n                } else {\\n                    lo = mid + 1;\\n                }\\n            } else {\\n                if (target > A[mid] && target <= A[hi]) {\\n                    lo = mid + 1;\\n                } else {\\n                    hi = mid - 1;\\n                }\\n            }\\n        }\\n        return A[lo] == target ? lo : -1;\\n    }\\n}",
                "solutionTags": [
                    "Java",
                    "Binary Tree"
                ],
                "code": "class Solution {\\n    public int search(int[] A, int target) {\\n        int lo = 0;\\n        int hi = A.length - 1;\\n        while (lo < hi) {\\n            int mid = (lo + hi) / 2;\\n            if (A[mid] == target) return mid;\\n            \\n            if (A[lo] <= A[mid]) {\\n                if (target >= A[lo] && target < A[mid]) {\\n                    hi = mid - 1;\\n                }",
                "codeTag": "Java"
            },
            {
                "id": 154836,
                "title": "the-inf-and-inf-method-but-with-a-better-explanation-for-dummies-like-me",
                "content": "[Solution and explanation from StefanPochmann](https://leetcode.com/problems/search-in-rotated-sorted-array/discuss/14435/Clever-idea-making-it-simple) but I\\'m such a dummy I could not understand it for a whole day. I had to think of it intuitively for a long time before I got it and thought I\\'d write an explanation for dummies like me\\n**Explanation**\\nThink of the problem in this. We cannot do regular binary search because of the rotation.\\n* Example: ```nums```: [12, 13, 14, 15, 16, 17, 0, 1, 2, 3, 4, 5, 6, 7]\\n* Ideally this would have looked as [0, 1, 2, 3, 4, 5, 6, 7, **12**, 13, 14, 15, 16, 17]\\nBut it is rotated at a pivot number: 12. This is ```nums[0]```. Let\\'s call it  pivot number for this explanation.\\n\\nLet\\'s call the left increasing sub sequence as **left half** and right increasing subsequence as **right half**. \\n\\n**HERE\\'S THE GIST OF THE SOLUTION LOGIC: THE PROBLEM IN NOT BEING ABLE TO DO REGULAR BINARY SEARCH IS: WHEN YOUR MID POINT AND TARGET END UP BEING IN DIFFERENT HALVES (ONE IS IN LEFT AND OTHER IN RIGHT OR VICE VERSA). IF THEY ARE BOTH IN SAME HALF, IT\\'S JUST LIKE REGULAR BINARY SEARCH BECAUSE YOU WILL CONVERGE TOWARDS THE TARGET ON THAT STEP OF THE BINARY SEARCH. IF YOU ENDED UP IN SEPARATE HALVES, WE CAN CONVERGE TOWARDS THE TARGET BY MAKING IT -INF OR INF LIKE SHOWN BELOW.**\\nHere\\'s the trick:\\n* If ```target``` is say in the left half, then when searching we need to make the numbers as \\n\\t*  [12, 13, 14, 15, 16, 17, inf, inf, inf, inf, inf, inf, inf, inf] \\n*  if ```target``` is in right half then we need to make it as \\n\\t*  [-inf, -inf, -inf, -inf, -inf, -inf, 0, 1, 2, 3, 4, 5, 6, 7]\\n\\nWe don\\'t need to edit the actual array like that, we just need to make the comparator number(in regular case, the mid point that we select) to INF or -INF based on which side the ```target``` is and which side the mid point number is.\\n\\nOkay, but we don\\'t need to always use the comparator as -inf or inf. Think of the case when that is possible?\\nThat\\'s when your ```target``` and ```nums[mid]``` are on the same half side (left or right half). THis means that your mid point and target are on the same half and you are converging towards the target. So then just keep doing regular binary for that step and let the comparator be ```nums[mid]```.\\n* How do we check if they both (```nums[mid]``` and ```target```) are on the same half? We have to check if they are both greater than the pivot number or both smaller than pivot number \\n\\t* ```if (((nums[mid] > nums[0]) && (target > nums[0])) || ((nums[mid] <= nums[0]) && (target <= nums[0])))```.\\n\\t* This can also be done as ```if ((target > nums[0]) == (nums[mid] > nums[0]))```.\\n\\t* Ok, so if they both are on the same half let our comparator be ```nums[mid]```, because we are converging towards the target and are on the same half at the moment of comparision.\\n\\t*  ```comparator = nums[mid]```\\n\\t*  proceed with comparing how you do regular binary search comparision.\\n\\nBut, what if ```nums[mid]``` and ```target``` are on different halves? Then we have to not use the ```nums[mid]``` as comparator. We have to use -INF or INF. How can we decide whether to make comparator as  -INF or INF instead of ```nums[mid]```?\\n* target and ```nums[mid]``` are on different halves. we have to change ```nums[mid]``` to -INF or INF.\\n* Let\\'s find out which side ```nums[mid]``` is. If we know which half (left or right) it is in, we know whether to select -INF or INF.\\n* Compare target to ```nums[0]```. (Why compare ```target``` and not ```nums[mid]``` because we want to make the numbers on ```nums[mid]``` \\'s side as -INF or INF when comparing, not on ```target```\\'s side, so we use target as the reference)\\n* if ```target``` is greater than ```nums[0]```, target is on the **left half**. Look at the example above and you can see this.\\n\\t* For example: ```target``` is 14, it is greater than 12 so it belongs in **left half**\\n\\t* This means that ```nums[mid]``` is on the other half: **right half**. Make comparator as INF.\\n* if ```target``` is less than nums[0], target is on the **right half**. Look at the example above:\\n\\t* For example if ```target``` is 5, it is less than 12 so it belongs in **right half**\\n\\t* This means that ```nums[mid]``` is on the other half. **left half**. make comparator as -INF.\\n\\nNow you can go ahead and do binary search\\n______________________________________________________________________________________________________________________________________________________\\n\\n**CODE:**\\n```\\nclass Solution {\\npublic:\\n    int search(vector<int>& nums, int target) \\n    {\\n            int l = 0, r = nums.size()-1;\\n            while(l <= r)\\n            {\\n                int mid = (r - l)/2 + l;\\n                int comparator = nums[mid];\\n                // Checking if both target and nums[mid] are on same side.\\n                if((target < nums[0]) && (nums[mid] < nums[0]) || (target >= nums[0]) && (nums[mid] >= nums[0]))\\n                    comparator = nums[mid];\\n                else\\n                {\\n                    // Trying to figure out where nums[mid] is and making comparator as -INF or INF\\n                    if(target <nums[0])\\n                        comparator = -INFINITY;\\n                    else \\n                        comparator = INFINITY;\\n\\n                }\\n                if(target == comparator) return mid;\\n                if(target > comparator)            \\n                    l = mid+1;            \\n                else\\n                    r = mid-1;\\n\\n            }\\n            return -1;\\n    }\\n};\\n```\\n",
                "solutionTags": [],
                "code": "```nums```\n```nums[0]```\n```target```\n```target```\n```target```\n```target```\n```nums[mid]```\n```nums[mid]```\n```nums[mid]```\n```target```\n```if (((nums[mid] > nums[0]) && (target > nums[0])) || ((nums[mid] <= nums[0]) && (target <= nums[0])))```\n```if ((target > nums[0]) == (nums[mid] > nums[0]))```\n```nums[mid]```\n```comparator = nums[mid]```\n```nums[mid]```\n```target```\n```nums[mid]```\n```nums[mid]```\n```nums[mid]```\n```nums[mid]```\n```nums[mid]```\n```nums[0]```\n```target```\n```nums[mid]```\n```nums[mid]```\n```target```\n```target```\n```nums[0]```\n```target```\n```nums[mid]```\n```target```\n```target```\n```nums[mid]```\n```\\nclass Solution {\\npublic:\\n    int search(vector<int>& nums, int target) \\n    {\\n            int l = 0, r = nums.size()-1;\\n            while(l <= r)\\n            {\\n                int mid = (r - l)/2 + l;\\n                int comparator = nums[mid];\\n                // Checking if both target and nums[mid] are on same side.\\n                if((target < nums[0]) && (nums[mid] < nums[0]) || (target >= nums[0]) && (nums[mid] >= nums[0]))\\n                    comparator = nums[mid];\\n                else\\n                {\\n                    // Trying to figure out where nums[mid] is and making comparator as -INF or INF\\n                    if(target <nums[0])\\n                        comparator = -INFINITY;\\n                    else \\n                        comparator = INFINITY;\\n\\n                }\\n                if(target == comparator) return mid;\\n                if(target > comparator)            \\n                    l = mid+1;            \\n                else\\n                    r = mid-1;\\n\\n            }\\n            return -1;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 14472,
                "title": "java-ac-solution-using-once-binary-search",
                "content": "The idea is that when rotating the array, there must be one half of the array that is still in sorted order. \\nFor example,  6 7 1 2 3 4 5, the order is disrupted from the point between 7 and 1. So when doing binary search, we can make a judgement that which part is ordered and whether the target is in that range, if yes, continue the search in that half, if not continue in the other half. \\n    \\n    \\n\\n    public class Solution {\\n        public int search(int[] nums, int target) {\\n            int start = 0;\\n            int end = nums.length - 1;\\n            while (start <= end){\\n                int mid = (start + end) / 2;\\n                if (nums[mid] == target)\\n                    return mid;\\n            \\n                if (nums[start] <= nums[mid]){\\n                     if (target < nums[mid] && target >= nums[start]) \\n                        end = mid - 1;\\n                     else\\n                        start = mid + 1;\\n                } \\n            \\n                if (nums[mid] <= nums[end]){\\n                    if (target > nums[mid] && target <= nums[end])\\n                        start = mid + 1;\\n                     else\\n                        end = mid - 1;\\n                }\\n            }\\n            return -1;\\n        }\\n    }",
                "solutionTags": [
                    "Java",
                    "Binary Tree"
                ],
                "code": "class Solution {\\n        public int search(int[] nums, int target) {\\n            int start = 0;\\n            int end = nums.length - 1;\\n            while (start <= end){\\n                int mid = (start + end) / 2;\\n                if (nums[mid] == target)\\n                    return mid;\\n            \\n                if (nums[start] <= nums[mid]){\\n                     if (target < nums[mid] && target >= nums[start]) \\n                        end = mid - 1;\\n                     else\\n                        start = mid + 1;\\n                }",
                "codeTag": "Java"
            },
            {
                "id": 14437,
                "title": "python-binary-search-solution-o-logn-48ms",
                "content": "    class Solution:\\n        # @param {integer[]} numss\\n        # @param {integer} target\\n        # @return {integer}\\n        def search(self, nums, target):\\n            if not nums:\\n                return -1\\n    \\n            low, high = 0, len(nums) - 1\\n    \\n            while low <= high:\\n                mid = (low + high) / 2\\n                if target == nums[mid]:\\n                    return mid\\n    \\n                if nums[low] <= nums[mid]:\\n                    if nums[low] <= target <= nums[mid]:\\n                        high = mid - 1\\n                    else:\\n                        low = mid + 1\\n                else:\\n                    if nums[mid] <= target <= nums[high]:\\n                        low = mid + 1\\n                    else:\\n                        high = mid - 1\\n    \\n            return -1",
                "solutionTags": [
                    "Python",
                    "Binary Tree"
                ],
                "code": "class Solution:\\n        # @param {integer[]}",
                "codeTag": "Java"
            },
            {
                "id": 14616,
                "title": "c-binary-search-with-comments-easy-to-read-and-understand",
                "content": "    class Solution {\\n    public:\\n        int search(vector<int>& nums, int target) {\\n            int l = 0, r = nums.size()-1;\\n            while (l <= r) {\\n                int mid = (l+r) / 2;\\n                if (target == nums[mid])\\n                    return mid;\\n                // there exists rotation; the middle element is in the left part of the array\\n                if (nums[mid] > nums[r]) {\\n                    if (target < nums[mid] && target >= nums[l])\\n                        r = mid - 1;\\n                    else\\n                        l = mid + 1;\\n                }\\n                // there exists rotation; the middle element is in the right part of the array\\n                else if (nums[mid] < nums[l]) {\\n                    if (target > nums[mid] && target <= nums[r])\\n                        l = mid + 1;\\n                    else\\n                        r = mid - 1;\\n                }\\n                // there is no rotation; just like normal binary search\\n                else {\\n                    if (target < nums[mid])\\n                        r = mid - 1;\\n                    else\\n                        l = mid + 1;\\n                }\\n            }\\n            return -1;\\n        }\\n    };",
                "solutionTags": [],
                "code": "class Solution {\\n    public:\\n        int search(vector<int>& nums, int target) {\\n            int l = 0, r = nums.size()-1;\\n            while (l <= r) {\\n                int mid = (l+r) / 2;\\n                if (target == nums[mid])\\n                    return mid;\\n                // there exists rotation; the middle element is in the left part of the array\\n                if (nums[mid] > nums[r]) {\\n                    if (target < nums[mid] && target >= nums[l])\\n                        r = mid - 1;\\n                    else\\n                        l = mid + 1;\\n                }",
                "codeTag": "Java"
            },
            {
                "id": 273622,
                "title": "javascript-simple-o-log-n-binary-search-solution",
                "content": "Let\\'s take some examples and see how we can simplify the condition.\\n\\nOriginal sorted array\\n[1, 2, 3, 4, 5, 6, 7] \\n\\nAfter rotation, it might be something like\\n[3, 4, 5, 6, 7, 1, 2]\\n[6, 7, 1, 2, 3, 4, 5]\\n[1, 2, 3, 4, 5, 6, 7] <-- rotated and end up the same\\nand etc..\\n\\nWhen you divide the rotated array into two halves, using `mid` index, **at least one of subarray should remain sorted ALWAYS**.\\n\\n[3, 4, 5, 6, 7, 1, 2] \\n-> **[3, 4, 5]** [ 6, 7, 1, 2] \\nthe left side remains sorted\\n\\n[6, 7, 1, 2, 3, 4, 5]\\n-> [6, 7, 1] **[2, 3, 4, 5]**\\n the right side remains sorted\\n\\n[1, 2, 3, 4, 5, 6, 7]\\n-> **[1, 2, 3]** **[4, 5, 6, 7]**\\nBoth sides remain sorted.\\n\\nIf you know one side is sorted, the rest of logic becomes very simple. \\nIf one side is sorted, check if the `target` is in the boundary, otherwise it\\'s on the other side.\\n```\\nIF smallest <= target <= biggest\\n  then target is here\\nELSE\\n  then target is on the other side\\n```\\n\\n\\n```\\n/**\\n * @param {number[]} nums\\n * @param {number} target\\n * @return {number}\\n */\\nvar search = function(nums, target) {\\n  let left = 0;\\n  let right = nums.length - 1;\\n    \\n  while (left <= right) {\\n    let mid = Math.floor((left + right) / 2);\\n    \\n    if (nums[mid] === target) {\\n      return mid;\\n    }\\n    \\n    // When dividing the roated array into two halves, one must be sorted.\\n    \\n    // Check if the left side is sorted\\n    if (nums[left] <= nums[mid]) {\\n      if (nums[left] <= target && target <= nums[mid]) {\\n        // target is in the left\\n        right = mid - 1;\\n        \\n      } else {\\n        // target is in the right\\n        left = mid + 1;\\n      }\\n    } \\n    \\n    // Otherwise, the right side is sorted\\n    else {\\n      if (nums[mid] <= target && target <= nums[right]) {\\n        // target is in the right\\n        left = mid + 1;\\n\\n      } else {\\n        // target is in the left\\n        right = mid - 1;\\n      }\\n    }\\n    \\n    \\n  }\\n    \\n  return -1;\\n};\\n```",
                "solutionTags": [
                    "JavaScript",
                    "Binary Search"
                ],
                "code": "```\\nIF smallest <= target <= biggest\\n  then target is here\\nELSE\\n  then target is on the other side\\n```\n```\\n/**\\n * @param {number[]} nums\\n * @param {number} target\\n * @return {number}\\n */\\nvar search = function(nums, target) {\\n  let left = 0;\\n  let right = nums.length - 1;\\n    \\n  while (left <= right) {\\n    let mid = Math.floor((left + right) / 2);\\n    \\n    if (nums[mid] === target) {\\n      return mid;\\n    }\\n    \\n    // When dividing the roated array into two halves, one must be sorted.\\n    \\n    // Check if the left side is sorted\\n    if (nums[left] <= nums[mid]) {\\n      if (nums[left] <= target && target <= nums[mid]) {\\n        // target is in the left\\n        right = mid - 1;\\n        \\n      } else {\\n        // target is in the right\\n        left = mid + 1;\\n      }\\n    } \\n    \\n    // Otherwise, the right side is sorted\\n    else {\\n      if (nums[mid] <= target && target <= nums[right]) {\\n        // target is in the right\\n        left = mid + 1;\\n\\n      } else {\\n        // target is in the left\\n        right = mid - 1;\\n      }\\n    }\\n    \\n    \\n  }\\n    \\n  return -1;\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3879263,
                "title": "100-binary-search-easy-video-o-log-n-optimal-solution",
                "content": "# Problem Understanding\\n\\nThe task is to search for a target integer in a sorted array that has been rotated at an unknown pivot. \\n\\nFor instance, the array $$[0,1,2,4,5,6,7]$$ could be rotated at the 4th position to give $$[4,5,6,7,0,1,2]$$. The challenge is to find the position of the target integer in this rotated array. \\n\\n![example.png](https://assets.leetcode.com/users/images/368df713-a386-4fd6-92eb-72d7606ac16f_1691456157.2050898.png)\\n\\n- The top section shows the `nums` array with a red rectangle highlighting the current \"mid\" value being considered in each step.\\n- The bottom section displays a table that presents the steps of the binary search. Each row corresponds to a step, detailing:\\n  - The step number.\\n  - The indices of the low (L), mid (M), and high (R) pointers.\\n  - The values at the low (L), mid (M), and high (R) positions.\\n\\n# Live Coding & Explenation\\nhttps://youtu.be/hywGbVJldj0\\n\\n# Approach\\n\\nGiven the properties of the array, it\\'s tempting to perform a linear search. However, that would result in a time complexity of $$O(n)$$. Instead, we can use the properties of the array to our advantage and apply a binary search to find the target with time complexity of $$ O(\\\\log n) $$ only.\\n\\n## Treating the Rotated Array\\n\\nAlthough the array is rotated, it retains some properties of sorted arrays that we can leverage. Specifically, one half of the array (either the left or the right) will always be sorted. This means we can still apply binary search by determining which half of our array is sorted and whether the target lies within it.\\n\\n## Binary Search\\n\\nBinary search is an efficient algorithm for finding a target value within a sorted list. It works by repeatedly dividing the search interval in half. If the value of the search key is less than the item in the middle of the interval, narrow the interval to the lower half. Otherwise, narrow it to the upper half. Repeatedly check until the value is found or the interval is empty.\\n\\n## Initialization\\n\\nWe start with two pointers:\\n\\n- $$ \\\\text{left} $$ - This represents the beginning of the array. We initialize it to 0, the index of the first element.\\n- $$ \\\\text{right} $$ - This represents the end of the array. It\\'s set to $$ n - 1 $$, the index of the last element, where $$ n $$ is the length of the array.\\n\\n## Iterative Binary Search\\n\\nWe perform the binary search within a while loop until $$ \\\\text{left} $$ exceeds $$ \\\\text{right} $$. In each iteration, we calculate the midpoint between $$ \\\\text{left} $$ and $$ \\\\text{right} $$.\\n\\n### Deciding the Sorted Half:\\n\\nAt any point during the search in the rotated array, one half (either the left or the right) will always be sorted. Determining which half is sorted is crucial for our modified binary search. \\n\\n- **If left half $$[low...mid]$$ is sorted**: We know this if the element at $$ \\\\text{low} $$ is less than or equal to the element at $$ \\\\text{mid} $$. In a normally sorted array, if the start is less than or equal to the midpoint, it means all elements till the midpoint are in the correct increasing order.\\n\\n  - **If the target lies within this sorted left half**: We know this if the target is greater than or equal to the element at $$ \\\\text{low} $$ and less than the element at $$ \\\\text{mid} $$. If this is the case, we then move our search to this half, meaning, we update $$ \\\\text{high} $$ to $$ \\\\text{mid} - 1 $$.\\n\\n  - **Otherwise**: The target must be in the right half. So, we update $$ \\\\text{low} $$ to $$ \\\\text{mid} + 1 $$.\\n\\n- **If right half $$[mid...high]$$ is sorted**: This is the else part. If the left half isn\\'t sorted, the right half must be!\\n\\n  - **If the target lies within this sorted right half**: We know this if the target is greater than the element at $$ \\\\text{mid} $$ and less than or equal to the element at $$ \\\\text{high} $$. If so, we move our search to this half by updating $$ \\\\text{low} $$ to $$ \\\\text{mid} + 1 $$.\\n\\n  - **Otherwise**: The target must be in the left half. So, we update $$ \\\\text{high} $$ to $$ \\\\text{mid} - 1 $$.\\n\\n### Rationale:\\n\\nThe beauty of this approach lies in its ability to determine with certainty which half of the array to look in, even though the array is rotated. By checking which half of the array is sorted and then using the sorted property to determine if the target lies in that half, we can effectively eliminate half of the array from consideration at each step, maintaining the $$ O(\\\\log n) $$ time complexity of the binary search.\\n\\n## Complexity\\n\\n**Time Complexity**: The time complexity is $$ O(\\\\log n) $$ since we\\'re performing a binary search over the elements of the array.\\n\\n**Space Complexity**: The space complexity is $$ O(1) $$ because we only use a constant amount of space to store our variables ($$ \\\\text{left} $$, $$\\\\text{right} $$, $$ \\\\text{mid} $$), regardless of the size of the input array.\\n\\n# Performance\\n\\n![33-per.png](https://assets.leetcode.com/users/images/1306fe69-ec15-427c-90e0-c641ed275b2f_1691455472.463153.png)\\n\\n\\n# Code\\n\\n``` Python []\\nclass Solution:\\n    def search(self, nums: List[int], target: int) -> int:\\n        left, right = 0, len(nums) - 1\\n\\n        while left <= right:\\n            mid = (left + right) // 2\\n\\n            if nums[mid] == target:\\n                return mid\\n\\n            # Check if left half is sorted\\n            if nums[left] <= nums[mid]:\\n                if nums[left] <= target < nums[mid]:\\n                    right = mid - 1\\n                else:\\n                    left = mid + 1\\n            # Otherwise, right half is sorted\\n            else:\\n                if nums[mid] < target <= nums[right]:\\n                    left = mid + 1\\n                else:\\n                    right = mid - 1\\n\\n        return -1\\n```\\n``` C++ []\\nclass Solution {\\npublic:\\n    int search(std::vector<int>& nums, int target) {\\n        int low = 0, high = nums.size() - 1;\\n\\n        while (low <= high) {\\n            int mid = (low + high) / 2;\\n\\n            if (nums[mid] == target) {\\n                return mid;\\n            }\\n\\n            if (nums[low] <= nums[mid]) {\\n                if (nums[low] <= target && target < nums[mid]) {\\n                    high = mid - 1;\\n                } else {\\n                    low = mid + 1;\\n                }\\n            } else {\\n                if (nums[mid] < target && target <= nums[high]) {\\n                    low = mid + 1;\\n                } else {\\n                    high = mid - 1;\\n                }\\n            }\\n        }\\n\\n        return -1;\\n    }\\n};\\n```\\n``` Go []\\nfunc search(nums []int, target int) int {\\n    low, high := 0, len(nums) - 1\\n\\n    for low <= high {\\n        mid := (low + high) / 2\\n\\n        if nums[mid] == target {\\n            return mid\\n        }\\n\\n        if nums[low] <= nums[mid] {\\n            if nums[low] <= target && target < nums[mid] {\\n                high = mid - 1\\n            } else {\\n                low = mid + 1\\n            }\\n        } else {\\n            if nums[mid] < target && target <= nums[high] {\\n                low = mid + 1\\n            } else {\\n                high = mid - 1\\n            }\\n        }\\n    }\\n\\n    return -1\\n}\\n```\\n``` Rust []\\nimpl Solution {\\n    pub fn search(nums: Vec<i32>, target: i32) -> i32 {\\n        let mut low = 0;\\n        let mut high = nums.len() as i32 - 1;\\n\\n        while low <= high {\\n            let mid = (low + high) / 2;\\n\\n            if nums[mid as usize] == target {\\n                return mid;\\n            }\\n\\n            if nums[low as usize] <= nums[mid as usize] {\\n                if nums[low as usize] <= target && target < nums[mid as usize] {\\n                    high = mid - 1;\\n                } else {\\n                    low = mid + 1;\\n                }\\n            } else {\\n                if nums[mid as usize] < target && target <= nums[high as usize] {\\n                    low = mid + 1;\\n                } else {\\n                    high = mid - 1;\\n                }\\n            }\\n        }\\n\\n        -1\\n    }\\n}\\n```\\n``` Java []\\nclass Solution {\\n    public int search(int[] nums, int target) {\\n        int low = 0, high = nums.length - 1;\\n\\n        while (low <= high) {\\n            int mid = (low + high) / 2;\\n\\n            if (nums[mid] == target) {\\n                return mid;\\n            }\\n\\n            if (nums[low] <= nums[mid]) {\\n                if (nums[low] <= target && target < nums[mid]) {\\n                    high = mid - 1;\\n                } else {\\n                    low = mid + 1;\\n                }\\n            } else {\\n                if (nums[mid] < target && target <= nums[high]) {\\n                    low = mid + 1;\\n                } else {\\n                    high = mid - 1;\\n                }\\n            }\\n        }\\n\\n        return -1;\\n    }\\n}\\n```\\n``` JavaScript []\\n/**\\n * @param {number[]} nums\\n * @param {number} target\\n * @return {number}\\n */\\nvar search = function(nums, target) {\\n    let low = 0, high = nums.length - 1;\\n\\n    while (low <= high) {\\n        let mid = Math.floor((low + high) / 2);\\n\\n        if (nums[mid] === target) {\\n            return mid;\\n        }\\n\\n        if (nums[low] <= nums[mid]) {\\n            if (nums[low] <= target && target < nums[mid]) {\\n                high = mid - 1;\\n            } else {\\n                low = mid + 1;\\n            }\\n        } else {\\n            if (nums[mid] < target && target <= nums[high]) {\\n                low = mid + 1;\\n            } else {\\n                high = mid - 1;\\n            }\\n        }\\n    }\\n\\n    return -1;\\n};\\n```\\n``` C# []\\npublic class Solution {\\n    public int Search(int[] nums, int target) {\\n        int low = 0, high = nums.Length - 1;\\n\\n        while (low <= high) {\\n            int mid = (low + high) / 2;\\n\\n            if (nums[mid] == target) {\\n                return mid;\\n            }\\n\\n            if (nums[low] <= nums[mid]) {\\n                if (nums[low] <= target && target < nums[mid]) {\\n                    high = mid - 1;\\n                } else {\\n                    low = mid + 1;\\n                }\\n            } else {\\n                if (nums[mid] < target && target <= nums[high]) {\\n                    low = mid + 1;\\n                } else {\\n                    high = mid - 1;\\n                }\\n            }\\n        }\\n\\n        return -1;\\n    }\\n}\\n```\\n\\nI hope this explanation provides clarity on the \"Search in Rotated Sorted Array\" problem. If you have any more questions, feel free to ask! If you found this helpful, consider giving it a thumbs up. Happy coding! \\uD83D\\uDC69\\u200D\\uD83D\\uDCBB\\uD83D\\uDE80\\uD83D\\uDC68\\u200D\\uD83D\\uDCBB",
                "solutionTags": [
                    "C++",
                    "Java",
                    "Python3",
                    "C#",
                    "JavaScript",
                    "Go",
                    "Rust",
                    "Array",
                    "Binary Search"
                ],
                "code": "``` Python []\\nclass Solution:\\n    def search(self, nums: List[int], target: int) -> int:\\n        left, right = 0, len(nums) - 1\\n\\n        while left <= right:\\n            mid = (left + right) // 2\\n\\n            if nums[mid] == target:\\n                return mid\\n\\n            # Check if left half is sorted\\n            if nums[left] <= nums[mid]:\\n                if nums[left] <= target < nums[mid]:\\n                    right = mid - 1\\n                else:\\n                    left = mid + 1\\n            # Otherwise, right half is sorted\\n            else:\\n                if nums[mid] < target <= nums[right]:\\n                    left = mid + 1\\n                else:\\n                    right = mid - 1\\n\\n        return -1\\n```\n``` C++ []\\nclass Solution {\\npublic:\\n    int search(std::vector<int>& nums, int target) {\\n        int low = 0, high = nums.size() - 1;\\n\\n        while (low <= high) {\\n            int mid = (low + high) / 2;\\n\\n            if (nums[mid] == target) {\\n                return mid;\\n            }\\n\\n            if (nums[low] <= nums[mid]) {\\n                if (nums[low] <= target && target < nums[mid]) {\\n                    high = mid - 1;\\n                } else {\\n                    low = mid + 1;\\n                }\\n            } else {\\n                if (nums[mid] < target && target <= nums[high]) {\\n                    low = mid + 1;\\n                } else {\\n                    high = mid - 1;\\n                }\\n            }\\n        }\\n\\n        return -1;\\n    }\\n};\\n```\n``` Go []\\nfunc search(nums []int, target int) int {\\n    low, high := 0, len(nums) - 1\\n\\n    for low <= high {\\n        mid := (low + high) / 2\\n\\n        if nums[mid] == target {\\n            return mid\\n        }\\n\\n        if nums[low] <= nums[mid] {\\n            if nums[low] <= target && target < nums[mid] {\\n                high = mid - 1\\n            } else {\\n                low = mid + 1\\n            }\\n        } else {\\n            if nums[mid] < target && target <= nums[high] {\\n                low = mid + 1\\n            } else {\\n                high = mid - 1\\n            }\\n        }\\n    }\\n\\n    return -1\\n}\\n```\n``` Rust []\\nimpl Solution {\\n    pub fn search(nums: Vec<i32>, target: i32) -> i32 {\\n        let mut low = 0;\\n        let mut high = nums.len() as i32 - 1;\\n\\n        while low <= high {\\n            let mid = (low + high) / 2;\\n\\n            if nums[mid as usize] == target {\\n                return mid;\\n            }\\n\\n            if nums[low as usize] <= nums[mid as usize] {\\n                if nums[low as usize] <= target && target < nums[mid as usize] {\\n                    high = mid - 1;\\n                } else {\\n                    low = mid + 1;\\n                }\\n            } else {\\n                if nums[mid as usize] < target && target <= nums[high as usize] {\\n                    low = mid + 1;\\n                } else {\\n                    high = mid - 1;\\n                }\\n            }\\n        }\\n\\n        -1\\n    }\\n}\\n```\n``` Java []\\nclass Solution {\\n    public int search(int[] nums, int target) {\\n        int low = 0, high = nums.length - 1;\\n\\n        while (low <= high) {\\n            int mid = (low + high) / 2;\\n\\n            if (nums[mid] == target) {\\n                return mid;\\n            }\\n\\n            if (nums[low] <= nums[mid]) {\\n                if (nums[low] <= target && target < nums[mid]) {\\n                    high = mid - 1;\\n                } else {\\n                    low = mid + 1;\\n                }\\n            } else {\\n                if (nums[mid] < target && target <= nums[high]) {\\n                    low = mid + 1;\\n                } else {\\n                    high = mid - 1;\\n                }\\n            }\\n        }\\n\\n        return -1;\\n    }\\n}\\n```\n``` JavaScript []\\n/**\\n * @param {number[]} nums\\n * @param {number} target\\n * @return {number}\\n */\\nvar search = function(nums, target) {\\n    let low = 0, high = nums.length - 1;\\n\\n    while (low <= high) {\\n        let mid = Math.floor((low + high) / 2);\\n\\n        if (nums[mid] === target) {\\n            return mid;\\n        }\\n\\n        if (nums[low] <= nums[mid]) {\\n            if (nums[low] <= target && target < nums[mid]) {\\n                high = mid - 1;\\n            } else {\\n                low = mid + 1;\\n            }\\n        } else {\\n            if (nums[mid] < target && target <= nums[high]) {\\n                low = mid + 1;\\n            } else {\\n                high = mid - 1;\\n            }\\n        }\\n    }\\n\\n    return -1;\\n};\\n```\n``` C# []\\npublic class Solution {\\n    public int Search(int[] nums, int target) {\\n        int low = 0, high = nums.Length - 1;\\n\\n        while (low <= high) {\\n            int mid = (low + high) / 2;\\n\\n            if (nums[mid] == target) {\\n                return mid;\\n            }\\n\\n            if (nums[low] <= nums[mid]) {\\n                if (nums[low] <= target && target < nums[mid]) {\\n                    high = mid - 1;\\n                } else {\\n                    low = mid + 1;\\n                }\\n            } else {\\n                if (nums[mid] < target && target <= nums[high]) {\\n                    low = mid + 1;\\n                } else {\\n                    high = mid - 1;\\n                }\\n            }\\n        }\\n\\n        return -1;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 894031,
                "title": "python-o-logn-detailed-explanation",
                "content": "#### Idea:\\nWe have an ascending array, which is rotated at some pivot.\\nLet\\'s call the rotation the `inflection point`. (IP)\\nOne characteristic the inflection point holds is: `arr[IP] > arr[IP + 1] and arr[IP] > arr[IP - 1]`\\nSo if we had an array like: `[7, 8, 9, 0, 1, 2, 3, 4]` the inflection point, `IP` would be the number `9`.\\n\\nOne thing we can see is that values until the IP are ascending. And values from IP + 1 until end are also ascending (`binary search`, wink, wink).\\nAlso the values from [0, IP] are always bigger than [IP + 1, n].\\n\\n#### intuition:\\nWe can perform a Binary Search.\\nIf **A[mid] is bigger than A[left]** we know the inflection point will be to the right of us, meaning values from a[left]...a[mid] **are ascending**.\\n\\nSo if `target` is between that range we just `cut our search space to the left`.\\nOtherwise go right.\\n\\n**The other condition is that A[mid] is not bigger than A[left]** meaning **a[mid]...a[right] is ascending**.\\nIn the same manner we can check if target is in that range and cut the search space correspondingly.\\n\\n##### Time complexity: O(logn)\\n##### Space complexity: O(1)\\n<hr/>\\n\\n### Algorithm:\\n\\n```\\nclass Solution:\\n    def search(self, A: List[int], target: int) -> int:\\n        n = len(A)\\n        left, right = 0, n - 1\\n        if n == 0: return -1\\n        \\n        while left <= right:\\n            mid = left + (right - left) // 2\\n            if A[mid] == target: return mid\\n            \\n            # inflection point to the right. Left is strictly increasing\\n            if A[mid] >= A[left]:\\n                if A[left] <= target < A[mid]:\\n                    right = mid - 1\\n                else:\\n                    left = mid + 1\\n                    \\n            # inflection point to the left of me. Right is strictly increasing\\n            else:\\n                if A[mid] < target <= A[right]:\\n                    left = mid + 1\\n                else:\\n                    right = mid - 1\\n            \\n        return -1\\n```\\n",
                "solutionTags": [
                    "Python",
                    "Binary Tree"
                ],
                "code": "```\\nclass Solution:\\n    def search(self, A: List[int], target: int) -> int:\\n        n = len(A)\\n        left, right = 0, n - 1\\n        if n == 0: return -1\\n        \\n        while left <= right:\\n            mid = left + (right - left) // 2\\n            if A[mid] == target: return mid\\n            \\n            # inflection point to the right. Left is strictly increasing\\n            if A[mid] >= A[left]:\\n                if A[left] <= target < A[mid]:\\n                    right = mid - 1\\n                else:\\n                    left = mid + 1\\n                    \\n            # inflection point to the left of me. Right is strictly increasing\\n            else:\\n                if A[mid] < target <= A[right]:\\n                    left = mid + 1\\n                else:\\n                    right = mid - 1\\n            \\n        return -1\\n```",
                "codeTag": "Java"
            },
            {
                "id": 14419,
                "title": "pretty-short-c-java-ruby-python",
                "content": "Explanation below the codes.\\n\\n**Ruby:**\\n\\n    def search(nums, target)\\n      i = (0...nums.size).bsearch { |i|\\n        (nums[0] <= target) ^ (nums[0] > nums[i]) ^ (target > nums[i])\\n      }\\n      nums[i || 0] == target ? i : -1\\n    end\\n\\n**Ruby Golf**, just once for fun:\\n\\n    def search(n, t)\\n      i=(0...n.size).bsearch{|i|(n[0]<=t)^(n[0]>n[i])^(t>n[i])};n[i||0]==t ?i:-1\\n    end\\n\\n**Python:**\\n\\n    def search(self, nums, target):\\n        lo, hi = 0, len(nums) - 1\\n        while lo < hi:\\n            mid = (lo + hi) / 2\\n            if (nums[0] > target) ^ (nums[0] > nums[mid]) ^ (target > nums[mid]):\\n                lo = mid + 1\\n            else:\\n                hi = mid\\n        return lo if target in nums[lo:lo+1] else -1\\n\\n**Python using `bisect`:**\\n\\n    class Solution:\\n        def search(self, nums, target):\\n            self.__getitem__ = lambda i: \\\\\\n                (nums[0] <= target) ^ (nums[0] > nums[i]) ^ (target > nums[i])\\n            i = bisect.bisect_left(self, True, 0, len(nums))\\n            return i if target in nums[i:i+1] else -1\\n\\n**C++:**\\n\\n    int search(vector<int>& nums, int target) {\\n        int lo = 0, hi = int(nums.size()) - 1;\\n        while (lo < hi) {\\n            int mid = (lo + hi) / 2;\\n            if ((nums[0] > target) ^ (nums[0] > nums[mid]) ^ (target > nums[mid]))\\n                lo = mid + 1;\\n            else\\n                hi = mid;\\n        }\\n        return lo == hi && nums[lo] == target ? lo : -1;\\n    }\\n\\n**Java:**\\n\\n    public int search(int[] nums, int target) {\\n        int lo = 0, hi = nums.length - 1;\\n        while (lo < hi) {\\n            int mid = (lo + hi) / 2;\\n            if ((nums[0] > target) ^ (nums[0] > nums[mid]) ^ (target > nums[mid]))\\n                lo = mid + 1;\\n            else\\n                hi = mid;\\n        }\\n        return lo == hi && nums[lo] == target ? lo : -1;\\n    }\\n\\n---\\n\\nExplanation\\n-\\n\\nMy solutions use binary search guided by the following thoughts:\\n\\nRemember the array is sorted, except it might drop at one point.\\n\\n- **If nums[0] <= nums[i]**, then nums[0..i] is sorted (in case of \"**==**\" it's just one element, and in case of \"**<**\" there must be a drop elsewhere). So we should keep searching in nums[0..i] if the target lies in this sorted range, i.e., if `nums[0] <= target <= nums[i]`.\\n\\n- **If nums[i] < nums[0]**, then nums[0..i] contains a drop, and thus nums[i+1..end] is sorted and lies strictly between nums[i] and nums[0]. So we should keep searching in nums[0..i] if the target *doesn't* lie strictly between them, i.e., if `target <= nums[i] < nums[0]` or `nums[i] < nums[0] <= target`\\n\\nThose three cases look cyclic:\\n\\n        nums[0] <= target <= nums[i]\\n                   target <= nums[i] < nums[0]\\n                             nums[i] < nums[0] <= target\\n\\nSo I have the three checks `(nums[0] <= target)`, `(target <= nums[i])` and `(nums[i] < nums[0])`, and I want to know whether exactly two of them are true. They can't all be true or all be false (check it), so I just need to distinguish between \"two true\" and \"one true\". Parity is enough for that, so instead of adding them I xor them, which is a bit shorter and particularly helpful in Java and Ruby, because those don't let me add booleans but do let me xor them.\\n\\n(Actually while developing this I thought of permutations of nums[0], target and nums[i] and the permutation parity and saw those three checks as representing inversions, but I had trouble putting that into words and now find the above explanation much better. But it helped me get there, so I wanted to mention it here.)",
                "solutionTags": [
                    "C++",
                    "Java",
                    "Python"
                ],
                "code": "class Solution:\\n        def search(self, nums, target):\\n            self.__getitem__ = lambda i: \\\\\\n                (nums[0] <= target) ^ (nums[0] > nums[i]) ^ (target > nums[i])\\n            i = bisect.bisect_left(self, True, 0, len(nums))\\n            return i if target in nums[i:i+1] else -1\\n\\n**C++:**\\n\\n    int search(vector<int>& nums, int target) {\\n        int lo = 0, hi = int(nums.size()) - 1;\\n        while (lo < hi) {\\n            int mid = (lo + hi) / 2;\\n            if ((nums[0] > target) ^ (nums[0] > nums[mid]) ^ (target > nums[mid]))\\n                lo = mid + 1;\\n            else\\n                hi = mid;\\n        }",
                "codeTag": "Java"
            },
            {
                "id": 3283609,
                "title": "easy-to-understand-c-100-beats",
                "content": "\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\nThe function search takes in a vector nums representing the rotated sorted array and an integer target that we need to find.\\nIt initializes the variables left and right to the start and end indices of the array, respectively.\\nThe variable mid is calculated as the middle index of the array using the formula (left + right) / 2.\\nThe while loop is executed as long as the left pointer is less than or equal to the right pointer. This ensures that the search space is not empty.\\nInside the while loop, we check if the middle element nums[mid] is equal to the target. If it is, we return the index mid.\\nIf the middle element is greater than or equal to the left element, it means the left part of the array is non-rotated.\\nWe then check if the target is within the range of the left non-rotated part. If it is, we update the right pointer to mid - 1 to search in the left part.\\nIf the target is not within the range, we update the left pointer to mid + 1 to search in the right part.\\nIf the middle element is less than the left element, it means the right part of the array is rotated.\\nWe then check if the target is within the range of the right rotated part. If it is, we update the left pointer to mid + 1 to search in the right part.\\nIf the target is not within the range, we update the right pointer to mid - 1 to search in the left part.\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\nO(log n)\\n\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->O(1)\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int search(vector<int>& nums, int target) {\\n     int n = nums.size();\\n      int left = 0;\\n      int right = n-1;\\n      int mid= left + (right - left) / 2;\\n      while(left <= right){\\n        if(nums[mid] == target)\\n         return mid;\\n        if(nums[mid] >= nums[left]) {\\n          if(target >= nums[left] && target <= nums[mid])\\n            {\\n                right = mid - 1;\\n            }\\n           else left = mid + 1;\\n        } \\n        else {\\n          if(target >= nums[mid] && target <= nums[right]) \\n            left = mid + 1;\\n          else right = mid - 1;\\n        }\\n          mid = left + (right - left) / 2;\\n      }\\n      return -1;\\n    }\\n};\\n```\\n![upvote 1.jpeg](https://assets.leetcode.com/users/images/c8840309-29a1-4863-bf1b-90c2f8bd1387_1678528531.5008342.jpeg)\\n\\n\\n\\n",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int search(vector<int>& nums, int target) {\\n     int n = nums.size();\\n      int left = 0;\\n      int right = n-1;\\n      int mid= left + (right - left) / 2;\\n      while(left <= right){\\n        if(nums[mid] == target)\\n         return mid;\\n        if(nums[mid] >= nums[left]) {\\n          if(target >= nums[left] && target <= nums[mid])\\n            {\\n                right = mid - 1;\\n            }\\n           else left = mid + 1;\\n        } \\n        else {\\n          if(target >= nums[mid] && target <= nums[right]) \\n            left = mid + 1;\\n          else right = mid - 1;\\n        }\\n          mid = left + (right - left) / 2;\\n      }\\n      return -1;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 427469,
                "title": "c-very-easy-to-understand-100-faster-binary-search-solution",
                "content": "**PSUEDOCODE**\\n1) Find middle point mid = (l + h)/2\\n2) If key is present at middle point, return mid.\\n3) Else If arr[l..mid] is sorted\\n    a) If key to be searched lies in range from arr[l]\\n       to arr[mid], recur for arr[l..mid].\\n    b) Else recur for arr[mid+1..h]\\n4) Else (arr[mid+1..h] must be sorted)\\n    a) If key to be searched lies in range from arr[mid+1]\\n       to arr[h], recur for arr[mid+1..h].\\n    b) Else recur for arr[l..mid] \\n**PS:** The psuedocode is taken from geeksfor geeks to help someone reading understand better, But code is mine!!\\n```\\nint beg=0,end=nums.size()-1,mid;\\n        while(beg<=end)\\n        {\\n            mid=(beg+end)/2;\\n            if(nums[mid]==target)\\n                return mid;\\n            if(nums[beg]<=nums[mid])\\n            {\\n                if(target<=nums[mid] && target>=nums[beg])\\n                    end=mid-1;\\n                else\\n                    beg=mid+1;\\n            }\\n            \\n            else\\n            {\\n                if(target>=nums[mid] && target<=nums[end])\\n                   beg=mid+1;\\n                else\\n                    end=mid-1;\\n            }\\n            \\n        }\\n        return -1;\\n    }\\n```",
                "solutionTags": [
                    "C++",
                    "C",
                    "Binary Search",
                    "Binary Tree"
                ],
                "code": "```\\nint beg=0,end=nums.size()-1,mid;\\n        while(beg<=end)\\n        {\\n            mid=(beg+end)/2;\\n            if(nums[mid]==target)\\n                return mid;\\n            if(nums[beg]<=nums[mid])\\n            {\\n                if(target<=nums[mid] && target>=nums[beg])\\n                    end=mid-1;\\n                else\\n                    beg=mid+1;\\n            }\\n            \\n            else\\n            {\\n                if(target>=nums[mid] && target<=nums[end])\\n                   beg=mid+1;\\n                else\\n                    end=mid-1;\\n            }\\n            \\n        }\\n        return -1;\\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2690820,
                "title": "efficient-approach-modified-binary-search",
                "content": "![image](https://assets.leetcode.com/users/images/b652beed-4dbf-4e9c-b10a-bcf7d81ada74_1666416201.2681432.png)\\n\\n```\\n/* This is always possible when we are at mid either left half is sorted or right haldf is sorted */\\nclass Solution {\\npublic:\\n    int search(vector<int>& arr, int target) {\\n        int n = arr.size();\\n        int low = 0, high = n-1;\\n        long int mid = -1;\\n        while(low <= high){\\n            mid = low + (high-low)/2;\\n            if(arr[mid] == target) return  mid;\\n            if(arr[mid] >= arr[low]){\\n                /* left half sorted */\\n                if(target >= arr[low] && target < arr[mid]) high = mid-1;\\n                else low = mid+1;\\n            }\\n            else{\\n                /* right half is sorted */\\n                if( target > arr[mid] && target <= arr[high]) low = mid+1;\\n                else high = mid-1;\\n            }\\n        }\\n        return -1;\\n    }\\n};\\n/*  If you like the solution please upvote thanku*/\\n```\\n\\nIf you like the solution please upvote thanku",
                "solutionTags": [
                    "Java",
                    "C",
                    "Binary Search Tree"
                ],
                "code": "```\\n/* This is always possible when we are at mid either left half is sorted or right haldf is sorted */\\nclass Solution {\\npublic:\\n    int search(vector<int>& arr, int target) {\\n        int n = arr.size();\\n        int low = 0, high = n-1;\\n        long int mid = -1;\\n        while(low <= high){\\n            mid = low + (high-low)/2;\\n            if(arr[mid] == target) return  mid;\\n            if(arr[mid] >= arr[low]){\\n                /* left half sorted */\\n                if(target >= arr[low] && target < arr[mid]) high = mid-1;\\n                else low = mid+1;\\n            }\\n            else{\\n                /* right half is sorted */\\n                if( target > arr[mid] && target <= arr[high]) low = mid+1;\\n                else high = mid-1;\\n            }\\n        }\\n        return -1;\\n    }\\n};\\n/*  If you like the solution please upvote thanku*/\\n```",
                "codeTag": "Java"
            },
            {
                "id": 14601,
                "title": "java-intuitive-closest-to-unflavored-binary-search",
                "content": "I have looked at popular solutions like [this][1], [this][2] and [this][3] , and found that the top-level logic is not consistent with binary search, because they compare nums[left] or nums[right] against nums[mid], instead of against target.\\n\\nIf we keep the logic of binary search, and just checking monotonicity inside the if block, the logic will be closest to unflavored binary search. Easier to understand and connect to binary search.\\n\\n\\n    public int search(int[] nums, int target) {\\n        int left = 0;\\n        int right = nums.length - 1;\\n        while (left <= right) {\\n            int mid = left + (right - left) / 2;\\n            if (nums[mid] == target) {\\n                return mid;\\n            } else if (nums[mid] > target) {\\n                // the left half is monotonic, yet still does not satisfy\\n                if (nums[left] <= nums[mid] && nums[left] > target) { \\n                    left = mid + 1;\\n                } else {\\n                    right = mid - 1;\\n                }\\n            } else {\\n                // the right half is monotonic, yet still does not satisfy\\n                if (nums[right] >= nums[mid] && nums[right] < target) { \\n                    right = mid - 1;\\n                } else {\\n                    left = mid + 1;\\n                }\\n            }\\n        }\\n        return -1;\\n    }\\n\\n\\n  [1]: https://leetcode.com/discuss/41134/java-ac-solution-using-once-binary-search\\n  [2]: https://leetcode.com/discuss/25389/binary-search-java-solusion-o-log-n\\n  [3]: https://leetcode.com/discuss/22678/revised-binary-search",
                "solutionTags": [
                    "Binary Tree"
                ],
                "code": "I have looked at popular solutions like [this][1], [this][2] and [this][3] , and found that the top-level logic is not consistent with binary search, because they compare nums[left] or nums[right] against nums[mid], instead of against target.\\n\\nIf we keep the logic of binary search, and just checking monotonicity inside the if block, the logic will be closest to unflavored binary search. Easier to understand and connect to binary search.\\n\\n\\n    public int search(int[] nums, int target) {\\n        int left = 0;\\n        int right = nums.length - 1;\\n        while (left <= right) {\\n            int mid = left + (right - left) / 2;\\n            if (nums[mid] == target) {\\n                return mid;\\n            } else if (nums[mid] > target) {\\n                // the left half is monotonic, yet still does not satisfy\\n                if (nums[left] <= nums[mid] && nums[left] > target) { \\n                    left = mid + 1;\\n                } else {\\n                    right = mid - 1;\\n                }\\n            } else {\\n                // the right half is monotonic, yet still does not satisfy\\n                if (nums[right] >= nums[mid] && nums[right] < target) { \\n                    right = mid - 1;\\n                } else {\\n                    left = mid + 1;\\n                }\\n            }\\n        }\\n        return -1;\\n    }\\n\\n\\n  [1]: https://leetcode.com/discuss/41134/java-ac-solution-using-once-binary-search\\n  [2]: https://leetcode.com/discuss/25389/binary-search-java-solusion-o-log-n\\n  [3]: https://leetcode.com/discuss/22678/revised-binary-search",
                "codeTag": "Unknown"
            },
            {
                "id": 3416630,
                "title": "c-java-python-javascript-fully-explained-binary-search",
                "content": "# Intuition:\\nThe given problem asks us to find the index of the target element in the given rotated sorted array.\\n\\n# Approach:\\n- The solution provided in the code implements two approaches, Brute force and Binary search.\\n\\n    - The Brute force approach: \\n        1. Iterates through the array and checks if the current element is equal to the target. If it is, then it returns the index of that element, otherwise, it returns -1. This approach has a time complexity of O(n).\\n\\n    - The Binary search approach is based on the fact that a rotated sorted array can be divided into two sorted arrays.\\n        1. The approach starts with finding the mid element and compares it with the target element. \\n        2. If they are equal, it returns the mid index. If the left half of the array is sorted, then it checks if the target lies between the start and the mid, and updates the end pointer accordingly. \\n        3. Otherwise, it checks if the target lies between mid and end, and updates the start pointer accordingly. \\n        4. If the right half of the array is sorted, then it checks if the target lies between mid and end, and updates the start pointer accordingly. \\n        5. Otherwise, it checks if the target lies between start and mid, and updates the end pointer accordingly. \\n        6. This process continues until the target element is found, or the start pointer becomes greater than the end pointer, in which case it returns -1. \\n        7. This approach has a time complexity of O(log n).\\n\\n# Complexity:\\n\\n- Time Complexity:\\n    1. The time complexity of the Brute force approach is O(n), where n is the size of the input array.\\n    2. The time complexity of the Binary search approach is O(log n), where n is the size of the input array.\\n\\n- Space Complexity:\\nThe space complexity of both approaches is O(1) as we are not using any extra space to store any intermediate results.\\n\\n---\\n\\n\\n# Code:  C++\\n## Brute Force:\\n```\\nclass Solution {\\npublic:\\n    int search(vector<int>& nums, int target) {\\n        for(int i=0;i<nums.size();i++){\\n            if(target==nums[i]){\\n                return i;\\n            }\\n        }\\n        return -1;\\n    }\\n};\\n```\\n## Binary Search:\\n```\\nclass Solution {\\npublic:\\n    int search(vector<int>& nums, int target) {\\n        int start=0,end=nums.size()-1;\\n        int mid= (start+end)/2;\\n        while(start<=end){\\n            mid=(start+end)/2;\\n            if(target==nums[mid]){\\n                return mid;\\n            }\\n            if(nums[start]<=nums[mid]){\\n                if(nums[start]<=target && nums[mid]>=target){\\n                    end=mid-1;\\n                }\\n                else{\\n                    start=mid+1;\\n                }\\n            }\\n            else{\\n                if(nums[end]>=target && nums[mid]<=target){\\n                    start=mid+1;\\n                }\\n                else{\\n                    end=mid-1;\\n                }\\n            }\\n        }\\n        return -1;\\n    }\\n};\\n\\n```\\n\\n---\\n\\n# Code: Java\\n## Binary Search:\\n```\\nclass Solution {\\n    public int search(int[] nums, int target) {\\n        int start = 0, end = nums.length - 1;\\n        int mid = (start + end) / 2;\\n        while (start <= end) {\\n            mid = (start + end) / 2;\\n            if (target == nums[mid]) {\\n                return mid;\\n            }\\n            if (nums[start] <= nums[mid]) {\\n                if (nums[start] <= target && nums[mid] >= target) {\\n                    end = mid - 1;\\n                } else {\\n                    start = mid + 1;\\n                }\\n            } else {\\n                if (nums[end] >= target && nums[mid] <= target) {\\n                    start = mid + 1;\\n                } else {\\n                    end = mid - 1;\\n                }\\n            }\\n        }\\n        return -1;\\n    }\\n}\\n\\n```\\n\\n---\\n\\n# Code: Python\\n## Binary Search:\\n```\\nclass Solution:\\n    def search(self, nums, target):\\n        start, end = 0, len(nums) - 1\\n        mid = (start + end) / 2\\n        while start <= end:\\n            mid = (start + end) / 2\\n            if target == nums[mid]:\\n                return mid\\n            if nums[start] <= nums[mid]:\\n                if nums[start] <= target and nums[mid] >= target:\\n                    end = mid - 1\\n                else:\\n                    start = mid + 1\\n            else:\\n                if nums[end] >= target and nums[mid] <= target:\\n                    start = mid + 1\\n                else:\\n                    end = mid - 1\\n        return -1\\n\\n```\\n\\n---\\n\\n# Code: JavaScript\\n## Binary Search:\\n```\\nvar search = function(nums, target) {\\n    let start = 0, end = nums.length - 1;\\n    let mid = Math.floor((start + end) / 2);\\n    while (start <= end) {\\n        mid = Math.floor((start + end) / 2);\\n        if (target === nums[mid]) {\\n            return mid;\\n        }\\n        if (nums[start] <= nums[mid]) {\\n            if (nums[start] <= target && nums[mid] >= target) {\\n                end = mid - 1;\\n            } else {\\n                start = mid + 1;\\n            }\\n        } else {\\n            if (nums[end] >= target && nums[mid] <= target) {\\n                start = mid + 1;\\n            } else {\\n                end = mid - 1;\\n            }\\n        }\\n    }\\n    return -1;\\n}\\n\\n```\\n> # ***Thanks For Voting***\\n",
                "solutionTags": [
                    "C++",
                    "Java",
                    "Python",
                    "JavaScript",
                    "Binary Search"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int search(vector<int>& nums, int target) {\\n        for(int i=0;i<nums.size();i++){\\n            if(target==nums[i]){\\n                return i;\\n            }\\n        }\\n        return -1;\\n    }\\n};\\n```\n```\\nclass Solution {\\npublic:\\n    int search(vector<int>& nums, int target) {\\n        int start=0,end=nums.size()-1;\\n        int mid= (start+end)/2;\\n        while(start<=end){\\n            mid=(start+end)/2;\\n            if(target==nums[mid]){\\n                return mid;\\n            }\\n            if(nums[start]<=nums[mid]){\\n                if(nums[start]<=target && nums[mid]>=target){\\n                    end=mid-1;\\n                }\\n                else{\\n                    start=mid+1;\\n                }\\n            }\\n            else{\\n                if(nums[end]>=target && nums[mid]<=target){\\n                    start=mid+1;\\n                }\\n                else{\\n                    end=mid-1;\\n                }\\n            }\\n        }\\n        return -1;\\n    }\\n};\\n\\n```\n```\\nclass Solution {\\n    public int search(int[] nums, int target) {\\n        int start = 0, end = nums.length - 1;\\n        int mid = (start + end) / 2;\\n        while (start <= end) {\\n            mid = (start + end) / 2;\\n            if (target == nums[mid]) {\\n                return mid;\\n            }\\n            if (nums[start] <= nums[mid]) {\\n                if (nums[start] <= target && nums[mid] >= target) {\\n                    end = mid - 1;\\n                } else {\\n                    start = mid + 1;\\n                }\\n            } else {\\n                if (nums[end] >= target && nums[mid] <= target) {\\n                    start = mid + 1;\\n                } else {\\n                    end = mid - 1;\\n                }\\n            }\\n        }\\n        return -1;\\n    }\\n}\\n\\n```\n```\\nclass Solution:\\n    def search(self, nums, target):\\n        start, end = 0, len(nums) - 1\\n        mid = (start + end) / 2\\n        while start <= end:\\n            mid = (start + end) / 2\\n            if target == nums[mid]:\\n                return mid\\n            if nums[start] <= nums[mid]:\\n                if nums[start] <= target and nums[mid] >= target:\\n                    end = mid - 1\\n                else:\\n                    start = mid + 1\\n            else:\\n                if nums[end] >= target and nums[mid] <= target:\\n                    start = mid + 1\\n                else:\\n                    end = mid - 1\\n        return -1\\n\\n```\n```\\nvar search = function(nums, target) {\\n    let start = 0, end = nums.length - 1;\\n    let mid = Math.floor((start + end) / 2);\\n    while (start <= end) {\\n        mid = Math.floor((start + end) / 2);\\n        if (target === nums[mid]) {\\n            return mid;\\n        }\\n        if (nums[start] <= nums[mid]) {\\n            if (nums[start] <= target && nums[mid] >= target) {\\n                end = mid - 1;\\n            } else {\\n                start = mid + 1;\\n            }\\n        } else {\\n            if (nums[end] >= target && nums[mid] <= target) {\\n                start = mid + 1;\\n            } else {\\n                end = mid - 1;\\n            }\\n        }\\n    }\\n    return -1;\\n}\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 14443,
                "title": "c-4-lines-4ms",
                "content": "    int search(vector<int>& nums, int target) \\n    {\\n            auto skip_left  = [&]( int x) { return x >= nums[0] ? numeric_limits<int>::min() : x; };\\n            auto skip_right = [&] (int x) { return x < nums[0] ? numeric_limits<int>::max() : x; };\\n            auto adjust = [&] (int x) { return target < nums[0] ? skip_left(x) : skip_right(x); };\\n      \\n            auto it = lower_bound( nums.begin(), nums.end(), target, [&] (int x, int y) { return adjust(x) < adjust(y); } );\\n                \\n            return it != nums.end() && *it == target ? it-nums.begin() : -1;\\n    }\\n\\n\\n\\nYou are not expected to understand that :)",
                "solutionTags": [],
                "code": "    int search(vector<int>& nums, int target) \\n    {\\n            auto skip_left  = [&]( int x) { return x >= nums[0] ? numeric_limits<int>::min() : x; };\\n            auto skip_right = [&] (int x) { return x < nums[0] ? numeric_limits<int>::max() : x; };\\n            auto adjust = [&] (int x) { return target < nums[0] ? skip_left(x) : skip_right(x); };\\n      \\n            auto it = lower_bound( nums.begin(), nums.end(), target, [&] (int x, int y) { return adjust(x) < adjust(y); } );\\n                \\n            return it != nums.end() && *it == target ? it-nums.begin() : -1;\\n    }\\n\\n\\n\\nYou are not expected to understand that :)",
                "codeTag": "Unknown"
            },
            {
                "id": 1369541,
                "title": "c-binary-search-logic-explanation",
                "content": "## Logic Explanation:\\n* **Core Observation** - As we are are given a sorted and rotated array, it is guranteed that ***either 1/2 of the array is going to be sorted*** (If you aren\\'t getting this try taking different combinations of provided example array)\\n* Now our first job is to find that sorted half. To do this we can do a simple comparison of mid (```mid = (low+high)/2```) element with the starting element (```low```) of the array. \\n* Comparison (do this with pen and paper in hand)\\n\\t* ```if(nums[mid] >= nums[low])``` -> the left half of array is sorted.\\n\\t* ```else```  -> the right half of array is sorted.\\n* Now if left half of array is sorted:\\n\\t* check if provided ```target``` element lies in the range ```[low, mid)```.\\n\\t* If it does then update ```high = mid-1``` (hence skipping the part present on right of mid). \\n\\t* else update ```low = mid+1``` (hence skipping the part present on left of mid)\\n* else as the right array is sorted:\\n\\t* check if provided ```target``` element lies in the range ```(mid, high]```.\\n\\t* If it does then update ```low = mid+1``` (hence skipping the part present on left of mid). \\n\\t* else update ```high = mid-1``` (hence skipping the part present on right of mid)\\n* If still not found then ```return -1``` (duh!)\\n```\\nint search(vector<int>& nums, int target) {\\n        int low=0,high=nums.size()-1;\\n        while(low<=high){\\n            int mid = (low+high)/2;\\n            if(nums[mid]==target) return mid;\\n            \\n            if(nums[mid]>=nums[low]){\\n                //left half is sorted\\n                if(target>=nums[low] && target<nums[mid])\\n                    high = mid-1;\\n                else\\n                    low = mid+1;\\n            }\\n            else{\\n                //right half is sorted\\n                if(target>nums[mid] && target<=nums[high])\\n                    low = mid+1;\\n                else\\n                    high = mid-1;\\n            }\\n        }\\n        return -1;\\n    }\\n```\\nHapping coding :)",
                "solutionTags": [
                    "C"
                ],
                "code": "```mid = (low+high)/2```\n```low```\n```if(nums[mid] >= nums[low])```\n```else```\n```target```\n```[low, mid)```\n```high = mid-1```\n```low = mid+1```\n```target```\n```(mid, high]```\n```low = mid+1```\n```high = mid-1```\n```return -1```\n```\\nint search(vector<int>& nums, int target) {\\n        int low=0,high=nums.size()-1;\\n        while(low<=high){\\n            int mid = (low+high)/2;\\n            if(nums[mid]==target) return mid;\\n            \\n            if(nums[mid]>=nums[low]){\\n                //left half is sorted\\n                if(target>=nums[low] && target<nums[mid])\\n                    high = mid-1;\\n                else\\n                    low = mid+1;\\n            }\\n            else{\\n                //right half is sorted\\n                if(target>nums[mid] && target<=nums[high])\\n                    low = mid+1;\\n                else\\n                    high = mid-1;\\n            }\\n        }\\n        return -1;\\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1350076,
                "title": "c-python-binary-search-clean-concise",
                "content": "**Idea**\\n- Please note that, this binary search only works when all elements in the array are distict.\\n- Binary search to find the pivot index, which is the index of the minimum element, exactly same with [153. Find Minimum in Rotated Sorted Array](https://leetcode.com/problems/find-minimum-in-rotated-sorted-array/discuss/1436502)\\n- Then binary search to search the `target` in two increasing subarrays `[0..pivot-1]` and `[pivot...n-1]`.\\n<iframe src=\"https://leetcode.com/playground/n6K4c8SR/shared\" frameBorder=\"0\" width=\"100%\" height=\"650\"></iframe>\\n\\nComplexity:\\n- Time: `O(logN)`, where `N` is length of `nums` array.\\n- Space: `O(1)`",
                "solutionTags": [],
                "code": "**Idea**\\n- Please note that, this binary search only works when all elements in the array are distict.\\n- Binary search to find the pivot index, which is the index of the minimum element, exactly same with [153. Find Minimum in Rotated Sorted Array](https://leetcode.com/problems/find-minimum-in-rotated-sorted-array/discuss/1436502)\\n- Then binary search to search the `target` in two increasing subarrays `[0..pivot-1]` and `[pivot...n-1]`.\\n<iframe src=\"https://leetcode.com/playground/n6K4c8SR/shared\" frameBorder=\"0\" width=\"100%\" height=\"650\"></iframe>\\n\\nComplexity:\\n- Time: `O(logN)`, where `N` is length of `nums` array.\\n- Space: `O(1)`",
                "codeTag": "Unknown"
            },
            {
                "id": 14608,
                "title": "c-binary-search-solution",
                "content": "        \\n    int search(vector<int>& nums, int target) {\\n        int l = 0, r = nums.size()-1;\\n        while (l<=r) {\\n            int mid = (r-l)/2+l;\\n            if (nums[mid] == target)\\n                return mid;\\n            if (nums[mid] < nums[r]) {\\n                if (nums[mid]<target && target<=nums[r])\\n                    l = mid+1;\\n                else\\n                    r = mid-1;\\n            } else {\\n                if(nums[l]<=target && target<nums[mid])\\n                    r = mid-1;\\n                else\\n                    l = mid+1;\\n            }\\n        }\\n        return -1;\\n    }",
                "solutionTags": [
                    "C++",
                    "Binary Tree"
                ],
                "code": "        \\n    int search(vector<int>& nums, int target) {\\n        int l = 0, r = nums.size()-1;\\n        while (l<=r) {\\n            int mid = (r-l)/2+l;\\n            if (nums[mid] == target)\\n                return mid;\\n            if (nums[mid] < nums[r]) {\\n                if (nums[mid]<target && target<=nums[r])\\n                    l = mid+1;\\n                else\\n                    r = mid-1;\\n            } else {\\n                if(nums[l]<=target && target<nums[mid])\\n                    r = mid-1;\\n                else\\n                    l = mid+1;\\n            }\\n        }\\n        return -1;\\n    }",
                "codeTag": "Unknown"
            },
            {
                "id": 1739104,
                "title": "c-binary-search-approach-0ms",
                "content": "Kindly **upvote**, if you find it helpful : )\\n\\n![image](https://assets.leetcode.com/users/images/2de76340-7386-457c-b049-e96982ad8d53_1643800067.1715698.jpeg)\\n\\nImplementation in C++:\\n\\n```\\nclass Solution {\\npublic:\\n    \\n    int getPivot(vector<int>& nums, int n){\\n        int s = 0;\\n        int e = n-1;\\n        int m = s + (e-s)/2;\\n        while(s < e){\\n            if(nums[m] >= nums[0]){\\n                s = m+1;\\n            }\\n            else{\\n                e = m;\\n            }\\n            m = s + (e-s)/2;\\n        }\\n        return s;\\n    }\\n    \\n    int binarySearch(vector<int>& nums, int s, int e, int target){\\n        int m = s + (e-s)/2;\\n        while(s <= e){\\n            if(nums[m]== target){\\n                return m;\\n            }\\n            else if(nums[m]< target){\\n                s = m+1;\\n            }\\n            else{\\n                e = m-1;\\n            }\\n            m = s + (e-s)/2;\\n        }\\n        return -1;\\n    }\\n    \\n    int search(vector<int>& nums, int target) {\\n        int n = nums.size();\\n        int pivot = getPivot(nums, n);\\n        if(target >= nums[pivot] && target <= nums[n-1]){\\n            return binarySearch(nums, pivot, n-1, target);\\n        }\\n        else{\\n            return binarySearch(nums, 0, pivot-1, target);\\n        }\\n    }\\n    \\n};\\n\\n```\\n",
                "solutionTags": [
                    "C",
                    "Binary Tree"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    \\n    int getPivot(vector<int>& nums, int n){\\n        int s = 0;\\n        int e = n-1;\\n        int m = s + (e-s)/2;\\n        while(s < e){\\n            if(nums[m] >= nums[0]){\\n                s = m+1;\\n            }\\n            else{\\n                e = m;\\n            }\\n            m = s + (e-s)/2;\\n        }\\n        return s;\\n    }\\n    \\n    int binarySearch(vector<int>& nums, int s, int e, int target){\\n        int m = s + (e-s)/2;\\n        while(s <= e){\\n            if(nums[m]== target){\\n                return m;\\n            }\\n            else if(nums[m]< target){\\n                s = m+1;\\n            }\\n            else{\\n                e = m-1;\\n            }\\n            m = s + (e-s)/2;\\n        }\\n        return -1;\\n    }\\n    \\n    int search(vector<int>& nums, int target) {\\n        int n = nums.size();\\n        int pivot = getPivot(nums, n);\\n        if(target >= nums[pivot] && target <= nums[n-1]){\\n            return binarySearch(nums, pivot, n-1, target);\\n        }\\n        else{\\n            return binarySearch(nums, 0, pivot-1, target);\\n        }\\n    }\\n    \\n};\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 14572,
                "title": "share-my-pretty-neat-java-bs-solution",
                "content": "I had different versions for this problem and read several other people's solutions and I came up with this neat solution. I want to share it here and hope you like it. The idea is to compare the middle element with the left element to decide which part is in order.\\n\\n    public int search(int[] nums, int target) {\\n        if (nums == null || nums.length == 0) return -1;\\n        int l = 0, r = nums.length - 1;\\n        while (l < r) {\\n            int m = l + (r - l) / 2;\\n            if (nums[m] >= nums[l]) {\\n                if (target <= nums[m] && target >= nums[l]) r = m;\\n                else l = m + 1;\\n            } else {\\n                if (target > nums[m] && target <= nums[r]) l = m + 1;\\n                else r = m;\\n            }\\n        }\\n        return nums[l] == target ? l : -1;\\n    }",
                "solutionTags": [
                    "Java"
                ],
                "code": "I had different versions for this problem and read several other people's solutions and I came up with this neat solution. I want to share it here and hope you like it. The idea is to compare the middle element with the left element to decide which part is in order.\\n\\n    public int search(int[] nums, int target) {\\n        if (nums == null || nums.length == 0) return -1;\\n        int l = 0, r = nums.length - 1;\\n        while (l < r) {\\n            int m = l + (r - l) / 2;\\n            if (nums[m] >= nums[l]) {\\n                if (target <= nums[m] && target >= nums[l]) r = m;\\n                else l = m + 1;\\n            } else {\\n                if (target > nums[m] && target <= nums[r]) l = m + 1;\\n                else r = m;\\n            }\\n        }\\n        return nums[l] == target ? l : -1;\\n    }",
                "codeTag": "Unknown"
            },
            {
                "id": 3347991,
                "title": "100-beats-java-solutions-clean-and-easy-to-understand-code-look-at-once",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n# simple binary search \\n# Complexity\\n- Time complexity: O(logn)\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: O(1)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\n    public int search(int[] nums, int target) {\\n      int start=0;\\n        int end=nums.length-1;\\n        \\n        while(start<=end){\\n        int mid= start+(end-start) /2;\\n        if(nums[mid]==target) return mid;\\n        if(nums[start]<=nums[mid]){\\n            if(target<=nums[mid] && target>=nums[start]){\\n                end=mid-1;\\n            }else{\\n                start=mid+1;\\n            }\\n        }\\n        else{\\n            if(target>=nums[mid] && target<=nums[end]){  \\n                start=mid+1;\\n            }else{\\n                end=mid-1;\\n            }\\n        }\\n        }\\n        return -1;\\n    }\\n    \\n}\\n```\\nplease upvote this for better solution of other questions![download.jfif](https://assets.leetcode.com/users/images/6e20163e-37d4-448f-b574-21bd83baf6cd_1679927244.280445.jpeg)\\n",
                "solutionTags": [
                    "Java",
                    "Two Pointers",
                    "Binary Search"
                ],
                "code": "```\\nclass Solution {\\n    public int search(int[] nums, int target) {\\n      int start=0;\\n        int end=nums.length-1;\\n        \\n        while(start<=end){\\n        int mid= start+(end-start) /2;\\n        if(nums[mid]==target) return mid;\\n        if(nums[start]<=nums[mid]){\\n            if(target<=nums[mid] && target>=nums[start]){\\n                end=mid-1;\\n            }else{\\n                start=mid+1;\\n            }\\n        }\\n        else{\\n            if(target>=nums[mid] && target<=nums[end]){  \\n                start=mid+1;\\n            }else{\\n                end=mid-1;\\n            }\\n        }\\n        }\\n        return -1;\\n    }\\n    \\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 432678,
                "title": "commented-easy-to-understand-simple-binary-search-javascript-submission",
                "content": "**Please do upvote, this motivates me to write better posts\\uD83D\\uDE05**\\n\\n```\\nvar search = function(nums, target) {\\n    let start = 0, end = nums.length - 1;\\n    while(start<end){\\n        let mid = Math.floor((start+end)/2);\\n        if(nums[mid]===target) return mid;\\n//         If the left part is sorted\\n        if(nums[mid]>nums[start]){\\n//             if target lies in the range of left part\\n            if(target>=nums[start] && target<nums[mid]) end = mid-1;\\n            else start = mid+1;\\n        }\\n//         if the right part is sorted\\n        else if(nums[mid]<nums[end]){\\n//             if the target lies in the range of right part\\n            if(target>nums[mid] && target<=nums[end]) start = mid+1;\\n            else end = mid-1;\\n                \\n        }\\n//         otherwise break out of the loop\\n        else break;\\n    }\\n    return nums[end]===target?end:-1;\\n};\\n```",
                "solutionTags": [
                    "JavaScript",
                    "Binary Search"
                ],
                "code": "```\\nvar search = function(nums, target) {\\n    let start = 0, end = nums.length - 1;\\n    while(start<end){\\n        let mid = Math.floor((start+end)/2);\\n        if(nums[mid]===target) return mid;\\n//         If the left part is sorted\\n        if(nums[mid]>nums[start]){\\n//             if target lies in the range of left part\\n            if(target>=nums[start] && target<nums[mid]) end = mid-1;\\n            else start = mid+1;\\n        }\\n//         if the right part is sorted\\n        else if(nums[mid]<nums[end]){\\n//             if the target lies in the range of right part\\n            if(target>nums[mid] && target<=nums[end]) start = mid+1;\\n            else end = mid-1;\\n                \\n        }\\n//         otherwise break out of the loop\\n        else break;\\n    }\\n    return nums[end]===target?end:-1;\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3879488,
                "title": "binary-search-easy-to-understand-code-c-java-python",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nArray is sorted and rotated if we are able to find in which part target is present and also whether it is sorted or not then we can search easily by binary search.\\n\\nFor detailed explanation you can refer to my youtube channel (Hindi Language)\\nhttps://youtu.be/hZOtEvTCAvQ\\n or link in my profile.Here,you can find any solution in playlists monthwise from june 2023 with detailed explanation.i upload daily leetcode solution video with short and precise explanation (5-10) minutes.\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n1. Initialize two pointers `i` and `j` to represent the current search interval, where `i` is the left boundary and `j` is the right boundary.\\n\\n2. Enter a loop that continues as long as `i` is less than or equal to `j`.\\n\\n3. Calculate the middle index `mid` as `i + (j - i) / 2`.\\n\\n4. Check if the element at index `mid` is equal to the target. If it is, return `mid` as the index where the target is found.\\n\\n5. Check if the left part of the interval (from `i` to `mid`) is sorted:\\n\\n   a. If `nums[mid] >= nums[i]`, then the left part is sorted.\\n\\n   b. Check if the target is within the range of values in the left sorted part (`nums[i]` to `nums[mid]`). If yes, update `j = mid - 1` to search in the left part; otherwise, update `i = mid + 1` to search in the right part.\\n\\n6. Check if the right part of the interval (from `mid` to `j`) is sorted:\\n\\n   a. If `nums[mid] <= nums[j]`, then the right part is sorted.\\n\\n   b. Check if the target is within the range of values in the right sorted part (`nums[mid]` to `nums[j]`). If yes, update `i = mid + 1` to search in the right part; otherwise, update `j = mid - 1` to search in the left part.\\n\\n7. If none of the conditions above is satisfied, return `-1` to indicate that the target element is not found in the array.\\n\\n8. After the loop ends (when `i > j`), return `-1` to indicate that the target element is not found in the rotated sorted array.\\n\\n# Complexity\\n- Time complexity:O(log n)\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:O(1)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n``` C++ []\\nclass Solution {\\npublic:\\n    int search(vector<int>& nums, int target) {\\n        int i=0;\\n        int j=nums.size()-1;\\n        while(i<=j){\\n            int mid=i+(j-i)/2;\\n            if(nums[mid]==target){\\n                return mid;\\n            }\\n            else if(nums[mid]>=nums[i]){\\n                if(target>=nums[i]&& target<nums[mid]){\\n                    j=mid-1;\\n                }\\n                else\\n                    i=mid+1;\\n            }\\n            else if(nums[mid]<=nums[j]){\\n                if(target>nums[mid]&&target<=nums[j])\\n                    i=mid+1;\\n                else\\n                j=mid-1;\\n            }\\n        }\\n        return -1;\\n    }\\n};\\n```\\n```java []\\nclass Solution {\\n    public int search(int[] nums, int target) {\\n        int i = 0;\\n        int j = nums.length - 1;\\n        while (i <= j) {\\n            int mid = i + (j - i) / 2;\\n            if (nums[mid] == target) {\\n                return mid;\\n            } else if (nums[mid] >= nums[i]) {\\n                if (target >= nums[i] && target < nums[mid]) {\\n                    j = mid - 1;\\n                } else {\\n                    i = mid + 1;\\n                }\\n            } else if (nums[mid] <= nums[j]) {\\n                if (target > nums[mid] && target <= nums[j]) {\\n                    i = mid + 1;\\n                } else {\\n                    j = mid - 1;\\n                }\\n            }\\n        }\\n        return -1;\\n    }\\n}\\n\\n```\\n```python []\\nclass Solution:\\n    def search(self, nums: List[int], target: int) -> int:\\n        i = 0\\n        j = len(nums) - 1\\n        while i <= j:\\n            mid = i + (j - i) // 2\\n            if nums[mid] == target:\\n                return mid\\n            elif nums[mid] >= nums[i]:\\n                if target >= nums[i] and target < nums[mid]:\\n                    j = mid - 1\\n                else:\\n                    i = mid + 1\\n            elif nums[mid] <= nums[j]:\\n                if target > nums[mid] and target <= nums[j]:\\n                    i = mid + 1\\n                else:\\n                    j = mid - 1\\n        return -1\\n\\n```\\n\\n",
                "solutionTags": [
                    "C++",
                    "Java",
                    "Python",
                    "Array",
                    "Binary Search"
                ],
                "code": "``` C++ []\\nclass Solution {\\npublic:\\n    int search(vector<int>& nums, int target) {\\n        int i=0;\\n        int j=nums.size()-1;\\n        while(i<=j){\\n            int mid=i+(j-i)/2;\\n            if(nums[mid]==target){\\n                return mid;\\n            }\\n            else if(nums[mid]>=nums[i]){\\n                if(target>=nums[i]&& target<nums[mid]){\\n                    j=mid-1;\\n                }\\n                else\\n                    i=mid+1;\\n            }\\n            else if(nums[mid]<=nums[j]){\\n                if(target>nums[mid]&&target<=nums[j])\\n                    i=mid+1;\\n                else\\n                j=mid-1;\\n            }\\n        }\\n        return -1;\\n    }\\n};\\n```\n```java []\\nclass Solution {\\n    public int search(int[] nums, int target) {\\n        int i = 0;\\n        int j = nums.length - 1;\\n        while (i <= j) {\\n            int mid = i + (j - i) / 2;\\n            if (nums[mid] == target) {\\n                return mid;\\n            } else if (nums[mid] >= nums[i]) {\\n                if (target >= nums[i] && target < nums[mid]) {\\n                    j = mid - 1;\\n                } else {\\n                    i = mid + 1;\\n                }\\n            } else if (nums[mid] <= nums[j]) {\\n                if (target > nums[mid] && target <= nums[j]) {\\n                    i = mid + 1;\\n                } else {\\n                    j = mid - 1;\\n                }\\n            }\\n        }\\n        return -1;\\n    }\\n}\\n\\n```\n```python []\\nclass Solution:\\n    def search(self, nums: List[int], target: int) -> int:\\n        i = 0\\n        j = len(nums) - 1\\n        while i <= j:\\n            mid = i + (j - i) // 2\\n            if nums[mid] == target:\\n                return mid\\n            elif nums[mid] >= nums[i]:\\n                if target >= nums[i] and target < nums[mid]:\\n                    j = mid - 1\\n                else:\\n                    i = mid + 1\\n            elif nums[mid] <= nums[j]:\\n                if target > nums[mid] and target <= nums[j]:\\n                    i = mid + 1\\n                else:\\n                    j = mid - 1\\n        return -1\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 14470,
                "title": "python-44ms-solution-binary-search-o-logn",
                "content": "    class Solution:\\n    # @param {integer[]} nums\\n    # @param {integer} target\\n    # @return {integer}\\n    def search(self, nums, target):\\n        if not nums:\\n            return -1\\n        return self.binarySearch(nums, target, 0, len(nums)-1)\\n        \\n    def binarySearch(self, nums, target, start, end):\\n        if end < start:\\n            return -1\\n        mid = (start+end)/2\\n        if nums[mid] == target:\\n            return mid\\n        if nums[start] <= target < nums[mid]: # left side is sorted and has target\\n            return self.binarySearch(nums, target, start, mid-1)\\n        elif nums[mid] < target <= nums[end]: # right side is sorted and has target\\n            return self.binarySearch(nums, target, mid+1, end)\\n        elif nums[mid] > nums[end]: # right side is pivoted\\n            return self.binarySearch(nums, target, mid+1, end)\\n        else: # left side is pivoted\\n            return self.binarySearch(nums, target, start, mid-1)",
                "solutionTags": [
                    "Python",
                    "Binary Tree"
                ],
                "code": "class Solution:\\n    # @param {integer[]}",
                "codeTag": "Java"
            },
            {
                "id": 1349313,
                "title": "accepted-solution-for-swift",
                "content": "```swift\\nclass Solution {\\n    func search(_ n: [Int], _ t: Int) -> Int {\\n        var lhs = 0, rhs = n.count - 1\\n        while lhs <= rhs {\\n            let mid = (rhs - lhs) / 2 + lhs\\n            let val = (l: n[lhs], m: n[mid], r: n[rhs])\\n            if val.m == t { return mid }\\n            func setR() { rhs = mid - 1 }\\n            func setL() { lhs = mid + 1 }\\n            if val.m >= val.l {\\n                val.m > t && t >= val.l ? setR() : setL()\\n            } else {\\n                val.m < t && t <= val.r ? setL() : setR()\\n            }\\n        }\\n        return -1\\n    }\\n}\\n```\\n\\n<hr>\\n\\n<details>\\n<summary><img src=\"https://git.io/JDblm\" height=\"24\"> <b>TEST CASES</b></summary>\\n\\n<pre>\\nResult: Executed 3 tests, with 0 failures (0 unexpected) in 0.007 (0.010) seconds\\n</pre>\\n\\n```swift\\nimport XCTest\\n\\nclass Tests: XCTestCase {\\n    \\n    private let solution = Solution()\\n    \\n    func test0() {\\n        let res = solution.search([4,5,6,7,0,1,2], 0)\\n        XCTAssertEqual(res, 4)\\n    }\\n    \\n    func test1() {\\n        let res = solution.search([4,5,6,7,0,1,2], 3)\\n        XCTAssertEqual(res, -1)\\n    }\\n    \\n    func test2() {\\n        let res = solution.search([1], 0)\\n        XCTAssertEqual(res, -1)\\n    }\\n}\\n\\nTests.defaultTestSuite.run()\\n```\\n\\n</details>",
                "solutionTags": [
                    "Swift"
                ],
                "code": "```swift\\nclass Solution {\\n    func search(_ n: [Int], _ t: Int) -> Int {\\n        var lhs = 0, rhs = n.count - 1\\n        while lhs <= rhs {\\n            let mid = (rhs - lhs) / 2 + lhs\\n            let val = (l: n[lhs], m: n[mid], r: n[rhs])\\n            if val.m == t { return mid }\\n            func setR() { rhs = mid - 1 }\\n            func setL() { lhs = mid + 1 }\\n            if val.m >= val.l {\\n                val.m > t && t >= val.l ? setR() : setL()\\n            } else {\\n                val.m < t && t <= val.r ? setL() : setR()\\n            }\\n        }\\n        return -1\\n    }\\n}\\n```\n```swift\\nimport XCTest\\n\\nclass Tests: XCTestCase {\\n    \\n    private let solution = Solution()\\n    \\n    func test0() {\\n        let res = solution.search([4,5,6,7,0,1,2], 0)\\n        XCTAssertEqual(res, 4)\\n    }\\n    \\n    func test1() {\\n        let res = solution.search([4,5,6,7,0,1,2], 3)\\n        XCTAssertEqual(res, -1)\\n    }\\n    \\n    func test2() {\\n        let res = solution.search([1], 0)\\n        XCTAssertEqual(res, -1)\\n    }\\n}\\n\\nTests.defaultTestSuite.run()\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1183146,
                "title": "python3-solution-using-binary-search-faster-than-98-and-uses-the-least-memory",
                "content": "```\\n#This solution is for the O(logn) complexity.....28ms\\nclass Solution:\\n    def search(self, nums: List[int], target: int) -> int:\\n        left, right = 0, len(nums)-1\\n        while left<=right:\\n            mid = left+(right-left)//2\\n            if nums[mid] == target:\\n                return mid\\n            if nums[mid]<nums[right]:\\n                if nums[mid]<target<=nums[right]:\\n                    left=mid+1\\n                else:\\n                    right=mid-1\\n            else:\\n                if nums[left]<=target<nums[mid]:\\n                    right=mid-1\\n                else:\\n                    left = mid+1\\n        return -1\\n\\n```\\n```\\n#This solution is for the O(n) complexity......32 ms\\nclass Solution:\\n    def search(self, nums: List[int], target: int) -> int:\\n        if target not in nums:\\n            return(-1)\\n        else:\\n            return(nums.index(target)) \\n```\\n",
                "solutionTags": [
                    "Python",
                    "Python3"
                ],
                "code": "```\\n#This solution is for the O(logn) complexity.....28ms\\nclass Solution:\\n    def search(self, nums: List[int], target: int) -> int:\\n        left, right = 0, len(nums)-1\\n        while left<=right:\\n            mid = left+(right-left)//2\\n            if nums[mid] == target:\\n                return mid\\n            if nums[mid]<nums[right]:\\n                if nums[mid]<target<=nums[right]:\\n                    left=mid+1\\n                else:\\n                    right=mid-1\\n            else:\\n                if nums[left]<=target<nums[mid]:\\n                    right=mid-1\\n                else:\\n                    left = mid+1\\n        return -1\\n\\n```\n```\\n#This solution is for the O(n) complexity......32 ms\\nclass Solution:\\n    def search(self, nums: List[int], target: int) -> int:\\n        if target not in nums:\\n            return(-1)\\n        else:\\n            return(nums.index(target)) \\n```",
                "codeTag": "Java"
            },
            {
                "id": 3410249,
                "title": "c-2-approaches-easy-linear-binary-o-logn",
                "content": "\\n```# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    /****************************** LINEAR APPROACH  ******************************/\\n    /*\\n    int search(vector<int>& nums, int target) {\\n        int n = nums.size();\\n        int index = -1;\\n        for(int i = 0; i< n ; i++)\\n        {\\n            if(nums[i] == target)\\n            {\\n                index = i;\\n            }\\n        }\\n        return index;\\n    }*/\\n\\n    /****************************** BINARY SEARCH APPROACH  ******************************/\\n    int search(vector<int>& nums, int target)\\n    {\\n        int i = 0 ; int j = nums.size()-1;\\n        while(i <= j)\\n        {\\n            int mid =  (i+j)/2;\\n\\n            if(nums[mid] == target) // if target is found return\\n            {\\n                return mid;\\n            }\\n\\n            if (nums[i] <= nums[mid])\\n            {\\n                if (nums[i] <= target && nums[mid] >= target)\\n                    j = mid - 1; \\n                else\\n                    i = mid + 1;\\n            } \\n            else\\n            { \\n                if (nums[mid] <= target && target <= nums[j])\\n                    i = mid + 1;\\n                else\\n                    j = mid - 1;\\n            }\\n        }\\n        return -1;\\n    }\\n\\n};\\n\\n\\n\\n```\\n```\\n![c8840309-29a1-4863-bf1b-90c2f8bd1387_1678528531.5008342.jpeg](https://assets.leetcode.com/users/images/94f8ec63-f298-4744-a9e2-f8f24cd17f2e_1681329169.909031.jpeg)\\n\\n\\n```\\n\\n",
                "solutionTags": [
                    "C++",
                    "Binary Search"
                ],
                "code": "```# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\n```\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1456125,
                "title": "c-linear-search-to-binary-search-detailed-solution",
                "content": "**Rotated Sorted Array Search**\\n\\nwe have a sorted array and it is rotated by a some factor (say k)\\n\\n[1,2,3,4,5,6,7]   if rotated by  k=3 it becomes  [4,5,6,7,1,2,3]\\n\\nwe have given a **target** value if it is present in our array or not ,\\n\\nif we have the target value in our array then we have to return **index** \\n\\nat which target is present ,if not we simply return -1.\\n\\n__________________________________________________________________-\\n\\nLet\\'s start from the most naive approach and gradually progress towards the optimal approach.\\n\\nas our problem is about searching so first thing came into mind is **LINEAR SEARCH.**\\n\\n**Approach 1: Linear Search**\\n\\nwe can simply traverse on our array and compare each element of our array one by one with the target value and decide our result on the basis of is **current value of array is equals to target or not .\\n**\\nDRY RUN :\\n\\nnums: [4,5,6,7,1,2,3]     target=2\\n\\n![image](https://assets.leetcode.com/users/images/7748e614-385f-4a81-8b6e-0de9a2dc101e_1631302063.761646.png)\\n\\n\\n```cpp\\n\\nint search(vector<int> nums, int target)\\n{\\n\\tint n = nums.size();\\n\\n\\tfor (int i = 0; i < n; i++)\\n\\t{\\n\\t\\tint currElement = nums[i];\\n\\t\\tif (currElement == target)\\n\\t\\t{\\n\\t\\t\\treturn i;\\n\\t\\t}\\n\\t}\\n\\n\\treturn -1;   // if target is not present \\n}\\n```\\n\\nTime Complexity: O(N)\\n\\nSpace Complexity: O(1)\\n\\n**Approach 2:  Binary Search:**\\n\\nAs our array is sorted then we can think of binary search.\\n\\nWe apply a modified version of binary search here.\\n\\n**Algorithm :**\\n\\n1. If nums[mid]==target then we got the result!\\n2. if not .. then we can observe that\\n\\n           one of the left or right subarray about mid is always sorted.\\n\\n   2.1:  If the left part of mid is sorted  i.e(nums[start] \\u2264nums[mid])\\n\\n            a: now we check is our target value falls in the left range then we move our \\n\\n              End pointer to mid-1 , by doing this we reduce half of search space in one go.\\n\\n            b: if target does not fall into left range then we check into right part.\\n\\n   2.2    if the right part of mid is sorted i.e,(nums[mid]\\u2264nums[end])\\n\\n            a: we check target value falls into right range then we start pointer to mid+1,\\n      \\n            b: else we move to left part\\n\\t\\t\\t\\n___________________________________________________________________________________________________________________________\\n\\t\\t\\t\\n![image](https://assets.leetcode.com/users/images/63a590ff-ddee-43f3-8a42-6362f1a7bb1c_1631302089.6877496.png)\\n\\n_________________________________________________________________________________________________________\\n![image](https://assets.leetcode.com/users/images/c538e183-5490-4222-8280-08382ce63476_1631302089.3599315.png)\\n\\n\\n \\n\\n```cpp\\nint search(vector<int> &nums, int target)\\n{\\n\\tint n = nums.size();\\n\\tint start = 0;\\n\\tint end = n - 1;\\n\\n\\twhile (start <= end)\\n\\t{\\n\\t\\tint mid = start + (end - start) / 2;\\n\\n\\t\\tif (nums[mid] == target)\\n\\t\\t{\\n\\t\\t\\treturn mid;\\n\\t\\t}\\n\\n\\t\\telse if (nums[start] <= nums[mid])           // is left part sorted \\n\\t\\t{\\n\\t\\t\\tif (nums[start] <= target && nums[mid] > target)  // is target is in left range or not\\n\\t\\t\\t{\\n\\t\\t\\t\\tend = mid - 1;\\n\\t\\t\\t}\\n\\t\\t\\telse\\n\\t\\t\\t{\\n\\t\\t\\t\\tstart = mid + 1;\\n\\t\\t\\t}\\n\\t\\t}\\n\\t\\telse\\n\\t\\t{\\n\\t\\t\\tif (nums[end] >= target && nums[mid] < target)   // is target is in right range or not\\n\\t\\t\\t{\\n\\t\\t\\t\\tstart = mid + 1;\\n\\t\\t\\t}\\n\\t\\t\\telse\\n\\t\\t\\t{\\n\\t\\t\\t\\tend = mid - 1;\\n\\t\\t\\t}\\n\\t\\t}\\n\\t}\\n\\n\\treturn -1;\\n\\n}\\n```\\n\\nTime Complexity: O(logN)\\n\\nSpace Complexity: O(1)",
                "solutionTags": [],
                "code": "```cpp\\n\\nint search(vector<int> nums, int target)\\n{\\n\\tint n = nums.size();\\n\\n\\tfor (int i = 0; i < n; i++)\\n\\t{\\n\\t\\tint currElement = nums[i];\\n\\t\\tif (currElement == target)\\n\\t\\t{\\n\\t\\t\\treturn i;\\n\\t\\t}\\n\\t}\\n\\n\\treturn -1;   // if target is not present \\n}\\n```\n```cpp\\nint search(vector<int> &nums, int target)\\n{\\n\\tint n = nums.size();\\n\\tint start = 0;\\n\\tint end = n - 1;\\n\\n\\twhile (start <= end)\\n\\t{\\n\\t\\tint mid = start + (end - start) / 2;\\n\\n\\t\\tif (nums[mid] == target)\\n\\t\\t{\\n\\t\\t\\treturn mid;\\n\\t\\t}\\n\\n\\t\\telse if (nums[start] <= nums[mid])           // is left part sorted \\n\\t\\t{\\n\\t\\t\\tif (nums[start] <= target && nums[mid] > target)  // is target is in left range or not\\n\\t\\t\\t{\\n\\t\\t\\t\\tend = mid - 1;\\n\\t\\t\\t}\\n\\t\\t\\telse\\n\\t\\t\\t{\\n\\t\\t\\t\\tstart = mid + 1;\\n\\t\\t\\t}\\n\\t\\t}\\n\\t\\telse\\n\\t\\t{\\n\\t\\t\\tif (nums[end] >= target && nums[mid] < target)   // is target is in right range or not\\n\\t\\t\\t{\\n\\t\\t\\t\\tstart = mid + 1;\\n\\t\\t\\t}\\n\\t\\t\\telse\\n\\t\\t\\t{\\n\\t\\t\\t\\tend = mid - 1;\\n\\t\\t\\t}\\n\\t\\t}\\n\\t}\\n\\n\\treturn -1;\\n\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3774690,
                "title": "c-hinglish-easy-explanation-binary-search-interview-prep",
                "content": "# Intuition & Approach\\n- Explained in the code.\\n\\n# Code\\n```\\nclass Solution\\n{\\n    public:\\n       \\tLOGIC\\n\\n       \\tAPPROACH-1\\n       \\t1.Simplest way is to traverse the array and find that number.\\n       \\tO(N)\\n\\n       \\tAPPROACH-2(BINARY SEARCH)\\n       \\t1.Why? Binary Search is used when\\n       \\t-Array is Sorted\\n       \\t- for finding target we have to eliminate the half\\n       \\t- reduces the search space by half\\n       \\t2. Here whole array is not sorted but we can figure out 2 sorted halves.\\n       \\t3 We just have to identify the sorted half and eliminate the other half\\n\\n       \\tlow--------mid----T----high\\n       \\t4.Like in the above case the target is in the 2nd half then we will eliminate the first half completely.\\n       \\t5.So Binary Search is applied in halves.\\n\\n       \\tTC\\n       \\tO(logn)\\n//-------------------------------------------------------------------------------------------------------------------------\\n        int search(vector<int> &nums, int target)\\n        {\\n            int n = nums.size();\\n            int low = 0;\\n            int high = n - 1;\\n            while (low <= high)\\n            {\\n                int mid = (low + high) / 2;\\n                if (nums[mid] == target)\\n                    return mid;\\n               \\t//Index found\\n                else if (nums[low] <= nums[mid])\\n               \\t//Left half\\n                {\\n                    if (nums[low] <= target && target <= nums[mid])\\n                    {\\n                    //right half eliminated\\n                        high = mid - 1;\\n                    }\\n                    else\\n                   \\t//left half eliminated\\n                    {\\n                        low = mid + 1;\\n                    }\\n                }\\n                else\\n                {\\n                   \\t//right half\\n                    if (nums[mid] <= target && target <= nums[high])\\n                   \\t//left half eliminated\\n                    {\\n                        low = mid + 1;\\n                    }\\n                   \\t//right half eliminated\\n                    else\\n                    {\\n                        high = mid - 1;\\n                    }\\n                }\\n            }\\n            //Index not found\\n            return -1;\\n        }\\n};\\n```\\n# Complexity\\n- Time complexity:$O(logn)$ Binary Search\\n\\n- Space complexity:$O(1)$\\n\\nIf you *like* \\uD83D\\uDC4D this solution do *upvote* \\u2B06\\uFE0F and if there is any *improvement or suggestion* do mention it in the *comment* section \\uD83D\\uDE0A.\\n\\n<p align=\"center\">\\n<img src=\"https://assets.leetcode.com/users/images/1b604300-df68-46aa-a267-71f38463bb89_1684820402.7869222.jpeg\" width=\\'350\\' alt=\"Upvote Image\">\\n</p>\\n\\n",
                "solutionTags": [
                    "C++",
                    "Array",
                    "Binary Search"
                ],
                "code": "```\\nclass Solution\\n{\\n    public:\\n       \\tLOGIC\\n\\n       \\tAPPROACH-1\\n       \\t1.Simplest way is to traverse the array and find that number.\\n       \\tO(N)\\n\\n       \\tAPPROACH-2(BINARY SEARCH)\\n       \\t1.Why? Binary Search is used when\\n       \\t-Array is Sorted\\n       \\t- for finding target we have to eliminate the half\\n       \\t- reduces the search space by half\\n       \\t2. Here whole array is not sorted but we can figure out 2 sorted halves.\\n       \\t3 We just have to identify the sorted half and eliminate the other half\\n\\n       \\tlow--------mid----T----high\\n       \\t4.Like in the above case the target is in the 2nd half then we will eliminate the first half completely.\\n       \\t5.So Binary Search is applied in halves.\\n\\n       \\tTC\\n       \\tO(logn)\\n//-------------------------------------------------------------------------------------------------------------------------\\n        int search(vector<int> &nums, int target)\\n        {\\n            int n = nums.size();\\n            int low = 0;\\n            int high = n - 1;\\n            while (low <= high)\\n            {\\n                int mid = (low + high) / 2;\\n                if (nums[mid] == target)\\n                    return mid;\\n               \\t//Index found\\n                else if (nums[low] <= nums[mid])\\n               \\t//Left half\\n                {\\n                    if (nums[low] <= target && target <= nums[mid])\\n                    {\\n                    //right half eliminated\\n                        high = mid - 1;\\n                    }\\n                    else\\n                   \\t//left half eliminated\\n                    {\\n                        low = mid + 1;\\n                    }\\n                }\\n                else\\n                {\\n                   \\t//right half\\n                    if (nums[mid] <= target && target <= nums[high])\\n                   \\t//left half eliminated\\n                    {\\n                        low = mid + 1;\\n                    }\\n                   \\t//right half eliminated\\n                    else\\n                    {\\n                        high = mid - 1;\\n                    }\\n                }\\n            }\\n            //Index not found\\n            return -1;\\n        }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3227761,
                "title": "beats-100-easy-approach-detailed-explanation",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nThe code is implementing the Binary Search algorithm to find an element in a rotated sorted array. The approach to solving this problem is to modify the regular Binary Search algorithm to handle the rotated sorted array.\\n\\nThe intuition behind this approach is that the rotated sorted array can be divided into two parts, one part is still sorted, and the other part is also sorted, but the minimum element of the array is somewhere in the middle of the array. We can identify which part of the array is still sorted by comparing the middle element of the array with the first element of the array. If the middle element is greater than or equal to the first element, then the left part of the array is sorted, and if the middle element is less than the first element, then the right part of the array is sorted.\\n\\nOnce we have identified which part of the array is sorted, we can check if the target element is present in the sorted part of the array using the regular Binary Search algorithm. If the target element is not present in the sorted part of the array, we can search for it in the other part of the array by recursively calling the same Binary Search algorithm on that part.\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\nO(log n)\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\nO(1)\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n\\n        \\n    int search(vector<int>& nums, int target) {\\n        int size=nums.size();\\n       int s=0,e=size-1,m=0;\\n        while(s<=e){\\n                m=s+(e-s)/2;\\n                if(nums[m]==target) return m;\\n                if(nums[m]>=nums[s]){\\n                if(nums[m]>=target && nums[s]<=target) e=m-1;\\n                else s=m+1;}\\n                else{\\n                    if(nums[m]<=target && nums[e]>=target) s=m+1;\\n                    else e=m-1;\\n                }\\n        }\\n        return -1;\\n        \\n\\n        \\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n\\n        \\n    int search(vector<int>& nums, int target) {\\n        int size=nums.size();\\n       int s=0,e=size-1,m=0;\\n        while(s<=e){\\n                m=s+(e-s)/2;\\n                if(nums[m]==target) return m;\\n                if(nums[m]>=nums[s]){\\n                if(nums[m]>=target && nums[s]<=target) e=m-1;\\n                else s=m+1;}\\n                else{\\n                    if(nums[m]<=target && nums[e]>=target) s=m+1;\\n                    else e=m-1;\\n                }\\n        }\\n        return -1;\\n        \\n\\n        \\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 146832,
                "title": "clear-java-solution-in-o-log-n",
                "content": "The interesting property of a sorted + rotated array is that when you divide it into two halves, atleast one of the two halves will always be sorted.\\n\\n```\\nLet input array arr = [4,5,6,7,8,9,1,2,3]\\nnumber of elements  = 9\\nmid index = (0+8)/2 = 4\\n\\n[4,5,6,7,8,9,1,2,3]\\n         ^\\n left   mid  right\\n```\\n\\nit seems right sub-array is not sorted while left sub-array is sorted.\\n\\nIf mid happens to be the point of rotation them both left and right sub-arrays will be sorted.\\n\\n```\\n[6,7,8,9,1,2,3,4,5]\\n         ^\\n```\\n\\nBut in any case **one half(sub-array) must be sorted.**\\n\\nWe can easily know which half is sorted by comparing start and end element of each half.\\n\\nOnce we find which half is sorted we can see if the key is present in that half - simple comparison with the extremes.\\n\\nIf the key is present in that half we recursively call the function on that half else we recursively call our search on the other half.\\n\\nWe are discarding one half of the array in each call which makes this algorithm O(logN).\\n\\n```\\nclass Solution {\\n    public int search(int[] nums, int target) {\\n        int low = 0;\\n        int high = nums.length -1;\\n        return search(nums, target, low, high);\\n    }\\n    \\n    private int search(int[] nums, int target, int low, int high) {\\n        int mid = (low + high)/2;\\n        \\n        // key not present\\n        if(low > high) {\\n            return -1;\\n        }\\n        \\n        // Key is found\\n        if(nums[mid] == target) {\\n            return mid;\\n        }\\n        \\n        // if left half is sorted\\n        if(nums[low] <= nums[mid]) {\\n            // if key is present in left half.\\n            if(nums[low] <= target && nums[mid] >=target) {\\n                return search(nums, target, low, mid-1);\\n            }else{\\n                // if key is not present in left half. Search the right half\\n                return search(nums, target, mid+1, high);\\n            }\\n        }\\n        // if right half is sorted\\n        else {\\n            \\n            // if key is present in right half.\\n            if(nums[mid] <= target && nums[high] >=target) {\\n                return search(nums, target, mid+1, high);\\n            }else{\\n                // if key is not present in right half. Search the left half\\n                return search(nums, target, low, mid-1);\\n            }\\n        }\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nLet input array arr = [4,5,6,7,8,9,1,2,3]\\nnumber of elements  = 9\\nmid index = (0+8)/2 = 4\\n\\n[4,5,6,7,8,9,1,2,3]\\n         ^\\n left   mid  right\\n```\n```\\n[6,7,8,9,1,2,3,4,5]\\n         ^\\n```\n```\\nclass Solution {\\n    public int search(int[] nums, int target) {\\n        int low = 0;\\n        int high = nums.length -1;\\n        return search(nums, target, low, high);\\n    }\\n    \\n    private int search(int[] nums, int target, int low, int high) {\\n        int mid = (low + high)/2;\\n        \\n        // key not present\\n        if(low > high) {\\n            return -1;\\n        }\\n        \\n        // Key is found\\n        if(nums[mid] == target) {\\n            return mid;\\n        }\\n        \\n        // if left half is sorted\\n        if(nums[low] <= nums[mid]) {\\n            // if key is present in left half.\\n            if(nums[low] <= target && nums[mid] >=target) {\\n                return search(nums, target, low, mid-1);\\n            }else{\\n                // if key is not present in left half. Search the right half\\n                return search(nums, target, mid+1, high);\\n            }\\n        }\\n        // if right half is sorted\\n        else {\\n            \\n            // if key is present in right half.\\n            if(nums[mid] <= target && nums[high] >=target) {\\n                return search(nums, target, mid+1, high);\\n            }else{\\n                // if key is not present in right half. Search the left half\\n                return search(nums, target, low, mid-1);\\n            }\\n        }\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2609488,
                "title": "explained-binary-search-python",
                "content": "# Binary Search\\n### Using Python :\\n- Best Explaination Ever\\n```py\\n#----------Method-1------------>\\nclass Solution:            \\n    def search(self, nums: List[int], target: int) -> int:\\n        # left pointer\\n        start=0  \\n        # right pointer\\n        end=len(nums)-1\\n        # until both comes not equal\\n        while start<=end:\\n            mid=(start+end)>>1      # Calculating mid point\\n            # checking if mid is target then return  index\\n            if nums[mid]==target:\\n                return mid\\n            #   checking first half array is sorted or not\\n            elif nums[mid]>=nums[start]:\\n                # checking target is exist in first half or not\\n                if (target>=nums[start] and target<nums[mid]):\\n                    end=mid-1\\n                else:\\n                    start=mid+1\\n            else:\\n                # checking for target exist in second half or not\\n                if (target<=nums[end] and target>nums[mid]):\\n                    start=mid+1\\n                else:\\n                    end=mid-1\\n        return -1\\n```\\n",
                "solutionTags": [
                    "Python",
                    "Binary Tree"
                ],
                "code": "```py\\n#----------Method-1------------>\\nclass Solution:            \\n    def search(self, nums: List[int], target: int) -> int:\\n        # left pointer\\n        start=0  \\n        # right pointer\\n        end=len(nums)-1\\n        # until both comes not equal\\n        while start<=end:\\n            mid=(start+end)>>1      # Calculating mid point\\n            # checking if mid is target then return  index\\n            if nums[mid]==target:\\n                return mid\\n            #   checking first half array is sorted or not\\n            elif nums[mid]>=nums[start]:\\n                # checking target is exist in first half or not\\n                if (target>=nums[start] and target<nums[mid]):\\n                    end=mid-1\\n                else:\\n                    start=mid+1\\n            else:\\n                # checking for target exist in second half or not\\n                if (target<=nums[end] and target>nums[mid]):\\n                    start=mid+1\\n                else:\\n                    end=mid-1\\n        return -1\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2920511,
                "title": "python",
                "content": "```\\nclass Solution:\\n    def search(self, nums: List[int], target: int) -> int:\\n        if not nums:\\n            return -1\\n        \\n        left, right = 0, len(nums) - 1\\n\\n        while left <= right:\\n            mid = (left + right) // 2\\n\\n            if nums[mid] == target:\\n                return mid\\n\\n            # Left position\\n            if nums[left] <= nums[mid]:\\n                # if target is between start & mid, make right to (mid -1)\\n                if nums[left] <= target <= nums[mid]:\\n                    right = mid - 1\\n                else:\\n                    left = mid + 1\\n\\n            # Right position\\n            else:\\n                # if target is between mid & end, make start to (mid + 1)\\n                if nums[mid] <= target <= nums[right]:\\n                    left = mid + 1\\n                else:\\n                    right = mid - 1\\n\\n        return -1\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution:\\n    def search(self, nums: List[int], target: int) -> int:\\n        if not nums:\\n            return -1\\n        \\n        left, right = 0, len(nums) - 1\\n\\n        while left <= right:\\n            mid = (left + right) // 2\\n\\n            if nums[mid] == target:\\n                return mid\\n\\n            # Left position\\n            if nums[left] <= nums[mid]:\\n                # if target is between start & mid, make right to (mid -1)\\n                if nums[left] <= target <= nums[mid]:\\n                    right = mid - 1\\n                else:\\n                    left = mid + 1\\n\\n            # Right position\\n            else:\\n                # if target is between mid & end, make start to (mid + 1)\\n                if nums[mid] <= target <= nums[right]:\\n                    left = mid + 1\\n                else:\\n                    right = mid - 1\\n\\n        return -1\\n```",
                "codeTag": "Java"
            },
            {
                "id": 763245,
                "title": "0ms-100-faster-o-log-n-binary-search-easy-with-explaination-in-comments",
                "content": "```\\nclass Solution {\\n    public int search(int[] nums, int target) {\\n        if (nums == null || nums.length == 0) {\\n            return -1;\\n        }\\n        int l = 0;\\n        int r = nums.length - 1;\\n        while(l<r){\\n            int mid = (l+r)/2;\\n            if(nums[mid] == target)\\n                return mid;\\n            if(nums[l] <= nums[mid]){ //checking if first half array is sorted if so\\n                if(nums[l] <= target && target < nums[mid]){ //check if target lies in the range if so\\n                    r = mid - 1;                              // search in first half only\\n                }else                                         //else search in second half\\n                    l = mid + 1;\\n            }else{  //if first half isn\\'t sorted go and check for second\\n                if(nums[mid] < target && target <= nums[r]){ //check if target lies in second half\\n                    l = mid + 1;                             //if so search in second half\\n                }else{\\n                    r = mid - 1;\\n                }\\n            }\\n        }\\n        return nums[l] == target ? l : -1;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Binary Search",
                    "Binary Tree"
                ],
                "code": "```\\nclass Solution {\\n    public int search(int[] nums, int target) {\\n        if (nums == null || nums.length == 0) {\\n            return -1;\\n        }\\n        int l = 0;\\n        int r = nums.length - 1;\\n        while(l<r){\\n            int mid = (l+r)/2;\\n            if(nums[mid] == target)\\n                return mid;\\n            if(nums[l] <= nums[mid]){ //checking if first half array is sorted if so\\n                if(nums[l] <= target && target < nums[mid]){ //check if target lies in the range if so\\n                    r = mid - 1;                              // search in first half only\\n                }else                                         //else search in second half\\n                    l = mid + 1;\\n            }else{  //if first half isn\\'t sorted go and check for second\\n                if(nums[mid] < target && target <= nums[r]){ //check if target lies in second half\\n                    l = mid + 1;                             //if so search in second half\\n                }else{\\n                    r = mid - 1;\\n                }\\n            }\\n        }\\n        return nums[l] == target ? l : -1;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 14659,
                "title": "binary-search-java-solusion-o-log-n",
                "content": "    public int search(int[] A, int target) {\\n        if (A.length == 0) return -1;\\n        int L = 0, R = A.length-1;\\n        //\\n        if (target < A[L] && target > A[R]) return -1;\\n        \\n        while (L < R) {\\n            int M = (L + R)/2;\\n            if (A[M] <= A[R]) {\\n                if (target > A[M] && target <= A[R]) {\\n                    L = M+1;\\n                } else {\\n                    R = M;\\n                }\\n                \\n            } else {\\n                if (target <= A[M] && target >= A[L]) {\\n                        R = M;\\n                } else {\\n                    L = M+1;\\n                }\\n            }\\n        }\\n        if (A[L] == target) return L;\\n        else return -1;\\n    }",
                "solutionTags": [
                    "Java",
                    "Binary Tree"
                ],
                "code": "    public int search(int[] A, int target) {\\n        if (A.length == 0) return -1;\\n        int L = 0, R = A.length-1;\\n        //\\n        if (target < A[L] && target > A[R]) return -1;\\n        \\n        while (L < R) {\\n            int M = (L + R)/2;\\n            if (A[M] <= A[R]) {\\n                if (target > A[M] && target <= A[R]) {\\n                    L = M+1;\\n                } else {\\n                    R = M;\\n                }\\n                \\n            } else {\\n                if (target <= A[M] && target >= A[L]) {\\n                        R = M;\\n                } else {\\n                    L = M+1;\\n                }\\n            }\\n        }\\n        if (A[L] == target) return L;\\n        else return -1;\\n    }",
                "codeTag": "Unknown"
            },
            {
                "id": 406621,
                "title": "super-easy-python-solution-find-pivot-using-bin-search-run-bin-search-on-both-sides-of-pivot",
                "content": "1) Binary search to find index of pivot (where the array has been rotated).\\n2) Normal Binary search on both sides of pivot to find element\\n\\nCode uses the property that the last element of array will be smaller than all elements before the pivot. See example below to clarify:\\n**example: in rotated array: 8,9,11,5,6,7. We know 5 is the pivot.\\nAll elements on left side of pivot are larger than last element, 7\\nAll elements on right side of pivot including pivot are smaller than last element, 7.**\\nWe can use this property to binary search and find pivot, once we have pivot, run normal bin_search on both sides of pivot and we\\'re done woohoo! \\n```\\nclass Solution(object):\\n    def search(self, nums, target):\\n        \"\"\"\\n        :type nums: List[int]\\n        :type target: int\\n        :rtype: int\\n        \"\"\"\\n        if(not nums):\\n            return -1\\n        pivot_index = self.find_pivot(nums) \\n        result = self.bin_search(nums, target, 0, pivot_index-1)\\n        if(result!=-1):\\n            return result\\n        else:\\n            return self.bin_search(nums, target, pivot_index, len(nums)-1)\\n        \\n    def find_pivot(self, arr):\\n\\t#compare last element to mid element. \\n\\t#If mid element is greater than last element, pivot must be on right move low to mid+1\\n\\t#If mid element is less than last element, move high to mid-1\\n        element_to_compare = arr[-1]\\n        low = 0\\n        high = len(arr)-1    \\n        while(low <= high):\\n            mid = (low+high)//2\\n            if element_to_compare < arr[mid]:\\n                low = mid+1\\n            elif element_to_compare >= arr[mid]:\\n                high = mid-1\\n        return low    \\n\\n    def bin_search(self, arr, value, low, high):     \\n        while(low <= high):\\n            mid = (low+high)/2\\n            if value<arr[mid]:\\n                high = mid-1\\n            elif value>arr[mid]:\\n                low = mid+1\\n            else:\\n                return mid\\n        return -1\\n```",
                "solutionTags": [
                    "Python",
                    "Python3"
                ],
                "code": "```\\nclass Solution(object):\\n    def search(self, nums, target):\\n        \"\"\"\\n        :type nums: List[int]\\n        :type target: int\\n        :rtype: int\\n        \"\"\"\\n        if(not nums):\\n            return -1\\n        pivot_index = self.find_pivot(nums) \\n        result = self.bin_search(nums, target, 0, pivot_index-1)\\n        if(result!=-1):\\n            return result\\n        else:\\n            return self.bin_search(nums, target, pivot_index, len(nums)-1)\\n        \\n    def find_pivot(self, arr):\\n\\t#compare last element to mid element. \\n\\t#If mid element is greater than last element, pivot must be on right move low to mid+1\\n\\t#If mid element is less than last element, move high to mid-1\\n        element_to_compare = arr[-1]\\n        low = 0\\n        high = len(arr)-1    \\n        while(low <= high):\\n            mid = (low+high)//2\\n            if element_to_compare < arr[mid]:\\n                low = mid+1\\n            elif element_to_compare >= arr[mid]:\\n                high = mid-1\\n        return low    \\n\\n    def bin_search(self, arr, value, low, high):     \\n        while(low <= high):\\n            mid = (low+high)/2\\n            if value<arr[mid]:\\n                high = mid-1\\n            elif value>arr[mid]:\\n                low = mid+1\\n            else:\\n                return mid\\n        return -1\\n```",
                "codeTag": "Java"
            },
            {
                "id": 173843,
                "title": "javascript-solution",
                "content": "# Approach\\nBinary Search\\n\\n# Complexity\\n- Time complexity:\\n$$O(log(n))$$\\n\\n- Space complexity:\\n$$O(1)$$\\n\\n# Code\\n\\n```js\\nvar search = function(nums, target) {\\n  if (nums.length === 0) return -1; // check empty\\n\\n  let left = 0;\\n  let right = nums.length - 1;\\n\\n  while (left <= right) {\\n    const mid = left + Math.floor((right - left) / 2);\\n\\n    if (nums[mid] === target) return mid;\\n\\n    // left sorted\\n    if (nums[left] <= nums[mid]) {\\n      // check if itarget is in the left sorted part\\n      if (nums[left] <= target && target < nums[mid]) {\\n        right = mid - 1;\\n      } else {\\n        left = mid + 1;\\n      }\\n    // right sorted\\n    } else {\\n      // check if target is in the right sorted part\\n      if (nums[mid] < target && target <= nums[right]) {\\n        left = mid + 1;\\n      } else {\\n        right = mid - 1;\\n      }\\n    }\\n  }\\n\\n  return -1;\\n};\\n```",
                "solutionTags": [
                    "Binary Search"
                ],
                "code": "```js\\nvar search = function(nums, target) {\\n  if (nums.length === 0) return -1; // check empty\\n\\n  let left = 0;\\n  let right = nums.length - 1;\\n\\n  while (left <= right) {\\n    const mid = left + Math.floor((right - left) / 2);\\n\\n    if (nums[mid] === target) return mid;\\n\\n    // left sorted\\n    if (nums[left] <= nums[mid]) {\\n      // check if itarget is in the left sorted part\\n      if (nums[left] <= target && target < nums[mid]) {\\n        right = mid - 1;\\n      } else {\\n        left = mid + 1;\\n      }\\n    // right sorted\\n    } else {\\n      // check if target is in the right sorted part\\n      if (nums[mid] < target && target <= nums[right]) {\\n        left = mid + 1;\\n      } else {\\n        right = mid - 1;\\n      }\\n    }\\n  }\\n\\n  return -1;\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1529302,
                "title": "java-tc-o-logn-sc-o-1-modified-binary-search-optimal-solution",
                "content": "```java\\n/**\\n * Modified binary search. This solution cannot handle duplicates in the input\\n * array.\\n *\\n * Time Complexity: O(log N) --> Search space is reduced by half in every\\n * iteration.\\n *\\n * Space Complexity: O(1)\\n *\\n * N = length of input array.\\n */\\nclass Solution {\\n    public int search(int[] nums, int target) {\\n        if (nums == null || nums.length == 0) {\\n            return -1;\\n        }\\n\\n        int start = 0;\\n        int end = nums.length - 1;\\n\\n        while (start <= end) {\\n            int mid = start + (end - start) / 2;\\n            if (nums[mid] == target) {\\n                return mid;\\n            }\\n\\n            // Left side is sorted and Right side is unsorted.\\n            if (nums[start] <= nums[mid]) {\\n                if (target >= nums[start] && target < nums[mid]) {\\n                    end = mid - 1;\\n                } else {\\n                    start = mid + 1;\\n                }\\n            } else {\\n                // Left side is unsorted and Right side is sorted.\\n                if (target > nums[mid] && target <= nums[end]) {\\n                    start = mid + 1;\\n                } else {\\n                    end = mid - 1;\\n                }\\n            }\\n        }\\n\\n        return -1;\\n    }\\n}\\n```\\n\\n---\\n\\nSolutions to other Rotated Sorted Array questions on LeetCode:\\n- [81. Search in Rotated Sorted Array II](https://leetcode.com/problems/search-in-rotated-sorted-array-ii/discuss/1529305/Java-or-TC:-O(N2)-or-SC:-O(1)-or-Modified-Binary-Search-optimal-solution)\\n- [153. Find Minimum in Rotated Sorted Array](https://leetcode.com/problems/find-minimum-in-rotated-sorted-array/discuss/1529313/Java-or-TC:-O(logN)-or-SC:-O(1)-or-Optimal-Binary-Search-with-Early-Exit)\\n- [154. Find Minimum in Rotated Sorted Array II + FollowUp](https://leetcode.com/problems/find-minimum-in-rotated-sorted-array-ii/discuss/1529323/Java-or-TC:-O(N2)-or-SC:-O(1)-or-Optimal-Binary-Search-w-Early-Exit-and-FollowUp)\\n",
                "solutionTags": [
                    "Java",
                    "Array",
                    "Binary Tree"
                ],
                "code": "```java\\n/**\\n * Modified binary search. This solution cannot handle duplicates in the input\\n * array.\\n *\\n * Time Complexity: O(log N) --> Search space is reduced by half in every\\n * iteration.\\n *\\n * Space Complexity: O(1)\\n *\\n * N = length of input array.\\n */\\nclass Solution {\\n    public int search(int[] nums, int target) {\\n        if (nums == null || nums.length == 0) {\\n            return -1;\\n        }\\n\\n        int start = 0;\\n        int end = nums.length - 1;\\n\\n        while (start <= end) {\\n            int mid = start + (end - start) / 2;\\n            if (nums[mid] == target) {\\n                return mid;\\n            }\\n\\n            // Left side is sorted and Right side is unsorted.\\n            if (nums[start] <= nums[mid]) {\\n                if (target >= nums[start] && target < nums[mid]) {\\n                    end = mid - 1;\\n                } else {\\n                    start = mid + 1;\\n                }\\n            } else {\\n                // Left side is unsorted and Right side is sorted.\\n                if (target > nums[mid] && target <= nums[end]) {\\n                    start = mid + 1;\\n                } else {\\n                    end = mid - 1;\\n                }\\n            }\\n        }\\n\\n        return -1;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 587261,
                "title": "python-recursion-o-log-n-11-lines-easy-to-understand",
                "content": "Hi there,\\n\\nwanted to share a - in my opinion - quite clean and self-explanatory solution. Here it is:\\n\\n``` \\n      def search(self, nums: List[int], target: int) -> int:\\n        def helper(l,r):\\n            if l > r:\\n                return -1\\n            m = (r+l)//2\\n            if nums[m] == target:\\n                return m\\n            # follow left half if it is sorted and target is in its range or if right half is sorted but target is not in its range\\n            if nums[l] <= target < nums[m] or (nums[m] <= nums[r]  and not nums[m] < target <= nums[r]):\\n                return helper(l,m-1)\\n            else: \\n                return helper(m+1, r)\\n        return helper(0,len(nums)-1)",
                "solutionTags": [],
                "code": "Hi there,\\n\\nwanted to share a - in my opinion - quite clean and self-explanatory solution. Here it is:\\n\\n``` \\n      def search(self, nums: List[int], target: int) -> int:\\n        def helper(l,r):\\n            if l > r:\\n                return -1\\n            m = (r+l)//2\\n            if nums[m] == target:\\n                return m\\n            # follow left half if it is sorted and target is in its range or if right half is sorted but target is not in its range\\n            if nums[l] <= target < nums[m] or (nums[m] <= nums[r]  and not nums[m] < target <= nums[r]):\\n                return helper(l,m-1)\\n            else: \\n                return helper(m+1, r)\\n        return helper(0,len(nums)-1)",
                "codeTag": "Python3"
            },
            {
                "id": 14589,
                "title": "java-binary-search-with-recursion",
                "content": "We can take advantage of the fact that the array is sorted (although rotated). \\n1. Figure out if left half is sorted\\n1.1. If the target is on left side, continue binary search on left half.\\n1.2 If not, it must of in the right half. <br>\\n2. Similarly figure out if right half is sorted\\n2.1. If the target is on right side, continue binary search on right half.\\n2.2 If not, it must of in the left half.\\n```\\n\\n    public int search(int[] nums, int target) {\\n        return search(nums, 0, nums.length-1, target);\\n    }\\n    \\n    //6,7,1,2,3,4,5\\n    public int search (int[] nums, int first, int last, int target){\\n        if (first > last) return -1;\\n        \\n        int mid = (first + last) / 2;\\n        if (nums[mid] == target) return mid;\\n        \\n        if (nums[first] <= nums[mid]) // Left half is sorted\\n            if (nums[first] <= target && target <= nums[mid]) // target is in this sorted (left) half\\n                return search (nums, first, mid - 1, target);\\n            else // target must be in the right half\\n                return search (nums, mid + 1, last, target);\\n        if (nums[mid] <= nums[last])// Right half is sorted\\n            if (nums[mid] <= target && target <= nums[last]) // target is in this sorted (right) half\\n                return search (nums, mid + 1, last, target);\\n            else // target must be in left half\\n                return search (nums, first, mid - 1, target);\\n        \\n        return -1;\\n                \\n    }\\n```",
                "solutionTags": [
                    "Java",
                    "Recursion",
                    "Binary Tree"
                ],
                "code": "```\\n\\n    public int search(int[] nums, int target) {\\n        return search(nums, 0, nums.length-1, target);\\n    }\\n    \\n    //6,7,1,2,3,4,5\\n    public int search (int[] nums, int first, int last, int target){\\n        if (first > last) return -1;\\n        \\n        int mid = (first + last) / 2;\\n        if (nums[mid] == target) return mid;\\n        \\n        if (nums[first] <= nums[mid]) // Left half is sorted\\n            if (nums[first] <= target && target <= nums[mid]) // target is in this sorted (left) half\\n                return search (nums, first, mid - 1, target);\\n            else // target must be in the right half\\n                return search (nums, mid + 1, last, target);\\n        if (nums[mid] <= nums[last])// Right half is sorted\\n            if (nums[mid] <= target && target <= nums[last]) // target is in this sorted (right) half\\n                return search (nums, mid + 1, last, target);\\n            else // target must be in left half\\n                return search (nums, first, mid - 1, target);\\n        \\n        return -1;\\n                \\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 14654,
                "title": "c-solution-with-explanation",
                "content": "With scrutiny on a rotated sorted array, it\\'s not hard to find that for every index i, either the part [0, i] is sorted or the part [i, n - 1] is sorted.\\nThe idea is that we can always divide the array into two parts L, R. If L is sorted and the key is in the range we can simply throw R away, if key is not in the range then we know the key must be in the unsorted part(i.e. R). If key is in R, we are back to the same problem with the size halved, so we can apply the same idea on R.\\n```\\nclass Solution {\\npublic:\\n    int search(int A[], int n, int target) {\\n        int l = 0, r = n - 1;\\n        while(l <= r) {\\n            int m = (l + r) / 2;\\n            if (A[m] == target)\\n                return m;\\n            else if (A[l] <= A[m]) { /* left part is sorted */\\n                if (A[l] <= target && target < A[m]) /* target is in the left part */\\n                    r = m - 1;\\n                else  /* target is in the right part */\\n                    l = m + 1;                               \\n            } else {/* right part is sorted */\\n                if (A[m] < target && target <= A[r]) /* target is in the right part */\\n                    l = m + 1;\\n                else /* target is in the left part */\\n                    r = m - 1;\\n            }\\n        }\\n        \\n        return -1;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int search(int A[], int n, int target) {\\n        int l = 0, r = n - 1;\\n        while(l <= r) {\\n            int m = (l + r) / 2;\\n            if (A[m] == target)\\n                return m;\\n            else if (A[l] <= A[m]) { /* left part is sorted */\\n                if (A[l] <= target && target < A[m]) /* target is in the left part */\\n                    r = m - 1;\\n                else  /* target is in the right part */\\n                    l = m + 1;                               \\n            } else {/* right part is sorted */\\n                if (A[m] < target && target <= A[r]) /* target is in the right part */\\n                    l = m + 1;\\n                else /* target is in the left part */\\n                    r = m - 1;\\n            }\\n        }\\n        \\n        return -1;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1905767,
                "title": "100-fastest-swift-solution-o-log-n-o-1",
                "content": "```\\nclass Solution {\\n    // - Complexity:\\n    //     - time: O(log n), where n is the length of nums.\\n    //     - space: O(1), only constant space is used.\\n    \\n    func search(_ nums: [Int], _ target: Int) -> Int {\\n        var start = 0\\n        var end = nums.count - 1\\n\\n        while start <= end {\\n            let mid = start + (end - start) / 2\\n            guard nums[mid] != target else { return mid }\\n\\n            if nums[start] < nums[mid] {\\n                if nums[start] <= target, target < nums[mid] {\\n                    end = mid - 1\\n                } else {\\n                    start = mid + 1\\n                }\\n            } else if nums[start] > nums[mid] {\\n                if nums[mid] < target, target <= nums[end] {\\n                    start = mid + 1\\n                } else {\\n                    end = mid - 1\\n                }\\n\\n            } else {\\n                start = mid + 1\\n            }\\n\\n        }\\n        return -1\\n    }\\n\\n}\\n```\\n\\nLet me know in comments if you have any doubts. I will be happy to answer.\\n\\nPlease upvote if you found the solution useful.",
                "solutionTags": [
                    "Swift"
                ],
                "code": "```\\nclass Solution {\\n    // - Complexity:\\n    //     - time: O(log n), where n is the length of nums.\\n    //     - space: O(1), only constant space is used.\\n    \\n    func search(_ nums: [Int], _ target: Int) -> Int {\\n        var start = 0\\n        var end = nums.count - 1\\n\\n        while start <= end {\\n            let mid = start + (end - start) / 2\\n            guard nums[mid] != target else { return mid }\\n\\n            if nums[start] < nums[mid] {\\n                if nums[start] <= target, target < nums[mid] {\\n                    end = mid - 1\\n                } else {\\n                    start = mid + 1\\n                }\\n            } else if nums[start] > nums[mid] {\\n                if nums[mid] < target, target <= nums[end] {\\n                    start = mid + 1\\n                } else {\\n                    end = mid - 1\\n                }\\n\\n            } else {\\n                start = mid + 1\\n            }\\n\\n        }\\n        return -1\\n    }\\n\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1082643,
                "title": "very-simple-c-solution-easy-to-read-and-understand",
                "content": "```\\nclass Solution {\\npublic:\\n    int search(vector<int>& nums, int target) {\\n        int n = nums.size();\\n        int l = 0,h = n-1;\\n        // First find the index of lowest element\\n        while(l<h){\\n            int m = l + (h-l)/2;\\n            if(nums[m]>nums[h]) l = m+1;\\n            else h = m; \\n        }\\n        int r = l; // store it in r\\n        \\n\\t\\tif(target==nums[r]) return r;\\n\\t\\telse if(r==0) l=0,h=n-1; // In this case the whole array is sorted ..as our lowest element is at first index..that\\'s why we\\'ll search in our whole array .. 0 ... n-1\\n\\t\\telse if(target>=nums[0]) l=0,h = r;  // If our target is greater than our first element , then target will present in array before our lowest element ,so range is 0 ..... r \\n\\t\\telse if(target<nums[0]) l = r,h=n-1; // if our target is less than our first element, then target will be after our lowest element , r ..... n-1\\n        \\n        //Simple Binary Search\\n        while(l<=h){\\n            int m = l + (h-l)/2;\\n            if(nums[m]==target) return m;\\n            if(nums[m]>target) h = m -1;\\n            else l = m+1;\\n        }\\n        return -1;\\n    }\\n};\\n\\n        \\n```",
                "solutionTags": [
                    "C",
                    "Binary Tree"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int search(vector<int>& nums, int target) {\\n        int n = nums.size();\\n        int l = 0,h = n-1;\\n        // First find the index of lowest element\\n        while(l<h){\\n            int m = l + (h-l)/2;\\n            if(nums[m]>nums[h]) l = m+1;\\n            else h = m; \\n        }\\n        int r = l; // store it in r\\n        \\n\\t\\tif(target==nums[r]) return r;\\n\\t\\telse if(r==0) l=0,h=n-1; // In this case the whole array is sorted ..as our lowest element is at first index..that\\'s why we\\'ll search in our whole array .. 0 ... n-1\\n\\t\\telse if(target>=nums[0]) l=0,h = r;  // If our target is greater than our first element , then target will present in array before our lowest element ,so range is 0 ..... r \\n\\t\\telse if(target<nums[0]) l = r,h=n-1; // if our target is less than our first element, then target will be after our lowest element , r ..... n-1\\n        \\n        //Simple Binary Search\\n        while(l<=h){\\n            int m = l + (h-l)/2;\\n            if(nums[m]==target) return m;\\n            if(nums[m]>target) h = m -1;\\n            else l = m+1;\\n        }\\n        return -1;\\n    }\\n};\\n\\n        \\n```",
                "codeTag": "Java"
            },
            {
                "id": 14629,
                "title": "python-o-lgn-solution-it-needs-a-pen-and-some-paper-to-figure-it-out-at-the-first-time",
                "content": "        \\n    def search(self, nums, target):\\n        l, r = 0, len(nums)-1\\n        while l <= r:\\n            mid = l + (r-l)//2\\n            if nums[mid] == target:\\n                return mid\\n            if nums[l] <= nums[mid]:  # here should include \"==\" case\\n                if nums[l] <= target < nums[mid]:\\n                    r = mid - 1\\n                else:\\n                    l = mid + 1\\n            else:\\n                if nums[mid] < target <= nums[r]:\\n                    l = mid + 1\\n                else:\\n                    r = mid - 1\\n        return -1",
                "solutionTags": [
                    "Python"
                ],
                "code": "        \\n    def search(self, nums, target):\\n        l, r = 0, len(nums)-1\\n        while l <= r:\\n            mid = l + (r-l)//2\\n            if nums[mid] == target:\\n                return mid\\n            if nums[l] <= nums[mid]:  # here should include \"==\" case\\n                if nums[l] <= target < nums[mid]:\\n                    r = mid - 1\\n                else:\\n                    l = mid + 1\\n            else:\\n                if nums[mid] < target <= nums[r]:\\n                    l = mid + 1\\n                else:\\n                    r = mid - 1\\n        return -1",
                "codeTag": "Python3"
            },
            {
                "id": 3880735,
                "title": "c-binary-search-day-8",
                "content": "# Code\\n```\\nclass Solution {\\npublic:\\n    int search(vector<int>& v, int target) {\\n        int l=0,r=v.size()-1;\\n        while(l<=r){\\n            int m=(l+r)/2;\\n            if(v[m]==target)return m;\\n            if(v[m]>=v[l]){\\n                if(target>=v[l] && v[m]>=target)r=m-1;\\n                else l=m+1;\\n            }\\n            else {\\n                if(v[r]>=target && v[m]<=target)l=m+1;\\n                else r=m-1;\\n            }\\n        }\\n        return -1;\\n    }\\n};\\n```\\n![upvote (2).jpg](https://assets.leetcode.com/users/images/17354111-24a1-45f8-bbf4-835bbf3f60c2_1691482271.5097225.jpeg)\\n",
                "solutionTags": [
                    "C++",
                    "Array",
                    "Binary Search"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int search(vector<int>& v, int target) {\\n        int l=0,r=v.size()-1;\\n        while(l<=r){\\n            int m=(l+r)/2;\\n            if(v[m]==target)return m;\\n            if(v[m]>=v[l]){\\n                if(target>=v[l] && v[m]>=target)r=m-1;\\n                else l=m+1;\\n            }\\n            else {\\n                if(v[r]>=target && v[m]<=target)l=m+1;\\n                else r=m-1;\\n            }\\n        }\\n        return -1;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3435461,
                "title": "binary-search-implementation-o-logn-complexity-beats-90",
                "content": "# Code\\n```\\nclass Solution:\\n    def search(self, nums: List[int], target: int) -> int:\\n        if not nums:\\n            return -1 \\n\\n        low = 0\\n        high = len(nums)-1\\n\\n        while low <= high:\\n            mid = (low+high)//2\\n\\n            if target == nums[mid]:\\n                return mid\\n\\n            if nums[low] <= nums[mid]:\\n                if nums[low] <= target <= nums[mid]:\\n                    high = mid - 1\\n                else:\\n                    low = mid + 1\\n            \\n            else:\\n                if nums[mid] <= target <= nums[high]:\\n                    low = mid + 1\\n                else:\\n                    high = mid - 1\\n        \\n        return -1\\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def search(self, nums: List[int], target: int) -> int:\\n        if not nums:\\n            return -1 \\n\\n        low = 0\\n        high = len(nums)-1\\n\\n        while low <= high:\\n            mid = (low+high)//2\\n\\n            if target == nums[mid]:\\n                return mid\\n\\n            if nums[low] <= nums[mid]:\\n                if nums[low] <= target <= nums[mid]:\\n                    high = mid - 1\\n                else:\\n                    low = mid + 1\\n            \\n            else:\\n                if nums[mid] <= target <= nums[high]:\\n                    low = mid + 1\\n                else:\\n                    high = mid - 1\\n        \\n        return -1\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2740157,
                "title": "binary-search-time-complexity-space-complexity-explanation",
                "content": "Time Complexity - Searching for the minimum element and binary search both take O(logN base 2). Hence time taken is O(logN base 2).\\nSpace Complexity - Space taken is O(1).\\nExplanation - A prerequisite to this problem would be the following 2 problems:\\nProblem 1: https://leetcode.com/problems/binary-search/\\nSolution: https://github.com/Arya-Gupta/LeetCode/blob/main/704.%20Binary%20Search/Solution\\nProblem 2: https://leetcode.com/problems/find-minimum-in-rotated-sorted-array/\\nSolution: https://github.com/Arya-Gupta/LeetCode/blob/main/153.%20Find%20Minimum%20in%20Rotated%20Sorted%20Array/Binary%20Search\\n\\n**Now we can reduce our current problem to a simple variation of these problems.**\\nA rotated array can be divided into 2 sorted parts on the basis of its minimum element.\\nFor example: 4, 5, 6, 1, 2, 3 can be divided into 4, 5, 6 and 1, 2, 3.\\nNow we apply the regular binary search algorithm on both of these parts and search for our target element.\\nIf they aren\\'t present in either part, we return -1.\\n\\n```\\nclass Solution {\\npublic:\\n    int findMin(vector<int>& nums){\\n        int n = nums.size(), start = 0, end = n - 1, mid;\\n        while(start <= end){\\n            if(nums[start] < nums[end]) return start;\\n            mid = start + (end - start) / 2;\\n            if(nums[mid] <= nums[(mid + n - 1) % n]) return mid;\\n            else if(nums[start] <= nums[mid]) start = mid + 1;\\n            else end = mid - 1;\\n        }\\n        return -1;\\n    }\\n    \\n    int binarySearch(vector<int>& nums, int target, int start, int end) {\\n        while(start <= end){\\n            int mid = start + (end - start) / 2;\\n            if(nums[mid] == target) return mid;\\n            else if(target > nums[mid]) start = mid + 1;\\n            else end = mid - 1;\\n        }\\n        return -1;\\n    }\\n    \\n    int search(vector<int>& nums, int target){\\n        int n = nums.size(), minPos = findMin(nums);\\n        if(binarySearch(nums, target, 0, minPos - 1) != -1) return binarySearch(nums, target, 0, minPos - 1);\\n        return binarySearch(nums, target, minPos, n - 1);\\n    }\\n};\\n```\\n\\n**Kindly upvote if you found the solution helpful :)**\\nFor more such explanations of LeetCode problems along with their C++ solutions:\\nhttps://github.com/Arya-Gupta/LeetCode",
                "solutionTags": [
                    "C++",
                    "C",
                    "Array",
                    "Binary Search",
                    "Binary Tree"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int findMin(vector<int>& nums){\\n        int n = nums.size(), start = 0, end = n - 1, mid;\\n        while(start <= end){\\n            if(nums[start] < nums[end]) return start;\\n            mid = start + (end - start) / 2;\\n            if(nums[mid] <= nums[(mid + n - 1) % n]) return mid;\\n            else if(nums[start] <= nums[mid]) start = mid + 1;\\n            else end = mid - 1;\\n        }\\n        return -1;\\n    }\\n    \\n    int binarySearch(vector<int>& nums, int target, int start, int end) {\\n        while(start <= end){\\n            int mid = start + (end - start) / 2;\\n            if(nums[mid] == target) return mid;\\n            else if(target > nums[mid]) start = mid + 1;\\n            else end = mid - 1;\\n        }\\n        return -1;\\n    }\\n    \\n    int search(vector<int>& nums, int target){\\n        int n = nums.size(), minPos = findMin(nums);\\n        if(binarySearch(nums, target, 0, minPos - 1) != -1) return binarySearch(nums, target, 0, minPos - 1);\\n        return binarySearch(nums, target, minPos, n - 1);\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 186585,
                "title": "javascript-solution-with-detailed-explanation",
                "content": "```\\n/**\\n * @param {number[]} nums\\n * @param {number} target\\n * @return {number}\\n */\\nvar search = function(rotated, target) {\\n    var left = 0;\\n    var right = rotated.length - 1;\\n    \\n    // Just a straight binary search.\\n    while (left <= right) {\\n        var middle = Math.floor((right + left) / 2);\\n    \\n        // We have found our target.\\n        if (rotated[middle] === target) {\\n            return middle;\\n        }\\n    \\n        // The clever part starts here:\\n        if (rotated[left] <= rotated[middle]) {\\n            // If the middle element is greater than the element to the left\\n            // of it, then that means that the bottom half is strictly increasing\\n            // from left to middle, i.e. it is sorted and we can just do a normal\\n            // binary search.\\n    \\n            // Is the target in this range?\\n            if (rotated[left] <= target && target < rotated[middle]) {\\n                // \\'recurse\\' down this side\\n                right = middle - 1;\\n            } else {\\n                // \\'recurse\\' down the other side\\n                left = middle + 1;\\n            }\\n        } else {\\n            // This means that the *top* half must be sorted, because\\n            // there can only be one place in the entire array where\\n            // the order is not sorted, and it\\'s on the bottom half.\\n    \\n            if (rotated[middle] < target && target <= rotated[right]) {\\n                // \\'recurse\\' down this side\\n                left = middle + 1;\\n            } else {\\n                // \\'recurse\\' down the other side\\n                right = middle - 1;\\n            }\\n    \\n        }\\n    }\\n  \\n  return -1;\\n};\\n```",
                "solutionTags": [],
                "code": "```\\n/**\\n * @param {number[]} nums\\n * @param {number} target\\n * @return {number}\\n */\\nvar search = function(rotated, target) {\\n    var left = 0;\\n    var right = rotated.length - 1;\\n    \\n    // Just a straight binary search.\\n    while (left <= right) {\\n        var middle = Math.floor((right + left) / 2);\\n    \\n        // We have found our target.\\n        if (rotated[middle] === target) {\\n            return middle;\\n        }\\n    \\n        // The clever part starts here:\\n        if (rotated[left] <= rotated[middle]) {\\n            // If the middle element is greater than the element to the left\\n            // of it, then that means that the bottom half is strictly increasing\\n            // from left to middle, i.e. it is sorted and we can just do a normal\\n            // binary search.\\n    \\n            // Is the target in this range?\\n            if (rotated[left] <= target && target < rotated[middle]) {\\n                // \\'recurse\\' down this side\\n                right = middle - 1;\\n            } else {\\n                // \\'recurse\\' down the other side\\n                left = middle + 1;\\n            }\\n        } else {\\n            // This means that the *top* half must be sorted, because\\n            // there can only be one place in the entire array where\\n            // the order is not sorted, and it\\'s on the bottom half.\\n    \\n            if (rotated[middle] < target && target <= rotated[right]) {\\n                // \\'recurse\\' down this side\\n                left = middle + 1;\\n            } else {\\n                // \\'recurse\\' down the other side\\n                right = middle - 1;\\n            }\\n    \\n        }\\n    }\\n  \\n  return -1;\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1890634,
                "title": "c-binary-search-commented-solution-easy-to-understand",
                "content": "# C++ Code :\\n\\n```\\nclass Solution {\\npublic:\\n    int search(vector<int>& nums, int target) {\\n    //there exists atleast one strictly increasing subarray due to pivot element\\n    //using modified binary search \\n        int n=nums.size();\\n        int s=0;\\n        int e=n-1;\\n        \\n        while(s<=e){\\n            int mid=s+(e-s)/2;\\n            \\n            if(nums[mid] == target) return mid;\\n  //else if left subarray is str increasing then search only in the LEFT SUBARRAY          \\n            else if(nums[mid]>=nums[s]){\\n                if(target>=nums[s] && target <=nums[mid]){\\n                    \\n                    e =mid-1;//update the right pointer\\n                    \\n                }\\n                else\\n                    s=mid+1;//update the left pointer\\n            }\\n //else search in the RIGHT SUBARRAY\\n            else{\\n                if(target>=nums[mid] && target<=nums[e]){\\n                    \\n                    s=mid+1;\\n                    \\n                }\\n                else\\n                    e=mid-1;\\n            }\\n            \\n        }\\n        \\n        return -1;//if it is not PRESENT\\n    }\\n};\\n```\\n**Don\\'t forget to Upvote if you liked the solution !**",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    int search(vector<int>& nums, int target) {\\n    //there exists atleast one strictly increasing subarray due to pivot element\\n    //using modified binary search \\n        int n=nums.size();\\n        int s=0;\\n        int e=n-1;\\n        \\n        while(s<=e){\\n            int mid=s+(e-s)/2;\\n            \\n            if(nums[mid] == target) return mid;\\n  //else if left subarray is str increasing then search only in the LEFT SUBARRAY          \\n            else if(nums[mid]>=nums[s]){\\n                if(target>=nums[s] && target <=nums[mid]){\\n                    \\n                    e =mid-1;//update the right pointer\\n                    \\n                }\\n                else\\n                    s=mid+1;//update the left pointer\\n            }\\n //else search in the RIGHT SUBARRAY\\n            else{\\n                if(target>=nums[mid] && target<=nums[e]){\\n                    \\n                    s=mid+1;\\n                    \\n                }\\n                else\\n                    e=mid-1;\\n            }\\n            \\n        }\\n        \\n        return -1;//if it is not PRESENT\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1283472,
                "title": "java-simple-intuitive-solution-faster-than-100-explained",
                "content": "Approach:\\n- The idea here is quite simple and on basic intuition. It\\'s simple Binary Search with a few added conditions.\\n\\n- Generally, if `target > nums[mid]`, we\\'d know to go to `[mid+1, end]` but here, it could even lie in `[start, mid-1]` because we could be on the other side of pivot.\\n\\n- Hence, we do the added checks, to check which range we are currently standing in, i.e.\\n\\t- If `nums[start] <= nums[mid]` => We are in the first part of pivot.\\n\\t- If `nums[start] > nums[mid]` => We are in the second part of pivot.\\n\\n- Post deciding which part of pivot we are in, we simply have to check if `target` lies in current part of pivot or not, and update `start/end` pointers accordingly.\\n\\n- The code is pretty intuitive, so you should be able to get the hang of it from the code now.\\n\\n\\nHere is the code:\\n**Runtime:** 0 ms **(Faster than 100%)**\\n**Memory Usage:** 38.5 MB **(Beats 32.42%)**\\n\\n```\\nclass Solution {\\n    public int search(int[] nums, int target) {\\n        int start = 0, end = nums.length-1, mid;\\n\\n        while (start <= end) {\\n            mid = (start+end)/2;\\n            if (target == nums[mid])\\n                return mid;\\n\\n            if (nums[start] <= nums[mid]) {\\n                if (target >= nums[start] && target < nums[mid])\\n                    end = mid-1;\\n                else\\n                    start = mid+1;\\n            }\\n            else {\\n                if (target > nums[mid] && target <= nums[end]) \\n                        start = mid+1;\\n                else\\n                    end = mid-1;\\n            }\\n        }\\n        return -1;\\n    }\\n}\\n```\\n\\n----------------------------------------------------------------------------------------------------------------------------------\\n\\nIf you find this post helpful, do upvote!\\nHappy Coding!! :)",
                "solutionTags": [
                    "Java",
                    "Binary Tree"
                ],
                "code": "```\\nclass Solution {\\n    public int search(int[] nums, int target) {\\n        int start = 0, end = nums.length-1, mid;\\n\\n        while (start <= end) {\\n            mid = (start+end)/2;\\n            if (target == nums[mid])\\n                return mid;\\n\\n            if (nums[start] <= nums[mid]) {\\n                if (target >= nums[start] && target < nums[mid])\\n                    end = mid-1;\\n                else\\n                    start = mid+1;\\n            }\\n            else {\\n                if (target > nums[mid] && target <= nums[end]) \\n                        start = mid+1;\\n                else\\n                    end = mid-1;\\n            }\\n        }\\n        return -1;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 422098,
                "title": "python-40ms-o-logn-one-pass-binary-search",
                "content": "One pass python solution using binary search. Time: O(logN). Space: O(1)\\n```\\nclass Solution:\\n    def search(self, nums: List[int], target: int) -> int:\\n        start, end = 0, len(nums) - 1\\n       \\n        while start <= end:\\n            mid = (start+end)//2\\n            \\n            if nums[mid] == target:\\n                return mid\\n            \\n            elif nums[mid]<target:\\n                if nums[start]<= target and nums[start] > nums[mid]:\\n                    end = mid -1\\n                else:\\n                    start = mid+1\\n            \\n            elif nums[mid]>target:\\n                if target<=nums[end] and nums[end]<nums[mid]:\\n                    start = mid+1\\n                else:\\n                    end = mid -1 \\n        \\n        return -1\\n\\n```",
                "solutionTags": [
                    "Python",
                    "Python3",
                    "Binary Tree"
                ],
                "code": "```\\nclass Solution:\\n    def search(self, nums: List[int], target: int) -> int:\\n        start, end = 0, len(nums) - 1\\n       \\n        while start <= end:\\n            mid = (start+end)//2\\n            \\n            if nums[mid] == target:\\n                return mid\\n            \\n            elif nums[mid]<target:\\n                if nums[start]<= target and nums[start] > nums[mid]:\\n                    end = mid -1\\n                else:\\n                    start = mid+1\\n            \\n            elif nums[mid]>target:\\n                if target<=nums[end] and nums[end]<nums[mid]:\\n                    start = mid+1\\n                else:\\n                    end = mid -1 \\n        \\n        return -1\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 14571,
                "title": "10-lines-simple-and-concise-c-solution-with-detailed-explanation-and-thought-process",
                "content": "**THOUGHT**:\\n\\nWe know that a normal sorted array has an increasing trend from beginning to the end, but a rotated array may have some point that break the trend. For example, 4 5 6 7 1 2 3, if you look at 4 5 6 7 and 1 2 3 separately, you see two increasing sub-array, and the observation is: \\n\\n**The rightmost number of the second sub-array is smaller than the leftmost number of the first sub-array if there exists and rotated position**\\n\\nSo every time, when we get the mid position, compare to nums[r] to see if the rotated position is on the right half:\\n1) If nums[mid] > nums[r], which not follows the increasing trend, so we know that the rotated position (smallest number in this array) is on the right side of mid position, so please have some thought here, what kind of numbers will be on the right side? It should be either numbers greater than nums[mid] or less than or equal to nums[r]. So check if target is in this range, if yes, we pick the right side by updating index l to mid + 1, otherwise, we pick the left side. Giving an example here, \\n4 5 6 7 **8 1 2 3**. So here, nums[mid] = 7, nums[r] = 3, you'll see numbers greater than 7 (number 8) and numbers <= nums[r] (number 1, 2, 3) are on the right side of mid. \\n\\n2) If nums[mid] < nums[r], we know that  the numbers on the right side are in pure increasing order now, and if target falls into this range, we pick the right side, otherwise, we pick the left side.\\n\\nHope this makes sense.\\n\\n\\n    class Solution {\\n    public:\\n        int search(vector<int>& nums, int target) {\\n            int l = 0, r = nums.size() - 1;\\n            \\n            while(l <= r){ \\n                int mid = l + (r - l) / 2;\\n                \\n                if(nums[mid] == target) return mid;\\n                if(nums[mid] > nums[r]){\\n                    if(target > nums[mid] || target <= nums[r]) l = mid + 1;   // condition for pick right side\\n                    else r = mid - 1;    // else, pick left side\\n                }else{\\n                    if(target <= nums[r] && target > nums[mid]) l = mid + 1;  // condition for pick right side\\n                    else r = mid - 1;     // else, pick left side\\n                } \\n            }\\n            \\n            return -1;\\n        }\\n    };",
                "solutionTags": [
                    "C++"
                ],
                "code": "class Solution {\\n    public:\\n        int search(vector<int>& nums, int target) {\\n            int l = 0, r = nums.size() - 1;\\n            \\n            while(l <= r){ \\n                int mid = l + (r - l) / 2;\\n                \\n                if(nums[mid] == target) return mid;\\n                if(nums[mid] > nums[r]){\\n                    if(target > nums[mid] || target <= nums[r]) l = mid + 1;   // condition for pick right side\\n                    else r = mid - 1;    // else, pick left side\\n                }",
                "codeTag": "Java"
            },
            {
                "id": 14581,
                "title": "javascript-ac-code",
                "content": "The idea is: the rotated array has to fall into 2 categories: smallest on the left side or right side:\\n4, 5, 6, 7 | 8, 1, 2, 3\\n7, 8, 1, 2 | 3, 4, 5, 6\\nThis can be determined by comparing:\\nIf nums[head] < nums[mid], first case;\\nIf nums[head] > nums[mid], second case;\\nThen we just need to determine: in which situation, target falls onto left side; Else, it must be on right side; The long \"else if\" case in the code is doing exactly that.\\n\\nNote that the edge cases like: only 1 element or or elements are automatically handled, because of \"else\". In those cases, we first need to compare nums[mid] and target, if mid is not target, we just need to advance the head/tail, so head > tail, then we can return -1;\\n\\n    /**\\n     * @param {number[]} nums\\n     * @param {number} target\\n     * @return {number}\\n     */\\n    var search = function(nums, target) {\\n      if (nums.length === 0) return -1;\\n      \\n      var index = -1,\\n        head = 0,\\n        tail = nums.length - 1,\\n        mid;\\n      \\n      while (head <= tail) {\\n        mid = Math.floor((head + tail) / 2);\\n        if (nums[mid] === target) {\\n          index = mid;\\n          break;\\n        } else if ((nums[head] <= target && target < nums[mid]) ||\\n                   (nums[head] > nums[mid] && (nums[head] <= target || target < nums[mid]))) {\\n          tail = mid - 1;\\n        } else {\\n          head = mid + 1;\\n        }\\n      }\\n      \\n      return index;\\n    };",
                "solutionTags": [
                    "JavaScript",
                    "Binary Tree"
                ],
                "code": "The idea is: the rotated array has to fall into 2 categories: smallest on the left side or right side:\\n4, 5, 6, 7 | 8, 1, 2, 3\\n7, 8, 1, 2 | 3, 4, 5, 6\\nThis can be determined by comparing:\\nIf nums[head] < nums[mid], first case;\\nIf nums[head] > nums[mid], second case;\\nThen we just need to determine: in which situation, target falls onto left side; Else, it must be on right side; The long \"else if\" case in the code is doing exactly that.\\n\\nNote that the edge cases like: only 1 element or or elements are automatically handled, because of \"else\". In those cases, we first need to compare nums[mid] and target, if mid is not target, we just need to advance the head/tail, so head > tail, then we can return -1;\\n\\n    /**\\n     * @param {number[]} nums\\n     * @param {number} target\\n     * @return {number}\\n     */\\n    var search = function(nums, target) {\\n      if (nums.length === 0) return -1;\\n      \\n      var index = -1,\\n        head = 0,\\n        tail = nums.length - 1,\\n        mid;\\n      \\n      while (head <= tail) {\\n        mid = Math.floor((head + tail) / 2);\\n        if (nums[mid] === target) {\\n          index = mid;\\n          break;\\n        } else if ((nums[head] <= target && target < nums[mid]) ||\\n                   (nums[head] > nums[mid] && (nums[head] <= target || target < nums[mid]))) {\\n          tail = mid - 1;\\n        } else {\\n          head = mid + 1;\\n        }\\n      }\\n      \\n      return index;\\n    };",
                "codeTag": "Unknown"
            },
            {
                "id": 2228304,
                "title": "faster-than-90-solutions-best-interview-code",
                "content": "![image](https://assets.leetcode.com/users/images/f6cbf215-fc9c-4069-9d8a-a9c125fa2bb4_1656777163.082676.png)\\n\\nLet\\'s start with an important observation that:\\n``` \\n\\t\\t\\t\\n\\t\\t\\tnums = [5, 6, 7, 1, 2, 3, 4] \\n\\t\\t\\t\\t\\t\\t \\uD83D\\uDD3A\\n\\t\\t\\t\\t\\t    Pivot\\n\\t\\t\\t\\t\\t\\t\\n\\t\\t\\tn = len(nums)\\n\\t\\t\\t\\n```\\n\\n* the rotated array has **two sorted** parts\\n\\t* Part 1: \\n\\t\\t* nums[i] <= nums[n-1]\\n\\t\\t* i.e. : 1,2,3,4\\n\\t\\t\\n\\t* Part 2:\\n\\t\\t* nums[i] > nums[n-1]\\n\\t\\t*  i.e. : 5,6,7\\n\\n* Understand that if we somehow we know the index of the element that seprates the two parts (Pivot) then we will have an idea about - in which part our target element is present\\n\\t* In the given example, firstly we need to find the index of \\'7\\' which is the pivot element\\n\\n### **How to find the index of Pivot element?**\\n\\n* We will use the same property that defined Part1 and Part2 to find the pivot index\\n* Reminder \\n\\t* \"Pivot is in Part2\"\\n\\t* the unique property of pivot is that, the pivot element is greater than next index element ( 7 > 1)\\n\\t\\t* **nums[idx] > nums[idx+1]** (idx = index of pivot)\\n\\t\\t\\n* As we want optimized approach so we will use binary search to find the pivot index\\n```\\n def pivotIndex(nums):\\n            low = 0\\n            high = n-1\\n            while low <= high:\\n                m = (low + high)//2\\n                if nums[m] <= nums[n-1]:           # we are in part 1 but pivot is in part2, move left\\n                    high = m-1\\n                else:                                              # we are in part2\\n                    if nums[m] > nums[m+1]:        # using the property of pivot element, if on pivot element\\n                        return m\\n                    else:\\n                        low = m+1                           # still in part2 but in left of pivot element, need to move to right\\n\\t\\t\\t\\t\\t\\t\\n            return high\\n```\\n\\n* Now, we exactly know that \\n\\t* part2 : [0, pivot]\\n\\t* part1 : [pivot+1, n-1]\\n\\t\\n* We will not blindly run binary search, we will compare the target and nums[n-1], this step will tell us our target is present in part1 or part2. (use if-else condition)\\n\\n* Now, we just need to pass the start and end position of binary search based on target in part1 or part2\\n\\n* **Edge Case:** You might miss this case so be careful about the fact that maybe the nums array is not rotated, that is rotation = 0, ex: [1,2,3,4,5,6,7]\\n\\n\\t* In this case, we need to run binary search on whole nums array\\n\\t\\n\\t* this case needs to be handled, the comment in the code indicates how we have handled this case\\n\\n### Complete Code:\\n\\n```\\nclass Solution:\\n    def search(self, nums: List[int], target: int) -> int:\\n        \\n        n = len(nums)\\n        \\n        if len(nums) == 1 and nums[0] == target:\\n            return 0\\n        \\n        # pivot index finding\\n        \\n        # [PART2 with pivot, PART1]\\n        \\n        def pivotIndex(nums):\\n            low = 0\\n            high = n-1\\n            while low <= high:\\n                m = (low + high)//2\\n                if nums[m] <= nums[n-1]:\\n                    high = m-1\\n                else:\\n                    if nums[m] > nums[m+1]:\\n                        return m\\n                    else:\\n                        low = m+1\\n                    \\n            return high\\n        \\n        pivot = pivotIndex(nums)\\n            \\n        def binarySearch(start, end):\\n            while start <= end:\\n                m = (start+end)//2\\n                if nums[m] == target:\\n                    return m\\n                elif nums[m] > target:\\n                    end = m-1\\n                elif nums[m] < target:\\n                    start = m+1\\n            return -1\\n        \\n\\t\\t\\n        if target <= nums[n-1]:\\n            if pivot == -1:           # if edge case: number of rotation in array = 0, either check low > high or pivot = -1\\n                ans = binarySearch(0, n-1)\\n            else:\\n                ans = binarySearch(pivot+1, n-1)   # search part 1\\n        else:\\n            ans = binarySearch(0, pivot)               # search part2\\n            \\n        return ans\\n       \\n```\\n**Time Complexity: O(logN)**\\n**Space Complexity: O(1)**\\n\\n***I hope this explanation was helpful, please make sure to UPVOTE so that it can rank higher in discussion***",
                "solutionTags": [
                    "Python",
                    "Binary Search",
                    "Binary Tree"
                ],
                "code": "``` \\n\\t\\t\\t\\n\\t\\t\\tnums = [5, 6, 7, 1, 2, 3, 4] \\n\\t\\t\\t\\t\\t\\t \\uD83D\\uDD3A\\n\\t\\t\\t\\t\\t    Pivot\\n\\t\\t\\t\\t\\t\\t\\n\\t\\t\\tn = len(nums)\\n\\t\\t\\t\\n```\n```\\n def pivotIndex(nums):\\n            low = 0\\n            high = n-1\\n            while low <= high:\\n                m = (low + high)//2\\n                if nums[m] <= nums[n-1]:           # we are in part 1 but pivot is in part2, move left\\n                    high = m-1\\n                else:                                              # we are in part2\\n                    if nums[m] > nums[m+1]:        # using the property of pivot element, if on pivot element\\n                        return m\\n                    else:\\n                        low = m+1                           # still in part2 but in left of pivot element, need to move to right\\n\\t\\t\\t\\t\\t\\t\\n            return high\\n```\n```\\nclass Solution:\\n    def search(self, nums: List[int], target: int) -> int:\\n        \\n        n = len(nums)\\n        \\n        if len(nums) == 1 and nums[0] == target:\\n            return 0\\n        \\n        # pivot index finding\\n        \\n        # [PART2 with pivot, PART1]\\n        \\n        def pivotIndex(nums):\\n            low = 0\\n            high = n-1\\n            while low <= high:\\n                m = (low + high)//2\\n                if nums[m] <= nums[n-1]:\\n                    high = m-1\\n                else:\\n                    if nums[m] > nums[m+1]:\\n                        return m\\n                    else:\\n                        low = m+1\\n                    \\n            return high\\n        \\n        pivot = pivotIndex(nums)\\n            \\n        def binarySearch(start, end):\\n            while start <= end:\\n                m = (start+end)//2\\n                if nums[m] == target:\\n                    return m\\n                elif nums[m] > target:\\n                    end = m-1\\n                elif nums[m] < target:\\n                    start = m+1\\n            return -1\\n        \\n\\t\\t\\n        if target <= nums[n-1]:\\n            if pivot == -1:           # if edge case: number of rotation in array = 0, either check low > high or pivot = -1\\n                ans = binarySearch(0, n-1)\\n            else:\\n                ans = binarySearch(pivot+1, n-1)   # search part 1\\n        else:\\n            ans = binarySearch(0, pivot)               # search part2\\n            \\n        return ans\\n       \\n```",
                "codeTag": "Java"
            },
            {
                "id": 2023121,
                "title": "c-easy-to-understand-detailed-explanation-beginner-friendly-binary-search-o-log-n",
                "content": "Ayo, here\\'s another solution! Pretty simple if you get the idea.\\n\\nHere\\'s what\\'s important:\\n- We do regular binary search on the array. We need to find a target but the array is rotated. What do we do?\\n- Did you see how there are 2 parts in the array that are sorted?\\n- For array [4,5,6,7,0,1,2]\\n\\t- Part 1: [4,5,6,7]\\n\\t- Part 2: [0,1,2]\\n- This is the only thing that\\'s going to help us solve the problem.\\n\\nApply regular binary search on the array, but here\\'s what we\\'re going to change:\\n1. Calculate mid as usual.\\n2. First, check if the array has been rotated by checking if you\\'re in the 1st or 2nd part of the array.\\n3. If you\\'re in first part, your arr[low] will be smaller than arr[mid] because remember, the 1st part of the array is sorted.\\n\\n4. If the number at low is indeed smaller than mid, then we search for the target in this low->mid range. \\n\\t**A.** So, check if target is greater/equal to low and target is smaller than mid (but not smaller or equal because if it were equal to mid, we would have returned the answer). If it does lie between low and mid, let\\'s narrow search down to low to mid by making our high equal to mid.\\n\\t**B.** If the target doesn\\'t lie between low and mid, then surely it must lie beyond mid. So we narrow search down to `mid+1` to `high` by setting `low = mid + 1`.\\n\\n7. Similarly, check again for array rotation. If mid is not greater than low, then it must be smaller than low. Which means we\\'re in the 2nd sorted part of the array.\\n\\t**A.** So, check if target is greater than mid and target is smaller/equal to high. If it does lie between mid and high, let\\'s narrow search down to mid to mid by making our low equal to mid+1.\\n\\t**B.** If the target doesn\\'t lie between mid and high, then it\\'s probably because it\\'s greater than both mid and high, meaning that it belongs in the 1st part of rotated sorted array. So we narrow search down to `low` to `mid` by setting `low = mid`.\\n\\nSo basically, binary search stuff comes later, we just first check what part of the rotation we\\'re in before making any moves.\\n\\t\\n```cpp\\nclass Solution {\\npublic:\\n    int search(vector<int>& nums, int target) {\\n        int low = 0;\\n        int high = nums.size() - 1;\\n        \\n        while(low <= high){\\n            int mid = low + (high - low) / 2;\\n            \\n            if(nums[mid] == target){\\n                return mid;\\n            }\\n            \\n            // if low is less than mid (not less or equal because equal is handled by the previous if statement), then low to mid is sorted\\n            if (nums[low] <= nums[mid]){\\n                // if target is between low to mid,\\n                // narrow search down to low to mid\\n                if(target >= nums[low] and target <= nums[mid]){\\n                    high = mid;\\n                } else {\\n                    // if target is beyond mid\\n                    // narrow search down to mid + 1 to high\\n                    low = mid + 1;\\n                }\\n                // if low is greater than mid,\\n                // then we\\'re in the rotated part\\n            } else if (nums[low] > nums[mid]){\\n                // if target is between mid to high\\n                // narrow search down to mid to high\\n                if(target >= nums[mid] and target <= nums[high]){\\n                    low = mid + 1;\\n                } else {\\n                    // if target is greater than high and mid both\\n                    // narrow search down to the second part before\\n                    // mid. So low to mid.\\n                    high = mid;\\n                }\\n            }\\n        }\\n        \\n        return -1;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "C",
                    "Binary Tree"
                ],
                "code": "```cpp\\nclass Solution {\\npublic:\\n    int search(vector<int>& nums, int target) {\\n        int low = 0;\\n        int high = nums.size() - 1;\\n        \\n        while(low <= high){\\n            int mid = low + (high - low) / 2;\\n            \\n            if(nums[mid] == target){\\n                return mid;\\n            }\\n            \\n            // if low is less than mid (not less or equal because equal is handled by the previous if statement), then low to mid is sorted\\n            if (nums[low] <= nums[mid]){\\n                // if target is between low to mid,\\n                // narrow search down to low to mid\\n                if(target >= nums[low] and target <= nums[mid]){\\n                    high = mid;\\n                } else {\\n                    // if target is beyond mid\\n                    // narrow search down to mid + 1 to high\\n                    low = mid + 1;\\n                }\\n                // if low is greater than mid,\\n                // then we\\'re in the rotated part\\n            } else if (nums[low] > nums[mid]){\\n                // if target is between mid to high\\n                // narrow search down to mid to high\\n                if(target >= nums[mid] and target <= nums[high]){\\n                    low = mid + 1;\\n                } else {\\n                    // if target is greater than high and mid both\\n                    // narrow search down to the second part before\\n                    // mid. So low to mid.\\n                    high = mid;\\n                }\\n            }\\n        }\\n        \\n        return -1;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 943288,
                "title": "c-double-binary-search-solution-explained-100-time-40-space",
                "content": "Nice one to practice a bit binary searches, since with my approach we will need it not once, but twice - one to find the rotational pivot, one to find the actual element.\\n\\nWe will need first of all a few support variables:\\n* `len` will store the lenght of `nums`;\\n* `l`, `r` and `mid` will be the cogs of our binary search, witht the first 2 initialised to be `0` and `len`, respectively.\\n\\nOne peculiar case is when `l == len`, which means the array is fully sorted, so we have to check inside all of it, resetting `l` to `0`.\\n\\nWe proceed then with the first binary search to find the pivot around which the vector/array was rotated, looping as long as `l < r`:\\n* at each step we compute first of all `mid` as the average of `l` and `r`;\\n* if `nums[mid]` is greater than or equal to the first element, it means we need to keep looking to the right to find a pivot, so we update the value of `l`;\\n* conversely, it means we need to search to the left, so we update `r` before iterating again.\\n\\nOnce we move out of the first search, we have the index of what would be the first element in a fully sorted vector - and that is also the smallest one, so at this point we can decide if we want to search either in the `[0 - l)` or in the `[l - len)` range.\\n\\nWe proceed rather trivially with a similar approach to the previous to look for `target` in the interval we just decided, with an extra step:\\n* we check if `mid` is by any chance already pointing at the value of `target` - this might not be ideal in terms of performance, but I noticed that it avoided me a few annoying edge cases. If so, we just return `mid`;\\n* depending on the value of `nums[mid]` compared to `target`, we either move right (updating `l`) or left (updating `r`).\\n\\nProvided we did not encounter it already as a value of `mid`, once we exit the loop we return `l` if it points to `target`, `-1` othewise.\\n\\nThe code:\\n\\n```cpp\\nclass Solution {\\npublic:\\n    int search(vector<int>& nums, int target) {\\n        // support variables\\n        int len = nums.size(), l = 0, r = len, mid;\\n        // finding the pivot\\n        while (l < r) {\\n            mid = (l + r) / 2;\\n            // current element > first elemen: we move the window right\\n            if (nums[mid] >= nums[0]) l = mid + 1;\\n            // otherwise we move it left\\n            else r = mid;\\n        }\\n        // checking for edge case - pivot at the end = sorted vector\\n        if (l == len) l = 0;\\n        // preparing for the next BS: target is between pivot and the last element\\n        if (target >= nums[l] && target <= nums.back()) r = len;\\n        // target is between the first element and the one before pivot\\n        else r = l, l = 0;\\n        // all other cases\\n        // finding the element\\n        while (l < r) {\\n            mid = (l + r) / 2;\\n            // mid matches the target element: we return it\\n            if (nums[mid] == target) return mid;\\n            // mid matches an element smaller than target: we move the window right\\n            else if (nums[mid] < target) l = mid + 1;\\n            // otherwise we move it left\\n            else r = mid;\\n        }\\n        return nums[l] == target ? l : -1;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "C",
                    "Binary Search",
                    "Binary Tree"
                ],
                "code": "```cpp\\nclass Solution {\\npublic:\\n    int search(vector<int>& nums, int target) {\\n        // support variables\\n        int len = nums.size(), l = 0, r = len, mid;\\n        // finding the pivot\\n        while (l < r) {\\n            mid = (l + r) / 2;\\n            // current element > first elemen: we move the window right\\n            if (nums[mid] >= nums[0]) l = mid + 1;\\n            // otherwise we move it left\\n            else r = mid;\\n        }\\n        // checking for edge case - pivot at the end = sorted vector\\n        if (l == len) l = 0;\\n        // preparing for the next BS: target is between pivot and the last element\\n        if (target >= nums[l] && target <= nums.back()) r = len;\\n        // target is between the first element and the one before pivot\\n        else r = l, l = 0;\\n        // all other cases\\n        // finding the element\\n        while (l < r) {\\n            mid = (l + r) / 2;\\n            // mid matches the target element: we return it\\n            if (nums[mid] == target) return mid;\\n            // mid matches an element smaller than target: we move the window right\\n            else if (nums[mid] < target) l = mid + 1;\\n            // otherwise we move it left\\n            else r = mid;\\n        }\\n        return nums[l] == target ? l : -1;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2615822,
                "title": "java-binary-search-o-logn-explanation-in-detail",
                "content": "```\\nclass Solution {\\n    public int search(int[] nums, int target) {\\n        // define pointers\\n        int left = 0, right = nums.length - 1;\\n        \\n\\t\\t// Loop while to narrow down left and right pointer\\n        while(left <= right){\\n            int mid = left + (right - left)/2;\\n            if(nums[mid] == target) return mid;\\n            \\n            // These line of code will do:\\n            // From middle, we will look from LEFT and RIGHT to know LEFT portion is SORTED or RIGHT portion is SORTED\\n            // Besides, we use target to narrow down left and right pointer\\n            if(nums[left] <= nums[mid]){\\n                // from left to mid, all elements are sorted. It means LEFT portion of mid are SORTED\\n                // find target belong to THIS LEFT portion or not\\n                // [4,5,6,7,8,9,0,1,2]\\n                //  l       m       r\\n                //  l     r            (Ex: target = 5) - YES                \\n                //            l     r. (Ex: target = 1) - NO   \\n                if(nums[left] <= target && target < nums[mid]){ // Why we check target < nums[mid] (NOT target <= nums[mid]) HERE, BECAUSE we checked ABOVE (if(nums[mid] == target) return mid;)\\n                    // YES: target belong to LEFT portion that sorted\\n                    right = mid - 1;\\n                } else {\\n                    // NO: target belong to RIGHT portion (BUT we not sort it is sorted or not)\\n                    left = mid + 1;\\n                }                \\n            } else if (nums[mid] <= nums[right]) {\\n                // from mid to right, all elements are sorted. It means RIGHT portion of mid are SORTED\\n                // find target belong to THIS RIGHT portion or not\\n                // [7,8,0,1,2,4,5,6,9]\\n                //  l       m       r\\n                //            l     r. (Ex: target = 5) - YES\\n                //  l     r            (Ex: target = 1) - NO\\n                if(nums[mid] < target && target <= nums[right]){ // Why we check &&  nums[mid] < target (NOT nums[mid] <= target) HERE, BECAUSE we checked ABOVE (if(nums[mid] == target) return mid;)\\n                    // YES: target belong to RIGHT portion that sorted\\n                    left = mid + 1;\\n                } else {\\n                    // NO: target belong to LEFT portion (BUT we not sort it is sorted or not)\\n                    right = mid - 1;\\n                }\\n            }\\n            \\n            // When we go here, we DID narrow down left and right pointer. \\n\\t\\t\\t// The loop while will continue AND left and right pointer will be NARROW down again and again (In worst case, left = right = middle)\\n\\t\\t\\t// If target found on array, we will found it at MIDDLE and return. (at line - if(nums[mid] == target) return mid;)\\n            // If not, we will go out of loop and RETURN -1 at the end.\\n        }\\n        \\n        return -1;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Binary Tree"
                ],
                "code": "```\\nclass Solution {\\n    public int search(int[] nums, int target) {\\n        // define pointers\\n        int left = 0, right = nums.length - 1;\\n        \\n\\t\\t// Loop while to narrow down left and right pointer\\n        while(left <= right){\\n            int mid = left + (right - left)/2;\\n            if(nums[mid] == target) return mid;\\n            \\n            // These line of code will do:\\n            // From middle, we will look from LEFT and RIGHT to know LEFT portion is SORTED or RIGHT portion is SORTED\\n            // Besides, we use target to narrow down left and right pointer\\n            if(nums[left] <= nums[mid]){\\n                // from left to mid, all elements are sorted. It means LEFT portion of mid are SORTED\\n                // find target belong to THIS LEFT portion or not\\n                // [4,5,6,7,8,9,0,1,2]\\n                //  l       m       r\\n                //  l     r            (Ex: target = 5) - YES                \\n                //            l     r. (Ex: target = 1) - NO   \\n                if(nums[left] <= target && target < nums[mid]){ // Why we check target < nums[mid] (NOT target <= nums[mid]) HERE, BECAUSE we checked ABOVE (if(nums[mid] == target) return mid;)\\n                    // YES: target belong to LEFT portion that sorted\\n                    right = mid - 1;\\n                } else {\\n                    // NO: target belong to RIGHT portion (BUT we not sort it is sorted or not)\\n                    left = mid + 1;\\n                }                \\n            } else if (nums[mid] <= nums[right]) {\\n                // from mid to right, all elements are sorted. It means RIGHT portion of mid are SORTED\\n                // find target belong to THIS RIGHT portion or not\\n                // [7,8,0,1,2,4,5,6,9]\\n                //  l       m       r\\n                //            l     r. (Ex: target = 5) - YES\\n                //  l     r            (Ex: target = 1) - NO\\n                if(nums[mid] < target && target <= nums[right]){ // Why we check &&  nums[mid] < target (NOT nums[mid] <= target) HERE, BECAUSE we checked ABOVE (if(nums[mid] == target) return mid;)\\n                    // YES: target belong to RIGHT portion that sorted\\n                    left = mid + 1;\\n                } else {\\n                    // NO: target belong to LEFT portion (BUT we not sort it is sorted or not)\\n                    right = mid - 1;\\n                }\\n            }\\n            \\n            // When we go here, we DID narrow down left and right pointer. \\n\\t\\t\\t// The loop while will continue AND left and right pointer will be NARROW down again and again (In worst case, left = right = middle)\\n\\t\\t\\t// If target found on array, we will found it at MIDDLE and return. (at line - if(nums[mid] == target) return mid;)\\n            // If not, we will go out of loop and RETURN -1 at the end.\\n        }\\n        \\n        return -1;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 338285,
                "title": "python-o-log-n-solution-with-explanation-beats-98-time-and-space-complexity",
                "content": "To solve this question, we need to apply binary search with a twist which is that the list is pivoted.\\n\\nIn order to account for the pivot, we introduce the following conditions:\\n1. If start is less than mid than the list is in increasing order:\\n\\t* \\tIf Start <= target < mid: The target must be between start and mid\\n\\t* \\tElse: Target must be between mid and end\\n\\t \\t\\n2. Start is greater than mid, list is pivoted somewhere in the middle of start and mid\\n\\t* \\tIf mid < target < start: The target must be between mid and end\\n\\t* \\tElse: Target must be between start and mid\\n\\n```\\nclass Solution:\\n    def search(self, nums: List[int], target: int) -> int:\\n        \\n        start = 0\\n        end = len(nums) - 1\\n\\n        while ( start <= end ):\\n            mid = ( start + end ) // 2\\n            # found the element\\n            if nums[mid] == target:\\n                return mid\\n            # Couldn\\'t find the element in the list\\n            elif( start == mid == end ):\\n                return -1\\n            \\n            # start is less than mid, list is in increasing order                \\n            elif ( nums[start] <= nums[mid] ):\\n                \\n                # target is greater than equal to start & smaller than mid\\n                if( nums[start] <= target < nums[mid] ):\\n                    end = mid\\n                \\n                # target is smaller than start & mid\\n                # target is greater than start & greater than mid\\n                else:\\n                    start = mid + 1\\n            \\n            # start is greater than mid, list is pivoted\\n            else: #( nums[start] > nums[mid] ):\\n                # target is smaller than start & greater than mid\\n                if ( nums[mid] < target < nums[start] ):\\n                    start = mid + 1\\n                \\n                # target is smaller than start & smaller than mid\\n                # target is greater than start & greater than mid\\n                else:\\n                    end = mid\\n\\n        return -1\\n```\\n\\nSome helpful test cases:\\n\\n```\\n[4,5,6,7,0,1,2]\\n4\\n[4,5,6,7,0,1,2]\\n5\\n[4,5,6,7,0,1,2]\\n6\\n[4,5,6,7,0,1,2]\\n7\\n[4,5,6,7,0,1,2]\\n0\\n[4,5,6,7,0,1,2]\\n1\\n[4,5,6,7,0,1,2]\\n2\\n[6,7,0,1,2,4,5]\\n4\\n[6,7,0,1,2,4,5]\\n5\\n[6,7,0,1,2,4,5]\\n6\\n[6,7,0,1,2,4,5]\\n7\\n[6,7,0,1,2,4,5]\\n0\\n[6,7,0,1,2,4,5]\\n1\\n[6,7,0,1,2,4,5]\\n2\\n[6,7,0,1,2,4,5]\\n3\\n[0,1,2,3,4,5,6,7]\\n4\\n[0,1,2,3,4,5,6,7]\\n5\\n[0,1,2,3,4,5,6,7]\\n6\\n[0,1,2,3,4,5,6,7]\\n7\\n[0,1,2,3,4,5,6,7]\\n0\\n[0,1,2,3,4,5,6,7]\\n1\\n[0,1,2,3,4,5,6,7]\\n2\\n[0,1,2,3,4,5,6,7]\\n3\\n[4,5,6,7,0,1,2,3]\\n4\\n[4,5,6,7,0,1,2,3]\\n5\\n[4,5,6,7,0,1,2,3]\\n6\\n[4,5,6,7,0,1,2,3]\\n7\\n[4,5,6,7,0,1,2,3]\\n0\\n[4,5,6,7,0,1,2,3]\\n1\\n[4,5,6,7,0,1,2,3]\\n2\\n[4,5,6,7,0,1,2,3]\\n3\\n```",
                "solutionTags": [
                    "Python",
                    "Python3",
                    "Binary Search"
                ],
                "code": "```\\nclass Solution:\\n    def search(self, nums: List[int], target: int) -> int:\\n        \\n        start = 0\\n        end = len(nums) - 1\\n\\n        while ( start <= end ):\\n            mid = ( start + end ) // 2\\n            # found the element\\n            if nums[mid] == target:\\n                return mid\\n            # Couldn\\'t find the element in the list\\n            elif( start == mid == end ):\\n                return -1\\n            \\n            # start is less than mid, list is in increasing order                \\n            elif ( nums[start] <= nums[mid] ):\\n                \\n                # target is greater than equal to start & smaller than mid\\n                if( nums[start] <= target < nums[mid] ):\\n                    end = mid\\n                \\n                # target is smaller than start & mid\\n                # target is greater than start & greater than mid\\n                else:\\n                    start = mid + 1\\n            \\n            # start is greater than mid, list is pivoted\\n            else: #( nums[start] > nums[mid] ):\\n                # target is smaller than start & greater than mid\\n                if ( nums[mid] < target < nums[start] ):\\n                    start = mid + 1\\n                \\n                # target is smaller than start & smaller than mid\\n                # target is greater than start & greater than mid\\n                else:\\n                    end = mid\\n\\n        return -1\\n```\n```\\n[4,5,6,7,0,1,2]\\n4\\n[4,5,6,7,0,1,2]\\n5\\n[4,5,6,7,0,1,2]\\n6\\n[4,5,6,7,0,1,2]\\n7\\n[4,5,6,7,0,1,2]\\n0\\n[4,5,6,7,0,1,2]\\n1\\n[4,5,6,7,0,1,2]\\n2\\n[6,7,0,1,2,4,5]\\n4\\n[6,7,0,1,2,4,5]\\n5\\n[6,7,0,1,2,4,5]\\n6\\n[6,7,0,1,2,4,5]\\n7\\n[6,7,0,1,2,4,5]\\n0\\n[6,7,0,1,2,4,5]\\n1\\n[6,7,0,1,2,4,5]\\n2\\n[6,7,0,1,2,4,5]\\n3\\n[0,1,2,3,4,5,6,7]\\n4\\n[0,1,2,3,4,5,6,7]\\n5\\n[0,1,2,3,4,5,6,7]\\n6\\n[0,1,2,3,4,5,6,7]\\n7\\n[0,1,2,3,4,5,6,7]\\n0\\n[0,1,2,3,4,5,6,7]\\n1\\n[0,1,2,3,4,5,6,7]\\n2\\n[0,1,2,3,4,5,6,7]\\n3\\n[4,5,6,7,0,1,2,3]\\n4\\n[4,5,6,7,0,1,2,3]\\n5\\n[4,5,6,7,0,1,2,3]\\n6\\n[4,5,6,7,0,1,2,3]\\n7\\n[4,5,6,7,0,1,2,3]\\n0\\n[4,5,6,7,0,1,2,3]\\n1\\n[4,5,6,7,0,1,2,3]\\n2\\n[4,5,6,7,0,1,2,3]\\n3\\n```",
                "codeTag": "Java"
            },
            {
                "id": 283384,
                "title": "simple-java-solution-beats-100-with-explanation",
                "content": "Basically - the difference from a noraml Binary Search, is the decision to choose the left side or the right side of the array, other than that is pretty much the same.\\n    \\nAs yo probably know, one side has to be in ascendant order, so in order to search on the left side of the array, it has to be in either of those 2 set of conditions:\\n1. \\tThe first and last element of the left side array is in asc order AND the target val is in between those first and last values.\\n1. \\tThe frist and last element of the right side array is in asc order AND the target val is NOT in between those first and last values.\\n\\nOtherwise search for the right side of the array\\n    \\n    public int search(int[] nums, int target) {\\n        \\n        int from = 0;\\n        int to = nums.length -1;\\n        \\n        while(from<=to){\\n\\n            int mid = from + (to-from)/2;\\n            \\n            if(nums[mid] == target){\\n                return mid;\\n            }\\n               \\n            if( isInLeftSide(nums[from], nums[to], nums[mid], target) ){\\n                to = mid-1;\\n            }else {\\n                from = mid+1;\\n            }\\n        }\\n        \\n        return -1;\\n    }\\n    \\n     //Left side is asc order AND is between the target OR  R side is asc order AND is NOT between the target\\n    private boolean isInLeftSide(int from, int to, int mid, int target){\\n        return (from <= mid && isBetweenInclusive(target,from,mid)) || (mid <= to && !isBetweenInclusive(target,mid,to));\\n    }\\n    \\n    private boolean isBetweenInclusive(int target, int from, int to){\\n        return from <=target && to >= target;\\n    }",
                "solutionTags": [
                    "Java",
                    "Binary Tree"
                ],
                "code": "Basically - the difference from a noraml Binary Search, is the decision to choose the left side or the right side of the array, other than that is pretty much the same.\\n    \\nAs yo probably know, one side has to be in ascendant order, so in order to search on the left side of the array, it has to be in either of those 2 set of conditions:\\n1. \\tThe first and last element of the left side array is in asc order AND the target val is in between those first and last values.\\n1. \\tThe frist and last element of the right side array is in asc order AND the target val is NOT in between those first and last values.\\n\\nOtherwise search for the right side of the array\\n    \\n    public int search(int[] nums, int target) {\\n        \\n        int from = 0;\\n        int to = nums.length -1;\\n        \\n        while(from<=to){\\n\\n            int mid = from + (to-from)/2;\\n            \\n            if(nums[mid] == target){\\n                return mid;\\n            }\\n               \\n            if( isInLeftSide(nums[from], nums[to], nums[mid], target) ){\\n                to = mid-1;\\n            }else {\\n                from = mid+1;\\n            }\\n        }\\n        \\n        return -1;\\n    }\\n    \\n     //Left side is asc order AND is between the target OR  R side is asc order AND is NOT between the target\\n    private boolean isInLeftSide(int from, int to, int mid, int target){\\n        return (from <= mid && isBetweenInclusive(target,from,mid)) || (mid <= to && !isBetweenInclusive(target,mid,to));\\n    }\\n    \\n    private boolean isBetweenInclusive(int target, int from, int to){\\n        return from <=target && to >= target;\\n    }",
                "codeTag": "Unknown"
            },
            {
                "id": 174076,
                "title": "binary-search-thinking-process",
                "content": "**Rotated sorted array property**\\nIf we split a `rotated sorted array` in half, one half is monotonic-increasing, the other half itself is a `rotated sorted array`. We can compare the start and end element in a half to tell whether it is monotonic-increasing.\\n\\n**To search for an element in rotated sorted array,**\\n1. Divide `rotated sorted array` in half, \\n2. If `target` in monotonic-increasing half, do **Binary Search**;\\nOtherwise, re-apply the first step on the other half\\n\\n**To reason about the loop**\\n```\\nLoop Invariant: the index of target is in [lo, hi] if target exists in nums (i.e., [lo, hi] is the searching space)\\n\\n// Loop Invariant is true here.\\nwhile searching space is not exhausted,\\n    if nums[mi] == target, return mi\\n\\tif nums[lo] <= nums[mi]\\n\\t\\tif target is in [lo, mi - 1], normal binary search on [lo, mi - 1]\\n\\t\\telse, lo = mi + 1\\n\\telse\\n\\t\\tif target is in [mi + 1, hi], normal binary search on [mi + 1, hi]\\n\\t\\telse, hi = mi - 1 \\n\\t// Loop Invariant is true here.\\nreturn -1\\n```\\n\\n**Python**\\n```\\nclass Solution:\\n    def search(self, nums: List[int], target: int) -> int:\\n        l, r = 0, len(nums) - 1\\n        \\n        while l <= r:\\n            m = (l + r) // 2\\n            if nums[m] == target:\\n                return m\\n            if nums[m] <= nums[r]:\\n                # [m, r] is monotonic increasing\\n                if nums[m] < target <= nums[r]:\\n                    return self.bs(nums, m, r, target)\\n                else:\\n                    r = m - 1\\n            elif nums[l] <= nums[m]:\\n                # [l, r] is monotonic increasing\\n                if nums[l] <= target < nums[m]:\\n                    return self.bs(nums, l, m, target)\\n                else:\\n                    l = m + 1\\n        return -1\\n  \\n\\n    def bs(self, nums, st, en, target):\\n        while st <= en:\\n            mi = (st + en) // 2\\n            if target == nums[mi]:\\n                return mi\\n            elif target < nums[mi]:\\n                en = mi - 1\\n            else:\\n                st = mi + 1\\n        return -1\\n```\\n\\n\\n**Java**\\n```\\n    public int search(int[] nums, int target) {\\n        if (nums.length == 0) {\\n            return -1;\\n        }\\n        \\n        int left = 0;\\n        int right = nums.length - 1;\\n        \\n        while (left <= right) {\\n            int mid = left + (right - left) / 2;\\n            \\n            if (nums[mid] == target) {\\n                return mid;\\n            }\\n            \\n            if (nums[mid] < nums[right]) { // right half sorted\\n                if (nums[mid] < target && target <= nums[right]) { // target within right half\\n                    left = mid + 1; \\n                } else {\\n                    right = mid - 1;\\n                }\\n            } else { // left half sorted\\n                if (nums[left] <= target && target < nums[mid]) { // target within left half\\n                    right = mid - 1;\\n                } else {\\n                    left = mid + 1;\\n                }\\n            }\\n        }\\n        \\n        return -1;\\n    }\\n```",
                "solutionTags": [],
                "code": "```\\nLoop Invariant: the index of target is in [lo, hi] if target exists in nums (i.e., [lo, hi] is the searching space)\\n\\n// Loop Invariant is true here.\\nwhile searching space is not exhausted,\\n    if nums[mi] == target, return mi\\n\\tif nums[lo] <= nums[mi]\\n\\t\\tif target is in [lo, mi - 1], normal binary search on [lo, mi - 1]\\n\\t\\telse, lo = mi + 1\\n\\telse\\n\\t\\tif target is in [mi + 1, hi], normal binary search on [mi + 1, hi]\\n\\t\\telse, hi = mi - 1 \\n\\t// Loop Invariant is true here.\\nreturn -1\\n```\n```\\nclass Solution:\\n    def search(self, nums: List[int], target: int) -> int:\\n        l, r = 0, len(nums) - 1\\n        \\n        while l <= r:\\n            m = (l + r) // 2\\n            if nums[m] == target:\\n                return m\\n            if nums[m] <= nums[r]:\\n                # [m, r] is monotonic increasing\\n                if nums[m] < target <= nums[r]:\\n                    return self.bs(nums, m, r, target)\\n                else:\\n                    r = m - 1\\n            elif nums[l] <= nums[m]:\\n                # [l, r] is monotonic increasing\\n                if nums[l] <= target < nums[m]:\\n                    return self.bs(nums, l, m, target)\\n                else:\\n                    l = m + 1\\n        return -1\\n  \\n\\n    def bs(self, nums, st, en, target):\\n        while st <= en:\\n            mi = (st + en) // 2\\n            if target == nums[mi]:\\n                return mi\\n            elif target < nums[mi]:\\n                en = mi - 1\\n            else:\\n                st = mi + 1\\n        return -1\\n```\n```\\n    public int search(int[] nums, int target) {\\n        if (nums.length == 0) {\\n            return -1;\\n        }\\n        \\n        int left = 0;\\n        int right = nums.length - 1;\\n        \\n        while (left <= right) {\\n            int mid = left + (right - left) / 2;\\n            \\n            if (nums[mid] == target) {\\n                return mid;\\n            }\\n            \\n            if (nums[mid] < nums[right]) { // right half sorted\\n                if (nums[mid] < target && target <= nums[right]) { // target within right half\\n                    left = mid + 1; \\n                } else {\\n                    right = mid - 1;\\n                }\\n            } else { // left half sorted\\n                if (nums[left] <= target && target < nums[mid]) { // target within left half\\n                    right = mid - 1;\\n                } else {\\n                    left = mid + 1;\\n                }\\n            }\\n        }\\n        \\n        return -1;\\n    }\\n```",
                "codeTag": "Java"
            },
            {
                "id": 14619,
                "title": "simple-and-easy-understanding-java-solution",
                "content": "    public int search(int[] nums, int target) {\\n\\t\\t        int pivot = findPivot(nums);\\n\\t\\t        return binarySearch(nums, 0, pivot, target) + binarySearch(nums, pivot + 1, nums.length - 1, target) + 1;\\n\\t\\t    }\\n\\t\\t \\t\\n\\t\\t \\tpublic int findPivot(int nums[]){\\n\\t\\t \\t\\tint i = 0, j = nums.length - 1;\\n\\t\\t\\t\\twhile(i < j - 1){\\n\\t\\t\\t\\t\\tint mid = i + (j - i) / 2;\\n\\t\\t\\t\\t\\tif(nums[i] < nums[mid] && nums[j] < nums[mid]){\\n\\t\\t\\t\\t\\t\\ti = mid;\\n\\t\\t\\t\\t\\t}else {\\n\\t\\t\\t\\t\\t\\tj = mid;\\n\\t\\t\\t\\t\\t}\\n\\t\\t\\t\\t}\\n\\t\\t \\t\\treturn i;\\n\\t\\t \\t}\\n\\t\\t \\t\\n\\t\\t \\tpublic int binarySearch(int a[], int start, int end, int key){\\n\\t\\t\\t\\tint i = start, j = end;\\n\\t\\t\\t\\twhile(i <= j){\\n\\t\\t\\t\\t\\tint mid = i + (j - i) / 2;\\n\\t\\t\\t\\t\\tif(a[mid] > key){\\n\\t\\t\\t\\t\\t\\tj = mid - 1;\\n\\t\\t\\t\\t\\t}else if(a[mid] < key){\\n\\t\\t\\t\\t\\t\\ti = mid + 1;\\n\\t\\t\\t\\t\\t}\\n\\t\\t\\t\\t\\telse return mid;\\n\\t\\t\\t\\t}\\n\\t\\t\\t\\treturn -1;\\n\\t\\t\\t}",
                "solutionTags": [
                    "Java"
                ],
                "code": "    public int search(int[] nums, int target) {\\n\\t\\t        int pivot = findPivot(nums);\\n\\t\\t        return binarySearch(nums, 0, pivot, target) + binarySearch(nums, pivot + 1, nums.length - 1, target) + 1;\\n\\t\\t    }\\n\\t\\t \\t\\n\\t\\t \\tpublic int findPivot(int nums[]){\\n\\t\\t \\t\\tint i = 0, j = nums.length - 1;\\n\\t\\t\\t\\twhile(i < j - 1){\\n\\t\\t\\t\\t\\tint mid = i + (j - i) / 2;\\n\\t\\t\\t\\t\\tif(nums[i] < nums[mid] && nums[j] < nums[mid]){\\n\\t\\t\\t\\t\\t\\ti = mid;\\n\\t\\t\\t\\t\\t}else {\\n\\t\\t\\t\\t\\t\\tj = mid;\\n\\t\\t\\t\\t\\t}\\n\\t\\t\\t\\t}\\n\\t\\t \\t\\treturn i;\\n\\t\\t \\t}\\n\\t\\t \\t\\n\\t\\t \\tpublic int binarySearch(int a[], int start, int end, int key){\\n\\t\\t\\t\\tint i = start, j = end;\\n\\t\\t\\t\\twhile(i <= j){\\n\\t\\t\\t\\t\\tint mid = i + (j - i) / 2;\\n\\t\\t\\t\\t\\tif(a[mid] > key){\\n\\t\\t\\t\\t\\t\\tj = mid - 1;\\n\\t\\t\\t\\t\\t}else if(a[mid] < key){\\n\\t\\t\\t\\t\\t\\ti = mid + 1;\\n\\t\\t\\t\\t\\t}\\n\\t\\t\\t\\t\\telse return mid;\\n\\t\\t\\t\\t}\\n\\t\\t\\t\\treturn -1;\\n\\t\\t\\t}",
                "codeTag": "Unknown"
            },
            {
                "id": 1732232,
                "title": "python-using-bisect-with-a-key-function",
                "content": "At Python 3.10 you can supply a `key` function to `bisect`. The input array is sorted suitably for a binary search if we use `(num < nums[0], num)` as this key since the first element takes the value `False=0` until the rotation point and then `True=1`   \\n```\\nfrom bisect import bisect_left\\n\\nclass Solution:\\n    def search(self, nums: List[int], target: int) -> int:\\n        key = lambda num: (num < nums[0], num)\\n        i = bisect_left(nums, key(target), key=key)\\n        return i if (i < len(nums) and nums[i] == target) else -1\\n```\\n",
                "solutionTags": [
                    "Python"
                ],
                "code": "```\\nfrom bisect import bisect_left\\n\\nclass Solution:\\n    def search(self, nums: List[int], target: int) -> int:\\n        key = lambda num: (num < nums[0], num)\\n        i = bisect_left(nums, key(target), key=key)\\n        return i if (i < len(nums) and nums[i] == target) else -1\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1170180,
                "title": "c-binary-search-full-explanation",
                "content": "## **Concept**:\\nNo matter how many times the array\\'s rotated,\\nIt is guaranteed that **one half of array will always be sorted**.\\n\\n## **Finding a pattern**:\\n\\n\\t consider\\n\\t (fs) = first element of array, (mi) = mid element of array, (ls) = last element of array,\\n\\t (!<) = not less than, (>!) = not greater than\\n\\n\\todd number array: \\n    [1,2,3,4,5,6,7] fs < mi < ls => all sorted (mi = 4)\\n    [7,1,2,3,4,5,6] fs !< mi, but mi < ls => right half sorted (mi = 3)\\n    [6,7,1,2,3,4,5] fs !< mi, but m < ls => right half sorted (mi = 2)\\n    [5,6,7,1,2,3,4] fs !< mi, but m < ls => right half sorted (mi = 1)\\n    [4,5,6,7,1,2,3] fs < mi and m !< ls => left half sorted (mi = 7)\\n    [3,4,5,6,7,1,2] fs < mi and m !< ls => left half sorted (mi = 6)\\n    [2,3,4,5,6,7,1] fs < mi and m !< ls => left half sorted (mi = 5)\\n     \\n     even number array: \\n     [1,2,3,4,5,6] fs < mi < ls => all sorted (mi = 3)\\n     [6,1,2,3,4,5] fs !< mi but, mi < ls => right half sorted (mi = 2)\\n     [5,6,1,2,3,4] fs !< mi but, mi < ls => right half sorted (mi = 1)\\n     [4,5,6,1,2,3] fs < mi and mi !< ls => left half sorted (mi = 6)\\n     [3,4,5,6,1,2] fs < mi and mi !< ls => left half sorted (mi = 5)\\n     [2,3,4,5,6,1] fs < mi and mi !< ls => left half sorted (mi = 4)\\n\\t \\n\\t \\n## **Algorithm**:\\n\\n_low = index of first element, mid = (low+high)/2, high = index of last element_\\n\\n**case 1** **:**\\n* if left half is sorted **(arr[low] <= arr[mid])** and target lies in this range **(target >= nums[low] and target < nums[mid])**, Search in this half **(high = mid - 1)**\\n* otherwise search for right half **(low = mid+1)**\\n\\n**case 2** **:**\\n* if left half is not sorted that means right half is sorted. Now if target lies in this range **(target > nums[mid] and target <= nums[high])**, Search in this half **(low = mid + 1)**\\n* otherwise search for left half **(high = mid -1 )**\\n\\n## **Example**:\\n* let nums = [6, 7, 1, 2, 3, 4, 5], target = 6\\n* Iteration 1:\\n\\t*  low = 0, high = 6, mid = 3\\n\\t*  on comparing arr[low] and arr[mid] => right half is sorted\\n\\t*  does target lie in range of right half => NO\\n\\t*  search for left half\\n* Iteration 2:\\n\\t* low = 0, high = 2, mid = 1\\n\\t* on comparing arr[low] and arr[mid] => left half sorted\\n\\t* does target lie in this range => YES\\n\\t* search in this half\\n* Iteration 3:\\n\\t* low = 0, high = 0, mid = 0\\n\\t* this is the required element\\n\\n**code:**\\n\\n```\\n// search an element in a sorted and rotated array. O(logn)\\nint search(int nums[], int size, int target)\\n{\\n    // initialize low and high variables\\n    int low = 0, high = size - 1;\\n\\n    // logic\\n    while (low <= high)\\n    {\\n        // compute mid\\n        int mid = (low + high) / 2;\\n\\n        // check middle element (base case)\\n        if (nums[mid] == target)\\n            return mid;\\n\\n        // left half is sorted\\n        if (nums[low] <= nums[mid])\\n        {\\n            if (target >= nums[low] && target < nums[mid]) // notice target <= nums[mid] is not required because equality has already been checked earlier\\n                high = mid - 1; // go to left half\\n            else\\n                low = mid + 1; // go to right half\\n        }\\n        // right half is sorted\\n        else\\n        {\\n            if (target > nums[mid] && target <= nums[high]) // notice target >= nums[mid] is not required because equality has already been checked earlier\\n                low = mid + 1; // go to right half\\n            else\\n                high = mid - 1; // go to left half\\n        }\\n    }\\n\\n    // if element not found\\n    return -1;\\n}\\n```\\n\\n**Upvote if you found it useful! Thank you**",
                "solutionTags": [
                    "C",
                    "Binary Search",
                    "Binary Search Tree"
                ],
                "code": "```\\n// search an element in a sorted and rotated array. O(logn)\\nint search(int nums[], int size, int target)\\n{\\n    // initialize low and high variables\\n    int low = 0, high = size - 1;\\n\\n    // logic\\n    while (low <= high)\\n    {\\n        // compute mid\\n        int mid = (low + high) / 2;\\n\\n        // check middle element (base case)\\n        if (nums[mid] == target)\\n            return mid;\\n\\n        // left half is sorted\\n        if (nums[low] <= nums[mid])\\n        {\\n            if (target >= nums[low] && target < nums[mid]) // notice target <= nums[mid] is not required because equality has already been checked earlier\\n                high = mid - 1; // go to left half\\n            else\\n                low = mid + 1; // go to right half\\n        }\\n        // right half is sorted\\n        else\\n        {\\n            if (target > nums[mid] && target <= nums[high]) // notice target >= nums[mid] is not required because equality has already been checked earlier\\n                low = mid + 1; // go to right half\\n            else\\n                high = mid - 1; // go to left half\\n        }\\n    }\\n\\n    // if element not found\\n    return -1;\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1001111,
                "title": "javascript-o-logn-time-o-1-space",
                "content": "```\\nvar search = function(nums, target) {\\n    let l = 0\\n    let r = nums.length -1\\n    while (l <= r) {\\n        let mid = Math.floor((r - l) / 2 + l)\\n        if (nums[mid] === target) return mid\\n        if (nums[l] <= nums[mid]) {\\n            // left sorted\\n            if (target >= nums[l] && target < nums[mid]) {\\n                // target in sorted\\n                r = mid - 1                \\n            } else {\\n                // target in unsorted\\n                l = mid + 1\\n            }\\n        } else {\\n            // right sorted\\n            if (target <= nums[r] && target > nums[mid]) {\\n                // target in sorted\\n                l = mid + 1\\n            } else {\\n                // target in unsorted\\n                r = mid - 1\\n            }            \\n        }\\n    }\\n    return -1\\n};\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\nvar search = function(nums, target) {\\n    let l = 0\\n    let r = nums.length -1\\n    while (l <= r) {\\n        let mid = Math.floor((r - l) / 2 + l)\\n        if (nums[mid] === target) return mid\\n        if (nums[l] <= nums[mid]) {\\n            // left sorted\\n            if (target >= nums[l] && target < nums[mid]) {\\n                // target in sorted\\n                r = mid - 1                \\n            } else {\\n                // target in unsorted\\n                l = mid + 1\\n            }\\n        } else {\\n            // right sorted\\n            if (target <= nums[r] && target > nums[mid]) {\\n                // target in sorted\\n                l = mid + 1\\n            } else {\\n                // target in unsorted\\n                r = mid - 1\\n            }            \\n        }\\n    }\\n    return -1\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 593263,
                "title": "go-two-binary-searches",
                "content": "```\\nfunc search(nums []int, target int) int {\\n    n := len(nums)\\n    \\n    // Find the pivot.\\n    left, right := 0, n-1\\n    for left < right {\\n        mid := left+(right-left)/2\\n        if nums[mid] > nums[right] {\\n            left = mid+1\\n        } else {\\n            right = mid\\n        }\\n    }\\n    \\n    pivot := left\\n    \\n\\t// Regular binary search\\n    left, right = pivot, pivot-1+n\\n    for left <= right {\\n        mid := left+(right-left)/2\\n        midVal := nums[mid % n]\\n        \\n        if midVal > target {\\n            right = mid-1\\n        } else if midVal < target {\\n            left = mid+1\\n        } else {\\n            return mid % n\\n        }\\n    }\\n    \\n    return -1\\n}\\n```",
                "solutionTags": [
                    "Go",
                    "Binary Tree"
                ],
                "code": "```\\nfunc search(nums []int, target int) int {\\n    n := len(nums)\\n    \\n    // Find the pivot.\\n    left, right := 0, n-1\\n    for left < right {\\n        mid := left+(right-left)/2\\n        if nums[mid] > nums[right] {\\n            left = mid+1\\n        } else {\\n            right = mid\\n        }\\n    }\\n    \\n    pivot := left\\n    \\n\\t// Regular binary search\\n    left, right = pivot, pivot-1+n\\n    for left <= right {\\n        mid := left+(right-left)/2\\n        midVal := nums[mid % n]\\n        \\n        if midVal > target {\\n            right = mid-1\\n        } else if midVal < target {\\n            left = mid+1\\n        } else {\\n            return mid % n\\n        }\\n    }\\n    \\n    return -1\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 14623,
                "title": "binary-search-case-by-case",
                "content": "The difficulty of applying binary search to this problem lies in how to determine the correct half for `target`. \\n\\nWhen we do binary search, we start wtih a `l` pointer and a `r` pointer. Then we compute the `m` pointer, if `nums[m]` happens to be `target`, then we are of luck. Otherwise, `nums[m]` can be either to the left or right of `target`. If `nums[m]` is to the left of `target`, we search for the right half; otherwise the left half. So we need to figure out how to check whether `nums[m]` is to the left or right of `target`.\\n\\nWhen `nums[m]` is to the left of `target`: `nums[l] nums[m] target nums[r]`, we will have three cases:\\n\\n1. `nums[l] > nums[m] < target`;\\n2. `nums[l] <= nums[m] > target`;\\n3. `nums[l] <= nums[m] < target`.\\n\\nNote that `m` may be just `l` since the division to compute `m` is a floor division.\\n\\nSimilarly, when `nums[m]` is to the right of `target`: `nums[l] target nums[m] nums[r]`, we will have other three cases:\\n\\n4. `nums[l] > target < nums[m]`;\\n5. `nums[l] <= target > nums[m]`;\\n6. `nums[l] <= target < nums[m]`.\\n\\nYou may just code either cases 1, 2, 3 or cases 4, 5, 6 to determine whether to check the left or right half. The code is as follows.\\n\\n```cpp\\nclass Solution {\\npublic:\\n    int search(vector<int>& nums, int target) {\\n        int n = nums.size(), l = 0, r = n - 1;\\n        while (l <= r) {\\n            int m = (l + r) / 2;\\n            if (nums[m] == target) {\\n                return m;\\n            }\\n            if (left(nums[l], nums[m], target)) {\\n                l = m + 1;\\n            } else {\\n                r = m - 1;\\n            }\\n        }\\n        return -1;\\n    }\\nprivate:\\n    bool left(int l, int m, int t) {\\n        return (l > m && l > t && m < t) || (l <= m && l > t && m > t) || (l <= m && l < t && m < t);\\n    }\\n};\\n```\\n\\nIn general binary search, we will compare `nums[m]` with `target` to determine the half.\\n\\nWhen `nums[m] > target`, it corresponds to cases 2, 4, and 6. In case 2, we need to check for the right half while in cases 4 and 6 the left. And cases 4 and 6 can be compressed into `nums[l] <= target || nums[l] > nums[m]`.\\n\\nSimilarly, when `nums[m] < target`, it corresponds to cases 1, 3, and 5. In case 5, we need to check the left while in cases 1 and 3 the right. And cases 1 and 3 can be compressed into `nums[l] > target || nums[l] <= nums[m]`.\\n\\nUsing the above compressed checks, we will come to the following code.\\n\\n```cpp\\nclass Solution {\\npublic:\\n    int search(vector<int>& nums, int target) {\\n        int l = 0, r = nums.size() - 1;\\n        while (l <= r) {\\n            int m = (l + r) / 2;\\n            if (nums[m] == target) {\\n                return m;\\n            }\\n            if (nums[m] > target) {\\n                if (nums[l] <= target || nums[l] > nums[m]) {\\n                    r = m - 1;\\n                } else {\\n                    l = m + 1;\\n                }\\n            } else {\\n                if (nums[l] > target || nums[l] <= nums[m]) {\\n                    l = m + 1;\\n                } else {\\n                    r = m - 1;\\n                }\\n            }\\n        }\\n        return -1;\\n    }\\n};\\n```\\n\\nYou may wonder, for example, when `nums[m] > target`, why don\\'t we need a check for case 2 before entering `l = m + 1`? Actually, when `nums[l] <= target || nums[l] > nums[m]` does not hold, it is just case 2. Similarly you can explain why we don\\'t need to check for case 5 before entering `r = m - 1` below.\\n\\nAnother simple approach is to use the sorted version of the array by applying some tricks to the indices. It is not easy to search in `4, 5, 6, 7, 0, 1, 2`, but it is very easy to search in `0, 1, 2, 4, 5, 6, 7`. Suppose you would like to visit the `3`-rd element in the sorted array, in this case, it is just the `(3 + 4) % 7 = 0`-th element in the rotated array. The `4` is just the index of the minimum. You can find it out using the same idea of [Find Minimum in Rotated Sorted Array](https://leetcode.com/problems/find-minimum-in-rotated-sorted-array/).\\n\\n```cpp\\nclass Solution {\\npublic:\\n    int search(vector<int>& nums, int target) {\\n        int l = 0, r = nums.size() - 1, idx = findMinIdx(nums);\\n        while (l <= r) {\\n            int m = l + (r - l) / 2, mid = (m + idx) % nums.size();\\n            if (nums[mid] == target) {\\n                return mid;\\n            }\\n            if (nums[mid] < target) {\\n                l = m + 1;\\n            } else {\\n                r = m - 1;\\n            }\\n        }\\n        return -1;\\n    }\\nprivate:\\n    int findMinIdx(vector<int>& nums) {\\n        int l = 0, r = nums.size() - 1;\\n        while (l < r && nums[l] > nums[r]) {\\n            int m = l + (r - l) / 2;\\n            if (nums[m] > nums[r]) {\\n                l = m + 1;\\n            } else {\\n                r = m;\\n            }\\n        }\\n        return l;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Binary Search"
                ],
                "code": "```cpp\\nclass Solution {\\npublic:\\n    int search(vector<int>& nums, int target) {\\n        int n = nums.size(), l = 0, r = n - 1;\\n        while (l <= r) {\\n            int m = (l + r) / 2;\\n            if (nums[m] == target) {\\n                return m;\\n            }\\n            if (left(nums[l], nums[m], target)) {\\n                l = m + 1;\\n            } else {\\n                r = m - 1;\\n            }\\n        }\\n        return -1;\\n    }\\nprivate:\\n    bool left(int l, int m, int t) {\\n        return (l > m && l > t && m < t) || (l <= m && l > t && m > t) || (l <= m && l < t && m < t);\\n    }\\n};\\n```\n```cpp\\nclass Solution {\\npublic:\\n    int search(vector<int>& nums, int target) {\\n        int l = 0, r = nums.size() - 1;\\n        while (l <= r) {\\n            int m = (l + r) / 2;\\n            if (nums[m] == target) {\\n                return m;\\n            }\\n            if (nums[m] > target) {\\n                if (nums[l] <= target || nums[l] > nums[m]) {\\n                    r = m - 1;\\n                } else {\\n                    l = m + 1;\\n                }\\n            } else {\\n                if (nums[l] > target || nums[l] <= nums[m]) {\\n                    l = m + 1;\\n                } else {\\n                    r = m - 1;\\n                }\\n            }\\n        }\\n        return -1;\\n    }\\n};\\n```\n```cpp\\nclass Solution {\\npublic:\\n    int search(vector<int>& nums, int target) {\\n        int l = 0, r = nums.size() - 1, idx = findMinIdx(nums);\\n        while (l <= r) {\\n            int m = l + (r - l) / 2, mid = (m + idx) % nums.size();\\n            if (nums[mid] == target) {\\n                return mid;\\n            }\\n            if (nums[mid] < target) {\\n                l = m + 1;\\n            } else {\\n                r = m - 1;\\n            }\\n        }\\n        return -1;\\n    }\\nprivate:\\n    int findMinIdx(vector<int>& nums) {\\n        int l = 0, r = nums.size() - 1;\\n        while (l < r && nums[l] > nums[r]) {\\n            int m = l + (r - l) / 2;\\n            if (nums[m] > nums[r]) {\\n                l = m + 1;\\n            } else {\\n                r = m;\\n            }\\n        }\\n        return l;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 14646,
                "title": "my-accepted-c-codes-o-logn-4ms",
                "content": "Binary search. \\n\\n    class Solution {\\n    public:\\n        int search(vector<int>& nums, int target) {\\n            if(nums.size() == 0)\\n                return -1;\\n            int left = 0;\\n            int right = nums.size()-1;\\n            while(left <= right){\\n                int mid = (left+right)/2;\\n                if(target == nums[mid])\\n                    return mid;\\n                if((nums[mid]>=nums[left] && (target>nums[mid] || (target<nums[left]))) || (nums[mid]<nums[left] && target>nums[mid] && target<=nums[right]))\\n                    left = mid + 1;\\n                else\\n                    right = mid -1;\\n            }\\n            return -1;\\n        }\\n    };",
                "solutionTags": [],
                "code": "class Solution {\\n    public:\\n        int search(vector<int>& nums, int target) {\\n            if(nums.size() == 0)\\n                return -1;\\n            int left = 0;\\n            int right = nums.size()-1;\\n            while(left <= right){\\n                int mid = (left+right)/2;\\n                if(target == nums[mid])\\n                    return mid;\\n                if((nums[mid]>=nums[left] && (target>nums[mid] || (target<nums[left]))) || (nums[mid]<nums[left] && target>nums[mid] && target<=nums[right]))\\n                    left = mid + 1;\\n                else\\n                    right = mid -1;\\n            }",
                "codeTag": "Java"
            },
            {
                "id": 3882526,
                "title": "java-simple-solution-runtime-0ms-beats100",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\n    public static int search(int[] nums, int target) {\\n    int low = 0;\\n    int high = nums.length - 1;\\n\\n    while (low <= high) {\\n        int mid = low + (high - low) / 2;\\n\\n        if (nums[mid] == target) {\\n            return mid;\\n        } else if (nums[mid] >= nums[low]) { \\n            if (target >= nums[low] && target < nums[mid]) {\\n                high = mid - 1;\\n            } else {\\n                low = mid + 1;\\n            }\\n        } else {\\n            if (target > nums[mid] && target <= nums[high]) {\\n                low = mid + 1;\\n            } else {\\n                high = mid - 1;\\n            }\\n        }\\n    }\\n\\n    return -1;\\n}\\n\\n}\\n```\\n\\n\\n![e78315ef-8a9d-492b-9908-e3917f23eb31_1674946036.087042.jpeg](https://assets.leetcode.com/users/images/6e9839aa-d5b7-4d19-a954-e7a09921a6e4_1691510628.7730532.jpeg)\\n",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public static int search(int[] nums, int target) {\\n    int low = 0;\\n    int high = nums.length - 1;\\n\\n    while (low <= high) {\\n        int mid = low + (high - low) / 2;\\n\\n        if (nums[mid] == target) {\\n            return mid;\\n        } else if (nums[mid] >= nums[low]) { \\n            if (target >= nums[low] && target < nums[mid]) {\\n                high = mid - 1;\\n            } else {\\n                low = mid + 1;\\n            }\\n        } else {\\n            if (target > nums[mid] && target <= nums[high]) {\\n                low = mid + 1;\\n            } else {\\n                high = mid - 1;\\n            }\\n        }\\n    }\\n\\n    return -1;\\n}\\n\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3879891,
                "title": "100-faster-c-java-simple-explanation-beginner-friendly-binary-search",
                "content": "## We\\'ll be checking only for the first part after dividing the array from mid.\\n##### There are two possible conditions\\n- if the first part is like `[4,5,7,0,1]` (rotated elements are in first part).\\n- or the first part is like `[3,4,5,6]` (simple sorted in first part)\\n##### Let\\'s handle first condition.\\n- `target <= nums[mid] || target >= nums[start]` then call with `start=start` and `end=mid`.\\n- Otherwise element does not lie in `[start, mid]` therefore call with `start=mid+1` and `end=end`.\\n##### Second condition\\n- check only if the target lies in between `[start, mid]`, then call `start=start` and `end=mid`.\\n- otehrwise call with `start=mid+1` and `end=end`.\\n\\n# Code (Below \\uD83D\\uDC47)\\n<img src=\"https://assets.leetcode.com/users/images/cde42097-431d-4683-963b-d488af508080_1681230761.754524.png\" width=\"400\">\\n\\n### C++ \\n```\\nclass Solution {\\n\\n    int binary_search(vector<int>& nums, int target, int start, int end){\\n        if(start > end || (start==end && nums[start]!=target)) return -1;\\n        if(start == end) return start;\\n        int mid = (start + end)/2;\\n        if(nums[mid]<nums[start]){\\n            if(target >= nums[start] || target <= nums[mid]) \\n                return binary_search(nums, target, start, mid);\\n            else \\n                return binary_search(nums, target, mid+1, end);\\n        }else{\\n            if(target >= nums[start] && target <= nums[mid])\\n                return binary_search(nums, target, start, mid);\\n            else\\n                return binary_search(nums, target, mid+1, end);\\n        }\\n    }\\n\\npublic:\\n    int search(vector<int>& nums, int target) {\\n        return binary_search(nums, target, 0, nums.size()-1);\\n    }\\n};\\n```\\n### Java\\n```\\npublic class Solution {\\n\\n    private int binary_search(int[] nums, int target, int start, int end) {\\n        if (start > end || (start == end && nums[start] != target)) return -1;\\n        if (start == end) return start;\\n        int mid = (start + end) / 2;\\n        if (nums[mid] < nums[start]) {\\n            if (target >= nums[start] || target <= nums[mid])\\n                return binary_search(nums, target, start, mid);\\n            else\\n                return binary_search(nums, target, mid + 1, end);\\n        } else {\\n            if (target >= nums[start] && target <= nums[mid])\\n                return binary_search(nums, target, start, mid);\\n            else\\n                return binary_search(nums, target, mid + 1, end);\\n        }\\n    }\\n\\n    public int search(int[] nums, int target) {\\n        return binary_search(nums, target, 0, nums.length - 1);\\n    }\\n}\\n\\n```\\n\\n\\n\\n\\n\\n### Thank you :)",
                "solutionTags": [
                    "C++",
                    "Java",
                    "Binary Search"
                ],
                "code": "```\\nclass Solution {\\n\\n    int binary_search(vector<int>& nums, int target, int start, int end){\\n        if(start > end || (start==end && nums[start]!=target)) return -1;\\n        if(start == end) return start;\\n        int mid = (start + end)/2;\\n        if(nums[mid]<nums[start]){\\n            if(target >= nums[start] || target <= nums[mid]) \\n                return binary_search(nums, target, start, mid);\\n            else \\n                return binary_search(nums, target, mid+1, end);\\n        }else{\\n            if(target >= nums[start] && target <= nums[mid])\\n                return binary_search(nums, target, start, mid);\\n            else\\n                return binary_search(nums, target, mid+1, end);\\n        }\\n    }\\n\\npublic:\\n    int search(vector<int>& nums, int target) {\\n        return binary_search(nums, target, 0, nums.size()-1);\\n    }\\n};\\n```\n```\\npublic class Solution {\\n\\n    private int binary_search(int[] nums, int target, int start, int end) {\\n        if (start > end || (start == end && nums[start] != target)) return -1;\\n        if (start == end) return start;\\n        int mid = (start + end) / 2;\\n        if (nums[mid] < nums[start]) {\\n            if (target >= nums[start] || target <= nums[mid])\\n                return binary_search(nums, target, start, mid);\\n            else\\n                return binary_search(nums, target, mid + 1, end);\\n        } else {\\n            if (target >= nums[start] && target <= nums[mid])\\n                return binary_search(nums, target, start, mid);\\n            else\\n                return binary_search(nums, target, mid + 1, end);\\n        }\\n    }\\n\\n    public int search(int[] nums, int target) {\\n        return binary_search(nums, target, 0, nums.length - 1);\\n    }\\n}\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3343236,
                "title": "short-concise-crispy-easy-self-explanatory-solution",
                "content": "# Intuition\\nTo make Medium Code very Easy\\nHERE I AM PRESENTING JAVA CODE FOR C++ USE VECTOR INSTEAD OF ARRAY\\n\\n# Approach\\nSS \\nJust Smile and Solve\\n\\n# Complexity\\nNothing Complex\\n\\n# Please Upvote\\n\\n# Code\\n```\\nclass Solution {\\n    public int search(int[] arr, int x) {\\n        int l=arr.length;\\n        int i=0;\\n        while(i+1<l&&arr[i]<arr[i+1])\\n        {\\n            i++;\\n        }\\n        Arrays.sort(arr);\\n         int beg=0,end=l-1,mid;\\n        while(beg<=end)\\n        {\\n            mid=(beg+end)/2;\\n            if(x==arr[mid])\\n            {\\n                if((mid+i)>=(l-1))\\n                return mid+i-l+1;\\n                return mid+i+1;\\n            }\\n            else if(arr[mid]<x)\\n            beg=mid+1;\\n            else\\n            end=mid-1;\\n        \\n        }\\n        return -1;\\n    }\\n}\\n```",
                "solutionTags": [
                    "C++",
                    "Java",
                    "Array",
                    "Binary Search"
                ],
                "code": "```\\nclass Solution {\\n    public int search(int[] arr, int x) {\\n        int l=arr.length;\\n        int i=0;\\n        while(i+1<l&&arr[i]<arr[i+1])\\n        {\\n            i++;\\n        }\\n        Arrays.sort(arr);\\n         int beg=0,end=l-1,mid;\\n        while(beg<=end)\\n        {\\n            mid=(beg+end)/2;\\n            if(x==arr[mid])\\n            {\\n                if((mid+i)>=(l-1))\\n                return mid+i-l+1;\\n                return mid+i+1;\\n            }\\n            else if(arr[mid]<x)\\n            beg=mid+1;\\n            else\\n            end=mid-1;\\n        \\n        }\\n        return -1;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3137660,
                "title": "fully-explained-step-by-step-which-line-to-search",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nin question, it is given we have to solve it in lon n times. which means we have to use divide and conquer technique.\\n    if in question complexity is not mentioned , then it is obvious since array is rotated and sorted that is both parts are sorted. we have to eliminate one part so that we can search in right part.\\n\\n# WHAT IS PIVOT OF AN ROTATED SORTED ARRAY.\\nIt is the index of the array at which array get sorted in two halves. example- [4,5,6,7,8]->[8,4,5,6,7], pivot is 4\\n# WHY PIVOT????\\n we are finding pivot so that we can eliminate the second half and apply search in the correct part.\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n1. firstly we have to find pivot using binary search.\\n2. then we have to check whether target is less or greater than pivot.\\n3. if target is greater than pivot apply search on right half else left half.  [4,5,6,7,8]->[8,4,5,6,7] , target is 6.... search is done on [4,5,6,7]\\n4 apply binary search on the half.\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\nO(lon n)\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\nO(1)- constant \\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int BinarySearch(vector<int>& arr, int s,int e,int k)\\n    {\\n      while(s<=e)\\n      {\\n        int mid=(s+e)/2;\\n        if(arr[mid]==k)\\n          return mid;\\n        else if(arr[mid]<k)\\n        {\\n          s=mid+1;\\n        }\\n        else\\n          e=mid-1;\\n      }\\n       return -1;\\n    }\\n     int getPivot(vector<int>& arr)\\n     {\\n       int s=0,e=arr.size()-1;\\n       int mid=(s+e)/2;\\n       while(s<e)\\n       {\\n         if(arr[mid] >= arr[0])\\n            s=mid+1;\\n          else\\n            e=mid;\\n        mid=(s+e)/2;\\n       }\\n       return s;\\n     }\\n    int search(vector<int>& arr, int target) {\\n        int pivot =getPivot(arr);\\n        if(arr[pivot]<=target && target <= arr[arr.size()-1])\\n        {\\n          return BinarySearch(arr,pivot,arr.size()-1,target);\\n        }\\n        else\\n          return BinarySearch(arr,0,pivot-1,target);\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int BinarySearch(vector<int>& arr, int s,int e,int k)\\n    {\\n      while(s<=e)\\n      {\\n        int mid=(s+e)/2;\\n        if(arr[mid]==k)\\n          return mid;\\n        else if(arr[mid]<k)\\n        {\\n          s=mid+1;\\n        }\\n        else\\n          e=mid-1;\\n      }\\n       return -1;\\n    }\\n     int getPivot(vector<int>& arr)\\n     {\\n       int s=0,e=arr.size()-1;\\n       int mid=(s+e)/2;\\n       while(s<e)\\n       {\\n         if(arr[mid] >= arr[0])\\n            s=mid+1;\\n          else\\n            e=mid;\\n        mid=(s+e)/2;\\n       }\\n       return s;\\n     }\\n    int search(vector<int>& arr, int target) {\\n        int pivot =getPivot(arr);\\n        if(arr[pivot]<=target && target <= arr[arr.size()-1])\\n        {\\n          return BinarySearch(arr,pivot,arr.size()-1,target);\\n        }\\n        else\\n          return BinarySearch(arr,0,pivot-1,target);\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3105482,
                "title": "binary-search-approach-c-easy-solution",
                "content": "\\n\\n# Approach\\nBinary Search\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity: O(logn)\\n\\n\\n- Space complexity: O(1)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int search(vector<int>& a, int k) {\\n       int l=0;\\n       int h=a.size()-1;\\n       while(l<h){\\n            int mid=(l+h)/2;\\n            if(a[mid]==k) return mid;\\n            if(a[l]<=a[mid]){\\n                if(k>=a[l] && k<a[mid]){\\n                    h=mid-1;\\n                }\\n                else{\\n                    l=mid+1;\\n                }\\n            }\\n            else{\\n                if(k<=a[h] && k>a[mid]){\\n                    l=mid+1;\\n                }\\n                else{\\n                    h=mid-1;\\n                }\\n            }\\n        }\\n        if(a[l]==k)\\n        return l;\\n        else return -1;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int search(vector<int>& a, int k) {\\n       int l=0;\\n       int h=a.size()-1;\\n       while(l<h){\\n            int mid=(l+h)/2;\\n            if(a[mid]==k) return mid;\\n            if(a[l]<=a[mid]){\\n                if(k>=a[l] && k<a[mid]){\\n                    h=mid-1;\\n                }\\n                else{\\n                    l=mid+1;\\n                }\\n            }\\n            else{\\n                if(k<=a[h] && k>a[mid]){\\n                    l=mid+1;\\n                }\\n                else{\\n                    h=mid-1;\\n                }\\n            }\\n        }\\n        if(a[l]==k)\\n        return l;\\n        else return -1;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3067008,
                "title": "0ms-java-beats-100-easy-modified-binary-search",
                "content": "# Approach\\nIt is a Modified Binary Search in which from the middle element we are dividing array into two halves and checking which half is in sorted order as it is easy to find a element in a sorted array and if the element is not present in sorted half then we will go for another half, and discard the half which does not contains the element, repeat it until you find the target or if it is not present print -1.\\n*Note -- it is guranted that one of the half will be always in sorted order.*\\n\\n# Time complexity:\\nO(log n) -- as we are dividing array into two parts every time.\\n\\n# Code\\n```\\nclass Solution {\\n    public int search(int[] nums, int target) {\\n        int len = nums.length;\\n        int i = 0;\\n        int j = len-1;\\n        while(i<=j)\\n        {\\n            int mid = (i + j) / 2;\\n            if(nums[mid] == target)\\n                return mid;\\n            else if(nums[i] <= nums[mid]) // checking whether first half is in sorted order or not\\n            {\\n                if(target < nums[mid] && target >= nums[i]) //if the element is in first half then we will discard second half\\n                    j = mid - 1;\\n                else\\n                    i = mid + 1;\\n            }\\n            else\\n            {\\n                    if(target > nums[mid] && target <= nums[j])\\n                        i = mid + 1;\\n                    else\\n                        j = mid - 1;\\n            }\\n        }\\n        return -1;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Array",
                    "Binary Search"
                ],
                "code": "```\\nclass Solution {\\n    public int search(int[] nums, int target) {\\n        int len = nums.length;\\n        int i = 0;\\n        int j = len-1;\\n        while(i<=j)\\n        {\\n            int mid = (i + j) / 2;\\n            if(nums[mid] == target)\\n                return mid;\\n            else if(nums[i] <= nums[mid]) // checking whether first half is in sorted order or not\\n            {\\n                if(target < nums[mid] && target >= nums[i]) //if the element is in first half then we will discard second half\\n                    j = mid - 1;\\n                else\\n                    i = mid + 1;\\n            }\\n            else\\n            {\\n                    if(target > nums[mid] && target <= nums[j])\\n                        i = mid + 1;\\n                    else\\n                        j = mid - 1;\\n            }\\n        }\\n        return -1;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2690428,
                "title": "faster-than-100-easy-java-solution",
                "content": "Feel free to ask and point out a better approach \\nAlso upvote if it was helpful\\n\\n```\\nclass Solution {\\n    public int search(int[] nums, int target) {\\n        int left = 0;\\n        int right = nums.length-1;\\n        int mid;\\n        while(left<=right){\\n            mid = left+(right-left)/2;\\n            if(nums[mid] == target) return mid;\\n            // condition for left side is sort\\n            if(nums[left]<=nums[mid]){\\n                if(target>=nums[left] && target <=nums[mid]){\\n                    right = mid-1;\\n                }else {\\n                    left = mid+1;\\n                }\\n            }\\n            else{\\n                if(target>=nums[mid] && target <=nums[right]){\\n                    left = mid+1;\\n                }else{\\n                    right = mid-1;\\n                }\\n            }\\n    }\\n     return -1;   \\n    }\\n    \\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Binary Tree"
                ],
                "code": "```\\nclass Solution {\\n    public int search(int[] nums, int target) {\\n        int left = 0;\\n        int right = nums.length-1;\\n        int mid;\\n        while(left<=right){\\n            mid = left+(right-left)/2;\\n            if(nums[mid] == target) return mid;\\n            // condition for left side is sort\\n            if(nums[left]<=nums[mid]){\\n                if(target>=nums[left] && target <=nums[mid]){\\n                    right = mid-1;\\n                }else {\\n                    left = mid+1;\\n                }\\n            }\\n            else{\\n                if(target>=nums[mid] && target <=nums[right]){\\n                    left = mid+1;\\n                }else{\\n                    right = mid-1;\\n                }\\n            }\\n    }\\n     return -1;   \\n    }\\n    \\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2595571,
                "title": "my-solution",
                "content": "```\\nclass Solution:\\n    def search(self, nums: List[int], target: int) -> int:\\n        if not nums:\\n            return -1\\n        \\n        left, right = 0, len(nums) - 1\\n\\n        while left <= right:\\n            mid = (left + right) // 2\\n\\n            if nums[mid] == target:\\n                return mid\\n\\n            # Left position\\n            if nums[left] <= nums[mid]:\\n                # if target is between start & mid, make right to (mid -1)\\n                if nums[left] <= target <= nums[mid]:\\n                    right = mid - 1\\n                else:\\n                    left = mid + 1\\n\\n            # Right position\\n            else:\\n                # if target is between mid & end, make start to (mid + 1)\\n                if nums[mid] <= target <= nums[right]:\\n                    left = mid + 1\\n                else:\\n                    right = mid - 1\\n\\n        return -1\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution:\\n    def search(self, nums: List[int], target: int) -> int:\\n        if not nums:\\n            return -1\\n        \\n        left, right = 0, len(nums) - 1\\n\\n        while left <= right:\\n            mid = (left + right) // 2\\n\\n            if nums[mid] == target:\\n                return mid\\n\\n            # Left position\\n            if nums[left] <= nums[mid]:\\n                # if target is between start & mid, make right to (mid -1)\\n                if nums[left] <= target <= nums[mid]:\\n                    right = mid - 1\\n                else:\\n                    left = mid + 1\\n\\n            # Right position\\n            else:\\n                # if target is between mid & end, make start to (mid + 1)\\n                if nums[mid] <= target <= nums[right]:\\n                    left = mid + 1\\n                else:\\n                    right = mid - 1\\n\\n        return -1\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1938870,
                "title": "c-very-easy-to-understand-4-ms",
                "content": "In this example, we have to search in **rotated sorted array**. So simple idea comes in mind for searching, either we can use linear search or binary seach.\\nTo use linear seach is also one approach to solve this problem but if we use linear search technique than it takes **O(N)** time complexity to solve this problem. But in problem description we have given that solve in **O(logn)** time complexity. So we need to think some idea about binary search.\\nOur simple Binary Seach only works for sorted array but here we have given **rotated sorted array** so we need to modify binary seach slighty.\\nOne important observation in rotated sorted array.\\n**At any point we have atleast one half of array which is sorted (another half may or may not sorted).**\\nBy using this observation this problem is very easy to solve using binary seach.\\n\\n**Code**\\n```\\nint search(vector<int>& arr, int key) {\\n        int low = 0, high = arr.size() - 1;\\n        while(low <= high)\\n        {\\n            int mid = (low + high) / 2;\\n            if(arr[mid] == key)\\n                return mid;\\n            \\n\\t\\t// find which half is sorted.\\n            if(arr[low] <= arr[mid])\\n            {\\n\\t\\t\\t\\t// If left half is sorted\\n\\t\\t\\t\\t// then find key in left half\\n                if(key <= arr[mid] && key >= arr[low])\\n                    high = mid - 1;\\n                else\\n                    low = mid + 1;\\n            }\\n            else\\n            {\\n\\t\\t\\t\\t// if right half is sorted\\n\\t\\t\\t\\t// then find key in right half.\\n                if(key >= arr[mid] && key <= arr[high])\\n                    low = mid + 1;\\n                else\\n                    high = mid - 1;\\n            }\\n        }\\n        return -1;\\n    }\\n```\\n**Time Complexity : O(logn)\\nSpace Complexity : O(1)**\\n\\n**If you find it useful please upvote.\\nIf you have any question feel free to ask in comment section.**",
                "solutionTags": [
                    "C",
                    "Binary Tree"
                ],
                "code": "```\\nint search(vector<int>& arr, int key) {\\n        int low = 0, high = arr.size() - 1;\\n        while(low <= high)\\n        {\\n            int mid = (low + high) / 2;\\n            if(arr[mid] == key)\\n                return mid;\\n            \\n\\t\\t// find which half is sorted.\\n            if(arr[low] <= arr[mid])\\n            {\\n\\t\\t\\t\\t// If left half is sorted\\n\\t\\t\\t\\t// then find key in left half\\n                if(key <= arr[mid] && key >= arr[low])\\n                    high = mid - 1;\\n                else\\n                    low = mid + 1;\\n            }\\n            else\\n            {\\n\\t\\t\\t\\t// if right half is sorted\\n\\t\\t\\t\\t// then find key in right half.\\n                if(key >= arr[mid] && key <= arr[high])\\n                    low = mid + 1;\\n                else\\n                    high = mid - 1;\\n            }\\n        }\\n        return -1;\\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1487949,
                "title": "python-binary-search-beats-99-simple-and-efficient-solutions-with-explanation",
                "content": "### Solution 1\\n```\\nclass Solution:\\n    def findPivot(self, nums):\\n        start = 0\\n        end = len(nums) - 1\\n        while start <= end:\\n            mid = start + ((end - start) // 2)\\n            if mid < end and nums[mid] > nums[mid + 1]:\\n                return mid\\n            elif mid > start and nums[mid] < nums[mid - 1]:\\n                return mid - 1\\n            elif nums[mid] > nums[start]:\\n                start = mid + 1\\n            else:\\n                end = mid - 1\\n        return start\\n\\n    def binarySearch(self, nums, start, end, target):\\n        while start <= end:\\n            mid = start + ((end - start) // 2)\\n            if nums[mid] == target:\\n                return mid\\n            elif target < nums[mid]:\\n                end = mid - 1\\n            else:\\n                start = mid + 1\\n        return -1\\n    \\n    def search(self, nums: List[int], target: int) -> int:\\n        pivotIndex = self.findPivot(nums)\\n        targetIndex = self.binarySearch(nums, 0, pivotIndex, target)\\n        return targetIndex if targetIndex != -1 else self.binarySearch(nums, pivotIndex+1, len(nums)-1, target)\\n```\\n\\n### Solution 2 - Elegant Solution\\n```\\nclass Solution:\\n    def search(self, nums: List[int], target: int) -> int:\\n        start = 0\\n        end = len(nums) - 1\\n        while start <= end:\\n            mid = start + ((end - start) // 2)\\n\\t\\t\\t\"\"\"\\n\\t\\t\\t\\tUpdate start and end pointers based on the different parts of array where target may lie.\\n\\t\\t\\t\\tFor example - Consider the following array:\\n\\t\\t\\t\\tarr = [4, 5, 6, 7, 8, 1, 2, 3] \\n\\t\\t\\t\\tparts of array would be:\\n\\t\\t\\t\\t1st part: 4-7\\n\\t\\t\\t\\t2nd part: 8\\n\\t\\t\\t\\t3rd part: 1-3\\n\\t\\t\\t\"\"\"\\n            if nums[mid] == target:\\n                return mid\\n            elif nums[start] <= nums[mid]:\\n\\t\\t\\t\\t# 1st part of array i.e, if target lies in first part of array then search only in that part Else search in the remaining parts\\n                if nums[start] <= target < nums[mid]:\\n                    end = mid - 1\\n                else:\\n                    start = mid + 1\\n            else:\\n\\t\\t\\t\\t# 3rd part of array i.e, if target lies in 3rd part then search only in that part Else search in the remaining parts.\\n                if nums[mid] < target <= nums[end]:\\n                    start = mid + 1\\n                else:\\n                    end = mid - 1\\n        return -1\\n```\\n\\n***If you liked the above solution then please upvote!***",
                "solutionTags": [
                    "Python",
                    "Binary Tree"
                ],
                "code": "```\\nclass Solution:\\n    def findPivot(self, nums):\\n        start = 0\\n        end = len(nums) - 1\\n        while start <= end:\\n            mid = start + ((end - start) // 2)\\n            if mid < end and nums[mid] > nums[mid + 1]:\\n                return mid\\n            elif mid > start and nums[mid] < nums[mid - 1]:\\n                return mid - 1\\n            elif nums[mid] > nums[start]:\\n                start = mid + 1\\n            else:\\n                end = mid - 1\\n        return start\\n\\n    def binarySearch(self, nums, start, end, target):\\n        while start <= end:\\n            mid = start + ((end - start) // 2)\\n            if nums[mid] == target:\\n                return mid\\n            elif target < nums[mid]:\\n                end = mid - 1\\n            else:\\n                start = mid + 1\\n        return -1\\n    \\n    def search(self, nums: List[int], target: int) -> int:\\n        pivotIndex = self.findPivot(nums)\\n        targetIndex = self.binarySearch(nums, 0, pivotIndex, target)\\n        return targetIndex if targetIndex != -1 else self.binarySearch(nums, pivotIndex+1, len(nums)-1, target)\\n```\n```\\nclass Solution:\\n    def search(self, nums: List[int], target: int) -> int:\\n        start = 0\\n        end = len(nums) - 1\\n        while start <= end:\\n            mid = start + ((end - start) // 2)\\n\\t\\t\\t\"\"\"\\n\\t\\t\\t\\tUpdate start and end pointers based on the different parts of array where target may lie.\\n\\t\\t\\t\\tFor example - Consider the following array:\\n\\t\\t\\t\\tarr = [4, 5, 6, 7, 8, 1, 2, 3] \\n\\t\\t\\t\\tparts of array would be:\\n\\t\\t\\t\\t1st part: 4-7\\n\\t\\t\\t\\t2nd part: 8\\n\\t\\t\\t\\t3rd part: 1-3\\n\\t\\t\\t\"\"\"\\n            if nums[mid] == target:\\n                return mid\\n            elif nums[start] <= nums[mid]:\\n\\t\\t\\t\\t# 1st part of array i.e, if target lies in first part of array then search only in that part Else search in the remaining parts\\n                if nums[start] <= target < nums[mid]:\\n                    end = mid - 1\\n                else:\\n                    start = mid + 1\\n            else:\\n\\t\\t\\t\\t# 3rd part of array i.e, if target lies in 3rd part then search only in that part Else search in the remaining parts.\\n                if nums[mid] < target <= nums[end]:\\n                    start = mid + 1\\n                else:\\n                    end = mid - 1\\n        return -1\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1201394,
                "title": "c-modify-binary-search",
                "content": "```\\nclass Solution {\\npublic:\\n    int search(vector<int>& nums, int target) {\\n        int L = 0, R = nums.size() - 1, M;\\n        while (L <= R) {\\n            M = (L + R) / 2;\\n            if (nums[M] == target) {\\n                return M;\\n            }\\n            // If Left is sorted\\n            if (nums[L] <= nums[M]) {\\n                // If the target lays on the left part\\n                if (nums[L] <= target and target <= nums[M]) {\\n                    R = M - 1;\\n                } \\n                else {\\n                    L = M + 1;\\n                }\\n            }\\n            // If Right is sorted\\n            else {\\n                // If the target lays on the right part\\n                if (nums[M] <= target and target <= nums[R]) {\\n                    L = M + 1;\\n                } \\n                else {\\n                    R = M - 1;\\n                }\\n            }\\n        }   \\n        return -1;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C",
                    "Binary Tree"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int search(vector<int>& nums, int target) {\\n        int L = 0, R = nums.size() - 1, M;\\n        while (L <= R) {\\n            M = (L + R) / 2;\\n            if (nums[M] == target) {\\n                return M;\\n            }\\n            // If Left is sorted\\n            if (nums[L] <= nums[M]) {\\n                // If the target lays on the left part\\n                if (nums[L] <= target and target <= nums[M]) {\\n                    R = M - 1;\\n                } \\n                else {\\n                    L = M + 1;\\n                }\\n            }\\n            // If Right is sorted\\n            else {\\n                // If the target lays on the right part\\n                if (nums[M] <= target and target <= nums[R]) {\\n                    L = M + 1;\\n                } \\n                else {\\n                    R = M - 1;\\n                }\\n            }\\n        }   \\n        return -1;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 588195,
                "title": "c-binary-search-solution",
                "content": "An array is sorted in ascending or descending order and then rotated at some unknown pivots. For convenience, here we only talk about cases where the array was originally sorted in ascending order. Below digram shows all the rotated sorted arrays that are generated by the same array.\\n![image](https://assets.leetcode.com/users/images/ca7fda6b-1272-4210-a896-9c47f4dded29_1595998493.391367.png)\\n\\n\\nIn math, an inflection point is a point on a curve at which the sign of curvature changes. In a rotated sorted array, we call a point inflection point (red line shown as below) such that all the elements in its left interval are greater than the first element, and all the elements in its right interval are less than the first element.\\n![image](https://assets.leetcode.com/users/images/e4a78dcb-2be8-4f17-88cf-9f6e7698c2e3_1595998500.6699812.png)\\n\\n\\n### Alogrithm\\n\\nSame as the regular binary search, the idea of solving this problem is keep narrowing down the search range until the target is found. However, we can\\'t eliminate half of the elements every time by just comparing target and nums[mid] since the entire array is neither in ascending order nor in descending order after the rotation. But we can still find a monotone interval and use it to narrow down the search range. \\n\\n   - If nums[mid] >= nums[left], then [left, mid] is a monotone interval in which all the elements are sorted in ascending order. In this case, if target is within range [left, mid), then we narrow down the search range to [left, mid-1], therwise we narrow down search range to [mid+1, right]. \\n   - If nums[mid] < nums[left], then [mid, right] is a monotone interval in which all the elements are sorted in ascending order. In this case, if target is within range (mid,right] then we narrow down the search range to [mid+1, right], otherwise we narrow down search range to [left, mid-1].\\n   \\n![image](https://assets.leetcode.com/users/images/b505483b-24b2-4db3-a603-7cc4aa1dce51_1595920273.5792851.png)\\n\\n### Implementation\\n```\\npublic class Solution {\\n    public int Search(int[] nums, int target) {\\n        \\n        if(nums == null || nums.Length == 0)\\n            return -1;\\n        \\n        int left = 0, right = nums.Length - 1;\\n        \\n        while(left <= right)\\n        {\\n            int mid = left + (right - left) / 2;\\n            \\n            if(target == nums[mid])\\n            {\\n                return mid;\\n            }\\n            else if(nums[mid] >= nums[left])\\n            {\\n                if(target >= nums[left] && target < nums[mid])\\n                    right = mid - 1;\\n                else\\n                    left = mid + 1;\\n            }\\n            else\\n            {\\n                if(target > nums[mid] && target <= nums[right])\\n                    left = mid + 1;\\n                else\\n                    right = mid - 1;\\n            }\\n        }\\n        \\n        return -1;\\n    }\\n}\\n```\\n",
                "solutionTags": [],
                "code": "```\\npublic class Solution {\\n    public int Search(int[] nums, int target) {\\n        \\n        if(nums == null || nums.Length == 0)\\n            return -1;\\n        \\n        int left = 0, right = nums.Length - 1;\\n        \\n        while(left <= right)\\n        {\\n            int mid = left + (right - left) / 2;\\n            \\n            if(target == nums[mid])\\n            {\\n                return mid;\\n            }\\n            else if(nums[mid] >= nums[left])\\n            {\\n                if(target >= nums[left] && target < nums[mid])\\n                    right = mid - 1;\\n                else\\n                    left = mid + 1;\\n            }\\n            else\\n            {\\n                if(target > nums[mid] && target <= nums[right])\\n                    left = mid + 1;\\n                else\\n                    right = mid - 1;\\n            }\\n        }\\n        \\n        return -1;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 417017,
                "title": "java-binary-search-with-explanations-and-examples",
                "content": "```java\\n\\n    // Since the array is partially sorted, there are only 2 scenarios to consider.\\n    // let m = (left+right)/2. \\n    // (1) the subarray from left to m_th index is sorted\\n    // (2) the subarray from m_th to right index is sorted\\n    // eg. [4,5,6,7,0,1,2]\\n    // left = 0, right = 6, m = 3\\n    // either [4,5,6,7] or [7,0,1,2] must be sorted\\n    // this can be checked comparing subarray[0] and subarray[length-1]\\n    // if subarray[length-1] >= subarray[0], the subarray is sorted\\n    // for each each scenario, we consider if the target is in the range of {subarray[0], subarray[length-1]}.\\n    // if it is, we do normal binary search. else, we search in the other half\\n    \\n    // walk through\\n    // [4,5,6,7,0,1,2], target = 0\\n    // l=0, r=6, m=3\\n    // nums[3]=7, left subarray is sorted since nums[3] >= nums[0] and target 0 is not in range. therefore, we search the other half.\\n    // l=m+1=4, r=6, m=5\\n    // nums[5]=1, left subarray is sorted since nums[5] >= nums[4] and target 0 is in range. therefore, we search in the left half.\\n    // l=4, r=5, m=4\\n    // nums[4]=0, target = 0, therefore, return 4;\\n    \\n    // what if target is not in the array\\n    // [4,5,6,8,0,1,2], target = 7\\n    // l=0, r=6, m=3\\n    // l=0, r=3, m=1\\n    // l=2, r=3, m=2\\n    // l=3, r=3, m=3\\n    // since nums[l] and nums[m] both point to 8 and 7 != 8, l = 4\\n    // l=4, r=3. exits loop\\n\\t\\n    public int search(int[] nums, int target) {\\n        int left = 0;\\n        int right = nums.length-1;\\n        while (left <= right && left < nums.length && right >= 0) {\\n            int mid = left + (right-left)/2;\\n            if (target == nums[mid]) {    //condition 1\\n                return mid;\\n            }\\n            if (nums[left] <= nums[mid] && nums[left] <= target && target <= nums[mid]) {     //condition 2\\n                right = mid;\\n            }\\n            else if (nums[left] <= nums[mid]) {     //condition 3\\n                left = mid + 1;\\n            }\\n            else if (nums[right] >= nums[mid] && nums[mid] <= target && target <= nums[right]) {     //condition 4\\n                left = mid;\\n            }\\n            else {     //condition 5\\n                right = mid - 1;\\n            }\\n        }\\n        return -1;\\n    }\\n\\t\\n```\\nupdate: \\n i think the key is to grasp boundary conditions is to makes ure that after each iteration, the problem size decreases. the only time the problem size doesn\\'t have to decrease is when you have found the answer.\\n if condition 3 or 5 is met, the problem size is guaranteed to decrease. if condition 1 is met, we exit the loop.\\nhowever, for condition 2 and 4, the problem size only decreases when the subarray contains 2 or more numbers.\\nassuming subarray contains [1,2,3], target = 1. l=0, r=2, m=1, condition 2 is met.\\nthe subarray becomes [1,2] , l=0, r=1, m=0. if condition 1 didn\\'t exist, condition 2 would have been met, subarray would become [1], l=0, r=0, m=0, then we go into an infinite loop.\\ntherefore, condition 1 ensures that the problem size will always decrease in the case where the subarray contained only 1 element and condition 2 or 4 are met.\\ntherefore, it is ensured that the problem size decreases after each iteration. i think that\\'s the key to solving binary search problems.\\n\\nanother thing is to keep track of your left and right pointers.\\nif you set the condition as (nums[mid] < target) instead of (nums[mid] <= target), you also need to change the instructions along with the condition.\\nif the condition is (nums[mid] <= target) and it is met, the next step would be to search in a subarray that starts at mid.\\nif the condition is (nums[mid] < target) and it is met, the next step would be to search in a subarray that starts at (mid+1).\\n",
                "solutionTags": [],
                "code": "```java\\n\\n    // Since the array is partially sorted, there are only 2 scenarios to consider.\\n    // let m = (left+right)/2. \\n    // (1) the subarray from left to m_th index is sorted\\n    // (2) the subarray from m_th to right index is sorted\\n    // eg. [4,5,6,7,0,1,2]\\n    // left = 0, right = 6, m = 3\\n    // either [4,5,6,7] or [7,0,1,2] must be sorted\\n    // this can be checked comparing subarray[0] and subarray[length-1]\\n    // if subarray[length-1] >= subarray[0], the subarray is sorted\\n    // for each each scenario, we consider if the target is in the range of {subarray[0], subarray[length-1]}.\\n    // if it is, we do normal binary search. else, we search in the other half\\n    \\n    // walk through\\n    // [4,5,6,7,0,1,2], target = 0\\n    // l=0, r=6, m=3\\n    // nums[3]=7, left subarray is sorted since nums[3] >= nums[0] and target 0 is not in range. therefore, we search the other half.\\n    // l=m+1=4, r=6, m=5\\n    // nums[5]=1, left subarray is sorted since nums[5] >= nums[4] and target 0 is in range. therefore, we search in the left half.\\n    // l=4, r=5, m=4\\n    // nums[4]=0, target = 0, therefore, return 4;\\n    \\n    // what if target is not in the array\\n    // [4,5,6,8,0,1,2], target = 7\\n    // l=0, r=6, m=3\\n    // l=0, r=3, m=1\\n    // l=2, r=3, m=2\\n    // l=3, r=3, m=3\\n    // since nums[l] and nums[m] both point to 8 and 7 != 8, l = 4\\n    // l=4, r=3. exits loop\\n\\t\\n    public int search(int[] nums, int target) {\\n        int left = 0;\\n        int right = nums.length-1;\\n        while (left <= right && left < nums.length && right >= 0) {\\n            int mid = left + (right-left)/2;\\n            if (target == nums[mid]) {    //condition 1\\n                return mid;\\n            }\\n            if (nums[left] <= nums[mid] && nums[left] <= target && target <= nums[mid]) {     //condition 2\\n                right = mid;\\n            }\\n            else if (nums[left] <= nums[mid]) {     //condition 3\\n                left = mid + 1;\\n            }\\n            else if (nums[right] >= nums[mid] && nums[mid] <= target && target <= nums[right]) {     //condition 4\\n                left = mid;\\n            }\\n            else {     //condition 5\\n                right = mid - 1;\\n            }\\n        }\\n        return -1;\\n    }\\n\\t\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 279439,
                "title": "c-binary-search",
                "content": "```\\npublic class Solution {\\n    public int Search(int[] nums, int target) {\\n        var n = nums.Length;\\n\\n        var left = 0;\\n        var right = n - 1;\\n\\n        while (left <= right) {\\n            var mid = left + (right - left) / 2;\\n            if (nums[mid] == target) {\\n                return mid;\\n            } else if (nums[left] <= nums[mid]) {\\n                // NOTE: left might equal to mid [3,1], single number matches the rule, so need nums[left] <= nums[mid]\\n                // increasing on the left\\n                if (nums[left] <= target && target <= nums[mid]) {\\n                    right = mid - 1;\\n                } else {\\n                    left = mid + 1;\\n                }\\n            } else {\\n                // increasing on the right\\n                if (nums[mid] <= target && target <= nums[right]) {\\n                    left = mid + 1;\\n                } else {\\n                    right = mid - 1;\\n                }\\n            }\\n        }\\n\\n        return -1;\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\npublic class Solution {\\n    public int Search(int[] nums, int target) {\\n        var n = nums.Length;\\n\\n        var left = 0;\\n        var right = n - 1;\\n\\n        while (left <= right) {\\n            var mid = left + (right - left) / 2;\\n            if (nums[mid] == target) {\\n                return mid;\\n            } else if (nums[left] <= nums[mid]) {\\n                // NOTE: left might equal to mid [3,1], single number matches the rule, so need nums[left] <= nums[mid]\\n                // increasing on the left\\n                if (nums[left] <= target && target <= nums[mid]) {\\n                    right = mid - 1;\\n                } else {\\n                    left = mid + 1;\\n                }\\n            } else {\\n                // increasing on the right\\n                if (nums[mid] <= target && target <= nums[right]) {\\n                    left = mid + 1;\\n                } else {\\n                    right = mid - 1;\\n                }\\n            }\\n        }\\n\\n        return -1;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3879510,
                "title": "c-o-logn-binary-search-pictorial-representation",
                "content": "**Connect with me on LinkedIn**: https://www.linkedin.com/in/abhay5349singh/\\n\\n![image](https://assets.leetcode.com/users/images/99f8d605-726f-45d7-8df1-28376d128ea5_1691462070.3995874.jpeg)\\n\\n**Approach:**\\n* identify in which segment our current *mid* is present \\n* Present in left segment: a[m]>a[n-1]\\n\\t* Move right side: if target is in right segment or target is greater than mid\\n\\t* else move left\\n* Present in right segment: a[m]<a[n-1]\\n\\t* Move left side: if target is in left segment or target is smaller than mid\\n\\t* else move right\\n\\n```\\nclass Solution {\\npublic:\\n    int search(vector<int>& a, int target) {\\n        int n=a.size();\\n        int l=0, r=n-1;\\n        \\n        while(l<=r){\\n            int m=(l+r)/2;\\n            if(a[m]==target) return m;\\n            if(a[m]>a[n-1]){ // left side of peak element\\n                if(target>a[m] || target<a[0]){\\n                    l=m+1;\\n                }else{\\n                    r=m-1;\\n                }\\n            }else{ // right side of peak element\\n                if(target<a[m] || target>a[n-1]){\\n                    r=m-1;\\n                }else{\\n                    l=m+1;\\n                }\\n            }\\n        }\\n      return -1;\\n    }\\n};\\n```\\n\\n**Do upvote if it helps :)**",
                "solutionTags": [
                    "C++",
                    "Binary Tree"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int search(vector<int>& a, int target) {\\n        int n=a.size();\\n        int l=0, r=n-1;\\n        \\n        while(l<=r){\\n            int m=(l+r)/2;\\n            if(a[m]==target) return m;\\n            if(a[m]>a[n-1]){ // left side of peak element\\n                if(target>a[m] || target<a[0]){\\n                    l=m+1;\\n                }else{\\n                    r=m-1;\\n                }\\n            }else{ // right side of peak element\\n                if(target<a[m] || target>a[n-1]){\\n                    r=m-1;\\n                }else{\\n                    l=m+1;\\n                }\\n            }\\n        }\\n      return -1;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3780314,
                "title": "binary-search-template-solution-intuition-explained-in-detail-video-solution",
                "content": "# Intuition\\nIntuition\\nhey every one i have made video playlist for binary search where i discuss a template solution and intuition behind it, this template solution will be very useful as this will help you solve many other questions in binary search this question is the part of that playlist:\\nVideo link for question:\\nhttps://youtu.be/DnNyh3WIdpg\\n\\nPlaylist ink: https://youtube.com/playlist?list=PLICVjZ3X1AcYYdde4GTp79zfdp_VACSkX\\n\\n\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n        // 4 5 6 7 0 1 2 \\n\\n    bool predicate(int mid,vector<int>& nums, int target){\\n        int val;\\n        if(target< nums[0] == nums[mid]<nums[0]){\\n            val=nums[mid];\\n        }\\n        else{\\n            if(target<nums[0]){\\n                val=INT_MIN;\\n            }\\n            else{\\n                val=INT_MAX;\\n            }\\n        }\\n        return val>=target;\\n\\n    }\\n    int search(vector<int>& nums, int target) {\\n        int left=0;\\n        int right=nums.size()-1;\\n        while(left<right){\\n            int mid= left+ (right-left)/2;\\n            if(predicate(mid,nums,target)){\\n                right=mid;\\n            }\\n            else{\\n                left=mid+1;\\n            }\\n        }\\n        return nums[left]==target ? left:-1;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n        // 4 5 6 7 0 1 2 \\n\\n    bool predicate(int mid,vector<int>& nums, int target){\\n        int val;\\n        if(target< nums[0] == nums[mid]<nums[0]){\\n            val=nums[mid];\\n        }\\n        else{\\n            if(target<nums[0]){\\n                val=INT_MIN;\\n            }\\n            else{\\n                val=INT_MAX;\\n            }\\n        }\\n        return val>=target;\\n\\n    }\\n    int search(vector<int>& nums, int target) {\\n        int left=0;\\n        int right=nums.size()-1;\\n        while(left<right){\\n            int mid= left+ (right-left)/2;\\n            if(predicate(mid,nums,target)){\\n                right=mid;\\n            }\\n            else{\\n                left=mid+1;\\n            }\\n        }\\n        return nums[left]==target ? left:-1;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3221484,
                "title": "rotated-array-binary-search-finding-targets-in-style-with-o-log-n-time-complexity",
                "content": "To solve this problem with O(log n) time complexity, we can use a modified binary search algorithm.\\n\\n1. First, we find the pivot point where the array is rotated. This can be done using binary search. We start with the middle element and check if it is greater than the last element. If it is, then the pivot must be in the right half of the array. If it is not, then the pivot must be in the left half of the array. We continue this process until we find the pivot element.\\n\\n2. Once we know the pivot point, we can perform binary search on the appropriate half of the array. If the target is less than or equal to the last element in the left half, then we search the left half. Otherwise, we search the right half.\\n\\n3. In each iteration of the binary search, we check the middle element of the current range. If it is equal to the target, we return its index. If it is greater than the target, we search the left half. Otherwise, we search the right half. If we reach the end of the range without finding the target, we return -1.\\n\\n# Complexity\\n- Time complexity: The algorithm uses binary search twice, once to find the pivot and once to find the target. Both binary searches take $$O(log n)$$ time. Therefore, the total time complexity is $$O(log n)$$.\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: The algorithm uses a constant amount of extra space for variables such as left, right, mid, and pivot. Therefore, the space complexity is $$O(1)$$.\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution:\\n    def search(self, nums: List[int], target: int) -> int:\\n        # find the pivot point\\n        left, right = 0, len(nums) - 1\\n        while left < right:\\n            mid = (left + right) // 2\\n            if nums[mid] > nums[right]:\\n                left = mid + 1\\n            else:\\n                right = mid\\n        pivot = left\\n    \\n    # perform binary search on the appropriate half of the array\\n        if target >= nums[pivot] and target <= nums[-1]:\\n            left, right = pivot, len(nums) - 1\\n        else:\\n            left, right = 0, pivot - 1\\n        while left <= right:\\n            mid = (left + right) // 2\\n            if nums[mid] == target:\\n                return mid\\n            elif nums[mid] < target:\\n                left = mid + 1\\n            else:\\n                right = mid - 1\\n        return -1\\n```",
                "solutionTags": [
                    "Python3",
                    "Array",
                    "Binary Search"
                ],
                "code": "```\\nclass Solution:\\n    def search(self, nums: List[int], target: int) -> int:\\n        # find the pivot point\\n        left, right = 0, len(nums) - 1\\n        while left < right:\\n            mid = (left + right) // 2\\n            if nums[mid] > nums[right]:\\n                left = mid + 1\\n            else:\\n                right = mid\\n        pivot = left\\n    \\n    # perform binary search on the appropriate half of the array\\n        if target >= nums[pivot] and target <= nums[-1]:\\n            left, right = pivot, len(nums) - 1\\n        else:\\n            left, right = 0, pivot - 1\\n        while left <= right:\\n            mid = (left + right) // 2\\n            if nums[mid] == target:\\n                return mid\\n            elif nums[mid] < target:\\n                left = mid + 1\\n            else:\\n                right = mid - 1\\n        return -1\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3100908,
                "title": "best-o-logn-solution",
                "content": "# Approach 1\\nLinear Search\\n\\n# Complexity\\n- Time complexity:\\n$$O(n)$$\\n\\n- Space complexity:\\n$$O(1)$$\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int search(vector<int>& nums, int target) {\\n        for (int i = 0; i < nums.size(); i++)\\n            if (nums[i] == target)\\n                return i;\\n        return -1;          \\n    }\\n};\\n```\\n\\n# Approach 2\\nBinary Search\\n\\n# Complexity\\n- Time complexity:\\n$$O(logn)$$\\n\\n- Space complexity:\\n$$O(1)$$\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int search(vector<int>& nums, int target) {\\n        int low = 0, high = nums.size() - 1;\\n        while (low < high) {\\n            int mid = (low + high) / 2;\\n            if (nums[mid] == target)\\n                return mid;\\n            if (nums[low] <= nums[mid]) {\\n                if (target >= nums[low] && target < nums[mid])\\n                    high = mid - 1;\\n                else\\n                    low = mid + 1;    \\n            } else {\\n                if (target > nums[mid] && target <= nums[high])\\n                    low = mid + 1;\\n                else\\n                    high = mid - 1; \\n            }    \\n        }\\n        return nums[low] == target ? low : -1;        \\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int search(vector<int>& nums, int target) {\\n        for (int i = 0; i < nums.size(); i++)\\n            if (nums[i] == target)\\n                return i;\\n        return -1;          \\n    }\\n};\\n```\n```\\nclass Solution {\\npublic:\\n    int search(vector<int>& nums, int target) {\\n        int low = 0, high = nums.size() - 1;\\n        while (low < high) {\\n            int mid = (low + high) / 2;\\n            if (nums[mid] == target)\\n                return mid;\\n            if (nums[low] <= nums[mid]) {\\n                if (target >= nums[low] && target < nums[mid])\\n                    high = mid - 1;\\n                else\\n                    low = mid + 1;    \\n            } else {\\n                if (target > nums[mid] && target <= nums[high])\\n                    low = mid + 1;\\n                else\\n                    high = mid - 1; \\n            }    \\n        }\\n        return nums[low] == target ? low : -1;        \\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2303961,
                "title": "c-1-time-binary-search-solution-runtime-faster-than-100-00-memory-usage-less-than-75-00",
                "content": "Without finding the pivot point , from where the array is rotated...\\nthere are only two possibilities ..\\n1.The mid of our search space will be greater than start of our search space.\\n*    now array will be sorted from start to mid\\n*    here are two possibilities ...target can be between start to mid or on the right part of mid.\\n\\n2.The mid of our search space will be smaller than start of our search space \\n* now the array will be sorted from mid to end \\n* here are other two possiblities ...target can be in between the mid to end or on the left part of mid\\n```\\nclass Solution {\\npublic:\\n    int search(vector<int>& nums, int target) {\\n       int s=0,e=nums.size()-1;\\n        while(s<=e){\\n            int m=(s+e)/2;\\n            if(target==nums[m])return m;\\n            if(s==m){s+=1;continue;}\\n            if(nums[m]>nums[s]){\\n                if(target>=nums[s] and target<nums[m]) e=m-1;\\n                else s=m+1;\\n            }\\n            else{\\n                 if(target>nums[m] and target<=nums[e]) s=m+1;\\n                else e=m-1;\\n            }\\n        }\\n        return -1;\\n        \\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "C",
                    "Binary Tree"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int search(vector<int>& nums, int target) {\\n       int s=0,e=nums.size()-1;\\n        while(s<=e){\\n            int m=(s+e)/2;\\n            if(target==nums[m])return m;\\n            if(s==m){s+=1;continue;}\\n            if(nums[m]>nums[s]){\\n                if(target>=nums[s] and target<nums[m]) e=m-1;\\n                else s=m+1;\\n            }\\n            else{\\n                 if(target>nums[m] and target<=nums[e]) s=m+1;\\n                else e=m-1;\\n            }\\n        }\\n        return -1;\\n        \\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1842472,
                "title": "c-simple-code-easy-o-log-n-search",
                "content": "**Please upvote if you like this approach \\\\ solution \\uD83D\\uDE0A**\\n\\n\\tclass Solution {\\n\\tpublic:\\n\\t\\tint search(vector<int>& nums, int target) {\\n\\t\\t\\tint start = 0;\\n\\t\\t\\tint end = nums.size()-1;\\n\\n\\t\\t\\twhile(start <= end)\\n\\t\\t\\t{\\n\\t\\t\\t\\tint mid = start + (end - start) / 2;\\n\\n\\t\\t\\t\\tif(nums[mid] == target)\\n\\t\\t\\t\\t\\treturn mid;\\n\\n\\t\\t\\t\\tif(nums[mid] >= nums[start])\\n\\t\\t\\t\\t{\\n\\t\\t\\t\\t\\tif(nums[start] <= target && target < nums[mid])\\n\\t\\t\\t\\t\\t\\tend = mid - 1;\\n\\t\\t\\t\\t\\telse\\n\\t\\t\\t\\t\\t\\tstart = mid + 1;\\n\\t\\t\\t\\t}\\n\\t\\t\\t\\telse\\n\\t\\t\\t\\t{\\n\\t\\t\\t\\t\\tif(nums[mid] < target && target <= nums[end])\\n\\t\\t\\t\\t\\t\\tstart = mid + 1;\\n\\t\\t\\t\\t\\telse\\n\\t\\t\\t\\t\\t\\tend = mid - 1;\\n\\t\\t\\t\\t}\\n\\t\\t\\t}\\n\\t\\t\\treturn -1;\\n\\t\\t} \\n\\t};",
                "solutionTags": [
                    "C++",
                    "C",
                    "Binary Tree"
                ],
                "code": "class Solution {\\n\\tpublic:\\n\\t\\tint search(vector<int>& nums, int target) {\\n\\t\\t\\tint start = 0;\\n\\t\\t\\tint end = nums.size()-1;\\n\\n\\t\\t\\twhile(start <= end)\\n\\t\\t\\t{\\n\\t\\t\\t\\tint mid = start + (end - start) / 2;\\n\\n\\t\\t\\t\\tif(nums[mid] == target)\\n\\t\\t\\t\\t\\treturn mid;\\n\\n\\t\\t\\t\\tif(nums[mid] >= nums[start])\\n\\t\\t\\t\\t{\\n\\t\\t\\t\\t\\tif(nums[start] <= target && target < nums[mid])\\n\\t\\t\\t\\t\\t\\tend = mid - 1;\\n\\t\\t\\t\\t\\telse\\n\\t\\t\\t\\t\\t\\tstart = mid + 1;\\n\\t\\t\\t\\t}",
                "codeTag": "Java"
            },
            {
                "id": 1654277,
                "title": "python-binary-search-with-explanation-3-cases",
                "content": "**Idea:** There are three cases for when we search on the right half of each step.\\n\\n1. If target is between mid and right (easiest case, we know it might be in the right half b/c target is greater than mid but less than right)\\n2. If target is greater than mid, and left is less than/equal to mid (even though right will be less than mid, we know it\\'s not in the left half as left is smaller than mid)\\n3. If target is less than left, and left is less than/equal to mid (left is smaller than mid, we know it\\'s not iin the left half as target is smaller than left)\\n\\n**left = `nums[l]`, right = `nums[r]`, mid = `nums[mid]`.\\n\\nCase 1 relies on the proof that target can only be in right half. Cases 2 and 3 relies on the proof that target can not be in left half. Each case also relies on the precondition that the array is strictly increasing (from some index i to n - 1 and continued from 0 to i - 1).\\n\\nSmall example is listed for each case below in form of # [nums], target\\n\\n```\\nclass Solution:\\n    def search(self, nums: List[int], target: int) -> int:\\n        l, r = 0, len(nums) - 1\\n        while l <= r:\\n            mid = (l + r) // 2\\n            if nums[mid] == target:\\n                return mid\\n            elif (nums[mid] < target <= nums[r] or # eg. [2, 0, 1],    1 (0 < 1)\\n                  nums[l] <= nums[mid] < target or # eg. [1, 2, 3, 0], 3 (1 <= 2)\\n                  target < nums[l] <= nums[mid]):  # eg. [1, 2, 0],    0 (1 <= 2)\\n                l = mid + 1\\n            else:\\n                r = mid - 1\\n        return -1\\n```",
                "solutionTags": [
                    "Python",
                    "Binary Tree"
                ],
                "code": "```\\nclass Solution:\\n    def search(self, nums: List[int], target: int) -> int:\\n        l, r = 0, len(nums) - 1\\n        while l <= r:\\n            mid = (l + r) // 2\\n            if nums[mid] == target:\\n                return mid\\n            elif (nums[mid] < target <= nums[r] or # eg. [2, 0, 1],    1 (0 < 1)\\n                  nums[l] <= nums[mid] < target or # eg. [1, 2, 3, 0], 3 (1 <= 2)\\n                  target < nums[l] <= nums[mid]):  # eg. [1, 2, 0],    0 (1 <= 2)\\n                l = mid + 1\\n            else:\\n                r = mid - 1\\n        return -1\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1174197,
                "title": "python-simple-explanation-2-approaches",
                "content": "**Approach 1:**\\nFind the minimum value index in the array and use this to identify the 2 ascending parts of the array. (Regular binary search in each part)\\nThe key is figuring out how to find the min_value_index.\\n**Key idea to find min_value_index:** \\nIf arr[mid] is greater than arr[end], it means our min_value would be on the right of mid (and it is definitely not mid). Hence go right => start = mid + 1\\nElse if arr[mid] is less than arr[end], it means our min_value is on the left (and it also could be present at mid). Hence go left => end = mid.\\nDo this while start<end. \\nWhen loop ends, start == end, and start will be pointing to min_value_index.\\nUse the min_value_index as the partition point to binary search on the 2 ascending parts.\\n\\n```\\nclass Solution:\\n    def search(self, nums: List[int], target: int) -> int:\\n        if not nums:\\n            return -1\\n        min_value_index = self.find_min_value_index(nums)\\n        result = self.binary_search(nums, target, min_value_index, len(nums)-1)\\n        if result == -1 and min_value_index != 0:\\n            result = self.binary_search(nums, target, 0, min_value_index-1)\\n        return result\\n               \\n    def binary_search(self, nums, target, start, end):\\n        while start <= end:\\n            mid = start + (end - start) // 2\\n            if target == nums[mid]:\\n                return mid\\n            if target < nums[mid]:\\n                end = mid - 1\\n            else:\\n                start = mid + 1\\n        return -1\\n        \\n    def find_min_value_index(self, nums):\\n        start = 0\\n        end = len(nums) - 1\\n        while start < end:\\n            mid = start + (end - start) // 2\\n            if nums[mid] > nums[end]:\\n                # go right\\n                start = mid + 1\\n            else:\\n                # go left and do not eliminate mid\\n                end = mid\\n        return start\\n```\\n\\n**Approach 2:**\\n**Key idea:** \\nRealizing that after finding the mid, we need to find if sorted part lies on the left or on the right.\\nOnce we know which part is sorted, for this part, we ask the question: does the key lie in this part? \\nIf yes, go into this part. If not, go to the other part.\\n\\t\\t\\t\\t\\t \\n```\\nclass Solution:\\n    def search(self, nums: List[int], target: int) -> int:\\n        if not nums:\\n            return -1\\n        start = 0\\n        end = len(nums) - 1\\n        \\n        while start <= end:\\n            mid = start + (end - start) // 2\\n            if nums[mid] == target: return mid\\n\\t\\t\\t\\n            if nums[start] <= nums[mid]:\\n\\t\\t\\t# If left part is sorted ascending\\n\\t\\t\\t# Note: We need to have <= for a case where array size is 2, in which case mid == start is also possible.\\n\\t\\t\\t# Now we ask the question:  does the key exist in this sorted part? Adjust bounds accordingly.\\n                if target >= nums[start] and target < nums[mid]:\\n                    end = mid - 1\\n                else:\\n                    start = mid + 1\\n            else:\\n\\t\\t\\t# Else right part is the sorted ascending part. \\n\\t\\t\\t# Ask the same question with respect to this part and adjust bounds accordingly.\\n                if target > nums[mid] and target <= nums[end]:\\n                    start = mid + 1\\n                else:\\n                    end = mid - 1\\n        return -1\\n```",
                "solutionTags": [
                    "Python",
                    "Binary Tree"
                ],
                "code": "```\\nclass Solution:\\n    def search(self, nums: List[int], target: int) -> int:\\n        if not nums:\\n            return -1\\n        min_value_index = self.find_min_value_index(nums)\\n        result = self.binary_search(nums, target, min_value_index, len(nums)-1)\\n        if result == -1 and min_value_index != 0:\\n            result = self.binary_search(nums, target, 0, min_value_index-1)\\n        return result\\n               \\n    def binary_search(self, nums, target, start, end):\\n        while start <= end:\\n            mid = start + (end - start) // 2\\n            if target == nums[mid]:\\n                return mid\\n            if target < nums[mid]:\\n                end = mid - 1\\n            else:\\n                start = mid + 1\\n        return -1\\n        \\n    def find_min_value_index(self, nums):\\n        start = 0\\n        end = len(nums) - 1\\n        while start < end:\\n            mid = start + (end - start) // 2\\n            if nums[mid] > nums[end]:\\n                # go right\\n                start = mid + 1\\n            else:\\n                # go left and do not eliminate mid\\n                end = mid\\n        return start\\n```\n```\\nclass Solution:\\n    def search(self, nums: List[int], target: int) -> int:\\n        if not nums:\\n            return -1\\n        start = 0\\n        end = len(nums) - 1\\n        \\n        while start <= end:\\n            mid = start + (end - start) // 2\\n            if nums[mid] == target: return mid\\n\\t\\t\\t\\n            if nums[start] <= nums[mid]:\\n\\t\\t\\t# If left part is sorted ascending\\n\\t\\t\\t# Note: We need to have <= for a case where array size is 2, in which case mid == start is also possible.\\n\\t\\t\\t# Now we ask the question:  does the key exist in this sorted part? Adjust bounds accordingly.\\n                if target >= nums[start] and target < nums[mid]:\\n                    end = mid - 1\\n                else:\\n                    start = mid + 1\\n            else:\\n\\t\\t\\t# Else right part is the sorted ascending part. \\n\\t\\t\\t# Ask the same question with respect to this part and adjust bounds accordingly.\\n                if target > nums[mid] and target <= nums[end]:\\n                    start = mid + 1\\n                else:\\n                    end = mid - 1\\n        return -1\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1042562,
                "title": "java-binary-search-calls-basic-binary-search-with-picture-expanation",
                "content": "### Find mid index, three senarios:\\n### senario 1 : nums[mid] == target\\n### senario 2 (left picture) : nums[mid] > nums[left]\\nif (target >= nums[left] && target < nums[mid]):  calls Binary search\\nelse left = mid + 1;\\n### senario 3 (right picture) : nums[mid] <= nums[left]\\nif (target > nums[mid] && target <= nums[right]):  calls Binary search\\nelse right = mid - 1;\\n![image](https://assets.leetcode.com/users/images/afbdafb4-3d42-41f9-ba5f-af2a08583d96_1612041019.4078958.png)\\n\\n```\\nclass Solution {\\n    public int search(int[] nums, int target) {\\n        int left = 0, right = nums.length - 1;\\n        while (left <= right) {\\n            int mid = left + (right - left) / 2;\\n            if (nums[mid] == target) return mid;\\n            if (nums[mid] < nums[left]) {\\n                if (target > nums[mid] && target <= nums[right]) {\\n                    return biSearch(nums, target, mid + 1, right);\\n                } else {\\n                    right = mid - 1;\\n                }\\n            } else {\\n                if (target >= nums[left] && target < nums[mid]) {\\n                    return biSearch(nums, target, left, mid - 1);\\n                } else {\\n                    left = mid + 1;\\n                }\\n            }\\n        }\\n        return -1;\\n    }\\n    \\n    private int biSearch(int[] nums, int target, int left, int right) {\\n        while (left <= right) {\\n            int mid = left + (right - left) / 2;\\n            if (nums[mid] == target) return mid;\\n            if (target < nums[mid]) {\\n                right = mid - 1;\\n            } else {\\n                left = mid + 1;\\n            }\\n        }\\n        return -1; \\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Binary Tree"
                ],
                "code": "```\\nclass Solution {\\n    public int search(int[] nums, int target) {\\n        int left = 0, right = nums.length - 1;\\n        while (left <= right) {\\n            int mid = left + (right - left) / 2;\\n            if (nums[mid] == target) return mid;\\n            if (nums[mid] < nums[left]) {\\n                if (target > nums[mid] && target <= nums[right]) {\\n                    return biSearch(nums, target, mid + 1, right);\\n                } else {\\n                    right = mid - 1;\\n                }\\n            } else {\\n                if (target >= nums[left] && target < nums[mid]) {\\n                    return biSearch(nums, target, left, mid - 1);\\n                } else {\\n                    left = mid + 1;\\n                }\\n            }\\n        }\\n        return -1;\\n    }\\n    \\n    private int biSearch(int[] nums, int target, int left, int right) {\\n        while (left <= right) {\\n            int mid = left + (right - left) / 2;\\n            if (nums[mid] == target) return mid;\\n            if (target < nums[mid]) {\\n                right = mid - 1;\\n            } else {\\n                left = mid + 1;\\n            }\\n        }\\n        return -1; \\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 408046,
                "title": "javascript-1pass-approach-w-explanation",
                "content": "#### The idea\\nIn order to fullfill the condition of a running time of `O(logn)`, we must use the binary search algorithm. However, Binary search algorithm only works if all the element in the array is sorted, when we have a `pivot` or `rotate` point in our array, we will find that the array is splited in to two parts, 1 to the left of the `rotate` point where everything is sorterd, and 1 to the right(included the `rotate` point) where everything is sorted. In order to apply binary search to find our `target`, we need to figure our which part of the sorted array does the `target` belong to, and from there everything is just standard binary search. \\n\\n*How can we find which part is it in?*\\nwe can make sure a part of the array is all sorted, if the beginning number is smaller than the end number, other wise, there must be a `rotate` point in between\\n\\n``` javascript\\nvar search1pass = function(nums, target) {\\n    if (nums.length == 0) {\\n        return -1;\\n    }\\n    if (nums.length == 1) {\\n        return nums[0] == target?0:-1;\\n    }\\n    let low = 0, high = nums.length - 1;\\n    while (low <= high) {\\n        mid = parseInt((low + (high - low)/2))\\n        if (target == nums[mid]) {\\n            return mid\\n        } else if (nums[low] <= nums[mid]) { // this means everything in between `low` & `mid` is in correct order\\n            // if target is bigger than nums[low] (the smallest # in this partial array) and smaller than nums[mid](the biggest # in this partial array)\\n            if (target >= nums[low] && target < nums[mid]) { \\n                high = mid - 1; // shift the right boundary to left of mid\\n            } else {\\n                // otherwise, our target is in the other end, shift the left boundary to right of mid\\n                low = mid + 1;\\n            }\\n        } else { // there must be a rotate point in between `low` and `mid`, and in between `mid` and `high`, the numbers should be in correct order\\n            // if the target is in between `mid` and `high`\\n            if (target <= nums[high] && target > nums[mid]) {\\n                low = mid + 1; // shift the left boundary to the right of mid\\n            } else {\\n                high = mid - 1 // shift the right boudary to the left of mid, \\n            }\\n        }\\n    }\\n    return -1;\\n}\\n```\\n**I think this version is better since it\\'s more consistent and easier to understand**\\n```\\nvar search = function(nums, target) {\\n    let left=0, right=nums.length-1;\\n    while(left < right) {\\n        let mid = left + Math.floor((right - left)/2);\\n        if (nums[mid] < nums[right]) {\\n            if (target > nums[mid] && target <= nums[right]) {\\n                left = mid + 1;\\n            } else {\\n                right = mid;\\n            }\\n        } else {\\n            if (target > nums[mid] || target < nums[left]) {\\n                left = mid + 1;\\n            } else {\\n                right = mid;\\n            }\\n        }\\n    }\\n    return nums[left]==target?left:-1;\\n};\\n```\\nIf you wan to read more on how to write consisntent binary search code, check out my tutorial [here](https://leetcode.com/problems/binary-search/discuss/423162/Binary-Search-101-The-Ultimate-Binary-Search-Handbook)",
                "solutionTags": [
                    "JavaScript",
                    "Binary Tree"
                ],
                "code": "``` javascript\\nvar search1pass = function(nums, target) {\\n    if (nums.length == 0) {\\n        return -1;\\n    }\\n    if (nums.length == 1) {\\n        return nums[0] == target?0:-1;\\n    }\\n    let low = 0, high = nums.length - 1;\\n    while (low <= high) {\\n        mid = parseInt((low + (high - low)/2))\\n        if (target == nums[mid]) {\\n            return mid\\n        } else if (nums[low] <= nums[mid]) { // this means everything in between `low` & `mid` is in correct order\\n            // if target is bigger than nums[low] (the smallest # in this partial array) and smaller than nums[mid](the biggest # in this partial array)\\n            if (target >= nums[low] && target < nums[mid]) { \\n                high = mid - 1; // shift the right boundary to left of mid\\n            } else {\\n                // otherwise, our target is in the other end, shift the left boundary to right of mid\\n                low = mid + 1;\\n            }\\n        } else { // there must be a rotate point in between `low` and `mid`, and in between `mid` and `high`, the numbers should be in correct order\\n            // if the target is in between `mid` and `high`\\n            if (target <= nums[high] && target > nums[mid]) {\\n                low = mid + 1; // shift the left boundary to the right of mid\\n            } else {\\n                high = mid - 1 // shift the right boudary to the left of mid, \\n            }\\n        }\\n    }\\n    return -1;\\n}\\n```\n```\\nvar search = function(nums, target) {\\n    let left=0, right=nums.length-1;\\n    while(left < right) {\\n        let mid = left + Math.floor((right - left)/2);\\n        if (nums[mid] < nums[right]) {\\n            if (target > nums[mid] && target <= nums[right]) {\\n                left = mid + 1;\\n            } else {\\n                right = mid;\\n            }\\n        } else {\\n            if (target > nums[mid] || target < nums[left]) {\\n                left = mid + 1;\\n            } else {\\n                right = mid;\\n            }\\n        }\\n    }\\n    return nums[left]==target?left:-1;\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3880652,
                "title": "simple-c-solution-using-binary-search-o-logn",
                "content": "# Intuition\\nDistinguish problem\\'s scenario between two cases: rotated array (where last element can\\'t be greater than the first, i.e., `first` >= `last`) and sorted array (where `first` < `last`).\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n1. Initialize `i` = 0 and `j` = size - 1.\\n2. Iterate while `i` <= `j`.\\n3. If the array is rotated (`first element` >= `last element`), check target against `i` and `j`. Return index if found, otherwise increment `i` and decrement `j`.\\nNote: Reason behind `i++` and `j--` is to gradually narrow down to a potentially sorted subarray (`nums[i]` < `nums[j]`). This transition indicates moving from the rotated part to a sorted section, where the target could be found.\\n4. If the array is sorted (`first element` < `last element`), apply **Binary search**.\\n5. `Return -1` if the target is not found.\\n\\nThis approach handles both rotated and sorted arrays efficiently to find the target index or return -1 if the target is not present.\\n\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n$$O(logn)$$\\nbecause used a modified binary search, which reduces the search space by half in each iteration.\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n$$O(1)$$\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int search(vector<int>& nums, int target) {\\n        int n = nums.size();\\n        int i=0, j=n-1;\\n        while(i<=j)\\n        {\\n            //For rotated arrays (Case 1), \\n            if(nums[i]>=nums[j])\\n            {\\n                //check if the target matches at ith or jth\\n                if(target==nums[i])\\n                return i;\\n                else if(target==nums[j])\\n                return j;\\n                //if not, iteratively increment i and decrement j.\\n                else\\n                i++;\\n                j--;\\n            }\\n            else\\n            {\\n                //nums[i]<nums[j], array is sorted between ith and jth index\\n                //apply binary search\\n                int mid = i + (j - i) / 2;\\n                if(nums[mid]<target)\\n                    i=mid+1;\\n                else if(nums[mid]>target)\\n                    j=mid-1;\\n                else\\n                return mid;\\n            }\\n        }\\n        //if Element is not found return -1.\\n        return -1;\\n    }\\n};\\n\\n```",
                "solutionTags": [
                    "C++",
                    "Binary Search"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int search(vector<int>& nums, int target) {\\n        int n = nums.size();\\n        int i=0, j=n-1;\\n        while(i<=j)\\n        {\\n            //For rotated arrays (Case 1), \\n            if(nums[i]>=nums[j])\\n            {\\n                //check if the target matches at ith or jth\\n                if(target==nums[i])\\n                return i;\\n                else if(target==nums[j])\\n                return j;\\n                //if not, iteratively increment i and decrement j.\\n                else\\n                i++;\\n                j--;\\n            }\\n            else\\n            {\\n                //nums[i]<nums[j], array is sorted between ith and jth index\\n                //apply binary search\\n                int mid = i + (j - i) / 2;\\n                if(nums[mid]<target)\\n                    i=mid+1;\\n                else if(nums[mid]>target)\\n                    j=mid-1;\\n                else\\n                return mid;\\n            }\\n        }\\n        //if Element is not found return -1.\\n        return -1;\\n    }\\n};\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3058206,
                "title": "easy-c-solution-binary-search-basic-approach",
                "content": "# Intuition\\nNeed to find sorted part and use binary search in it.\\n\\n# Approach\\nFind sorted part of array.Then check if target lies in that sorted part using binary search. If no, then go to unsorted part and search in its sorted subpart. If yes , return ans else return -1;\\n\\n# Complexity\\n- Time complexity: $$O(logn)$$ \\n\\n- Space complexity: $$O(1)$$ \\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int search(vector<int>& nums, int target) {\\n        int n = nums.size();\\n        int s = 0 , e = n-1;\\n\\n        while(s <= e){\\n            int mid = s +(e-s)/2;\\n            if(nums[mid] == target) return mid;\\n            \\n            //if left half is sorted \\n            if(nums[s] <= nums[mid]){\\n                // check if target lies in left side\\n                if(target <= nums[mid] && target >= nums[s]) e = mid-1;\\n                else s = mid + 1;\\n            }    \\n            //if right side is sorted \\n            else{\\n                // check if target lies in right side\\n                if(target >= nums[mid] && target <= nums[e]) s = mid+1;\\n                else e = mid-1;\\n            }\\n        }\\n        return -1;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int search(vector<int>& nums, int target) {\\n        int n = nums.size();\\n        int s = 0 , e = n-1;\\n\\n        while(s <= e){\\n            int mid = s +(e-s)/2;\\n            if(nums[mid] == target) return mid;\\n            \\n            //if left half is sorted \\n            if(nums[s] <= nums[mid]){\\n                // check if target lies in left side\\n                if(target <= nums[mid] && target >= nums[s]) e = mid-1;\\n                else s = mid + 1;\\n            }    \\n            //if right side is sorted \\n            else{\\n                // check if target lies in right side\\n                if(target >= nums[mid] && target <= nums[e]) s = mid+1;\\n                else e = mid-1;\\n            }\\n        }\\n        return -1;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2859654,
                "title": "c-solution",
                "content": "# Approach\\n<!-- Describe your approach to solving the problem. -->\\n    Binary Search\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n    O(log N)\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n    O(1)\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int search(vector<int>& nums, int target) {\\n        int l = 0, r = nums.size()-1;\\n        while(l <= r) {\\n            int mid = (l + r) / 2;\\n            if(nums[mid] == target) return mid;\\n            if (nums[mid] >= nums[l]) {\\n                if(target >= nums[l] && target < nums[mid]) r = mid - 1;\\n                else l = mid + 1;\\n            }\\n            else {\\n                if(target > nums[mid] && target <= nums[r]) l = mid + 1;\\n                else r = mid - 1;   \\n            }\\n        } \\n        return -1;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int search(vector<int>& nums, int target) {\\n        int l = 0, r = nums.size()-1;\\n        while(l <= r) {\\n            int mid = (l + r) / 2;\\n            if(nums[mid] == target) return mid;\\n            if (nums[mid] >= nums[l]) {\\n                if(target >= nums[l] && target < nums[mid]) r = mid - 1;\\n                else l = mid + 1;\\n            }\\n            else {\\n                if(target > nums[mid] && target <= nums[r]) l = mid + 1;\\n                else r = mid - 1;   \\n            }\\n        } \\n        return -1;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1883147,
                "title": "python-easiest-solution-95-04-faster-binary-search-beg-to-adv",
                "content": "```python\\nclass Solution:\\n    def search(self, nums: List[int], target: int) -> int:\\n        left = 0\\n        right = len(nums) - 1 \\n        \\n        while left <= right:\\n            \\n            mid = (right + left ) // 2\\n            \\n            if nums[mid] == target:\\n                return mid \\n            # LEFT SORTED PORTION\\n            elif nums[left]<=nums[mid]:\\n                if target > nums[mid] or target < nums[left]:\\n                     left = mid + 1\\n                else:\\n                    right = mid -1\\n            # RIGHT SORTED PORTION\\n            else:\\n                if target < nums[mid] or target > nums[right]:\\n                    right = mid -1 \\n                else:\\n                     left = mid+1\\n                    \\n        \\n        return -1\\n            \\n```\\n\\n***Found helpful, Do upvote !!***",
                "solutionTags": [
                    "Python",
                    "Python3",
                    "Binary Tree"
                ],
                "code": "```python\\nclass Solution:\\n    def search(self, nums: List[int], target: int) -> int:\\n        left = 0\\n        right = len(nums) - 1 \\n        \\n        while left <= right:\\n            \\n            mid = (right + left ) // 2\\n            \\n            if nums[mid] == target:\\n                return mid \\n            # LEFT SORTED PORTION\\n            elif nums[left]<=nums[mid]:\\n                if target > nums[mid] or target < nums[left]:\\n                     left = mid + 1\\n                else:\\n                    right = mid -1\\n            # RIGHT SORTED PORTION\\n            else:\\n                if target < nums[mid] or target > nums[right]:\\n                    right = mid -1 \\n                else:\\n                     left = mid+1\\n                    \\n        \\n        return -1\\n            \\n```",
                "codeTag": "Java"
            },
            {
                "id": 1399442,
                "title": "c-binary-search-simple-solution",
                "content": "Please upvote if it was helpful.\\n\\n\\tclass Solution {\\n\\tpublic:\\n\\t\\tint search(vector<int>& nums, int target) {\\n\\t\\t\\tint first = 0, last = nums.size() - 1;\\n\\t\\t\\t\\n\\t\\t\\twhile(first <= last){\\n\\t\\t\\t\\tint mid = first + (last - first) / 2;\\n\\t\\t\\t\\t\\n\\t\\t\\t\\tif(target == nums[mid]) return mid;\\n\\t\\t\\t\\tif(nums[first] <= nums[mid]){\\n\\t\\t\\t\\t\\tif(target >= nums[first] && target <= nums[mid])\\n\\t\\t\\t\\t\\t\\tlast = mid - 1;\\n\\t\\t\\t\\t\\telse\\n\\t\\t\\t\\t\\t\\tfirst = mid + 1;\\n\\t\\t\\t\\t} else {\\n\\t\\t\\t\\t\\tif(target <= nums[last] && target >= nums[mid])\\n\\t\\t\\t\\t\\t\\tfirst = mid + 1;\\n\\t\\t\\t\\t\\telse\\n\\t\\t\\t\\t\\t\\tlast = mid - 1;\\n\\t\\t\\t\\t}\\n\\t\\t\\t}\\n\\t\\t\\treturn -1;\\n\\t\\t}\\n\\t};\\nThank You !!",
                "solutionTags": [],
                "code": "class Solution {\\n\\tpublic:\\n\\t\\tint search(vector<int>& nums, int target) {\\n\\t\\t\\tint first = 0, last = nums.size() - 1;\\n\\t\\t\\t\\n\\t\\t\\twhile(first <= last){\\n\\t\\t\\t\\tint mid = first + (last - first) / 2;\\n\\t\\t\\t\\t\\n\\t\\t\\t\\tif(target == nums[mid]) return mid;\\n\\t\\t\\t\\tif(nums[first] <= nums[mid]){\\n\\t\\t\\t\\t\\tif(target >= nums[first] && target <= nums[mid])\\n\\t\\t\\t\\t\\t\\tlast = mid - 1;\\n\\t\\t\\t\\t\\telse\\n\\t\\t\\t\\t\\t\\tfirst = mid + 1;\\n\\t\\t\\t\\t}",
                "codeTag": "Java"
            },
            {
                "id": 1322975,
                "title": "java-binary-search-solution-important-to-interview",
                "content": "```\\nclass Solution {\\n    public int search(int[] nums, int target) {\\n        \\n        int low = 0,high = nums.length-1;\\n        \\n        while(low <= high)\\n        {\\n            int mid = (low+high)/2;\\n            if(nums[mid] == target)\\n                return mid;\\n            if(nums[low] <= nums[mid])\\n            {\\n                if(target >= nums[low] && target <= nums[mid])\\n                    high = mid-1;\\n                else    low = mid+1;\\n            }\\n            else\\n            {\\n                if(target >= nums[mid] && target <= nums[high])\\n                    low = mid+1;\\n                else    high = mid-1;\\n            }\\n        }\\n        return -1;\\n    }\\n}\\n```\\nPlease upvote if u find my code easy",
                "solutionTags": [
                    "Java",
                    "Binary Tree"
                ],
                "code": "```\\nclass Solution {\\n    public int search(int[] nums, int target) {\\n        \\n        int low = 0,high = nums.length-1;\\n        \\n        while(low <= high)\\n        {\\n            int mid = (low+high)/2;\\n            if(nums[mid] == target)\\n                return mid;\\n            if(nums[low] <= nums[mid])\\n            {\\n                if(target >= nums[low] && target <= nums[mid])\\n                    high = mid-1;\\n                else    low = mid+1;\\n            }\\n            else\\n            {\\n                if(target >= nums[mid] && target <= nums[high])\\n                    low = mid+1;\\n                else    high = mid-1;\\n            }\\n        }\\n        return -1;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 684828,
                "title": "python-binary-search-explained-the-logic",
                "content": "```\\nclass Solution:\\n    def search(self, nums: List[int], target: int) -> int:\\n        ## RC ##\\n        ## APPROACH : BINARY SEARCH ##\\n        #   1. have to find rotation point\\n        #   2. make mid = pivot element, start and end\\n        #   3. IMP : If Pivot element is larger than the first element in the array, i.e. the part of array from the first element to the pivot one is non-rotated.\\n        #   4. If the target is in that non-rotated part as well: go left: otherwise go right.\\n        #   5. Pivot element is smaller than the first element of the array, i.e. the rotation index is somewhere between 0 and mid. That means that the part of array from the pivot element to the last one is non-rotated.\\n        #   6. If target is in that non-rotated part as well: go right: else left.\\n        \\n        start, end = 0, len(nums)-1\\n        \\n        while(start <= end):\\n            mid = start + (end - start) // 2                        # watch out\\n            \\n            if(target == nums[mid]): return mid\\n            \\n            if(nums[mid] >= nums[start]):                           # indicates non-rotated array\\n                \\n                if(target < nums[mid] and target >= nums[start]):   # check for target in non-rotated part\\n                    end = mid -1\\n                else:\\n                    start = mid + 1\\n            else:                                                   # indicates otated array\\n                if(target <= nums[end] and target > nums[mid]):     # check for target in non-rotated part\\n                    start = mid + 1\\n                else:\\n                    end = mid - 1\\n        return -1\\n```",
                "solutionTags": [
                    "Python",
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def search(self, nums: List[int], target: int) -> int:\\n        ## RC ##\\n        ## APPROACH : BINARY SEARCH ##\\n        #   1. have to find rotation point\\n        #   2. make mid = pivot element, start and end\\n        #   3. IMP : If Pivot element is larger than the first element in the array, i.e. the part of array from the first element to the pivot one is non-rotated.\\n        #   4. If the target is in that non-rotated part as well: go left: otherwise go right.\\n        #   5. Pivot element is smaller than the first element of the array, i.e. the rotation index is somewhere between 0 and mid. That means that the part of array from the pivot element to the last one is non-rotated.\\n        #   6. If target is in that non-rotated part as well: go right: else left.\\n        \\n        start, end = 0, len(nums)-1\\n        \\n        while(start <= end):\\n            mid = start + (end - start) // 2                        # watch out\\n            \\n            if(target == nums[mid]): return mid\\n            \\n            if(nums[mid] >= nums[start]):                           # indicates non-rotated array\\n                \\n                if(target < nums[mid] and target >= nums[start]):   # check for target in non-rotated part\\n                    end = mid -1\\n                else:\\n                    start = mid + 1\\n            else:                                                   # indicates otated array\\n                if(target <= nums[end] and target > nums[mid]):     # check for target in non-rotated part\\n                    start = mid + 1\\n                else:\\n                    end = mid - 1\\n        return -1\\n```",
                "codeTag": "Java"
            },
            {
                "id": 557476,
                "title": "python3-modified-bs-explained-and-faster-than-64-77",
                "content": "*Runtime: 40 ms, faster than 64.77% of Python3 online submissions for Search in Rotated Sorted Array.\\nMemory Usage: 13.3 MB, less than 43.36% of Python3 online submissions for Search in Rotated Sorted Array.*\\n\\n```python\\nclass Solution:\\n    def search(self, nums: List[int], target: int) -> int:\\n        if not nums: return -1\\n        # almost standard bs\\n        l, r = 0, len(nums)-1\\n        while l<r:\\n            m = (l+r)//2\\n            if target == nums[m]: return m\\n            # is the left sorted?\\n            if nums[l] < nums[m]:\\n                if nums[l] <= target <= nums[m]: r = m\\n                else: l = m+1\\n            # then right is sorted...\\n            else: \\n                if nums[m+1] <= target <= nums[r]: l = m+1\\n                else: r = m\\n        return l if nums[l] == target else -1\\n```\\n\\nIs almost the standard **BS**, we just need to stop before applying the BS on an interval and ask if it is sorted (`nums[l] < nums[r]`), and if our target can actually be inside that sorted interval (`nums[l] <= target <= nums[r]`) if both are true we do the usual binary search here, and if not we do it in the other half.",
                "solutionTags": [
                    "Python",
                    "Python3",
                    "Binary Tree"
                ],
                "code": "```python\\nclass Solution:\\n    def search(self, nums: List[int], target: int) -> int:\\n        if not nums: return -1\\n        # almost standard bs\\n        l, r = 0, len(nums)-1\\n        while l<r:\\n            m = (l+r)//2\\n            if target == nums[m]: return m\\n            # is the left sorted?\\n            if nums[l] < nums[m]:\\n                if nums[l] <= target <= nums[m]: r = m\\n                else: l = m+1\\n            # then right is sorted...\\n            else: \\n                if nums[m+1] <= target <= nums[r]: l = m+1\\n                else: r = m\\n        return l if nums[l] == target else -1\\n```",
                "codeTag": "Java"
            },
            {
                "id": 164948,
                "title": "javascript-o-logn-100-explained-cracking-the-code-interview-binary-search",
                "content": "All but the right condition is exactly the same as in the Cracking The Code Interview Binary Search sample code.\\n\\nHow to know when the value is located on the right side:\\n\\n`<low> <mid> <high>`\\nDescending condition: `4 7 2`, target 0 (i.e. `[4,5,6,7,0,1,2]`)\\n- We are looking for values that are over 7 and less/eq than 2.\\n- `const descendingCondition = target >= nums[mid] || target <= nums[high];`\\n\\nAscending condition: `0 1 2`, target = 2 (i.e. `[0 1 2 3 4 5 6]`)\\n- We are looking for values that are within 1 and 2 (2 included).\\n- `const ascendingCondition = target >= nums[mid] && target <= nums[high];`\\n\\n```\\n/**\\n * @param {number[]} nums\\n * @param {number} target\\n * @return {number}\\n */\\nvar search = function(nums, target) {\\n    let low = 0;\\n    let high = nums.length - 1;\\n    while (low <= high) {\\n        const mid = Math.floor((high - low) / 2) + low;\\n        \\n        // <low> <mid> <high>\\n        // Descending condition: 4 7 2, target 0\\n        // - We are looking for values that are over 7 and less/eq than 2.\\n        // Ascending condition: 0 1 2, target = 2\\n        // - We are looking for values that are within 1 and 2 (2 included).\\n        const descendingCondition = target >= nums[mid] || target <= nums[high];\\n        const ascendingCondition = target >= nums[mid] && target <= nums[high];\\n        const isRight = nums[high] - nums[mid] >= 0 ? ascendingCondition : descendingCondition;\\n        \\n        if (nums[mid] === target) {\\n            return mid;\\n        } else if (isRight) {\\n            low = mid + 1;\\n        } else {\\n            high = mid - 1;\\n        }\\n    }\\n    \\n    return -1;\\n};\\n```",
                "solutionTags": [],
                "code": "```\\n/**\\n * @param {number[]} nums\\n * @param {number} target\\n * @return {number}\\n */\\nvar search = function(nums, target) {\\n    let low = 0;\\n    let high = nums.length - 1;\\n    while (low <= high) {\\n        const mid = Math.floor((high - low) / 2) + low;\\n        \\n        // <low> <mid> <high>\\n        // Descending condition: 4 7 2, target 0\\n        // - We are looking for values that are over 7 and less/eq than 2.\\n        // Ascending condition: 0 1 2, target = 2\\n        // - We are looking for values that are within 1 and 2 (2 included).\\n        const descendingCondition = target >= nums[mid] || target <= nums[high];\\n        const ascendingCondition = target >= nums[mid] && target <= nums[high];\\n        const isRight = nums[high] - nums[mid] >= 0 ? ascendingCondition : descendingCondition;\\n        \\n        if (nums[mid] === target) {\\n            return mid;\\n        } else if (isRight) {\\n            low = mid + 1;\\n        } else {\\n            high = mid - 1;\\n        }\\n    }\\n    \\n    return -1;\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3880197,
                "title": "c-very-easy-and-simple-approach",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nThe intuition behind this algorithm is to utilize the binary search approach, but with a twist to handle the rotation. We divide the array into two parts: one that is sorted and the other that isn\\'t. By comparing the target with the elements at the middle and adjusting the pointers based on whether the left or right side is sorted, we can efficiently narrow down the search range.\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n- Initialize two pointers, left and right, to the start and end indices of the array.\\n- Enter a binary search loop while left is less than or equal to right.\\n- Calculate the middle index, mid, using the formula (left + right) / 2.\\n- Check if the element at mid is the target. If so, return mid.\\n- Determine which side of the array is sorted: the left side (from left to mid) or the right side (from mid to right).\\n- Depending on which side is sorted, check if the target falls within the range of that side. If it does, adjust the pointers to narrow down the search range accordingly.\\n- If the target is not found in the current search range, update the pointers and repeat the process.\\n- If the loop ends and the target is not found, return -1.\\n\\n# Complexity\\n- Time complexity: **O(log n)** - The algorithm halves the search range in each step, resulting in a logarithmic number of steps.\\n\\n\\n- Space complexity: **O(1)** - The algorithm uses a constant amount of extra space for variables regardless of the input size.\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int search(vector<int>& nums, int target) {\\n        int left = 0;\\n        int right = nums.size() - 1;\\n        \\n        while (left <= right) {\\n            int mid = left + (right - left) / 2;\\n            \\n            if (nums[mid] == target) {\\n                return mid; // Found the target\\n            }\\n            \\n            // Check which side is sorted\\n            if (nums[left] <= nums[mid]) {\\n                // Left side is sorted\\n                if (nums[left] <= target && target < nums[mid]) {\\n                    // Target is in the left sorted side\\n                    right = mid - 1;\\n                } else {\\n                    // Target is in the right unsorted side\\n                    left = mid + 1;\\n                }\\n            } else {\\n                // Right side is sorted\\n                if (nums[mid] < target && target <= nums[right]) {\\n                    // Target is in the right sorted side\\n                    left = mid + 1;\\n                } else {\\n                    // Target is in the left unsorted side\\n                    right = mid - 1;\\n                }\\n            }\\n        }\\n        \\n        return -1; // Target not found\\n    }\\n};\\n\\n```\\n![upvote img.jpg](https://assets.leetcode.com/users/images/b55c25eb-7c93-4665-82c4-29df36f019d8_1691474602.022517.jpeg)\\n",
                "solutionTags": [
                    "C++",
                    "Array",
                    "Binary Search"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int search(vector<int>& nums, int target) {\\n        int left = 0;\\n        int right = nums.size() - 1;\\n        \\n        while (left <= right) {\\n            int mid = left + (right - left) / 2;\\n            \\n            if (nums[mid] == target) {\\n                return mid; // Found the target\\n            }\\n            \\n            // Check which side is sorted\\n            if (nums[left] <= nums[mid]) {\\n                // Left side is sorted\\n                if (nums[left] <= target && target < nums[mid]) {\\n                    // Target is in the left sorted side\\n                    right = mid - 1;\\n                } else {\\n                    // Target is in the right unsorted side\\n                    left = mid + 1;\\n                }\\n            } else {\\n                // Right side is sorted\\n                if (nums[mid] < target && target <= nums[right]) {\\n                    // Target is in the right sorted side\\n                    left = mid + 1;\\n                } else {\\n                    // Target is in the left unsorted side\\n                    right = mid - 1;\\n                }\\n            }\\n        }\\n        \\n        return -1; // Target not found\\n    }\\n};\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3879481,
                "title": "beats-100-video-solution-java-c-python",
                "content": "<iframe width=\"560\" height=\"315\" src=\"https://www.youtube.com/embed/rGJPl03mAPc\" title=\"YouTube video player\" frameborder=\"0\" allow=\"accelerometer; autoplay; clipboard-write; encrypted-media; gyroscope; picture-in-picture; web-share\" allowfullscreen></iframe>\\n\\n```\\nclass Solution {\\n    public int search(int[] A, int B) {\\n        int l = 0;\\n        int r = A.length-1;\\n        int m;\\n        while(l<=r){\\n            m = (l+r)/2;\\n            if(A[m] == B) return m;\\n            if(A[m]>=A[0]){\\n                if(B>=A[0] && B<=A[m]) r = m-1;\\n                else l = m+1;\\n            }else{\\n                if(B>=A[m] && B<=A[A.length-1]) l = m+1;\\n                else r = m-1;\\n            }\\n\\n        }\\n        return -1;\\n    }\\n}\\n```\\n\\n```\\nclass Solution {\\npublic:\\n    int search(vector<int>& A, int B) {\\n        int l = 0;\\n        int r = A.size() - 1;\\n        int m;\\n        while (l <= r) {\\n            m = (l + r) / 2;\\n            if (A[m] == B) return m;\\n            if (A[m] >= A[0]) {\\n                if (B >= A[0] && B <= A[m]) r = m - 1;\\n                else l = m + 1;\\n            } else {\\n                if (B >= A[m] && B <= A[A.size() - 1]) l = m + 1;\\n                else r = m - 1;\\n            }\\n        }\\n        return -1;\\n    }\\n};\\n```\\n\\n```\\nclass Solution:\\n    def search(self, A: List[int], B: int) -> int:\\n        l = 0\\n        r = len(A) - 1\\n        while l <= r:\\n            m = (l + r) // 2\\n            if A[m] == B:\\n                return m\\n            if A[m] >= A[0]:\\n                if B >= A[0] and B <= A[m]:\\n                    r = m - 1\\n                else:\\n                    l = m + 1\\n            else:\\n                if B >= A[m] and B <= A[-1]:\\n                    l = m + 1\\n                else:\\n                    r = m - 1\\n        return -1\\n\\n```",
                "solutionTags": [
                    "Java",
                    "Python",
                    "C"
                ],
                "code": "```\\nclass Solution {\\n    public int search(int[] A, int B) {\\n        int l = 0;\\n        int r = A.length-1;\\n        int m;\\n        while(l<=r){\\n            m = (l+r)/2;\\n            if(A[m] == B) return m;\\n            if(A[m]>=A[0]){\\n                if(B>=A[0] && B<=A[m]) r = m-1;\\n                else l = m+1;\\n            }else{\\n                if(B>=A[m] && B<=A[A.length-1]) l = m+1;\\n                else r = m-1;\\n            }\\n\\n        }\\n        return -1;\\n    }\\n}\\n```\n```\\nclass Solution {\\npublic:\\n    int search(vector<int>& A, int B) {\\n        int l = 0;\\n        int r = A.size() - 1;\\n        int m;\\n        while (l <= r) {\\n            m = (l + r) / 2;\\n            if (A[m] == B) return m;\\n            if (A[m] >= A[0]) {\\n                if (B >= A[0] && B <= A[m]) r = m - 1;\\n                else l = m + 1;\\n            } else {\\n                if (B >= A[m] && B <= A[A.size() - 1]) l = m + 1;\\n                else r = m - 1;\\n            }\\n        }\\n        return -1;\\n    }\\n};\\n```\n```\\nclass Solution:\\n    def search(self, A: List[int], B: int) -> int:\\n        l = 0\\n        r = len(A) - 1\\n        while l <= r:\\n            m = (l + r) // 2\\n            if A[m] == B:\\n                return m\\n            if A[m] >= A[0]:\\n                if B >= A[0] and B <= A[m]:\\n                    r = m - 1\\n                else:\\n                    l = m + 1\\n            else:\\n                if B >= A[m] and B <= A[-1]:\\n                    l = m + 1\\n                else:\\n                    r = m - 1\\n        return -1\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3879257,
                "title": "c-python-binary-search-beats-100",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nThis problem is solved by using binary search several times.\\nFirstly, it is suggested to find the location for the peak which can be done by binary search.\\nSecondly, using binary search to find location for the target which is possible before the peak or after the peak.\\n\\nBe careful for the boundary cases when n=1 and n=2.\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\nTo find the location for the peak, it needs to build a binary searching function for this special purpose. Once the location of the peak is sure, then use the built-in  C++ lower_bound to find the target.\\n\\nThe python solution uses bisect_left.\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n $$O(\\\\log n)$$\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n $$O(1)$$\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int n;\\n    vector<int> x;\\n    int findK() {\\n        if (n==1) return 0;\\n        if (n==2) return (x[0]<x[1])?1:0;\\n        int l=0, r=n, m;\\n        while(l<r){\\n            m=(r+l)/2;\\n            if (m==n-1 || x[m]>x[m+1]) return m;\\n            if (x[m]>x[l]) l=m;\\n            else r=m;    \\n        }\\n        return m;\\n    }\\n    int search(vector<int>& nums, int target) {\\n        x=nums;\\n        n=nums.size();\\n        int k=findK();\\n    //    cout<<\"k=\"<<k<<endl;\\n        auto it=x.begin();\\n        if (target>=x[0] || k==n-1){\\n            int i=lower_bound(it,it+k+1,target)-it;\\n            if (i == k+1 || x[i] != target) return -1;\\n            return i;\\n        }     \\n        else{\\n            int i=lower_bound(it+k+1,it+n,target)-it;\\n            if (i == n || x[i] != target) return -1;\\n            return i;\\n        }\\n    }\\n};\\n```\\n# Python solution\\n```\\nclass Solution:\\n    def search(self, x: List[int], target: int) -> int:\\n        n = len(x)\\n        \\n        def findK():\\n            if n == 1:\\n                return 0\\n            if n==2:\\n                if x[0]<x[1]: return 1\\n                else: return 0\\n            l=0\\n            r=n\\n            while l < r:\\n                m = (r + l) // 2\\n                if m==n-1 or x[m]>x[m+1]: return m\\n                if x[m]>x[l]: l=m\\n                else: r=m\\n            return m\\n        \\n        k=findK()\\n        \\n        if target >= x[0]:\\n            i = bisect_left(x, target, hi=k)\\n            if i<n and x[i] == target:\\n                return i\\n            return -1\\n        else:\\n            i = bisect_left(x, target, lo=k+1)\\n            if i<n and x[i] == target:\\n                return i\\n            return -1\\n```\\n# findK() uses bisect_right()\\n```\\ndef findK():\\n  if n == 1:\\n    return 0\\n  return bisect_right(x, False, key=lambda y: y < x[0])\\n```",
                "solutionTags": [
                    "C++",
                    "Python3",
                    "Binary Search"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int n;\\n    vector<int> x;\\n    int findK() {\\n        if (n==1) return 0;\\n        if (n==2) return (x[0]<x[1])?1:0;\\n        int l=0, r=n, m;\\n        while(l<r){\\n            m=(r+l)/2;\\n            if (m==n-1 || x[m]>x[m+1]) return m;\\n            if (x[m]>x[l]) l=m;\\n            else r=m;    \\n        }\\n        return m;\\n    }\\n    int search(vector<int>& nums, int target) {\\n        x=nums;\\n        n=nums.size();\\n        int k=findK();\\n    //    cout<<\"k=\"<<k<<endl;\\n        auto it=x.begin();\\n        if (target>=x[0] || k==n-1){\\n            int i=lower_bound(it,it+k+1,target)-it;\\n            if (i == k+1 || x[i] != target) return -1;\\n            return i;\\n        }     \\n        else{\\n            int i=lower_bound(it+k+1,it+n,target)-it;\\n            if (i == n || x[i] != target) return -1;\\n            return i;\\n        }\\n    }\\n};\\n```\n```\\nclass Solution:\\n    def search(self, x: List[int], target: int) -> int:\\n        n = len(x)\\n        \\n        def findK():\\n            if n == 1:\\n                return 0\\n            if n==2:\\n                if x[0]<x[1]: return 1\\n                else: return 0\\n            l=0\\n            r=n\\n            while l < r:\\n                m = (r + l) // 2\\n                if m==n-1 or x[m]>x[m+1]: return m\\n                if x[m]>x[l]: l=m\\n                else: r=m\\n            return m\\n        \\n        k=findK()\\n        \\n        if target >= x[0]:\\n            i = bisect_left(x, target, hi=k)\\n            if i<n and x[i] == target:\\n                return i\\n            return -1\\n        else:\\n            i = bisect_left(x, target, lo=k+1)\\n            if i<n and x[i] == target:\\n                return i\\n            return -1\\n```\n```\\ndef findK():\\n  if n == 1:\\n    return 0\\n  return bisect_right(x, False, key=lambda y: y < x[0])\\n```",
                "codeTag": "C++"
            },
            {
                "id": 2999171,
                "title": "c-intuitive-o-logn-solution-with-explanation",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nWe can easily see intitutively, if we are somehow able to find the peak or the index from where the rotation is happening, then we can easily apply Binary Search in the given rotated array.\\nBut how to find the peak in `O(logn)` time? else the complexity of problem may not be `O(logn)`.\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n1. **To Find Peak Element in rotated array**\\n\\t\\tWe can return the mid, if we found the peak in the mid i.e `nums[mid-1]<nums[mid]>nums[mid+1]` else       we\\'ll check if the peak can be found in right subarray or left subarray.\\n\\t\\tIf the left subarray is unsorted that means peak is in the left subarray i.e if `nums[low]>nums[mid]`\\n\\t\\telse the peak is in the right subarray.\\n2. **To find the target after peak (k)**\\n\\t  Once the peak is found i.e `k` then we can easily search for elements with updated mid index as \\n\\t\\t`(mid+k+1)%n` , where k is the peak or point from where array is rotated.\\n\\n# Complexity\\n- Time complexity: $$O(logn)$$, where `peak` function also takes $$O(logn)$$ time.\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: $$O(1)$$\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int peak(vector<int>& nums){\\n        int n= nums.size();\\n        int low=0;\\n        int high = n-1;\\n        while(low<=high){\\n            int mid=(low+high)>>1;\\n            if((mid==0||nums[mid]>nums[mid-1])&&(mid==n-1||nums[mid]>nums[mid+1]))\\n            return mid;\\n            else\\n            if(nums[low]>nums[mid])\\n            high=mid-1;\\n            else\\n            low=mid+1;\\n        }\\n        return -1;\\n    }\\n    int search(vector<int>& nums, int target) {\\n        int n= nums.size();\\n        int low=0;\\n        int high = n-1;\\n        int k = peak(nums);\\n        while(low<=high){\\n            int mid = (low+high)>>1;\\n            int z=(mid+k+1)%n;\\n            if(nums[z]==target)\\n            return z;\\n            else\\n            if(nums[z]>target)\\n            high=mid-1;\\n            else\\n            low=mid+1;\\n        }\\n        return -1;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Java",
                    "Python",
                    "Two Pointers",
                    "Binary Search"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int peak(vector<int>& nums){\\n        int n= nums.size();\\n        int low=0;\\n        int high = n-1;\\n        while(low<=high){\\n            int mid=(low+high)>>1;\\n            if((mid==0||nums[mid]>nums[mid-1])&&(mid==n-1||nums[mid]>nums[mid+1]))\\n            return mid;\\n            else\\n            if(nums[low]>nums[mid])\\n            high=mid-1;\\n            else\\n            low=mid+1;\\n        }\\n        return -1;\\n    }\\n    int search(vector<int>& nums, int target) {\\n        int n= nums.size();\\n        int low=0;\\n        int high = n-1;\\n        int k = peak(nums);\\n        while(low<=high){\\n            int mid = (low+high)>>1;\\n            int z=(mid+k+1)%n;\\n            if(nums[z]==target)\\n            return z;\\n            else\\n            if(nums[z]>target)\\n            high=mid-1;\\n            else\\n            low=mid+1;\\n        }\\n        return -1;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2759124,
                "title": "most-efficient-solution-binary-search-modified-for-rotated-sorted-list",
                "content": "Order - O(log n)\\n```\\nclass Solution:\\n    def search(self, nums: List[int], target: int) -> int:\\n        return searchlist(nums,target)\\n      \\ndef searchlist(nums,target):\\n  low,high = 0,len(nums)-1\\n  while low<=high:\\n    mid = (low+high)//2\\n    if nums[mid]==target:\\n      return mid\\n    #check if mid in left sorted arr\\n    if nums[mid]>=nums[low]:\\n      if target>=nums[low] and target<nums[mid]:\\n        high = mid - 1\\n      else:\\n        low = mid + 1\\n        \\n    #check if mid in right sorted arr    \\n    else:\\n      if target<=nums[high] and target>nums[mid]:\\n        low = mid+1\\n      else:\\n        high = mid-1\\n        \\n  return -1 \\n  ```\\n  \\n  Hope this helps!!",
                "solutionTags": [
                    "Python",
                    "Python3",
                    "Binary Search",
                    "Binary Tree"
                ],
                "code": "```\\nclass Solution:\\n    def search(self, nums: List[int], target: int) -> int:\\n        return searchlist(nums,target)\\n      \\ndef searchlist(nums,target):\\n  low,high = 0,len(nums)-1\\n  while low<=high:\\n    mid = (low+high)//2\\n    if nums[mid]==target:\\n      return mid\\n    #check if mid in left sorted arr\\n    if nums[mid]>=nums[low]:\\n      if target>=nums[low] and target<nums[mid]:\\n        high = mid - 1\\n      else:\\n        low = mid + 1\\n        \\n    #check if mid in right sorted arr    \\n    else:\\n      if target<=nums[high] and target>nums[mid]:\\n        low = mid+1\\n      else:\\n        high = mid-1\\n        \\n  return -1 \\n  ```",
                "codeTag": "Java"
            },
            {
                "id": 2625839,
                "title": "python-o-log-n-solution-super-easy",
                "content": "\\t\\tstart, end = 0, len(nums) - 1\\n        \\n        while start <= end:\\n            mid = start + (end-start) // 2\\n            \\n            if nums[mid] == target:\\n                return mid\\n            \\n            elif nums[mid] >= nums[start]:\\n                if target <= nums[mid] and target >=nums[start]:\\n                    end = mid - 1\\n                else:\\n                    start = mid + 1\\n            else:\\n                if target >= nums[mid] and target <= nums[end]:\\n                    start = mid + 1\\n                else:\\n                    end = mid - 1\\n        return -1",
                "solutionTags": [
                    "Python",
                    "Array",
                    "Binary Search",
                    "Sorting"
                ],
                "code": "\\t\\tstart, end = 0, len(nums) - 1\\n        \\n        while start <= end:\\n            mid = start + (end-start) // 2\\n            \\n            if nums[mid] == target:\\n                return mid\\n            \\n            elif nums[mid] >= nums[start]:\\n                if target <= nums[mid] and target >=nums[start]:\\n                    end = mid - 1\\n                else:\\n                    start = mid + 1\\n            else:\\n                if target >= nums[mid] and target <= nums[end]:\\n                    start = mid + 1\\n                else:\\n                    end = mid - 1\\n        return -1",
                "codeTag": "Unknown"
            },
            {
                "id": 2450337,
                "title": "java-simple-solution",
                "content": "https://www.youtube.com/watch?v=e-84rG-c8AE",
                "solutionTags": [],
                "code": "https://www.youtube.com/watch?v=e-84rG-c8AE",
                "codeTag": "Unknown"
            },
            {
                "id": 2228217,
                "title": "c-100-faster-o-log-n-binary-search-modification",
                "content": "\\n```\\nclass Solution {\\npublic:\\n    int search(vector<int>& nums, int target) \\n    {\\n        int n=nums.size();\\n        int l=0,r=n-1;\\n        while(r>=l)\\n        {\\n            int mid=l+(r-l)/2;\\n            if(nums[mid]==target)\\n                return mid;\\n            if(nums[l]<=nums[mid])\\n            {\\n                if(target>=nums[l] && target<=nums[mid])\\n                    r=mid-1;\\n                else\\n                   l=mid+1;          \\n            }\\n            else\\n            {\\n                if(target>=nums[mid] && target<=nums[r])\\n                    l=mid+1; \\n                else\\n                    r=mid-1;\\n            }     \\n        }\\n        return -1;\\n    }\\n};\\n```\\n\\nTime Complexity: O(log n)\\n",
                "solutionTags": [
                    "C",
                    "Binary Tree"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int search(vector<int>& nums, int target) \\n    {\\n        int n=nums.size();\\n        int l=0,r=n-1;\\n        while(r>=l)\\n        {\\n            int mid=l+(r-l)/2;\\n            if(nums[mid]==target)\\n                return mid;\\n            if(nums[l]<=nums[mid])\\n            {\\n                if(target>=nums[l] && target<=nums[mid])\\n                    r=mid-1;\\n                else\\n                   l=mid+1;          \\n            }\\n            else\\n            {\\n                if(target>=nums[mid] && target<=nums[r])\\n                    l=mid+1; \\n                else\\n                    r=mid-1;\\n            }     \\n        }\\n        return -1;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2194609,
                "title": "python-soln-beats-93-in-time",
                "content": "```\\nclass Solution:\\n    def search(self, nums: List[int], target: int) -> int:\\n        start, end = 0, len(nums)-1\\n        while(start<=end):\\n            mid=int((start + end)/2)\\n            if nums[mid]==target: return mid\\n            elif nums[start]<=nums[mid]:\\n                if target>=nums[start] and target<nums[mid]: end=mid-1\\n                else: start=mid+1\\n            else:\\n                if target<=nums[end] and target>nums[mid]: start=mid+1\\n                else: end=mid-1\\n        return -1\\n```\\n***Pls upvote if you find it helpful***",
                "solutionTags": [
                    "Python",
                    "Binary Tree"
                ],
                "code": "```\\nclass Solution:\\n    def search(self, nums: List[int], target: int) -> int:\\n        start, end = 0, len(nums)-1\\n        while(start<=end):\\n            mid=int((start + end)/2)\\n            if nums[mid]==target: return mid\\n            elif nums[start]<=nums[mid]:\\n                if target>=nums[start] and target<nums[mid]: end=mid-1\\n                else: start=mid+1\\n            else:\\n                if target<=nums[end] and target>nums[mid]: start=mid+1\\n                else: end=mid-1\\n        return -1\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1924327,
                "title": "python-most-efficient-binary-search-simple-comments-o-log-n",
                "content": "```\\n\\'\\'\\'\\nApproach: Binary Search\\n\\nPoint to note: In a rotated sorted array, when doing binary search, one side will always be sorted and other side will always be incorrectly sorted if \\npivot index k (1 <= k < nums.length)\\n\\n\\n1. find mid. \\n2. if left side is sorted\\n    - if target is within left limits, binary search on left\\n    - else binary search on right\\n3 else (if left side is not sorted, right side is sorted)\\n    - if target is within right limits, binary search on right\\n    - else binary search on left\\n\\n\\n\\'\\'\\'\\n\\nclass Solution:\\n    def search(self, nums: List[int], target: int) -> int:\\n        left,right = 0,len(nums)-1\\n        while left<=right:\\n            mid = (left+right)//2\\n            if nums[mid]==target:\\n                return mid\\n            elif nums[left]>nums[mid]:\\n                if nums[mid]<target<=nums[right]:\\n                    left = mid+1\\n                else:\\n                    right = mid-1\\n            else:\\n                if nums[left]<=target<nums[mid]:\\n                    right = mid-1\\n                else:\\n                    left = mid+1\\n                    \\n        return -1\\n            \\n        \\n```",
                "solutionTags": [
                    "Python",
                    "Python3",
                    "Binary Search"
                ],
                "code": "```\\n\\'\\'\\'\\nApproach: Binary Search\\n\\nPoint to note: In a rotated sorted array, when doing binary search, one side will always be sorted and other side will always be incorrectly sorted if \\npivot index k (1 <= k < nums.length)\\n\\n\\n1. find mid. \\n2. if left side is sorted\\n    - if target is within left limits, binary search on left\\n    - else binary search on right\\n3 else (if left side is not sorted, right side is sorted)\\n    - if target is within right limits, binary search on right\\n    - else binary search on left\\n\\n\\n\\'\\'\\'\\n\\nclass Solution:\\n    def search(self, nums: List[int], target: int) -> int:\\n        left,right = 0,len(nums)-1\\n        while left<=right:\\n            mid = (left+right)//2\\n            if nums[mid]==target:\\n                return mid\\n            elif nums[left]>nums[mid]:\\n                if nums[mid]<target<=nums[right]:\\n                    left = mid+1\\n                else:\\n                    right = mid-1\\n            else:\\n                if nums[left]<=target<nums[mid]:\\n                    right = mid-1\\n                else:\\n                    left = mid+1\\n                    \\n        return -1\\n            \\n        \\n```",
                "codeTag": "Java"
            },
            {
                "id": 1698723,
                "title": "python3-runtime-28-ms-faster-than-99-69-memory-14-mb-less-than-99-97",
                "content": "```\\nclass Solution:\\n    def search(self, nums, target):\\n        if not nums:\\n        \\treturn -1\\n        left, right = 0, len(nums) - 1\\n        while left <= right:\\n        \\tmid = int((left + right) / 2)\\n        \\tif nums[mid] == target:\\n        \\t\\treturn mid\\n        \\tif nums[left] <= nums[mid]:\\n        \\t\\tif target >= nums[left] and target <= nums[mid]:\\n        \\t\\t\\tright = mid - 1\\n        \\t\\telse:\\n        \\t\\t\\tleft = mid + 1\\n        \\telse:\\n        \\t\\tif target >= nums[mid] and target <= nums[right]:\\n        \\t\\t\\tleft = mid + 1\\n        \\t\\telse:\\n        \\t\\t\\tright = mid - 1\\n        return -1\\n```",
                "solutionTags": [
                    "Python",
                    "Binary Tree"
                ],
                "code": "```\\nclass Solution:\\n    def search(self, nums, target):\\n        if not nums:\\n        \\treturn -1\\n        left, right = 0, len(nums) - 1\\n        while left <= right:\\n        \\tmid = int((left + right) / 2)\\n        \\tif nums[mid] == target:\\n        \\t\\treturn mid\\n        \\tif nums[left] <= nums[mid]:\\n        \\t\\tif target >= nums[left] and target <= nums[mid]:\\n        \\t\\t\\tright = mid - 1\\n        \\t\\telse:\\n        \\t\\t\\tleft = mid + 1\\n        \\telse:\\n        \\t\\tif target >= nums[mid] and target <= nums[right]:\\n        \\t\\t\\tleft = mid + 1\\n        \\t\\telse:\\n        \\t\\t\\tright = mid - 1\\n        return -1\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1427928,
                "title": "explained-solution-with-diagrams-language-friendly",
                "content": "The rotated array can be thought as a composition of two arrays as the picture below shows. We first selected the middle element  and we have to figure in which part of the array we are in. If the nums[mid]>=nums[start], then we are in the red part. If not, we are in the blue part. \\n\\n![image](https://assets.leetcode.com/users/images/999f2060-2765-4281-88a5-9fe39777e929_1630004936.2318954.png)\\n\\nIf we are in the red zone we know that the elements in the range [start, mid] are bounded below by nums[start] and are bounded above by nums[mid]. If target is in this range, then it must be located between start and mid so we update the end pointer to point to mid-1. If it is not within this range, then we can disregard every element in the range [start, mid] and we can update the start pointer to point to mid+1. A similar argument works if we happen to be in the blue zone. \\n\\nA python implementation is shown below:\\n\\n```\\nclass Solution:\\n    def search(self, nums: List[int], target: int) -> int:\\n        start, end = 0, len(nums)-1\\n        \\n        while start <= end:\\n            ind = start + (end-start)//2\\n            if nums[ind] == target:\\n                return ind\\n            \\n            if nums[ind] >= nums[start]:\\n                if nums[start] <= target < nums[ind]:\\n                    end = ind - 1\\n                else:\\n                    start = ind + 1\\n            \\n            else:\\n                if nums[ind] < target <= nums[end]:\\n                    start = ind + 1\\n                else:\\n                    end = ind - 1\\n            \\n            \\n        return -1\\n```\\n\\nPlease consider liking if you found this post helpful :)",
                "solutionTags": [
                    "Python",
                    "Binary Search",
                    "Binary Tree"
                ],
                "code": "```\\nclass Solution:\\n    def search(self, nums: List[int], target: int) -> int:\\n        start, end = 0, len(nums)-1\\n        \\n        while start <= end:\\n            ind = start + (end-start)//2\\n            if nums[ind] == target:\\n                return ind\\n            \\n            if nums[ind] >= nums[start]:\\n                if nums[start] <= target < nums[ind]:\\n                    end = ind - 1\\n                else:\\n                    start = ind + 1\\n            \\n            else:\\n                if nums[ind] < target <= nums[end]:\\n                    start = ind + 1\\n                else:\\n                    end = ind - 1\\n            \\n            \\n        return -1\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1213154,
                "title": "c-binary-search-approach-o-log-n-100-faster",
                "content": "```\\nclass Solution {\\npublic:\\n    int search(vector<int>& a, int target) {\\n        int l=0,h=a.size()-1,m;\\n        while(l<=h){\\n            m=l+(h-l)/2;\\n            if(a[m]==target) return m;\\n            else if(a[m]>=a[l]){\\n                if(target>=a[l] && target<=a[m]) h=m-1;\\n                else l=m+1;\\n            }\\n            else{\\n                if(target>=a[m] && target<=a[h]) l=m+1;\\n                else h=m-1;\\n            }\\n        }\\n        return -1;\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    int search(vector<int>& a, int target) {\\n        int l=0,h=a.size()-1,m;\\n        while(l<=h){\\n            m=l+(h-l)/2;\\n            if(a[m]==target) return m;\\n            else if(a[m]>=a[l]){\\n                if(target>=a[l] && target<=a[m]) h=m-1;\\n                else l=m+1;\\n            }\\n            else{\\n                if(target>=a[m] && target<=a[h]) l=m+1;\\n                else h=m-1;\\n            }\\n        }\\n        return -1;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 926473,
                "title": "go-binary-search",
                "content": "<b>By Tag</b>\\n#BinarySearch - [github](https://github.com/idiotleon/lc-problem-by-tag-leon/tree/main/txt/by_algorithm/search/binary_search)\\n\\n```\\nfunc search(nums []int, target int) int {    \\n    var lo, hi int = 0, len(nums) - 1\\n    \\n    for lo <= hi {\\n        var mid = lo + (hi - lo) / 2\\n        \\n        if nums[mid] == target {\\n            return mid\\n        }\\n        \\n        if nums[lo] <= nums[mid]{\\n            if target >= nums[lo] && target <= nums[mid] {\\n                hi = mid - 1\\n            } else {\\n                lo = mid + 1\\n            }\\n        }else if nums[mid] < nums[hi]{\\n            if target > nums[mid] && target <= nums[hi] {\\n                lo = mid + 1\\n            }else {\\n                hi = mid - 1\\n            }\\n        }\\n    }\\n    \\n    return -1\\n}\\n```",
                "solutionTags": [
                    "Go",
                    "Binary Tree"
                ],
                "code": "```\\nfunc search(nums []int, target int) int {    \\n    var lo, hi int = 0, len(nums) - 1\\n    \\n    for lo <= hi {\\n        var mid = lo + (hi - lo) / 2\\n        \\n        if nums[mid] == target {\\n            return mid\\n        }\\n        \\n        if nums[lo] <= nums[mid]{\\n            if target >= nums[lo] && target <= nums[mid] {\\n                hi = mid - 1\\n            } else {\\n                lo = mid + 1\\n            }\\n        }else if nums[mid] < nums[hi]{\\n            if target > nums[mid] && target <= nums[hi] {\\n                lo = mid + 1\\n            }else {\\n                hi = mid - 1\\n            }\\n        }\\n    }\\n    \\n    return -1\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 689417,
                "title": "easy-python-binary-search-solution-with-additional-conditions",
                "content": "\\n    def search(self, nums: List[int], target: int) -> int:\\n        start = 0\\n        end = len(nums) - 1\\n        while(start<=end):\\n            mid = (start+end)//2\\n            if(nums[mid] == target):\\n                return mid\\n            elif(target < nums[mid]):\\n                if(target < nums[start] and nums[start] <= nums[mid]):\\n                    start = mid + 1\\n                else:\\n                    end = mid - 1\\n            elif(target > nums[mid]):\\n                if(target > nums[end] and nums[end] > nums[mid]):\\n                    end = mid - 1\\n                else:\\n                    start = mid + 1\\n        return -1",
                "solutionTags": [
                    "Python",
                    "Binary Search"
                ],
                "code": "\\n    def search(self, nums: List[int], target: int) -> int:\\n        start = 0\\n        end = len(nums) - 1\\n        while(start<=end):\\n            mid = (start+end)//2\\n            if(nums[mid] == target):\\n                return mid\\n            elif(target < nums[mid]):\\n                if(target < nums[start] and nums[start] <= nums[mid]):\\n                    start = mid + 1\\n                else:\\n                    end = mid - 1\\n            elif(target > nums[mid]):\\n                if(target > nums[end] and nums[end] > nums[mid]):\\n                    end = mid - 1\\n                else:\\n                    start = mid + 1\\n        return -1",
                "codeTag": "Python3"
            },
            {
                "id": 374841,
                "title": "beat-100-100-java-binary-search",
                "content": "\\n    public int search(int[] nums, int target) {     \\n        int left = 0, right = nums.length-1;\\n        \\n        while (left <= right) {\\n            int mid = (left + right) >> 1;\\n            if (target == nums[mid]) return mid;\\n            \\n            if (nums[left] <= nums[mid]) {\\n                if (nums[left] <= target && target < nums[mid]) right = mid-1;\\n                else left = mid+1;\\n            } else {\\n                if (nums[mid] < target && target <= nums[right]) left = mid+1;\\n                else right = mid-1;\\n            }\\n        }\\n        return -1;\\n    }\\n",
                "solutionTags": [],
                "code": "\\n    public int search(int[] nums, int target) {     \\n        int left = 0, right = nums.length-1;\\n        \\n        while (left <= right) {\\n            int mid = (left + right) >> 1;\\n            if (target == nums[mid]) return mid;\\n            \\n            if (nums[left] <= nums[mid]) {\\n                if (nums[left] <= target && target < nums[mid]) right = mid-1;\\n                else left = mid+1;\\n            } else {\\n                if (nums[mid] < target && target <= nums[right]) left = mid+1;\\n                else right = mid-1;\\n            }\\n        }\\n        return -1;\\n    }\\n",
                "codeTag": "Unknown"
            },
            {
                "id": 14625,
                "title": "recursive-solution-for-java",
                "content": "```\\npublic int search(int[] nums, int target) {\\n\\treturn binarySearch(0, nums.length - 1, nums, target);\\n}\\n\\npublic int binarySearch(int low, int high, int[] nums, int target){\\n\\tint mid = (low + high)/2;\\n\\tif(nums[mid] == target)\\n\\t\\treturn mid;\\n\\tif(low > high)\\n\\t\\treturn -1;\\n\\n\\tif(nums[mid] >= nums[low]){//array between nums[low] and nums[mid] are sorted\\n\\t\\tif( nums[low] <= target && target < nums[mid])//target is between nums[low] and nums[mid]\\n\\t\\t\\treturn binarySearch(low, mid - 1, nums, target);\\n\\t\\telse\\n\\t\\t\\treturn binarySearch(mid + 1, high, nums, target);\\n\\t} else{//unsorted part of array\\n\\t\\tif(nums[mid] < target && target <= nums[high])\\n\\t\\t\\treturn binarySearch(mid + 1, high, nums, target);\\n\\t\\telse\\n\\t\\t\\treturn binarySearch(low, mid - 1, nums, target);\\n\\t}\\n}\\n```",
                "solutionTags": [],
                "code": "```\\npublic int search(int[] nums, int target) {\\n\\treturn binarySearch(0, nums.length - 1, nums, target);\\n}\\n\\npublic int binarySearch(int low, int high, int[] nums, int target){\\n\\tint mid = (low + high)/2;\\n\\tif(nums[mid] == target)\\n\\t\\treturn mid;\\n\\tif(low > high)\\n\\t\\treturn -1;\\n\\n\\tif(nums[mid] >= nums[low]){//array between nums[low] and nums[mid] are sorted\\n\\t\\tif( nums[low] <= target && target < nums[mid])//target is between nums[low] and nums[mid]\\n\\t\\t\\treturn binarySearch(low, mid - 1, nums, target);\\n\\t\\telse\\n\\t\\t\\treturn binarySearch(mid + 1, high, nums, target);\\n\\t} else{//unsorted part of array\\n\\t\\tif(nums[mid] < target && target <= nums[high])\\n\\t\\t\\treturn binarySearch(mid + 1, high, nums, target);\\n\\t\\telse\\n\\t\\t\\treturn binarySearch(low, mid - 1, nums, target);\\n\\t}\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 14649,
                "title": "c-binary-search-8ms-always-check-the-half-portion-that-is-in-order",
                "content": " The idea is to do binary search. Since due to the shift, the two halfs may not be both in order but at least one of them is in order, so always check the in-order half and see if the target is in the range of that half.\\nOne mistake I made is I used \\n\\n                        if(nums[left]<nums[mid])\\n  instead of\\n \\n\\n               if(nums[left]<=nums[mid])\\n\\nThat causes an error in the case [3,1] since when the length is 2, mid is equal to left\\n\\n    class Solution {\\n    public:\\n        int search(vector<int>& nums, int target) {\\n            int res, left =0, right= nums.size()-1, mid;\\n            while(left<=right)\\n            {\\n                mid= (left+right)/2;\\n                if(nums[mid] == target) return mid;\\n                if(nums[left]<=nums[mid])\\n                {// if the first half is in-order, <= since mid may be equal to left when there are only two elements\\n                    if(target>=nums[left] && target < nums[mid] ) right = mid -1;  // if target is in the range of the first half\\n                    else left = mid + 1;\\n                }\\n                else\\n                {// if the second half is in order\\n                    if(target > nums[mid] && target <= nums[right] ) left = mid + 1; // target is in the range of the second half\\n                    else right = mid - 1;\\n                }\\n            }\\n            return -1;\\n        }\\n    };\\n\\n\\nI revised the above version to make it more neat\\n\\n    class Solution {\\n    public:\\n        int search(vector<int>& nums, int target) {\\n            int left=0, right=nums.size()-1, mid;\\n            while(left<=right)\\n            {\\n                mid = (left+right)/2;\\n                if(target==nums[mid]) return mid;\\n                if( (nums[left]<= target && target < nums[mid]) || (nums[mid]< nums[right] && (nums[mid]>target || nums[right]<target)) )  right = mid-1; // if it the first half is in order and target is in that range or the second half is in order and target is not in the second half\\n                else left = mid+1;\\n            }\\n            return -1;\\n        }\\n    };",
                "solutionTags": [],
                "code": "class Solution {\\n    public:\\n        int search(vector<int>& nums, int target) {\\n            int res, left =0, right= nums.size()-1, mid;\\n            while(left<=right)\\n            {\\n                mid= (left+right)/2;\\n                if(nums[mid] == target) return mid;\\n                if(nums[left]<=nums[mid])\\n                {// if the first half is in-order, <= since mid may be equal to left when there are only two elements\\n                    if(target>=nums[left] && target < nums[mid] ) right = mid -1;  // if target is in the range of the first half\\n                    else left = mid + 1;\\n                }",
                "codeTag": "Java"
            },
            {
                "id": 14670,
                "title": "solution-o-logn-binary-search-solution-with-explanation-java",
                "content": "    public class Solution {\\n        public int searchHelper(int[] A, int target, int start, int end){\\n            if(start>end){\\n                return -1;\\n            }\\n            int mid = (start+end)/2;\\n            if(A[mid] == target){\\n                return mid;\\n            }\\n            \\n            //Case 1: Left half is sorted\\n            if(A[mid] >= A[start]){\\n                if(target >= A[start] && target <= A[mid]){\\n                    return searchHelper(A,target,start,mid-1);    \\n                }\\n                else{\\n                    return searchHelper(A,target,mid+1,end);\\n                }\\n            }\\n            //Case 2: Right half is sorted\\n            if(A[end]>=A[mid]){\\n                if(target>=A[mid] && target<=A[end]){\\n                    return searchHelper(A,target,mid+1,end);\\n                }\\n                else{\\n                    return searchHelper(A,target,start,mid-1);\\n                }\\n            }\\n            return -1;\\n        }\\n        \\n        public int search(int[] A, int target) {\\n            return searchHelper(A,target,0,A.length-1);\\n        }\\n    }\\n\\nGiven the assumption of unique elements, there are 2 possibilities:\\n1. Left half is sorted i.e. pivot is in right half\\n2. Right half is sorted i.e. pivot is in left half\\n\\nIf target value is within the range of sorted half, binary search continues there. \\n\\nOtherwise, binary search continues in the half with the pivot.",
                "solutionTags": [
                    "Java",
                    "Binary Tree"
                ],
                "code": "class Solution {\\n        public int searchHelper(int[] A, int target, int start, int end){\\n            if(start>end){\\n                return -1;\\n            }",
                "codeTag": "Java"
            },
            {
                "id": 3879413,
                "title": "rust-go-python-binary-search",
                "content": "# Intuition\\n\\nWhen faced with the challenge of searching for an element in a rotated sorted array, our instinct might initially direct us towards a linear search. However, since the array is initially sorted before rotation, we realize that at any given point, at least one half of the array must still be in sorted order. This observation is the key. We can utilize a binary search approach but with a few modifications to account for the rotation. Both Go and Rust, as systems programming languages, are particularly adept at handling such low-level manipulations efficiently.\\n\\n# Approach\\n\\n1. **Initialization**: We start with two pointers, `low` and `high`, indicating the start and the end of the array.\\n2. **Calculate Midpoint**: In every iteration of our loop, we find the midpoint of our current segment.\\n3. **Check for Target**: If the number at the midpoint is our target, we\\'ve found our number.\\n4. **Identify the Sorted Half**: We then determine which half of our current segment is sorted.\\n   - If the left half is sorted, we check if our target lies in this half by comparing it against the lowest and midpoint values. If it does, we adjust our `high` pointer to search in this segment. If not, it must be in the right half, so we adjust our `low` pointer accordingly.\\n   - Similarly, if the right half is sorted and the target lies within this half, we adjust our `low` pointer, else we adjust our `high` pointer.\\n5. **Repeat**: We then repeat the process in the identified half until we find our target or exhaust our search space.\\n\\n# Complexity\\n\\n- **Time complexity**: \\\\(O(\\\\log n)\\\\). The essence of this algorithm is still binary search. With each iteration, we halve our search space, leading to a logarithmic time complexity.\\n  \\n- **Space complexity**: \\\\(O(1)\\\\). We only use a constant amount of space for our variables (`low`, `high`, `mid`), irrespective of the size of the input array.\\n\\n# Code\\n```Go []\\nfunc search(nums []int, target int) int {\\n    low, high := 0, len(nums) - 1\\n\\n    for low <= high {\\n        mid := (low + high) / 2\\n\\n        if nums[mid] == target {\\n            return mid\\n        }\\n\\n        if nums[low] <= nums[mid] {\\n            if nums[low] <= target && target < nums[mid] {\\n                high = mid - 1\\n            } else {\\n                low = mid + 1\\n            }\\n        } else {\\n            if nums[mid] < target && target <= nums[high] {\\n                low = mid + 1\\n            } else {\\n                high = mid - 1\\n            }\\n        }\\n    }\\n\\n    return -1\\n}\\n```\\n```Rust []\\nimpl Solution {\\n    pub fn search(nums: Vec<i32>, target: i32) -> i32 {\\n        let mut low = 0;\\n        let mut high = nums.len() as i32 - 1;\\n\\n        while low <= high {\\n            let mid = (low + high) / 2;\\n\\n            if nums[mid as usize] == target {\\n                return mid;\\n            }\\n\\n            if nums[low as usize] <= nums[mid as usize] {\\n                if nums[low as usize] <= target && target < nums[mid as usize] {\\n                    high = mid - 1;\\n                } else {\\n                    low = mid + 1;\\n                }\\n            } else {\\n                if nums[mid as usize] < target && target <= nums[high as usize] {\\n                    low = mid + 1;\\n                } else {\\n                    high = mid - 1;\\n                }\\n            }\\n        }\\n\\n        -1\\n    }\\n}\\n```\\n``` Python []\\nclass Solution:\\n    def search(self, nums: List[int], target: int) -> int:\\n        low, high = 0, len(nums) - 1 \\n\\n        while low <= high: \\n            mid = (low + high) // 2 \\n\\n            if nums[mid] == target: \\n                return mid \\n\\n            if nums[low] <= nums[mid]: \\n                if nums[low] <= target < nums[mid]: \\n                    high = mid - 1 \\n                else: \\n                    low = mid + 1 \\n            else: \\n                if nums[mid] < target <= nums[high]: \\n                    low = mid + 1 \\n                else: \\n                    high = mid - 1 \\n\\n        return -1 \\n```\\n\\nThe coding style in both Go and Rust is quite expressive. Go, with its simplicity and clear syntax, makes the logic straightforward. Rust, while having a bit more verbosity due to its strict type and ownership system, ensures memory safety without sacrificing performance. Both languages, with their static typing and powerful standard libraries, make it easier to implement such algorithms efficiently.",
                "solutionTags": [
                    "Python3",
                    "Go",
                    "Rust"
                ],
                "code": "```Go []\\nfunc search(nums []int, target int) int {\\n    low, high := 0, len(nums) - 1\\n\\n    for low <= high {\\n        mid := (low + high) / 2\\n\\n        if nums[mid] == target {\\n            return mid\\n        }\\n\\n        if nums[low] <= nums[mid] {\\n            if nums[low] <= target && target < nums[mid] {\\n                high = mid - 1\\n            } else {\\n                low = mid + 1\\n            }\\n        } else {\\n            if nums[mid] < target && target <= nums[high] {\\n                low = mid + 1\\n            } else {\\n                high = mid - 1\\n            }\\n        }\\n    }\\n\\n    return -1\\n}\\n```\n```Rust []\\nimpl Solution {\\n    pub fn search(nums: Vec<i32>, target: i32) -> i32 {\\n        let mut low = 0;\\n        let mut high = nums.len() as i32 - 1;\\n\\n        while low <= high {\\n            let mid = (low + high) / 2;\\n\\n            if nums[mid as usize] == target {\\n                return mid;\\n            }\\n\\n            if nums[low as usize] <= nums[mid as usize] {\\n                if nums[low as usize] <= target && target < nums[mid as usize] {\\n                    high = mid - 1;\\n                } else {\\n                    low = mid + 1;\\n                }\\n            } else {\\n                if nums[mid as usize] < target && target <= nums[high as usize] {\\n                    low = mid + 1;\\n                } else {\\n                    high = mid - 1;\\n                }\\n            }\\n        }\\n\\n        -1\\n    }\\n}\\n```\n``` Python []\\nclass Solution:\\n    def search(self, nums: List[int], target: int) -> int:\\n        low, high = 0, len(nums) - 1 \\n\\n        while low <= high: \\n            mid = (low + high) // 2 \\n\\n            if nums[mid] == target: \\n                return mid \\n\\n            if nums[low] <= nums[mid]: \\n                if nums[low] <= target < nums[mid]: \\n                    high = mid - 1 \\n                else: \\n                    low = mid + 1 \\n            else: \\n                if nums[mid] < target <= nums[high]: \\n                    low = mid + 1 \\n                else: \\n                    high = mid - 1 \\n\\n        return -1 \\n```",
                "codeTag": "Java"
            },
            {
                "id": 3879398,
                "title": "python-3-7-lines-binary-searches-w-explanation-t-m-92-94",
                "content": "Here\\'s the intuition:\\n\\n1. If we can determine`k`, the so-called *unknown pivot index*, the solution becomes easier. The key is that `nums[k]` is the first element in `nums` that is strictly less than `nums[0]`, so we can find it in *O*(log*N*) time with a boolean binary search.\\n\\n1. We now have the two subrrays, `nums[:k]` and `nums[k:]`, and we easily deduce in which subarray `target` must lie  (if it indeed does lie in`nums`) by comparing `target` to `nums[0]`.\\n\\n1. We perform a numerical binary search on the appropriate subarray, return the index if we find`target`, otherwise we return`-1`.\\n\\n\\n```\\nclass Solution:\\n    def search(self, nums: List[int], target: int) -> int:\\n\\n        k = bisect_left(nums, True, key = lambda x: x < nums[0])  # <-- 1\\n \\n        if target  >= nums[0]:                                    # <-- 2\\n            \\n            left = bisect_left(nums, target, hi = k-1)            # \\n            return left if nums[left] == target else -1           #\\n                                                                  # <-- 3\\n        rght = bisect_left(nums, target, lo = k)                  #\\n        return rght if rght < len(nums                            # (this line to avoid index out of range)\\n                     ) and nums[rght] == target else -1           #\\n```\\n[https://leetcode.com/problems/search-in-rotated-sorted-array/submissions/1015192078/](http://)\\n\\nI could be wrong, but I think that time complexity is *O*(log*N*) and space complexity is *O*(1), in which *N* ~ `len(nums)`.",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def search(self, nums: List[int], target: int) -> int:\\n\\n        k = bisect_left(nums, True, key = lambda x: x < nums[0])  # <-- 1\\n \\n        if target  >= nums[0]:                                    # <-- 2\\n            \\n            left = bisect_left(nums, target, hi = k-1)            # \\n            return left if nums[left] == target else -1           #\\n                                                                  # <-- 3\\n        rght = bisect_left(nums, target, lo = k)                  #\\n        return rght if rght < len(nums                            # (this line to avoid index out of range)\\n                     ) and nums[rght] == target else -1           #\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3510929,
                "title": "java-solution-for-search-in-a-rotated-array-problem",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nThe intuition behind the solution is to utilize binary search to efficiently find the target element in the rotated sorted array. By comparing the target with the mid element, the code determines which half of the array to continue the search in.\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n1. The code initializes the left and right pointers, representing the indices of the leftmost and rightmost elements in the search range.\\n. It enters a while loop where the search range is not empty (left <= right).\\n3. In each iteration, the code calculates the middle index mid as the average of the left and right indices.\\n4. If the target is equal to the element at the mid index, the function returns mid as the index of the target element.\\n5. If the element at the left index is less than or equal to the element at the mid index, it means the left half of the array is sorted in ascending order.\\n- If the target is within the range of the left half (between left and mid), the right pointer is updated to mid - 1 to continue the search in the left half.\\n- Otherwise, the left pointer is updated to mid + 1 to search in the right half.\\n6. If the element at the left index is greater than the element at the mid index, it means the right half of the array is sorted in ascending order.\\n- If the target is within the range of the right half (between mid and right), the left pointer is updated to mid + 1 to continue the search in the right half.\\n- Otherwise, the right pointer is updated to mid - 1 to search in the left half.\\n7. If the target is not found in the array, the while loop terminates, and the function returns -1 to indicate that the target is not present in the array.\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\nThe time complexity of the binary search algorithm is O(log n), where n is the length of the input array. This is because the search range is halved in each iteration, resulting in a logarithmic time complexity.\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\nThe space complexity of the code is O(1) because it uses a constant amount of extra space for the variables left, right, and mid. The space does not depend on the input size.\\n\\n# Code\\n```\\nclass Solution {\\n    public int search(int[] nums, int target) {\\n        int left = 0;\\n        int right= nums.length-1;\\n        while(left<=right)\\n        {\\n            int mid = left + (right-left)/2;\\n            if(target==nums[mid])\\n                return mid;\\n            if(nums[left]<=nums[mid])\\n            {\\n                if(nums[left]<=target&& target<nums[mid])\\n                {\\n                    right=mid-1;\\n                }\\n                else\\n                {\\n                    left=mid+1;\\n                }\\n            }\\n            else\\n            {\\n                if(nums[mid]<target&& target<=nums[right])\\n                {\\n                    left=mid+1;\\n                }\\n                else\\n                {\\n                    right=mid-1;\\n                }\\n            }\\n        }\\n        return -1;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int search(int[] nums, int target) {\\n        int left = 0;\\n        int right= nums.length-1;\\n        while(left<=right)\\n        {\\n            int mid = left + (right-left)/2;\\n            if(target==nums[mid])\\n                return mid;\\n            if(nums[left]<=nums[mid])\\n            {\\n                if(nums[left]<=target&& target<nums[mid])\\n                {\\n                    right=mid-1;\\n                }\\n                else\\n                {\\n                    left=mid+1;\\n                }\\n            }\\n            else\\n            {\\n                if(nums[mid]<target&& target<=nums[right])\\n                {\\n                    left=mid+1;\\n                }\\n                else\\n                {\\n                    right=mid-1;\\n                }\\n            }\\n        }\\n        return -1;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3316342,
                "title": "java-100-faster-binary-search",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\n    public int search(int[] nums, int target) {\\n        int low=0;\\n        int high=nums.length-1;\\n        while(low<=high){\\n            int mid=(low+high)/2;\\n            if (nums[mid] == target)\\n                return mid; \\n\\n            if (nums[low] <= nums[mid]) { \\n                if (nums[low] <= target && nums[mid] >= target)\\n                    high = mid - 1;\\n                else\\n                    low = mid + 1;\\n            } else {\\n                if (nums[mid] <= target && target <= nums[high])\\n                    low = mid + 1;\\n                else\\n                    high = mid - 1;\\n            }\\n        }\\n        return -1;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int search(int[] nums, int target) {\\n        int low=0;\\n        int high=nums.length-1;\\n        while(low<=high){\\n            int mid=(low+high)/2;\\n            if (nums[mid] == target)\\n                return mid; \\n\\n            if (nums[low] <= nums[mid]) { \\n                if (nums[low] <= target && nums[mid] >= target)\\n                    high = mid - 1;\\n                else\\n                    low = mid + 1;\\n            } else {\\n                if (nums[mid] <= target && target <= nums[high])\\n                    low = mid + 1;\\n                else\\n                    high = mid - 1;\\n            }\\n        }\\n        return -1;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3296300,
                "title": "a-recursion-approach",
                "content": "# Intuition\\nCheck if the sub-array contains the pivot index and decide the next part to be searched\\n\\n# Approach\\nUse recursion with different condition handling\\n\\n# Complexity\\n- Time complexity:\\n$$O(logn)$$\\n\\n# Code\\n```\\nclass Solution {\\n    public int search(int[] nums, int target) {\\n        return find(nums, 0, nums.length-1, target);\\n    }\\n\\n    public int find(int[] nums, int left, int right, int target) {\\n        if ((right - left) == 1 || left == right) {\\n            if (nums[left] == target) {\\n                return left;\\n            } else if(nums[right] == target) {\\n                return right;\\n            } else {\\n                return -1;\\n            }\\n        }\\n\\n        int mid = (left + right)/2;\\n        if (nums[left] <= nums[mid]) {\\n            if (target >= nums[left] && target <= nums[mid]) {\\n                return find(nums, left, mid, target);\\n            } else {\\n                return find(nums, mid, right, target);\\n            }\\n        } else {\\n            if (target >= nums[left] || target <= nums[mid]) {\\n                return find(nums, left, mid, target);\\n            } else {\\n                return find(nums, mid, right, target);\\n            }\\n        }\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int search(int[] nums, int target) {\\n        return find(nums, 0, nums.length-1, target);\\n    }\\n\\n    public int find(int[] nums, int left, int right, int target) {\\n        if ((right - left) == 1 || left == right) {\\n            if (nums[left] == target) {\\n                return left;\\n            } else if(nums[right] == target) {\\n                return right;\\n            } else {\\n                return -1;\\n            }\\n        }\\n\\n        int mid = (left + right)/2;\\n        if (nums[left] <= nums[mid]) {\\n            if (target >= nums[left] && target <= nums[mid]) {\\n                return find(nums, left, mid, target);\\n            } else {\\n                return find(nums, mid, right, target);\\n            }\\n        } else {\\n            if (target >= nums[left] || target <= nums[mid]) {\\n                return find(nums, left, mid, target);\\n            } else {\\n                return find(nums, mid, right, target);\\n            }\\n        }\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3220051,
                "title": "easy-java-solution-two-pointer-0ms-for-beginners",
                "content": "bin# Complexity\\n- Time complexity: O(logN)\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:O(1)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\n    public int search(int[] nums, int target) {\\n    \\n    int start = 0;\\n    int end = nums.length-1;\\n    while(start <= end){\\n        if(nums[start] == target) return start;\\n        if(nums[end] == target) return end;\\n        start ++;\\n        end--;\\n        }\\n       return -1;    \\n    }\\n     \\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Binary Search"
                ],
                "code": "```\\nclass Solution {\\n    public int search(int[] nums, int target) {\\n    \\n    int start = 0;\\n    int end = nums.length-1;\\n    while(start <= end){\\n        if(nums[start] == target) return start;\\n        if(nums[end] == target) return end;\\n        start ++;\\n        end--;\\n        }\\n       return -1;    \\n    }\\n     \\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3166291,
                "title": "easiest-c-code-using-binary-search-super-easy",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:O(logn)\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int search(vector<int>& nums, int target) {\\n        int n=nums.size(),l=0,r=n-1,m=0;\\n        while(l<=r){\\n                m=l+(r-l)/2;\\n                if(nums[m]==target) return m;\\n                if(nums[m]>=nums[l]){\\n                if(nums[m]>=target && nums[l]<=target) r=m-1;\\n                else l=m+1;}\\n                else{\\n                    if(nums[m]<=target && nums[r]>=target) l=m+1;\\n                    else r=m-1;\\n                }\\n        }\\n        return -1;\\n     }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int search(vector<int>& nums, int target) {\\n        int n=nums.size(),l=0,r=n-1,m=0;\\n        while(l<=r){\\n                m=l+(r-l)/2;\\n                if(nums[m]==target) return m;\\n                if(nums[m]>=nums[l]){\\n                if(nums[m]>=target && nums[l]<=target) r=m-1;\\n                else l=m+1;}\\n                else{\\n                    if(nums[m]<=target && nums[r]>=target) l=m+1;\\n                    else r=m-1;\\n                }\\n        }\\n        return -1;\\n     }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3162650,
                "title": "easy-c-solution-love-babber-dsa-sheet",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int search(vector<int>& nums, int target) {\\n        int low=0;\\n        int high=nums.size()-1;\\n        while(low<=high)\\n        {\\n            int mid=(low+high)/2;\\n            if(nums[mid]== target) return mid;\\n\\n            else if(nums[mid]>=nums[low])\\n            {\\n                if(nums[mid]>= target and nums[low]<= target) high=mid-1;\\n                else low = mid+1;\\n            }\\n            else{\\n                if(nums[mid]<= target and nums[high]>= target) low=mid+1;\\n                else high=mid-1;\\n\\n            }\\n        }\\n        return -1;\\n        \\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int search(vector<int>& nums, int target) {\\n        int low=0;\\n        int high=nums.size()-1;\\n        while(low<=high)\\n        {\\n            int mid=(low+high)/2;\\n            if(nums[mid]== target) return mid;\\n\\n            else if(nums[mid]>=nums[low])\\n            {\\n                if(nums[mid]>= target and nums[low]<= target) high=mid-1;\\n                else low = mid+1;\\n            }\\n            else{\\n                if(nums[mid]<= target and nums[high]>= target) low=mid+1;\\n                else high=mid-1;\\n\\n            }\\n        }\\n        return -1;\\n        \\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3138093,
                "title": "easy-c-solution-binary-search-linear-search-brute-force-optimize",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nWe can Solved this question using Two approach.\\n\\n1. Using Linear Search (Brute Force).\\n2. Using Binary Search (Optimize).\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\nWe can easily understand All the approaches by seeing the code which is easy to understand with comments.\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\nTime complexity provided in code comment.\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\nSpace complexity provided in code comment.\\n\\n# Code\\n```\\n/*\\n\\n    Time Complexity : O(N), because in the worst case, the target element may be present at the end of the array.\\n    Thus the time complexity is linear.\\n\\n    Space Complexity : O(1), the space complexity is constant.\\n\\n    Solved Using Linear Search + Array.\\n\\n*/\\n\\nclass Solution {\\npublic:\\n    int search(vector<int>& nums, int target) {\\n        int n = nums.size();\\n        for(int i=0; i<n; i++){\\n            if(nums[i] == target){\\n                return i;\\n            }\\n        }\\n        return -1;\\n    }\\n}; \\n\\n\\n\\n\\n\\n\\n/*\\n\\n    Time Complexity : O(log N), since we have used binary search to find the target element. The time complexity\\n    is logarithmic.\\n\\n    Space Complexity : O(1), since we stored only some constant number of elements, the space complexity is\\n    constant.\\n\\n    Solved Using Binary Search + Array.\\n\\n*/\\n\\nclass Solution {\\npublic:\\n    int search(vector<int>& nums, int target) {\\n        int low = 0;\\n        int high = nums.size()-1;\\n        while(low <= high){\\n            int mid = (low+high) >> 1;\\n            if(nums[mid] == target){\\n                return mid;\\n            }\\n            if(nums[low] <= nums[mid]){\\n                if(nums[low] <= target && nums[mid] > target){\\n                    high = mid - 1;\\n                }\\n                else{\\n                    low = mid + 1; \\n                }\\n            }\\n            else{\\n                if(target > nums[mid] && target <= nums[high]){\\n                    low = mid + 1;\\n                }\\n                else{\\n                    high = mid-1;\\n                }\\n            }\\n        }\\n        return -1;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Array",
                    "Binary Search"
                ],
                "code": "```\\n/*\\n\\n    Time Complexity : O(N), because in the worst case, the target element may be present at the end of the array.\\n    Thus the time complexity is linear.\\n\\n    Space Complexity : O(1), the space complexity is constant.\\n\\n    Solved Using Linear Search + Array.\\n\\n*/\\n\\nclass Solution {\\npublic:\\n    int search(vector<int>& nums, int target) {\\n        int n = nums.size();\\n        for(int i=0; i<n; i++){\\n            if(nums[i] == target){\\n                return i;\\n            }\\n        }\\n        return -1;\\n    }\\n}; \\n\\n\\n\\n\\n\\n\\n/*\\n\\n    Time Complexity : O(log N), since we have used binary search to find the target element. The time complexity\\n    is logarithmic.\\n\\n    Space Complexity : O(1), since we stored only some constant number of elements, the space complexity is\\n    constant.\\n\\n    Solved Using Binary Search + Array.\\n\\n*/\\n\\nclass Solution {\\npublic:\\n    int search(vector<int>& nums, int target) {\\n        int low = 0;\\n        int high = nums.size()-1;\\n        while(low <= high){\\n            int mid = (low+high) >> 1;\\n            if(nums[mid] == target){\\n                return mid;\\n            }\\n            if(nums[low] <= nums[mid]){\\n                if(nums[low] <= target && nums[mid] > target){\\n                    high = mid - 1;\\n                }\\n                else{\\n                    low = mid + 1; \\n                }\\n            }\\n            else{\\n                if(target > nums[mid] && target <= nums[high]){\\n                    low = mid + 1;\\n                }\\n                else{\\n                    high = mid-1;\\n                }\\n            }\\n        }\\n        return -1;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3018458,
                "title": "simple-go-solution-beats-100-and-99-performance",
                "content": "\\n# Approach\\nIn standard binary search, first we identify if the rotation is in left or right part. Check if target is in the range of the unrotated part to update search boundaries, `left` and `right`.\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity: O(log(n))\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: O(1)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nfunc search(nums []int, target int) int {\\n    left := 0\\n    right := len(nums) - 1\\n\\n    for left <= right {\\n        mid := left + (right - left) / 2\\n        if nums[mid] == target {\\n            return mid\\n        }\\n\\n        if nums[left] > nums[mid] {\\n            if nums[mid] < target && target <= nums[right] {\\n                left = mid + 1\\n            } else {\\n                right = mid - 1\\n            }\\n        } else {\\n            if nums[left] <= target && target < nums[mid] {\\n                right = mid - 1\\n            } else {\\n                left = mid + 1\\n            }\\n        }\\n    }\\n    \\n    return -1\\n}\\n```",
                "solutionTags": [
                    "Go",
                    "Binary Search"
                ],
                "code": "```\\nfunc search(nums []int, target int) int {\\n    left := 0\\n    right := len(nums) - 1\\n\\n    for left <= right {\\n        mid := left + (right - left) / 2\\n        if nums[mid] == target {\\n            return mid\\n        }\\n\\n        if nums[left] > nums[mid] {\\n            if nums[mid] < target && target <= nums[right] {\\n                left = mid + 1\\n            } else {\\n                right = mid - 1\\n            }\\n        } else {\\n            if nums[left] <= target && target < nums[mid] {\\n                right = mid - 1\\n            } else {\\n                left = mid + 1\\n            }\\n        }\\n    }\\n    \\n    return -1\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3010709,
                "title": "0ms-100-beats-easily-understandable-java-sol",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->Binary Search\\n\\n# Complexity\\n- Time complexity:O(log n)\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:O(1)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\n    public int search(int[] nums, int target) {\\n       int low=0,high=nums.length-1;\\n       while(low<=high){\\n           int mid = low+(high-low)/2;\\n           if(nums[mid] == target) return mid;\\n           if(nums[low]<=nums[mid]){\\n           if(target>=nums[low] && target<=nums[mid] ){\\n               high = mid-1;\\n           }else{\\n               low = mid+1;\\n           }\\n           }\\n           else{\\n               if(target>=nums[mid] && target<=nums[high]){\\n                   low = mid+1;\\n               }else{\\n                   high = mid-1;\\n               }\\n           }\\n           \\n       } return -1;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int search(int[] nums, int target) {\\n       int low=0,high=nums.length-1;\\n       while(low<=high){\\n           int mid = low+(high-low)/2;\\n           if(nums[mid] == target) return mid;\\n           if(nums[low]<=nums[mid]){\\n           if(target>=nums[low] && target<=nums[mid] ){\\n               high = mid-1;\\n           }else{\\n               low = mid+1;\\n           }\\n           }\\n           else{\\n               if(target>=nums[mid] && target<=nums[high]){\\n                   low = mid+1;\\n               }else{\\n                   high = mid-1;\\n               }\\n           }\\n           \\n       } return -1;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2771076,
                "title": "2-easy-approaches-3-line-fast-short-easy",
                "content": "**Please voteup if you like.**\\n```Approach 1:```\\n\\n```\\n--> In this approach I am taking two integer variable and set value 0, size - 1 of vector( end of vector ) respectively.\\n--> Run a while loop till i <= j.\\n--> Each time check nums with index i and j .\\n--> If nums[i] == target than return i.\\n--> If nums[j] == target than return j.\\n--> At last if target not present in vector than return -1.\\n```\\n\\ncode:\\n\\n```\\nclass Solution {\\npublic:\\n    int search(vector<int>& nums, int target) {\\n        int i = 0,j = nums.size()-1;\\n        while(i<=j)\\n        {\\n            if(nums[i] == target)    return i;\\n            else if(nums[j] == target)   return j;\\n            i++;\\n            j--;\\n        }\\n        return -1;\\n    }\\n};\\n```\\n\\n```Approach 2:```\\n\\n```\\n--> Run a Simple for loop and compare all elements with target one by one.\\n--> If elements match with target return the index value.\\n--> If target not available in vector than return -1.\\n```\\n\\t\\ncode:\\n```\\nclass Solution {\\npublic:\\n    int search(vector<int>& nums, int target) {       \\n        for(int i=0;i<nums.size();i++)\\n        {\\n            if(nums[i] == target)\\n                return i;\\n        }\\n        return -1;\\n    }\\n};\\n```\\nHope it will help you \\uD83D\\uDE4C.\\nThank you!.",
                "solutionTags": [
                    "C++",
                    "C",
                    "Two Pointers"
                ],
                "code": "```Approach 1:```\n```\\n--> In this approach I am taking two integer variable and set value 0, size - 1 of vector( end of vector ) respectively.\\n--> Run a while loop till i <= j.\\n--> Each time check nums with index i and j .\\n--> If nums[i] == target than return i.\\n--> If nums[j] == target than return j.\\n--> At last if target not present in vector than return -1.\\n```\n```\\nclass Solution {\\npublic:\\n    int search(vector<int>& nums, int target) {\\n        int i = 0,j = nums.size()-1;\\n        while(i<=j)\\n        {\\n            if(nums[i] == target)    return i;\\n            else if(nums[j] == target)   return j;\\n            i++;\\n            j--;\\n        }\\n        return -1;\\n    }\\n};\\n```\n```Approach 2:```\n```\\n--> Run a Simple for loop and compare all elements with target one by one.\\n--> If elements match with target return the index value.\\n--> If target not available in vector than return -1.\\n```\n```\\nclass Solution {\\npublic:\\n    int search(vector<int>& nums, int target) {       \\n        for(int i=0;i<nums.size();i++)\\n        {\\n            if(nums[i] == target)\\n                return i;\\n        }\\n        return -1;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2733041,
                "title": "simple-java-solution",
                "content": "```\\nclass Solution {\\n    public int search(int[] nums, int target) {\\n        int start = 0, end = nums.length - 1;\\n        while (start <= end) {\\n            int mid = ( start + end) / 2;\\n            if (nums[mid] == target) {\\n                return mid;\\n            }\\n            if (nums[start] <= nums[mid]) {\\n                if (nums[start] <= target && target < nums[mid]) {\\n                    end = mid -1;\\n                }\\n                else {\\n                    start = mid + 1;\\n                }\\n            }\\n            else{\\n                if (nums[mid] < target && target <= nums[end]) {\\n                    start = mid + 1;\\n                }\\n                else {\\n                    end = mid -1;\\n                }\\n            }\\n        }\\n        return -1;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int search(int[] nums, int target) {\\n        int start = 0, end = nums.length - 1;\\n        while (start <= end) {\\n            int mid = ( start + end) / 2;\\n            if (nums[mid] == target) {\\n                return mid;\\n            }\\n            if (nums[start] <= nums[mid]) {\\n                if (nums[start] <= target && target < nums[mid]) {\\n                    end = mid -1;\\n                }\\n                else {\\n                    start = mid + 1;\\n                }\\n            }\\n            else{\\n                if (nums[mid] < target && target <= nums[end]) {\\n                    start = mid + 1;\\n                }\\n                else {\\n                    end = mid -1;\\n                }\\n            }\\n        }\\n        return -1;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2731478,
                "title": "search-in-rotated-sorted-array-easy-to-understand-simple-binary-search-approach",
                "content": "**Brute force:O(n)**\\n```\\nclass Solution {\\npublic:\\n    \\n    int search(vector<int>& nums, int target) \\n    {\\n        int n=nums.size();\\n        \\n        int fix=-1;\\n        \\n        for(int i=0;i<n;i++)\\n        {\\n            if(nums[i]==target)\\n            {\\n                fix=i;\\n                break;\\n            }\\n        }\\n        \\n        return fix;\\n    }\\n};\\n```\\n\\n\\n**Binary Search : O(log2n)**\\n\\n**We simply divide the array from point  where curr element is greater than equal to prev one and less than or equal to next one and apply binary search twice...\\none on first section and  another on right section**\\n\\n```\\nclass Solution {\\npublic:\\n    \\nint bs(vector<int>&arr,int n,int find,int start,int end)\\n{\\n \\n   \\n   \\n   int mid;\\n   \\n   while(start<=end)\\n   {\\n       mid=start+(end-start)/2;\\n       \\n       if(arr[mid]==find)\\n       {\\n           return mid;\\n       }\\n       else if(arr[mid]<find)\\n       {\\n           start=mid+1;\\n       }\\n       else\\n       {\\n           end=mid-1;\\n       }\\n   }\\n   \\n   return -1;\\n    \\n   \\n}\\n    \\n    \\n    int search(vector<int>&arr, int target)\\n    {\\n        \\n      int n=arr.size();\\n      int s=0;\\n\\t  int e=n-1;\\n\\t  int fix;\\n        \\n\\t  while(s<=e)\\n\\t  {\\n\\t      int mid=s+(e-s)/2;\\n\\t      \\n\\t      int prev=(mid-1+n)%n;\\n\\t      int next=(mid+1)%n;\\n\\t      \\n\\t      \\n\\t      if((arr[mid]<=arr[prev])&&(arr[mid]<=arr[next]))\\n\\t      {\\n\\t          fix=mid;\\n              break;\\n\\t      }\\n\\t      else if(arr[mid]<=arr[e])\\n\\t      {\\n\\t          e=mid-1;\\n\\t      }\\n\\t      else if(arr[mid]>=arr[s])\\n\\t      {\\n\\t          s=mid+1;\\n\\t      }\\n\\t  }\\n\\t  \\n        \\n        \\n        int x=bs(arr,n,target,0,fix-1);\\n        int y=bs(arr,n,target,fix,n-1);\\n       \\n        \\n        \\n        if((x==y)&&(x==-1))\\n        {\\n            return -1;\\n        }\\n        \\n        if(x!=-1)\\n        {\\n            return x;\\n        }\\n        \\n        \\n        return y;\\n        \\n        \\n        \\n    }\\n};\\n```\\n\\n**Thank you**",
                "solutionTags": [
                    "C++",
                    "Binary Search"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    \\n    int search(vector<int>& nums, int target) \\n    {\\n        int n=nums.size();\\n        \\n        int fix=-1;\\n        \\n        for(int i=0;i<n;i++)\\n        {\\n            if(nums[i]==target)\\n            {\\n                fix=i;\\n                break;\\n            }\\n        }\\n        \\n        return fix;\\n    }\\n};\\n```\n```\\nclass Solution {\\npublic:\\n    \\nint bs(vector<int>&arr,int n,int find,int start,int end)\\n{\\n \\n   \\n   \\n   int mid;\\n   \\n   while(start<=end)\\n   {\\n       mid=start+(end-start)/2;\\n       \\n       if(arr[mid]==find)\\n       {\\n           return mid;\\n       }\\n       else if(arr[mid]<find)\\n       {\\n           start=mid+1;\\n       }\\n       else\\n       {\\n           end=mid-1;\\n       }\\n   }\\n   \\n   return -1;\\n    \\n   \\n}\\n    \\n    \\n    int search(vector<int>&arr, int target)\\n    {\\n        \\n      int n=arr.size();\\n      int s=0;\\n\\t  int e=n-1;\\n\\t  int fix;\\n        \\n\\t  while(s<=e)\\n\\t  {\\n\\t      int mid=s+(e-s)/2;\\n\\t      \\n\\t      int prev=(mid-1+n)%n;\\n\\t      int next=(mid+1)%n;\\n\\t      \\n\\t      \\n\\t      if((arr[mid]<=arr[prev])&&(arr[mid]<=arr[next]))\\n\\t      {\\n\\t          fix=mid;\\n              break;\\n\\t      }\\n\\t      else if(arr[mid]<=arr[e])\\n\\t      {\\n\\t          e=mid-1;\\n\\t      }\\n\\t      else if(arr[mid]>=arr[s])\\n\\t      {\\n\\t          s=mid+1;\\n\\t      }\\n\\t  }\\n\\t  \\n        \\n        \\n        int x=bs(arr,n,target,0,fix-1);\\n        int y=bs(arr,n,target,fix,n-1);\\n       \\n        \\n        \\n        if((x==y)&&(x==-1))\\n        {\\n            return -1;\\n        }\\n        \\n        if(x!=-1)\\n        {\\n            return x;\\n        }\\n        \\n        \\n        return y;\\n        \\n        \\n        \\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2398677,
                "title": "java-simple-0ms-faster-than-100",
                "content": "```\\npublic int search(int[] nums, int target) \\n    {\\n        int start = 0;\\n        int end = nums.length -1;\\n        \\n        while(start <= end)\\n        {\\n            int mid = start + (end - start) /2;\\n            \\n            if(target == nums[mid])\\n                return mid;\\n            \\n            if(nums[start] <= nums[mid])\\n            {\\n                if(nums[mid] > target && nums[start] <= target)\\n                   end = mid -1; \\n                \\n                else \\n                   start = mid +1;\\n        }\\n            else\\n            {\\n                if(nums[end] >= target && nums[mid] < target)\\n                    start = mid +1;\\n                else\\n                    end = mid-1;\\n            }\\n    }\\n        return -1;\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Binary Tree"
                ],
                "code": "```\\npublic int search(int[] nums, int target) \\n    {\\n        int start = 0;\\n        int end = nums.length -1;\\n        \\n        while(start <= end)\\n        {\\n            int mid = start + (end - start) /2;\\n            \\n            if(target == nums[mid])\\n                return mid;\\n            \\n            if(nums[start] <= nums[mid])\\n            {\\n                if(nums[mid] > target && nums[start] <= target)\\n                   end = mid -1; \\n                \\n                else \\n                   start = mid +1;\\n        }\\n            else\\n            {\\n                if(nums[end] >= target && nums[mid] < target)\\n                    start = mid +1;\\n                else\\n                    end = mid-1;\\n            }\\n    }\\n        return -1;\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2301747,
                "title": "beginner-friendly-java-javascript-python-solutions",
                "content": "\\n``` java []\\nclass Solution {\\n    public int search(int[] nums, int target) {\\n        int l=0, r=nums.length-1;\\n        while(l < r){\\n            int mid = (l+r)/2;\\n            if(nums[mid] > nums[r]){\\n                if(nums[mid] < target || target <= nums[r]){\\n                    l = mid + 1;\\n                } else{\\n                    r = mid;\\n                }\\n            } else{\\n                if(nums[mid] < target && target <= nums[r]){\\n                    l = mid + 1;\\n                } else{\\n                    r = mid;\\n                }\\n            }\\n        }\\n        return nums[l] == target ? l : -1;\\n    }\\n}\\n```\\n\\n```javascript []\\nvar search = function(nums, target) {\\n    let l=0, r=nums.length-1\\n    while(l < r){\\n        let mid = Math.floor((l+r)/2)\\n        if(nums[mid] > nums[r]){\\n            if(nums[mid] < target || target <= nums[r]) l = mid + 1\\n            else    r = mid\\n        } else{\\n            if(nums[mid] < target && target <= nums[r]) l = mid + 1\\n            else    r = mid\\n        }\\n    }\\n    return nums[l] == target ? l : -1\\n};\\n```\\n\\n```python []\\nclass Solution(object):\\n    def search(self, nums, target):\\n        l, r = 0, len(nums)-1\\n        while l < r:\\n            mid = (l+r)/2\\n            if nums[mid] > nums[r]:\\n                if nums[mid] < target or target <= nums[r]:\\n                    l = mid + 1\\n                else:\\n                    r = mid\\n            else:\\n                if nums[mid] < target and target <= nums[r]:\\n                    l = mid + 1\\n                else:\\n                    r = mid\\n        return l if nums[l] == target else -1\\n```",
                "solutionTags": [
                    "Java",
                    "Python",
                    "JavaScript"
                ],
                "code": "``` java []\\nclass Solution {\\n    public int search(int[] nums, int target) {\\n        int l=0, r=nums.length-1;\\n        while(l < r){\\n            int mid = (l+r)/2;\\n            if(nums[mid] > nums[r]){\\n                if(nums[mid] < target || target <= nums[r]){\\n                    l = mid + 1;\\n                } else{\\n                    r = mid;\\n                }\\n            } else{\\n                if(nums[mid] < target && target <= nums[r]){\\n                    l = mid + 1;\\n                } else{\\n                    r = mid;\\n                }\\n            }\\n        }\\n        return nums[l] == target ? l : -1;\\n    }\\n}\\n```\n```javascript []\\nvar search = function(nums, target) {\\n    let l=0, r=nums.length-1\\n    while(l < r){\\n        let mid = Math.floor((l+r)/2)\\n        if(nums[mid] > nums[r]){\\n            if(nums[mid] < target || target <= nums[r]) l = mid + 1\\n            else    r = mid\\n        } else{\\n            if(nums[mid] < target && target <= nums[r]) l = mid + 1\\n            else    r = mid\\n        }\\n    }\\n    return nums[l] == target ? l : -1\\n};\\n```\n```python []\\nclass Solution(object):\\n    def search(self, nums, target):\\n        l, r = 0, len(nums)-1\\n        while l < r:\\n            mid = (l+r)/2\\n            if nums[mid] > nums[r]:\\n                if nums[mid] < target or target <= nums[r]:\\n                    l = mid + 1\\n                else:\\n                    r = mid\\n            else:\\n                if nums[mid] < target and target <= nums[r]:\\n                    l = mid + 1\\n                else:\\n                    r = mid\\n        return l if nums[l] == target else -1\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2222958,
                "title": "c-binary-search-easy-two-pass-solution-o-logn",
                "content": "For those who have difficulties understanding one-pass binary search solution, I tried to divide the problem into two stages:\\n\\n1. Find the lowest value in array.\\n2. Find the target in left or right group.\\n\\nThe overall time complexity is still `O(log n)`, but much easier to come up with.\\n\\n```\\nclass Solution {\\npublic:\\n    int findLow(vector<int> &nums) {\\n        int lo = 0, hi = nums.size() - 1;\\n        while(lo < hi) {\\n            // case 1: mid > lo && mid > hi -> move lo\\n            // case 2: mid < lo && mid < hi -> move hi\\n            // case 3: mid > lo && mid < hi -> move hi\\n            int mid = lo + (hi - lo) / 2;\\n            if(nums[mid] > nums[hi])\\n                lo = mid + 1;\\n            else\\n                hi = mid;\\n        }\\n        return lo;\\n    }\\n    int bs(vector<int> &nums, int target, int lo, int hi) {\\n        while(lo <= hi) {\\n            int mid = lo + (hi - lo) / 2;\\n            if(nums[mid] == target) return mid;\\n            else if(nums[mid] > target) hi = mid-1;\\n            else lo = mid+1;\\n        }\\n        return -1;\\n    }\\n    int search(vector<int>& nums, int target) {\\n        int idx = findLow(nums);\\n        if(nums.back() < target)\\n            return bs(nums, target, 0, idx-1);\\n        else\\n            return bs(nums, target, idx, nums.size()-1);\\n    }\\n};\\n```\\n\\nTime complexity: `O(log n)`\\nSpace complexity: `O(1)`",
                "solutionTags": [
                    "C",
                    "Binary Tree"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int findLow(vector<int> &nums) {\\n        int lo = 0, hi = nums.size() - 1;\\n        while(lo < hi) {\\n            // case 1: mid > lo && mid > hi -> move lo\\n            // case 2: mid < lo && mid < hi -> move hi\\n            // case 3: mid > lo && mid < hi -> move hi\\n            int mid = lo + (hi - lo) / 2;\\n            if(nums[mid] > nums[hi])\\n                lo = mid + 1;\\n            else\\n                hi = mid;\\n        }\\n        return lo;\\n    }\\n    int bs(vector<int> &nums, int target, int lo, int hi) {\\n        while(lo <= hi) {\\n            int mid = lo + (hi - lo) / 2;\\n            if(nums[mid] == target) return mid;\\n            else if(nums[mid] > target) hi = mid-1;\\n            else lo = mid+1;\\n        }\\n        return -1;\\n    }\\n    int search(vector<int>& nums, int target) {\\n        int idx = findLow(nums);\\n        if(nums.back() < target)\\n            return bs(nums, target, 0, idx-1);\\n        else\\n            return bs(nums, target, idx, nums.size()-1);\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2196530,
                "title": "c-most-intuitive-approach-w-visual-breakdown-o-log-n",
                "content": "\\n# \"Brute force\" intuitive Approach O(log(n))\\n\\nIf you were ever stuck on this problem, you might\\'ve arrived at this optimal approach if you simply \"blindy\" drew out the possible cases. As you do so, you will notice that it just consists of a few if-statements and is not difficult too difficult to code up at all. This is the first approach which is still an optimal approach.\\n\\nHowever, as you can see from other posts or if you ponder on the problem long enough, the code (shown below) can surely be condensed as there\\'s repetitive logic somewhere in there. But here\\'s a good way to start as it still a **O(log(n))** solution. **I will show you what the non repetitive version is later**.\\n\\n**Case 1) The Array is Rotated**\\n* Case 1.1) The MID is in the **LEFT** subarray\\n\\t* 1.1.1) The target is between the (MID, LEFT] -> Only look at LEFT of MID -> *R = mid-1*\\n\\t* 1.1.2) Else only look at RIGHT of mid -> *L = mid+1*\\n* Case 1.2) The MID is in the **RIGHT** subarray\\n\\t* 1.2.1) The target is between the (MID, RIGHT] -> Only look at RIGHT of mid -> *L = mid+1*\\n\\t* 1.2.2) Else only look at LEFT of mid -> *R = mid-1*\\n\\t\\n**Case 2) The Array is NOT Rotated** (this is the logic that can be removed)\\n* Case 2.1) Do a regular binary search (you should know this)\\n\\t* 2.1) Target is between (MID, RIGHT] --> L = mid+1\\n\\t* 2.2) Else --> R = mid-1\\n\\n![image](https://assets.leetcode.com/users/images/636b2f48-85c1-4029-8c74-85bb57e692e5_1656176521.2446127.png)\\n\\n\\n**Code**\\n```\\nclass Solution {\\npublic:\\n    int search(vector<int>& nums, int target) {\\n        int L = 0;\\n        int R = nums.size()-1;\\n        int mid;\\n        while(L <= R){\\n            mid = (L+R)/2;\\n            \\n            // found target\\n            if(nums[mid] == target)\\n                return mid;\\n            \\n            // case1: rotated case\\n            if(nums[L] > nums[R]){\\n                \\n                // case 1.1: mid is in left subarray\\n                if(nums[mid] >= nums[L]){\\n                    if(target >= nums[L] && target < nums[mid]) // 1.1.1\\n                        R = mid-1;\\n                    else // 1.1.2\\n                        L = mid+1;\\n                    \\n                // case 1.2: mid is in right subarray\\n                } else {\\n                    if(target > nums[mid] && target <= nums[R]) // 1.2.1\\n                        L = mid+1;\\n                    else // 1.2.2\\n                        R = mid-1;\\n                }\\n                \\n            // case2: regular binary search\\n            } else {\\n                if(nums[mid] > target)\\n                    R = mid-1;\\n                else\\n                    L = mid+1;\\n            }\\n        }\\n        \\n        return -1;\\n    }\\n};\\n```\\n_________________\\n# Removed repetitive logic from intuitive Approach O(log(n))\\n\\nNow if you can notice it, the whole of case 2 where we do a regular binary search is actually not needed. We can compeltely remove case 2 and simply always run case 1. \\n\\nWhy is this?\\n\\nLook at Case 1.1. Our code logic for case 1.1 is: `if(nums[mid] >= nums[L])`. In a regular sorted array like [0,1,2,3,4,5], this if statement is always true. Now if we look at Cases 1.1.1 and 1.1.2 that fall under Case 1.1, this is just the same as a regular binary search. \\n* Case 1.1.1 says: \"If target is between (MID, LEFT] --> Look at LEFT of MID -> R = mid-1, ELSE look at RIGHT of mid ->L = mid+1\\n\\nThis is just another way to write the if statements in a regular binary search!\\nAs a result, we can remove Case 2 entirely and always run Case 1 only. You would\\'ve gotten to this solution if you realized that Case 1.1 is not just checking if MID is in the left subarray, but it is actually also checking if MID is in the SORTED portion of the array which is always the input in a regular binary search. \\n\\n**Code**\\n```\\nclass Solution {\\npublic:\\n    int search(vector<int>& nums, int target) {\\n        int L = 0;\\n        int R = nums.size()-1;\\n        int mid;\\n        // L   R\\n        while(L <= R){\\n            mid = (L+R)/2;\\n            \\n            // found target\\n            if(nums[mid] == target)\\n                return mid;\\n\\n            // case 1.1: mid is in left subarray aka the SORTED subarray\\n            if(nums[mid] >= nums[L]){\\n                if(target >= nums[L] && target < nums[mid])\\n                    R = mid-1;\\n                else\\n                    L = mid+1;\\n\\n            // case 1.2: mid is in right subarray\\n            } else {\\n                if(target > nums[mid] && target <= nums[R])\\n                    L = mid+1;\\n                else\\n                    R = mid-1;\\n            }\\n        }\\n        \\n        return -1;\\n    }\\n};\\n```\\n\\n",
                "solutionTags": [
                    "C++",
                    "C",
                    "Binary Search"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int search(vector<int>& nums, int target) {\\n        int L = 0;\\n        int R = nums.size()-1;\\n        int mid;\\n        while(L <= R){\\n            mid = (L+R)/2;\\n            \\n            // found target\\n            if(nums[mid] == target)\\n                return mid;\\n            \\n            // case1: rotated case\\n            if(nums[L] > nums[R]){\\n                \\n                // case 1.1: mid is in left subarray\\n                if(nums[mid] >= nums[L]){\\n                    if(target >= nums[L] && target < nums[mid]) // 1.1.1\\n                        R = mid-1;\\n                    else // 1.1.2\\n                        L = mid+1;\\n                    \\n                // case 1.2: mid is in right subarray\\n                } else {\\n                    if(target > nums[mid] && target <= nums[R]) // 1.2.1\\n                        L = mid+1;\\n                    else // 1.2.2\\n                        R = mid-1;\\n                }\\n                \\n            // case2: regular binary search\\n            } else {\\n                if(nums[mid] > target)\\n                    R = mid-1;\\n                else\\n                    L = mid+1;\\n            }\\n        }\\n        \\n        return -1;\\n    }\\n};\\n```\n```\\nclass Solution {\\npublic:\\n    int search(vector<int>& nums, int target) {\\n        int L = 0;\\n        int R = nums.size()-1;\\n        int mid;\\n        // L   R\\n        while(L <= R){\\n            mid = (L+R)/2;\\n            \\n            // found target\\n            if(nums[mid] == target)\\n                return mid;\\n\\n            // case 1.1: mid is in left subarray aka the SORTED subarray\\n            if(nums[mid] >= nums[L]){\\n                if(target >= nums[L] && target < nums[mid])\\n                    R = mid-1;\\n                else\\n                    L = mid+1;\\n\\n            // case 1.2: mid is in right subarray\\n            } else {\\n                if(target > nums[mid] && target <= nums[R])\\n                    L = mid+1;\\n                else\\n                    R = mid-1;\\n            }\\n        }\\n        \\n        return -1;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2144045,
                "title": "best-and-easy-c-code-binary-search-11ms",
                "content": "**A small story, if you want you can skip:**\\nIn the comment box of this post, @Malkeet_Levi asked me how I approached the logic of this question. So, I thought to share a small story with you. In one of my interviews, the interviewer asked me a similiar question. I solved that in O(n) time complexicity but he asked me to optimize. I got the idea that it will be solve using binary search but I was confusing how to shift pointers. He gave me a hint how to shift pointers. At that time, it hit my mind and I solved it. Basically, if we have given these type of array, we check which side we are getting increasing sequence. It means in which half the array is sorted.\\n\\n**PS:** During interviews, if you are not getting anything, try to be interactive with the interviewer. Ask as much as hints you want. \\n\\n**Main code starts from here:**\\nThis is my easy and simple binary seach code. Here what we are doing basically, first we use simple binary search as we do. Like first we found the mid of the array. Now, we will see this in three steps:\\n\\n* First , we check mid element with the target element. If it is the target element then we will return its index.\\n* Either  we will check that the sorted array is in left half or in right half by comparing with mid-indexed element.\\n* If it is in left half, we will reduced our high pointer **high=mid-1** or it is in a right half we will increased our low pointer **low=mid+1**.\\n\\nHere is my code:\\n\\n```\\nint search(vector<int>& nums, int tar) {\\n        int low=0,high=nums.size()-1;\\n        \\n        while(low<=high)\\n        {\\n            long long mid=((high+low)/2);\\n            \\n\\t\\t\\t// Check whether mid element is target element or not\\n            if(nums[mid]==tar)\\n            return mid;\\n            \\n            // To check that first half is sorted or not\\n            if(nums[low]<=nums[mid])\\n            {\\n                if(tar>=nums[low] and tar<nums[mid])\\n                high=mid-1;\\n                else\\n                low=mid+1;\\n            }\\n\\t\\t\\t\\n            // To check that second half is sorted or not\\n            else\\n            {\\n                if(tar>nums[mid] and tar<=nums[high])\\n                low=mid+1;\\n                else\\n                high=mid-1;\\n            }     \\n        }\\n        \\n        return -1;        \\n    }\\n```\\n\\n**PS: Keep Coding...Keep Learning.**\\n",
                "solutionTags": [
                    "C",
                    "Binary Tree"
                ],
                "code": "```\\nint search(vector<int>& nums, int tar) {\\n        int low=0,high=nums.size()-1;\\n        \\n        while(low<=high)\\n        {\\n            long long mid=((high+low)/2);\\n            \\n\\t\\t\\t// Check whether mid element is target element or not\\n            if(nums[mid]==tar)\\n            return mid;\\n            \\n            // To check that first half is sorted or not\\n            if(nums[low]<=nums[mid])\\n            {\\n                if(tar>=nums[low] and tar<nums[mid])\\n                high=mid-1;\\n                else\\n                low=mid+1;\\n            }\\n\\t\\t\\t\\n            // To check that second half is sorted or not\\n            else\\n            {\\n                if(tar>nums[mid] and tar<=nums[high])\\n                low=mid+1;\\n                else\\n                high=mid-1;\\n            }     \\n        }\\n        \\n        return -1;        \\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2087043,
                "title": "simple-java-solution-with-algorithm-1ms-o-log-n",
                "content": "**Algorithm**\\n* The complete idea is very simple. The main approach is binary search. The array is already sorted, but it is rotated from some point. We need to find that pivot and use them as two arrays.\\n* First find the maximum element(pivot) using binary search method. \\n* Then send the sub array to the function binarySearch in which the target should be contained. \\n* The returned value is the answer.\\n\\nTime Complexity: O(log n)\\n\\n**Code**\\n```\\npublic int search(int[] nums, int target) {\\n        int l = 0, r = nums.length-1;\\n        int k=0;\\n        while(l<r){\\n            int mid = (int)(l+r)/2;\\n            if(nums[mid] > nums[l] && nums[mid] > nums[r]) l = mid;\\n            else  r = mid;\\n        }\\n        int res = 0;\\n        if(target <= nums[r] && target >= nums[0]) res = binarySearch(nums, 0, r, target);\\n        else res = binarySearch(nums, r+1, nums.length-1, target);\\n        \\n        return res;\\n    }\\n    private int binarySearch(int[] nums, int l, int r, int target){\\n        while(l<=r){\\n            int mid = l+(r-l)/2;\\n            if(nums[mid] == target) return mid;\\n            else if(nums[mid] < target) l = mid+1;\\n            else  r = mid-1;\\n        }\\n        return -1;\\n    }\\n```\\n**Please upvote if you liked the solution**\\n*Feel free to ask any questions in the comment section*",
                "solutionTags": [
                    "Java",
                    "Binary Tree"
                ],
                "code": "```\\npublic int search(int[] nums, int target) {\\n        int l = 0, r = nums.length-1;\\n        int k=0;\\n        while(l<r){\\n            int mid = (int)(l+r)/2;\\n            if(nums[mid] > nums[l] && nums[mid] > nums[r]) l = mid;\\n            else  r = mid;\\n        }\\n        int res = 0;\\n        if(target <= nums[r] && target >= nums[0]) res = binarySearch(nums, 0, r, target);\\n        else res = binarySearch(nums, r+1, nums.length-1, target);\\n        \\n        return res;\\n    }\\n    private int binarySearch(int[] nums, int l, int r, int target){\\n        while(l<=r){\\n            int mid = l+(r-l)/2;\\n            if(nums[mid] == target) return mid;\\n            else if(nums[mid] < target) l = mid+1;\\n            else  r = mid-1;\\n        }\\n        return -1;\\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2006156,
                "title": "100-faster-than-all-online-solutions-c",
                "content": "```\\nclass Solution {\\npublic:\\n    \\n    int search(vector<int>& nums, int target) {\\n        int lo = 0;\\n        int hi = nums.size() - 1;\\n        while(lo<hi)\\n        {\\n            int mid = lo+(hi-lo)/2;\\n            if(nums[mid]>nums[hi])\\n                lo = mid+1;\\n            else\\n                hi = mid;\\n        }\\n        //We have divided the array into two parts\\n        int p = lo;\\n        hi = nums.size()-1;\\n        if(target>nums[hi])\\n        {\\n            lo = 0;\\n            hi = p-1;\\n        }\\n        else{\\n            lo = p;\\n            hi = nums.size()-1;\\n        }\\n        \\n        \\n        while(lo<=hi)\\n        {\\n            int mid = lo+(hi-lo)/2;\\n            \\n            if(nums[mid]==target)\\n                return mid;\\n            else if(nums[mid]<target)\\n            {\\n                lo = mid+1;\\n            }\\n            else{\\n                hi = mid-1;\\n            }\\n        }\\n        \\n        return -1;\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    \\n    int search(vector<int>& nums, int target) {\\n        int lo = 0;\\n        int hi = nums.size() - 1;\\n        while(lo<hi)\\n        {\\n            int mid = lo+(hi-lo)/2;\\n            if(nums[mid]>nums[hi])\\n                lo = mid+1;\\n            else\\n                hi = mid;\\n        }\\n        //We have divided the array into two parts\\n        int p = lo;\\n        hi = nums.size()-1;\\n        if(target>nums[hi])\\n        {\\n            lo = 0;\\n            hi = p-1;\\n        }\\n        else{\\n            lo = p;\\n            hi = nums.size()-1;\\n        }\\n        \\n        \\n        while(lo<=hi)\\n        {\\n            int mid = lo+(hi-lo)/2;\\n            \\n            if(nums[mid]==target)\\n                return mid;\\n            else if(nums[mid]<target)\\n            {\\n                lo = mid+1;\\n            }\\n            else{\\n                hi = mid-1;\\n            }\\n        }\\n        \\n        return -1;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1932901,
                "title": "java-0-ms-faster-than-100-00-of-java-online-submissions-binary-search",
                "content": "### Please upvote, if you like the solution\\n\\n\\tclass Solution {\\n\\t\\t\\tpublic int search(int[] arr, int target) {\\n\\t\\t\\t\\tint low = 0, high = arr.length-1;\\n\\n\\t\\t\\t\\twhile(low<=high){\\n\\t\\t\\t\\t\\tint mid = low +(high-low)/2;\\n\\t\\t\\t\\t\\tif(arr[mid]==target){ return mid; }\\n\\t\\t\\t\\t\\tif(arr[mid]>=arr[low]){\\n\\t\\t\\t\\t\\t\\tif(target<=arr[mid] && target>=arr[low]){\\n\\t\\t\\t\\t\\t\\t\\thigh = mid-1;\\n\\t\\t\\t\\t\\t\\t}\\n\\t\\t\\t\\t\\t\\telse{\\n\\t\\t\\t\\t\\t\\t\\tlow = mid+1;\\n\\t\\t\\t\\t\\t\\t}\\n\\t\\t\\t\\t\\t}\\n\\t\\t\\t\\t\\telse{\\n\\t\\t\\t\\t\\t\\tif(target>=arr[mid] && target<=arr[high]){\\n\\t\\t\\t\\t\\t\\t\\tlow = mid+1;\\n\\t\\t\\t\\t\\t\\t}\\n\\t\\t\\t\\t\\t\\telse{\\n\\t\\t\\t\\t\\t\\t\\thigh = mid-1;\\n\\t\\t\\t\\t\\t\\t}\\n\\t\\t\\t\\t\\t}\\n\\t\\t\\t\\t}\\n\\t\\t\\t\\treturn -1;\\n\\t\\t\\t}\\n\\t\\t}",
                "solutionTags": [
                    "Java",
                    "Binary Tree"
                ],
                "code": "class Solution {\\n\\t\\t\\tpublic int search(int[] arr, int target) {\\n\\t\\t\\t\\tint low = 0, high = arr.length-1;\\n\\n\\t\\t\\t\\twhile(low<=high){\\n\\t\\t\\t\\t\\tint mid = low +(high-low)/2;\\n\\t\\t\\t\\t\\tif(arr[mid]==target){ return mid; }",
                "codeTag": "Java"
            },
            {
                "id": 1791418,
                "title": "detailed-approach-with-solution-c",
                "content": "# Modified Binary Search\\n### Approach\\n```\\nRun a loop till start element is smaller then end element\\n    if mid element is equal to target: return mid\\n    else if mid element is greater than start element -> array before mid element must be sorted\\n        if target is smaller than mid element and greater than start element: new end element is mid element -> unrotated part\\n        else : new start element is mid element -> rotated part\\n    else -> array after mid must be sorted\\n        if target is greater than mid element and smaller than end element: new start element is mid element -> unrotated side\\n        else : new end element is mid element -> rotated side\\nreturn -1 -> element not found in array\\n```\\n\\n **Time Complexity: *O(log(n))***\\n**Space Complexity: *O(1)***\\n\\n### Solution\\n```\\nclass Solution {\\n   public:\\n    int search(vector<int>& nums, int target) {\\n        int low = 0, mid, high = nums.size() - 1;\\n        while (low <= high) {\\n            mid = low + (high - low) / 2;\\n            if (nums[mid] == target) {\\n                return mid;\\n            } else if (nums[mid] >= nums[low]) {\\n                if (target < nums[mid] && target >= nums[low]) {\\n                    high = mid - 1;\\n                } else {\\n                    low = mid + 1;\\n                }\\n            } else {\\n                if (target > nums[mid] && target <= nums[high]) {\\n                    low = mid + 1;\\n                } else {\\n                    high = mid - 1;\\n                }\\n            }\\n        }\\n        return -1;\\n    }\\n};\\n```\\n",
                "solutionTags": [
                    "C",
                    "Binary Tree"
                ],
                "code": "```\\nRun a loop till start element is smaller then end element\\n    if mid element is equal to target: return mid\\n    else if mid element is greater than start element -> array before mid element must be sorted\\n        if target is smaller than mid element and greater than start element: new end element is mid element -> unrotated part\\n        else : new start element is mid element -> rotated part\\n    else -> array after mid must be sorted\\n        if target is greater than mid element and smaller than end element: new start element is mid element -> unrotated side\\n        else : new end element is mid element -> rotated side\\nreturn -1 -> element not found in array\\n```\n```\\nclass Solution {\\n   public:\\n    int search(vector<int>& nums, int target) {\\n        int low = 0, mid, high = nums.size() - 1;\\n        while (low <= high) {\\n            mid = low + (high - low) / 2;\\n            if (nums[mid] == target) {\\n                return mid;\\n            } else if (nums[mid] >= nums[low]) {\\n                if (target < nums[mid] && target >= nums[low]) {\\n                    high = mid - 1;\\n                } else {\\n                    low = mid + 1;\\n                }\\n            } else {\\n                if (target > nums[mid] && target <= nums[high]) {\\n                    low = mid + 1;\\n                } else {\\n                    high = mid - 1;\\n                }\\n            }\\n        }\\n        return -1;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1729466,
                "title": "java-simple-easy-o-log-n-explained",
                "content": "<u>**BASIC IDEA:**</u>\\n\\n* **First check the edge case** i.e. if the **given array**(nums) is **not rotated** or we can say is already in **strictly increasing order**[eg: `nums = {3, 5, 13, 21}`], then **do the normal/standard binary search and return the index of target if present or else -1**\\n\\teg: \\n\\t`nums[] = {3, 5, 13, 21}` and `target = 13`, then `return 2` as index\\n\\tand if `target = 53`, then `return -1` as index because 53 in not present in nums.\\n\\n* **If the array is rotated, then find the index of minimum element to get the pivot**\\n\\teg: \\n\\t`nums[] = {4, 5, 6, 7, 8, 1, 2, 3}`, here the **minimum element in array nums is 1** and **it\\'s index is 5**\\n\\t\\n* **After getting the index of minimum element**(i.e. 5),\\n\\t*  **if the target is equal to minimum element, then directly return it\\'s index**\\n\\teg: \\n\\t`nums[] = {5, 6, 7, 8, 9, 1, 2, 3, 4}` and `target = 1`, **then directly return 5 as it\\'s index**\\n\\n\\t* **else find out whether to search in left sorted array**(i.e. {5, 6, 7, 8, 9}) **or right sorted array**(i.e. {1, 2, 3, 4})\\n\\teg: \\n\\t`nums[] = {5, 6, 7, 8, 9, 1, 2, 3, 4}` and `target = 3`, **then search in the right sorted array**(i.e. {1, 2, 3, 4})\\n\\t\\n* **Once it\\'s found which sorted part(i.e. left or right) to search, do the normal/standard binary search on that sorted part and return the index of target if found or else return -1.**\\n\\n<u>**JAVA COMMENTED SOLUTION:**</u>\\n```\\nclass Solution {\\n  public int search(int[] nums, int target) {\\n\\n    int end = nums.length - 1;\\n\\n    // if the array is not rotated i.e. if the array is strictly increasing[eg: {1,2,3,4}], then\\n    if(nums[0] < nums[end]) {\\n      return indexOfTarget(nums, 0, end, target); // directly return the index of target if present, else return -1\\n    }\\n\\n    // find the index of minimum element in nums\\n    int start = 0;\\n    int firstElement = nums[0];\\n    while(start < end) {\\n\\n      int mid = (start + end) >> 1;\\n\\n      // if the current element is minimum, then store it\\'s index and stop iteration\\n      if(mid > 0 && nums[mid] < nums[mid - 1]) {\\n        start = mid;\\n        break;\\n      }\\n\\n      if(nums[mid] >= firstElement) { // to search in right sorted part\\n        start = mid + 1;\\n      } else { // to search in left sorted part\\n        end = mid;\\n      }\\n    }\\n\\n    // store the index of min element in nums\\n    int indexOfMinElement = start;\\n    // if the minimum element is equal to the the target, then\\n    if(nums[indexOfMinElement] == target) {\\n      return indexOfMinElement; //directly return it\\'s index\\n    }\\n\\n    start = 0;\\n    end = nums.length - 1;\\n\\n    // if the target element is on the right sorted part, then\\n    if(target < firstElement) {\\n      start = indexOfMinElement; // search from index of minimum element to the end of the array(nums)\\n    } else { // if the target element is on the left side of the sorted array\\n      end = indexOfMinElement - 1; // search from 0 to one previous element from index of minimum element\\n    }\\n\\n    // now as we know which sorted part(left or right) to search, do standard binary search\\n    // search for the index of target if the target is present in the nums, else return -1\\n    return indexOfTarget(nums, start, end, target);\\n  }\\n\\n  // standard binary search\\n  private int indexOfTarget(int[] nums, int start, int end, int target) {\\n\\n    while(start <= end) {\\n\\n      int mid = (start + end) >> 1;\\n\\n      if(nums[mid] == target) {\\n        return mid;\\n      }\\n\\n      if(nums[mid] < target) {\\n        start = mid + 1;\\n      } else {\\n        end = mid - 1;\\n      }\\n    }\\n\\n    return -1;\\n  }\\n}\\n```\\n\\n<u>**JAVA SOLUTION WITHOUT COMMENTS:**</u>\\n\\n```\\nclass Solution {\\n  public int search(int[] nums, int target) {\\n\\n    int end = nums.length - 1;\\n    if(nums[0] < nums[end]) {\\n      return indexOfTarget(nums, 0, end, target);\\n    }\\n\\n    int start = 0;\\n    int firstElement = nums[0];\\n    while(start < end) {\\n\\n      int mid = (start + end) >> 1;\\n\\n      if(mid > 0 && nums[mid] < nums[mid - 1]) {\\n        start = mid;\\n        break;\\n      }\\n\\n      if(nums[mid] >= firstElement) {\\n        start = mid + 1;\\n      } else {\\n        end = mid;\\n      }\\n    }\\n\\n    int indexOfMinElement = start;\\n    if(nums[indexOfMinElement] == target) {\\n      return indexOfMinElement;\\n    }\\n\\n    start = 0;\\n    end = nums.length - 1;\\n    if(target < firstElement) {\\n      start = indexOfMinElement;\\n    } else {\\n      end = indexOfMinElement - 1;\\n    }\\n\\n    return indexOfTarget(nums, start, end, target);\\n  }\\n\\n  private int indexOfTarget(int[] nums, int start, int end, int target) {\\n\\n    while(start <= end) {\\n\\n      int mid = (start + end) >> 1;\\n\\n      if(nums[mid] == target) {\\n        return mid;\\n      }\\n\\n      if(nums[mid] < target) {\\n        start = mid + 1;\\n      } else {\\n        end = mid - 1;\\n      }\\n    }\\n\\n    return -1;\\n  }\\n}\\n```\\n\\n\\n<u>**COMPLEXITY ANALYSIS:**</u>\\n* **Time: O(log<sub>2</sub>n)**, where **n is the size** of the given array(nums) and **O(log<sub>2</sub>n) is the maximum number of possible iterations**\\n* **Space: O(1)**, in-place\\n\\n<u><strong>Refer to the following github repsitory for more leetcode solutions<strong></u>\\nhttps://github.com/Akshaya-Amar/LeetCodeSolutions\\n\\n# **Please UPVOTE if you find the solution helpful :)**",
                "solutionTags": [
                    "Java",
                    "Binary Search"
                ],
                "code": "```\\nclass Solution {\\n  public int search(int[] nums, int target) {\\n\\n    int end = nums.length - 1;\\n\\n    // if the array is not rotated i.e. if the array is strictly increasing[eg: {1,2,3,4}], then\\n    if(nums[0] < nums[end]) {\\n      return indexOfTarget(nums, 0, end, target); // directly return the index of target if present, else return -1\\n    }\\n\\n    // find the index of minimum element in nums\\n    int start = 0;\\n    int firstElement = nums[0];\\n    while(start < end) {\\n\\n      int mid = (start + end) >> 1;\\n\\n      // if the current element is minimum, then store it\\'s index and stop iteration\\n      if(mid > 0 && nums[mid] < nums[mid - 1]) {\\n        start = mid;\\n        break;\\n      }\\n\\n      if(nums[mid] >= firstElement) { // to search in right sorted part\\n        start = mid + 1;\\n      } else { // to search in left sorted part\\n        end = mid;\\n      }\\n    }\\n\\n    // store the index of min element in nums\\n    int indexOfMinElement = start;\\n    // if the minimum element is equal to the the target, then\\n    if(nums[indexOfMinElement] == target) {\\n      return indexOfMinElement; //directly return it\\'s index\\n    }\\n\\n    start = 0;\\n    end = nums.length - 1;\\n\\n    // if the target element is on the right sorted part, then\\n    if(target < firstElement) {\\n      start = indexOfMinElement; // search from index of minimum element to the end of the array(nums)\\n    } else { // if the target element is on the left side of the sorted array\\n      end = indexOfMinElement - 1; // search from 0 to one previous element from index of minimum element\\n    }\\n\\n    // now as we know which sorted part(left or right) to search, do standard binary search\\n    // search for the index of target if the target is present in the nums, else return -1\\n    return indexOfTarget(nums, start, end, target);\\n  }\\n\\n  // standard binary search\\n  private int indexOfTarget(int[] nums, int start, int end, int target) {\\n\\n    while(start <= end) {\\n\\n      int mid = (start + end) >> 1;\\n\\n      if(nums[mid] == target) {\\n        return mid;\\n      }\\n\\n      if(nums[mid] < target) {\\n        start = mid + 1;\\n      } else {\\n        end = mid - 1;\\n      }\\n    }\\n\\n    return -1;\\n  }\\n}\\n```\n```\\nclass Solution {\\n  public int search(int[] nums, int target) {\\n\\n    int end = nums.length - 1;\\n    if(nums[0] < nums[end]) {\\n      return indexOfTarget(nums, 0, end, target);\\n    }\\n\\n    int start = 0;\\n    int firstElement = nums[0];\\n    while(start < end) {\\n\\n      int mid = (start + end) >> 1;\\n\\n      if(mid > 0 && nums[mid] < nums[mid - 1]) {\\n        start = mid;\\n        break;\\n      }\\n\\n      if(nums[mid] >= firstElement) {\\n        start = mid + 1;\\n      } else {\\n        end = mid;\\n      }\\n    }\\n\\n    int indexOfMinElement = start;\\n    if(nums[indexOfMinElement] == target) {\\n      return indexOfMinElement;\\n    }\\n\\n    start = 0;\\n    end = nums.length - 1;\\n    if(target < firstElement) {\\n      start = indexOfMinElement;\\n    } else {\\n      end = indexOfMinElement - 1;\\n    }\\n\\n    return indexOfTarget(nums, start, end, target);\\n  }\\n\\n  private int indexOfTarget(int[] nums, int start, int end, int target) {\\n\\n    while(start <= end) {\\n\\n      int mid = (start + end) >> 1;\\n\\n      if(nums[mid] == target) {\\n        return mid;\\n      }\\n\\n      if(nums[mid] < target) {\\n        start = mid + 1;\\n      } else {\\n        end = mid - 1;\\n      }\\n    }\\n\\n    return -1;\\n  }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1636185,
                "title": "binary-search-log-n-simple-and-easy-c",
                "content": "Implementation\\n\\n**Using Binary Search\\nTime Complexity = O(LogN), Space Complexity = O(1)**\\n```\\nclass Solution {\\npublic:\\n    int search(vector<int>& nums, int target) {\\n        int left = 0, right = nums.size()-1;\\n        \\n        while(left <= right){\\n            int mid = left + (right-left)/2;\\n            \\n            if(nums[mid] == target) return mid;\\n            \\n            if(nums[left] <= nums[mid]){\\n                if(target >= nums[left] && target <= nums[mid]) right = mid-1;\\n                else left = mid+1;\\n            }\\n            else{\\n                if(target >= nums[mid] && target <= nums[right]) left = mid+1;\\n                else right = mid-1;\\n            }\\n        }\\n        return -1;\\n    }\\n};\\n```\\nIf you find any issue in understanding the solution then comment below, will try to help you.\\nIf you found my solution useful.\\nSo **please do upvote and encourage me** to document all leetcode problems\\uD83D\\uDE03\\nHappy Coding **:)**",
                "solutionTags": [
                    "C",
                    "Array",
                    "Binary Search",
                    "Sorting"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int search(vector<int>& nums, int target) {\\n        int left = 0, right = nums.size()-1;\\n        \\n        while(left <= right){\\n            int mid = left + (right-left)/2;\\n            \\n            if(nums[mid] == target) return mid;\\n            \\n            if(nums[left] <= nums[mid]){\\n                if(target >= nums[left] && target <= nums[mid]) right = mid-1;\\n                else left = mid+1;\\n            }\\n            else{\\n                if(target >= nums[mid] && target <= nums[right]) left = mid+1;\\n                else right = mid-1;\\n            }\\n        }\\n        return -1;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1616520,
                "title": "i-got-the-intuition-behind-the-approach-easy-to-understand",
                "content": "* We can have 2 halves (low to mid & mid to high) of Array if we divided b/w Middle.\\n\\n* We need to check in which side Target can present **But But** we can\\'t check directly by comparing with nums[mid] & Target.\\n\\n* So, We first check which side is Sorted(one of them will sorted) \\n* So,That we can check whether the target lies within that range. If Not, Move to other side of SubArray.\\n\\n\\n```\\nint search(vector<int>& nums, int t) {\\n        int n=nums.size();\\n        \\n        int l=0,h=n-1;\\n        \\n        while(l<=h){\\n            int mid=(l+h)/2;\\n            //check mid==t\\n            if(nums[mid]==t) return mid;\\n            \\n            //check whether left subarray is sorted\\n            else if(nums[l]<=nums[mid]){\\n                //if Yes, check whether Target lies b/w this Range else move to right SubArray\\n                if(t>=nums[l] && t<=nums[mid]){\\n                    h=mid-1;\\n                }else{\\n                    l=mid+1;\\n                }\\n            }\\n            \\n            //same for right array\\n            else{\\n                if(t>=nums[mid] && t<=nums[h]){\\n                    l=mid+1;\\n                }else{\\n                    h=mid-1;\\n                }\\n            }\\n        }\\n        return -1;\\n    }\\n```\\n\\n\\uD83D\\uDC4D\\uD83D\\uDC4D Please upVote",
                "solutionTags": [
                    "C++",
                    "C",
                    "Binary Tree"
                ],
                "code": "```\\nint search(vector<int>& nums, int t) {\\n        int n=nums.size();\\n        \\n        int l=0,h=n-1;\\n        \\n        while(l<=h){\\n            int mid=(l+h)/2;\\n            //check mid==t\\n            if(nums[mid]==t) return mid;\\n            \\n            //check whether left subarray is sorted\\n            else if(nums[l]<=nums[mid]){\\n                //if Yes, check whether Target lies b/w this Range else move to right SubArray\\n                if(t>=nums[l] && t<=nums[mid]){\\n                    h=mid-1;\\n                }else{\\n                    l=mid+1;\\n                }\\n            }\\n            \\n            //same for right array\\n            else{\\n                if(t>=nums[mid] && t<=nums[h]){\\n                    l=mid+1;\\n                }else{\\n                    h=mid-1;\\n                }\\n            }\\n        }\\n        return -1;\\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1519112,
                "title": "c-o-log-n-easy-to-understand-straightforward-c-solution-with-explanation",
                "content": "I have seen a lot of soutions which are over complicated. It\\'s hard to grasp especially for beginners.\\nOkay, let\\'s get into it\\n[ 4, 5, 6, 7, 0, 1, 2 ] // sorted but rotated so, we can\\'t apply binary search directly.\\n- In the array you can see two sorted subarray\\n- when we find the mid in array, we check if  mid == target if so, we return the mid index.\\n- else we check left is sorted ( arr[low] <= arr[mid] ) \\n\\t- if left if sorted we check wether target belongs to left half or right half\\n- if left half is not sorted it gurantees that right half is sorted therefore we check if element belong to right of left half again.\\n\\n```\\nclass Solution {\\npublic:\\n    int search(vector<int>& nums, int target) {\\n        int n = nums.size();\\n        if(n==0)return -1;\\n        \\n        int low =0;\\n        int high = n-1;\\n        while(low <= high){\\n            int mid = low + (high-low)/2;\\n            if(nums[mid]==target){\\n                return mid;\\n            }\\n            \\n            // check if left half is sorted\\n            if(nums[low] <= nums[mid]){\\n                if(target>=nums[low] && target<=nums[mid]){ // check if target belongs to left sorted subarray\\n                    high = mid-1;\\n                }else{\\n                    low = mid+1;\\n                }\\n            }else{\\n                // if left is not sorted it gurantees that right half if sorted\\n                \\n                if(target>=nums[mid] && target<=nums[high]){\\n                    low = mid+1;\\n                }else{\\n                    high = mid-1;\\n                }\\n            }\\n        }\\n        \\n        return -1;\\n    }\\n};\\n\\n```\\n\\n#### Upvote if it has helped you :)",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    int search(vector<int>& nums, int target) {\\n        int n = nums.size();\\n        if(n==0)return -1;\\n        \\n        int low =0;\\n        int high = n-1;\\n        while(low <= high){\\n            int mid = low + (high-low)/2;\\n            if(nums[mid]==target){\\n                return mid;\\n            }\\n            \\n            // check if left half is sorted\\n            if(nums[low] <= nums[mid]){\\n                if(target>=nums[low] && target<=nums[mid]){ // check if target belongs to left sorted subarray\\n                    high = mid-1;\\n                }else{\\n                    low = mid+1;\\n                }\\n            }else{\\n                // if left is not sorted it gurantees that right half if sorted\\n                \\n                if(target>=nums[mid] && target<=nums[high]){\\n                    low = mid+1;\\n                }else{\\n                    high = mid-1;\\n                }\\n            }\\n        }\\n        \\n        return -1;\\n    }\\n};\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1445594,
                "title": "15-line-cpp-code-0ms-by-divide-and-conquer-alorithm",
                "content": "simply apply divide and conquer as we get last element where low and high are same then check that value with target if they match then update isMatch variable is not then simply return from base case\\n\\n```\\nclass Solution {\\npublic:\\n    void helper(vector<int>& nums, int target,int low,int high,int &isMatch){\\n        if(low>high) return;\\n        if(low==high ){\\n            if(target==nums[low])\\n                isMatch=low;\\n            return;\\n        }\\n        int mid=(high-low)/2+low;\\n        if(isMatch==-1 && mid>=0)\\n             helper(nums,target,low,mid,isMatch);\\n        if(isMatch==-1 && mid>=0) \\n            helper(nums,target,mid+1,high,isMatch);\\n            return;\\n    }\\n    \\n    int search(vector<int>& nums, int target) {\\n        int isMatch=-1;\\n        helper(nums,target,0,nums.size()-1,isMatch);\\n        return isMatch;\\n    }\\n};\\n```\\n**I think this code deserve a upvote. thankyou!!**",
                "solutionTags": [
                    "Divide and Conquer",
                    "Binary Tree"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    void helper(vector<int>& nums, int target,int low,int high,int &isMatch){\\n        if(low>high) return;\\n        if(low==high ){\\n            if(target==nums[low])\\n                isMatch=low;\\n            return;\\n        }\\n        int mid=(high-low)/2+low;\\n        if(isMatch==-1 && mid>=0)\\n             helper(nums,target,low,mid,isMatch);\\n        if(isMatch==-1 && mid>=0) \\n            helper(nums,target,mid+1,high,isMatch);\\n            return;\\n    }\\n    \\n    int search(vector<int>& nums, int target) {\\n        int isMatch=-1;\\n        helper(nums,target,0,nums.size()-1,isMatch);\\n        return isMatch;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1424130,
                "title": "100-c-with-explanation",
                "content": "The basic idea is that one half of the array will always be sorted. So check which part is sorted and then check if target is possible to occur in that range, if yes, update the low/high pointers accordingly.\\n\\n```\\nclass Solution {\\npublic:\\n    int search(vector<int>& nums, int target) {\\n        int low=0,high=nums.size()-1;\\n        \\n        while(low<=high)\\n        {\\n            int mid=(low+high)/2;\\n            if(nums[mid]==target)\\n                return mid;\\n            \\n            if(nums[mid]>=nums[low])//left side is sorted\\n            {\\n                if(target<nums[mid] && target>=nums[low])//if left side contains the target (range check)\\n                    high=mid-1;\\n                else//if doesn\\'t contains target, goto right half of the array\\n                    low=mid+1;\\n            }\\n            else//right side is sorted\\n            {\\n                if(target<=nums[high] && target>nums[mid])//if right side contains target\\n                    low=mid+1;\\n                else//else goto left part \\n                    high=mid-1;\\n            }\\n        }\\n        return -1;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "C",
                    "Binary Tree"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int search(vector<int>& nums, int target) {\\n        int low=0,high=nums.size()-1;\\n        \\n        while(low<=high)\\n        {\\n            int mid=(low+high)/2;\\n            if(nums[mid]==target)\\n                return mid;\\n            \\n            if(nums[mid]>=nums[low])//left side is sorted\\n            {\\n                if(target<nums[mid] && target>=nums[low])//if left side contains the target (range check)\\n                    high=mid-1;\\n                else//if doesn\\'t contains target, goto right half of the array\\n                    low=mid+1;\\n            }\\n            else//right side is sorted\\n            {\\n                if(target<=nums[high] && target>nums[mid])//if right side contains target\\n                    low=mid+1;\\n                else//else goto left part \\n                    high=mid-1;\\n            }\\n        }\\n        return -1;\\n    }\\n};\\n```",
                "codeTag": "Java"
            }
        ],
        "discussions": [
            {
                "id": 1567557,
                "content": [
                    {
                        "username": "ss9394",
                        "content": "The problem is intented for Binary search. \\nBut if some is simply travering once  i.e  O(n) , It beats 100% . Which should not be the case. \\n\\nIt should only succeed for binary search based solution. i.e. O(log n)\\n\\n"
                    },
                    {
                        "username": "kaustubhmjb",
                        "content": "Big O notation is asymptotic. An absolute runtime of 2048n is slower than 128n**2, for values of n < 16 (also referred to as n0 in some definitions). Big O notation focuses on rate of change as input size grows arbitrarily."
                    },
                    {
                        "username": "gbiems",
                        "content": "I did binary search, and ran it 3 times, I got 99.5%, 6.3%, and 32%. So I wouldn\\'t put too much stock in the runtime for this.\\n\\nThat said, agreed, surprising you\\'d didn\\'t get a TLE with linear search. "
                    },
                    {
                        "username": "CaptainGalbatrollix",
                        "content": "[@pru_cuder](/pru_cuder) Well that\\'s not true in essence. Yes, big(O) notation is important and leetcode\\'s runtime judgement can be weird and leave a lot to be desired. \\n\\nHowever, it is crucial to remember big(O) is not the end all be all. If the overhead is big enough, for smaller input sizes \\'worse\\' solutions tend to be much more efficient due to factors such as cache locality. For example C++ built in sort switches from quicksort to insertion sort o(n^2) time complexity, when arrays get small enough. \\n\\nIn real life, solving this problem using bsearch would be questionable. Biggest possible size of array in the problem is 5000. If it was 5 * 10^6, then yeah double bsearch is the way to go and can save a lot of time, but you can\\'t honestly tell me a 5000 element loop will be a bottleneck in any system."
                    },
                    {
                        "username": "shivanshutripathii",
                        "content": "Exactly, I\\'ve applied binary search method and it beats only 8.19% in time (O(logn)).\\nWhen I\\'ve applied linear search then it beats 13.60% in time O(n). Crazy things happen."
                    },
                    {
                        "username": "pru_cuder",
                        "content": "those runtimes are based on machine i.e cpu config as well as programming language. Never take these runtimes as a parameter, always focus on Big O notation"
                    },
                    {
                        "username": "mandy1339",
                        "content": "First do a binary search to find the pivot:\\n\\n- Step 1\\n\\t-  compare mid pointer to right most value on the array. If value in mid pointer is greater than right most value in array, we know the pivot is to the right of the mid pointer. If value at mid pointer is smaller than right most value in the array, we know that the pivot is to the left. Split array in half until your left and right pointers touch.\\n- Step 2\\n\\t- Do a 2nd binary search on the whole array. This time we are looking for the target, not a pivot. Now that we know our pivot we just need to modify our midvalue like so: realMid = (mid + pivot) % nums.Length;\\n\\nComplexity of 2 binary searches is O ( 2 Log (n)) which is O (Log(n))"
                    },
                    {
                        "username": "Nitkapur30",
                        "content": "Solution explained: \\nhttps://leetcode.com/problems/search-in-rotated-sorted-array/solutions/3782253/c-binary-search-solution-with-breakdown-of-each-condition/"
                    },
                    {
                        "username": "srapol",
                        "content": "[@Aishwarya_jits](/Aishwarya_jits) how ?"
                    },
                    {
                        "username": "bparanj",
                        "content": "[@shape_mismatch](/shape_mismatch) Actually, both approaches are equally efficient when it comes to handling the case where the array is not pivoted, or sorted. This is because the binary search is performed based on the relationship between the target and the elements at the left, mid, and right positions, not based on whether the array is sorted or not.\\n\\nHowever, comparing with the leftmost element in the array does have an advantage when the array has duplicate values. In case of duplicate values, comparing with the rightmost element might lead to scenarios where we\\'re unable to decide which half of the array to proceed with, thus degrading the performance to O(n) in the worst-case scenario. On the other hand, comparing with the leftmost element can help us avoid such scenarios, thus maintaining a time complexity of O(log n) even when the array contains duplicate values.\\n"
                    },
                    {
                        "username": "Ramonsan07",
                        "content": "was ramdomly checking this problem and  remembered I had solved this in the way you describe https://leetcode.com/problems/search-in-rotated-sorted-array/solutions/3498417/easiest-intuitive-simple-two-binary-searches-solution/"
                    },
                    {
                        "username": "dragon1105",
                        "content": "[@shape_mismatch](/shape_mismatch) I think to compare mid with either the leftmost or the rightmost value is the same, because the probabilities that the pivot is located closer to the left side or to the right side are equal.\\nAnd for the case the array is not pivoted, we just need to check at the beginning whether the leftmost value is less than the rightmost value. If it is, then the array is not pivoted, because if the array is then leftmost must be greater than rightmost."
                    },
                    {
                        "username": "Salominius",
                        "content": "[@lucasscodes](/lucasscodes) 2*O(log n) is NOT O(n) but in fact O(log n).\\nJust as 2 * log n is not n."
                    },
                    {
                        "username": "Aishwarya_jits",
                        "content": "You dont need to do binary search twice, the target can be found in one search by tweaking the binary search code to accommodate for the pivoted element. My point is you dont necessarily have to find the pivot, your code just needs to be aware of its existence. "
                    },
                    {
                        "username": "imankulov53",
                        "content": "thank you for your idea to find pivot on which array is rotated, it\\'s simplifies task and give clear and simple solution"
                    },
                    {
                        "username": "user2748pU",
                        "content": "[@lucasscodes](/lucasscodes) actually what u are saying is wrong, binary search doesn\\'t take n/2 time, it takes log(n) time, so even doing it twice will result in a \"real time\" of 2 times of what it took do do a binary search once (=> 2*log(n)), which will in turn result in O(log(n)), since we ignore constant factors (like the 2*) in big O-Notation."
                    },
                    {
                        "username": "lucasscodes",
                        "content": "This has O(n) complexity.\\n2 times n/2 => n.\\nDont even mind binary search if you need to do it twice..."
                    },
                    {
                        "username": "spencerreitz2002",
                        "content": "[@shape_mismatch](/shape_mismatch) I believe the opposite it true. If the array is pivoted one place to the left, the number at the leftmost position of the array is less than the middle, but the rightmost point is now less than the middle also."
                    },
                    {
                        "username": "_arjan31",
                        "content": "To get it in log(N) complexity , follow strivers method"
                    },
                    {
                        "username": "shape_mismatch",
                        "content": "Wouldn\\'t it be better to compare with the leftmost value in the array (step 1), instead of the rightmost. It would be faster in taking care of cases where the array is not pivoted?"
                    },
                    {
                        "username": "charly371",
                        "content": "I get an error with the following test case: ([1,3], 1) which should output 0 since the integer 1 is present at index 0. \\nMy solution did not work for this one because I based it on the fact that the array will get rotate somewhere. \\n\\nI m thus wondering if you think this test case is valid ? or maybe the exercise should be change to say that the array may be rotated (but not necessarily is...) ?\\n\\nI will change my algo but i would like your feedback in case it was a real interview. what would you say ?\\nThx"
                    },
                    {
                        "username": "olsonpm",
                        "content": "[@vaishali_p14](/vaishali_p14) It also doesn\\'t say what to return in the case it\\'s not rotated\\n\\n> return the index of target if it is in nums, or -1 if it is not in nums"
                    },
                    {
                        "username": "GitG0",
                        "content": "people in 2023 answering a question asked in 2017 without knowing if the constraints or the question itself were modified in those ~6 years lol "
                    },
                    {
                        "username": "raghavsharmaji",
                        "content": "What do you think is meant by \"is possibly rotated\"?"
                    },
                    {
                        "username": "devansh10z",
                        "content": "suppose a case where an array of length n is rotated n times. you get the same array. that is the only reason this test case is a valid case."
                    },
                    {
                        "username": "AHawkeye",
                        "content": "[@vaishali_p14](/vaishali_p14)  But in the description, is says that k >= 1, which means the arrayed must be rotated."
                    },
                    {
                        "username": "sanjay2207",
                        "content": "You may not be checking one of <= or >= conditions correctly. I ran into same issue."
                    },
                    {
                        "username": "vaishali_p14",
                        "content": "In the question, it is mentioned that the passed array is sorted and POSSIBLY rotated."
                    },
                    {
                        "username": "hafezachu",
                        "content": "The main idea is to use binary search to find the target in the array. Binary search is a technique that divides the search space into two halves and compares the target with the middle element. If the target is equal to the middle element, we have found the index. If the target is smaller than the middle element, we search in the left half. If the target is larger than the middle element, we search in the right half. This way, we can reduce the search space by half in each iteration and achieve O(log n) runtime complexity.\\n\\nHowever, since the array is possibly rotated at some unknown pivot, we cannot directly apply binary search. We need to modify it slightly to handle the rotation. The key observation is that one of the two halves must be sorted, and the other half must contain the pivot. For example, if the array is [4,5,6,7,0,1,2], then the left half [4,5,6,7] is sorted and the right half [0,1,2] contains the pivot. If the array is [7,0,1,2,4,5,6], then the right half [2,4,5,6] is sorted and the left half [7,0,1] contains the pivot.\\n\\nSo, in each iteration of binary search, we first check which half is sorted by comparing the left and middle elements. Then we check if the target is in that sorted half by comparing it with the left and middle elements. If it is in that sorted half, we search in that half as usual. If it is not in that sorted half, we search in the other half that contains the pivot.\\n\\nFor example, if the array is [4,5,6,7,0,1,2] and the target is 0:\\n\\n- We start with left = 0 and right = 6. The middle index is 3 and the middle element is 7.\\n- We see that the left half [4,5,6,7] is sorted and the right half [0,1,2] contains the pivot.\\n- We check if the target 0 is in the left half by comparing it with 4 and 7. It is not in that half because 0 < 4 < 7.\\n- So we search in the right half that contains the pivot by setting left = mid + 1 = 4.\\n- We repeat this process until we find the target or exhaust the search space."
                    },
                    {
                        "username": "dragon1105",
                        "content": "Thank you. This is probably the most elegant way to solve this problem. With this solution, we don\\'t even need to find the pivot\\'s location, which is quite smart."
                    },
                    {
                        "username": "jackbb147",
                        "content": "thank you. Great explanation"
                    },
                    {
                        "username": "eugk123",
                        "content": "Why is there a [1,3,5] test case?\\n\\nIt\\'s not that big of a deal, but the problem states it guarantee\\'s pivot in all test cases. Leetcode team, please either remove that statement or fix your test case."
                    },
                    {
                        "username": "amansingh4958",
                        "content": "Just avoid finding pivot for these cases by just comparing 1st and last element of the array"
                    },
                    {
                        "username": "heyyyankit",
                        "content": "[@pranavagrawal321](/pranavagrawal321)its given that ( 1 <= k < nums.length) so this is not possible..."
                    },
                    {
                        "username": "Gautamparti",
                        "content": "question clearly states \"possibly rotated\" , which means you have to include a case where their is no pivot"
                    },
                    {
                        "username": "mrunfunny",
                        "content": "[@pranavagrawal321](/pranavagrawal321) That\\'s one way to look at this :XD"
                    },
                    {
                        "username": "pranavagrawal321",
                        "content": "The test case is correct, since the array can be rotated thrice, resulting in the original sorted array."
                    },
                    {
                        "username": "brauliojde",
                        "content": "I believe that there is an error in one of the test cases because the array that is entered is [1,3] and in this array there is no rotation. "
                    },
                    {
                        "username": "vaishali_p14",
                        "content": "In the question, it is mentioned that the passed array is sorted and POSSIBLY rotated.\\n\\n"
                    },
                    {
                        "username": "Yanlin0408",
                        "content": "[@lakshminathan](/lakshminathan) lmao"
                    },
                    {
                        "username": "lakshminathan",
                        "content": "it is rotated twice"
                    },
                    {
                        "username": "euphoria_kiki",
                        "content": "The key idea is during the process fo binary search, we compare the number at position mid and position left. If the number at mid is larger, it implies that range [left, mid] is ordered (not rotated), so we can decide whether to move towards that range for further search. Otherwise, the number at mid is smaller, which implies that range [mid, right] is ordered (not rotated)."
                    },
                    {
                        "username": "Spam_Musubi",
                        "content": "nice, I was wondering why this was on the medium side, they should\\'ve made something to make this harder and for us to naturally come up with the binary search.\\n"
                    },
                    {
                        "username": "insomniachou",
                        "content": "I don't think this problem is for JS. I saw someone's (n + logn) solution, was wondering why not just compare one by one, resulting in O(n). Not sure the question is asking the index in the sorted array or in the rotated array.  I tried js build-in array method, and surprisingly my answer passed and beats 60%.  \\n\\n\\tvar search = function(nums, target) {\\n\\t\\treturn nums.indexOf(target);\\n\\t};"
                    },
                    {
                        "username": "danielmascena",
                        "content": "doesnt matter the programming language but the approach used"
                    },
                    {
                        "username": "rohiinegi2002",
                        "content": "it will pass... Cause you are using a function that runs of O(logn) time complexity and is called Binary Search..(^ ^)"
                    },
                    {
                        "username": "normanlmfung",
                        "content": "Same in pyton: def search(self, nums: List[int], target: int) -> int:\\n        if target in nums:\\n            return nums.index(target)\\n        else:\\n            return -1"
                    },
                    {
                        "username": "ladiaz4e98",
                        "content": "this is wrong. this is o(n), question is asking for o(log(n)).."
                    },
                    {
                        "username": "thedevwonder",
                        "content": "JS solution in O(logn) works, my answer beats 90%. I think it is independent of programming lang as long as you don\\'t use built in functions"
                    },
                    {
                        "username": "mohaymenrafi",
                        "content": "[@christinehong](/christinehong) when you use indexOf method, in worse case, it actually traverse the entire array which is O(n) operation. but in the question it specifically mentioned to use O(log n)"
                    },
                    {
                        "username": "christinehong",
                        "content": "that was literally my line of logic and i ended up with the same solution but in python"
                    },
                    {
                        "username": "gurnainwadhwa",
                        "content": "Just Binary Search"
                    },
                    {
                        "username": "anwendeng",
                        "content": "This problem is solved by using binary search several times.\nFirstly, it is suggested to find the location for the peak which can be done by binary search. \nSecondly, using  binary search to find location for the target  which  is possible before the peak or after the peak.\n\n# Be careful for the boundary cases when n=1 and n=2."
                    }
                ]
            },
            {
                "id": 1576279,
                "content": [
                    {
                        "username": "ss9394",
                        "content": "The problem is intented for Binary search. \\nBut if some is simply travering once  i.e  O(n) , It beats 100% . Which should not be the case. \\n\\nIt should only succeed for binary search based solution. i.e. O(log n)\\n\\n"
                    },
                    {
                        "username": "kaustubhmjb",
                        "content": "Big O notation is asymptotic. An absolute runtime of 2048n is slower than 128n**2, for values of n < 16 (also referred to as n0 in some definitions). Big O notation focuses on rate of change as input size grows arbitrarily."
                    },
                    {
                        "username": "gbiems",
                        "content": "I did binary search, and ran it 3 times, I got 99.5%, 6.3%, and 32%. So I wouldn\\'t put too much stock in the runtime for this.\\n\\nThat said, agreed, surprising you\\'d didn\\'t get a TLE with linear search. "
                    },
                    {
                        "username": "CaptainGalbatrollix",
                        "content": "[@pru_cuder](/pru_cuder) Well that\\'s not true in essence. Yes, big(O) notation is important and leetcode\\'s runtime judgement can be weird and leave a lot to be desired. \\n\\nHowever, it is crucial to remember big(O) is not the end all be all. If the overhead is big enough, for smaller input sizes \\'worse\\' solutions tend to be much more efficient due to factors such as cache locality. For example C++ built in sort switches from quicksort to insertion sort o(n^2) time complexity, when arrays get small enough. \\n\\nIn real life, solving this problem using bsearch would be questionable. Biggest possible size of array in the problem is 5000. If it was 5 * 10^6, then yeah double bsearch is the way to go and can save a lot of time, but you can\\'t honestly tell me a 5000 element loop will be a bottleneck in any system."
                    },
                    {
                        "username": "shivanshutripathii",
                        "content": "Exactly, I\\'ve applied binary search method and it beats only 8.19% in time (O(logn)).\\nWhen I\\'ve applied linear search then it beats 13.60% in time O(n). Crazy things happen."
                    },
                    {
                        "username": "pru_cuder",
                        "content": "those runtimes are based on machine i.e cpu config as well as programming language. Never take these runtimes as a parameter, always focus on Big O notation"
                    },
                    {
                        "username": "mandy1339",
                        "content": "First do a binary search to find the pivot:\\n\\n- Step 1\\n\\t-  compare mid pointer to right most value on the array. If value in mid pointer is greater than right most value in array, we know the pivot is to the right of the mid pointer. If value at mid pointer is smaller than right most value in the array, we know that the pivot is to the left. Split array in half until your left and right pointers touch.\\n- Step 2\\n\\t- Do a 2nd binary search on the whole array. This time we are looking for the target, not a pivot. Now that we know our pivot we just need to modify our midvalue like so: realMid = (mid + pivot) % nums.Length;\\n\\nComplexity of 2 binary searches is O ( 2 Log (n)) which is O (Log(n))"
                    },
                    {
                        "username": "Nitkapur30",
                        "content": "Solution explained: \\nhttps://leetcode.com/problems/search-in-rotated-sorted-array/solutions/3782253/c-binary-search-solution-with-breakdown-of-each-condition/"
                    },
                    {
                        "username": "srapol",
                        "content": "[@Aishwarya_jits](/Aishwarya_jits) how ?"
                    },
                    {
                        "username": "bparanj",
                        "content": "[@shape_mismatch](/shape_mismatch) Actually, both approaches are equally efficient when it comes to handling the case where the array is not pivoted, or sorted. This is because the binary search is performed based on the relationship between the target and the elements at the left, mid, and right positions, not based on whether the array is sorted or not.\\n\\nHowever, comparing with the leftmost element in the array does have an advantage when the array has duplicate values. In case of duplicate values, comparing with the rightmost element might lead to scenarios where we\\'re unable to decide which half of the array to proceed with, thus degrading the performance to O(n) in the worst-case scenario. On the other hand, comparing with the leftmost element can help us avoid such scenarios, thus maintaining a time complexity of O(log n) even when the array contains duplicate values.\\n"
                    },
                    {
                        "username": "Ramonsan07",
                        "content": "was ramdomly checking this problem and  remembered I had solved this in the way you describe https://leetcode.com/problems/search-in-rotated-sorted-array/solutions/3498417/easiest-intuitive-simple-two-binary-searches-solution/"
                    },
                    {
                        "username": "dragon1105",
                        "content": "[@shape_mismatch](/shape_mismatch) I think to compare mid with either the leftmost or the rightmost value is the same, because the probabilities that the pivot is located closer to the left side or to the right side are equal.\\nAnd for the case the array is not pivoted, we just need to check at the beginning whether the leftmost value is less than the rightmost value. If it is, then the array is not pivoted, because if the array is then leftmost must be greater than rightmost."
                    },
                    {
                        "username": "Salominius",
                        "content": "[@lucasscodes](/lucasscodes) 2*O(log n) is NOT O(n) but in fact O(log n).\\nJust as 2 * log n is not n."
                    },
                    {
                        "username": "Aishwarya_jits",
                        "content": "You dont need to do binary search twice, the target can be found in one search by tweaking the binary search code to accommodate for the pivoted element. My point is you dont necessarily have to find the pivot, your code just needs to be aware of its existence. "
                    },
                    {
                        "username": "imankulov53",
                        "content": "thank you for your idea to find pivot on which array is rotated, it\\'s simplifies task and give clear and simple solution"
                    },
                    {
                        "username": "user2748pU",
                        "content": "[@lucasscodes](/lucasscodes) actually what u are saying is wrong, binary search doesn\\'t take n/2 time, it takes log(n) time, so even doing it twice will result in a \"real time\" of 2 times of what it took do do a binary search once (=> 2*log(n)), which will in turn result in O(log(n)), since we ignore constant factors (like the 2*) in big O-Notation."
                    },
                    {
                        "username": "lucasscodes",
                        "content": "This has O(n) complexity.\\n2 times n/2 => n.\\nDont even mind binary search if you need to do it twice..."
                    },
                    {
                        "username": "spencerreitz2002",
                        "content": "[@shape_mismatch](/shape_mismatch) I believe the opposite it true. If the array is pivoted one place to the left, the number at the leftmost position of the array is less than the middle, but the rightmost point is now less than the middle also."
                    },
                    {
                        "username": "_arjan31",
                        "content": "To get it in log(N) complexity , follow strivers method"
                    },
                    {
                        "username": "shape_mismatch",
                        "content": "Wouldn\\'t it be better to compare with the leftmost value in the array (step 1), instead of the rightmost. It would be faster in taking care of cases where the array is not pivoted?"
                    },
                    {
                        "username": "charly371",
                        "content": "I get an error with the following test case: ([1,3], 1) which should output 0 since the integer 1 is present at index 0. \\nMy solution did not work for this one because I based it on the fact that the array will get rotate somewhere. \\n\\nI m thus wondering if you think this test case is valid ? or maybe the exercise should be change to say that the array may be rotated (but not necessarily is...) ?\\n\\nI will change my algo but i would like your feedback in case it was a real interview. what would you say ?\\nThx"
                    },
                    {
                        "username": "olsonpm",
                        "content": "[@vaishali_p14](/vaishali_p14) It also doesn\\'t say what to return in the case it\\'s not rotated\\n\\n> return the index of target if it is in nums, or -1 if it is not in nums"
                    },
                    {
                        "username": "GitG0",
                        "content": "people in 2023 answering a question asked in 2017 without knowing if the constraints or the question itself were modified in those ~6 years lol "
                    },
                    {
                        "username": "raghavsharmaji",
                        "content": "What do you think is meant by \"is possibly rotated\"?"
                    },
                    {
                        "username": "devansh10z",
                        "content": "suppose a case where an array of length n is rotated n times. you get the same array. that is the only reason this test case is a valid case."
                    },
                    {
                        "username": "AHawkeye",
                        "content": "[@vaishali_p14](/vaishali_p14)  But in the description, is says that k >= 1, which means the arrayed must be rotated."
                    },
                    {
                        "username": "sanjay2207",
                        "content": "You may not be checking one of <= or >= conditions correctly. I ran into same issue."
                    },
                    {
                        "username": "vaishali_p14",
                        "content": "In the question, it is mentioned that the passed array is sorted and POSSIBLY rotated."
                    },
                    {
                        "username": "hafezachu",
                        "content": "The main idea is to use binary search to find the target in the array. Binary search is a technique that divides the search space into two halves and compares the target with the middle element. If the target is equal to the middle element, we have found the index. If the target is smaller than the middle element, we search in the left half. If the target is larger than the middle element, we search in the right half. This way, we can reduce the search space by half in each iteration and achieve O(log n) runtime complexity.\\n\\nHowever, since the array is possibly rotated at some unknown pivot, we cannot directly apply binary search. We need to modify it slightly to handle the rotation. The key observation is that one of the two halves must be sorted, and the other half must contain the pivot. For example, if the array is [4,5,6,7,0,1,2], then the left half [4,5,6,7] is sorted and the right half [0,1,2] contains the pivot. If the array is [7,0,1,2,4,5,6], then the right half [2,4,5,6] is sorted and the left half [7,0,1] contains the pivot.\\n\\nSo, in each iteration of binary search, we first check which half is sorted by comparing the left and middle elements. Then we check if the target is in that sorted half by comparing it with the left and middle elements. If it is in that sorted half, we search in that half as usual. If it is not in that sorted half, we search in the other half that contains the pivot.\\n\\nFor example, if the array is [4,5,6,7,0,1,2] and the target is 0:\\n\\n- We start with left = 0 and right = 6. The middle index is 3 and the middle element is 7.\\n- We see that the left half [4,5,6,7] is sorted and the right half [0,1,2] contains the pivot.\\n- We check if the target 0 is in the left half by comparing it with 4 and 7. It is not in that half because 0 < 4 < 7.\\n- So we search in the right half that contains the pivot by setting left = mid + 1 = 4.\\n- We repeat this process until we find the target or exhaust the search space."
                    },
                    {
                        "username": "dragon1105",
                        "content": "Thank you. This is probably the most elegant way to solve this problem. With this solution, we don\\'t even need to find the pivot\\'s location, which is quite smart."
                    },
                    {
                        "username": "jackbb147",
                        "content": "thank you. Great explanation"
                    },
                    {
                        "username": "eugk123",
                        "content": "Why is there a [1,3,5] test case?\\n\\nIt\\'s not that big of a deal, but the problem states it guarantee\\'s pivot in all test cases. Leetcode team, please either remove that statement or fix your test case."
                    },
                    {
                        "username": "amansingh4958",
                        "content": "Just avoid finding pivot for these cases by just comparing 1st and last element of the array"
                    },
                    {
                        "username": "heyyyankit",
                        "content": "[@pranavagrawal321](/pranavagrawal321)its given that ( 1 <= k < nums.length) so this is not possible..."
                    },
                    {
                        "username": "Gautamparti",
                        "content": "question clearly states \"possibly rotated\" , which means you have to include a case where their is no pivot"
                    },
                    {
                        "username": "mrunfunny",
                        "content": "[@pranavagrawal321](/pranavagrawal321) That\\'s one way to look at this :XD"
                    },
                    {
                        "username": "pranavagrawal321",
                        "content": "The test case is correct, since the array can be rotated thrice, resulting in the original sorted array."
                    },
                    {
                        "username": "brauliojde",
                        "content": "I believe that there is an error in one of the test cases because the array that is entered is [1,3] and in this array there is no rotation. "
                    },
                    {
                        "username": "vaishali_p14",
                        "content": "In the question, it is mentioned that the passed array is sorted and POSSIBLY rotated.\\n\\n"
                    },
                    {
                        "username": "Yanlin0408",
                        "content": "[@lakshminathan](/lakshminathan) lmao"
                    },
                    {
                        "username": "lakshminathan",
                        "content": "it is rotated twice"
                    },
                    {
                        "username": "euphoria_kiki",
                        "content": "The key idea is during the process fo binary search, we compare the number at position mid and position left. If the number at mid is larger, it implies that range [left, mid] is ordered (not rotated), so we can decide whether to move towards that range for further search. Otherwise, the number at mid is smaller, which implies that range [mid, right] is ordered (not rotated)."
                    },
                    {
                        "username": "Spam_Musubi",
                        "content": "nice, I was wondering why this was on the medium side, they should\\'ve made something to make this harder and for us to naturally come up with the binary search.\\n"
                    },
                    {
                        "username": "insomniachou",
                        "content": "I don't think this problem is for JS. I saw someone's (n + logn) solution, was wondering why not just compare one by one, resulting in O(n). Not sure the question is asking the index in the sorted array or in the rotated array.  I tried js build-in array method, and surprisingly my answer passed and beats 60%.  \\n\\n\\tvar search = function(nums, target) {\\n\\t\\treturn nums.indexOf(target);\\n\\t};"
                    },
                    {
                        "username": "danielmascena",
                        "content": "doesnt matter the programming language but the approach used"
                    },
                    {
                        "username": "rohiinegi2002",
                        "content": "it will pass... Cause you are using a function that runs of O(logn) time complexity and is called Binary Search..(^ ^)"
                    },
                    {
                        "username": "normanlmfung",
                        "content": "Same in pyton: def search(self, nums: List[int], target: int) -> int:\\n        if target in nums:\\n            return nums.index(target)\\n        else:\\n            return -1"
                    },
                    {
                        "username": "ladiaz4e98",
                        "content": "this is wrong. this is o(n), question is asking for o(log(n)).."
                    },
                    {
                        "username": "thedevwonder",
                        "content": "JS solution in O(logn) works, my answer beats 90%. I think it is independent of programming lang as long as you don\\'t use built in functions"
                    },
                    {
                        "username": "mohaymenrafi",
                        "content": "[@christinehong](/christinehong) when you use indexOf method, in worse case, it actually traverse the entire array which is O(n) operation. but in the question it specifically mentioned to use O(log n)"
                    },
                    {
                        "username": "christinehong",
                        "content": "that was literally my line of logic and i ended up with the same solution but in python"
                    },
                    {
                        "username": "gurnainwadhwa",
                        "content": "Just Binary Search"
                    },
                    {
                        "username": "anwendeng",
                        "content": "This problem is solved by using binary search several times.\nFirstly, it is suggested to find the location for the peak which can be done by binary search. \nSecondly, using  binary search to find location for the target  which  is possible before the peak or after the peak.\n\n# Be careful for the boundary cases when n=1 and n=2."
                    }
                ]
            },
            {
                "id": 1565736,
                "content": [
                    {
                        "username": "ss9394",
                        "content": "The problem is intented for Binary search. \\nBut if some is simply travering once  i.e  O(n) , It beats 100% . Which should not be the case. \\n\\nIt should only succeed for binary search based solution. i.e. O(log n)\\n\\n"
                    },
                    {
                        "username": "kaustubhmjb",
                        "content": "Big O notation is asymptotic. An absolute runtime of 2048n is slower than 128n**2, for values of n < 16 (also referred to as n0 in some definitions). Big O notation focuses on rate of change as input size grows arbitrarily."
                    },
                    {
                        "username": "gbiems",
                        "content": "I did binary search, and ran it 3 times, I got 99.5%, 6.3%, and 32%. So I wouldn\\'t put too much stock in the runtime for this.\\n\\nThat said, agreed, surprising you\\'d didn\\'t get a TLE with linear search. "
                    },
                    {
                        "username": "CaptainGalbatrollix",
                        "content": "[@pru_cuder](/pru_cuder) Well that\\'s not true in essence. Yes, big(O) notation is important and leetcode\\'s runtime judgement can be weird and leave a lot to be desired. \\n\\nHowever, it is crucial to remember big(O) is not the end all be all. If the overhead is big enough, for smaller input sizes \\'worse\\' solutions tend to be much more efficient due to factors such as cache locality. For example C++ built in sort switches from quicksort to insertion sort o(n^2) time complexity, when arrays get small enough. \\n\\nIn real life, solving this problem using bsearch would be questionable. Biggest possible size of array in the problem is 5000. If it was 5 * 10^6, then yeah double bsearch is the way to go and can save a lot of time, but you can\\'t honestly tell me a 5000 element loop will be a bottleneck in any system."
                    },
                    {
                        "username": "shivanshutripathii",
                        "content": "Exactly, I\\'ve applied binary search method and it beats only 8.19% in time (O(logn)).\\nWhen I\\'ve applied linear search then it beats 13.60% in time O(n). Crazy things happen."
                    },
                    {
                        "username": "pru_cuder",
                        "content": "those runtimes are based on machine i.e cpu config as well as programming language. Never take these runtimes as a parameter, always focus on Big O notation"
                    },
                    {
                        "username": "mandy1339",
                        "content": "First do a binary search to find the pivot:\\n\\n- Step 1\\n\\t-  compare mid pointer to right most value on the array. If value in mid pointer is greater than right most value in array, we know the pivot is to the right of the mid pointer. If value at mid pointer is smaller than right most value in the array, we know that the pivot is to the left. Split array in half until your left and right pointers touch.\\n- Step 2\\n\\t- Do a 2nd binary search on the whole array. This time we are looking for the target, not a pivot. Now that we know our pivot we just need to modify our midvalue like so: realMid = (mid + pivot) % nums.Length;\\n\\nComplexity of 2 binary searches is O ( 2 Log (n)) which is O (Log(n))"
                    },
                    {
                        "username": "Nitkapur30",
                        "content": "Solution explained: \\nhttps://leetcode.com/problems/search-in-rotated-sorted-array/solutions/3782253/c-binary-search-solution-with-breakdown-of-each-condition/"
                    },
                    {
                        "username": "srapol",
                        "content": "[@Aishwarya_jits](/Aishwarya_jits) how ?"
                    },
                    {
                        "username": "bparanj",
                        "content": "[@shape_mismatch](/shape_mismatch) Actually, both approaches are equally efficient when it comes to handling the case where the array is not pivoted, or sorted. This is because the binary search is performed based on the relationship between the target and the elements at the left, mid, and right positions, not based on whether the array is sorted or not.\\n\\nHowever, comparing with the leftmost element in the array does have an advantage when the array has duplicate values. In case of duplicate values, comparing with the rightmost element might lead to scenarios where we\\'re unable to decide which half of the array to proceed with, thus degrading the performance to O(n) in the worst-case scenario. On the other hand, comparing with the leftmost element can help us avoid such scenarios, thus maintaining a time complexity of O(log n) even when the array contains duplicate values.\\n"
                    },
                    {
                        "username": "Ramonsan07",
                        "content": "was ramdomly checking this problem and  remembered I had solved this in the way you describe https://leetcode.com/problems/search-in-rotated-sorted-array/solutions/3498417/easiest-intuitive-simple-two-binary-searches-solution/"
                    },
                    {
                        "username": "dragon1105",
                        "content": "[@shape_mismatch](/shape_mismatch) I think to compare mid with either the leftmost or the rightmost value is the same, because the probabilities that the pivot is located closer to the left side or to the right side are equal.\\nAnd for the case the array is not pivoted, we just need to check at the beginning whether the leftmost value is less than the rightmost value. If it is, then the array is not pivoted, because if the array is then leftmost must be greater than rightmost."
                    },
                    {
                        "username": "Salominius",
                        "content": "[@lucasscodes](/lucasscodes) 2*O(log n) is NOT O(n) but in fact O(log n).\\nJust as 2 * log n is not n."
                    },
                    {
                        "username": "Aishwarya_jits",
                        "content": "You dont need to do binary search twice, the target can be found in one search by tweaking the binary search code to accommodate for the pivoted element. My point is you dont necessarily have to find the pivot, your code just needs to be aware of its existence. "
                    },
                    {
                        "username": "imankulov53",
                        "content": "thank you for your idea to find pivot on which array is rotated, it\\'s simplifies task and give clear and simple solution"
                    },
                    {
                        "username": "user2748pU",
                        "content": "[@lucasscodes](/lucasscodes) actually what u are saying is wrong, binary search doesn\\'t take n/2 time, it takes log(n) time, so even doing it twice will result in a \"real time\" of 2 times of what it took do do a binary search once (=> 2*log(n)), which will in turn result in O(log(n)), since we ignore constant factors (like the 2*) in big O-Notation."
                    },
                    {
                        "username": "lucasscodes",
                        "content": "This has O(n) complexity.\\n2 times n/2 => n.\\nDont even mind binary search if you need to do it twice..."
                    },
                    {
                        "username": "spencerreitz2002",
                        "content": "[@shape_mismatch](/shape_mismatch) I believe the opposite it true. If the array is pivoted one place to the left, the number at the leftmost position of the array is less than the middle, but the rightmost point is now less than the middle also."
                    },
                    {
                        "username": "_arjan31",
                        "content": "To get it in log(N) complexity , follow strivers method"
                    },
                    {
                        "username": "shape_mismatch",
                        "content": "Wouldn\\'t it be better to compare with the leftmost value in the array (step 1), instead of the rightmost. It would be faster in taking care of cases where the array is not pivoted?"
                    },
                    {
                        "username": "charly371",
                        "content": "I get an error with the following test case: ([1,3], 1) which should output 0 since the integer 1 is present at index 0. \\nMy solution did not work for this one because I based it on the fact that the array will get rotate somewhere. \\n\\nI m thus wondering if you think this test case is valid ? or maybe the exercise should be change to say that the array may be rotated (but not necessarily is...) ?\\n\\nI will change my algo but i would like your feedback in case it was a real interview. what would you say ?\\nThx"
                    },
                    {
                        "username": "olsonpm",
                        "content": "[@vaishali_p14](/vaishali_p14) It also doesn\\'t say what to return in the case it\\'s not rotated\\n\\n> return the index of target if it is in nums, or -1 if it is not in nums"
                    },
                    {
                        "username": "GitG0",
                        "content": "people in 2023 answering a question asked in 2017 without knowing if the constraints or the question itself were modified in those ~6 years lol "
                    },
                    {
                        "username": "raghavsharmaji",
                        "content": "What do you think is meant by \"is possibly rotated\"?"
                    },
                    {
                        "username": "devansh10z",
                        "content": "suppose a case where an array of length n is rotated n times. you get the same array. that is the only reason this test case is a valid case."
                    },
                    {
                        "username": "AHawkeye",
                        "content": "[@vaishali_p14](/vaishali_p14)  But in the description, is says that k >= 1, which means the arrayed must be rotated."
                    },
                    {
                        "username": "sanjay2207",
                        "content": "You may not be checking one of <= or >= conditions correctly. I ran into same issue."
                    },
                    {
                        "username": "vaishali_p14",
                        "content": "In the question, it is mentioned that the passed array is sorted and POSSIBLY rotated."
                    },
                    {
                        "username": "hafezachu",
                        "content": "The main idea is to use binary search to find the target in the array. Binary search is a technique that divides the search space into two halves and compares the target with the middle element. If the target is equal to the middle element, we have found the index. If the target is smaller than the middle element, we search in the left half. If the target is larger than the middle element, we search in the right half. This way, we can reduce the search space by half in each iteration and achieve O(log n) runtime complexity.\\n\\nHowever, since the array is possibly rotated at some unknown pivot, we cannot directly apply binary search. We need to modify it slightly to handle the rotation. The key observation is that one of the two halves must be sorted, and the other half must contain the pivot. For example, if the array is [4,5,6,7,0,1,2], then the left half [4,5,6,7] is sorted and the right half [0,1,2] contains the pivot. If the array is [7,0,1,2,4,5,6], then the right half [2,4,5,6] is sorted and the left half [7,0,1] contains the pivot.\\n\\nSo, in each iteration of binary search, we first check which half is sorted by comparing the left and middle elements. Then we check if the target is in that sorted half by comparing it with the left and middle elements. If it is in that sorted half, we search in that half as usual. If it is not in that sorted half, we search in the other half that contains the pivot.\\n\\nFor example, if the array is [4,5,6,7,0,1,2] and the target is 0:\\n\\n- We start with left = 0 and right = 6. The middle index is 3 and the middle element is 7.\\n- We see that the left half [4,5,6,7] is sorted and the right half [0,1,2] contains the pivot.\\n- We check if the target 0 is in the left half by comparing it with 4 and 7. It is not in that half because 0 < 4 < 7.\\n- So we search in the right half that contains the pivot by setting left = mid + 1 = 4.\\n- We repeat this process until we find the target or exhaust the search space."
                    },
                    {
                        "username": "dragon1105",
                        "content": "Thank you. This is probably the most elegant way to solve this problem. With this solution, we don\\'t even need to find the pivot\\'s location, which is quite smart."
                    },
                    {
                        "username": "jackbb147",
                        "content": "thank you. Great explanation"
                    },
                    {
                        "username": "eugk123",
                        "content": "Why is there a [1,3,5] test case?\\n\\nIt\\'s not that big of a deal, but the problem states it guarantee\\'s pivot in all test cases. Leetcode team, please either remove that statement or fix your test case."
                    },
                    {
                        "username": "amansingh4958",
                        "content": "Just avoid finding pivot for these cases by just comparing 1st and last element of the array"
                    },
                    {
                        "username": "heyyyankit",
                        "content": "[@pranavagrawal321](/pranavagrawal321)its given that ( 1 <= k < nums.length) so this is not possible..."
                    },
                    {
                        "username": "Gautamparti",
                        "content": "question clearly states \"possibly rotated\" , which means you have to include a case where their is no pivot"
                    },
                    {
                        "username": "mrunfunny",
                        "content": "[@pranavagrawal321](/pranavagrawal321) That\\'s one way to look at this :XD"
                    },
                    {
                        "username": "pranavagrawal321",
                        "content": "The test case is correct, since the array can be rotated thrice, resulting in the original sorted array."
                    },
                    {
                        "username": "brauliojde",
                        "content": "I believe that there is an error in one of the test cases because the array that is entered is [1,3] and in this array there is no rotation. "
                    },
                    {
                        "username": "vaishali_p14",
                        "content": "In the question, it is mentioned that the passed array is sorted and POSSIBLY rotated.\\n\\n"
                    },
                    {
                        "username": "Yanlin0408",
                        "content": "[@lakshminathan](/lakshminathan) lmao"
                    },
                    {
                        "username": "lakshminathan",
                        "content": "it is rotated twice"
                    },
                    {
                        "username": "euphoria_kiki",
                        "content": "The key idea is during the process fo binary search, we compare the number at position mid and position left. If the number at mid is larger, it implies that range [left, mid] is ordered (not rotated), so we can decide whether to move towards that range for further search. Otherwise, the number at mid is smaller, which implies that range [mid, right] is ordered (not rotated)."
                    },
                    {
                        "username": "Spam_Musubi",
                        "content": "nice, I was wondering why this was on the medium side, they should\\'ve made something to make this harder and for us to naturally come up with the binary search.\\n"
                    },
                    {
                        "username": "insomniachou",
                        "content": "I don't think this problem is for JS. I saw someone's (n + logn) solution, was wondering why not just compare one by one, resulting in O(n). Not sure the question is asking the index in the sorted array or in the rotated array.  I tried js build-in array method, and surprisingly my answer passed and beats 60%.  \\n\\n\\tvar search = function(nums, target) {\\n\\t\\treturn nums.indexOf(target);\\n\\t};"
                    },
                    {
                        "username": "danielmascena",
                        "content": "doesnt matter the programming language but the approach used"
                    },
                    {
                        "username": "rohiinegi2002",
                        "content": "it will pass... Cause you are using a function that runs of O(logn) time complexity and is called Binary Search..(^ ^)"
                    },
                    {
                        "username": "normanlmfung",
                        "content": "Same in pyton: def search(self, nums: List[int], target: int) -> int:\\n        if target in nums:\\n            return nums.index(target)\\n        else:\\n            return -1"
                    },
                    {
                        "username": "ladiaz4e98",
                        "content": "this is wrong. this is o(n), question is asking for o(log(n)).."
                    },
                    {
                        "username": "thedevwonder",
                        "content": "JS solution in O(logn) works, my answer beats 90%. I think it is independent of programming lang as long as you don\\'t use built in functions"
                    },
                    {
                        "username": "mohaymenrafi",
                        "content": "[@christinehong](/christinehong) when you use indexOf method, in worse case, it actually traverse the entire array which is O(n) operation. but in the question it specifically mentioned to use O(log n)"
                    },
                    {
                        "username": "christinehong",
                        "content": "that was literally my line of logic and i ended up with the same solution but in python"
                    },
                    {
                        "username": "gurnainwadhwa",
                        "content": "Just Binary Search"
                    },
                    {
                        "username": "anwendeng",
                        "content": "This problem is solved by using binary search several times.\nFirstly, it is suggested to find the location for the peak which can be done by binary search. \nSecondly, using  binary search to find location for the target  which  is possible before the peak or after the peak.\n\n# Be careful for the boundary cases when n=1 and n=2."
                    }
                ]
            },
            {
                "id": 1909894,
                "content": [
                    {
                        "username": "ss9394",
                        "content": "The problem is intented for Binary search. \\nBut if some is simply travering once  i.e  O(n) , It beats 100% . Which should not be the case. \\n\\nIt should only succeed for binary search based solution. i.e. O(log n)\\n\\n"
                    },
                    {
                        "username": "kaustubhmjb",
                        "content": "Big O notation is asymptotic. An absolute runtime of 2048n is slower than 128n**2, for values of n < 16 (also referred to as n0 in some definitions). Big O notation focuses on rate of change as input size grows arbitrarily."
                    },
                    {
                        "username": "gbiems",
                        "content": "I did binary search, and ran it 3 times, I got 99.5%, 6.3%, and 32%. So I wouldn\\'t put too much stock in the runtime for this.\\n\\nThat said, agreed, surprising you\\'d didn\\'t get a TLE with linear search. "
                    },
                    {
                        "username": "CaptainGalbatrollix",
                        "content": "[@pru_cuder](/pru_cuder) Well that\\'s not true in essence. Yes, big(O) notation is important and leetcode\\'s runtime judgement can be weird and leave a lot to be desired. \\n\\nHowever, it is crucial to remember big(O) is not the end all be all. If the overhead is big enough, for smaller input sizes \\'worse\\' solutions tend to be much more efficient due to factors such as cache locality. For example C++ built in sort switches from quicksort to insertion sort o(n^2) time complexity, when arrays get small enough. \\n\\nIn real life, solving this problem using bsearch would be questionable. Biggest possible size of array in the problem is 5000. If it was 5 * 10^6, then yeah double bsearch is the way to go and can save a lot of time, but you can\\'t honestly tell me a 5000 element loop will be a bottleneck in any system."
                    },
                    {
                        "username": "shivanshutripathii",
                        "content": "Exactly, I\\'ve applied binary search method and it beats only 8.19% in time (O(logn)).\\nWhen I\\'ve applied linear search then it beats 13.60% in time O(n). Crazy things happen."
                    },
                    {
                        "username": "pru_cuder",
                        "content": "those runtimes are based on machine i.e cpu config as well as programming language. Never take these runtimes as a parameter, always focus on Big O notation"
                    },
                    {
                        "username": "mandy1339",
                        "content": "First do a binary search to find the pivot:\\n\\n- Step 1\\n\\t-  compare mid pointer to right most value on the array. If value in mid pointer is greater than right most value in array, we know the pivot is to the right of the mid pointer. If value at mid pointer is smaller than right most value in the array, we know that the pivot is to the left. Split array in half until your left and right pointers touch.\\n- Step 2\\n\\t- Do a 2nd binary search on the whole array. This time we are looking for the target, not a pivot. Now that we know our pivot we just need to modify our midvalue like so: realMid = (mid + pivot) % nums.Length;\\n\\nComplexity of 2 binary searches is O ( 2 Log (n)) which is O (Log(n))"
                    },
                    {
                        "username": "Nitkapur30",
                        "content": "Solution explained: \\nhttps://leetcode.com/problems/search-in-rotated-sorted-array/solutions/3782253/c-binary-search-solution-with-breakdown-of-each-condition/"
                    },
                    {
                        "username": "srapol",
                        "content": "[@Aishwarya_jits](/Aishwarya_jits) how ?"
                    },
                    {
                        "username": "bparanj",
                        "content": "[@shape_mismatch](/shape_mismatch) Actually, both approaches are equally efficient when it comes to handling the case where the array is not pivoted, or sorted. This is because the binary search is performed based on the relationship between the target and the elements at the left, mid, and right positions, not based on whether the array is sorted or not.\\n\\nHowever, comparing with the leftmost element in the array does have an advantage when the array has duplicate values. In case of duplicate values, comparing with the rightmost element might lead to scenarios where we\\'re unable to decide which half of the array to proceed with, thus degrading the performance to O(n) in the worst-case scenario. On the other hand, comparing with the leftmost element can help us avoid such scenarios, thus maintaining a time complexity of O(log n) even when the array contains duplicate values.\\n"
                    },
                    {
                        "username": "Ramonsan07",
                        "content": "was ramdomly checking this problem and  remembered I had solved this in the way you describe https://leetcode.com/problems/search-in-rotated-sorted-array/solutions/3498417/easiest-intuitive-simple-two-binary-searches-solution/"
                    },
                    {
                        "username": "dragon1105",
                        "content": "[@shape_mismatch](/shape_mismatch) I think to compare mid with either the leftmost or the rightmost value is the same, because the probabilities that the pivot is located closer to the left side or to the right side are equal.\\nAnd for the case the array is not pivoted, we just need to check at the beginning whether the leftmost value is less than the rightmost value. If it is, then the array is not pivoted, because if the array is then leftmost must be greater than rightmost."
                    },
                    {
                        "username": "Salominius",
                        "content": "[@lucasscodes](/lucasscodes) 2*O(log n) is NOT O(n) but in fact O(log n).\\nJust as 2 * log n is not n."
                    },
                    {
                        "username": "Aishwarya_jits",
                        "content": "You dont need to do binary search twice, the target can be found in one search by tweaking the binary search code to accommodate for the pivoted element. My point is you dont necessarily have to find the pivot, your code just needs to be aware of its existence. "
                    },
                    {
                        "username": "imankulov53",
                        "content": "thank you for your idea to find pivot on which array is rotated, it\\'s simplifies task and give clear and simple solution"
                    },
                    {
                        "username": "user2748pU",
                        "content": "[@lucasscodes](/lucasscodes) actually what u are saying is wrong, binary search doesn\\'t take n/2 time, it takes log(n) time, so even doing it twice will result in a \"real time\" of 2 times of what it took do do a binary search once (=> 2*log(n)), which will in turn result in O(log(n)), since we ignore constant factors (like the 2*) in big O-Notation."
                    },
                    {
                        "username": "lucasscodes",
                        "content": "This has O(n) complexity.\\n2 times n/2 => n.\\nDont even mind binary search if you need to do it twice..."
                    },
                    {
                        "username": "spencerreitz2002",
                        "content": "[@shape_mismatch](/shape_mismatch) I believe the opposite it true. If the array is pivoted one place to the left, the number at the leftmost position of the array is less than the middle, but the rightmost point is now less than the middle also."
                    },
                    {
                        "username": "_arjan31",
                        "content": "To get it in log(N) complexity , follow strivers method"
                    },
                    {
                        "username": "shape_mismatch",
                        "content": "Wouldn\\'t it be better to compare with the leftmost value in the array (step 1), instead of the rightmost. It would be faster in taking care of cases where the array is not pivoted?"
                    },
                    {
                        "username": "charly371",
                        "content": "I get an error with the following test case: ([1,3], 1) which should output 0 since the integer 1 is present at index 0. \\nMy solution did not work for this one because I based it on the fact that the array will get rotate somewhere. \\n\\nI m thus wondering if you think this test case is valid ? or maybe the exercise should be change to say that the array may be rotated (but not necessarily is...) ?\\n\\nI will change my algo but i would like your feedback in case it was a real interview. what would you say ?\\nThx"
                    },
                    {
                        "username": "olsonpm",
                        "content": "[@vaishali_p14](/vaishali_p14) It also doesn\\'t say what to return in the case it\\'s not rotated\\n\\n> return the index of target if it is in nums, or -1 if it is not in nums"
                    },
                    {
                        "username": "GitG0",
                        "content": "people in 2023 answering a question asked in 2017 without knowing if the constraints or the question itself were modified in those ~6 years lol "
                    },
                    {
                        "username": "raghavsharmaji",
                        "content": "What do you think is meant by \"is possibly rotated\"?"
                    },
                    {
                        "username": "devansh10z",
                        "content": "suppose a case where an array of length n is rotated n times. you get the same array. that is the only reason this test case is a valid case."
                    },
                    {
                        "username": "AHawkeye",
                        "content": "[@vaishali_p14](/vaishali_p14)  But in the description, is says that k >= 1, which means the arrayed must be rotated."
                    },
                    {
                        "username": "sanjay2207",
                        "content": "You may not be checking one of <= or >= conditions correctly. I ran into same issue."
                    },
                    {
                        "username": "vaishali_p14",
                        "content": "In the question, it is mentioned that the passed array is sorted and POSSIBLY rotated."
                    },
                    {
                        "username": "hafezachu",
                        "content": "The main idea is to use binary search to find the target in the array. Binary search is a technique that divides the search space into two halves and compares the target with the middle element. If the target is equal to the middle element, we have found the index. If the target is smaller than the middle element, we search in the left half. If the target is larger than the middle element, we search in the right half. This way, we can reduce the search space by half in each iteration and achieve O(log n) runtime complexity.\\n\\nHowever, since the array is possibly rotated at some unknown pivot, we cannot directly apply binary search. We need to modify it slightly to handle the rotation. The key observation is that one of the two halves must be sorted, and the other half must contain the pivot. For example, if the array is [4,5,6,7,0,1,2], then the left half [4,5,6,7] is sorted and the right half [0,1,2] contains the pivot. If the array is [7,0,1,2,4,5,6], then the right half [2,4,5,6] is sorted and the left half [7,0,1] contains the pivot.\\n\\nSo, in each iteration of binary search, we first check which half is sorted by comparing the left and middle elements. Then we check if the target is in that sorted half by comparing it with the left and middle elements. If it is in that sorted half, we search in that half as usual. If it is not in that sorted half, we search in the other half that contains the pivot.\\n\\nFor example, if the array is [4,5,6,7,0,1,2] and the target is 0:\\n\\n- We start with left = 0 and right = 6. The middle index is 3 and the middle element is 7.\\n- We see that the left half [4,5,6,7] is sorted and the right half [0,1,2] contains the pivot.\\n- We check if the target 0 is in the left half by comparing it with 4 and 7. It is not in that half because 0 < 4 < 7.\\n- So we search in the right half that contains the pivot by setting left = mid + 1 = 4.\\n- We repeat this process until we find the target or exhaust the search space."
                    },
                    {
                        "username": "dragon1105",
                        "content": "Thank you. This is probably the most elegant way to solve this problem. With this solution, we don\\'t even need to find the pivot\\'s location, which is quite smart."
                    },
                    {
                        "username": "jackbb147",
                        "content": "thank you. Great explanation"
                    },
                    {
                        "username": "eugk123",
                        "content": "Why is there a [1,3,5] test case?\\n\\nIt\\'s not that big of a deal, but the problem states it guarantee\\'s pivot in all test cases. Leetcode team, please either remove that statement or fix your test case."
                    },
                    {
                        "username": "amansingh4958",
                        "content": "Just avoid finding pivot for these cases by just comparing 1st and last element of the array"
                    },
                    {
                        "username": "heyyyankit",
                        "content": "[@pranavagrawal321](/pranavagrawal321)its given that ( 1 <= k < nums.length) so this is not possible..."
                    },
                    {
                        "username": "Gautamparti",
                        "content": "question clearly states \"possibly rotated\" , which means you have to include a case where their is no pivot"
                    },
                    {
                        "username": "mrunfunny",
                        "content": "[@pranavagrawal321](/pranavagrawal321) That\\'s one way to look at this :XD"
                    },
                    {
                        "username": "pranavagrawal321",
                        "content": "The test case is correct, since the array can be rotated thrice, resulting in the original sorted array."
                    },
                    {
                        "username": "brauliojde",
                        "content": "I believe that there is an error in one of the test cases because the array that is entered is [1,3] and in this array there is no rotation. "
                    },
                    {
                        "username": "vaishali_p14",
                        "content": "In the question, it is mentioned that the passed array is sorted and POSSIBLY rotated.\\n\\n"
                    },
                    {
                        "username": "Yanlin0408",
                        "content": "[@lakshminathan](/lakshminathan) lmao"
                    },
                    {
                        "username": "lakshminathan",
                        "content": "it is rotated twice"
                    },
                    {
                        "username": "euphoria_kiki",
                        "content": "The key idea is during the process fo binary search, we compare the number at position mid and position left. If the number at mid is larger, it implies that range [left, mid] is ordered (not rotated), so we can decide whether to move towards that range for further search. Otherwise, the number at mid is smaller, which implies that range [mid, right] is ordered (not rotated)."
                    },
                    {
                        "username": "Spam_Musubi",
                        "content": "nice, I was wondering why this was on the medium side, they should\\'ve made something to make this harder and for us to naturally come up with the binary search.\\n"
                    },
                    {
                        "username": "insomniachou",
                        "content": "I don't think this problem is for JS. I saw someone's (n + logn) solution, was wondering why not just compare one by one, resulting in O(n). Not sure the question is asking the index in the sorted array or in the rotated array.  I tried js build-in array method, and surprisingly my answer passed and beats 60%.  \\n\\n\\tvar search = function(nums, target) {\\n\\t\\treturn nums.indexOf(target);\\n\\t};"
                    },
                    {
                        "username": "danielmascena",
                        "content": "doesnt matter the programming language but the approach used"
                    },
                    {
                        "username": "rohiinegi2002",
                        "content": "it will pass... Cause you are using a function that runs of O(logn) time complexity and is called Binary Search..(^ ^)"
                    },
                    {
                        "username": "normanlmfung",
                        "content": "Same in pyton: def search(self, nums: List[int], target: int) -> int:\\n        if target in nums:\\n            return nums.index(target)\\n        else:\\n            return -1"
                    },
                    {
                        "username": "ladiaz4e98",
                        "content": "this is wrong. this is o(n), question is asking for o(log(n)).."
                    },
                    {
                        "username": "thedevwonder",
                        "content": "JS solution in O(logn) works, my answer beats 90%. I think it is independent of programming lang as long as you don\\'t use built in functions"
                    },
                    {
                        "username": "mohaymenrafi",
                        "content": "[@christinehong](/christinehong) when you use indexOf method, in worse case, it actually traverse the entire array which is O(n) operation. but in the question it specifically mentioned to use O(log n)"
                    },
                    {
                        "username": "christinehong",
                        "content": "that was literally my line of logic and i ended up with the same solution but in python"
                    },
                    {
                        "username": "gurnainwadhwa",
                        "content": "Just Binary Search"
                    },
                    {
                        "username": "anwendeng",
                        "content": "This problem is solved by using binary search several times.\nFirstly, it is suggested to find the location for the peak which can be done by binary search. \nSecondly, using  binary search to find location for the target  which  is possible before the peak or after the peak.\n\n# Be careful for the boundary cases when n=1 and n=2."
                    }
                ]
            },
            {
                "id": 1566652,
                "content": [
                    {
                        "username": "ss9394",
                        "content": "The problem is intented for Binary search. \\nBut if some is simply travering once  i.e  O(n) , It beats 100% . Which should not be the case. \\n\\nIt should only succeed for binary search based solution. i.e. O(log n)\\n\\n"
                    },
                    {
                        "username": "kaustubhmjb",
                        "content": "Big O notation is asymptotic. An absolute runtime of 2048n is slower than 128n**2, for values of n < 16 (also referred to as n0 in some definitions). Big O notation focuses on rate of change as input size grows arbitrarily."
                    },
                    {
                        "username": "gbiems",
                        "content": "I did binary search, and ran it 3 times, I got 99.5%, 6.3%, and 32%. So I wouldn\\'t put too much stock in the runtime for this.\\n\\nThat said, agreed, surprising you\\'d didn\\'t get a TLE with linear search. "
                    },
                    {
                        "username": "CaptainGalbatrollix",
                        "content": "[@pru_cuder](/pru_cuder) Well that\\'s not true in essence. Yes, big(O) notation is important and leetcode\\'s runtime judgement can be weird and leave a lot to be desired. \\n\\nHowever, it is crucial to remember big(O) is not the end all be all. If the overhead is big enough, for smaller input sizes \\'worse\\' solutions tend to be much more efficient due to factors such as cache locality. For example C++ built in sort switches from quicksort to insertion sort o(n^2) time complexity, when arrays get small enough. \\n\\nIn real life, solving this problem using bsearch would be questionable. Biggest possible size of array in the problem is 5000. If it was 5 * 10^6, then yeah double bsearch is the way to go and can save a lot of time, but you can\\'t honestly tell me a 5000 element loop will be a bottleneck in any system."
                    },
                    {
                        "username": "shivanshutripathii",
                        "content": "Exactly, I\\'ve applied binary search method and it beats only 8.19% in time (O(logn)).\\nWhen I\\'ve applied linear search then it beats 13.60% in time O(n). Crazy things happen."
                    },
                    {
                        "username": "pru_cuder",
                        "content": "those runtimes are based on machine i.e cpu config as well as programming language. Never take these runtimes as a parameter, always focus on Big O notation"
                    },
                    {
                        "username": "mandy1339",
                        "content": "First do a binary search to find the pivot:\\n\\n- Step 1\\n\\t-  compare mid pointer to right most value on the array. If value in mid pointer is greater than right most value in array, we know the pivot is to the right of the mid pointer. If value at mid pointer is smaller than right most value in the array, we know that the pivot is to the left. Split array in half until your left and right pointers touch.\\n- Step 2\\n\\t- Do a 2nd binary search on the whole array. This time we are looking for the target, not a pivot. Now that we know our pivot we just need to modify our midvalue like so: realMid = (mid + pivot) % nums.Length;\\n\\nComplexity of 2 binary searches is O ( 2 Log (n)) which is O (Log(n))"
                    },
                    {
                        "username": "Nitkapur30",
                        "content": "Solution explained: \\nhttps://leetcode.com/problems/search-in-rotated-sorted-array/solutions/3782253/c-binary-search-solution-with-breakdown-of-each-condition/"
                    },
                    {
                        "username": "srapol",
                        "content": "[@Aishwarya_jits](/Aishwarya_jits) how ?"
                    },
                    {
                        "username": "bparanj",
                        "content": "[@shape_mismatch](/shape_mismatch) Actually, both approaches are equally efficient when it comes to handling the case where the array is not pivoted, or sorted. This is because the binary search is performed based on the relationship between the target and the elements at the left, mid, and right positions, not based on whether the array is sorted or not.\\n\\nHowever, comparing with the leftmost element in the array does have an advantage when the array has duplicate values. In case of duplicate values, comparing with the rightmost element might lead to scenarios where we\\'re unable to decide which half of the array to proceed with, thus degrading the performance to O(n) in the worst-case scenario. On the other hand, comparing with the leftmost element can help us avoid such scenarios, thus maintaining a time complexity of O(log n) even when the array contains duplicate values.\\n"
                    },
                    {
                        "username": "Ramonsan07",
                        "content": "was ramdomly checking this problem and  remembered I had solved this in the way you describe https://leetcode.com/problems/search-in-rotated-sorted-array/solutions/3498417/easiest-intuitive-simple-two-binary-searches-solution/"
                    },
                    {
                        "username": "dragon1105",
                        "content": "[@shape_mismatch](/shape_mismatch) I think to compare mid with either the leftmost or the rightmost value is the same, because the probabilities that the pivot is located closer to the left side or to the right side are equal.\\nAnd for the case the array is not pivoted, we just need to check at the beginning whether the leftmost value is less than the rightmost value. If it is, then the array is not pivoted, because if the array is then leftmost must be greater than rightmost."
                    },
                    {
                        "username": "Salominius",
                        "content": "[@lucasscodes](/lucasscodes) 2*O(log n) is NOT O(n) but in fact O(log n).\\nJust as 2 * log n is not n."
                    },
                    {
                        "username": "Aishwarya_jits",
                        "content": "You dont need to do binary search twice, the target can be found in one search by tweaking the binary search code to accommodate for the pivoted element. My point is you dont necessarily have to find the pivot, your code just needs to be aware of its existence. "
                    },
                    {
                        "username": "imankulov53",
                        "content": "thank you for your idea to find pivot on which array is rotated, it\\'s simplifies task and give clear and simple solution"
                    },
                    {
                        "username": "user2748pU",
                        "content": "[@lucasscodes](/lucasscodes) actually what u are saying is wrong, binary search doesn\\'t take n/2 time, it takes log(n) time, so even doing it twice will result in a \"real time\" of 2 times of what it took do do a binary search once (=> 2*log(n)), which will in turn result in O(log(n)), since we ignore constant factors (like the 2*) in big O-Notation."
                    },
                    {
                        "username": "lucasscodes",
                        "content": "This has O(n) complexity.\\n2 times n/2 => n.\\nDont even mind binary search if you need to do it twice..."
                    },
                    {
                        "username": "spencerreitz2002",
                        "content": "[@shape_mismatch](/shape_mismatch) I believe the opposite it true. If the array is pivoted one place to the left, the number at the leftmost position of the array is less than the middle, but the rightmost point is now less than the middle also."
                    },
                    {
                        "username": "_arjan31",
                        "content": "To get it in log(N) complexity , follow strivers method"
                    },
                    {
                        "username": "shape_mismatch",
                        "content": "Wouldn\\'t it be better to compare with the leftmost value in the array (step 1), instead of the rightmost. It would be faster in taking care of cases where the array is not pivoted?"
                    },
                    {
                        "username": "charly371",
                        "content": "I get an error with the following test case: ([1,3], 1) which should output 0 since the integer 1 is present at index 0. \\nMy solution did not work for this one because I based it on the fact that the array will get rotate somewhere. \\n\\nI m thus wondering if you think this test case is valid ? or maybe the exercise should be change to say that the array may be rotated (but not necessarily is...) ?\\n\\nI will change my algo but i would like your feedback in case it was a real interview. what would you say ?\\nThx"
                    },
                    {
                        "username": "olsonpm",
                        "content": "[@vaishali_p14](/vaishali_p14) It also doesn\\'t say what to return in the case it\\'s not rotated\\n\\n> return the index of target if it is in nums, or -1 if it is not in nums"
                    },
                    {
                        "username": "GitG0",
                        "content": "people in 2023 answering a question asked in 2017 without knowing if the constraints or the question itself were modified in those ~6 years lol "
                    },
                    {
                        "username": "raghavsharmaji",
                        "content": "What do you think is meant by \"is possibly rotated\"?"
                    },
                    {
                        "username": "devansh10z",
                        "content": "suppose a case where an array of length n is rotated n times. you get the same array. that is the only reason this test case is a valid case."
                    },
                    {
                        "username": "AHawkeye",
                        "content": "[@vaishali_p14](/vaishali_p14)  But in the description, is says that k >= 1, which means the arrayed must be rotated."
                    },
                    {
                        "username": "sanjay2207",
                        "content": "You may not be checking one of <= or >= conditions correctly. I ran into same issue."
                    },
                    {
                        "username": "vaishali_p14",
                        "content": "In the question, it is mentioned that the passed array is sorted and POSSIBLY rotated."
                    },
                    {
                        "username": "hafezachu",
                        "content": "The main idea is to use binary search to find the target in the array. Binary search is a technique that divides the search space into two halves and compares the target with the middle element. If the target is equal to the middle element, we have found the index. If the target is smaller than the middle element, we search in the left half. If the target is larger than the middle element, we search in the right half. This way, we can reduce the search space by half in each iteration and achieve O(log n) runtime complexity.\\n\\nHowever, since the array is possibly rotated at some unknown pivot, we cannot directly apply binary search. We need to modify it slightly to handle the rotation. The key observation is that one of the two halves must be sorted, and the other half must contain the pivot. For example, if the array is [4,5,6,7,0,1,2], then the left half [4,5,6,7] is sorted and the right half [0,1,2] contains the pivot. If the array is [7,0,1,2,4,5,6], then the right half [2,4,5,6] is sorted and the left half [7,0,1] contains the pivot.\\n\\nSo, in each iteration of binary search, we first check which half is sorted by comparing the left and middle elements. Then we check if the target is in that sorted half by comparing it with the left and middle elements. If it is in that sorted half, we search in that half as usual. If it is not in that sorted half, we search in the other half that contains the pivot.\\n\\nFor example, if the array is [4,5,6,7,0,1,2] and the target is 0:\\n\\n- We start with left = 0 and right = 6. The middle index is 3 and the middle element is 7.\\n- We see that the left half [4,5,6,7] is sorted and the right half [0,1,2] contains the pivot.\\n- We check if the target 0 is in the left half by comparing it with 4 and 7. It is not in that half because 0 < 4 < 7.\\n- So we search in the right half that contains the pivot by setting left = mid + 1 = 4.\\n- We repeat this process until we find the target or exhaust the search space."
                    },
                    {
                        "username": "dragon1105",
                        "content": "Thank you. This is probably the most elegant way to solve this problem. With this solution, we don\\'t even need to find the pivot\\'s location, which is quite smart."
                    },
                    {
                        "username": "jackbb147",
                        "content": "thank you. Great explanation"
                    },
                    {
                        "username": "eugk123",
                        "content": "Why is there a [1,3,5] test case?\\n\\nIt\\'s not that big of a deal, but the problem states it guarantee\\'s pivot in all test cases. Leetcode team, please either remove that statement or fix your test case."
                    },
                    {
                        "username": "amansingh4958",
                        "content": "Just avoid finding pivot for these cases by just comparing 1st and last element of the array"
                    },
                    {
                        "username": "heyyyankit",
                        "content": "[@pranavagrawal321](/pranavagrawal321)its given that ( 1 <= k < nums.length) so this is not possible..."
                    },
                    {
                        "username": "Gautamparti",
                        "content": "question clearly states \"possibly rotated\" , which means you have to include a case where their is no pivot"
                    },
                    {
                        "username": "mrunfunny",
                        "content": "[@pranavagrawal321](/pranavagrawal321) That\\'s one way to look at this :XD"
                    },
                    {
                        "username": "pranavagrawal321",
                        "content": "The test case is correct, since the array can be rotated thrice, resulting in the original sorted array."
                    },
                    {
                        "username": "brauliojde",
                        "content": "I believe that there is an error in one of the test cases because the array that is entered is [1,3] and in this array there is no rotation. "
                    },
                    {
                        "username": "vaishali_p14",
                        "content": "In the question, it is mentioned that the passed array is sorted and POSSIBLY rotated.\\n\\n"
                    },
                    {
                        "username": "Yanlin0408",
                        "content": "[@lakshminathan](/lakshminathan) lmao"
                    },
                    {
                        "username": "lakshminathan",
                        "content": "it is rotated twice"
                    },
                    {
                        "username": "euphoria_kiki",
                        "content": "The key idea is during the process fo binary search, we compare the number at position mid and position left. If the number at mid is larger, it implies that range [left, mid] is ordered (not rotated), so we can decide whether to move towards that range for further search. Otherwise, the number at mid is smaller, which implies that range [mid, right] is ordered (not rotated)."
                    },
                    {
                        "username": "Spam_Musubi",
                        "content": "nice, I was wondering why this was on the medium side, they should\\'ve made something to make this harder and for us to naturally come up with the binary search.\\n"
                    },
                    {
                        "username": "insomniachou",
                        "content": "I don't think this problem is for JS. I saw someone's (n + logn) solution, was wondering why not just compare one by one, resulting in O(n). Not sure the question is asking the index in the sorted array or in the rotated array.  I tried js build-in array method, and surprisingly my answer passed and beats 60%.  \\n\\n\\tvar search = function(nums, target) {\\n\\t\\treturn nums.indexOf(target);\\n\\t};"
                    },
                    {
                        "username": "danielmascena",
                        "content": "doesnt matter the programming language but the approach used"
                    },
                    {
                        "username": "rohiinegi2002",
                        "content": "it will pass... Cause you are using a function that runs of O(logn) time complexity and is called Binary Search..(^ ^)"
                    },
                    {
                        "username": "normanlmfung",
                        "content": "Same in pyton: def search(self, nums: List[int], target: int) -> int:\\n        if target in nums:\\n            return nums.index(target)\\n        else:\\n            return -1"
                    },
                    {
                        "username": "ladiaz4e98",
                        "content": "this is wrong. this is o(n), question is asking for o(log(n)).."
                    },
                    {
                        "username": "thedevwonder",
                        "content": "JS solution in O(logn) works, my answer beats 90%. I think it is independent of programming lang as long as you don\\'t use built in functions"
                    },
                    {
                        "username": "mohaymenrafi",
                        "content": "[@christinehong](/christinehong) when you use indexOf method, in worse case, it actually traverse the entire array which is O(n) operation. but in the question it specifically mentioned to use O(log n)"
                    },
                    {
                        "username": "christinehong",
                        "content": "that was literally my line of logic and i ended up with the same solution but in python"
                    },
                    {
                        "username": "gurnainwadhwa",
                        "content": "Just Binary Search"
                    },
                    {
                        "username": "anwendeng",
                        "content": "This problem is solved by using binary search several times.\nFirstly, it is suggested to find the location for the peak which can be done by binary search. \nSecondly, using  binary search to find location for the target  which  is possible before the peak or after the peak.\n\n# Be careful for the boundary cases when n=1 and n=2."
                    }
                ]
            },
            {
                "id": 1566532,
                "content": [
                    {
                        "username": "ss9394",
                        "content": "The problem is intented for Binary search. \\nBut if some is simply travering once  i.e  O(n) , It beats 100% . Which should not be the case. \\n\\nIt should only succeed for binary search based solution. i.e. O(log n)\\n\\n"
                    },
                    {
                        "username": "kaustubhmjb",
                        "content": "Big O notation is asymptotic. An absolute runtime of 2048n is slower than 128n**2, for values of n < 16 (also referred to as n0 in some definitions). Big O notation focuses on rate of change as input size grows arbitrarily."
                    },
                    {
                        "username": "gbiems",
                        "content": "I did binary search, and ran it 3 times, I got 99.5%, 6.3%, and 32%. So I wouldn\\'t put too much stock in the runtime for this.\\n\\nThat said, agreed, surprising you\\'d didn\\'t get a TLE with linear search. "
                    },
                    {
                        "username": "CaptainGalbatrollix",
                        "content": "[@pru_cuder](/pru_cuder) Well that\\'s not true in essence. Yes, big(O) notation is important and leetcode\\'s runtime judgement can be weird and leave a lot to be desired. \\n\\nHowever, it is crucial to remember big(O) is not the end all be all. If the overhead is big enough, for smaller input sizes \\'worse\\' solutions tend to be much more efficient due to factors such as cache locality. For example C++ built in sort switches from quicksort to insertion sort o(n^2) time complexity, when arrays get small enough. \\n\\nIn real life, solving this problem using bsearch would be questionable. Biggest possible size of array in the problem is 5000. If it was 5 * 10^6, then yeah double bsearch is the way to go and can save a lot of time, but you can\\'t honestly tell me a 5000 element loop will be a bottleneck in any system."
                    },
                    {
                        "username": "shivanshutripathii",
                        "content": "Exactly, I\\'ve applied binary search method and it beats only 8.19% in time (O(logn)).\\nWhen I\\'ve applied linear search then it beats 13.60% in time O(n). Crazy things happen."
                    },
                    {
                        "username": "pru_cuder",
                        "content": "those runtimes are based on machine i.e cpu config as well as programming language. Never take these runtimes as a parameter, always focus on Big O notation"
                    },
                    {
                        "username": "mandy1339",
                        "content": "First do a binary search to find the pivot:\\n\\n- Step 1\\n\\t-  compare mid pointer to right most value on the array. If value in mid pointer is greater than right most value in array, we know the pivot is to the right of the mid pointer. If value at mid pointer is smaller than right most value in the array, we know that the pivot is to the left. Split array in half until your left and right pointers touch.\\n- Step 2\\n\\t- Do a 2nd binary search on the whole array. This time we are looking for the target, not a pivot. Now that we know our pivot we just need to modify our midvalue like so: realMid = (mid + pivot) % nums.Length;\\n\\nComplexity of 2 binary searches is O ( 2 Log (n)) which is O (Log(n))"
                    },
                    {
                        "username": "Nitkapur30",
                        "content": "Solution explained: \\nhttps://leetcode.com/problems/search-in-rotated-sorted-array/solutions/3782253/c-binary-search-solution-with-breakdown-of-each-condition/"
                    },
                    {
                        "username": "srapol",
                        "content": "[@Aishwarya_jits](/Aishwarya_jits) how ?"
                    },
                    {
                        "username": "bparanj",
                        "content": "[@shape_mismatch](/shape_mismatch) Actually, both approaches are equally efficient when it comes to handling the case where the array is not pivoted, or sorted. This is because the binary search is performed based on the relationship between the target and the elements at the left, mid, and right positions, not based on whether the array is sorted or not.\\n\\nHowever, comparing with the leftmost element in the array does have an advantage when the array has duplicate values. In case of duplicate values, comparing with the rightmost element might lead to scenarios where we\\'re unable to decide which half of the array to proceed with, thus degrading the performance to O(n) in the worst-case scenario. On the other hand, comparing with the leftmost element can help us avoid such scenarios, thus maintaining a time complexity of O(log n) even when the array contains duplicate values.\\n"
                    },
                    {
                        "username": "Ramonsan07",
                        "content": "was ramdomly checking this problem and  remembered I had solved this in the way you describe https://leetcode.com/problems/search-in-rotated-sorted-array/solutions/3498417/easiest-intuitive-simple-two-binary-searches-solution/"
                    },
                    {
                        "username": "dragon1105",
                        "content": "[@shape_mismatch](/shape_mismatch) I think to compare mid with either the leftmost or the rightmost value is the same, because the probabilities that the pivot is located closer to the left side or to the right side are equal.\\nAnd for the case the array is not pivoted, we just need to check at the beginning whether the leftmost value is less than the rightmost value. If it is, then the array is not pivoted, because if the array is then leftmost must be greater than rightmost."
                    },
                    {
                        "username": "Salominius",
                        "content": "[@lucasscodes](/lucasscodes) 2*O(log n) is NOT O(n) but in fact O(log n).\\nJust as 2 * log n is not n."
                    },
                    {
                        "username": "Aishwarya_jits",
                        "content": "You dont need to do binary search twice, the target can be found in one search by tweaking the binary search code to accommodate for the pivoted element. My point is you dont necessarily have to find the pivot, your code just needs to be aware of its existence. "
                    },
                    {
                        "username": "imankulov53",
                        "content": "thank you for your idea to find pivot on which array is rotated, it\\'s simplifies task and give clear and simple solution"
                    },
                    {
                        "username": "user2748pU",
                        "content": "[@lucasscodes](/lucasscodes) actually what u are saying is wrong, binary search doesn\\'t take n/2 time, it takes log(n) time, so even doing it twice will result in a \"real time\" of 2 times of what it took do do a binary search once (=> 2*log(n)), which will in turn result in O(log(n)), since we ignore constant factors (like the 2*) in big O-Notation."
                    },
                    {
                        "username": "lucasscodes",
                        "content": "This has O(n) complexity.\\n2 times n/2 => n.\\nDont even mind binary search if you need to do it twice..."
                    },
                    {
                        "username": "spencerreitz2002",
                        "content": "[@shape_mismatch](/shape_mismatch) I believe the opposite it true. If the array is pivoted one place to the left, the number at the leftmost position of the array is less than the middle, but the rightmost point is now less than the middle also."
                    },
                    {
                        "username": "_arjan31",
                        "content": "To get it in log(N) complexity , follow strivers method"
                    },
                    {
                        "username": "shape_mismatch",
                        "content": "Wouldn\\'t it be better to compare with the leftmost value in the array (step 1), instead of the rightmost. It would be faster in taking care of cases where the array is not pivoted?"
                    },
                    {
                        "username": "charly371",
                        "content": "I get an error with the following test case: ([1,3], 1) which should output 0 since the integer 1 is present at index 0. \\nMy solution did not work for this one because I based it on the fact that the array will get rotate somewhere. \\n\\nI m thus wondering if you think this test case is valid ? or maybe the exercise should be change to say that the array may be rotated (but not necessarily is...) ?\\n\\nI will change my algo but i would like your feedback in case it was a real interview. what would you say ?\\nThx"
                    },
                    {
                        "username": "olsonpm",
                        "content": "[@vaishali_p14](/vaishali_p14) It also doesn\\'t say what to return in the case it\\'s not rotated\\n\\n> return the index of target if it is in nums, or -1 if it is not in nums"
                    },
                    {
                        "username": "GitG0",
                        "content": "people in 2023 answering a question asked in 2017 without knowing if the constraints or the question itself were modified in those ~6 years lol "
                    },
                    {
                        "username": "raghavsharmaji",
                        "content": "What do you think is meant by \"is possibly rotated\"?"
                    },
                    {
                        "username": "devansh10z",
                        "content": "suppose a case where an array of length n is rotated n times. you get the same array. that is the only reason this test case is a valid case."
                    },
                    {
                        "username": "AHawkeye",
                        "content": "[@vaishali_p14](/vaishali_p14)  But in the description, is says that k >= 1, which means the arrayed must be rotated."
                    },
                    {
                        "username": "sanjay2207",
                        "content": "You may not be checking one of <= or >= conditions correctly. I ran into same issue."
                    },
                    {
                        "username": "vaishali_p14",
                        "content": "In the question, it is mentioned that the passed array is sorted and POSSIBLY rotated."
                    },
                    {
                        "username": "hafezachu",
                        "content": "The main idea is to use binary search to find the target in the array. Binary search is a technique that divides the search space into two halves and compares the target with the middle element. If the target is equal to the middle element, we have found the index. If the target is smaller than the middle element, we search in the left half. If the target is larger than the middle element, we search in the right half. This way, we can reduce the search space by half in each iteration and achieve O(log n) runtime complexity.\\n\\nHowever, since the array is possibly rotated at some unknown pivot, we cannot directly apply binary search. We need to modify it slightly to handle the rotation. The key observation is that one of the two halves must be sorted, and the other half must contain the pivot. For example, if the array is [4,5,6,7,0,1,2], then the left half [4,5,6,7] is sorted and the right half [0,1,2] contains the pivot. If the array is [7,0,1,2,4,5,6], then the right half [2,4,5,6] is sorted and the left half [7,0,1] contains the pivot.\\n\\nSo, in each iteration of binary search, we first check which half is sorted by comparing the left and middle elements. Then we check if the target is in that sorted half by comparing it with the left and middle elements. If it is in that sorted half, we search in that half as usual. If it is not in that sorted half, we search in the other half that contains the pivot.\\n\\nFor example, if the array is [4,5,6,7,0,1,2] and the target is 0:\\n\\n- We start with left = 0 and right = 6. The middle index is 3 and the middle element is 7.\\n- We see that the left half [4,5,6,7] is sorted and the right half [0,1,2] contains the pivot.\\n- We check if the target 0 is in the left half by comparing it with 4 and 7. It is not in that half because 0 < 4 < 7.\\n- So we search in the right half that contains the pivot by setting left = mid + 1 = 4.\\n- We repeat this process until we find the target or exhaust the search space."
                    },
                    {
                        "username": "dragon1105",
                        "content": "Thank you. This is probably the most elegant way to solve this problem. With this solution, we don\\'t even need to find the pivot\\'s location, which is quite smart."
                    },
                    {
                        "username": "jackbb147",
                        "content": "thank you. Great explanation"
                    },
                    {
                        "username": "eugk123",
                        "content": "Why is there a [1,3,5] test case?\\n\\nIt\\'s not that big of a deal, but the problem states it guarantee\\'s pivot in all test cases. Leetcode team, please either remove that statement or fix your test case."
                    },
                    {
                        "username": "amansingh4958",
                        "content": "Just avoid finding pivot for these cases by just comparing 1st and last element of the array"
                    },
                    {
                        "username": "heyyyankit",
                        "content": "[@pranavagrawal321](/pranavagrawal321)its given that ( 1 <= k < nums.length) so this is not possible..."
                    },
                    {
                        "username": "Gautamparti",
                        "content": "question clearly states \"possibly rotated\" , which means you have to include a case where their is no pivot"
                    },
                    {
                        "username": "mrunfunny",
                        "content": "[@pranavagrawal321](/pranavagrawal321) That\\'s one way to look at this :XD"
                    },
                    {
                        "username": "pranavagrawal321",
                        "content": "The test case is correct, since the array can be rotated thrice, resulting in the original sorted array."
                    },
                    {
                        "username": "brauliojde",
                        "content": "I believe that there is an error in one of the test cases because the array that is entered is [1,3] and in this array there is no rotation. "
                    },
                    {
                        "username": "vaishali_p14",
                        "content": "In the question, it is mentioned that the passed array is sorted and POSSIBLY rotated.\\n\\n"
                    },
                    {
                        "username": "Yanlin0408",
                        "content": "[@lakshminathan](/lakshminathan) lmao"
                    },
                    {
                        "username": "lakshminathan",
                        "content": "it is rotated twice"
                    },
                    {
                        "username": "euphoria_kiki",
                        "content": "The key idea is during the process fo binary search, we compare the number at position mid and position left. If the number at mid is larger, it implies that range [left, mid] is ordered (not rotated), so we can decide whether to move towards that range for further search. Otherwise, the number at mid is smaller, which implies that range [mid, right] is ordered (not rotated)."
                    },
                    {
                        "username": "Spam_Musubi",
                        "content": "nice, I was wondering why this was on the medium side, they should\\'ve made something to make this harder and for us to naturally come up with the binary search.\\n"
                    },
                    {
                        "username": "insomniachou",
                        "content": "I don't think this problem is for JS. I saw someone's (n + logn) solution, was wondering why not just compare one by one, resulting in O(n). Not sure the question is asking the index in the sorted array or in the rotated array.  I tried js build-in array method, and surprisingly my answer passed and beats 60%.  \\n\\n\\tvar search = function(nums, target) {\\n\\t\\treturn nums.indexOf(target);\\n\\t};"
                    },
                    {
                        "username": "danielmascena",
                        "content": "doesnt matter the programming language but the approach used"
                    },
                    {
                        "username": "rohiinegi2002",
                        "content": "it will pass... Cause you are using a function that runs of O(logn) time complexity and is called Binary Search..(^ ^)"
                    },
                    {
                        "username": "normanlmfung",
                        "content": "Same in pyton: def search(self, nums: List[int], target: int) -> int:\\n        if target in nums:\\n            return nums.index(target)\\n        else:\\n            return -1"
                    },
                    {
                        "username": "ladiaz4e98",
                        "content": "this is wrong. this is o(n), question is asking for o(log(n)).."
                    },
                    {
                        "username": "thedevwonder",
                        "content": "JS solution in O(logn) works, my answer beats 90%. I think it is independent of programming lang as long as you don\\'t use built in functions"
                    },
                    {
                        "username": "mohaymenrafi",
                        "content": "[@christinehong](/christinehong) when you use indexOf method, in worse case, it actually traverse the entire array which is O(n) operation. but in the question it specifically mentioned to use O(log n)"
                    },
                    {
                        "username": "christinehong",
                        "content": "that was literally my line of logic and i ended up with the same solution but in python"
                    },
                    {
                        "username": "gurnainwadhwa",
                        "content": "Just Binary Search"
                    },
                    {
                        "username": "anwendeng",
                        "content": "This problem is solved by using binary search several times.\nFirstly, it is suggested to find the location for the peak which can be done by binary search. \nSecondly, using  binary search to find location for the target  which  is possible before the peak or after the peak.\n\n# Be careful for the boundary cases when n=1 and n=2."
                    }
                ]
            },
            {
                "id": 1576174,
                "content": [
                    {
                        "username": "ss9394",
                        "content": "The problem is intented for Binary search. \\nBut if some is simply travering once  i.e  O(n) , It beats 100% . Which should not be the case. \\n\\nIt should only succeed for binary search based solution. i.e. O(log n)\\n\\n"
                    },
                    {
                        "username": "kaustubhmjb",
                        "content": "Big O notation is asymptotic. An absolute runtime of 2048n is slower than 128n**2, for values of n < 16 (also referred to as n0 in some definitions). Big O notation focuses on rate of change as input size grows arbitrarily."
                    },
                    {
                        "username": "gbiems",
                        "content": "I did binary search, and ran it 3 times, I got 99.5%, 6.3%, and 32%. So I wouldn\\'t put too much stock in the runtime for this.\\n\\nThat said, agreed, surprising you\\'d didn\\'t get a TLE with linear search. "
                    },
                    {
                        "username": "CaptainGalbatrollix",
                        "content": "[@pru_cuder](/pru_cuder) Well that\\'s not true in essence. Yes, big(O) notation is important and leetcode\\'s runtime judgement can be weird and leave a lot to be desired. \\n\\nHowever, it is crucial to remember big(O) is not the end all be all. If the overhead is big enough, for smaller input sizes \\'worse\\' solutions tend to be much more efficient due to factors such as cache locality. For example C++ built in sort switches from quicksort to insertion sort o(n^2) time complexity, when arrays get small enough. \\n\\nIn real life, solving this problem using bsearch would be questionable. Biggest possible size of array in the problem is 5000. If it was 5 * 10^6, then yeah double bsearch is the way to go and can save a lot of time, but you can\\'t honestly tell me a 5000 element loop will be a bottleneck in any system."
                    },
                    {
                        "username": "shivanshutripathii",
                        "content": "Exactly, I\\'ve applied binary search method and it beats only 8.19% in time (O(logn)).\\nWhen I\\'ve applied linear search then it beats 13.60% in time O(n). Crazy things happen."
                    },
                    {
                        "username": "pru_cuder",
                        "content": "those runtimes are based on machine i.e cpu config as well as programming language. Never take these runtimes as a parameter, always focus on Big O notation"
                    },
                    {
                        "username": "mandy1339",
                        "content": "First do a binary search to find the pivot:\\n\\n- Step 1\\n\\t-  compare mid pointer to right most value on the array. If value in mid pointer is greater than right most value in array, we know the pivot is to the right of the mid pointer. If value at mid pointer is smaller than right most value in the array, we know that the pivot is to the left. Split array in half until your left and right pointers touch.\\n- Step 2\\n\\t- Do a 2nd binary search on the whole array. This time we are looking for the target, not a pivot. Now that we know our pivot we just need to modify our midvalue like so: realMid = (mid + pivot) % nums.Length;\\n\\nComplexity of 2 binary searches is O ( 2 Log (n)) which is O (Log(n))"
                    },
                    {
                        "username": "Nitkapur30",
                        "content": "Solution explained: \\nhttps://leetcode.com/problems/search-in-rotated-sorted-array/solutions/3782253/c-binary-search-solution-with-breakdown-of-each-condition/"
                    },
                    {
                        "username": "srapol",
                        "content": "[@Aishwarya_jits](/Aishwarya_jits) how ?"
                    },
                    {
                        "username": "bparanj",
                        "content": "[@shape_mismatch](/shape_mismatch) Actually, both approaches are equally efficient when it comes to handling the case where the array is not pivoted, or sorted. This is because the binary search is performed based on the relationship between the target and the elements at the left, mid, and right positions, not based on whether the array is sorted or not.\\n\\nHowever, comparing with the leftmost element in the array does have an advantage when the array has duplicate values. In case of duplicate values, comparing with the rightmost element might lead to scenarios where we\\'re unable to decide which half of the array to proceed with, thus degrading the performance to O(n) in the worst-case scenario. On the other hand, comparing with the leftmost element can help us avoid such scenarios, thus maintaining a time complexity of O(log n) even when the array contains duplicate values.\\n"
                    },
                    {
                        "username": "Ramonsan07",
                        "content": "was ramdomly checking this problem and  remembered I had solved this in the way you describe https://leetcode.com/problems/search-in-rotated-sorted-array/solutions/3498417/easiest-intuitive-simple-two-binary-searches-solution/"
                    },
                    {
                        "username": "dragon1105",
                        "content": "[@shape_mismatch](/shape_mismatch) I think to compare mid with either the leftmost or the rightmost value is the same, because the probabilities that the pivot is located closer to the left side or to the right side are equal.\\nAnd for the case the array is not pivoted, we just need to check at the beginning whether the leftmost value is less than the rightmost value. If it is, then the array is not pivoted, because if the array is then leftmost must be greater than rightmost."
                    },
                    {
                        "username": "Salominius",
                        "content": "[@lucasscodes](/lucasscodes) 2*O(log n) is NOT O(n) but in fact O(log n).\\nJust as 2 * log n is not n."
                    },
                    {
                        "username": "Aishwarya_jits",
                        "content": "You dont need to do binary search twice, the target can be found in one search by tweaking the binary search code to accommodate for the pivoted element. My point is you dont necessarily have to find the pivot, your code just needs to be aware of its existence. "
                    },
                    {
                        "username": "imankulov53",
                        "content": "thank you for your idea to find pivot on which array is rotated, it\\'s simplifies task and give clear and simple solution"
                    },
                    {
                        "username": "user2748pU",
                        "content": "[@lucasscodes](/lucasscodes) actually what u are saying is wrong, binary search doesn\\'t take n/2 time, it takes log(n) time, so even doing it twice will result in a \"real time\" of 2 times of what it took do do a binary search once (=> 2*log(n)), which will in turn result in O(log(n)), since we ignore constant factors (like the 2*) in big O-Notation."
                    },
                    {
                        "username": "lucasscodes",
                        "content": "This has O(n) complexity.\\n2 times n/2 => n.\\nDont even mind binary search if you need to do it twice..."
                    },
                    {
                        "username": "spencerreitz2002",
                        "content": "[@shape_mismatch](/shape_mismatch) I believe the opposite it true. If the array is pivoted one place to the left, the number at the leftmost position of the array is less than the middle, but the rightmost point is now less than the middle also."
                    },
                    {
                        "username": "_arjan31",
                        "content": "To get it in log(N) complexity , follow strivers method"
                    },
                    {
                        "username": "shape_mismatch",
                        "content": "Wouldn\\'t it be better to compare with the leftmost value in the array (step 1), instead of the rightmost. It would be faster in taking care of cases where the array is not pivoted?"
                    },
                    {
                        "username": "charly371",
                        "content": "I get an error with the following test case: ([1,3], 1) which should output 0 since the integer 1 is present at index 0. \\nMy solution did not work for this one because I based it on the fact that the array will get rotate somewhere. \\n\\nI m thus wondering if you think this test case is valid ? or maybe the exercise should be change to say that the array may be rotated (but not necessarily is...) ?\\n\\nI will change my algo but i would like your feedback in case it was a real interview. what would you say ?\\nThx"
                    },
                    {
                        "username": "olsonpm",
                        "content": "[@vaishali_p14](/vaishali_p14) It also doesn\\'t say what to return in the case it\\'s not rotated\\n\\n> return the index of target if it is in nums, or -1 if it is not in nums"
                    },
                    {
                        "username": "GitG0",
                        "content": "people in 2023 answering a question asked in 2017 without knowing if the constraints or the question itself were modified in those ~6 years lol "
                    },
                    {
                        "username": "raghavsharmaji",
                        "content": "What do you think is meant by \"is possibly rotated\"?"
                    },
                    {
                        "username": "devansh10z",
                        "content": "suppose a case where an array of length n is rotated n times. you get the same array. that is the only reason this test case is a valid case."
                    },
                    {
                        "username": "AHawkeye",
                        "content": "[@vaishali_p14](/vaishali_p14)  But in the description, is says that k >= 1, which means the arrayed must be rotated."
                    },
                    {
                        "username": "sanjay2207",
                        "content": "You may not be checking one of <= or >= conditions correctly. I ran into same issue."
                    },
                    {
                        "username": "vaishali_p14",
                        "content": "In the question, it is mentioned that the passed array is sorted and POSSIBLY rotated."
                    },
                    {
                        "username": "hafezachu",
                        "content": "The main idea is to use binary search to find the target in the array. Binary search is a technique that divides the search space into two halves and compares the target with the middle element. If the target is equal to the middle element, we have found the index. If the target is smaller than the middle element, we search in the left half. If the target is larger than the middle element, we search in the right half. This way, we can reduce the search space by half in each iteration and achieve O(log n) runtime complexity.\\n\\nHowever, since the array is possibly rotated at some unknown pivot, we cannot directly apply binary search. We need to modify it slightly to handle the rotation. The key observation is that one of the two halves must be sorted, and the other half must contain the pivot. For example, if the array is [4,5,6,7,0,1,2], then the left half [4,5,6,7] is sorted and the right half [0,1,2] contains the pivot. If the array is [7,0,1,2,4,5,6], then the right half [2,4,5,6] is sorted and the left half [7,0,1] contains the pivot.\\n\\nSo, in each iteration of binary search, we first check which half is sorted by comparing the left and middle elements. Then we check if the target is in that sorted half by comparing it with the left and middle elements. If it is in that sorted half, we search in that half as usual. If it is not in that sorted half, we search in the other half that contains the pivot.\\n\\nFor example, if the array is [4,5,6,7,0,1,2] and the target is 0:\\n\\n- We start with left = 0 and right = 6. The middle index is 3 and the middle element is 7.\\n- We see that the left half [4,5,6,7] is sorted and the right half [0,1,2] contains the pivot.\\n- We check if the target 0 is in the left half by comparing it with 4 and 7. It is not in that half because 0 < 4 < 7.\\n- So we search in the right half that contains the pivot by setting left = mid + 1 = 4.\\n- We repeat this process until we find the target or exhaust the search space."
                    },
                    {
                        "username": "dragon1105",
                        "content": "Thank you. This is probably the most elegant way to solve this problem. With this solution, we don\\'t even need to find the pivot\\'s location, which is quite smart."
                    },
                    {
                        "username": "jackbb147",
                        "content": "thank you. Great explanation"
                    },
                    {
                        "username": "eugk123",
                        "content": "Why is there a [1,3,5] test case?\\n\\nIt\\'s not that big of a deal, but the problem states it guarantee\\'s pivot in all test cases. Leetcode team, please either remove that statement or fix your test case."
                    },
                    {
                        "username": "amansingh4958",
                        "content": "Just avoid finding pivot for these cases by just comparing 1st and last element of the array"
                    },
                    {
                        "username": "heyyyankit",
                        "content": "[@pranavagrawal321](/pranavagrawal321)its given that ( 1 <= k < nums.length) so this is not possible..."
                    },
                    {
                        "username": "Gautamparti",
                        "content": "question clearly states \"possibly rotated\" , which means you have to include a case where their is no pivot"
                    },
                    {
                        "username": "mrunfunny",
                        "content": "[@pranavagrawal321](/pranavagrawal321) That\\'s one way to look at this :XD"
                    },
                    {
                        "username": "pranavagrawal321",
                        "content": "The test case is correct, since the array can be rotated thrice, resulting in the original sorted array."
                    },
                    {
                        "username": "brauliojde",
                        "content": "I believe that there is an error in one of the test cases because the array that is entered is [1,3] and in this array there is no rotation. "
                    },
                    {
                        "username": "vaishali_p14",
                        "content": "In the question, it is mentioned that the passed array is sorted and POSSIBLY rotated.\\n\\n"
                    },
                    {
                        "username": "Yanlin0408",
                        "content": "[@lakshminathan](/lakshminathan) lmao"
                    },
                    {
                        "username": "lakshminathan",
                        "content": "it is rotated twice"
                    },
                    {
                        "username": "euphoria_kiki",
                        "content": "The key idea is during the process fo binary search, we compare the number at position mid and position left. If the number at mid is larger, it implies that range [left, mid] is ordered (not rotated), so we can decide whether to move towards that range for further search. Otherwise, the number at mid is smaller, which implies that range [mid, right] is ordered (not rotated)."
                    },
                    {
                        "username": "Spam_Musubi",
                        "content": "nice, I was wondering why this was on the medium side, they should\\'ve made something to make this harder and for us to naturally come up with the binary search.\\n"
                    },
                    {
                        "username": "insomniachou",
                        "content": "I don't think this problem is for JS. I saw someone's (n + logn) solution, was wondering why not just compare one by one, resulting in O(n). Not sure the question is asking the index in the sorted array or in the rotated array.  I tried js build-in array method, and surprisingly my answer passed and beats 60%.  \\n\\n\\tvar search = function(nums, target) {\\n\\t\\treturn nums.indexOf(target);\\n\\t};"
                    },
                    {
                        "username": "danielmascena",
                        "content": "doesnt matter the programming language but the approach used"
                    },
                    {
                        "username": "rohiinegi2002",
                        "content": "it will pass... Cause you are using a function that runs of O(logn) time complexity and is called Binary Search..(^ ^)"
                    },
                    {
                        "username": "normanlmfung",
                        "content": "Same in pyton: def search(self, nums: List[int], target: int) -> int:\\n        if target in nums:\\n            return nums.index(target)\\n        else:\\n            return -1"
                    },
                    {
                        "username": "ladiaz4e98",
                        "content": "this is wrong. this is o(n), question is asking for o(log(n)).."
                    },
                    {
                        "username": "thedevwonder",
                        "content": "JS solution in O(logn) works, my answer beats 90%. I think it is independent of programming lang as long as you don\\'t use built in functions"
                    },
                    {
                        "username": "mohaymenrafi",
                        "content": "[@christinehong](/christinehong) when you use indexOf method, in worse case, it actually traverse the entire array which is O(n) operation. but in the question it specifically mentioned to use O(log n)"
                    },
                    {
                        "username": "christinehong",
                        "content": "that was literally my line of logic and i ended up with the same solution but in python"
                    },
                    {
                        "username": "gurnainwadhwa",
                        "content": "Just Binary Search"
                    },
                    {
                        "username": "anwendeng",
                        "content": "This problem is solved by using binary search several times.\nFirstly, it is suggested to find the location for the peak which can be done by binary search. \nSecondly, using  binary search to find location for the target  which  is possible before the peak or after the peak.\n\n# Be careful for the boundary cases when n=1 and n=2."
                    }
                ]
            },
            {
                "id": 1567816,
                "content": [
                    {
                        "username": "ss9394",
                        "content": "The problem is intented for Binary search. \\nBut if some is simply travering once  i.e  O(n) , It beats 100% . Which should not be the case. \\n\\nIt should only succeed for binary search based solution. i.e. O(log n)\\n\\n"
                    },
                    {
                        "username": "kaustubhmjb",
                        "content": "Big O notation is asymptotic. An absolute runtime of 2048n is slower than 128n**2, for values of n < 16 (also referred to as n0 in some definitions). Big O notation focuses on rate of change as input size grows arbitrarily."
                    },
                    {
                        "username": "gbiems",
                        "content": "I did binary search, and ran it 3 times, I got 99.5%, 6.3%, and 32%. So I wouldn\\'t put too much stock in the runtime for this.\\n\\nThat said, agreed, surprising you\\'d didn\\'t get a TLE with linear search. "
                    },
                    {
                        "username": "CaptainGalbatrollix",
                        "content": "[@pru_cuder](/pru_cuder) Well that\\'s not true in essence. Yes, big(O) notation is important and leetcode\\'s runtime judgement can be weird and leave a lot to be desired. \\n\\nHowever, it is crucial to remember big(O) is not the end all be all. If the overhead is big enough, for smaller input sizes \\'worse\\' solutions tend to be much more efficient due to factors such as cache locality. For example C++ built in sort switches from quicksort to insertion sort o(n^2) time complexity, when arrays get small enough. \\n\\nIn real life, solving this problem using bsearch would be questionable. Biggest possible size of array in the problem is 5000. If it was 5 * 10^6, then yeah double bsearch is the way to go and can save a lot of time, but you can\\'t honestly tell me a 5000 element loop will be a bottleneck in any system."
                    },
                    {
                        "username": "shivanshutripathii",
                        "content": "Exactly, I\\'ve applied binary search method and it beats only 8.19% in time (O(logn)).\\nWhen I\\'ve applied linear search then it beats 13.60% in time O(n). Crazy things happen."
                    },
                    {
                        "username": "pru_cuder",
                        "content": "those runtimes are based on machine i.e cpu config as well as programming language. Never take these runtimes as a parameter, always focus on Big O notation"
                    },
                    {
                        "username": "mandy1339",
                        "content": "First do a binary search to find the pivot:\\n\\n- Step 1\\n\\t-  compare mid pointer to right most value on the array. If value in mid pointer is greater than right most value in array, we know the pivot is to the right of the mid pointer. If value at mid pointer is smaller than right most value in the array, we know that the pivot is to the left. Split array in half until your left and right pointers touch.\\n- Step 2\\n\\t- Do a 2nd binary search on the whole array. This time we are looking for the target, not a pivot. Now that we know our pivot we just need to modify our midvalue like so: realMid = (mid + pivot) % nums.Length;\\n\\nComplexity of 2 binary searches is O ( 2 Log (n)) which is O (Log(n))"
                    },
                    {
                        "username": "Nitkapur30",
                        "content": "Solution explained: \\nhttps://leetcode.com/problems/search-in-rotated-sorted-array/solutions/3782253/c-binary-search-solution-with-breakdown-of-each-condition/"
                    },
                    {
                        "username": "srapol",
                        "content": "[@Aishwarya_jits](/Aishwarya_jits) how ?"
                    },
                    {
                        "username": "bparanj",
                        "content": "[@shape_mismatch](/shape_mismatch) Actually, both approaches are equally efficient when it comes to handling the case where the array is not pivoted, or sorted. This is because the binary search is performed based on the relationship between the target and the elements at the left, mid, and right positions, not based on whether the array is sorted or not.\\n\\nHowever, comparing with the leftmost element in the array does have an advantage when the array has duplicate values. In case of duplicate values, comparing with the rightmost element might lead to scenarios where we\\'re unable to decide which half of the array to proceed with, thus degrading the performance to O(n) in the worst-case scenario. On the other hand, comparing with the leftmost element can help us avoid such scenarios, thus maintaining a time complexity of O(log n) even when the array contains duplicate values.\\n"
                    },
                    {
                        "username": "Ramonsan07",
                        "content": "was ramdomly checking this problem and  remembered I had solved this in the way you describe https://leetcode.com/problems/search-in-rotated-sorted-array/solutions/3498417/easiest-intuitive-simple-two-binary-searches-solution/"
                    },
                    {
                        "username": "dragon1105",
                        "content": "[@shape_mismatch](/shape_mismatch) I think to compare mid with either the leftmost or the rightmost value is the same, because the probabilities that the pivot is located closer to the left side or to the right side are equal.\\nAnd for the case the array is not pivoted, we just need to check at the beginning whether the leftmost value is less than the rightmost value. If it is, then the array is not pivoted, because if the array is then leftmost must be greater than rightmost."
                    },
                    {
                        "username": "Salominius",
                        "content": "[@lucasscodes](/lucasscodes) 2*O(log n) is NOT O(n) but in fact O(log n).\\nJust as 2 * log n is not n."
                    },
                    {
                        "username": "Aishwarya_jits",
                        "content": "You dont need to do binary search twice, the target can be found in one search by tweaking the binary search code to accommodate for the pivoted element. My point is you dont necessarily have to find the pivot, your code just needs to be aware of its existence. "
                    },
                    {
                        "username": "imankulov53",
                        "content": "thank you for your idea to find pivot on which array is rotated, it\\'s simplifies task and give clear and simple solution"
                    },
                    {
                        "username": "user2748pU",
                        "content": "[@lucasscodes](/lucasscodes) actually what u are saying is wrong, binary search doesn\\'t take n/2 time, it takes log(n) time, so even doing it twice will result in a \"real time\" of 2 times of what it took do do a binary search once (=> 2*log(n)), which will in turn result in O(log(n)), since we ignore constant factors (like the 2*) in big O-Notation."
                    },
                    {
                        "username": "lucasscodes",
                        "content": "This has O(n) complexity.\\n2 times n/2 => n.\\nDont even mind binary search if you need to do it twice..."
                    },
                    {
                        "username": "spencerreitz2002",
                        "content": "[@shape_mismatch](/shape_mismatch) I believe the opposite it true. If the array is pivoted one place to the left, the number at the leftmost position of the array is less than the middle, but the rightmost point is now less than the middle also."
                    },
                    {
                        "username": "_arjan31",
                        "content": "To get it in log(N) complexity , follow strivers method"
                    },
                    {
                        "username": "shape_mismatch",
                        "content": "Wouldn\\'t it be better to compare with the leftmost value in the array (step 1), instead of the rightmost. It would be faster in taking care of cases where the array is not pivoted?"
                    },
                    {
                        "username": "charly371",
                        "content": "I get an error with the following test case: ([1,3], 1) which should output 0 since the integer 1 is present at index 0. \\nMy solution did not work for this one because I based it on the fact that the array will get rotate somewhere. \\n\\nI m thus wondering if you think this test case is valid ? or maybe the exercise should be change to say that the array may be rotated (but not necessarily is...) ?\\n\\nI will change my algo but i would like your feedback in case it was a real interview. what would you say ?\\nThx"
                    },
                    {
                        "username": "olsonpm",
                        "content": "[@vaishali_p14](/vaishali_p14) It also doesn\\'t say what to return in the case it\\'s not rotated\\n\\n> return the index of target if it is in nums, or -1 if it is not in nums"
                    },
                    {
                        "username": "GitG0",
                        "content": "people in 2023 answering a question asked in 2017 without knowing if the constraints or the question itself were modified in those ~6 years lol "
                    },
                    {
                        "username": "raghavsharmaji",
                        "content": "What do you think is meant by \"is possibly rotated\"?"
                    },
                    {
                        "username": "devansh10z",
                        "content": "suppose a case where an array of length n is rotated n times. you get the same array. that is the only reason this test case is a valid case."
                    },
                    {
                        "username": "AHawkeye",
                        "content": "[@vaishali_p14](/vaishali_p14)  But in the description, is says that k >= 1, which means the arrayed must be rotated."
                    },
                    {
                        "username": "sanjay2207",
                        "content": "You may not be checking one of <= or >= conditions correctly. I ran into same issue."
                    },
                    {
                        "username": "vaishali_p14",
                        "content": "In the question, it is mentioned that the passed array is sorted and POSSIBLY rotated."
                    },
                    {
                        "username": "hafezachu",
                        "content": "The main idea is to use binary search to find the target in the array. Binary search is a technique that divides the search space into two halves and compares the target with the middle element. If the target is equal to the middle element, we have found the index. If the target is smaller than the middle element, we search in the left half. If the target is larger than the middle element, we search in the right half. This way, we can reduce the search space by half in each iteration and achieve O(log n) runtime complexity.\\n\\nHowever, since the array is possibly rotated at some unknown pivot, we cannot directly apply binary search. We need to modify it slightly to handle the rotation. The key observation is that one of the two halves must be sorted, and the other half must contain the pivot. For example, if the array is [4,5,6,7,0,1,2], then the left half [4,5,6,7] is sorted and the right half [0,1,2] contains the pivot. If the array is [7,0,1,2,4,5,6], then the right half [2,4,5,6] is sorted and the left half [7,0,1] contains the pivot.\\n\\nSo, in each iteration of binary search, we first check which half is sorted by comparing the left and middle elements. Then we check if the target is in that sorted half by comparing it with the left and middle elements. If it is in that sorted half, we search in that half as usual. If it is not in that sorted half, we search in the other half that contains the pivot.\\n\\nFor example, if the array is [4,5,6,7,0,1,2] and the target is 0:\\n\\n- We start with left = 0 and right = 6. The middle index is 3 and the middle element is 7.\\n- We see that the left half [4,5,6,7] is sorted and the right half [0,1,2] contains the pivot.\\n- We check if the target 0 is in the left half by comparing it with 4 and 7. It is not in that half because 0 < 4 < 7.\\n- So we search in the right half that contains the pivot by setting left = mid + 1 = 4.\\n- We repeat this process until we find the target or exhaust the search space."
                    },
                    {
                        "username": "dragon1105",
                        "content": "Thank you. This is probably the most elegant way to solve this problem. With this solution, we don\\'t even need to find the pivot\\'s location, which is quite smart."
                    },
                    {
                        "username": "jackbb147",
                        "content": "thank you. Great explanation"
                    },
                    {
                        "username": "eugk123",
                        "content": "Why is there a [1,3,5] test case?\\n\\nIt\\'s not that big of a deal, but the problem states it guarantee\\'s pivot in all test cases. Leetcode team, please either remove that statement or fix your test case."
                    },
                    {
                        "username": "amansingh4958",
                        "content": "Just avoid finding pivot for these cases by just comparing 1st and last element of the array"
                    },
                    {
                        "username": "heyyyankit",
                        "content": "[@pranavagrawal321](/pranavagrawal321)its given that ( 1 <= k < nums.length) so this is not possible..."
                    },
                    {
                        "username": "Gautamparti",
                        "content": "question clearly states \"possibly rotated\" , which means you have to include a case where their is no pivot"
                    },
                    {
                        "username": "mrunfunny",
                        "content": "[@pranavagrawal321](/pranavagrawal321) That\\'s one way to look at this :XD"
                    },
                    {
                        "username": "pranavagrawal321",
                        "content": "The test case is correct, since the array can be rotated thrice, resulting in the original sorted array."
                    },
                    {
                        "username": "brauliojde",
                        "content": "I believe that there is an error in one of the test cases because the array that is entered is [1,3] and in this array there is no rotation. "
                    },
                    {
                        "username": "vaishali_p14",
                        "content": "In the question, it is mentioned that the passed array is sorted and POSSIBLY rotated.\\n\\n"
                    },
                    {
                        "username": "Yanlin0408",
                        "content": "[@lakshminathan](/lakshminathan) lmao"
                    },
                    {
                        "username": "lakshminathan",
                        "content": "it is rotated twice"
                    },
                    {
                        "username": "euphoria_kiki",
                        "content": "The key idea is during the process fo binary search, we compare the number at position mid and position left. If the number at mid is larger, it implies that range [left, mid] is ordered (not rotated), so we can decide whether to move towards that range for further search. Otherwise, the number at mid is smaller, which implies that range [mid, right] is ordered (not rotated)."
                    },
                    {
                        "username": "Spam_Musubi",
                        "content": "nice, I was wondering why this was on the medium side, they should\\'ve made something to make this harder and for us to naturally come up with the binary search.\\n"
                    },
                    {
                        "username": "insomniachou",
                        "content": "I don't think this problem is for JS. I saw someone's (n + logn) solution, was wondering why not just compare one by one, resulting in O(n). Not sure the question is asking the index in the sorted array or in the rotated array.  I tried js build-in array method, and surprisingly my answer passed and beats 60%.  \\n\\n\\tvar search = function(nums, target) {\\n\\t\\treturn nums.indexOf(target);\\n\\t};"
                    },
                    {
                        "username": "danielmascena",
                        "content": "doesnt matter the programming language but the approach used"
                    },
                    {
                        "username": "rohiinegi2002",
                        "content": "it will pass... Cause you are using a function that runs of O(logn) time complexity and is called Binary Search..(^ ^)"
                    },
                    {
                        "username": "normanlmfung",
                        "content": "Same in pyton: def search(self, nums: List[int], target: int) -> int:\\n        if target in nums:\\n            return nums.index(target)\\n        else:\\n            return -1"
                    },
                    {
                        "username": "ladiaz4e98",
                        "content": "this is wrong. this is o(n), question is asking for o(log(n)).."
                    },
                    {
                        "username": "thedevwonder",
                        "content": "JS solution in O(logn) works, my answer beats 90%. I think it is independent of programming lang as long as you don\\'t use built in functions"
                    },
                    {
                        "username": "mohaymenrafi",
                        "content": "[@christinehong](/christinehong) when you use indexOf method, in worse case, it actually traverse the entire array which is O(n) operation. but in the question it specifically mentioned to use O(log n)"
                    },
                    {
                        "username": "christinehong",
                        "content": "that was literally my line of logic and i ended up with the same solution but in python"
                    },
                    {
                        "username": "gurnainwadhwa",
                        "content": "Just Binary Search"
                    },
                    {
                        "username": "anwendeng",
                        "content": "This problem is solved by using binary search several times.\nFirstly, it is suggested to find the location for the peak which can be done by binary search. \nSecondly, using  binary search to find location for the target  which  is possible before the peak or after the peak.\n\n# Be careful for the boundary cases when n=1 and n=2."
                    }
                ]
            },
            {
                "id": 1844246,
                "content": [
                    {
                        "username": "ss9394",
                        "content": "The problem is intented for Binary search. \\nBut if some is simply travering once  i.e  O(n) , It beats 100% . Which should not be the case. \\n\\nIt should only succeed for binary search based solution. i.e. O(log n)\\n\\n"
                    },
                    {
                        "username": "kaustubhmjb",
                        "content": "Big O notation is asymptotic. An absolute runtime of 2048n is slower than 128n**2, for values of n < 16 (also referred to as n0 in some definitions). Big O notation focuses on rate of change as input size grows arbitrarily."
                    },
                    {
                        "username": "gbiems",
                        "content": "I did binary search, and ran it 3 times, I got 99.5%, 6.3%, and 32%. So I wouldn\\'t put too much stock in the runtime for this.\\n\\nThat said, agreed, surprising you\\'d didn\\'t get a TLE with linear search. "
                    },
                    {
                        "username": "CaptainGalbatrollix",
                        "content": "[@pru_cuder](/pru_cuder) Well that\\'s not true in essence. Yes, big(O) notation is important and leetcode\\'s runtime judgement can be weird and leave a lot to be desired. \\n\\nHowever, it is crucial to remember big(O) is not the end all be all. If the overhead is big enough, for smaller input sizes \\'worse\\' solutions tend to be much more efficient due to factors such as cache locality. For example C++ built in sort switches from quicksort to insertion sort o(n^2) time complexity, when arrays get small enough. \\n\\nIn real life, solving this problem using bsearch would be questionable. Biggest possible size of array in the problem is 5000. If it was 5 * 10^6, then yeah double bsearch is the way to go and can save a lot of time, but you can\\'t honestly tell me a 5000 element loop will be a bottleneck in any system."
                    },
                    {
                        "username": "shivanshutripathii",
                        "content": "Exactly, I\\'ve applied binary search method and it beats only 8.19% in time (O(logn)).\\nWhen I\\'ve applied linear search then it beats 13.60% in time O(n). Crazy things happen."
                    },
                    {
                        "username": "pru_cuder",
                        "content": "those runtimes are based on machine i.e cpu config as well as programming language. Never take these runtimes as a parameter, always focus on Big O notation"
                    },
                    {
                        "username": "mandy1339",
                        "content": "First do a binary search to find the pivot:\\n\\n- Step 1\\n\\t-  compare mid pointer to right most value on the array. If value in mid pointer is greater than right most value in array, we know the pivot is to the right of the mid pointer. If value at mid pointer is smaller than right most value in the array, we know that the pivot is to the left. Split array in half until your left and right pointers touch.\\n- Step 2\\n\\t- Do a 2nd binary search on the whole array. This time we are looking for the target, not a pivot. Now that we know our pivot we just need to modify our midvalue like so: realMid = (mid + pivot) % nums.Length;\\n\\nComplexity of 2 binary searches is O ( 2 Log (n)) which is O (Log(n))"
                    },
                    {
                        "username": "Nitkapur30",
                        "content": "Solution explained: \\nhttps://leetcode.com/problems/search-in-rotated-sorted-array/solutions/3782253/c-binary-search-solution-with-breakdown-of-each-condition/"
                    },
                    {
                        "username": "srapol",
                        "content": "[@Aishwarya_jits](/Aishwarya_jits) how ?"
                    },
                    {
                        "username": "bparanj",
                        "content": "[@shape_mismatch](/shape_mismatch) Actually, both approaches are equally efficient when it comes to handling the case where the array is not pivoted, or sorted. This is because the binary search is performed based on the relationship between the target and the elements at the left, mid, and right positions, not based on whether the array is sorted or not.\\n\\nHowever, comparing with the leftmost element in the array does have an advantage when the array has duplicate values. In case of duplicate values, comparing with the rightmost element might lead to scenarios where we\\'re unable to decide which half of the array to proceed with, thus degrading the performance to O(n) in the worst-case scenario. On the other hand, comparing with the leftmost element can help us avoid such scenarios, thus maintaining a time complexity of O(log n) even when the array contains duplicate values.\\n"
                    },
                    {
                        "username": "Ramonsan07",
                        "content": "was ramdomly checking this problem and  remembered I had solved this in the way you describe https://leetcode.com/problems/search-in-rotated-sorted-array/solutions/3498417/easiest-intuitive-simple-two-binary-searches-solution/"
                    },
                    {
                        "username": "dragon1105",
                        "content": "[@shape_mismatch](/shape_mismatch) I think to compare mid with either the leftmost or the rightmost value is the same, because the probabilities that the pivot is located closer to the left side or to the right side are equal.\\nAnd for the case the array is not pivoted, we just need to check at the beginning whether the leftmost value is less than the rightmost value. If it is, then the array is not pivoted, because if the array is then leftmost must be greater than rightmost."
                    },
                    {
                        "username": "Salominius",
                        "content": "[@lucasscodes](/lucasscodes) 2*O(log n) is NOT O(n) but in fact O(log n).\\nJust as 2 * log n is not n."
                    },
                    {
                        "username": "Aishwarya_jits",
                        "content": "You dont need to do binary search twice, the target can be found in one search by tweaking the binary search code to accommodate for the pivoted element. My point is you dont necessarily have to find the pivot, your code just needs to be aware of its existence. "
                    },
                    {
                        "username": "imankulov53",
                        "content": "thank you for your idea to find pivot on which array is rotated, it\\'s simplifies task and give clear and simple solution"
                    },
                    {
                        "username": "user2748pU",
                        "content": "[@lucasscodes](/lucasscodes) actually what u are saying is wrong, binary search doesn\\'t take n/2 time, it takes log(n) time, so even doing it twice will result in a \"real time\" of 2 times of what it took do do a binary search once (=> 2*log(n)), which will in turn result in O(log(n)), since we ignore constant factors (like the 2*) in big O-Notation."
                    },
                    {
                        "username": "lucasscodes",
                        "content": "This has O(n) complexity.\\n2 times n/2 => n.\\nDont even mind binary search if you need to do it twice..."
                    },
                    {
                        "username": "spencerreitz2002",
                        "content": "[@shape_mismatch](/shape_mismatch) I believe the opposite it true. If the array is pivoted one place to the left, the number at the leftmost position of the array is less than the middle, but the rightmost point is now less than the middle also."
                    },
                    {
                        "username": "_arjan31",
                        "content": "To get it in log(N) complexity , follow strivers method"
                    },
                    {
                        "username": "shape_mismatch",
                        "content": "Wouldn\\'t it be better to compare with the leftmost value in the array (step 1), instead of the rightmost. It would be faster in taking care of cases where the array is not pivoted?"
                    },
                    {
                        "username": "charly371",
                        "content": "I get an error with the following test case: ([1,3], 1) which should output 0 since the integer 1 is present at index 0. \\nMy solution did not work for this one because I based it on the fact that the array will get rotate somewhere. \\n\\nI m thus wondering if you think this test case is valid ? or maybe the exercise should be change to say that the array may be rotated (but not necessarily is...) ?\\n\\nI will change my algo but i would like your feedback in case it was a real interview. what would you say ?\\nThx"
                    },
                    {
                        "username": "olsonpm",
                        "content": "[@vaishali_p14](/vaishali_p14) It also doesn\\'t say what to return in the case it\\'s not rotated\\n\\n> return the index of target if it is in nums, or -1 if it is not in nums"
                    },
                    {
                        "username": "GitG0",
                        "content": "people in 2023 answering a question asked in 2017 without knowing if the constraints or the question itself were modified in those ~6 years lol "
                    },
                    {
                        "username": "raghavsharmaji",
                        "content": "What do you think is meant by \"is possibly rotated\"?"
                    },
                    {
                        "username": "devansh10z",
                        "content": "suppose a case where an array of length n is rotated n times. you get the same array. that is the only reason this test case is a valid case."
                    },
                    {
                        "username": "AHawkeye",
                        "content": "[@vaishali_p14](/vaishali_p14)  But in the description, is says that k >= 1, which means the arrayed must be rotated."
                    },
                    {
                        "username": "sanjay2207",
                        "content": "You may not be checking one of <= or >= conditions correctly. I ran into same issue."
                    },
                    {
                        "username": "vaishali_p14",
                        "content": "In the question, it is mentioned that the passed array is sorted and POSSIBLY rotated."
                    },
                    {
                        "username": "hafezachu",
                        "content": "The main idea is to use binary search to find the target in the array. Binary search is a technique that divides the search space into two halves and compares the target with the middle element. If the target is equal to the middle element, we have found the index. If the target is smaller than the middle element, we search in the left half. If the target is larger than the middle element, we search in the right half. This way, we can reduce the search space by half in each iteration and achieve O(log n) runtime complexity.\\n\\nHowever, since the array is possibly rotated at some unknown pivot, we cannot directly apply binary search. We need to modify it slightly to handle the rotation. The key observation is that one of the two halves must be sorted, and the other half must contain the pivot. For example, if the array is [4,5,6,7,0,1,2], then the left half [4,5,6,7] is sorted and the right half [0,1,2] contains the pivot. If the array is [7,0,1,2,4,5,6], then the right half [2,4,5,6] is sorted and the left half [7,0,1] contains the pivot.\\n\\nSo, in each iteration of binary search, we first check which half is sorted by comparing the left and middle elements. Then we check if the target is in that sorted half by comparing it with the left and middle elements. If it is in that sorted half, we search in that half as usual. If it is not in that sorted half, we search in the other half that contains the pivot.\\n\\nFor example, if the array is [4,5,6,7,0,1,2] and the target is 0:\\n\\n- We start with left = 0 and right = 6. The middle index is 3 and the middle element is 7.\\n- We see that the left half [4,5,6,7] is sorted and the right half [0,1,2] contains the pivot.\\n- We check if the target 0 is in the left half by comparing it with 4 and 7. It is not in that half because 0 < 4 < 7.\\n- So we search in the right half that contains the pivot by setting left = mid + 1 = 4.\\n- We repeat this process until we find the target or exhaust the search space."
                    },
                    {
                        "username": "dragon1105",
                        "content": "Thank you. This is probably the most elegant way to solve this problem. With this solution, we don\\'t even need to find the pivot\\'s location, which is quite smart."
                    },
                    {
                        "username": "jackbb147",
                        "content": "thank you. Great explanation"
                    },
                    {
                        "username": "eugk123",
                        "content": "Why is there a [1,3,5] test case?\\n\\nIt\\'s not that big of a deal, but the problem states it guarantee\\'s pivot in all test cases. Leetcode team, please either remove that statement or fix your test case."
                    },
                    {
                        "username": "amansingh4958",
                        "content": "Just avoid finding pivot for these cases by just comparing 1st and last element of the array"
                    },
                    {
                        "username": "heyyyankit",
                        "content": "[@pranavagrawal321](/pranavagrawal321)its given that ( 1 <= k < nums.length) so this is not possible..."
                    },
                    {
                        "username": "Gautamparti",
                        "content": "question clearly states \"possibly rotated\" , which means you have to include a case where their is no pivot"
                    },
                    {
                        "username": "mrunfunny",
                        "content": "[@pranavagrawal321](/pranavagrawal321) That\\'s one way to look at this :XD"
                    },
                    {
                        "username": "pranavagrawal321",
                        "content": "The test case is correct, since the array can be rotated thrice, resulting in the original sorted array."
                    },
                    {
                        "username": "brauliojde",
                        "content": "I believe that there is an error in one of the test cases because the array that is entered is [1,3] and in this array there is no rotation. "
                    },
                    {
                        "username": "vaishali_p14",
                        "content": "In the question, it is mentioned that the passed array is sorted and POSSIBLY rotated.\\n\\n"
                    },
                    {
                        "username": "Yanlin0408",
                        "content": "[@lakshminathan](/lakshminathan) lmao"
                    },
                    {
                        "username": "lakshminathan",
                        "content": "it is rotated twice"
                    },
                    {
                        "username": "euphoria_kiki",
                        "content": "The key idea is during the process fo binary search, we compare the number at position mid and position left. If the number at mid is larger, it implies that range [left, mid] is ordered (not rotated), so we can decide whether to move towards that range for further search. Otherwise, the number at mid is smaller, which implies that range [mid, right] is ordered (not rotated)."
                    },
                    {
                        "username": "Spam_Musubi",
                        "content": "nice, I was wondering why this was on the medium side, they should\\'ve made something to make this harder and for us to naturally come up with the binary search.\\n"
                    },
                    {
                        "username": "insomniachou",
                        "content": "I don't think this problem is for JS. I saw someone's (n + logn) solution, was wondering why not just compare one by one, resulting in O(n). Not sure the question is asking the index in the sorted array or in the rotated array.  I tried js build-in array method, and surprisingly my answer passed and beats 60%.  \\n\\n\\tvar search = function(nums, target) {\\n\\t\\treturn nums.indexOf(target);\\n\\t};"
                    },
                    {
                        "username": "danielmascena",
                        "content": "doesnt matter the programming language but the approach used"
                    },
                    {
                        "username": "rohiinegi2002",
                        "content": "it will pass... Cause you are using a function that runs of O(logn) time complexity and is called Binary Search..(^ ^)"
                    },
                    {
                        "username": "normanlmfung",
                        "content": "Same in pyton: def search(self, nums: List[int], target: int) -> int:\\n        if target in nums:\\n            return nums.index(target)\\n        else:\\n            return -1"
                    },
                    {
                        "username": "ladiaz4e98",
                        "content": "this is wrong. this is o(n), question is asking for o(log(n)).."
                    },
                    {
                        "username": "thedevwonder",
                        "content": "JS solution in O(logn) works, my answer beats 90%. I think it is independent of programming lang as long as you don\\'t use built in functions"
                    },
                    {
                        "username": "mohaymenrafi",
                        "content": "[@christinehong](/christinehong) when you use indexOf method, in worse case, it actually traverse the entire array which is O(n) operation. but in the question it specifically mentioned to use O(log n)"
                    },
                    {
                        "username": "christinehong",
                        "content": "that was literally my line of logic and i ended up with the same solution but in python"
                    },
                    {
                        "username": "gurnainwadhwa",
                        "content": "Just Binary Search"
                    },
                    {
                        "username": "anwendeng",
                        "content": "This problem is solved by using binary search several times.\nFirstly, it is suggested to find the location for the peak which can be done by binary search. \nSecondly, using  binary search to find location for the target  which  is possible before the peak or after the peak.\n\n# Be careful for the boundary cases when n=1 and n=2."
                    }
                ]
            },
            {
                "id": 2004907,
                "content": [
                    {
                        "username": "ss9394",
                        "content": "The problem is intented for Binary search. \\nBut if some is simply travering once  i.e  O(n) , It beats 100% . Which should not be the case. \\n\\nIt should only succeed for binary search based solution. i.e. O(log n)\\n\\n"
                    },
                    {
                        "username": "kaustubhmjb",
                        "content": "Big O notation is asymptotic. An absolute runtime of 2048n is slower than 128n**2, for values of n < 16 (also referred to as n0 in some definitions). Big O notation focuses on rate of change as input size grows arbitrarily."
                    },
                    {
                        "username": "gbiems",
                        "content": "I did binary search, and ran it 3 times, I got 99.5%, 6.3%, and 32%. So I wouldn\\'t put too much stock in the runtime for this.\\n\\nThat said, agreed, surprising you\\'d didn\\'t get a TLE with linear search. "
                    },
                    {
                        "username": "CaptainGalbatrollix",
                        "content": "[@pru_cuder](/pru_cuder) Well that\\'s not true in essence. Yes, big(O) notation is important and leetcode\\'s runtime judgement can be weird and leave a lot to be desired. \\n\\nHowever, it is crucial to remember big(O) is not the end all be all. If the overhead is big enough, for smaller input sizes \\'worse\\' solutions tend to be much more efficient due to factors such as cache locality. For example C++ built in sort switches from quicksort to insertion sort o(n^2) time complexity, when arrays get small enough. \\n\\nIn real life, solving this problem using bsearch would be questionable. Biggest possible size of array in the problem is 5000. If it was 5 * 10^6, then yeah double bsearch is the way to go and can save a lot of time, but you can\\'t honestly tell me a 5000 element loop will be a bottleneck in any system."
                    },
                    {
                        "username": "shivanshutripathii",
                        "content": "Exactly, I\\'ve applied binary search method and it beats only 8.19% in time (O(logn)).\\nWhen I\\'ve applied linear search then it beats 13.60% in time O(n). Crazy things happen."
                    },
                    {
                        "username": "pru_cuder",
                        "content": "those runtimes are based on machine i.e cpu config as well as programming language. Never take these runtimes as a parameter, always focus on Big O notation"
                    },
                    {
                        "username": "mandy1339",
                        "content": "First do a binary search to find the pivot:\\n\\n- Step 1\\n\\t-  compare mid pointer to right most value on the array. If value in mid pointer is greater than right most value in array, we know the pivot is to the right of the mid pointer. If value at mid pointer is smaller than right most value in the array, we know that the pivot is to the left. Split array in half until your left and right pointers touch.\\n- Step 2\\n\\t- Do a 2nd binary search on the whole array. This time we are looking for the target, not a pivot. Now that we know our pivot we just need to modify our midvalue like so: realMid = (mid + pivot) % nums.Length;\\n\\nComplexity of 2 binary searches is O ( 2 Log (n)) which is O (Log(n))"
                    },
                    {
                        "username": "Nitkapur30",
                        "content": "Solution explained: \\nhttps://leetcode.com/problems/search-in-rotated-sorted-array/solutions/3782253/c-binary-search-solution-with-breakdown-of-each-condition/"
                    },
                    {
                        "username": "srapol",
                        "content": "[@Aishwarya_jits](/Aishwarya_jits) how ?"
                    },
                    {
                        "username": "bparanj",
                        "content": "[@shape_mismatch](/shape_mismatch) Actually, both approaches are equally efficient when it comes to handling the case where the array is not pivoted, or sorted. This is because the binary search is performed based on the relationship between the target and the elements at the left, mid, and right positions, not based on whether the array is sorted or not.\\n\\nHowever, comparing with the leftmost element in the array does have an advantage when the array has duplicate values. In case of duplicate values, comparing with the rightmost element might lead to scenarios where we\\'re unable to decide which half of the array to proceed with, thus degrading the performance to O(n) in the worst-case scenario. On the other hand, comparing with the leftmost element can help us avoid such scenarios, thus maintaining a time complexity of O(log n) even when the array contains duplicate values.\\n"
                    },
                    {
                        "username": "Ramonsan07",
                        "content": "was ramdomly checking this problem and  remembered I had solved this in the way you describe https://leetcode.com/problems/search-in-rotated-sorted-array/solutions/3498417/easiest-intuitive-simple-two-binary-searches-solution/"
                    },
                    {
                        "username": "dragon1105",
                        "content": "[@shape_mismatch](/shape_mismatch) I think to compare mid with either the leftmost or the rightmost value is the same, because the probabilities that the pivot is located closer to the left side or to the right side are equal.\\nAnd for the case the array is not pivoted, we just need to check at the beginning whether the leftmost value is less than the rightmost value. If it is, then the array is not pivoted, because if the array is then leftmost must be greater than rightmost."
                    },
                    {
                        "username": "Salominius",
                        "content": "[@lucasscodes](/lucasscodes) 2*O(log n) is NOT O(n) but in fact O(log n).\\nJust as 2 * log n is not n."
                    },
                    {
                        "username": "Aishwarya_jits",
                        "content": "You dont need to do binary search twice, the target can be found in one search by tweaking the binary search code to accommodate for the pivoted element. My point is you dont necessarily have to find the pivot, your code just needs to be aware of its existence. "
                    },
                    {
                        "username": "imankulov53",
                        "content": "thank you for your idea to find pivot on which array is rotated, it\\'s simplifies task and give clear and simple solution"
                    },
                    {
                        "username": "user2748pU",
                        "content": "[@lucasscodes](/lucasscodes) actually what u are saying is wrong, binary search doesn\\'t take n/2 time, it takes log(n) time, so even doing it twice will result in a \"real time\" of 2 times of what it took do do a binary search once (=> 2*log(n)), which will in turn result in O(log(n)), since we ignore constant factors (like the 2*) in big O-Notation."
                    },
                    {
                        "username": "lucasscodes",
                        "content": "This has O(n) complexity.\\n2 times n/2 => n.\\nDont even mind binary search if you need to do it twice..."
                    },
                    {
                        "username": "spencerreitz2002",
                        "content": "[@shape_mismatch](/shape_mismatch) I believe the opposite it true. If the array is pivoted one place to the left, the number at the leftmost position of the array is less than the middle, but the rightmost point is now less than the middle also."
                    },
                    {
                        "username": "_arjan31",
                        "content": "To get it in log(N) complexity , follow strivers method"
                    },
                    {
                        "username": "shape_mismatch",
                        "content": "Wouldn\\'t it be better to compare with the leftmost value in the array (step 1), instead of the rightmost. It would be faster in taking care of cases where the array is not pivoted?"
                    },
                    {
                        "username": "charly371",
                        "content": "I get an error with the following test case: ([1,3], 1) which should output 0 since the integer 1 is present at index 0. \\nMy solution did not work for this one because I based it on the fact that the array will get rotate somewhere. \\n\\nI m thus wondering if you think this test case is valid ? or maybe the exercise should be change to say that the array may be rotated (but not necessarily is...) ?\\n\\nI will change my algo but i would like your feedback in case it was a real interview. what would you say ?\\nThx"
                    },
                    {
                        "username": "olsonpm",
                        "content": "[@vaishali_p14](/vaishali_p14) It also doesn\\'t say what to return in the case it\\'s not rotated\\n\\n> return the index of target if it is in nums, or -1 if it is not in nums"
                    },
                    {
                        "username": "GitG0",
                        "content": "people in 2023 answering a question asked in 2017 without knowing if the constraints or the question itself were modified in those ~6 years lol "
                    },
                    {
                        "username": "raghavsharmaji",
                        "content": "What do you think is meant by \"is possibly rotated\"?"
                    },
                    {
                        "username": "devansh10z",
                        "content": "suppose a case where an array of length n is rotated n times. you get the same array. that is the only reason this test case is a valid case."
                    },
                    {
                        "username": "AHawkeye",
                        "content": "[@vaishali_p14](/vaishali_p14)  But in the description, is says that k >= 1, which means the arrayed must be rotated."
                    },
                    {
                        "username": "sanjay2207",
                        "content": "You may not be checking one of <= or >= conditions correctly. I ran into same issue."
                    },
                    {
                        "username": "vaishali_p14",
                        "content": "In the question, it is mentioned that the passed array is sorted and POSSIBLY rotated."
                    },
                    {
                        "username": "hafezachu",
                        "content": "The main idea is to use binary search to find the target in the array. Binary search is a technique that divides the search space into two halves and compares the target with the middle element. If the target is equal to the middle element, we have found the index. If the target is smaller than the middle element, we search in the left half. If the target is larger than the middle element, we search in the right half. This way, we can reduce the search space by half in each iteration and achieve O(log n) runtime complexity.\\n\\nHowever, since the array is possibly rotated at some unknown pivot, we cannot directly apply binary search. We need to modify it slightly to handle the rotation. The key observation is that one of the two halves must be sorted, and the other half must contain the pivot. For example, if the array is [4,5,6,7,0,1,2], then the left half [4,5,6,7] is sorted and the right half [0,1,2] contains the pivot. If the array is [7,0,1,2,4,5,6], then the right half [2,4,5,6] is sorted and the left half [7,0,1] contains the pivot.\\n\\nSo, in each iteration of binary search, we first check which half is sorted by comparing the left and middle elements. Then we check if the target is in that sorted half by comparing it with the left and middle elements. If it is in that sorted half, we search in that half as usual. If it is not in that sorted half, we search in the other half that contains the pivot.\\n\\nFor example, if the array is [4,5,6,7,0,1,2] and the target is 0:\\n\\n- We start with left = 0 and right = 6. The middle index is 3 and the middle element is 7.\\n- We see that the left half [4,5,6,7] is sorted and the right half [0,1,2] contains the pivot.\\n- We check if the target 0 is in the left half by comparing it with 4 and 7. It is not in that half because 0 < 4 < 7.\\n- So we search in the right half that contains the pivot by setting left = mid + 1 = 4.\\n- We repeat this process until we find the target or exhaust the search space."
                    },
                    {
                        "username": "dragon1105",
                        "content": "Thank you. This is probably the most elegant way to solve this problem. With this solution, we don\\'t even need to find the pivot\\'s location, which is quite smart."
                    },
                    {
                        "username": "jackbb147",
                        "content": "thank you. Great explanation"
                    },
                    {
                        "username": "eugk123",
                        "content": "Why is there a [1,3,5] test case?\\n\\nIt\\'s not that big of a deal, but the problem states it guarantee\\'s pivot in all test cases. Leetcode team, please either remove that statement or fix your test case."
                    },
                    {
                        "username": "amansingh4958",
                        "content": "Just avoid finding pivot for these cases by just comparing 1st and last element of the array"
                    },
                    {
                        "username": "heyyyankit",
                        "content": "[@pranavagrawal321](/pranavagrawal321)its given that ( 1 <= k < nums.length) so this is not possible..."
                    },
                    {
                        "username": "Gautamparti",
                        "content": "question clearly states \"possibly rotated\" , which means you have to include a case where their is no pivot"
                    },
                    {
                        "username": "mrunfunny",
                        "content": "[@pranavagrawal321](/pranavagrawal321) That\\'s one way to look at this :XD"
                    },
                    {
                        "username": "pranavagrawal321",
                        "content": "The test case is correct, since the array can be rotated thrice, resulting in the original sorted array."
                    },
                    {
                        "username": "brauliojde",
                        "content": "I believe that there is an error in one of the test cases because the array that is entered is [1,3] and in this array there is no rotation. "
                    },
                    {
                        "username": "vaishali_p14",
                        "content": "In the question, it is mentioned that the passed array is sorted and POSSIBLY rotated.\\n\\n"
                    },
                    {
                        "username": "Yanlin0408",
                        "content": "[@lakshminathan](/lakshminathan) lmao"
                    },
                    {
                        "username": "lakshminathan",
                        "content": "it is rotated twice"
                    },
                    {
                        "username": "euphoria_kiki",
                        "content": "The key idea is during the process fo binary search, we compare the number at position mid and position left. If the number at mid is larger, it implies that range [left, mid] is ordered (not rotated), so we can decide whether to move towards that range for further search. Otherwise, the number at mid is smaller, which implies that range [mid, right] is ordered (not rotated)."
                    },
                    {
                        "username": "Spam_Musubi",
                        "content": "nice, I was wondering why this was on the medium side, they should\\'ve made something to make this harder and for us to naturally come up with the binary search.\\n"
                    },
                    {
                        "username": "insomniachou",
                        "content": "I don't think this problem is for JS. I saw someone's (n + logn) solution, was wondering why not just compare one by one, resulting in O(n). Not sure the question is asking the index in the sorted array or in the rotated array.  I tried js build-in array method, and surprisingly my answer passed and beats 60%.  \\n\\n\\tvar search = function(nums, target) {\\n\\t\\treturn nums.indexOf(target);\\n\\t};"
                    },
                    {
                        "username": "danielmascena",
                        "content": "doesnt matter the programming language but the approach used"
                    },
                    {
                        "username": "rohiinegi2002",
                        "content": "it will pass... Cause you are using a function that runs of O(logn) time complexity and is called Binary Search..(^ ^)"
                    },
                    {
                        "username": "normanlmfung",
                        "content": "Same in pyton: def search(self, nums: List[int], target: int) -> int:\\n        if target in nums:\\n            return nums.index(target)\\n        else:\\n            return -1"
                    },
                    {
                        "username": "ladiaz4e98",
                        "content": "this is wrong. this is o(n), question is asking for o(log(n)).."
                    },
                    {
                        "username": "thedevwonder",
                        "content": "JS solution in O(logn) works, my answer beats 90%. I think it is independent of programming lang as long as you don\\'t use built in functions"
                    },
                    {
                        "username": "mohaymenrafi",
                        "content": "[@christinehong](/christinehong) when you use indexOf method, in worse case, it actually traverse the entire array which is O(n) operation. but in the question it specifically mentioned to use O(log n)"
                    },
                    {
                        "username": "christinehong",
                        "content": "that was literally my line of logic and i ended up with the same solution but in python"
                    },
                    {
                        "username": "gurnainwadhwa",
                        "content": "Just Binary Search"
                    },
                    {
                        "username": "anwendeng",
                        "content": "This problem is solved by using binary search several times.\nFirstly, it is suggested to find the location for the peak which can be done by binary search. \nSecondly, using  binary search to find location for the target  which  is possible before the peak or after the peak.\n\n# Be careful for the boundary cases when n=1 and n=2."
                    }
                ]
            },
            {
                "id": 1567557,
                "content": [
                    {
                        "username": "ss9394",
                        "content": "The problem is intented for Binary search. \\nBut if some is simply travering once  i.e  O(n) , It beats 100% . Which should not be the case. \\n\\nIt should only succeed for binary search based solution. i.e. O(log n)\\n\\n"
                    },
                    {
                        "username": "kaustubhmjb",
                        "content": "Big O notation is asymptotic. An absolute runtime of 2048n is slower than 128n**2, for values of n < 16 (also referred to as n0 in some definitions). Big O notation focuses on rate of change as input size grows arbitrarily."
                    },
                    {
                        "username": "gbiems",
                        "content": "I did binary search, and ran it 3 times, I got 99.5%, 6.3%, and 32%. So I wouldn\\'t put too much stock in the runtime for this.\\n\\nThat said, agreed, surprising you\\'d didn\\'t get a TLE with linear search. "
                    },
                    {
                        "username": "CaptainGalbatrollix",
                        "content": "[@pru_cuder](/pru_cuder) Well that\\'s not true in essence. Yes, big(O) notation is important and leetcode\\'s runtime judgement can be weird and leave a lot to be desired. \\n\\nHowever, it is crucial to remember big(O) is not the end all be all. If the overhead is big enough, for smaller input sizes \\'worse\\' solutions tend to be much more efficient due to factors such as cache locality. For example C++ built in sort switches from quicksort to insertion sort o(n^2) time complexity, when arrays get small enough. \\n\\nIn real life, solving this problem using bsearch would be questionable. Biggest possible size of array in the problem is 5000. If it was 5 * 10^6, then yeah double bsearch is the way to go and can save a lot of time, but you can\\'t honestly tell me a 5000 element loop will be a bottleneck in any system."
                    },
                    {
                        "username": "shivanshutripathii",
                        "content": "Exactly, I\\'ve applied binary search method and it beats only 8.19% in time (O(logn)).\\nWhen I\\'ve applied linear search then it beats 13.60% in time O(n). Crazy things happen."
                    },
                    {
                        "username": "pru_cuder",
                        "content": "those runtimes are based on machine i.e cpu config as well as programming language. Never take these runtimes as a parameter, always focus on Big O notation"
                    },
                    {
                        "username": "mandy1339",
                        "content": "First do a binary search to find the pivot:\\n\\n- Step 1\\n\\t-  compare mid pointer to right most value on the array. If value in mid pointer is greater than right most value in array, we know the pivot is to the right of the mid pointer. If value at mid pointer is smaller than right most value in the array, we know that the pivot is to the left. Split array in half until your left and right pointers touch.\\n- Step 2\\n\\t- Do a 2nd binary search on the whole array. This time we are looking for the target, not a pivot. Now that we know our pivot we just need to modify our midvalue like so: realMid = (mid + pivot) % nums.Length;\\n\\nComplexity of 2 binary searches is O ( 2 Log (n)) which is O (Log(n))"
                    },
                    {
                        "username": "Nitkapur30",
                        "content": "Solution explained: \\nhttps://leetcode.com/problems/search-in-rotated-sorted-array/solutions/3782253/c-binary-search-solution-with-breakdown-of-each-condition/"
                    },
                    {
                        "username": "srapol",
                        "content": "[@Aishwarya_jits](/Aishwarya_jits) how ?"
                    },
                    {
                        "username": "bparanj",
                        "content": "[@shape_mismatch](/shape_mismatch) Actually, both approaches are equally efficient when it comes to handling the case where the array is not pivoted, or sorted. This is because the binary search is performed based on the relationship between the target and the elements at the left, mid, and right positions, not based on whether the array is sorted or not.\\n\\nHowever, comparing with the leftmost element in the array does have an advantage when the array has duplicate values. In case of duplicate values, comparing with the rightmost element might lead to scenarios where we\\'re unable to decide which half of the array to proceed with, thus degrading the performance to O(n) in the worst-case scenario. On the other hand, comparing with the leftmost element can help us avoid such scenarios, thus maintaining a time complexity of O(log n) even when the array contains duplicate values.\\n"
                    },
                    {
                        "username": "Ramonsan07",
                        "content": "was ramdomly checking this problem and  remembered I had solved this in the way you describe https://leetcode.com/problems/search-in-rotated-sorted-array/solutions/3498417/easiest-intuitive-simple-two-binary-searches-solution/"
                    },
                    {
                        "username": "dragon1105",
                        "content": "[@shape_mismatch](/shape_mismatch) I think to compare mid with either the leftmost or the rightmost value is the same, because the probabilities that the pivot is located closer to the left side or to the right side are equal.\\nAnd for the case the array is not pivoted, we just need to check at the beginning whether the leftmost value is less than the rightmost value. If it is, then the array is not pivoted, because if the array is then leftmost must be greater than rightmost."
                    },
                    {
                        "username": "Salominius",
                        "content": "[@lucasscodes](/lucasscodes) 2*O(log n) is NOT O(n) but in fact O(log n).\\nJust as 2 * log n is not n."
                    },
                    {
                        "username": "Aishwarya_jits",
                        "content": "You dont need to do binary search twice, the target can be found in one search by tweaking the binary search code to accommodate for the pivoted element. My point is you dont necessarily have to find the pivot, your code just needs to be aware of its existence. "
                    },
                    {
                        "username": "imankulov53",
                        "content": "thank you for your idea to find pivot on which array is rotated, it\\'s simplifies task and give clear and simple solution"
                    },
                    {
                        "username": "user2748pU",
                        "content": "[@lucasscodes](/lucasscodes) actually what u are saying is wrong, binary search doesn\\'t take n/2 time, it takes log(n) time, so even doing it twice will result in a \"real time\" of 2 times of what it took do do a binary search once (=> 2*log(n)), which will in turn result in O(log(n)), since we ignore constant factors (like the 2*) in big O-Notation."
                    },
                    {
                        "username": "lucasscodes",
                        "content": "This has O(n) complexity.\\n2 times n/2 => n.\\nDont even mind binary search if you need to do it twice..."
                    },
                    {
                        "username": "spencerreitz2002",
                        "content": "[@shape_mismatch](/shape_mismatch) I believe the opposite it true. If the array is pivoted one place to the left, the number at the leftmost position of the array is less than the middle, but the rightmost point is now less than the middle also."
                    },
                    {
                        "username": "_arjan31",
                        "content": "To get it in log(N) complexity , follow strivers method"
                    },
                    {
                        "username": "shape_mismatch",
                        "content": "Wouldn\\'t it be better to compare with the leftmost value in the array (step 1), instead of the rightmost. It would be faster in taking care of cases where the array is not pivoted?"
                    },
                    {
                        "username": "charly371",
                        "content": "I get an error with the following test case: ([1,3], 1) which should output 0 since the integer 1 is present at index 0. \\nMy solution did not work for this one because I based it on the fact that the array will get rotate somewhere. \\n\\nI m thus wondering if you think this test case is valid ? or maybe the exercise should be change to say that the array may be rotated (but not necessarily is...) ?\\n\\nI will change my algo but i would like your feedback in case it was a real interview. what would you say ?\\nThx"
                    },
                    {
                        "username": "olsonpm",
                        "content": "[@vaishali_p14](/vaishali_p14) It also doesn\\'t say what to return in the case it\\'s not rotated\\n\\n> return the index of target if it is in nums, or -1 if it is not in nums"
                    },
                    {
                        "username": "GitG0",
                        "content": "people in 2023 answering a question asked in 2017 without knowing if the constraints or the question itself were modified in those ~6 years lol "
                    },
                    {
                        "username": "raghavsharmaji",
                        "content": "What do you think is meant by \"is possibly rotated\"?"
                    },
                    {
                        "username": "devansh10z",
                        "content": "suppose a case where an array of length n is rotated n times. you get the same array. that is the only reason this test case is a valid case."
                    },
                    {
                        "username": "AHawkeye",
                        "content": "[@vaishali_p14](/vaishali_p14)  But in the description, is says that k >= 1, which means the arrayed must be rotated."
                    },
                    {
                        "username": "sanjay2207",
                        "content": "You may not be checking one of <= or >= conditions correctly. I ran into same issue."
                    },
                    {
                        "username": "vaishali_p14",
                        "content": "In the question, it is mentioned that the passed array is sorted and POSSIBLY rotated."
                    },
                    {
                        "username": "hafezachu",
                        "content": "The main idea is to use binary search to find the target in the array. Binary search is a technique that divides the search space into two halves and compares the target with the middle element. If the target is equal to the middle element, we have found the index. If the target is smaller than the middle element, we search in the left half. If the target is larger than the middle element, we search in the right half. This way, we can reduce the search space by half in each iteration and achieve O(log n) runtime complexity.\\n\\nHowever, since the array is possibly rotated at some unknown pivot, we cannot directly apply binary search. We need to modify it slightly to handle the rotation. The key observation is that one of the two halves must be sorted, and the other half must contain the pivot. For example, if the array is [4,5,6,7,0,1,2], then the left half [4,5,6,7] is sorted and the right half [0,1,2] contains the pivot. If the array is [7,0,1,2,4,5,6], then the right half [2,4,5,6] is sorted and the left half [7,0,1] contains the pivot.\\n\\nSo, in each iteration of binary search, we first check which half is sorted by comparing the left and middle elements. Then we check if the target is in that sorted half by comparing it with the left and middle elements. If it is in that sorted half, we search in that half as usual. If it is not in that sorted half, we search in the other half that contains the pivot.\\n\\nFor example, if the array is [4,5,6,7,0,1,2] and the target is 0:\\n\\n- We start with left = 0 and right = 6. The middle index is 3 and the middle element is 7.\\n- We see that the left half [4,5,6,7] is sorted and the right half [0,1,2] contains the pivot.\\n- We check if the target 0 is in the left half by comparing it with 4 and 7. It is not in that half because 0 < 4 < 7.\\n- So we search in the right half that contains the pivot by setting left = mid + 1 = 4.\\n- We repeat this process until we find the target or exhaust the search space."
                    },
                    {
                        "username": "dragon1105",
                        "content": "Thank you. This is probably the most elegant way to solve this problem. With this solution, we don\\'t even need to find the pivot\\'s location, which is quite smart."
                    },
                    {
                        "username": "jackbb147",
                        "content": "thank you. Great explanation"
                    },
                    {
                        "username": "eugk123",
                        "content": "Why is there a [1,3,5] test case?\\n\\nIt\\'s not that big of a deal, but the problem states it guarantee\\'s pivot in all test cases. Leetcode team, please either remove that statement or fix your test case."
                    },
                    {
                        "username": "amansingh4958",
                        "content": "Just avoid finding pivot for these cases by just comparing 1st and last element of the array"
                    },
                    {
                        "username": "heyyyankit",
                        "content": "[@pranavagrawal321](/pranavagrawal321)its given that ( 1 <= k < nums.length) so this is not possible..."
                    },
                    {
                        "username": "Gautamparti",
                        "content": "question clearly states \"possibly rotated\" , which means you have to include a case where their is no pivot"
                    },
                    {
                        "username": "mrunfunny",
                        "content": "[@pranavagrawal321](/pranavagrawal321) That\\'s one way to look at this :XD"
                    },
                    {
                        "username": "pranavagrawal321",
                        "content": "The test case is correct, since the array can be rotated thrice, resulting in the original sorted array."
                    },
                    {
                        "username": "brauliojde",
                        "content": "I believe that there is an error in one of the test cases because the array that is entered is [1,3] and in this array there is no rotation. "
                    },
                    {
                        "username": "vaishali_p14",
                        "content": "In the question, it is mentioned that the passed array is sorted and POSSIBLY rotated.\\n\\n"
                    },
                    {
                        "username": "Yanlin0408",
                        "content": "[@lakshminathan](/lakshminathan) lmao"
                    },
                    {
                        "username": "lakshminathan",
                        "content": "it is rotated twice"
                    },
                    {
                        "username": "euphoria_kiki",
                        "content": "The key idea is during the process fo binary search, we compare the number at position mid and position left. If the number at mid is larger, it implies that range [left, mid] is ordered (not rotated), so we can decide whether to move towards that range for further search. Otherwise, the number at mid is smaller, which implies that range [mid, right] is ordered (not rotated)."
                    },
                    {
                        "username": "Spam_Musubi",
                        "content": "nice, I was wondering why this was on the medium side, they should\\'ve made something to make this harder and for us to naturally come up with the binary search.\\n"
                    },
                    {
                        "username": "insomniachou",
                        "content": "I don't think this problem is for JS. I saw someone's (n + logn) solution, was wondering why not just compare one by one, resulting in O(n). Not sure the question is asking the index in the sorted array or in the rotated array.  I tried js build-in array method, and surprisingly my answer passed and beats 60%.  \\n\\n\\tvar search = function(nums, target) {\\n\\t\\treturn nums.indexOf(target);\\n\\t};"
                    },
                    {
                        "username": "danielmascena",
                        "content": "doesnt matter the programming language but the approach used"
                    },
                    {
                        "username": "rohiinegi2002",
                        "content": "it will pass... Cause you are using a function that runs of O(logn) time complexity and is called Binary Search..(^ ^)"
                    },
                    {
                        "username": "normanlmfung",
                        "content": "Same in pyton: def search(self, nums: List[int], target: int) -> int:\\n        if target in nums:\\n            return nums.index(target)\\n        else:\\n            return -1"
                    },
                    {
                        "username": "ladiaz4e98",
                        "content": "this is wrong. this is o(n), question is asking for o(log(n)).."
                    },
                    {
                        "username": "thedevwonder",
                        "content": "JS solution in O(logn) works, my answer beats 90%. I think it is independent of programming lang as long as you don\\'t use built in functions"
                    },
                    {
                        "username": "mohaymenrafi",
                        "content": "[@christinehong](/christinehong) when you use indexOf method, in worse case, it actually traverse the entire array which is O(n) operation. but in the question it specifically mentioned to use O(log n)"
                    },
                    {
                        "username": "christinehong",
                        "content": "that was literally my line of logic and i ended up with the same solution but in python"
                    },
                    {
                        "username": "gurnainwadhwa",
                        "content": "Just Binary Search"
                    },
                    {
                        "username": "anwendeng",
                        "content": "This problem is solved by using binary search several times.\nFirstly, it is suggested to find the location for the peak which can be done by binary search. \nSecondly, using  binary search to find location for the target  which  is possible before the peak or after the peak.\n\n# Be careful for the boundary cases when n=1 and n=2."
                    }
                ]
            },
            {
                "id": 1576279,
                "content": [
                    {
                        "username": "ss9394",
                        "content": "The problem is intented for Binary search. \\nBut if some is simply travering once  i.e  O(n) , It beats 100% . Which should not be the case. \\n\\nIt should only succeed for binary search based solution. i.e. O(log n)\\n\\n"
                    },
                    {
                        "username": "kaustubhmjb",
                        "content": "Big O notation is asymptotic. An absolute runtime of 2048n is slower than 128n**2, for values of n < 16 (also referred to as n0 in some definitions). Big O notation focuses on rate of change as input size grows arbitrarily."
                    },
                    {
                        "username": "gbiems",
                        "content": "I did binary search, and ran it 3 times, I got 99.5%, 6.3%, and 32%. So I wouldn\\'t put too much stock in the runtime for this.\\n\\nThat said, agreed, surprising you\\'d didn\\'t get a TLE with linear search. "
                    },
                    {
                        "username": "CaptainGalbatrollix",
                        "content": "[@pru_cuder](/pru_cuder) Well that\\'s not true in essence. Yes, big(O) notation is important and leetcode\\'s runtime judgement can be weird and leave a lot to be desired. \\n\\nHowever, it is crucial to remember big(O) is not the end all be all. If the overhead is big enough, for smaller input sizes \\'worse\\' solutions tend to be much more efficient due to factors such as cache locality. For example C++ built in sort switches from quicksort to insertion sort o(n^2) time complexity, when arrays get small enough. \\n\\nIn real life, solving this problem using bsearch would be questionable. Biggest possible size of array in the problem is 5000. If it was 5 * 10^6, then yeah double bsearch is the way to go and can save a lot of time, but you can\\'t honestly tell me a 5000 element loop will be a bottleneck in any system."
                    },
                    {
                        "username": "shivanshutripathii",
                        "content": "Exactly, I\\'ve applied binary search method and it beats only 8.19% in time (O(logn)).\\nWhen I\\'ve applied linear search then it beats 13.60% in time O(n). Crazy things happen."
                    },
                    {
                        "username": "pru_cuder",
                        "content": "those runtimes are based on machine i.e cpu config as well as programming language. Never take these runtimes as a parameter, always focus on Big O notation"
                    },
                    {
                        "username": "mandy1339",
                        "content": "First do a binary search to find the pivot:\\n\\n- Step 1\\n\\t-  compare mid pointer to right most value on the array. If value in mid pointer is greater than right most value in array, we know the pivot is to the right of the mid pointer. If value at mid pointer is smaller than right most value in the array, we know that the pivot is to the left. Split array in half until your left and right pointers touch.\\n- Step 2\\n\\t- Do a 2nd binary search on the whole array. This time we are looking for the target, not a pivot. Now that we know our pivot we just need to modify our midvalue like so: realMid = (mid + pivot) % nums.Length;\\n\\nComplexity of 2 binary searches is O ( 2 Log (n)) which is O (Log(n))"
                    },
                    {
                        "username": "Nitkapur30",
                        "content": "Solution explained: \\nhttps://leetcode.com/problems/search-in-rotated-sorted-array/solutions/3782253/c-binary-search-solution-with-breakdown-of-each-condition/"
                    },
                    {
                        "username": "srapol",
                        "content": "[@Aishwarya_jits](/Aishwarya_jits) how ?"
                    },
                    {
                        "username": "bparanj",
                        "content": "[@shape_mismatch](/shape_mismatch) Actually, both approaches are equally efficient when it comes to handling the case where the array is not pivoted, or sorted. This is because the binary search is performed based on the relationship between the target and the elements at the left, mid, and right positions, not based on whether the array is sorted or not.\\n\\nHowever, comparing with the leftmost element in the array does have an advantage when the array has duplicate values. In case of duplicate values, comparing with the rightmost element might lead to scenarios where we\\'re unable to decide which half of the array to proceed with, thus degrading the performance to O(n) in the worst-case scenario. On the other hand, comparing with the leftmost element can help us avoid such scenarios, thus maintaining a time complexity of O(log n) even when the array contains duplicate values.\\n"
                    },
                    {
                        "username": "Ramonsan07",
                        "content": "was ramdomly checking this problem and  remembered I had solved this in the way you describe https://leetcode.com/problems/search-in-rotated-sorted-array/solutions/3498417/easiest-intuitive-simple-two-binary-searches-solution/"
                    },
                    {
                        "username": "dragon1105",
                        "content": "[@shape_mismatch](/shape_mismatch) I think to compare mid with either the leftmost or the rightmost value is the same, because the probabilities that the pivot is located closer to the left side or to the right side are equal.\\nAnd for the case the array is not pivoted, we just need to check at the beginning whether the leftmost value is less than the rightmost value. If it is, then the array is not pivoted, because if the array is then leftmost must be greater than rightmost."
                    },
                    {
                        "username": "Salominius",
                        "content": "[@lucasscodes](/lucasscodes) 2*O(log n) is NOT O(n) but in fact O(log n).\\nJust as 2 * log n is not n."
                    },
                    {
                        "username": "Aishwarya_jits",
                        "content": "You dont need to do binary search twice, the target can be found in one search by tweaking the binary search code to accommodate for the pivoted element. My point is you dont necessarily have to find the pivot, your code just needs to be aware of its existence. "
                    },
                    {
                        "username": "imankulov53",
                        "content": "thank you for your idea to find pivot on which array is rotated, it\\'s simplifies task and give clear and simple solution"
                    },
                    {
                        "username": "user2748pU",
                        "content": "[@lucasscodes](/lucasscodes) actually what u are saying is wrong, binary search doesn\\'t take n/2 time, it takes log(n) time, so even doing it twice will result in a \"real time\" of 2 times of what it took do do a binary search once (=> 2*log(n)), which will in turn result in O(log(n)), since we ignore constant factors (like the 2*) in big O-Notation."
                    },
                    {
                        "username": "lucasscodes",
                        "content": "This has O(n) complexity.\\n2 times n/2 => n.\\nDont even mind binary search if you need to do it twice..."
                    },
                    {
                        "username": "spencerreitz2002",
                        "content": "[@shape_mismatch](/shape_mismatch) I believe the opposite it true. If the array is pivoted one place to the left, the number at the leftmost position of the array is less than the middle, but the rightmost point is now less than the middle also."
                    },
                    {
                        "username": "_arjan31",
                        "content": "To get it in log(N) complexity , follow strivers method"
                    },
                    {
                        "username": "shape_mismatch",
                        "content": "Wouldn\\'t it be better to compare with the leftmost value in the array (step 1), instead of the rightmost. It would be faster in taking care of cases where the array is not pivoted?"
                    },
                    {
                        "username": "charly371",
                        "content": "I get an error with the following test case: ([1,3], 1) which should output 0 since the integer 1 is present at index 0. \\nMy solution did not work for this one because I based it on the fact that the array will get rotate somewhere. \\n\\nI m thus wondering if you think this test case is valid ? or maybe the exercise should be change to say that the array may be rotated (but not necessarily is...) ?\\n\\nI will change my algo but i would like your feedback in case it was a real interview. what would you say ?\\nThx"
                    },
                    {
                        "username": "olsonpm",
                        "content": "[@vaishali_p14](/vaishali_p14) It also doesn\\'t say what to return in the case it\\'s not rotated\\n\\n> return the index of target if it is in nums, or -1 if it is not in nums"
                    },
                    {
                        "username": "GitG0",
                        "content": "people in 2023 answering a question asked in 2017 without knowing if the constraints or the question itself were modified in those ~6 years lol "
                    },
                    {
                        "username": "raghavsharmaji",
                        "content": "What do you think is meant by \"is possibly rotated\"?"
                    },
                    {
                        "username": "devansh10z",
                        "content": "suppose a case where an array of length n is rotated n times. you get the same array. that is the only reason this test case is a valid case."
                    },
                    {
                        "username": "AHawkeye",
                        "content": "[@vaishali_p14](/vaishali_p14)  But in the description, is says that k >= 1, which means the arrayed must be rotated."
                    },
                    {
                        "username": "sanjay2207",
                        "content": "You may not be checking one of <= or >= conditions correctly. I ran into same issue."
                    },
                    {
                        "username": "vaishali_p14",
                        "content": "In the question, it is mentioned that the passed array is sorted and POSSIBLY rotated."
                    },
                    {
                        "username": "hafezachu",
                        "content": "The main idea is to use binary search to find the target in the array. Binary search is a technique that divides the search space into two halves and compares the target with the middle element. If the target is equal to the middle element, we have found the index. If the target is smaller than the middle element, we search in the left half. If the target is larger than the middle element, we search in the right half. This way, we can reduce the search space by half in each iteration and achieve O(log n) runtime complexity.\\n\\nHowever, since the array is possibly rotated at some unknown pivot, we cannot directly apply binary search. We need to modify it slightly to handle the rotation. The key observation is that one of the two halves must be sorted, and the other half must contain the pivot. For example, if the array is [4,5,6,7,0,1,2], then the left half [4,5,6,7] is sorted and the right half [0,1,2] contains the pivot. If the array is [7,0,1,2,4,5,6], then the right half [2,4,5,6] is sorted and the left half [7,0,1] contains the pivot.\\n\\nSo, in each iteration of binary search, we first check which half is sorted by comparing the left and middle elements. Then we check if the target is in that sorted half by comparing it with the left and middle elements. If it is in that sorted half, we search in that half as usual. If it is not in that sorted half, we search in the other half that contains the pivot.\\n\\nFor example, if the array is [4,5,6,7,0,1,2] and the target is 0:\\n\\n- We start with left = 0 and right = 6. The middle index is 3 and the middle element is 7.\\n- We see that the left half [4,5,6,7] is sorted and the right half [0,1,2] contains the pivot.\\n- We check if the target 0 is in the left half by comparing it with 4 and 7. It is not in that half because 0 < 4 < 7.\\n- So we search in the right half that contains the pivot by setting left = mid + 1 = 4.\\n- We repeat this process until we find the target or exhaust the search space."
                    },
                    {
                        "username": "dragon1105",
                        "content": "Thank you. This is probably the most elegant way to solve this problem. With this solution, we don\\'t even need to find the pivot\\'s location, which is quite smart."
                    },
                    {
                        "username": "jackbb147",
                        "content": "thank you. Great explanation"
                    },
                    {
                        "username": "eugk123",
                        "content": "Why is there a [1,3,5] test case?\\n\\nIt\\'s not that big of a deal, but the problem states it guarantee\\'s pivot in all test cases. Leetcode team, please either remove that statement or fix your test case."
                    },
                    {
                        "username": "amansingh4958",
                        "content": "Just avoid finding pivot for these cases by just comparing 1st and last element of the array"
                    },
                    {
                        "username": "heyyyankit",
                        "content": "[@pranavagrawal321](/pranavagrawal321)its given that ( 1 <= k < nums.length) so this is not possible..."
                    },
                    {
                        "username": "Gautamparti",
                        "content": "question clearly states \"possibly rotated\" , which means you have to include a case where their is no pivot"
                    },
                    {
                        "username": "mrunfunny",
                        "content": "[@pranavagrawal321](/pranavagrawal321) That\\'s one way to look at this :XD"
                    },
                    {
                        "username": "pranavagrawal321",
                        "content": "The test case is correct, since the array can be rotated thrice, resulting in the original sorted array."
                    },
                    {
                        "username": "brauliojde",
                        "content": "I believe that there is an error in one of the test cases because the array that is entered is [1,3] and in this array there is no rotation. "
                    },
                    {
                        "username": "vaishali_p14",
                        "content": "In the question, it is mentioned that the passed array is sorted and POSSIBLY rotated.\\n\\n"
                    },
                    {
                        "username": "Yanlin0408",
                        "content": "[@lakshminathan](/lakshminathan) lmao"
                    },
                    {
                        "username": "lakshminathan",
                        "content": "it is rotated twice"
                    },
                    {
                        "username": "euphoria_kiki",
                        "content": "The key idea is during the process fo binary search, we compare the number at position mid and position left. If the number at mid is larger, it implies that range [left, mid] is ordered (not rotated), so we can decide whether to move towards that range for further search. Otherwise, the number at mid is smaller, which implies that range [mid, right] is ordered (not rotated)."
                    },
                    {
                        "username": "Spam_Musubi",
                        "content": "nice, I was wondering why this was on the medium side, they should\\'ve made something to make this harder and for us to naturally come up with the binary search.\\n"
                    },
                    {
                        "username": "insomniachou",
                        "content": "I don't think this problem is for JS. I saw someone's (n + logn) solution, was wondering why not just compare one by one, resulting in O(n). Not sure the question is asking the index in the sorted array or in the rotated array.  I tried js build-in array method, and surprisingly my answer passed and beats 60%.  \\n\\n\\tvar search = function(nums, target) {\\n\\t\\treturn nums.indexOf(target);\\n\\t};"
                    },
                    {
                        "username": "danielmascena",
                        "content": "doesnt matter the programming language but the approach used"
                    },
                    {
                        "username": "rohiinegi2002",
                        "content": "it will pass... Cause you are using a function that runs of O(logn) time complexity and is called Binary Search..(^ ^)"
                    },
                    {
                        "username": "normanlmfung",
                        "content": "Same in pyton: def search(self, nums: List[int], target: int) -> int:\\n        if target in nums:\\n            return nums.index(target)\\n        else:\\n            return -1"
                    },
                    {
                        "username": "ladiaz4e98",
                        "content": "this is wrong. this is o(n), question is asking for o(log(n)).."
                    },
                    {
                        "username": "thedevwonder",
                        "content": "JS solution in O(logn) works, my answer beats 90%. I think it is independent of programming lang as long as you don\\'t use built in functions"
                    },
                    {
                        "username": "mohaymenrafi",
                        "content": "[@christinehong](/christinehong) when you use indexOf method, in worse case, it actually traverse the entire array which is O(n) operation. but in the question it specifically mentioned to use O(log n)"
                    },
                    {
                        "username": "christinehong",
                        "content": "that was literally my line of logic and i ended up with the same solution but in python"
                    },
                    {
                        "username": "gurnainwadhwa",
                        "content": "Just Binary Search"
                    },
                    {
                        "username": "anwendeng",
                        "content": "This problem is solved by using binary search several times.\nFirstly, it is suggested to find the location for the peak which can be done by binary search. \nSecondly, using  binary search to find location for the target  which  is possible before the peak or after the peak.\n\n# Be careful for the boundary cases when n=1 and n=2."
                    }
                ]
            },
            {
                "id": 1565736,
                "content": [
                    {
                        "username": "ss9394",
                        "content": "The problem is intented for Binary search. \\nBut if some is simply travering once  i.e  O(n) , It beats 100% . Which should not be the case. \\n\\nIt should only succeed for binary search based solution. i.e. O(log n)\\n\\n"
                    },
                    {
                        "username": "kaustubhmjb",
                        "content": "Big O notation is asymptotic. An absolute runtime of 2048n is slower than 128n**2, for values of n < 16 (also referred to as n0 in some definitions). Big O notation focuses on rate of change as input size grows arbitrarily."
                    },
                    {
                        "username": "gbiems",
                        "content": "I did binary search, and ran it 3 times, I got 99.5%, 6.3%, and 32%. So I wouldn\\'t put too much stock in the runtime for this.\\n\\nThat said, agreed, surprising you\\'d didn\\'t get a TLE with linear search. "
                    },
                    {
                        "username": "CaptainGalbatrollix",
                        "content": "[@pru_cuder](/pru_cuder) Well that\\'s not true in essence. Yes, big(O) notation is important and leetcode\\'s runtime judgement can be weird and leave a lot to be desired. \\n\\nHowever, it is crucial to remember big(O) is not the end all be all. If the overhead is big enough, for smaller input sizes \\'worse\\' solutions tend to be much more efficient due to factors such as cache locality. For example C++ built in sort switches from quicksort to insertion sort o(n^2) time complexity, when arrays get small enough. \\n\\nIn real life, solving this problem using bsearch would be questionable. Biggest possible size of array in the problem is 5000. If it was 5 * 10^6, then yeah double bsearch is the way to go and can save a lot of time, but you can\\'t honestly tell me a 5000 element loop will be a bottleneck in any system."
                    },
                    {
                        "username": "shivanshutripathii",
                        "content": "Exactly, I\\'ve applied binary search method and it beats only 8.19% in time (O(logn)).\\nWhen I\\'ve applied linear search then it beats 13.60% in time O(n). Crazy things happen."
                    },
                    {
                        "username": "pru_cuder",
                        "content": "those runtimes are based on machine i.e cpu config as well as programming language. Never take these runtimes as a parameter, always focus on Big O notation"
                    },
                    {
                        "username": "mandy1339",
                        "content": "First do a binary search to find the pivot:\\n\\n- Step 1\\n\\t-  compare mid pointer to right most value on the array. If value in mid pointer is greater than right most value in array, we know the pivot is to the right of the mid pointer. If value at mid pointer is smaller than right most value in the array, we know that the pivot is to the left. Split array in half until your left and right pointers touch.\\n- Step 2\\n\\t- Do a 2nd binary search on the whole array. This time we are looking for the target, not a pivot. Now that we know our pivot we just need to modify our midvalue like so: realMid = (mid + pivot) % nums.Length;\\n\\nComplexity of 2 binary searches is O ( 2 Log (n)) which is O (Log(n))"
                    },
                    {
                        "username": "Nitkapur30",
                        "content": "Solution explained: \\nhttps://leetcode.com/problems/search-in-rotated-sorted-array/solutions/3782253/c-binary-search-solution-with-breakdown-of-each-condition/"
                    },
                    {
                        "username": "srapol",
                        "content": "[@Aishwarya_jits](/Aishwarya_jits) how ?"
                    },
                    {
                        "username": "bparanj",
                        "content": "[@shape_mismatch](/shape_mismatch) Actually, both approaches are equally efficient when it comes to handling the case where the array is not pivoted, or sorted. This is because the binary search is performed based on the relationship between the target and the elements at the left, mid, and right positions, not based on whether the array is sorted or not.\\n\\nHowever, comparing with the leftmost element in the array does have an advantage when the array has duplicate values. In case of duplicate values, comparing with the rightmost element might lead to scenarios where we\\'re unable to decide which half of the array to proceed with, thus degrading the performance to O(n) in the worst-case scenario. On the other hand, comparing with the leftmost element can help us avoid such scenarios, thus maintaining a time complexity of O(log n) even when the array contains duplicate values.\\n"
                    },
                    {
                        "username": "Ramonsan07",
                        "content": "was ramdomly checking this problem and  remembered I had solved this in the way you describe https://leetcode.com/problems/search-in-rotated-sorted-array/solutions/3498417/easiest-intuitive-simple-two-binary-searches-solution/"
                    },
                    {
                        "username": "dragon1105",
                        "content": "[@shape_mismatch](/shape_mismatch) I think to compare mid with either the leftmost or the rightmost value is the same, because the probabilities that the pivot is located closer to the left side or to the right side are equal.\\nAnd for the case the array is not pivoted, we just need to check at the beginning whether the leftmost value is less than the rightmost value. If it is, then the array is not pivoted, because if the array is then leftmost must be greater than rightmost."
                    },
                    {
                        "username": "Salominius",
                        "content": "[@lucasscodes](/lucasscodes) 2*O(log n) is NOT O(n) but in fact O(log n).\\nJust as 2 * log n is not n."
                    },
                    {
                        "username": "Aishwarya_jits",
                        "content": "You dont need to do binary search twice, the target can be found in one search by tweaking the binary search code to accommodate for the pivoted element. My point is you dont necessarily have to find the pivot, your code just needs to be aware of its existence. "
                    },
                    {
                        "username": "imankulov53",
                        "content": "thank you for your idea to find pivot on which array is rotated, it\\'s simplifies task and give clear and simple solution"
                    },
                    {
                        "username": "user2748pU",
                        "content": "[@lucasscodes](/lucasscodes) actually what u are saying is wrong, binary search doesn\\'t take n/2 time, it takes log(n) time, so even doing it twice will result in a \"real time\" of 2 times of what it took do do a binary search once (=> 2*log(n)), which will in turn result in O(log(n)), since we ignore constant factors (like the 2*) in big O-Notation."
                    },
                    {
                        "username": "lucasscodes",
                        "content": "This has O(n) complexity.\\n2 times n/2 => n.\\nDont even mind binary search if you need to do it twice..."
                    },
                    {
                        "username": "spencerreitz2002",
                        "content": "[@shape_mismatch](/shape_mismatch) I believe the opposite it true. If the array is pivoted one place to the left, the number at the leftmost position of the array is less than the middle, but the rightmost point is now less than the middle also."
                    },
                    {
                        "username": "_arjan31",
                        "content": "To get it in log(N) complexity , follow strivers method"
                    },
                    {
                        "username": "shape_mismatch",
                        "content": "Wouldn\\'t it be better to compare with the leftmost value in the array (step 1), instead of the rightmost. It would be faster in taking care of cases where the array is not pivoted?"
                    },
                    {
                        "username": "charly371",
                        "content": "I get an error with the following test case: ([1,3], 1) which should output 0 since the integer 1 is present at index 0. \\nMy solution did not work for this one because I based it on the fact that the array will get rotate somewhere. \\n\\nI m thus wondering if you think this test case is valid ? or maybe the exercise should be change to say that the array may be rotated (but not necessarily is...) ?\\n\\nI will change my algo but i would like your feedback in case it was a real interview. what would you say ?\\nThx"
                    },
                    {
                        "username": "olsonpm",
                        "content": "[@vaishali_p14](/vaishali_p14) It also doesn\\'t say what to return in the case it\\'s not rotated\\n\\n> return the index of target if it is in nums, or -1 if it is not in nums"
                    },
                    {
                        "username": "GitG0",
                        "content": "people in 2023 answering a question asked in 2017 without knowing if the constraints or the question itself were modified in those ~6 years lol "
                    },
                    {
                        "username": "raghavsharmaji",
                        "content": "What do you think is meant by \"is possibly rotated\"?"
                    },
                    {
                        "username": "devansh10z",
                        "content": "suppose a case where an array of length n is rotated n times. you get the same array. that is the only reason this test case is a valid case."
                    },
                    {
                        "username": "AHawkeye",
                        "content": "[@vaishali_p14](/vaishali_p14)  But in the description, is says that k >= 1, which means the arrayed must be rotated."
                    },
                    {
                        "username": "sanjay2207",
                        "content": "You may not be checking one of <= or >= conditions correctly. I ran into same issue."
                    },
                    {
                        "username": "vaishali_p14",
                        "content": "In the question, it is mentioned that the passed array is sorted and POSSIBLY rotated."
                    },
                    {
                        "username": "hafezachu",
                        "content": "The main idea is to use binary search to find the target in the array. Binary search is a technique that divides the search space into two halves and compares the target with the middle element. If the target is equal to the middle element, we have found the index. If the target is smaller than the middle element, we search in the left half. If the target is larger than the middle element, we search in the right half. This way, we can reduce the search space by half in each iteration and achieve O(log n) runtime complexity.\\n\\nHowever, since the array is possibly rotated at some unknown pivot, we cannot directly apply binary search. We need to modify it slightly to handle the rotation. The key observation is that one of the two halves must be sorted, and the other half must contain the pivot. For example, if the array is [4,5,6,7,0,1,2], then the left half [4,5,6,7] is sorted and the right half [0,1,2] contains the pivot. If the array is [7,0,1,2,4,5,6], then the right half [2,4,5,6] is sorted and the left half [7,0,1] contains the pivot.\\n\\nSo, in each iteration of binary search, we first check which half is sorted by comparing the left and middle elements. Then we check if the target is in that sorted half by comparing it with the left and middle elements. If it is in that sorted half, we search in that half as usual. If it is not in that sorted half, we search in the other half that contains the pivot.\\n\\nFor example, if the array is [4,5,6,7,0,1,2] and the target is 0:\\n\\n- We start with left = 0 and right = 6. The middle index is 3 and the middle element is 7.\\n- We see that the left half [4,5,6,7] is sorted and the right half [0,1,2] contains the pivot.\\n- We check if the target 0 is in the left half by comparing it with 4 and 7. It is not in that half because 0 < 4 < 7.\\n- So we search in the right half that contains the pivot by setting left = mid + 1 = 4.\\n- We repeat this process until we find the target or exhaust the search space."
                    },
                    {
                        "username": "dragon1105",
                        "content": "Thank you. This is probably the most elegant way to solve this problem. With this solution, we don\\'t even need to find the pivot\\'s location, which is quite smart."
                    },
                    {
                        "username": "jackbb147",
                        "content": "thank you. Great explanation"
                    },
                    {
                        "username": "eugk123",
                        "content": "Why is there a [1,3,5] test case?\\n\\nIt\\'s not that big of a deal, but the problem states it guarantee\\'s pivot in all test cases. Leetcode team, please either remove that statement or fix your test case."
                    },
                    {
                        "username": "amansingh4958",
                        "content": "Just avoid finding pivot for these cases by just comparing 1st and last element of the array"
                    },
                    {
                        "username": "heyyyankit",
                        "content": "[@pranavagrawal321](/pranavagrawal321)its given that ( 1 <= k < nums.length) so this is not possible..."
                    },
                    {
                        "username": "Gautamparti",
                        "content": "question clearly states \"possibly rotated\" , which means you have to include a case where their is no pivot"
                    },
                    {
                        "username": "mrunfunny",
                        "content": "[@pranavagrawal321](/pranavagrawal321) That\\'s one way to look at this :XD"
                    },
                    {
                        "username": "pranavagrawal321",
                        "content": "The test case is correct, since the array can be rotated thrice, resulting in the original sorted array."
                    },
                    {
                        "username": "brauliojde",
                        "content": "I believe that there is an error in one of the test cases because the array that is entered is [1,3] and in this array there is no rotation. "
                    },
                    {
                        "username": "vaishali_p14",
                        "content": "In the question, it is mentioned that the passed array is sorted and POSSIBLY rotated.\\n\\n"
                    },
                    {
                        "username": "Yanlin0408",
                        "content": "[@lakshminathan](/lakshminathan) lmao"
                    },
                    {
                        "username": "lakshminathan",
                        "content": "it is rotated twice"
                    },
                    {
                        "username": "euphoria_kiki",
                        "content": "The key idea is during the process fo binary search, we compare the number at position mid and position left. If the number at mid is larger, it implies that range [left, mid] is ordered (not rotated), so we can decide whether to move towards that range for further search. Otherwise, the number at mid is smaller, which implies that range [mid, right] is ordered (not rotated)."
                    },
                    {
                        "username": "Spam_Musubi",
                        "content": "nice, I was wondering why this was on the medium side, they should\\'ve made something to make this harder and for us to naturally come up with the binary search.\\n"
                    },
                    {
                        "username": "insomniachou",
                        "content": "I don't think this problem is for JS. I saw someone's (n + logn) solution, was wondering why not just compare one by one, resulting in O(n). Not sure the question is asking the index in the sorted array or in the rotated array.  I tried js build-in array method, and surprisingly my answer passed and beats 60%.  \\n\\n\\tvar search = function(nums, target) {\\n\\t\\treturn nums.indexOf(target);\\n\\t};"
                    },
                    {
                        "username": "danielmascena",
                        "content": "doesnt matter the programming language but the approach used"
                    },
                    {
                        "username": "rohiinegi2002",
                        "content": "it will pass... Cause you are using a function that runs of O(logn) time complexity and is called Binary Search..(^ ^)"
                    },
                    {
                        "username": "normanlmfung",
                        "content": "Same in pyton: def search(self, nums: List[int], target: int) -> int:\\n        if target in nums:\\n            return nums.index(target)\\n        else:\\n            return -1"
                    },
                    {
                        "username": "ladiaz4e98",
                        "content": "this is wrong. this is o(n), question is asking for o(log(n)).."
                    },
                    {
                        "username": "thedevwonder",
                        "content": "JS solution in O(logn) works, my answer beats 90%. I think it is independent of programming lang as long as you don\\'t use built in functions"
                    },
                    {
                        "username": "mohaymenrafi",
                        "content": "[@christinehong](/christinehong) when you use indexOf method, in worse case, it actually traverse the entire array which is O(n) operation. but in the question it specifically mentioned to use O(log n)"
                    },
                    {
                        "username": "christinehong",
                        "content": "that was literally my line of logic and i ended up with the same solution but in python"
                    },
                    {
                        "username": "gurnainwadhwa",
                        "content": "Just Binary Search"
                    },
                    {
                        "username": "anwendeng",
                        "content": "This problem is solved by using binary search several times.\nFirstly, it is suggested to find the location for the peak which can be done by binary search. \nSecondly, using  binary search to find location for the target  which  is possible before the peak or after the peak.\n\n# Be careful for the boundary cases when n=1 and n=2."
                    }
                ]
            },
            {
                "id": 1909894,
                "content": [
                    {
                        "username": "ss9394",
                        "content": "The problem is intented for Binary search. \\nBut if some is simply travering once  i.e  O(n) , It beats 100% . Which should not be the case. \\n\\nIt should only succeed for binary search based solution. i.e. O(log n)\\n\\n"
                    },
                    {
                        "username": "kaustubhmjb",
                        "content": "Big O notation is asymptotic. An absolute runtime of 2048n is slower than 128n**2, for values of n < 16 (also referred to as n0 in some definitions). Big O notation focuses on rate of change as input size grows arbitrarily."
                    },
                    {
                        "username": "gbiems",
                        "content": "I did binary search, and ran it 3 times, I got 99.5%, 6.3%, and 32%. So I wouldn\\'t put too much stock in the runtime for this.\\n\\nThat said, agreed, surprising you\\'d didn\\'t get a TLE with linear search. "
                    },
                    {
                        "username": "CaptainGalbatrollix",
                        "content": "[@pru_cuder](/pru_cuder) Well that\\'s not true in essence. Yes, big(O) notation is important and leetcode\\'s runtime judgement can be weird and leave a lot to be desired. \\n\\nHowever, it is crucial to remember big(O) is not the end all be all. If the overhead is big enough, for smaller input sizes \\'worse\\' solutions tend to be much more efficient due to factors such as cache locality. For example C++ built in sort switches from quicksort to insertion sort o(n^2) time complexity, when arrays get small enough. \\n\\nIn real life, solving this problem using bsearch would be questionable. Biggest possible size of array in the problem is 5000. If it was 5 * 10^6, then yeah double bsearch is the way to go and can save a lot of time, but you can\\'t honestly tell me a 5000 element loop will be a bottleneck in any system."
                    },
                    {
                        "username": "shivanshutripathii",
                        "content": "Exactly, I\\'ve applied binary search method and it beats only 8.19% in time (O(logn)).\\nWhen I\\'ve applied linear search then it beats 13.60% in time O(n). Crazy things happen."
                    },
                    {
                        "username": "pru_cuder",
                        "content": "those runtimes are based on machine i.e cpu config as well as programming language. Never take these runtimes as a parameter, always focus on Big O notation"
                    },
                    {
                        "username": "mandy1339",
                        "content": "First do a binary search to find the pivot:\\n\\n- Step 1\\n\\t-  compare mid pointer to right most value on the array. If value in mid pointer is greater than right most value in array, we know the pivot is to the right of the mid pointer. If value at mid pointer is smaller than right most value in the array, we know that the pivot is to the left. Split array in half until your left and right pointers touch.\\n- Step 2\\n\\t- Do a 2nd binary search on the whole array. This time we are looking for the target, not a pivot. Now that we know our pivot we just need to modify our midvalue like so: realMid = (mid + pivot) % nums.Length;\\n\\nComplexity of 2 binary searches is O ( 2 Log (n)) which is O (Log(n))"
                    },
                    {
                        "username": "Nitkapur30",
                        "content": "Solution explained: \\nhttps://leetcode.com/problems/search-in-rotated-sorted-array/solutions/3782253/c-binary-search-solution-with-breakdown-of-each-condition/"
                    },
                    {
                        "username": "srapol",
                        "content": "[@Aishwarya_jits](/Aishwarya_jits) how ?"
                    },
                    {
                        "username": "bparanj",
                        "content": "[@shape_mismatch](/shape_mismatch) Actually, both approaches are equally efficient when it comes to handling the case where the array is not pivoted, or sorted. This is because the binary search is performed based on the relationship between the target and the elements at the left, mid, and right positions, not based on whether the array is sorted or not.\\n\\nHowever, comparing with the leftmost element in the array does have an advantage when the array has duplicate values. In case of duplicate values, comparing with the rightmost element might lead to scenarios where we\\'re unable to decide which half of the array to proceed with, thus degrading the performance to O(n) in the worst-case scenario. On the other hand, comparing with the leftmost element can help us avoid such scenarios, thus maintaining a time complexity of O(log n) even when the array contains duplicate values.\\n"
                    },
                    {
                        "username": "Ramonsan07",
                        "content": "was ramdomly checking this problem and  remembered I had solved this in the way you describe https://leetcode.com/problems/search-in-rotated-sorted-array/solutions/3498417/easiest-intuitive-simple-two-binary-searches-solution/"
                    },
                    {
                        "username": "dragon1105",
                        "content": "[@shape_mismatch](/shape_mismatch) I think to compare mid with either the leftmost or the rightmost value is the same, because the probabilities that the pivot is located closer to the left side or to the right side are equal.\\nAnd for the case the array is not pivoted, we just need to check at the beginning whether the leftmost value is less than the rightmost value. If it is, then the array is not pivoted, because if the array is then leftmost must be greater than rightmost."
                    },
                    {
                        "username": "Salominius",
                        "content": "[@lucasscodes](/lucasscodes) 2*O(log n) is NOT O(n) but in fact O(log n).\\nJust as 2 * log n is not n."
                    },
                    {
                        "username": "Aishwarya_jits",
                        "content": "You dont need to do binary search twice, the target can be found in one search by tweaking the binary search code to accommodate for the pivoted element. My point is you dont necessarily have to find the pivot, your code just needs to be aware of its existence. "
                    },
                    {
                        "username": "imankulov53",
                        "content": "thank you for your idea to find pivot on which array is rotated, it\\'s simplifies task and give clear and simple solution"
                    },
                    {
                        "username": "user2748pU",
                        "content": "[@lucasscodes](/lucasscodes) actually what u are saying is wrong, binary search doesn\\'t take n/2 time, it takes log(n) time, so even doing it twice will result in a \"real time\" of 2 times of what it took do do a binary search once (=> 2*log(n)), which will in turn result in O(log(n)), since we ignore constant factors (like the 2*) in big O-Notation."
                    },
                    {
                        "username": "lucasscodes",
                        "content": "This has O(n) complexity.\\n2 times n/2 => n.\\nDont even mind binary search if you need to do it twice..."
                    },
                    {
                        "username": "spencerreitz2002",
                        "content": "[@shape_mismatch](/shape_mismatch) I believe the opposite it true. If the array is pivoted one place to the left, the number at the leftmost position of the array is less than the middle, but the rightmost point is now less than the middle also."
                    },
                    {
                        "username": "_arjan31",
                        "content": "To get it in log(N) complexity , follow strivers method"
                    },
                    {
                        "username": "shape_mismatch",
                        "content": "Wouldn\\'t it be better to compare with the leftmost value in the array (step 1), instead of the rightmost. It would be faster in taking care of cases where the array is not pivoted?"
                    },
                    {
                        "username": "charly371",
                        "content": "I get an error with the following test case: ([1,3], 1) which should output 0 since the integer 1 is present at index 0. \\nMy solution did not work for this one because I based it on the fact that the array will get rotate somewhere. \\n\\nI m thus wondering if you think this test case is valid ? or maybe the exercise should be change to say that the array may be rotated (but not necessarily is...) ?\\n\\nI will change my algo but i would like your feedback in case it was a real interview. what would you say ?\\nThx"
                    },
                    {
                        "username": "olsonpm",
                        "content": "[@vaishali_p14](/vaishali_p14) It also doesn\\'t say what to return in the case it\\'s not rotated\\n\\n> return the index of target if it is in nums, or -1 if it is not in nums"
                    },
                    {
                        "username": "GitG0",
                        "content": "people in 2023 answering a question asked in 2017 without knowing if the constraints or the question itself were modified in those ~6 years lol "
                    },
                    {
                        "username": "raghavsharmaji",
                        "content": "What do you think is meant by \"is possibly rotated\"?"
                    },
                    {
                        "username": "devansh10z",
                        "content": "suppose a case where an array of length n is rotated n times. you get the same array. that is the only reason this test case is a valid case."
                    },
                    {
                        "username": "AHawkeye",
                        "content": "[@vaishali_p14](/vaishali_p14)  But in the description, is says that k >= 1, which means the arrayed must be rotated."
                    },
                    {
                        "username": "sanjay2207",
                        "content": "You may not be checking one of <= or >= conditions correctly. I ran into same issue."
                    },
                    {
                        "username": "vaishali_p14",
                        "content": "In the question, it is mentioned that the passed array is sorted and POSSIBLY rotated."
                    },
                    {
                        "username": "hafezachu",
                        "content": "The main idea is to use binary search to find the target in the array. Binary search is a technique that divides the search space into two halves and compares the target with the middle element. If the target is equal to the middle element, we have found the index. If the target is smaller than the middle element, we search in the left half. If the target is larger than the middle element, we search in the right half. This way, we can reduce the search space by half in each iteration and achieve O(log n) runtime complexity.\\n\\nHowever, since the array is possibly rotated at some unknown pivot, we cannot directly apply binary search. We need to modify it slightly to handle the rotation. The key observation is that one of the two halves must be sorted, and the other half must contain the pivot. For example, if the array is [4,5,6,7,0,1,2], then the left half [4,5,6,7] is sorted and the right half [0,1,2] contains the pivot. If the array is [7,0,1,2,4,5,6], then the right half [2,4,5,6] is sorted and the left half [7,0,1] contains the pivot.\\n\\nSo, in each iteration of binary search, we first check which half is sorted by comparing the left and middle elements. Then we check if the target is in that sorted half by comparing it with the left and middle elements. If it is in that sorted half, we search in that half as usual. If it is not in that sorted half, we search in the other half that contains the pivot.\\n\\nFor example, if the array is [4,5,6,7,0,1,2] and the target is 0:\\n\\n- We start with left = 0 and right = 6. The middle index is 3 and the middle element is 7.\\n- We see that the left half [4,5,6,7] is sorted and the right half [0,1,2] contains the pivot.\\n- We check if the target 0 is in the left half by comparing it with 4 and 7. It is not in that half because 0 < 4 < 7.\\n- So we search in the right half that contains the pivot by setting left = mid + 1 = 4.\\n- We repeat this process until we find the target or exhaust the search space."
                    },
                    {
                        "username": "dragon1105",
                        "content": "Thank you. This is probably the most elegant way to solve this problem. With this solution, we don\\'t even need to find the pivot\\'s location, which is quite smart."
                    },
                    {
                        "username": "jackbb147",
                        "content": "thank you. Great explanation"
                    },
                    {
                        "username": "eugk123",
                        "content": "Why is there a [1,3,5] test case?\\n\\nIt\\'s not that big of a deal, but the problem states it guarantee\\'s pivot in all test cases. Leetcode team, please either remove that statement or fix your test case."
                    },
                    {
                        "username": "amansingh4958",
                        "content": "Just avoid finding pivot for these cases by just comparing 1st and last element of the array"
                    },
                    {
                        "username": "heyyyankit",
                        "content": "[@pranavagrawal321](/pranavagrawal321)its given that ( 1 <= k < nums.length) so this is not possible..."
                    },
                    {
                        "username": "Gautamparti",
                        "content": "question clearly states \"possibly rotated\" , which means you have to include a case where their is no pivot"
                    },
                    {
                        "username": "mrunfunny",
                        "content": "[@pranavagrawal321](/pranavagrawal321) That\\'s one way to look at this :XD"
                    },
                    {
                        "username": "pranavagrawal321",
                        "content": "The test case is correct, since the array can be rotated thrice, resulting in the original sorted array."
                    },
                    {
                        "username": "brauliojde",
                        "content": "I believe that there is an error in one of the test cases because the array that is entered is [1,3] and in this array there is no rotation. "
                    },
                    {
                        "username": "vaishali_p14",
                        "content": "In the question, it is mentioned that the passed array is sorted and POSSIBLY rotated.\\n\\n"
                    },
                    {
                        "username": "Yanlin0408",
                        "content": "[@lakshminathan](/lakshminathan) lmao"
                    },
                    {
                        "username": "lakshminathan",
                        "content": "it is rotated twice"
                    },
                    {
                        "username": "euphoria_kiki",
                        "content": "The key idea is during the process fo binary search, we compare the number at position mid and position left. If the number at mid is larger, it implies that range [left, mid] is ordered (not rotated), so we can decide whether to move towards that range for further search. Otherwise, the number at mid is smaller, which implies that range [mid, right] is ordered (not rotated)."
                    },
                    {
                        "username": "Spam_Musubi",
                        "content": "nice, I was wondering why this was on the medium side, they should\\'ve made something to make this harder and for us to naturally come up with the binary search.\\n"
                    },
                    {
                        "username": "insomniachou",
                        "content": "I don't think this problem is for JS. I saw someone's (n + logn) solution, was wondering why not just compare one by one, resulting in O(n). Not sure the question is asking the index in the sorted array or in the rotated array.  I tried js build-in array method, and surprisingly my answer passed and beats 60%.  \\n\\n\\tvar search = function(nums, target) {\\n\\t\\treturn nums.indexOf(target);\\n\\t};"
                    },
                    {
                        "username": "danielmascena",
                        "content": "doesnt matter the programming language but the approach used"
                    },
                    {
                        "username": "rohiinegi2002",
                        "content": "it will pass... Cause you are using a function that runs of O(logn) time complexity and is called Binary Search..(^ ^)"
                    },
                    {
                        "username": "normanlmfung",
                        "content": "Same in pyton: def search(self, nums: List[int], target: int) -> int:\\n        if target in nums:\\n            return nums.index(target)\\n        else:\\n            return -1"
                    },
                    {
                        "username": "ladiaz4e98",
                        "content": "this is wrong. this is o(n), question is asking for o(log(n)).."
                    },
                    {
                        "username": "thedevwonder",
                        "content": "JS solution in O(logn) works, my answer beats 90%. I think it is independent of programming lang as long as you don\\'t use built in functions"
                    },
                    {
                        "username": "mohaymenrafi",
                        "content": "[@christinehong](/christinehong) when you use indexOf method, in worse case, it actually traverse the entire array which is O(n) operation. but in the question it specifically mentioned to use O(log n)"
                    },
                    {
                        "username": "christinehong",
                        "content": "that was literally my line of logic and i ended up with the same solution but in python"
                    },
                    {
                        "username": "gurnainwadhwa",
                        "content": "Just Binary Search"
                    },
                    {
                        "username": "anwendeng",
                        "content": "This problem is solved by using binary search several times.\nFirstly, it is suggested to find the location for the peak which can be done by binary search. \nSecondly, using  binary search to find location for the target  which  is possible before the peak or after the peak.\n\n# Be careful for the boundary cases when n=1 and n=2."
                    }
                ]
            },
            {
                "id": 1566652,
                "content": [
                    {
                        "username": "ss9394",
                        "content": "The problem is intented for Binary search. \\nBut if some is simply travering once  i.e  O(n) , It beats 100% . Which should not be the case. \\n\\nIt should only succeed for binary search based solution. i.e. O(log n)\\n\\n"
                    },
                    {
                        "username": "kaustubhmjb",
                        "content": "Big O notation is asymptotic. An absolute runtime of 2048n is slower than 128n**2, for values of n < 16 (also referred to as n0 in some definitions). Big O notation focuses on rate of change as input size grows arbitrarily."
                    },
                    {
                        "username": "gbiems",
                        "content": "I did binary search, and ran it 3 times, I got 99.5%, 6.3%, and 32%. So I wouldn\\'t put too much stock in the runtime for this.\\n\\nThat said, agreed, surprising you\\'d didn\\'t get a TLE with linear search. "
                    },
                    {
                        "username": "CaptainGalbatrollix",
                        "content": "[@pru_cuder](/pru_cuder) Well that\\'s not true in essence. Yes, big(O) notation is important and leetcode\\'s runtime judgement can be weird and leave a lot to be desired. \\n\\nHowever, it is crucial to remember big(O) is not the end all be all. If the overhead is big enough, for smaller input sizes \\'worse\\' solutions tend to be much more efficient due to factors such as cache locality. For example C++ built in sort switches from quicksort to insertion sort o(n^2) time complexity, when arrays get small enough. \\n\\nIn real life, solving this problem using bsearch would be questionable. Biggest possible size of array in the problem is 5000. If it was 5 * 10^6, then yeah double bsearch is the way to go and can save a lot of time, but you can\\'t honestly tell me a 5000 element loop will be a bottleneck in any system."
                    },
                    {
                        "username": "shivanshutripathii",
                        "content": "Exactly, I\\'ve applied binary search method and it beats only 8.19% in time (O(logn)).\\nWhen I\\'ve applied linear search then it beats 13.60% in time O(n). Crazy things happen."
                    },
                    {
                        "username": "pru_cuder",
                        "content": "those runtimes are based on machine i.e cpu config as well as programming language. Never take these runtimes as a parameter, always focus on Big O notation"
                    },
                    {
                        "username": "mandy1339",
                        "content": "First do a binary search to find the pivot:\\n\\n- Step 1\\n\\t-  compare mid pointer to right most value on the array. If value in mid pointer is greater than right most value in array, we know the pivot is to the right of the mid pointer. If value at mid pointer is smaller than right most value in the array, we know that the pivot is to the left. Split array in half until your left and right pointers touch.\\n- Step 2\\n\\t- Do a 2nd binary search on the whole array. This time we are looking for the target, not a pivot. Now that we know our pivot we just need to modify our midvalue like so: realMid = (mid + pivot) % nums.Length;\\n\\nComplexity of 2 binary searches is O ( 2 Log (n)) which is O (Log(n))"
                    },
                    {
                        "username": "Nitkapur30",
                        "content": "Solution explained: \\nhttps://leetcode.com/problems/search-in-rotated-sorted-array/solutions/3782253/c-binary-search-solution-with-breakdown-of-each-condition/"
                    },
                    {
                        "username": "srapol",
                        "content": "[@Aishwarya_jits](/Aishwarya_jits) how ?"
                    },
                    {
                        "username": "bparanj",
                        "content": "[@shape_mismatch](/shape_mismatch) Actually, both approaches are equally efficient when it comes to handling the case where the array is not pivoted, or sorted. This is because the binary search is performed based on the relationship between the target and the elements at the left, mid, and right positions, not based on whether the array is sorted or not.\\n\\nHowever, comparing with the leftmost element in the array does have an advantage when the array has duplicate values. In case of duplicate values, comparing with the rightmost element might lead to scenarios where we\\'re unable to decide which half of the array to proceed with, thus degrading the performance to O(n) in the worst-case scenario. On the other hand, comparing with the leftmost element can help us avoid such scenarios, thus maintaining a time complexity of O(log n) even when the array contains duplicate values.\\n"
                    },
                    {
                        "username": "Ramonsan07",
                        "content": "was ramdomly checking this problem and  remembered I had solved this in the way you describe https://leetcode.com/problems/search-in-rotated-sorted-array/solutions/3498417/easiest-intuitive-simple-two-binary-searches-solution/"
                    },
                    {
                        "username": "dragon1105",
                        "content": "[@shape_mismatch](/shape_mismatch) I think to compare mid with either the leftmost or the rightmost value is the same, because the probabilities that the pivot is located closer to the left side or to the right side are equal.\\nAnd for the case the array is not pivoted, we just need to check at the beginning whether the leftmost value is less than the rightmost value. If it is, then the array is not pivoted, because if the array is then leftmost must be greater than rightmost."
                    },
                    {
                        "username": "Salominius",
                        "content": "[@lucasscodes](/lucasscodes) 2*O(log n) is NOT O(n) but in fact O(log n).\\nJust as 2 * log n is not n."
                    },
                    {
                        "username": "Aishwarya_jits",
                        "content": "You dont need to do binary search twice, the target can be found in one search by tweaking the binary search code to accommodate for the pivoted element. My point is you dont necessarily have to find the pivot, your code just needs to be aware of its existence. "
                    },
                    {
                        "username": "imankulov53",
                        "content": "thank you for your idea to find pivot on which array is rotated, it\\'s simplifies task and give clear and simple solution"
                    },
                    {
                        "username": "user2748pU",
                        "content": "[@lucasscodes](/lucasscodes) actually what u are saying is wrong, binary search doesn\\'t take n/2 time, it takes log(n) time, so even doing it twice will result in a \"real time\" of 2 times of what it took do do a binary search once (=> 2*log(n)), which will in turn result in O(log(n)), since we ignore constant factors (like the 2*) in big O-Notation."
                    },
                    {
                        "username": "lucasscodes",
                        "content": "This has O(n) complexity.\\n2 times n/2 => n.\\nDont even mind binary search if you need to do it twice..."
                    },
                    {
                        "username": "spencerreitz2002",
                        "content": "[@shape_mismatch](/shape_mismatch) I believe the opposite it true. If the array is pivoted one place to the left, the number at the leftmost position of the array is less than the middle, but the rightmost point is now less than the middle also."
                    },
                    {
                        "username": "_arjan31",
                        "content": "To get it in log(N) complexity , follow strivers method"
                    },
                    {
                        "username": "shape_mismatch",
                        "content": "Wouldn\\'t it be better to compare with the leftmost value in the array (step 1), instead of the rightmost. It would be faster in taking care of cases where the array is not pivoted?"
                    },
                    {
                        "username": "charly371",
                        "content": "I get an error with the following test case: ([1,3], 1) which should output 0 since the integer 1 is present at index 0. \\nMy solution did not work for this one because I based it on the fact that the array will get rotate somewhere. \\n\\nI m thus wondering if you think this test case is valid ? or maybe the exercise should be change to say that the array may be rotated (but not necessarily is...) ?\\n\\nI will change my algo but i would like your feedback in case it was a real interview. what would you say ?\\nThx"
                    },
                    {
                        "username": "olsonpm",
                        "content": "[@vaishali_p14](/vaishali_p14) It also doesn\\'t say what to return in the case it\\'s not rotated\\n\\n> return the index of target if it is in nums, or -1 if it is not in nums"
                    },
                    {
                        "username": "GitG0",
                        "content": "people in 2023 answering a question asked in 2017 without knowing if the constraints or the question itself were modified in those ~6 years lol "
                    },
                    {
                        "username": "raghavsharmaji",
                        "content": "What do you think is meant by \"is possibly rotated\"?"
                    },
                    {
                        "username": "devansh10z",
                        "content": "suppose a case where an array of length n is rotated n times. you get the same array. that is the only reason this test case is a valid case."
                    },
                    {
                        "username": "AHawkeye",
                        "content": "[@vaishali_p14](/vaishali_p14)  But in the description, is says that k >= 1, which means the arrayed must be rotated."
                    },
                    {
                        "username": "sanjay2207",
                        "content": "You may not be checking one of <= or >= conditions correctly. I ran into same issue."
                    },
                    {
                        "username": "vaishali_p14",
                        "content": "In the question, it is mentioned that the passed array is sorted and POSSIBLY rotated."
                    },
                    {
                        "username": "hafezachu",
                        "content": "The main idea is to use binary search to find the target in the array. Binary search is a technique that divides the search space into two halves and compares the target with the middle element. If the target is equal to the middle element, we have found the index. If the target is smaller than the middle element, we search in the left half. If the target is larger than the middle element, we search in the right half. This way, we can reduce the search space by half in each iteration and achieve O(log n) runtime complexity.\\n\\nHowever, since the array is possibly rotated at some unknown pivot, we cannot directly apply binary search. We need to modify it slightly to handle the rotation. The key observation is that one of the two halves must be sorted, and the other half must contain the pivot. For example, if the array is [4,5,6,7,0,1,2], then the left half [4,5,6,7] is sorted and the right half [0,1,2] contains the pivot. If the array is [7,0,1,2,4,5,6], then the right half [2,4,5,6] is sorted and the left half [7,0,1] contains the pivot.\\n\\nSo, in each iteration of binary search, we first check which half is sorted by comparing the left and middle elements. Then we check if the target is in that sorted half by comparing it with the left and middle elements. If it is in that sorted half, we search in that half as usual. If it is not in that sorted half, we search in the other half that contains the pivot.\\n\\nFor example, if the array is [4,5,6,7,0,1,2] and the target is 0:\\n\\n- We start with left = 0 and right = 6. The middle index is 3 and the middle element is 7.\\n- We see that the left half [4,5,6,7] is sorted and the right half [0,1,2] contains the pivot.\\n- We check if the target 0 is in the left half by comparing it with 4 and 7. It is not in that half because 0 < 4 < 7.\\n- So we search in the right half that contains the pivot by setting left = mid + 1 = 4.\\n- We repeat this process until we find the target or exhaust the search space."
                    },
                    {
                        "username": "dragon1105",
                        "content": "Thank you. This is probably the most elegant way to solve this problem. With this solution, we don\\'t even need to find the pivot\\'s location, which is quite smart."
                    },
                    {
                        "username": "jackbb147",
                        "content": "thank you. Great explanation"
                    },
                    {
                        "username": "eugk123",
                        "content": "Why is there a [1,3,5] test case?\\n\\nIt\\'s not that big of a deal, but the problem states it guarantee\\'s pivot in all test cases. Leetcode team, please either remove that statement or fix your test case."
                    },
                    {
                        "username": "amansingh4958",
                        "content": "Just avoid finding pivot for these cases by just comparing 1st and last element of the array"
                    },
                    {
                        "username": "heyyyankit",
                        "content": "[@pranavagrawal321](/pranavagrawal321)its given that ( 1 <= k < nums.length) so this is not possible..."
                    },
                    {
                        "username": "Gautamparti",
                        "content": "question clearly states \"possibly rotated\" , which means you have to include a case where their is no pivot"
                    },
                    {
                        "username": "mrunfunny",
                        "content": "[@pranavagrawal321](/pranavagrawal321) That\\'s one way to look at this :XD"
                    },
                    {
                        "username": "pranavagrawal321",
                        "content": "The test case is correct, since the array can be rotated thrice, resulting in the original sorted array."
                    },
                    {
                        "username": "brauliojde",
                        "content": "I believe that there is an error in one of the test cases because the array that is entered is [1,3] and in this array there is no rotation. "
                    },
                    {
                        "username": "vaishali_p14",
                        "content": "In the question, it is mentioned that the passed array is sorted and POSSIBLY rotated.\\n\\n"
                    },
                    {
                        "username": "Yanlin0408",
                        "content": "[@lakshminathan](/lakshminathan) lmao"
                    },
                    {
                        "username": "lakshminathan",
                        "content": "it is rotated twice"
                    },
                    {
                        "username": "euphoria_kiki",
                        "content": "The key idea is during the process fo binary search, we compare the number at position mid and position left. If the number at mid is larger, it implies that range [left, mid] is ordered (not rotated), so we can decide whether to move towards that range for further search. Otherwise, the number at mid is smaller, which implies that range [mid, right] is ordered (not rotated)."
                    },
                    {
                        "username": "Spam_Musubi",
                        "content": "nice, I was wondering why this was on the medium side, they should\\'ve made something to make this harder and for us to naturally come up with the binary search.\\n"
                    },
                    {
                        "username": "insomniachou",
                        "content": "I don't think this problem is for JS. I saw someone's (n + logn) solution, was wondering why not just compare one by one, resulting in O(n). Not sure the question is asking the index in the sorted array or in the rotated array.  I tried js build-in array method, and surprisingly my answer passed and beats 60%.  \\n\\n\\tvar search = function(nums, target) {\\n\\t\\treturn nums.indexOf(target);\\n\\t};"
                    },
                    {
                        "username": "danielmascena",
                        "content": "doesnt matter the programming language but the approach used"
                    },
                    {
                        "username": "rohiinegi2002",
                        "content": "it will pass... Cause you are using a function that runs of O(logn) time complexity and is called Binary Search..(^ ^)"
                    },
                    {
                        "username": "normanlmfung",
                        "content": "Same in pyton: def search(self, nums: List[int], target: int) -> int:\\n        if target in nums:\\n            return nums.index(target)\\n        else:\\n            return -1"
                    },
                    {
                        "username": "ladiaz4e98",
                        "content": "this is wrong. this is o(n), question is asking for o(log(n)).."
                    },
                    {
                        "username": "thedevwonder",
                        "content": "JS solution in O(logn) works, my answer beats 90%. I think it is independent of programming lang as long as you don\\'t use built in functions"
                    },
                    {
                        "username": "mohaymenrafi",
                        "content": "[@christinehong](/christinehong) when you use indexOf method, in worse case, it actually traverse the entire array which is O(n) operation. but in the question it specifically mentioned to use O(log n)"
                    },
                    {
                        "username": "christinehong",
                        "content": "that was literally my line of logic and i ended up with the same solution but in python"
                    },
                    {
                        "username": "gurnainwadhwa",
                        "content": "Just Binary Search"
                    },
                    {
                        "username": "anwendeng",
                        "content": "This problem is solved by using binary search several times.\nFirstly, it is suggested to find the location for the peak which can be done by binary search. \nSecondly, using  binary search to find location for the target  which  is possible before the peak or after the peak.\n\n# Be careful for the boundary cases when n=1 and n=2."
                    }
                ]
            },
            {
                "id": 1566532,
                "content": [
                    {
                        "username": "ss9394",
                        "content": "The problem is intented for Binary search. \\nBut if some is simply travering once  i.e  O(n) , It beats 100% . Which should not be the case. \\n\\nIt should only succeed for binary search based solution. i.e. O(log n)\\n\\n"
                    },
                    {
                        "username": "kaustubhmjb",
                        "content": "Big O notation is asymptotic. An absolute runtime of 2048n is slower than 128n**2, for values of n < 16 (also referred to as n0 in some definitions). Big O notation focuses on rate of change as input size grows arbitrarily."
                    },
                    {
                        "username": "gbiems",
                        "content": "I did binary search, and ran it 3 times, I got 99.5%, 6.3%, and 32%. So I wouldn\\'t put too much stock in the runtime for this.\\n\\nThat said, agreed, surprising you\\'d didn\\'t get a TLE with linear search. "
                    },
                    {
                        "username": "CaptainGalbatrollix",
                        "content": "[@pru_cuder](/pru_cuder) Well that\\'s not true in essence. Yes, big(O) notation is important and leetcode\\'s runtime judgement can be weird and leave a lot to be desired. \\n\\nHowever, it is crucial to remember big(O) is not the end all be all. If the overhead is big enough, for smaller input sizes \\'worse\\' solutions tend to be much more efficient due to factors such as cache locality. For example C++ built in sort switches from quicksort to insertion sort o(n^2) time complexity, when arrays get small enough. \\n\\nIn real life, solving this problem using bsearch would be questionable. Biggest possible size of array in the problem is 5000. If it was 5 * 10^6, then yeah double bsearch is the way to go and can save a lot of time, but you can\\'t honestly tell me a 5000 element loop will be a bottleneck in any system."
                    },
                    {
                        "username": "shivanshutripathii",
                        "content": "Exactly, I\\'ve applied binary search method and it beats only 8.19% in time (O(logn)).\\nWhen I\\'ve applied linear search then it beats 13.60% in time O(n). Crazy things happen."
                    },
                    {
                        "username": "pru_cuder",
                        "content": "those runtimes are based on machine i.e cpu config as well as programming language. Never take these runtimes as a parameter, always focus on Big O notation"
                    },
                    {
                        "username": "mandy1339",
                        "content": "First do a binary search to find the pivot:\\n\\n- Step 1\\n\\t-  compare mid pointer to right most value on the array. If value in mid pointer is greater than right most value in array, we know the pivot is to the right of the mid pointer. If value at mid pointer is smaller than right most value in the array, we know that the pivot is to the left. Split array in half until your left and right pointers touch.\\n- Step 2\\n\\t- Do a 2nd binary search on the whole array. This time we are looking for the target, not a pivot. Now that we know our pivot we just need to modify our midvalue like so: realMid = (mid + pivot) % nums.Length;\\n\\nComplexity of 2 binary searches is O ( 2 Log (n)) which is O (Log(n))"
                    },
                    {
                        "username": "Nitkapur30",
                        "content": "Solution explained: \\nhttps://leetcode.com/problems/search-in-rotated-sorted-array/solutions/3782253/c-binary-search-solution-with-breakdown-of-each-condition/"
                    },
                    {
                        "username": "srapol",
                        "content": "[@Aishwarya_jits](/Aishwarya_jits) how ?"
                    },
                    {
                        "username": "bparanj",
                        "content": "[@shape_mismatch](/shape_mismatch) Actually, both approaches are equally efficient when it comes to handling the case where the array is not pivoted, or sorted. This is because the binary search is performed based on the relationship between the target and the elements at the left, mid, and right positions, not based on whether the array is sorted or not.\\n\\nHowever, comparing with the leftmost element in the array does have an advantage when the array has duplicate values. In case of duplicate values, comparing with the rightmost element might lead to scenarios where we\\'re unable to decide which half of the array to proceed with, thus degrading the performance to O(n) in the worst-case scenario. On the other hand, comparing with the leftmost element can help us avoid such scenarios, thus maintaining a time complexity of O(log n) even when the array contains duplicate values.\\n"
                    },
                    {
                        "username": "Ramonsan07",
                        "content": "was ramdomly checking this problem and  remembered I had solved this in the way you describe https://leetcode.com/problems/search-in-rotated-sorted-array/solutions/3498417/easiest-intuitive-simple-two-binary-searches-solution/"
                    },
                    {
                        "username": "dragon1105",
                        "content": "[@shape_mismatch](/shape_mismatch) I think to compare mid with either the leftmost or the rightmost value is the same, because the probabilities that the pivot is located closer to the left side or to the right side are equal.\\nAnd for the case the array is not pivoted, we just need to check at the beginning whether the leftmost value is less than the rightmost value. If it is, then the array is not pivoted, because if the array is then leftmost must be greater than rightmost."
                    },
                    {
                        "username": "Salominius",
                        "content": "[@lucasscodes](/lucasscodes) 2*O(log n) is NOT O(n) but in fact O(log n).\\nJust as 2 * log n is not n."
                    },
                    {
                        "username": "Aishwarya_jits",
                        "content": "You dont need to do binary search twice, the target can be found in one search by tweaking the binary search code to accommodate for the pivoted element. My point is you dont necessarily have to find the pivot, your code just needs to be aware of its existence. "
                    },
                    {
                        "username": "imankulov53",
                        "content": "thank you for your idea to find pivot on which array is rotated, it\\'s simplifies task and give clear and simple solution"
                    },
                    {
                        "username": "user2748pU",
                        "content": "[@lucasscodes](/lucasscodes) actually what u are saying is wrong, binary search doesn\\'t take n/2 time, it takes log(n) time, so even doing it twice will result in a \"real time\" of 2 times of what it took do do a binary search once (=> 2*log(n)), which will in turn result in O(log(n)), since we ignore constant factors (like the 2*) in big O-Notation."
                    },
                    {
                        "username": "lucasscodes",
                        "content": "This has O(n) complexity.\\n2 times n/2 => n.\\nDont even mind binary search if you need to do it twice..."
                    },
                    {
                        "username": "spencerreitz2002",
                        "content": "[@shape_mismatch](/shape_mismatch) I believe the opposite it true. If the array is pivoted one place to the left, the number at the leftmost position of the array is less than the middle, but the rightmost point is now less than the middle also."
                    },
                    {
                        "username": "_arjan31",
                        "content": "To get it in log(N) complexity , follow strivers method"
                    },
                    {
                        "username": "shape_mismatch",
                        "content": "Wouldn\\'t it be better to compare with the leftmost value in the array (step 1), instead of the rightmost. It would be faster in taking care of cases where the array is not pivoted?"
                    },
                    {
                        "username": "charly371",
                        "content": "I get an error with the following test case: ([1,3], 1) which should output 0 since the integer 1 is present at index 0. \\nMy solution did not work for this one because I based it on the fact that the array will get rotate somewhere. \\n\\nI m thus wondering if you think this test case is valid ? or maybe the exercise should be change to say that the array may be rotated (but not necessarily is...) ?\\n\\nI will change my algo but i would like your feedback in case it was a real interview. what would you say ?\\nThx"
                    },
                    {
                        "username": "olsonpm",
                        "content": "[@vaishali_p14](/vaishali_p14) It also doesn\\'t say what to return in the case it\\'s not rotated\\n\\n> return the index of target if it is in nums, or -1 if it is not in nums"
                    },
                    {
                        "username": "GitG0",
                        "content": "people in 2023 answering a question asked in 2017 without knowing if the constraints or the question itself were modified in those ~6 years lol "
                    },
                    {
                        "username": "raghavsharmaji",
                        "content": "What do you think is meant by \"is possibly rotated\"?"
                    },
                    {
                        "username": "devansh10z",
                        "content": "suppose a case where an array of length n is rotated n times. you get the same array. that is the only reason this test case is a valid case."
                    },
                    {
                        "username": "AHawkeye",
                        "content": "[@vaishali_p14](/vaishali_p14)  But in the description, is says that k >= 1, which means the arrayed must be rotated."
                    },
                    {
                        "username": "sanjay2207",
                        "content": "You may not be checking one of <= or >= conditions correctly. I ran into same issue."
                    },
                    {
                        "username": "vaishali_p14",
                        "content": "In the question, it is mentioned that the passed array is sorted and POSSIBLY rotated."
                    },
                    {
                        "username": "hafezachu",
                        "content": "The main idea is to use binary search to find the target in the array. Binary search is a technique that divides the search space into two halves and compares the target with the middle element. If the target is equal to the middle element, we have found the index. If the target is smaller than the middle element, we search in the left half. If the target is larger than the middle element, we search in the right half. This way, we can reduce the search space by half in each iteration and achieve O(log n) runtime complexity.\\n\\nHowever, since the array is possibly rotated at some unknown pivot, we cannot directly apply binary search. We need to modify it slightly to handle the rotation. The key observation is that one of the two halves must be sorted, and the other half must contain the pivot. For example, if the array is [4,5,6,7,0,1,2], then the left half [4,5,6,7] is sorted and the right half [0,1,2] contains the pivot. If the array is [7,0,1,2,4,5,6], then the right half [2,4,5,6] is sorted and the left half [7,0,1] contains the pivot.\\n\\nSo, in each iteration of binary search, we first check which half is sorted by comparing the left and middle elements. Then we check if the target is in that sorted half by comparing it with the left and middle elements. If it is in that sorted half, we search in that half as usual. If it is not in that sorted half, we search in the other half that contains the pivot.\\n\\nFor example, if the array is [4,5,6,7,0,1,2] and the target is 0:\\n\\n- We start with left = 0 and right = 6. The middle index is 3 and the middle element is 7.\\n- We see that the left half [4,5,6,7] is sorted and the right half [0,1,2] contains the pivot.\\n- We check if the target 0 is in the left half by comparing it with 4 and 7. It is not in that half because 0 < 4 < 7.\\n- So we search in the right half that contains the pivot by setting left = mid + 1 = 4.\\n- We repeat this process until we find the target or exhaust the search space."
                    },
                    {
                        "username": "dragon1105",
                        "content": "Thank you. This is probably the most elegant way to solve this problem. With this solution, we don\\'t even need to find the pivot\\'s location, which is quite smart."
                    },
                    {
                        "username": "jackbb147",
                        "content": "thank you. Great explanation"
                    },
                    {
                        "username": "eugk123",
                        "content": "Why is there a [1,3,5] test case?\\n\\nIt\\'s not that big of a deal, but the problem states it guarantee\\'s pivot in all test cases. Leetcode team, please either remove that statement or fix your test case."
                    },
                    {
                        "username": "amansingh4958",
                        "content": "Just avoid finding pivot for these cases by just comparing 1st and last element of the array"
                    },
                    {
                        "username": "heyyyankit",
                        "content": "[@pranavagrawal321](/pranavagrawal321)its given that ( 1 <= k < nums.length) so this is not possible..."
                    },
                    {
                        "username": "Gautamparti",
                        "content": "question clearly states \"possibly rotated\" , which means you have to include a case where their is no pivot"
                    },
                    {
                        "username": "mrunfunny",
                        "content": "[@pranavagrawal321](/pranavagrawal321) That\\'s one way to look at this :XD"
                    },
                    {
                        "username": "pranavagrawal321",
                        "content": "The test case is correct, since the array can be rotated thrice, resulting in the original sorted array."
                    },
                    {
                        "username": "brauliojde",
                        "content": "I believe that there is an error in one of the test cases because the array that is entered is [1,3] and in this array there is no rotation. "
                    },
                    {
                        "username": "vaishali_p14",
                        "content": "In the question, it is mentioned that the passed array is sorted and POSSIBLY rotated.\\n\\n"
                    },
                    {
                        "username": "Yanlin0408",
                        "content": "[@lakshminathan](/lakshminathan) lmao"
                    },
                    {
                        "username": "lakshminathan",
                        "content": "it is rotated twice"
                    },
                    {
                        "username": "euphoria_kiki",
                        "content": "The key idea is during the process fo binary search, we compare the number at position mid and position left. If the number at mid is larger, it implies that range [left, mid] is ordered (not rotated), so we can decide whether to move towards that range for further search. Otherwise, the number at mid is smaller, which implies that range [mid, right] is ordered (not rotated)."
                    },
                    {
                        "username": "Spam_Musubi",
                        "content": "nice, I was wondering why this was on the medium side, they should\\'ve made something to make this harder and for us to naturally come up with the binary search.\\n"
                    },
                    {
                        "username": "insomniachou",
                        "content": "I don't think this problem is for JS. I saw someone's (n + logn) solution, was wondering why not just compare one by one, resulting in O(n). Not sure the question is asking the index in the sorted array or in the rotated array.  I tried js build-in array method, and surprisingly my answer passed and beats 60%.  \\n\\n\\tvar search = function(nums, target) {\\n\\t\\treturn nums.indexOf(target);\\n\\t};"
                    },
                    {
                        "username": "danielmascena",
                        "content": "doesnt matter the programming language but the approach used"
                    },
                    {
                        "username": "rohiinegi2002",
                        "content": "it will pass... Cause you are using a function that runs of O(logn) time complexity and is called Binary Search..(^ ^)"
                    },
                    {
                        "username": "normanlmfung",
                        "content": "Same in pyton: def search(self, nums: List[int], target: int) -> int:\\n        if target in nums:\\n            return nums.index(target)\\n        else:\\n            return -1"
                    },
                    {
                        "username": "ladiaz4e98",
                        "content": "this is wrong. this is o(n), question is asking for o(log(n)).."
                    },
                    {
                        "username": "thedevwonder",
                        "content": "JS solution in O(logn) works, my answer beats 90%. I think it is independent of programming lang as long as you don\\'t use built in functions"
                    },
                    {
                        "username": "mohaymenrafi",
                        "content": "[@christinehong](/christinehong) when you use indexOf method, in worse case, it actually traverse the entire array which is O(n) operation. but in the question it specifically mentioned to use O(log n)"
                    },
                    {
                        "username": "christinehong",
                        "content": "that was literally my line of logic and i ended up with the same solution but in python"
                    },
                    {
                        "username": "gurnainwadhwa",
                        "content": "Just Binary Search"
                    },
                    {
                        "username": "anwendeng",
                        "content": "This problem is solved by using binary search several times.\nFirstly, it is suggested to find the location for the peak which can be done by binary search. \nSecondly, using  binary search to find location for the target  which  is possible before the peak or after the peak.\n\n# Be careful for the boundary cases when n=1 and n=2."
                    }
                ]
            },
            {
                "id": 1576174,
                "content": [
                    {
                        "username": "ss9394",
                        "content": "The problem is intented for Binary search. \\nBut if some is simply travering once  i.e  O(n) , It beats 100% . Which should not be the case. \\n\\nIt should only succeed for binary search based solution. i.e. O(log n)\\n\\n"
                    },
                    {
                        "username": "kaustubhmjb",
                        "content": "Big O notation is asymptotic. An absolute runtime of 2048n is slower than 128n**2, for values of n < 16 (also referred to as n0 in some definitions). Big O notation focuses on rate of change as input size grows arbitrarily."
                    },
                    {
                        "username": "gbiems",
                        "content": "I did binary search, and ran it 3 times, I got 99.5%, 6.3%, and 32%. So I wouldn\\'t put too much stock in the runtime for this.\\n\\nThat said, agreed, surprising you\\'d didn\\'t get a TLE with linear search. "
                    },
                    {
                        "username": "CaptainGalbatrollix",
                        "content": "[@pru_cuder](/pru_cuder) Well that\\'s not true in essence. Yes, big(O) notation is important and leetcode\\'s runtime judgement can be weird and leave a lot to be desired. \\n\\nHowever, it is crucial to remember big(O) is not the end all be all. If the overhead is big enough, for smaller input sizes \\'worse\\' solutions tend to be much more efficient due to factors such as cache locality. For example C++ built in sort switches from quicksort to insertion sort o(n^2) time complexity, when arrays get small enough. \\n\\nIn real life, solving this problem using bsearch would be questionable. Biggest possible size of array in the problem is 5000. If it was 5 * 10^6, then yeah double bsearch is the way to go and can save a lot of time, but you can\\'t honestly tell me a 5000 element loop will be a bottleneck in any system."
                    },
                    {
                        "username": "shivanshutripathii",
                        "content": "Exactly, I\\'ve applied binary search method and it beats only 8.19% in time (O(logn)).\\nWhen I\\'ve applied linear search then it beats 13.60% in time O(n). Crazy things happen."
                    },
                    {
                        "username": "pru_cuder",
                        "content": "those runtimes are based on machine i.e cpu config as well as programming language. Never take these runtimes as a parameter, always focus on Big O notation"
                    },
                    {
                        "username": "mandy1339",
                        "content": "First do a binary search to find the pivot:\\n\\n- Step 1\\n\\t-  compare mid pointer to right most value on the array. If value in mid pointer is greater than right most value in array, we know the pivot is to the right of the mid pointer. If value at mid pointer is smaller than right most value in the array, we know that the pivot is to the left. Split array in half until your left and right pointers touch.\\n- Step 2\\n\\t- Do a 2nd binary search on the whole array. This time we are looking for the target, not a pivot. Now that we know our pivot we just need to modify our midvalue like so: realMid = (mid + pivot) % nums.Length;\\n\\nComplexity of 2 binary searches is O ( 2 Log (n)) which is O (Log(n))"
                    },
                    {
                        "username": "Nitkapur30",
                        "content": "Solution explained: \\nhttps://leetcode.com/problems/search-in-rotated-sorted-array/solutions/3782253/c-binary-search-solution-with-breakdown-of-each-condition/"
                    },
                    {
                        "username": "srapol",
                        "content": "[@Aishwarya_jits](/Aishwarya_jits) how ?"
                    },
                    {
                        "username": "bparanj",
                        "content": "[@shape_mismatch](/shape_mismatch) Actually, both approaches are equally efficient when it comes to handling the case where the array is not pivoted, or sorted. This is because the binary search is performed based on the relationship between the target and the elements at the left, mid, and right positions, not based on whether the array is sorted or not.\\n\\nHowever, comparing with the leftmost element in the array does have an advantage when the array has duplicate values. In case of duplicate values, comparing with the rightmost element might lead to scenarios where we\\'re unable to decide which half of the array to proceed with, thus degrading the performance to O(n) in the worst-case scenario. On the other hand, comparing with the leftmost element can help us avoid such scenarios, thus maintaining a time complexity of O(log n) even when the array contains duplicate values.\\n"
                    },
                    {
                        "username": "Ramonsan07",
                        "content": "was ramdomly checking this problem and  remembered I had solved this in the way you describe https://leetcode.com/problems/search-in-rotated-sorted-array/solutions/3498417/easiest-intuitive-simple-two-binary-searches-solution/"
                    },
                    {
                        "username": "dragon1105",
                        "content": "[@shape_mismatch](/shape_mismatch) I think to compare mid with either the leftmost or the rightmost value is the same, because the probabilities that the pivot is located closer to the left side or to the right side are equal.\\nAnd for the case the array is not pivoted, we just need to check at the beginning whether the leftmost value is less than the rightmost value. If it is, then the array is not pivoted, because if the array is then leftmost must be greater than rightmost."
                    },
                    {
                        "username": "Salominius",
                        "content": "[@lucasscodes](/lucasscodes) 2*O(log n) is NOT O(n) but in fact O(log n).\\nJust as 2 * log n is not n."
                    },
                    {
                        "username": "Aishwarya_jits",
                        "content": "You dont need to do binary search twice, the target can be found in one search by tweaking the binary search code to accommodate for the pivoted element. My point is you dont necessarily have to find the pivot, your code just needs to be aware of its existence. "
                    },
                    {
                        "username": "imankulov53",
                        "content": "thank you for your idea to find pivot on which array is rotated, it\\'s simplifies task and give clear and simple solution"
                    },
                    {
                        "username": "user2748pU",
                        "content": "[@lucasscodes](/lucasscodes) actually what u are saying is wrong, binary search doesn\\'t take n/2 time, it takes log(n) time, so even doing it twice will result in a \"real time\" of 2 times of what it took do do a binary search once (=> 2*log(n)), which will in turn result in O(log(n)), since we ignore constant factors (like the 2*) in big O-Notation."
                    },
                    {
                        "username": "lucasscodes",
                        "content": "This has O(n) complexity.\\n2 times n/2 => n.\\nDont even mind binary search if you need to do it twice..."
                    },
                    {
                        "username": "spencerreitz2002",
                        "content": "[@shape_mismatch](/shape_mismatch) I believe the opposite it true. If the array is pivoted one place to the left, the number at the leftmost position of the array is less than the middle, but the rightmost point is now less than the middle also."
                    },
                    {
                        "username": "_arjan31",
                        "content": "To get it in log(N) complexity , follow strivers method"
                    },
                    {
                        "username": "shape_mismatch",
                        "content": "Wouldn\\'t it be better to compare with the leftmost value in the array (step 1), instead of the rightmost. It would be faster in taking care of cases where the array is not pivoted?"
                    },
                    {
                        "username": "charly371",
                        "content": "I get an error with the following test case: ([1,3], 1) which should output 0 since the integer 1 is present at index 0. \\nMy solution did not work for this one because I based it on the fact that the array will get rotate somewhere. \\n\\nI m thus wondering if you think this test case is valid ? or maybe the exercise should be change to say that the array may be rotated (but not necessarily is...) ?\\n\\nI will change my algo but i would like your feedback in case it was a real interview. what would you say ?\\nThx"
                    },
                    {
                        "username": "olsonpm",
                        "content": "[@vaishali_p14](/vaishali_p14) It also doesn\\'t say what to return in the case it\\'s not rotated\\n\\n> return the index of target if it is in nums, or -1 if it is not in nums"
                    },
                    {
                        "username": "GitG0",
                        "content": "people in 2023 answering a question asked in 2017 without knowing if the constraints or the question itself were modified in those ~6 years lol "
                    },
                    {
                        "username": "raghavsharmaji",
                        "content": "What do you think is meant by \"is possibly rotated\"?"
                    },
                    {
                        "username": "devansh10z",
                        "content": "suppose a case where an array of length n is rotated n times. you get the same array. that is the only reason this test case is a valid case."
                    },
                    {
                        "username": "AHawkeye",
                        "content": "[@vaishali_p14](/vaishali_p14)  But in the description, is says that k >= 1, which means the arrayed must be rotated."
                    },
                    {
                        "username": "sanjay2207",
                        "content": "You may not be checking one of <= or >= conditions correctly. I ran into same issue."
                    },
                    {
                        "username": "vaishali_p14",
                        "content": "In the question, it is mentioned that the passed array is sorted and POSSIBLY rotated."
                    },
                    {
                        "username": "hafezachu",
                        "content": "The main idea is to use binary search to find the target in the array. Binary search is a technique that divides the search space into two halves and compares the target with the middle element. If the target is equal to the middle element, we have found the index. If the target is smaller than the middle element, we search in the left half. If the target is larger than the middle element, we search in the right half. This way, we can reduce the search space by half in each iteration and achieve O(log n) runtime complexity.\\n\\nHowever, since the array is possibly rotated at some unknown pivot, we cannot directly apply binary search. We need to modify it slightly to handle the rotation. The key observation is that one of the two halves must be sorted, and the other half must contain the pivot. For example, if the array is [4,5,6,7,0,1,2], then the left half [4,5,6,7] is sorted and the right half [0,1,2] contains the pivot. If the array is [7,0,1,2,4,5,6], then the right half [2,4,5,6] is sorted and the left half [7,0,1] contains the pivot.\\n\\nSo, in each iteration of binary search, we first check which half is sorted by comparing the left and middle elements. Then we check if the target is in that sorted half by comparing it with the left and middle elements. If it is in that sorted half, we search in that half as usual. If it is not in that sorted half, we search in the other half that contains the pivot.\\n\\nFor example, if the array is [4,5,6,7,0,1,2] and the target is 0:\\n\\n- We start with left = 0 and right = 6. The middle index is 3 and the middle element is 7.\\n- We see that the left half [4,5,6,7] is sorted and the right half [0,1,2] contains the pivot.\\n- We check if the target 0 is in the left half by comparing it with 4 and 7. It is not in that half because 0 < 4 < 7.\\n- So we search in the right half that contains the pivot by setting left = mid + 1 = 4.\\n- We repeat this process until we find the target or exhaust the search space."
                    },
                    {
                        "username": "dragon1105",
                        "content": "Thank you. This is probably the most elegant way to solve this problem. With this solution, we don\\'t even need to find the pivot\\'s location, which is quite smart."
                    },
                    {
                        "username": "jackbb147",
                        "content": "thank you. Great explanation"
                    },
                    {
                        "username": "eugk123",
                        "content": "Why is there a [1,3,5] test case?\\n\\nIt\\'s not that big of a deal, but the problem states it guarantee\\'s pivot in all test cases. Leetcode team, please either remove that statement or fix your test case."
                    },
                    {
                        "username": "amansingh4958",
                        "content": "Just avoid finding pivot for these cases by just comparing 1st and last element of the array"
                    },
                    {
                        "username": "heyyyankit",
                        "content": "[@pranavagrawal321](/pranavagrawal321)its given that ( 1 <= k < nums.length) so this is not possible..."
                    },
                    {
                        "username": "Gautamparti",
                        "content": "question clearly states \"possibly rotated\" , which means you have to include a case where their is no pivot"
                    },
                    {
                        "username": "mrunfunny",
                        "content": "[@pranavagrawal321](/pranavagrawal321) That\\'s one way to look at this :XD"
                    },
                    {
                        "username": "pranavagrawal321",
                        "content": "The test case is correct, since the array can be rotated thrice, resulting in the original sorted array."
                    },
                    {
                        "username": "brauliojde",
                        "content": "I believe that there is an error in one of the test cases because the array that is entered is [1,3] and in this array there is no rotation. "
                    },
                    {
                        "username": "vaishali_p14",
                        "content": "In the question, it is mentioned that the passed array is sorted and POSSIBLY rotated.\\n\\n"
                    },
                    {
                        "username": "Yanlin0408",
                        "content": "[@lakshminathan](/lakshminathan) lmao"
                    },
                    {
                        "username": "lakshminathan",
                        "content": "it is rotated twice"
                    },
                    {
                        "username": "euphoria_kiki",
                        "content": "The key idea is during the process fo binary search, we compare the number at position mid and position left. If the number at mid is larger, it implies that range [left, mid] is ordered (not rotated), so we can decide whether to move towards that range for further search. Otherwise, the number at mid is smaller, which implies that range [mid, right] is ordered (not rotated)."
                    },
                    {
                        "username": "Spam_Musubi",
                        "content": "nice, I was wondering why this was on the medium side, they should\\'ve made something to make this harder and for us to naturally come up with the binary search.\\n"
                    },
                    {
                        "username": "insomniachou",
                        "content": "I don't think this problem is for JS. I saw someone's (n + logn) solution, was wondering why not just compare one by one, resulting in O(n). Not sure the question is asking the index in the sorted array or in the rotated array.  I tried js build-in array method, and surprisingly my answer passed and beats 60%.  \\n\\n\\tvar search = function(nums, target) {\\n\\t\\treturn nums.indexOf(target);\\n\\t};"
                    },
                    {
                        "username": "danielmascena",
                        "content": "doesnt matter the programming language but the approach used"
                    },
                    {
                        "username": "rohiinegi2002",
                        "content": "it will pass... Cause you are using a function that runs of O(logn) time complexity and is called Binary Search..(^ ^)"
                    },
                    {
                        "username": "normanlmfung",
                        "content": "Same in pyton: def search(self, nums: List[int], target: int) -> int:\\n        if target in nums:\\n            return nums.index(target)\\n        else:\\n            return -1"
                    },
                    {
                        "username": "ladiaz4e98",
                        "content": "this is wrong. this is o(n), question is asking for o(log(n)).."
                    },
                    {
                        "username": "thedevwonder",
                        "content": "JS solution in O(logn) works, my answer beats 90%. I think it is independent of programming lang as long as you don\\'t use built in functions"
                    },
                    {
                        "username": "mohaymenrafi",
                        "content": "[@christinehong](/christinehong) when you use indexOf method, in worse case, it actually traverse the entire array which is O(n) operation. but in the question it specifically mentioned to use O(log n)"
                    },
                    {
                        "username": "christinehong",
                        "content": "that was literally my line of logic and i ended up with the same solution but in python"
                    },
                    {
                        "username": "gurnainwadhwa",
                        "content": "Just Binary Search"
                    },
                    {
                        "username": "anwendeng",
                        "content": "This problem is solved by using binary search several times.\nFirstly, it is suggested to find the location for the peak which can be done by binary search. \nSecondly, using  binary search to find location for the target  which  is possible before the peak or after the peak.\n\n# Be careful for the boundary cases when n=1 and n=2."
                    }
                ]
            },
            {
                "id": 1567816,
                "content": [
                    {
                        "username": "ss9394",
                        "content": "The problem is intented for Binary search. \\nBut if some is simply travering once  i.e  O(n) , It beats 100% . Which should not be the case. \\n\\nIt should only succeed for binary search based solution. i.e. O(log n)\\n\\n"
                    },
                    {
                        "username": "kaustubhmjb",
                        "content": "Big O notation is asymptotic. An absolute runtime of 2048n is slower than 128n**2, for values of n < 16 (also referred to as n0 in some definitions). Big O notation focuses on rate of change as input size grows arbitrarily."
                    },
                    {
                        "username": "gbiems",
                        "content": "I did binary search, and ran it 3 times, I got 99.5%, 6.3%, and 32%. So I wouldn\\'t put too much stock in the runtime for this.\\n\\nThat said, agreed, surprising you\\'d didn\\'t get a TLE with linear search. "
                    },
                    {
                        "username": "CaptainGalbatrollix",
                        "content": "[@pru_cuder](/pru_cuder) Well that\\'s not true in essence. Yes, big(O) notation is important and leetcode\\'s runtime judgement can be weird and leave a lot to be desired. \\n\\nHowever, it is crucial to remember big(O) is not the end all be all. If the overhead is big enough, for smaller input sizes \\'worse\\' solutions tend to be much more efficient due to factors such as cache locality. For example C++ built in sort switches from quicksort to insertion sort o(n^2) time complexity, when arrays get small enough. \\n\\nIn real life, solving this problem using bsearch would be questionable. Biggest possible size of array in the problem is 5000. If it was 5 * 10^6, then yeah double bsearch is the way to go and can save a lot of time, but you can\\'t honestly tell me a 5000 element loop will be a bottleneck in any system."
                    },
                    {
                        "username": "shivanshutripathii",
                        "content": "Exactly, I\\'ve applied binary search method and it beats only 8.19% in time (O(logn)).\\nWhen I\\'ve applied linear search then it beats 13.60% in time O(n). Crazy things happen."
                    },
                    {
                        "username": "pru_cuder",
                        "content": "those runtimes are based on machine i.e cpu config as well as programming language. Never take these runtimes as a parameter, always focus on Big O notation"
                    },
                    {
                        "username": "mandy1339",
                        "content": "First do a binary search to find the pivot:\\n\\n- Step 1\\n\\t-  compare mid pointer to right most value on the array. If value in mid pointer is greater than right most value in array, we know the pivot is to the right of the mid pointer. If value at mid pointer is smaller than right most value in the array, we know that the pivot is to the left. Split array in half until your left and right pointers touch.\\n- Step 2\\n\\t- Do a 2nd binary search on the whole array. This time we are looking for the target, not a pivot. Now that we know our pivot we just need to modify our midvalue like so: realMid = (mid + pivot) % nums.Length;\\n\\nComplexity of 2 binary searches is O ( 2 Log (n)) which is O (Log(n))"
                    },
                    {
                        "username": "Nitkapur30",
                        "content": "Solution explained: \\nhttps://leetcode.com/problems/search-in-rotated-sorted-array/solutions/3782253/c-binary-search-solution-with-breakdown-of-each-condition/"
                    },
                    {
                        "username": "srapol",
                        "content": "[@Aishwarya_jits](/Aishwarya_jits) how ?"
                    },
                    {
                        "username": "bparanj",
                        "content": "[@shape_mismatch](/shape_mismatch) Actually, both approaches are equally efficient when it comes to handling the case where the array is not pivoted, or sorted. This is because the binary search is performed based on the relationship between the target and the elements at the left, mid, and right positions, not based on whether the array is sorted or not.\\n\\nHowever, comparing with the leftmost element in the array does have an advantage when the array has duplicate values. In case of duplicate values, comparing with the rightmost element might lead to scenarios where we\\'re unable to decide which half of the array to proceed with, thus degrading the performance to O(n) in the worst-case scenario. On the other hand, comparing with the leftmost element can help us avoid such scenarios, thus maintaining a time complexity of O(log n) even when the array contains duplicate values.\\n"
                    },
                    {
                        "username": "Ramonsan07",
                        "content": "was ramdomly checking this problem and  remembered I had solved this in the way you describe https://leetcode.com/problems/search-in-rotated-sorted-array/solutions/3498417/easiest-intuitive-simple-two-binary-searches-solution/"
                    },
                    {
                        "username": "dragon1105",
                        "content": "[@shape_mismatch](/shape_mismatch) I think to compare mid with either the leftmost or the rightmost value is the same, because the probabilities that the pivot is located closer to the left side or to the right side are equal.\\nAnd for the case the array is not pivoted, we just need to check at the beginning whether the leftmost value is less than the rightmost value. If it is, then the array is not pivoted, because if the array is then leftmost must be greater than rightmost."
                    },
                    {
                        "username": "Salominius",
                        "content": "[@lucasscodes](/lucasscodes) 2*O(log n) is NOT O(n) but in fact O(log n).\\nJust as 2 * log n is not n."
                    },
                    {
                        "username": "Aishwarya_jits",
                        "content": "You dont need to do binary search twice, the target can be found in one search by tweaking the binary search code to accommodate for the pivoted element. My point is you dont necessarily have to find the pivot, your code just needs to be aware of its existence. "
                    },
                    {
                        "username": "imankulov53",
                        "content": "thank you for your idea to find pivot on which array is rotated, it\\'s simplifies task and give clear and simple solution"
                    },
                    {
                        "username": "user2748pU",
                        "content": "[@lucasscodes](/lucasscodes) actually what u are saying is wrong, binary search doesn\\'t take n/2 time, it takes log(n) time, so even doing it twice will result in a \"real time\" of 2 times of what it took do do a binary search once (=> 2*log(n)), which will in turn result in O(log(n)), since we ignore constant factors (like the 2*) in big O-Notation."
                    },
                    {
                        "username": "lucasscodes",
                        "content": "This has O(n) complexity.\\n2 times n/2 => n.\\nDont even mind binary search if you need to do it twice..."
                    },
                    {
                        "username": "spencerreitz2002",
                        "content": "[@shape_mismatch](/shape_mismatch) I believe the opposite it true. If the array is pivoted one place to the left, the number at the leftmost position of the array is less than the middle, but the rightmost point is now less than the middle also."
                    },
                    {
                        "username": "_arjan31",
                        "content": "To get it in log(N) complexity , follow strivers method"
                    },
                    {
                        "username": "shape_mismatch",
                        "content": "Wouldn\\'t it be better to compare with the leftmost value in the array (step 1), instead of the rightmost. It would be faster in taking care of cases where the array is not pivoted?"
                    },
                    {
                        "username": "charly371",
                        "content": "I get an error with the following test case: ([1,3], 1) which should output 0 since the integer 1 is present at index 0. \\nMy solution did not work for this one because I based it on the fact that the array will get rotate somewhere. \\n\\nI m thus wondering if you think this test case is valid ? or maybe the exercise should be change to say that the array may be rotated (but not necessarily is...) ?\\n\\nI will change my algo but i would like your feedback in case it was a real interview. what would you say ?\\nThx"
                    },
                    {
                        "username": "olsonpm",
                        "content": "[@vaishali_p14](/vaishali_p14) It also doesn\\'t say what to return in the case it\\'s not rotated\\n\\n> return the index of target if it is in nums, or -1 if it is not in nums"
                    },
                    {
                        "username": "GitG0",
                        "content": "people in 2023 answering a question asked in 2017 without knowing if the constraints or the question itself were modified in those ~6 years lol "
                    },
                    {
                        "username": "raghavsharmaji",
                        "content": "What do you think is meant by \"is possibly rotated\"?"
                    },
                    {
                        "username": "devansh10z",
                        "content": "suppose a case where an array of length n is rotated n times. you get the same array. that is the only reason this test case is a valid case."
                    },
                    {
                        "username": "AHawkeye",
                        "content": "[@vaishali_p14](/vaishali_p14)  But in the description, is says that k >= 1, which means the arrayed must be rotated."
                    },
                    {
                        "username": "sanjay2207",
                        "content": "You may not be checking one of <= or >= conditions correctly. I ran into same issue."
                    },
                    {
                        "username": "vaishali_p14",
                        "content": "In the question, it is mentioned that the passed array is sorted and POSSIBLY rotated."
                    },
                    {
                        "username": "hafezachu",
                        "content": "The main idea is to use binary search to find the target in the array. Binary search is a technique that divides the search space into two halves and compares the target with the middle element. If the target is equal to the middle element, we have found the index. If the target is smaller than the middle element, we search in the left half. If the target is larger than the middle element, we search in the right half. This way, we can reduce the search space by half in each iteration and achieve O(log n) runtime complexity.\\n\\nHowever, since the array is possibly rotated at some unknown pivot, we cannot directly apply binary search. We need to modify it slightly to handle the rotation. The key observation is that one of the two halves must be sorted, and the other half must contain the pivot. For example, if the array is [4,5,6,7,0,1,2], then the left half [4,5,6,7] is sorted and the right half [0,1,2] contains the pivot. If the array is [7,0,1,2,4,5,6], then the right half [2,4,5,6] is sorted and the left half [7,0,1] contains the pivot.\\n\\nSo, in each iteration of binary search, we first check which half is sorted by comparing the left and middle elements. Then we check if the target is in that sorted half by comparing it with the left and middle elements. If it is in that sorted half, we search in that half as usual. If it is not in that sorted half, we search in the other half that contains the pivot.\\n\\nFor example, if the array is [4,5,6,7,0,1,2] and the target is 0:\\n\\n- We start with left = 0 and right = 6. The middle index is 3 and the middle element is 7.\\n- We see that the left half [4,5,6,7] is sorted and the right half [0,1,2] contains the pivot.\\n- We check if the target 0 is in the left half by comparing it with 4 and 7. It is not in that half because 0 < 4 < 7.\\n- So we search in the right half that contains the pivot by setting left = mid + 1 = 4.\\n- We repeat this process until we find the target or exhaust the search space."
                    },
                    {
                        "username": "dragon1105",
                        "content": "Thank you. This is probably the most elegant way to solve this problem. With this solution, we don\\'t even need to find the pivot\\'s location, which is quite smart."
                    },
                    {
                        "username": "jackbb147",
                        "content": "thank you. Great explanation"
                    },
                    {
                        "username": "eugk123",
                        "content": "Why is there a [1,3,5] test case?\\n\\nIt\\'s not that big of a deal, but the problem states it guarantee\\'s pivot in all test cases. Leetcode team, please either remove that statement or fix your test case."
                    },
                    {
                        "username": "amansingh4958",
                        "content": "Just avoid finding pivot for these cases by just comparing 1st and last element of the array"
                    },
                    {
                        "username": "heyyyankit",
                        "content": "[@pranavagrawal321](/pranavagrawal321)its given that ( 1 <= k < nums.length) so this is not possible..."
                    },
                    {
                        "username": "Gautamparti",
                        "content": "question clearly states \"possibly rotated\" , which means you have to include a case where their is no pivot"
                    },
                    {
                        "username": "mrunfunny",
                        "content": "[@pranavagrawal321](/pranavagrawal321) That\\'s one way to look at this :XD"
                    },
                    {
                        "username": "pranavagrawal321",
                        "content": "The test case is correct, since the array can be rotated thrice, resulting in the original sorted array."
                    },
                    {
                        "username": "brauliojde",
                        "content": "I believe that there is an error in one of the test cases because the array that is entered is [1,3] and in this array there is no rotation. "
                    },
                    {
                        "username": "vaishali_p14",
                        "content": "In the question, it is mentioned that the passed array is sorted and POSSIBLY rotated.\\n\\n"
                    },
                    {
                        "username": "Yanlin0408",
                        "content": "[@lakshminathan](/lakshminathan) lmao"
                    },
                    {
                        "username": "lakshminathan",
                        "content": "it is rotated twice"
                    },
                    {
                        "username": "euphoria_kiki",
                        "content": "The key idea is during the process fo binary search, we compare the number at position mid and position left. If the number at mid is larger, it implies that range [left, mid] is ordered (not rotated), so we can decide whether to move towards that range for further search. Otherwise, the number at mid is smaller, which implies that range [mid, right] is ordered (not rotated)."
                    },
                    {
                        "username": "Spam_Musubi",
                        "content": "nice, I was wondering why this was on the medium side, they should\\'ve made something to make this harder and for us to naturally come up with the binary search.\\n"
                    },
                    {
                        "username": "insomniachou",
                        "content": "I don't think this problem is for JS. I saw someone's (n + logn) solution, was wondering why not just compare one by one, resulting in O(n). Not sure the question is asking the index in the sorted array or in the rotated array.  I tried js build-in array method, and surprisingly my answer passed and beats 60%.  \\n\\n\\tvar search = function(nums, target) {\\n\\t\\treturn nums.indexOf(target);\\n\\t};"
                    },
                    {
                        "username": "danielmascena",
                        "content": "doesnt matter the programming language but the approach used"
                    },
                    {
                        "username": "rohiinegi2002",
                        "content": "it will pass... Cause you are using a function that runs of O(logn) time complexity and is called Binary Search..(^ ^)"
                    },
                    {
                        "username": "normanlmfung",
                        "content": "Same in pyton: def search(self, nums: List[int], target: int) -> int:\\n        if target in nums:\\n            return nums.index(target)\\n        else:\\n            return -1"
                    },
                    {
                        "username": "ladiaz4e98",
                        "content": "this is wrong. this is o(n), question is asking for o(log(n)).."
                    },
                    {
                        "username": "thedevwonder",
                        "content": "JS solution in O(logn) works, my answer beats 90%. I think it is independent of programming lang as long as you don\\'t use built in functions"
                    },
                    {
                        "username": "mohaymenrafi",
                        "content": "[@christinehong](/christinehong) when you use indexOf method, in worse case, it actually traverse the entire array which is O(n) operation. but in the question it specifically mentioned to use O(log n)"
                    },
                    {
                        "username": "christinehong",
                        "content": "that was literally my line of logic and i ended up with the same solution but in python"
                    },
                    {
                        "username": "gurnainwadhwa",
                        "content": "Just Binary Search"
                    },
                    {
                        "username": "anwendeng",
                        "content": "This problem is solved by using binary search several times.\nFirstly, it is suggested to find the location for the peak which can be done by binary search. \nSecondly, using  binary search to find location for the target  which  is possible before the peak or after the peak.\n\n# Be careful for the boundary cases when n=1 and n=2."
                    }
                ]
            },
            {
                "id": 1844246,
                "content": [
                    {
                        "username": "ss9394",
                        "content": "The problem is intented for Binary search. \\nBut if some is simply travering once  i.e  O(n) , It beats 100% . Which should not be the case. \\n\\nIt should only succeed for binary search based solution. i.e. O(log n)\\n\\n"
                    },
                    {
                        "username": "kaustubhmjb",
                        "content": "Big O notation is asymptotic. An absolute runtime of 2048n is slower than 128n**2, for values of n < 16 (also referred to as n0 in some definitions). Big O notation focuses on rate of change as input size grows arbitrarily."
                    },
                    {
                        "username": "gbiems",
                        "content": "I did binary search, and ran it 3 times, I got 99.5%, 6.3%, and 32%. So I wouldn\\'t put too much stock in the runtime for this.\\n\\nThat said, agreed, surprising you\\'d didn\\'t get a TLE with linear search. "
                    },
                    {
                        "username": "CaptainGalbatrollix",
                        "content": "[@pru_cuder](/pru_cuder) Well that\\'s not true in essence. Yes, big(O) notation is important and leetcode\\'s runtime judgement can be weird and leave a lot to be desired. \\n\\nHowever, it is crucial to remember big(O) is not the end all be all. If the overhead is big enough, for smaller input sizes \\'worse\\' solutions tend to be much more efficient due to factors such as cache locality. For example C++ built in sort switches from quicksort to insertion sort o(n^2) time complexity, when arrays get small enough. \\n\\nIn real life, solving this problem using bsearch would be questionable. Biggest possible size of array in the problem is 5000. If it was 5 * 10^6, then yeah double bsearch is the way to go and can save a lot of time, but you can\\'t honestly tell me a 5000 element loop will be a bottleneck in any system."
                    },
                    {
                        "username": "shivanshutripathii",
                        "content": "Exactly, I\\'ve applied binary search method and it beats only 8.19% in time (O(logn)).\\nWhen I\\'ve applied linear search then it beats 13.60% in time O(n). Crazy things happen."
                    },
                    {
                        "username": "pru_cuder",
                        "content": "those runtimes are based on machine i.e cpu config as well as programming language. Never take these runtimes as a parameter, always focus on Big O notation"
                    },
                    {
                        "username": "mandy1339",
                        "content": "First do a binary search to find the pivot:\\n\\n- Step 1\\n\\t-  compare mid pointer to right most value on the array. If value in mid pointer is greater than right most value in array, we know the pivot is to the right of the mid pointer. If value at mid pointer is smaller than right most value in the array, we know that the pivot is to the left. Split array in half until your left and right pointers touch.\\n- Step 2\\n\\t- Do a 2nd binary search on the whole array. This time we are looking for the target, not a pivot. Now that we know our pivot we just need to modify our midvalue like so: realMid = (mid + pivot) % nums.Length;\\n\\nComplexity of 2 binary searches is O ( 2 Log (n)) which is O (Log(n))"
                    },
                    {
                        "username": "Nitkapur30",
                        "content": "Solution explained: \\nhttps://leetcode.com/problems/search-in-rotated-sorted-array/solutions/3782253/c-binary-search-solution-with-breakdown-of-each-condition/"
                    },
                    {
                        "username": "srapol",
                        "content": "[@Aishwarya_jits](/Aishwarya_jits) how ?"
                    },
                    {
                        "username": "bparanj",
                        "content": "[@shape_mismatch](/shape_mismatch) Actually, both approaches are equally efficient when it comes to handling the case where the array is not pivoted, or sorted. This is because the binary search is performed based on the relationship between the target and the elements at the left, mid, and right positions, not based on whether the array is sorted or not.\\n\\nHowever, comparing with the leftmost element in the array does have an advantage when the array has duplicate values. In case of duplicate values, comparing with the rightmost element might lead to scenarios where we\\'re unable to decide which half of the array to proceed with, thus degrading the performance to O(n) in the worst-case scenario. On the other hand, comparing with the leftmost element can help us avoid such scenarios, thus maintaining a time complexity of O(log n) even when the array contains duplicate values.\\n"
                    },
                    {
                        "username": "Ramonsan07",
                        "content": "was ramdomly checking this problem and  remembered I had solved this in the way you describe https://leetcode.com/problems/search-in-rotated-sorted-array/solutions/3498417/easiest-intuitive-simple-two-binary-searches-solution/"
                    },
                    {
                        "username": "dragon1105",
                        "content": "[@shape_mismatch](/shape_mismatch) I think to compare mid with either the leftmost or the rightmost value is the same, because the probabilities that the pivot is located closer to the left side or to the right side are equal.\\nAnd for the case the array is not pivoted, we just need to check at the beginning whether the leftmost value is less than the rightmost value. If it is, then the array is not pivoted, because if the array is then leftmost must be greater than rightmost."
                    },
                    {
                        "username": "Salominius",
                        "content": "[@lucasscodes](/lucasscodes) 2*O(log n) is NOT O(n) but in fact O(log n).\\nJust as 2 * log n is not n."
                    },
                    {
                        "username": "Aishwarya_jits",
                        "content": "You dont need to do binary search twice, the target can be found in one search by tweaking the binary search code to accommodate for the pivoted element. My point is you dont necessarily have to find the pivot, your code just needs to be aware of its existence. "
                    },
                    {
                        "username": "imankulov53",
                        "content": "thank you for your idea to find pivot on which array is rotated, it\\'s simplifies task and give clear and simple solution"
                    },
                    {
                        "username": "user2748pU",
                        "content": "[@lucasscodes](/lucasscodes) actually what u are saying is wrong, binary search doesn\\'t take n/2 time, it takes log(n) time, so even doing it twice will result in a \"real time\" of 2 times of what it took do do a binary search once (=> 2*log(n)), which will in turn result in O(log(n)), since we ignore constant factors (like the 2*) in big O-Notation."
                    },
                    {
                        "username": "lucasscodes",
                        "content": "This has O(n) complexity.\\n2 times n/2 => n.\\nDont even mind binary search if you need to do it twice..."
                    },
                    {
                        "username": "spencerreitz2002",
                        "content": "[@shape_mismatch](/shape_mismatch) I believe the opposite it true. If the array is pivoted one place to the left, the number at the leftmost position of the array is less than the middle, but the rightmost point is now less than the middle also."
                    },
                    {
                        "username": "_arjan31",
                        "content": "To get it in log(N) complexity , follow strivers method"
                    },
                    {
                        "username": "shape_mismatch",
                        "content": "Wouldn\\'t it be better to compare with the leftmost value in the array (step 1), instead of the rightmost. It would be faster in taking care of cases where the array is not pivoted?"
                    },
                    {
                        "username": "charly371",
                        "content": "I get an error with the following test case: ([1,3], 1) which should output 0 since the integer 1 is present at index 0. \\nMy solution did not work for this one because I based it on the fact that the array will get rotate somewhere. \\n\\nI m thus wondering if you think this test case is valid ? or maybe the exercise should be change to say that the array may be rotated (but not necessarily is...) ?\\n\\nI will change my algo but i would like your feedback in case it was a real interview. what would you say ?\\nThx"
                    },
                    {
                        "username": "olsonpm",
                        "content": "[@vaishali_p14](/vaishali_p14) It also doesn\\'t say what to return in the case it\\'s not rotated\\n\\n> return the index of target if it is in nums, or -1 if it is not in nums"
                    },
                    {
                        "username": "GitG0",
                        "content": "people in 2023 answering a question asked in 2017 without knowing if the constraints or the question itself were modified in those ~6 years lol "
                    },
                    {
                        "username": "raghavsharmaji",
                        "content": "What do you think is meant by \"is possibly rotated\"?"
                    },
                    {
                        "username": "devansh10z",
                        "content": "suppose a case where an array of length n is rotated n times. you get the same array. that is the only reason this test case is a valid case."
                    },
                    {
                        "username": "AHawkeye",
                        "content": "[@vaishali_p14](/vaishali_p14)  But in the description, is says that k >= 1, which means the arrayed must be rotated."
                    },
                    {
                        "username": "sanjay2207",
                        "content": "You may not be checking one of <= or >= conditions correctly. I ran into same issue."
                    },
                    {
                        "username": "vaishali_p14",
                        "content": "In the question, it is mentioned that the passed array is sorted and POSSIBLY rotated."
                    },
                    {
                        "username": "hafezachu",
                        "content": "The main idea is to use binary search to find the target in the array. Binary search is a technique that divides the search space into two halves and compares the target with the middle element. If the target is equal to the middle element, we have found the index. If the target is smaller than the middle element, we search in the left half. If the target is larger than the middle element, we search in the right half. This way, we can reduce the search space by half in each iteration and achieve O(log n) runtime complexity.\\n\\nHowever, since the array is possibly rotated at some unknown pivot, we cannot directly apply binary search. We need to modify it slightly to handle the rotation. The key observation is that one of the two halves must be sorted, and the other half must contain the pivot. For example, if the array is [4,5,6,7,0,1,2], then the left half [4,5,6,7] is sorted and the right half [0,1,2] contains the pivot. If the array is [7,0,1,2,4,5,6], then the right half [2,4,5,6] is sorted and the left half [7,0,1] contains the pivot.\\n\\nSo, in each iteration of binary search, we first check which half is sorted by comparing the left and middle elements. Then we check if the target is in that sorted half by comparing it with the left and middle elements. If it is in that sorted half, we search in that half as usual. If it is not in that sorted half, we search in the other half that contains the pivot.\\n\\nFor example, if the array is [4,5,6,7,0,1,2] and the target is 0:\\n\\n- We start with left = 0 and right = 6. The middle index is 3 and the middle element is 7.\\n- We see that the left half [4,5,6,7] is sorted and the right half [0,1,2] contains the pivot.\\n- We check if the target 0 is in the left half by comparing it with 4 and 7. It is not in that half because 0 < 4 < 7.\\n- So we search in the right half that contains the pivot by setting left = mid + 1 = 4.\\n- We repeat this process until we find the target or exhaust the search space."
                    },
                    {
                        "username": "dragon1105",
                        "content": "Thank you. This is probably the most elegant way to solve this problem. With this solution, we don\\'t even need to find the pivot\\'s location, which is quite smart."
                    },
                    {
                        "username": "jackbb147",
                        "content": "thank you. Great explanation"
                    },
                    {
                        "username": "eugk123",
                        "content": "Why is there a [1,3,5] test case?\\n\\nIt\\'s not that big of a deal, but the problem states it guarantee\\'s pivot in all test cases. Leetcode team, please either remove that statement or fix your test case."
                    },
                    {
                        "username": "amansingh4958",
                        "content": "Just avoid finding pivot for these cases by just comparing 1st and last element of the array"
                    },
                    {
                        "username": "heyyyankit",
                        "content": "[@pranavagrawal321](/pranavagrawal321)its given that ( 1 <= k < nums.length) so this is not possible..."
                    },
                    {
                        "username": "Gautamparti",
                        "content": "question clearly states \"possibly rotated\" , which means you have to include a case where their is no pivot"
                    },
                    {
                        "username": "mrunfunny",
                        "content": "[@pranavagrawal321](/pranavagrawal321) That\\'s one way to look at this :XD"
                    },
                    {
                        "username": "pranavagrawal321",
                        "content": "The test case is correct, since the array can be rotated thrice, resulting in the original sorted array."
                    },
                    {
                        "username": "brauliojde",
                        "content": "I believe that there is an error in one of the test cases because the array that is entered is [1,3] and in this array there is no rotation. "
                    },
                    {
                        "username": "vaishali_p14",
                        "content": "In the question, it is mentioned that the passed array is sorted and POSSIBLY rotated.\\n\\n"
                    },
                    {
                        "username": "Yanlin0408",
                        "content": "[@lakshminathan](/lakshminathan) lmao"
                    },
                    {
                        "username": "lakshminathan",
                        "content": "it is rotated twice"
                    },
                    {
                        "username": "euphoria_kiki",
                        "content": "The key idea is during the process fo binary search, we compare the number at position mid and position left. If the number at mid is larger, it implies that range [left, mid] is ordered (not rotated), so we can decide whether to move towards that range for further search. Otherwise, the number at mid is smaller, which implies that range [mid, right] is ordered (not rotated)."
                    },
                    {
                        "username": "Spam_Musubi",
                        "content": "nice, I was wondering why this was on the medium side, they should\\'ve made something to make this harder and for us to naturally come up with the binary search.\\n"
                    },
                    {
                        "username": "insomniachou",
                        "content": "I don't think this problem is for JS. I saw someone's (n + logn) solution, was wondering why not just compare one by one, resulting in O(n). Not sure the question is asking the index in the sorted array or in the rotated array.  I tried js build-in array method, and surprisingly my answer passed and beats 60%.  \\n\\n\\tvar search = function(nums, target) {\\n\\t\\treturn nums.indexOf(target);\\n\\t};"
                    },
                    {
                        "username": "danielmascena",
                        "content": "doesnt matter the programming language but the approach used"
                    },
                    {
                        "username": "rohiinegi2002",
                        "content": "it will pass... Cause you are using a function that runs of O(logn) time complexity and is called Binary Search..(^ ^)"
                    },
                    {
                        "username": "normanlmfung",
                        "content": "Same in pyton: def search(self, nums: List[int], target: int) -> int:\\n        if target in nums:\\n            return nums.index(target)\\n        else:\\n            return -1"
                    },
                    {
                        "username": "ladiaz4e98",
                        "content": "this is wrong. this is o(n), question is asking for o(log(n)).."
                    },
                    {
                        "username": "thedevwonder",
                        "content": "JS solution in O(logn) works, my answer beats 90%. I think it is independent of programming lang as long as you don\\'t use built in functions"
                    },
                    {
                        "username": "mohaymenrafi",
                        "content": "[@christinehong](/christinehong) when you use indexOf method, in worse case, it actually traverse the entire array which is O(n) operation. but in the question it specifically mentioned to use O(log n)"
                    },
                    {
                        "username": "christinehong",
                        "content": "that was literally my line of logic and i ended up with the same solution but in python"
                    },
                    {
                        "username": "gurnainwadhwa",
                        "content": "Just Binary Search"
                    },
                    {
                        "username": "anwendeng",
                        "content": "This problem is solved by using binary search several times.\nFirstly, it is suggested to find the location for the peak which can be done by binary search. \nSecondly, using  binary search to find location for the target  which  is possible before the peak or after the peak.\n\n# Be careful for the boundary cases when n=1 and n=2."
                    }
                ]
            },
            {
                "id": 2004907,
                "content": [
                    {
                        "username": "ss9394",
                        "content": "The problem is intented for Binary search. \\nBut if some is simply travering once  i.e  O(n) , It beats 100% . Which should not be the case. \\n\\nIt should only succeed for binary search based solution. i.e. O(log n)\\n\\n"
                    },
                    {
                        "username": "kaustubhmjb",
                        "content": "Big O notation is asymptotic. An absolute runtime of 2048n is slower than 128n**2, for values of n < 16 (also referred to as n0 in some definitions). Big O notation focuses on rate of change as input size grows arbitrarily."
                    },
                    {
                        "username": "gbiems",
                        "content": "I did binary search, and ran it 3 times, I got 99.5%, 6.3%, and 32%. So I wouldn\\'t put too much stock in the runtime for this.\\n\\nThat said, agreed, surprising you\\'d didn\\'t get a TLE with linear search. "
                    },
                    {
                        "username": "CaptainGalbatrollix",
                        "content": "[@pru_cuder](/pru_cuder) Well that\\'s not true in essence. Yes, big(O) notation is important and leetcode\\'s runtime judgement can be weird and leave a lot to be desired. \\n\\nHowever, it is crucial to remember big(O) is not the end all be all. If the overhead is big enough, for smaller input sizes \\'worse\\' solutions tend to be much more efficient due to factors such as cache locality. For example C++ built in sort switches from quicksort to insertion sort o(n^2) time complexity, when arrays get small enough. \\n\\nIn real life, solving this problem using bsearch would be questionable. Biggest possible size of array in the problem is 5000. If it was 5 * 10^6, then yeah double bsearch is the way to go and can save a lot of time, but you can\\'t honestly tell me a 5000 element loop will be a bottleneck in any system."
                    },
                    {
                        "username": "shivanshutripathii",
                        "content": "Exactly, I\\'ve applied binary search method and it beats only 8.19% in time (O(logn)).\\nWhen I\\'ve applied linear search then it beats 13.60% in time O(n). Crazy things happen."
                    },
                    {
                        "username": "pru_cuder",
                        "content": "those runtimes are based on machine i.e cpu config as well as programming language. Never take these runtimes as a parameter, always focus on Big O notation"
                    },
                    {
                        "username": "mandy1339",
                        "content": "First do a binary search to find the pivot:\\n\\n- Step 1\\n\\t-  compare mid pointer to right most value on the array. If value in mid pointer is greater than right most value in array, we know the pivot is to the right of the mid pointer. If value at mid pointer is smaller than right most value in the array, we know that the pivot is to the left. Split array in half until your left and right pointers touch.\\n- Step 2\\n\\t- Do a 2nd binary search on the whole array. This time we are looking for the target, not a pivot. Now that we know our pivot we just need to modify our midvalue like so: realMid = (mid + pivot) % nums.Length;\\n\\nComplexity of 2 binary searches is O ( 2 Log (n)) which is O (Log(n))"
                    },
                    {
                        "username": "Nitkapur30",
                        "content": "Solution explained: \\nhttps://leetcode.com/problems/search-in-rotated-sorted-array/solutions/3782253/c-binary-search-solution-with-breakdown-of-each-condition/"
                    },
                    {
                        "username": "srapol",
                        "content": "[@Aishwarya_jits](/Aishwarya_jits) how ?"
                    },
                    {
                        "username": "bparanj",
                        "content": "[@shape_mismatch](/shape_mismatch) Actually, both approaches are equally efficient when it comes to handling the case where the array is not pivoted, or sorted. This is because the binary search is performed based on the relationship between the target and the elements at the left, mid, and right positions, not based on whether the array is sorted or not.\\n\\nHowever, comparing with the leftmost element in the array does have an advantage when the array has duplicate values. In case of duplicate values, comparing with the rightmost element might lead to scenarios where we\\'re unable to decide which half of the array to proceed with, thus degrading the performance to O(n) in the worst-case scenario. On the other hand, comparing with the leftmost element can help us avoid such scenarios, thus maintaining a time complexity of O(log n) even when the array contains duplicate values.\\n"
                    },
                    {
                        "username": "Ramonsan07",
                        "content": "was ramdomly checking this problem and  remembered I had solved this in the way you describe https://leetcode.com/problems/search-in-rotated-sorted-array/solutions/3498417/easiest-intuitive-simple-two-binary-searches-solution/"
                    },
                    {
                        "username": "dragon1105",
                        "content": "[@shape_mismatch](/shape_mismatch) I think to compare mid with either the leftmost or the rightmost value is the same, because the probabilities that the pivot is located closer to the left side or to the right side are equal.\\nAnd for the case the array is not pivoted, we just need to check at the beginning whether the leftmost value is less than the rightmost value. If it is, then the array is not pivoted, because if the array is then leftmost must be greater than rightmost."
                    },
                    {
                        "username": "Salominius",
                        "content": "[@lucasscodes](/lucasscodes) 2*O(log n) is NOT O(n) but in fact O(log n).\\nJust as 2 * log n is not n."
                    },
                    {
                        "username": "Aishwarya_jits",
                        "content": "You dont need to do binary search twice, the target can be found in one search by tweaking the binary search code to accommodate for the pivoted element. My point is you dont necessarily have to find the pivot, your code just needs to be aware of its existence. "
                    },
                    {
                        "username": "imankulov53",
                        "content": "thank you for your idea to find pivot on which array is rotated, it\\'s simplifies task and give clear and simple solution"
                    },
                    {
                        "username": "user2748pU",
                        "content": "[@lucasscodes](/lucasscodes) actually what u are saying is wrong, binary search doesn\\'t take n/2 time, it takes log(n) time, so even doing it twice will result in a \"real time\" of 2 times of what it took do do a binary search once (=> 2*log(n)), which will in turn result in O(log(n)), since we ignore constant factors (like the 2*) in big O-Notation."
                    },
                    {
                        "username": "lucasscodes",
                        "content": "This has O(n) complexity.\\n2 times n/2 => n.\\nDont even mind binary search if you need to do it twice..."
                    },
                    {
                        "username": "spencerreitz2002",
                        "content": "[@shape_mismatch](/shape_mismatch) I believe the opposite it true. If the array is pivoted one place to the left, the number at the leftmost position of the array is less than the middle, but the rightmost point is now less than the middle also."
                    },
                    {
                        "username": "_arjan31",
                        "content": "To get it in log(N) complexity , follow strivers method"
                    },
                    {
                        "username": "shape_mismatch",
                        "content": "Wouldn\\'t it be better to compare with the leftmost value in the array (step 1), instead of the rightmost. It would be faster in taking care of cases where the array is not pivoted?"
                    },
                    {
                        "username": "charly371",
                        "content": "I get an error with the following test case: ([1,3], 1) which should output 0 since the integer 1 is present at index 0. \\nMy solution did not work for this one because I based it on the fact that the array will get rotate somewhere. \\n\\nI m thus wondering if you think this test case is valid ? or maybe the exercise should be change to say that the array may be rotated (but not necessarily is...) ?\\n\\nI will change my algo but i would like your feedback in case it was a real interview. what would you say ?\\nThx"
                    },
                    {
                        "username": "olsonpm",
                        "content": "[@vaishali_p14](/vaishali_p14) It also doesn\\'t say what to return in the case it\\'s not rotated\\n\\n> return the index of target if it is in nums, or -1 if it is not in nums"
                    },
                    {
                        "username": "GitG0",
                        "content": "people in 2023 answering a question asked in 2017 without knowing if the constraints or the question itself were modified in those ~6 years lol "
                    },
                    {
                        "username": "raghavsharmaji",
                        "content": "What do you think is meant by \"is possibly rotated\"?"
                    },
                    {
                        "username": "devansh10z",
                        "content": "suppose a case where an array of length n is rotated n times. you get the same array. that is the only reason this test case is a valid case."
                    },
                    {
                        "username": "AHawkeye",
                        "content": "[@vaishali_p14](/vaishali_p14)  But in the description, is says that k >= 1, which means the arrayed must be rotated."
                    },
                    {
                        "username": "sanjay2207",
                        "content": "You may not be checking one of <= or >= conditions correctly. I ran into same issue."
                    },
                    {
                        "username": "vaishali_p14",
                        "content": "In the question, it is mentioned that the passed array is sorted and POSSIBLY rotated."
                    },
                    {
                        "username": "hafezachu",
                        "content": "The main idea is to use binary search to find the target in the array. Binary search is a technique that divides the search space into two halves and compares the target with the middle element. If the target is equal to the middle element, we have found the index. If the target is smaller than the middle element, we search in the left half. If the target is larger than the middle element, we search in the right half. This way, we can reduce the search space by half in each iteration and achieve O(log n) runtime complexity.\\n\\nHowever, since the array is possibly rotated at some unknown pivot, we cannot directly apply binary search. We need to modify it slightly to handle the rotation. The key observation is that one of the two halves must be sorted, and the other half must contain the pivot. For example, if the array is [4,5,6,7,0,1,2], then the left half [4,5,6,7] is sorted and the right half [0,1,2] contains the pivot. If the array is [7,0,1,2,4,5,6], then the right half [2,4,5,6] is sorted and the left half [7,0,1] contains the pivot.\\n\\nSo, in each iteration of binary search, we first check which half is sorted by comparing the left and middle elements. Then we check if the target is in that sorted half by comparing it with the left and middle elements. If it is in that sorted half, we search in that half as usual. If it is not in that sorted half, we search in the other half that contains the pivot.\\n\\nFor example, if the array is [4,5,6,7,0,1,2] and the target is 0:\\n\\n- We start with left = 0 and right = 6. The middle index is 3 and the middle element is 7.\\n- We see that the left half [4,5,6,7] is sorted and the right half [0,1,2] contains the pivot.\\n- We check if the target 0 is in the left half by comparing it with 4 and 7. It is not in that half because 0 < 4 < 7.\\n- So we search in the right half that contains the pivot by setting left = mid + 1 = 4.\\n- We repeat this process until we find the target or exhaust the search space."
                    },
                    {
                        "username": "dragon1105",
                        "content": "Thank you. This is probably the most elegant way to solve this problem. With this solution, we don\\'t even need to find the pivot\\'s location, which is quite smart."
                    },
                    {
                        "username": "jackbb147",
                        "content": "thank you. Great explanation"
                    },
                    {
                        "username": "eugk123",
                        "content": "Why is there a [1,3,5] test case?\\n\\nIt\\'s not that big of a deal, but the problem states it guarantee\\'s pivot in all test cases. Leetcode team, please either remove that statement or fix your test case."
                    },
                    {
                        "username": "amansingh4958",
                        "content": "Just avoid finding pivot for these cases by just comparing 1st and last element of the array"
                    },
                    {
                        "username": "heyyyankit",
                        "content": "[@pranavagrawal321](/pranavagrawal321)its given that ( 1 <= k < nums.length) so this is not possible..."
                    },
                    {
                        "username": "Gautamparti",
                        "content": "question clearly states \"possibly rotated\" , which means you have to include a case where their is no pivot"
                    },
                    {
                        "username": "mrunfunny",
                        "content": "[@pranavagrawal321](/pranavagrawal321) That\\'s one way to look at this :XD"
                    },
                    {
                        "username": "pranavagrawal321",
                        "content": "The test case is correct, since the array can be rotated thrice, resulting in the original sorted array."
                    },
                    {
                        "username": "brauliojde",
                        "content": "I believe that there is an error in one of the test cases because the array that is entered is [1,3] and in this array there is no rotation. "
                    },
                    {
                        "username": "vaishali_p14",
                        "content": "In the question, it is mentioned that the passed array is sorted and POSSIBLY rotated.\\n\\n"
                    },
                    {
                        "username": "Yanlin0408",
                        "content": "[@lakshminathan](/lakshminathan) lmao"
                    },
                    {
                        "username": "lakshminathan",
                        "content": "it is rotated twice"
                    },
                    {
                        "username": "euphoria_kiki",
                        "content": "The key idea is during the process fo binary search, we compare the number at position mid and position left. If the number at mid is larger, it implies that range [left, mid] is ordered (not rotated), so we can decide whether to move towards that range for further search. Otherwise, the number at mid is smaller, which implies that range [mid, right] is ordered (not rotated)."
                    },
                    {
                        "username": "Spam_Musubi",
                        "content": "nice, I was wondering why this was on the medium side, they should\\'ve made something to make this harder and for us to naturally come up with the binary search.\\n"
                    },
                    {
                        "username": "insomniachou",
                        "content": "I don't think this problem is for JS. I saw someone's (n + logn) solution, was wondering why not just compare one by one, resulting in O(n). Not sure the question is asking the index in the sorted array or in the rotated array.  I tried js build-in array method, and surprisingly my answer passed and beats 60%.  \\n\\n\\tvar search = function(nums, target) {\\n\\t\\treturn nums.indexOf(target);\\n\\t};"
                    },
                    {
                        "username": "danielmascena",
                        "content": "doesnt matter the programming language but the approach used"
                    },
                    {
                        "username": "rohiinegi2002",
                        "content": "it will pass... Cause you are using a function that runs of O(logn) time complexity and is called Binary Search..(^ ^)"
                    },
                    {
                        "username": "normanlmfung",
                        "content": "Same in pyton: def search(self, nums: List[int], target: int) -> int:\\n        if target in nums:\\n            return nums.index(target)\\n        else:\\n            return -1"
                    },
                    {
                        "username": "ladiaz4e98",
                        "content": "this is wrong. this is o(n), question is asking for o(log(n)).."
                    },
                    {
                        "username": "thedevwonder",
                        "content": "JS solution in O(logn) works, my answer beats 90%. I think it is independent of programming lang as long as you don\\'t use built in functions"
                    },
                    {
                        "username": "mohaymenrafi",
                        "content": "[@christinehong](/christinehong) when you use indexOf method, in worse case, it actually traverse the entire array which is O(n) operation. but in the question it specifically mentioned to use O(log n)"
                    },
                    {
                        "username": "christinehong",
                        "content": "that was literally my line of logic and i ended up with the same solution but in python"
                    },
                    {
                        "username": "gurnainwadhwa",
                        "content": "Just Binary Search"
                    },
                    {
                        "username": "anwendeng",
                        "content": "This problem is solved by using binary search several times.\nFirstly, it is suggested to find the location for the peak which can be done by binary search. \nSecondly, using  binary search to find location for the target  which  is possible before the peak or after the peak.\n\n# Be careful for the boundary cases when n=1 and n=2."
                    }
                ]
            },
            {
                "id": 2016109,
                "content": [
                    {
                        "username": "DraculeMihawk",
                        "content": "The steps are as follows:\\n\\n1. Place the 2 pointers i.e. low and high: Initially, we will place the pointers like this: low will point to the first index, and high will point to the last index.\\n2. Calculate the \\u2018mid\\u2019: Now, inside a loop, we will calculate the value of \\u2018mid\\u2019 using the following formula:\\nmid = (low+high) // 2 ( \\u2018//\\u2019 refers to integer division)\\n3. Check if arr[mid] == target: If it is, return the index mid.\\n4. Identify the sorted half, check where the target is located, and then eliminate one half accordingly:\\n                   1. if arr[low] <= arr[mid]: This condition ensures that the left part is sorted.\\n                       a. If arr[low] <= target && target <= arr[mid]: It signifies that the target is in this sorted half. So, we will eliminate the right half (high = mid-1).\\n                       b. Otherwise, the target does not exist in the sorted half. So, we will eliminate this left half by doing low = mid+1.\\n                   2. Otherwise, if the right half is sorted:\\n                       a. If arr[mid] <= target && target <= arr[high]: It signifies that the target is in this sorted right half. So, we will eliminate the left half (low = mid+1).\\n                       b. Otherwise, the target does not exist in this sorted half. So, we will eliminate this right half by doing high = mid-1.\\n5. Once, the \\u2018mid\\u2019 points to the target, the index will be returned.\\n6. This process will be inside a loop and the loop will continue until low crosses high. If no index is found, we will return -1."
                    },
                    {
                        "username": "grovre",
                        "content": "Leetcode, the bringer of problems that don\\'t exist"
                    },
                    {
                        "username": "Zimzozaur",
                        "content": "True"
                    },
                    {
                        "username": "mandesi",
                        "content": "Here are the constraints -\\nConstraints:\\n\\n1 <= nums.length <= 5000\\n-10^4 <= nums[i] <= 10^4\\nAll values of nums are unique.\\nnums is guranteed to be rotated at some pivot.      <--- array is guranteed to be sorted\\n-10^4 <= target <= 10^4\\n\\nand with this this input -\\n\\n[1,3]  <-- array is sorted but not rotated\\n1  <-- target element\\n\\nthen how come expected output could be - 0th index, although element is present but array is not rotated.\\n\\nplease suggest if i am understanding the wrong way."
                    },
                    {
                        "username": "vaishali_p14",
                        "content": "In the question, it is mentioned that the passed array is sorted and POSSIBLY rotated.\\n"
                    },
                    {
                        "username": "vaishali_p14",
                        "content": "[@adamk90](/adamk90) No, pivot index cannot be 0. In the question, it is mentioned that pivot index k can be greater than equal to index 1 and less than equal to index n (n is size of the sorted array).  "
                    },
                    {
                        "username": "adamk90",
                        "content": "its rotated at 0th index ;)"
                    },
                    {
                        "username": "user2136ED",
                        "content": "If in constraints it is specified that \\n\"nums is guranteed to be rotated at some pivot\"\\nThen how is following input valid.\\n[1,2,3,4,5]\\n5"
                    },
                    {
                        "username": "vaishali_p14",
                        "content": "In the question, it is mentioned that the passed array is sorted and POSSIBLY rotated."
                    },
                    {
                        "username": "rzelnick",
                        "content": "For those who would like to have some idea without looking at any code..\\n\\n1. Find a \"pivot\" index where the ith element is greater than (i+1)th element\\n2. Perform a binary search from the beginning up to the pivot\\n3. Perform a binary search from the pivot up to the end\\n4. If found in any of the halves return the index otherwise return -1"
                    },
                    {
                        "username": "brbamcoding",
                        "content": "Instead of performing it on both halvaes, why not check within which boundaries target lies and perform binary search only on that half?"
                    },
                    {
                        "username": "Balerii",
                        "content": "such an annoing question "
                    },
                    {
                        "username": "Akhil169",
                        "content": "The constraints are stupid even O(n) solution will get accepted it should be somewhat like : 1<=nums.size()<=10^9\\nso that only O(log(n)) solutions get accepted"
                    },
                    {
                        "username": "Mister_CK",
                        "content": "agreed! yesterdays problems had the same issue. My O(n^2) solution from a long time ago beat 96% so I didn\\'t feel like improving it. Today I did it properly  in O(log(n)) and I only beat 30%..."
                    },
                    {
                        "username": "suren-yeager",
                        "content": "Whenever I solve this problem, I always get atleast 1-2 WA. Still a tricky one for me. "
                    },
                    {
                        "username": "Shubham_Raj22",
                        "content": "First do a binary Search to get the pivot.\\n\\nIf `nums[mid] > nums[high]` means the pivot lies between mid and high and vice versa. Use this logic in BS to get pivot index.\\n\\nAfter finding the pivot, check whether target lies left to the pivot or right. \\n\\nIf `nums[pivot] < target < nums[high`] means it lies on the right subarray part of the array.\\n\\nSo do a simple binary search on the right portion."
                    },
                    {
                        "username": "vansh_agarwal31",
                        "content": " class Solution {\\npublic:\\n    int search(vector<int>& nums, int target) {\\n\\n        int n =nums.size();\\n        int left = 0;\\n        int right = n-1;\\n        int mid;\\n\\n        while(left<=right)\\n        {\\n            mid = (left+right)/2;\\n            \\n            if(nums[mid]==target)\\n            return mid;\\n\\n            else if(nums[mid]>=nums[left])\\n            {\\n                if(target<=nums[mid] && target>=nums[left])\\n                right = mid-1;\\n                else\\n                left = mid+1;\\n            }\\n            else\\n            {\\n                if(target>=nums[mid]&& target<=nums[right])\\n                left = mid+1;\\n                else\\n                right = mid-1; \\n            }   \\n        }\\n        return -1;\\n    }\\n};\\n\\n// VERY EASY SOLUTION  C++ //\\n"
                    }
                ]
            },
            {
                "id": 2005097,
                "content": [
                    {
                        "username": "DraculeMihawk",
                        "content": "The steps are as follows:\\n\\n1. Place the 2 pointers i.e. low and high: Initially, we will place the pointers like this: low will point to the first index, and high will point to the last index.\\n2. Calculate the \\u2018mid\\u2019: Now, inside a loop, we will calculate the value of \\u2018mid\\u2019 using the following formula:\\nmid = (low+high) // 2 ( \\u2018//\\u2019 refers to integer division)\\n3. Check if arr[mid] == target: If it is, return the index mid.\\n4. Identify the sorted half, check where the target is located, and then eliminate one half accordingly:\\n                   1. if arr[low] <= arr[mid]: This condition ensures that the left part is sorted.\\n                       a. If arr[low] <= target && target <= arr[mid]: It signifies that the target is in this sorted half. So, we will eliminate the right half (high = mid-1).\\n                       b. Otherwise, the target does not exist in the sorted half. So, we will eliminate this left half by doing low = mid+1.\\n                   2. Otherwise, if the right half is sorted:\\n                       a. If arr[mid] <= target && target <= arr[high]: It signifies that the target is in this sorted right half. So, we will eliminate the left half (low = mid+1).\\n                       b. Otherwise, the target does not exist in this sorted half. So, we will eliminate this right half by doing high = mid-1.\\n5. Once, the \\u2018mid\\u2019 points to the target, the index will be returned.\\n6. This process will be inside a loop and the loop will continue until low crosses high. If no index is found, we will return -1."
                    },
                    {
                        "username": "grovre",
                        "content": "Leetcode, the bringer of problems that don\\'t exist"
                    },
                    {
                        "username": "Zimzozaur",
                        "content": "True"
                    },
                    {
                        "username": "mandesi",
                        "content": "Here are the constraints -\\nConstraints:\\n\\n1 <= nums.length <= 5000\\n-10^4 <= nums[i] <= 10^4\\nAll values of nums are unique.\\nnums is guranteed to be rotated at some pivot.      <--- array is guranteed to be sorted\\n-10^4 <= target <= 10^4\\n\\nand with this this input -\\n\\n[1,3]  <-- array is sorted but not rotated\\n1  <-- target element\\n\\nthen how come expected output could be - 0th index, although element is present but array is not rotated.\\n\\nplease suggest if i am understanding the wrong way."
                    },
                    {
                        "username": "vaishali_p14",
                        "content": "In the question, it is mentioned that the passed array is sorted and POSSIBLY rotated.\\n"
                    },
                    {
                        "username": "vaishali_p14",
                        "content": "[@adamk90](/adamk90) No, pivot index cannot be 0. In the question, it is mentioned that pivot index k can be greater than equal to index 1 and less than equal to index n (n is size of the sorted array).  "
                    },
                    {
                        "username": "adamk90",
                        "content": "its rotated at 0th index ;)"
                    },
                    {
                        "username": "user2136ED",
                        "content": "If in constraints it is specified that \\n\"nums is guranteed to be rotated at some pivot\"\\nThen how is following input valid.\\n[1,2,3,4,5]\\n5"
                    },
                    {
                        "username": "vaishali_p14",
                        "content": "In the question, it is mentioned that the passed array is sorted and POSSIBLY rotated."
                    },
                    {
                        "username": "rzelnick",
                        "content": "For those who would like to have some idea without looking at any code..\\n\\n1. Find a \"pivot\" index where the ith element is greater than (i+1)th element\\n2. Perform a binary search from the beginning up to the pivot\\n3. Perform a binary search from the pivot up to the end\\n4. If found in any of the halves return the index otherwise return -1"
                    },
                    {
                        "username": "brbamcoding",
                        "content": "Instead of performing it on both halvaes, why not check within which boundaries target lies and perform binary search only on that half?"
                    },
                    {
                        "username": "Balerii",
                        "content": "such an annoing question "
                    },
                    {
                        "username": "Akhil169",
                        "content": "The constraints are stupid even O(n) solution will get accepted it should be somewhat like : 1<=nums.size()<=10^9\\nso that only O(log(n)) solutions get accepted"
                    },
                    {
                        "username": "Mister_CK",
                        "content": "agreed! yesterdays problems had the same issue. My O(n^2) solution from a long time ago beat 96% so I didn\\'t feel like improving it. Today I did it properly  in O(log(n)) and I only beat 30%..."
                    },
                    {
                        "username": "suren-yeager",
                        "content": "Whenever I solve this problem, I always get atleast 1-2 WA. Still a tricky one for me. "
                    },
                    {
                        "username": "Shubham_Raj22",
                        "content": "First do a binary Search to get the pivot.\\n\\nIf `nums[mid] > nums[high]` means the pivot lies between mid and high and vice versa. Use this logic in BS to get pivot index.\\n\\nAfter finding the pivot, check whether target lies left to the pivot or right. \\n\\nIf `nums[pivot] < target < nums[high`] means it lies on the right subarray part of the array.\\n\\nSo do a simple binary search on the right portion."
                    },
                    {
                        "username": "vansh_agarwal31",
                        "content": " class Solution {\\npublic:\\n    int search(vector<int>& nums, int target) {\\n\\n        int n =nums.size();\\n        int left = 0;\\n        int right = n-1;\\n        int mid;\\n\\n        while(left<=right)\\n        {\\n            mid = (left+right)/2;\\n            \\n            if(nums[mid]==target)\\n            return mid;\\n\\n            else if(nums[mid]>=nums[left])\\n            {\\n                if(target<=nums[mid] && target>=nums[left])\\n                right = mid-1;\\n                else\\n                left = mid+1;\\n            }\\n            else\\n            {\\n                if(target>=nums[mid]&& target<=nums[right])\\n                left = mid+1;\\n                else\\n                right = mid-1; \\n            }   \\n        }\\n        return -1;\\n    }\\n};\\n\\n// VERY EASY SOLUTION  C++ //\\n"
                    }
                ]
            },
            {
                "id": 1568434,
                "content": [
                    {
                        "username": "DraculeMihawk",
                        "content": "The steps are as follows:\\n\\n1. Place the 2 pointers i.e. low and high: Initially, we will place the pointers like this: low will point to the first index, and high will point to the last index.\\n2. Calculate the \\u2018mid\\u2019: Now, inside a loop, we will calculate the value of \\u2018mid\\u2019 using the following formula:\\nmid = (low+high) // 2 ( \\u2018//\\u2019 refers to integer division)\\n3. Check if arr[mid] == target: If it is, return the index mid.\\n4. Identify the sorted half, check where the target is located, and then eliminate one half accordingly:\\n                   1. if arr[low] <= arr[mid]: This condition ensures that the left part is sorted.\\n                       a. If arr[low] <= target && target <= arr[mid]: It signifies that the target is in this sorted half. So, we will eliminate the right half (high = mid-1).\\n                       b. Otherwise, the target does not exist in the sorted half. So, we will eliminate this left half by doing low = mid+1.\\n                   2. Otherwise, if the right half is sorted:\\n                       a. If arr[mid] <= target && target <= arr[high]: It signifies that the target is in this sorted right half. So, we will eliminate the left half (low = mid+1).\\n                       b. Otherwise, the target does not exist in this sorted half. So, we will eliminate this right half by doing high = mid-1.\\n5. Once, the \\u2018mid\\u2019 points to the target, the index will be returned.\\n6. This process will be inside a loop and the loop will continue until low crosses high. If no index is found, we will return -1."
                    },
                    {
                        "username": "grovre",
                        "content": "Leetcode, the bringer of problems that don\\'t exist"
                    },
                    {
                        "username": "Zimzozaur",
                        "content": "True"
                    },
                    {
                        "username": "mandesi",
                        "content": "Here are the constraints -\\nConstraints:\\n\\n1 <= nums.length <= 5000\\n-10^4 <= nums[i] <= 10^4\\nAll values of nums are unique.\\nnums is guranteed to be rotated at some pivot.      <--- array is guranteed to be sorted\\n-10^4 <= target <= 10^4\\n\\nand with this this input -\\n\\n[1,3]  <-- array is sorted but not rotated\\n1  <-- target element\\n\\nthen how come expected output could be - 0th index, although element is present but array is not rotated.\\n\\nplease suggest if i am understanding the wrong way."
                    },
                    {
                        "username": "vaishali_p14",
                        "content": "In the question, it is mentioned that the passed array is sorted and POSSIBLY rotated.\\n"
                    },
                    {
                        "username": "vaishali_p14",
                        "content": "[@adamk90](/adamk90) No, pivot index cannot be 0. In the question, it is mentioned that pivot index k can be greater than equal to index 1 and less than equal to index n (n is size of the sorted array).  "
                    },
                    {
                        "username": "adamk90",
                        "content": "its rotated at 0th index ;)"
                    },
                    {
                        "username": "user2136ED",
                        "content": "If in constraints it is specified that \\n\"nums is guranteed to be rotated at some pivot\"\\nThen how is following input valid.\\n[1,2,3,4,5]\\n5"
                    },
                    {
                        "username": "vaishali_p14",
                        "content": "In the question, it is mentioned that the passed array is sorted and POSSIBLY rotated."
                    },
                    {
                        "username": "rzelnick",
                        "content": "For those who would like to have some idea without looking at any code..\\n\\n1. Find a \"pivot\" index where the ith element is greater than (i+1)th element\\n2. Perform a binary search from the beginning up to the pivot\\n3. Perform a binary search from the pivot up to the end\\n4. If found in any of the halves return the index otherwise return -1"
                    },
                    {
                        "username": "brbamcoding",
                        "content": "Instead of performing it on both halvaes, why not check within which boundaries target lies and perform binary search only on that half?"
                    },
                    {
                        "username": "Balerii",
                        "content": "such an annoing question "
                    },
                    {
                        "username": "Akhil169",
                        "content": "The constraints are stupid even O(n) solution will get accepted it should be somewhat like : 1<=nums.size()<=10^9\\nso that only O(log(n)) solutions get accepted"
                    },
                    {
                        "username": "Mister_CK",
                        "content": "agreed! yesterdays problems had the same issue. My O(n^2) solution from a long time ago beat 96% so I didn\\'t feel like improving it. Today I did it properly  in O(log(n)) and I only beat 30%..."
                    },
                    {
                        "username": "suren-yeager",
                        "content": "Whenever I solve this problem, I always get atleast 1-2 WA. Still a tricky one for me. "
                    },
                    {
                        "username": "Shubham_Raj22",
                        "content": "First do a binary Search to get the pivot.\\n\\nIf `nums[mid] > nums[high]` means the pivot lies between mid and high and vice versa. Use this logic in BS to get pivot index.\\n\\nAfter finding the pivot, check whether target lies left to the pivot or right. \\n\\nIf `nums[pivot] < target < nums[high`] means it lies on the right subarray part of the array.\\n\\nSo do a simple binary search on the right portion."
                    },
                    {
                        "username": "vansh_agarwal31",
                        "content": " class Solution {\\npublic:\\n    int search(vector<int>& nums, int target) {\\n\\n        int n =nums.size();\\n        int left = 0;\\n        int right = n-1;\\n        int mid;\\n\\n        while(left<=right)\\n        {\\n            mid = (left+right)/2;\\n            \\n            if(nums[mid]==target)\\n            return mid;\\n\\n            else if(nums[mid]>=nums[left])\\n            {\\n                if(target<=nums[mid] && target>=nums[left])\\n                right = mid-1;\\n                else\\n                left = mid+1;\\n            }\\n            else\\n            {\\n                if(target>=nums[mid]&& target<=nums[right])\\n                left = mid+1;\\n                else\\n                right = mid-1; \\n            }   \\n        }\\n        return -1;\\n    }\\n};\\n\\n// VERY EASY SOLUTION  C++ //\\n"
                    }
                ]
            },
            {
                "id": 1574236,
                "content": [
                    {
                        "username": "DraculeMihawk",
                        "content": "The steps are as follows:\\n\\n1. Place the 2 pointers i.e. low and high: Initially, we will place the pointers like this: low will point to the first index, and high will point to the last index.\\n2. Calculate the \\u2018mid\\u2019: Now, inside a loop, we will calculate the value of \\u2018mid\\u2019 using the following formula:\\nmid = (low+high) // 2 ( \\u2018//\\u2019 refers to integer division)\\n3. Check if arr[mid] == target: If it is, return the index mid.\\n4. Identify the sorted half, check where the target is located, and then eliminate one half accordingly:\\n                   1. if arr[low] <= arr[mid]: This condition ensures that the left part is sorted.\\n                       a. If arr[low] <= target && target <= arr[mid]: It signifies that the target is in this sorted half. So, we will eliminate the right half (high = mid-1).\\n                       b. Otherwise, the target does not exist in the sorted half. So, we will eliminate this left half by doing low = mid+1.\\n                   2. Otherwise, if the right half is sorted:\\n                       a. If arr[mid] <= target && target <= arr[high]: It signifies that the target is in this sorted right half. So, we will eliminate the left half (low = mid+1).\\n                       b. Otherwise, the target does not exist in this sorted half. So, we will eliminate this right half by doing high = mid-1.\\n5. Once, the \\u2018mid\\u2019 points to the target, the index will be returned.\\n6. This process will be inside a loop and the loop will continue until low crosses high. If no index is found, we will return -1."
                    },
                    {
                        "username": "grovre",
                        "content": "Leetcode, the bringer of problems that don\\'t exist"
                    },
                    {
                        "username": "Zimzozaur",
                        "content": "True"
                    },
                    {
                        "username": "mandesi",
                        "content": "Here are the constraints -\\nConstraints:\\n\\n1 <= nums.length <= 5000\\n-10^4 <= nums[i] <= 10^4\\nAll values of nums are unique.\\nnums is guranteed to be rotated at some pivot.      <--- array is guranteed to be sorted\\n-10^4 <= target <= 10^4\\n\\nand with this this input -\\n\\n[1,3]  <-- array is sorted but not rotated\\n1  <-- target element\\n\\nthen how come expected output could be - 0th index, although element is present but array is not rotated.\\n\\nplease suggest if i am understanding the wrong way."
                    },
                    {
                        "username": "vaishali_p14",
                        "content": "In the question, it is mentioned that the passed array is sorted and POSSIBLY rotated.\\n"
                    },
                    {
                        "username": "vaishali_p14",
                        "content": "[@adamk90](/adamk90) No, pivot index cannot be 0. In the question, it is mentioned that pivot index k can be greater than equal to index 1 and less than equal to index n (n is size of the sorted array).  "
                    },
                    {
                        "username": "adamk90",
                        "content": "its rotated at 0th index ;)"
                    },
                    {
                        "username": "user2136ED",
                        "content": "If in constraints it is specified that \\n\"nums is guranteed to be rotated at some pivot\"\\nThen how is following input valid.\\n[1,2,3,4,5]\\n5"
                    },
                    {
                        "username": "vaishali_p14",
                        "content": "In the question, it is mentioned that the passed array is sorted and POSSIBLY rotated."
                    },
                    {
                        "username": "rzelnick",
                        "content": "For those who would like to have some idea without looking at any code..\\n\\n1. Find a \"pivot\" index where the ith element is greater than (i+1)th element\\n2. Perform a binary search from the beginning up to the pivot\\n3. Perform a binary search from the pivot up to the end\\n4. If found in any of the halves return the index otherwise return -1"
                    },
                    {
                        "username": "brbamcoding",
                        "content": "Instead of performing it on both halvaes, why not check within which boundaries target lies and perform binary search only on that half?"
                    },
                    {
                        "username": "Balerii",
                        "content": "such an annoing question "
                    },
                    {
                        "username": "Akhil169",
                        "content": "The constraints are stupid even O(n) solution will get accepted it should be somewhat like : 1<=nums.size()<=10^9\\nso that only O(log(n)) solutions get accepted"
                    },
                    {
                        "username": "Mister_CK",
                        "content": "agreed! yesterdays problems had the same issue. My O(n^2) solution from a long time ago beat 96% so I didn\\'t feel like improving it. Today I did it properly  in O(log(n)) and I only beat 30%..."
                    },
                    {
                        "username": "suren-yeager",
                        "content": "Whenever I solve this problem, I always get atleast 1-2 WA. Still a tricky one for me. "
                    },
                    {
                        "username": "Shubham_Raj22",
                        "content": "First do a binary Search to get the pivot.\\n\\nIf `nums[mid] > nums[high]` means the pivot lies between mid and high and vice versa. Use this logic in BS to get pivot index.\\n\\nAfter finding the pivot, check whether target lies left to the pivot or right. \\n\\nIf `nums[pivot] < target < nums[high`] means it lies on the right subarray part of the array.\\n\\nSo do a simple binary search on the right portion."
                    },
                    {
                        "username": "vansh_agarwal31",
                        "content": " class Solution {\\npublic:\\n    int search(vector<int>& nums, int target) {\\n\\n        int n =nums.size();\\n        int left = 0;\\n        int right = n-1;\\n        int mid;\\n\\n        while(left<=right)\\n        {\\n            mid = (left+right)/2;\\n            \\n            if(nums[mid]==target)\\n            return mid;\\n\\n            else if(nums[mid]>=nums[left])\\n            {\\n                if(target<=nums[mid] && target>=nums[left])\\n                right = mid-1;\\n                else\\n                left = mid+1;\\n            }\\n            else\\n            {\\n                if(target>=nums[mid]&& target<=nums[right])\\n                left = mid+1;\\n                else\\n                right = mid-1; \\n            }   \\n        }\\n        return -1;\\n    }\\n};\\n\\n// VERY EASY SOLUTION  C++ //\\n"
                    }
                ]
            },
            {
                "id": 1572865,
                "content": [
                    {
                        "username": "DraculeMihawk",
                        "content": "The steps are as follows:\\n\\n1. Place the 2 pointers i.e. low and high: Initially, we will place the pointers like this: low will point to the first index, and high will point to the last index.\\n2. Calculate the \\u2018mid\\u2019: Now, inside a loop, we will calculate the value of \\u2018mid\\u2019 using the following formula:\\nmid = (low+high) // 2 ( \\u2018//\\u2019 refers to integer division)\\n3. Check if arr[mid] == target: If it is, return the index mid.\\n4. Identify the sorted half, check where the target is located, and then eliminate one half accordingly:\\n                   1. if arr[low] <= arr[mid]: This condition ensures that the left part is sorted.\\n                       a. If arr[low] <= target && target <= arr[mid]: It signifies that the target is in this sorted half. So, we will eliminate the right half (high = mid-1).\\n                       b. Otherwise, the target does not exist in the sorted half. So, we will eliminate this left half by doing low = mid+1.\\n                   2. Otherwise, if the right half is sorted:\\n                       a. If arr[mid] <= target && target <= arr[high]: It signifies that the target is in this sorted right half. So, we will eliminate the left half (low = mid+1).\\n                       b. Otherwise, the target does not exist in this sorted half. So, we will eliminate this right half by doing high = mid-1.\\n5. Once, the \\u2018mid\\u2019 points to the target, the index will be returned.\\n6. This process will be inside a loop and the loop will continue until low crosses high. If no index is found, we will return -1."
                    },
                    {
                        "username": "grovre",
                        "content": "Leetcode, the bringer of problems that don\\'t exist"
                    },
                    {
                        "username": "Zimzozaur",
                        "content": "True"
                    },
                    {
                        "username": "mandesi",
                        "content": "Here are the constraints -\\nConstraints:\\n\\n1 <= nums.length <= 5000\\n-10^4 <= nums[i] <= 10^4\\nAll values of nums are unique.\\nnums is guranteed to be rotated at some pivot.      <--- array is guranteed to be sorted\\n-10^4 <= target <= 10^4\\n\\nand with this this input -\\n\\n[1,3]  <-- array is sorted but not rotated\\n1  <-- target element\\n\\nthen how come expected output could be - 0th index, although element is present but array is not rotated.\\n\\nplease suggest if i am understanding the wrong way."
                    },
                    {
                        "username": "vaishali_p14",
                        "content": "In the question, it is mentioned that the passed array is sorted and POSSIBLY rotated.\\n"
                    },
                    {
                        "username": "vaishali_p14",
                        "content": "[@adamk90](/adamk90) No, pivot index cannot be 0. In the question, it is mentioned that pivot index k can be greater than equal to index 1 and less than equal to index n (n is size of the sorted array).  "
                    },
                    {
                        "username": "adamk90",
                        "content": "its rotated at 0th index ;)"
                    },
                    {
                        "username": "user2136ED",
                        "content": "If in constraints it is specified that \\n\"nums is guranteed to be rotated at some pivot\"\\nThen how is following input valid.\\n[1,2,3,4,5]\\n5"
                    },
                    {
                        "username": "vaishali_p14",
                        "content": "In the question, it is mentioned that the passed array is sorted and POSSIBLY rotated."
                    },
                    {
                        "username": "rzelnick",
                        "content": "For those who would like to have some idea without looking at any code..\\n\\n1. Find a \"pivot\" index where the ith element is greater than (i+1)th element\\n2. Perform a binary search from the beginning up to the pivot\\n3. Perform a binary search from the pivot up to the end\\n4. If found in any of the halves return the index otherwise return -1"
                    },
                    {
                        "username": "brbamcoding",
                        "content": "Instead of performing it on both halvaes, why not check within which boundaries target lies and perform binary search only on that half?"
                    },
                    {
                        "username": "Balerii",
                        "content": "such an annoing question "
                    },
                    {
                        "username": "Akhil169",
                        "content": "The constraints are stupid even O(n) solution will get accepted it should be somewhat like : 1<=nums.size()<=10^9\\nso that only O(log(n)) solutions get accepted"
                    },
                    {
                        "username": "Mister_CK",
                        "content": "agreed! yesterdays problems had the same issue. My O(n^2) solution from a long time ago beat 96% so I didn\\'t feel like improving it. Today I did it properly  in O(log(n)) and I only beat 30%..."
                    },
                    {
                        "username": "suren-yeager",
                        "content": "Whenever I solve this problem, I always get atleast 1-2 WA. Still a tricky one for me. "
                    },
                    {
                        "username": "Shubham_Raj22",
                        "content": "First do a binary Search to get the pivot.\\n\\nIf `nums[mid] > nums[high]` means the pivot lies between mid and high and vice versa. Use this logic in BS to get pivot index.\\n\\nAfter finding the pivot, check whether target lies left to the pivot or right. \\n\\nIf `nums[pivot] < target < nums[high`] means it lies on the right subarray part of the array.\\n\\nSo do a simple binary search on the right portion."
                    },
                    {
                        "username": "vansh_agarwal31",
                        "content": " class Solution {\\npublic:\\n    int search(vector<int>& nums, int target) {\\n\\n        int n =nums.size();\\n        int left = 0;\\n        int right = n-1;\\n        int mid;\\n\\n        while(left<=right)\\n        {\\n            mid = (left+right)/2;\\n            \\n            if(nums[mid]==target)\\n            return mid;\\n\\n            else if(nums[mid]>=nums[left])\\n            {\\n                if(target<=nums[mid] && target>=nums[left])\\n                right = mid-1;\\n                else\\n                left = mid+1;\\n            }\\n            else\\n            {\\n                if(target>=nums[mid]&& target<=nums[right])\\n                left = mid+1;\\n                else\\n                right = mid-1; \\n            }   \\n        }\\n        return -1;\\n    }\\n};\\n\\n// VERY EASY SOLUTION  C++ //\\n"
                    }
                ]
            },
            {
                "id": 2004937,
                "content": [
                    {
                        "username": "DraculeMihawk",
                        "content": "The steps are as follows:\\n\\n1. Place the 2 pointers i.e. low and high: Initially, we will place the pointers like this: low will point to the first index, and high will point to the last index.\\n2. Calculate the \\u2018mid\\u2019: Now, inside a loop, we will calculate the value of \\u2018mid\\u2019 using the following formula:\\nmid = (low+high) // 2 ( \\u2018//\\u2019 refers to integer division)\\n3. Check if arr[mid] == target: If it is, return the index mid.\\n4. Identify the sorted half, check where the target is located, and then eliminate one half accordingly:\\n                   1. if arr[low] <= arr[mid]: This condition ensures that the left part is sorted.\\n                       a. If arr[low] <= target && target <= arr[mid]: It signifies that the target is in this sorted half. So, we will eliminate the right half (high = mid-1).\\n                       b. Otherwise, the target does not exist in the sorted half. So, we will eliminate this left half by doing low = mid+1.\\n                   2. Otherwise, if the right half is sorted:\\n                       a. If arr[mid] <= target && target <= arr[high]: It signifies that the target is in this sorted right half. So, we will eliminate the left half (low = mid+1).\\n                       b. Otherwise, the target does not exist in this sorted half. So, we will eliminate this right half by doing high = mid-1.\\n5. Once, the \\u2018mid\\u2019 points to the target, the index will be returned.\\n6. This process will be inside a loop and the loop will continue until low crosses high. If no index is found, we will return -1."
                    },
                    {
                        "username": "grovre",
                        "content": "Leetcode, the bringer of problems that don\\'t exist"
                    },
                    {
                        "username": "Zimzozaur",
                        "content": "True"
                    },
                    {
                        "username": "mandesi",
                        "content": "Here are the constraints -\\nConstraints:\\n\\n1 <= nums.length <= 5000\\n-10^4 <= nums[i] <= 10^4\\nAll values of nums are unique.\\nnums is guranteed to be rotated at some pivot.      <--- array is guranteed to be sorted\\n-10^4 <= target <= 10^4\\n\\nand with this this input -\\n\\n[1,3]  <-- array is sorted but not rotated\\n1  <-- target element\\n\\nthen how come expected output could be - 0th index, although element is present but array is not rotated.\\n\\nplease suggest if i am understanding the wrong way."
                    },
                    {
                        "username": "vaishali_p14",
                        "content": "In the question, it is mentioned that the passed array is sorted and POSSIBLY rotated.\\n"
                    },
                    {
                        "username": "vaishali_p14",
                        "content": "[@adamk90](/adamk90) No, pivot index cannot be 0. In the question, it is mentioned that pivot index k can be greater than equal to index 1 and less than equal to index n (n is size of the sorted array).  "
                    },
                    {
                        "username": "adamk90",
                        "content": "its rotated at 0th index ;)"
                    },
                    {
                        "username": "user2136ED",
                        "content": "If in constraints it is specified that \\n\"nums is guranteed to be rotated at some pivot\"\\nThen how is following input valid.\\n[1,2,3,4,5]\\n5"
                    },
                    {
                        "username": "vaishali_p14",
                        "content": "In the question, it is mentioned that the passed array is sorted and POSSIBLY rotated."
                    },
                    {
                        "username": "rzelnick",
                        "content": "For those who would like to have some idea without looking at any code..\\n\\n1. Find a \"pivot\" index where the ith element is greater than (i+1)th element\\n2. Perform a binary search from the beginning up to the pivot\\n3. Perform a binary search from the pivot up to the end\\n4. If found in any of the halves return the index otherwise return -1"
                    },
                    {
                        "username": "brbamcoding",
                        "content": "Instead of performing it on both halvaes, why not check within which boundaries target lies and perform binary search only on that half?"
                    },
                    {
                        "username": "Balerii",
                        "content": "such an annoing question "
                    },
                    {
                        "username": "Akhil169",
                        "content": "The constraints are stupid even O(n) solution will get accepted it should be somewhat like : 1<=nums.size()<=10^9\\nso that only O(log(n)) solutions get accepted"
                    },
                    {
                        "username": "Mister_CK",
                        "content": "agreed! yesterdays problems had the same issue. My O(n^2) solution from a long time ago beat 96% so I didn\\'t feel like improving it. Today I did it properly  in O(log(n)) and I only beat 30%..."
                    },
                    {
                        "username": "suren-yeager",
                        "content": "Whenever I solve this problem, I always get atleast 1-2 WA. Still a tricky one for me. "
                    },
                    {
                        "username": "Shubham_Raj22",
                        "content": "First do a binary Search to get the pivot.\\n\\nIf `nums[mid] > nums[high]` means the pivot lies between mid and high and vice versa. Use this logic in BS to get pivot index.\\n\\nAfter finding the pivot, check whether target lies left to the pivot or right. \\n\\nIf `nums[pivot] < target < nums[high`] means it lies on the right subarray part of the array.\\n\\nSo do a simple binary search on the right portion."
                    },
                    {
                        "username": "vansh_agarwal31",
                        "content": " class Solution {\\npublic:\\n    int search(vector<int>& nums, int target) {\\n\\n        int n =nums.size();\\n        int left = 0;\\n        int right = n-1;\\n        int mid;\\n\\n        while(left<=right)\\n        {\\n            mid = (left+right)/2;\\n            \\n            if(nums[mid]==target)\\n            return mid;\\n\\n            else if(nums[mid]>=nums[left])\\n            {\\n                if(target<=nums[mid] && target>=nums[left])\\n                right = mid-1;\\n                else\\n                left = mid+1;\\n            }\\n            else\\n            {\\n                if(target>=nums[mid]&& target<=nums[right])\\n                left = mid+1;\\n                else\\n                right = mid-1; \\n            }   \\n        }\\n        return -1;\\n    }\\n};\\n\\n// VERY EASY SOLUTION  C++ //\\n"
                    }
                ]
            },
            {
                "id": 2005112,
                "content": [
                    {
                        "username": "DraculeMihawk",
                        "content": "The steps are as follows:\\n\\n1. Place the 2 pointers i.e. low and high: Initially, we will place the pointers like this: low will point to the first index, and high will point to the last index.\\n2. Calculate the \\u2018mid\\u2019: Now, inside a loop, we will calculate the value of \\u2018mid\\u2019 using the following formula:\\nmid = (low+high) // 2 ( \\u2018//\\u2019 refers to integer division)\\n3. Check if arr[mid] == target: If it is, return the index mid.\\n4. Identify the sorted half, check where the target is located, and then eliminate one half accordingly:\\n                   1. if arr[low] <= arr[mid]: This condition ensures that the left part is sorted.\\n                       a. If arr[low] <= target && target <= arr[mid]: It signifies that the target is in this sorted half. So, we will eliminate the right half (high = mid-1).\\n                       b. Otherwise, the target does not exist in the sorted half. So, we will eliminate this left half by doing low = mid+1.\\n                   2. Otherwise, if the right half is sorted:\\n                       a. If arr[mid] <= target && target <= arr[high]: It signifies that the target is in this sorted right half. So, we will eliminate the left half (low = mid+1).\\n                       b. Otherwise, the target does not exist in this sorted half. So, we will eliminate this right half by doing high = mid-1.\\n5. Once, the \\u2018mid\\u2019 points to the target, the index will be returned.\\n6. This process will be inside a loop and the loop will continue until low crosses high. If no index is found, we will return -1."
                    },
                    {
                        "username": "grovre",
                        "content": "Leetcode, the bringer of problems that don\\'t exist"
                    },
                    {
                        "username": "Zimzozaur",
                        "content": "True"
                    },
                    {
                        "username": "mandesi",
                        "content": "Here are the constraints -\\nConstraints:\\n\\n1 <= nums.length <= 5000\\n-10^4 <= nums[i] <= 10^4\\nAll values of nums are unique.\\nnums is guranteed to be rotated at some pivot.      <--- array is guranteed to be sorted\\n-10^4 <= target <= 10^4\\n\\nand with this this input -\\n\\n[1,3]  <-- array is sorted but not rotated\\n1  <-- target element\\n\\nthen how come expected output could be - 0th index, although element is present but array is not rotated.\\n\\nplease suggest if i am understanding the wrong way."
                    },
                    {
                        "username": "vaishali_p14",
                        "content": "In the question, it is mentioned that the passed array is sorted and POSSIBLY rotated.\\n"
                    },
                    {
                        "username": "vaishali_p14",
                        "content": "[@adamk90](/adamk90) No, pivot index cannot be 0. In the question, it is mentioned that pivot index k can be greater than equal to index 1 and less than equal to index n (n is size of the sorted array).  "
                    },
                    {
                        "username": "adamk90",
                        "content": "its rotated at 0th index ;)"
                    },
                    {
                        "username": "user2136ED",
                        "content": "If in constraints it is specified that \\n\"nums is guranteed to be rotated at some pivot\"\\nThen how is following input valid.\\n[1,2,3,4,5]\\n5"
                    },
                    {
                        "username": "vaishali_p14",
                        "content": "In the question, it is mentioned that the passed array is sorted and POSSIBLY rotated."
                    },
                    {
                        "username": "rzelnick",
                        "content": "For those who would like to have some idea without looking at any code..\\n\\n1. Find a \"pivot\" index where the ith element is greater than (i+1)th element\\n2. Perform a binary search from the beginning up to the pivot\\n3. Perform a binary search from the pivot up to the end\\n4. If found in any of the halves return the index otherwise return -1"
                    },
                    {
                        "username": "brbamcoding",
                        "content": "Instead of performing it on both halvaes, why not check within which boundaries target lies and perform binary search only on that half?"
                    },
                    {
                        "username": "Balerii",
                        "content": "such an annoing question "
                    },
                    {
                        "username": "Akhil169",
                        "content": "The constraints are stupid even O(n) solution will get accepted it should be somewhat like : 1<=nums.size()<=10^9\\nso that only O(log(n)) solutions get accepted"
                    },
                    {
                        "username": "Mister_CK",
                        "content": "agreed! yesterdays problems had the same issue. My O(n^2) solution from a long time ago beat 96% so I didn\\'t feel like improving it. Today I did it properly  in O(log(n)) and I only beat 30%..."
                    },
                    {
                        "username": "suren-yeager",
                        "content": "Whenever I solve this problem, I always get atleast 1-2 WA. Still a tricky one for me. "
                    },
                    {
                        "username": "Shubham_Raj22",
                        "content": "First do a binary Search to get the pivot.\\n\\nIf `nums[mid] > nums[high]` means the pivot lies between mid and high and vice versa. Use this logic in BS to get pivot index.\\n\\nAfter finding the pivot, check whether target lies left to the pivot or right. \\n\\nIf `nums[pivot] < target < nums[high`] means it lies on the right subarray part of the array.\\n\\nSo do a simple binary search on the right portion."
                    },
                    {
                        "username": "vansh_agarwal31",
                        "content": " class Solution {\\npublic:\\n    int search(vector<int>& nums, int target) {\\n\\n        int n =nums.size();\\n        int left = 0;\\n        int right = n-1;\\n        int mid;\\n\\n        while(left<=right)\\n        {\\n            mid = (left+right)/2;\\n            \\n            if(nums[mid]==target)\\n            return mid;\\n\\n            else if(nums[mid]>=nums[left])\\n            {\\n                if(target<=nums[mid] && target>=nums[left])\\n                right = mid-1;\\n                else\\n                left = mid+1;\\n            }\\n            else\\n            {\\n                if(target>=nums[mid]&& target<=nums[right])\\n                left = mid+1;\\n                else\\n                right = mid-1; \\n            }   \\n        }\\n        return -1;\\n    }\\n};\\n\\n// VERY EASY SOLUTION  C++ //\\n"
                    }
                ]
            },
            {
                "id": 2005067,
                "content": [
                    {
                        "username": "DraculeMihawk",
                        "content": "The steps are as follows:\\n\\n1. Place the 2 pointers i.e. low and high: Initially, we will place the pointers like this: low will point to the first index, and high will point to the last index.\\n2. Calculate the \\u2018mid\\u2019: Now, inside a loop, we will calculate the value of \\u2018mid\\u2019 using the following formula:\\nmid = (low+high) // 2 ( \\u2018//\\u2019 refers to integer division)\\n3. Check if arr[mid] == target: If it is, return the index mid.\\n4. Identify the sorted half, check where the target is located, and then eliminate one half accordingly:\\n                   1. if arr[low] <= arr[mid]: This condition ensures that the left part is sorted.\\n                       a. If arr[low] <= target && target <= arr[mid]: It signifies that the target is in this sorted half. So, we will eliminate the right half (high = mid-1).\\n                       b. Otherwise, the target does not exist in the sorted half. So, we will eliminate this left half by doing low = mid+1.\\n                   2. Otherwise, if the right half is sorted:\\n                       a. If arr[mid] <= target && target <= arr[high]: It signifies that the target is in this sorted right half. So, we will eliminate the left half (low = mid+1).\\n                       b. Otherwise, the target does not exist in this sorted half. So, we will eliminate this right half by doing high = mid-1.\\n5. Once, the \\u2018mid\\u2019 points to the target, the index will be returned.\\n6. This process will be inside a loop and the loop will continue until low crosses high. If no index is found, we will return -1."
                    },
                    {
                        "username": "grovre",
                        "content": "Leetcode, the bringer of problems that don\\'t exist"
                    },
                    {
                        "username": "Zimzozaur",
                        "content": "True"
                    },
                    {
                        "username": "mandesi",
                        "content": "Here are the constraints -\\nConstraints:\\n\\n1 <= nums.length <= 5000\\n-10^4 <= nums[i] <= 10^4\\nAll values of nums are unique.\\nnums is guranteed to be rotated at some pivot.      <--- array is guranteed to be sorted\\n-10^4 <= target <= 10^4\\n\\nand with this this input -\\n\\n[1,3]  <-- array is sorted but not rotated\\n1  <-- target element\\n\\nthen how come expected output could be - 0th index, although element is present but array is not rotated.\\n\\nplease suggest if i am understanding the wrong way."
                    },
                    {
                        "username": "vaishali_p14",
                        "content": "In the question, it is mentioned that the passed array is sorted and POSSIBLY rotated.\\n"
                    },
                    {
                        "username": "vaishali_p14",
                        "content": "[@adamk90](/adamk90) No, pivot index cannot be 0. In the question, it is mentioned that pivot index k can be greater than equal to index 1 and less than equal to index n (n is size of the sorted array).  "
                    },
                    {
                        "username": "adamk90",
                        "content": "its rotated at 0th index ;)"
                    },
                    {
                        "username": "user2136ED",
                        "content": "If in constraints it is specified that \\n\"nums is guranteed to be rotated at some pivot\"\\nThen how is following input valid.\\n[1,2,3,4,5]\\n5"
                    },
                    {
                        "username": "vaishali_p14",
                        "content": "In the question, it is mentioned that the passed array is sorted and POSSIBLY rotated."
                    },
                    {
                        "username": "rzelnick",
                        "content": "For those who would like to have some idea without looking at any code..\\n\\n1. Find a \"pivot\" index where the ith element is greater than (i+1)th element\\n2. Perform a binary search from the beginning up to the pivot\\n3. Perform a binary search from the pivot up to the end\\n4. If found in any of the halves return the index otherwise return -1"
                    },
                    {
                        "username": "brbamcoding",
                        "content": "Instead of performing it on both halvaes, why not check within which boundaries target lies and perform binary search only on that half?"
                    },
                    {
                        "username": "Balerii",
                        "content": "such an annoing question "
                    },
                    {
                        "username": "Akhil169",
                        "content": "The constraints are stupid even O(n) solution will get accepted it should be somewhat like : 1<=nums.size()<=10^9\\nso that only O(log(n)) solutions get accepted"
                    },
                    {
                        "username": "Mister_CK",
                        "content": "agreed! yesterdays problems had the same issue. My O(n^2) solution from a long time ago beat 96% so I didn\\'t feel like improving it. Today I did it properly  in O(log(n)) and I only beat 30%..."
                    },
                    {
                        "username": "suren-yeager",
                        "content": "Whenever I solve this problem, I always get atleast 1-2 WA. Still a tricky one for me. "
                    },
                    {
                        "username": "Shubham_Raj22",
                        "content": "First do a binary Search to get the pivot.\\n\\nIf `nums[mid] > nums[high]` means the pivot lies between mid and high and vice versa. Use this logic in BS to get pivot index.\\n\\nAfter finding the pivot, check whether target lies left to the pivot or right. \\n\\nIf `nums[pivot] < target < nums[high`] means it lies on the right subarray part of the array.\\n\\nSo do a simple binary search on the right portion."
                    },
                    {
                        "username": "vansh_agarwal31",
                        "content": " class Solution {\\npublic:\\n    int search(vector<int>& nums, int target) {\\n\\n        int n =nums.size();\\n        int left = 0;\\n        int right = n-1;\\n        int mid;\\n\\n        while(left<=right)\\n        {\\n            mid = (left+right)/2;\\n            \\n            if(nums[mid]==target)\\n            return mid;\\n\\n            else if(nums[mid]>=nums[left])\\n            {\\n                if(target<=nums[mid] && target>=nums[left])\\n                right = mid-1;\\n                else\\n                left = mid+1;\\n            }\\n            else\\n            {\\n                if(target>=nums[mid]&& target<=nums[right])\\n                left = mid+1;\\n                else\\n                right = mid-1; \\n            }   \\n        }\\n        return -1;\\n    }\\n};\\n\\n// VERY EASY SOLUTION  C++ //\\n"
                    }
                ]
            },
            {
                "id": 2004993,
                "content": [
                    {
                        "username": "DraculeMihawk",
                        "content": "The steps are as follows:\\n\\n1. Place the 2 pointers i.e. low and high: Initially, we will place the pointers like this: low will point to the first index, and high will point to the last index.\\n2. Calculate the \\u2018mid\\u2019: Now, inside a loop, we will calculate the value of \\u2018mid\\u2019 using the following formula:\\nmid = (low+high) // 2 ( \\u2018//\\u2019 refers to integer division)\\n3. Check if arr[mid] == target: If it is, return the index mid.\\n4. Identify the sorted half, check where the target is located, and then eliminate one half accordingly:\\n                   1. if arr[low] <= arr[mid]: This condition ensures that the left part is sorted.\\n                       a. If arr[low] <= target && target <= arr[mid]: It signifies that the target is in this sorted half. So, we will eliminate the right half (high = mid-1).\\n                       b. Otherwise, the target does not exist in the sorted half. So, we will eliminate this left half by doing low = mid+1.\\n                   2. Otherwise, if the right half is sorted:\\n                       a. If arr[mid] <= target && target <= arr[high]: It signifies that the target is in this sorted right half. So, we will eliminate the left half (low = mid+1).\\n                       b. Otherwise, the target does not exist in this sorted half. So, we will eliminate this right half by doing high = mid-1.\\n5. Once, the \\u2018mid\\u2019 points to the target, the index will be returned.\\n6. This process will be inside a loop and the loop will continue until low crosses high. If no index is found, we will return -1."
                    },
                    {
                        "username": "grovre",
                        "content": "Leetcode, the bringer of problems that don\\'t exist"
                    },
                    {
                        "username": "Zimzozaur",
                        "content": "True"
                    },
                    {
                        "username": "mandesi",
                        "content": "Here are the constraints -\\nConstraints:\\n\\n1 <= nums.length <= 5000\\n-10^4 <= nums[i] <= 10^4\\nAll values of nums are unique.\\nnums is guranteed to be rotated at some pivot.      <--- array is guranteed to be sorted\\n-10^4 <= target <= 10^4\\n\\nand with this this input -\\n\\n[1,3]  <-- array is sorted but not rotated\\n1  <-- target element\\n\\nthen how come expected output could be - 0th index, although element is present but array is not rotated.\\n\\nplease suggest if i am understanding the wrong way."
                    },
                    {
                        "username": "vaishali_p14",
                        "content": "In the question, it is mentioned that the passed array is sorted and POSSIBLY rotated.\\n"
                    },
                    {
                        "username": "vaishali_p14",
                        "content": "[@adamk90](/adamk90) No, pivot index cannot be 0. In the question, it is mentioned that pivot index k can be greater than equal to index 1 and less than equal to index n (n is size of the sorted array).  "
                    },
                    {
                        "username": "adamk90",
                        "content": "its rotated at 0th index ;)"
                    },
                    {
                        "username": "user2136ED",
                        "content": "If in constraints it is specified that \\n\"nums is guranteed to be rotated at some pivot\"\\nThen how is following input valid.\\n[1,2,3,4,5]\\n5"
                    },
                    {
                        "username": "vaishali_p14",
                        "content": "In the question, it is mentioned that the passed array is sorted and POSSIBLY rotated."
                    },
                    {
                        "username": "rzelnick",
                        "content": "For those who would like to have some idea without looking at any code..\\n\\n1. Find a \"pivot\" index where the ith element is greater than (i+1)th element\\n2. Perform a binary search from the beginning up to the pivot\\n3. Perform a binary search from the pivot up to the end\\n4. If found in any of the halves return the index otherwise return -1"
                    },
                    {
                        "username": "brbamcoding",
                        "content": "Instead of performing it on both halvaes, why not check within which boundaries target lies and perform binary search only on that half?"
                    },
                    {
                        "username": "Balerii",
                        "content": "such an annoing question "
                    },
                    {
                        "username": "Akhil169",
                        "content": "The constraints are stupid even O(n) solution will get accepted it should be somewhat like : 1<=nums.size()<=10^9\\nso that only O(log(n)) solutions get accepted"
                    },
                    {
                        "username": "Mister_CK",
                        "content": "agreed! yesterdays problems had the same issue. My O(n^2) solution from a long time ago beat 96% so I didn\\'t feel like improving it. Today I did it properly  in O(log(n)) and I only beat 30%..."
                    },
                    {
                        "username": "suren-yeager",
                        "content": "Whenever I solve this problem, I always get atleast 1-2 WA. Still a tricky one for me. "
                    },
                    {
                        "username": "Shubham_Raj22",
                        "content": "First do a binary Search to get the pivot.\\n\\nIf `nums[mid] > nums[high]` means the pivot lies between mid and high and vice versa. Use this logic in BS to get pivot index.\\n\\nAfter finding the pivot, check whether target lies left to the pivot or right. \\n\\nIf `nums[pivot] < target < nums[high`] means it lies on the right subarray part of the array.\\n\\nSo do a simple binary search on the right portion."
                    },
                    {
                        "username": "vansh_agarwal31",
                        "content": " class Solution {\\npublic:\\n    int search(vector<int>& nums, int target) {\\n\\n        int n =nums.size();\\n        int left = 0;\\n        int right = n-1;\\n        int mid;\\n\\n        while(left<=right)\\n        {\\n            mid = (left+right)/2;\\n            \\n            if(nums[mid]==target)\\n            return mid;\\n\\n            else if(nums[mid]>=nums[left])\\n            {\\n                if(target<=nums[mid] && target>=nums[left])\\n                right = mid-1;\\n                else\\n                left = mid+1;\\n            }\\n            else\\n            {\\n                if(target>=nums[mid]&& target<=nums[right])\\n                left = mid+1;\\n                else\\n                right = mid-1; \\n            }   \\n        }\\n        return -1;\\n    }\\n};\\n\\n// VERY EASY SOLUTION  C++ //\\n"
                    }
                ]
            },
            {
                "id": 1713453,
                "content": [
                    {
                        "username": "DraculeMihawk",
                        "content": "The steps are as follows:\\n\\n1. Place the 2 pointers i.e. low and high: Initially, we will place the pointers like this: low will point to the first index, and high will point to the last index.\\n2. Calculate the \\u2018mid\\u2019: Now, inside a loop, we will calculate the value of \\u2018mid\\u2019 using the following formula:\\nmid = (low+high) // 2 ( \\u2018//\\u2019 refers to integer division)\\n3. Check if arr[mid] == target: If it is, return the index mid.\\n4. Identify the sorted half, check where the target is located, and then eliminate one half accordingly:\\n                   1. if arr[low] <= arr[mid]: This condition ensures that the left part is sorted.\\n                       a. If arr[low] <= target && target <= arr[mid]: It signifies that the target is in this sorted half. So, we will eliminate the right half (high = mid-1).\\n                       b. Otherwise, the target does not exist in the sorted half. So, we will eliminate this left half by doing low = mid+1.\\n                   2. Otherwise, if the right half is sorted:\\n                       a. If arr[mid] <= target && target <= arr[high]: It signifies that the target is in this sorted right half. So, we will eliminate the left half (low = mid+1).\\n                       b. Otherwise, the target does not exist in this sorted half. So, we will eliminate this right half by doing high = mid-1.\\n5. Once, the \\u2018mid\\u2019 points to the target, the index will be returned.\\n6. This process will be inside a loop and the loop will continue until low crosses high. If no index is found, we will return -1."
                    },
                    {
                        "username": "grovre",
                        "content": "Leetcode, the bringer of problems that don\\'t exist"
                    },
                    {
                        "username": "Zimzozaur",
                        "content": "True"
                    },
                    {
                        "username": "mandesi",
                        "content": "Here are the constraints -\\nConstraints:\\n\\n1 <= nums.length <= 5000\\n-10^4 <= nums[i] <= 10^4\\nAll values of nums are unique.\\nnums is guranteed to be rotated at some pivot.      <--- array is guranteed to be sorted\\n-10^4 <= target <= 10^4\\n\\nand with this this input -\\n\\n[1,3]  <-- array is sorted but not rotated\\n1  <-- target element\\n\\nthen how come expected output could be - 0th index, although element is present but array is not rotated.\\n\\nplease suggest if i am understanding the wrong way."
                    },
                    {
                        "username": "vaishali_p14",
                        "content": "In the question, it is mentioned that the passed array is sorted and POSSIBLY rotated.\\n"
                    },
                    {
                        "username": "vaishali_p14",
                        "content": "[@adamk90](/adamk90) No, pivot index cannot be 0. In the question, it is mentioned that pivot index k can be greater than equal to index 1 and less than equal to index n (n is size of the sorted array).  "
                    },
                    {
                        "username": "adamk90",
                        "content": "its rotated at 0th index ;)"
                    },
                    {
                        "username": "user2136ED",
                        "content": "If in constraints it is specified that \\n\"nums is guranteed to be rotated at some pivot\"\\nThen how is following input valid.\\n[1,2,3,4,5]\\n5"
                    },
                    {
                        "username": "vaishali_p14",
                        "content": "In the question, it is mentioned that the passed array is sorted and POSSIBLY rotated."
                    },
                    {
                        "username": "rzelnick",
                        "content": "For those who would like to have some idea without looking at any code..\\n\\n1. Find a \"pivot\" index where the ith element is greater than (i+1)th element\\n2. Perform a binary search from the beginning up to the pivot\\n3. Perform a binary search from the pivot up to the end\\n4. If found in any of the halves return the index otherwise return -1"
                    },
                    {
                        "username": "brbamcoding",
                        "content": "Instead of performing it on both halvaes, why not check within which boundaries target lies and perform binary search only on that half?"
                    },
                    {
                        "username": "Balerii",
                        "content": "such an annoing question "
                    },
                    {
                        "username": "Akhil169",
                        "content": "The constraints are stupid even O(n) solution will get accepted it should be somewhat like : 1<=nums.size()<=10^9\\nso that only O(log(n)) solutions get accepted"
                    },
                    {
                        "username": "Mister_CK",
                        "content": "agreed! yesterdays problems had the same issue. My O(n^2) solution from a long time ago beat 96% so I didn\\'t feel like improving it. Today I did it properly  in O(log(n)) and I only beat 30%..."
                    },
                    {
                        "username": "suren-yeager",
                        "content": "Whenever I solve this problem, I always get atleast 1-2 WA. Still a tricky one for me. "
                    },
                    {
                        "username": "Shubham_Raj22",
                        "content": "First do a binary Search to get the pivot.\\n\\nIf `nums[mid] > nums[high]` means the pivot lies between mid and high and vice versa. Use this logic in BS to get pivot index.\\n\\nAfter finding the pivot, check whether target lies left to the pivot or right. \\n\\nIf `nums[pivot] < target < nums[high`] means it lies on the right subarray part of the array.\\n\\nSo do a simple binary search on the right portion."
                    },
                    {
                        "username": "vansh_agarwal31",
                        "content": " class Solution {\\npublic:\\n    int search(vector<int>& nums, int target) {\\n\\n        int n =nums.size();\\n        int left = 0;\\n        int right = n-1;\\n        int mid;\\n\\n        while(left<=right)\\n        {\\n            mid = (left+right)/2;\\n            \\n            if(nums[mid]==target)\\n            return mid;\\n\\n            else if(nums[mid]>=nums[left])\\n            {\\n                if(target<=nums[mid] && target>=nums[left])\\n                right = mid-1;\\n                else\\n                left = mid+1;\\n            }\\n            else\\n            {\\n                if(target>=nums[mid]&& target<=nums[right])\\n                left = mid+1;\\n                else\\n                right = mid-1; \\n            }   \\n        }\\n        return -1;\\n    }\\n};\\n\\n// VERY EASY SOLUTION  C++ //\\n"
                    }
                ]
            },
            {
                "id": 1575558,
                "content": [
                    {
                        "username": "Tim_P",
                        "content": "Does rotation pivot = 0 means that the array is not rotated?\\nIf resulting array is `[nums[k], nums[k+1], ..., nums[n-1], nums[0], nums[1], ..., nums[k-1]]`, so k=0 means that the rotated array is actually `[nums[0], nums[1], ..., nums[n-1]`, right?\\n\\n(So what does \"`nums` is guaranteed to be rotated at some pivot\" mean?)"
                    },
                    {
                        "username": "jonT5301",
                        "content": "One of the tests I failed was [1,3], 0. But [1,3] isn\\'t technically rotated, no?"
                    },
                    {
                        "username": "chmielecki7",
                        "content": "If I found the pivot in log n time then search the target on the left/right side of the pivot in log n time. Does it count as log n solution? :)"
                    },
                    {
                        "username": "dragon1105",
                        "content": "Yes, because in terms of Big O notation, 2 log n is still log n (omitting the coefficient)."
                    },
                    {
                        "username": "baba_sunilo",
                        "content": "yes"
                    },
                    {
                        "username": "lc7",
                        "content": "0 ms runtime achieved with C."
                    },
                    {
                        "username": "francolai",
                        "content": "Without finding the pivot, we know that:\\n1. if the number at the end of array is smaller than number at middle, the left side must be sorted.\\nExample: [3, 4, 5, 6, 7, 8, 9, 1, 2], 2 < 7, left side sorted.\\n2. if the number at the beginning of array is bigger than number at middle, the right side must be sorted.\\nExample: [8, 9, 1, 2, 3, 4, 5, 6, 7]  8>3, right side sorted.\\n3. if neither, the whole array is sorted.\\nExample: [1, 2, 3, 4, 5, 6, 7, 8, 9]\\n"
                    },
                    {
                        "username": "ALS_Venky",
                        "content": "welcome to binary search week"
                    },
                    {
                        "username": "harisshah753159",
                        "content": "Need Help! why it\\'s gives Runtime error on test case nums = [1] and target = 1.  \\nclass Solution {\\npublic:\\n    int search(vector<int>& nums, int target) {\\n        int n = nums.size() - 1;\\n        int s=0, e=n;\\n        while(s<e) {\\n            int mid = s + (e-s) / 2;\\n            if(nums[mid] > nums[e]) {\\n                s = mid + 1;\\n            }\\n            else {\\n                e = mid;\\n            }\\n        }\\n        int pivotIndex = s;\\n        s = 0 , e = n;\\n        if(target >= nums[s] && target <= nums[pivotIndex -1]) {\\n            e = pivotIndex - 1;\\n        }\\n        else {\\n            s = pivotIndex ;\\n        }\\n        int mid = s + (e-s) / 2;\\n        while (s<=e) {\\n            if(nums[mid] == target) {\\n                return mid;\\n            }\\n            else if(target > nums[mid]) {\\n                s = mid + 1;\\n            }\\n            else {\\n                e = mid - 1;\\n            }\\n            mid = s + (e-s) / 2;\\n        }\\n        return -1;\\n    }\\n};\\n"
                    },
                    {
                        "username": "bparanj",
                        "content": "Your code is giving a runtime error for an array of size 1 because of the line `if(target >= nums[s] && target <= nums[pivotIndex -1])`. In the case when `nums = [1]` and `target = 1`, `pivotIndex` is 0, and `nums[pivotIndex - 1]` refers to `nums[-1]`, which in C++ gives the last element of the array.\\n\\nHowever, as there is only one element in the array, `nums[-1]` is effectively `nums[0]`, and you\\'re checking if the target is both greater than and less than `nums[0]` at the same time, which is impossible, leading to your issue.\\n\\nInstead of checking the range in this way, you should handle the edge case where your array size is 1 before doing any other operations:\\n\\n```cpp\\nint search(vector<int>& nums, int target) {\\n    int n = nums.size();\\n    if (n == 1)\\n        return nums[0] == target ? 0 : -1;\\n    // Rest of your code...\\n}\\n```\\n\\nBy doing this, you effectively bypass the rest of your code and return the correct index immediately when the size of your array is 1."
                    },
                    {
                        "username": "user2194kq",
                        "content": "pivot index is 0 in the case [1] \\nand then you are trying to access nums[pivot_index-1]\\nwhich will lead to an runtime error"
                    },
                    {
                        "username": "KITSCODER",
                        "content": "class Solution {\\n    public int search(int[] nums, int target) {\\n        int n =-1;\\n        for(int i=0;i<nums.length;i++){\\n            if(nums[i]==target){\\n                n = i;\\n            }\\n        }\\n        return n;\\n    }\\n}"
                    },
                    {
                        "username": "dos_77",
                        "content": "We apply Binary search 3 times:\\n- once for determining pivot\\n- other 2 times for searching on left and right side of pivot\\n\\nTo determine pivot, we keep track of left most element in binary search:\\n- compare the mid element with left most element of the search\\n- if mid element > left element -> pivot exists in nums[m:r]\\n- else if mid element < left element -> pivot exists in nums[l:m]\\n- else we are right on the pivot element\\n\\nNext Apply simple Binary Search on Left and right side of pivot\\n\\nFor Code & Line-By-Line explanation:\\n[Click here](https://leetcode.com/problems/search-in-rotated-sorted-array/solutions/2809810/python3-simple-line-by-line-explanation-with-code/)"
                    },
                    {
                        "username": "adamk90",
                        "content": "you dont need to search on both sides of the pivot, if target is lesser than the first element of the array, it should be in the right side of the pivot (including the pivot)"
                    },
                    {
                        "username": "jshi005",
                        "content": "This problem does not say the numbers in the array have to be unique.\\n\\nSo maybe you want to try a test like:\\n\\nnums = [3,0,1,3,3,3,3]\\ntarget = 0"
                    },
                    {
                        "username": "psionl0",
                        "content": "``nums`` is an <b>ascending</b> array that is possibly rotated."
                    }
                ]
            },
            {
                "id": 1574543,
                "content": [
                    {
                        "username": "Tim_P",
                        "content": "Does rotation pivot = 0 means that the array is not rotated?\\nIf resulting array is `[nums[k], nums[k+1], ..., nums[n-1], nums[0], nums[1], ..., nums[k-1]]`, so k=0 means that the rotated array is actually `[nums[0], nums[1], ..., nums[n-1]`, right?\\n\\n(So what does \"`nums` is guaranteed to be rotated at some pivot\" mean?)"
                    },
                    {
                        "username": "jonT5301",
                        "content": "One of the tests I failed was [1,3], 0. But [1,3] isn\\'t technically rotated, no?"
                    },
                    {
                        "username": "chmielecki7",
                        "content": "If I found the pivot in log n time then search the target on the left/right side of the pivot in log n time. Does it count as log n solution? :)"
                    },
                    {
                        "username": "dragon1105",
                        "content": "Yes, because in terms of Big O notation, 2 log n is still log n (omitting the coefficient)."
                    },
                    {
                        "username": "baba_sunilo",
                        "content": "yes"
                    },
                    {
                        "username": "lc7",
                        "content": "0 ms runtime achieved with C."
                    },
                    {
                        "username": "francolai",
                        "content": "Without finding the pivot, we know that:\\n1. if the number at the end of array is smaller than number at middle, the left side must be sorted.\\nExample: [3, 4, 5, 6, 7, 8, 9, 1, 2], 2 < 7, left side sorted.\\n2. if the number at the beginning of array is bigger than number at middle, the right side must be sorted.\\nExample: [8, 9, 1, 2, 3, 4, 5, 6, 7]  8>3, right side sorted.\\n3. if neither, the whole array is sorted.\\nExample: [1, 2, 3, 4, 5, 6, 7, 8, 9]\\n"
                    },
                    {
                        "username": "ALS_Venky",
                        "content": "welcome to binary search week"
                    },
                    {
                        "username": "harisshah753159",
                        "content": "Need Help! why it\\'s gives Runtime error on test case nums = [1] and target = 1.  \\nclass Solution {\\npublic:\\n    int search(vector<int>& nums, int target) {\\n        int n = nums.size() - 1;\\n        int s=0, e=n;\\n        while(s<e) {\\n            int mid = s + (e-s) / 2;\\n            if(nums[mid] > nums[e]) {\\n                s = mid + 1;\\n            }\\n            else {\\n                e = mid;\\n            }\\n        }\\n        int pivotIndex = s;\\n        s = 0 , e = n;\\n        if(target >= nums[s] && target <= nums[pivotIndex -1]) {\\n            e = pivotIndex - 1;\\n        }\\n        else {\\n            s = pivotIndex ;\\n        }\\n        int mid = s + (e-s) / 2;\\n        while (s<=e) {\\n            if(nums[mid] == target) {\\n                return mid;\\n            }\\n            else if(target > nums[mid]) {\\n                s = mid + 1;\\n            }\\n            else {\\n                e = mid - 1;\\n            }\\n            mid = s + (e-s) / 2;\\n        }\\n        return -1;\\n    }\\n};\\n"
                    },
                    {
                        "username": "bparanj",
                        "content": "Your code is giving a runtime error for an array of size 1 because of the line `if(target >= nums[s] && target <= nums[pivotIndex -1])`. In the case when `nums = [1]` and `target = 1`, `pivotIndex` is 0, and `nums[pivotIndex - 1]` refers to `nums[-1]`, which in C++ gives the last element of the array.\\n\\nHowever, as there is only one element in the array, `nums[-1]` is effectively `nums[0]`, and you\\'re checking if the target is both greater than and less than `nums[0]` at the same time, which is impossible, leading to your issue.\\n\\nInstead of checking the range in this way, you should handle the edge case where your array size is 1 before doing any other operations:\\n\\n```cpp\\nint search(vector<int>& nums, int target) {\\n    int n = nums.size();\\n    if (n == 1)\\n        return nums[0] == target ? 0 : -1;\\n    // Rest of your code...\\n}\\n```\\n\\nBy doing this, you effectively bypass the rest of your code and return the correct index immediately when the size of your array is 1."
                    },
                    {
                        "username": "user2194kq",
                        "content": "pivot index is 0 in the case [1] \\nand then you are trying to access nums[pivot_index-1]\\nwhich will lead to an runtime error"
                    },
                    {
                        "username": "KITSCODER",
                        "content": "class Solution {\\n    public int search(int[] nums, int target) {\\n        int n =-1;\\n        for(int i=0;i<nums.length;i++){\\n            if(nums[i]==target){\\n                n = i;\\n            }\\n        }\\n        return n;\\n    }\\n}"
                    },
                    {
                        "username": "dos_77",
                        "content": "We apply Binary search 3 times:\\n- once for determining pivot\\n- other 2 times for searching on left and right side of pivot\\n\\nTo determine pivot, we keep track of left most element in binary search:\\n- compare the mid element with left most element of the search\\n- if mid element > left element -> pivot exists in nums[m:r]\\n- else if mid element < left element -> pivot exists in nums[l:m]\\n- else we are right on the pivot element\\n\\nNext Apply simple Binary Search on Left and right side of pivot\\n\\nFor Code & Line-By-Line explanation:\\n[Click here](https://leetcode.com/problems/search-in-rotated-sorted-array/solutions/2809810/python3-simple-line-by-line-explanation-with-code/)"
                    },
                    {
                        "username": "adamk90",
                        "content": "you dont need to search on both sides of the pivot, if target is lesser than the first element of the array, it should be in the right side of the pivot (including the pivot)"
                    },
                    {
                        "username": "jshi005",
                        "content": "This problem does not say the numbers in the array have to be unique.\\n\\nSo maybe you want to try a test like:\\n\\nnums = [3,0,1,3,3,3,3]\\ntarget = 0"
                    },
                    {
                        "username": "psionl0",
                        "content": "``nums`` is an <b>ascending</b> array that is possibly rotated."
                    }
                ]
            },
            {
                "id": 1573246,
                "content": [
                    {
                        "username": "Tim_P",
                        "content": "Does rotation pivot = 0 means that the array is not rotated?\\nIf resulting array is `[nums[k], nums[k+1], ..., nums[n-1], nums[0], nums[1], ..., nums[k-1]]`, so k=0 means that the rotated array is actually `[nums[0], nums[1], ..., nums[n-1]`, right?\\n\\n(So what does \"`nums` is guaranteed to be rotated at some pivot\" mean?)"
                    },
                    {
                        "username": "jonT5301",
                        "content": "One of the tests I failed was [1,3], 0. But [1,3] isn\\'t technically rotated, no?"
                    },
                    {
                        "username": "chmielecki7",
                        "content": "If I found the pivot in log n time then search the target on the left/right side of the pivot in log n time. Does it count as log n solution? :)"
                    },
                    {
                        "username": "dragon1105",
                        "content": "Yes, because in terms of Big O notation, 2 log n is still log n (omitting the coefficient)."
                    },
                    {
                        "username": "baba_sunilo",
                        "content": "yes"
                    },
                    {
                        "username": "lc7",
                        "content": "0 ms runtime achieved with C."
                    },
                    {
                        "username": "francolai",
                        "content": "Without finding the pivot, we know that:\\n1. if the number at the end of array is smaller than number at middle, the left side must be sorted.\\nExample: [3, 4, 5, 6, 7, 8, 9, 1, 2], 2 < 7, left side sorted.\\n2. if the number at the beginning of array is bigger than number at middle, the right side must be sorted.\\nExample: [8, 9, 1, 2, 3, 4, 5, 6, 7]  8>3, right side sorted.\\n3. if neither, the whole array is sorted.\\nExample: [1, 2, 3, 4, 5, 6, 7, 8, 9]\\n"
                    },
                    {
                        "username": "ALS_Venky",
                        "content": "welcome to binary search week"
                    },
                    {
                        "username": "harisshah753159",
                        "content": "Need Help! why it\\'s gives Runtime error on test case nums = [1] and target = 1.  \\nclass Solution {\\npublic:\\n    int search(vector<int>& nums, int target) {\\n        int n = nums.size() - 1;\\n        int s=0, e=n;\\n        while(s<e) {\\n            int mid = s + (e-s) / 2;\\n            if(nums[mid] > nums[e]) {\\n                s = mid + 1;\\n            }\\n            else {\\n                e = mid;\\n            }\\n        }\\n        int pivotIndex = s;\\n        s = 0 , e = n;\\n        if(target >= nums[s] && target <= nums[pivotIndex -1]) {\\n            e = pivotIndex - 1;\\n        }\\n        else {\\n            s = pivotIndex ;\\n        }\\n        int mid = s + (e-s) / 2;\\n        while (s<=e) {\\n            if(nums[mid] == target) {\\n                return mid;\\n            }\\n            else if(target > nums[mid]) {\\n                s = mid + 1;\\n            }\\n            else {\\n                e = mid - 1;\\n            }\\n            mid = s + (e-s) / 2;\\n        }\\n        return -1;\\n    }\\n};\\n"
                    },
                    {
                        "username": "bparanj",
                        "content": "Your code is giving a runtime error for an array of size 1 because of the line `if(target >= nums[s] && target <= nums[pivotIndex -1])`. In the case when `nums = [1]` and `target = 1`, `pivotIndex` is 0, and `nums[pivotIndex - 1]` refers to `nums[-1]`, which in C++ gives the last element of the array.\\n\\nHowever, as there is only one element in the array, `nums[-1]` is effectively `nums[0]`, and you\\'re checking if the target is both greater than and less than `nums[0]` at the same time, which is impossible, leading to your issue.\\n\\nInstead of checking the range in this way, you should handle the edge case where your array size is 1 before doing any other operations:\\n\\n```cpp\\nint search(vector<int>& nums, int target) {\\n    int n = nums.size();\\n    if (n == 1)\\n        return nums[0] == target ? 0 : -1;\\n    // Rest of your code...\\n}\\n```\\n\\nBy doing this, you effectively bypass the rest of your code and return the correct index immediately when the size of your array is 1."
                    },
                    {
                        "username": "user2194kq",
                        "content": "pivot index is 0 in the case [1] \\nand then you are trying to access nums[pivot_index-1]\\nwhich will lead to an runtime error"
                    },
                    {
                        "username": "KITSCODER",
                        "content": "class Solution {\\n    public int search(int[] nums, int target) {\\n        int n =-1;\\n        for(int i=0;i<nums.length;i++){\\n            if(nums[i]==target){\\n                n = i;\\n            }\\n        }\\n        return n;\\n    }\\n}"
                    },
                    {
                        "username": "dos_77",
                        "content": "We apply Binary search 3 times:\\n- once for determining pivot\\n- other 2 times for searching on left and right side of pivot\\n\\nTo determine pivot, we keep track of left most element in binary search:\\n- compare the mid element with left most element of the search\\n- if mid element > left element -> pivot exists in nums[m:r]\\n- else if mid element < left element -> pivot exists in nums[l:m]\\n- else we are right on the pivot element\\n\\nNext Apply simple Binary Search on Left and right side of pivot\\n\\nFor Code & Line-By-Line explanation:\\n[Click here](https://leetcode.com/problems/search-in-rotated-sorted-array/solutions/2809810/python3-simple-line-by-line-explanation-with-code/)"
                    },
                    {
                        "username": "adamk90",
                        "content": "you dont need to search on both sides of the pivot, if target is lesser than the first element of the array, it should be in the right side of the pivot (including the pivot)"
                    },
                    {
                        "username": "jshi005",
                        "content": "This problem does not say the numbers in the array have to be unique.\\n\\nSo maybe you want to try a test like:\\n\\nnums = [3,0,1,3,3,3,3]\\ntarget = 0"
                    },
                    {
                        "username": "psionl0",
                        "content": "``nums`` is an <b>ascending</b> array that is possibly rotated."
                    }
                ]
            },
            {
                "id": 2056610,
                "content": [
                    {
                        "username": "Tim_P",
                        "content": "Does rotation pivot = 0 means that the array is not rotated?\\nIf resulting array is `[nums[k], nums[k+1], ..., nums[n-1], nums[0], nums[1], ..., nums[k-1]]`, so k=0 means that the rotated array is actually `[nums[0], nums[1], ..., nums[n-1]`, right?\\n\\n(So what does \"`nums` is guaranteed to be rotated at some pivot\" mean?)"
                    },
                    {
                        "username": "jonT5301",
                        "content": "One of the tests I failed was [1,3], 0. But [1,3] isn\\'t technically rotated, no?"
                    },
                    {
                        "username": "chmielecki7",
                        "content": "If I found the pivot in log n time then search the target on the left/right side of the pivot in log n time. Does it count as log n solution? :)"
                    },
                    {
                        "username": "dragon1105",
                        "content": "Yes, because in terms of Big O notation, 2 log n is still log n (omitting the coefficient)."
                    },
                    {
                        "username": "baba_sunilo",
                        "content": "yes"
                    },
                    {
                        "username": "lc7",
                        "content": "0 ms runtime achieved with C."
                    },
                    {
                        "username": "francolai",
                        "content": "Without finding the pivot, we know that:\\n1. if the number at the end of array is smaller than number at middle, the left side must be sorted.\\nExample: [3, 4, 5, 6, 7, 8, 9, 1, 2], 2 < 7, left side sorted.\\n2. if the number at the beginning of array is bigger than number at middle, the right side must be sorted.\\nExample: [8, 9, 1, 2, 3, 4, 5, 6, 7]  8>3, right side sorted.\\n3. if neither, the whole array is sorted.\\nExample: [1, 2, 3, 4, 5, 6, 7, 8, 9]\\n"
                    },
                    {
                        "username": "ALS_Venky",
                        "content": "welcome to binary search week"
                    },
                    {
                        "username": "harisshah753159",
                        "content": "Need Help! why it\\'s gives Runtime error on test case nums = [1] and target = 1.  \\nclass Solution {\\npublic:\\n    int search(vector<int>& nums, int target) {\\n        int n = nums.size() - 1;\\n        int s=0, e=n;\\n        while(s<e) {\\n            int mid = s + (e-s) / 2;\\n            if(nums[mid] > nums[e]) {\\n                s = mid + 1;\\n            }\\n            else {\\n                e = mid;\\n            }\\n        }\\n        int pivotIndex = s;\\n        s = 0 , e = n;\\n        if(target >= nums[s] && target <= nums[pivotIndex -1]) {\\n            e = pivotIndex - 1;\\n        }\\n        else {\\n            s = pivotIndex ;\\n        }\\n        int mid = s + (e-s) / 2;\\n        while (s<=e) {\\n            if(nums[mid] == target) {\\n                return mid;\\n            }\\n            else if(target > nums[mid]) {\\n                s = mid + 1;\\n            }\\n            else {\\n                e = mid - 1;\\n            }\\n            mid = s + (e-s) / 2;\\n        }\\n        return -1;\\n    }\\n};\\n"
                    },
                    {
                        "username": "bparanj",
                        "content": "Your code is giving a runtime error for an array of size 1 because of the line `if(target >= nums[s] && target <= nums[pivotIndex -1])`. In the case when `nums = [1]` and `target = 1`, `pivotIndex` is 0, and `nums[pivotIndex - 1]` refers to `nums[-1]`, which in C++ gives the last element of the array.\\n\\nHowever, as there is only one element in the array, `nums[-1]` is effectively `nums[0]`, and you\\'re checking if the target is both greater than and less than `nums[0]` at the same time, which is impossible, leading to your issue.\\n\\nInstead of checking the range in this way, you should handle the edge case where your array size is 1 before doing any other operations:\\n\\n```cpp\\nint search(vector<int>& nums, int target) {\\n    int n = nums.size();\\n    if (n == 1)\\n        return nums[0] == target ? 0 : -1;\\n    // Rest of your code...\\n}\\n```\\n\\nBy doing this, you effectively bypass the rest of your code and return the correct index immediately when the size of your array is 1."
                    },
                    {
                        "username": "user2194kq",
                        "content": "pivot index is 0 in the case [1] \\nand then you are trying to access nums[pivot_index-1]\\nwhich will lead to an runtime error"
                    },
                    {
                        "username": "KITSCODER",
                        "content": "class Solution {\\n    public int search(int[] nums, int target) {\\n        int n =-1;\\n        for(int i=0;i<nums.length;i++){\\n            if(nums[i]==target){\\n                n = i;\\n            }\\n        }\\n        return n;\\n    }\\n}"
                    },
                    {
                        "username": "dos_77",
                        "content": "We apply Binary search 3 times:\\n- once for determining pivot\\n- other 2 times for searching on left and right side of pivot\\n\\nTo determine pivot, we keep track of left most element in binary search:\\n- compare the mid element with left most element of the search\\n- if mid element > left element -> pivot exists in nums[m:r]\\n- else if mid element < left element -> pivot exists in nums[l:m]\\n- else we are right on the pivot element\\n\\nNext Apply simple Binary Search on Left and right side of pivot\\n\\nFor Code & Line-By-Line explanation:\\n[Click here](https://leetcode.com/problems/search-in-rotated-sorted-array/solutions/2809810/python3-simple-line-by-line-explanation-with-code/)"
                    },
                    {
                        "username": "adamk90",
                        "content": "you dont need to search on both sides of the pivot, if target is lesser than the first element of the array, it should be in the right side of the pivot (including the pivot)"
                    },
                    {
                        "username": "jshi005",
                        "content": "This problem does not say the numbers in the array have to be unique.\\n\\nSo maybe you want to try a test like:\\n\\nnums = [3,0,1,3,3,3,3]\\ntarget = 0"
                    },
                    {
                        "username": "psionl0",
                        "content": "``nums`` is an <b>ascending</b> array that is possibly rotated."
                    }
                ]
            },
            {
                "id": 2005057,
                "content": [
                    {
                        "username": "Tim_P",
                        "content": "Does rotation pivot = 0 means that the array is not rotated?\\nIf resulting array is `[nums[k], nums[k+1], ..., nums[n-1], nums[0], nums[1], ..., nums[k-1]]`, so k=0 means that the rotated array is actually `[nums[0], nums[1], ..., nums[n-1]`, right?\\n\\n(So what does \"`nums` is guaranteed to be rotated at some pivot\" mean?)"
                    },
                    {
                        "username": "jonT5301",
                        "content": "One of the tests I failed was [1,3], 0. But [1,3] isn\\'t technically rotated, no?"
                    },
                    {
                        "username": "chmielecki7",
                        "content": "If I found the pivot in log n time then search the target on the left/right side of the pivot in log n time. Does it count as log n solution? :)"
                    },
                    {
                        "username": "dragon1105",
                        "content": "Yes, because in terms of Big O notation, 2 log n is still log n (omitting the coefficient)."
                    },
                    {
                        "username": "baba_sunilo",
                        "content": "yes"
                    },
                    {
                        "username": "lc7",
                        "content": "0 ms runtime achieved with C."
                    },
                    {
                        "username": "francolai",
                        "content": "Without finding the pivot, we know that:\\n1. if the number at the end of array is smaller than number at middle, the left side must be sorted.\\nExample: [3, 4, 5, 6, 7, 8, 9, 1, 2], 2 < 7, left side sorted.\\n2. if the number at the beginning of array is bigger than number at middle, the right side must be sorted.\\nExample: [8, 9, 1, 2, 3, 4, 5, 6, 7]  8>3, right side sorted.\\n3. if neither, the whole array is sorted.\\nExample: [1, 2, 3, 4, 5, 6, 7, 8, 9]\\n"
                    },
                    {
                        "username": "ALS_Venky",
                        "content": "welcome to binary search week"
                    },
                    {
                        "username": "harisshah753159",
                        "content": "Need Help! why it\\'s gives Runtime error on test case nums = [1] and target = 1.  \\nclass Solution {\\npublic:\\n    int search(vector<int>& nums, int target) {\\n        int n = nums.size() - 1;\\n        int s=0, e=n;\\n        while(s<e) {\\n            int mid = s + (e-s) / 2;\\n            if(nums[mid] > nums[e]) {\\n                s = mid + 1;\\n            }\\n            else {\\n                e = mid;\\n            }\\n        }\\n        int pivotIndex = s;\\n        s = 0 , e = n;\\n        if(target >= nums[s] && target <= nums[pivotIndex -1]) {\\n            e = pivotIndex - 1;\\n        }\\n        else {\\n            s = pivotIndex ;\\n        }\\n        int mid = s + (e-s) / 2;\\n        while (s<=e) {\\n            if(nums[mid] == target) {\\n                return mid;\\n            }\\n            else if(target > nums[mid]) {\\n                s = mid + 1;\\n            }\\n            else {\\n                e = mid - 1;\\n            }\\n            mid = s + (e-s) / 2;\\n        }\\n        return -1;\\n    }\\n};\\n"
                    },
                    {
                        "username": "bparanj",
                        "content": "Your code is giving a runtime error for an array of size 1 because of the line `if(target >= nums[s] && target <= nums[pivotIndex -1])`. In the case when `nums = [1]` and `target = 1`, `pivotIndex` is 0, and `nums[pivotIndex - 1]` refers to `nums[-1]`, which in C++ gives the last element of the array.\\n\\nHowever, as there is only one element in the array, `nums[-1]` is effectively `nums[0]`, and you\\'re checking if the target is both greater than and less than `nums[0]` at the same time, which is impossible, leading to your issue.\\n\\nInstead of checking the range in this way, you should handle the edge case where your array size is 1 before doing any other operations:\\n\\n```cpp\\nint search(vector<int>& nums, int target) {\\n    int n = nums.size();\\n    if (n == 1)\\n        return nums[0] == target ? 0 : -1;\\n    // Rest of your code...\\n}\\n```\\n\\nBy doing this, you effectively bypass the rest of your code and return the correct index immediately when the size of your array is 1."
                    },
                    {
                        "username": "user2194kq",
                        "content": "pivot index is 0 in the case [1] \\nand then you are trying to access nums[pivot_index-1]\\nwhich will lead to an runtime error"
                    },
                    {
                        "username": "KITSCODER",
                        "content": "class Solution {\\n    public int search(int[] nums, int target) {\\n        int n =-1;\\n        for(int i=0;i<nums.length;i++){\\n            if(nums[i]==target){\\n                n = i;\\n            }\\n        }\\n        return n;\\n    }\\n}"
                    },
                    {
                        "username": "dos_77",
                        "content": "We apply Binary search 3 times:\\n- once for determining pivot\\n- other 2 times for searching on left and right side of pivot\\n\\nTo determine pivot, we keep track of left most element in binary search:\\n- compare the mid element with left most element of the search\\n- if mid element > left element -> pivot exists in nums[m:r]\\n- else if mid element < left element -> pivot exists in nums[l:m]\\n- else we are right on the pivot element\\n\\nNext Apply simple Binary Search on Left and right side of pivot\\n\\nFor Code & Line-By-Line explanation:\\n[Click here](https://leetcode.com/problems/search-in-rotated-sorted-array/solutions/2809810/python3-simple-line-by-line-explanation-with-code/)"
                    },
                    {
                        "username": "adamk90",
                        "content": "you dont need to search on both sides of the pivot, if target is lesser than the first element of the array, it should be in the right side of the pivot (including the pivot)"
                    },
                    {
                        "username": "jshi005",
                        "content": "This problem does not say the numbers in the array have to be unique.\\n\\nSo maybe you want to try a test like:\\n\\nnums = [3,0,1,3,3,3,3]\\ntarget = 0"
                    },
                    {
                        "username": "psionl0",
                        "content": "``nums`` is an <b>ascending</b> array that is possibly rotated."
                    }
                ]
            },
            {
                "id": 2004959,
                "content": [
                    {
                        "username": "Tim_P",
                        "content": "Does rotation pivot = 0 means that the array is not rotated?\\nIf resulting array is `[nums[k], nums[k+1], ..., nums[n-1], nums[0], nums[1], ..., nums[k-1]]`, so k=0 means that the rotated array is actually `[nums[0], nums[1], ..., nums[n-1]`, right?\\n\\n(So what does \"`nums` is guaranteed to be rotated at some pivot\" mean?)"
                    },
                    {
                        "username": "jonT5301",
                        "content": "One of the tests I failed was [1,3], 0. But [1,3] isn\\'t technically rotated, no?"
                    },
                    {
                        "username": "chmielecki7",
                        "content": "If I found the pivot in log n time then search the target on the left/right side of the pivot in log n time. Does it count as log n solution? :)"
                    },
                    {
                        "username": "dragon1105",
                        "content": "Yes, because in terms of Big O notation, 2 log n is still log n (omitting the coefficient)."
                    },
                    {
                        "username": "baba_sunilo",
                        "content": "yes"
                    },
                    {
                        "username": "lc7",
                        "content": "0 ms runtime achieved with C."
                    },
                    {
                        "username": "francolai",
                        "content": "Without finding the pivot, we know that:\\n1. if the number at the end of array is smaller than number at middle, the left side must be sorted.\\nExample: [3, 4, 5, 6, 7, 8, 9, 1, 2], 2 < 7, left side sorted.\\n2. if the number at the beginning of array is bigger than number at middle, the right side must be sorted.\\nExample: [8, 9, 1, 2, 3, 4, 5, 6, 7]  8>3, right side sorted.\\n3. if neither, the whole array is sorted.\\nExample: [1, 2, 3, 4, 5, 6, 7, 8, 9]\\n"
                    },
                    {
                        "username": "ALS_Venky",
                        "content": "welcome to binary search week"
                    },
                    {
                        "username": "harisshah753159",
                        "content": "Need Help! why it\\'s gives Runtime error on test case nums = [1] and target = 1.  \\nclass Solution {\\npublic:\\n    int search(vector<int>& nums, int target) {\\n        int n = nums.size() - 1;\\n        int s=0, e=n;\\n        while(s<e) {\\n            int mid = s + (e-s) / 2;\\n            if(nums[mid] > nums[e]) {\\n                s = mid + 1;\\n            }\\n            else {\\n                e = mid;\\n            }\\n        }\\n        int pivotIndex = s;\\n        s = 0 , e = n;\\n        if(target >= nums[s] && target <= nums[pivotIndex -1]) {\\n            e = pivotIndex - 1;\\n        }\\n        else {\\n            s = pivotIndex ;\\n        }\\n        int mid = s + (e-s) / 2;\\n        while (s<=e) {\\n            if(nums[mid] == target) {\\n                return mid;\\n            }\\n            else if(target > nums[mid]) {\\n                s = mid + 1;\\n            }\\n            else {\\n                e = mid - 1;\\n            }\\n            mid = s + (e-s) / 2;\\n        }\\n        return -1;\\n    }\\n};\\n"
                    },
                    {
                        "username": "bparanj",
                        "content": "Your code is giving a runtime error for an array of size 1 because of the line `if(target >= nums[s] && target <= nums[pivotIndex -1])`. In the case when `nums = [1]` and `target = 1`, `pivotIndex` is 0, and `nums[pivotIndex - 1]` refers to `nums[-1]`, which in C++ gives the last element of the array.\\n\\nHowever, as there is only one element in the array, `nums[-1]` is effectively `nums[0]`, and you\\'re checking if the target is both greater than and less than `nums[0]` at the same time, which is impossible, leading to your issue.\\n\\nInstead of checking the range in this way, you should handle the edge case where your array size is 1 before doing any other operations:\\n\\n```cpp\\nint search(vector<int>& nums, int target) {\\n    int n = nums.size();\\n    if (n == 1)\\n        return nums[0] == target ? 0 : -1;\\n    // Rest of your code...\\n}\\n```\\n\\nBy doing this, you effectively bypass the rest of your code and return the correct index immediately when the size of your array is 1."
                    },
                    {
                        "username": "user2194kq",
                        "content": "pivot index is 0 in the case [1] \\nand then you are trying to access nums[pivot_index-1]\\nwhich will lead to an runtime error"
                    },
                    {
                        "username": "KITSCODER",
                        "content": "class Solution {\\n    public int search(int[] nums, int target) {\\n        int n =-1;\\n        for(int i=0;i<nums.length;i++){\\n            if(nums[i]==target){\\n                n = i;\\n            }\\n        }\\n        return n;\\n    }\\n}"
                    },
                    {
                        "username": "dos_77",
                        "content": "We apply Binary search 3 times:\\n- once for determining pivot\\n- other 2 times for searching on left and right side of pivot\\n\\nTo determine pivot, we keep track of left most element in binary search:\\n- compare the mid element with left most element of the search\\n- if mid element > left element -> pivot exists in nums[m:r]\\n- else if mid element < left element -> pivot exists in nums[l:m]\\n- else we are right on the pivot element\\n\\nNext Apply simple Binary Search on Left and right side of pivot\\n\\nFor Code & Line-By-Line explanation:\\n[Click here](https://leetcode.com/problems/search-in-rotated-sorted-array/solutions/2809810/python3-simple-line-by-line-explanation-with-code/)"
                    },
                    {
                        "username": "adamk90",
                        "content": "you dont need to search on both sides of the pivot, if target is lesser than the first element of the array, it should be in the right side of the pivot (including the pivot)"
                    },
                    {
                        "username": "jshi005",
                        "content": "This problem does not say the numbers in the array have to be unique.\\n\\nSo maybe you want to try a test like:\\n\\nnums = [3,0,1,3,3,3,3]\\ntarget = 0"
                    },
                    {
                        "username": "psionl0",
                        "content": "``nums`` is an <b>ascending</b> array that is possibly rotated."
                    }
                ]
            },
            {
                "id": 1882199,
                "content": [
                    {
                        "username": "Tim_P",
                        "content": "Does rotation pivot = 0 means that the array is not rotated?\\nIf resulting array is `[nums[k], nums[k+1], ..., nums[n-1], nums[0], nums[1], ..., nums[k-1]]`, so k=0 means that the rotated array is actually `[nums[0], nums[1], ..., nums[n-1]`, right?\\n\\n(So what does \"`nums` is guaranteed to be rotated at some pivot\" mean?)"
                    },
                    {
                        "username": "jonT5301",
                        "content": "One of the tests I failed was [1,3], 0. But [1,3] isn\\'t technically rotated, no?"
                    },
                    {
                        "username": "chmielecki7",
                        "content": "If I found the pivot in log n time then search the target on the left/right side of the pivot in log n time. Does it count as log n solution? :)"
                    },
                    {
                        "username": "dragon1105",
                        "content": "Yes, because in terms of Big O notation, 2 log n is still log n (omitting the coefficient)."
                    },
                    {
                        "username": "baba_sunilo",
                        "content": "yes"
                    },
                    {
                        "username": "lc7",
                        "content": "0 ms runtime achieved with C."
                    },
                    {
                        "username": "francolai",
                        "content": "Without finding the pivot, we know that:\\n1. if the number at the end of array is smaller than number at middle, the left side must be sorted.\\nExample: [3, 4, 5, 6, 7, 8, 9, 1, 2], 2 < 7, left side sorted.\\n2. if the number at the beginning of array is bigger than number at middle, the right side must be sorted.\\nExample: [8, 9, 1, 2, 3, 4, 5, 6, 7]  8>3, right side sorted.\\n3. if neither, the whole array is sorted.\\nExample: [1, 2, 3, 4, 5, 6, 7, 8, 9]\\n"
                    },
                    {
                        "username": "ALS_Venky",
                        "content": "welcome to binary search week"
                    },
                    {
                        "username": "harisshah753159",
                        "content": "Need Help! why it\\'s gives Runtime error on test case nums = [1] and target = 1.  \\nclass Solution {\\npublic:\\n    int search(vector<int>& nums, int target) {\\n        int n = nums.size() - 1;\\n        int s=0, e=n;\\n        while(s<e) {\\n            int mid = s + (e-s) / 2;\\n            if(nums[mid] > nums[e]) {\\n                s = mid + 1;\\n            }\\n            else {\\n                e = mid;\\n            }\\n        }\\n        int pivotIndex = s;\\n        s = 0 , e = n;\\n        if(target >= nums[s] && target <= nums[pivotIndex -1]) {\\n            e = pivotIndex - 1;\\n        }\\n        else {\\n            s = pivotIndex ;\\n        }\\n        int mid = s + (e-s) / 2;\\n        while (s<=e) {\\n            if(nums[mid] == target) {\\n                return mid;\\n            }\\n            else if(target > nums[mid]) {\\n                s = mid + 1;\\n            }\\n            else {\\n                e = mid - 1;\\n            }\\n            mid = s + (e-s) / 2;\\n        }\\n        return -1;\\n    }\\n};\\n"
                    },
                    {
                        "username": "bparanj",
                        "content": "Your code is giving a runtime error for an array of size 1 because of the line `if(target >= nums[s] && target <= nums[pivotIndex -1])`. In the case when `nums = [1]` and `target = 1`, `pivotIndex` is 0, and `nums[pivotIndex - 1]` refers to `nums[-1]`, which in C++ gives the last element of the array.\\n\\nHowever, as there is only one element in the array, `nums[-1]` is effectively `nums[0]`, and you\\'re checking if the target is both greater than and less than `nums[0]` at the same time, which is impossible, leading to your issue.\\n\\nInstead of checking the range in this way, you should handle the edge case where your array size is 1 before doing any other operations:\\n\\n```cpp\\nint search(vector<int>& nums, int target) {\\n    int n = nums.size();\\n    if (n == 1)\\n        return nums[0] == target ? 0 : -1;\\n    // Rest of your code...\\n}\\n```\\n\\nBy doing this, you effectively bypass the rest of your code and return the correct index immediately when the size of your array is 1."
                    },
                    {
                        "username": "user2194kq",
                        "content": "pivot index is 0 in the case [1] \\nand then you are trying to access nums[pivot_index-1]\\nwhich will lead to an runtime error"
                    },
                    {
                        "username": "KITSCODER",
                        "content": "class Solution {\\n    public int search(int[] nums, int target) {\\n        int n =-1;\\n        for(int i=0;i<nums.length;i++){\\n            if(nums[i]==target){\\n                n = i;\\n            }\\n        }\\n        return n;\\n    }\\n}"
                    },
                    {
                        "username": "dos_77",
                        "content": "We apply Binary search 3 times:\\n- once for determining pivot\\n- other 2 times for searching on left and right side of pivot\\n\\nTo determine pivot, we keep track of left most element in binary search:\\n- compare the mid element with left most element of the search\\n- if mid element > left element -> pivot exists in nums[m:r]\\n- else if mid element < left element -> pivot exists in nums[l:m]\\n- else we are right on the pivot element\\n\\nNext Apply simple Binary Search on Left and right side of pivot\\n\\nFor Code & Line-By-Line explanation:\\n[Click here](https://leetcode.com/problems/search-in-rotated-sorted-array/solutions/2809810/python3-simple-line-by-line-explanation-with-code/)"
                    },
                    {
                        "username": "adamk90",
                        "content": "you dont need to search on both sides of the pivot, if target is lesser than the first element of the array, it should be in the right side of the pivot (including the pivot)"
                    },
                    {
                        "username": "jshi005",
                        "content": "This problem does not say the numbers in the array have to be unique.\\n\\nSo maybe you want to try a test like:\\n\\nnums = [3,0,1,3,3,3,3]\\ntarget = 0"
                    },
                    {
                        "username": "psionl0",
                        "content": "``nums`` is an <b>ascending</b> array that is possibly rotated."
                    }
                ]
            },
            {
                "id": 1797653,
                "content": [
                    {
                        "username": "Tim_P",
                        "content": "Does rotation pivot = 0 means that the array is not rotated?\\nIf resulting array is `[nums[k], nums[k+1], ..., nums[n-1], nums[0], nums[1], ..., nums[k-1]]`, so k=0 means that the rotated array is actually `[nums[0], nums[1], ..., nums[n-1]`, right?\\n\\n(So what does \"`nums` is guaranteed to be rotated at some pivot\" mean?)"
                    },
                    {
                        "username": "jonT5301",
                        "content": "One of the tests I failed was [1,3], 0. But [1,3] isn\\'t technically rotated, no?"
                    },
                    {
                        "username": "chmielecki7",
                        "content": "If I found the pivot in log n time then search the target on the left/right side of the pivot in log n time. Does it count as log n solution? :)"
                    },
                    {
                        "username": "dragon1105",
                        "content": "Yes, because in terms of Big O notation, 2 log n is still log n (omitting the coefficient)."
                    },
                    {
                        "username": "baba_sunilo",
                        "content": "yes"
                    },
                    {
                        "username": "lc7",
                        "content": "0 ms runtime achieved with C."
                    },
                    {
                        "username": "francolai",
                        "content": "Without finding the pivot, we know that:\\n1. if the number at the end of array is smaller than number at middle, the left side must be sorted.\\nExample: [3, 4, 5, 6, 7, 8, 9, 1, 2], 2 < 7, left side sorted.\\n2. if the number at the beginning of array is bigger than number at middle, the right side must be sorted.\\nExample: [8, 9, 1, 2, 3, 4, 5, 6, 7]  8>3, right side sorted.\\n3. if neither, the whole array is sorted.\\nExample: [1, 2, 3, 4, 5, 6, 7, 8, 9]\\n"
                    },
                    {
                        "username": "ALS_Venky",
                        "content": "welcome to binary search week"
                    },
                    {
                        "username": "harisshah753159",
                        "content": "Need Help! why it\\'s gives Runtime error on test case nums = [1] and target = 1.  \\nclass Solution {\\npublic:\\n    int search(vector<int>& nums, int target) {\\n        int n = nums.size() - 1;\\n        int s=0, e=n;\\n        while(s<e) {\\n            int mid = s + (e-s) / 2;\\n            if(nums[mid] > nums[e]) {\\n                s = mid + 1;\\n            }\\n            else {\\n                e = mid;\\n            }\\n        }\\n        int pivotIndex = s;\\n        s = 0 , e = n;\\n        if(target >= nums[s] && target <= nums[pivotIndex -1]) {\\n            e = pivotIndex - 1;\\n        }\\n        else {\\n            s = pivotIndex ;\\n        }\\n        int mid = s + (e-s) / 2;\\n        while (s<=e) {\\n            if(nums[mid] == target) {\\n                return mid;\\n            }\\n            else if(target > nums[mid]) {\\n                s = mid + 1;\\n            }\\n            else {\\n                e = mid - 1;\\n            }\\n            mid = s + (e-s) / 2;\\n        }\\n        return -1;\\n    }\\n};\\n"
                    },
                    {
                        "username": "bparanj",
                        "content": "Your code is giving a runtime error for an array of size 1 because of the line `if(target >= nums[s] && target <= nums[pivotIndex -1])`. In the case when `nums = [1]` and `target = 1`, `pivotIndex` is 0, and `nums[pivotIndex - 1]` refers to `nums[-1]`, which in C++ gives the last element of the array.\\n\\nHowever, as there is only one element in the array, `nums[-1]` is effectively `nums[0]`, and you\\'re checking if the target is both greater than and less than `nums[0]` at the same time, which is impossible, leading to your issue.\\n\\nInstead of checking the range in this way, you should handle the edge case where your array size is 1 before doing any other operations:\\n\\n```cpp\\nint search(vector<int>& nums, int target) {\\n    int n = nums.size();\\n    if (n == 1)\\n        return nums[0] == target ? 0 : -1;\\n    // Rest of your code...\\n}\\n```\\n\\nBy doing this, you effectively bypass the rest of your code and return the correct index immediately when the size of your array is 1."
                    },
                    {
                        "username": "user2194kq",
                        "content": "pivot index is 0 in the case [1] \\nand then you are trying to access nums[pivot_index-1]\\nwhich will lead to an runtime error"
                    },
                    {
                        "username": "KITSCODER",
                        "content": "class Solution {\\n    public int search(int[] nums, int target) {\\n        int n =-1;\\n        for(int i=0;i<nums.length;i++){\\n            if(nums[i]==target){\\n                n = i;\\n            }\\n        }\\n        return n;\\n    }\\n}"
                    },
                    {
                        "username": "dos_77",
                        "content": "We apply Binary search 3 times:\\n- once for determining pivot\\n- other 2 times for searching on left and right side of pivot\\n\\nTo determine pivot, we keep track of left most element in binary search:\\n- compare the mid element with left most element of the search\\n- if mid element > left element -> pivot exists in nums[m:r]\\n- else if mid element < left element -> pivot exists in nums[l:m]\\n- else we are right on the pivot element\\n\\nNext Apply simple Binary Search on Left and right side of pivot\\n\\nFor Code & Line-By-Line explanation:\\n[Click here](https://leetcode.com/problems/search-in-rotated-sorted-array/solutions/2809810/python3-simple-line-by-line-explanation-with-code/)"
                    },
                    {
                        "username": "adamk90",
                        "content": "you dont need to search on both sides of the pivot, if target is lesser than the first element of the array, it should be in the right side of the pivot (including the pivot)"
                    },
                    {
                        "username": "jshi005",
                        "content": "This problem does not say the numbers in the array have to be unique.\\n\\nSo maybe you want to try a test like:\\n\\nnums = [3,0,1,3,3,3,3]\\ntarget = 0"
                    },
                    {
                        "username": "psionl0",
                        "content": "``nums`` is an <b>ascending</b> array that is possibly rotated."
                    }
                ]
            },
            {
                "id": 1682346,
                "content": [
                    {
                        "username": "Tim_P",
                        "content": "Does rotation pivot = 0 means that the array is not rotated?\\nIf resulting array is `[nums[k], nums[k+1], ..., nums[n-1], nums[0], nums[1], ..., nums[k-1]]`, so k=0 means that the rotated array is actually `[nums[0], nums[1], ..., nums[n-1]`, right?\\n\\n(So what does \"`nums` is guaranteed to be rotated at some pivot\" mean?)"
                    },
                    {
                        "username": "jonT5301",
                        "content": "One of the tests I failed was [1,3], 0. But [1,3] isn\\'t technically rotated, no?"
                    },
                    {
                        "username": "chmielecki7",
                        "content": "If I found the pivot in log n time then search the target on the left/right side of the pivot in log n time. Does it count as log n solution? :)"
                    },
                    {
                        "username": "dragon1105",
                        "content": "Yes, because in terms of Big O notation, 2 log n is still log n (omitting the coefficient)."
                    },
                    {
                        "username": "baba_sunilo",
                        "content": "yes"
                    },
                    {
                        "username": "lc7",
                        "content": "0 ms runtime achieved with C."
                    },
                    {
                        "username": "francolai",
                        "content": "Without finding the pivot, we know that:\\n1. if the number at the end of array is smaller than number at middle, the left side must be sorted.\\nExample: [3, 4, 5, 6, 7, 8, 9, 1, 2], 2 < 7, left side sorted.\\n2. if the number at the beginning of array is bigger than number at middle, the right side must be sorted.\\nExample: [8, 9, 1, 2, 3, 4, 5, 6, 7]  8>3, right side sorted.\\n3. if neither, the whole array is sorted.\\nExample: [1, 2, 3, 4, 5, 6, 7, 8, 9]\\n"
                    },
                    {
                        "username": "ALS_Venky",
                        "content": "welcome to binary search week"
                    },
                    {
                        "username": "harisshah753159",
                        "content": "Need Help! why it\\'s gives Runtime error on test case nums = [1] and target = 1.  \\nclass Solution {\\npublic:\\n    int search(vector<int>& nums, int target) {\\n        int n = nums.size() - 1;\\n        int s=0, e=n;\\n        while(s<e) {\\n            int mid = s + (e-s) / 2;\\n            if(nums[mid] > nums[e]) {\\n                s = mid + 1;\\n            }\\n            else {\\n                e = mid;\\n            }\\n        }\\n        int pivotIndex = s;\\n        s = 0 , e = n;\\n        if(target >= nums[s] && target <= nums[pivotIndex -1]) {\\n            e = pivotIndex - 1;\\n        }\\n        else {\\n            s = pivotIndex ;\\n        }\\n        int mid = s + (e-s) / 2;\\n        while (s<=e) {\\n            if(nums[mid] == target) {\\n                return mid;\\n            }\\n            else if(target > nums[mid]) {\\n                s = mid + 1;\\n            }\\n            else {\\n                e = mid - 1;\\n            }\\n            mid = s + (e-s) / 2;\\n        }\\n        return -1;\\n    }\\n};\\n"
                    },
                    {
                        "username": "bparanj",
                        "content": "Your code is giving a runtime error for an array of size 1 because of the line `if(target >= nums[s] && target <= nums[pivotIndex -1])`. In the case when `nums = [1]` and `target = 1`, `pivotIndex` is 0, and `nums[pivotIndex - 1]` refers to `nums[-1]`, which in C++ gives the last element of the array.\\n\\nHowever, as there is only one element in the array, `nums[-1]` is effectively `nums[0]`, and you\\'re checking if the target is both greater than and less than `nums[0]` at the same time, which is impossible, leading to your issue.\\n\\nInstead of checking the range in this way, you should handle the edge case where your array size is 1 before doing any other operations:\\n\\n```cpp\\nint search(vector<int>& nums, int target) {\\n    int n = nums.size();\\n    if (n == 1)\\n        return nums[0] == target ? 0 : -1;\\n    // Rest of your code...\\n}\\n```\\n\\nBy doing this, you effectively bypass the rest of your code and return the correct index immediately when the size of your array is 1."
                    },
                    {
                        "username": "user2194kq",
                        "content": "pivot index is 0 in the case [1] \\nand then you are trying to access nums[pivot_index-1]\\nwhich will lead to an runtime error"
                    },
                    {
                        "username": "KITSCODER",
                        "content": "class Solution {\\n    public int search(int[] nums, int target) {\\n        int n =-1;\\n        for(int i=0;i<nums.length;i++){\\n            if(nums[i]==target){\\n                n = i;\\n            }\\n        }\\n        return n;\\n    }\\n}"
                    },
                    {
                        "username": "dos_77",
                        "content": "We apply Binary search 3 times:\\n- once for determining pivot\\n- other 2 times for searching on left and right side of pivot\\n\\nTo determine pivot, we keep track of left most element in binary search:\\n- compare the mid element with left most element of the search\\n- if mid element > left element -> pivot exists in nums[m:r]\\n- else if mid element < left element -> pivot exists in nums[l:m]\\n- else we are right on the pivot element\\n\\nNext Apply simple Binary Search on Left and right side of pivot\\n\\nFor Code & Line-By-Line explanation:\\n[Click here](https://leetcode.com/problems/search-in-rotated-sorted-array/solutions/2809810/python3-simple-line-by-line-explanation-with-code/)"
                    },
                    {
                        "username": "adamk90",
                        "content": "you dont need to search on both sides of the pivot, if target is lesser than the first element of the array, it should be in the right side of the pivot (including the pivot)"
                    },
                    {
                        "username": "jshi005",
                        "content": "This problem does not say the numbers in the array have to be unique.\\n\\nSo maybe you want to try a test like:\\n\\nnums = [3,0,1,3,3,3,3]\\ntarget = 0"
                    },
                    {
                        "username": "psionl0",
                        "content": "``nums`` is an <b>ascending</b> array that is possibly rotated."
                    }
                ]
            },
            {
                "id": 1574648,
                "content": [
                    {
                        "username": "Tim_P",
                        "content": "Does rotation pivot = 0 means that the array is not rotated?\\nIf resulting array is `[nums[k], nums[k+1], ..., nums[n-1], nums[0], nums[1], ..., nums[k-1]]`, so k=0 means that the rotated array is actually `[nums[0], nums[1], ..., nums[n-1]`, right?\\n\\n(So what does \"`nums` is guaranteed to be rotated at some pivot\" mean?)"
                    },
                    {
                        "username": "jonT5301",
                        "content": "One of the tests I failed was [1,3], 0. But [1,3] isn\\'t technically rotated, no?"
                    },
                    {
                        "username": "chmielecki7",
                        "content": "If I found the pivot in log n time then search the target on the left/right side of the pivot in log n time. Does it count as log n solution? :)"
                    },
                    {
                        "username": "dragon1105",
                        "content": "Yes, because in terms of Big O notation, 2 log n is still log n (omitting the coefficient)."
                    },
                    {
                        "username": "baba_sunilo",
                        "content": "yes"
                    },
                    {
                        "username": "lc7",
                        "content": "0 ms runtime achieved with C."
                    },
                    {
                        "username": "francolai",
                        "content": "Without finding the pivot, we know that:\\n1. if the number at the end of array is smaller than number at middle, the left side must be sorted.\\nExample: [3, 4, 5, 6, 7, 8, 9, 1, 2], 2 < 7, left side sorted.\\n2. if the number at the beginning of array is bigger than number at middle, the right side must be sorted.\\nExample: [8, 9, 1, 2, 3, 4, 5, 6, 7]  8>3, right side sorted.\\n3. if neither, the whole array is sorted.\\nExample: [1, 2, 3, 4, 5, 6, 7, 8, 9]\\n"
                    },
                    {
                        "username": "ALS_Venky",
                        "content": "welcome to binary search week"
                    },
                    {
                        "username": "harisshah753159",
                        "content": "Need Help! why it\\'s gives Runtime error on test case nums = [1] and target = 1.  \\nclass Solution {\\npublic:\\n    int search(vector<int>& nums, int target) {\\n        int n = nums.size() - 1;\\n        int s=0, e=n;\\n        while(s<e) {\\n            int mid = s + (e-s) / 2;\\n            if(nums[mid] > nums[e]) {\\n                s = mid + 1;\\n            }\\n            else {\\n                e = mid;\\n            }\\n        }\\n        int pivotIndex = s;\\n        s = 0 , e = n;\\n        if(target >= nums[s] && target <= nums[pivotIndex -1]) {\\n            e = pivotIndex - 1;\\n        }\\n        else {\\n            s = pivotIndex ;\\n        }\\n        int mid = s + (e-s) / 2;\\n        while (s<=e) {\\n            if(nums[mid] == target) {\\n                return mid;\\n            }\\n            else if(target > nums[mid]) {\\n                s = mid + 1;\\n            }\\n            else {\\n                e = mid - 1;\\n            }\\n            mid = s + (e-s) / 2;\\n        }\\n        return -1;\\n    }\\n};\\n"
                    },
                    {
                        "username": "bparanj",
                        "content": "Your code is giving a runtime error for an array of size 1 because of the line `if(target >= nums[s] && target <= nums[pivotIndex -1])`. In the case when `nums = [1]` and `target = 1`, `pivotIndex` is 0, and `nums[pivotIndex - 1]` refers to `nums[-1]`, which in C++ gives the last element of the array.\\n\\nHowever, as there is only one element in the array, `nums[-1]` is effectively `nums[0]`, and you\\'re checking if the target is both greater than and less than `nums[0]` at the same time, which is impossible, leading to your issue.\\n\\nInstead of checking the range in this way, you should handle the edge case where your array size is 1 before doing any other operations:\\n\\n```cpp\\nint search(vector<int>& nums, int target) {\\n    int n = nums.size();\\n    if (n == 1)\\n        return nums[0] == target ? 0 : -1;\\n    // Rest of your code...\\n}\\n```\\n\\nBy doing this, you effectively bypass the rest of your code and return the correct index immediately when the size of your array is 1."
                    },
                    {
                        "username": "user2194kq",
                        "content": "pivot index is 0 in the case [1] \\nand then you are trying to access nums[pivot_index-1]\\nwhich will lead to an runtime error"
                    },
                    {
                        "username": "KITSCODER",
                        "content": "class Solution {\\n    public int search(int[] nums, int target) {\\n        int n =-1;\\n        for(int i=0;i<nums.length;i++){\\n            if(nums[i]==target){\\n                n = i;\\n            }\\n        }\\n        return n;\\n    }\\n}"
                    },
                    {
                        "username": "dos_77",
                        "content": "We apply Binary search 3 times:\\n- once for determining pivot\\n- other 2 times for searching on left and right side of pivot\\n\\nTo determine pivot, we keep track of left most element in binary search:\\n- compare the mid element with left most element of the search\\n- if mid element > left element -> pivot exists in nums[m:r]\\n- else if mid element < left element -> pivot exists in nums[l:m]\\n- else we are right on the pivot element\\n\\nNext Apply simple Binary Search on Left and right side of pivot\\n\\nFor Code & Line-By-Line explanation:\\n[Click here](https://leetcode.com/problems/search-in-rotated-sorted-array/solutions/2809810/python3-simple-line-by-line-explanation-with-code/)"
                    },
                    {
                        "username": "adamk90",
                        "content": "you dont need to search on both sides of the pivot, if target is lesser than the first element of the array, it should be in the right side of the pivot (including the pivot)"
                    },
                    {
                        "username": "jshi005",
                        "content": "This problem does not say the numbers in the array have to be unique.\\n\\nSo maybe you want to try a test like:\\n\\nnums = [3,0,1,3,3,3,3]\\ntarget = 0"
                    },
                    {
                        "username": "psionl0",
                        "content": "``nums`` is an <b>ascending</b> array that is possibly rotated."
                    }
                ]
            },
            {
                "id": 1574180,
                "content": [
                    {
                        "username": "adiljaved1311",
                        "content": "I think this question was asked in Google, Microsoft and Amazon. I found this link really helpful\\xA0\\nhttps://algopro.in/questions/category/array/search-in-a-rotated-sorted-array"
                    },
                    {
                        "username": "wculkin24",
                        "content": "Is the correct approach to binary search for the pivot and then binary search for the target"
                    },
                    {
                        "username": "bparanj",
                        "content": "Binary searching for the pivot and then for the target is one possible approach, and it can indeed solve the problem. In this approach, you perform two separate binary searches: one to find the pivot (i.e., the minimum element, or the point of rotation), and then another to find the target in the appropriate section of the array.\\n\\nHowever, this approach could be simplified by combining the two binary searches into one. Instead of explicitly finding the pivot, you can directly search for the target while accounting for the rotation in the array. You still use the same binary search structure, but with a modified condition for choosing the search space.\\n\\nIn each iteration, you determine whether the left or right half of the array is sorted (one half must be), and then check if the target lies within the sorted half. If it does, you continue your search in that half; otherwise, you search in the other half.\\n\\nThis combined approach is more efficient because it only requires one pass through the array (as opposed to two), and it simplifies the implementation by reducing the amount of code. Its time complexity remains O(log n) since it still uses binary search, but it has a smaller constant factor.\\n\\nBoth approaches are valid, but the combined approach is generally preferable due to its greater efficiency and simplicity."
                    },
                    {
                        "username": "osipovea",
                        "content": "Description: nums is guranteed to be rotated at some pivot.\\nTest case: [1, 3, 5]\\n\\nNo array rotation in this case, although it is said rotation is guranteed."
                    },
                    {
                        "username": "user5369RY",
                        "content": "[@lakshminathan](/lakshminathan) Please provide us with the rotations all one by one I can not get the rotation process"
                    },
                    {
                        "username": "lakshminathan",
                        "content": "rotated 3 times"
                    },
                    {
                        "username": "hfcparth",
                        "content": "the single binary method is confusing and does not click immidately"
                    },
                    {
                        "username": "SabaSaadatnia",
                        "content": "in this testcase:\\nInput\\nnums =\\n[4,5,6,7,0,1,2]\\ntarget =\\n5\\nExpected\\n1\\nthe expected output should be -1 because it states in the question that you should look for the target after the rotation. Am I wrong?"
                    },
                    {
                        "username": "firoz_18",
                        "content": "int bin_search(vector<int>& num, int start, int end, int target) {\\n    while (start <= end) {\\n        int mid = start + (end - start) / 2;\\n        if (num[mid] == target) {\\n            return mid;\\n        } else if (num[mid] < target) {\\n            start = mid + 1;\\n        } else {\\n            end = mid - 1;\\n        }\\n    }\\n    return -1;\\n}\\n\\nint pivot(vector<int>& num, int size) {\\n    int start = 0;\\n    int end = size - 1;\\n\\n   \\n    while (start < end) {\\n        int mid = start + (end - start) / 2;\\n\\n        if (num[mid] >= num[0]) {\\n            start = mid + 1;\\n        } else {\\n            end = mid;\\n        }\\n    }\\n\\n    return start;\\n}\\n\\nclass Solution {\\npublic:\\n    int search(vector<int>& nums, int target) {\\n        int size = nums.size();\\n        if (size == 0) {\\n            return -1;\\n        }\\n        \\n        int pivotIndex = pivot(nums, size);\\n        \\n        if (target == nums[pivotIndex]) {\\n            return pivotIndex;\\n        } else if (target >= nums[0] && target <= nums[pivotIndex - 1]) {\\n            return bin_search(nums, 0, pivotIndex - 1, target);\\n        } else {\\n            return bin_search(nums, pivotIndex, size - 1, target);\\n        }\\n    }\\n};\\n\\n\\ncan anyone explain my mistake , im getting error Line 1037: Char 34: runtime error: addition of unsigned offset to 0x602000000250 overflowed to 0x60200000024c (stl_vector.h)\\nSUMMARY: UndefinedBehaviorSanitizer: undefined-behavior /usr/bin/../lib/gcc/x86_64-linux-gnu/11/../../../../include/c++/11/bits/stl_vector.h:1046:34\\n\\ni only passed 4 test cases\\n"
                    },
                    {
                        "username": "Osereme",
                        "content": "With the new changes to Leetcode UI, how do i add this question to a list?"
                    },
                    {
                        "username": "Ramonsan07",
                        "content": "the little star next to the dislike button my friend"
                    },
                    {
                        "username": "rbdakee",
                        "content": "Is it okay that my solution worked perfectly and passed all testcases\\nif target in nums:\\n        return nums.index(target)\\nelse:\\n        return -1\\n"
                    },
                    {
                        "username": "Code_Enthusiast232",
                        "content": "Just do Binary search here!"
                    },
                    {
                        "username": "Shreyanshs18",
                        "content": "Wasted so much for binary search solution but couldn\\'t come up with any.\\nGo for linear search....it works."
                    }
                ]
            },
            {
                "id": 1573064,
                "content": [
                    {
                        "username": "adiljaved1311",
                        "content": "I think this question was asked in Google, Microsoft and Amazon. I found this link really helpful\\xA0\\nhttps://algopro.in/questions/category/array/search-in-a-rotated-sorted-array"
                    },
                    {
                        "username": "wculkin24",
                        "content": "Is the correct approach to binary search for the pivot and then binary search for the target"
                    },
                    {
                        "username": "bparanj",
                        "content": "Binary searching for the pivot and then for the target is one possible approach, and it can indeed solve the problem. In this approach, you perform two separate binary searches: one to find the pivot (i.e., the minimum element, or the point of rotation), and then another to find the target in the appropriate section of the array.\\n\\nHowever, this approach could be simplified by combining the two binary searches into one. Instead of explicitly finding the pivot, you can directly search for the target while accounting for the rotation in the array. You still use the same binary search structure, but with a modified condition for choosing the search space.\\n\\nIn each iteration, you determine whether the left or right half of the array is sorted (one half must be), and then check if the target lies within the sorted half. If it does, you continue your search in that half; otherwise, you search in the other half.\\n\\nThis combined approach is more efficient because it only requires one pass through the array (as opposed to two), and it simplifies the implementation by reducing the amount of code. Its time complexity remains O(log n) since it still uses binary search, but it has a smaller constant factor.\\n\\nBoth approaches are valid, but the combined approach is generally preferable due to its greater efficiency and simplicity."
                    },
                    {
                        "username": "osipovea",
                        "content": "Description: nums is guranteed to be rotated at some pivot.\\nTest case: [1, 3, 5]\\n\\nNo array rotation in this case, although it is said rotation is guranteed."
                    },
                    {
                        "username": "user5369RY",
                        "content": "[@lakshminathan](/lakshminathan) Please provide us with the rotations all one by one I can not get the rotation process"
                    },
                    {
                        "username": "lakshminathan",
                        "content": "rotated 3 times"
                    },
                    {
                        "username": "hfcparth",
                        "content": "the single binary method is confusing and does not click immidately"
                    },
                    {
                        "username": "SabaSaadatnia",
                        "content": "in this testcase:\\nInput\\nnums =\\n[4,5,6,7,0,1,2]\\ntarget =\\n5\\nExpected\\n1\\nthe expected output should be -1 because it states in the question that you should look for the target after the rotation. Am I wrong?"
                    },
                    {
                        "username": "firoz_18",
                        "content": "int bin_search(vector<int>& num, int start, int end, int target) {\\n    while (start <= end) {\\n        int mid = start + (end - start) / 2;\\n        if (num[mid] == target) {\\n            return mid;\\n        } else if (num[mid] < target) {\\n            start = mid + 1;\\n        } else {\\n            end = mid - 1;\\n        }\\n    }\\n    return -1;\\n}\\n\\nint pivot(vector<int>& num, int size) {\\n    int start = 0;\\n    int end = size - 1;\\n\\n   \\n    while (start < end) {\\n        int mid = start + (end - start) / 2;\\n\\n        if (num[mid] >= num[0]) {\\n            start = mid + 1;\\n        } else {\\n            end = mid;\\n        }\\n    }\\n\\n    return start;\\n}\\n\\nclass Solution {\\npublic:\\n    int search(vector<int>& nums, int target) {\\n        int size = nums.size();\\n        if (size == 0) {\\n            return -1;\\n        }\\n        \\n        int pivotIndex = pivot(nums, size);\\n        \\n        if (target == nums[pivotIndex]) {\\n            return pivotIndex;\\n        } else if (target >= nums[0] && target <= nums[pivotIndex - 1]) {\\n            return bin_search(nums, 0, pivotIndex - 1, target);\\n        } else {\\n            return bin_search(nums, pivotIndex, size - 1, target);\\n        }\\n    }\\n};\\n\\n\\ncan anyone explain my mistake , im getting error Line 1037: Char 34: runtime error: addition of unsigned offset to 0x602000000250 overflowed to 0x60200000024c (stl_vector.h)\\nSUMMARY: UndefinedBehaviorSanitizer: undefined-behavior /usr/bin/../lib/gcc/x86_64-linux-gnu/11/../../../../include/c++/11/bits/stl_vector.h:1046:34\\n\\ni only passed 4 test cases\\n"
                    },
                    {
                        "username": "Osereme",
                        "content": "With the new changes to Leetcode UI, how do i add this question to a list?"
                    },
                    {
                        "username": "Ramonsan07",
                        "content": "the little star next to the dislike button my friend"
                    },
                    {
                        "username": "rbdakee",
                        "content": "Is it okay that my solution worked perfectly and passed all testcases\\nif target in nums:\\n        return nums.index(target)\\nelse:\\n        return -1\\n"
                    },
                    {
                        "username": "Code_Enthusiast232",
                        "content": "Just do Binary search here!"
                    },
                    {
                        "username": "Shreyanshs18",
                        "content": "Wasted so much for binary search solution but couldn\\'t come up with any.\\nGo for linear search....it works."
                    }
                ]
            },
            {
                "id": 1570282,
                "content": [
                    {
                        "username": "adiljaved1311",
                        "content": "I think this question was asked in Google, Microsoft and Amazon. I found this link really helpful\\xA0\\nhttps://algopro.in/questions/category/array/search-in-a-rotated-sorted-array"
                    },
                    {
                        "username": "wculkin24",
                        "content": "Is the correct approach to binary search for the pivot and then binary search for the target"
                    },
                    {
                        "username": "bparanj",
                        "content": "Binary searching for the pivot and then for the target is one possible approach, and it can indeed solve the problem. In this approach, you perform two separate binary searches: one to find the pivot (i.e., the minimum element, or the point of rotation), and then another to find the target in the appropriate section of the array.\\n\\nHowever, this approach could be simplified by combining the two binary searches into one. Instead of explicitly finding the pivot, you can directly search for the target while accounting for the rotation in the array. You still use the same binary search structure, but with a modified condition for choosing the search space.\\n\\nIn each iteration, you determine whether the left or right half of the array is sorted (one half must be), and then check if the target lies within the sorted half. If it does, you continue your search in that half; otherwise, you search in the other half.\\n\\nThis combined approach is more efficient because it only requires one pass through the array (as opposed to two), and it simplifies the implementation by reducing the amount of code. Its time complexity remains O(log n) since it still uses binary search, but it has a smaller constant factor.\\n\\nBoth approaches are valid, but the combined approach is generally preferable due to its greater efficiency and simplicity."
                    },
                    {
                        "username": "osipovea",
                        "content": "Description: nums is guranteed to be rotated at some pivot.\\nTest case: [1, 3, 5]\\n\\nNo array rotation in this case, although it is said rotation is guranteed."
                    },
                    {
                        "username": "user5369RY",
                        "content": "[@lakshminathan](/lakshminathan) Please provide us with the rotations all one by one I can not get the rotation process"
                    },
                    {
                        "username": "lakshminathan",
                        "content": "rotated 3 times"
                    },
                    {
                        "username": "hfcparth",
                        "content": "the single binary method is confusing and does not click immidately"
                    },
                    {
                        "username": "SabaSaadatnia",
                        "content": "in this testcase:\\nInput\\nnums =\\n[4,5,6,7,0,1,2]\\ntarget =\\n5\\nExpected\\n1\\nthe expected output should be -1 because it states in the question that you should look for the target after the rotation. Am I wrong?"
                    },
                    {
                        "username": "firoz_18",
                        "content": "int bin_search(vector<int>& num, int start, int end, int target) {\\n    while (start <= end) {\\n        int mid = start + (end - start) / 2;\\n        if (num[mid] == target) {\\n            return mid;\\n        } else if (num[mid] < target) {\\n            start = mid + 1;\\n        } else {\\n            end = mid - 1;\\n        }\\n    }\\n    return -1;\\n}\\n\\nint pivot(vector<int>& num, int size) {\\n    int start = 0;\\n    int end = size - 1;\\n\\n   \\n    while (start < end) {\\n        int mid = start + (end - start) / 2;\\n\\n        if (num[mid] >= num[0]) {\\n            start = mid + 1;\\n        } else {\\n            end = mid;\\n        }\\n    }\\n\\n    return start;\\n}\\n\\nclass Solution {\\npublic:\\n    int search(vector<int>& nums, int target) {\\n        int size = nums.size();\\n        if (size == 0) {\\n            return -1;\\n        }\\n        \\n        int pivotIndex = pivot(nums, size);\\n        \\n        if (target == nums[pivotIndex]) {\\n            return pivotIndex;\\n        } else if (target >= nums[0] && target <= nums[pivotIndex - 1]) {\\n            return bin_search(nums, 0, pivotIndex - 1, target);\\n        } else {\\n            return bin_search(nums, pivotIndex, size - 1, target);\\n        }\\n    }\\n};\\n\\n\\ncan anyone explain my mistake , im getting error Line 1037: Char 34: runtime error: addition of unsigned offset to 0x602000000250 overflowed to 0x60200000024c (stl_vector.h)\\nSUMMARY: UndefinedBehaviorSanitizer: undefined-behavior /usr/bin/../lib/gcc/x86_64-linux-gnu/11/../../../../include/c++/11/bits/stl_vector.h:1046:34\\n\\ni only passed 4 test cases\\n"
                    },
                    {
                        "username": "Osereme",
                        "content": "With the new changes to Leetcode UI, how do i add this question to a list?"
                    },
                    {
                        "username": "Ramonsan07",
                        "content": "the little star next to the dislike button my friend"
                    },
                    {
                        "username": "rbdakee",
                        "content": "Is it okay that my solution worked perfectly and passed all testcases\\nif target in nums:\\n        return nums.index(target)\\nelse:\\n        return -1\\n"
                    },
                    {
                        "username": "Code_Enthusiast232",
                        "content": "Just do Binary search here!"
                    },
                    {
                        "username": "Shreyanshs18",
                        "content": "Wasted so much for binary search solution but couldn\\'t come up with any.\\nGo for linear search....it works."
                    }
                ]
            },
            {
                "id": 2064419,
                "content": [
                    {
                        "username": "adiljaved1311",
                        "content": "I think this question was asked in Google, Microsoft and Amazon. I found this link really helpful\\xA0\\nhttps://algopro.in/questions/category/array/search-in-a-rotated-sorted-array"
                    },
                    {
                        "username": "wculkin24",
                        "content": "Is the correct approach to binary search for the pivot and then binary search for the target"
                    },
                    {
                        "username": "bparanj",
                        "content": "Binary searching for the pivot and then for the target is one possible approach, and it can indeed solve the problem. In this approach, you perform two separate binary searches: one to find the pivot (i.e., the minimum element, or the point of rotation), and then another to find the target in the appropriate section of the array.\\n\\nHowever, this approach could be simplified by combining the two binary searches into one. Instead of explicitly finding the pivot, you can directly search for the target while accounting for the rotation in the array. You still use the same binary search structure, but with a modified condition for choosing the search space.\\n\\nIn each iteration, you determine whether the left or right half of the array is sorted (one half must be), and then check if the target lies within the sorted half. If it does, you continue your search in that half; otherwise, you search in the other half.\\n\\nThis combined approach is more efficient because it only requires one pass through the array (as opposed to two), and it simplifies the implementation by reducing the amount of code. Its time complexity remains O(log n) since it still uses binary search, but it has a smaller constant factor.\\n\\nBoth approaches are valid, but the combined approach is generally preferable due to its greater efficiency and simplicity."
                    },
                    {
                        "username": "osipovea",
                        "content": "Description: nums is guranteed to be rotated at some pivot.\\nTest case: [1, 3, 5]\\n\\nNo array rotation in this case, although it is said rotation is guranteed."
                    },
                    {
                        "username": "user5369RY",
                        "content": "[@lakshminathan](/lakshminathan) Please provide us with the rotations all one by one I can not get the rotation process"
                    },
                    {
                        "username": "lakshminathan",
                        "content": "rotated 3 times"
                    },
                    {
                        "username": "hfcparth",
                        "content": "the single binary method is confusing and does not click immidately"
                    },
                    {
                        "username": "SabaSaadatnia",
                        "content": "in this testcase:\\nInput\\nnums =\\n[4,5,6,7,0,1,2]\\ntarget =\\n5\\nExpected\\n1\\nthe expected output should be -1 because it states in the question that you should look for the target after the rotation. Am I wrong?"
                    },
                    {
                        "username": "firoz_18",
                        "content": "int bin_search(vector<int>& num, int start, int end, int target) {\\n    while (start <= end) {\\n        int mid = start + (end - start) / 2;\\n        if (num[mid] == target) {\\n            return mid;\\n        } else if (num[mid] < target) {\\n            start = mid + 1;\\n        } else {\\n            end = mid - 1;\\n        }\\n    }\\n    return -1;\\n}\\n\\nint pivot(vector<int>& num, int size) {\\n    int start = 0;\\n    int end = size - 1;\\n\\n   \\n    while (start < end) {\\n        int mid = start + (end - start) / 2;\\n\\n        if (num[mid] >= num[0]) {\\n            start = mid + 1;\\n        } else {\\n            end = mid;\\n        }\\n    }\\n\\n    return start;\\n}\\n\\nclass Solution {\\npublic:\\n    int search(vector<int>& nums, int target) {\\n        int size = nums.size();\\n        if (size == 0) {\\n            return -1;\\n        }\\n        \\n        int pivotIndex = pivot(nums, size);\\n        \\n        if (target == nums[pivotIndex]) {\\n            return pivotIndex;\\n        } else if (target >= nums[0] && target <= nums[pivotIndex - 1]) {\\n            return bin_search(nums, 0, pivotIndex - 1, target);\\n        } else {\\n            return bin_search(nums, pivotIndex, size - 1, target);\\n        }\\n    }\\n};\\n\\n\\ncan anyone explain my mistake , im getting error Line 1037: Char 34: runtime error: addition of unsigned offset to 0x602000000250 overflowed to 0x60200000024c (stl_vector.h)\\nSUMMARY: UndefinedBehaviorSanitizer: undefined-behavior /usr/bin/../lib/gcc/x86_64-linux-gnu/11/../../../../include/c++/11/bits/stl_vector.h:1046:34\\n\\ni only passed 4 test cases\\n"
                    },
                    {
                        "username": "Osereme",
                        "content": "With the new changes to Leetcode UI, how do i add this question to a list?"
                    },
                    {
                        "username": "Ramonsan07",
                        "content": "the little star next to the dislike button my friend"
                    },
                    {
                        "username": "rbdakee",
                        "content": "Is it okay that my solution worked perfectly and passed all testcases\\nif target in nums:\\n        return nums.index(target)\\nelse:\\n        return -1\\n"
                    },
                    {
                        "username": "Code_Enthusiast232",
                        "content": "Just do Binary search here!"
                    },
                    {
                        "username": "Shreyanshs18",
                        "content": "Wasted so much for binary search solution but couldn\\'t come up with any.\\nGo for linear search....it works."
                    }
                ]
            },
            {
                "id": 2060635,
                "content": [
                    {
                        "username": "adiljaved1311",
                        "content": "I think this question was asked in Google, Microsoft and Amazon. I found this link really helpful\\xA0\\nhttps://algopro.in/questions/category/array/search-in-a-rotated-sorted-array"
                    },
                    {
                        "username": "wculkin24",
                        "content": "Is the correct approach to binary search for the pivot and then binary search for the target"
                    },
                    {
                        "username": "bparanj",
                        "content": "Binary searching for the pivot and then for the target is one possible approach, and it can indeed solve the problem. In this approach, you perform two separate binary searches: one to find the pivot (i.e., the minimum element, or the point of rotation), and then another to find the target in the appropriate section of the array.\\n\\nHowever, this approach could be simplified by combining the two binary searches into one. Instead of explicitly finding the pivot, you can directly search for the target while accounting for the rotation in the array. You still use the same binary search structure, but with a modified condition for choosing the search space.\\n\\nIn each iteration, you determine whether the left or right half of the array is sorted (one half must be), and then check if the target lies within the sorted half. If it does, you continue your search in that half; otherwise, you search in the other half.\\n\\nThis combined approach is more efficient because it only requires one pass through the array (as opposed to two), and it simplifies the implementation by reducing the amount of code. Its time complexity remains O(log n) since it still uses binary search, but it has a smaller constant factor.\\n\\nBoth approaches are valid, but the combined approach is generally preferable due to its greater efficiency and simplicity."
                    },
                    {
                        "username": "osipovea",
                        "content": "Description: nums is guranteed to be rotated at some pivot.\\nTest case: [1, 3, 5]\\n\\nNo array rotation in this case, although it is said rotation is guranteed."
                    },
                    {
                        "username": "user5369RY",
                        "content": "[@lakshminathan](/lakshminathan) Please provide us with the rotations all one by one I can not get the rotation process"
                    },
                    {
                        "username": "lakshminathan",
                        "content": "rotated 3 times"
                    },
                    {
                        "username": "hfcparth",
                        "content": "the single binary method is confusing and does not click immidately"
                    },
                    {
                        "username": "SabaSaadatnia",
                        "content": "in this testcase:\\nInput\\nnums =\\n[4,5,6,7,0,1,2]\\ntarget =\\n5\\nExpected\\n1\\nthe expected output should be -1 because it states in the question that you should look for the target after the rotation. Am I wrong?"
                    },
                    {
                        "username": "firoz_18",
                        "content": "int bin_search(vector<int>& num, int start, int end, int target) {\\n    while (start <= end) {\\n        int mid = start + (end - start) / 2;\\n        if (num[mid] == target) {\\n            return mid;\\n        } else if (num[mid] < target) {\\n            start = mid + 1;\\n        } else {\\n            end = mid - 1;\\n        }\\n    }\\n    return -1;\\n}\\n\\nint pivot(vector<int>& num, int size) {\\n    int start = 0;\\n    int end = size - 1;\\n\\n   \\n    while (start < end) {\\n        int mid = start + (end - start) / 2;\\n\\n        if (num[mid] >= num[0]) {\\n            start = mid + 1;\\n        } else {\\n            end = mid;\\n        }\\n    }\\n\\n    return start;\\n}\\n\\nclass Solution {\\npublic:\\n    int search(vector<int>& nums, int target) {\\n        int size = nums.size();\\n        if (size == 0) {\\n            return -1;\\n        }\\n        \\n        int pivotIndex = pivot(nums, size);\\n        \\n        if (target == nums[pivotIndex]) {\\n            return pivotIndex;\\n        } else if (target >= nums[0] && target <= nums[pivotIndex - 1]) {\\n            return bin_search(nums, 0, pivotIndex - 1, target);\\n        } else {\\n            return bin_search(nums, pivotIndex, size - 1, target);\\n        }\\n    }\\n};\\n\\n\\ncan anyone explain my mistake , im getting error Line 1037: Char 34: runtime error: addition of unsigned offset to 0x602000000250 overflowed to 0x60200000024c (stl_vector.h)\\nSUMMARY: UndefinedBehaviorSanitizer: undefined-behavior /usr/bin/../lib/gcc/x86_64-linux-gnu/11/../../../../include/c++/11/bits/stl_vector.h:1046:34\\n\\ni only passed 4 test cases\\n"
                    },
                    {
                        "username": "Osereme",
                        "content": "With the new changes to Leetcode UI, how do i add this question to a list?"
                    },
                    {
                        "username": "Ramonsan07",
                        "content": "the little star next to the dislike button my friend"
                    },
                    {
                        "username": "rbdakee",
                        "content": "Is it okay that my solution worked perfectly and passed all testcases\\nif target in nums:\\n        return nums.index(target)\\nelse:\\n        return -1\\n"
                    },
                    {
                        "username": "Code_Enthusiast232",
                        "content": "Just do Binary search here!"
                    },
                    {
                        "username": "Shreyanshs18",
                        "content": "Wasted so much for binary search solution but couldn\\'t come up with any.\\nGo for linear search....it works."
                    }
                ]
            },
            {
                "id": 2057691,
                "content": [
                    {
                        "username": "adiljaved1311",
                        "content": "I think this question was asked in Google, Microsoft and Amazon. I found this link really helpful\\xA0\\nhttps://algopro.in/questions/category/array/search-in-a-rotated-sorted-array"
                    },
                    {
                        "username": "wculkin24",
                        "content": "Is the correct approach to binary search for the pivot and then binary search for the target"
                    },
                    {
                        "username": "bparanj",
                        "content": "Binary searching for the pivot and then for the target is one possible approach, and it can indeed solve the problem. In this approach, you perform two separate binary searches: one to find the pivot (i.e., the minimum element, or the point of rotation), and then another to find the target in the appropriate section of the array.\\n\\nHowever, this approach could be simplified by combining the two binary searches into one. Instead of explicitly finding the pivot, you can directly search for the target while accounting for the rotation in the array. You still use the same binary search structure, but with a modified condition for choosing the search space.\\n\\nIn each iteration, you determine whether the left or right half of the array is sorted (one half must be), and then check if the target lies within the sorted half. If it does, you continue your search in that half; otherwise, you search in the other half.\\n\\nThis combined approach is more efficient because it only requires one pass through the array (as opposed to two), and it simplifies the implementation by reducing the amount of code. Its time complexity remains O(log n) since it still uses binary search, but it has a smaller constant factor.\\n\\nBoth approaches are valid, but the combined approach is generally preferable due to its greater efficiency and simplicity."
                    },
                    {
                        "username": "osipovea",
                        "content": "Description: nums is guranteed to be rotated at some pivot.\\nTest case: [1, 3, 5]\\n\\nNo array rotation in this case, although it is said rotation is guranteed."
                    },
                    {
                        "username": "user5369RY",
                        "content": "[@lakshminathan](/lakshminathan) Please provide us with the rotations all one by one I can not get the rotation process"
                    },
                    {
                        "username": "lakshminathan",
                        "content": "rotated 3 times"
                    },
                    {
                        "username": "hfcparth",
                        "content": "the single binary method is confusing and does not click immidately"
                    },
                    {
                        "username": "SabaSaadatnia",
                        "content": "in this testcase:\\nInput\\nnums =\\n[4,5,6,7,0,1,2]\\ntarget =\\n5\\nExpected\\n1\\nthe expected output should be -1 because it states in the question that you should look for the target after the rotation. Am I wrong?"
                    },
                    {
                        "username": "firoz_18",
                        "content": "int bin_search(vector<int>& num, int start, int end, int target) {\\n    while (start <= end) {\\n        int mid = start + (end - start) / 2;\\n        if (num[mid] == target) {\\n            return mid;\\n        } else if (num[mid] < target) {\\n            start = mid + 1;\\n        } else {\\n            end = mid - 1;\\n        }\\n    }\\n    return -1;\\n}\\n\\nint pivot(vector<int>& num, int size) {\\n    int start = 0;\\n    int end = size - 1;\\n\\n   \\n    while (start < end) {\\n        int mid = start + (end - start) / 2;\\n\\n        if (num[mid] >= num[0]) {\\n            start = mid + 1;\\n        } else {\\n            end = mid;\\n        }\\n    }\\n\\n    return start;\\n}\\n\\nclass Solution {\\npublic:\\n    int search(vector<int>& nums, int target) {\\n        int size = nums.size();\\n        if (size == 0) {\\n            return -1;\\n        }\\n        \\n        int pivotIndex = pivot(nums, size);\\n        \\n        if (target == nums[pivotIndex]) {\\n            return pivotIndex;\\n        } else if (target >= nums[0] && target <= nums[pivotIndex - 1]) {\\n            return bin_search(nums, 0, pivotIndex - 1, target);\\n        } else {\\n            return bin_search(nums, pivotIndex, size - 1, target);\\n        }\\n    }\\n};\\n\\n\\ncan anyone explain my mistake , im getting error Line 1037: Char 34: runtime error: addition of unsigned offset to 0x602000000250 overflowed to 0x60200000024c (stl_vector.h)\\nSUMMARY: UndefinedBehaviorSanitizer: undefined-behavior /usr/bin/../lib/gcc/x86_64-linux-gnu/11/../../../../include/c++/11/bits/stl_vector.h:1046:34\\n\\ni only passed 4 test cases\\n"
                    },
                    {
                        "username": "Osereme",
                        "content": "With the new changes to Leetcode UI, how do i add this question to a list?"
                    },
                    {
                        "username": "Ramonsan07",
                        "content": "the little star next to the dislike button my friend"
                    },
                    {
                        "username": "rbdakee",
                        "content": "Is it okay that my solution worked perfectly and passed all testcases\\nif target in nums:\\n        return nums.index(target)\\nelse:\\n        return -1\\n"
                    },
                    {
                        "username": "Code_Enthusiast232",
                        "content": "Just do Binary search here!"
                    },
                    {
                        "username": "Shreyanshs18",
                        "content": "Wasted so much for binary search solution but couldn\\'t come up with any.\\nGo for linear search....it works."
                    }
                ]
            },
            {
                "id": 2055258,
                "content": [
                    {
                        "username": "adiljaved1311",
                        "content": "I think this question was asked in Google, Microsoft and Amazon. I found this link really helpful\\xA0\\nhttps://algopro.in/questions/category/array/search-in-a-rotated-sorted-array"
                    },
                    {
                        "username": "wculkin24",
                        "content": "Is the correct approach to binary search for the pivot and then binary search for the target"
                    },
                    {
                        "username": "bparanj",
                        "content": "Binary searching for the pivot and then for the target is one possible approach, and it can indeed solve the problem. In this approach, you perform two separate binary searches: one to find the pivot (i.e., the minimum element, or the point of rotation), and then another to find the target in the appropriate section of the array.\\n\\nHowever, this approach could be simplified by combining the two binary searches into one. Instead of explicitly finding the pivot, you can directly search for the target while accounting for the rotation in the array. You still use the same binary search structure, but with a modified condition for choosing the search space.\\n\\nIn each iteration, you determine whether the left or right half of the array is sorted (one half must be), and then check if the target lies within the sorted half. If it does, you continue your search in that half; otherwise, you search in the other half.\\n\\nThis combined approach is more efficient because it only requires one pass through the array (as opposed to two), and it simplifies the implementation by reducing the amount of code. Its time complexity remains O(log n) since it still uses binary search, but it has a smaller constant factor.\\n\\nBoth approaches are valid, but the combined approach is generally preferable due to its greater efficiency and simplicity."
                    },
                    {
                        "username": "osipovea",
                        "content": "Description: nums is guranteed to be rotated at some pivot.\\nTest case: [1, 3, 5]\\n\\nNo array rotation in this case, although it is said rotation is guranteed."
                    },
                    {
                        "username": "user5369RY",
                        "content": "[@lakshminathan](/lakshminathan) Please provide us with the rotations all one by one I can not get the rotation process"
                    },
                    {
                        "username": "lakshminathan",
                        "content": "rotated 3 times"
                    },
                    {
                        "username": "hfcparth",
                        "content": "the single binary method is confusing and does not click immidately"
                    },
                    {
                        "username": "SabaSaadatnia",
                        "content": "in this testcase:\\nInput\\nnums =\\n[4,5,6,7,0,1,2]\\ntarget =\\n5\\nExpected\\n1\\nthe expected output should be -1 because it states in the question that you should look for the target after the rotation. Am I wrong?"
                    },
                    {
                        "username": "firoz_18",
                        "content": "int bin_search(vector<int>& num, int start, int end, int target) {\\n    while (start <= end) {\\n        int mid = start + (end - start) / 2;\\n        if (num[mid] == target) {\\n            return mid;\\n        } else if (num[mid] < target) {\\n            start = mid + 1;\\n        } else {\\n            end = mid - 1;\\n        }\\n    }\\n    return -1;\\n}\\n\\nint pivot(vector<int>& num, int size) {\\n    int start = 0;\\n    int end = size - 1;\\n\\n   \\n    while (start < end) {\\n        int mid = start + (end - start) / 2;\\n\\n        if (num[mid] >= num[0]) {\\n            start = mid + 1;\\n        } else {\\n            end = mid;\\n        }\\n    }\\n\\n    return start;\\n}\\n\\nclass Solution {\\npublic:\\n    int search(vector<int>& nums, int target) {\\n        int size = nums.size();\\n        if (size == 0) {\\n            return -1;\\n        }\\n        \\n        int pivotIndex = pivot(nums, size);\\n        \\n        if (target == nums[pivotIndex]) {\\n            return pivotIndex;\\n        } else if (target >= nums[0] && target <= nums[pivotIndex - 1]) {\\n            return bin_search(nums, 0, pivotIndex - 1, target);\\n        } else {\\n            return bin_search(nums, pivotIndex, size - 1, target);\\n        }\\n    }\\n};\\n\\n\\ncan anyone explain my mistake , im getting error Line 1037: Char 34: runtime error: addition of unsigned offset to 0x602000000250 overflowed to 0x60200000024c (stl_vector.h)\\nSUMMARY: UndefinedBehaviorSanitizer: undefined-behavior /usr/bin/../lib/gcc/x86_64-linux-gnu/11/../../../../include/c++/11/bits/stl_vector.h:1046:34\\n\\ni only passed 4 test cases\\n"
                    },
                    {
                        "username": "Osereme",
                        "content": "With the new changes to Leetcode UI, how do i add this question to a list?"
                    },
                    {
                        "username": "Ramonsan07",
                        "content": "the little star next to the dislike button my friend"
                    },
                    {
                        "username": "rbdakee",
                        "content": "Is it okay that my solution worked perfectly and passed all testcases\\nif target in nums:\\n        return nums.index(target)\\nelse:\\n        return -1\\n"
                    },
                    {
                        "username": "Code_Enthusiast232",
                        "content": "Just do Binary search here!"
                    },
                    {
                        "username": "Shreyanshs18",
                        "content": "Wasted so much for binary search solution but couldn\\'t come up with any.\\nGo for linear search....it works."
                    }
                ]
            },
            {
                "id": 2053962,
                "content": [
                    {
                        "username": "adiljaved1311",
                        "content": "I think this question was asked in Google, Microsoft and Amazon. I found this link really helpful\\xA0\\nhttps://algopro.in/questions/category/array/search-in-a-rotated-sorted-array"
                    },
                    {
                        "username": "wculkin24",
                        "content": "Is the correct approach to binary search for the pivot and then binary search for the target"
                    },
                    {
                        "username": "bparanj",
                        "content": "Binary searching for the pivot and then for the target is one possible approach, and it can indeed solve the problem. In this approach, you perform two separate binary searches: one to find the pivot (i.e., the minimum element, or the point of rotation), and then another to find the target in the appropriate section of the array.\\n\\nHowever, this approach could be simplified by combining the two binary searches into one. Instead of explicitly finding the pivot, you can directly search for the target while accounting for the rotation in the array. You still use the same binary search structure, but with a modified condition for choosing the search space.\\n\\nIn each iteration, you determine whether the left or right half of the array is sorted (one half must be), and then check if the target lies within the sorted half. If it does, you continue your search in that half; otherwise, you search in the other half.\\n\\nThis combined approach is more efficient because it only requires one pass through the array (as opposed to two), and it simplifies the implementation by reducing the amount of code. Its time complexity remains O(log n) since it still uses binary search, but it has a smaller constant factor.\\n\\nBoth approaches are valid, but the combined approach is generally preferable due to its greater efficiency and simplicity."
                    },
                    {
                        "username": "osipovea",
                        "content": "Description: nums is guranteed to be rotated at some pivot.\\nTest case: [1, 3, 5]\\n\\nNo array rotation in this case, although it is said rotation is guranteed."
                    },
                    {
                        "username": "user5369RY",
                        "content": "[@lakshminathan](/lakshminathan) Please provide us with the rotations all one by one I can not get the rotation process"
                    },
                    {
                        "username": "lakshminathan",
                        "content": "rotated 3 times"
                    },
                    {
                        "username": "hfcparth",
                        "content": "the single binary method is confusing and does not click immidately"
                    },
                    {
                        "username": "SabaSaadatnia",
                        "content": "in this testcase:\\nInput\\nnums =\\n[4,5,6,7,0,1,2]\\ntarget =\\n5\\nExpected\\n1\\nthe expected output should be -1 because it states in the question that you should look for the target after the rotation. Am I wrong?"
                    },
                    {
                        "username": "firoz_18",
                        "content": "int bin_search(vector<int>& num, int start, int end, int target) {\\n    while (start <= end) {\\n        int mid = start + (end - start) / 2;\\n        if (num[mid] == target) {\\n            return mid;\\n        } else if (num[mid] < target) {\\n            start = mid + 1;\\n        } else {\\n            end = mid - 1;\\n        }\\n    }\\n    return -1;\\n}\\n\\nint pivot(vector<int>& num, int size) {\\n    int start = 0;\\n    int end = size - 1;\\n\\n   \\n    while (start < end) {\\n        int mid = start + (end - start) / 2;\\n\\n        if (num[mid] >= num[0]) {\\n            start = mid + 1;\\n        } else {\\n            end = mid;\\n        }\\n    }\\n\\n    return start;\\n}\\n\\nclass Solution {\\npublic:\\n    int search(vector<int>& nums, int target) {\\n        int size = nums.size();\\n        if (size == 0) {\\n            return -1;\\n        }\\n        \\n        int pivotIndex = pivot(nums, size);\\n        \\n        if (target == nums[pivotIndex]) {\\n            return pivotIndex;\\n        } else if (target >= nums[0] && target <= nums[pivotIndex - 1]) {\\n            return bin_search(nums, 0, pivotIndex - 1, target);\\n        } else {\\n            return bin_search(nums, pivotIndex, size - 1, target);\\n        }\\n    }\\n};\\n\\n\\ncan anyone explain my mistake , im getting error Line 1037: Char 34: runtime error: addition of unsigned offset to 0x602000000250 overflowed to 0x60200000024c (stl_vector.h)\\nSUMMARY: UndefinedBehaviorSanitizer: undefined-behavior /usr/bin/../lib/gcc/x86_64-linux-gnu/11/../../../../include/c++/11/bits/stl_vector.h:1046:34\\n\\ni only passed 4 test cases\\n"
                    },
                    {
                        "username": "Osereme",
                        "content": "With the new changes to Leetcode UI, how do i add this question to a list?"
                    },
                    {
                        "username": "Ramonsan07",
                        "content": "the little star next to the dislike button my friend"
                    },
                    {
                        "username": "rbdakee",
                        "content": "Is it okay that my solution worked perfectly and passed all testcases\\nif target in nums:\\n        return nums.index(target)\\nelse:\\n        return -1\\n"
                    },
                    {
                        "username": "Code_Enthusiast232",
                        "content": "Just do Binary search here!"
                    },
                    {
                        "username": "Shreyanshs18",
                        "content": "Wasted so much for binary search solution but couldn\\'t come up with any.\\nGo for linear search....it works."
                    }
                ]
            },
            {
                "id": 2051610,
                "content": [
                    {
                        "username": "adiljaved1311",
                        "content": "I think this question was asked in Google, Microsoft and Amazon. I found this link really helpful\\xA0\\nhttps://algopro.in/questions/category/array/search-in-a-rotated-sorted-array"
                    },
                    {
                        "username": "wculkin24",
                        "content": "Is the correct approach to binary search for the pivot and then binary search for the target"
                    },
                    {
                        "username": "bparanj",
                        "content": "Binary searching for the pivot and then for the target is one possible approach, and it can indeed solve the problem. In this approach, you perform two separate binary searches: one to find the pivot (i.e., the minimum element, or the point of rotation), and then another to find the target in the appropriate section of the array.\\n\\nHowever, this approach could be simplified by combining the two binary searches into one. Instead of explicitly finding the pivot, you can directly search for the target while accounting for the rotation in the array. You still use the same binary search structure, but with a modified condition for choosing the search space.\\n\\nIn each iteration, you determine whether the left or right half of the array is sorted (one half must be), and then check if the target lies within the sorted half. If it does, you continue your search in that half; otherwise, you search in the other half.\\n\\nThis combined approach is more efficient because it only requires one pass through the array (as opposed to two), and it simplifies the implementation by reducing the amount of code. Its time complexity remains O(log n) since it still uses binary search, but it has a smaller constant factor.\\n\\nBoth approaches are valid, but the combined approach is generally preferable due to its greater efficiency and simplicity."
                    },
                    {
                        "username": "osipovea",
                        "content": "Description: nums is guranteed to be rotated at some pivot.\\nTest case: [1, 3, 5]\\n\\nNo array rotation in this case, although it is said rotation is guranteed."
                    },
                    {
                        "username": "user5369RY",
                        "content": "[@lakshminathan](/lakshminathan) Please provide us with the rotations all one by one I can not get the rotation process"
                    },
                    {
                        "username": "lakshminathan",
                        "content": "rotated 3 times"
                    },
                    {
                        "username": "hfcparth",
                        "content": "the single binary method is confusing and does not click immidately"
                    },
                    {
                        "username": "SabaSaadatnia",
                        "content": "in this testcase:\\nInput\\nnums =\\n[4,5,6,7,0,1,2]\\ntarget =\\n5\\nExpected\\n1\\nthe expected output should be -1 because it states in the question that you should look for the target after the rotation. Am I wrong?"
                    },
                    {
                        "username": "firoz_18",
                        "content": "int bin_search(vector<int>& num, int start, int end, int target) {\\n    while (start <= end) {\\n        int mid = start + (end - start) / 2;\\n        if (num[mid] == target) {\\n            return mid;\\n        } else if (num[mid] < target) {\\n            start = mid + 1;\\n        } else {\\n            end = mid - 1;\\n        }\\n    }\\n    return -1;\\n}\\n\\nint pivot(vector<int>& num, int size) {\\n    int start = 0;\\n    int end = size - 1;\\n\\n   \\n    while (start < end) {\\n        int mid = start + (end - start) / 2;\\n\\n        if (num[mid] >= num[0]) {\\n            start = mid + 1;\\n        } else {\\n            end = mid;\\n        }\\n    }\\n\\n    return start;\\n}\\n\\nclass Solution {\\npublic:\\n    int search(vector<int>& nums, int target) {\\n        int size = nums.size();\\n        if (size == 0) {\\n            return -1;\\n        }\\n        \\n        int pivotIndex = pivot(nums, size);\\n        \\n        if (target == nums[pivotIndex]) {\\n            return pivotIndex;\\n        } else if (target >= nums[0] && target <= nums[pivotIndex - 1]) {\\n            return bin_search(nums, 0, pivotIndex - 1, target);\\n        } else {\\n            return bin_search(nums, pivotIndex, size - 1, target);\\n        }\\n    }\\n};\\n\\n\\ncan anyone explain my mistake , im getting error Line 1037: Char 34: runtime error: addition of unsigned offset to 0x602000000250 overflowed to 0x60200000024c (stl_vector.h)\\nSUMMARY: UndefinedBehaviorSanitizer: undefined-behavior /usr/bin/../lib/gcc/x86_64-linux-gnu/11/../../../../include/c++/11/bits/stl_vector.h:1046:34\\n\\ni only passed 4 test cases\\n"
                    },
                    {
                        "username": "Osereme",
                        "content": "With the new changes to Leetcode UI, how do i add this question to a list?"
                    },
                    {
                        "username": "Ramonsan07",
                        "content": "the little star next to the dislike button my friend"
                    },
                    {
                        "username": "rbdakee",
                        "content": "Is it okay that my solution worked perfectly and passed all testcases\\nif target in nums:\\n        return nums.index(target)\\nelse:\\n        return -1\\n"
                    },
                    {
                        "username": "Code_Enthusiast232",
                        "content": "Just do Binary search here!"
                    },
                    {
                        "username": "Shreyanshs18",
                        "content": "Wasted so much for binary search solution but couldn\\'t come up with any.\\nGo for linear search....it works."
                    }
                ]
            },
            {
                "id": 2049573,
                "content": [
                    {
                        "username": "adiljaved1311",
                        "content": "I think this question was asked in Google, Microsoft and Amazon. I found this link really helpful\\xA0\\nhttps://algopro.in/questions/category/array/search-in-a-rotated-sorted-array"
                    },
                    {
                        "username": "wculkin24",
                        "content": "Is the correct approach to binary search for the pivot and then binary search for the target"
                    },
                    {
                        "username": "bparanj",
                        "content": "Binary searching for the pivot and then for the target is one possible approach, and it can indeed solve the problem. In this approach, you perform two separate binary searches: one to find the pivot (i.e., the minimum element, or the point of rotation), and then another to find the target in the appropriate section of the array.\\n\\nHowever, this approach could be simplified by combining the two binary searches into one. Instead of explicitly finding the pivot, you can directly search for the target while accounting for the rotation in the array. You still use the same binary search structure, but with a modified condition for choosing the search space.\\n\\nIn each iteration, you determine whether the left or right half of the array is sorted (one half must be), and then check if the target lies within the sorted half. If it does, you continue your search in that half; otherwise, you search in the other half.\\n\\nThis combined approach is more efficient because it only requires one pass through the array (as opposed to two), and it simplifies the implementation by reducing the amount of code. Its time complexity remains O(log n) since it still uses binary search, but it has a smaller constant factor.\\n\\nBoth approaches are valid, but the combined approach is generally preferable due to its greater efficiency and simplicity."
                    },
                    {
                        "username": "osipovea",
                        "content": "Description: nums is guranteed to be rotated at some pivot.\\nTest case: [1, 3, 5]\\n\\nNo array rotation in this case, although it is said rotation is guranteed."
                    },
                    {
                        "username": "user5369RY",
                        "content": "[@lakshminathan](/lakshminathan) Please provide us with the rotations all one by one I can not get the rotation process"
                    },
                    {
                        "username": "lakshminathan",
                        "content": "rotated 3 times"
                    },
                    {
                        "username": "hfcparth",
                        "content": "the single binary method is confusing and does not click immidately"
                    },
                    {
                        "username": "SabaSaadatnia",
                        "content": "in this testcase:\\nInput\\nnums =\\n[4,5,6,7,0,1,2]\\ntarget =\\n5\\nExpected\\n1\\nthe expected output should be -1 because it states in the question that you should look for the target after the rotation. Am I wrong?"
                    },
                    {
                        "username": "firoz_18",
                        "content": "int bin_search(vector<int>& num, int start, int end, int target) {\\n    while (start <= end) {\\n        int mid = start + (end - start) / 2;\\n        if (num[mid] == target) {\\n            return mid;\\n        } else if (num[mid] < target) {\\n            start = mid + 1;\\n        } else {\\n            end = mid - 1;\\n        }\\n    }\\n    return -1;\\n}\\n\\nint pivot(vector<int>& num, int size) {\\n    int start = 0;\\n    int end = size - 1;\\n\\n   \\n    while (start < end) {\\n        int mid = start + (end - start) / 2;\\n\\n        if (num[mid] >= num[0]) {\\n            start = mid + 1;\\n        } else {\\n            end = mid;\\n        }\\n    }\\n\\n    return start;\\n}\\n\\nclass Solution {\\npublic:\\n    int search(vector<int>& nums, int target) {\\n        int size = nums.size();\\n        if (size == 0) {\\n            return -1;\\n        }\\n        \\n        int pivotIndex = pivot(nums, size);\\n        \\n        if (target == nums[pivotIndex]) {\\n            return pivotIndex;\\n        } else if (target >= nums[0] && target <= nums[pivotIndex - 1]) {\\n            return bin_search(nums, 0, pivotIndex - 1, target);\\n        } else {\\n            return bin_search(nums, pivotIndex, size - 1, target);\\n        }\\n    }\\n};\\n\\n\\ncan anyone explain my mistake , im getting error Line 1037: Char 34: runtime error: addition of unsigned offset to 0x602000000250 overflowed to 0x60200000024c (stl_vector.h)\\nSUMMARY: UndefinedBehaviorSanitizer: undefined-behavior /usr/bin/../lib/gcc/x86_64-linux-gnu/11/../../../../include/c++/11/bits/stl_vector.h:1046:34\\n\\ni only passed 4 test cases\\n"
                    },
                    {
                        "username": "Osereme",
                        "content": "With the new changes to Leetcode UI, how do i add this question to a list?"
                    },
                    {
                        "username": "Ramonsan07",
                        "content": "the little star next to the dislike button my friend"
                    },
                    {
                        "username": "rbdakee",
                        "content": "Is it okay that my solution worked perfectly and passed all testcases\\nif target in nums:\\n        return nums.index(target)\\nelse:\\n        return -1\\n"
                    },
                    {
                        "username": "Code_Enthusiast232",
                        "content": "Just do Binary search here!"
                    },
                    {
                        "username": "Shreyanshs18",
                        "content": "Wasted so much for binary search solution but couldn\\'t come up with any.\\nGo for linear search....it works."
                    }
                ]
            },
            {
                "id": 2046504,
                "content": [
                    {
                        "username": "Rivo11",
                        "content": "Conclusion .. you try to identify your position in the left sorted or the right sorted array.....so you can compare the target with a range."
                    },
                    {
                        "username": "rmbidada",
                        "content": "Could you please help me to understand why this is not running ?\n `class Solution {\n    public int search(int[] nums, int target) {\n        int rotation = 0;\n        int low = 0, high = nums.length-1, mid;\n        // boolean matched = false;\n        \n        while(low <= high){\n            mid = (high + low)/2;\n            System.out.println(\"here I come\");\n            if(target == nums[mid]){\n                System.out.println(\"matched\");\n                return low;\n            }else if(nums[low] > nums[high] && nums[low] > target){\n                low = mid;            \n                mid = (low + high)/2;                \n                System.out.println(\"low : \" + low + \" mid: \" + mid + \" high: \"+ high );\n            }else if(nums[low] < target && nums[low] < nums[high]){\n                high = mid;\n                mid = (low + high)/2;\n            }\n        }\n        return -1;\n    }\n}`\n\nI am getting below response even after matching the target\nhere I come\nlow : 3 mid: 4 high: 6\nhere I come\nmatched\nhere I come\nlow : 3 mid: 4 high: 6\nhere I come\nlow : 4 mid: 5 high: 6...\n\nand its timing out due to infinite loop."
                    },
                    {
                        "username": "Spam_Musubi",
                        "content": "how is this in the medium difficulty??"
                    },
                    {
                        "username": "hermawangan39",
                        "content": "here\\'s some tips,\\ncheck if mid is in the left half or right half\\ncheck whether the target is in the left half or right half"
                    },
                    {
                        "username": "raghu_codes",
                        "content": "There are no constraints specified, so why not use the find function provided by the STL library , rather than using the binary search?"
                    },
                    {
                        "username": "Abu017",
                        "content": "class Solution {\\npublic:\\n    int search(vector<int>& nums, int target) {\\n    int start=0;\\n    int end=nums.size();\\n    while(start<=end){\\n        if(nums[start]==target){\\n            return target;\\n        }else if(nums[end]==target){\\n        return target;\\n        }\\n        start++;\\n        end--;\\n    }\\n    return -1;\\n }\\n};"
                    },
                    {
                        "username": "Ashu07",
                        "content": "class Solution {\\n    public int search(int[] nums, int target) {\\n        // ========= Uaing Linear Search================\\n    //     for(int i=0;i<nums.length;i++){\\n    //         if(nums[i]==target){\\n    //             return i;\\n    //         }\\n    //     }\\n    //     return -1;\\n    // }\\n\\n\\n    int low=0;\\n    int high=nums.length-1;\\n\\n    while(low<=high)\\n    {\\n        int mid=(low+high)/2;\\n        // If target is at middle index simply return mid\\n        if(nums[mid]==target){\\n            return mid;\\n        }\\n\\n        // Checking which part is sorted\\n        if(nums[low]<=nums[mid]){\\n            // The above condition only matches when left part is sorted\\n\\n            // Now there is 2 possibities \\n                    // i) Target lies in sorted part \\n                    // ii) Target does not lies in sorted part \\n            \\n            if(target>=nums[low] && target<=nums[mid]){\\n                //This condition means target is in sorted part \\n                // so we can eliminate right part of array\\n                high=mid-1;\\n            }\\n            else{\\n                //Target is not in sorted part \\n                low=mid+1;\\n            }\\n\\n        }\\n        else{\\n            // The above condition only matches when right part is sorted\\n\\n            // Now there is 2 possibities \\n                    // i) Target lies in sorted part \\n                    // ii) Target does not lies in sorted part \\n            \\n            if(target<=nums[high] && target>=nums[mid]){\\n                //This condition means target is in sorted part \\n                // so we can eliminate right part of array\\n              low=mid+1;\\n            }\\n            else{\\n                //Target is not in sorted part \\n                high=mid-1;\\n            }\\n\\n        }\\n    }\\nreturn -1;\\n}\\n}\\n"
                    },
                    {
                        "username": "chakravarthybatna46234",
                        "content": "nums =[5,1,3] target=5 ,output=-1 and expected 0 but the description say\\'s 1<=k<nums.length means k>=1 but here k is in index 0 why "
                    },
                    {
                        "username": "vavasor",
                        "content": "IT SAID \\'\\'POSSIBLY ROTATED\\'\\'"
                    },
                    {
                        "username": "user1889GX",
                        "content": "My binary search is failing for the test case i was trying [7,0,1,2,3,4,5,6] and looking for 0.\\ni guess i need to change the way I am doing binary search.\\n\\nSince my assumption is if the number is small it will be found at the right and not in left due to rotation\\nhence i changes the condition to if nums[mid] > target then i am advancing start = mid + 1 and it is less then i am decrementing end = mid -1 if target is less.\\n"
                    }
                ]
            },
            {
                "id": 2044999,
                "content": [
                    {
                        "username": "Rivo11",
                        "content": "Conclusion .. you try to identify your position in the left sorted or the right sorted array.....so you can compare the target with a range."
                    },
                    {
                        "username": "rmbidada",
                        "content": "Could you please help me to understand why this is not running ?\n `class Solution {\n    public int search(int[] nums, int target) {\n        int rotation = 0;\n        int low = 0, high = nums.length-1, mid;\n        // boolean matched = false;\n        \n        while(low <= high){\n            mid = (high + low)/2;\n            System.out.println(\"here I come\");\n            if(target == nums[mid]){\n                System.out.println(\"matched\");\n                return low;\n            }else if(nums[low] > nums[high] && nums[low] > target){\n                low = mid;            \n                mid = (low + high)/2;                \n                System.out.println(\"low : \" + low + \" mid: \" + mid + \" high: \"+ high );\n            }else if(nums[low] < target && nums[low] < nums[high]){\n                high = mid;\n                mid = (low + high)/2;\n            }\n        }\n        return -1;\n    }\n}`\n\nI am getting below response even after matching the target\nhere I come\nlow : 3 mid: 4 high: 6\nhere I come\nmatched\nhere I come\nlow : 3 mid: 4 high: 6\nhere I come\nlow : 4 mid: 5 high: 6...\n\nand its timing out due to infinite loop."
                    },
                    {
                        "username": "Spam_Musubi",
                        "content": "how is this in the medium difficulty??"
                    },
                    {
                        "username": "hermawangan39",
                        "content": "here\\'s some tips,\\ncheck if mid is in the left half or right half\\ncheck whether the target is in the left half or right half"
                    },
                    {
                        "username": "raghu_codes",
                        "content": "There are no constraints specified, so why not use the find function provided by the STL library , rather than using the binary search?"
                    },
                    {
                        "username": "Abu017",
                        "content": "class Solution {\\npublic:\\n    int search(vector<int>& nums, int target) {\\n    int start=0;\\n    int end=nums.size();\\n    while(start<=end){\\n        if(nums[start]==target){\\n            return target;\\n        }else if(nums[end]==target){\\n        return target;\\n        }\\n        start++;\\n        end--;\\n    }\\n    return -1;\\n }\\n};"
                    },
                    {
                        "username": "Ashu07",
                        "content": "class Solution {\\n    public int search(int[] nums, int target) {\\n        // ========= Uaing Linear Search================\\n    //     for(int i=0;i<nums.length;i++){\\n    //         if(nums[i]==target){\\n    //             return i;\\n    //         }\\n    //     }\\n    //     return -1;\\n    // }\\n\\n\\n    int low=0;\\n    int high=nums.length-1;\\n\\n    while(low<=high)\\n    {\\n        int mid=(low+high)/2;\\n        // If target is at middle index simply return mid\\n        if(nums[mid]==target){\\n            return mid;\\n        }\\n\\n        // Checking which part is sorted\\n        if(nums[low]<=nums[mid]){\\n            // The above condition only matches when left part is sorted\\n\\n            // Now there is 2 possibities \\n                    // i) Target lies in sorted part \\n                    // ii) Target does not lies in sorted part \\n            \\n            if(target>=nums[low] && target<=nums[mid]){\\n                //This condition means target is in sorted part \\n                // so we can eliminate right part of array\\n                high=mid-1;\\n            }\\n            else{\\n                //Target is not in sorted part \\n                low=mid+1;\\n            }\\n\\n        }\\n        else{\\n            // The above condition only matches when right part is sorted\\n\\n            // Now there is 2 possibities \\n                    // i) Target lies in sorted part \\n                    // ii) Target does not lies in sorted part \\n            \\n            if(target<=nums[high] && target>=nums[mid]){\\n                //This condition means target is in sorted part \\n                // so we can eliminate right part of array\\n              low=mid+1;\\n            }\\n            else{\\n                //Target is not in sorted part \\n                high=mid-1;\\n            }\\n\\n        }\\n    }\\nreturn -1;\\n}\\n}\\n"
                    },
                    {
                        "username": "chakravarthybatna46234",
                        "content": "nums =[5,1,3] target=5 ,output=-1 and expected 0 but the description say\\'s 1<=k<nums.length means k>=1 but here k is in index 0 why "
                    },
                    {
                        "username": "vavasor",
                        "content": "IT SAID \\'\\'POSSIBLY ROTATED\\'\\'"
                    },
                    {
                        "username": "user1889GX",
                        "content": "My binary search is failing for the test case i was trying [7,0,1,2,3,4,5,6] and looking for 0.\\ni guess i need to change the way I am doing binary search.\\n\\nSince my assumption is if the number is small it will be found at the right and not in left due to rotation\\nhence i changes the condition to if nums[mid] > target then i am advancing start = mid + 1 and it is less then i am decrementing end = mid -1 if target is less.\\n"
                    }
                ]
            },
            {
                "id": 2039423,
                "content": [
                    {
                        "username": "Rivo11",
                        "content": "Conclusion .. you try to identify your position in the left sorted or the right sorted array.....so you can compare the target with a range."
                    },
                    {
                        "username": "rmbidada",
                        "content": "Could you please help me to understand why this is not running ?\n `class Solution {\n    public int search(int[] nums, int target) {\n        int rotation = 0;\n        int low = 0, high = nums.length-1, mid;\n        // boolean matched = false;\n        \n        while(low <= high){\n            mid = (high + low)/2;\n            System.out.println(\"here I come\");\n            if(target == nums[mid]){\n                System.out.println(\"matched\");\n                return low;\n            }else if(nums[low] > nums[high] && nums[low] > target){\n                low = mid;            \n                mid = (low + high)/2;                \n                System.out.println(\"low : \" + low + \" mid: \" + mid + \" high: \"+ high );\n            }else if(nums[low] < target && nums[low] < nums[high]){\n                high = mid;\n                mid = (low + high)/2;\n            }\n        }\n        return -1;\n    }\n}`\n\nI am getting below response even after matching the target\nhere I come\nlow : 3 mid: 4 high: 6\nhere I come\nmatched\nhere I come\nlow : 3 mid: 4 high: 6\nhere I come\nlow : 4 mid: 5 high: 6...\n\nand its timing out due to infinite loop."
                    },
                    {
                        "username": "Spam_Musubi",
                        "content": "how is this in the medium difficulty??"
                    },
                    {
                        "username": "hermawangan39",
                        "content": "here\\'s some tips,\\ncheck if mid is in the left half or right half\\ncheck whether the target is in the left half or right half"
                    },
                    {
                        "username": "raghu_codes",
                        "content": "There are no constraints specified, so why not use the find function provided by the STL library , rather than using the binary search?"
                    },
                    {
                        "username": "Abu017",
                        "content": "class Solution {\\npublic:\\n    int search(vector<int>& nums, int target) {\\n    int start=0;\\n    int end=nums.size();\\n    while(start<=end){\\n        if(nums[start]==target){\\n            return target;\\n        }else if(nums[end]==target){\\n        return target;\\n        }\\n        start++;\\n        end--;\\n    }\\n    return -1;\\n }\\n};"
                    },
                    {
                        "username": "Ashu07",
                        "content": "class Solution {\\n    public int search(int[] nums, int target) {\\n        // ========= Uaing Linear Search================\\n    //     for(int i=0;i<nums.length;i++){\\n    //         if(nums[i]==target){\\n    //             return i;\\n    //         }\\n    //     }\\n    //     return -1;\\n    // }\\n\\n\\n    int low=0;\\n    int high=nums.length-1;\\n\\n    while(low<=high)\\n    {\\n        int mid=(low+high)/2;\\n        // If target is at middle index simply return mid\\n        if(nums[mid]==target){\\n            return mid;\\n        }\\n\\n        // Checking which part is sorted\\n        if(nums[low]<=nums[mid]){\\n            // The above condition only matches when left part is sorted\\n\\n            // Now there is 2 possibities \\n                    // i) Target lies in sorted part \\n                    // ii) Target does not lies in sorted part \\n            \\n            if(target>=nums[low] && target<=nums[mid]){\\n                //This condition means target is in sorted part \\n                // so we can eliminate right part of array\\n                high=mid-1;\\n            }\\n            else{\\n                //Target is not in sorted part \\n                low=mid+1;\\n            }\\n\\n        }\\n        else{\\n            // The above condition only matches when right part is sorted\\n\\n            // Now there is 2 possibities \\n                    // i) Target lies in sorted part \\n                    // ii) Target does not lies in sorted part \\n            \\n            if(target<=nums[high] && target>=nums[mid]){\\n                //This condition means target is in sorted part \\n                // so we can eliminate right part of array\\n              low=mid+1;\\n            }\\n            else{\\n                //Target is not in sorted part \\n                high=mid-1;\\n            }\\n\\n        }\\n    }\\nreturn -1;\\n}\\n}\\n"
                    },
                    {
                        "username": "chakravarthybatna46234",
                        "content": "nums =[5,1,3] target=5 ,output=-1 and expected 0 but the description say\\'s 1<=k<nums.length means k>=1 but here k is in index 0 why "
                    },
                    {
                        "username": "vavasor",
                        "content": "IT SAID \\'\\'POSSIBLY ROTATED\\'\\'"
                    },
                    {
                        "username": "user1889GX",
                        "content": "My binary search is failing for the test case i was trying [7,0,1,2,3,4,5,6] and looking for 0.\\ni guess i need to change the way I am doing binary search.\\n\\nSince my assumption is if the number is small it will be found at the right and not in left due to rotation\\nhence i changes the condition to if nums[mid] > target then i am advancing start = mid + 1 and it is less then i am decrementing end = mid -1 if target is less.\\n"
                    }
                ]
            },
            {
                "id": 2036407,
                "content": [
                    {
                        "username": "Rivo11",
                        "content": "Conclusion .. you try to identify your position in the left sorted or the right sorted array.....so you can compare the target with a range."
                    },
                    {
                        "username": "rmbidada",
                        "content": "Could you please help me to understand why this is not running ?\n `class Solution {\n    public int search(int[] nums, int target) {\n        int rotation = 0;\n        int low = 0, high = nums.length-1, mid;\n        // boolean matched = false;\n        \n        while(low <= high){\n            mid = (high + low)/2;\n            System.out.println(\"here I come\");\n            if(target == nums[mid]){\n                System.out.println(\"matched\");\n                return low;\n            }else if(nums[low] > nums[high] && nums[low] > target){\n                low = mid;            \n                mid = (low + high)/2;                \n                System.out.println(\"low : \" + low + \" mid: \" + mid + \" high: \"+ high );\n            }else if(nums[low] < target && nums[low] < nums[high]){\n                high = mid;\n                mid = (low + high)/2;\n            }\n        }\n        return -1;\n    }\n}`\n\nI am getting below response even after matching the target\nhere I come\nlow : 3 mid: 4 high: 6\nhere I come\nmatched\nhere I come\nlow : 3 mid: 4 high: 6\nhere I come\nlow : 4 mid: 5 high: 6...\n\nand its timing out due to infinite loop."
                    },
                    {
                        "username": "Spam_Musubi",
                        "content": "how is this in the medium difficulty??"
                    },
                    {
                        "username": "hermawangan39",
                        "content": "here\\'s some tips,\\ncheck if mid is in the left half or right half\\ncheck whether the target is in the left half or right half"
                    },
                    {
                        "username": "raghu_codes",
                        "content": "There are no constraints specified, so why not use the find function provided by the STL library , rather than using the binary search?"
                    },
                    {
                        "username": "Abu017",
                        "content": "class Solution {\\npublic:\\n    int search(vector<int>& nums, int target) {\\n    int start=0;\\n    int end=nums.size();\\n    while(start<=end){\\n        if(nums[start]==target){\\n            return target;\\n        }else if(nums[end]==target){\\n        return target;\\n        }\\n        start++;\\n        end--;\\n    }\\n    return -1;\\n }\\n};"
                    },
                    {
                        "username": "Ashu07",
                        "content": "class Solution {\\n    public int search(int[] nums, int target) {\\n        // ========= Uaing Linear Search================\\n    //     for(int i=0;i<nums.length;i++){\\n    //         if(nums[i]==target){\\n    //             return i;\\n    //         }\\n    //     }\\n    //     return -1;\\n    // }\\n\\n\\n    int low=0;\\n    int high=nums.length-1;\\n\\n    while(low<=high)\\n    {\\n        int mid=(low+high)/2;\\n        // If target is at middle index simply return mid\\n        if(nums[mid]==target){\\n            return mid;\\n        }\\n\\n        // Checking which part is sorted\\n        if(nums[low]<=nums[mid]){\\n            // The above condition only matches when left part is sorted\\n\\n            // Now there is 2 possibities \\n                    // i) Target lies in sorted part \\n                    // ii) Target does not lies in sorted part \\n            \\n            if(target>=nums[low] && target<=nums[mid]){\\n                //This condition means target is in sorted part \\n                // so we can eliminate right part of array\\n                high=mid-1;\\n            }\\n            else{\\n                //Target is not in sorted part \\n                low=mid+1;\\n            }\\n\\n        }\\n        else{\\n            // The above condition only matches when right part is sorted\\n\\n            // Now there is 2 possibities \\n                    // i) Target lies in sorted part \\n                    // ii) Target does not lies in sorted part \\n            \\n            if(target<=nums[high] && target>=nums[mid]){\\n                //This condition means target is in sorted part \\n                // so we can eliminate right part of array\\n              low=mid+1;\\n            }\\n            else{\\n                //Target is not in sorted part \\n                high=mid-1;\\n            }\\n\\n        }\\n    }\\nreturn -1;\\n}\\n}\\n"
                    },
                    {
                        "username": "chakravarthybatna46234",
                        "content": "nums =[5,1,3] target=5 ,output=-1 and expected 0 but the description say\\'s 1<=k<nums.length means k>=1 but here k is in index 0 why "
                    },
                    {
                        "username": "vavasor",
                        "content": "IT SAID \\'\\'POSSIBLY ROTATED\\'\\'"
                    },
                    {
                        "username": "user1889GX",
                        "content": "My binary search is failing for the test case i was trying [7,0,1,2,3,4,5,6] and looking for 0.\\ni guess i need to change the way I am doing binary search.\\n\\nSince my assumption is if the number is small it will be found at the right and not in left due to rotation\\nhence i changes the condition to if nums[mid] > target then i am advancing start = mid + 1 and it is less then i am decrementing end = mid -1 if target is less.\\n"
                    }
                ]
            },
            {
                "id": 2030239,
                "content": [
                    {
                        "username": "Rivo11",
                        "content": "Conclusion .. you try to identify your position in the left sorted or the right sorted array.....so you can compare the target with a range."
                    },
                    {
                        "username": "rmbidada",
                        "content": "Could you please help me to understand why this is not running ?\n `class Solution {\n    public int search(int[] nums, int target) {\n        int rotation = 0;\n        int low = 0, high = nums.length-1, mid;\n        // boolean matched = false;\n        \n        while(low <= high){\n            mid = (high + low)/2;\n            System.out.println(\"here I come\");\n            if(target == nums[mid]){\n                System.out.println(\"matched\");\n                return low;\n            }else if(nums[low] > nums[high] && nums[low] > target){\n                low = mid;            \n                mid = (low + high)/2;                \n                System.out.println(\"low : \" + low + \" mid: \" + mid + \" high: \"+ high );\n            }else if(nums[low] < target && nums[low] < nums[high]){\n                high = mid;\n                mid = (low + high)/2;\n            }\n        }\n        return -1;\n    }\n}`\n\nI am getting below response even after matching the target\nhere I come\nlow : 3 mid: 4 high: 6\nhere I come\nmatched\nhere I come\nlow : 3 mid: 4 high: 6\nhere I come\nlow : 4 mid: 5 high: 6...\n\nand its timing out due to infinite loop."
                    },
                    {
                        "username": "Spam_Musubi",
                        "content": "how is this in the medium difficulty??"
                    },
                    {
                        "username": "hermawangan39",
                        "content": "here\\'s some tips,\\ncheck if mid is in the left half or right half\\ncheck whether the target is in the left half or right half"
                    },
                    {
                        "username": "raghu_codes",
                        "content": "There are no constraints specified, so why not use the find function provided by the STL library , rather than using the binary search?"
                    },
                    {
                        "username": "Abu017",
                        "content": "class Solution {\\npublic:\\n    int search(vector<int>& nums, int target) {\\n    int start=0;\\n    int end=nums.size();\\n    while(start<=end){\\n        if(nums[start]==target){\\n            return target;\\n        }else if(nums[end]==target){\\n        return target;\\n        }\\n        start++;\\n        end--;\\n    }\\n    return -1;\\n }\\n};"
                    },
                    {
                        "username": "Ashu07",
                        "content": "class Solution {\\n    public int search(int[] nums, int target) {\\n        // ========= Uaing Linear Search================\\n    //     for(int i=0;i<nums.length;i++){\\n    //         if(nums[i]==target){\\n    //             return i;\\n    //         }\\n    //     }\\n    //     return -1;\\n    // }\\n\\n\\n    int low=0;\\n    int high=nums.length-1;\\n\\n    while(low<=high)\\n    {\\n        int mid=(low+high)/2;\\n        // If target is at middle index simply return mid\\n        if(nums[mid]==target){\\n            return mid;\\n        }\\n\\n        // Checking which part is sorted\\n        if(nums[low]<=nums[mid]){\\n            // The above condition only matches when left part is sorted\\n\\n            // Now there is 2 possibities \\n                    // i) Target lies in sorted part \\n                    // ii) Target does not lies in sorted part \\n            \\n            if(target>=nums[low] && target<=nums[mid]){\\n                //This condition means target is in sorted part \\n                // so we can eliminate right part of array\\n                high=mid-1;\\n            }\\n            else{\\n                //Target is not in sorted part \\n                low=mid+1;\\n            }\\n\\n        }\\n        else{\\n            // The above condition only matches when right part is sorted\\n\\n            // Now there is 2 possibities \\n                    // i) Target lies in sorted part \\n                    // ii) Target does not lies in sorted part \\n            \\n            if(target<=nums[high] && target>=nums[mid]){\\n                //This condition means target is in sorted part \\n                // so we can eliminate right part of array\\n              low=mid+1;\\n            }\\n            else{\\n                //Target is not in sorted part \\n                high=mid-1;\\n            }\\n\\n        }\\n    }\\nreturn -1;\\n}\\n}\\n"
                    },
                    {
                        "username": "chakravarthybatna46234",
                        "content": "nums =[5,1,3] target=5 ,output=-1 and expected 0 but the description say\\'s 1<=k<nums.length means k>=1 but here k is in index 0 why "
                    },
                    {
                        "username": "vavasor",
                        "content": "IT SAID \\'\\'POSSIBLY ROTATED\\'\\'"
                    },
                    {
                        "username": "user1889GX",
                        "content": "My binary search is failing for the test case i was trying [7,0,1,2,3,4,5,6] and looking for 0.\\ni guess i need to change the way I am doing binary search.\\n\\nSince my assumption is if the number is small it will be found at the right and not in left due to rotation\\nhence i changes the condition to if nums[mid] > target then i am advancing start = mid + 1 and it is less then i am decrementing end = mid -1 if target is less.\\n"
                    }
                ]
            },
            {
                "id": 2023620,
                "content": [
                    {
                        "username": "Rivo11",
                        "content": "Conclusion .. you try to identify your position in the left sorted or the right sorted array.....so you can compare the target with a range."
                    },
                    {
                        "username": "rmbidada",
                        "content": "Could you please help me to understand why this is not running ?\n `class Solution {\n    public int search(int[] nums, int target) {\n        int rotation = 0;\n        int low = 0, high = nums.length-1, mid;\n        // boolean matched = false;\n        \n        while(low <= high){\n            mid = (high + low)/2;\n            System.out.println(\"here I come\");\n            if(target == nums[mid]){\n                System.out.println(\"matched\");\n                return low;\n            }else if(nums[low] > nums[high] && nums[low] > target){\n                low = mid;            \n                mid = (low + high)/2;                \n                System.out.println(\"low : \" + low + \" mid: \" + mid + \" high: \"+ high );\n            }else if(nums[low] < target && nums[low] < nums[high]){\n                high = mid;\n                mid = (low + high)/2;\n            }\n        }\n        return -1;\n    }\n}`\n\nI am getting below response even after matching the target\nhere I come\nlow : 3 mid: 4 high: 6\nhere I come\nmatched\nhere I come\nlow : 3 mid: 4 high: 6\nhere I come\nlow : 4 mid: 5 high: 6...\n\nand its timing out due to infinite loop."
                    },
                    {
                        "username": "Spam_Musubi",
                        "content": "how is this in the medium difficulty??"
                    },
                    {
                        "username": "hermawangan39",
                        "content": "here\\'s some tips,\\ncheck if mid is in the left half or right half\\ncheck whether the target is in the left half or right half"
                    },
                    {
                        "username": "raghu_codes",
                        "content": "There are no constraints specified, so why not use the find function provided by the STL library , rather than using the binary search?"
                    },
                    {
                        "username": "Abu017",
                        "content": "class Solution {\\npublic:\\n    int search(vector<int>& nums, int target) {\\n    int start=0;\\n    int end=nums.size();\\n    while(start<=end){\\n        if(nums[start]==target){\\n            return target;\\n        }else if(nums[end]==target){\\n        return target;\\n        }\\n        start++;\\n        end--;\\n    }\\n    return -1;\\n }\\n};"
                    },
                    {
                        "username": "Ashu07",
                        "content": "class Solution {\\n    public int search(int[] nums, int target) {\\n        // ========= Uaing Linear Search================\\n    //     for(int i=0;i<nums.length;i++){\\n    //         if(nums[i]==target){\\n    //             return i;\\n    //         }\\n    //     }\\n    //     return -1;\\n    // }\\n\\n\\n    int low=0;\\n    int high=nums.length-1;\\n\\n    while(low<=high)\\n    {\\n        int mid=(low+high)/2;\\n        // If target is at middle index simply return mid\\n        if(nums[mid]==target){\\n            return mid;\\n        }\\n\\n        // Checking which part is sorted\\n        if(nums[low]<=nums[mid]){\\n            // The above condition only matches when left part is sorted\\n\\n            // Now there is 2 possibities \\n                    // i) Target lies in sorted part \\n                    // ii) Target does not lies in sorted part \\n            \\n            if(target>=nums[low] && target<=nums[mid]){\\n                //This condition means target is in sorted part \\n                // so we can eliminate right part of array\\n                high=mid-1;\\n            }\\n            else{\\n                //Target is not in sorted part \\n                low=mid+1;\\n            }\\n\\n        }\\n        else{\\n            // The above condition only matches when right part is sorted\\n\\n            // Now there is 2 possibities \\n                    // i) Target lies in sorted part \\n                    // ii) Target does not lies in sorted part \\n            \\n            if(target<=nums[high] && target>=nums[mid]){\\n                //This condition means target is in sorted part \\n                // so we can eliminate right part of array\\n              low=mid+1;\\n            }\\n            else{\\n                //Target is not in sorted part \\n                high=mid-1;\\n            }\\n\\n        }\\n    }\\nreturn -1;\\n}\\n}\\n"
                    },
                    {
                        "username": "chakravarthybatna46234",
                        "content": "nums =[5,1,3] target=5 ,output=-1 and expected 0 but the description say\\'s 1<=k<nums.length means k>=1 but here k is in index 0 why "
                    },
                    {
                        "username": "vavasor",
                        "content": "IT SAID \\'\\'POSSIBLY ROTATED\\'\\'"
                    },
                    {
                        "username": "user1889GX",
                        "content": "My binary search is failing for the test case i was trying [7,0,1,2,3,4,5,6] and looking for 0.\\ni guess i need to change the way I am doing binary search.\\n\\nSince my assumption is if the number is small it will be found at the right and not in left due to rotation\\nhence i changes the condition to if nums[mid] > target then i am advancing start = mid + 1 and it is less then i am decrementing end = mid -1 if target is less.\\n"
                    }
                ]
            },
            {
                "id": 2019312,
                "content": [
                    {
                        "username": "Rivo11",
                        "content": "Conclusion .. you try to identify your position in the left sorted or the right sorted array.....so you can compare the target with a range."
                    },
                    {
                        "username": "rmbidada",
                        "content": "Could you please help me to understand why this is not running ?\n `class Solution {\n    public int search(int[] nums, int target) {\n        int rotation = 0;\n        int low = 0, high = nums.length-1, mid;\n        // boolean matched = false;\n        \n        while(low <= high){\n            mid = (high + low)/2;\n            System.out.println(\"here I come\");\n            if(target == nums[mid]){\n                System.out.println(\"matched\");\n                return low;\n            }else if(nums[low] > nums[high] && nums[low] > target){\n                low = mid;            \n                mid = (low + high)/2;                \n                System.out.println(\"low : \" + low + \" mid: \" + mid + \" high: \"+ high );\n            }else if(nums[low] < target && nums[low] < nums[high]){\n                high = mid;\n                mid = (low + high)/2;\n            }\n        }\n        return -1;\n    }\n}`\n\nI am getting below response even after matching the target\nhere I come\nlow : 3 mid: 4 high: 6\nhere I come\nmatched\nhere I come\nlow : 3 mid: 4 high: 6\nhere I come\nlow : 4 mid: 5 high: 6...\n\nand its timing out due to infinite loop."
                    },
                    {
                        "username": "Spam_Musubi",
                        "content": "how is this in the medium difficulty??"
                    },
                    {
                        "username": "hermawangan39",
                        "content": "here\\'s some tips,\\ncheck if mid is in the left half or right half\\ncheck whether the target is in the left half or right half"
                    },
                    {
                        "username": "raghu_codes",
                        "content": "There are no constraints specified, so why not use the find function provided by the STL library , rather than using the binary search?"
                    },
                    {
                        "username": "Abu017",
                        "content": "class Solution {\\npublic:\\n    int search(vector<int>& nums, int target) {\\n    int start=0;\\n    int end=nums.size();\\n    while(start<=end){\\n        if(nums[start]==target){\\n            return target;\\n        }else if(nums[end]==target){\\n        return target;\\n        }\\n        start++;\\n        end--;\\n    }\\n    return -1;\\n }\\n};"
                    },
                    {
                        "username": "Ashu07",
                        "content": "class Solution {\\n    public int search(int[] nums, int target) {\\n        // ========= Uaing Linear Search================\\n    //     for(int i=0;i<nums.length;i++){\\n    //         if(nums[i]==target){\\n    //             return i;\\n    //         }\\n    //     }\\n    //     return -1;\\n    // }\\n\\n\\n    int low=0;\\n    int high=nums.length-1;\\n\\n    while(low<=high)\\n    {\\n        int mid=(low+high)/2;\\n        // If target is at middle index simply return mid\\n        if(nums[mid]==target){\\n            return mid;\\n        }\\n\\n        // Checking which part is sorted\\n        if(nums[low]<=nums[mid]){\\n            // The above condition only matches when left part is sorted\\n\\n            // Now there is 2 possibities \\n                    // i) Target lies in sorted part \\n                    // ii) Target does not lies in sorted part \\n            \\n            if(target>=nums[low] && target<=nums[mid]){\\n                //This condition means target is in sorted part \\n                // so we can eliminate right part of array\\n                high=mid-1;\\n            }\\n            else{\\n                //Target is not in sorted part \\n                low=mid+1;\\n            }\\n\\n        }\\n        else{\\n            // The above condition only matches when right part is sorted\\n\\n            // Now there is 2 possibities \\n                    // i) Target lies in sorted part \\n                    // ii) Target does not lies in sorted part \\n            \\n            if(target<=nums[high] && target>=nums[mid]){\\n                //This condition means target is in sorted part \\n                // so we can eliminate right part of array\\n              low=mid+1;\\n            }\\n            else{\\n                //Target is not in sorted part \\n                high=mid-1;\\n            }\\n\\n        }\\n    }\\nreturn -1;\\n}\\n}\\n"
                    },
                    {
                        "username": "chakravarthybatna46234",
                        "content": "nums =[5,1,3] target=5 ,output=-1 and expected 0 but the description say\\'s 1<=k<nums.length means k>=1 but here k is in index 0 why "
                    },
                    {
                        "username": "vavasor",
                        "content": "IT SAID \\'\\'POSSIBLY ROTATED\\'\\'"
                    },
                    {
                        "username": "user1889GX",
                        "content": "My binary search is failing for the test case i was trying [7,0,1,2,3,4,5,6] and looking for 0.\\ni guess i need to change the way I am doing binary search.\\n\\nSince my assumption is if the number is small it will be found at the right and not in left due to rotation\\nhence i changes the condition to if nums[mid] > target then i am advancing start = mid + 1 and it is less then i am decrementing end = mid -1 if target is less.\\n"
                    }
                ]
            },
            {
                "id": 2018099,
                "content": [
                    {
                        "username": "Rivo11",
                        "content": "Conclusion .. you try to identify your position in the left sorted or the right sorted array.....so you can compare the target with a range."
                    },
                    {
                        "username": "rmbidada",
                        "content": "Could you please help me to understand why this is not running ?\n `class Solution {\n    public int search(int[] nums, int target) {\n        int rotation = 0;\n        int low = 0, high = nums.length-1, mid;\n        // boolean matched = false;\n        \n        while(low <= high){\n            mid = (high + low)/2;\n            System.out.println(\"here I come\");\n            if(target == nums[mid]){\n                System.out.println(\"matched\");\n                return low;\n            }else if(nums[low] > nums[high] && nums[low] > target){\n                low = mid;            \n                mid = (low + high)/2;                \n                System.out.println(\"low : \" + low + \" mid: \" + mid + \" high: \"+ high );\n            }else if(nums[low] < target && nums[low] < nums[high]){\n                high = mid;\n                mid = (low + high)/2;\n            }\n        }\n        return -1;\n    }\n}`\n\nI am getting below response even after matching the target\nhere I come\nlow : 3 mid: 4 high: 6\nhere I come\nmatched\nhere I come\nlow : 3 mid: 4 high: 6\nhere I come\nlow : 4 mid: 5 high: 6...\n\nand its timing out due to infinite loop."
                    },
                    {
                        "username": "Spam_Musubi",
                        "content": "how is this in the medium difficulty??"
                    },
                    {
                        "username": "hermawangan39",
                        "content": "here\\'s some tips,\\ncheck if mid is in the left half or right half\\ncheck whether the target is in the left half or right half"
                    },
                    {
                        "username": "raghu_codes",
                        "content": "There are no constraints specified, so why not use the find function provided by the STL library , rather than using the binary search?"
                    },
                    {
                        "username": "Abu017",
                        "content": "class Solution {\\npublic:\\n    int search(vector<int>& nums, int target) {\\n    int start=0;\\n    int end=nums.size();\\n    while(start<=end){\\n        if(nums[start]==target){\\n            return target;\\n        }else if(nums[end]==target){\\n        return target;\\n        }\\n        start++;\\n        end--;\\n    }\\n    return -1;\\n }\\n};"
                    },
                    {
                        "username": "Ashu07",
                        "content": "class Solution {\\n    public int search(int[] nums, int target) {\\n        // ========= Uaing Linear Search================\\n    //     for(int i=0;i<nums.length;i++){\\n    //         if(nums[i]==target){\\n    //             return i;\\n    //         }\\n    //     }\\n    //     return -1;\\n    // }\\n\\n\\n    int low=0;\\n    int high=nums.length-1;\\n\\n    while(low<=high)\\n    {\\n        int mid=(low+high)/2;\\n        // If target is at middle index simply return mid\\n        if(nums[mid]==target){\\n            return mid;\\n        }\\n\\n        // Checking which part is sorted\\n        if(nums[low]<=nums[mid]){\\n            // The above condition only matches when left part is sorted\\n\\n            // Now there is 2 possibities \\n                    // i) Target lies in sorted part \\n                    // ii) Target does not lies in sorted part \\n            \\n            if(target>=nums[low] && target<=nums[mid]){\\n                //This condition means target is in sorted part \\n                // so we can eliminate right part of array\\n                high=mid-1;\\n            }\\n            else{\\n                //Target is not in sorted part \\n                low=mid+1;\\n            }\\n\\n        }\\n        else{\\n            // The above condition only matches when right part is sorted\\n\\n            // Now there is 2 possibities \\n                    // i) Target lies in sorted part \\n                    // ii) Target does not lies in sorted part \\n            \\n            if(target<=nums[high] && target>=nums[mid]){\\n                //This condition means target is in sorted part \\n                // so we can eliminate right part of array\\n              low=mid+1;\\n            }\\n            else{\\n                //Target is not in sorted part \\n                high=mid-1;\\n            }\\n\\n        }\\n    }\\nreturn -1;\\n}\\n}\\n"
                    },
                    {
                        "username": "chakravarthybatna46234",
                        "content": "nums =[5,1,3] target=5 ,output=-1 and expected 0 but the description say\\'s 1<=k<nums.length means k>=1 but here k is in index 0 why "
                    },
                    {
                        "username": "vavasor",
                        "content": "IT SAID \\'\\'POSSIBLY ROTATED\\'\\'"
                    },
                    {
                        "username": "user1889GX",
                        "content": "My binary search is failing for the test case i was trying [7,0,1,2,3,4,5,6] and looking for 0.\\ni guess i need to change the way I am doing binary search.\\n\\nSince my assumption is if the number is small it will be found at the right and not in left due to rotation\\nhence i changes the condition to if nums[mid] > target then i am advancing start = mid + 1 and it is less then i am decrementing end = mid -1 if target is less.\\n"
                    }
                ]
            },
            {
                "id": 2017805,
                "content": [
                    {
                        "username": "Rivo11",
                        "content": "Conclusion .. you try to identify your position in the left sorted or the right sorted array.....so you can compare the target with a range."
                    },
                    {
                        "username": "rmbidada",
                        "content": "Could you please help me to understand why this is not running ?\n `class Solution {\n    public int search(int[] nums, int target) {\n        int rotation = 0;\n        int low = 0, high = nums.length-1, mid;\n        // boolean matched = false;\n        \n        while(low <= high){\n            mid = (high + low)/2;\n            System.out.println(\"here I come\");\n            if(target == nums[mid]){\n                System.out.println(\"matched\");\n                return low;\n            }else if(nums[low] > nums[high] && nums[low] > target){\n                low = mid;            \n                mid = (low + high)/2;                \n                System.out.println(\"low : \" + low + \" mid: \" + mid + \" high: \"+ high );\n            }else if(nums[low] < target && nums[low] < nums[high]){\n                high = mid;\n                mid = (low + high)/2;\n            }\n        }\n        return -1;\n    }\n}`\n\nI am getting below response even after matching the target\nhere I come\nlow : 3 mid: 4 high: 6\nhere I come\nmatched\nhere I come\nlow : 3 mid: 4 high: 6\nhere I come\nlow : 4 mid: 5 high: 6...\n\nand its timing out due to infinite loop."
                    },
                    {
                        "username": "Spam_Musubi",
                        "content": "how is this in the medium difficulty??"
                    },
                    {
                        "username": "hermawangan39",
                        "content": "here\\'s some tips,\\ncheck if mid is in the left half or right half\\ncheck whether the target is in the left half or right half"
                    },
                    {
                        "username": "raghu_codes",
                        "content": "There are no constraints specified, so why not use the find function provided by the STL library , rather than using the binary search?"
                    },
                    {
                        "username": "Abu017",
                        "content": "class Solution {\\npublic:\\n    int search(vector<int>& nums, int target) {\\n    int start=0;\\n    int end=nums.size();\\n    while(start<=end){\\n        if(nums[start]==target){\\n            return target;\\n        }else if(nums[end]==target){\\n        return target;\\n        }\\n        start++;\\n        end--;\\n    }\\n    return -1;\\n }\\n};"
                    },
                    {
                        "username": "Ashu07",
                        "content": "class Solution {\\n    public int search(int[] nums, int target) {\\n        // ========= Uaing Linear Search================\\n    //     for(int i=0;i<nums.length;i++){\\n    //         if(nums[i]==target){\\n    //             return i;\\n    //         }\\n    //     }\\n    //     return -1;\\n    // }\\n\\n\\n    int low=0;\\n    int high=nums.length-1;\\n\\n    while(low<=high)\\n    {\\n        int mid=(low+high)/2;\\n        // If target is at middle index simply return mid\\n        if(nums[mid]==target){\\n            return mid;\\n        }\\n\\n        // Checking which part is sorted\\n        if(nums[low]<=nums[mid]){\\n            // The above condition only matches when left part is sorted\\n\\n            // Now there is 2 possibities \\n                    // i) Target lies in sorted part \\n                    // ii) Target does not lies in sorted part \\n            \\n            if(target>=nums[low] && target<=nums[mid]){\\n                //This condition means target is in sorted part \\n                // so we can eliminate right part of array\\n                high=mid-1;\\n            }\\n            else{\\n                //Target is not in sorted part \\n                low=mid+1;\\n            }\\n\\n        }\\n        else{\\n            // The above condition only matches when right part is sorted\\n\\n            // Now there is 2 possibities \\n                    // i) Target lies in sorted part \\n                    // ii) Target does not lies in sorted part \\n            \\n            if(target<=nums[high] && target>=nums[mid]){\\n                //This condition means target is in sorted part \\n                // so we can eliminate right part of array\\n              low=mid+1;\\n            }\\n            else{\\n                //Target is not in sorted part \\n                high=mid-1;\\n            }\\n\\n        }\\n    }\\nreturn -1;\\n}\\n}\\n"
                    },
                    {
                        "username": "chakravarthybatna46234",
                        "content": "nums =[5,1,3] target=5 ,output=-1 and expected 0 but the description say\\'s 1<=k<nums.length means k>=1 but here k is in index 0 why "
                    },
                    {
                        "username": "vavasor",
                        "content": "IT SAID \\'\\'POSSIBLY ROTATED\\'\\'"
                    },
                    {
                        "username": "user1889GX",
                        "content": "My binary search is failing for the test case i was trying [7,0,1,2,3,4,5,6] and looking for 0.\\ni guess i need to change the way I am doing binary search.\\n\\nSince my assumption is if the number is small it will be found at the right and not in left due to rotation\\nhence i changes the condition to if nums[mid] > target then i am advancing start = mid + 1 and it is less then i am decrementing end = mid -1 if target is less.\\n"
                    }
                ]
            },
            {
                "id": 2016540,
                "content": [
                    {
                        "username": "Rivo11",
                        "content": "Conclusion .. you try to identify your position in the left sorted or the right sorted array.....so you can compare the target with a range."
                    },
                    {
                        "username": "rmbidada",
                        "content": "Could you please help me to understand why this is not running ?\n `class Solution {\n    public int search(int[] nums, int target) {\n        int rotation = 0;\n        int low = 0, high = nums.length-1, mid;\n        // boolean matched = false;\n        \n        while(low <= high){\n            mid = (high + low)/2;\n            System.out.println(\"here I come\");\n            if(target == nums[mid]){\n                System.out.println(\"matched\");\n                return low;\n            }else if(nums[low] > nums[high] && nums[low] > target){\n                low = mid;            \n                mid = (low + high)/2;                \n                System.out.println(\"low : \" + low + \" mid: \" + mid + \" high: \"+ high );\n            }else if(nums[low] < target && nums[low] < nums[high]){\n                high = mid;\n                mid = (low + high)/2;\n            }\n        }\n        return -1;\n    }\n}`\n\nI am getting below response even after matching the target\nhere I come\nlow : 3 mid: 4 high: 6\nhere I come\nmatched\nhere I come\nlow : 3 mid: 4 high: 6\nhere I come\nlow : 4 mid: 5 high: 6...\n\nand its timing out due to infinite loop."
                    },
                    {
                        "username": "Spam_Musubi",
                        "content": "how is this in the medium difficulty??"
                    },
                    {
                        "username": "hermawangan39",
                        "content": "here\\'s some tips,\\ncheck if mid is in the left half or right half\\ncheck whether the target is in the left half or right half"
                    },
                    {
                        "username": "raghu_codes",
                        "content": "There are no constraints specified, so why not use the find function provided by the STL library , rather than using the binary search?"
                    },
                    {
                        "username": "Abu017",
                        "content": "class Solution {\\npublic:\\n    int search(vector<int>& nums, int target) {\\n    int start=0;\\n    int end=nums.size();\\n    while(start<=end){\\n        if(nums[start]==target){\\n            return target;\\n        }else if(nums[end]==target){\\n        return target;\\n        }\\n        start++;\\n        end--;\\n    }\\n    return -1;\\n }\\n};"
                    },
                    {
                        "username": "Ashu07",
                        "content": "class Solution {\\n    public int search(int[] nums, int target) {\\n        // ========= Uaing Linear Search================\\n    //     for(int i=0;i<nums.length;i++){\\n    //         if(nums[i]==target){\\n    //             return i;\\n    //         }\\n    //     }\\n    //     return -1;\\n    // }\\n\\n\\n    int low=0;\\n    int high=nums.length-1;\\n\\n    while(low<=high)\\n    {\\n        int mid=(low+high)/2;\\n        // If target is at middle index simply return mid\\n        if(nums[mid]==target){\\n            return mid;\\n        }\\n\\n        // Checking which part is sorted\\n        if(nums[low]<=nums[mid]){\\n            // The above condition only matches when left part is sorted\\n\\n            // Now there is 2 possibities \\n                    // i) Target lies in sorted part \\n                    // ii) Target does not lies in sorted part \\n            \\n            if(target>=nums[low] && target<=nums[mid]){\\n                //This condition means target is in sorted part \\n                // so we can eliminate right part of array\\n                high=mid-1;\\n            }\\n            else{\\n                //Target is not in sorted part \\n                low=mid+1;\\n            }\\n\\n        }\\n        else{\\n            // The above condition only matches when right part is sorted\\n\\n            // Now there is 2 possibities \\n                    // i) Target lies in sorted part \\n                    // ii) Target does not lies in sorted part \\n            \\n            if(target<=nums[high] && target>=nums[mid]){\\n                //This condition means target is in sorted part \\n                // so we can eliminate right part of array\\n              low=mid+1;\\n            }\\n            else{\\n                //Target is not in sorted part \\n                high=mid-1;\\n            }\\n\\n        }\\n    }\\nreturn -1;\\n}\\n}\\n"
                    },
                    {
                        "username": "chakravarthybatna46234",
                        "content": "nums =[5,1,3] target=5 ,output=-1 and expected 0 but the description say\\'s 1<=k<nums.length means k>=1 but here k is in index 0 why "
                    },
                    {
                        "username": "vavasor",
                        "content": "IT SAID \\'\\'POSSIBLY ROTATED\\'\\'"
                    },
                    {
                        "username": "user1889GX",
                        "content": "My binary search is failing for the test case i was trying [7,0,1,2,3,4,5,6] and looking for 0.\\ni guess i need to change the way I am doing binary search.\\n\\nSince my assumption is if the number is small it will be found at the right and not in left due to rotation\\nhence i changes the condition to if nums[mid] > target then i am advancing start = mid + 1 and it is less then i am decrementing end = mid -1 if target is less.\\n"
                    }
                ]
            },
            {
                "id": 2007649,
                "content": [
                    {
                        "username": "sriganesh777",
                        "content": "why is the length constraint so low?\\n"
                    },
                    {
                        "username": "hamburgercookieicecream",
                        "content": "I dont understand the first test case nor the problem in general. Shouldn\\'t the output of the first test case be index 0 instead of index 4, since you are given nums after the rotation?"
                    },
                    {
                        "username": "aeinha_sha",
                        "content": "[@hamburgercookieicecream](/hamburgercookieicecream) see here, the rotation might happen or might not. What we are interested is that we are able to solve this problem using binary search. As you can see,the first half before 0 is in ascending order in the first case. After 0 ,it is still in ascending order. Normally we can\\'t apply binary search ,but we will be using binary search by using some tricks. If you have a good grasp on find the peak value of a rotated array, then you will use these peak value as pointers to your binary search. If your target lies in between index 0 and peak. we will use binary Search in that. or else we will use on the other half of the array i.e., peak+1 and arr.size()-1\\n "
                    },
                    {
                        "username": "hamburgercookieicecream",
                        "content": "[@aeinha_sha](/aeinha_sha) Ok but from the first test case it is not in ascending order, therefore we know that it has been rotated. After rotation, doesn\\'t the 0 change from the zeroeth index to the fourth index? So if we are not returning its original index, how is this problem different from just taking in an array and finding the index of the item you are given. How does rotation come into play?"
                    },
                    {
                        "username": "aeinha_sha",
                        "content": "You need to return the index of 0 (which is 4) hence 4 is the answer. A arr named nums can be either rotated or not and we need to find a target in that array called nums . In order to solve this problem you need to understand the idea of pivot point and Binary Search. Then, you can tackle this problem."
                    },
                    {
                        "username": "natitati",
                        "content": "I remember like 2 months i wasn\\'t able to solve it... I was too afraid to try. Today, I was able to solve it quite easily... Thanks Leetcode, for making me progress so much. Also nice edge cases.\\n\\nFor anyone struggling, try the following:\\n-Find the pivot index using binary search (which will be the smallest value in he array one found)\\n-Run regular binary search, but on each check, add the pivot as an offset (don\\'t forget to mod by the size!)"
                    },
                    {
                        "username": "natitati",
                        "content": "Suppose the example array in the question. You found the pivot - it\\'s 4. Now perform binary search: low = 0, high = nums.size() = 7.\\nmid would be 3, which is 0, which obviously isn\\'t the mid value. We add the pivot, since the array was rotated. so 3 + 4 = 7. Mod by 7 since it exceeds the size of the array - this gives the effect of rotation. so we get to index 0, which is 4, which is the actual mid value (if the array was regulary sorted.)."
                    },
                    {
                        "username": "aeinha_sha",
                        "content": "add the pivot as an offset (don\\'t forget to mod by the size!) . can you explain this line?"
                    },
                    {
                        "username": "lacnoskillz",
                        "content": "Basically, writing your own custom function instead of using indexOf (javascript)"
                    },
                    {
                        "username": "jasurbekabdunazarov111",
                        "content": "in C#\\npublic class Solution {\\n    public int Search(int[] nums, int target) {\\n        int low = 0, high = nums.Length - 1;\\n\\n        while (low <= high) {\\n            int mid = (low + high) / 2;\\n\\n            if (nums[mid] == target) {\\n                return mid;\\n            }\\n\\n            if (nums[low] <= nums[mid]) {\\n                if (nums[low] <= target && target < nums[mid]) {\\n                    high = mid - 1;\\n                } else {\\n                    low = mid + 1;\\n                }\\n            } else {\\n                if (nums[mid] < target && target <= nums[high]) {\\n                    low = mid + 1;\\n                } else {\\n                    high = mid - 1;\\n                }\\n            }\\n        }\\n\\n        return -1;\\n    }\\n}\\n"
                    },
                    {
                        "username": "awasthivarsha0710",
                        "content": "Just do binary search ....and you will beat 73% of the solutions in terms of time complexity."
                    },
                    {
                        "username": "roman-mc",
                        "content": "Test cases are passing even for O(n) solutions, which shouldn't be passing"
                    },
                    {
                        "username": "hp333854",
                        "content": "In this problem what is the twist here? I really don\\'t get can anyone tell me?"
                    },
                    {
                        "username": "vishal_246",
                        "content": "can any explain me how we use constraints in this question using binary search(c++) . i just started programming so i don,t have much knowledge of constraints!!"
                    },
                    {
                        "username": "brycedoeswhat",
                        "content": "I really don\\'t understand this problem? are you not allowed to just i++ over the entire vector until you reach the target if not return -1? is the challenge to just make it most efficient? I see people posting insane code but it could be solved using 1 for loop?"
                    },
                    {
                        "username": "shreyarora1000",
                        "content": "Yep, you must write an algorithm with O(log n) runtime complexity."
                    }
                ]
            },
            {
                "id": 2006187,
                "content": [
                    {
                        "username": "sriganesh777",
                        "content": "why is the length constraint so low?\\n"
                    },
                    {
                        "username": "hamburgercookieicecream",
                        "content": "I dont understand the first test case nor the problem in general. Shouldn\\'t the output of the first test case be index 0 instead of index 4, since you are given nums after the rotation?"
                    },
                    {
                        "username": "aeinha_sha",
                        "content": "[@hamburgercookieicecream](/hamburgercookieicecream) see here, the rotation might happen or might not. What we are interested is that we are able to solve this problem using binary search. As you can see,the first half before 0 is in ascending order in the first case. After 0 ,it is still in ascending order. Normally we can\\'t apply binary search ,but we will be using binary search by using some tricks. If you have a good grasp on find the peak value of a rotated array, then you will use these peak value as pointers to your binary search. If your target lies in between index 0 and peak. we will use binary Search in that. or else we will use on the other half of the array i.e., peak+1 and arr.size()-1\\n "
                    },
                    {
                        "username": "hamburgercookieicecream",
                        "content": "[@aeinha_sha](/aeinha_sha) Ok but from the first test case it is not in ascending order, therefore we know that it has been rotated. After rotation, doesn\\'t the 0 change from the zeroeth index to the fourth index? So if we are not returning its original index, how is this problem different from just taking in an array and finding the index of the item you are given. How does rotation come into play?"
                    },
                    {
                        "username": "aeinha_sha",
                        "content": "You need to return the index of 0 (which is 4) hence 4 is the answer. A arr named nums can be either rotated or not and we need to find a target in that array called nums . In order to solve this problem you need to understand the idea of pivot point and Binary Search. Then, you can tackle this problem."
                    },
                    {
                        "username": "natitati",
                        "content": "I remember like 2 months i wasn\\'t able to solve it... I was too afraid to try. Today, I was able to solve it quite easily... Thanks Leetcode, for making me progress so much. Also nice edge cases.\\n\\nFor anyone struggling, try the following:\\n-Find the pivot index using binary search (which will be the smallest value in he array one found)\\n-Run regular binary search, but on each check, add the pivot as an offset (don\\'t forget to mod by the size!)"
                    },
                    {
                        "username": "natitati",
                        "content": "Suppose the example array in the question. You found the pivot - it\\'s 4. Now perform binary search: low = 0, high = nums.size() = 7.\\nmid would be 3, which is 0, which obviously isn\\'t the mid value. We add the pivot, since the array was rotated. so 3 + 4 = 7. Mod by 7 since it exceeds the size of the array - this gives the effect of rotation. so we get to index 0, which is 4, which is the actual mid value (if the array was regulary sorted.)."
                    },
                    {
                        "username": "aeinha_sha",
                        "content": "add the pivot as an offset (don\\'t forget to mod by the size!) . can you explain this line?"
                    },
                    {
                        "username": "lacnoskillz",
                        "content": "Basically, writing your own custom function instead of using indexOf (javascript)"
                    },
                    {
                        "username": "jasurbekabdunazarov111",
                        "content": "in C#\\npublic class Solution {\\n    public int Search(int[] nums, int target) {\\n        int low = 0, high = nums.Length - 1;\\n\\n        while (low <= high) {\\n            int mid = (low + high) / 2;\\n\\n            if (nums[mid] == target) {\\n                return mid;\\n            }\\n\\n            if (nums[low] <= nums[mid]) {\\n                if (nums[low] <= target && target < nums[mid]) {\\n                    high = mid - 1;\\n                } else {\\n                    low = mid + 1;\\n                }\\n            } else {\\n                if (nums[mid] < target && target <= nums[high]) {\\n                    low = mid + 1;\\n                } else {\\n                    high = mid - 1;\\n                }\\n            }\\n        }\\n\\n        return -1;\\n    }\\n}\\n"
                    },
                    {
                        "username": "awasthivarsha0710",
                        "content": "Just do binary search ....and you will beat 73% of the solutions in terms of time complexity."
                    },
                    {
                        "username": "roman-mc",
                        "content": "Test cases are passing even for O(n) solutions, which shouldn't be passing"
                    },
                    {
                        "username": "hp333854",
                        "content": "In this problem what is the twist here? I really don\\'t get can anyone tell me?"
                    },
                    {
                        "username": "vishal_246",
                        "content": "can any explain me how we use constraints in this question using binary search(c++) . i just started programming so i don,t have much knowledge of constraints!!"
                    },
                    {
                        "username": "brycedoeswhat",
                        "content": "I really don\\'t understand this problem? are you not allowed to just i++ over the entire vector until you reach the target if not return -1? is the challenge to just make it most efficient? I see people posting insane code but it could be solved using 1 for loop?"
                    },
                    {
                        "username": "shreyarora1000",
                        "content": "Yep, you must write an algorithm with O(log n) runtime complexity."
                    }
                ]
            },
            {
                "id": 2006133,
                "content": [
                    {
                        "username": "sriganesh777",
                        "content": "why is the length constraint so low?\\n"
                    },
                    {
                        "username": "hamburgercookieicecream",
                        "content": "I dont understand the first test case nor the problem in general. Shouldn\\'t the output of the first test case be index 0 instead of index 4, since you are given nums after the rotation?"
                    },
                    {
                        "username": "aeinha_sha",
                        "content": "[@hamburgercookieicecream](/hamburgercookieicecream) see here, the rotation might happen or might not. What we are interested is that we are able to solve this problem using binary search. As you can see,the first half before 0 is in ascending order in the first case. After 0 ,it is still in ascending order. Normally we can\\'t apply binary search ,but we will be using binary search by using some tricks. If you have a good grasp on find the peak value of a rotated array, then you will use these peak value as pointers to your binary search. If your target lies in between index 0 and peak. we will use binary Search in that. or else we will use on the other half of the array i.e., peak+1 and arr.size()-1\\n "
                    },
                    {
                        "username": "hamburgercookieicecream",
                        "content": "[@aeinha_sha](/aeinha_sha) Ok but from the first test case it is not in ascending order, therefore we know that it has been rotated. After rotation, doesn\\'t the 0 change from the zeroeth index to the fourth index? So if we are not returning its original index, how is this problem different from just taking in an array and finding the index of the item you are given. How does rotation come into play?"
                    },
                    {
                        "username": "aeinha_sha",
                        "content": "You need to return the index of 0 (which is 4) hence 4 is the answer. A arr named nums can be either rotated or not and we need to find a target in that array called nums . In order to solve this problem you need to understand the idea of pivot point and Binary Search. Then, you can tackle this problem."
                    },
                    {
                        "username": "natitati",
                        "content": "I remember like 2 months i wasn\\'t able to solve it... I was too afraid to try. Today, I was able to solve it quite easily... Thanks Leetcode, for making me progress so much. Also nice edge cases.\\n\\nFor anyone struggling, try the following:\\n-Find the pivot index using binary search (which will be the smallest value in he array one found)\\n-Run regular binary search, but on each check, add the pivot as an offset (don\\'t forget to mod by the size!)"
                    },
                    {
                        "username": "natitati",
                        "content": "Suppose the example array in the question. You found the pivot - it\\'s 4. Now perform binary search: low = 0, high = nums.size() = 7.\\nmid would be 3, which is 0, which obviously isn\\'t the mid value. We add the pivot, since the array was rotated. so 3 + 4 = 7. Mod by 7 since it exceeds the size of the array - this gives the effect of rotation. so we get to index 0, which is 4, which is the actual mid value (if the array was regulary sorted.)."
                    },
                    {
                        "username": "aeinha_sha",
                        "content": "add the pivot as an offset (don\\'t forget to mod by the size!) . can you explain this line?"
                    },
                    {
                        "username": "lacnoskillz",
                        "content": "Basically, writing your own custom function instead of using indexOf (javascript)"
                    },
                    {
                        "username": "jasurbekabdunazarov111",
                        "content": "in C#\\npublic class Solution {\\n    public int Search(int[] nums, int target) {\\n        int low = 0, high = nums.Length - 1;\\n\\n        while (low <= high) {\\n            int mid = (low + high) / 2;\\n\\n            if (nums[mid] == target) {\\n                return mid;\\n            }\\n\\n            if (nums[low] <= nums[mid]) {\\n                if (nums[low] <= target && target < nums[mid]) {\\n                    high = mid - 1;\\n                } else {\\n                    low = mid + 1;\\n                }\\n            } else {\\n                if (nums[mid] < target && target <= nums[high]) {\\n                    low = mid + 1;\\n                } else {\\n                    high = mid - 1;\\n                }\\n            }\\n        }\\n\\n        return -1;\\n    }\\n}\\n"
                    },
                    {
                        "username": "awasthivarsha0710",
                        "content": "Just do binary search ....and you will beat 73% of the solutions in terms of time complexity."
                    },
                    {
                        "username": "roman-mc",
                        "content": "Test cases are passing even for O(n) solutions, which shouldn't be passing"
                    },
                    {
                        "username": "hp333854",
                        "content": "In this problem what is the twist here? I really don\\'t get can anyone tell me?"
                    },
                    {
                        "username": "vishal_246",
                        "content": "can any explain me how we use constraints in this question using binary search(c++) . i just started programming so i don,t have much knowledge of constraints!!"
                    },
                    {
                        "username": "brycedoeswhat",
                        "content": "I really don\\'t understand this problem? are you not allowed to just i++ over the entire vector until you reach the target if not return -1? is the challenge to just make it most efficient? I see people posting insane code but it could be solved using 1 for loop?"
                    },
                    {
                        "username": "shreyarora1000",
                        "content": "Yep, you must write an algorithm with O(log n) runtime complexity."
                    }
                ]
            },
            {
                "id": 2005899,
                "content": [
                    {
                        "username": "sriganesh777",
                        "content": "why is the length constraint so low?\\n"
                    },
                    {
                        "username": "hamburgercookieicecream",
                        "content": "I dont understand the first test case nor the problem in general. Shouldn\\'t the output of the first test case be index 0 instead of index 4, since you are given nums after the rotation?"
                    },
                    {
                        "username": "aeinha_sha",
                        "content": "[@hamburgercookieicecream](/hamburgercookieicecream) see here, the rotation might happen or might not. What we are interested is that we are able to solve this problem using binary search. As you can see,the first half before 0 is in ascending order in the first case. After 0 ,it is still in ascending order. Normally we can\\'t apply binary search ,but we will be using binary search by using some tricks. If you have a good grasp on find the peak value of a rotated array, then you will use these peak value as pointers to your binary search. If your target lies in between index 0 and peak. we will use binary Search in that. or else we will use on the other half of the array i.e., peak+1 and arr.size()-1\\n "
                    },
                    {
                        "username": "hamburgercookieicecream",
                        "content": "[@aeinha_sha](/aeinha_sha) Ok but from the first test case it is not in ascending order, therefore we know that it has been rotated. After rotation, doesn\\'t the 0 change from the zeroeth index to the fourth index? So if we are not returning its original index, how is this problem different from just taking in an array and finding the index of the item you are given. How does rotation come into play?"
                    },
                    {
                        "username": "aeinha_sha",
                        "content": "You need to return the index of 0 (which is 4) hence 4 is the answer. A arr named nums can be either rotated or not and we need to find a target in that array called nums . In order to solve this problem you need to understand the idea of pivot point and Binary Search. Then, you can tackle this problem."
                    },
                    {
                        "username": "natitati",
                        "content": "I remember like 2 months i wasn\\'t able to solve it... I was too afraid to try. Today, I was able to solve it quite easily... Thanks Leetcode, for making me progress so much. Also nice edge cases.\\n\\nFor anyone struggling, try the following:\\n-Find the pivot index using binary search (which will be the smallest value in he array one found)\\n-Run regular binary search, but on each check, add the pivot as an offset (don\\'t forget to mod by the size!)"
                    },
                    {
                        "username": "natitati",
                        "content": "Suppose the example array in the question. You found the pivot - it\\'s 4. Now perform binary search: low = 0, high = nums.size() = 7.\\nmid would be 3, which is 0, which obviously isn\\'t the mid value. We add the pivot, since the array was rotated. so 3 + 4 = 7. Mod by 7 since it exceeds the size of the array - this gives the effect of rotation. so we get to index 0, which is 4, which is the actual mid value (if the array was regulary sorted.)."
                    },
                    {
                        "username": "aeinha_sha",
                        "content": "add the pivot as an offset (don\\'t forget to mod by the size!) . can you explain this line?"
                    },
                    {
                        "username": "lacnoskillz",
                        "content": "Basically, writing your own custom function instead of using indexOf (javascript)"
                    },
                    {
                        "username": "jasurbekabdunazarov111",
                        "content": "in C#\\npublic class Solution {\\n    public int Search(int[] nums, int target) {\\n        int low = 0, high = nums.Length - 1;\\n\\n        while (low <= high) {\\n            int mid = (low + high) / 2;\\n\\n            if (nums[mid] == target) {\\n                return mid;\\n            }\\n\\n            if (nums[low] <= nums[mid]) {\\n                if (nums[low] <= target && target < nums[mid]) {\\n                    high = mid - 1;\\n                } else {\\n                    low = mid + 1;\\n                }\\n            } else {\\n                if (nums[mid] < target && target <= nums[high]) {\\n                    low = mid + 1;\\n                } else {\\n                    high = mid - 1;\\n                }\\n            }\\n        }\\n\\n        return -1;\\n    }\\n}\\n"
                    },
                    {
                        "username": "awasthivarsha0710",
                        "content": "Just do binary search ....and you will beat 73% of the solutions in terms of time complexity."
                    },
                    {
                        "username": "roman-mc",
                        "content": "Test cases are passing even for O(n) solutions, which shouldn't be passing"
                    },
                    {
                        "username": "hp333854",
                        "content": "In this problem what is the twist here? I really don\\'t get can anyone tell me?"
                    },
                    {
                        "username": "vishal_246",
                        "content": "can any explain me how we use constraints in this question using binary search(c++) . i just started programming so i don,t have much knowledge of constraints!!"
                    },
                    {
                        "username": "brycedoeswhat",
                        "content": "I really don\\'t understand this problem? are you not allowed to just i++ over the entire vector until you reach the target if not return -1? is the challenge to just make it most efficient? I see people posting insane code but it could be solved using 1 for loop?"
                    },
                    {
                        "username": "shreyarora1000",
                        "content": "Yep, you must write an algorithm with O(log n) runtime complexity."
                    }
                ]
            },
            {
                "id": 2005868,
                "content": [
                    {
                        "username": "sriganesh777",
                        "content": "why is the length constraint so low?\\n"
                    },
                    {
                        "username": "hamburgercookieicecream",
                        "content": "I dont understand the first test case nor the problem in general. Shouldn\\'t the output of the first test case be index 0 instead of index 4, since you are given nums after the rotation?"
                    },
                    {
                        "username": "aeinha_sha",
                        "content": "[@hamburgercookieicecream](/hamburgercookieicecream) see here, the rotation might happen or might not. What we are interested is that we are able to solve this problem using binary search. As you can see,the first half before 0 is in ascending order in the first case. After 0 ,it is still in ascending order. Normally we can\\'t apply binary search ,but we will be using binary search by using some tricks. If you have a good grasp on find the peak value of a rotated array, then you will use these peak value as pointers to your binary search. If your target lies in between index 0 and peak. we will use binary Search in that. or else we will use on the other half of the array i.e., peak+1 and arr.size()-1\\n "
                    },
                    {
                        "username": "hamburgercookieicecream",
                        "content": "[@aeinha_sha](/aeinha_sha) Ok but from the first test case it is not in ascending order, therefore we know that it has been rotated. After rotation, doesn\\'t the 0 change from the zeroeth index to the fourth index? So if we are not returning its original index, how is this problem different from just taking in an array and finding the index of the item you are given. How does rotation come into play?"
                    },
                    {
                        "username": "aeinha_sha",
                        "content": "You need to return the index of 0 (which is 4) hence 4 is the answer. A arr named nums can be either rotated or not and we need to find a target in that array called nums . In order to solve this problem you need to understand the idea of pivot point and Binary Search. Then, you can tackle this problem."
                    },
                    {
                        "username": "natitati",
                        "content": "I remember like 2 months i wasn\\'t able to solve it... I was too afraid to try. Today, I was able to solve it quite easily... Thanks Leetcode, for making me progress so much. Also nice edge cases.\\n\\nFor anyone struggling, try the following:\\n-Find the pivot index using binary search (which will be the smallest value in he array one found)\\n-Run regular binary search, but on each check, add the pivot as an offset (don\\'t forget to mod by the size!)"
                    },
                    {
                        "username": "natitati",
                        "content": "Suppose the example array in the question. You found the pivot - it\\'s 4. Now perform binary search: low = 0, high = nums.size() = 7.\\nmid would be 3, which is 0, which obviously isn\\'t the mid value. We add the pivot, since the array was rotated. so 3 + 4 = 7. Mod by 7 since it exceeds the size of the array - this gives the effect of rotation. so we get to index 0, which is 4, which is the actual mid value (if the array was regulary sorted.)."
                    },
                    {
                        "username": "aeinha_sha",
                        "content": "add the pivot as an offset (don\\'t forget to mod by the size!) . can you explain this line?"
                    },
                    {
                        "username": "lacnoskillz",
                        "content": "Basically, writing your own custom function instead of using indexOf (javascript)"
                    },
                    {
                        "username": "jasurbekabdunazarov111",
                        "content": "in C#\\npublic class Solution {\\n    public int Search(int[] nums, int target) {\\n        int low = 0, high = nums.Length - 1;\\n\\n        while (low <= high) {\\n            int mid = (low + high) / 2;\\n\\n            if (nums[mid] == target) {\\n                return mid;\\n            }\\n\\n            if (nums[low] <= nums[mid]) {\\n                if (nums[low] <= target && target < nums[mid]) {\\n                    high = mid - 1;\\n                } else {\\n                    low = mid + 1;\\n                }\\n            } else {\\n                if (nums[mid] < target && target <= nums[high]) {\\n                    low = mid + 1;\\n                } else {\\n                    high = mid - 1;\\n                }\\n            }\\n        }\\n\\n        return -1;\\n    }\\n}\\n"
                    },
                    {
                        "username": "awasthivarsha0710",
                        "content": "Just do binary search ....and you will beat 73% of the solutions in terms of time complexity."
                    },
                    {
                        "username": "roman-mc",
                        "content": "Test cases are passing even for O(n) solutions, which shouldn't be passing"
                    },
                    {
                        "username": "hp333854",
                        "content": "In this problem what is the twist here? I really don\\'t get can anyone tell me?"
                    },
                    {
                        "username": "vishal_246",
                        "content": "can any explain me how we use constraints in this question using binary search(c++) . i just started programming so i don,t have much knowledge of constraints!!"
                    },
                    {
                        "username": "brycedoeswhat",
                        "content": "I really don\\'t understand this problem? are you not allowed to just i++ over the entire vector until you reach the target if not return -1? is the challenge to just make it most efficient? I see people posting insane code but it could be solved using 1 for loop?"
                    },
                    {
                        "username": "shreyarora1000",
                        "content": "Yep, you must write an algorithm with O(log n) runtime complexity."
                    }
                ]
            },
            {
                "id": 2005855,
                "content": [
                    {
                        "username": "sriganesh777",
                        "content": "why is the length constraint so low?\\n"
                    },
                    {
                        "username": "hamburgercookieicecream",
                        "content": "I dont understand the first test case nor the problem in general. Shouldn\\'t the output of the first test case be index 0 instead of index 4, since you are given nums after the rotation?"
                    },
                    {
                        "username": "aeinha_sha",
                        "content": "[@hamburgercookieicecream](/hamburgercookieicecream) see here, the rotation might happen or might not. What we are interested is that we are able to solve this problem using binary search. As you can see,the first half before 0 is in ascending order in the first case. After 0 ,it is still in ascending order. Normally we can\\'t apply binary search ,but we will be using binary search by using some tricks. If you have a good grasp on find the peak value of a rotated array, then you will use these peak value as pointers to your binary search. If your target lies in between index 0 and peak. we will use binary Search in that. or else we will use on the other half of the array i.e., peak+1 and arr.size()-1\\n "
                    },
                    {
                        "username": "hamburgercookieicecream",
                        "content": "[@aeinha_sha](/aeinha_sha) Ok but from the first test case it is not in ascending order, therefore we know that it has been rotated. After rotation, doesn\\'t the 0 change from the zeroeth index to the fourth index? So if we are not returning its original index, how is this problem different from just taking in an array and finding the index of the item you are given. How does rotation come into play?"
                    },
                    {
                        "username": "aeinha_sha",
                        "content": "You need to return the index of 0 (which is 4) hence 4 is the answer. A arr named nums can be either rotated or not and we need to find a target in that array called nums . In order to solve this problem you need to understand the idea of pivot point and Binary Search. Then, you can tackle this problem."
                    },
                    {
                        "username": "natitati",
                        "content": "I remember like 2 months i wasn\\'t able to solve it... I was too afraid to try. Today, I was able to solve it quite easily... Thanks Leetcode, for making me progress so much. Also nice edge cases.\\n\\nFor anyone struggling, try the following:\\n-Find the pivot index using binary search (which will be the smallest value in he array one found)\\n-Run regular binary search, but on each check, add the pivot as an offset (don\\'t forget to mod by the size!)"
                    },
                    {
                        "username": "natitati",
                        "content": "Suppose the example array in the question. You found the pivot - it\\'s 4. Now perform binary search: low = 0, high = nums.size() = 7.\\nmid would be 3, which is 0, which obviously isn\\'t the mid value. We add the pivot, since the array was rotated. so 3 + 4 = 7. Mod by 7 since it exceeds the size of the array - this gives the effect of rotation. so we get to index 0, which is 4, which is the actual mid value (if the array was regulary sorted.)."
                    },
                    {
                        "username": "aeinha_sha",
                        "content": "add the pivot as an offset (don\\'t forget to mod by the size!) . can you explain this line?"
                    },
                    {
                        "username": "lacnoskillz",
                        "content": "Basically, writing your own custom function instead of using indexOf (javascript)"
                    },
                    {
                        "username": "jasurbekabdunazarov111",
                        "content": "in C#\\npublic class Solution {\\n    public int Search(int[] nums, int target) {\\n        int low = 0, high = nums.Length - 1;\\n\\n        while (low <= high) {\\n            int mid = (low + high) / 2;\\n\\n            if (nums[mid] == target) {\\n                return mid;\\n            }\\n\\n            if (nums[low] <= nums[mid]) {\\n                if (nums[low] <= target && target < nums[mid]) {\\n                    high = mid - 1;\\n                } else {\\n                    low = mid + 1;\\n                }\\n            } else {\\n                if (nums[mid] < target && target <= nums[high]) {\\n                    low = mid + 1;\\n                } else {\\n                    high = mid - 1;\\n                }\\n            }\\n        }\\n\\n        return -1;\\n    }\\n}\\n"
                    },
                    {
                        "username": "awasthivarsha0710",
                        "content": "Just do binary search ....and you will beat 73% of the solutions in terms of time complexity."
                    },
                    {
                        "username": "roman-mc",
                        "content": "Test cases are passing even for O(n) solutions, which shouldn't be passing"
                    },
                    {
                        "username": "hp333854",
                        "content": "In this problem what is the twist here? I really don\\'t get can anyone tell me?"
                    },
                    {
                        "username": "vishal_246",
                        "content": "can any explain me how we use constraints in this question using binary search(c++) . i just started programming so i don,t have much knowledge of constraints!!"
                    },
                    {
                        "username": "brycedoeswhat",
                        "content": "I really don\\'t understand this problem? are you not allowed to just i++ over the entire vector until you reach the target if not return -1? is the challenge to just make it most efficient? I see people posting insane code but it could be solved using 1 for loop?"
                    },
                    {
                        "username": "shreyarora1000",
                        "content": "Yep, you must write an algorithm with O(log n) runtime complexity."
                    }
                ]
            },
            {
                "id": 2005824,
                "content": [
                    {
                        "username": "sriganesh777",
                        "content": "why is the length constraint so low?\\n"
                    },
                    {
                        "username": "hamburgercookieicecream",
                        "content": "I dont understand the first test case nor the problem in general. Shouldn\\'t the output of the first test case be index 0 instead of index 4, since you are given nums after the rotation?"
                    },
                    {
                        "username": "aeinha_sha",
                        "content": "[@hamburgercookieicecream](/hamburgercookieicecream) see here, the rotation might happen or might not. What we are interested is that we are able to solve this problem using binary search. As you can see,the first half before 0 is in ascending order in the first case. After 0 ,it is still in ascending order. Normally we can\\'t apply binary search ,but we will be using binary search by using some tricks. If you have a good grasp on find the peak value of a rotated array, then you will use these peak value as pointers to your binary search. If your target lies in between index 0 and peak. we will use binary Search in that. or else we will use on the other half of the array i.e., peak+1 and arr.size()-1\\n "
                    },
                    {
                        "username": "hamburgercookieicecream",
                        "content": "[@aeinha_sha](/aeinha_sha) Ok but from the first test case it is not in ascending order, therefore we know that it has been rotated. After rotation, doesn\\'t the 0 change from the zeroeth index to the fourth index? So if we are not returning its original index, how is this problem different from just taking in an array and finding the index of the item you are given. How does rotation come into play?"
                    },
                    {
                        "username": "aeinha_sha",
                        "content": "You need to return the index of 0 (which is 4) hence 4 is the answer. A arr named nums can be either rotated or not and we need to find a target in that array called nums . In order to solve this problem you need to understand the idea of pivot point and Binary Search. Then, you can tackle this problem."
                    },
                    {
                        "username": "natitati",
                        "content": "I remember like 2 months i wasn\\'t able to solve it... I was too afraid to try. Today, I was able to solve it quite easily... Thanks Leetcode, for making me progress so much. Also nice edge cases.\\n\\nFor anyone struggling, try the following:\\n-Find the pivot index using binary search (which will be the smallest value in he array one found)\\n-Run regular binary search, but on each check, add the pivot as an offset (don\\'t forget to mod by the size!)"
                    },
                    {
                        "username": "natitati",
                        "content": "Suppose the example array in the question. You found the pivot - it\\'s 4. Now perform binary search: low = 0, high = nums.size() = 7.\\nmid would be 3, which is 0, which obviously isn\\'t the mid value. We add the pivot, since the array was rotated. so 3 + 4 = 7. Mod by 7 since it exceeds the size of the array - this gives the effect of rotation. so we get to index 0, which is 4, which is the actual mid value (if the array was regulary sorted.)."
                    },
                    {
                        "username": "aeinha_sha",
                        "content": "add the pivot as an offset (don\\'t forget to mod by the size!) . can you explain this line?"
                    },
                    {
                        "username": "lacnoskillz",
                        "content": "Basically, writing your own custom function instead of using indexOf (javascript)"
                    },
                    {
                        "username": "jasurbekabdunazarov111",
                        "content": "in C#\\npublic class Solution {\\n    public int Search(int[] nums, int target) {\\n        int low = 0, high = nums.Length - 1;\\n\\n        while (low <= high) {\\n            int mid = (low + high) / 2;\\n\\n            if (nums[mid] == target) {\\n                return mid;\\n            }\\n\\n            if (nums[low] <= nums[mid]) {\\n                if (nums[low] <= target && target < nums[mid]) {\\n                    high = mid - 1;\\n                } else {\\n                    low = mid + 1;\\n                }\\n            } else {\\n                if (nums[mid] < target && target <= nums[high]) {\\n                    low = mid + 1;\\n                } else {\\n                    high = mid - 1;\\n                }\\n            }\\n        }\\n\\n        return -1;\\n    }\\n}\\n"
                    },
                    {
                        "username": "awasthivarsha0710",
                        "content": "Just do binary search ....and you will beat 73% of the solutions in terms of time complexity."
                    },
                    {
                        "username": "roman-mc",
                        "content": "Test cases are passing even for O(n) solutions, which shouldn't be passing"
                    },
                    {
                        "username": "hp333854",
                        "content": "In this problem what is the twist here? I really don\\'t get can anyone tell me?"
                    },
                    {
                        "username": "vishal_246",
                        "content": "can any explain me how we use constraints in this question using binary search(c++) . i just started programming so i don,t have much knowledge of constraints!!"
                    },
                    {
                        "username": "brycedoeswhat",
                        "content": "I really don\\'t understand this problem? are you not allowed to just i++ over the entire vector until you reach the target if not return -1? is the challenge to just make it most efficient? I see people posting insane code but it could be solved using 1 for loop?"
                    },
                    {
                        "username": "shreyarora1000",
                        "content": "Yep, you must write an algorithm with O(log n) runtime complexity."
                    }
                ]
            },
            {
                "id": 2005787,
                "content": [
                    {
                        "username": "sriganesh777",
                        "content": "why is the length constraint so low?\\n"
                    },
                    {
                        "username": "hamburgercookieicecream",
                        "content": "I dont understand the first test case nor the problem in general. Shouldn\\'t the output of the first test case be index 0 instead of index 4, since you are given nums after the rotation?"
                    },
                    {
                        "username": "aeinha_sha",
                        "content": "[@hamburgercookieicecream](/hamburgercookieicecream) see here, the rotation might happen or might not. What we are interested is that we are able to solve this problem using binary search. As you can see,the first half before 0 is in ascending order in the first case. After 0 ,it is still in ascending order. Normally we can\\'t apply binary search ,but we will be using binary search by using some tricks. If you have a good grasp on find the peak value of a rotated array, then you will use these peak value as pointers to your binary search. If your target lies in between index 0 and peak. we will use binary Search in that. or else we will use on the other half of the array i.e., peak+1 and arr.size()-1\\n "
                    },
                    {
                        "username": "hamburgercookieicecream",
                        "content": "[@aeinha_sha](/aeinha_sha) Ok but from the first test case it is not in ascending order, therefore we know that it has been rotated. After rotation, doesn\\'t the 0 change from the zeroeth index to the fourth index? So if we are not returning its original index, how is this problem different from just taking in an array and finding the index of the item you are given. How does rotation come into play?"
                    },
                    {
                        "username": "aeinha_sha",
                        "content": "You need to return the index of 0 (which is 4) hence 4 is the answer. A arr named nums can be either rotated or not and we need to find a target in that array called nums . In order to solve this problem you need to understand the idea of pivot point and Binary Search. Then, you can tackle this problem."
                    },
                    {
                        "username": "natitati",
                        "content": "I remember like 2 months i wasn\\'t able to solve it... I was too afraid to try. Today, I was able to solve it quite easily... Thanks Leetcode, for making me progress so much. Also nice edge cases.\\n\\nFor anyone struggling, try the following:\\n-Find the pivot index using binary search (which will be the smallest value in he array one found)\\n-Run regular binary search, but on each check, add the pivot as an offset (don\\'t forget to mod by the size!)"
                    },
                    {
                        "username": "natitati",
                        "content": "Suppose the example array in the question. You found the pivot - it\\'s 4. Now perform binary search: low = 0, high = nums.size() = 7.\\nmid would be 3, which is 0, which obviously isn\\'t the mid value. We add the pivot, since the array was rotated. so 3 + 4 = 7. Mod by 7 since it exceeds the size of the array - this gives the effect of rotation. so we get to index 0, which is 4, which is the actual mid value (if the array was regulary sorted.)."
                    },
                    {
                        "username": "aeinha_sha",
                        "content": "add the pivot as an offset (don\\'t forget to mod by the size!) . can you explain this line?"
                    },
                    {
                        "username": "lacnoskillz",
                        "content": "Basically, writing your own custom function instead of using indexOf (javascript)"
                    },
                    {
                        "username": "jasurbekabdunazarov111",
                        "content": "in C#\\npublic class Solution {\\n    public int Search(int[] nums, int target) {\\n        int low = 0, high = nums.Length - 1;\\n\\n        while (low <= high) {\\n            int mid = (low + high) / 2;\\n\\n            if (nums[mid] == target) {\\n                return mid;\\n            }\\n\\n            if (nums[low] <= nums[mid]) {\\n                if (nums[low] <= target && target < nums[mid]) {\\n                    high = mid - 1;\\n                } else {\\n                    low = mid + 1;\\n                }\\n            } else {\\n                if (nums[mid] < target && target <= nums[high]) {\\n                    low = mid + 1;\\n                } else {\\n                    high = mid - 1;\\n                }\\n            }\\n        }\\n\\n        return -1;\\n    }\\n}\\n"
                    },
                    {
                        "username": "awasthivarsha0710",
                        "content": "Just do binary search ....and you will beat 73% of the solutions in terms of time complexity."
                    },
                    {
                        "username": "roman-mc",
                        "content": "Test cases are passing even for O(n) solutions, which shouldn't be passing"
                    },
                    {
                        "username": "hp333854",
                        "content": "In this problem what is the twist here? I really don\\'t get can anyone tell me?"
                    },
                    {
                        "username": "vishal_246",
                        "content": "can any explain me how we use constraints in this question using binary search(c++) . i just started programming so i don,t have much knowledge of constraints!!"
                    },
                    {
                        "username": "brycedoeswhat",
                        "content": "I really don\\'t understand this problem? are you not allowed to just i++ over the entire vector until you reach the target if not return -1? is the challenge to just make it most efficient? I see people posting insane code but it could be solved using 1 for loop?"
                    },
                    {
                        "username": "shreyarora1000",
                        "content": "Yep, you must write an algorithm with O(log n) runtime complexity."
                    }
                ]
            },
            {
                "id": 2005780,
                "content": [
                    {
                        "username": "sriganesh777",
                        "content": "why is the length constraint so low?\\n"
                    },
                    {
                        "username": "hamburgercookieicecream",
                        "content": "I dont understand the first test case nor the problem in general. Shouldn\\'t the output of the first test case be index 0 instead of index 4, since you are given nums after the rotation?"
                    },
                    {
                        "username": "aeinha_sha",
                        "content": "[@hamburgercookieicecream](/hamburgercookieicecream) see here, the rotation might happen or might not. What we are interested is that we are able to solve this problem using binary search. As you can see,the first half before 0 is in ascending order in the first case. After 0 ,it is still in ascending order. Normally we can\\'t apply binary search ,but we will be using binary search by using some tricks. If you have a good grasp on find the peak value of a rotated array, then you will use these peak value as pointers to your binary search. If your target lies in between index 0 and peak. we will use binary Search in that. or else we will use on the other half of the array i.e., peak+1 and arr.size()-1\\n "
                    },
                    {
                        "username": "hamburgercookieicecream",
                        "content": "[@aeinha_sha](/aeinha_sha) Ok but from the first test case it is not in ascending order, therefore we know that it has been rotated. After rotation, doesn\\'t the 0 change from the zeroeth index to the fourth index? So if we are not returning its original index, how is this problem different from just taking in an array and finding the index of the item you are given. How does rotation come into play?"
                    },
                    {
                        "username": "aeinha_sha",
                        "content": "You need to return the index of 0 (which is 4) hence 4 is the answer. A arr named nums can be either rotated or not and we need to find a target in that array called nums . In order to solve this problem you need to understand the idea of pivot point and Binary Search. Then, you can tackle this problem."
                    },
                    {
                        "username": "natitati",
                        "content": "I remember like 2 months i wasn\\'t able to solve it... I was too afraid to try. Today, I was able to solve it quite easily... Thanks Leetcode, for making me progress so much. Also nice edge cases.\\n\\nFor anyone struggling, try the following:\\n-Find the pivot index using binary search (which will be the smallest value in he array one found)\\n-Run regular binary search, but on each check, add the pivot as an offset (don\\'t forget to mod by the size!)"
                    },
                    {
                        "username": "natitati",
                        "content": "Suppose the example array in the question. You found the pivot - it\\'s 4. Now perform binary search: low = 0, high = nums.size() = 7.\\nmid would be 3, which is 0, which obviously isn\\'t the mid value. We add the pivot, since the array was rotated. so 3 + 4 = 7. Mod by 7 since it exceeds the size of the array - this gives the effect of rotation. so we get to index 0, which is 4, which is the actual mid value (if the array was regulary sorted.)."
                    },
                    {
                        "username": "aeinha_sha",
                        "content": "add the pivot as an offset (don\\'t forget to mod by the size!) . can you explain this line?"
                    },
                    {
                        "username": "lacnoskillz",
                        "content": "Basically, writing your own custom function instead of using indexOf (javascript)"
                    },
                    {
                        "username": "jasurbekabdunazarov111",
                        "content": "in C#\\npublic class Solution {\\n    public int Search(int[] nums, int target) {\\n        int low = 0, high = nums.Length - 1;\\n\\n        while (low <= high) {\\n            int mid = (low + high) / 2;\\n\\n            if (nums[mid] == target) {\\n                return mid;\\n            }\\n\\n            if (nums[low] <= nums[mid]) {\\n                if (nums[low] <= target && target < nums[mid]) {\\n                    high = mid - 1;\\n                } else {\\n                    low = mid + 1;\\n                }\\n            } else {\\n                if (nums[mid] < target && target <= nums[high]) {\\n                    low = mid + 1;\\n                } else {\\n                    high = mid - 1;\\n                }\\n            }\\n        }\\n\\n        return -1;\\n    }\\n}\\n"
                    },
                    {
                        "username": "awasthivarsha0710",
                        "content": "Just do binary search ....and you will beat 73% of the solutions in terms of time complexity."
                    },
                    {
                        "username": "roman-mc",
                        "content": "Test cases are passing even for O(n) solutions, which shouldn't be passing"
                    },
                    {
                        "username": "hp333854",
                        "content": "In this problem what is the twist here? I really don\\'t get can anyone tell me?"
                    },
                    {
                        "username": "vishal_246",
                        "content": "can any explain me how we use constraints in this question using binary search(c++) . i just started programming so i don,t have much knowledge of constraints!!"
                    },
                    {
                        "username": "brycedoeswhat",
                        "content": "I really don\\'t understand this problem? are you not allowed to just i++ over the entire vector until you reach the target if not return -1? is the challenge to just make it most efficient? I see people posting insane code but it could be solved using 1 for loop?"
                    },
                    {
                        "username": "shreyarora1000",
                        "content": "Yep, you must write an algorithm with O(log n) runtime complexity."
                    }
                ]
            },
            {
                "id": 2005658,
                "content": [
                    {
                        "username": "sriganesh777",
                        "content": "why is the length constraint so low?\\n"
                    },
                    {
                        "username": "hamburgercookieicecream",
                        "content": "I dont understand the first test case nor the problem in general. Shouldn\\'t the output of the first test case be index 0 instead of index 4, since you are given nums after the rotation?"
                    },
                    {
                        "username": "aeinha_sha",
                        "content": "[@hamburgercookieicecream](/hamburgercookieicecream) see here, the rotation might happen or might not. What we are interested is that we are able to solve this problem using binary search. As you can see,the first half before 0 is in ascending order in the first case. After 0 ,it is still in ascending order. Normally we can\\'t apply binary search ,but we will be using binary search by using some tricks. If you have a good grasp on find the peak value of a rotated array, then you will use these peak value as pointers to your binary search. If your target lies in between index 0 and peak. we will use binary Search in that. or else we will use on the other half of the array i.e., peak+1 and arr.size()-1\\n "
                    },
                    {
                        "username": "hamburgercookieicecream",
                        "content": "[@aeinha_sha](/aeinha_sha) Ok but from the first test case it is not in ascending order, therefore we know that it has been rotated. After rotation, doesn\\'t the 0 change from the zeroeth index to the fourth index? So if we are not returning its original index, how is this problem different from just taking in an array and finding the index of the item you are given. How does rotation come into play?"
                    },
                    {
                        "username": "aeinha_sha",
                        "content": "You need to return the index of 0 (which is 4) hence 4 is the answer. A arr named nums can be either rotated or not and we need to find a target in that array called nums . In order to solve this problem you need to understand the idea of pivot point and Binary Search. Then, you can tackle this problem."
                    },
                    {
                        "username": "natitati",
                        "content": "I remember like 2 months i wasn\\'t able to solve it... I was too afraid to try. Today, I was able to solve it quite easily... Thanks Leetcode, for making me progress so much. Also nice edge cases.\\n\\nFor anyone struggling, try the following:\\n-Find the pivot index using binary search (which will be the smallest value in he array one found)\\n-Run regular binary search, but on each check, add the pivot as an offset (don\\'t forget to mod by the size!)"
                    },
                    {
                        "username": "natitati",
                        "content": "Suppose the example array in the question. You found the pivot - it\\'s 4. Now perform binary search: low = 0, high = nums.size() = 7.\\nmid would be 3, which is 0, which obviously isn\\'t the mid value. We add the pivot, since the array was rotated. so 3 + 4 = 7. Mod by 7 since it exceeds the size of the array - this gives the effect of rotation. so we get to index 0, which is 4, which is the actual mid value (if the array was regulary sorted.)."
                    },
                    {
                        "username": "aeinha_sha",
                        "content": "add the pivot as an offset (don\\'t forget to mod by the size!) . can you explain this line?"
                    },
                    {
                        "username": "lacnoskillz",
                        "content": "Basically, writing your own custom function instead of using indexOf (javascript)"
                    },
                    {
                        "username": "jasurbekabdunazarov111",
                        "content": "in C#\\npublic class Solution {\\n    public int Search(int[] nums, int target) {\\n        int low = 0, high = nums.Length - 1;\\n\\n        while (low <= high) {\\n            int mid = (low + high) / 2;\\n\\n            if (nums[mid] == target) {\\n                return mid;\\n            }\\n\\n            if (nums[low] <= nums[mid]) {\\n                if (nums[low] <= target && target < nums[mid]) {\\n                    high = mid - 1;\\n                } else {\\n                    low = mid + 1;\\n                }\\n            } else {\\n                if (nums[mid] < target && target <= nums[high]) {\\n                    low = mid + 1;\\n                } else {\\n                    high = mid - 1;\\n                }\\n            }\\n        }\\n\\n        return -1;\\n    }\\n}\\n"
                    },
                    {
                        "username": "awasthivarsha0710",
                        "content": "Just do binary search ....and you will beat 73% of the solutions in terms of time complexity."
                    },
                    {
                        "username": "roman-mc",
                        "content": "Test cases are passing even for O(n) solutions, which shouldn't be passing"
                    },
                    {
                        "username": "hp333854",
                        "content": "In this problem what is the twist here? I really don\\'t get can anyone tell me?"
                    },
                    {
                        "username": "vishal_246",
                        "content": "can any explain me how we use constraints in this question using binary search(c++) . i just started programming so i don,t have much knowledge of constraints!!"
                    },
                    {
                        "username": "brycedoeswhat",
                        "content": "I really don\\'t understand this problem? are you not allowed to just i++ over the entire vector until you reach the target if not return -1? is the challenge to just make it most efficient? I see people posting insane code but it could be solved using 1 for loop?"
                    },
                    {
                        "username": "shreyarora1000",
                        "content": "Yep, you must write an algorithm with O(log n) runtime complexity."
                    }
                ]
            },
            {
                "id": 2005518,
                "content": [
                    {
                        "username": "sasukesharma",
                        "content": "already done one again "
                    },
                    {
                        "username": "SaiTarun2502",
                        "content": "Linear search beats 100% java sols.. :)"
                    },
                    {
                        "username": "spieles21",
                        "content": "not just Java..."
                    },
                    {
                        "username": "breathermachine",
                        "content": "LC could do some sort of doubling test to guess the algorithm's performance, similar to how codility does it. Should help in invalidating those solutions that don't follow the required complexity.\n\nhttps://algs4.cs.princeton.edu/14analysis/"
                    },
                    {
                        "username": "riturajpaul18",
                        "content": "What a coincidence!\\nI solved this problem yesterday and today it is POTD."
                    },
                    {
                        "username": "amansingh4958",
                        "content": "Somehow solved it on the first try using 2 binary searches. Felt so happy after a long time."
                    },
                    {
                        "username": "daring-calf",
                        "content": "This takes binary search to the next level."
                    },
                    {
                        "username": "Under_developed",
                        "content": "Finally i got a problem which was submitted earlier "
                    },
                    {
                        "username": "Chitra-Devi",
                        "content": "https://youtu.be/0yCbqDgzwlU"
                    },
                    {
                        "username": "aitachii",
                        "content": "`O(2 * logn)` is still  `O(logn)`"
                    },
                    {
                        "username": "Ultron03",
                        "content": "it's going to be a binary search week  :)"
                    }
                ]
            },
            {
                "id": 2005411,
                "content": [
                    {
                        "username": "sasukesharma",
                        "content": "already done one again "
                    },
                    {
                        "username": "SaiTarun2502",
                        "content": "Linear search beats 100% java sols.. :)"
                    },
                    {
                        "username": "spieles21",
                        "content": "not just Java..."
                    },
                    {
                        "username": "breathermachine",
                        "content": "LC could do some sort of doubling test to guess the algorithm's performance, similar to how codility does it. Should help in invalidating those solutions that don't follow the required complexity.\n\nhttps://algs4.cs.princeton.edu/14analysis/"
                    },
                    {
                        "username": "riturajpaul18",
                        "content": "What a coincidence!\\nI solved this problem yesterday and today it is POTD."
                    },
                    {
                        "username": "amansingh4958",
                        "content": "Somehow solved it on the first try using 2 binary searches. Felt so happy after a long time."
                    },
                    {
                        "username": "daring-calf",
                        "content": "This takes binary search to the next level."
                    },
                    {
                        "username": "Under_developed",
                        "content": "Finally i got a problem which was submitted earlier "
                    },
                    {
                        "username": "Chitra-Devi",
                        "content": "https://youtu.be/0yCbqDgzwlU"
                    },
                    {
                        "username": "aitachii",
                        "content": "`O(2 * logn)` is still  `O(logn)`"
                    },
                    {
                        "username": "Ultron03",
                        "content": "it's going to be a binary search week  :)"
                    }
                ]
            },
            {
                "id": 2005343,
                "content": [
                    {
                        "username": "sasukesharma",
                        "content": "already done one again "
                    },
                    {
                        "username": "SaiTarun2502",
                        "content": "Linear search beats 100% java sols.. :)"
                    },
                    {
                        "username": "spieles21",
                        "content": "not just Java..."
                    },
                    {
                        "username": "breathermachine",
                        "content": "LC could do some sort of doubling test to guess the algorithm's performance, similar to how codility does it. Should help in invalidating those solutions that don't follow the required complexity.\n\nhttps://algs4.cs.princeton.edu/14analysis/"
                    },
                    {
                        "username": "riturajpaul18",
                        "content": "What a coincidence!\\nI solved this problem yesterday and today it is POTD."
                    },
                    {
                        "username": "amansingh4958",
                        "content": "Somehow solved it on the first try using 2 binary searches. Felt so happy after a long time."
                    },
                    {
                        "username": "daring-calf",
                        "content": "This takes binary search to the next level."
                    },
                    {
                        "username": "Under_developed",
                        "content": "Finally i got a problem which was submitted earlier "
                    },
                    {
                        "username": "Chitra-Devi",
                        "content": "https://youtu.be/0yCbqDgzwlU"
                    },
                    {
                        "username": "aitachii",
                        "content": "`O(2 * logn)` is still  `O(logn)`"
                    },
                    {
                        "username": "Ultron03",
                        "content": "it's going to be a binary search week  :)"
                    }
                ]
            },
            {
                "id": 2005318,
                "content": [
                    {
                        "username": "sasukesharma",
                        "content": "already done one again "
                    },
                    {
                        "username": "SaiTarun2502",
                        "content": "Linear search beats 100% java sols.. :)"
                    },
                    {
                        "username": "spieles21",
                        "content": "not just Java..."
                    },
                    {
                        "username": "breathermachine",
                        "content": "LC could do some sort of doubling test to guess the algorithm's performance, similar to how codility does it. Should help in invalidating those solutions that don't follow the required complexity.\n\nhttps://algs4.cs.princeton.edu/14analysis/"
                    },
                    {
                        "username": "riturajpaul18",
                        "content": "What a coincidence!\\nI solved this problem yesterday and today it is POTD."
                    },
                    {
                        "username": "amansingh4958",
                        "content": "Somehow solved it on the first try using 2 binary searches. Felt so happy after a long time."
                    },
                    {
                        "username": "daring-calf",
                        "content": "This takes binary search to the next level."
                    },
                    {
                        "username": "Under_developed",
                        "content": "Finally i got a problem which was submitted earlier "
                    },
                    {
                        "username": "Chitra-Devi",
                        "content": "https://youtu.be/0yCbqDgzwlU"
                    },
                    {
                        "username": "aitachii",
                        "content": "`O(2 * logn)` is still  `O(logn)`"
                    },
                    {
                        "username": "Ultron03",
                        "content": "it's going to be a binary search week  :)"
                    }
                ]
            },
            {
                "id": 2005229,
                "content": [
                    {
                        "username": "sasukesharma",
                        "content": "already done one again "
                    },
                    {
                        "username": "SaiTarun2502",
                        "content": "Linear search beats 100% java sols.. :)"
                    },
                    {
                        "username": "spieles21",
                        "content": "not just Java..."
                    },
                    {
                        "username": "breathermachine",
                        "content": "LC could do some sort of doubling test to guess the algorithm's performance, similar to how codility does it. Should help in invalidating those solutions that don't follow the required complexity.\n\nhttps://algs4.cs.princeton.edu/14analysis/"
                    },
                    {
                        "username": "riturajpaul18",
                        "content": "What a coincidence!\\nI solved this problem yesterday and today it is POTD."
                    },
                    {
                        "username": "amansingh4958",
                        "content": "Somehow solved it on the first try using 2 binary searches. Felt so happy after a long time."
                    },
                    {
                        "username": "daring-calf",
                        "content": "This takes binary search to the next level."
                    },
                    {
                        "username": "Under_developed",
                        "content": "Finally i got a problem which was submitted earlier "
                    },
                    {
                        "username": "Chitra-Devi",
                        "content": "https://youtu.be/0yCbqDgzwlU"
                    },
                    {
                        "username": "aitachii",
                        "content": "`O(2 * logn)` is still  `O(logn)`"
                    },
                    {
                        "username": "Ultron03",
                        "content": "it's going to be a binary search week  :)"
                    }
                ]
            },
            {
                "id": 2005175,
                "content": [
                    {
                        "username": "sasukesharma",
                        "content": "already done one again "
                    },
                    {
                        "username": "SaiTarun2502",
                        "content": "Linear search beats 100% java sols.. :)"
                    },
                    {
                        "username": "spieles21",
                        "content": "not just Java..."
                    },
                    {
                        "username": "breathermachine",
                        "content": "LC could do some sort of doubling test to guess the algorithm's performance, similar to how codility does it. Should help in invalidating those solutions that don't follow the required complexity.\n\nhttps://algs4.cs.princeton.edu/14analysis/"
                    },
                    {
                        "username": "riturajpaul18",
                        "content": "What a coincidence!\\nI solved this problem yesterday and today it is POTD."
                    },
                    {
                        "username": "amansingh4958",
                        "content": "Somehow solved it on the first try using 2 binary searches. Felt so happy after a long time."
                    },
                    {
                        "username": "daring-calf",
                        "content": "This takes binary search to the next level."
                    },
                    {
                        "username": "Under_developed",
                        "content": "Finally i got a problem which was submitted earlier "
                    },
                    {
                        "username": "Chitra-Devi",
                        "content": "https://youtu.be/0yCbqDgzwlU"
                    },
                    {
                        "username": "aitachii",
                        "content": "`O(2 * logn)` is still  `O(logn)`"
                    },
                    {
                        "username": "Ultron03",
                        "content": "it's going to be a binary search week  :)"
                    }
                ]
            },
            {
                "id": 2005124,
                "content": [
                    {
                        "username": "sasukesharma",
                        "content": "already done one again "
                    },
                    {
                        "username": "SaiTarun2502",
                        "content": "Linear search beats 100% java sols.. :)"
                    },
                    {
                        "username": "spieles21",
                        "content": "not just Java..."
                    },
                    {
                        "username": "breathermachine",
                        "content": "LC could do some sort of doubling test to guess the algorithm's performance, similar to how codility does it. Should help in invalidating those solutions that don't follow the required complexity.\n\nhttps://algs4.cs.princeton.edu/14analysis/"
                    },
                    {
                        "username": "riturajpaul18",
                        "content": "What a coincidence!\\nI solved this problem yesterday and today it is POTD."
                    },
                    {
                        "username": "amansingh4958",
                        "content": "Somehow solved it on the first try using 2 binary searches. Felt so happy after a long time."
                    },
                    {
                        "username": "daring-calf",
                        "content": "This takes binary search to the next level."
                    },
                    {
                        "username": "Under_developed",
                        "content": "Finally i got a problem which was submitted earlier "
                    },
                    {
                        "username": "Chitra-Devi",
                        "content": "https://youtu.be/0yCbqDgzwlU"
                    },
                    {
                        "username": "aitachii",
                        "content": "`O(2 * logn)` is still  `O(logn)`"
                    },
                    {
                        "username": "Ultron03",
                        "content": "it's going to be a binary search week  :)"
                    }
                ]
            },
            {
                "id": 2005085,
                "content": [
                    {
                        "username": "sasukesharma",
                        "content": "already done one again "
                    },
                    {
                        "username": "SaiTarun2502",
                        "content": "Linear search beats 100% java sols.. :)"
                    },
                    {
                        "username": "spieles21",
                        "content": "not just Java..."
                    },
                    {
                        "username": "breathermachine",
                        "content": "LC could do some sort of doubling test to guess the algorithm's performance, similar to how codility does it. Should help in invalidating those solutions that don't follow the required complexity.\n\nhttps://algs4.cs.princeton.edu/14analysis/"
                    },
                    {
                        "username": "riturajpaul18",
                        "content": "What a coincidence!\\nI solved this problem yesterday and today it is POTD."
                    },
                    {
                        "username": "amansingh4958",
                        "content": "Somehow solved it on the first try using 2 binary searches. Felt so happy after a long time."
                    },
                    {
                        "username": "daring-calf",
                        "content": "This takes binary search to the next level."
                    },
                    {
                        "username": "Under_developed",
                        "content": "Finally i got a problem which was submitted earlier "
                    },
                    {
                        "username": "Chitra-Devi",
                        "content": "https://youtu.be/0yCbqDgzwlU"
                    },
                    {
                        "username": "aitachii",
                        "content": "`O(2 * logn)` is still  `O(logn)`"
                    },
                    {
                        "username": "Ultron03",
                        "content": "it's going to be a binary search week  :)"
                    }
                ]
            },
            {
                "id": 2005068,
                "content": [
                    {
                        "username": "sasukesharma",
                        "content": "already done one again "
                    },
                    {
                        "username": "SaiTarun2502",
                        "content": "Linear search beats 100% java sols.. :)"
                    },
                    {
                        "username": "spieles21",
                        "content": "not just Java..."
                    },
                    {
                        "username": "breathermachine",
                        "content": "LC could do some sort of doubling test to guess the algorithm's performance, similar to how codility does it. Should help in invalidating those solutions that don't follow the required complexity.\n\nhttps://algs4.cs.princeton.edu/14analysis/"
                    },
                    {
                        "username": "riturajpaul18",
                        "content": "What a coincidence!\\nI solved this problem yesterday and today it is POTD."
                    },
                    {
                        "username": "amansingh4958",
                        "content": "Somehow solved it on the first try using 2 binary searches. Felt so happy after a long time."
                    },
                    {
                        "username": "daring-calf",
                        "content": "This takes binary search to the next level."
                    },
                    {
                        "username": "Under_developed",
                        "content": "Finally i got a problem which was submitted earlier "
                    },
                    {
                        "username": "Chitra-Devi",
                        "content": "https://youtu.be/0yCbqDgzwlU"
                    },
                    {
                        "username": "aitachii",
                        "content": "`O(2 * logn)` is still  `O(logn)`"
                    },
                    {
                        "username": "Ultron03",
                        "content": "it's going to be a binary search week  :)"
                    }
                ]
            },
            {
                "id": 2004998,
                "content": [
                    {
                        "username": "sasukesharma",
                        "content": "already done one again "
                    },
                    {
                        "username": "SaiTarun2502",
                        "content": "Linear search beats 100% java sols.. :)"
                    },
                    {
                        "username": "spieles21",
                        "content": "not just Java..."
                    },
                    {
                        "username": "breathermachine",
                        "content": "LC could do some sort of doubling test to guess the algorithm's performance, similar to how codility does it. Should help in invalidating those solutions that don't follow the required complexity.\n\nhttps://algs4.cs.princeton.edu/14analysis/"
                    },
                    {
                        "username": "riturajpaul18",
                        "content": "What a coincidence!\\nI solved this problem yesterday and today it is POTD."
                    },
                    {
                        "username": "amansingh4958",
                        "content": "Somehow solved it on the first try using 2 binary searches. Felt so happy after a long time."
                    },
                    {
                        "username": "daring-calf",
                        "content": "This takes binary search to the next level."
                    },
                    {
                        "username": "Under_developed",
                        "content": "Finally i got a problem which was submitted earlier "
                    },
                    {
                        "username": "Chitra-Devi",
                        "content": "https://youtu.be/0yCbqDgzwlU"
                    },
                    {
                        "username": "aitachii",
                        "content": "`O(2 * logn)` is still  `O(logn)`"
                    },
                    {
                        "username": "Ultron03",
                        "content": "it's going to be a binary search week  :)"
                    }
                ]
            },
            {
                "id": 1998846,
                "content": [
                    {
                        "username": "Lsfhv",
                        "content": "2 Binary searches "
                    },
                    {
                        "username": "Sakab_132",
                        "content": "can anybody explain the concept pls.............."
                    },
                    {
                        "username": "Rightlyso",
                        "content": "Find the min number in the vector, min no would be smaller than both it\\'s neighbor. Then apply two binary search on left and right side of the vector"
                    },
                    {
                        "username": "thuynh3",
                        "content": "Binary search to find pivot. Then one mini binary search either from start-pivot or pivot-end to find the item."
                    },
                    {
                        "username": "cubiclestudios",
                        "content": "Isn\\'t there an error with test case 175\\n`[242,245,249,250,252,253,257,262,263,268,275,280,282,283,285,290,292,293,297,299,4,5,8,9,10,14,16,17,18,20,22,23,29,32,36,39,47,51,56,68,70,73,75,77,79,81,82,89,98,100,107,108,112,114,115,117,118,119,128,131,134,139,142,147,148,154,161,162,165,167,171,172,174,177,180,183,189,190,191,192,194,197,200,203,206,207,208,209,210,212,217,220,223,226,227,231,237]. `\\nThis test case is incorrect because its not in ascending rotated order. It jumps from 299, to 4, to 14. "
                    },
                    {
                        "username": "thuynh3",
                        "content": "I understand how it works but the edges are so hard to take care of"
                    },
                    {
                        "username": "Ultron03",
                        "content": "just reduce your input size ->run ->correct your code "
                    },
                    {
                        "username": "Nitkapur30",
                        "content": "In the given question, we can see that there may be a pivot point in the array. To make sure that binary search can be applied, we break down the question into 3 simple conditions:\\n\\nIf array is rotated and nums[mid]>nums[end]\\nIf the array is rotated and nums[mid]>nums[start]\\nif the array is sorted without rotation.\\nAll these steps are further broken down to two conditions each that helps us find the exact position for target.\\n\\nFor Example: Step 1), if nums[mid]>nums[end], then we further check position of target to see if it lies between mid and end or start and end and proceed by applying binary search accordingly.\\n\\nIn 3) Step, we can apply normal binary search since the array is sorted. If target is not found with the help of all these steps, simply return -1."
                    },
                    {
                        "username": "parass419",
                        "content": "\\nint FindPivot(vector<int>& arr, int n ){\\n    int s = 0;\\n    int e = n-1;\\n    int mid = s +(e-s)/2;\\n\\n    while(s<e){\\n        if(arr[mid] >= arr[0]){\\n            s = mid+1;\\n            }\\n            else{\\n                e = mid;\\n\\n            }\\n            mid= s+(e-s)/2;\\n    }\\n    return s;\\n}\\n\\n\\n\\n\\nint BinarySearch(vector<int>& arr , int s , int e  , int key){ // S and E // // here because here array is already divided into two parts thats why we ///// are getting the starting and ending undex if the array.\\n   \\n    int mid = s+(e-s)/2;\\n    int i = 0;\\n    int size = arr.size();\\n\\n    while(i<size){\\n        if(arr[mid]==key ){\\n            return mid;\\n        }\\n        else if(arr[mid]<key){\\n            s = mid+1;\\n        }\\n        else{\\n            e = mid-1; \\n        }\\n        mid = s+(e-s)/2;\\n\\n    }\\nreturn s;\\n     \\n}\\n\\n\\nclass Solution {\\npublic:\\n    int search(vector<int>& nums, int target) {\\n        int size = nums.size();\\n        int pivot = FindPivot(nums , size);\\n        if( target >= nums[pivot]  &&  target <=nums[size-1])\\n        {\\n            return BinarySearch(nums,pivot,size-1,target);\\n        }\\n        else{\\n             return BinarySearch(nums,0,pivot - 1,target);\\n        }\\n\\n    }\\n};\\n\\n\\nWHy this code shows TLE"
                    },
                    {
                        "username": "mukul_gupta_",
                        "content": "Does number of lines affects the memory?\nAs both the code below is same only way of writing the code differs. Can someone explain it to me?\nSnippet1:\n        return nums.index(target) if target in nums else -1\n\nSnippet2:\n        if target in nums:\n            return nums.index(target)\n        else:\n            return -1"
                    },
                    {
                        "username": "pranitarora03",
                        "content": "class Solution(object):\\n    def search(self, nums, target):\\n        \"\"\"\\n        :type nums: List[int]\\n        :type target: int\\n        :rtype: int\\n        \"\"\"\\n\\n        def findMid(nums):\\n            low = 0\\n            high = len(nums)-1\\n            \\n            while low < high:\\n                mid = (low+high) // 2\\n                \\n                if mid > 0 and nums[mid]> nums[mid+1]:\\n                    return mid\\n                elif nums[mid] > nums[len(nums)-1]:\\n                    low = mid+1\\n                elif nums[mid] < nums[len(nums)-1]:\\n                    high = mid-1\\n            return 0\\n\\n\\n        def bs(nums,target,low,high):\\n            # low = 0 \\n            # high = len(nums)-1\\n\\n            while low <= high:\\n                mid = (low+high) // 2 \\n                if nums[mid] == target:\\n                    return mid\\n                elif nums[mid] < target:\\n                    low = mid+1\\n                else:\\n                    high = mid-1\\n            return -1                    \\n\\n\\n\\n        result = findMid(nums)\\n        # newNum = nums[:result] + nums[result+1:]\\n        if target <= nums[len(nums)-1]:\\n            low = result\\n            high = len(nums)-1\\n            return bs(nums,target,low,high)\\n        else:\\n            return bs(nums,target,0,result)\\n\\n\\n\\nPassed 171/195 tests cases. Please Review where did it went wrong"
                    },
                    {
                        "username": "rohiinegi2002",
                        "content": "i think you should return low instead of 0 in the find mid func.. and also make high as mid\\n\\n\\n..here is the code for:\\n\\n\\nclass Solution(object):\\n    def search(self, nums, target):\\n        \"\"\"\\n        :type nums: List[int]\\n        :type target: int\\n        :rtype: int\\n        \"\"\"\\n        def findPivot(nums):\\n            low = 0\\n            high = len(nums) - 1\\n\\n            while low < high:\\n                mid = (low + high) // 2\\n\\n                if nums[mid] > nums[high]:\\n                    low = mid + 1\\n                else:\\n                    high = mid\\n\\n            return low\\n\\n        def binarySearch(nums, target, low, high):\\n            while low <= high:\\n                mid = (low + high) // 2\\n                if nums[mid] == target:\\n                    return mid\\n                elif nums[mid] < target:\\n                    low = mid + 1\\n                else:\\n                    high = mid - 1\\n            return -1\\n\\n        pivot = findPivot(nums)\\n        n = len(nums)\\n        \\n        if target >= nums[pivot] and target <= nums[n - 1]:\\n            return binarySearch(nums, target, pivot, n - 1)\\n        else:\\n            return binarySearch(nums, target, 0, pivot - 1)\\n"
                    },
                    {
                        "username": "tnzngdw",
                        "content": "return Arrays.binarySearch(nums,target); why this code doesnt work for this ?"
                    },
                    {
                        "username": "honourableahamedsha001",
                        "content": "\\nquestion clearly states ```possibly rotated``` , which means you have to include a case where array is not rotated"
                    }
                ]
            },
            {
                "id": 1994510,
                "content": [
                    {
                        "username": "Lsfhv",
                        "content": "2 Binary searches "
                    },
                    {
                        "username": "Sakab_132",
                        "content": "can anybody explain the concept pls.............."
                    },
                    {
                        "username": "Rightlyso",
                        "content": "Find the min number in the vector, min no would be smaller than both it\\'s neighbor. Then apply two binary search on left and right side of the vector"
                    },
                    {
                        "username": "thuynh3",
                        "content": "Binary search to find pivot. Then one mini binary search either from start-pivot or pivot-end to find the item."
                    },
                    {
                        "username": "cubiclestudios",
                        "content": "Isn\\'t there an error with test case 175\\n`[242,245,249,250,252,253,257,262,263,268,275,280,282,283,285,290,292,293,297,299,4,5,8,9,10,14,16,17,18,20,22,23,29,32,36,39,47,51,56,68,70,73,75,77,79,81,82,89,98,100,107,108,112,114,115,117,118,119,128,131,134,139,142,147,148,154,161,162,165,167,171,172,174,177,180,183,189,190,191,192,194,197,200,203,206,207,208,209,210,212,217,220,223,226,227,231,237]. `\\nThis test case is incorrect because its not in ascending rotated order. It jumps from 299, to 4, to 14. "
                    },
                    {
                        "username": "thuynh3",
                        "content": "I understand how it works but the edges are so hard to take care of"
                    },
                    {
                        "username": "Ultron03",
                        "content": "just reduce your input size ->run ->correct your code "
                    },
                    {
                        "username": "Nitkapur30",
                        "content": "In the given question, we can see that there may be a pivot point in the array. To make sure that binary search can be applied, we break down the question into 3 simple conditions:\\n\\nIf array is rotated and nums[mid]>nums[end]\\nIf the array is rotated and nums[mid]>nums[start]\\nif the array is sorted without rotation.\\nAll these steps are further broken down to two conditions each that helps us find the exact position for target.\\n\\nFor Example: Step 1), if nums[mid]>nums[end], then we further check position of target to see if it lies between mid and end or start and end and proceed by applying binary search accordingly.\\n\\nIn 3) Step, we can apply normal binary search since the array is sorted. If target is not found with the help of all these steps, simply return -1."
                    },
                    {
                        "username": "parass419",
                        "content": "\\nint FindPivot(vector<int>& arr, int n ){\\n    int s = 0;\\n    int e = n-1;\\n    int mid = s +(e-s)/2;\\n\\n    while(s<e){\\n        if(arr[mid] >= arr[0]){\\n            s = mid+1;\\n            }\\n            else{\\n                e = mid;\\n\\n            }\\n            mid= s+(e-s)/2;\\n    }\\n    return s;\\n}\\n\\n\\n\\n\\nint BinarySearch(vector<int>& arr , int s , int e  , int key){ // S and E // // here because here array is already divided into two parts thats why we ///// are getting the starting and ending undex if the array.\\n   \\n    int mid = s+(e-s)/2;\\n    int i = 0;\\n    int size = arr.size();\\n\\n    while(i<size){\\n        if(arr[mid]==key ){\\n            return mid;\\n        }\\n        else if(arr[mid]<key){\\n            s = mid+1;\\n        }\\n        else{\\n            e = mid-1; \\n        }\\n        mid = s+(e-s)/2;\\n\\n    }\\nreturn s;\\n     \\n}\\n\\n\\nclass Solution {\\npublic:\\n    int search(vector<int>& nums, int target) {\\n        int size = nums.size();\\n        int pivot = FindPivot(nums , size);\\n        if( target >= nums[pivot]  &&  target <=nums[size-1])\\n        {\\n            return BinarySearch(nums,pivot,size-1,target);\\n        }\\n        else{\\n             return BinarySearch(nums,0,pivot - 1,target);\\n        }\\n\\n    }\\n};\\n\\n\\nWHy this code shows TLE"
                    },
                    {
                        "username": "mukul_gupta_",
                        "content": "Does number of lines affects the memory?\nAs both the code below is same only way of writing the code differs. Can someone explain it to me?\nSnippet1:\n        return nums.index(target) if target in nums else -1\n\nSnippet2:\n        if target in nums:\n            return nums.index(target)\n        else:\n            return -1"
                    },
                    {
                        "username": "pranitarora03",
                        "content": "class Solution(object):\\n    def search(self, nums, target):\\n        \"\"\"\\n        :type nums: List[int]\\n        :type target: int\\n        :rtype: int\\n        \"\"\"\\n\\n        def findMid(nums):\\n            low = 0\\n            high = len(nums)-1\\n            \\n            while low < high:\\n                mid = (low+high) // 2\\n                \\n                if mid > 0 and nums[mid]> nums[mid+1]:\\n                    return mid\\n                elif nums[mid] > nums[len(nums)-1]:\\n                    low = mid+1\\n                elif nums[mid] < nums[len(nums)-1]:\\n                    high = mid-1\\n            return 0\\n\\n\\n        def bs(nums,target,low,high):\\n            # low = 0 \\n            # high = len(nums)-1\\n\\n            while low <= high:\\n                mid = (low+high) // 2 \\n                if nums[mid] == target:\\n                    return mid\\n                elif nums[mid] < target:\\n                    low = mid+1\\n                else:\\n                    high = mid-1\\n            return -1                    \\n\\n\\n\\n        result = findMid(nums)\\n        # newNum = nums[:result] + nums[result+1:]\\n        if target <= nums[len(nums)-1]:\\n            low = result\\n            high = len(nums)-1\\n            return bs(nums,target,low,high)\\n        else:\\n            return bs(nums,target,0,result)\\n\\n\\n\\nPassed 171/195 tests cases. Please Review where did it went wrong"
                    },
                    {
                        "username": "rohiinegi2002",
                        "content": "i think you should return low instead of 0 in the find mid func.. and also make high as mid\\n\\n\\n..here is the code for:\\n\\n\\nclass Solution(object):\\n    def search(self, nums, target):\\n        \"\"\"\\n        :type nums: List[int]\\n        :type target: int\\n        :rtype: int\\n        \"\"\"\\n        def findPivot(nums):\\n            low = 0\\n            high = len(nums) - 1\\n\\n            while low < high:\\n                mid = (low + high) // 2\\n\\n                if nums[mid] > nums[high]:\\n                    low = mid + 1\\n                else:\\n                    high = mid\\n\\n            return low\\n\\n        def binarySearch(nums, target, low, high):\\n            while low <= high:\\n                mid = (low + high) // 2\\n                if nums[mid] == target:\\n                    return mid\\n                elif nums[mid] < target:\\n                    low = mid + 1\\n                else:\\n                    high = mid - 1\\n            return -1\\n\\n        pivot = findPivot(nums)\\n        n = len(nums)\\n        \\n        if target >= nums[pivot] and target <= nums[n - 1]:\\n            return binarySearch(nums, target, pivot, n - 1)\\n        else:\\n            return binarySearch(nums, target, 0, pivot - 1)\\n"
                    },
                    {
                        "username": "tnzngdw",
                        "content": "return Arrays.binarySearch(nums,target); why this code doesnt work for this ?"
                    },
                    {
                        "username": "honourableahamedsha001",
                        "content": "\\nquestion clearly states ```possibly rotated``` , which means you have to include a case where array is not rotated"
                    }
                ]
            },
            {
                "id": 1978889,
                "content": [
                    {
                        "username": "Lsfhv",
                        "content": "2 Binary searches "
                    },
                    {
                        "username": "Sakab_132",
                        "content": "can anybody explain the concept pls.............."
                    },
                    {
                        "username": "Rightlyso",
                        "content": "Find the min number in the vector, min no would be smaller than both it\\'s neighbor. Then apply two binary search on left and right side of the vector"
                    },
                    {
                        "username": "thuynh3",
                        "content": "Binary search to find pivot. Then one mini binary search either from start-pivot or pivot-end to find the item."
                    },
                    {
                        "username": "cubiclestudios",
                        "content": "Isn\\'t there an error with test case 175\\n`[242,245,249,250,252,253,257,262,263,268,275,280,282,283,285,290,292,293,297,299,4,5,8,9,10,14,16,17,18,20,22,23,29,32,36,39,47,51,56,68,70,73,75,77,79,81,82,89,98,100,107,108,112,114,115,117,118,119,128,131,134,139,142,147,148,154,161,162,165,167,171,172,174,177,180,183,189,190,191,192,194,197,200,203,206,207,208,209,210,212,217,220,223,226,227,231,237]. `\\nThis test case is incorrect because its not in ascending rotated order. It jumps from 299, to 4, to 14. "
                    },
                    {
                        "username": "thuynh3",
                        "content": "I understand how it works but the edges are so hard to take care of"
                    },
                    {
                        "username": "Ultron03",
                        "content": "just reduce your input size ->run ->correct your code "
                    },
                    {
                        "username": "Nitkapur30",
                        "content": "In the given question, we can see that there may be a pivot point in the array. To make sure that binary search can be applied, we break down the question into 3 simple conditions:\\n\\nIf array is rotated and nums[mid]>nums[end]\\nIf the array is rotated and nums[mid]>nums[start]\\nif the array is sorted without rotation.\\nAll these steps are further broken down to two conditions each that helps us find the exact position for target.\\n\\nFor Example: Step 1), if nums[mid]>nums[end], then we further check position of target to see if it lies between mid and end or start and end and proceed by applying binary search accordingly.\\n\\nIn 3) Step, we can apply normal binary search since the array is sorted. If target is not found with the help of all these steps, simply return -1."
                    },
                    {
                        "username": "parass419",
                        "content": "\\nint FindPivot(vector<int>& arr, int n ){\\n    int s = 0;\\n    int e = n-1;\\n    int mid = s +(e-s)/2;\\n\\n    while(s<e){\\n        if(arr[mid] >= arr[0]){\\n            s = mid+1;\\n            }\\n            else{\\n                e = mid;\\n\\n            }\\n            mid= s+(e-s)/2;\\n    }\\n    return s;\\n}\\n\\n\\n\\n\\nint BinarySearch(vector<int>& arr , int s , int e  , int key){ // S and E // // here because here array is already divided into two parts thats why we ///// are getting the starting and ending undex if the array.\\n   \\n    int mid = s+(e-s)/2;\\n    int i = 0;\\n    int size = arr.size();\\n\\n    while(i<size){\\n        if(arr[mid]==key ){\\n            return mid;\\n        }\\n        else if(arr[mid]<key){\\n            s = mid+1;\\n        }\\n        else{\\n            e = mid-1; \\n        }\\n        mid = s+(e-s)/2;\\n\\n    }\\nreturn s;\\n     \\n}\\n\\n\\nclass Solution {\\npublic:\\n    int search(vector<int>& nums, int target) {\\n        int size = nums.size();\\n        int pivot = FindPivot(nums , size);\\n        if( target >= nums[pivot]  &&  target <=nums[size-1])\\n        {\\n            return BinarySearch(nums,pivot,size-1,target);\\n        }\\n        else{\\n             return BinarySearch(nums,0,pivot - 1,target);\\n        }\\n\\n    }\\n};\\n\\n\\nWHy this code shows TLE"
                    },
                    {
                        "username": "mukul_gupta_",
                        "content": "Does number of lines affects the memory?\nAs both the code below is same only way of writing the code differs. Can someone explain it to me?\nSnippet1:\n        return nums.index(target) if target in nums else -1\n\nSnippet2:\n        if target in nums:\n            return nums.index(target)\n        else:\n            return -1"
                    },
                    {
                        "username": "pranitarora03",
                        "content": "class Solution(object):\\n    def search(self, nums, target):\\n        \"\"\"\\n        :type nums: List[int]\\n        :type target: int\\n        :rtype: int\\n        \"\"\"\\n\\n        def findMid(nums):\\n            low = 0\\n            high = len(nums)-1\\n            \\n            while low < high:\\n                mid = (low+high) // 2\\n                \\n                if mid > 0 and nums[mid]> nums[mid+1]:\\n                    return mid\\n                elif nums[mid] > nums[len(nums)-1]:\\n                    low = mid+1\\n                elif nums[mid] < nums[len(nums)-1]:\\n                    high = mid-1\\n            return 0\\n\\n\\n        def bs(nums,target,low,high):\\n            # low = 0 \\n            # high = len(nums)-1\\n\\n            while low <= high:\\n                mid = (low+high) // 2 \\n                if nums[mid] == target:\\n                    return mid\\n                elif nums[mid] < target:\\n                    low = mid+1\\n                else:\\n                    high = mid-1\\n            return -1                    \\n\\n\\n\\n        result = findMid(nums)\\n        # newNum = nums[:result] + nums[result+1:]\\n        if target <= nums[len(nums)-1]:\\n            low = result\\n            high = len(nums)-1\\n            return bs(nums,target,low,high)\\n        else:\\n            return bs(nums,target,0,result)\\n\\n\\n\\nPassed 171/195 tests cases. Please Review where did it went wrong"
                    },
                    {
                        "username": "rohiinegi2002",
                        "content": "i think you should return low instead of 0 in the find mid func.. and also make high as mid\\n\\n\\n..here is the code for:\\n\\n\\nclass Solution(object):\\n    def search(self, nums, target):\\n        \"\"\"\\n        :type nums: List[int]\\n        :type target: int\\n        :rtype: int\\n        \"\"\"\\n        def findPivot(nums):\\n            low = 0\\n            high = len(nums) - 1\\n\\n            while low < high:\\n                mid = (low + high) // 2\\n\\n                if nums[mid] > nums[high]:\\n                    low = mid + 1\\n                else:\\n                    high = mid\\n\\n            return low\\n\\n        def binarySearch(nums, target, low, high):\\n            while low <= high:\\n                mid = (low + high) // 2\\n                if nums[mid] == target:\\n                    return mid\\n                elif nums[mid] < target:\\n                    low = mid + 1\\n                else:\\n                    high = mid - 1\\n            return -1\\n\\n        pivot = findPivot(nums)\\n        n = len(nums)\\n        \\n        if target >= nums[pivot] and target <= nums[n - 1]:\\n            return binarySearch(nums, target, pivot, n - 1)\\n        else:\\n            return binarySearch(nums, target, 0, pivot - 1)\\n"
                    },
                    {
                        "username": "tnzngdw",
                        "content": "return Arrays.binarySearch(nums,target); why this code doesnt work for this ?"
                    },
                    {
                        "username": "honourableahamedsha001",
                        "content": "\\nquestion clearly states ```possibly rotated``` , which means you have to include a case where array is not rotated"
                    }
                ]
            },
            {
                "id": 1977884,
                "content": [
                    {
                        "username": "Lsfhv",
                        "content": "2 Binary searches "
                    },
                    {
                        "username": "Sakab_132",
                        "content": "can anybody explain the concept pls.............."
                    },
                    {
                        "username": "Rightlyso",
                        "content": "Find the min number in the vector, min no would be smaller than both it\\'s neighbor. Then apply two binary search on left and right side of the vector"
                    },
                    {
                        "username": "thuynh3",
                        "content": "Binary search to find pivot. Then one mini binary search either from start-pivot or pivot-end to find the item."
                    },
                    {
                        "username": "cubiclestudios",
                        "content": "Isn\\'t there an error with test case 175\\n`[242,245,249,250,252,253,257,262,263,268,275,280,282,283,285,290,292,293,297,299,4,5,8,9,10,14,16,17,18,20,22,23,29,32,36,39,47,51,56,68,70,73,75,77,79,81,82,89,98,100,107,108,112,114,115,117,118,119,128,131,134,139,142,147,148,154,161,162,165,167,171,172,174,177,180,183,189,190,191,192,194,197,200,203,206,207,208,209,210,212,217,220,223,226,227,231,237]. `\\nThis test case is incorrect because its not in ascending rotated order. It jumps from 299, to 4, to 14. "
                    },
                    {
                        "username": "thuynh3",
                        "content": "I understand how it works but the edges are so hard to take care of"
                    },
                    {
                        "username": "Ultron03",
                        "content": "just reduce your input size ->run ->correct your code "
                    },
                    {
                        "username": "Nitkapur30",
                        "content": "In the given question, we can see that there may be a pivot point in the array. To make sure that binary search can be applied, we break down the question into 3 simple conditions:\\n\\nIf array is rotated and nums[mid]>nums[end]\\nIf the array is rotated and nums[mid]>nums[start]\\nif the array is sorted without rotation.\\nAll these steps are further broken down to two conditions each that helps us find the exact position for target.\\n\\nFor Example: Step 1), if nums[mid]>nums[end], then we further check position of target to see if it lies between mid and end or start and end and proceed by applying binary search accordingly.\\n\\nIn 3) Step, we can apply normal binary search since the array is sorted. If target is not found with the help of all these steps, simply return -1."
                    },
                    {
                        "username": "parass419",
                        "content": "\\nint FindPivot(vector<int>& arr, int n ){\\n    int s = 0;\\n    int e = n-1;\\n    int mid = s +(e-s)/2;\\n\\n    while(s<e){\\n        if(arr[mid] >= arr[0]){\\n            s = mid+1;\\n            }\\n            else{\\n                e = mid;\\n\\n            }\\n            mid= s+(e-s)/2;\\n    }\\n    return s;\\n}\\n\\n\\n\\n\\nint BinarySearch(vector<int>& arr , int s , int e  , int key){ // S and E // // here because here array is already divided into two parts thats why we ///// are getting the starting and ending undex if the array.\\n   \\n    int mid = s+(e-s)/2;\\n    int i = 0;\\n    int size = arr.size();\\n\\n    while(i<size){\\n        if(arr[mid]==key ){\\n            return mid;\\n        }\\n        else if(arr[mid]<key){\\n            s = mid+1;\\n        }\\n        else{\\n            e = mid-1; \\n        }\\n        mid = s+(e-s)/2;\\n\\n    }\\nreturn s;\\n     \\n}\\n\\n\\nclass Solution {\\npublic:\\n    int search(vector<int>& nums, int target) {\\n        int size = nums.size();\\n        int pivot = FindPivot(nums , size);\\n        if( target >= nums[pivot]  &&  target <=nums[size-1])\\n        {\\n            return BinarySearch(nums,pivot,size-1,target);\\n        }\\n        else{\\n             return BinarySearch(nums,0,pivot - 1,target);\\n        }\\n\\n    }\\n};\\n\\n\\nWHy this code shows TLE"
                    },
                    {
                        "username": "mukul_gupta_",
                        "content": "Does number of lines affects the memory?\nAs both the code below is same only way of writing the code differs. Can someone explain it to me?\nSnippet1:\n        return nums.index(target) if target in nums else -1\n\nSnippet2:\n        if target in nums:\n            return nums.index(target)\n        else:\n            return -1"
                    },
                    {
                        "username": "pranitarora03",
                        "content": "class Solution(object):\\n    def search(self, nums, target):\\n        \"\"\"\\n        :type nums: List[int]\\n        :type target: int\\n        :rtype: int\\n        \"\"\"\\n\\n        def findMid(nums):\\n            low = 0\\n            high = len(nums)-1\\n            \\n            while low < high:\\n                mid = (low+high) // 2\\n                \\n                if mid > 0 and nums[mid]> nums[mid+1]:\\n                    return mid\\n                elif nums[mid] > nums[len(nums)-1]:\\n                    low = mid+1\\n                elif nums[mid] < nums[len(nums)-1]:\\n                    high = mid-1\\n            return 0\\n\\n\\n        def bs(nums,target,low,high):\\n            # low = 0 \\n            # high = len(nums)-1\\n\\n            while low <= high:\\n                mid = (low+high) // 2 \\n                if nums[mid] == target:\\n                    return mid\\n                elif nums[mid] < target:\\n                    low = mid+1\\n                else:\\n                    high = mid-1\\n            return -1                    \\n\\n\\n\\n        result = findMid(nums)\\n        # newNum = nums[:result] + nums[result+1:]\\n        if target <= nums[len(nums)-1]:\\n            low = result\\n            high = len(nums)-1\\n            return bs(nums,target,low,high)\\n        else:\\n            return bs(nums,target,0,result)\\n\\n\\n\\nPassed 171/195 tests cases. Please Review where did it went wrong"
                    },
                    {
                        "username": "rohiinegi2002",
                        "content": "i think you should return low instead of 0 in the find mid func.. and also make high as mid\\n\\n\\n..here is the code for:\\n\\n\\nclass Solution(object):\\n    def search(self, nums, target):\\n        \"\"\"\\n        :type nums: List[int]\\n        :type target: int\\n        :rtype: int\\n        \"\"\"\\n        def findPivot(nums):\\n            low = 0\\n            high = len(nums) - 1\\n\\n            while low < high:\\n                mid = (low + high) // 2\\n\\n                if nums[mid] > nums[high]:\\n                    low = mid + 1\\n                else:\\n                    high = mid\\n\\n            return low\\n\\n        def binarySearch(nums, target, low, high):\\n            while low <= high:\\n                mid = (low + high) // 2\\n                if nums[mid] == target:\\n                    return mid\\n                elif nums[mid] < target:\\n                    low = mid + 1\\n                else:\\n                    high = mid - 1\\n            return -1\\n\\n        pivot = findPivot(nums)\\n        n = len(nums)\\n        \\n        if target >= nums[pivot] and target <= nums[n - 1]:\\n            return binarySearch(nums, target, pivot, n - 1)\\n        else:\\n            return binarySearch(nums, target, 0, pivot - 1)\\n"
                    },
                    {
                        "username": "tnzngdw",
                        "content": "return Arrays.binarySearch(nums,target); why this code doesnt work for this ?"
                    },
                    {
                        "username": "honourableahamedsha001",
                        "content": "\\nquestion clearly states ```possibly rotated``` , which means you have to include a case where array is not rotated"
                    }
                ]
            },
            {
                "id": 1975460,
                "content": [
                    {
                        "username": "Lsfhv",
                        "content": "2 Binary searches "
                    },
                    {
                        "username": "Sakab_132",
                        "content": "can anybody explain the concept pls.............."
                    },
                    {
                        "username": "Rightlyso",
                        "content": "Find the min number in the vector, min no would be smaller than both it\\'s neighbor. Then apply two binary search on left and right side of the vector"
                    },
                    {
                        "username": "thuynh3",
                        "content": "Binary search to find pivot. Then one mini binary search either from start-pivot or pivot-end to find the item."
                    },
                    {
                        "username": "cubiclestudios",
                        "content": "Isn\\'t there an error with test case 175\\n`[242,245,249,250,252,253,257,262,263,268,275,280,282,283,285,290,292,293,297,299,4,5,8,9,10,14,16,17,18,20,22,23,29,32,36,39,47,51,56,68,70,73,75,77,79,81,82,89,98,100,107,108,112,114,115,117,118,119,128,131,134,139,142,147,148,154,161,162,165,167,171,172,174,177,180,183,189,190,191,192,194,197,200,203,206,207,208,209,210,212,217,220,223,226,227,231,237]. `\\nThis test case is incorrect because its not in ascending rotated order. It jumps from 299, to 4, to 14. "
                    },
                    {
                        "username": "thuynh3",
                        "content": "I understand how it works but the edges are so hard to take care of"
                    },
                    {
                        "username": "Ultron03",
                        "content": "just reduce your input size ->run ->correct your code "
                    },
                    {
                        "username": "Nitkapur30",
                        "content": "In the given question, we can see that there may be a pivot point in the array. To make sure that binary search can be applied, we break down the question into 3 simple conditions:\\n\\nIf array is rotated and nums[mid]>nums[end]\\nIf the array is rotated and nums[mid]>nums[start]\\nif the array is sorted without rotation.\\nAll these steps are further broken down to two conditions each that helps us find the exact position for target.\\n\\nFor Example: Step 1), if nums[mid]>nums[end], then we further check position of target to see if it lies between mid and end or start and end and proceed by applying binary search accordingly.\\n\\nIn 3) Step, we can apply normal binary search since the array is sorted. If target is not found with the help of all these steps, simply return -1."
                    },
                    {
                        "username": "parass419",
                        "content": "\\nint FindPivot(vector<int>& arr, int n ){\\n    int s = 0;\\n    int e = n-1;\\n    int mid = s +(e-s)/2;\\n\\n    while(s<e){\\n        if(arr[mid] >= arr[0]){\\n            s = mid+1;\\n            }\\n            else{\\n                e = mid;\\n\\n            }\\n            mid= s+(e-s)/2;\\n    }\\n    return s;\\n}\\n\\n\\n\\n\\nint BinarySearch(vector<int>& arr , int s , int e  , int key){ // S and E // // here because here array is already divided into two parts thats why we ///// are getting the starting and ending undex if the array.\\n   \\n    int mid = s+(e-s)/2;\\n    int i = 0;\\n    int size = arr.size();\\n\\n    while(i<size){\\n        if(arr[mid]==key ){\\n            return mid;\\n        }\\n        else if(arr[mid]<key){\\n            s = mid+1;\\n        }\\n        else{\\n            e = mid-1; \\n        }\\n        mid = s+(e-s)/2;\\n\\n    }\\nreturn s;\\n     \\n}\\n\\n\\nclass Solution {\\npublic:\\n    int search(vector<int>& nums, int target) {\\n        int size = nums.size();\\n        int pivot = FindPivot(nums , size);\\n        if( target >= nums[pivot]  &&  target <=nums[size-1])\\n        {\\n            return BinarySearch(nums,pivot,size-1,target);\\n        }\\n        else{\\n             return BinarySearch(nums,0,pivot - 1,target);\\n        }\\n\\n    }\\n};\\n\\n\\nWHy this code shows TLE"
                    },
                    {
                        "username": "mukul_gupta_",
                        "content": "Does number of lines affects the memory?\nAs both the code below is same only way of writing the code differs. Can someone explain it to me?\nSnippet1:\n        return nums.index(target) if target in nums else -1\n\nSnippet2:\n        if target in nums:\n            return nums.index(target)\n        else:\n            return -1"
                    },
                    {
                        "username": "pranitarora03",
                        "content": "class Solution(object):\\n    def search(self, nums, target):\\n        \"\"\"\\n        :type nums: List[int]\\n        :type target: int\\n        :rtype: int\\n        \"\"\"\\n\\n        def findMid(nums):\\n            low = 0\\n            high = len(nums)-1\\n            \\n            while low < high:\\n                mid = (low+high) // 2\\n                \\n                if mid > 0 and nums[mid]> nums[mid+1]:\\n                    return mid\\n                elif nums[mid] > nums[len(nums)-1]:\\n                    low = mid+1\\n                elif nums[mid] < nums[len(nums)-1]:\\n                    high = mid-1\\n            return 0\\n\\n\\n        def bs(nums,target,low,high):\\n            # low = 0 \\n            # high = len(nums)-1\\n\\n            while low <= high:\\n                mid = (low+high) // 2 \\n                if nums[mid] == target:\\n                    return mid\\n                elif nums[mid] < target:\\n                    low = mid+1\\n                else:\\n                    high = mid-1\\n            return -1                    \\n\\n\\n\\n        result = findMid(nums)\\n        # newNum = nums[:result] + nums[result+1:]\\n        if target <= nums[len(nums)-1]:\\n            low = result\\n            high = len(nums)-1\\n            return bs(nums,target,low,high)\\n        else:\\n            return bs(nums,target,0,result)\\n\\n\\n\\nPassed 171/195 tests cases. Please Review where did it went wrong"
                    },
                    {
                        "username": "rohiinegi2002",
                        "content": "i think you should return low instead of 0 in the find mid func.. and also make high as mid\\n\\n\\n..here is the code for:\\n\\n\\nclass Solution(object):\\n    def search(self, nums, target):\\n        \"\"\"\\n        :type nums: List[int]\\n        :type target: int\\n        :rtype: int\\n        \"\"\"\\n        def findPivot(nums):\\n            low = 0\\n            high = len(nums) - 1\\n\\n            while low < high:\\n                mid = (low + high) // 2\\n\\n                if nums[mid] > nums[high]:\\n                    low = mid + 1\\n                else:\\n                    high = mid\\n\\n            return low\\n\\n        def binarySearch(nums, target, low, high):\\n            while low <= high:\\n                mid = (low + high) // 2\\n                if nums[mid] == target:\\n                    return mid\\n                elif nums[mid] < target:\\n                    low = mid + 1\\n                else:\\n                    high = mid - 1\\n            return -1\\n\\n        pivot = findPivot(nums)\\n        n = len(nums)\\n        \\n        if target >= nums[pivot] and target <= nums[n - 1]:\\n            return binarySearch(nums, target, pivot, n - 1)\\n        else:\\n            return binarySearch(nums, target, 0, pivot - 1)\\n"
                    },
                    {
                        "username": "tnzngdw",
                        "content": "return Arrays.binarySearch(nums,target); why this code doesnt work for this ?"
                    },
                    {
                        "username": "honourableahamedsha001",
                        "content": "\\nquestion clearly states ```possibly rotated``` , which means you have to include a case where array is not rotated"
                    }
                ]
            },
            {
                "id": 1974882,
                "content": [
                    {
                        "username": "Lsfhv",
                        "content": "2 Binary searches "
                    },
                    {
                        "username": "Sakab_132",
                        "content": "can anybody explain the concept pls.............."
                    },
                    {
                        "username": "Rightlyso",
                        "content": "Find the min number in the vector, min no would be smaller than both it\\'s neighbor. Then apply two binary search on left and right side of the vector"
                    },
                    {
                        "username": "thuynh3",
                        "content": "Binary search to find pivot. Then one mini binary search either from start-pivot or pivot-end to find the item."
                    },
                    {
                        "username": "cubiclestudios",
                        "content": "Isn\\'t there an error with test case 175\\n`[242,245,249,250,252,253,257,262,263,268,275,280,282,283,285,290,292,293,297,299,4,5,8,9,10,14,16,17,18,20,22,23,29,32,36,39,47,51,56,68,70,73,75,77,79,81,82,89,98,100,107,108,112,114,115,117,118,119,128,131,134,139,142,147,148,154,161,162,165,167,171,172,174,177,180,183,189,190,191,192,194,197,200,203,206,207,208,209,210,212,217,220,223,226,227,231,237]. `\\nThis test case is incorrect because its not in ascending rotated order. It jumps from 299, to 4, to 14. "
                    },
                    {
                        "username": "thuynh3",
                        "content": "I understand how it works but the edges are so hard to take care of"
                    },
                    {
                        "username": "Ultron03",
                        "content": "just reduce your input size ->run ->correct your code "
                    },
                    {
                        "username": "Nitkapur30",
                        "content": "In the given question, we can see that there may be a pivot point in the array. To make sure that binary search can be applied, we break down the question into 3 simple conditions:\\n\\nIf array is rotated and nums[mid]>nums[end]\\nIf the array is rotated and nums[mid]>nums[start]\\nif the array is sorted without rotation.\\nAll these steps are further broken down to two conditions each that helps us find the exact position for target.\\n\\nFor Example: Step 1), if nums[mid]>nums[end], then we further check position of target to see if it lies between mid and end or start and end and proceed by applying binary search accordingly.\\n\\nIn 3) Step, we can apply normal binary search since the array is sorted. If target is not found with the help of all these steps, simply return -1."
                    },
                    {
                        "username": "parass419",
                        "content": "\\nint FindPivot(vector<int>& arr, int n ){\\n    int s = 0;\\n    int e = n-1;\\n    int mid = s +(e-s)/2;\\n\\n    while(s<e){\\n        if(arr[mid] >= arr[0]){\\n            s = mid+1;\\n            }\\n            else{\\n                e = mid;\\n\\n            }\\n            mid= s+(e-s)/2;\\n    }\\n    return s;\\n}\\n\\n\\n\\n\\nint BinarySearch(vector<int>& arr , int s , int e  , int key){ // S and E // // here because here array is already divided into two parts thats why we ///// are getting the starting and ending undex if the array.\\n   \\n    int mid = s+(e-s)/2;\\n    int i = 0;\\n    int size = arr.size();\\n\\n    while(i<size){\\n        if(arr[mid]==key ){\\n            return mid;\\n        }\\n        else if(arr[mid]<key){\\n            s = mid+1;\\n        }\\n        else{\\n            e = mid-1; \\n        }\\n        mid = s+(e-s)/2;\\n\\n    }\\nreturn s;\\n     \\n}\\n\\n\\nclass Solution {\\npublic:\\n    int search(vector<int>& nums, int target) {\\n        int size = nums.size();\\n        int pivot = FindPivot(nums , size);\\n        if( target >= nums[pivot]  &&  target <=nums[size-1])\\n        {\\n            return BinarySearch(nums,pivot,size-1,target);\\n        }\\n        else{\\n             return BinarySearch(nums,0,pivot - 1,target);\\n        }\\n\\n    }\\n};\\n\\n\\nWHy this code shows TLE"
                    },
                    {
                        "username": "mukul_gupta_",
                        "content": "Does number of lines affects the memory?\nAs both the code below is same only way of writing the code differs. Can someone explain it to me?\nSnippet1:\n        return nums.index(target) if target in nums else -1\n\nSnippet2:\n        if target in nums:\n            return nums.index(target)\n        else:\n            return -1"
                    },
                    {
                        "username": "pranitarora03",
                        "content": "class Solution(object):\\n    def search(self, nums, target):\\n        \"\"\"\\n        :type nums: List[int]\\n        :type target: int\\n        :rtype: int\\n        \"\"\"\\n\\n        def findMid(nums):\\n            low = 0\\n            high = len(nums)-1\\n            \\n            while low < high:\\n                mid = (low+high) // 2\\n                \\n                if mid > 0 and nums[mid]> nums[mid+1]:\\n                    return mid\\n                elif nums[mid] > nums[len(nums)-1]:\\n                    low = mid+1\\n                elif nums[mid] < nums[len(nums)-1]:\\n                    high = mid-1\\n            return 0\\n\\n\\n        def bs(nums,target,low,high):\\n            # low = 0 \\n            # high = len(nums)-1\\n\\n            while low <= high:\\n                mid = (low+high) // 2 \\n                if nums[mid] == target:\\n                    return mid\\n                elif nums[mid] < target:\\n                    low = mid+1\\n                else:\\n                    high = mid-1\\n            return -1                    \\n\\n\\n\\n        result = findMid(nums)\\n        # newNum = nums[:result] + nums[result+1:]\\n        if target <= nums[len(nums)-1]:\\n            low = result\\n            high = len(nums)-1\\n            return bs(nums,target,low,high)\\n        else:\\n            return bs(nums,target,0,result)\\n\\n\\n\\nPassed 171/195 tests cases. Please Review where did it went wrong"
                    },
                    {
                        "username": "rohiinegi2002",
                        "content": "i think you should return low instead of 0 in the find mid func.. and also make high as mid\\n\\n\\n..here is the code for:\\n\\n\\nclass Solution(object):\\n    def search(self, nums, target):\\n        \"\"\"\\n        :type nums: List[int]\\n        :type target: int\\n        :rtype: int\\n        \"\"\"\\n        def findPivot(nums):\\n            low = 0\\n            high = len(nums) - 1\\n\\n            while low < high:\\n                mid = (low + high) // 2\\n\\n                if nums[mid] > nums[high]:\\n                    low = mid + 1\\n                else:\\n                    high = mid\\n\\n            return low\\n\\n        def binarySearch(nums, target, low, high):\\n            while low <= high:\\n                mid = (low + high) // 2\\n                if nums[mid] == target:\\n                    return mid\\n                elif nums[mid] < target:\\n                    low = mid + 1\\n                else:\\n                    high = mid - 1\\n            return -1\\n\\n        pivot = findPivot(nums)\\n        n = len(nums)\\n        \\n        if target >= nums[pivot] and target <= nums[n - 1]:\\n            return binarySearch(nums, target, pivot, n - 1)\\n        else:\\n            return binarySearch(nums, target, 0, pivot - 1)\\n"
                    },
                    {
                        "username": "tnzngdw",
                        "content": "return Arrays.binarySearch(nums,target); why this code doesnt work for this ?"
                    },
                    {
                        "username": "honourableahamedsha001",
                        "content": "\\nquestion clearly states ```possibly rotated``` , which means you have to include a case where array is not rotated"
                    }
                ]
            },
            {
                "id": 1974562,
                "content": [
                    {
                        "username": "Lsfhv",
                        "content": "2 Binary searches "
                    },
                    {
                        "username": "Sakab_132",
                        "content": "can anybody explain the concept pls.............."
                    },
                    {
                        "username": "Rightlyso",
                        "content": "Find the min number in the vector, min no would be smaller than both it\\'s neighbor. Then apply two binary search on left and right side of the vector"
                    },
                    {
                        "username": "thuynh3",
                        "content": "Binary search to find pivot. Then one mini binary search either from start-pivot or pivot-end to find the item."
                    },
                    {
                        "username": "cubiclestudios",
                        "content": "Isn\\'t there an error with test case 175\\n`[242,245,249,250,252,253,257,262,263,268,275,280,282,283,285,290,292,293,297,299,4,5,8,9,10,14,16,17,18,20,22,23,29,32,36,39,47,51,56,68,70,73,75,77,79,81,82,89,98,100,107,108,112,114,115,117,118,119,128,131,134,139,142,147,148,154,161,162,165,167,171,172,174,177,180,183,189,190,191,192,194,197,200,203,206,207,208,209,210,212,217,220,223,226,227,231,237]. `\\nThis test case is incorrect because its not in ascending rotated order. It jumps from 299, to 4, to 14. "
                    },
                    {
                        "username": "thuynh3",
                        "content": "I understand how it works but the edges are so hard to take care of"
                    },
                    {
                        "username": "Ultron03",
                        "content": "just reduce your input size ->run ->correct your code "
                    },
                    {
                        "username": "Nitkapur30",
                        "content": "In the given question, we can see that there may be a pivot point in the array. To make sure that binary search can be applied, we break down the question into 3 simple conditions:\\n\\nIf array is rotated and nums[mid]>nums[end]\\nIf the array is rotated and nums[mid]>nums[start]\\nif the array is sorted without rotation.\\nAll these steps are further broken down to two conditions each that helps us find the exact position for target.\\n\\nFor Example: Step 1), if nums[mid]>nums[end], then we further check position of target to see if it lies between mid and end or start and end and proceed by applying binary search accordingly.\\n\\nIn 3) Step, we can apply normal binary search since the array is sorted. If target is not found with the help of all these steps, simply return -1."
                    },
                    {
                        "username": "parass419",
                        "content": "\\nint FindPivot(vector<int>& arr, int n ){\\n    int s = 0;\\n    int e = n-1;\\n    int mid = s +(e-s)/2;\\n\\n    while(s<e){\\n        if(arr[mid] >= arr[0]){\\n            s = mid+1;\\n            }\\n            else{\\n                e = mid;\\n\\n            }\\n            mid= s+(e-s)/2;\\n    }\\n    return s;\\n}\\n\\n\\n\\n\\nint BinarySearch(vector<int>& arr , int s , int e  , int key){ // S and E // // here because here array is already divided into two parts thats why we ///// are getting the starting and ending undex if the array.\\n   \\n    int mid = s+(e-s)/2;\\n    int i = 0;\\n    int size = arr.size();\\n\\n    while(i<size){\\n        if(arr[mid]==key ){\\n            return mid;\\n        }\\n        else if(arr[mid]<key){\\n            s = mid+1;\\n        }\\n        else{\\n            e = mid-1; \\n        }\\n        mid = s+(e-s)/2;\\n\\n    }\\nreturn s;\\n     \\n}\\n\\n\\nclass Solution {\\npublic:\\n    int search(vector<int>& nums, int target) {\\n        int size = nums.size();\\n        int pivot = FindPivot(nums , size);\\n        if( target >= nums[pivot]  &&  target <=nums[size-1])\\n        {\\n            return BinarySearch(nums,pivot,size-1,target);\\n        }\\n        else{\\n             return BinarySearch(nums,0,pivot - 1,target);\\n        }\\n\\n    }\\n};\\n\\n\\nWHy this code shows TLE"
                    },
                    {
                        "username": "mukul_gupta_",
                        "content": "Does number of lines affects the memory?\nAs both the code below is same only way of writing the code differs. Can someone explain it to me?\nSnippet1:\n        return nums.index(target) if target in nums else -1\n\nSnippet2:\n        if target in nums:\n            return nums.index(target)\n        else:\n            return -1"
                    },
                    {
                        "username": "pranitarora03",
                        "content": "class Solution(object):\\n    def search(self, nums, target):\\n        \"\"\"\\n        :type nums: List[int]\\n        :type target: int\\n        :rtype: int\\n        \"\"\"\\n\\n        def findMid(nums):\\n            low = 0\\n            high = len(nums)-1\\n            \\n            while low < high:\\n                mid = (low+high) // 2\\n                \\n                if mid > 0 and nums[mid]> nums[mid+1]:\\n                    return mid\\n                elif nums[mid] > nums[len(nums)-1]:\\n                    low = mid+1\\n                elif nums[mid] < nums[len(nums)-1]:\\n                    high = mid-1\\n            return 0\\n\\n\\n        def bs(nums,target,low,high):\\n            # low = 0 \\n            # high = len(nums)-1\\n\\n            while low <= high:\\n                mid = (low+high) // 2 \\n                if nums[mid] == target:\\n                    return mid\\n                elif nums[mid] < target:\\n                    low = mid+1\\n                else:\\n                    high = mid-1\\n            return -1                    \\n\\n\\n\\n        result = findMid(nums)\\n        # newNum = nums[:result] + nums[result+1:]\\n        if target <= nums[len(nums)-1]:\\n            low = result\\n            high = len(nums)-1\\n            return bs(nums,target,low,high)\\n        else:\\n            return bs(nums,target,0,result)\\n\\n\\n\\nPassed 171/195 tests cases. Please Review where did it went wrong"
                    },
                    {
                        "username": "rohiinegi2002",
                        "content": "i think you should return low instead of 0 in the find mid func.. and also make high as mid\\n\\n\\n..here is the code for:\\n\\n\\nclass Solution(object):\\n    def search(self, nums, target):\\n        \"\"\"\\n        :type nums: List[int]\\n        :type target: int\\n        :rtype: int\\n        \"\"\"\\n        def findPivot(nums):\\n            low = 0\\n            high = len(nums) - 1\\n\\n            while low < high:\\n                mid = (low + high) // 2\\n\\n                if nums[mid] > nums[high]:\\n                    low = mid + 1\\n                else:\\n                    high = mid\\n\\n            return low\\n\\n        def binarySearch(nums, target, low, high):\\n            while low <= high:\\n                mid = (low + high) // 2\\n                if nums[mid] == target:\\n                    return mid\\n                elif nums[mid] < target:\\n                    low = mid + 1\\n                else:\\n                    high = mid - 1\\n            return -1\\n\\n        pivot = findPivot(nums)\\n        n = len(nums)\\n        \\n        if target >= nums[pivot] and target <= nums[n - 1]:\\n            return binarySearch(nums, target, pivot, n - 1)\\n        else:\\n            return binarySearch(nums, target, 0, pivot - 1)\\n"
                    },
                    {
                        "username": "tnzngdw",
                        "content": "return Arrays.binarySearch(nums,target); why this code doesnt work for this ?"
                    },
                    {
                        "username": "honourableahamedsha001",
                        "content": "\\nquestion clearly states ```possibly rotated``` , which means you have to include a case where array is not rotated"
                    }
                ]
            },
            {
                "id": 1972613,
                "content": [
                    {
                        "username": "Lsfhv",
                        "content": "2 Binary searches "
                    },
                    {
                        "username": "Sakab_132",
                        "content": "can anybody explain the concept pls.............."
                    },
                    {
                        "username": "Rightlyso",
                        "content": "Find the min number in the vector, min no would be smaller than both it\\'s neighbor. Then apply two binary search on left and right side of the vector"
                    },
                    {
                        "username": "thuynh3",
                        "content": "Binary search to find pivot. Then one mini binary search either from start-pivot or pivot-end to find the item."
                    },
                    {
                        "username": "cubiclestudios",
                        "content": "Isn\\'t there an error with test case 175\\n`[242,245,249,250,252,253,257,262,263,268,275,280,282,283,285,290,292,293,297,299,4,5,8,9,10,14,16,17,18,20,22,23,29,32,36,39,47,51,56,68,70,73,75,77,79,81,82,89,98,100,107,108,112,114,115,117,118,119,128,131,134,139,142,147,148,154,161,162,165,167,171,172,174,177,180,183,189,190,191,192,194,197,200,203,206,207,208,209,210,212,217,220,223,226,227,231,237]. `\\nThis test case is incorrect because its not in ascending rotated order. It jumps from 299, to 4, to 14. "
                    },
                    {
                        "username": "thuynh3",
                        "content": "I understand how it works but the edges are so hard to take care of"
                    },
                    {
                        "username": "Ultron03",
                        "content": "just reduce your input size ->run ->correct your code "
                    },
                    {
                        "username": "Nitkapur30",
                        "content": "In the given question, we can see that there may be a pivot point in the array. To make sure that binary search can be applied, we break down the question into 3 simple conditions:\\n\\nIf array is rotated and nums[mid]>nums[end]\\nIf the array is rotated and nums[mid]>nums[start]\\nif the array is sorted without rotation.\\nAll these steps are further broken down to two conditions each that helps us find the exact position for target.\\n\\nFor Example: Step 1), if nums[mid]>nums[end], then we further check position of target to see if it lies between mid and end or start and end and proceed by applying binary search accordingly.\\n\\nIn 3) Step, we can apply normal binary search since the array is sorted. If target is not found with the help of all these steps, simply return -1."
                    },
                    {
                        "username": "parass419",
                        "content": "\\nint FindPivot(vector<int>& arr, int n ){\\n    int s = 0;\\n    int e = n-1;\\n    int mid = s +(e-s)/2;\\n\\n    while(s<e){\\n        if(arr[mid] >= arr[0]){\\n            s = mid+1;\\n            }\\n            else{\\n                e = mid;\\n\\n            }\\n            mid= s+(e-s)/2;\\n    }\\n    return s;\\n}\\n\\n\\n\\n\\nint BinarySearch(vector<int>& arr , int s , int e  , int key){ // S and E // // here because here array is already divided into two parts thats why we ///// are getting the starting and ending undex if the array.\\n   \\n    int mid = s+(e-s)/2;\\n    int i = 0;\\n    int size = arr.size();\\n\\n    while(i<size){\\n        if(arr[mid]==key ){\\n            return mid;\\n        }\\n        else if(arr[mid]<key){\\n            s = mid+1;\\n        }\\n        else{\\n            e = mid-1; \\n        }\\n        mid = s+(e-s)/2;\\n\\n    }\\nreturn s;\\n     \\n}\\n\\n\\nclass Solution {\\npublic:\\n    int search(vector<int>& nums, int target) {\\n        int size = nums.size();\\n        int pivot = FindPivot(nums , size);\\n        if( target >= nums[pivot]  &&  target <=nums[size-1])\\n        {\\n            return BinarySearch(nums,pivot,size-1,target);\\n        }\\n        else{\\n             return BinarySearch(nums,0,pivot - 1,target);\\n        }\\n\\n    }\\n};\\n\\n\\nWHy this code shows TLE"
                    },
                    {
                        "username": "mukul_gupta_",
                        "content": "Does number of lines affects the memory?\nAs both the code below is same only way of writing the code differs. Can someone explain it to me?\nSnippet1:\n        return nums.index(target) if target in nums else -1\n\nSnippet2:\n        if target in nums:\n            return nums.index(target)\n        else:\n            return -1"
                    },
                    {
                        "username": "pranitarora03",
                        "content": "class Solution(object):\\n    def search(self, nums, target):\\n        \"\"\"\\n        :type nums: List[int]\\n        :type target: int\\n        :rtype: int\\n        \"\"\"\\n\\n        def findMid(nums):\\n            low = 0\\n            high = len(nums)-1\\n            \\n            while low < high:\\n                mid = (low+high) // 2\\n                \\n                if mid > 0 and nums[mid]> nums[mid+1]:\\n                    return mid\\n                elif nums[mid] > nums[len(nums)-1]:\\n                    low = mid+1\\n                elif nums[mid] < nums[len(nums)-1]:\\n                    high = mid-1\\n            return 0\\n\\n\\n        def bs(nums,target,low,high):\\n            # low = 0 \\n            # high = len(nums)-1\\n\\n            while low <= high:\\n                mid = (low+high) // 2 \\n                if nums[mid] == target:\\n                    return mid\\n                elif nums[mid] < target:\\n                    low = mid+1\\n                else:\\n                    high = mid-1\\n            return -1                    \\n\\n\\n\\n        result = findMid(nums)\\n        # newNum = nums[:result] + nums[result+1:]\\n        if target <= nums[len(nums)-1]:\\n            low = result\\n            high = len(nums)-1\\n            return bs(nums,target,low,high)\\n        else:\\n            return bs(nums,target,0,result)\\n\\n\\n\\nPassed 171/195 tests cases. Please Review where did it went wrong"
                    },
                    {
                        "username": "rohiinegi2002",
                        "content": "i think you should return low instead of 0 in the find mid func.. and also make high as mid\\n\\n\\n..here is the code for:\\n\\n\\nclass Solution(object):\\n    def search(self, nums, target):\\n        \"\"\"\\n        :type nums: List[int]\\n        :type target: int\\n        :rtype: int\\n        \"\"\"\\n        def findPivot(nums):\\n            low = 0\\n            high = len(nums) - 1\\n\\n            while low < high:\\n                mid = (low + high) // 2\\n\\n                if nums[mid] > nums[high]:\\n                    low = mid + 1\\n                else:\\n                    high = mid\\n\\n            return low\\n\\n        def binarySearch(nums, target, low, high):\\n            while low <= high:\\n                mid = (low + high) // 2\\n                if nums[mid] == target:\\n                    return mid\\n                elif nums[mid] < target:\\n                    low = mid + 1\\n                else:\\n                    high = mid - 1\\n            return -1\\n\\n        pivot = findPivot(nums)\\n        n = len(nums)\\n        \\n        if target >= nums[pivot] and target <= nums[n - 1]:\\n            return binarySearch(nums, target, pivot, n - 1)\\n        else:\\n            return binarySearch(nums, target, 0, pivot - 1)\\n"
                    },
                    {
                        "username": "tnzngdw",
                        "content": "return Arrays.binarySearch(nums,target); why this code doesnt work for this ?"
                    },
                    {
                        "username": "honourableahamedsha001",
                        "content": "\\nquestion clearly states ```possibly rotated``` , which means you have to include a case where array is not rotated"
                    }
                ]
            },
            {
                "id": 1966190,
                "content": [
                    {
                        "username": "Lsfhv",
                        "content": "2 Binary searches "
                    },
                    {
                        "username": "Sakab_132",
                        "content": "can anybody explain the concept pls.............."
                    },
                    {
                        "username": "Rightlyso",
                        "content": "Find the min number in the vector, min no would be smaller than both it\\'s neighbor. Then apply two binary search on left and right side of the vector"
                    },
                    {
                        "username": "thuynh3",
                        "content": "Binary search to find pivot. Then one mini binary search either from start-pivot or pivot-end to find the item."
                    },
                    {
                        "username": "cubiclestudios",
                        "content": "Isn\\'t there an error with test case 175\\n`[242,245,249,250,252,253,257,262,263,268,275,280,282,283,285,290,292,293,297,299,4,5,8,9,10,14,16,17,18,20,22,23,29,32,36,39,47,51,56,68,70,73,75,77,79,81,82,89,98,100,107,108,112,114,115,117,118,119,128,131,134,139,142,147,148,154,161,162,165,167,171,172,174,177,180,183,189,190,191,192,194,197,200,203,206,207,208,209,210,212,217,220,223,226,227,231,237]. `\\nThis test case is incorrect because its not in ascending rotated order. It jumps from 299, to 4, to 14. "
                    },
                    {
                        "username": "thuynh3",
                        "content": "I understand how it works but the edges are so hard to take care of"
                    },
                    {
                        "username": "Ultron03",
                        "content": "just reduce your input size ->run ->correct your code "
                    },
                    {
                        "username": "Nitkapur30",
                        "content": "In the given question, we can see that there may be a pivot point in the array. To make sure that binary search can be applied, we break down the question into 3 simple conditions:\\n\\nIf array is rotated and nums[mid]>nums[end]\\nIf the array is rotated and nums[mid]>nums[start]\\nif the array is sorted without rotation.\\nAll these steps are further broken down to two conditions each that helps us find the exact position for target.\\n\\nFor Example: Step 1), if nums[mid]>nums[end], then we further check position of target to see if it lies between mid and end or start and end and proceed by applying binary search accordingly.\\n\\nIn 3) Step, we can apply normal binary search since the array is sorted. If target is not found with the help of all these steps, simply return -1."
                    },
                    {
                        "username": "parass419",
                        "content": "\\nint FindPivot(vector<int>& arr, int n ){\\n    int s = 0;\\n    int e = n-1;\\n    int mid = s +(e-s)/2;\\n\\n    while(s<e){\\n        if(arr[mid] >= arr[0]){\\n            s = mid+1;\\n            }\\n            else{\\n                e = mid;\\n\\n            }\\n            mid= s+(e-s)/2;\\n    }\\n    return s;\\n}\\n\\n\\n\\n\\nint BinarySearch(vector<int>& arr , int s , int e  , int key){ // S and E // // here because here array is already divided into two parts thats why we ///// are getting the starting and ending undex if the array.\\n   \\n    int mid = s+(e-s)/2;\\n    int i = 0;\\n    int size = arr.size();\\n\\n    while(i<size){\\n        if(arr[mid]==key ){\\n            return mid;\\n        }\\n        else if(arr[mid]<key){\\n            s = mid+1;\\n        }\\n        else{\\n            e = mid-1; \\n        }\\n        mid = s+(e-s)/2;\\n\\n    }\\nreturn s;\\n     \\n}\\n\\n\\nclass Solution {\\npublic:\\n    int search(vector<int>& nums, int target) {\\n        int size = nums.size();\\n        int pivot = FindPivot(nums , size);\\n        if( target >= nums[pivot]  &&  target <=nums[size-1])\\n        {\\n            return BinarySearch(nums,pivot,size-1,target);\\n        }\\n        else{\\n             return BinarySearch(nums,0,pivot - 1,target);\\n        }\\n\\n    }\\n};\\n\\n\\nWHy this code shows TLE"
                    },
                    {
                        "username": "mukul_gupta_",
                        "content": "Does number of lines affects the memory?\nAs both the code below is same only way of writing the code differs. Can someone explain it to me?\nSnippet1:\n        return nums.index(target) if target in nums else -1\n\nSnippet2:\n        if target in nums:\n            return nums.index(target)\n        else:\n            return -1"
                    },
                    {
                        "username": "pranitarora03",
                        "content": "class Solution(object):\\n    def search(self, nums, target):\\n        \"\"\"\\n        :type nums: List[int]\\n        :type target: int\\n        :rtype: int\\n        \"\"\"\\n\\n        def findMid(nums):\\n            low = 0\\n            high = len(nums)-1\\n            \\n            while low < high:\\n                mid = (low+high) // 2\\n                \\n                if mid > 0 and nums[mid]> nums[mid+1]:\\n                    return mid\\n                elif nums[mid] > nums[len(nums)-1]:\\n                    low = mid+1\\n                elif nums[mid] < nums[len(nums)-1]:\\n                    high = mid-1\\n            return 0\\n\\n\\n        def bs(nums,target,low,high):\\n            # low = 0 \\n            # high = len(nums)-1\\n\\n            while low <= high:\\n                mid = (low+high) // 2 \\n                if nums[mid] == target:\\n                    return mid\\n                elif nums[mid] < target:\\n                    low = mid+1\\n                else:\\n                    high = mid-1\\n            return -1                    \\n\\n\\n\\n        result = findMid(nums)\\n        # newNum = nums[:result] + nums[result+1:]\\n        if target <= nums[len(nums)-1]:\\n            low = result\\n            high = len(nums)-1\\n            return bs(nums,target,low,high)\\n        else:\\n            return bs(nums,target,0,result)\\n\\n\\n\\nPassed 171/195 tests cases. Please Review where did it went wrong"
                    },
                    {
                        "username": "rohiinegi2002",
                        "content": "i think you should return low instead of 0 in the find mid func.. and also make high as mid\\n\\n\\n..here is the code for:\\n\\n\\nclass Solution(object):\\n    def search(self, nums, target):\\n        \"\"\"\\n        :type nums: List[int]\\n        :type target: int\\n        :rtype: int\\n        \"\"\"\\n        def findPivot(nums):\\n            low = 0\\n            high = len(nums) - 1\\n\\n            while low < high:\\n                mid = (low + high) // 2\\n\\n                if nums[mid] > nums[high]:\\n                    low = mid + 1\\n                else:\\n                    high = mid\\n\\n            return low\\n\\n        def binarySearch(nums, target, low, high):\\n            while low <= high:\\n                mid = (low + high) // 2\\n                if nums[mid] == target:\\n                    return mid\\n                elif nums[mid] < target:\\n                    low = mid + 1\\n                else:\\n                    high = mid - 1\\n            return -1\\n\\n        pivot = findPivot(nums)\\n        n = len(nums)\\n        \\n        if target >= nums[pivot] and target <= nums[n - 1]:\\n            return binarySearch(nums, target, pivot, n - 1)\\n        else:\\n            return binarySearch(nums, target, 0, pivot - 1)\\n"
                    },
                    {
                        "username": "tnzngdw",
                        "content": "return Arrays.binarySearch(nums,target); why this code doesnt work for this ?"
                    },
                    {
                        "username": "honourableahamedsha001",
                        "content": "\\nquestion clearly states ```possibly rotated``` , which means you have to include a case where array is not rotated"
                    }
                ]
            },
            {
                "id": 1958850,
                "content": [
                    {
                        "username": "Lsfhv",
                        "content": "2 Binary searches "
                    },
                    {
                        "username": "Sakab_132",
                        "content": "can anybody explain the concept pls.............."
                    },
                    {
                        "username": "Rightlyso",
                        "content": "Find the min number in the vector, min no would be smaller than both it\\'s neighbor. Then apply two binary search on left and right side of the vector"
                    },
                    {
                        "username": "thuynh3",
                        "content": "Binary search to find pivot. Then one mini binary search either from start-pivot or pivot-end to find the item."
                    },
                    {
                        "username": "cubiclestudios",
                        "content": "Isn\\'t there an error with test case 175\\n`[242,245,249,250,252,253,257,262,263,268,275,280,282,283,285,290,292,293,297,299,4,5,8,9,10,14,16,17,18,20,22,23,29,32,36,39,47,51,56,68,70,73,75,77,79,81,82,89,98,100,107,108,112,114,115,117,118,119,128,131,134,139,142,147,148,154,161,162,165,167,171,172,174,177,180,183,189,190,191,192,194,197,200,203,206,207,208,209,210,212,217,220,223,226,227,231,237]. `\\nThis test case is incorrect because its not in ascending rotated order. It jumps from 299, to 4, to 14. "
                    },
                    {
                        "username": "thuynh3",
                        "content": "I understand how it works but the edges are so hard to take care of"
                    },
                    {
                        "username": "Ultron03",
                        "content": "just reduce your input size ->run ->correct your code "
                    },
                    {
                        "username": "Nitkapur30",
                        "content": "In the given question, we can see that there may be a pivot point in the array. To make sure that binary search can be applied, we break down the question into 3 simple conditions:\\n\\nIf array is rotated and nums[mid]>nums[end]\\nIf the array is rotated and nums[mid]>nums[start]\\nif the array is sorted without rotation.\\nAll these steps are further broken down to two conditions each that helps us find the exact position for target.\\n\\nFor Example: Step 1), if nums[mid]>nums[end], then we further check position of target to see if it lies between mid and end or start and end and proceed by applying binary search accordingly.\\n\\nIn 3) Step, we can apply normal binary search since the array is sorted. If target is not found with the help of all these steps, simply return -1."
                    },
                    {
                        "username": "parass419",
                        "content": "\\nint FindPivot(vector<int>& arr, int n ){\\n    int s = 0;\\n    int e = n-1;\\n    int mid = s +(e-s)/2;\\n\\n    while(s<e){\\n        if(arr[mid] >= arr[0]){\\n            s = mid+1;\\n            }\\n            else{\\n                e = mid;\\n\\n            }\\n            mid= s+(e-s)/2;\\n    }\\n    return s;\\n}\\n\\n\\n\\n\\nint BinarySearch(vector<int>& arr , int s , int e  , int key){ // S and E // // here because here array is already divided into two parts thats why we ///// are getting the starting and ending undex if the array.\\n   \\n    int mid = s+(e-s)/2;\\n    int i = 0;\\n    int size = arr.size();\\n\\n    while(i<size){\\n        if(arr[mid]==key ){\\n            return mid;\\n        }\\n        else if(arr[mid]<key){\\n            s = mid+1;\\n        }\\n        else{\\n            e = mid-1; \\n        }\\n        mid = s+(e-s)/2;\\n\\n    }\\nreturn s;\\n     \\n}\\n\\n\\nclass Solution {\\npublic:\\n    int search(vector<int>& nums, int target) {\\n        int size = nums.size();\\n        int pivot = FindPivot(nums , size);\\n        if( target >= nums[pivot]  &&  target <=nums[size-1])\\n        {\\n            return BinarySearch(nums,pivot,size-1,target);\\n        }\\n        else{\\n             return BinarySearch(nums,0,pivot - 1,target);\\n        }\\n\\n    }\\n};\\n\\n\\nWHy this code shows TLE"
                    },
                    {
                        "username": "mukul_gupta_",
                        "content": "Does number of lines affects the memory?\nAs both the code below is same only way of writing the code differs. Can someone explain it to me?\nSnippet1:\n        return nums.index(target) if target in nums else -1\n\nSnippet2:\n        if target in nums:\n            return nums.index(target)\n        else:\n            return -1"
                    },
                    {
                        "username": "pranitarora03",
                        "content": "class Solution(object):\\n    def search(self, nums, target):\\n        \"\"\"\\n        :type nums: List[int]\\n        :type target: int\\n        :rtype: int\\n        \"\"\"\\n\\n        def findMid(nums):\\n            low = 0\\n            high = len(nums)-1\\n            \\n            while low < high:\\n                mid = (low+high) // 2\\n                \\n                if mid > 0 and nums[mid]> nums[mid+1]:\\n                    return mid\\n                elif nums[mid] > nums[len(nums)-1]:\\n                    low = mid+1\\n                elif nums[mid] < nums[len(nums)-1]:\\n                    high = mid-1\\n            return 0\\n\\n\\n        def bs(nums,target,low,high):\\n            # low = 0 \\n            # high = len(nums)-1\\n\\n            while low <= high:\\n                mid = (low+high) // 2 \\n                if nums[mid] == target:\\n                    return mid\\n                elif nums[mid] < target:\\n                    low = mid+1\\n                else:\\n                    high = mid-1\\n            return -1                    \\n\\n\\n\\n        result = findMid(nums)\\n        # newNum = nums[:result] + nums[result+1:]\\n        if target <= nums[len(nums)-1]:\\n            low = result\\n            high = len(nums)-1\\n            return bs(nums,target,low,high)\\n        else:\\n            return bs(nums,target,0,result)\\n\\n\\n\\nPassed 171/195 tests cases. Please Review where did it went wrong"
                    },
                    {
                        "username": "rohiinegi2002",
                        "content": "i think you should return low instead of 0 in the find mid func.. and also make high as mid\\n\\n\\n..here is the code for:\\n\\n\\nclass Solution(object):\\n    def search(self, nums, target):\\n        \"\"\"\\n        :type nums: List[int]\\n        :type target: int\\n        :rtype: int\\n        \"\"\"\\n        def findPivot(nums):\\n            low = 0\\n            high = len(nums) - 1\\n\\n            while low < high:\\n                mid = (low + high) // 2\\n\\n                if nums[mid] > nums[high]:\\n                    low = mid + 1\\n                else:\\n                    high = mid\\n\\n            return low\\n\\n        def binarySearch(nums, target, low, high):\\n            while low <= high:\\n                mid = (low + high) // 2\\n                if nums[mid] == target:\\n                    return mid\\n                elif nums[mid] < target:\\n                    low = mid + 1\\n                else:\\n                    high = mid - 1\\n            return -1\\n\\n        pivot = findPivot(nums)\\n        n = len(nums)\\n        \\n        if target >= nums[pivot] and target <= nums[n - 1]:\\n            return binarySearch(nums, target, pivot, n - 1)\\n        else:\\n            return binarySearch(nums, target, 0, pivot - 1)\\n"
                    },
                    {
                        "username": "tnzngdw",
                        "content": "return Arrays.binarySearch(nums,target); why this code doesnt work for this ?"
                    },
                    {
                        "username": "honourableahamedsha001",
                        "content": "\\nquestion clearly states ```possibly rotated``` , which means you have to include a case where array is not rotated"
                    }
                ]
            },
            {
                "id": 1958267,
                "content": [
                    {
                        "username": "mkathi",
                        "content": "can this be solved by using a map structure by storing element as key and index as value....? "
                    },
                    {
                        "username": "bparanj",
                        "content": "Yes, it\\'s possible to solve this problem using a map data structure where the key is the element and the value is its index. This approach involves iterating over the entire array once to populate the map, and then you can find the target in constant time.\\n\\nHere\\'s a basic outline of this approach in Python:\\n\\n```python\\ndef search(nums, target):\\n    num_to_index = {num: idx for idx, num in enumerate(nums)}\\n    return num_to_index.get(target, -1)\\n```\\n\\nHowever, there are a few points to consider:\\n\\n1. **Time complexity**: This approach has a time complexity of O(n) due to the initial iteration over the array, which is less efficient than the binary search approach that has a time complexity of O(log n).\\n\\n2. **Space complexity**: This approach requires O(n) additional space to store the map, whereas the binary search approach only requires O(1) space.\\n\\n3. **Unnecessary work**: This approach involves examining every element in the array, even though the array is sorted (or almost sorted, given the rotation). In many cases, the target could be found without having to look at every element.\\n\\nTherefore, while it\\'s possible to use a map to solve this problem, it\\'s not the most efficient solution. The binary search approach takes advantage of the sorted nature of the array and is generally a better choice for this problem."
                    },
                    {
                        "username": "mkathi",
                        "content": "i think if i use a map here , i\\'ll find the solution faster just by storing element as key and index as value ..... what do you say guys?"
                    },
                    {
                        "username": "rohiinegi2002",
                        "content": "may be yes..but then the space complexity will increase \\n"
                    },
                    {
                        "username": "amanpandey2000",
                        "content": "What's wrong with leetcode ? Why is not exiting the while loop when s==l?\nBelow is my solution. Can someone tell me if this is issue with leetcode runtime? \nI am able to run the code successfully in some other online editor,\n\nclass Solution {\npublic:\n    int search(vector<int>& nums, int target) {\n        int s = 0;\n        int l = nums.size() -1;\n        while(s<l)\n        {\n            cout<<s<<\" \"<<l<<\"\\n\";\n            int m =s+l;\n            if(m%2==0)\n            m = m/2;\n            else m = (m-1)/2;\n            \n            if(nums[m] == target)\n            {\n                cout<< \"*\"<<m<<\"*  \";\n                s = m;\n                l = m;\n            }\n            else if(nums[s]<=nums[m])\n            {\n                if(target>=nums[s] && target<=nums[m]) l = m;\n                else s = m;\n            }\n            else\n            {\n                if(target>=nums[m] && target<=nums[l]) s = m;\n                else l=m;\n            }\n            if(s==l)\n            {\n                cout<<\"BREAK\";\n                break;\n            }\n            cout<<s<<\" \"<<l<<\"\\n\";\n        }\n        if(nums[s] == target) return s;\n        else return -1;\n    }\n};"
                    },
                    {
                        "username": "amanpandey2000",
                        "content": "[@bparanj](/bparanj)  thanks for looking into it. Agreed that my solution has this flaw.\\n\\nBut still the thing that the first test case should exit properly worries me. In some other compiler it is working fine, but if I run this solution in leetcode, it is behaving wierdly as the statement which I have printed cout<<:BREAK\" is getting executed but in the next line the break statement should exit the while loop. But it is not happening which mainly worries me here."
                    },
                    {
                        "username": "bparanj",
                        "content": "From what I can see, your implementation of binary search seems to have an infinite loop issue when the target is not present in the array. This happens because you are updating your `s` and `l` pointers to `m` without checking if `m` can make `s` or `l` to move.\\n\\nLet\\'s look at the case when `s` and `l` are consecutive numbers. If `nums[s] <= nums[m]` is true and `target` is not in the range of `nums[s]` to `nums[m]`, `s` will be updated to `m`. However, if `m` is equal to `s` (which is possible when `s` and `l` are consecutive), `s` will not move. This will cause an infinite loop, as `s` and `l` will not change. The same problem can occur with `l`.\\n\\nA standard binary search implementation makes sure that `s` or `l` always changes:\\n\\n```cpp\\nclass Solution {\\npublic:\\n    int search(vector<int>& nums, int target) {\\n        int s = 0;\\n        int l = nums.size();\\n        while (s < l) {\\n            int m = s + (l - s) / 2;\\n            if (nums[m] == target) {\\n                return m;\\n            } else if (nums[s] <= nums[m]) {\\n                if (target >= nums[s] && target < nums[m]) {\\n                    l = m;\\n                } else {\\n                    s = m + 1;\\n                }\\n            } else {\\n                if (target > nums[m] && target <= nums[l-1]) {\\n                    s = m + 1;\\n                } else {\\n                    l = m;\\n                }\\n            }\\n        }\\n        return -1;\\n    }\\n};\\n```\\n\\nIn this code, if the target is not found, `s` or `l` will be updated such that it either increments or decrements. This way, the function is guaranteed to exit."
                    },
                    {
                        "username": "saambpatil",
                        "content": "#define endl \\'\\\\n\\'\\n// #define int long long\\n#define pb push_back\\n#define FAST                 \\\\\\n    ios::sync_with_stdio(0); \\\\\\n    cin.tie(0);              \\\\\\n    cout.tie(0);\\n#define ppb pop_back\\n#define lld long double\\n#define all(a) a.begin(), a.end()\\n#define vi vector<int>\\n#define vs vector<string>\\n#define vb vector<bool>\\n#define vvi vector<vector<int>>\\n// #define sz(a) a.size()\\n#define rep(i, a, n) for (int i = a; i < n; i++)\\n\\nclass Solution {\\npublic:\\n    \\n\\n    int binary2(vi arr, int pivotindex, int n, int target)\\n{\\n    int low = pivotindex + 1;\\n    int high = n - 1;\\n\\n    while (high >= low)\\n    {\\n        int mid = low + (high - low) / 2;\\n        if (arr[mid] == target)\\n        {\\n            return mid;\\n        }\\n        else if (arr[mid] > target)\\n        {\\n            high = mid - 1;\\n        }\\n        else\\n        {\\n            low = mid + 1;\\n        }\\n    }\\n    return -1;\\n}\\n\\nint binary1(vi arr, int pivotindex, int n, int target)\\n{\\n    int high = pivotindex;\\n    int low = n - 1;\\n\\n    while (high >= low)\\n    {\\n        int mid = low + (high - low) / 2;\\n        if (arr[mid] == target)\\n        {\\n            return mid;\\n        }\\n        else if (arr[mid] > target)\\n        {\\n            high = mid - 1;\\n        }\\n        else\\n        {\\n            low = mid + 1;\\n        }\\n    }\\n    return -1;\\n}\\n\\n    int pivot(vi arr, int n)\\n{\\n    int low = 0;\\n    int high = n - 1;\\n    while (low <= high)\\n    {\\n        int mid = low + (high - low) / 2;\\n        if (arr[mid] <= arr[n - 1])\\n        {\\n            // We are in part 2 of the array\\n            high = mid - 1;\\n        }\\n        else // We are in part 1 of the array\\n        {\\n            // We are on the pivot element\\n            if (arr[mid] > arr[mid + 1] && arr[mid] > arr[mid - 1])\\n            {\\n                return mid;\\n            }\\n            // We are not on pivot element\\n            else\\n            {\\n                low = mid + 1;\\n            }\\n        }\\n    }\\n    return 0;\\n\\n}\\n\\n    int search(vector<int>& numbers, int target) {\\n        int n = numbers.size();\\n        int pivotindex = pivot(numbers, n);\\n        int index;\\n         if (target <= numbers[n - 1])\\n        {\\n            index = binary2(numbers, pivotindex, n, target);\\n        }\\n        else if (target > numbers[n - 1])\\n        {\\n            index = binary1(numbers, pivotindex, n, target);\\n        }\\n        return index;\\n    }\\n};\\n\\nI am getting proper result when i run the code but getting runtime error while submitting pls correct the code and point out the mistake"
                    },
                    {
                        "username": "bparanj",
                        "content": "The runtime error may be due to an \"array index out of bounds\" issue. In the pivot function, you\\'re comparing `arr[mid]` with `arr[mid + 1]` and `arr[mid - 1]` without checking if `mid + 1` and `mid - 1` are valid indices. If `mid` happens to be 0 or `n - 1`, it will result in an out-of-bounds error. \\n\\nAlso, note that in `binary1()` function, you\\'ve set `low` to `n - 1` and `high` to `pivotindex`, which might be causing a logical error because `low` should be less than `high` in a standard binary search.\\n\\nHere is the corrected version of your code:\\n\\n```cpp\\nclass Solution {\\npublic:\\n    int binary2(vector<int>& arr, int pivotindex, int n, int target) {\\n        int low = pivotindex + 1;\\n        int high = n - 1;\\n\\n        while (high >= low) {\\n            int mid = low + (high - low) / 2;\\n            if (arr[mid] == target) {\\n                return mid;\\n            }\\n            else if (arr[mid] > target) {\\n                high = mid - 1;\\n            }\\n            else {\\n                low = mid + 1;\\n            }\\n        }\\n        return -1;\\n    }\\n\\n    int binary1(vector<int>& arr, int pivotindex, int n, int target) {\\n        int low = 0;\\n        int high = pivotindex;\\n\\n        while (high >= low) {\\n            int mid = low + (high - low) / 2;\\n            if (arr[mid] == target) {\\n                return mid;\\n            }\\n            else if (arr[mid] > target) {\\n                high = mid - 1;\\n            }\\n            else {\\n                low = mid + 1;\\n            }\\n        }\\n        return -1;\\n    }\\n\\n    int pivot(vector<int>& arr, int n) {\\n        int low = 0;\\n        int high = n - 1;\\n        while (low <= high) {\\n            int mid = low + (high - low) / 2;\\n            if (arr[mid] <= arr[n - 1]) {\\n                high = mid - 1;\\n            }\\n            else {\\n                if (mid > 0 && mid < n - 1 && arr[mid] > arr[mid + 1] && arr[mid] > arr[mid - 1]) {\\n                    return mid;\\n                }\\n                else {\\n                    low = mid + 1;\\n                }\\n            }\\n        }\\n        return 0;\\n    }\\n\\n    int search(vector<int>& numbers, int target) {\\n        int n = numbers.size();\\n        int pivotindex = pivot(numbers, n);\\n        int index;\\n        if (target <= numbers[n - 1]) {\\n            index = binary2(numbers, pivotindex, n, target);\\n        }\\n        else if (target > numbers[n - 1]) {\\n            index = binary1(numbers, pivotindex, n, target);\\n        }\\n        return index;\\n    }\\n};\\n```\\nThis code should fix the runtime error you\\'re encountering. Please test it out on different test cases to ensure that it\\'s working as expected."
                    },
                    {
                        "username": "amangupta9255",
                        "content": "The problem has two important keywords, \"Search\" and \"Sorted\". This gives us the idea of using binary search in this problem. Since the array is rotated, so the idea is to check that which protion of array is sorted. First we check that portion of array and then we check if the target lies in the sorted portion of array or not. This process is repeated, if target element is not present in array we return -1."
                    },
                    {
                        "username": "Kaushh",
                        "content": "\\uD83D\\uDE02\\uD83D\\uDE02linear search gives 100% while Binary Search only 46%."
                    },
                    {
                        "username": "viraat0700",
                        "content": "we only have to write code for the function right . We do not have to write the main function?\\n"
                    },
                    {
                        "username": "Honey_19",
                        "content": "It should be in easy \\n"
                    },
                    {
                        "username": "user5369RY",
                        "content": "[3,5,1] the target is 3 why not  1?   for all cases if the list was rotated then the most right element is smaller than the middle then the index of most right is the target or in the mid equal to target then it is he target why in this case such logic did not work?"
                    },
                    {
                        "username": "bparanj",
                        "content": "Your logic assumes that the target is always the pivot (the smallest element in the rotated array) or the middle element. However, the problem statement says that the target could be any number in the array, not necessarily the pivot or the middle. \\n\\nIn your example [3,5,1], the target could be 3, 5, or 1. If the target is 3, then the expected output is 0 because 3 is at index 0. If the target is 5, then the expected output is 1 because 5 is at index 1. If the target is 1, then the expected output is 2 because 1 is at index 2.\\n\\nSo, the key to solving this problem is not to find the pivot or the middle, but to find the target. This requires modifying the binary search to handle the rotation."
                    },
                    {
                        "username": "mohitjangid14101",
                        "content": "class Solution {\\npublic:\\n    int binarySearch(vector<int>arr,int target,int s,int e){\\n        while(s<=e){\\n            int mid=s+(e-s)/2;\\n            if(arr[mid]==target){\\n                return mid;\\n            }\\n            else if(arr[mid]>target){\\n                e=mid-1;\\n            }\\n            else{\\n                s=mid+1;\\n            }\\n        }\\n        return -1;\\n    }\\n    int findPivot(vector<int>arr){\\n        int s=0;\\n        int e=arr.size()-1;\\n        int mid=s+(e-s)/2;\\n        while(s<e){\\n            \\n            if(mid+1<arr.size() && arr[mid]>arr[mid+1]){\\n                return mid;\\n            }\\n            if(mid-1>=0 && arr[mid-1]>arr[mid]){\\n                return mid-1;\\n            }\\n            if(arr[s]>=arr[mid]){  \\n                e=mid-1;\\n            }\\n            else{\\n                s=mid;\\n                \\n            }\\n            mid=s+(e-s)/2;\\n        }\\n    return s;\\n    }\\n    int search(vector<int>& arr, int target) {\\n        int pivot=findPivot(arr);\\n        if(target>=arr[0] && target<=arr[pivot]){\\n            int ans=binarySearch(arr,target,0,pivot);\\n            return ans;\\n        }\\n        if( pivot+1<arr.size() && target>=arr[pivot+1] &&         target<=arr[arr.size()-1] ){\\n            int ans=binarySearch(arr,target,pivot+1,arr.size()-1);\\n            return ans;\\n        }\\n        return -1;\\n    }\\n};"
                    }
                ]
            },
            {
                "id": 1958265,
                "content": [
                    {
                        "username": "mkathi",
                        "content": "can this be solved by using a map structure by storing element as key and index as value....? "
                    },
                    {
                        "username": "bparanj",
                        "content": "Yes, it\\'s possible to solve this problem using a map data structure where the key is the element and the value is its index. This approach involves iterating over the entire array once to populate the map, and then you can find the target in constant time.\\n\\nHere\\'s a basic outline of this approach in Python:\\n\\n```python\\ndef search(nums, target):\\n    num_to_index = {num: idx for idx, num in enumerate(nums)}\\n    return num_to_index.get(target, -1)\\n```\\n\\nHowever, there are a few points to consider:\\n\\n1. **Time complexity**: This approach has a time complexity of O(n) due to the initial iteration over the array, which is less efficient than the binary search approach that has a time complexity of O(log n).\\n\\n2. **Space complexity**: This approach requires O(n) additional space to store the map, whereas the binary search approach only requires O(1) space.\\n\\n3. **Unnecessary work**: This approach involves examining every element in the array, even though the array is sorted (or almost sorted, given the rotation). In many cases, the target could be found without having to look at every element.\\n\\nTherefore, while it\\'s possible to use a map to solve this problem, it\\'s not the most efficient solution. The binary search approach takes advantage of the sorted nature of the array and is generally a better choice for this problem."
                    },
                    {
                        "username": "mkathi",
                        "content": "i think if i use a map here , i\\'ll find the solution faster just by storing element as key and index as value ..... what do you say guys?"
                    },
                    {
                        "username": "rohiinegi2002",
                        "content": "may be yes..but then the space complexity will increase \\n"
                    },
                    {
                        "username": "amanpandey2000",
                        "content": "What's wrong with leetcode ? Why is not exiting the while loop when s==l?\nBelow is my solution. Can someone tell me if this is issue with leetcode runtime? \nI am able to run the code successfully in some other online editor,\n\nclass Solution {\npublic:\n    int search(vector<int>& nums, int target) {\n        int s = 0;\n        int l = nums.size() -1;\n        while(s<l)\n        {\n            cout<<s<<\" \"<<l<<\"\\n\";\n            int m =s+l;\n            if(m%2==0)\n            m = m/2;\n            else m = (m-1)/2;\n            \n            if(nums[m] == target)\n            {\n                cout<< \"*\"<<m<<\"*  \";\n                s = m;\n                l = m;\n            }\n            else if(nums[s]<=nums[m])\n            {\n                if(target>=nums[s] && target<=nums[m]) l = m;\n                else s = m;\n            }\n            else\n            {\n                if(target>=nums[m] && target<=nums[l]) s = m;\n                else l=m;\n            }\n            if(s==l)\n            {\n                cout<<\"BREAK\";\n                break;\n            }\n            cout<<s<<\" \"<<l<<\"\\n\";\n        }\n        if(nums[s] == target) return s;\n        else return -1;\n    }\n};"
                    },
                    {
                        "username": "amanpandey2000",
                        "content": "[@bparanj](/bparanj)  thanks for looking into it. Agreed that my solution has this flaw.\\n\\nBut still the thing that the first test case should exit properly worries me. In some other compiler it is working fine, but if I run this solution in leetcode, it is behaving wierdly as the statement which I have printed cout<<:BREAK\" is getting executed but in the next line the break statement should exit the while loop. But it is not happening which mainly worries me here."
                    },
                    {
                        "username": "bparanj",
                        "content": "From what I can see, your implementation of binary search seems to have an infinite loop issue when the target is not present in the array. This happens because you are updating your `s` and `l` pointers to `m` without checking if `m` can make `s` or `l` to move.\\n\\nLet\\'s look at the case when `s` and `l` are consecutive numbers. If `nums[s] <= nums[m]` is true and `target` is not in the range of `nums[s]` to `nums[m]`, `s` will be updated to `m`. However, if `m` is equal to `s` (which is possible when `s` and `l` are consecutive), `s` will not move. This will cause an infinite loop, as `s` and `l` will not change. The same problem can occur with `l`.\\n\\nA standard binary search implementation makes sure that `s` or `l` always changes:\\n\\n```cpp\\nclass Solution {\\npublic:\\n    int search(vector<int>& nums, int target) {\\n        int s = 0;\\n        int l = nums.size();\\n        while (s < l) {\\n            int m = s + (l - s) / 2;\\n            if (nums[m] == target) {\\n                return m;\\n            } else if (nums[s] <= nums[m]) {\\n                if (target >= nums[s] && target < nums[m]) {\\n                    l = m;\\n                } else {\\n                    s = m + 1;\\n                }\\n            } else {\\n                if (target > nums[m] && target <= nums[l-1]) {\\n                    s = m + 1;\\n                } else {\\n                    l = m;\\n                }\\n            }\\n        }\\n        return -1;\\n    }\\n};\\n```\\n\\nIn this code, if the target is not found, `s` or `l` will be updated such that it either increments or decrements. This way, the function is guaranteed to exit."
                    },
                    {
                        "username": "saambpatil",
                        "content": "#define endl \\'\\\\n\\'\\n// #define int long long\\n#define pb push_back\\n#define FAST                 \\\\\\n    ios::sync_with_stdio(0); \\\\\\n    cin.tie(0);              \\\\\\n    cout.tie(0);\\n#define ppb pop_back\\n#define lld long double\\n#define all(a) a.begin(), a.end()\\n#define vi vector<int>\\n#define vs vector<string>\\n#define vb vector<bool>\\n#define vvi vector<vector<int>>\\n// #define sz(a) a.size()\\n#define rep(i, a, n) for (int i = a; i < n; i++)\\n\\nclass Solution {\\npublic:\\n    \\n\\n    int binary2(vi arr, int pivotindex, int n, int target)\\n{\\n    int low = pivotindex + 1;\\n    int high = n - 1;\\n\\n    while (high >= low)\\n    {\\n        int mid = low + (high - low) / 2;\\n        if (arr[mid] == target)\\n        {\\n            return mid;\\n        }\\n        else if (arr[mid] > target)\\n        {\\n            high = mid - 1;\\n        }\\n        else\\n        {\\n            low = mid + 1;\\n        }\\n    }\\n    return -1;\\n}\\n\\nint binary1(vi arr, int pivotindex, int n, int target)\\n{\\n    int high = pivotindex;\\n    int low = n - 1;\\n\\n    while (high >= low)\\n    {\\n        int mid = low + (high - low) / 2;\\n        if (arr[mid] == target)\\n        {\\n            return mid;\\n        }\\n        else if (arr[mid] > target)\\n        {\\n            high = mid - 1;\\n        }\\n        else\\n        {\\n            low = mid + 1;\\n        }\\n    }\\n    return -1;\\n}\\n\\n    int pivot(vi arr, int n)\\n{\\n    int low = 0;\\n    int high = n - 1;\\n    while (low <= high)\\n    {\\n        int mid = low + (high - low) / 2;\\n        if (arr[mid] <= arr[n - 1])\\n        {\\n            // We are in part 2 of the array\\n            high = mid - 1;\\n        }\\n        else // We are in part 1 of the array\\n        {\\n            // We are on the pivot element\\n            if (arr[mid] > arr[mid + 1] && arr[mid] > arr[mid - 1])\\n            {\\n                return mid;\\n            }\\n            // We are not on pivot element\\n            else\\n            {\\n                low = mid + 1;\\n            }\\n        }\\n    }\\n    return 0;\\n\\n}\\n\\n    int search(vector<int>& numbers, int target) {\\n        int n = numbers.size();\\n        int pivotindex = pivot(numbers, n);\\n        int index;\\n         if (target <= numbers[n - 1])\\n        {\\n            index = binary2(numbers, pivotindex, n, target);\\n        }\\n        else if (target > numbers[n - 1])\\n        {\\n            index = binary1(numbers, pivotindex, n, target);\\n        }\\n        return index;\\n    }\\n};\\n\\nI am getting proper result when i run the code but getting runtime error while submitting pls correct the code and point out the mistake"
                    },
                    {
                        "username": "bparanj",
                        "content": "The runtime error may be due to an \"array index out of bounds\" issue. In the pivot function, you\\'re comparing `arr[mid]` with `arr[mid + 1]` and `arr[mid - 1]` without checking if `mid + 1` and `mid - 1` are valid indices. If `mid` happens to be 0 or `n - 1`, it will result in an out-of-bounds error. \\n\\nAlso, note that in `binary1()` function, you\\'ve set `low` to `n - 1` and `high` to `pivotindex`, which might be causing a logical error because `low` should be less than `high` in a standard binary search.\\n\\nHere is the corrected version of your code:\\n\\n```cpp\\nclass Solution {\\npublic:\\n    int binary2(vector<int>& arr, int pivotindex, int n, int target) {\\n        int low = pivotindex + 1;\\n        int high = n - 1;\\n\\n        while (high >= low) {\\n            int mid = low + (high - low) / 2;\\n            if (arr[mid] == target) {\\n                return mid;\\n            }\\n            else if (arr[mid] > target) {\\n                high = mid - 1;\\n            }\\n            else {\\n                low = mid + 1;\\n            }\\n        }\\n        return -1;\\n    }\\n\\n    int binary1(vector<int>& arr, int pivotindex, int n, int target) {\\n        int low = 0;\\n        int high = pivotindex;\\n\\n        while (high >= low) {\\n            int mid = low + (high - low) / 2;\\n            if (arr[mid] == target) {\\n                return mid;\\n            }\\n            else if (arr[mid] > target) {\\n                high = mid - 1;\\n            }\\n            else {\\n                low = mid + 1;\\n            }\\n        }\\n        return -1;\\n    }\\n\\n    int pivot(vector<int>& arr, int n) {\\n        int low = 0;\\n        int high = n - 1;\\n        while (low <= high) {\\n            int mid = low + (high - low) / 2;\\n            if (arr[mid] <= arr[n - 1]) {\\n                high = mid - 1;\\n            }\\n            else {\\n                if (mid > 0 && mid < n - 1 && arr[mid] > arr[mid + 1] && arr[mid] > arr[mid - 1]) {\\n                    return mid;\\n                }\\n                else {\\n                    low = mid + 1;\\n                }\\n            }\\n        }\\n        return 0;\\n    }\\n\\n    int search(vector<int>& numbers, int target) {\\n        int n = numbers.size();\\n        int pivotindex = pivot(numbers, n);\\n        int index;\\n        if (target <= numbers[n - 1]) {\\n            index = binary2(numbers, pivotindex, n, target);\\n        }\\n        else if (target > numbers[n - 1]) {\\n            index = binary1(numbers, pivotindex, n, target);\\n        }\\n        return index;\\n    }\\n};\\n```\\nThis code should fix the runtime error you\\'re encountering. Please test it out on different test cases to ensure that it\\'s working as expected."
                    },
                    {
                        "username": "amangupta9255",
                        "content": "The problem has two important keywords, \"Search\" and \"Sorted\". This gives us the idea of using binary search in this problem. Since the array is rotated, so the idea is to check that which protion of array is sorted. First we check that portion of array and then we check if the target lies in the sorted portion of array or not. This process is repeated, if target element is not present in array we return -1."
                    },
                    {
                        "username": "Kaushh",
                        "content": "\\uD83D\\uDE02\\uD83D\\uDE02linear search gives 100% while Binary Search only 46%."
                    },
                    {
                        "username": "viraat0700",
                        "content": "we only have to write code for the function right . We do not have to write the main function?\\n"
                    },
                    {
                        "username": "Honey_19",
                        "content": "It should be in easy \\n"
                    },
                    {
                        "username": "user5369RY",
                        "content": "[3,5,1] the target is 3 why not  1?   for all cases if the list was rotated then the most right element is smaller than the middle then the index of most right is the target or in the mid equal to target then it is he target why in this case such logic did not work?"
                    },
                    {
                        "username": "bparanj",
                        "content": "Your logic assumes that the target is always the pivot (the smallest element in the rotated array) or the middle element. However, the problem statement says that the target could be any number in the array, not necessarily the pivot or the middle. \\n\\nIn your example [3,5,1], the target could be 3, 5, or 1. If the target is 3, then the expected output is 0 because 3 is at index 0. If the target is 5, then the expected output is 1 because 5 is at index 1. If the target is 1, then the expected output is 2 because 1 is at index 2.\\n\\nSo, the key to solving this problem is not to find the pivot or the middle, but to find the target. This requires modifying the binary search to handle the rotation."
                    },
                    {
                        "username": "mohitjangid14101",
                        "content": "class Solution {\\npublic:\\n    int binarySearch(vector<int>arr,int target,int s,int e){\\n        while(s<=e){\\n            int mid=s+(e-s)/2;\\n            if(arr[mid]==target){\\n                return mid;\\n            }\\n            else if(arr[mid]>target){\\n                e=mid-1;\\n            }\\n            else{\\n                s=mid+1;\\n            }\\n        }\\n        return -1;\\n    }\\n    int findPivot(vector<int>arr){\\n        int s=0;\\n        int e=arr.size()-1;\\n        int mid=s+(e-s)/2;\\n        while(s<e){\\n            \\n            if(mid+1<arr.size() && arr[mid]>arr[mid+1]){\\n                return mid;\\n            }\\n            if(mid-1>=0 && arr[mid-1]>arr[mid]){\\n                return mid-1;\\n            }\\n            if(arr[s]>=arr[mid]){  \\n                e=mid-1;\\n            }\\n            else{\\n                s=mid;\\n                \\n            }\\n            mid=s+(e-s)/2;\\n        }\\n    return s;\\n    }\\n    int search(vector<int>& arr, int target) {\\n        int pivot=findPivot(arr);\\n        if(target>=arr[0] && target<=arr[pivot]){\\n            int ans=binarySearch(arr,target,0,pivot);\\n            return ans;\\n        }\\n        if( pivot+1<arr.size() && target>=arr[pivot+1] &&         target<=arr[arr.size()-1] ){\\n            int ans=binarySearch(arr,target,pivot+1,arr.size()-1);\\n            return ans;\\n        }\\n        return -1;\\n    }\\n};"
                    }
                ]
            },
            {
                "id": 1950463,
                "content": [
                    {
                        "username": "mkathi",
                        "content": "can this be solved by using a map structure by storing element as key and index as value....? "
                    },
                    {
                        "username": "bparanj",
                        "content": "Yes, it\\'s possible to solve this problem using a map data structure where the key is the element and the value is its index. This approach involves iterating over the entire array once to populate the map, and then you can find the target in constant time.\\n\\nHere\\'s a basic outline of this approach in Python:\\n\\n```python\\ndef search(nums, target):\\n    num_to_index = {num: idx for idx, num in enumerate(nums)}\\n    return num_to_index.get(target, -1)\\n```\\n\\nHowever, there are a few points to consider:\\n\\n1. **Time complexity**: This approach has a time complexity of O(n) due to the initial iteration over the array, which is less efficient than the binary search approach that has a time complexity of O(log n).\\n\\n2. **Space complexity**: This approach requires O(n) additional space to store the map, whereas the binary search approach only requires O(1) space.\\n\\n3. **Unnecessary work**: This approach involves examining every element in the array, even though the array is sorted (or almost sorted, given the rotation). In many cases, the target could be found without having to look at every element.\\n\\nTherefore, while it\\'s possible to use a map to solve this problem, it\\'s not the most efficient solution. The binary search approach takes advantage of the sorted nature of the array and is generally a better choice for this problem."
                    },
                    {
                        "username": "mkathi",
                        "content": "i think if i use a map here , i\\'ll find the solution faster just by storing element as key and index as value ..... what do you say guys?"
                    },
                    {
                        "username": "rohiinegi2002",
                        "content": "may be yes..but then the space complexity will increase \\n"
                    },
                    {
                        "username": "amanpandey2000",
                        "content": "What's wrong with leetcode ? Why is not exiting the while loop when s==l?\nBelow is my solution. Can someone tell me if this is issue with leetcode runtime? \nI am able to run the code successfully in some other online editor,\n\nclass Solution {\npublic:\n    int search(vector<int>& nums, int target) {\n        int s = 0;\n        int l = nums.size() -1;\n        while(s<l)\n        {\n            cout<<s<<\" \"<<l<<\"\\n\";\n            int m =s+l;\n            if(m%2==0)\n            m = m/2;\n            else m = (m-1)/2;\n            \n            if(nums[m] == target)\n            {\n                cout<< \"*\"<<m<<\"*  \";\n                s = m;\n                l = m;\n            }\n            else if(nums[s]<=nums[m])\n            {\n                if(target>=nums[s] && target<=nums[m]) l = m;\n                else s = m;\n            }\n            else\n            {\n                if(target>=nums[m] && target<=nums[l]) s = m;\n                else l=m;\n            }\n            if(s==l)\n            {\n                cout<<\"BREAK\";\n                break;\n            }\n            cout<<s<<\" \"<<l<<\"\\n\";\n        }\n        if(nums[s] == target) return s;\n        else return -1;\n    }\n};"
                    },
                    {
                        "username": "amanpandey2000",
                        "content": "[@bparanj](/bparanj)  thanks for looking into it. Agreed that my solution has this flaw.\\n\\nBut still the thing that the first test case should exit properly worries me. In some other compiler it is working fine, but if I run this solution in leetcode, it is behaving wierdly as the statement which I have printed cout<<:BREAK\" is getting executed but in the next line the break statement should exit the while loop. But it is not happening which mainly worries me here."
                    },
                    {
                        "username": "bparanj",
                        "content": "From what I can see, your implementation of binary search seems to have an infinite loop issue when the target is not present in the array. This happens because you are updating your `s` and `l` pointers to `m` without checking if `m` can make `s` or `l` to move.\\n\\nLet\\'s look at the case when `s` and `l` are consecutive numbers. If `nums[s] <= nums[m]` is true and `target` is not in the range of `nums[s]` to `nums[m]`, `s` will be updated to `m`. However, if `m` is equal to `s` (which is possible when `s` and `l` are consecutive), `s` will not move. This will cause an infinite loop, as `s` and `l` will not change. The same problem can occur with `l`.\\n\\nA standard binary search implementation makes sure that `s` or `l` always changes:\\n\\n```cpp\\nclass Solution {\\npublic:\\n    int search(vector<int>& nums, int target) {\\n        int s = 0;\\n        int l = nums.size();\\n        while (s < l) {\\n            int m = s + (l - s) / 2;\\n            if (nums[m] == target) {\\n                return m;\\n            } else if (nums[s] <= nums[m]) {\\n                if (target >= nums[s] && target < nums[m]) {\\n                    l = m;\\n                } else {\\n                    s = m + 1;\\n                }\\n            } else {\\n                if (target > nums[m] && target <= nums[l-1]) {\\n                    s = m + 1;\\n                } else {\\n                    l = m;\\n                }\\n            }\\n        }\\n        return -1;\\n    }\\n};\\n```\\n\\nIn this code, if the target is not found, `s` or `l` will be updated such that it either increments or decrements. This way, the function is guaranteed to exit."
                    },
                    {
                        "username": "saambpatil",
                        "content": "#define endl \\'\\\\n\\'\\n// #define int long long\\n#define pb push_back\\n#define FAST                 \\\\\\n    ios::sync_with_stdio(0); \\\\\\n    cin.tie(0);              \\\\\\n    cout.tie(0);\\n#define ppb pop_back\\n#define lld long double\\n#define all(a) a.begin(), a.end()\\n#define vi vector<int>\\n#define vs vector<string>\\n#define vb vector<bool>\\n#define vvi vector<vector<int>>\\n// #define sz(a) a.size()\\n#define rep(i, a, n) for (int i = a; i < n; i++)\\n\\nclass Solution {\\npublic:\\n    \\n\\n    int binary2(vi arr, int pivotindex, int n, int target)\\n{\\n    int low = pivotindex + 1;\\n    int high = n - 1;\\n\\n    while (high >= low)\\n    {\\n        int mid = low + (high - low) / 2;\\n        if (arr[mid] == target)\\n        {\\n            return mid;\\n        }\\n        else if (arr[mid] > target)\\n        {\\n            high = mid - 1;\\n        }\\n        else\\n        {\\n            low = mid + 1;\\n        }\\n    }\\n    return -1;\\n}\\n\\nint binary1(vi arr, int pivotindex, int n, int target)\\n{\\n    int high = pivotindex;\\n    int low = n - 1;\\n\\n    while (high >= low)\\n    {\\n        int mid = low + (high - low) / 2;\\n        if (arr[mid] == target)\\n        {\\n            return mid;\\n        }\\n        else if (arr[mid] > target)\\n        {\\n            high = mid - 1;\\n        }\\n        else\\n        {\\n            low = mid + 1;\\n        }\\n    }\\n    return -1;\\n}\\n\\n    int pivot(vi arr, int n)\\n{\\n    int low = 0;\\n    int high = n - 1;\\n    while (low <= high)\\n    {\\n        int mid = low + (high - low) / 2;\\n        if (arr[mid] <= arr[n - 1])\\n        {\\n            // We are in part 2 of the array\\n            high = mid - 1;\\n        }\\n        else // We are in part 1 of the array\\n        {\\n            // We are on the pivot element\\n            if (arr[mid] > arr[mid + 1] && arr[mid] > arr[mid - 1])\\n            {\\n                return mid;\\n            }\\n            // We are not on pivot element\\n            else\\n            {\\n                low = mid + 1;\\n            }\\n        }\\n    }\\n    return 0;\\n\\n}\\n\\n    int search(vector<int>& numbers, int target) {\\n        int n = numbers.size();\\n        int pivotindex = pivot(numbers, n);\\n        int index;\\n         if (target <= numbers[n - 1])\\n        {\\n            index = binary2(numbers, pivotindex, n, target);\\n        }\\n        else if (target > numbers[n - 1])\\n        {\\n            index = binary1(numbers, pivotindex, n, target);\\n        }\\n        return index;\\n    }\\n};\\n\\nI am getting proper result when i run the code but getting runtime error while submitting pls correct the code and point out the mistake"
                    },
                    {
                        "username": "bparanj",
                        "content": "The runtime error may be due to an \"array index out of bounds\" issue. In the pivot function, you\\'re comparing `arr[mid]` with `arr[mid + 1]` and `arr[mid - 1]` without checking if `mid + 1` and `mid - 1` are valid indices. If `mid` happens to be 0 or `n - 1`, it will result in an out-of-bounds error. \\n\\nAlso, note that in `binary1()` function, you\\'ve set `low` to `n - 1` and `high` to `pivotindex`, which might be causing a logical error because `low` should be less than `high` in a standard binary search.\\n\\nHere is the corrected version of your code:\\n\\n```cpp\\nclass Solution {\\npublic:\\n    int binary2(vector<int>& arr, int pivotindex, int n, int target) {\\n        int low = pivotindex + 1;\\n        int high = n - 1;\\n\\n        while (high >= low) {\\n            int mid = low + (high - low) / 2;\\n            if (arr[mid] == target) {\\n                return mid;\\n            }\\n            else if (arr[mid] > target) {\\n                high = mid - 1;\\n            }\\n            else {\\n                low = mid + 1;\\n            }\\n        }\\n        return -1;\\n    }\\n\\n    int binary1(vector<int>& arr, int pivotindex, int n, int target) {\\n        int low = 0;\\n        int high = pivotindex;\\n\\n        while (high >= low) {\\n            int mid = low + (high - low) / 2;\\n            if (arr[mid] == target) {\\n                return mid;\\n            }\\n            else if (arr[mid] > target) {\\n                high = mid - 1;\\n            }\\n            else {\\n                low = mid + 1;\\n            }\\n        }\\n        return -1;\\n    }\\n\\n    int pivot(vector<int>& arr, int n) {\\n        int low = 0;\\n        int high = n - 1;\\n        while (low <= high) {\\n            int mid = low + (high - low) / 2;\\n            if (arr[mid] <= arr[n - 1]) {\\n                high = mid - 1;\\n            }\\n            else {\\n                if (mid > 0 && mid < n - 1 && arr[mid] > arr[mid + 1] && arr[mid] > arr[mid - 1]) {\\n                    return mid;\\n                }\\n                else {\\n                    low = mid + 1;\\n                }\\n            }\\n        }\\n        return 0;\\n    }\\n\\n    int search(vector<int>& numbers, int target) {\\n        int n = numbers.size();\\n        int pivotindex = pivot(numbers, n);\\n        int index;\\n        if (target <= numbers[n - 1]) {\\n            index = binary2(numbers, pivotindex, n, target);\\n        }\\n        else if (target > numbers[n - 1]) {\\n            index = binary1(numbers, pivotindex, n, target);\\n        }\\n        return index;\\n    }\\n};\\n```\\nThis code should fix the runtime error you\\'re encountering. Please test it out on different test cases to ensure that it\\'s working as expected."
                    },
                    {
                        "username": "amangupta9255",
                        "content": "The problem has two important keywords, \"Search\" and \"Sorted\". This gives us the idea of using binary search in this problem. Since the array is rotated, so the idea is to check that which protion of array is sorted. First we check that portion of array and then we check if the target lies in the sorted portion of array or not. This process is repeated, if target element is not present in array we return -1."
                    },
                    {
                        "username": "Kaushh",
                        "content": "\\uD83D\\uDE02\\uD83D\\uDE02linear search gives 100% while Binary Search only 46%."
                    },
                    {
                        "username": "viraat0700",
                        "content": "we only have to write code for the function right . We do not have to write the main function?\\n"
                    },
                    {
                        "username": "Honey_19",
                        "content": "It should be in easy \\n"
                    },
                    {
                        "username": "user5369RY",
                        "content": "[3,5,1] the target is 3 why not  1?   for all cases if the list was rotated then the most right element is smaller than the middle then the index of most right is the target or in the mid equal to target then it is he target why in this case such logic did not work?"
                    },
                    {
                        "username": "bparanj",
                        "content": "Your logic assumes that the target is always the pivot (the smallest element in the rotated array) or the middle element. However, the problem statement says that the target could be any number in the array, not necessarily the pivot or the middle. \\n\\nIn your example [3,5,1], the target could be 3, 5, or 1. If the target is 3, then the expected output is 0 because 3 is at index 0. If the target is 5, then the expected output is 1 because 5 is at index 1. If the target is 1, then the expected output is 2 because 1 is at index 2.\\n\\nSo, the key to solving this problem is not to find the pivot or the middle, but to find the target. This requires modifying the binary search to handle the rotation."
                    },
                    {
                        "username": "mohitjangid14101",
                        "content": "class Solution {\\npublic:\\n    int binarySearch(vector<int>arr,int target,int s,int e){\\n        while(s<=e){\\n            int mid=s+(e-s)/2;\\n            if(arr[mid]==target){\\n                return mid;\\n            }\\n            else if(arr[mid]>target){\\n                e=mid-1;\\n            }\\n            else{\\n                s=mid+1;\\n            }\\n        }\\n        return -1;\\n    }\\n    int findPivot(vector<int>arr){\\n        int s=0;\\n        int e=arr.size()-1;\\n        int mid=s+(e-s)/2;\\n        while(s<e){\\n            \\n            if(mid+1<arr.size() && arr[mid]>arr[mid+1]){\\n                return mid;\\n            }\\n            if(mid-1>=0 && arr[mid-1]>arr[mid]){\\n                return mid-1;\\n            }\\n            if(arr[s]>=arr[mid]){  \\n                e=mid-1;\\n            }\\n            else{\\n                s=mid;\\n                \\n            }\\n            mid=s+(e-s)/2;\\n        }\\n    return s;\\n    }\\n    int search(vector<int>& arr, int target) {\\n        int pivot=findPivot(arr);\\n        if(target>=arr[0] && target<=arr[pivot]){\\n            int ans=binarySearch(arr,target,0,pivot);\\n            return ans;\\n        }\\n        if( pivot+1<arr.size() && target>=arr[pivot+1] &&         target<=arr[arr.size()-1] ){\\n            int ans=binarySearch(arr,target,pivot+1,arr.size()-1);\\n            return ans;\\n        }\\n        return -1;\\n    }\\n};"
                    }
                ]
            },
            {
                "id": 1946950,
                "content": [
                    {
                        "username": "mkathi",
                        "content": "can this be solved by using a map structure by storing element as key and index as value....? "
                    },
                    {
                        "username": "bparanj",
                        "content": "Yes, it\\'s possible to solve this problem using a map data structure where the key is the element and the value is its index. This approach involves iterating over the entire array once to populate the map, and then you can find the target in constant time.\\n\\nHere\\'s a basic outline of this approach in Python:\\n\\n```python\\ndef search(nums, target):\\n    num_to_index = {num: idx for idx, num in enumerate(nums)}\\n    return num_to_index.get(target, -1)\\n```\\n\\nHowever, there are a few points to consider:\\n\\n1. **Time complexity**: This approach has a time complexity of O(n) due to the initial iteration over the array, which is less efficient than the binary search approach that has a time complexity of O(log n).\\n\\n2. **Space complexity**: This approach requires O(n) additional space to store the map, whereas the binary search approach only requires O(1) space.\\n\\n3. **Unnecessary work**: This approach involves examining every element in the array, even though the array is sorted (or almost sorted, given the rotation). In many cases, the target could be found without having to look at every element.\\n\\nTherefore, while it\\'s possible to use a map to solve this problem, it\\'s not the most efficient solution. The binary search approach takes advantage of the sorted nature of the array and is generally a better choice for this problem."
                    },
                    {
                        "username": "mkathi",
                        "content": "i think if i use a map here , i\\'ll find the solution faster just by storing element as key and index as value ..... what do you say guys?"
                    },
                    {
                        "username": "rohiinegi2002",
                        "content": "may be yes..but then the space complexity will increase \\n"
                    },
                    {
                        "username": "amanpandey2000",
                        "content": "What's wrong with leetcode ? Why is not exiting the while loop when s==l?\nBelow is my solution. Can someone tell me if this is issue with leetcode runtime? \nI am able to run the code successfully in some other online editor,\n\nclass Solution {\npublic:\n    int search(vector<int>& nums, int target) {\n        int s = 0;\n        int l = nums.size() -1;\n        while(s<l)\n        {\n            cout<<s<<\" \"<<l<<\"\\n\";\n            int m =s+l;\n            if(m%2==0)\n            m = m/2;\n            else m = (m-1)/2;\n            \n            if(nums[m] == target)\n            {\n                cout<< \"*\"<<m<<\"*  \";\n                s = m;\n                l = m;\n            }\n            else if(nums[s]<=nums[m])\n            {\n                if(target>=nums[s] && target<=nums[m]) l = m;\n                else s = m;\n            }\n            else\n            {\n                if(target>=nums[m] && target<=nums[l]) s = m;\n                else l=m;\n            }\n            if(s==l)\n            {\n                cout<<\"BREAK\";\n                break;\n            }\n            cout<<s<<\" \"<<l<<\"\\n\";\n        }\n        if(nums[s] == target) return s;\n        else return -1;\n    }\n};"
                    },
                    {
                        "username": "amanpandey2000",
                        "content": "[@bparanj](/bparanj)  thanks for looking into it. Agreed that my solution has this flaw.\\n\\nBut still the thing that the first test case should exit properly worries me. In some other compiler it is working fine, but if I run this solution in leetcode, it is behaving wierdly as the statement which I have printed cout<<:BREAK\" is getting executed but in the next line the break statement should exit the while loop. But it is not happening which mainly worries me here."
                    },
                    {
                        "username": "bparanj",
                        "content": "From what I can see, your implementation of binary search seems to have an infinite loop issue when the target is not present in the array. This happens because you are updating your `s` and `l` pointers to `m` without checking if `m` can make `s` or `l` to move.\\n\\nLet\\'s look at the case when `s` and `l` are consecutive numbers. If `nums[s] <= nums[m]` is true and `target` is not in the range of `nums[s]` to `nums[m]`, `s` will be updated to `m`. However, if `m` is equal to `s` (which is possible when `s` and `l` are consecutive), `s` will not move. This will cause an infinite loop, as `s` and `l` will not change. The same problem can occur with `l`.\\n\\nA standard binary search implementation makes sure that `s` or `l` always changes:\\n\\n```cpp\\nclass Solution {\\npublic:\\n    int search(vector<int>& nums, int target) {\\n        int s = 0;\\n        int l = nums.size();\\n        while (s < l) {\\n            int m = s + (l - s) / 2;\\n            if (nums[m] == target) {\\n                return m;\\n            } else if (nums[s] <= nums[m]) {\\n                if (target >= nums[s] && target < nums[m]) {\\n                    l = m;\\n                } else {\\n                    s = m + 1;\\n                }\\n            } else {\\n                if (target > nums[m] && target <= nums[l-1]) {\\n                    s = m + 1;\\n                } else {\\n                    l = m;\\n                }\\n            }\\n        }\\n        return -1;\\n    }\\n};\\n```\\n\\nIn this code, if the target is not found, `s` or `l` will be updated such that it either increments or decrements. This way, the function is guaranteed to exit."
                    },
                    {
                        "username": "saambpatil",
                        "content": "#define endl \\'\\\\n\\'\\n// #define int long long\\n#define pb push_back\\n#define FAST                 \\\\\\n    ios::sync_with_stdio(0); \\\\\\n    cin.tie(0);              \\\\\\n    cout.tie(0);\\n#define ppb pop_back\\n#define lld long double\\n#define all(a) a.begin(), a.end()\\n#define vi vector<int>\\n#define vs vector<string>\\n#define vb vector<bool>\\n#define vvi vector<vector<int>>\\n// #define sz(a) a.size()\\n#define rep(i, a, n) for (int i = a; i < n; i++)\\n\\nclass Solution {\\npublic:\\n    \\n\\n    int binary2(vi arr, int pivotindex, int n, int target)\\n{\\n    int low = pivotindex + 1;\\n    int high = n - 1;\\n\\n    while (high >= low)\\n    {\\n        int mid = low + (high - low) / 2;\\n        if (arr[mid] == target)\\n        {\\n            return mid;\\n        }\\n        else if (arr[mid] > target)\\n        {\\n            high = mid - 1;\\n        }\\n        else\\n        {\\n            low = mid + 1;\\n        }\\n    }\\n    return -1;\\n}\\n\\nint binary1(vi arr, int pivotindex, int n, int target)\\n{\\n    int high = pivotindex;\\n    int low = n - 1;\\n\\n    while (high >= low)\\n    {\\n        int mid = low + (high - low) / 2;\\n        if (arr[mid] == target)\\n        {\\n            return mid;\\n        }\\n        else if (arr[mid] > target)\\n        {\\n            high = mid - 1;\\n        }\\n        else\\n        {\\n            low = mid + 1;\\n        }\\n    }\\n    return -1;\\n}\\n\\n    int pivot(vi arr, int n)\\n{\\n    int low = 0;\\n    int high = n - 1;\\n    while (low <= high)\\n    {\\n        int mid = low + (high - low) / 2;\\n        if (arr[mid] <= arr[n - 1])\\n        {\\n            // We are in part 2 of the array\\n            high = mid - 1;\\n        }\\n        else // We are in part 1 of the array\\n        {\\n            // We are on the pivot element\\n            if (arr[mid] > arr[mid + 1] && arr[mid] > arr[mid - 1])\\n            {\\n                return mid;\\n            }\\n            // We are not on pivot element\\n            else\\n            {\\n                low = mid + 1;\\n            }\\n        }\\n    }\\n    return 0;\\n\\n}\\n\\n    int search(vector<int>& numbers, int target) {\\n        int n = numbers.size();\\n        int pivotindex = pivot(numbers, n);\\n        int index;\\n         if (target <= numbers[n - 1])\\n        {\\n            index = binary2(numbers, pivotindex, n, target);\\n        }\\n        else if (target > numbers[n - 1])\\n        {\\n            index = binary1(numbers, pivotindex, n, target);\\n        }\\n        return index;\\n    }\\n};\\n\\nI am getting proper result when i run the code but getting runtime error while submitting pls correct the code and point out the mistake"
                    },
                    {
                        "username": "bparanj",
                        "content": "The runtime error may be due to an \"array index out of bounds\" issue. In the pivot function, you\\'re comparing `arr[mid]` with `arr[mid + 1]` and `arr[mid - 1]` without checking if `mid + 1` and `mid - 1` are valid indices. If `mid` happens to be 0 or `n - 1`, it will result in an out-of-bounds error. \\n\\nAlso, note that in `binary1()` function, you\\'ve set `low` to `n - 1` and `high` to `pivotindex`, which might be causing a logical error because `low` should be less than `high` in a standard binary search.\\n\\nHere is the corrected version of your code:\\n\\n```cpp\\nclass Solution {\\npublic:\\n    int binary2(vector<int>& arr, int pivotindex, int n, int target) {\\n        int low = pivotindex + 1;\\n        int high = n - 1;\\n\\n        while (high >= low) {\\n            int mid = low + (high - low) / 2;\\n            if (arr[mid] == target) {\\n                return mid;\\n            }\\n            else if (arr[mid] > target) {\\n                high = mid - 1;\\n            }\\n            else {\\n                low = mid + 1;\\n            }\\n        }\\n        return -1;\\n    }\\n\\n    int binary1(vector<int>& arr, int pivotindex, int n, int target) {\\n        int low = 0;\\n        int high = pivotindex;\\n\\n        while (high >= low) {\\n            int mid = low + (high - low) / 2;\\n            if (arr[mid] == target) {\\n                return mid;\\n            }\\n            else if (arr[mid] > target) {\\n                high = mid - 1;\\n            }\\n            else {\\n                low = mid + 1;\\n            }\\n        }\\n        return -1;\\n    }\\n\\n    int pivot(vector<int>& arr, int n) {\\n        int low = 0;\\n        int high = n - 1;\\n        while (low <= high) {\\n            int mid = low + (high - low) / 2;\\n            if (arr[mid] <= arr[n - 1]) {\\n                high = mid - 1;\\n            }\\n            else {\\n                if (mid > 0 && mid < n - 1 && arr[mid] > arr[mid + 1] && arr[mid] > arr[mid - 1]) {\\n                    return mid;\\n                }\\n                else {\\n                    low = mid + 1;\\n                }\\n            }\\n        }\\n        return 0;\\n    }\\n\\n    int search(vector<int>& numbers, int target) {\\n        int n = numbers.size();\\n        int pivotindex = pivot(numbers, n);\\n        int index;\\n        if (target <= numbers[n - 1]) {\\n            index = binary2(numbers, pivotindex, n, target);\\n        }\\n        else if (target > numbers[n - 1]) {\\n            index = binary1(numbers, pivotindex, n, target);\\n        }\\n        return index;\\n    }\\n};\\n```\\nThis code should fix the runtime error you\\'re encountering. Please test it out on different test cases to ensure that it\\'s working as expected."
                    },
                    {
                        "username": "amangupta9255",
                        "content": "The problem has two important keywords, \"Search\" and \"Sorted\". This gives us the idea of using binary search in this problem. Since the array is rotated, so the idea is to check that which protion of array is sorted. First we check that portion of array and then we check if the target lies in the sorted portion of array or not. This process is repeated, if target element is not present in array we return -1."
                    },
                    {
                        "username": "Kaushh",
                        "content": "\\uD83D\\uDE02\\uD83D\\uDE02linear search gives 100% while Binary Search only 46%."
                    },
                    {
                        "username": "viraat0700",
                        "content": "we only have to write code for the function right . We do not have to write the main function?\\n"
                    },
                    {
                        "username": "Honey_19",
                        "content": "It should be in easy \\n"
                    },
                    {
                        "username": "user5369RY",
                        "content": "[3,5,1] the target is 3 why not  1?   for all cases if the list was rotated then the most right element is smaller than the middle then the index of most right is the target or in the mid equal to target then it is he target why in this case such logic did not work?"
                    },
                    {
                        "username": "bparanj",
                        "content": "Your logic assumes that the target is always the pivot (the smallest element in the rotated array) or the middle element. However, the problem statement says that the target could be any number in the array, not necessarily the pivot or the middle. \\n\\nIn your example [3,5,1], the target could be 3, 5, or 1. If the target is 3, then the expected output is 0 because 3 is at index 0. If the target is 5, then the expected output is 1 because 5 is at index 1. If the target is 1, then the expected output is 2 because 1 is at index 2.\\n\\nSo, the key to solving this problem is not to find the pivot or the middle, but to find the target. This requires modifying the binary search to handle the rotation."
                    },
                    {
                        "username": "mohitjangid14101",
                        "content": "class Solution {\\npublic:\\n    int binarySearch(vector<int>arr,int target,int s,int e){\\n        while(s<=e){\\n            int mid=s+(e-s)/2;\\n            if(arr[mid]==target){\\n                return mid;\\n            }\\n            else if(arr[mid]>target){\\n                e=mid-1;\\n            }\\n            else{\\n                s=mid+1;\\n            }\\n        }\\n        return -1;\\n    }\\n    int findPivot(vector<int>arr){\\n        int s=0;\\n        int e=arr.size()-1;\\n        int mid=s+(e-s)/2;\\n        while(s<e){\\n            \\n            if(mid+1<arr.size() && arr[mid]>arr[mid+1]){\\n                return mid;\\n            }\\n            if(mid-1>=0 && arr[mid-1]>arr[mid]){\\n                return mid-1;\\n            }\\n            if(arr[s]>=arr[mid]){  \\n                e=mid-1;\\n            }\\n            else{\\n                s=mid;\\n                \\n            }\\n            mid=s+(e-s)/2;\\n        }\\n    return s;\\n    }\\n    int search(vector<int>& arr, int target) {\\n        int pivot=findPivot(arr);\\n        if(target>=arr[0] && target<=arr[pivot]){\\n            int ans=binarySearch(arr,target,0,pivot);\\n            return ans;\\n        }\\n        if( pivot+1<arr.size() && target>=arr[pivot+1] &&         target<=arr[arr.size()-1] ){\\n            int ans=binarySearch(arr,target,pivot+1,arr.size()-1);\\n            return ans;\\n        }\\n        return -1;\\n    }\\n};"
                    }
                ]
            },
            {
                "id": 1941884,
                "content": [
                    {
                        "username": "mkathi",
                        "content": "can this be solved by using a map structure by storing element as key and index as value....? "
                    },
                    {
                        "username": "bparanj",
                        "content": "Yes, it\\'s possible to solve this problem using a map data structure where the key is the element and the value is its index. This approach involves iterating over the entire array once to populate the map, and then you can find the target in constant time.\\n\\nHere\\'s a basic outline of this approach in Python:\\n\\n```python\\ndef search(nums, target):\\n    num_to_index = {num: idx for idx, num in enumerate(nums)}\\n    return num_to_index.get(target, -1)\\n```\\n\\nHowever, there are a few points to consider:\\n\\n1. **Time complexity**: This approach has a time complexity of O(n) due to the initial iteration over the array, which is less efficient than the binary search approach that has a time complexity of O(log n).\\n\\n2. **Space complexity**: This approach requires O(n) additional space to store the map, whereas the binary search approach only requires O(1) space.\\n\\n3. **Unnecessary work**: This approach involves examining every element in the array, even though the array is sorted (or almost sorted, given the rotation). In many cases, the target could be found without having to look at every element.\\n\\nTherefore, while it\\'s possible to use a map to solve this problem, it\\'s not the most efficient solution. The binary search approach takes advantage of the sorted nature of the array and is generally a better choice for this problem."
                    },
                    {
                        "username": "mkathi",
                        "content": "i think if i use a map here , i\\'ll find the solution faster just by storing element as key and index as value ..... what do you say guys?"
                    },
                    {
                        "username": "rohiinegi2002",
                        "content": "may be yes..but then the space complexity will increase \\n"
                    },
                    {
                        "username": "amanpandey2000",
                        "content": "What's wrong with leetcode ? Why is not exiting the while loop when s==l?\nBelow is my solution. Can someone tell me if this is issue with leetcode runtime? \nI am able to run the code successfully in some other online editor,\n\nclass Solution {\npublic:\n    int search(vector<int>& nums, int target) {\n        int s = 0;\n        int l = nums.size() -1;\n        while(s<l)\n        {\n            cout<<s<<\" \"<<l<<\"\\n\";\n            int m =s+l;\n            if(m%2==0)\n            m = m/2;\n            else m = (m-1)/2;\n            \n            if(nums[m] == target)\n            {\n                cout<< \"*\"<<m<<\"*  \";\n                s = m;\n                l = m;\n            }\n            else if(nums[s]<=nums[m])\n            {\n                if(target>=nums[s] && target<=nums[m]) l = m;\n                else s = m;\n            }\n            else\n            {\n                if(target>=nums[m] && target<=nums[l]) s = m;\n                else l=m;\n            }\n            if(s==l)\n            {\n                cout<<\"BREAK\";\n                break;\n            }\n            cout<<s<<\" \"<<l<<\"\\n\";\n        }\n        if(nums[s] == target) return s;\n        else return -1;\n    }\n};"
                    },
                    {
                        "username": "amanpandey2000",
                        "content": "[@bparanj](/bparanj)  thanks for looking into it. Agreed that my solution has this flaw.\\n\\nBut still the thing that the first test case should exit properly worries me. In some other compiler it is working fine, but if I run this solution in leetcode, it is behaving wierdly as the statement which I have printed cout<<:BREAK\" is getting executed but in the next line the break statement should exit the while loop. But it is not happening which mainly worries me here."
                    },
                    {
                        "username": "bparanj",
                        "content": "From what I can see, your implementation of binary search seems to have an infinite loop issue when the target is not present in the array. This happens because you are updating your `s` and `l` pointers to `m` without checking if `m` can make `s` or `l` to move.\\n\\nLet\\'s look at the case when `s` and `l` are consecutive numbers. If `nums[s] <= nums[m]` is true and `target` is not in the range of `nums[s]` to `nums[m]`, `s` will be updated to `m`. However, if `m` is equal to `s` (which is possible when `s` and `l` are consecutive), `s` will not move. This will cause an infinite loop, as `s` and `l` will not change. The same problem can occur with `l`.\\n\\nA standard binary search implementation makes sure that `s` or `l` always changes:\\n\\n```cpp\\nclass Solution {\\npublic:\\n    int search(vector<int>& nums, int target) {\\n        int s = 0;\\n        int l = nums.size();\\n        while (s < l) {\\n            int m = s + (l - s) / 2;\\n            if (nums[m] == target) {\\n                return m;\\n            } else if (nums[s] <= nums[m]) {\\n                if (target >= nums[s] && target < nums[m]) {\\n                    l = m;\\n                } else {\\n                    s = m + 1;\\n                }\\n            } else {\\n                if (target > nums[m] && target <= nums[l-1]) {\\n                    s = m + 1;\\n                } else {\\n                    l = m;\\n                }\\n            }\\n        }\\n        return -1;\\n    }\\n};\\n```\\n\\nIn this code, if the target is not found, `s` or `l` will be updated such that it either increments or decrements. This way, the function is guaranteed to exit."
                    },
                    {
                        "username": "saambpatil",
                        "content": "#define endl \\'\\\\n\\'\\n// #define int long long\\n#define pb push_back\\n#define FAST                 \\\\\\n    ios::sync_with_stdio(0); \\\\\\n    cin.tie(0);              \\\\\\n    cout.tie(0);\\n#define ppb pop_back\\n#define lld long double\\n#define all(a) a.begin(), a.end()\\n#define vi vector<int>\\n#define vs vector<string>\\n#define vb vector<bool>\\n#define vvi vector<vector<int>>\\n// #define sz(a) a.size()\\n#define rep(i, a, n) for (int i = a; i < n; i++)\\n\\nclass Solution {\\npublic:\\n    \\n\\n    int binary2(vi arr, int pivotindex, int n, int target)\\n{\\n    int low = pivotindex + 1;\\n    int high = n - 1;\\n\\n    while (high >= low)\\n    {\\n        int mid = low + (high - low) / 2;\\n        if (arr[mid] == target)\\n        {\\n            return mid;\\n        }\\n        else if (arr[mid] > target)\\n        {\\n            high = mid - 1;\\n        }\\n        else\\n        {\\n            low = mid + 1;\\n        }\\n    }\\n    return -1;\\n}\\n\\nint binary1(vi arr, int pivotindex, int n, int target)\\n{\\n    int high = pivotindex;\\n    int low = n - 1;\\n\\n    while (high >= low)\\n    {\\n        int mid = low + (high - low) / 2;\\n        if (arr[mid] == target)\\n        {\\n            return mid;\\n        }\\n        else if (arr[mid] > target)\\n        {\\n            high = mid - 1;\\n        }\\n        else\\n        {\\n            low = mid + 1;\\n        }\\n    }\\n    return -1;\\n}\\n\\n    int pivot(vi arr, int n)\\n{\\n    int low = 0;\\n    int high = n - 1;\\n    while (low <= high)\\n    {\\n        int mid = low + (high - low) / 2;\\n        if (arr[mid] <= arr[n - 1])\\n        {\\n            // We are in part 2 of the array\\n            high = mid - 1;\\n        }\\n        else // We are in part 1 of the array\\n        {\\n            // We are on the pivot element\\n            if (arr[mid] > arr[mid + 1] && arr[mid] > arr[mid - 1])\\n            {\\n                return mid;\\n            }\\n            // We are not on pivot element\\n            else\\n            {\\n                low = mid + 1;\\n            }\\n        }\\n    }\\n    return 0;\\n\\n}\\n\\n    int search(vector<int>& numbers, int target) {\\n        int n = numbers.size();\\n        int pivotindex = pivot(numbers, n);\\n        int index;\\n         if (target <= numbers[n - 1])\\n        {\\n            index = binary2(numbers, pivotindex, n, target);\\n        }\\n        else if (target > numbers[n - 1])\\n        {\\n            index = binary1(numbers, pivotindex, n, target);\\n        }\\n        return index;\\n    }\\n};\\n\\nI am getting proper result when i run the code but getting runtime error while submitting pls correct the code and point out the mistake"
                    },
                    {
                        "username": "bparanj",
                        "content": "The runtime error may be due to an \"array index out of bounds\" issue. In the pivot function, you\\'re comparing `arr[mid]` with `arr[mid + 1]` and `arr[mid - 1]` without checking if `mid + 1` and `mid - 1` are valid indices. If `mid` happens to be 0 or `n - 1`, it will result in an out-of-bounds error. \\n\\nAlso, note that in `binary1()` function, you\\'ve set `low` to `n - 1` and `high` to `pivotindex`, which might be causing a logical error because `low` should be less than `high` in a standard binary search.\\n\\nHere is the corrected version of your code:\\n\\n```cpp\\nclass Solution {\\npublic:\\n    int binary2(vector<int>& arr, int pivotindex, int n, int target) {\\n        int low = pivotindex + 1;\\n        int high = n - 1;\\n\\n        while (high >= low) {\\n            int mid = low + (high - low) / 2;\\n            if (arr[mid] == target) {\\n                return mid;\\n            }\\n            else if (arr[mid] > target) {\\n                high = mid - 1;\\n            }\\n            else {\\n                low = mid + 1;\\n            }\\n        }\\n        return -1;\\n    }\\n\\n    int binary1(vector<int>& arr, int pivotindex, int n, int target) {\\n        int low = 0;\\n        int high = pivotindex;\\n\\n        while (high >= low) {\\n            int mid = low + (high - low) / 2;\\n            if (arr[mid] == target) {\\n                return mid;\\n            }\\n            else if (arr[mid] > target) {\\n                high = mid - 1;\\n            }\\n            else {\\n                low = mid + 1;\\n            }\\n        }\\n        return -1;\\n    }\\n\\n    int pivot(vector<int>& arr, int n) {\\n        int low = 0;\\n        int high = n - 1;\\n        while (low <= high) {\\n            int mid = low + (high - low) / 2;\\n            if (arr[mid] <= arr[n - 1]) {\\n                high = mid - 1;\\n            }\\n            else {\\n                if (mid > 0 && mid < n - 1 && arr[mid] > arr[mid + 1] && arr[mid] > arr[mid - 1]) {\\n                    return mid;\\n                }\\n                else {\\n                    low = mid + 1;\\n                }\\n            }\\n        }\\n        return 0;\\n    }\\n\\n    int search(vector<int>& numbers, int target) {\\n        int n = numbers.size();\\n        int pivotindex = pivot(numbers, n);\\n        int index;\\n        if (target <= numbers[n - 1]) {\\n            index = binary2(numbers, pivotindex, n, target);\\n        }\\n        else if (target > numbers[n - 1]) {\\n            index = binary1(numbers, pivotindex, n, target);\\n        }\\n        return index;\\n    }\\n};\\n```\\nThis code should fix the runtime error you\\'re encountering. Please test it out on different test cases to ensure that it\\'s working as expected."
                    },
                    {
                        "username": "amangupta9255",
                        "content": "The problem has two important keywords, \"Search\" and \"Sorted\". This gives us the idea of using binary search in this problem. Since the array is rotated, so the idea is to check that which protion of array is sorted. First we check that portion of array and then we check if the target lies in the sorted portion of array or not. This process is repeated, if target element is not present in array we return -1."
                    },
                    {
                        "username": "Kaushh",
                        "content": "\\uD83D\\uDE02\\uD83D\\uDE02linear search gives 100% while Binary Search only 46%."
                    },
                    {
                        "username": "viraat0700",
                        "content": "we only have to write code for the function right . We do not have to write the main function?\\n"
                    },
                    {
                        "username": "Honey_19",
                        "content": "It should be in easy \\n"
                    },
                    {
                        "username": "user5369RY",
                        "content": "[3,5,1] the target is 3 why not  1?   for all cases if the list was rotated then the most right element is smaller than the middle then the index of most right is the target or in the mid equal to target then it is he target why in this case such logic did not work?"
                    },
                    {
                        "username": "bparanj",
                        "content": "Your logic assumes that the target is always the pivot (the smallest element in the rotated array) or the middle element. However, the problem statement says that the target could be any number in the array, not necessarily the pivot or the middle. \\n\\nIn your example [3,5,1], the target could be 3, 5, or 1. If the target is 3, then the expected output is 0 because 3 is at index 0. If the target is 5, then the expected output is 1 because 5 is at index 1. If the target is 1, then the expected output is 2 because 1 is at index 2.\\n\\nSo, the key to solving this problem is not to find the pivot or the middle, but to find the target. This requires modifying the binary search to handle the rotation."
                    },
                    {
                        "username": "mohitjangid14101",
                        "content": "class Solution {\\npublic:\\n    int binarySearch(vector<int>arr,int target,int s,int e){\\n        while(s<=e){\\n            int mid=s+(e-s)/2;\\n            if(arr[mid]==target){\\n                return mid;\\n            }\\n            else if(arr[mid]>target){\\n                e=mid-1;\\n            }\\n            else{\\n                s=mid+1;\\n            }\\n        }\\n        return -1;\\n    }\\n    int findPivot(vector<int>arr){\\n        int s=0;\\n        int e=arr.size()-1;\\n        int mid=s+(e-s)/2;\\n        while(s<e){\\n            \\n            if(mid+1<arr.size() && arr[mid]>arr[mid+1]){\\n                return mid;\\n            }\\n            if(mid-1>=0 && arr[mid-1]>arr[mid]){\\n                return mid-1;\\n            }\\n            if(arr[s]>=arr[mid]){  \\n                e=mid-1;\\n            }\\n            else{\\n                s=mid;\\n                \\n            }\\n            mid=s+(e-s)/2;\\n        }\\n    return s;\\n    }\\n    int search(vector<int>& arr, int target) {\\n        int pivot=findPivot(arr);\\n        if(target>=arr[0] && target<=arr[pivot]){\\n            int ans=binarySearch(arr,target,0,pivot);\\n            return ans;\\n        }\\n        if( pivot+1<arr.size() && target>=arr[pivot+1] &&         target<=arr[arr.size()-1] ){\\n            int ans=binarySearch(arr,target,pivot+1,arr.size()-1);\\n            return ans;\\n        }\\n        return -1;\\n    }\\n};"
                    }
                ]
            },
            {
                "id": 1941772,
                "content": [
                    {
                        "username": "mkathi",
                        "content": "can this be solved by using a map structure by storing element as key and index as value....? "
                    },
                    {
                        "username": "bparanj",
                        "content": "Yes, it\\'s possible to solve this problem using a map data structure where the key is the element and the value is its index. This approach involves iterating over the entire array once to populate the map, and then you can find the target in constant time.\\n\\nHere\\'s a basic outline of this approach in Python:\\n\\n```python\\ndef search(nums, target):\\n    num_to_index = {num: idx for idx, num in enumerate(nums)}\\n    return num_to_index.get(target, -1)\\n```\\n\\nHowever, there are a few points to consider:\\n\\n1. **Time complexity**: This approach has a time complexity of O(n) due to the initial iteration over the array, which is less efficient than the binary search approach that has a time complexity of O(log n).\\n\\n2. **Space complexity**: This approach requires O(n) additional space to store the map, whereas the binary search approach only requires O(1) space.\\n\\n3. **Unnecessary work**: This approach involves examining every element in the array, even though the array is sorted (or almost sorted, given the rotation). In many cases, the target could be found without having to look at every element.\\n\\nTherefore, while it\\'s possible to use a map to solve this problem, it\\'s not the most efficient solution. The binary search approach takes advantage of the sorted nature of the array and is generally a better choice for this problem."
                    },
                    {
                        "username": "mkathi",
                        "content": "i think if i use a map here , i\\'ll find the solution faster just by storing element as key and index as value ..... what do you say guys?"
                    },
                    {
                        "username": "rohiinegi2002",
                        "content": "may be yes..but then the space complexity will increase \\n"
                    },
                    {
                        "username": "amanpandey2000",
                        "content": "What's wrong with leetcode ? Why is not exiting the while loop when s==l?\nBelow is my solution. Can someone tell me if this is issue with leetcode runtime? \nI am able to run the code successfully in some other online editor,\n\nclass Solution {\npublic:\n    int search(vector<int>& nums, int target) {\n        int s = 0;\n        int l = nums.size() -1;\n        while(s<l)\n        {\n            cout<<s<<\" \"<<l<<\"\\n\";\n            int m =s+l;\n            if(m%2==0)\n            m = m/2;\n            else m = (m-1)/2;\n            \n            if(nums[m] == target)\n            {\n                cout<< \"*\"<<m<<\"*  \";\n                s = m;\n                l = m;\n            }\n            else if(nums[s]<=nums[m])\n            {\n                if(target>=nums[s] && target<=nums[m]) l = m;\n                else s = m;\n            }\n            else\n            {\n                if(target>=nums[m] && target<=nums[l]) s = m;\n                else l=m;\n            }\n            if(s==l)\n            {\n                cout<<\"BREAK\";\n                break;\n            }\n            cout<<s<<\" \"<<l<<\"\\n\";\n        }\n        if(nums[s] == target) return s;\n        else return -1;\n    }\n};"
                    },
                    {
                        "username": "amanpandey2000",
                        "content": "[@bparanj](/bparanj)  thanks for looking into it. Agreed that my solution has this flaw.\\n\\nBut still the thing that the first test case should exit properly worries me. In some other compiler it is working fine, but if I run this solution in leetcode, it is behaving wierdly as the statement which I have printed cout<<:BREAK\" is getting executed but in the next line the break statement should exit the while loop. But it is not happening which mainly worries me here."
                    },
                    {
                        "username": "bparanj",
                        "content": "From what I can see, your implementation of binary search seems to have an infinite loop issue when the target is not present in the array. This happens because you are updating your `s` and `l` pointers to `m` without checking if `m` can make `s` or `l` to move.\\n\\nLet\\'s look at the case when `s` and `l` are consecutive numbers. If `nums[s] <= nums[m]` is true and `target` is not in the range of `nums[s]` to `nums[m]`, `s` will be updated to `m`. However, if `m` is equal to `s` (which is possible when `s` and `l` are consecutive), `s` will not move. This will cause an infinite loop, as `s` and `l` will not change. The same problem can occur with `l`.\\n\\nA standard binary search implementation makes sure that `s` or `l` always changes:\\n\\n```cpp\\nclass Solution {\\npublic:\\n    int search(vector<int>& nums, int target) {\\n        int s = 0;\\n        int l = nums.size();\\n        while (s < l) {\\n            int m = s + (l - s) / 2;\\n            if (nums[m] == target) {\\n                return m;\\n            } else if (nums[s] <= nums[m]) {\\n                if (target >= nums[s] && target < nums[m]) {\\n                    l = m;\\n                } else {\\n                    s = m + 1;\\n                }\\n            } else {\\n                if (target > nums[m] && target <= nums[l-1]) {\\n                    s = m + 1;\\n                } else {\\n                    l = m;\\n                }\\n            }\\n        }\\n        return -1;\\n    }\\n};\\n```\\n\\nIn this code, if the target is not found, `s` or `l` will be updated such that it either increments or decrements. This way, the function is guaranteed to exit."
                    },
                    {
                        "username": "saambpatil",
                        "content": "#define endl \\'\\\\n\\'\\n// #define int long long\\n#define pb push_back\\n#define FAST                 \\\\\\n    ios::sync_with_stdio(0); \\\\\\n    cin.tie(0);              \\\\\\n    cout.tie(0);\\n#define ppb pop_back\\n#define lld long double\\n#define all(a) a.begin(), a.end()\\n#define vi vector<int>\\n#define vs vector<string>\\n#define vb vector<bool>\\n#define vvi vector<vector<int>>\\n// #define sz(a) a.size()\\n#define rep(i, a, n) for (int i = a; i < n; i++)\\n\\nclass Solution {\\npublic:\\n    \\n\\n    int binary2(vi arr, int pivotindex, int n, int target)\\n{\\n    int low = pivotindex + 1;\\n    int high = n - 1;\\n\\n    while (high >= low)\\n    {\\n        int mid = low + (high - low) / 2;\\n        if (arr[mid] == target)\\n        {\\n            return mid;\\n        }\\n        else if (arr[mid] > target)\\n        {\\n            high = mid - 1;\\n        }\\n        else\\n        {\\n            low = mid + 1;\\n        }\\n    }\\n    return -1;\\n}\\n\\nint binary1(vi arr, int pivotindex, int n, int target)\\n{\\n    int high = pivotindex;\\n    int low = n - 1;\\n\\n    while (high >= low)\\n    {\\n        int mid = low + (high - low) / 2;\\n        if (arr[mid] == target)\\n        {\\n            return mid;\\n        }\\n        else if (arr[mid] > target)\\n        {\\n            high = mid - 1;\\n        }\\n        else\\n        {\\n            low = mid + 1;\\n        }\\n    }\\n    return -1;\\n}\\n\\n    int pivot(vi arr, int n)\\n{\\n    int low = 0;\\n    int high = n - 1;\\n    while (low <= high)\\n    {\\n        int mid = low + (high - low) / 2;\\n        if (arr[mid] <= arr[n - 1])\\n        {\\n            // We are in part 2 of the array\\n            high = mid - 1;\\n        }\\n        else // We are in part 1 of the array\\n        {\\n            // We are on the pivot element\\n            if (arr[mid] > arr[mid + 1] && arr[mid] > arr[mid - 1])\\n            {\\n                return mid;\\n            }\\n            // We are not on pivot element\\n            else\\n            {\\n                low = mid + 1;\\n            }\\n        }\\n    }\\n    return 0;\\n\\n}\\n\\n    int search(vector<int>& numbers, int target) {\\n        int n = numbers.size();\\n        int pivotindex = pivot(numbers, n);\\n        int index;\\n         if (target <= numbers[n - 1])\\n        {\\n            index = binary2(numbers, pivotindex, n, target);\\n        }\\n        else if (target > numbers[n - 1])\\n        {\\n            index = binary1(numbers, pivotindex, n, target);\\n        }\\n        return index;\\n    }\\n};\\n\\nI am getting proper result when i run the code but getting runtime error while submitting pls correct the code and point out the mistake"
                    },
                    {
                        "username": "bparanj",
                        "content": "The runtime error may be due to an \"array index out of bounds\" issue. In the pivot function, you\\'re comparing `arr[mid]` with `arr[mid + 1]` and `arr[mid - 1]` without checking if `mid + 1` and `mid - 1` are valid indices. If `mid` happens to be 0 or `n - 1`, it will result in an out-of-bounds error. \\n\\nAlso, note that in `binary1()` function, you\\'ve set `low` to `n - 1` and `high` to `pivotindex`, which might be causing a logical error because `low` should be less than `high` in a standard binary search.\\n\\nHere is the corrected version of your code:\\n\\n```cpp\\nclass Solution {\\npublic:\\n    int binary2(vector<int>& arr, int pivotindex, int n, int target) {\\n        int low = pivotindex + 1;\\n        int high = n - 1;\\n\\n        while (high >= low) {\\n            int mid = low + (high - low) / 2;\\n            if (arr[mid] == target) {\\n                return mid;\\n            }\\n            else if (arr[mid] > target) {\\n                high = mid - 1;\\n            }\\n            else {\\n                low = mid + 1;\\n            }\\n        }\\n        return -1;\\n    }\\n\\n    int binary1(vector<int>& arr, int pivotindex, int n, int target) {\\n        int low = 0;\\n        int high = pivotindex;\\n\\n        while (high >= low) {\\n            int mid = low + (high - low) / 2;\\n            if (arr[mid] == target) {\\n                return mid;\\n            }\\n            else if (arr[mid] > target) {\\n                high = mid - 1;\\n            }\\n            else {\\n                low = mid + 1;\\n            }\\n        }\\n        return -1;\\n    }\\n\\n    int pivot(vector<int>& arr, int n) {\\n        int low = 0;\\n        int high = n - 1;\\n        while (low <= high) {\\n            int mid = low + (high - low) / 2;\\n            if (arr[mid] <= arr[n - 1]) {\\n                high = mid - 1;\\n            }\\n            else {\\n                if (mid > 0 && mid < n - 1 && arr[mid] > arr[mid + 1] && arr[mid] > arr[mid - 1]) {\\n                    return mid;\\n                }\\n                else {\\n                    low = mid + 1;\\n                }\\n            }\\n        }\\n        return 0;\\n    }\\n\\n    int search(vector<int>& numbers, int target) {\\n        int n = numbers.size();\\n        int pivotindex = pivot(numbers, n);\\n        int index;\\n        if (target <= numbers[n - 1]) {\\n            index = binary2(numbers, pivotindex, n, target);\\n        }\\n        else if (target > numbers[n - 1]) {\\n            index = binary1(numbers, pivotindex, n, target);\\n        }\\n        return index;\\n    }\\n};\\n```\\nThis code should fix the runtime error you\\'re encountering. Please test it out on different test cases to ensure that it\\'s working as expected."
                    },
                    {
                        "username": "amangupta9255",
                        "content": "The problem has two important keywords, \"Search\" and \"Sorted\". This gives us the idea of using binary search in this problem. Since the array is rotated, so the idea is to check that which protion of array is sorted. First we check that portion of array and then we check if the target lies in the sorted portion of array or not. This process is repeated, if target element is not present in array we return -1."
                    },
                    {
                        "username": "Kaushh",
                        "content": "\\uD83D\\uDE02\\uD83D\\uDE02linear search gives 100% while Binary Search only 46%."
                    },
                    {
                        "username": "viraat0700",
                        "content": "we only have to write code for the function right . We do not have to write the main function?\\n"
                    },
                    {
                        "username": "Honey_19",
                        "content": "It should be in easy \\n"
                    },
                    {
                        "username": "user5369RY",
                        "content": "[3,5,1] the target is 3 why not  1?   for all cases if the list was rotated then the most right element is smaller than the middle then the index of most right is the target or in the mid equal to target then it is he target why in this case such logic did not work?"
                    },
                    {
                        "username": "bparanj",
                        "content": "Your logic assumes that the target is always the pivot (the smallest element in the rotated array) or the middle element. However, the problem statement says that the target could be any number in the array, not necessarily the pivot or the middle. \\n\\nIn your example [3,5,1], the target could be 3, 5, or 1. If the target is 3, then the expected output is 0 because 3 is at index 0. If the target is 5, then the expected output is 1 because 5 is at index 1. If the target is 1, then the expected output is 2 because 1 is at index 2.\\n\\nSo, the key to solving this problem is not to find the pivot or the middle, but to find the target. This requires modifying the binary search to handle the rotation."
                    },
                    {
                        "username": "mohitjangid14101",
                        "content": "class Solution {\\npublic:\\n    int binarySearch(vector<int>arr,int target,int s,int e){\\n        while(s<=e){\\n            int mid=s+(e-s)/2;\\n            if(arr[mid]==target){\\n                return mid;\\n            }\\n            else if(arr[mid]>target){\\n                e=mid-1;\\n            }\\n            else{\\n                s=mid+1;\\n            }\\n        }\\n        return -1;\\n    }\\n    int findPivot(vector<int>arr){\\n        int s=0;\\n        int e=arr.size()-1;\\n        int mid=s+(e-s)/2;\\n        while(s<e){\\n            \\n            if(mid+1<arr.size() && arr[mid]>arr[mid+1]){\\n                return mid;\\n            }\\n            if(mid-1>=0 && arr[mid-1]>arr[mid]){\\n                return mid-1;\\n            }\\n            if(arr[s]>=arr[mid]){  \\n                e=mid-1;\\n            }\\n            else{\\n                s=mid;\\n                \\n            }\\n            mid=s+(e-s)/2;\\n        }\\n    return s;\\n    }\\n    int search(vector<int>& arr, int target) {\\n        int pivot=findPivot(arr);\\n        if(target>=arr[0] && target<=arr[pivot]){\\n            int ans=binarySearch(arr,target,0,pivot);\\n            return ans;\\n        }\\n        if( pivot+1<arr.size() && target>=arr[pivot+1] &&         target<=arr[arr.size()-1] ){\\n            int ans=binarySearch(arr,target,pivot+1,arr.size()-1);\\n            return ans;\\n        }\\n        return -1;\\n    }\\n};"
                    }
                ]
            },
            {
                "id": 1938429,
                "content": [
                    {
                        "username": "mkathi",
                        "content": "can this be solved by using a map structure by storing element as key and index as value....? "
                    },
                    {
                        "username": "bparanj",
                        "content": "Yes, it\\'s possible to solve this problem using a map data structure where the key is the element and the value is its index. This approach involves iterating over the entire array once to populate the map, and then you can find the target in constant time.\\n\\nHere\\'s a basic outline of this approach in Python:\\n\\n```python\\ndef search(nums, target):\\n    num_to_index = {num: idx for idx, num in enumerate(nums)}\\n    return num_to_index.get(target, -1)\\n```\\n\\nHowever, there are a few points to consider:\\n\\n1. **Time complexity**: This approach has a time complexity of O(n) due to the initial iteration over the array, which is less efficient than the binary search approach that has a time complexity of O(log n).\\n\\n2. **Space complexity**: This approach requires O(n) additional space to store the map, whereas the binary search approach only requires O(1) space.\\n\\n3. **Unnecessary work**: This approach involves examining every element in the array, even though the array is sorted (or almost sorted, given the rotation). In many cases, the target could be found without having to look at every element.\\n\\nTherefore, while it\\'s possible to use a map to solve this problem, it\\'s not the most efficient solution. The binary search approach takes advantage of the sorted nature of the array and is generally a better choice for this problem."
                    },
                    {
                        "username": "mkathi",
                        "content": "i think if i use a map here , i\\'ll find the solution faster just by storing element as key and index as value ..... what do you say guys?"
                    },
                    {
                        "username": "rohiinegi2002",
                        "content": "may be yes..but then the space complexity will increase \\n"
                    },
                    {
                        "username": "amanpandey2000",
                        "content": "What's wrong with leetcode ? Why is not exiting the while loop when s==l?\nBelow is my solution. Can someone tell me if this is issue with leetcode runtime? \nI am able to run the code successfully in some other online editor,\n\nclass Solution {\npublic:\n    int search(vector<int>& nums, int target) {\n        int s = 0;\n        int l = nums.size() -1;\n        while(s<l)\n        {\n            cout<<s<<\" \"<<l<<\"\\n\";\n            int m =s+l;\n            if(m%2==0)\n            m = m/2;\n            else m = (m-1)/2;\n            \n            if(nums[m] == target)\n            {\n                cout<< \"*\"<<m<<\"*  \";\n                s = m;\n                l = m;\n            }\n            else if(nums[s]<=nums[m])\n            {\n                if(target>=nums[s] && target<=nums[m]) l = m;\n                else s = m;\n            }\n            else\n            {\n                if(target>=nums[m] && target<=nums[l]) s = m;\n                else l=m;\n            }\n            if(s==l)\n            {\n                cout<<\"BREAK\";\n                break;\n            }\n            cout<<s<<\" \"<<l<<\"\\n\";\n        }\n        if(nums[s] == target) return s;\n        else return -1;\n    }\n};"
                    },
                    {
                        "username": "amanpandey2000",
                        "content": "[@bparanj](/bparanj)  thanks for looking into it. Agreed that my solution has this flaw.\\n\\nBut still the thing that the first test case should exit properly worries me. In some other compiler it is working fine, but if I run this solution in leetcode, it is behaving wierdly as the statement which I have printed cout<<:BREAK\" is getting executed but in the next line the break statement should exit the while loop. But it is not happening which mainly worries me here."
                    },
                    {
                        "username": "bparanj",
                        "content": "From what I can see, your implementation of binary search seems to have an infinite loop issue when the target is not present in the array. This happens because you are updating your `s` and `l` pointers to `m` without checking if `m` can make `s` or `l` to move.\\n\\nLet\\'s look at the case when `s` and `l` are consecutive numbers. If `nums[s] <= nums[m]` is true and `target` is not in the range of `nums[s]` to `nums[m]`, `s` will be updated to `m`. However, if `m` is equal to `s` (which is possible when `s` and `l` are consecutive), `s` will not move. This will cause an infinite loop, as `s` and `l` will not change. The same problem can occur with `l`.\\n\\nA standard binary search implementation makes sure that `s` or `l` always changes:\\n\\n```cpp\\nclass Solution {\\npublic:\\n    int search(vector<int>& nums, int target) {\\n        int s = 0;\\n        int l = nums.size();\\n        while (s < l) {\\n            int m = s + (l - s) / 2;\\n            if (nums[m] == target) {\\n                return m;\\n            } else if (nums[s] <= nums[m]) {\\n                if (target >= nums[s] && target < nums[m]) {\\n                    l = m;\\n                } else {\\n                    s = m + 1;\\n                }\\n            } else {\\n                if (target > nums[m] && target <= nums[l-1]) {\\n                    s = m + 1;\\n                } else {\\n                    l = m;\\n                }\\n            }\\n        }\\n        return -1;\\n    }\\n};\\n```\\n\\nIn this code, if the target is not found, `s` or `l` will be updated such that it either increments or decrements. This way, the function is guaranteed to exit."
                    },
                    {
                        "username": "saambpatil",
                        "content": "#define endl \\'\\\\n\\'\\n// #define int long long\\n#define pb push_back\\n#define FAST                 \\\\\\n    ios::sync_with_stdio(0); \\\\\\n    cin.tie(0);              \\\\\\n    cout.tie(0);\\n#define ppb pop_back\\n#define lld long double\\n#define all(a) a.begin(), a.end()\\n#define vi vector<int>\\n#define vs vector<string>\\n#define vb vector<bool>\\n#define vvi vector<vector<int>>\\n// #define sz(a) a.size()\\n#define rep(i, a, n) for (int i = a; i < n; i++)\\n\\nclass Solution {\\npublic:\\n    \\n\\n    int binary2(vi arr, int pivotindex, int n, int target)\\n{\\n    int low = pivotindex + 1;\\n    int high = n - 1;\\n\\n    while (high >= low)\\n    {\\n        int mid = low + (high - low) / 2;\\n        if (arr[mid] == target)\\n        {\\n            return mid;\\n        }\\n        else if (arr[mid] > target)\\n        {\\n            high = mid - 1;\\n        }\\n        else\\n        {\\n            low = mid + 1;\\n        }\\n    }\\n    return -1;\\n}\\n\\nint binary1(vi arr, int pivotindex, int n, int target)\\n{\\n    int high = pivotindex;\\n    int low = n - 1;\\n\\n    while (high >= low)\\n    {\\n        int mid = low + (high - low) / 2;\\n        if (arr[mid] == target)\\n        {\\n            return mid;\\n        }\\n        else if (arr[mid] > target)\\n        {\\n            high = mid - 1;\\n        }\\n        else\\n        {\\n            low = mid + 1;\\n        }\\n    }\\n    return -1;\\n}\\n\\n    int pivot(vi arr, int n)\\n{\\n    int low = 0;\\n    int high = n - 1;\\n    while (low <= high)\\n    {\\n        int mid = low + (high - low) / 2;\\n        if (arr[mid] <= arr[n - 1])\\n        {\\n            // We are in part 2 of the array\\n            high = mid - 1;\\n        }\\n        else // We are in part 1 of the array\\n        {\\n            // We are on the pivot element\\n            if (arr[mid] > arr[mid + 1] && arr[mid] > arr[mid - 1])\\n            {\\n                return mid;\\n            }\\n            // We are not on pivot element\\n            else\\n            {\\n                low = mid + 1;\\n            }\\n        }\\n    }\\n    return 0;\\n\\n}\\n\\n    int search(vector<int>& numbers, int target) {\\n        int n = numbers.size();\\n        int pivotindex = pivot(numbers, n);\\n        int index;\\n         if (target <= numbers[n - 1])\\n        {\\n            index = binary2(numbers, pivotindex, n, target);\\n        }\\n        else if (target > numbers[n - 1])\\n        {\\n            index = binary1(numbers, pivotindex, n, target);\\n        }\\n        return index;\\n    }\\n};\\n\\nI am getting proper result when i run the code but getting runtime error while submitting pls correct the code and point out the mistake"
                    },
                    {
                        "username": "bparanj",
                        "content": "The runtime error may be due to an \"array index out of bounds\" issue. In the pivot function, you\\'re comparing `arr[mid]` with `arr[mid + 1]` and `arr[mid - 1]` without checking if `mid + 1` and `mid - 1` are valid indices. If `mid` happens to be 0 or `n - 1`, it will result in an out-of-bounds error. \\n\\nAlso, note that in `binary1()` function, you\\'ve set `low` to `n - 1` and `high` to `pivotindex`, which might be causing a logical error because `low` should be less than `high` in a standard binary search.\\n\\nHere is the corrected version of your code:\\n\\n```cpp\\nclass Solution {\\npublic:\\n    int binary2(vector<int>& arr, int pivotindex, int n, int target) {\\n        int low = pivotindex + 1;\\n        int high = n - 1;\\n\\n        while (high >= low) {\\n            int mid = low + (high - low) / 2;\\n            if (arr[mid] == target) {\\n                return mid;\\n            }\\n            else if (arr[mid] > target) {\\n                high = mid - 1;\\n            }\\n            else {\\n                low = mid + 1;\\n            }\\n        }\\n        return -1;\\n    }\\n\\n    int binary1(vector<int>& arr, int pivotindex, int n, int target) {\\n        int low = 0;\\n        int high = pivotindex;\\n\\n        while (high >= low) {\\n            int mid = low + (high - low) / 2;\\n            if (arr[mid] == target) {\\n                return mid;\\n            }\\n            else if (arr[mid] > target) {\\n                high = mid - 1;\\n            }\\n            else {\\n                low = mid + 1;\\n            }\\n        }\\n        return -1;\\n    }\\n\\n    int pivot(vector<int>& arr, int n) {\\n        int low = 0;\\n        int high = n - 1;\\n        while (low <= high) {\\n            int mid = low + (high - low) / 2;\\n            if (arr[mid] <= arr[n - 1]) {\\n                high = mid - 1;\\n            }\\n            else {\\n                if (mid > 0 && mid < n - 1 && arr[mid] > arr[mid + 1] && arr[mid] > arr[mid - 1]) {\\n                    return mid;\\n                }\\n                else {\\n                    low = mid + 1;\\n                }\\n            }\\n        }\\n        return 0;\\n    }\\n\\n    int search(vector<int>& numbers, int target) {\\n        int n = numbers.size();\\n        int pivotindex = pivot(numbers, n);\\n        int index;\\n        if (target <= numbers[n - 1]) {\\n            index = binary2(numbers, pivotindex, n, target);\\n        }\\n        else if (target > numbers[n - 1]) {\\n            index = binary1(numbers, pivotindex, n, target);\\n        }\\n        return index;\\n    }\\n};\\n```\\nThis code should fix the runtime error you\\'re encountering. Please test it out on different test cases to ensure that it\\'s working as expected."
                    },
                    {
                        "username": "amangupta9255",
                        "content": "The problem has two important keywords, \"Search\" and \"Sorted\". This gives us the idea of using binary search in this problem. Since the array is rotated, so the idea is to check that which protion of array is sorted. First we check that portion of array and then we check if the target lies in the sorted portion of array or not. This process is repeated, if target element is not present in array we return -1."
                    },
                    {
                        "username": "Kaushh",
                        "content": "\\uD83D\\uDE02\\uD83D\\uDE02linear search gives 100% while Binary Search only 46%."
                    },
                    {
                        "username": "viraat0700",
                        "content": "we only have to write code for the function right . We do not have to write the main function?\\n"
                    },
                    {
                        "username": "Honey_19",
                        "content": "It should be in easy \\n"
                    },
                    {
                        "username": "user5369RY",
                        "content": "[3,5,1] the target is 3 why not  1?   for all cases if the list was rotated then the most right element is smaller than the middle then the index of most right is the target or in the mid equal to target then it is he target why in this case such logic did not work?"
                    },
                    {
                        "username": "bparanj",
                        "content": "Your logic assumes that the target is always the pivot (the smallest element in the rotated array) or the middle element. However, the problem statement says that the target could be any number in the array, not necessarily the pivot or the middle. \\n\\nIn your example [3,5,1], the target could be 3, 5, or 1. If the target is 3, then the expected output is 0 because 3 is at index 0. If the target is 5, then the expected output is 1 because 5 is at index 1. If the target is 1, then the expected output is 2 because 1 is at index 2.\\n\\nSo, the key to solving this problem is not to find the pivot or the middle, but to find the target. This requires modifying the binary search to handle the rotation."
                    },
                    {
                        "username": "mohitjangid14101",
                        "content": "class Solution {\\npublic:\\n    int binarySearch(vector<int>arr,int target,int s,int e){\\n        while(s<=e){\\n            int mid=s+(e-s)/2;\\n            if(arr[mid]==target){\\n                return mid;\\n            }\\n            else if(arr[mid]>target){\\n                e=mid-1;\\n            }\\n            else{\\n                s=mid+1;\\n            }\\n        }\\n        return -1;\\n    }\\n    int findPivot(vector<int>arr){\\n        int s=0;\\n        int e=arr.size()-1;\\n        int mid=s+(e-s)/2;\\n        while(s<e){\\n            \\n            if(mid+1<arr.size() && arr[mid]>arr[mid+1]){\\n                return mid;\\n            }\\n            if(mid-1>=0 && arr[mid-1]>arr[mid]){\\n                return mid-1;\\n            }\\n            if(arr[s]>=arr[mid]){  \\n                e=mid-1;\\n            }\\n            else{\\n                s=mid;\\n                \\n            }\\n            mid=s+(e-s)/2;\\n        }\\n    return s;\\n    }\\n    int search(vector<int>& arr, int target) {\\n        int pivot=findPivot(arr);\\n        if(target>=arr[0] && target<=arr[pivot]){\\n            int ans=binarySearch(arr,target,0,pivot);\\n            return ans;\\n        }\\n        if( pivot+1<arr.size() && target>=arr[pivot+1] &&         target<=arr[arr.size()-1] ){\\n            int ans=binarySearch(arr,target,pivot+1,arr.size()-1);\\n            return ans;\\n        }\\n        return -1;\\n    }\\n};"
                    }
                ]
            },
            {
                "id": 1936050,
                "content": [
                    {
                        "username": "mkathi",
                        "content": "can this be solved by using a map structure by storing element as key and index as value....? "
                    },
                    {
                        "username": "bparanj",
                        "content": "Yes, it\\'s possible to solve this problem using a map data structure where the key is the element and the value is its index. This approach involves iterating over the entire array once to populate the map, and then you can find the target in constant time.\\n\\nHere\\'s a basic outline of this approach in Python:\\n\\n```python\\ndef search(nums, target):\\n    num_to_index = {num: idx for idx, num in enumerate(nums)}\\n    return num_to_index.get(target, -1)\\n```\\n\\nHowever, there are a few points to consider:\\n\\n1. **Time complexity**: This approach has a time complexity of O(n) due to the initial iteration over the array, which is less efficient than the binary search approach that has a time complexity of O(log n).\\n\\n2. **Space complexity**: This approach requires O(n) additional space to store the map, whereas the binary search approach only requires O(1) space.\\n\\n3. **Unnecessary work**: This approach involves examining every element in the array, even though the array is sorted (or almost sorted, given the rotation). In many cases, the target could be found without having to look at every element.\\n\\nTherefore, while it\\'s possible to use a map to solve this problem, it\\'s not the most efficient solution. The binary search approach takes advantage of the sorted nature of the array and is generally a better choice for this problem."
                    },
                    {
                        "username": "mkathi",
                        "content": "i think if i use a map here , i\\'ll find the solution faster just by storing element as key and index as value ..... what do you say guys?"
                    },
                    {
                        "username": "rohiinegi2002",
                        "content": "may be yes..but then the space complexity will increase \\n"
                    },
                    {
                        "username": "amanpandey2000",
                        "content": "What's wrong with leetcode ? Why is not exiting the while loop when s==l?\nBelow is my solution. Can someone tell me if this is issue with leetcode runtime? \nI am able to run the code successfully in some other online editor,\n\nclass Solution {\npublic:\n    int search(vector<int>& nums, int target) {\n        int s = 0;\n        int l = nums.size() -1;\n        while(s<l)\n        {\n            cout<<s<<\" \"<<l<<\"\\n\";\n            int m =s+l;\n            if(m%2==0)\n            m = m/2;\n            else m = (m-1)/2;\n            \n            if(nums[m] == target)\n            {\n                cout<< \"*\"<<m<<\"*  \";\n                s = m;\n                l = m;\n            }\n            else if(nums[s]<=nums[m])\n            {\n                if(target>=nums[s] && target<=nums[m]) l = m;\n                else s = m;\n            }\n            else\n            {\n                if(target>=nums[m] && target<=nums[l]) s = m;\n                else l=m;\n            }\n            if(s==l)\n            {\n                cout<<\"BREAK\";\n                break;\n            }\n            cout<<s<<\" \"<<l<<\"\\n\";\n        }\n        if(nums[s] == target) return s;\n        else return -1;\n    }\n};"
                    },
                    {
                        "username": "amanpandey2000",
                        "content": "[@bparanj](/bparanj)  thanks for looking into it. Agreed that my solution has this flaw.\\n\\nBut still the thing that the first test case should exit properly worries me. In some other compiler it is working fine, but if I run this solution in leetcode, it is behaving wierdly as the statement which I have printed cout<<:BREAK\" is getting executed but in the next line the break statement should exit the while loop. But it is not happening which mainly worries me here."
                    },
                    {
                        "username": "bparanj",
                        "content": "From what I can see, your implementation of binary search seems to have an infinite loop issue when the target is not present in the array. This happens because you are updating your `s` and `l` pointers to `m` without checking if `m` can make `s` or `l` to move.\\n\\nLet\\'s look at the case when `s` and `l` are consecutive numbers. If `nums[s] <= nums[m]` is true and `target` is not in the range of `nums[s]` to `nums[m]`, `s` will be updated to `m`. However, if `m` is equal to `s` (which is possible when `s` and `l` are consecutive), `s` will not move. This will cause an infinite loop, as `s` and `l` will not change. The same problem can occur with `l`.\\n\\nA standard binary search implementation makes sure that `s` or `l` always changes:\\n\\n```cpp\\nclass Solution {\\npublic:\\n    int search(vector<int>& nums, int target) {\\n        int s = 0;\\n        int l = nums.size();\\n        while (s < l) {\\n            int m = s + (l - s) / 2;\\n            if (nums[m] == target) {\\n                return m;\\n            } else if (nums[s] <= nums[m]) {\\n                if (target >= nums[s] && target < nums[m]) {\\n                    l = m;\\n                } else {\\n                    s = m + 1;\\n                }\\n            } else {\\n                if (target > nums[m] && target <= nums[l-1]) {\\n                    s = m + 1;\\n                } else {\\n                    l = m;\\n                }\\n            }\\n        }\\n        return -1;\\n    }\\n};\\n```\\n\\nIn this code, if the target is not found, `s` or `l` will be updated such that it either increments or decrements. This way, the function is guaranteed to exit."
                    },
                    {
                        "username": "saambpatil",
                        "content": "#define endl \\'\\\\n\\'\\n// #define int long long\\n#define pb push_back\\n#define FAST                 \\\\\\n    ios::sync_with_stdio(0); \\\\\\n    cin.tie(0);              \\\\\\n    cout.tie(0);\\n#define ppb pop_back\\n#define lld long double\\n#define all(a) a.begin(), a.end()\\n#define vi vector<int>\\n#define vs vector<string>\\n#define vb vector<bool>\\n#define vvi vector<vector<int>>\\n// #define sz(a) a.size()\\n#define rep(i, a, n) for (int i = a; i < n; i++)\\n\\nclass Solution {\\npublic:\\n    \\n\\n    int binary2(vi arr, int pivotindex, int n, int target)\\n{\\n    int low = pivotindex + 1;\\n    int high = n - 1;\\n\\n    while (high >= low)\\n    {\\n        int mid = low + (high - low) / 2;\\n        if (arr[mid] == target)\\n        {\\n            return mid;\\n        }\\n        else if (arr[mid] > target)\\n        {\\n            high = mid - 1;\\n        }\\n        else\\n        {\\n            low = mid + 1;\\n        }\\n    }\\n    return -1;\\n}\\n\\nint binary1(vi arr, int pivotindex, int n, int target)\\n{\\n    int high = pivotindex;\\n    int low = n - 1;\\n\\n    while (high >= low)\\n    {\\n        int mid = low + (high - low) / 2;\\n        if (arr[mid] == target)\\n        {\\n            return mid;\\n        }\\n        else if (arr[mid] > target)\\n        {\\n            high = mid - 1;\\n        }\\n        else\\n        {\\n            low = mid + 1;\\n        }\\n    }\\n    return -1;\\n}\\n\\n    int pivot(vi arr, int n)\\n{\\n    int low = 0;\\n    int high = n - 1;\\n    while (low <= high)\\n    {\\n        int mid = low + (high - low) / 2;\\n        if (arr[mid] <= arr[n - 1])\\n        {\\n            // We are in part 2 of the array\\n            high = mid - 1;\\n        }\\n        else // We are in part 1 of the array\\n        {\\n            // We are on the pivot element\\n            if (arr[mid] > arr[mid + 1] && arr[mid] > arr[mid - 1])\\n            {\\n                return mid;\\n            }\\n            // We are not on pivot element\\n            else\\n            {\\n                low = mid + 1;\\n            }\\n        }\\n    }\\n    return 0;\\n\\n}\\n\\n    int search(vector<int>& numbers, int target) {\\n        int n = numbers.size();\\n        int pivotindex = pivot(numbers, n);\\n        int index;\\n         if (target <= numbers[n - 1])\\n        {\\n            index = binary2(numbers, pivotindex, n, target);\\n        }\\n        else if (target > numbers[n - 1])\\n        {\\n            index = binary1(numbers, pivotindex, n, target);\\n        }\\n        return index;\\n    }\\n};\\n\\nI am getting proper result when i run the code but getting runtime error while submitting pls correct the code and point out the mistake"
                    },
                    {
                        "username": "bparanj",
                        "content": "The runtime error may be due to an \"array index out of bounds\" issue. In the pivot function, you\\'re comparing `arr[mid]` with `arr[mid + 1]` and `arr[mid - 1]` without checking if `mid + 1` and `mid - 1` are valid indices. If `mid` happens to be 0 or `n - 1`, it will result in an out-of-bounds error. \\n\\nAlso, note that in `binary1()` function, you\\'ve set `low` to `n - 1` and `high` to `pivotindex`, which might be causing a logical error because `low` should be less than `high` in a standard binary search.\\n\\nHere is the corrected version of your code:\\n\\n```cpp\\nclass Solution {\\npublic:\\n    int binary2(vector<int>& arr, int pivotindex, int n, int target) {\\n        int low = pivotindex + 1;\\n        int high = n - 1;\\n\\n        while (high >= low) {\\n            int mid = low + (high - low) / 2;\\n            if (arr[mid] == target) {\\n                return mid;\\n            }\\n            else if (arr[mid] > target) {\\n                high = mid - 1;\\n            }\\n            else {\\n                low = mid + 1;\\n            }\\n        }\\n        return -1;\\n    }\\n\\n    int binary1(vector<int>& arr, int pivotindex, int n, int target) {\\n        int low = 0;\\n        int high = pivotindex;\\n\\n        while (high >= low) {\\n            int mid = low + (high - low) / 2;\\n            if (arr[mid] == target) {\\n                return mid;\\n            }\\n            else if (arr[mid] > target) {\\n                high = mid - 1;\\n            }\\n            else {\\n                low = mid + 1;\\n            }\\n        }\\n        return -1;\\n    }\\n\\n    int pivot(vector<int>& arr, int n) {\\n        int low = 0;\\n        int high = n - 1;\\n        while (low <= high) {\\n            int mid = low + (high - low) / 2;\\n            if (arr[mid] <= arr[n - 1]) {\\n                high = mid - 1;\\n            }\\n            else {\\n                if (mid > 0 && mid < n - 1 && arr[mid] > arr[mid + 1] && arr[mid] > arr[mid - 1]) {\\n                    return mid;\\n                }\\n                else {\\n                    low = mid + 1;\\n                }\\n            }\\n        }\\n        return 0;\\n    }\\n\\n    int search(vector<int>& numbers, int target) {\\n        int n = numbers.size();\\n        int pivotindex = pivot(numbers, n);\\n        int index;\\n        if (target <= numbers[n - 1]) {\\n            index = binary2(numbers, pivotindex, n, target);\\n        }\\n        else if (target > numbers[n - 1]) {\\n            index = binary1(numbers, pivotindex, n, target);\\n        }\\n        return index;\\n    }\\n};\\n```\\nThis code should fix the runtime error you\\'re encountering. Please test it out on different test cases to ensure that it\\'s working as expected."
                    },
                    {
                        "username": "amangupta9255",
                        "content": "The problem has two important keywords, \"Search\" and \"Sorted\". This gives us the idea of using binary search in this problem. Since the array is rotated, so the idea is to check that which protion of array is sorted. First we check that portion of array and then we check if the target lies in the sorted portion of array or not. This process is repeated, if target element is not present in array we return -1."
                    },
                    {
                        "username": "Kaushh",
                        "content": "\\uD83D\\uDE02\\uD83D\\uDE02linear search gives 100% while Binary Search only 46%."
                    },
                    {
                        "username": "viraat0700",
                        "content": "we only have to write code for the function right . We do not have to write the main function?\\n"
                    },
                    {
                        "username": "Honey_19",
                        "content": "It should be in easy \\n"
                    },
                    {
                        "username": "user5369RY",
                        "content": "[3,5,1] the target is 3 why not  1?   for all cases if the list was rotated then the most right element is smaller than the middle then the index of most right is the target or in the mid equal to target then it is he target why in this case such logic did not work?"
                    },
                    {
                        "username": "bparanj",
                        "content": "Your logic assumes that the target is always the pivot (the smallest element in the rotated array) or the middle element. However, the problem statement says that the target could be any number in the array, not necessarily the pivot or the middle. \\n\\nIn your example [3,5,1], the target could be 3, 5, or 1. If the target is 3, then the expected output is 0 because 3 is at index 0. If the target is 5, then the expected output is 1 because 5 is at index 1. If the target is 1, then the expected output is 2 because 1 is at index 2.\\n\\nSo, the key to solving this problem is not to find the pivot or the middle, but to find the target. This requires modifying the binary search to handle the rotation."
                    },
                    {
                        "username": "mohitjangid14101",
                        "content": "class Solution {\\npublic:\\n    int binarySearch(vector<int>arr,int target,int s,int e){\\n        while(s<=e){\\n            int mid=s+(e-s)/2;\\n            if(arr[mid]==target){\\n                return mid;\\n            }\\n            else if(arr[mid]>target){\\n                e=mid-1;\\n            }\\n            else{\\n                s=mid+1;\\n            }\\n        }\\n        return -1;\\n    }\\n    int findPivot(vector<int>arr){\\n        int s=0;\\n        int e=arr.size()-1;\\n        int mid=s+(e-s)/2;\\n        while(s<e){\\n            \\n            if(mid+1<arr.size() && arr[mid]>arr[mid+1]){\\n                return mid;\\n            }\\n            if(mid-1>=0 && arr[mid-1]>arr[mid]){\\n                return mid-1;\\n            }\\n            if(arr[s]>=arr[mid]){  \\n                e=mid-1;\\n            }\\n            else{\\n                s=mid;\\n                \\n            }\\n            mid=s+(e-s)/2;\\n        }\\n    return s;\\n    }\\n    int search(vector<int>& arr, int target) {\\n        int pivot=findPivot(arr);\\n        if(target>=arr[0] && target<=arr[pivot]){\\n            int ans=binarySearch(arr,target,0,pivot);\\n            return ans;\\n        }\\n        if( pivot+1<arr.size() && target>=arr[pivot+1] &&         target<=arr[arr.size()-1] ){\\n            int ans=binarySearch(arr,target,pivot+1,arr.size()-1);\\n            return ans;\\n        }\\n        return -1;\\n    }\\n};"
                    }
                ]
            },
            {
                "id": 1899510,
                "content": [
                    {
                        "username": "mkathi",
                        "content": "can this be solved by using a map structure by storing element as key and index as value....? "
                    },
                    {
                        "username": "bparanj",
                        "content": "Yes, it\\'s possible to solve this problem using a map data structure where the key is the element and the value is its index. This approach involves iterating over the entire array once to populate the map, and then you can find the target in constant time.\\n\\nHere\\'s a basic outline of this approach in Python:\\n\\n```python\\ndef search(nums, target):\\n    num_to_index = {num: idx for idx, num in enumerate(nums)}\\n    return num_to_index.get(target, -1)\\n```\\n\\nHowever, there are a few points to consider:\\n\\n1. **Time complexity**: This approach has a time complexity of O(n) due to the initial iteration over the array, which is less efficient than the binary search approach that has a time complexity of O(log n).\\n\\n2. **Space complexity**: This approach requires O(n) additional space to store the map, whereas the binary search approach only requires O(1) space.\\n\\n3. **Unnecessary work**: This approach involves examining every element in the array, even though the array is sorted (or almost sorted, given the rotation). In many cases, the target could be found without having to look at every element.\\n\\nTherefore, while it\\'s possible to use a map to solve this problem, it\\'s not the most efficient solution. The binary search approach takes advantage of the sorted nature of the array and is generally a better choice for this problem."
                    },
                    {
                        "username": "mkathi",
                        "content": "i think if i use a map here , i\\'ll find the solution faster just by storing element as key and index as value ..... what do you say guys?"
                    },
                    {
                        "username": "rohiinegi2002",
                        "content": "may be yes..but then the space complexity will increase \\n"
                    },
                    {
                        "username": "amanpandey2000",
                        "content": "What's wrong with leetcode ? Why is not exiting the while loop when s==l?\nBelow is my solution. Can someone tell me if this is issue with leetcode runtime? \nI am able to run the code successfully in some other online editor,\n\nclass Solution {\npublic:\n    int search(vector<int>& nums, int target) {\n        int s = 0;\n        int l = nums.size() -1;\n        while(s<l)\n        {\n            cout<<s<<\" \"<<l<<\"\\n\";\n            int m =s+l;\n            if(m%2==0)\n            m = m/2;\n            else m = (m-1)/2;\n            \n            if(nums[m] == target)\n            {\n                cout<< \"*\"<<m<<\"*  \";\n                s = m;\n                l = m;\n            }\n            else if(nums[s]<=nums[m])\n            {\n                if(target>=nums[s] && target<=nums[m]) l = m;\n                else s = m;\n            }\n            else\n            {\n                if(target>=nums[m] && target<=nums[l]) s = m;\n                else l=m;\n            }\n            if(s==l)\n            {\n                cout<<\"BREAK\";\n                break;\n            }\n            cout<<s<<\" \"<<l<<\"\\n\";\n        }\n        if(nums[s] == target) return s;\n        else return -1;\n    }\n};"
                    },
                    {
                        "username": "amanpandey2000",
                        "content": "[@bparanj](/bparanj)  thanks for looking into it. Agreed that my solution has this flaw.\\n\\nBut still the thing that the first test case should exit properly worries me. In some other compiler it is working fine, but if I run this solution in leetcode, it is behaving wierdly as the statement which I have printed cout<<:BREAK\" is getting executed but in the next line the break statement should exit the while loop. But it is not happening which mainly worries me here."
                    },
                    {
                        "username": "bparanj",
                        "content": "From what I can see, your implementation of binary search seems to have an infinite loop issue when the target is not present in the array. This happens because you are updating your `s` and `l` pointers to `m` without checking if `m` can make `s` or `l` to move.\\n\\nLet\\'s look at the case when `s` and `l` are consecutive numbers. If `nums[s] <= nums[m]` is true and `target` is not in the range of `nums[s]` to `nums[m]`, `s` will be updated to `m`. However, if `m` is equal to `s` (which is possible when `s` and `l` are consecutive), `s` will not move. This will cause an infinite loop, as `s` and `l` will not change. The same problem can occur with `l`.\\n\\nA standard binary search implementation makes sure that `s` or `l` always changes:\\n\\n```cpp\\nclass Solution {\\npublic:\\n    int search(vector<int>& nums, int target) {\\n        int s = 0;\\n        int l = nums.size();\\n        while (s < l) {\\n            int m = s + (l - s) / 2;\\n            if (nums[m] == target) {\\n                return m;\\n            } else if (nums[s] <= nums[m]) {\\n                if (target >= nums[s] && target < nums[m]) {\\n                    l = m;\\n                } else {\\n                    s = m + 1;\\n                }\\n            } else {\\n                if (target > nums[m] && target <= nums[l-1]) {\\n                    s = m + 1;\\n                } else {\\n                    l = m;\\n                }\\n            }\\n        }\\n        return -1;\\n    }\\n};\\n```\\n\\nIn this code, if the target is not found, `s` or `l` will be updated such that it either increments or decrements. This way, the function is guaranteed to exit."
                    },
                    {
                        "username": "saambpatil",
                        "content": "#define endl \\'\\\\n\\'\\n// #define int long long\\n#define pb push_back\\n#define FAST                 \\\\\\n    ios::sync_with_stdio(0); \\\\\\n    cin.tie(0);              \\\\\\n    cout.tie(0);\\n#define ppb pop_back\\n#define lld long double\\n#define all(a) a.begin(), a.end()\\n#define vi vector<int>\\n#define vs vector<string>\\n#define vb vector<bool>\\n#define vvi vector<vector<int>>\\n// #define sz(a) a.size()\\n#define rep(i, a, n) for (int i = a; i < n; i++)\\n\\nclass Solution {\\npublic:\\n    \\n\\n    int binary2(vi arr, int pivotindex, int n, int target)\\n{\\n    int low = pivotindex + 1;\\n    int high = n - 1;\\n\\n    while (high >= low)\\n    {\\n        int mid = low + (high - low) / 2;\\n        if (arr[mid] == target)\\n        {\\n            return mid;\\n        }\\n        else if (arr[mid] > target)\\n        {\\n            high = mid - 1;\\n        }\\n        else\\n        {\\n            low = mid + 1;\\n        }\\n    }\\n    return -1;\\n}\\n\\nint binary1(vi arr, int pivotindex, int n, int target)\\n{\\n    int high = pivotindex;\\n    int low = n - 1;\\n\\n    while (high >= low)\\n    {\\n        int mid = low + (high - low) / 2;\\n        if (arr[mid] == target)\\n        {\\n            return mid;\\n        }\\n        else if (arr[mid] > target)\\n        {\\n            high = mid - 1;\\n        }\\n        else\\n        {\\n            low = mid + 1;\\n        }\\n    }\\n    return -1;\\n}\\n\\n    int pivot(vi arr, int n)\\n{\\n    int low = 0;\\n    int high = n - 1;\\n    while (low <= high)\\n    {\\n        int mid = low + (high - low) / 2;\\n        if (arr[mid] <= arr[n - 1])\\n        {\\n            // We are in part 2 of the array\\n            high = mid - 1;\\n        }\\n        else // We are in part 1 of the array\\n        {\\n            // We are on the pivot element\\n            if (arr[mid] > arr[mid + 1] && arr[mid] > arr[mid - 1])\\n            {\\n                return mid;\\n            }\\n            // We are not on pivot element\\n            else\\n            {\\n                low = mid + 1;\\n            }\\n        }\\n    }\\n    return 0;\\n\\n}\\n\\n    int search(vector<int>& numbers, int target) {\\n        int n = numbers.size();\\n        int pivotindex = pivot(numbers, n);\\n        int index;\\n         if (target <= numbers[n - 1])\\n        {\\n            index = binary2(numbers, pivotindex, n, target);\\n        }\\n        else if (target > numbers[n - 1])\\n        {\\n            index = binary1(numbers, pivotindex, n, target);\\n        }\\n        return index;\\n    }\\n};\\n\\nI am getting proper result when i run the code but getting runtime error while submitting pls correct the code and point out the mistake"
                    },
                    {
                        "username": "bparanj",
                        "content": "The runtime error may be due to an \"array index out of bounds\" issue. In the pivot function, you\\'re comparing `arr[mid]` with `arr[mid + 1]` and `arr[mid - 1]` without checking if `mid + 1` and `mid - 1` are valid indices. If `mid` happens to be 0 or `n - 1`, it will result in an out-of-bounds error. \\n\\nAlso, note that in `binary1()` function, you\\'ve set `low` to `n - 1` and `high` to `pivotindex`, which might be causing a logical error because `low` should be less than `high` in a standard binary search.\\n\\nHere is the corrected version of your code:\\n\\n```cpp\\nclass Solution {\\npublic:\\n    int binary2(vector<int>& arr, int pivotindex, int n, int target) {\\n        int low = pivotindex + 1;\\n        int high = n - 1;\\n\\n        while (high >= low) {\\n            int mid = low + (high - low) / 2;\\n            if (arr[mid] == target) {\\n                return mid;\\n            }\\n            else if (arr[mid] > target) {\\n                high = mid - 1;\\n            }\\n            else {\\n                low = mid + 1;\\n            }\\n        }\\n        return -1;\\n    }\\n\\n    int binary1(vector<int>& arr, int pivotindex, int n, int target) {\\n        int low = 0;\\n        int high = pivotindex;\\n\\n        while (high >= low) {\\n            int mid = low + (high - low) / 2;\\n            if (arr[mid] == target) {\\n                return mid;\\n            }\\n            else if (arr[mid] > target) {\\n                high = mid - 1;\\n            }\\n            else {\\n                low = mid + 1;\\n            }\\n        }\\n        return -1;\\n    }\\n\\n    int pivot(vector<int>& arr, int n) {\\n        int low = 0;\\n        int high = n - 1;\\n        while (low <= high) {\\n            int mid = low + (high - low) / 2;\\n            if (arr[mid] <= arr[n - 1]) {\\n                high = mid - 1;\\n            }\\n            else {\\n                if (mid > 0 && mid < n - 1 && arr[mid] > arr[mid + 1] && arr[mid] > arr[mid - 1]) {\\n                    return mid;\\n                }\\n                else {\\n                    low = mid + 1;\\n                }\\n            }\\n        }\\n        return 0;\\n    }\\n\\n    int search(vector<int>& numbers, int target) {\\n        int n = numbers.size();\\n        int pivotindex = pivot(numbers, n);\\n        int index;\\n        if (target <= numbers[n - 1]) {\\n            index = binary2(numbers, pivotindex, n, target);\\n        }\\n        else if (target > numbers[n - 1]) {\\n            index = binary1(numbers, pivotindex, n, target);\\n        }\\n        return index;\\n    }\\n};\\n```\\nThis code should fix the runtime error you\\'re encountering. Please test it out on different test cases to ensure that it\\'s working as expected."
                    },
                    {
                        "username": "amangupta9255",
                        "content": "The problem has two important keywords, \"Search\" and \"Sorted\". This gives us the idea of using binary search in this problem. Since the array is rotated, so the idea is to check that which protion of array is sorted. First we check that portion of array and then we check if the target lies in the sorted portion of array or not. This process is repeated, if target element is not present in array we return -1."
                    },
                    {
                        "username": "Kaushh",
                        "content": "\\uD83D\\uDE02\\uD83D\\uDE02linear search gives 100% while Binary Search only 46%."
                    },
                    {
                        "username": "viraat0700",
                        "content": "we only have to write code for the function right . We do not have to write the main function?\\n"
                    },
                    {
                        "username": "Honey_19",
                        "content": "It should be in easy \\n"
                    },
                    {
                        "username": "user5369RY",
                        "content": "[3,5,1] the target is 3 why not  1?   for all cases if the list was rotated then the most right element is smaller than the middle then the index of most right is the target or in the mid equal to target then it is he target why in this case such logic did not work?"
                    },
                    {
                        "username": "bparanj",
                        "content": "Your logic assumes that the target is always the pivot (the smallest element in the rotated array) or the middle element. However, the problem statement says that the target could be any number in the array, not necessarily the pivot or the middle. \\n\\nIn your example [3,5,1], the target could be 3, 5, or 1. If the target is 3, then the expected output is 0 because 3 is at index 0. If the target is 5, then the expected output is 1 because 5 is at index 1. If the target is 1, then the expected output is 2 because 1 is at index 2.\\n\\nSo, the key to solving this problem is not to find the pivot or the middle, but to find the target. This requires modifying the binary search to handle the rotation."
                    },
                    {
                        "username": "mohitjangid14101",
                        "content": "class Solution {\\npublic:\\n    int binarySearch(vector<int>arr,int target,int s,int e){\\n        while(s<=e){\\n            int mid=s+(e-s)/2;\\n            if(arr[mid]==target){\\n                return mid;\\n            }\\n            else if(arr[mid]>target){\\n                e=mid-1;\\n            }\\n            else{\\n                s=mid+1;\\n            }\\n        }\\n        return -1;\\n    }\\n    int findPivot(vector<int>arr){\\n        int s=0;\\n        int e=arr.size()-1;\\n        int mid=s+(e-s)/2;\\n        while(s<e){\\n            \\n            if(mid+1<arr.size() && arr[mid]>arr[mid+1]){\\n                return mid;\\n            }\\n            if(mid-1>=0 && arr[mid-1]>arr[mid]){\\n                return mid-1;\\n            }\\n            if(arr[s]>=arr[mid]){  \\n                e=mid-1;\\n            }\\n            else{\\n                s=mid;\\n                \\n            }\\n            mid=s+(e-s)/2;\\n        }\\n    return s;\\n    }\\n    int search(vector<int>& arr, int target) {\\n        int pivot=findPivot(arr);\\n        if(target>=arr[0] && target<=arr[pivot]){\\n            int ans=binarySearch(arr,target,0,pivot);\\n            return ans;\\n        }\\n        if( pivot+1<arr.size() && target>=arr[pivot+1] &&         target<=arr[arr.size()-1] ){\\n            int ans=binarySearch(arr,target,pivot+1,arr.size()-1);\\n            return ans;\\n        }\\n        return -1;\\n    }\\n};"
                    }
                ]
            },
            {
                "id": 1890448,
                "content": [
                    {
                        "username": "mkathi",
                        "content": "can this be solved by using a map structure by storing element as key and index as value....? "
                    },
                    {
                        "username": "bparanj",
                        "content": "Yes, it\\'s possible to solve this problem using a map data structure where the key is the element and the value is its index. This approach involves iterating over the entire array once to populate the map, and then you can find the target in constant time.\\n\\nHere\\'s a basic outline of this approach in Python:\\n\\n```python\\ndef search(nums, target):\\n    num_to_index = {num: idx for idx, num in enumerate(nums)}\\n    return num_to_index.get(target, -1)\\n```\\n\\nHowever, there are a few points to consider:\\n\\n1. **Time complexity**: This approach has a time complexity of O(n) due to the initial iteration over the array, which is less efficient than the binary search approach that has a time complexity of O(log n).\\n\\n2. **Space complexity**: This approach requires O(n) additional space to store the map, whereas the binary search approach only requires O(1) space.\\n\\n3. **Unnecessary work**: This approach involves examining every element in the array, even though the array is sorted (or almost sorted, given the rotation). In many cases, the target could be found without having to look at every element.\\n\\nTherefore, while it\\'s possible to use a map to solve this problem, it\\'s not the most efficient solution. The binary search approach takes advantage of the sorted nature of the array and is generally a better choice for this problem."
                    },
                    {
                        "username": "mkathi",
                        "content": "i think if i use a map here , i\\'ll find the solution faster just by storing element as key and index as value ..... what do you say guys?"
                    },
                    {
                        "username": "rohiinegi2002",
                        "content": "may be yes..but then the space complexity will increase \\n"
                    },
                    {
                        "username": "amanpandey2000",
                        "content": "What's wrong with leetcode ? Why is not exiting the while loop when s==l?\nBelow is my solution. Can someone tell me if this is issue with leetcode runtime? \nI am able to run the code successfully in some other online editor,\n\nclass Solution {\npublic:\n    int search(vector<int>& nums, int target) {\n        int s = 0;\n        int l = nums.size() -1;\n        while(s<l)\n        {\n            cout<<s<<\" \"<<l<<\"\\n\";\n            int m =s+l;\n            if(m%2==0)\n            m = m/2;\n            else m = (m-1)/2;\n            \n            if(nums[m] == target)\n            {\n                cout<< \"*\"<<m<<\"*  \";\n                s = m;\n                l = m;\n            }\n            else if(nums[s]<=nums[m])\n            {\n                if(target>=nums[s] && target<=nums[m]) l = m;\n                else s = m;\n            }\n            else\n            {\n                if(target>=nums[m] && target<=nums[l]) s = m;\n                else l=m;\n            }\n            if(s==l)\n            {\n                cout<<\"BREAK\";\n                break;\n            }\n            cout<<s<<\" \"<<l<<\"\\n\";\n        }\n        if(nums[s] == target) return s;\n        else return -1;\n    }\n};"
                    },
                    {
                        "username": "amanpandey2000",
                        "content": "[@bparanj](/bparanj)  thanks for looking into it. Agreed that my solution has this flaw.\\n\\nBut still the thing that the first test case should exit properly worries me. In some other compiler it is working fine, but if I run this solution in leetcode, it is behaving wierdly as the statement which I have printed cout<<:BREAK\" is getting executed but in the next line the break statement should exit the while loop. But it is not happening which mainly worries me here."
                    },
                    {
                        "username": "bparanj",
                        "content": "From what I can see, your implementation of binary search seems to have an infinite loop issue when the target is not present in the array. This happens because you are updating your `s` and `l` pointers to `m` without checking if `m` can make `s` or `l` to move.\\n\\nLet\\'s look at the case when `s` and `l` are consecutive numbers. If `nums[s] <= nums[m]` is true and `target` is not in the range of `nums[s]` to `nums[m]`, `s` will be updated to `m`. However, if `m` is equal to `s` (which is possible when `s` and `l` are consecutive), `s` will not move. This will cause an infinite loop, as `s` and `l` will not change. The same problem can occur with `l`.\\n\\nA standard binary search implementation makes sure that `s` or `l` always changes:\\n\\n```cpp\\nclass Solution {\\npublic:\\n    int search(vector<int>& nums, int target) {\\n        int s = 0;\\n        int l = nums.size();\\n        while (s < l) {\\n            int m = s + (l - s) / 2;\\n            if (nums[m] == target) {\\n                return m;\\n            } else if (nums[s] <= nums[m]) {\\n                if (target >= nums[s] && target < nums[m]) {\\n                    l = m;\\n                } else {\\n                    s = m + 1;\\n                }\\n            } else {\\n                if (target > nums[m] && target <= nums[l-1]) {\\n                    s = m + 1;\\n                } else {\\n                    l = m;\\n                }\\n            }\\n        }\\n        return -1;\\n    }\\n};\\n```\\n\\nIn this code, if the target is not found, `s` or `l` will be updated such that it either increments or decrements. This way, the function is guaranteed to exit."
                    },
                    {
                        "username": "saambpatil",
                        "content": "#define endl \\'\\\\n\\'\\n// #define int long long\\n#define pb push_back\\n#define FAST                 \\\\\\n    ios::sync_with_stdio(0); \\\\\\n    cin.tie(0);              \\\\\\n    cout.tie(0);\\n#define ppb pop_back\\n#define lld long double\\n#define all(a) a.begin(), a.end()\\n#define vi vector<int>\\n#define vs vector<string>\\n#define vb vector<bool>\\n#define vvi vector<vector<int>>\\n// #define sz(a) a.size()\\n#define rep(i, a, n) for (int i = a; i < n; i++)\\n\\nclass Solution {\\npublic:\\n    \\n\\n    int binary2(vi arr, int pivotindex, int n, int target)\\n{\\n    int low = pivotindex + 1;\\n    int high = n - 1;\\n\\n    while (high >= low)\\n    {\\n        int mid = low + (high - low) / 2;\\n        if (arr[mid] == target)\\n        {\\n            return mid;\\n        }\\n        else if (arr[mid] > target)\\n        {\\n            high = mid - 1;\\n        }\\n        else\\n        {\\n            low = mid + 1;\\n        }\\n    }\\n    return -1;\\n}\\n\\nint binary1(vi arr, int pivotindex, int n, int target)\\n{\\n    int high = pivotindex;\\n    int low = n - 1;\\n\\n    while (high >= low)\\n    {\\n        int mid = low + (high - low) / 2;\\n        if (arr[mid] == target)\\n        {\\n            return mid;\\n        }\\n        else if (arr[mid] > target)\\n        {\\n            high = mid - 1;\\n        }\\n        else\\n        {\\n            low = mid + 1;\\n        }\\n    }\\n    return -1;\\n}\\n\\n    int pivot(vi arr, int n)\\n{\\n    int low = 0;\\n    int high = n - 1;\\n    while (low <= high)\\n    {\\n        int mid = low + (high - low) / 2;\\n        if (arr[mid] <= arr[n - 1])\\n        {\\n            // We are in part 2 of the array\\n            high = mid - 1;\\n        }\\n        else // We are in part 1 of the array\\n        {\\n            // We are on the pivot element\\n            if (arr[mid] > arr[mid + 1] && arr[mid] > arr[mid - 1])\\n            {\\n                return mid;\\n            }\\n            // We are not on pivot element\\n            else\\n            {\\n                low = mid + 1;\\n            }\\n        }\\n    }\\n    return 0;\\n\\n}\\n\\n    int search(vector<int>& numbers, int target) {\\n        int n = numbers.size();\\n        int pivotindex = pivot(numbers, n);\\n        int index;\\n         if (target <= numbers[n - 1])\\n        {\\n            index = binary2(numbers, pivotindex, n, target);\\n        }\\n        else if (target > numbers[n - 1])\\n        {\\n            index = binary1(numbers, pivotindex, n, target);\\n        }\\n        return index;\\n    }\\n};\\n\\nI am getting proper result when i run the code but getting runtime error while submitting pls correct the code and point out the mistake"
                    },
                    {
                        "username": "bparanj",
                        "content": "The runtime error may be due to an \"array index out of bounds\" issue. In the pivot function, you\\'re comparing `arr[mid]` with `arr[mid + 1]` and `arr[mid - 1]` without checking if `mid + 1` and `mid - 1` are valid indices. If `mid` happens to be 0 or `n - 1`, it will result in an out-of-bounds error. \\n\\nAlso, note that in `binary1()` function, you\\'ve set `low` to `n - 1` and `high` to `pivotindex`, which might be causing a logical error because `low` should be less than `high` in a standard binary search.\\n\\nHere is the corrected version of your code:\\n\\n```cpp\\nclass Solution {\\npublic:\\n    int binary2(vector<int>& arr, int pivotindex, int n, int target) {\\n        int low = pivotindex + 1;\\n        int high = n - 1;\\n\\n        while (high >= low) {\\n            int mid = low + (high - low) / 2;\\n            if (arr[mid] == target) {\\n                return mid;\\n            }\\n            else if (arr[mid] > target) {\\n                high = mid - 1;\\n            }\\n            else {\\n                low = mid + 1;\\n            }\\n        }\\n        return -1;\\n    }\\n\\n    int binary1(vector<int>& arr, int pivotindex, int n, int target) {\\n        int low = 0;\\n        int high = pivotindex;\\n\\n        while (high >= low) {\\n            int mid = low + (high - low) / 2;\\n            if (arr[mid] == target) {\\n                return mid;\\n            }\\n            else if (arr[mid] > target) {\\n                high = mid - 1;\\n            }\\n            else {\\n                low = mid + 1;\\n            }\\n        }\\n        return -1;\\n    }\\n\\n    int pivot(vector<int>& arr, int n) {\\n        int low = 0;\\n        int high = n - 1;\\n        while (low <= high) {\\n            int mid = low + (high - low) / 2;\\n            if (arr[mid] <= arr[n - 1]) {\\n                high = mid - 1;\\n            }\\n            else {\\n                if (mid > 0 && mid < n - 1 && arr[mid] > arr[mid + 1] && arr[mid] > arr[mid - 1]) {\\n                    return mid;\\n                }\\n                else {\\n                    low = mid + 1;\\n                }\\n            }\\n        }\\n        return 0;\\n    }\\n\\n    int search(vector<int>& numbers, int target) {\\n        int n = numbers.size();\\n        int pivotindex = pivot(numbers, n);\\n        int index;\\n        if (target <= numbers[n - 1]) {\\n            index = binary2(numbers, pivotindex, n, target);\\n        }\\n        else if (target > numbers[n - 1]) {\\n            index = binary1(numbers, pivotindex, n, target);\\n        }\\n        return index;\\n    }\\n};\\n```\\nThis code should fix the runtime error you\\'re encountering. Please test it out on different test cases to ensure that it\\'s working as expected."
                    },
                    {
                        "username": "amangupta9255",
                        "content": "The problem has two important keywords, \"Search\" and \"Sorted\". This gives us the idea of using binary search in this problem. Since the array is rotated, so the idea is to check that which protion of array is sorted. First we check that portion of array and then we check if the target lies in the sorted portion of array or not. This process is repeated, if target element is not present in array we return -1."
                    },
                    {
                        "username": "Kaushh",
                        "content": "\\uD83D\\uDE02\\uD83D\\uDE02linear search gives 100% while Binary Search only 46%."
                    },
                    {
                        "username": "viraat0700",
                        "content": "we only have to write code for the function right . We do not have to write the main function?\\n"
                    },
                    {
                        "username": "Honey_19",
                        "content": "It should be in easy \\n"
                    },
                    {
                        "username": "user5369RY",
                        "content": "[3,5,1] the target is 3 why not  1?   for all cases if the list was rotated then the most right element is smaller than the middle then the index of most right is the target or in the mid equal to target then it is he target why in this case such logic did not work?"
                    },
                    {
                        "username": "bparanj",
                        "content": "Your logic assumes that the target is always the pivot (the smallest element in the rotated array) or the middle element. However, the problem statement says that the target could be any number in the array, not necessarily the pivot or the middle. \\n\\nIn your example [3,5,1], the target could be 3, 5, or 1. If the target is 3, then the expected output is 0 because 3 is at index 0. If the target is 5, then the expected output is 1 because 5 is at index 1. If the target is 1, then the expected output is 2 because 1 is at index 2.\\n\\nSo, the key to solving this problem is not to find the pivot or the middle, but to find the target. This requires modifying the binary search to handle the rotation."
                    },
                    {
                        "username": "mohitjangid14101",
                        "content": "class Solution {\\npublic:\\n    int binarySearch(vector<int>arr,int target,int s,int e){\\n        while(s<=e){\\n            int mid=s+(e-s)/2;\\n            if(arr[mid]==target){\\n                return mid;\\n            }\\n            else if(arr[mid]>target){\\n                e=mid-1;\\n            }\\n            else{\\n                s=mid+1;\\n            }\\n        }\\n        return -1;\\n    }\\n    int findPivot(vector<int>arr){\\n        int s=0;\\n        int e=arr.size()-1;\\n        int mid=s+(e-s)/2;\\n        while(s<e){\\n            \\n            if(mid+1<arr.size() && arr[mid]>arr[mid+1]){\\n                return mid;\\n            }\\n            if(mid-1>=0 && arr[mid-1]>arr[mid]){\\n                return mid-1;\\n            }\\n            if(arr[s]>=arr[mid]){  \\n                e=mid-1;\\n            }\\n            else{\\n                s=mid;\\n                \\n            }\\n            mid=s+(e-s)/2;\\n        }\\n    return s;\\n    }\\n    int search(vector<int>& arr, int target) {\\n        int pivot=findPivot(arr);\\n        if(target>=arr[0] && target<=arr[pivot]){\\n            int ans=binarySearch(arr,target,0,pivot);\\n            return ans;\\n        }\\n        if( pivot+1<arr.size() && target>=arr[pivot+1] &&         target<=arr[arr.size()-1] ){\\n            int ans=binarySearch(arr,target,pivot+1,arr.size()-1);\\n            return ans;\\n        }\\n        return -1;\\n    }\\n};"
                    }
                ]
            },
            {
                "id": 1890107,
                "content": [
                    {
                        "username": "user8104ko",
                        "content": "Can any one tell me how to do this in o(log n)  in java ?"
                    },
                    {
                        "username": "podalakurisuryaprakash",
                        "content": "it is the complexity of binray search\\n"
                    },
                    {
                        "username": "mskamel",
                        "content": "Can someone tell me why this code/solution doesn\\'t work:\\n\\n\\n `class Solution {\\n    public int search(int[] nums, int target) {\\n        int low = 0;\\n        int high = nums.length;\\n        int pivot = 0;\\n\\n        while (low <= high) {\\n            int mid = low + (high - low) / 2;\\n\\n            if (nums[mid - 1] > nums[mid] && nums[mid + 1] > nums[mid]) {\\n                pivot = mid;\\n                break;\\n            }\\n            else if (nums[mid - 1] < nums[mid] && nums[mid + 1] > nums[mid]) {\\n                high = mid - 1;\\n            }\\n            else if (nums[mid - 1] > nums[mid] && nums[mid + 1] < nums[mid]) {\\n                low = mid;\\n            }\\n        }\\n\\n        if (target > pivot) {\\n            low = pivot;\\n            high = nums.length;\\n\\n            while (low <= high) {\\n                int mid = low + (high - low) / 2;\\n                if (nums[mid] == target) {\\n                    return mid;\\n                }\\n                else if (nums[mid] < target) {\\n                    high = mid - 1;\\n                }\\n                else {\\n                    low = mid;\\n                }\\n            }\\n        }\\n        else if (target < pivot) {\\n            low = pivot;\\n            high = 0;\\n\\n            while (high <= low) {\\n                int mid = high + (low - high) / 2;\\n                if (nums[mid] == target) {\\n                    return mid;\\n                }\\n                else if (nums[mid] < target) {\\n                    low = mid - 1;\\n                }\\n                else {\\n                    high = mid;\\n                }\\n            }\\n        }\\n\\n        return -1;\\n    }\\n}`"
                    },
                    {
                        "username": "bparanj",
                        "content": "The code has several issues:\\n\\n1. `int high = nums.length;` - The \\'high\\' variable is initialized to the length of the array, which is out of range. It should be `nums.length - 1`.\\n\\n2. The while loop `while (low <= high)` can result in an ArrayIndexOutOfBoundsException, as you are not checking if \\'mid\\' is at the ends of the array before accessing `nums[mid - 1]` and `nums[mid + 1]`.\\n\\n3. `if (target > pivot)` and `if (target < pivot)`: Here you\\'re comparing the target with the index \\'pivot\\', not with the value of \\'nums[pivot]\\'.\\n\\n4. In the second part of your code, you\\'re doing two binary searches, one for the case where the target is greater than the pivot value and one where it is smaller. However, in both cases, you are not adjusting the mid value correctly in the while loop.\\n\\nHere is a revised version of your code:\\n\\n```java\\nclass Solution {\\n    public int search(int[] nums, int target) {\\n        int low = 0;\\n        int high = nums.length - 1;\\n        int pivot = 0;\\n        \\n        while (low <= high) {\\n            int mid = low + (high - low) / 2;\\n            if (mid > 0 && mid < nums.length - 1 && nums[mid - 1] > nums[mid] && nums[mid + 1] > nums[mid]) {\\n                pivot = mid;\\n                break;\\n            }\\n            else if (nums[mid] > nums[low]) {\\n                low = mid + 1;\\n            }\\n            else {\\n                high = mid - 1;\\n            }\\n        }\\n        \\n        if (nums[pivot] == target) return pivot;\\n\\n        low = 0;\\n        high = nums.length - 1;\\n        \\n        while (low <= high) {\\n            int mid = low + (high - low) / 2;\\n            if (nums[mid] == target) {\\n                return mid;\\n            }\\n            else if (nums[mid] < target) {\\n                low = mid + 1;\\n            }\\n            else {\\n                high = mid - 1;\\n            }\\n        }\\n        return -1;\\n    }\\n}\\n```\\n\\nThis revised code firstly tries to find the pivot using a modified binary search. Then, it does a binary search on the entire array to find the target. This is not the most efficient solution, as the pivot is not utilized, but it corrects the issues in your original code. \\n\\nIn an optimal solution, once the pivot is found, we should do two binary searches: one from 0 to pivot, and another from pivot+1 to nums.length - 1, depending on the value of the target."
                    },
                    {
                        "username": "Raghav_36",
                        "content": "getting heap-buffer-overflow error in this code..can anyone help??\\n\\nint pivot(int arr[], int n)\\n{\\n    int s = 0;\\n    int e = n - 1;\\n    int mid = (s + e) / 2;\\n    while (s < e)\\n    {\\n        if (arr[mid] >= arr[0])\\n        {\\n            s = mid + 1;\\n        }\\n        else\\n        {\\n            e = mid;\\n        }\\n        mid = (s + e) / 2;\\n    }\\n    return s;\\n}\\nint binary(int arr[], int ele, int s, int e)\\n{\\n    int mid = (s + e) / 2;\\n    while (s <= e)\\n    {\\n        if (arr[mid] == ele)\\n        {\\n            return mid;\\n        }\\n        else if (arr[mid] > ele)\\n        {\\n            e = mid - 1;\\n        }\\n        else\\n        {\\n            s = mid + 1;\\n        }\\n        mid = (s + e) / 2;\\n    }\\n    return -1;\\n}\\nint search(int* nums, int numsSize, int target){\\n    int pi = pivot(nums, numsSize);\\n    if (target >= nums[0] && target <= nums[pi - 1])\\n    {\\n        return binary(nums, target, 0, pi - 1);\\n    }\\n    else\\n    {\\n        return binary(nums, target, pi, numsSize - 1);\\n    }\\n} "
                    },
                    {
                        "username": "bparanj",
                        "content": "The code provided here seems correct in terms of logic for a rotated sorted array, but the error \"heap-buffer-overflow\" typically occurs when you attempt to read or write outside the memory bounds of a heap-allocated variable.\\n\\nThe problem could be arising from the fact that `pi - 1` in the line `if (target >= nums[0] && target <= nums[pi - 1])` can be negative if `pi` is 0. This would happen if the array is already sorted (i.e., not rotated at all), in which case the pivot function would return 0. Accessing `nums[-1]` would result in a heap-buffer-overflow error because it tries to access memory outside the bounds of the array.\\n\\nTo fix this issue, you should add a check for the case when the array is not rotated:\\n\\n```c\\nint search(int* nums, int numsSize, int target){\\n    int pi = pivot(nums, numsSize);\\n    if (pi > 0 && target >= nums[0] && target <= nums[pi - 1]) {\\n        return binary(nums, target, 0, pi - 1);\\n    } else {\\n        return binary(nums, target, pi, numsSize - 1);\\n    }\\n}\\n```\\nAlso, if the target element is not in the array, it\\'s good to handle that case. But this is more related to the problem constraints.\\n\\nPlease try this adjustment and see if it resolves the heap-buffer-overflow error."
                    },
                    {
                        "username": "hendrywiranto",
                        "content": "this one is hard"
                    },
                    {
                        "username": "DEVELOPER_777M",
                        "content": "class Solution(object):\\n    def search(self, nums, target):\\n        if target in nums:\\n            for i in range(len(nums)):\\n                if nums[i] == target:\\n                    return i\\n        else:\\n            return -1\\n```\\nDo you think it\\'s difficult ?"
                    },
                    {
                        "username": "raihandevbd",
                        "content": "Things are broken everywhere, Because bugs are everywhere."
                    },
                    {
                        "username": "Dhruv_Khanna123",
                        "content": "This should be marked as easy. Many \"easy\" problems are tougher than this. "
                    },
                    {
                        "username": "Razzzzzzzzz",
                        "content": "class Solution:\\n    def search(self, nums: List[int], target: int) -> int:\\n        if target in nums:\\n            return nums.index(target)\\n        return -1       \\n \\n"
                    },
                    {
                        "username": "vishesh258",
                        "content": "wht is he use we can just search for target in the nums array and return its index"
                    },
                    {
                        "username": "AmeyDhimte",
                        "content": "Please listen all of you who think a sorted input test case like [1,3,5] is not valid!\nIt IS A VALID INPUT! It is just rotated integral multiple of n number of times.\nSay in this test case 1,3,5 may be rotated via 1(pivot) 0 times, 3 times, 6 times, 9 times, and so on any k*n (here n=3) times ,where k is a non-negative int.\nSo for SORTED INPUT TESTCASES 0th element or the 1ST ELEMENT is to be considered PIVOT"
                    }
                ]
            },
            {
                "id": 1877585,
                "content": [
                    {
                        "username": "user8104ko",
                        "content": "Can any one tell me how to do this in o(log n)  in java ?"
                    },
                    {
                        "username": "podalakurisuryaprakash",
                        "content": "it is the complexity of binray search\\n"
                    },
                    {
                        "username": "mskamel",
                        "content": "Can someone tell me why this code/solution doesn\\'t work:\\n\\n\\n `class Solution {\\n    public int search(int[] nums, int target) {\\n        int low = 0;\\n        int high = nums.length;\\n        int pivot = 0;\\n\\n        while (low <= high) {\\n            int mid = low + (high - low) / 2;\\n\\n            if (nums[mid - 1] > nums[mid] && nums[mid + 1] > nums[mid]) {\\n                pivot = mid;\\n                break;\\n            }\\n            else if (nums[mid - 1] < nums[mid] && nums[mid + 1] > nums[mid]) {\\n                high = mid - 1;\\n            }\\n            else if (nums[mid - 1] > nums[mid] && nums[mid + 1] < nums[mid]) {\\n                low = mid;\\n            }\\n        }\\n\\n        if (target > pivot) {\\n            low = pivot;\\n            high = nums.length;\\n\\n            while (low <= high) {\\n                int mid = low + (high - low) / 2;\\n                if (nums[mid] == target) {\\n                    return mid;\\n                }\\n                else if (nums[mid] < target) {\\n                    high = mid - 1;\\n                }\\n                else {\\n                    low = mid;\\n                }\\n            }\\n        }\\n        else if (target < pivot) {\\n            low = pivot;\\n            high = 0;\\n\\n            while (high <= low) {\\n                int mid = high + (low - high) / 2;\\n                if (nums[mid] == target) {\\n                    return mid;\\n                }\\n                else if (nums[mid] < target) {\\n                    low = mid - 1;\\n                }\\n                else {\\n                    high = mid;\\n                }\\n            }\\n        }\\n\\n        return -1;\\n    }\\n}`"
                    },
                    {
                        "username": "bparanj",
                        "content": "The code has several issues:\\n\\n1. `int high = nums.length;` - The \\'high\\' variable is initialized to the length of the array, which is out of range. It should be `nums.length - 1`.\\n\\n2. The while loop `while (low <= high)` can result in an ArrayIndexOutOfBoundsException, as you are not checking if \\'mid\\' is at the ends of the array before accessing `nums[mid - 1]` and `nums[mid + 1]`.\\n\\n3. `if (target > pivot)` and `if (target < pivot)`: Here you\\'re comparing the target with the index \\'pivot\\', not with the value of \\'nums[pivot]\\'.\\n\\n4. In the second part of your code, you\\'re doing two binary searches, one for the case where the target is greater than the pivot value and one where it is smaller. However, in both cases, you are not adjusting the mid value correctly in the while loop.\\n\\nHere is a revised version of your code:\\n\\n```java\\nclass Solution {\\n    public int search(int[] nums, int target) {\\n        int low = 0;\\n        int high = nums.length - 1;\\n        int pivot = 0;\\n        \\n        while (low <= high) {\\n            int mid = low + (high - low) / 2;\\n            if (mid > 0 && mid < nums.length - 1 && nums[mid - 1] > nums[mid] && nums[mid + 1] > nums[mid]) {\\n                pivot = mid;\\n                break;\\n            }\\n            else if (nums[mid] > nums[low]) {\\n                low = mid + 1;\\n            }\\n            else {\\n                high = mid - 1;\\n            }\\n        }\\n        \\n        if (nums[pivot] == target) return pivot;\\n\\n        low = 0;\\n        high = nums.length - 1;\\n        \\n        while (low <= high) {\\n            int mid = low + (high - low) / 2;\\n            if (nums[mid] == target) {\\n                return mid;\\n            }\\n            else if (nums[mid] < target) {\\n                low = mid + 1;\\n            }\\n            else {\\n                high = mid - 1;\\n            }\\n        }\\n        return -1;\\n    }\\n}\\n```\\n\\nThis revised code firstly tries to find the pivot using a modified binary search. Then, it does a binary search on the entire array to find the target. This is not the most efficient solution, as the pivot is not utilized, but it corrects the issues in your original code. \\n\\nIn an optimal solution, once the pivot is found, we should do two binary searches: one from 0 to pivot, and another from pivot+1 to nums.length - 1, depending on the value of the target."
                    },
                    {
                        "username": "Raghav_36",
                        "content": "getting heap-buffer-overflow error in this code..can anyone help??\\n\\nint pivot(int arr[], int n)\\n{\\n    int s = 0;\\n    int e = n - 1;\\n    int mid = (s + e) / 2;\\n    while (s < e)\\n    {\\n        if (arr[mid] >= arr[0])\\n        {\\n            s = mid + 1;\\n        }\\n        else\\n        {\\n            e = mid;\\n        }\\n        mid = (s + e) / 2;\\n    }\\n    return s;\\n}\\nint binary(int arr[], int ele, int s, int e)\\n{\\n    int mid = (s + e) / 2;\\n    while (s <= e)\\n    {\\n        if (arr[mid] == ele)\\n        {\\n            return mid;\\n        }\\n        else if (arr[mid] > ele)\\n        {\\n            e = mid - 1;\\n        }\\n        else\\n        {\\n            s = mid + 1;\\n        }\\n        mid = (s + e) / 2;\\n    }\\n    return -1;\\n}\\nint search(int* nums, int numsSize, int target){\\n    int pi = pivot(nums, numsSize);\\n    if (target >= nums[0] && target <= nums[pi - 1])\\n    {\\n        return binary(nums, target, 0, pi - 1);\\n    }\\n    else\\n    {\\n        return binary(nums, target, pi, numsSize - 1);\\n    }\\n} "
                    },
                    {
                        "username": "bparanj",
                        "content": "The code provided here seems correct in terms of logic for a rotated sorted array, but the error \"heap-buffer-overflow\" typically occurs when you attempt to read or write outside the memory bounds of a heap-allocated variable.\\n\\nThe problem could be arising from the fact that `pi - 1` in the line `if (target >= nums[0] && target <= nums[pi - 1])` can be negative if `pi` is 0. This would happen if the array is already sorted (i.e., not rotated at all), in which case the pivot function would return 0. Accessing `nums[-1]` would result in a heap-buffer-overflow error because it tries to access memory outside the bounds of the array.\\n\\nTo fix this issue, you should add a check for the case when the array is not rotated:\\n\\n```c\\nint search(int* nums, int numsSize, int target){\\n    int pi = pivot(nums, numsSize);\\n    if (pi > 0 && target >= nums[0] && target <= nums[pi - 1]) {\\n        return binary(nums, target, 0, pi - 1);\\n    } else {\\n        return binary(nums, target, pi, numsSize - 1);\\n    }\\n}\\n```\\nAlso, if the target element is not in the array, it\\'s good to handle that case. But this is more related to the problem constraints.\\n\\nPlease try this adjustment and see if it resolves the heap-buffer-overflow error."
                    },
                    {
                        "username": "hendrywiranto",
                        "content": "this one is hard"
                    },
                    {
                        "username": "DEVELOPER_777M",
                        "content": "class Solution(object):\\n    def search(self, nums, target):\\n        if target in nums:\\n            for i in range(len(nums)):\\n                if nums[i] == target:\\n                    return i\\n        else:\\n            return -1\\n```\\nDo you think it\\'s difficult ?"
                    },
                    {
                        "username": "raihandevbd",
                        "content": "Things are broken everywhere, Because bugs are everywhere."
                    },
                    {
                        "username": "Dhruv_Khanna123",
                        "content": "This should be marked as easy. Many \"easy\" problems are tougher than this. "
                    },
                    {
                        "username": "Razzzzzzzzz",
                        "content": "class Solution:\\n    def search(self, nums: List[int], target: int) -> int:\\n        if target in nums:\\n            return nums.index(target)\\n        return -1       \\n \\n"
                    },
                    {
                        "username": "vishesh258",
                        "content": "wht is he use we can just search for target in the nums array and return its index"
                    },
                    {
                        "username": "AmeyDhimte",
                        "content": "Please listen all of you who think a sorted input test case like [1,3,5] is not valid!\nIt IS A VALID INPUT! It is just rotated integral multiple of n number of times.\nSay in this test case 1,3,5 may be rotated via 1(pivot) 0 times, 3 times, 6 times, 9 times, and so on any k*n (here n=3) times ,where k is a non-negative int.\nSo for SORTED INPUT TESTCASES 0th element or the 1ST ELEMENT is to be considered PIVOT"
                    }
                ]
            },
            {
                "id": 1876291,
                "content": [
                    {
                        "username": "user8104ko",
                        "content": "Can any one tell me how to do this in o(log n)  in java ?"
                    },
                    {
                        "username": "podalakurisuryaprakash",
                        "content": "it is the complexity of binray search\\n"
                    },
                    {
                        "username": "mskamel",
                        "content": "Can someone tell me why this code/solution doesn\\'t work:\\n\\n\\n `class Solution {\\n    public int search(int[] nums, int target) {\\n        int low = 0;\\n        int high = nums.length;\\n        int pivot = 0;\\n\\n        while (low <= high) {\\n            int mid = low + (high - low) / 2;\\n\\n            if (nums[mid - 1] > nums[mid] && nums[mid + 1] > nums[mid]) {\\n                pivot = mid;\\n                break;\\n            }\\n            else if (nums[mid - 1] < nums[mid] && nums[mid + 1] > nums[mid]) {\\n                high = mid - 1;\\n            }\\n            else if (nums[mid - 1] > nums[mid] && nums[mid + 1] < nums[mid]) {\\n                low = mid;\\n            }\\n        }\\n\\n        if (target > pivot) {\\n            low = pivot;\\n            high = nums.length;\\n\\n            while (low <= high) {\\n                int mid = low + (high - low) / 2;\\n                if (nums[mid] == target) {\\n                    return mid;\\n                }\\n                else if (nums[mid] < target) {\\n                    high = mid - 1;\\n                }\\n                else {\\n                    low = mid;\\n                }\\n            }\\n        }\\n        else if (target < pivot) {\\n            low = pivot;\\n            high = 0;\\n\\n            while (high <= low) {\\n                int mid = high + (low - high) / 2;\\n                if (nums[mid] == target) {\\n                    return mid;\\n                }\\n                else if (nums[mid] < target) {\\n                    low = mid - 1;\\n                }\\n                else {\\n                    high = mid;\\n                }\\n            }\\n        }\\n\\n        return -1;\\n    }\\n}`"
                    },
                    {
                        "username": "bparanj",
                        "content": "The code has several issues:\\n\\n1. `int high = nums.length;` - The \\'high\\' variable is initialized to the length of the array, which is out of range. It should be `nums.length - 1`.\\n\\n2. The while loop `while (low <= high)` can result in an ArrayIndexOutOfBoundsException, as you are not checking if \\'mid\\' is at the ends of the array before accessing `nums[mid - 1]` and `nums[mid + 1]`.\\n\\n3. `if (target > pivot)` and `if (target < pivot)`: Here you\\'re comparing the target with the index \\'pivot\\', not with the value of \\'nums[pivot]\\'.\\n\\n4. In the second part of your code, you\\'re doing two binary searches, one for the case where the target is greater than the pivot value and one where it is smaller. However, in both cases, you are not adjusting the mid value correctly in the while loop.\\n\\nHere is a revised version of your code:\\n\\n```java\\nclass Solution {\\n    public int search(int[] nums, int target) {\\n        int low = 0;\\n        int high = nums.length - 1;\\n        int pivot = 0;\\n        \\n        while (low <= high) {\\n            int mid = low + (high - low) / 2;\\n            if (mid > 0 && mid < nums.length - 1 && nums[mid - 1] > nums[mid] && nums[mid + 1] > nums[mid]) {\\n                pivot = mid;\\n                break;\\n            }\\n            else if (nums[mid] > nums[low]) {\\n                low = mid + 1;\\n            }\\n            else {\\n                high = mid - 1;\\n            }\\n        }\\n        \\n        if (nums[pivot] == target) return pivot;\\n\\n        low = 0;\\n        high = nums.length - 1;\\n        \\n        while (low <= high) {\\n            int mid = low + (high - low) / 2;\\n            if (nums[mid] == target) {\\n                return mid;\\n            }\\n            else if (nums[mid] < target) {\\n                low = mid + 1;\\n            }\\n            else {\\n                high = mid - 1;\\n            }\\n        }\\n        return -1;\\n    }\\n}\\n```\\n\\nThis revised code firstly tries to find the pivot using a modified binary search. Then, it does a binary search on the entire array to find the target. This is not the most efficient solution, as the pivot is not utilized, but it corrects the issues in your original code. \\n\\nIn an optimal solution, once the pivot is found, we should do two binary searches: one from 0 to pivot, and another from pivot+1 to nums.length - 1, depending on the value of the target."
                    },
                    {
                        "username": "Raghav_36",
                        "content": "getting heap-buffer-overflow error in this code..can anyone help??\\n\\nint pivot(int arr[], int n)\\n{\\n    int s = 0;\\n    int e = n - 1;\\n    int mid = (s + e) / 2;\\n    while (s < e)\\n    {\\n        if (arr[mid] >= arr[0])\\n        {\\n            s = mid + 1;\\n        }\\n        else\\n        {\\n            e = mid;\\n        }\\n        mid = (s + e) / 2;\\n    }\\n    return s;\\n}\\nint binary(int arr[], int ele, int s, int e)\\n{\\n    int mid = (s + e) / 2;\\n    while (s <= e)\\n    {\\n        if (arr[mid] == ele)\\n        {\\n            return mid;\\n        }\\n        else if (arr[mid] > ele)\\n        {\\n            e = mid - 1;\\n        }\\n        else\\n        {\\n            s = mid + 1;\\n        }\\n        mid = (s + e) / 2;\\n    }\\n    return -1;\\n}\\nint search(int* nums, int numsSize, int target){\\n    int pi = pivot(nums, numsSize);\\n    if (target >= nums[0] && target <= nums[pi - 1])\\n    {\\n        return binary(nums, target, 0, pi - 1);\\n    }\\n    else\\n    {\\n        return binary(nums, target, pi, numsSize - 1);\\n    }\\n} "
                    },
                    {
                        "username": "bparanj",
                        "content": "The code provided here seems correct in terms of logic for a rotated sorted array, but the error \"heap-buffer-overflow\" typically occurs when you attempt to read or write outside the memory bounds of a heap-allocated variable.\\n\\nThe problem could be arising from the fact that `pi - 1` in the line `if (target >= nums[0] && target <= nums[pi - 1])` can be negative if `pi` is 0. This would happen if the array is already sorted (i.e., not rotated at all), in which case the pivot function would return 0. Accessing `nums[-1]` would result in a heap-buffer-overflow error because it tries to access memory outside the bounds of the array.\\n\\nTo fix this issue, you should add a check for the case when the array is not rotated:\\n\\n```c\\nint search(int* nums, int numsSize, int target){\\n    int pi = pivot(nums, numsSize);\\n    if (pi > 0 && target >= nums[0] && target <= nums[pi - 1]) {\\n        return binary(nums, target, 0, pi - 1);\\n    } else {\\n        return binary(nums, target, pi, numsSize - 1);\\n    }\\n}\\n```\\nAlso, if the target element is not in the array, it\\'s good to handle that case. But this is more related to the problem constraints.\\n\\nPlease try this adjustment and see if it resolves the heap-buffer-overflow error."
                    },
                    {
                        "username": "hendrywiranto",
                        "content": "this one is hard"
                    },
                    {
                        "username": "DEVELOPER_777M",
                        "content": "class Solution(object):\\n    def search(self, nums, target):\\n        if target in nums:\\n            for i in range(len(nums)):\\n                if nums[i] == target:\\n                    return i\\n        else:\\n            return -1\\n```\\nDo you think it\\'s difficult ?"
                    },
                    {
                        "username": "raihandevbd",
                        "content": "Things are broken everywhere, Because bugs are everywhere."
                    },
                    {
                        "username": "Dhruv_Khanna123",
                        "content": "This should be marked as easy. Many \"easy\" problems are tougher than this. "
                    },
                    {
                        "username": "Razzzzzzzzz",
                        "content": "class Solution:\\n    def search(self, nums: List[int], target: int) -> int:\\n        if target in nums:\\n            return nums.index(target)\\n        return -1       \\n \\n"
                    },
                    {
                        "username": "vishesh258",
                        "content": "wht is he use we can just search for target in the nums array and return its index"
                    },
                    {
                        "username": "AmeyDhimte",
                        "content": "Please listen all of you who think a sorted input test case like [1,3,5] is not valid!\nIt IS A VALID INPUT! It is just rotated integral multiple of n number of times.\nSay in this test case 1,3,5 may be rotated via 1(pivot) 0 times, 3 times, 6 times, 9 times, and so on any k*n (here n=3) times ,where k is a non-negative int.\nSo for SORTED INPUT TESTCASES 0th element or the 1ST ELEMENT is to be considered PIVOT"
                    }
                ]
            },
            {
                "id": 1871194,
                "content": [
                    {
                        "username": "user8104ko",
                        "content": "Can any one tell me how to do this in o(log n)  in java ?"
                    },
                    {
                        "username": "podalakurisuryaprakash",
                        "content": "it is the complexity of binray search\\n"
                    },
                    {
                        "username": "mskamel",
                        "content": "Can someone tell me why this code/solution doesn\\'t work:\\n\\n\\n `class Solution {\\n    public int search(int[] nums, int target) {\\n        int low = 0;\\n        int high = nums.length;\\n        int pivot = 0;\\n\\n        while (low <= high) {\\n            int mid = low + (high - low) / 2;\\n\\n            if (nums[mid - 1] > nums[mid] && nums[mid + 1] > nums[mid]) {\\n                pivot = mid;\\n                break;\\n            }\\n            else if (nums[mid - 1] < nums[mid] && nums[mid + 1] > nums[mid]) {\\n                high = mid - 1;\\n            }\\n            else if (nums[mid - 1] > nums[mid] && nums[mid + 1] < nums[mid]) {\\n                low = mid;\\n            }\\n        }\\n\\n        if (target > pivot) {\\n            low = pivot;\\n            high = nums.length;\\n\\n            while (low <= high) {\\n                int mid = low + (high - low) / 2;\\n                if (nums[mid] == target) {\\n                    return mid;\\n                }\\n                else if (nums[mid] < target) {\\n                    high = mid - 1;\\n                }\\n                else {\\n                    low = mid;\\n                }\\n            }\\n        }\\n        else if (target < pivot) {\\n            low = pivot;\\n            high = 0;\\n\\n            while (high <= low) {\\n                int mid = high + (low - high) / 2;\\n                if (nums[mid] == target) {\\n                    return mid;\\n                }\\n                else if (nums[mid] < target) {\\n                    low = mid - 1;\\n                }\\n                else {\\n                    high = mid;\\n                }\\n            }\\n        }\\n\\n        return -1;\\n    }\\n}`"
                    },
                    {
                        "username": "bparanj",
                        "content": "The code has several issues:\\n\\n1. `int high = nums.length;` - The \\'high\\' variable is initialized to the length of the array, which is out of range. It should be `nums.length - 1`.\\n\\n2. The while loop `while (low <= high)` can result in an ArrayIndexOutOfBoundsException, as you are not checking if \\'mid\\' is at the ends of the array before accessing `nums[mid - 1]` and `nums[mid + 1]`.\\n\\n3. `if (target > pivot)` and `if (target < pivot)`: Here you\\'re comparing the target with the index \\'pivot\\', not with the value of \\'nums[pivot]\\'.\\n\\n4. In the second part of your code, you\\'re doing two binary searches, one for the case where the target is greater than the pivot value and one where it is smaller. However, in both cases, you are not adjusting the mid value correctly in the while loop.\\n\\nHere is a revised version of your code:\\n\\n```java\\nclass Solution {\\n    public int search(int[] nums, int target) {\\n        int low = 0;\\n        int high = nums.length - 1;\\n        int pivot = 0;\\n        \\n        while (low <= high) {\\n            int mid = low + (high - low) / 2;\\n            if (mid > 0 && mid < nums.length - 1 && nums[mid - 1] > nums[mid] && nums[mid + 1] > nums[mid]) {\\n                pivot = mid;\\n                break;\\n            }\\n            else if (nums[mid] > nums[low]) {\\n                low = mid + 1;\\n            }\\n            else {\\n                high = mid - 1;\\n            }\\n        }\\n        \\n        if (nums[pivot] == target) return pivot;\\n\\n        low = 0;\\n        high = nums.length - 1;\\n        \\n        while (low <= high) {\\n            int mid = low + (high - low) / 2;\\n            if (nums[mid] == target) {\\n                return mid;\\n            }\\n            else if (nums[mid] < target) {\\n                low = mid + 1;\\n            }\\n            else {\\n                high = mid - 1;\\n            }\\n        }\\n        return -1;\\n    }\\n}\\n```\\n\\nThis revised code firstly tries to find the pivot using a modified binary search. Then, it does a binary search on the entire array to find the target. This is not the most efficient solution, as the pivot is not utilized, but it corrects the issues in your original code. \\n\\nIn an optimal solution, once the pivot is found, we should do two binary searches: one from 0 to pivot, and another from pivot+1 to nums.length - 1, depending on the value of the target."
                    },
                    {
                        "username": "Raghav_36",
                        "content": "getting heap-buffer-overflow error in this code..can anyone help??\\n\\nint pivot(int arr[], int n)\\n{\\n    int s = 0;\\n    int e = n - 1;\\n    int mid = (s + e) / 2;\\n    while (s < e)\\n    {\\n        if (arr[mid] >= arr[0])\\n        {\\n            s = mid + 1;\\n        }\\n        else\\n        {\\n            e = mid;\\n        }\\n        mid = (s + e) / 2;\\n    }\\n    return s;\\n}\\nint binary(int arr[], int ele, int s, int e)\\n{\\n    int mid = (s + e) / 2;\\n    while (s <= e)\\n    {\\n        if (arr[mid] == ele)\\n        {\\n            return mid;\\n        }\\n        else if (arr[mid] > ele)\\n        {\\n            e = mid - 1;\\n        }\\n        else\\n        {\\n            s = mid + 1;\\n        }\\n        mid = (s + e) / 2;\\n    }\\n    return -1;\\n}\\nint search(int* nums, int numsSize, int target){\\n    int pi = pivot(nums, numsSize);\\n    if (target >= nums[0] && target <= nums[pi - 1])\\n    {\\n        return binary(nums, target, 0, pi - 1);\\n    }\\n    else\\n    {\\n        return binary(nums, target, pi, numsSize - 1);\\n    }\\n} "
                    },
                    {
                        "username": "bparanj",
                        "content": "The code provided here seems correct in terms of logic for a rotated sorted array, but the error \"heap-buffer-overflow\" typically occurs when you attempt to read or write outside the memory bounds of a heap-allocated variable.\\n\\nThe problem could be arising from the fact that `pi - 1` in the line `if (target >= nums[0] && target <= nums[pi - 1])` can be negative if `pi` is 0. This would happen if the array is already sorted (i.e., not rotated at all), in which case the pivot function would return 0. Accessing `nums[-1]` would result in a heap-buffer-overflow error because it tries to access memory outside the bounds of the array.\\n\\nTo fix this issue, you should add a check for the case when the array is not rotated:\\n\\n```c\\nint search(int* nums, int numsSize, int target){\\n    int pi = pivot(nums, numsSize);\\n    if (pi > 0 && target >= nums[0] && target <= nums[pi - 1]) {\\n        return binary(nums, target, 0, pi - 1);\\n    } else {\\n        return binary(nums, target, pi, numsSize - 1);\\n    }\\n}\\n```\\nAlso, if the target element is not in the array, it\\'s good to handle that case. But this is more related to the problem constraints.\\n\\nPlease try this adjustment and see if it resolves the heap-buffer-overflow error."
                    },
                    {
                        "username": "hendrywiranto",
                        "content": "this one is hard"
                    },
                    {
                        "username": "DEVELOPER_777M",
                        "content": "class Solution(object):\\n    def search(self, nums, target):\\n        if target in nums:\\n            for i in range(len(nums)):\\n                if nums[i] == target:\\n                    return i\\n        else:\\n            return -1\\n```\\nDo you think it\\'s difficult ?"
                    },
                    {
                        "username": "raihandevbd",
                        "content": "Things are broken everywhere, Because bugs are everywhere."
                    },
                    {
                        "username": "Dhruv_Khanna123",
                        "content": "This should be marked as easy. Many \"easy\" problems are tougher than this. "
                    },
                    {
                        "username": "Razzzzzzzzz",
                        "content": "class Solution:\\n    def search(self, nums: List[int], target: int) -> int:\\n        if target in nums:\\n            return nums.index(target)\\n        return -1       \\n \\n"
                    },
                    {
                        "username": "vishesh258",
                        "content": "wht is he use we can just search for target in the nums array and return its index"
                    },
                    {
                        "username": "AmeyDhimte",
                        "content": "Please listen all of you who think a sorted input test case like [1,3,5] is not valid!\nIt IS A VALID INPUT! It is just rotated integral multiple of n number of times.\nSay in this test case 1,3,5 may be rotated via 1(pivot) 0 times, 3 times, 6 times, 9 times, and so on any k*n (here n=3) times ,where k is a non-negative int.\nSo for SORTED INPUT TESTCASES 0th element or the 1ST ELEMENT is to be considered PIVOT"
                    }
                ]
            },
            {
                "id": 1858198,
                "content": [
                    {
                        "username": "user8104ko",
                        "content": "Can any one tell me how to do this in o(log n)  in java ?"
                    },
                    {
                        "username": "podalakurisuryaprakash",
                        "content": "it is the complexity of binray search\\n"
                    },
                    {
                        "username": "mskamel",
                        "content": "Can someone tell me why this code/solution doesn\\'t work:\\n\\n\\n `class Solution {\\n    public int search(int[] nums, int target) {\\n        int low = 0;\\n        int high = nums.length;\\n        int pivot = 0;\\n\\n        while (low <= high) {\\n            int mid = low + (high - low) / 2;\\n\\n            if (nums[mid - 1] > nums[mid] && nums[mid + 1] > nums[mid]) {\\n                pivot = mid;\\n                break;\\n            }\\n            else if (nums[mid - 1] < nums[mid] && nums[mid + 1] > nums[mid]) {\\n                high = mid - 1;\\n            }\\n            else if (nums[mid - 1] > nums[mid] && nums[mid + 1] < nums[mid]) {\\n                low = mid;\\n            }\\n        }\\n\\n        if (target > pivot) {\\n            low = pivot;\\n            high = nums.length;\\n\\n            while (low <= high) {\\n                int mid = low + (high - low) / 2;\\n                if (nums[mid] == target) {\\n                    return mid;\\n                }\\n                else if (nums[mid] < target) {\\n                    high = mid - 1;\\n                }\\n                else {\\n                    low = mid;\\n                }\\n            }\\n        }\\n        else if (target < pivot) {\\n            low = pivot;\\n            high = 0;\\n\\n            while (high <= low) {\\n                int mid = high + (low - high) / 2;\\n                if (nums[mid] == target) {\\n                    return mid;\\n                }\\n                else if (nums[mid] < target) {\\n                    low = mid - 1;\\n                }\\n                else {\\n                    high = mid;\\n                }\\n            }\\n        }\\n\\n        return -1;\\n    }\\n}`"
                    },
                    {
                        "username": "bparanj",
                        "content": "The code has several issues:\\n\\n1. `int high = nums.length;` - The \\'high\\' variable is initialized to the length of the array, which is out of range. It should be `nums.length - 1`.\\n\\n2. The while loop `while (low <= high)` can result in an ArrayIndexOutOfBoundsException, as you are not checking if \\'mid\\' is at the ends of the array before accessing `nums[mid - 1]` and `nums[mid + 1]`.\\n\\n3. `if (target > pivot)` and `if (target < pivot)`: Here you\\'re comparing the target with the index \\'pivot\\', not with the value of \\'nums[pivot]\\'.\\n\\n4. In the second part of your code, you\\'re doing two binary searches, one for the case where the target is greater than the pivot value and one where it is smaller. However, in both cases, you are not adjusting the mid value correctly in the while loop.\\n\\nHere is a revised version of your code:\\n\\n```java\\nclass Solution {\\n    public int search(int[] nums, int target) {\\n        int low = 0;\\n        int high = nums.length - 1;\\n        int pivot = 0;\\n        \\n        while (low <= high) {\\n            int mid = low + (high - low) / 2;\\n            if (mid > 0 && mid < nums.length - 1 && nums[mid - 1] > nums[mid] && nums[mid + 1] > nums[mid]) {\\n                pivot = mid;\\n                break;\\n            }\\n            else if (nums[mid] > nums[low]) {\\n                low = mid + 1;\\n            }\\n            else {\\n                high = mid - 1;\\n            }\\n        }\\n        \\n        if (nums[pivot] == target) return pivot;\\n\\n        low = 0;\\n        high = nums.length - 1;\\n        \\n        while (low <= high) {\\n            int mid = low + (high - low) / 2;\\n            if (nums[mid] == target) {\\n                return mid;\\n            }\\n            else if (nums[mid] < target) {\\n                low = mid + 1;\\n            }\\n            else {\\n                high = mid - 1;\\n            }\\n        }\\n        return -1;\\n    }\\n}\\n```\\n\\nThis revised code firstly tries to find the pivot using a modified binary search. Then, it does a binary search on the entire array to find the target. This is not the most efficient solution, as the pivot is not utilized, but it corrects the issues in your original code. \\n\\nIn an optimal solution, once the pivot is found, we should do two binary searches: one from 0 to pivot, and another from pivot+1 to nums.length - 1, depending on the value of the target."
                    },
                    {
                        "username": "Raghav_36",
                        "content": "getting heap-buffer-overflow error in this code..can anyone help??\\n\\nint pivot(int arr[], int n)\\n{\\n    int s = 0;\\n    int e = n - 1;\\n    int mid = (s + e) / 2;\\n    while (s < e)\\n    {\\n        if (arr[mid] >= arr[0])\\n        {\\n            s = mid + 1;\\n        }\\n        else\\n        {\\n            e = mid;\\n        }\\n        mid = (s + e) / 2;\\n    }\\n    return s;\\n}\\nint binary(int arr[], int ele, int s, int e)\\n{\\n    int mid = (s + e) / 2;\\n    while (s <= e)\\n    {\\n        if (arr[mid] == ele)\\n        {\\n            return mid;\\n        }\\n        else if (arr[mid] > ele)\\n        {\\n            e = mid - 1;\\n        }\\n        else\\n        {\\n            s = mid + 1;\\n        }\\n        mid = (s + e) / 2;\\n    }\\n    return -1;\\n}\\nint search(int* nums, int numsSize, int target){\\n    int pi = pivot(nums, numsSize);\\n    if (target >= nums[0] && target <= nums[pi - 1])\\n    {\\n        return binary(nums, target, 0, pi - 1);\\n    }\\n    else\\n    {\\n        return binary(nums, target, pi, numsSize - 1);\\n    }\\n} "
                    },
                    {
                        "username": "bparanj",
                        "content": "The code provided here seems correct in terms of logic for a rotated sorted array, but the error \"heap-buffer-overflow\" typically occurs when you attempt to read or write outside the memory bounds of a heap-allocated variable.\\n\\nThe problem could be arising from the fact that `pi - 1` in the line `if (target >= nums[0] && target <= nums[pi - 1])` can be negative if `pi` is 0. This would happen if the array is already sorted (i.e., not rotated at all), in which case the pivot function would return 0. Accessing `nums[-1]` would result in a heap-buffer-overflow error because it tries to access memory outside the bounds of the array.\\n\\nTo fix this issue, you should add a check for the case when the array is not rotated:\\n\\n```c\\nint search(int* nums, int numsSize, int target){\\n    int pi = pivot(nums, numsSize);\\n    if (pi > 0 && target >= nums[0] && target <= nums[pi - 1]) {\\n        return binary(nums, target, 0, pi - 1);\\n    } else {\\n        return binary(nums, target, pi, numsSize - 1);\\n    }\\n}\\n```\\nAlso, if the target element is not in the array, it\\'s good to handle that case. But this is more related to the problem constraints.\\n\\nPlease try this adjustment and see if it resolves the heap-buffer-overflow error."
                    },
                    {
                        "username": "hendrywiranto",
                        "content": "this one is hard"
                    },
                    {
                        "username": "DEVELOPER_777M",
                        "content": "class Solution(object):\\n    def search(self, nums, target):\\n        if target in nums:\\n            for i in range(len(nums)):\\n                if nums[i] == target:\\n                    return i\\n        else:\\n            return -1\\n```\\nDo you think it\\'s difficult ?"
                    },
                    {
                        "username": "raihandevbd",
                        "content": "Things are broken everywhere, Because bugs are everywhere."
                    },
                    {
                        "username": "Dhruv_Khanna123",
                        "content": "This should be marked as easy. Many \"easy\" problems are tougher than this. "
                    },
                    {
                        "username": "Razzzzzzzzz",
                        "content": "class Solution:\\n    def search(self, nums: List[int], target: int) -> int:\\n        if target in nums:\\n            return nums.index(target)\\n        return -1       \\n \\n"
                    },
                    {
                        "username": "vishesh258",
                        "content": "wht is he use we can just search for target in the nums array and return its index"
                    },
                    {
                        "username": "AmeyDhimte",
                        "content": "Please listen all of you who think a sorted input test case like [1,3,5] is not valid!\nIt IS A VALID INPUT! It is just rotated integral multiple of n number of times.\nSay in this test case 1,3,5 may be rotated via 1(pivot) 0 times, 3 times, 6 times, 9 times, and so on any k*n (here n=3) times ,where k is a non-negative int.\nSo for SORTED INPUT TESTCASES 0th element or the 1ST ELEMENT is to be considered PIVOT"
                    }
                ]
            },
            {
                "id": 1846450,
                "content": [
                    {
                        "username": "user8104ko",
                        "content": "Can any one tell me how to do this in o(log n)  in java ?"
                    },
                    {
                        "username": "podalakurisuryaprakash",
                        "content": "it is the complexity of binray search\\n"
                    },
                    {
                        "username": "mskamel",
                        "content": "Can someone tell me why this code/solution doesn\\'t work:\\n\\n\\n `class Solution {\\n    public int search(int[] nums, int target) {\\n        int low = 0;\\n        int high = nums.length;\\n        int pivot = 0;\\n\\n        while (low <= high) {\\n            int mid = low + (high - low) / 2;\\n\\n            if (nums[mid - 1] > nums[mid] && nums[mid + 1] > nums[mid]) {\\n                pivot = mid;\\n                break;\\n            }\\n            else if (nums[mid - 1] < nums[mid] && nums[mid + 1] > nums[mid]) {\\n                high = mid - 1;\\n            }\\n            else if (nums[mid - 1] > nums[mid] && nums[mid + 1] < nums[mid]) {\\n                low = mid;\\n            }\\n        }\\n\\n        if (target > pivot) {\\n            low = pivot;\\n            high = nums.length;\\n\\n            while (low <= high) {\\n                int mid = low + (high - low) / 2;\\n                if (nums[mid] == target) {\\n                    return mid;\\n                }\\n                else if (nums[mid] < target) {\\n                    high = mid - 1;\\n                }\\n                else {\\n                    low = mid;\\n                }\\n            }\\n        }\\n        else if (target < pivot) {\\n            low = pivot;\\n            high = 0;\\n\\n            while (high <= low) {\\n                int mid = high + (low - high) / 2;\\n                if (nums[mid] == target) {\\n                    return mid;\\n                }\\n                else if (nums[mid] < target) {\\n                    low = mid - 1;\\n                }\\n                else {\\n                    high = mid;\\n                }\\n            }\\n        }\\n\\n        return -1;\\n    }\\n}`"
                    },
                    {
                        "username": "bparanj",
                        "content": "The code has several issues:\\n\\n1. `int high = nums.length;` - The \\'high\\' variable is initialized to the length of the array, which is out of range. It should be `nums.length - 1`.\\n\\n2. The while loop `while (low <= high)` can result in an ArrayIndexOutOfBoundsException, as you are not checking if \\'mid\\' is at the ends of the array before accessing `nums[mid - 1]` and `nums[mid + 1]`.\\n\\n3. `if (target > pivot)` and `if (target < pivot)`: Here you\\'re comparing the target with the index \\'pivot\\', not with the value of \\'nums[pivot]\\'.\\n\\n4. In the second part of your code, you\\'re doing two binary searches, one for the case where the target is greater than the pivot value and one where it is smaller. However, in both cases, you are not adjusting the mid value correctly in the while loop.\\n\\nHere is a revised version of your code:\\n\\n```java\\nclass Solution {\\n    public int search(int[] nums, int target) {\\n        int low = 0;\\n        int high = nums.length - 1;\\n        int pivot = 0;\\n        \\n        while (low <= high) {\\n            int mid = low + (high - low) / 2;\\n            if (mid > 0 && mid < nums.length - 1 && nums[mid - 1] > nums[mid] && nums[mid + 1] > nums[mid]) {\\n                pivot = mid;\\n                break;\\n            }\\n            else if (nums[mid] > nums[low]) {\\n                low = mid + 1;\\n            }\\n            else {\\n                high = mid - 1;\\n            }\\n        }\\n        \\n        if (nums[pivot] == target) return pivot;\\n\\n        low = 0;\\n        high = nums.length - 1;\\n        \\n        while (low <= high) {\\n            int mid = low + (high - low) / 2;\\n            if (nums[mid] == target) {\\n                return mid;\\n            }\\n            else if (nums[mid] < target) {\\n                low = mid + 1;\\n            }\\n            else {\\n                high = mid - 1;\\n            }\\n        }\\n        return -1;\\n    }\\n}\\n```\\n\\nThis revised code firstly tries to find the pivot using a modified binary search. Then, it does a binary search on the entire array to find the target. This is not the most efficient solution, as the pivot is not utilized, but it corrects the issues in your original code. \\n\\nIn an optimal solution, once the pivot is found, we should do two binary searches: one from 0 to pivot, and another from pivot+1 to nums.length - 1, depending on the value of the target."
                    },
                    {
                        "username": "Raghav_36",
                        "content": "getting heap-buffer-overflow error in this code..can anyone help??\\n\\nint pivot(int arr[], int n)\\n{\\n    int s = 0;\\n    int e = n - 1;\\n    int mid = (s + e) / 2;\\n    while (s < e)\\n    {\\n        if (arr[mid] >= arr[0])\\n        {\\n            s = mid + 1;\\n        }\\n        else\\n        {\\n            e = mid;\\n        }\\n        mid = (s + e) / 2;\\n    }\\n    return s;\\n}\\nint binary(int arr[], int ele, int s, int e)\\n{\\n    int mid = (s + e) / 2;\\n    while (s <= e)\\n    {\\n        if (arr[mid] == ele)\\n        {\\n            return mid;\\n        }\\n        else if (arr[mid] > ele)\\n        {\\n            e = mid - 1;\\n        }\\n        else\\n        {\\n            s = mid + 1;\\n        }\\n        mid = (s + e) / 2;\\n    }\\n    return -1;\\n}\\nint search(int* nums, int numsSize, int target){\\n    int pi = pivot(nums, numsSize);\\n    if (target >= nums[0] && target <= nums[pi - 1])\\n    {\\n        return binary(nums, target, 0, pi - 1);\\n    }\\n    else\\n    {\\n        return binary(nums, target, pi, numsSize - 1);\\n    }\\n} "
                    },
                    {
                        "username": "bparanj",
                        "content": "The code provided here seems correct in terms of logic for a rotated sorted array, but the error \"heap-buffer-overflow\" typically occurs when you attempt to read or write outside the memory bounds of a heap-allocated variable.\\n\\nThe problem could be arising from the fact that `pi - 1` in the line `if (target >= nums[0] && target <= nums[pi - 1])` can be negative if `pi` is 0. This would happen if the array is already sorted (i.e., not rotated at all), in which case the pivot function would return 0. Accessing `nums[-1]` would result in a heap-buffer-overflow error because it tries to access memory outside the bounds of the array.\\n\\nTo fix this issue, you should add a check for the case when the array is not rotated:\\n\\n```c\\nint search(int* nums, int numsSize, int target){\\n    int pi = pivot(nums, numsSize);\\n    if (pi > 0 && target >= nums[0] && target <= nums[pi - 1]) {\\n        return binary(nums, target, 0, pi - 1);\\n    } else {\\n        return binary(nums, target, pi, numsSize - 1);\\n    }\\n}\\n```\\nAlso, if the target element is not in the array, it\\'s good to handle that case. But this is more related to the problem constraints.\\n\\nPlease try this adjustment and see if it resolves the heap-buffer-overflow error."
                    },
                    {
                        "username": "hendrywiranto",
                        "content": "this one is hard"
                    },
                    {
                        "username": "DEVELOPER_777M",
                        "content": "class Solution(object):\\n    def search(self, nums, target):\\n        if target in nums:\\n            for i in range(len(nums)):\\n                if nums[i] == target:\\n                    return i\\n        else:\\n            return -1\\n```\\nDo you think it\\'s difficult ?"
                    },
                    {
                        "username": "raihandevbd",
                        "content": "Things are broken everywhere, Because bugs are everywhere."
                    },
                    {
                        "username": "Dhruv_Khanna123",
                        "content": "This should be marked as easy. Many \"easy\" problems are tougher than this. "
                    },
                    {
                        "username": "Razzzzzzzzz",
                        "content": "class Solution:\\n    def search(self, nums: List[int], target: int) -> int:\\n        if target in nums:\\n            return nums.index(target)\\n        return -1       \\n \\n"
                    },
                    {
                        "username": "vishesh258",
                        "content": "wht is he use we can just search for target in the nums array and return its index"
                    },
                    {
                        "username": "AmeyDhimte",
                        "content": "Please listen all of you who think a sorted input test case like [1,3,5] is not valid!\nIt IS A VALID INPUT! It is just rotated integral multiple of n number of times.\nSay in this test case 1,3,5 may be rotated via 1(pivot) 0 times, 3 times, 6 times, 9 times, and so on any k*n (here n=3) times ,where k is a non-negative int.\nSo for SORTED INPUT TESTCASES 0th element or the 1ST ELEMENT is to be considered PIVOT"
                    }
                ]
            },
            {
                "id": 1844323,
                "content": [
                    {
                        "username": "user8104ko",
                        "content": "Can any one tell me how to do this in o(log n)  in java ?"
                    },
                    {
                        "username": "podalakurisuryaprakash",
                        "content": "it is the complexity of binray search\\n"
                    },
                    {
                        "username": "mskamel",
                        "content": "Can someone tell me why this code/solution doesn\\'t work:\\n\\n\\n `class Solution {\\n    public int search(int[] nums, int target) {\\n        int low = 0;\\n        int high = nums.length;\\n        int pivot = 0;\\n\\n        while (low <= high) {\\n            int mid = low + (high - low) / 2;\\n\\n            if (nums[mid - 1] > nums[mid] && nums[mid + 1] > nums[mid]) {\\n                pivot = mid;\\n                break;\\n            }\\n            else if (nums[mid - 1] < nums[mid] && nums[mid + 1] > nums[mid]) {\\n                high = mid - 1;\\n            }\\n            else if (nums[mid - 1] > nums[mid] && nums[mid + 1] < nums[mid]) {\\n                low = mid;\\n            }\\n        }\\n\\n        if (target > pivot) {\\n            low = pivot;\\n            high = nums.length;\\n\\n            while (low <= high) {\\n                int mid = low + (high - low) / 2;\\n                if (nums[mid] == target) {\\n                    return mid;\\n                }\\n                else if (nums[mid] < target) {\\n                    high = mid - 1;\\n                }\\n                else {\\n                    low = mid;\\n                }\\n            }\\n        }\\n        else if (target < pivot) {\\n            low = pivot;\\n            high = 0;\\n\\n            while (high <= low) {\\n                int mid = high + (low - high) / 2;\\n                if (nums[mid] == target) {\\n                    return mid;\\n                }\\n                else if (nums[mid] < target) {\\n                    low = mid - 1;\\n                }\\n                else {\\n                    high = mid;\\n                }\\n            }\\n        }\\n\\n        return -1;\\n    }\\n}`"
                    },
                    {
                        "username": "bparanj",
                        "content": "The code has several issues:\\n\\n1. `int high = nums.length;` - The \\'high\\' variable is initialized to the length of the array, which is out of range. It should be `nums.length - 1`.\\n\\n2. The while loop `while (low <= high)` can result in an ArrayIndexOutOfBoundsException, as you are not checking if \\'mid\\' is at the ends of the array before accessing `nums[mid - 1]` and `nums[mid + 1]`.\\n\\n3. `if (target > pivot)` and `if (target < pivot)`: Here you\\'re comparing the target with the index \\'pivot\\', not with the value of \\'nums[pivot]\\'.\\n\\n4. In the second part of your code, you\\'re doing two binary searches, one for the case where the target is greater than the pivot value and one where it is smaller. However, in both cases, you are not adjusting the mid value correctly in the while loop.\\n\\nHere is a revised version of your code:\\n\\n```java\\nclass Solution {\\n    public int search(int[] nums, int target) {\\n        int low = 0;\\n        int high = nums.length - 1;\\n        int pivot = 0;\\n        \\n        while (low <= high) {\\n            int mid = low + (high - low) / 2;\\n            if (mid > 0 && mid < nums.length - 1 && nums[mid - 1] > nums[mid] && nums[mid + 1] > nums[mid]) {\\n                pivot = mid;\\n                break;\\n            }\\n            else if (nums[mid] > nums[low]) {\\n                low = mid + 1;\\n            }\\n            else {\\n                high = mid - 1;\\n            }\\n        }\\n        \\n        if (nums[pivot] == target) return pivot;\\n\\n        low = 0;\\n        high = nums.length - 1;\\n        \\n        while (low <= high) {\\n            int mid = low + (high - low) / 2;\\n            if (nums[mid] == target) {\\n                return mid;\\n            }\\n            else if (nums[mid] < target) {\\n                low = mid + 1;\\n            }\\n            else {\\n                high = mid - 1;\\n            }\\n        }\\n        return -1;\\n    }\\n}\\n```\\n\\nThis revised code firstly tries to find the pivot using a modified binary search. Then, it does a binary search on the entire array to find the target. This is not the most efficient solution, as the pivot is not utilized, but it corrects the issues in your original code. \\n\\nIn an optimal solution, once the pivot is found, we should do two binary searches: one from 0 to pivot, and another from pivot+1 to nums.length - 1, depending on the value of the target."
                    },
                    {
                        "username": "Raghav_36",
                        "content": "getting heap-buffer-overflow error in this code..can anyone help??\\n\\nint pivot(int arr[], int n)\\n{\\n    int s = 0;\\n    int e = n - 1;\\n    int mid = (s + e) / 2;\\n    while (s < e)\\n    {\\n        if (arr[mid] >= arr[0])\\n        {\\n            s = mid + 1;\\n        }\\n        else\\n        {\\n            e = mid;\\n        }\\n        mid = (s + e) / 2;\\n    }\\n    return s;\\n}\\nint binary(int arr[], int ele, int s, int e)\\n{\\n    int mid = (s + e) / 2;\\n    while (s <= e)\\n    {\\n        if (arr[mid] == ele)\\n        {\\n            return mid;\\n        }\\n        else if (arr[mid] > ele)\\n        {\\n            e = mid - 1;\\n        }\\n        else\\n        {\\n            s = mid + 1;\\n        }\\n        mid = (s + e) / 2;\\n    }\\n    return -1;\\n}\\nint search(int* nums, int numsSize, int target){\\n    int pi = pivot(nums, numsSize);\\n    if (target >= nums[0] && target <= nums[pi - 1])\\n    {\\n        return binary(nums, target, 0, pi - 1);\\n    }\\n    else\\n    {\\n        return binary(nums, target, pi, numsSize - 1);\\n    }\\n} "
                    },
                    {
                        "username": "bparanj",
                        "content": "The code provided here seems correct in terms of logic for a rotated sorted array, but the error \"heap-buffer-overflow\" typically occurs when you attempt to read or write outside the memory bounds of a heap-allocated variable.\\n\\nThe problem could be arising from the fact that `pi - 1` in the line `if (target >= nums[0] && target <= nums[pi - 1])` can be negative if `pi` is 0. This would happen if the array is already sorted (i.e., not rotated at all), in which case the pivot function would return 0. Accessing `nums[-1]` would result in a heap-buffer-overflow error because it tries to access memory outside the bounds of the array.\\n\\nTo fix this issue, you should add a check for the case when the array is not rotated:\\n\\n```c\\nint search(int* nums, int numsSize, int target){\\n    int pi = pivot(nums, numsSize);\\n    if (pi > 0 && target >= nums[0] && target <= nums[pi - 1]) {\\n        return binary(nums, target, 0, pi - 1);\\n    } else {\\n        return binary(nums, target, pi, numsSize - 1);\\n    }\\n}\\n```\\nAlso, if the target element is not in the array, it\\'s good to handle that case. But this is more related to the problem constraints.\\n\\nPlease try this adjustment and see if it resolves the heap-buffer-overflow error."
                    },
                    {
                        "username": "hendrywiranto",
                        "content": "this one is hard"
                    },
                    {
                        "username": "DEVELOPER_777M",
                        "content": "class Solution(object):\\n    def search(self, nums, target):\\n        if target in nums:\\n            for i in range(len(nums)):\\n                if nums[i] == target:\\n                    return i\\n        else:\\n            return -1\\n```\\nDo you think it\\'s difficult ?"
                    },
                    {
                        "username": "raihandevbd",
                        "content": "Things are broken everywhere, Because bugs are everywhere."
                    },
                    {
                        "username": "Dhruv_Khanna123",
                        "content": "This should be marked as easy. Many \"easy\" problems are tougher than this. "
                    },
                    {
                        "username": "Razzzzzzzzz",
                        "content": "class Solution:\\n    def search(self, nums: List[int], target: int) -> int:\\n        if target in nums:\\n            return nums.index(target)\\n        return -1       \\n \\n"
                    },
                    {
                        "username": "vishesh258",
                        "content": "wht is he use we can just search for target in the nums array and return its index"
                    },
                    {
                        "username": "AmeyDhimte",
                        "content": "Please listen all of you who think a sorted input test case like [1,3,5] is not valid!\nIt IS A VALID INPUT! It is just rotated integral multiple of n number of times.\nSay in this test case 1,3,5 may be rotated via 1(pivot) 0 times, 3 times, 6 times, 9 times, and so on any k*n (here n=3) times ,where k is a non-negative int.\nSo for SORTED INPUT TESTCASES 0th element or the 1ST ELEMENT is to be considered PIVOT"
                    }
                ]
            },
            {
                "id": 1840853,
                "content": [
                    {
                        "username": "user8104ko",
                        "content": "Can any one tell me how to do this in o(log n)  in java ?"
                    },
                    {
                        "username": "podalakurisuryaprakash",
                        "content": "it is the complexity of binray search\\n"
                    },
                    {
                        "username": "mskamel",
                        "content": "Can someone tell me why this code/solution doesn\\'t work:\\n\\n\\n `class Solution {\\n    public int search(int[] nums, int target) {\\n        int low = 0;\\n        int high = nums.length;\\n        int pivot = 0;\\n\\n        while (low <= high) {\\n            int mid = low + (high - low) / 2;\\n\\n            if (nums[mid - 1] > nums[mid] && nums[mid + 1] > nums[mid]) {\\n                pivot = mid;\\n                break;\\n            }\\n            else if (nums[mid - 1] < nums[mid] && nums[mid + 1] > nums[mid]) {\\n                high = mid - 1;\\n            }\\n            else if (nums[mid - 1] > nums[mid] && nums[mid + 1] < nums[mid]) {\\n                low = mid;\\n            }\\n        }\\n\\n        if (target > pivot) {\\n            low = pivot;\\n            high = nums.length;\\n\\n            while (low <= high) {\\n                int mid = low + (high - low) / 2;\\n                if (nums[mid] == target) {\\n                    return mid;\\n                }\\n                else if (nums[mid] < target) {\\n                    high = mid - 1;\\n                }\\n                else {\\n                    low = mid;\\n                }\\n            }\\n        }\\n        else if (target < pivot) {\\n            low = pivot;\\n            high = 0;\\n\\n            while (high <= low) {\\n                int mid = high + (low - high) / 2;\\n                if (nums[mid] == target) {\\n                    return mid;\\n                }\\n                else if (nums[mid] < target) {\\n                    low = mid - 1;\\n                }\\n                else {\\n                    high = mid;\\n                }\\n            }\\n        }\\n\\n        return -1;\\n    }\\n}`"
                    },
                    {
                        "username": "bparanj",
                        "content": "The code has several issues:\\n\\n1. `int high = nums.length;` - The \\'high\\' variable is initialized to the length of the array, which is out of range. It should be `nums.length - 1`.\\n\\n2. The while loop `while (low <= high)` can result in an ArrayIndexOutOfBoundsException, as you are not checking if \\'mid\\' is at the ends of the array before accessing `nums[mid - 1]` and `nums[mid + 1]`.\\n\\n3. `if (target > pivot)` and `if (target < pivot)`: Here you\\'re comparing the target with the index \\'pivot\\', not with the value of \\'nums[pivot]\\'.\\n\\n4. In the second part of your code, you\\'re doing two binary searches, one for the case where the target is greater than the pivot value and one where it is smaller. However, in both cases, you are not adjusting the mid value correctly in the while loop.\\n\\nHere is a revised version of your code:\\n\\n```java\\nclass Solution {\\n    public int search(int[] nums, int target) {\\n        int low = 0;\\n        int high = nums.length - 1;\\n        int pivot = 0;\\n        \\n        while (low <= high) {\\n            int mid = low + (high - low) / 2;\\n            if (mid > 0 && mid < nums.length - 1 && nums[mid - 1] > nums[mid] && nums[mid + 1] > nums[mid]) {\\n                pivot = mid;\\n                break;\\n            }\\n            else if (nums[mid] > nums[low]) {\\n                low = mid + 1;\\n            }\\n            else {\\n                high = mid - 1;\\n            }\\n        }\\n        \\n        if (nums[pivot] == target) return pivot;\\n\\n        low = 0;\\n        high = nums.length - 1;\\n        \\n        while (low <= high) {\\n            int mid = low + (high - low) / 2;\\n            if (nums[mid] == target) {\\n                return mid;\\n            }\\n            else if (nums[mid] < target) {\\n                low = mid + 1;\\n            }\\n            else {\\n                high = mid - 1;\\n            }\\n        }\\n        return -1;\\n    }\\n}\\n```\\n\\nThis revised code firstly tries to find the pivot using a modified binary search. Then, it does a binary search on the entire array to find the target. This is not the most efficient solution, as the pivot is not utilized, but it corrects the issues in your original code. \\n\\nIn an optimal solution, once the pivot is found, we should do two binary searches: one from 0 to pivot, and another from pivot+1 to nums.length - 1, depending on the value of the target."
                    },
                    {
                        "username": "Raghav_36",
                        "content": "getting heap-buffer-overflow error in this code..can anyone help??\\n\\nint pivot(int arr[], int n)\\n{\\n    int s = 0;\\n    int e = n - 1;\\n    int mid = (s + e) / 2;\\n    while (s < e)\\n    {\\n        if (arr[mid] >= arr[0])\\n        {\\n            s = mid + 1;\\n        }\\n        else\\n        {\\n            e = mid;\\n        }\\n        mid = (s + e) / 2;\\n    }\\n    return s;\\n}\\nint binary(int arr[], int ele, int s, int e)\\n{\\n    int mid = (s + e) / 2;\\n    while (s <= e)\\n    {\\n        if (arr[mid] == ele)\\n        {\\n            return mid;\\n        }\\n        else if (arr[mid] > ele)\\n        {\\n            e = mid - 1;\\n        }\\n        else\\n        {\\n            s = mid + 1;\\n        }\\n        mid = (s + e) / 2;\\n    }\\n    return -1;\\n}\\nint search(int* nums, int numsSize, int target){\\n    int pi = pivot(nums, numsSize);\\n    if (target >= nums[0] && target <= nums[pi - 1])\\n    {\\n        return binary(nums, target, 0, pi - 1);\\n    }\\n    else\\n    {\\n        return binary(nums, target, pi, numsSize - 1);\\n    }\\n} "
                    },
                    {
                        "username": "bparanj",
                        "content": "The code provided here seems correct in terms of logic for a rotated sorted array, but the error \"heap-buffer-overflow\" typically occurs when you attempt to read or write outside the memory bounds of a heap-allocated variable.\\n\\nThe problem could be arising from the fact that `pi - 1` in the line `if (target >= nums[0] && target <= nums[pi - 1])` can be negative if `pi` is 0. This would happen if the array is already sorted (i.e., not rotated at all), in which case the pivot function would return 0. Accessing `nums[-1]` would result in a heap-buffer-overflow error because it tries to access memory outside the bounds of the array.\\n\\nTo fix this issue, you should add a check for the case when the array is not rotated:\\n\\n```c\\nint search(int* nums, int numsSize, int target){\\n    int pi = pivot(nums, numsSize);\\n    if (pi > 0 && target >= nums[0] && target <= nums[pi - 1]) {\\n        return binary(nums, target, 0, pi - 1);\\n    } else {\\n        return binary(nums, target, pi, numsSize - 1);\\n    }\\n}\\n```\\nAlso, if the target element is not in the array, it\\'s good to handle that case. But this is more related to the problem constraints.\\n\\nPlease try this adjustment and see if it resolves the heap-buffer-overflow error."
                    },
                    {
                        "username": "hendrywiranto",
                        "content": "this one is hard"
                    },
                    {
                        "username": "DEVELOPER_777M",
                        "content": "class Solution(object):\\n    def search(self, nums, target):\\n        if target in nums:\\n            for i in range(len(nums)):\\n                if nums[i] == target:\\n                    return i\\n        else:\\n            return -1\\n```\\nDo you think it\\'s difficult ?"
                    },
                    {
                        "username": "raihandevbd",
                        "content": "Things are broken everywhere, Because bugs are everywhere."
                    },
                    {
                        "username": "Dhruv_Khanna123",
                        "content": "This should be marked as easy. Many \"easy\" problems are tougher than this. "
                    },
                    {
                        "username": "Razzzzzzzzz",
                        "content": "class Solution:\\n    def search(self, nums: List[int], target: int) -> int:\\n        if target in nums:\\n            return nums.index(target)\\n        return -1       \\n \\n"
                    },
                    {
                        "username": "vishesh258",
                        "content": "wht is he use we can just search for target in the nums array and return its index"
                    },
                    {
                        "username": "AmeyDhimte",
                        "content": "Please listen all of you who think a sorted input test case like [1,3,5] is not valid!\nIt IS A VALID INPUT! It is just rotated integral multiple of n number of times.\nSay in this test case 1,3,5 may be rotated via 1(pivot) 0 times, 3 times, 6 times, 9 times, and so on any k*n (here n=3) times ,where k is a non-negative int.\nSo for SORTED INPUT TESTCASES 0th element or the 1ST ELEMENT is to be considered PIVOT"
                    }
                ]
            },
            {
                "id": 1836540,
                "content": [
                    {
                        "username": "user8104ko",
                        "content": "Can any one tell me how to do this in o(log n)  in java ?"
                    },
                    {
                        "username": "podalakurisuryaprakash",
                        "content": "it is the complexity of binray search\\n"
                    },
                    {
                        "username": "mskamel",
                        "content": "Can someone tell me why this code/solution doesn\\'t work:\\n\\n\\n `class Solution {\\n    public int search(int[] nums, int target) {\\n        int low = 0;\\n        int high = nums.length;\\n        int pivot = 0;\\n\\n        while (low <= high) {\\n            int mid = low + (high - low) / 2;\\n\\n            if (nums[mid - 1] > nums[mid] && nums[mid + 1] > nums[mid]) {\\n                pivot = mid;\\n                break;\\n            }\\n            else if (nums[mid - 1] < nums[mid] && nums[mid + 1] > nums[mid]) {\\n                high = mid - 1;\\n            }\\n            else if (nums[mid - 1] > nums[mid] && nums[mid + 1] < nums[mid]) {\\n                low = mid;\\n            }\\n        }\\n\\n        if (target > pivot) {\\n            low = pivot;\\n            high = nums.length;\\n\\n            while (low <= high) {\\n                int mid = low + (high - low) / 2;\\n                if (nums[mid] == target) {\\n                    return mid;\\n                }\\n                else if (nums[mid] < target) {\\n                    high = mid - 1;\\n                }\\n                else {\\n                    low = mid;\\n                }\\n            }\\n        }\\n        else if (target < pivot) {\\n            low = pivot;\\n            high = 0;\\n\\n            while (high <= low) {\\n                int mid = high + (low - high) / 2;\\n                if (nums[mid] == target) {\\n                    return mid;\\n                }\\n                else if (nums[mid] < target) {\\n                    low = mid - 1;\\n                }\\n                else {\\n                    high = mid;\\n                }\\n            }\\n        }\\n\\n        return -1;\\n    }\\n}`"
                    },
                    {
                        "username": "bparanj",
                        "content": "The code has several issues:\\n\\n1. `int high = nums.length;` - The \\'high\\' variable is initialized to the length of the array, which is out of range. It should be `nums.length - 1`.\\n\\n2. The while loop `while (low <= high)` can result in an ArrayIndexOutOfBoundsException, as you are not checking if \\'mid\\' is at the ends of the array before accessing `nums[mid - 1]` and `nums[mid + 1]`.\\n\\n3. `if (target > pivot)` and `if (target < pivot)`: Here you\\'re comparing the target with the index \\'pivot\\', not with the value of \\'nums[pivot]\\'.\\n\\n4. In the second part of your code, you\\'re doing two binary searches, one for the case where the target is greater than the pivot value and one where it is smaller. However, in both cases, you are not adjusting the mid value correctly in the while loop.\\n\\nHere is a revised version of your code:\\n\\n```java\\nclass Solution {\\n    public int search(int[] nums, int target) {\\n        int low = 0;\\n        int high = nums.length - 1;\\n        int pivot = 0;\\n        \\n        while (low <= high) {\\n            int mid = low + (high - low) / 2;\\n            if (mid > 0 && mid < nums.length - 1 && nums[mid - 1] > nums[mid] && nums[mid + 1] > nums[mid]) {\\n                pivot = mid;\\n                break;\\n            }\\n            else if (nums[mid] > nums[low]) {\\n                low = mid + 1;\\n            }\\n            else {\\n                high = mid - 1;\\n            }\\n        }\\n        \\n        if (nums[pivot] == target) return pivot;\\n\\n        low = 0;\\n        high = nums.length - 1;\\n        \\n        while (low <= high) {\\n            int mid = low + (high - low) / 2;\\n            if (nums[mid] == target) {\\n                return mid;\\n            }\\n            else if (nums[mid] < target) {\\n                low = mid + 1;\\n            }\\n            else {\\n                high = mid - 1;\\n            }\\n        }\\n        return -1;\\n    }\\n}\\n```\\n\\nThis revised code firstly tries to find the pivot using a modified binary search. Then, it does a binary search on the entire array to find the target. This is not the most efficient solution, as the pivot is not utilized, but it corrects the issues in your original code. \\n\\nIn an optimal solution, once the pivot is found, we should do two binary searches: one from 0 to pivot, and another from pivot+1 to nums.length - 1, depending on the value of the target."
                    },
                    {
                        "username": "Raghav_36",
                        "content": "getting heap-buffer-overflow error in this code..can anyone help??\\n\\nint pivot(int arr[], int n)\\n{\\n    int s = 0;\\n    int e = n - 1;\\n    int mid = (s + e) / 2;\\n    while (s < e)\\n    {\\n        if (arr[mid] >= arr[0])\\n        {\\n            s = mid + 1;\\n        }\\n        else\\n        {\\n            e = mid;\\n        }\\n        mid = (s + e) / 2;\\n    }\\n    return s;\\n}\\nint binary(int arr[], int ele, int s, int e)\\n{\\n    int mid = (s + e) / 2;\\n    while (s <= e)\\n    {\\n        if (arr[mid] == ele)\\n        {\\n            return mid;\\n        }\\n        else if (arr[mid] > ele)\\n        {\\n            e = mid - 1;\\n        }\\n        else\\n        {\\n            s = mid + 1;\\n        }\\n        mid = (s + e) / 2;\\n    }\\n    return -1;\\n}\\nint search(int* nums, int numsSize, int target){\\n    int pi = pivot(nums, numsSize);\\n    if (target >= nums[0] && target <= nums[pi - 1])\\n    {\\n        return binary(nums, target, 0, pi - 1);\\n    }\\n    else\\n    {\\n        return binary(nums, target, pi, numsSize - 1);\\n    }\\n} "
                    },
                    {
                        "username": "bparanj",
                        "content": "The code provided here seems correct in terms of logic for a rotated sorted array, but the error \"heap-buffer-overflow\" typically occurs when you attempt to read or write outside the memory bounds of a heap-allocated variable.\\n\\nThe problem could be arising from the fact that `pi - 1` in the line `if (target >= nums[0] && target <= nums[pi - 1])` can be negative if `pi` is 0. This would happen if the array is already sorted (i.e., not rotated at all), in which case the pivot function would return 0. Accessing `nums[-1]` would result in a heap-buffer-overflow error because it tries to access memory outside the bounds of the array.\\n\\nTo fix this issue, you should add a check for the case when the array is not rotated:\\n\\n```c\\nint search(int* nums, int numsSize, int target){\\n    int pi = pivot(nums, numsSize);\\n    if (pi > 0 && target >= nums[0] && target <= nums[pi - 1]) {\\n        return binary(nums, target, 0, pi - 1);\\n    } else {\\n        return binary(nums, target, pi, numsSize - 1);\\n    }\\n}\\n```\\nAlso, if the target element is not in the array, it\\'s good to handle that case. But this is more related to the problem constraints.\\n\\nPlease try this adjustment and see if it resolves the heap-buffer-overflow error."
                    },
                    {
                        "username": "hendrywiranto",
                        "content": "this one is hard"
                    },
                    {
                        "username": "DEVELOPER_777M",
                        "content": "class Solution(object):\\n    def search(self, nums, target):\\n        if target in nums:\\n            for i in range(len(nums)):\\n                if nums[i] == target:\\n                    return i\\n        else:\\n            return -1\\n```\\nDo you think it\\'s difficult ?"
                    },
                    {
                        "username": "raihandevbd",
                        "content": "Things are broken everywhere, Because bugs are everywhere."
                    },
                    {
                        "username": "Dhruv_Khanna123",
                        "content": "This should be marked as easy. Many \"easy\" problems are tougher than this. "
                    },
                    {
                        "username": "Razzzzzzzzz",
                        "content": "class Solution:\\n    def search(self, nums: List[int], target: int) -> int:\\n        if target in nums:\\n            return nums.index(target)\\n        return -1       \\n \\n"
                    },
                    {
                        "username": "vishesh258",
                        "content": "wht is he use we can just search for target in the nums array and return its index"
                    },
                    {
                        "username": "AmeyDhimte",
                        "content": "Please listen all of you who think a sorted input test case like [1,3,5] is not valid!\nIt IS A VALID INPUT! It is just rotated integral multiple of n number of times.\nSay in this test case 1,3,5 may be rotated via 1(pivot) 0 times, 3 times, 6 times, 9 times, and so on any k*n (here n=3) times ,where k is a non-negative int.\nSo for SORTED INPUT TESTCASES 0th element or the 1ST ELEMENT is to be considered PIVOT"
                    }
                ]
            },
            {
                "id": 1827179,
                "content": [
                    {
                        "username": "user8104ko",
                        "content": "Can any one tell me how to do this in o(log n)  in java ?"
                    },
                    {
                        "username": "podalakurisuryaprakash",
                        "content": "it is the complexity of binray search\\n"
                    },
                    {
                        "username": "mskamel",
                        "content": "Can someone tell me why this code/solution doesn\\'t work:\\n\\n\\n `class Solution {\\n    public int search(int[] nums, int target) {\\n        int low = 0;\\n        int high = nums.length;\\n        int pivot = 0;\\n\\n        while (low <= high) {\\n            int mid = low + (high - low) / 2;\\n\\n            if (nums[mid - 1] > nums[mid] && nums[mid + 1] > nums[mid]) {\\n                pivot = mid;\\n                break;\\n            }\\n            else if (nums[mid - 1] < nums[mid] && nums[mid + 1] > nums[mid]) {\\n                high = mid - 1;\\n            }\\n            else if (nums[mid - 1] > nums[mid] && nums[mid + 1] < nums[mid]) {\\n                low = mid;\\n            }\\n        }\\n\\n        if (target > pivot) {\\n            low = pivot;\\n            high = nums.length;\\n\\n            while (low <= high) {\\n                int mid = low + (high - low) / 2;\\n                if (nums[mid] == target) {\\n                    return mid;\\n                }\\n                else if (nums[mid] < target) {\\n                    high = mid - 1;\\n                }\\n                else {\\n                    low = mid;\\n                }\\n            }\\n        }\\n        else if (target < pivot) {\\n            low = pivot;\\n            high = 0;\\n\\n            while (high <= low) {\\n                int mid = high + (low - high) / 2;\\n                if (nums[mid] == target) {\\n                    return mid;\\n                }\\n                else if (nums[mid] < target) {\\n                    low = mid - 1;\\n                }\\n                else {\\n                    high = mid;\\n                }\\n            }\\n        }\\n\\n        return -1;\\n    }\\n}`"
                    },
                    {
                        "username": "bparanj",
                        "content": "The code has several issues:\\n\\n1. `int high = nums.length;` - The \\'high\\' variable is initialized to the length of the array, which is out of range. It should be `nums.length - 1`.\\n\\n2. The while loop `while (low <= high)` can result in an ArrayIndexOutOfBoundsException, as you are not checking if \\'mid\\' is at the ends of the array before accessing `nums[mid - 1]` and `nums[mid + 1]`.\\n\\n3. `if (target > pivot)` and `if (target < pivot)`: Here you\\'re comparing the target with the index \\'pivot\\', not with the value of \\'nums[pivot]\\'.\\n\\n4. In the second part of your code, you\\'re doing two binary searches, one for the case where the target is greater than the pivot value and one where it is smaller. However, in both cases, you are not adjusting the mid value correctly in the while loop.\\n\\nHere is a revised version of your code:\\n\\n```java\\nclass Solution {\\n    public int search(int[] nums, int target) {\\n        int low = 0;\\n        int high = nums.length - 1;\\n        int pivot = 0;\\n        \\n        while (low <= high) {\\n            int mid = low + (high - low) / 2;\\n            if (mid > 0 && mid < nums.length - 1 && nums[mid - 1] > nums[mid] && nums[mid + 1] > nums[mid]) {\\n                pivot = mid;\\n                break;\\n            }\\n            else if (nums[mid] > nums[low]) {\\n                low = mid + 1;\\n            }\\n            else {\\n                high = mid - 1;\\n            }\\n        }\\n        \\n        if (nums[pivot] == target) return pivot;\\n\\n        low = 0;\\n        high = nums.length - 1;\\n        \\n        while (low <= high) {\\n            int mid = low + (high - low) / 2;\\n            if (nums[mid] == target) {\\n                return mid;\\n            }\\n            else if (nums[mid] < target) {\\n                low = mid + 1;\\n            }\\n            else {\\n                high = mid - 1;\\n            }\\n        }\\n        return -1;\\n    }\\n}\\n```\\n\\nThis revised code firstly tries to find the pivot using a modified binary search. Then, it does a binary search on the entire array to find the target. This is not the most efficient solution, as the pivot is not utilized, but it corrects the issues in your original code. \\n\\nIn an optimal solution, once the pivot is found, we should do two binary searches: one from 0 to pivot, and another from pivot+1 to nums.length - 1, depending on the value of the target."
                    },
                    {
                        "username": "Raghav_36",
                        "content": "getting heap-buffer-overflow error in this code..can anyone help??\\n\\nint pivot(int arr[], int n)\\n{\\n    int s = 0;\\n    int e = n - 1;\\n    int mid = (s + e) / 2;\\n    while (s < e)\\n    {\\n        if (arr[mid] >= arr[0])\\n        {\\n            s = mid + 1;\\n        }\\n        else\\n        {\\n            e = mid;\\n        }\\n        mid = (s + e) / 2;\\n    }\\n    return s;\\n}\\nint binary(int arr[], int ele, int s, int e)\\n{\\n    int mid = (s + e) / 2;\\n    while (s <= e)\\n    {\\n        if (arr[mid] == ele)\\n        {\\n            return mid;\\n        }\\n        else if (arr[mid] > ele)\\n        {\\n            e = mid - 1;\\n        }\\n        else\\n        {\\n            s = mid + 1;\\n        }\\n        mid = (s + e) / 2;\\n    }\\n    return -1;\\n}\\nint search(int* nums, int numsSize, int target){\\n    int pi = pivot(nums, numsSize);\\n    if (target >= nums[0] && target <= nums[pi - 1])\\n    {\\n        return binary(nums, target, 0, pi - 1);\\n    }\\n    else\\n    {\\n        return binary(nums, target, pi, numsSize - 1);\\n    }\\n} "
                    },
                    {
                        "username": "bparanj",
                        "content": "The code provided here seems correct in terms of logic for a rotated sorted array, but the error \"heap-buffer-overflow\" typically occurs when you attempt to read or write outside the memory bounds of a heap-allocated variable.\\n\\nThe problem could be arising from the fact that `pi - 1` in the line `if (target >= nums[0] && target <= nums[pi - 1])` can be negative if `pi` is 0. This would happen if the array is already sorted (i.e., not rotated at all), in which case the pivot function would return 0. Accessing `nums[-1]` would result in a heap-buffer-overflow error because it tries to access memory outside the bounds of the array.\\n\\nTo fix this issue, you should add a check for the case when the array is not rotated:\\n\\n```c\\nint search(int* nums, int numsSize, int target){\\n    int pi = pivot(nums, numsSize);\\n    if (pi > 0 && target >= nums[0] && target <= nums[pi - 1]) {\\n        return binary(nums, target, 0, pi - 1);\\n    } else {\\n        return binary(nums, target, pi, numsSize - 1);\\n    }\\n}\\n```\\nAlso, if the target element is not in the array, it\\'s good to handle that case. But this is more related to the problem constraints.\\n\\nPlease try this adjustment and see if it resolves the heap-buffer-overflow error."
                    },
                    {
                        "username": "hendrywiranto",
                        "content": "this one is hard"
                    },
                    {
                        "username": "DEVELOPER_777M",
                        "content": "class Solution(object):\\n    def search(self, nums, target):\\n        if target in nums:\\n            for i in range(len(nums)):\\n                if nums[i] == target:\\n                    return i\\n        else:\\n            return -1\\n```\\nDo you think it\\'s difficult ?"
                    },
                    {
                        "username": "raihandevbd",
                        "content": "Things are broken everywhere, Because bugs are everywhere."
                    },
                    {
                        "username": "Dhruv_Khanna123",
                        "content": "This should be marked as easy. Many \"easy\" problems are tougher than this. "
                    },
                    {
                        "username": "Razzzzzzzzz",
                        "content": "class Solution:\\n    def search(self, nums: List[int], target: int) -> int:\\n        if target in nums:\\n            return nums.index(target)\\n        return -1       \\n \\n"
                    },
                    {
                        "username": "vishesh258",
                        "content": "wht is he use we can just search for target in the nums array and return its index"
                    },
                    {
                        "username": "AmeyDhimte",
                        "content": "Please listen all of you who think a sorted input test case like [1,3,5] is not valid!\nIt IS A VALID INPUT! It is just rotated integral multiple of n number of times.\nSay in this test case 1,3,5 may be rotated via 1(pivot) 0 times, 3 times, 6 times, 9 times, and so on any k*n (here n=3) times ,where k is a non-negative int.\nSo for SORTED INPUT TESTCASES 0th element or the 1ST ELEMENT is to be considered PIVOT"
                    }
                ]
            },
            {
                "id": 1812434,
                "content": [
                    {
                        "username": "Shivam_Tyagi_G",
                        "content": "Beat 100% solutions\\nclass Solution {\\n    int solve(vector<int> &arr)\\n    {\\n        int low = 0;\\n        int n = arr.size()-1;\\n        int high = n;\\n        int mid;\\n        while(low<high)\\n        {\\n            mid = low+(high-low)/2;\\n            if(arr[mid] < arr[n])\\n            {\\n                high = mid;\\n            }\\n            else{\\n                low = mid+1;\\n            }\\n        }\\n        return low;\\n    }\\npublic:\\n    int search(vector<int>& arr, int target) {\\n        int pivot = solve(arr);\\n    int n = arr.size() - 1;\\n    int low, high;\\n    if (target <= arr[n]){\\n        low = pivot;\\n        high = n;\\n    }\\n    else{\\n        low = 0;\\n        high = pivot-1;\\n    }\\n    cout<<pivot<<endl;\\n    while(low<=high)\\n    {\\n        int mid = low+(high-low)/2;\\n        if(arr[mid] == target)\\n        {\\n            return mid;\\n        }\\n        else if(arr[mid] > target){\\n            high = mid-1;\\n        }\\n        else{\\n            low = mid+1;\\n        }\\n    }\\n    return -1;\\n    }\\n};"
                    },
                    {
                        "username": "Mit_Bhardiwala",
                        "content": "The concept is primarily of binary search. First we  need to find pivot index and then search target according to its value. Else it also passes for normal inbuilt search functions(which u should not try)."
                    },
                    {
                        "username": "YashuCoder",
                        "content": "This question really fucked me up . I had literally tried to change the binary search and tried to get the answer in O(logn) . But it did not happen . At last for fun I tried simple linear search it worked and beaten 70% lol . Wtf"
                    },
                    {
                        "username": "TiagoMendees",
                        "content": "Am i confused or is this problem too simple? Like i just used brute force by using a for loop and check if  ```nums[i] == target ```, if it was true return i, if nums doesn't contains target return -1.\n ```\n        for (size_t i = 0; i < nums.size(); i++)\n        {\n           if(nums[i] == target ) return i;\n        }\n        \n        return -1;\n```\n\nThis worked for me"
                    },
                    {
                        "username": "prasannapoola",
                        "content": "I covered all the ways that be able to go through left and right side of the array.\\nIf we don\\'t go for right side( left = mid +1 ) of array then there might be a chance target element present in left side of array. \\nI felt that conditions are too long but I don\\'t find other way.\\n\\n public int search(int[] nums, int target) {\\n        int left = 0;\\n        int right = nums.length-1;\\n        int mid = -1;\\n        boolean found = false;\\n        while(left<=right){\\n            mid = (left+right)/2;\\n            if(nums[mid]==target){\\n                found = true;\\n                break;\\n            }\\n            else if((target>nums[mid] && nums[left]<nums[right]) || (target<nums[mid] && nums[left]>nums[right] && nums[left]>target && nums[left]<=nums[mid] ) || (target>nums[mid] && nums[left]>target) || (target > nums[mid] && nums[mid]>nums[left])){\\n                left = mid + 1;\\n            }\\n            else{\\n                right = mid - 1;\\n            }\\n        }\\n        return (found)?mid:-1;\\n    }\\n"
                    },
                    {
                        "username": "bparanj",
                        "content": "Your code seems correct, but it is indeed a bit convoluted. In a coding interview, readability and simplicity are often as important as correctness. This means that the ideal solution is not only correct but also easy to understand.\\n\\nLet\\'s critique your solution:\\n\\n1. **Complex conditions:** The conditions inside your if and else if blocks are quite complex. This not only makes the code hard to read and understand, but also prone to errors. It would be better to break these conditions down into separate if else blocks with clear comments explaining the logic.\\n\\n2. **Use of found flag:** The boolean flag \"found\" is not necessary. You can just return `mid` from within the loop when you find the target.\\n\\n3. **Variable Naming:** It would be better to name your variables according to what they represent. For example, `left` and `right` could be `low` and `high`, which might more clearly represent the lower and upper bounds of the search range.\\n\\n4. **Code Comments:** Your code lacks comments, which would be useful in explaining the logic, especially when the condition checks are complex.\\n\\nHere\\'s a simpler version of a binary search algorithm on a rotated sorted array:\\n\\n```java\\npublic int search(int[] nums, int target) {\\n    int low = 0, high = nums.length - 1;\\n    while (low <= high) {\\n        int mid = (low + high) / 2;\\n        if (nums[mid] == target) return mid;\\n\\n        if (nums[low] <= nums[mid]) { // left half is sorted\\n            if (nums[low] <= target && target < nums[mid]) high = mid - 1; // target is in left half\\n            else low = mid + 1; // target is in right half\\n        } \\n        else { // right half is sorted\\n            if (nums[mid] < target && target <= nums[high]) low = mid + 1; // target is in right half\\n            else high = mid - 1; // target is in left half\\n        }\\n    }\\n    return -1;\\n}\\n```\\nThis code is more readable, shorter, and it accomplishes the same goal. It divides the array into two halves, checks which half is sorted, and determines which half the target could be in. Then, it repeats the process for that half."
                    },
                    {
                        "username": "Nobody_cares",
                        "content": "Why I am getting \\'-1\\' for the input [4,5,6,0,1,2] for the following code:\\nclass Solution {\\npublic:\\n    int search(vector<int>& nums, int target) {\\n        int n=nums.size(), ans;\\n        \\n        int start=0, end=n-1;\\n        if(nums[end]>nums[start]){\\n            ans=nums[start];\\n        }\\n        else{\\n            bool found=false;\\n            while(start<=end){\\n                int mid=start+(end-start)/2;\\n                if(nums[mid]==target){\\n                    found=true;\\n                    ans=mid;\\n                    break;\\n                }\\n                else if(nums[mid]>target){\\n                    start=mid+1;\\n                }\\n                else{\\n                    end=mid-1;\\n                }\\n            }\\n            if(!found) ans=-1;\\n            \\n        }\\n        return ans;\\n    }\\n};"
                    },
                    {
                        "username": "bparanj",
                        "content": "Your current implementation is wrong because it assumes that the array is always sorted in descending order and that if it\\'s not, it must be a rotated array.\\n\\nHowever, the array can be a regular sorted array (ascending order), or a rotated sorted array. Also, you have mistakenly assigned the `ans=nums[start];` when the `nums[end]>nums[start]` which means the array is in ascending order. In this case, you\\'re not actually performing a search but returning the first element of the array, which is wrong.\\n\\nMoreover, the logic of your binary search inside the `else` statement is flawed. The condition `else if(nums[mid]>target)` implies that if the middle element is greater than the target, you should look to the right side of the array (increasing `start`), which is incorrect. When the middle element is greater, we need to look to the left side (decreasing `end`).\\n\\nThe corrected code should look like:\\n\\n```cpp\\nclass Solution {\\npublic:\\n    int search(vector<int>& nums, int target) {\\n        int n=nums.size();\\n\\n        int start=0, end=n-1;\\n        while(start<=end){\\n            int mid=start+(end-start)/2;\\n            if(nums[mid]==target){\\n                return mid;\\n            }\\n            // Determine which half to go, left half is sorted\\n            else if(nums[start] <= nums[mid]){\\n                if(target >= nums[start] && target < nums[mid]){\\n                    end = mid - 1;\\n                }else{\\n                    start = mid + 1;\\n                }\\n            }\\n            // Right half is sorted\\n            else{\\n                if(target > nums[mid] && target <= nums[end]){\\n                    start = mid + 1;\\n                }else{\\n                    end = mid - 1;\\n                }\\n            }\\n        }\\n        return -1;\\n    }\\n};\\n```\\n\\nThis code performs a binary search checking which half is sorted and whether the target falls into that half or not. Then it adjusts the `start` and `end` pointers accordingly and repeats until the target is found or the search space is empty.\\n"
                    },
                    {
                        "username": "Ragavan2003",
                        "content": "I think I miss the intention of the question ,I can use linear search and still get all test case passed.\\nIs the intention is too mislead you to think too much?."
                    },
                    {
                        "username": "deepak_guptacoder-369",
                        "content": "class Solution {\\npublic:\\n    int search(vector<int>& nums, int target) {\\n        int left = 0, right = nums.size() - 1;\\n        while (left <= right) {\\n            int mid = left + (right - left) / 2;\\n            if (nums[mid] == target) return mid;\\n            if (nums[left] <= nums[mid]) {\\n                if (nums[left] <= target && target < nums[mid]) right = mid - 1;\\n                else left = mid + 1;\\n            } else {\\n                if (nums[mid] < target && target <= nums[right]) left = mid + 1;\\n                else right = mid - 1;\\n            }\\n        }\\n        return -1;\\n    }\\n};\\n"
                    },
                    {
                        "username": "ashutoshbhardwaj25122000",
                        "content": "Idea here is basically that if we keep breaking the array into two halves, then either the left array will be ordered or right array will be ordered. If the target value lies in the ordered half, then our further finding is restricted to this portion, otherwise it will get restricted to the other portion which is unordered. Doing this recursively, we will be able to find the index of target."
                    },
                    {
                        "username": "satyam_rai15",
                        "content": "The question is pointless as it doesn\\'t give TLE for O(N) solutions"
                    }
                ]
            },
            {
                "id": 1809646,
                "content": [
                    {
                        "username": "Shivam_Tyagi_G",
                        "content": "Beat 100% solutions\\nclass Solution {\\n    int solve(vector<int> &arr)\\n    {\\n        int low = 0;\\n        int n = arr.size()-1;\\n        int high = n;\\n        int mid;\\n        while(low<high)\\n        {\\n            mid = low+(high-low)/2;\\n            if(arr[mid] < arr[n])\\n            {\\n                high = mid;\\n            }\\n            else{\\n                low = mid+1;\\n            }\\n        }\\n        return low;\\n    }\\npublic:\\n    int search(vector<int>& arr, int target) {\\n        int pivot = solve(arr);\\n    int n = arr.size() - 1;\\n    int low, high;\\n    if (target <= arr[n]){\\n        low = pivot;\\n        high = n;\\n    }\\n    else{\\n        low = 0;\\n        high = pivot-1;\\n    }\\n    cout<<pivot<<endl;\\n    while(low<=high)\\n    {\\n        int mid = low+(high-low)/2;\\n        if(arr[mid] == target)\\n        {\\n            return mid;\\n        }\\n        else if(arr[mid] > target){\\n            high = mid-1;\\n        }\\n        else{\\n            low = mid+1;\\n        }\\n    }\\n    return -1;\\n    }\\n};"
                    },
                    {
                        "username": "Mit_Bhardiwala",
                        "content": "The concept is primarily of binary search. First we  need to find pivot index and then search target according to its value. Else it also passes for normal inbuilt search functions(which u should not try)."
                    },
                    {
                        "username": "YashuCoder",
                        "content": "This question really fucked me up . I had literally tried to change the binary search and tried to get the answer in O(logn) . But it did not happen . At last for fun I tried simple linear search it worked and beaten 70% lol . Wtf"
                    },
                    {
                        "username": "TiagoMendees",
                        "content": "Am i confused or is this problem too simple? Like i just used brute force by using a for loop and check if  ```nums[i] == target ```, if it was true return i, if nums doesn't contains target return -1.\n ```\n        for (size_t i = 0; i < nums.size(); i++)\n        {\n           if(nums[i] == target ) return i;\n        }\n        \n        return -1;\n```\n\nThis worked for me"
                    },
                    {
                        "username": "prasannapoola",
                        "content": "I covered all the ways that be able to go through left and right side of the array.\\nIf we don\\'t go for right side( left = mid +1 ) of array then there might be a chance target element present in left side of array. \\nI felt that conditions are too long but I don\\'t find other way.\\n\\n public int search(int[] nums, int target) {\\n        int left = 0;\\n        int right = nums.length-1;\\n        int mid = -1;\\n        boolean found = false;\\n        while(left<=right){\\n            mid = (left+right)/2;\\n            if(nums[mid]==target){\\n                found = true;\\n                break;\\n            }\\n            else if((target>nums[mid] && nums[left]<nums[right]) || (target<nums[mid] && nums[left]>nums[right] && nums[left]>target && nums[left]<=nums[mid] ) || (target>nums[mid] && nums[left]>target) || (target > nums[mid] && nums[mid]>nums[left])){\\n                left = mid + 1;\\n            }\\n            else{\\n                right = mid - 1;\\n            }\\n        }\\n        return (found)?mid:-1;\\n    }\\n"
                    },
                    {
                        "username": "bparanj",
                        "content": "Your code seems correct, but it is indeed a bit convoluted. In a coding interview, readability and simplicity are often as important as correctness. This means that the ideal solution is not only correct but also easy to understand.\\n\\nLet\\'s critique your solution:\\n\\n1. **Complex conditions:** The conditions inside your if and else if blocks are quite complex. This not only makes the code hard to read and understand, but also prone to errors. It would be better to break these conditions down into separate if else blocks with clear comments explaining the logic.\\n\\n2. **Use of found flag:** The boolean flag \"found\" is not necessary. You can just return `mid` from within the loop when you find the target.\\n\\n3. **Variable Naming:** It would be better to name your variables according to what they represent. For example, `left` and `right` could be `low` and `high`, which might more clearly represent the lower and upper bounds of the search range.\\n\\n4. **Code Comments:** Your code lacks comments, which would be useful in explaining the logic, especially when the condition checks are complex.\\n\\nHere\\'s a simpler version of a binary search algorithm on a rotated sorted array:\\n\\n```java\\npublic int search(int[] nums, int target) {\\n    int low = 0, high = nums.length - 1;\\n    while (low <= high) {\\n        int mid = (low + high) / 2;\\n        if (nums[mid] == target) return mid;\\n\\n        if (nums[low] <= nums[mid]) { // left half is sorted\\n            if (nums[low] <= target && target < nums[mid]) high = mid - 1; // target is in left half\\n            else low = mid + 1; // target is in right half\\n        } \\n        else { // right half is sorted\\n            if (nums[mid] < target && target <= nums[high]) low = mid + 1; // target is in right half\\n            else high = mid - 1; // target is in left half\\n        }\\n    }\\n    return -1;\\n}\\n```\\nThis code is more readable, shorter, and it accomplishes the same goal. It divides the array into two halves, checks which half is sorted, and determines which half the target could be in. Then, it repeats the process for that half."
                    },
                    {
                        "username": "Nobody_cares",
                        "content": "Why I am getting \\'-1\\' for the input [4,5,6,0,1,2] for the following code:\\nclass Solution {\\npublic:\\n    int search(vector<int>& nums, int target) {\\n        int n=nums.size(), ans;\\n        \\n        int start=0, end=n-1;\\n        if(nums[end]>nums[start]){\\n            ans=nums[start];\\n        }\\n        else{\\n            bool found=false;\\n            while(start<=end){\\n                int mid=start+(end-start)/2;\\n                if(nums[mid]==target){\\n                    found=true;\\n                    ans=mid;\\n                    break;\\n                }\\n                else if(nums[mid]>target){\\n                    start=mid+1;\\n                }\\n                else{\\n                    end=mid-1;\\n                }\\n            }\\n            if(!found) ans=-1;\\n            \\n        }\\n        return ans;\\n    }\\n};"
                    },
                    {
                        "username": "bparanj",
                        "content": "Your current implementation is wrong because it assumes that the array is always sorted in descending order and that if it\\'s not, it must be a rotated array.\\n\\nHowever, the array can be a regular sorted array (ascending order), or a rotated sorted array. Also, you have mistakenly assigned the `ans=nums[start];` when the `nums[end]>nums[start]` which means the array is in ascending order. In this case, you\\'re not actually performing a search but returning the first element of the array, which is wrong.\\n\\nMoreover, the logic of your binary search inside the `else` statement is flawed. The condition `else if(nums[mid]>target)` implies that if the middle element is greater than the target, you should look to the right side of the array (increasing `start`), which is incorrect. When the middle element is greater, we need to look to the left side (decreasing `end`).\\n\\nThe corrected code should look like:\\n\\n```cpp\\nclass Solution {\\npublic:\\n    int search(vector<int>& nums, int target) {\\n        int n=nums.size();\\n\\n        int start=0, end=n-1;\\n        while(start<=end){\\n            int mid=start+(end-start)/2;\\n            if(nums[mid]==target){\\n                return mid;\\n            }\\n            // Determine which half to go, left half is sorted\\n            else if(nums[start] <= nums[mid]){\\n                if(target >= nums[start] && target < nums[mid]){\\n                    end = mid - 1;\\n                }else{\\n                    start = mid + 1;\\n                }\\n            }\\n            // Right half is sorted\\n            else{\\n                if(target > nums[mid] && target <= nums[end]){\\n                    start = mid + 1;\\n                }else{\\n                    end = mid - 1;\\n                }\\n            }\\n        }\\n        return -1;\\n    }\\n};\\n```\\n\\nThis code performs a binary search checking which half is sorted and whether the target falls into that half or not. Then it adjusts the `start` and `end` pointers accordingly and repeats until the target is found or the search space is empty.\\n"
                    },
                    {
                        "username": "Ragavan2003",
                        "content": "I think I miss the intention of the question ,I can use linear search and still get all test case passed.\\nIs the intention is too mislead you to think too much?."
                    },
                    {
                        "username": "deepak_guptacoder-369",
                        "content": "class Solution {\\npublic:\\n    int search(vector<int>& nums, int target) {\\n        int left = 0, right = nums.size() - 1;\\n        while (left <= right) {\\n            int mid = left + (right - left) / 2;\\n            if (nums[mid] == target) return mid;\\n            if (nums[left] <= nums[mid]) {\\n                if (nums[left] <= target && target < nums[mid]) right = mid - 1;\\n                else left = mid + 1;\\n            } else {\\n                if (nums[mid] < target && target <= nums[right]) left = mid + 1;\\n                else right = mid - 1;\\n            }\\n        }\\n        return -1;\\n    }\\n};\\n"
                    },
                    {
                        "username": "ashutoshbhardwaj25122000",
                        "content": "Idea here is basically that if we keep breaking the array into two halves, then either the left array will be ordered or right array will be ordered. If the target value lies in the ordered half, then our further finding is restricted to this portion, otherwise it will get restricted to the other portion which is unordered. Doing this recursively, we will be able to find the index of target."
                    },
                    {
                        "username": "satyam_rai15",
                        "content": "The question is pointless as it doesn\\'t give TLE for O(N) solutions"
                    }
                ]
            },
            {
                "id": 1807110,
                "content": [
                    {
                        "username": "Shivam_Tyagi_G",
                        "content": "Beat 100% solutions\\nclass Solution {\\n    int solve(vector<int> &arr)\\n    {\\n        int low = 0;\\n        int n = arr.size()-1;\\n        int high = n;\\n        int mid;\\n        while(low<high)\\n        {\\n            mid = low+(high-low)/2;\\n            if(arr[mid] < arr[n])\\n            {\\n                high = mid;\\n            }\\n            else{\\n                low = mid+1;\\n            }\\n        }\\n        return low;\\n    }\\npublic:\\n    int search(vector<int>& arr, int target) {\\n        int pivot = solve(arr);\\n    int n = arr.size() - 1;\\n    int low, high;\\n    if (target <= arr[n]){\\n        low = pivot;\\n        high = n;\\n    }\\n    else{\\n        low = 0;\\n        high = pivot-1;\\n    }\\n    cout<<pivot<<endl;\\n    while(low<=high)\\n    {\\n        int mid = low+(high-low)/2;\\n        if(arr[mid] == target)\\n        {\\n            return mid;\\n        }\\n        else if(arr[mid] > target){\\n            high = mid-1;\\n        }\\n        else{\\n            low = mid+1;\\n        }\\n    }\\n    return -1;\\n    }\\n};"
                    },
                    {
                        "username": "Mit_Bhardiwala",
                        "content": "The concept is primarily of binary search. First we  need to find pivot index and then search target according to its value. Else it also passes for normal inbuilt search functions(which u should not try)."
                    },
                    {
                        "username": "YashuCoder",
                        "content": "This question really fucked me up . I had literally tried to change the binary search and tried to get the answer in O(logn) . But it did not happen . At last for fun I tried simple linear search it worked and beaten 70% lol . Wtf"
                    },
                    {
                        "username": "TiagoMendees",
                        "content": "Am i confused or is this problem too simple? Like i just used brute force by using a for loop and check if  ```nums[i] == target ```, if it was true return i, if nums doesn't contains target return -1.\n ```\n        for (size_t i = 0; i < nums.size(); i++)\n        {\n           if(nums[i] == target ) return i;\n        }\n        \n        return -1;\n```\n\nThis worked for me"
                    },
                    {
                        "username": "prasannapoola",
                        "content": "I covered all the ways that be able to go through left and right side of the array.\\nIf we don\\'t go for right side( left = mid +1 ) of array then there might be a chance target element present in left side of array. \\nI felt that conditions are too long but I don\\'t find other way.\\n\\n public int search(int[] nums, int target) {\\n        int left = 0;\\n        int right = nums.length-1;\\n        int mid = -1;\\n        boolean found = false;\\n        while(left<=right){\\n            mid = (left+right)/2;\\n            if(nums[mid]==target){\\n                found = true;\\n                break;\\n            }\\n            else if((target>nums[mid] && nums[left]<nums[right]) || (target<nums[mid] && nums[left]>nums[right] && nums[left]>target && nums[left]<=nums[mid] ) || (target>nums[mid] && nums[left]>target) || (target > nums[mid] && nums[mid]>nums[left])){\\n                left = mid + 1;\\n            }\\n            else{\\n                right = mid - 1;\\n            }\\n        }\\n        return (found)?mid:-1;\\n    }\\n"
                    },
                    {
                        "username": "bparanj",
                        "content": "Your code seems correct, but it is indeed a bit convoluted. In a coding interview, readability and simplicity are often as important as correctness. This means that the ideal solution is not only correct but also easy to understand.\\n\\nLet\\'s critique your solution:\\n\\n1. **Complex conditions:** The conditions inside your if and else if blocks are quite complex. This not only makes the code hard to read and understand, but also prone to errors. It would be better to break these conditions down into separate if else blocks with clear comments explaining the logic.\\n\\n2. **Use of found flag:** The boolean flag \"found\" is not necessary. You can just return `mid` from within the loop when you find the target.\\n\\n3. **Variable Naming:** It would be better to name your variables according to what they represent. For example, `left` and `right` could be `low` and `high`, which might more clearly represent the lower and upper bounds of the search range.\\n\\n4. **Code Comments:** Your code lacks comments, which would be useful in explaining the logic, especially when the condition checks are complex.\\n\\nHere\\'s a simpler version of a binary search algorithm on a rotated sorted array:\\n\\n```java\\npublic int search(int[] nums, int target) {\\n    int low = 0, high = nums.length - 1;\\n    while (low <= high) {\\n        int mid = (low + high) / 2;\\n        if (nums[mid] == target) return mid;\\n\\n        if (nums[low] <= nums[mid]) { // left half is sorted\\n            if (nums[low] <= target && target < nums[mid]) high = mid - 1; // target is in left half\\n            else low = mid + 1; // target is in right half\\n        } \\n        else { // right half is sorted\\n            if (nums[mid] < target && target <= nums[high]) low = mid + 1; // target is in right half\\n            else high = mid - 1; // target is in left half\\n        }\\n    }\\n    return -1;\\n}\\n```\\nThis code is more readable, shorter, and it accomplishes the same goal. It divides the array into two halves, checks which half is sorted, and determines which half the target could be in. Then, it repeats the process for that half."
                    },
                    {
                        "username": "Nobody_cares",
                        "content": "Why I am getting \\'-1\\' for the input [4,5,6,0,1,2] for the following code:\\nclass Solution {\\npublic:\\n    int search(vector<int>& nums, int target) {\\n        int n=nums.size(), ans;\\n        \\n        int start=0, end=n-1;\\n        if(nums[end]>nums[start]){\\n            ans=nums[start];\\n        }\\n        else{\\n            bool found=false;\\n            while(start<=end){\\n                int mid=start+(end-start)/2;\\n                if(nums[mid]==target){\\n                    found=true;\\n                    ans=mid;\\n                    break;\\n                }\\n                else if(nums[mid]>target){\\n                    start=mid+1;\\n                }\\n                else{\\n                    end=mid-1;\\n                }\\n            }\\n            if(!found) ans=-1;\\n            \\n        }\\n        return ans;\\n    }\\n};"
                    },
                    {
                        "username": "bparanj",
                        "content": "Your current implementation is wrong because it assumes that the array is always sorted in descending order and that if it\\'s not, it must be a rotated array.\\n\\nHowever, the array can be a regular sorted array (ascending order), or a rotated sorted array. Also, you have mistakenly assigned the `ans=nums[start];` when the `nums[end]>nums[start]` which means the array is in ascending order. In this case, you\\'re not actually performing a search but returning the first element of the array, which is wrong.\\n\\nMoreover, the logic of your binary search inside the `else` statement is flawed. The condition `else if(nums[mid]>target)` implies that if the middle element is greater than the target, you should look to the right side of the array (increasing `start`), which is incorrect. When the middle element is greater, we need to look to the left side (decreasing `end`).\\n\\nThe corrected code should look like:\\n\\n```cpp\\nclass Solution {\\npublic:\\n    int search(vector<int>& nums, int target) {\\n        int n=nums.size();\\n\\n        int start=0, end=n-1;\\n        while(start<=end){\\n            int mid=start+(end-start)/2;\\n            if(nums[mid]==target){\\n                return mid;\\n            }\\n            // Determine which half to go, left half is sorted\\n            else if(nums[start] <= nums[mid]){\\n                if(target >= nums[start] && target < nums[mid]){\\n                    end = mid - 1;\\n                }else{\\n                    start = mid + 1;\\n                }\\n            }\\n            // Right half is sorted\\n            else{\\n                if(target > nums[mid] && target <= nums[end]){\\n                    start = mid + 1;\\n                }else{\\n                    end = mid - 1;\\n                }\\n            }\\n        }\\n        return -1;\\n    }\\n};\\n```\\n\\nThis code performs a binary search checking which half is sorted and whether the target falls into that half or not. Then it adjusts the `start` and `end` pointers accordingly and repeats until the target is found or the search space is empty.\\n"
                    },
                    {
                        "username": "Ragavan2003",
                        "content": "I think I miss the intention of the question ,I can use linear search and still get all test case passed.\\nIs the intention is too mislead you to think too much?."
                    },
                    {
                        "username": "deepak_guptacoder-369",
                        "content": "class Solution {\\npublic:\\n    int search(vector<int>& nums, int target) {\\n        int left = 0, right = nums.size() - 1;\\n        while (left <= right) {\\n            int mid = left + (right - left) / 2;\\n            if (nums[mid] == target) return mid;\\n            if (nums[left] <= nums[mid]) {\\n                if (nums[left] <= target && target < nums[mid]) right = mid - 1;\\n                else left = mid + 1;\\n            } else {\\n                if (nums[mid] < target && target <= nums[right]) left = mid + 1;\\n                else right = mid - 1;\\n            }\\n        }\\n        return -1;\\n    }\\n};\\n"
                    },
                    {
                        "username": "ashutoshbhardwaj25122000",
                        "content": "Idea here is basically that if we keep breaking the array into two halves, then either the left array will be ordered or right array will be ordered. If the target value lies in the ordered half, then our further finding is restricted to this portion, otherwise it will get restricted to the other portion which is unordered. Doing this recursively, we will be able to find the index of target."
                    },
                    {
                        "username": "satyam_rai15",
                        "content": "The question is pointless as it doesn\\'t give TLE for O(N) solutions"
                    }
                ]
            },
            {
                "id": 1806109,
                "content": [
                    {
                        "username": "Shivam_Tyagi_G",
                        "content": "Beat 100% solutions\\nclass Solution {\\n    int solve(vector<int> &arr)\\n    {\\n        int low = 0;\\n        int n = arr.size()-1;\\n        int high = n;\\n        int mid;\\n        while(low<high)\\n        {\\n            mid = low+(high-low)/2;\\n            if(arr[mid] < arr[n])\\n            {\\n                high = mid;\\n            }\\n            else{\\n                low = mid+1;\\n            }\\n        }\\n        return low;\\n    }\\npublic:\\n    int search(vector<int>& arr, int target) {\\n        int pivot = solve(arr);\\n    int n = arr.size() - 1;\\n    int low, high;\\n    if (target <= arr[n]){\\n        low = pivot;\\n        high = n;\\n    }\\n    else{\\n        low = 0;\\n        high = pivot-1;\\n    }\\n    cout<<pivot<<endl;\\n    while(low<=high)\\n    {\\n        int mid = low+(high-low)/2;\\n        if(arr[mid] == target)\\n        {\\n            return mid;\\n        }\\n        else if(arr[mid] > target){\\n            high = mid-1;\\n        }\\n        else{\\n            low = mid+1;\\n        }\\n    }\\n    return -1;\\n    }\\n};"
                    },
                    {
                        "username": "Mit_Bhardiwala",
                        "content": "The concept is primarily of binary search. First we  need to find pivot index and then search target according to its value. Else it also passes for normal inbuilt search functions(which u should not try)."
                    },
                    {
                        "username": "YashuCoder",
                        "content": "This question really fucked me up . I had literally tried to change the binary search and tried to get the answer in O(logn) . But it did not happen . At last for fun I tried simple linear search it worked and beaten 70% lol . Wtf"
                    },
                    {
                        "username": "TiagoMendees",
                        "content": "Am i confused or is this problem too simple? Like i just used brute force by using a for loop and check if  ```nums[i] == target ```, if it was true return i, if nums doesn't contains target return -1.\n ```\n        for (size_t i = 0; i < nums.size(); i++)\n        {\n           if(nums[i] == target ) return i;\n        }\n        \n        return -1;\n```\n\nThis worked for me"
                    },
                    {
                        "username": "prasannapoola",
                        "content": "I covered all the ways that be able to go through left and right side of the array.\\nIf we don\\'t go for right side( left = mid +1 ) of array then there might be a chance target element present in left side of array. \\nI felt that conditions are too long but I don\\'t find other way.\\n\\n public int search(int[] nums, int target) {\\n        int left = 0;\\n        int right = nums.length-1;\\n        int mid = -1;\\n        boolean found = false;\\n        while(left<=right){\\n            mid = (left+right)/2;\\n            if(nums[mid]==target){\\n                found = true;\\n                break;\\n            }\\n            else if((target>nums[mid] && nums[left]<nums[right]) || (target<nums[mid] && nums[left]>nums[right] && nums[left]>target && nums[left]<=nums[mid] ) || (target>nums[mid] && nums[left]>target) || (target > nums[mid] && nums[mid]>nums[left])){\\n                left = mid + 1;\\n            }\\n            else{\\n                right = mid - 1;\\n            }\\n        }\\n        return (found)?mid:-1;\\n    }\\n"
                    },
                    {
                        "username": "bparanj",
                        "content": "Your code seems correct, but it is indeed a bit convoluted. In a coding interview, readability and simplicity are often as important as correctness. This means that the ideal solution is not only correct but also easy to understand.\\n\\nLet\\'s critique your solution:\\n\\n1. **Complex conditions:** The conditions inside your if and else if blocks are quite complex. This not only makes the code hard to read and understand, but also prone to errors. It would be better to break these conditions down into separate if else blocks with clear comments explaining the logic.\\n\\n2. **Use of found flag:** The boolean flag \"found\" is not necessary. You can just return `mid` from within the loop when you find the target.\\n\\n3. **Variable Naming:** It would be better to name your variables according to what they represent. For example, `left` and `right` could be `low` and `high`, which might more clearly represent the lower and upper bounds of the search range.\\n\\n4. **Code Comments:** Your code lacks comments, which would be useful in explaining the logic, especially when the condition checks are complex.\\n\\nHere\\'s a simpler version of a binary search algorithm on a rotated sorted array:\\n\\n```java\\npublic int search(int[] nums, int target) {\\n    int low = 0, high = nums.length - 1;\\n    while (low <= high) {\\n        int mid = (low + high) / 2;\\n        if (nums[mid] == target) return mid;\\n\\n        if (nums[low] <= nums[mid]) { // left half is sorted\\n            if (nums[low] <= target && target < nums[mid]) high = mid - 1; // target is in left half\\n            else low = mid + 1; // target is in right half\\n        } \\n        else { // right half is sorted\\n            if (nums[mid] < target && target <= nums[high]) low = mid + 1; // target is in right half\\n            else high = mid - 1; // target is in left half\\n        }\\n    }\\n    return -1;\\n}\\n```\\nThis code is more readable, shorter, and it accomplishes the same goal. It divides the array into two halves, checks which half is sorted, and determines which half the target could be in. Then, it repeats the process for that half."
                    },
                    {
                        "username": "Nobody_cares",
                        "content": "Why I am getting \\'-1\\' for the input [4,5,6,0,1,2] for the following code:\\nclass Solution {\\npublic:\\n    int search(vector<int>& nums, int target) {\\n        int n=nums.size(), ans;\\n        \\n        int start=0, end=n-1;\\n        if(nums[end]>nums[start]){\\n            ans=nums[start];\\n        }\\n        else{\\n            bool found=false;\\n            while(start<=end){\\n                int mid=start+(end-start)/2;\\n                if(nums[mid]==target){\\n                    found=true;\\n                    ans=mid;\\n                    break;\\n                }\\n                else if(nums[mid]>target){\\n                    start=mid+1;\\n                }\\n                else{\\n                    end=mid-1;\\n                }\\n            }\\n            if(!found) ans=-1;\\n            \\n        }\\n        return ans;\\n    }\\n};"
                    },
                    {
                        "username": "bparanj",
                        "content": "Your current implementation is wrong because it assumes that the array is always sorted in descending order and that if it\\'s not, it must be a rotated array.\\n\\nHowever, the array can be a regular sorted array (ascending order), or a rotated sorted array. Also, you have mistakenly assigned the `ans=nums[start];` when the `nums[end]>nums[start]` which means the array is in ascending order. In this case, you\\'re not actually performing a search but returning the first element of the array, which is wrong.\\n\\nMoreover, the logic of your binary search inside the `else` statement is flawed. The condition `else if(nums[mid]>target)` implies that if the middle element is greater than the target, you should look to the right side of the array (increasing `start`), which is incorrect. When the middle element is greater, we need to look to the left side (decreasing `end`).\\n\\nThe corrected code should look like:\\n\\n```cpp\\nclass Solution {\\npublic:\\n    int search(vector<int>& nums, int target) {\\n        int n=nums.size();\\n\\n        int start=0, end=n-1;\\n        while(start<=end){\\n            int mid=start+(end-start)/2;\\n            if(nums[mid]==target){\\n                return mid;\\n            }\\n            // Determine which half to go, left half is sorted\\n            else if(nums[start] <= nums[mid]){\\n                if(target >= nums[start] && target < nums[mid]){\\n                    end = mid - 1;\\n                }else{\\n                    start = mid + 1;\\n                }\\n            }\\n            // Right half is sorted\\n            else{\\n                if(target > nums[mid] && target <= nums[end]){\\n                    start = mid + 1;\\n                }else{\\n                    end = mid - 1;\\n                }\\n            }\\n        }\\n        return -1;\\n    }\\n};\\n```\\n\\nThis code performs a binary search checking which half is sorted and whether the target falls into that half or not. Then it adjusts the `start` and `end` pointers accordingly and repeats until the target is found or the search space is empty.\\n"
                    },
                    {
                        "username": "Ragavan2003",
                        "content": "I think I miss the intention of the question ,I can use linear search and still get all test case passed.\\nIs the intention is too mislead you to think too much?."
                    },
                    {
                        "username": "deepak_guptacoder-369",
                        "content": "class Solution {\\npublic:\\n    int search(vector<int>& nums, int target) {\\n        int left = 0, right = nums.size() - 1;\\n        while (left <= right) {\\n            int mid = left + (right - left) / 2;\\n            if (nums[mid] == target) return mid;\\n            if (nums[left] <= nums[mid]) {\\n                if (nums[left] <= target && target < nums[mid]) right = mid - 1;\\n                else left = mid + 1;\\n            } else {\\n                if (nums[mid] < target && target <= nums[right]) left = mid + 1;\\n                else right = mid - 1;\\n            }\\n        }\\n        return -1;\\n    }\\n};\\n"
                    },
                    {
                        "username": "ashutoshbhardwaj25122000",
                        "content": "Idea here is basically that if we keep breaking the array into two halves, then either the left array will be ordered or right array will be ordered. If the target value lies in the ordered half, then our further finding is restricted to this portion, otherwise it will get restricted to the other portion which is unordered. Doing this recursively, we will be able to find the index of target."
                    },
                    {
                        "username": "satyam_rai15",
                        "content": "The question is pointless as it doesn\\'t give TLE for O(N) solutions"
                    }
                ]
            },
            {
                "id": 1803570,
                "content": [
                    {
                        "username": "Shivam_Tyagi_G",
                        "content": "Beat 100% solutions\\nclass Solution {\\n    int solve(vector<int> &arr)\\n    {\\n        int low = 0;\\n        int n = arr.size()-1;\\n        int high = n;\\n        int mid;\\n        while(low<high)\\n        {\\n            mid = low+(high-low)/2;\\n            if(arr[mid] < arr[n])\\n            {\\n                high = mid;\\n            }\\n            else{\\n                low = mid+1;\\n            }\\n        }\\n        return low;\\n    }\\npublic:\\n    int search(vector<int>& arr, int target) {\\n        int pivot = solve(arr);\\n    int n = arr.size() - 1;\\n    int low, high;\\n    if (target <= arr[n]){\\n        low = pivot;\\n        high = n;\\n    }\\n    else{\\n        low = 0;\\n        high = pivot-1;\\n    }\\n    cout<<pivot<<endl;\\n    while(low<=high)\\n    {\\n        int mid = low+(high-low)/2;\\n        if(arr[mid] == target)\\n        {\\n            return mid;\\n        }\\n        else if(arr[mid] > target){\\n            high = mid-1;\\n        }\\n        else{\\n            low = mid+1;\\n        }\\n    }\\n    return -1;\\n    }\\n};"
                    },
                    {
                        "username": "Mit_Bhardiwala",
                        "content": "The concept is primarily of binary search. First we  need to find pivot index and then search target according to its value. Else it also passes for normal inbuilt search functions(which u should not try)."
                    },
                    {
                        "username": "YashuCoder",
                        "content": "This question really fucked me up . I had literally tried to change the binary search and tried to get the answer in O(logn) . But it did not happen . At last for fun I tried simple linear search it worked and beaten 70% lol . Wtf"
                    },
                    {
                        "username": "TiagoMendees",
                        "content": "Am i confused or is this problem too simple? Like i just used brute force by using a for loop and check if  ```nums[i] == target ```, if it was true return i, if nums doesn't contains target return -1.\n ```\n        for (size_t i = 0; i < nums.size(); i++)\n        {\n           if(nums[i] == target ) return i;\n        }\n        \n        return -1;\n```\n\nThis worked for me"
                    },
                    {
                        "username": "prasannapoola",
                        "content": "I covered all the ways that be able to go through left and right side of the array.\\nIf we don\\'t go for right side( left = mid +1 ) of array then there might be a chance target element present in left side of array. \\nI felt that conditions are too long but I don\\'t find other way.\\n\\n public int search(int[] nums, int target) {\\n        int left = 0;\\n        int right = nums.length-1;\\n        int mid = -1;\\n        boolean found = false;\\n        while(left<=right){\\n            mid = (left+right)/2;\\n            if(nums[mid]==target){\\n                found = true;\\n                break;\\n            }\\n            else if((target>nums[mid] && nums[left]<nums[right]) || (target<nums[mid] && nums[left]>nums[right] && nums[left]>target && nums[left]<=nums[mid] ) || (target>nums[mid] && nums[left]>target) || (target > nums[mid] && nums[mid]>nums[left])){\\n                left = mid + 1;\\n            }\\n            else{\\n                right = mid - 1;\\n            }\\n        }\\n        return (found)?mid:-1;\\n    }\\n"
                    },
                    {
                        "username": "bparanj",
                        "content": "Your code seems correct, but it is indeed a bit convoluted. In a coding interview, readability and simplicity are often as important as correctness. This means that the ideal solution is not only correct but also easy to understand.\\n\\nLet\\'s critique your solution:\\n\\n1. **Complex conditions:** The conditions inside your if and else if blocks are quite complex. This not only makes the code hard to read and understand, but also prone to errors. It would be better to break these conditions down into separate if else blocks with clear comments explaining the logic.\\n\\n2. **Use of found flag:** The boolean flag \"found\" is not necessary. You can just return `mid` from within the loop when you find the target.\\n\\n3. **Variable Naming:** It would be better to name your variables according to what they represent. For example, `left` and `right` could be `low` and `high`, which might more clearly represent the lower and upper bounds of the search range.\\n\\n4. **Code Comments:** Your code lacks comments, which would be useful in explaining the logic, especially when the condition checks are complex.\\n\\nHere\\'s a simpler version of a binary search algorithm on a rotated sorted array:\\n\\n```java\\npublic int search(int[] nums, int target) {\\n    int low = 0, high = nums.length - 1;\\n    while (low <= high) {\\n        int mid = (low + high) / 2;\\n        if (nums[mid] == target) return mid;\\n\\n        if (nums[low] <= nums[mid]) { // left half is sorted\\n            if (nums[low] <= target && target < nums[mid]) high = mid - 1; // target is in left half\\n            else low = mid + 1; // target is in right half\\n        } \\n        else { // right half is sorted\\n            if (nums[mid] < target && target <= nums[high]) low = mid + 1; // target is in right half\\n            else high = mid - 1; // target is in left half\\n        }\\n    }\\n    return -1;\\n}\\n```\\nThis code is more readable, shorter, and it accomplishes the same goal. It divides the array into two halves, checks which half is sorted, and determines which half the target could be in. Then, it repeats the process for that half."
                    },
                    {
                        "username": "Nobody_cares",
                        "content": "Why I am getting \\'-1\\' for the input [4,5,6,0,1,2] for the following code:\\nclass Solution {\\npublic:\\n    int search(vector<int>& nums, int target) {\\n        int n=nums.size(), ans;\\n        \\n        int start=0, end=n-1;\\n        if(nums[end]>nums[start]){\\n            ans=nums[start];\\n        }\\n        else{\\n            bool found=false;\\n            while(start<=end){\\n                int mid=start+(end-start)/2;\\n                if(nums[mid]==target){\\n                    found=true;\\n                    ans=mid;\\n                    break;\\n                }\\n                else if(nums[mid]>target){\\n                    start=mid+1;\\n                }\\n                else{\\n                    end=mid-1;\\n                }\\n            }\\n            if(!found) ans=-1;\\n            \\n        }\\n        return ans;\\n    }\\n};"
                    },
                    {
                        "username": "bparanj",
                        "content": "Your current implementation is wrong because it assumes that the array is always sorted in descending order and that if it\\'s not, it must be a rotated array.\\n\\nHowever, the array can be a regular sorted array (ascending order), or a rotated sorted array. Also, you have mistakenly assigned the `ans=nums[start];` when the `nums[end]>nums[start]` which means the array is in ascending order. In this case, you\\'re not actually performing a search but returning the first element of the array, which is wrong.\\n\\nMoreover, the logic of your binary search inside the `else` statement is flawed. The condition `else if(nums[mid]>target)` implies that if the middle element is greater than the target, you should look to the right side of the array (increasing `start`), which is incorrect. When the middle element is greater, we need to look to the left side (decreasing `end`).\\n\\nThe corrected code should look like:\\n\\n```cpp\\nclass Solution {\\npublic:\\n    int search(vector<int>& nums, int target) {\\n        int n=nums.size();\\n\\n        int start=0, end=n-1;\\n        while(start<=end){\\n            int mid=start+(end-start)/2;\\n            if(nums[mid]==target){\\n                return mid;\\n            }\\n            // Determine which half to go, left half is sorted\\n            else if(nums[start] <= nums[mid]){\\n                if(target >= nums[start] && target < nums[mid]){\\n                    end = mid - 1;\\n                }else{\\n                    start = mid + 1;\\n                }\\n            }\\n            // Right half is sorted\\n            else{\\n                if(target > nums[mid] && target <= nums[end]){\\n                    start = mid + 1;\\n                }else{\\n                    end = mid - 1;\\n                }\\n            }\\n        }\\n        return -1;\\n    }\\n};\\n```\\n\\nThis code performs a binary search checking which half is sorted and whether the target falls into that half or not. Then it adjusts the `start` and `end` pointers accordingly and repeats until the target is found or the search space is empty.\\n"
                    },
                    {
                        "username": "Ragavan2003",
                        "content": "I think I miss the intention of the question ,I can use linear search and still get all test case passed.\\nIs the intention is too mislead you to think too much?."
                    },
                    {
                        "username": "deepak_guptacoder-369",
                        "content": "class Solution {\\npublic:\\n    int search(vector<int>& nums, int target) {\\n        int left = 0, right = nums.size() - 1;\\n        while (left <= right) {\\n            int mid = left + (right - left) / 2;\\n            if (nums[mid] == target) return mid;\\n            if (nums[left] <= nums[mid]) {\\n                if (nums[left] <= target && target < nums[mid]) right = mid - 1;\\n                else left = mid + 1;\\n            } else {\\n                if (nums[mid] < target && target <= nums[right]) left = mid + 1;\\n                else right = mid - 1;\\n            }\\n        }\\n        return -1;\\n    }\\n};\\n"
                    },
                    {
                        "username": "ashutoshbhardwaj25122000",
                        "content": "Idea here is basically that if we keep breaking the array into two halves, then either the left array will be ordered or right array will be ordered. If the target value lies in the ordered half, then our further finding is restricted to this portion, otherwise it will get restricted to the other portion which is unordered. Doing this recursively, we will be able to find the index of target."
                    },
                    {
                        "username": "satyam_rai15",
                        "content": "The question is pointless as it doesn\\'t give TLE for O(N) solutions"
                    }
                ]
            },
            {
                "id": 1800366,
                "content": [
                    {
                        "username": "Shivam_Tyagi_G",
                        "content": "Beat 100% solutions\\nclass Solution {\\n    int solve(vector<int> &arr)\\n    {\\n        int low = 0;\\n        int n = arr.size()-1;\\n        int high = n;\\n        int mid;\\n        while(low<high)\\n        {\\n            mid = low+(high-low)/2;\\n            if(arr[mid] < arr[n])\\n            {\\n                high = mid;\\n            }\\n            else{\\n                low = mid+1;\\n            }\\n        }\\n        return low;\\n    }\\npublic:\\n    int search(vector<int>& arr, int target) {\\n        int pivot = solve(arr);\\n    int n = arr.size() - 1;\\n    int low, high;\\n    if (target <= arr[n]){\\n        low = pivot;\\n        high = n;\\n    }\\n    else{\\n        low = 0;\\n        high = pivot-1;\\n    }\\n    cout<<pivot<<endl;\\n    while(low<=high)\\n    {\\n        int mid = low+(high-low)/2;\\n        if(arr[mid] == target)\\n        {\\n            return mid;\\n        }\\n        else if(arr[mid] > target){\\n            high = mid-1;\\n        }\\n        else{\\n            low = mid+1;\\n        }\\n    }\\n    return -1;\\n    }\\n};"
                    },
                    {
                        "username": "Mit_Bhardiwala",
                        "content": "The concept is primarily of binary search. First we  need to find pivot index and then search target according to its value. Else it also passes for normal inbuilt search functions(which u should not try)."
                    },
                    {
                        "username": "YashuCoder",
                        "content": "This question really fucked me up . I had literally tried to change the binary search and tried to get the answer in O(logn) . But it did not happen . At last for fun I tried simple linear search it worked and beaten 70% lol . Wtf"
                    },
                    {
                        "username": "TiagoMendees",
                        "content": "Am i confused or is this problem too simple? Like i just used brute force by using a for loop and check if  ```nums[i] == target ```, if it was true return i, if nums doesn't contains target return -1.\n ```\n        for (size_t i = 0; i < nums.size(); i++)\n        {\n           if(nums[i] == target ) return i;\n        }\n        \n        return -1;\n```\n\nThis worked for me"
                    },
                    {
                        "username": "prasannapoola",
                        "content": "I covered all the ways that be able to go through left and right side of the array.\\nIf we don\\'t go for right side( left = mid +1 ) of array then there might be a chance target element present in left side of array. \\nI felt that conditions are too long but I don\\'t find other way.\\n\\n public int search(int[] nums, int target) {\\n        int left = 0;\\n        int right = nums.length-1;\\n        int mid = -1;\\n        boolean found = false;\\n        while(left<=right){\\n            mid = (left+right)/2;\\n            if(nums[mid]==target){\\n                found = true;\\n                break;\\n            }\\n            else if((target>nums[mid] && nums[left]<nums[right]) || (target<nums[mid] && nums[left]>nums[right] && nums[left]>target && nums[left]<=nums[mid] ) || (target>nums[mid] && nums[left]>target) || (target > nums[mid] && nums[mid]>nums[left])){\\n                left = mid + 1;\\n            }\\n            else{\\n                right = mid - 1;\\n            }\\n        }\\n        return (found)?mid:-1;\\n    }\\n"
                    },
                    {
                        "username": "bparanj",
                        "content": "Your code seems correct, but it is indeed a bit convoluted. In a coding interview, readability and simplicity are often as important as correctness. This means that the ideal solution is not only correct but also easy to understand.\\n\\nLet\\'s critique your solution:\\n\\n1. **Complex conditions:** The conditions inside your if and else if blocks are quite complex. This not only makes the code hard to read and understand, but also prone to errors. It would be better to break these conditions down into separate if else blocks with clear comments explaining the logic.\\n\\n2. **Use of found flag:** The boolean flag \"found\" is not necessary. You can just return `mid` from within the loop when you find the target.\\n\\n3. **Variable Naming:** It would be better to name your variables according to what they represent. For example, `left` and `right` could be `low` and `high`, which might more clearly represent the lower and upper bounds of the search range.\\n\\n4. **Code Comments:** Your code lacks comments, which would be useful in explaining the logic, especially when the condition checks are complex.\\n\\nHere\\'s a simpler version of a binary search algorithm on a rotated sorted array:\\n\\n```java\\npublic int search(int[] nums, int target) {\\n    int low = 0, high = nums.length - 1;\\n    while (low <= high) {\\n        int mid = (low + high) / 2;\\n        if (nums[mid] == target) return mid;\\n\\n        if (nums[low] <= nums[mid]) { // left half is sorted\\n            if (nums[low] <= target && target < nums[mid]) high = mid - 1; // target is in left half\\n            else low = mid + 1; // target is in right half\\n        } \\n        else { // right half is sorted\\n            if (nums[mid] < target && target <= nums[high]) low = mid + 1; // target is in right half\\n            else high = mid - 1; // target is in left half\\n        }\\n    }\\n    return -1;\\n}\\n```\\nThis code is more readable, shorter, and it accomplishes the same goal. It divides the array into two halves, checks which half is sorted, and determines which half the target could be in. Then, it repeats the process for that half."
                    },
                    {
                        "username": "Nobody_cares",
                        "content": "Why I am getting \\'-1\\' for the input [4,5,6,0,1,2] for the following code:\\nclass Solution {\\npublic:\\n    int search(vector<int>& nums, int target) {\\n        int n=nums.size(), ans;\\n        \\n        int start=0, end=n-1;\\n        if(nums[end]>nums[start]){\\n            ans=nums[start];\\n        }\\n        else{\\n            bool found=false;\\n            while(start<=end){\\n                int mid=start+(end-start)/2;\\n                if(nums[mid]==target){\\n                    found=true;\\n                    ans=mid;\\n                    break;\\n                }\\n                else if(nums[mid]>target){\\n                    start=mid+1;\\n                }\\n                else{\\n                    end=mid-1;\\n                }\\n            }\\n            if(!found) ans=-1;\\n            \\n        }\\n        return ans;\\n    }\\n};"
                    },
                    {
                        "username": "bparanj",
                        "content": "Your current implementation is wrong because it assumes that the array is always sorted in descending order and that if it\\'s not, it must be a rotated array.\\n\\nHowever, the array can be a regular sorted array (ascending order), or a rotated sorted array. Also, you have mistakenly assigned the `ans=nums[start];` when the `nums[end]>nums[start]` which means the array is in ascending order. In this case, you\\'re not actually performing a search but returning the first element of the array, which is wrong.\\n\\nMoreover, the logic of your binary search inside the `else` statement is flawed. The condition `else if(nums[mid]>target)` implies that if the middle element is greater than the target, you should look to the right side of the array (increasing `start`), which is incorrect. When the middle element is greater, we need to look to the left side (decreasing `end`).\\n\\nThe corrected code should look like:\\n\\n```cpp\\nclass Solution {\\npublic:\\n    int search(vector<int>& nums, int target) {\\n        int n=nums.size();\\n\\n        int start=0, end=n-1;\\n        while(start<=end){\\n            int mid=start+(end-start)/2;\\n            if(nums[mid]==target){\\n                return mid;\\n            }\\n            // Determine which half to go, left half is sorted\\n            else if(nums[start] <= nums[mid]){\\n                if(target >= nums[start] && target < nums[mid]){\\n                    end = mid - 1;\\n                }else{\\n                    start = mid + 1;\\n                }\\n            }\\n            // Right half is sorted\\n            else{\\n                if(target > nums[mid] && target <= nums[end]){\\n                    start = mid + 1;\\n                }else{\\n                    end = mid - 1;\\n                }\\n            }\\n        }\\n        return -1;\\n    }\\n};\\n```\\n\\nThis code performs a binary search checking which half is sorted and whether the target falls into that half or not. Then it adjusts the `start` and `end` pointers accordingly and repeats until the target is found or the search space is empty.\\n"
                    },
                    {
                        "username": "Ragavan2003",
                        "content": "I think I miss the intention of the question ,I can use linear search and still get all test case passed.\\nIs the intention is too mislead you to think too much?."
                    },
                    {
                        "username": "deepak_guptacoder-369",
                        "content": "class Solution {\\npublic:\\n    int search(vector<int>& nums, int target) {\\n        int left = 0, right = nums.size() - 1;\\n        while (left <= right) {\\n            int mid = left + (right - left) / 2;\\n            if (nums[mid] == target) return mid;\\n            if (nums[left] <= nums[mid]) {\\n                if (nums[left] <= target && target < nums[mid]) right = mid - 1;\\n                else left = mid + 1;\\n            } else {\\n                if (nums[mid] < target && target <= nums[right]) left = mid + 1;\\n                else right = mid - 1;\\n            }\\n        }\\n        return -1;\\n    }\\n};\\n"
                    },
                    {
                        "username": "ashutoshbhardwaj25122000",
                        "content": "Idea here is basically that if we keep breaking the array into two halves, then either the left array will be ordered or right array will be ordered. If the target value lies in the ordered half, then our further finding is restricted to this portion, otherwise it will get restricted to the other portion which is unordered. Doing this recursively, we will be able to find the index of target."
                    },
                    {
                        "username": "satyam_rai15",
                        "content": "The question is pointless as it doesn\\'t give TLE for O(N) solutions"
                    }
                ]
            },
            {
                "id": 1797736,
                "content": [
                    {
                        "username": "Shivam_Tyagi_G",
                        "content": "Beat 100% solutions\\nclass Solution {\\n    int solve(vector<int> &arr)\\n    {\\n        int low = 0;\\n        int n = arr.size()-1;\\n        int high = n;\\n        int mid;\\n        while(low<high)\\n        {\\n            mid = low+(high-low)/2;\\n            if(arr[mid] < arr[n])\\n            {\\n                high = mid;\\n            }\\n            else{\\n                low = mid+1;\\n            }\\n        }\\n        return low;\\n    }\\npublic:\\n    int search(vector<int>& arr, int target) {\\n        int pivot = solve(arr);\\n    int n = arr.size() - 1;\\n    int low, high;\\n    if (target <= arr[n]){\\n        low = pivot;\\n        high = n;\\n    }\\n    else{\\n        low = 0;\\n        high = pivot-1;\\n    }\\n    cout<<pivot<<endl;\\n    while(low<=high)\\n    {\\n        int mid = low+(high-low)/2;\\n        if(arr[mid] == target)\\n        {\\n            return mid;\\n        }\\n        else if(arr[mid] > target){\\n            high = mid-1;\\n        }\\n        else{\\n            low = mid+1;\\n        }\\n    }\\n    return -1;\\n    }\\n};"
                    },
                    {
                        "username": "Mit_Bhardiwala",
                        "content": "The concept is primarily of binary search. First we  need to find pivot index and then search target according to its value. Else it also passes for normal inbuilt search functions(which u should not try)."
                    },
                    {
                        "username": "YashuCoder",
                        "content": "This question really fucked me up . I had literally tried to change the binary search and tried to get the answer in O(logn) . But it did not happen . At last for fun I tried simple linear search it worked and beaten 70% lol . Wtf"
                    },
                    {
                        "username": "TiagoMendees",
                        "content": "Am i confused or is this problem too simple? Like i just used brute force by using a for loop and check if  ```nums[i] == target ```, if it was true return i, if nums doesn't contains target return -1.\n ```\n        for (size_t i = 0; i < nums.size(); i++)\n        {\n           if(nums[i] == target ) return i;\n        }\n        \n        return -1;\n```\n\nThis worked for me"
                    },
                    {
                        "username": "prasannapoola",
                        "content": "I covered all the ways that be able to go through left and right side of the array.\\nIf we don\\'t go for right side( left = mid +1 ) of array then there might be a chance target element present in left side of array. \\nI felt that conditions are too long but I don\\'t find other way.\\n\\n public int search(int[] nums, int target) {\\n        int left = 0;\\n        int right = nums.length-1;\\n        int mid = -1;\\n        boolean found = false;\\n        while(left<=right){\\n            mid = (left+right)/2;\\n            if(nums[mid]==target){\\n                found = true;\\n                break;\\n            }\\n            else if((target>nums[mid] && nums[left]<nums[right]) || (target<nums[mid] && nums[left]>nums[right] && nums[left]>target && nums[left]<=nums[mid] ) || (target>nums[mid] && nums[left]>target) || (target > nums[mid] && nums[mid]>nums[left])){\\n                left = mid + 1;\\n            }\\n            else{\\n                right = mid - 1;\\n            }\\n        }\\n        return (found)?mid:-1;\\n    }\\n"
                    },
                    {
                        "username": "bparanj",
                        "content": "Your code seems correct, but it is indeed a bit convoluted. In a coding interview, readability and simplicity are often as important as correctness. This means that the ideal solution is not only correct but also easy to understand.\\n\\nLet\\'s critique your solution:\\n\\n1. **Complex conditions:** The conditions inside your if and else if blocks are quite complex. This not only makes the code hard to read and understand, but also prone to errors. It would be better to break these conditions down into separate if else blocks with clear comments explaining the logic.\\n\\n2. **Use of found flag:** The boolean flag \"found\" is not necessary. You can just return `mid` from within the loop when you find the target.\\n\\n3. **Variable Naming:** It would be better to name your variables according to what they represent. For example, `left` and `right` could be `low` and `high`, which might more clearly represent the lower and upper bounds of the search range.\\n\\n4. **Code Comments:** Your code lacks comments, which would be useful in explaining the logic, especially when the condition checks are complex.\\n\\nHere\\'s a simpler version of a binary search algorithm on a rotated sorted array:\\n\\n```java\\npublic int search(int[] nums, int target) {\\n    int low = 0, high = nums.length - 1;\\n    while (low <= high) {\\n        int mid = (low + high) / 2;\\n        if (nums[mid] == target) return mid;\\n\\n        if (nums[low] <= nums[mid]) { // left half is sorted\\n            if (nums[low] <= target && target < nums[mid]) high = mid - 1; // target is in left half\\n            else low = mid + 1; // target is in right half\\n        } \\n        else { // right half is sorted\\n            if (nums[mid] < target && target <= nums[high]) low = mid + 1; // target is in right half\\n            else high = mid - 1; // target is in left half\\n        }\\n    }\\n    return -1;\\n}\\n```\\nThis code is more readable, shorter, and it accomplishes the same goal. It divides the array into two halves, checks which half is sorted, and determines which half the target could be in. Then, it repeats the process for that half."
                    },
                    {
                        "username": "Nobody_cares",
                        "content": "Why I am getting \\'-1\\' for the input [4,5,6,0,1,2] for the following code:\\nclass Solution {\\npublic:\\n    int search(vector<int>& nums, int target) {\\n        int n=nums.size(), ans;\\n        \\n        int start=0, end=n-1;\\n        if(nums[end]>nums[start]){\\n            ans=nums[start];\\n        }\\n        else{\\n            bool found=false;\\n            while(start<=end){\\n                int mid=start+(end-start)/2;\\n                if(nums[mid]==target){\\n                    found=true;\\n                    ans=mid;\\n                    break;\\n                }\\n                else if(nums[mid]>target){\\n                    start=mid+1;\\n                }\\n                else{\\n                    end=mid-1;\\n                }\\n            }\\n            if(!found) ans=-1;\\n            \\n        }\\n        return ans;\\n    }\\n};"
                    },
                    {
                        "username": "bparanj",
                        "content": "Your current implementation is wrong because it assumes that the array is always sorted in descending order and that if it\\'s not, it must be a rotated array.\\n\\nHowever, the array can be a regular sorted array (ascending order), or a rotated sorted array. Also, you have mistakenly assigned the `ans=nums[start];` when the `nums[end]>nums[start]` which means the array is in ascending order. In this case, you\\'re not actually performing a search but returning the first element of the array, which is wrong.\\n\\nMoreover, the logic of your binary search inside the `else` statement is flawed. The condition `else if(nums[mid]>target)` implies that if the middle element is greater than the target, you should look to the right side of the array (increasing `start`), which is incorrect. When the middle element is greater, we need to look to the left side (decreasing `end`).\\n\\nThe corrected code should look like:\\n\\n```cpp\\nclass Solution {\\npublic:\\n    int search(vector<int>& nums, int target) {\\n        int n=nums.size();\\n\\n        int start=0, end=n-1;\\n        while(start<=end){\\n            int mid=start+(end-start)/2;\\n            if(nums[mid]==target){\\n                return mid;\\n            }\\n            // Determine which half to go, left half is sorted\\n            else if(nums[start] <= nums[mid]){\\n                if(target >= nums[start] && target < nums[mid]){\\n                    end = mid - 1;\\n                }else{\\n                    start = mid + 1;\\n                }\\n            }\\n            // Right half is sorted\\n            else{\\n                if(target > nums[mid] && target <= nums[end]){\\n                    start = mid + 1;\\n                }else{\\n                    end = mid - 1;\\n                }\\n            }\\n        }\\n        return -1;\\n    }\\n};\\n```\\n\\nThis code performs a binary search checking which half is sorted and whether the target falls into that half or not. Then it adjusts the `start` and `end` pointers accordingly and repeats until the target is found or the search space is empty.\\n"
                    },
                    {
                        "username": "Ragavan2003",
                        "content": "I think I miss the intention of the question ,I can use linear search and still get all test case passed.\\nIs the intention is too mislead you to think too much?."
                    },
                    {
                        "username": "deepak_guptacoder-369",
                        "content": "class Solution {\\npublic:\\n    int search(vector<int>& nums, int target) {\\n        int left = 0, right = nums.size() - 1;\\n        while (left <= right) {\\n            int mid = left + (right - left) / 2;\\n            if (nums[mid] == target) return mid;\\n            if (nums[left] <= nums[mid]) {\\n                if (nums[left] <= target && target < nums[mid]) right = mid - 1;\\n                else left = mid + 1;\\n            } else {\\n                if (nums[mid] < target && target <= nums[right]) left = mid + 1;\\n                else right = mid - 1;\\n            }\\n        }\\n        return -1;\\n    }\\n};\\n"
                    },
                    {
                        "username": "ashutoshbhardwaj25122000",
                        "content": "Idea here is basically that if we keep breaking the array into two halves, then either the left array will be ordered or right array will be ordered. If the target value lies in the ordered half, then our further finding is restricted to this portion, otherwise it will get restricted to the other portion which is unordered. Doing this recursively, we will be able to find the index of target."
                    },
                    {
                        "username": "satyam_rai15",
                        "content": "The question is pointless as it doesn\\'t give TLE for O(N) solutions"
                    }
                ]
            },
            {
                "id": 1797599,
                "content": [
                    {
                        "username": "Shivam_Tyagi_G",
                        "content": "Beat 100% solutions\\nclass Solution {\\n    int solve(vector<int> &arr)\\n    {\\n        int low = 0;\\n        int n = arr.size()-1;\\n        int high = n;\\n        int mid;\\n        while(low<high)\\n        {\\n            mid = low+(high-low)/2;\\n            if(arr[mid] < arr[n])\\n            {\\n                high = mid;\\n            }\\n            else{\\n                low = mid+1;\\n            }\\n        }\\n        return low;\\n    }\\npublic:\\n    int search(vector<int>& arr, int target) {\\n        int pivot = solve(arr);\\n    int n = arr.size() - 1;\\n    int low, high;\\n    if (target <= arr[n]){\\n        low = pivot;\\n        high = n;\\n    }\\n    else{\\n        low = 0;\\n        high = pivot-1;\\n    }\\n    cout<<pivot<<endl;\\n    while(low<=high)\\n    {\\n        int mid = low+(high-low)/2;\\n        if(arr[mid] == target)\\n        {\\n            return mid;\\n        }\\n        else if(arr[mid] > target){\\n            high = mid-1;\\n        }\\n        else{\\n            low = mid+1;\\n        }\\n    }\\n    return -1;\\n    }\\n};"
                    },
                    {
                        "username": "Mit_Bhardiwala",
                        "content": "The concept is primarily of binary search. First we  need to find pivot index and then search target according to its value. Else it also passes for normal inbuilt search functions(which u should not try)."
                    },
                    {
                        "username": "YashuCoder",
                        "content": "This question really fucked me up . I had literally tried to change the binary search and tried to get the answer in O(logn) . But it did not happen . At last for fun I tried simple linear search it worked and beaten 70% lol . Wtf"
                    },
                    {
                        "username": "TiagoMendees",
                        "content": "Am i confused or is this problem too simple? Like i just used brute force by using a for loop and check if  ```nums[i] == target ```, if it was true return i, if nums doesn't contains target return -1.\n ```\n        for (size_t i = 0; i < nums.size(); i++)\n        {\n           if(nums[i] == target ) return i;\n        }\n        \n        return -1;\n```\n\nThis worked for me"
                    },
                    {
                        "username": "prasannapoola",
                        "content": "I covered all the ways that be able to go through left and right side of the array.\\nIf we don\\'t go for right side( left = mid +1 ) of array then there might be a chance target element present in left side of array. \\nI felt that conditions are too long but I don\\'t find other way.\\n\\n public int search(int[] nums, int target) {\\n        int left = 0;\\n        int right = nums.length-1;\\n        int mid = -1;\\n        boolean found = false;\\n        while(left<=right){\\n            mid = (left+right)/2;\\n            if(nums[mid]==target){\\n                found = true;\\n                break;\\n            }\\n            else if((target>nums[mid] && nums[left]<nums[right]) || (target<nums[mid] && nums[left]>nums[right] && nums[left]>target && nums[left]<=nums[mid] ) || (target>nums[mid] && nums[left]>target) || (target > nums[mid] && nums[mid]>nums[left])){\\n                left = mid + 1;\\n            }\\n            else{\\n                right = mid - 1;\\n            }\\n        }\\n        return (found)?mid:-1;\\n    }\\n"
                    },
                    {
                        "username": "bparanj",
                        "content": "Your code seems correct, but it is indeed a bit convoluted. In a coding interview, readability and simplicity are often as important as correctness. This means that the ideal solution is not only correct but also easy to understand.\\n\\nLet\\'s critique your solution:\\n\\n1. **Complex conditions:** The conditions inside your if and else if blocks are quite complex. This not only makes the code hard to read and understand, but also prone to errors. It would be better to break these conditions down into separate if else blocks with clear comments explaining the logic.\\n\\n2. **Use of found flag:** The boolean flag \"found\" is not necessary. You can just return `mid` from within the loop when you find the target.\\n\\n3. **Variable Naming:** It would be better to name your variables according to what they represent. For example, `left` and `right` could be `low` and `high`, which might more clearly represent the lower and upper bounds of the search range.\\n\\n4. **Code Comments:** Your code lacks comments, which would be useful in explaining the logic, especially when the condition checks are complex.\\n\\nHere\\'s a simpler version of a binary search algorithm on a rotated sorted array:\\n\\n```java\\npublic int search(int[] nums, int target) {\\n    int low = 0, high = nums.length - 1;\\n    while (low <= high) {\\n        int mid = (low + high) / 2;\\n        if (nums[mid] == target) return mid;\\n\\n        if (nums[low] <= nums[mid]) { // left half is sorted\\n            if (nums[low] <= target && target < nums[mid]) high = mid - 1; // target is in left half\\n            else low = mid + 1; // target is in right half\\n        } \\n        else { // right half is sorted\\n            if (nums[mid] < target && target <= nums[high]) low = mid + 1; // target is in right half\\n            else high = mid - 1; // target is in left half\\n        }\\n    }\\n    return -1;\\n}\\n```\\nThis code is more readable, shorter, and it accomplishes the same goal. It divides the array into two halves, checks which half is sorted, and determines which half the target could be in. Then, it repeats the process for that half."
                    },
                    {
                        "username": "Nobody_cares",
                        "content": "Why I am getting \\'-1\\' for the input [4,5,6,0,1,2] for the following code:\\nclass Solution {\\npublic:\\n    int search(vector<int>& nums, int target) {\\n        int n=nums.size(), ans;\\n        \\n        int start=0, end=n-1;\\n        if(nums[end]>nums[start]){\\n            ans=nums[start];\\n        }\\n        else{\\n            bool found=false;\\n            while(start<=end){\\n                int mid=start+(end-start)/2;\\n                if(nums[mid]==target){\\n                    found=true;\\n                    ans=mid;\\n                    break;\\n                }\\n                else if(nums[mid]>target){\\n                    start=mid+1;\\n                }\\n                else{\\n                    end=mid-1;\\n                }\\n            }\\n            if(!found) ans=-1;\\n            \\n        }\\n        return ans;\\n    }\\n};"
                    },
                    {
                        "username": "bparanj",
                        "content": "Your current implementation is wrong because it assumes that the array is always sorted in descending order and that if it\\'s not, it must be a rotated array.\\n\\nHowever, the array can be a regular sorted array (ascending order), or a rotated sorted array. Also, you have mistakenly assigned the `ans=nums[start];` when the `nums[end]>nums[start]` which means the array is in ascending order. In this case, you\\'re not actually performing a search but returning the first element of the array, which is wrong.\\n\\nMoreover, the logic of your binary search inside the `else` statement is flawed. The condition `else if(nums[mid]>target)` implies that if the middle element is greater than the target, you should look to the right side of the array (increasing `start`), which is incorrect. When the middle element is greater, we need to look to the left side (decreasing `end`).\\n\\nThe corrected code should look like:\\n\\n```cpp\\nclass Solution {\\npublic:\\n    int search(vector<int>& nums, int target) {\\n        int n=nums.size();\\n\\n        int start=0, end=n-1;\\n        while(start<=end){\\n            int mid=start+(end-start)/2;\\n            if(nums[mid]==target){\\n                return mid;\\n            }\\n            // Determine which half to go, left half is sorted\\n            else if(nums[start] <= nums[mid]){\\n                if(target >= nums[start] && target < nums[mid]){\\n                    end = mid - 1;\\n                }else{\\n                    start = mid + 1;\\n                }\\n            }\\n            // Right half is sorted\\n            else{\\n                if(target > nums[mid] && target <= nums[end]){\\n                    start = mid + 1;\\n                }else{\\n                    end = mid - 1;\\n                }\\n            }\\n        }\\n        return -1;\\n    }\\n};\\n```\\n\\nThis code performs a binary search checking which half is sorted and whether the target falls into that half or not. Then it adjusts the `start` and `end` pointers accordingly and repeats until the target is found or the search space is empty.\\n"
                    },
                    {
                        "username": "Ragavan2003",
                        "content": "I think I miss the intention of the question ,I can use linear search and still get all test case passed.\\nIs the intention is too mislead you to think too much?."
                    },
                    {
                        "username": "deepak_guptacoder-369",
                        "content": "class Solution {\\npublic:\\n    int search(vector<int>& nums, int target) {\\n        int left = 0, right = nums.size() - 1;\\n        while (left <= right) {\\n            int mid = left + (right - left) / 2;\\n            if (nums[mid] == target) return mid;\\n            if (nums[left] <= nums[mid]) {\\n                if (nums[left] <= target && target < nums[mid]) right = mid - 1;\\n                else left = mid + 1;\\n            } else {\\n                if (nums[mid] < target && target <= nums[right]) left = mid + 1;\\n                else right = mid - 1;\\n            }\\n        }\\n        return -1;\\n    }\\n};\\n"
                    },
                    {
                        "username": "ashutoshbhardwaj25122000",
                        "content": "Idea here is basically that if we keep breaking the array into two halves, then either the left array will be ordered or right array will be ordered. If the target value lies in the ordered half, then our further finding is restricted to this portion, otherwise it will get restricted to the other portion which is unordered. Doing this recursively, we will be able to find the index of target."
                    },
                    {
                        "username": "satyam_rai15",
                        "content": "The question is pointless as it doesn\\'t give TLE for O(N) solutions"
                    }
                ]
            },
            {
                "id": 1796857,
                "content": [
                    {
                        "username": "Shivam_Tyagi_G",
                        "content": "Beat 100% solutions\\nclass Solution {\\n    int solve(vector<int> &arr)\\n    {\\n        int low = 0;\\n        int n = arr.size()-1;\\n        int high = n;\\n        int mid;\\n        while(low<high)\\n        {\\n            mid = low+(high-low)/2;\\n            if(arr[mid] < arr[n])\\n            {\\n                high = mid;\\n            }\\n            else{\\n                low = mid+1;\\n            }\\n        }\\n        return low;\\n    }\\npublic:\\n    int search(vector<int>& arr, int target) {\\n        int pivot = solve(arr);\\n    int n = arr.size() - 1;\\n    int low, high;\\n    if (target <= arr[n]){\\n        low = pivot;\\n        high = n;\\n    }\\n    else{\\n        low = 0;\\n        high = pivot-1;\\n    }\\n    cout<<pivot<<endl;\\n    while(low<=high)\\n    {\\n        int mid = low+(high-low)/2;\\n        if(arr[mid] == target)\\n        {\\n            return mid;\\n        }\\n        else if(arr[mid] > target){\\n            high = mid-1;\\n        }\\n        else{\\n            low = mid+1;\\n        }\\n    }\\n    return -1;\\n    }\\n};"
                    },
                    {
                        "username": "Mit_Bhardiwala",
                        "content": "The concept is primarily of binary search. First we  need to find pivot index and then search target according to its value. Else it also passes for normal inbuilt search functions(which u should not try)."
                    },
                    {
                        "username": "YashuCoder",
                        "content": "This question really fucked me up . I had literally tried to change the binary search and tried to get the answer in O(logn) . But it did not happen . At last for fun I tried simple linear search it worked and beaten 70% lol . Wtf"
                    },
                    {
                        "username": "TiagoMendees",
                        "content": "Am i confused or is this problem too simple? Like i just used brute force by using a for loop and check if  ```nums[i] == target ```, if it was true return i, if nums doesn't contains target return -1.\n ```\n        for (size_t i = 0; i < nums.size(); i++)\n        {\n           if(nums[i] == target ) return i;\n        }\n        \n        return -1;\n```\n\nThis worked for me"
                    },
                    {
                        "username": "prasannapoola",
                        "content": "I covered all the ways that be able to go through left and right side of the array.\\nIf we don\\'t go for right side( left = mid +1 ) of array then there might be a chance target element present in left side of array. \\nI felt that conditions are too long but I don\\'t find other way.\\n\\n public int search(int[] nums, int target) {\\n        int left = 0;\\n        int right = nums.length-1;\\n        int mid = -1;\\n        boolean found = false;\\n        while(left<=right){\\n            mid = (left+right)/2;\\n            if(nums[mid]==target){\\n                found = true;\\n                break;\\n            }\\n            else if((target>nums[mid] && nums[left]<nums[right]) || (target<nums[mid] && nums[left]>nums[right] && nums[left]>target && nums[left]<=nums[mid] ) || (target>nums[mid] && nums[left]>target) || (target > nums[mid] && nums[mid]>nums[left])){\\n                left = mid + 1;\\n            }\\n            else{\\n                right = mid - 1;\\n            }\\n        }\\n        return (found)?mid:-1;\\n    }\\n"
                    },
                    {
                        "username": "bparanj",
                        "content": "Your code seems correct, but it is indeed a bit convoluted. In a coding interview, readability and simplicity are often as important as correctness. This means that the ideal solution is not only correct but also easy to understand.\\n\\nLet\\'s critique your solution:\\n\\n1. **Complex conditions:** The conditions inside your if and else if blocks are quite complex. This not only makes the code hard to read and understand, but also prone to errors. It would be better to break these conditions down into separate if else blocks with clear comments explaining the logic.\\n\\n2. **Use of found flag:** The boolean flag \"found\" is not necessary. You can just return `mid` from within the loop when you find the target.\\n\\n3. **Variable Naming:** It would be better to name your variables according to what they represent. For example, `left` and `right` could be `low` and `high`, which might more clearly represent the lower and upper bounds of the search range.\\n\\n4. **Code Comments:** Your code lacks comments, which would be useful in explaining the logic, especially when the condition checks are complex.\\n\\nHere\\'s a simpler version of a binary search algorithm on a rotated sorted array:\\n\\n```java\\npublic int search(int[] nums, int target) {\\n    int low = 0, high = nums.length - 1;\\n    while (low <= high) {\\n        int mid = (low + high) / 2;\\n        if (nums[mid] == target) return mid;\\n\\n        if (nums[low] <= nums[mid]) { // left half is sorted\\n            if (nums[low] <= target && target < nums[mid]) high = mid - 1; // target is in left half\\n            else low = mid + 1; // target is in right half\\n        } \\n        else { // right half is sorted\\n            if (nums[mid] < target && target <= nums[high]) low = mid + 1; // target is in right half\\n            else high = mid - 1; // target is in left half\\n        }\\n    }\\n    return -1;\\n}\\n```\\nThis code is more readable, shorter, and it accomplishes the same goal. It divides the array into two halves, checks which half is sorted, and determines which half the target could be in. Then, it repeats the process for that half."
                    },
                    {
                        "username": "Nobody_cares",
                        "content": "Why I am getting \\'-1\\' for the input [4,5,6,0,1,2] for the following code:\\nclass Solution {\\npublic:\\n    int search(vector<int>& nums, int target) {\\n        int n=nums.size(), ans;\\n        \\n        int start=0, end=n-1;\\n        if(nums[end]>nums[start]){\\n            ans=nums[start];\\n        }\\n        else{\\n            bool found=false;\\n            while(start<=end){\\n                int mid=start+(end-start)/2;\\n                if(nums[mid]==target){\\n                    found=true;\\n                    ans=mid;\\n                    break;\\n                }\\n                else if(nums[mid]>target){\\n                    start=mid+1;\\n                }\\n                else{\\n                    end=mid-1;\\n                }\\n            }\\n            if(!found) ans=-1;\\n            \\n        }\\n        return ans;\\n    }\\n};"
                    },
                    {
                        "username": "bparanj",
                        "content": "Your current implementation is wrong because it assumes that the array is always sorted in descending order and that if it\\'s not, it must be a rotated array.\\n\\nHowever, the array can be a regular sorted array (ascending order), or a rotated sorted array. Also, you have mistakenly assigned the `ans=nums[start];` when the `nums[end]>nums[start]` which means the array is in ascending order. In this case, you\\'re not actually performing a search but returning the first element of the array, which is wrong.\\n\\nMoreover, the logic of your binary search inside the `else` statement is flawed. The condition `else if(nums[mid]>target)` implies that if the middle element is greater than the target, you should look to the right side of the array (increasing `start`), which is incorrect. When the middle element is greater, we need to look to the left side (decreasing `end`).\\n\\nThe corrected code should look like:\\n\\n```cpp\\nclass Solution {\\npublic:\\n    int search(vector<int>& nums, int target) {\\n        int n=nums.size();\\n\\n        int start=0, end=n-1;\\n        while(start<=end){\\n            int mid=start+(end-start)/2;\\n            if(nums[mid]==target){\\n                return mid;\\n            }\\n            // Determine which half to go, left half is sorted\\n            else if(nums[start] <= nums[mid]){\\n                if(target >= nums[start] && target < nums[mid]){\\n                    end = mid - 1;\\n                }else{\\n                    start = mid + 1;\\n                }\\n            }\\n            // Right half is sorted\\n            else{\\n                if(target > nums[mid] && target <= nums[end]){\\n                    start = mid + 1;\\n                }else{\\n                    end = mid - 1;\\n                }\\n            }\\n        }\\n        return -1;\\n    }\\n};\\n```\\n\\nThis code performs a binary search checking which half is sorted and whether the target falls into that half or not. Then it adjusts the `start` and `end` pointers accordingly and repeats until the target is found or the search space is empty.\\n"
                    },
                    {
                        "username": "Ragavan2003",
                        "content": "I think I miss the intention of the question ,I can use linear search and still get all test case passed.\\nIs the intention is too mislead you to think too much?."
                    },
                    {
                        "username": "deepak_guptacoder-369",
                        "content": "class Solution {\\npublic:\\n    int search(vector<int>& nums, int target) {\\n        int left = 0, right = nums.size() - 1;\\n        while (left <= right) {\\n            int mid = left + (right - left) / 2;\\n            if (nums[mid] == target) return mid;\\n            if (nums[left] <= nums[mid]) {\\n                if (nums[left] <= target && target < nums[mid]) right = mid - 1;\\n                else left = mid + 1;\\n            } else {\\n                if (nums[mid] < target && target <= nums[right]) left = mid + 1;\\n                else right = mid - 1;\\n            }\\n        }\\n        return -1;\\n    }\\n};\\n"
                    },
                    {
                        "username": "ashutoshbhardwaj25122000",
                        "content": "Idea here is basically that if we keep breaking the array into two halves, then either the left array will be ordered or right array will be ordered. If the target value lies in the ordered half, then our further finding is restricted to this portion, otherwise it will get restricted to the other portion which is unordered. Doing this recursively, we will be able to find the index of target."
                    },
                    {
                        "username": "satyam_rai15",
                        "content": "The question is pointless as it doesn\\'t give TLE for O(N) solutions"
                    }
                ]
            },
            {
                "id": 1796422,
                "content": [
                    {
                        "username": "Shivam_Tyagi_G",
                        "content": "Beat 100% solutions\\nclass Solution {\\n    int solve(vector<int> &arr)\\n    {\\n        int low = 0;\\n        int n = arr.size()-1;\\n        int high = n;\\n        int mid;\\n        while(low<high)\\n        {\\n            mid = low+(high-low)/2;\\n            if(arr[mid] < arr[n])\\n            {\\n                high = mid;\\n            }\\n            else{\\n                low = mid+1;\\n            }\\n        }\\n        return low;\\n    }\\npublic:\\n    int search(vector<int>& arr, int target) {\\n        int pivot = solve(arr);\\n    int n = arr.size() - 1;\\n    int low, high;\\n    if (target <= arr[n]){\\n        low = pivot;\\n        high = n;\\n    }\\n    else{\\n        low = 0;\\n        high = pivot-1;\\n    }\\n    cout<<pivot<<endl;\\n    while(low<=high)\\n    {\\n        int mid = low+(high-low)/2;\\n        if(arr[mid] == target)\\n        {\\n            return mid;\\n        }\\n        else if(arr[mid] > target){\\n            high = mid-1;\\n        }\\n        else{\\n            low = mid+1;\\n        }\\n    }\\n    return -1;\\n    }\\n};"
                    },
                    {
                        "username": "Mit_Bhardiwala",
                        "content": "The concept is primarily of binary search. First we  need to find pivot index and then search target according to its value. Else it also passes for normal inbuilt search functions(which u should not try)."
                    },
                    {
                        "username": "YashuCoder",
                        "content": "This question really fucked me up . I had literally tried to change the binary search and tried to get the answer in O(logn) . But it did not happen . At last for fun I tried simple linear search it worked and beaten 70% lol . Wtf"
                    },
                    {
                        "username": "TiagoMendees",
                        "content": "Am i confused or is this problem too simple? Like i just used brute force by using a for loop and check if  ```nums[i] == target ```, if it was true return i, if nums doesn't contains target return -1.\n ```\n        for (size_t i = 0; i < nums.size(); i++)\n        {\n           if(nums[i] == target ) return i;\n        }\n        \n        return -1;\n```\n\nThis worked for me"
                    },
                    {
                        "username": "prasannapoola",
                        "content": "I covered all the ways that be able to go through left and right side of the array.\\nIf we don\\'t go for right side( left = mid +1 ) of array then there might be a chance target element present in left side of array. \\nI felt that conditions are too long but I don\\'t find other way.\\n\\n public int search(int[] nums, int target) {\\n        int left = 0;\\n        int right = nums.length-1;\\n        int mid = -1;\\n        boolean found = false;\\n        while(left<=right){\\n            mid = (left+right)/2;\\n            if(nums[mid]==target){\\n                found = true;\\n                break;\\n            }\\n            else if((target>nums[mid] && nums[left]<nums[right]) || (target<nums[mid] && nums[left]>nums[right] && nums[left]>target && nums[left]<=nums[mid] ) || (target>nums[mid] && nums[left]>target) || (target > nums[mid] && nums[mid]>nums[left])){\\n                left = mid + 1;\\n            }\\n            else{\\n                right = mid - 1;\\n            }\\n        }\\n        return (found)?mid:-1;\\n    }\\n"
                    },
                    {
                        "username": "bparanj",
                        "content": "Your code seems correct, but it is indeed a bit convoluted. In a coding interview, readability and simplicity are often as important as correctness. This means that the ideal solution is not only correct but also easy to understand.\\n\\nLet\\'s critique your solution:\\n\\n1. **Complex conditions:** The conditions inside your if and else if blocks are quite complex. This not only makes the code hard to read and understand, but also prone to errors. It would be better to break these conditions down into separate if else blocks with clear comments explaining the logic.\\n\\n2. **Use of found flag:** The boolean flag \"found\" is not necessary. You can just return `mid` from within the loop when you find the target.\\n\\n3. **Variable Naming:** It would be better to name your variables according to what they represent. For example, `left` and `right` could be `low` and `high`, which might more clearly represent the lower and upper bounds of the search range.\\n\\n4. **Code Comments:** Your code lacks comments, which would be useful in explaining the logic, especially when the condition checks are complex.\\n\\nHere\\'s a simpler version of a binary search algorithm on a rotated sorted array:\\n\\n```java\\npublic int search(int[] nums, int target) {\\n    int low = 0, high = nums.length - 1;\\n    while (low <= high) {\\n        int mid = (low + high) / 2;\\n        if (nums[mid] == target) return mid;\\n\\n        if (nums[low] <= nums[mid]) { // left half is sorted\\n            if (nums[low] <= target && target < nums[mid]) high = mid - 1; // target is in left half\\n            else low = mid + 1; // target is in right half\\n        } \\n        else { // right half is sorted\\n            if (nums[mid] < target && target <= nums[high]) low = mid + 1; // target is in right half\\n            else high = mid - 1; // target is in left half\\n        }\\n    }\\n    return -1;\\n}\\n```\\nThis code is more readable, shorter, and it accomplishes the same goal. It divides the array into two halves, checks which half is sorted, and determines which half the target could be in. Then, it repeats the process for that half."
                    },
                    {
                        "username": "Nobody_cares",
                        "content": "Why I am getting \\'-1\\' for the input [4,5,6,0,1,2] for the following code:\\nclass Solution {\\npublic:\\n    int search(vector<int>& nums, int target) {\\n        int n=nums.size(), ans;\\n        \\n        int start=0, end=n-1;\\n        if(nums[end]>nums[start]){\\n            ans=nums[start];\\n        }\\n        else{\\n            bool found=false;\\n            while(start<=end){\\n                int mid=start+(end-start)/2;\\n                if(nums[mid]==target){\\n                    found=true;\\n                    ans=mid;\\n                    break;\\n                }\\n                else if(nums[mid]>target){\\n                    start=mid+1;\\n                }\\n                else{\\n                    end=mid-1;\\n                }\\n            }\\n            if(!found) ans=-1;\\n            \\n        }\\n        return ans;\\n    }\\n};"
                    },
                    {
                        "username": "bparanj",
                        "content": "Your current implementation is wrong because it assumes that the array is always sorted in descending order and that if it\\'s not, it must be a rotated array.\\n\\nHowever, the array can be a regular sorted array (ascending order), or a rotated sorted array. Also, you have mistakenly assigned the `ans=nums[start];` when the `nums[end]>nums[start]` which means the array is in ascending order. In this case, you\\'re not actually performing a search but returning the first element of the array, which is wrong.\\n\\nMoreover, the logic of your binary search inside the `else` statement is flawed. The condition `else if(nums[mid]>target)` implies that if the middle element is greater than the target, you should look to the right side of the array (increasing `start`), which is incorrect. When the middle element is greater, we need to look to the left side (decreasing `end`).\\n\\nThe corrected code should look like:\\n\\n```cpp\\nclass Solution {\\npublic:\\n    int search(vector<int>& nums, int target) {\\n        int n=nums.size();\\n\\n        int start=0, end=n-1;\\n        while(start<=end){\\n            int mid=start+(end-start)/2;\\n            if(nums[mid]==target){\\n                return mid;\\n            }\\n            // Determine which half to go, left half is sorted\\n            else if(nums[start] <= nums[mid]){\\n                if(target >= nums[start] && target < nums[mid]){\\n                    end = mid - 1;\\n                }else{\\n                    start = mid + 1;\\n                }\\n            }\\n            // Right half is sorted\\n            else{\\n                if(target > nums[mid] && target <= nums[end]){\\n                    start = mid + 1;\\n                }else{\\n                    end = mid - 1;\\n                }\\n            }\\n        }\\n        return -1;\\n    }\\n};\\n```\\n\\nThis code performs a binary search checking which half is sorted and whether the target falls into that half or not. Then it adjusts the `start` and `end` pointers accordingly and repeats until the target is found or the search space is empty.\\n"
                    },
                    {
                        "username": "Ragavan2003",
                        "content": "I think I miss the intention of the question ,I can use linear search and still get all test case passed.\\nIs the intention is too mislead you to think too much?."
                    },
                    {
                        "username": "deepak_guptacoder-369",
                        "content": "class Solution {\\npublic:\\n    int search(vector<int>& nums, int target) {\\n        int left = 0, right = nums.size() - 1;\\n        while (left <= right) {\\n            int mid = left + (right - left) / 2;\\n            if (nums[mid] == target) return mid;\\n            if (nums[left] <= nums[mid]) {\\n                if (nums[left] <= target && target < nums[mid]) right = mid - 1;\\n                else left = mid + 1;\\n            } else {\\n                if (nums[mid] < target && target <= nums[right]) left = mid + 1;\\n                else right = mid - 1;\\n            }\\n        }\\n        return -1;\\n    }\\n};\\n"
                    },
                    {
                        "username": "ashutoshbhardwaj25122000",
                        "content": "Idea here is basically that if we keep breaking the array into two halves, then either the left array will be ordered or right array will be ordered. If the target value lies in the ordered half, then our further finding is restricted to this portion, otherwise it will get restricted to the other portion which is unordered. Doing this recursively, we will be able to find the index of target."
                    },
                    {
                        "username": "satyam_rai15",
                        "content": "The question is pointless as it doesn\\'t give TLE for O(N) solutions"
                    }
                ]
            },
            {
                "id": 1796303,
                "content": [
                    {
                        "username": "addu_coder",
                        "content": "I had used linear search and it\\'s find LoL!!!  @[leetcode](https://leetcode.com)"
                    },
                    {
                        "username": "NishantKende",
                        "content": "Guys, take it easy, Don\\'t get confused due to question\\'s description.\\nYou just need to search an array element inside given array. If you find it, return the index else return -1"
                    },
                    {
                        "username": "adityy",
                        "content": "why is this not working?\\nclass Solution {\\npublic:\\n    int search(vector<int>& nums, int target) {\\n        int high = nums.size()-1;\\n        int low = 0;\\n        while(low<high){\\n            int mid = low + (high - low)/2;\\n            if(nums[mid]==target) return mid+1;\\n            else if(nums[mid]>nums[mid+1]){\\n                if(nums[mid]>target)\\n                low = mid+1;\\n                else high = mid-1;\\n            }\\n            else if(nums[mid]<nums[mid+1]){\\n                if(nums[mid]>=target && nums[low]<=target)\\n                high = mid-1;\\n                else low = mid+1;\\n            }\\n        }\\n        return -1;\\n    }\\n};"
                    },
                    {
                        "username": "bparanj",
                        "content": "There are a couple of issues with your code. Here are the corrections:\\n\\n1. Your binary search loop should continue while `low <= high`, not while `low < high`. \\n\\n2. The check `nums[mid]==target` should return `mid`, not `mid+1`.\\n\\n3. Your conditions for checking which half to look in are incorrect. You want to determine if the left half is sorted and if the target is in that range, or if the right half is sorted and if the target is in that range.\\n\\nHere is a corrected version of your code:\\n\\n```cpp\\nclass Solution {\\npublic:\\n    int search(vector<int>& nums, int target) {\\n        int high = nums.size() - 1;\\n        int low = 0;\\n        while(low <= high){\\n            int mid = low + (high - low) / 2;\\n            if(nums[mid] == target) \\n                return mid;\\n            if(nums[low] <= nums[mid]) {  // Left half is sorted.\\n                if(nums[low] <= target && target < nums[mid]) \\n                    high = mid - 1;  // Target is in the left half.\\n                else\\n                    low = mid + 1;  // Target is in the right half.\\n            }\\n            else {  // Right half is sorted.\\n                if(nums[mid] < target && target <= nums[high])\\n                    low = mid + 1;  // Target is in the right half.\\n                else\\n                    high = mid - 1;  // Target is in the left half.\\n            }\\n        }\\n        return -1;\\n    }\\n};\\n```\\n\\nThis code works by first finding the middle of the current search range. If the middle element is the target, we\\'re done. Otherwise, we check if the left half of the range is sorted. If it is, and the target is in the range of the left half, we continue searching in the left half; otherwise, we search in the right half. If the left half is not sorted, that means the right half must be sorted. We then check if the target is in the range of the right half, and if so we continue searching in the right half; otherwise, we search in the left half."
                    },
                    {
                        "username": "kimkass",
                        "content": "def count_rotations_binary(nums):\\n    lo = 0\\n    hi = len(nums)-1\\n\\n    while hi>lo:\\n        mid = lo+hi//2\\n        mid_number = nums[mid]\\n\\n        print(\"lo :\",lo ,\"hi :\", hi,  \"mid :\",mid ,\"mid number :\", mid_number)\\n\\n        if mid > 0 and nums[mid] < nums[mid-1]:\\n            return mid\\n\\n        elif nums[mid] < nums[hi]:\\n            hi = mid-1\\n\\n        else:\\n            lo = mid+1\\n\\n// input nums : test1 = {\\n    \\'input\\' : {\\n        \\'nums\\' : [4,5,6,7,8,1,2,3] # after rotating 5 times\\n    },\\n    \\'output\\' : 5 # rotated 5 times means output = 5\\n}\\n\\n// Test failed on second division where mid + 1 = 4. following the same lo+hi//2. expected answer: 4+7=11.  11//2 = 5. \\nI am getting 7 for division of 11//2 as mid. what\\'s the problem in this code ?"
                    },
                    {
                        "username": "bparanj",
                        "content": "The issue lies in the order of operations in this line:\\n\\n```python\\nmid = lo + hi // 2\\n```\\n\\nIn Python, the division operator `//` has higher precedence than the addition operator `+`. This means that your code is actually performing `(hi // 2)` first, and then adding `lo` to the result. This will cause `mid` to be calculated incorrectly.\\n\\nYou want to divide the sum of `lo` and `hi` by `2`, so you should use parentheses to ensure the correct order of operations:\\n\\n```python\\nmid = (lo + hi) // 2\\n```\\n\\nThis line will first add `lo` and `hi`, and then divide the result by `2` (performing integer division), which will correctly calculate the middle index. Here\\'s the corrected code:\\n\\n```python\\ndef count_rotations_binary(nums):\\n    lo = 0\\n    hi = len(nums)-1\\n\\n    while hi > lo:\\n        mid = (lo + hi) // 2\\n        mid_number = nums[mid]\\n\\n        print(\"lo :\", lo, \"hi :\", hi, \"mid :\", mid, \"mid number :\", mid_number)\\n\\n        if mid > 0 and nums[mid] < nums[mid-1]:\\n            return mid\\n        elif nums[mid] < nums[hi]:\\n            hi = mid - 1\\n        else:\\n            lo = mid + 1\\n```\\n\\nThis will now correctly calculate the middle index and should produce the expected result."
                    },
                    {
                        "username": "kimkass",
                        "content": "if the target is different for every list the function has to be separate for  every list.\nor passing two elements in parenthesis nums (list as input) and output(target number as input), where function should return target number index position will work ?"
                    },
                    {
                        "username": "bparanj",
                        "content": "Yes, you can certainly pass the target number as an additional argument to the function. This is a common practice and will allow you to use the same function to search for different targets in different lists. The function signature would look something like this:\\n\\n```python\\ndef binary_search(nums, target):\\n    # Implementation here\\n```\\n\\nIn the body of this function, you would implement your binary search (or whatever searching algorithm you\\'re using). This function would take a list of numbers (`nums`) and a target number (`target`), and it would return the index of `target` within `nums`. If `target` is not in `nums`, you could return `-1` or some other sentinel value.\\n\\nHere\\'s an example of how you might call this function:\\n\\n```python\\nnums = [4, 5, 6, 7, 8, 1, 2, 3]\\ntarget = 6\\nprint(binary_search(nums, target))  # This would print 2, assuming the list is zero-indexed\\n```\\n\\nBy parameterizing the target number, you can easily reuse the same function to search for different targets in different lists."
                    },
                    {
                        "username": "skadam183",
                        "content": "I am wondering if it\\'s only me who is thinking problem was too easy or too difficult that I didn\\'t understand.\\nIt was just one liner.\\n\\n` return nums.indexOf(target);`"
                    },
                    {
                        "username": "brbamcoding",
                        "content": "This would not have log time complexity. It would be linear"
                    },
                    {
                        "username": "ziico",
                        "content": "Why does this pass all the test cases with linear search if its time complexity is O(n). Shouldn\\'t it pass all the test cases only if binary search is used, as O(logn) is required. I\\'m confused??\\n"
                    },
                    {
                        "username": "rasin02",
                        "content": "Approch 1\\n\\n uses a while loop to repeatedly divide the search space in half until the target value is found or until the search space is exhausted. \\n The loop starts with the left index set to 0 and the right index set to the last element of the array.\\n The mid index is calculated as the average of the left and right indices. \\n The function then checks if the element at the mid index is equal to the target value, and if so, it returns the mid index as the result. If the element at the mid index is not equal to the target value, the function checks if the left side of the array is strictly increasing or not. \\n If it is, it checks if the target value is between the left and mid elements, and if so, it updates the right index to be one less than the mid index, otherwise it updates the left index to be one more than the mid index.\\n If the left side is not strictly increasing, the function checks if the target value is between the mid and right elements, and if so, it updates the left index to be one more than the mid index, otherwise it updates the right index to be one less than the mid index. \\n If the search space is exhausted without finding the target value, the function returns -1. \\n\\nint search(vector<int>& nums, int target) \\n    {\\n        int left=0;\\n        int right=nums.size()-1;\\n        int mid;\\n        while(left<=right)\\n        {\\n            mid=(left+right)/2;\\n            if(nums[mid]==target)\\n            return mid;\\n            //check if left side is strictly increasing or not\\n            else if (nums[left]<=nums[mid])\\n            {\\n                if(nums[left]<=target && nums[mid]>=target)\\n                \\n                    right=mid-1;\\n                    else \\n                    {\\n                    left=mid+1;\\n                    }\\n            \\n            }\\n            //check if right side is strictly increasing or not\\n\\n            else \\n            {\\n                if(nums[mid]<=target && nums[right]>=target)\\n                \\n                    left=mid+1;\\n                else \\n                    right=mid-1;\\n                \\n            }\\n        }   \\n        return -1;   \\n    }\\n\\nApproach 2\\nusing the concept the earlier solved provblem number 33\\nin which we were asked to find the minimin element in the roated sorted arrray\\nusign that concept we find the index of the minimum element  of the arrray and the we use the binary search to search the target in the start to index and  apply another search on the index+1 to end and how ever return the answer greater than -1 will be final answer\\ni`nt binary_search(vector<int>& arr, int beg, int end, int target) {\\n         while(beg <= end) {\\n            int mid = beg + (end - beg) / 2;\\n            if (arr[mid] == target) {\\n                return mid;\\n            } else if (arr[mid] <= target) {\\n                beg = mid + 1;\\n            } else {\\n                end = mid - 1;\\n            }\\n        }\\n        return -1;\\n   }\\n   \\nint findmin(vector<int>nums, int target)\\n{\\n    int start=0;\\n    int n=nums.size()-1;\\n    int end=n-1;\\n\\n    int mid;\\n    while(start<=end){\\n        mid=start+(end-start)/2;\\n        int prev=(mid+n-1)%n;\\n        int next=(mid+1)%n;\\n        if(nums[mid]<=prev && nums[mid]<=next)\\n        return mid;\\n        else if(nums[mid]>=nums[0])\\n            start=mid+1;\\n        else if(nums[mid]<=nums[n])\\n            end=mid-1;\\n    }\\n    return 0;\\n}\\n  int search(vector<int>& nums, int target) \\n    {\\n        int min_index=findmin(nums,target);\\n        int ans1=binary_search(nums,0,min_index,target);\\n        int ans2=binary_search(nums,min_index,nums.size()-1,target);\\n        int a=ans1>0?ans1:-1;\\n        int b=ans2>0?ans2:-1;\\n        if(a>=0)\\n        return a;\\n        else\\n        return b;\\n        \\n    }\\n`\\n"
                    },
                    {
                        "username": "Joshi_Deepti",
                        "content": "i wonder why binary search approach(T.C-O(logn))  is giving TLE and iterative solution(T.C-O(n)) is working fine.."
                    },
                    {
                        "username": "Minato235",
                        "content": "var search = function(nums, target) {\\n    for(let i=0;i<nums.length;i++){\\n    if(nums[i]==target) return i;\\n}\\nreturn -1;\\n};"
                    }
                ]
            },
            {
                "id": 1793183,
                "content": [
                    {
                        "username": "addu_coder",
                        "content": "I had used linear search and it\\'s find LoL!!!  @[leetcode](https://leetcode.com)"
                    },
                    {
                        "username": "NishantKende",
                        "content": "Guys, take it easy, Don\\'t get confused due to question\\'s description.\\nYou just need to search an array element inside given array. If you find it, return the index else return -1"
                    },
                    {
                        "username": "adityy",
                        "content": "why is this not working?\\nclass Solution {\\npublic:\\n    int search(vector<int>& nums, int target) {\\n        int high = nums.size()-1;\\n        int low = 0;\\n        while(low<high){\\n            int mid = low + (high - low)/2;\\n            if(nums[mid]==target) return mid+1;\\n            else if(nums[mid]>nums[mid+1]){\\n                if(nums[mid]>target)\\n                low = mid+1;\\n                else high = mid-1;\\n            }\\n            else if(nums[mid]<nums[mid+1]){\\n                if(nums[mid]>=target && nums[low]<=target)\\n                high = mid-1;\\n                else low = mid+1;\\n            }\\n        }\\n        return -1;\\n    }\\n};"
                    },
                    {
                        "username": "bparanj",
                        "content": "There are a couple of issues with your code. Here are the corrections:\\n\\n1. Your binary search loop should continue while `low <= high`, not while `low < high`. \\n\\n2. The check `nums[mid]==target` should return `mid`, not `mid+1`.\\n\\n3. Your conditions for checking which half to look in are incorrect. You want to determine if the left half is sorted and if the target is in that range, or if the right half is sorted and if the target is in that range.\\n\\nHere is a corrected version of your code:\\n\\n```cpp\\nclass Solution {\\npublic:\\n    int search(vector<int>& nums, int target) {\\n        int high = nums.size() - 1;\\n        int low = 0;\\n        while(low <= high){\\n            int mid = low + (high - low) / 2;\\n            if(nums[mid] == target) \\n                return mid;\\n            if(nums[low] <= nums[mid]) {  // Left half is sorted.\\n                if(nums[low] <= target && target < nums[mid]) \\n                    high = mid - 1;  // Target is in the left half.\\n                else\\n                    low = mid + 1;  // Target is in the right half.\\n            }\\n            else {  // Right half is sorted.\\n                if(nums[mid] < target && target <= nums[high])\\n                    low = mid + 1;  // Target is in the right half.\\n                else\\n                    high = mid - 1;  // Target is in the left half.\\n            }\\n        }\\n        return -1;\\n    }\\n};\\n```\\n\\nThis code works by first finding the middle of the current search range. If the middle element is the target, we\\'re done. Otherwise, we check if the left half of the range is sorted. If it is, and the target is in the range of the left half, we continue searching in the left half; otherwise, we search in the right half. If the left half is not sorted, that means the right half must be sorted. We then check if the target is in the range of the right half, and if so we continue searching in the right half; otherwise, we search in the left half."
                    },
                    {
                        "username": "kimkass",
                        "content": "def count_rotations_binary(nums):\\n    lo = 0\\n    hi = len(nums)-1\\n\\n    while hi>lo:\\n        mid = lo+hi//2\\n        mid_number = nums[mid]\\n\\n        print(\"lo :\",lo ,\"hi :\", hi,  \"mid :\",mid ,\"mid number :\", mid_number)\\n\\n        if mid > 0 and nums[mid] < nums[mid-1]:\\n            return mid\\n\\n        elif nums[mid] < nums[hi]:\\n            hi = mid-1\\n\\n        else:\\n            lo = mid+1\\n\\n// input nums : test1 = {\\n    \\'input\\' : {\\n        \\'nums\\' : [4,5,6,7,8,1,2,3] # after rotating 5 times\\n    },\\n    \\'output\\' : 5 # rotated 5 times means output = 5\\n}\\n\\n// Test failed on second division where mid + 1 = 4. following the same lo+hi//2. expected answer: 4+7=11.  11//2 = 5. \\nI am getting 7 for division of 11//2 as mid. what\\'s the problem in this code ?"
                    },
                    {
                        "username": "bparanj",
                        "content": "The issue lies in the order of operations in this line:\\n\\n```python\\nmid = lo + hi // 2\\n```\\n\\nIn Python, the division operator `//` has higher precedence than the addition operator `+`. This means that your code is actually performing `(hi // 2)` first, and then adding `lo` to the result. This will cause `mid` to be calculated incorrectly.\\n\\nYou want to divide the sum of `lo` and `hi` by `2`, so you should use parentheses to ensure the correct order of operations:\\n\\n```python\\nmid = (lo + hi) // 2\\n```\\n\\nThis line will first add `lo` and `hi`, and then divide the result by `2` (performing integer division), which will correctly calculate the middle index. Here\\'s the corrected code:\\n\\n```python\\ndef count_rotations_binary(nums):\\n    lo = 0\\n    hi = len(nums)-1\\n\\n    while hi > lo:\\n        mid = (lo + hi) // 2\\n        mid_number = nums[mid]\\n\\n        print(\"lo :\", lo, \"hi :\", hi, \"mid :\", mid, \"mid number :\", mid_number)\\n\\n        if mid > 0 and nums[mid] < nums[mid-1]:\\n            return mid\\n        elif nums[mid] < nums[hi]:\\n            hi = mid - 1\\n        else:\\n            lo = mid + 1\\n```\\n\\nThis will now correctly calculate the middle index and should produce the expected result."
                    },
                    {
                        "username": "kimkass",
                        "content": "if the target is different for every list the function has to be separate for  every list.\nor passing two elements in parenthesis nums (list as input) and output(target number as input), where function should return target number index position will work ?"
                    },
                    {
                        "username": "bparanj",
                        "content": "Yes, you can certainly pass the target number as an additional argument to the function. This is a common practice and will allow you to use the same function to search for different targets in different lists. The function signature would look something like this:\\n\\n```python\\ndef binary_search(nums, target):\\n    # Implementation here\\n```\\n\\nIn the body of this function, you would implement your binary search (or whatever searching algorithm you\\'re using). This function would take a list of numbers (`nums`) and a target number (`target`), and it would return the index of `target` within `nums`. If `target` is not in `nums`, you could return `-1` or some other sentinel value.\\n\\nHere\\'s an example of how you might call this function:\\n\\n```python\\nnums = [4, 5, 6, 7, 8, 1, 2, 3]\\ntarget = 6\\nprint(binary_search(nums, target))  # This would print 2, assuming the list is zero-indexed\\n```\\n\\nBy parameterizing the target number, you can easily reuse the same function to search for different targets in different lists."
                    },
                    {
                        "username": "skadam183",
                        "content": "I am wondering if it\\'s only me who is thinking problem was too easy or too difficult that I didn\\'t understand.\\nIt was just one liner.\\n\\n` return nums.indexOf(target);`"
                    },
                    {
                        "username": "brbamcoding",
                        "content": "This would not have log time complexity. It would be linear"
                    },
                    {
                        "username": "ziico",
                        "content": "Why does this pass all the test cases with linear search if its time complexity is O(n). Shouldn\\'t it pass all the test cases only if binary search is used, as O(logn) is required. I\\'m confused??\\n"
                    },
                    {
                        "username": "rasin02",
                        "content": "Approch 1\\n\\n uses a while loop to repeatedly divide the search space in half until the target value is found or until the search space is exhausted. \\n The loop starts with the left index set to 0 and the right index set to the last element of the array.\\n The mid index is calculated as the average of the left and right indices. \\n The function then checks if the element at the mid index is equal to the target value, and if so, it returns the mid index as the result. If the element at the mid index is not equal to the target value, the function checks if the left side of the array is strictly increasing or not. \\n If it is, it checks if the target value is between the left and mid elements, and if so, it updates the right index to be one less than the mid index, otherwise it updates the left index to be one more than the mid index.\\n If the left side is not strictly increasing, the function checks if the target value is between the mid and right elements, and if so, it updates the left index to be one more than the mid index, otherwise it updates the right index to be one less than the mid index. \\n If the search space is exhausted without finding the target value, the function returns -1. \\n\\nint search(vector<int>& nums, int target) \\n    {\\n        int left=0;\\n        int right=nums.size()-1;\\n        int mid;\\n        while(left<=right)\\n        {\\n            mid=(left+right)/2;\\n            if(nums[mid]==target)\\n            return mid;\\n            //check if left side is strictly increasing or not\\n            else if (nums[left]<=nums[mid])\\n            {\\n                if(nums[left]<=target && nums[mid]>=target)\\n                \\n                    right=mid-1;\\n                    else \\n                    {\\n                    left=mid+1;\\n                    }\\n            \\n            }\\n            //check if right side is strictly increasing or not\\n\\n            else \\n            {\\n                if(nums[mid]<=target && nums[right]>=target)\\n                \\n                    left=mid+1;\\n                else \\n                    right=mid-1;\\n                \\n            }\\n        }   \\n        return -1;   \\n    }\\n\\nApproach 2\\nusing the concept the earlier solved provblem number 33\\nin which we were asked to find the minimin element in the roated sorted arrray\\nusign that concept we find the index of the minimum element  of the arrray and the we use the binary search to search the target in the start to index and  apply another search on the index+1 to end and how ever return the answer greater than -1 will be final answer\\ni`nt binary_search(vector<int>& arr, int beg, int end, int target) {\\n         while(beg <= end) {\\n            int mid = beg + (end - beg) / 2;\\n            if (arr[mid] == target) {\\n                return mid;\\n            } else if (arr[mid] <= target) {\\n                beg = mid + 1;\\n            } else {\\n                end = mid - 1;\\n            }\\n        }\\n        return -1;\\n   }\\n   \\nint findmin(vector<int>nums, int target)\\n{\\n    int start=0;\\n    int n=nums.size()-1;\\n    int end=n-1;\\n\\n    int mid;\\n    while(start<=end){\\n        mid=start+(end-start)/2;\\n        int prev=(mid+n-1)%n;\\n        int next=(mid+1)%n;\\n        if(nums[mid]<=prev && nums[mid]<=next)\\n        return mid;\\n        else if(nums[mid]>=nums[0])\\n            start=mid+1;\\n        else if(nums[mid]<=nums[n])\\n            end=mid-1;\\n    }\\n    return 0;\\n}\\n  int search(vector<int>& nums, int target) \\n    {\\n        int min_index=findmin(nums,target);\\n        int ans1=binary_search(nums,0,min_index,target);\\n        int ans2=binary_search(nums,min_index,nums.size()-1,target);\\n        int a=ans1>0?ans1:-1;\\n        int b=ans2>0?ans2:-1;\\n        if(a>=0)\\n        return a;\\n        else\\n        return b;\\n        \\n    }\\n`\\n"
                    },
                    {
                        "username": "Joshi_Deepti",
                        "content": "i wonder why binary search approach(T.C-O(logn))  is giving TLE and iterative solution(T.C-O(n)) is working fine.."
                    },
                    {
                        "username": "Minato235",
                        "content": "var search = function(nums, target) {\\n    for(let i=0;i<nums.length;i++){\\n    if(nums[i]==target) return i;\\n}\\nreturn -1;\\n};"
                    }
                ]
            },
            {
                "id": 1792022,
                "content": [
                    {
                        "username": "addu_coder",
                        "content": "I had used linear search and it\\'s find LoL!!!  @[leetcode](https://leetcode.com)"
                    },
                    {
                        "username": "NishantKende",
                        "content": "Guys, take it easy, Don\\'t get confused due to question\\'s description.\\nYou just need to search an array element inside given array. If you find it, return the index else return -1"
                    },
                    {
                        "username": "adityy",
                        "content": "why is this not working?\\nclass Solution {\\npublic:\\n    int search(vector<int>& nums, int target) {\\n        int high = nums.size()-1;\\n        int low = 0;\\n        while(low<high){\\n            int mid = low + (high - low)/2;\\n            if(nums[mid]==target) return mid+1;\\n            else if(nums[mid]>nums[mid+1]){\\n                if(nums[mid]>target)\\n                low = mid+1;\\n                else high = mid-1;\\n            }\\n            else if(nums[mid]<nums[mid+1]){\\n                if(nums[mid]>=target && nums[low]<=target)\\n                high = mid-1;\\n                else low = mid+1;\\n            }\\n        }\\n        return -1;\\n    }\\n};"
                    },
                    {
                        "username": "bparanj",
                        "content": "There are a couple of issues with your code. Here are the corrections:\\n\\n1. Your binary search loop should continue while `low <= high`, not while `low < high`. \\n\\n2. The check `nums[mid]==target` should return `mid`, not `mid+1`.\\n\\n3. Your conditions for checking which half to look in are incorrect. You want to determine if the left half is sorted and if the target is in that range, or if the right half is sorted and if the target is in that range.\\n\\nHere is a corrected version of your code:\\n\\n```cpp\\nclass Solution {\\npublic:\\n    int search(vector<int>& nums, int target) {\\n        int high = nums.size() - 1;\\n        int low = 0;\\n        while(low <= high){\\n            int mid = low + (high - low) / 2;\\n            if(nums[mid] == target) \\n                return mid;\\n            if(nums[low] <= nums[mid]) {  // Left half is sorted.\\n                if(nums[low] <= target && target < nums[mid]) \\n                    high = mid - 1;  // Target is in the left half.\\n                else\\n                    low = mid + 1;  // Target is in the right half.\\n            }\\n            else {  // Right half is sorted.\\n                if(nums[mid] < target && target <= nums[high])\\n                    low = mid + 1;  // Target is in the right half.\\n                else\\n                    high = mid - 1;  // Target is in the left half.\\n            }\\n        }\\n        return -1;\\n    }\\n};\\n```\\n\\nThis code works by first finding the middle of the current search range. If the middle element is the target, we\\'re done. Otherwise, we check if the left half of the range is sorted. If it is, and the target is in the range of the left half, we continue searching in the left half; otherwise, we search in the right half. If the left half is not sorted, that means the right half must be sorted. We then check if the target is in the range of the right half, and if so we continue searching in the right half; otherwise, we search in the left half."
                    },
                    {
                        "username": "kimkass",
                        "content": "def count_rotations_binary(nums):\\n    lo = 0\\n    hi = len(nums)-1\\n\\n    while hi>lo:\\n        mid = lo+hi//2\\n        mid_number = nums[mid]\\n\\n        print(\"lo :\",lo ,\"hi :\", hi,  \"mid :\",mid ,\"mid number :\", mid_number)\\n\\n        if mid > 0 and nums[mid] < nums[mid-1]:\\n            return mid\\n\\n        elif nums[mid] < nums[hi]:\\n            hi = mid-1\\n\\n        else:\\n            lo = mid+1\\n\\n// input nums : test1 = {\\n    \\'input\\' : {\\n        \\'nums\\' : [4,5,6,7,8,1,2,3] # after rotating 5 times\\n    },\\n    \\'output\\' : 5 # rotated 5 times means output = 5\\n}\\n\\n// Test failed on second division where mid + 1 = 4. following the same lo+hi//2. expected answer: 4+7=11.  11//2 = 5. \\nI am getting 7 for division of 11//2 as mid. what\\'s the problem in this code ?"
                    },
                    {
                        "username": "bparanj",
                        "content": "The issue lies in the order of operations in this line:\\n\\n```python\\nmid = lo + hi // 2\\n```\\n\\nIn Python, the division operator `//` has higher precedence than the addition operator `+`. This means that your code is actually performing `(hi // 2)` first, and then adding `lo` to the result. This will cause `mid` to be calculated incorrectly.\\n\\nYou want to divide the sum of `lo` and `hi` by `2`, so you should use parentheses to ensure the correct order of operations:\\n\\n```python\\nmid = (lo + hi) // 2\\n```\\n\\nThis line will first add `lo` and `hi`, and then divide the result by `2` (performing integer division), which will correctly calculate the middle index. Here\\'s the corrected code:\\n\\n```python\\ndef count_rotations_binary(nums):\\n    lo = 0\\n    hi = len(nums)-1\\n\\n    while hi > lo:\\n        mid = (lo + hi) // 2\\n        mid_number = nums[mid]\\n\\n        print(\"lo :\", lo, \"hi :\", hi, \"mid :\", mid, \"mid number :\", mid_number)\\n\\n        if mid > 0 and nums[mid] < nums[mid-1]:\\n            return mid\\n        elif nums[mid] < nums[hi]:\\n            hi = mid - 1\\n        else:\\n            lo = mid + 1\\n```\\n\\nThis will now correctly calculate the middle index and should produce the expected result."
                    },
                    {
                        "username": "kimkass",
                        "content": "if the target is different for every list the function has to be separate for  every list.\nor passing two elements in parenthesis nums (list as input) and output(target number as input), where function should return target number index position will work ?"
                    },
                    {
                        "username": "bparanj",
                        "content": "Yes, you can certainly pass the target number as an additional argument to the function. This is a common practice and will allow you to use the same function to search for different targets in different lists. The function signature would look something like this:\\n\\n```python\\ndef binary_search(nums, target):\\n    # Implementation here\\n```\\n\\nIn the body of this function, you would implement your binary search (or whatever searching algorithm you\\'re using). This function would take a list of numbers (`nums`) and a target number (`target`), and it would return the index of `target` within `nums`. If `target` is not in `nums`, you could return `-1` or some other sentinel value.\\n\\nHere\\'s an example of how you might call this function:\\n\\n```python\\nnums = [4, 5, 6, 7, 8, 1, 2, 3]\\ntarget = 6\\nprint(binary_search(nums, target))  # This would print 2, assuming the list is zero-indexed\\n```\\n\\nBy parameterizing the target number, you can easily reuse the same function to search for different targets in different lists."
                    },
                    {
                        "username": "skadam183",
                        "content": "I am wondering if it\\'s only me who is thinking problem was too easy or too difficult that I didn\\'t understand.\\nIt was just one liner.\\n\\n` return nums.indexOf(target);`"
                    },
                    {
                        "username": "brbamcoding",
                        "content": "This would not have log time complexity. It would be linear"
                    },
                    {
                        "username": "ziico",
                        "content": "Why does this pass all the test cases with linear search if its time complexity is O(n). Shouldn\\'t it pass all the test cases only if binary search is used, as O(logn) is required. I\\'m confused??\\n"
                    },
                    {
                        "username": "rasin02",
                        "content": "Approch 1\\n\\n uses a while loop to repeatedly divide the search space in half until the target value is found or until the search space is exhausted. \\n The loop starts with the left index set to 0 and the right index set to the last element of the array.\\n The mid index is calculated as the average of the left and right indices. \\n The function then checks if the element at the mid index is equal to the target value, and if so, it returns the mid index as the result. If the element at the mid index is not equal to the target value, the function checks if the left side of the array is strictly increasing or not. \\n If it is, it checks if the target value is between the left and mid elements, and if so, it updates the right index to be one less than the mid index, otherwise it updates the left index to be one more than the mid index.\\n If the left side is not strictly increasing, the function checks if the target value is between the mid and right elements, and if so, it updates the left index to be one more than the mid index, otherwise it updates the right index to be one less than the mid index. \\n If the search space is exhausted without finding the target value, the function returns -1. \\n\\nint search(vector<int>& nums, int target) \\n    {\\n        int left=0;\\n        int right=nums.size()-1;\\n        int mid;\\n        while(left<=right)\\n        {\\n            mid=(left+right)/2;\\n            if(nums[mid]==target)\\n            return mid;\\n            //check if left side is strictly increasing or not\\n            else if (nums[left]<=nums[mid])\\n            {\\n                if(nums[left]<=target && nums[mid]>=target)\\n                \\n                    right=mid-1;\\n                    else \\n                    {\\n                    left=mid+1;\\n                    }\\n            \\n            }\\n            //check if right side is strictly increasing or not\\n\\n            else \\n            {\\n                if(nums[mid]<=target && nums[right]>=target)\\n                \\n                    left=mid+1;\\n                else \\n                    right=mid-1;\\n                \\n            }\\n        }   \\n        return -1;   \\n    }\\n\\nApproach 2\\nusing the concept the earlier solved provblem number 33\\nin which we were asked to find the minimin element in the roated sorted arrray\\nusign that concept we find the index of the minimum element  of the arrray and the we use the binary search to search the target in the start to index and  apply another search on the index+1 to end and how ever return the answer greater than -1 will be final answer\\ni`nt binary_search(vector<int>& arr, int beg, int end, int target) {\\n         while(beg <= end) {\\n            int mid = beg + (end - beg) / 2;\\n            if (arr[mid] == target) {\\n                return mid;\\n            } else if (arr[mid] <= target) {\\n                beg = mid + 1;\\n            } else {\\n                end = mid - 1;\\n            }\\n        }\\n        return -1;\\n   }\\n   \\nint findmin(vector<int>nums, int target)\\n{\\n    int start=0;\\n    int n=nums.size()-1;\\n    int end=n-1;\\n\\n    int mid;\\n    while(start<=end){\\n        mid=start+(end-start)/2;\\n        int prev=(mid+n-1)%n;\\n        int next=(mid+1)%n;\\n        if(nums[mid]<=prev && nums[mid]<=next)\\n        return mid;\\n        else if(nums[mid]>=nums[0])\\n            start=mid+1;\\n        else if(nums[mid]<=nums[n])\\n            end=mid-1;\\n    }\\n    return 0;\\n}\\n  int search(vector<int>& nums, int target) \\n    {\\n        int min_index=findmin(nums,target);\\n        int ans1=binary_search(nums,0,min_index,target);\\n        int ans2=binary_search(nums,min_index,nums.size()-1,target);\\n        int a=ans1>0?ans1:-1;\\n        int b=ans2>0?ans2:-1;\\n        if(a>=0)\\n        return a;\\n        else\\n        return b;\\n        \\n    }\\n`\\n"
                    },
                    {
                        "username": "Joshi_Deepti",
                        "content": "i wonder why binary search approach(T.C-O(logn))  is giving TLE and iterative solution(T.C-O(n)) is working fine.."
                    },
                    {
                        "username": "Minato235",
                        "content": "var search = function(nums, target) {\\n    for(let i=0;i<nums.length;i++){\\n    if(nums[i]==target) return i;\\n}\\nreturn -1;\\n};"
                    }
                ]
            },
            {
                "id": 1780218,
                "content": [
                    {
                        "username": "addu_coder",
                        "content": "I had used linear search and it\\'s find LoL!!!  @[leetcode](https://leetcode.com)"
                    },
                    {
                        "username": "NishantKende",
                        "content": "Guys, take it easy, Don\\'t get confused due to question\\'s description.\\nYou just need to search an array element inside given array. If you find it, return the index else return -1"
                    },
                    {
                        "username": "adityy",
                        "content": "why is this not working?\\nclass Solution {\\npublic:\\n    int search(vector<int>& nums, int target) {\\n        int high = nums.size()-1;\\n        int low = 0;\\n        while(low<high){\\n            int mid = low + (high - low)/2;\\n            if(nums[mid]==target) return mid+1;\\n            else if(nums[mid]>nums[mid+1]){\\n                if(nums[mid]>target)\\n                low = mid+1;\\n                else high = mid-1;\\n            }\\n            else if(nums[mid]<nums[mid+1]){\\n                if(nums[mid]>=target && nums[low]<=target)\\n                high = mid-1;\\n                else low = mid+1;\\n            }\\n        }\\n        return -1;\\n    }\\n};"
                    },
                    {
                        "username": "bparanj",
                        "content": "There are a couple of issues with your code. Here are the corrections:\\n\\n1. Your binary search loop should continue while `low <= high`, not while `low < high`. \\n\\n2. The check `nums[mid]==target` should return `mid`, not `mid+1`.\\n\\n3. Your conditions for checking which half to look in are incorrect. You want to determine if the left half is sorted and if the target is in that range, or if the right half is sorted and if the target is in that range.\\n\\nHere is a corrected version of your code:\\n\\n```cpp\\nclass Solution {\\npublic:\\n    int search(vector<int>& nums, int target) {\\n        int high = nums.size() - 1;\\n        int low = 0;\\n        while(low <= high){\\n            int mid = low + (high - low) / 2;\\n            if(nums[mid] == target) \\n                return mid;\\n            if(nums[low] <= nums[mid]) {  // Left half is sorted.\\n                if(nums[low] <= target && target < nums[mid]) \\n                    high = mid - 1;  // Target is in the left half.\\n                else\\n                    low = mid + 1;  // Target is in the right half.\\n            }\\n            else {  // Right half is sorted.\\n                if(nums[mid] < target && target <= nums[high])\\n                    low = mid + 1;  // Target is in the right half.\\n                else\\n                    high = mid - 1;  // Target is in the left half.\\n            }\\n        }\\n        return -1;\\n    }\\n};\\n```\\n\\nThis code works by first finding the middle of the current search range. If the middle element is the target, we\\'re done. Otherwise, we check if the left half of the range is sorted. If it is, and the target is in the range of the left half, we continue searching in the left half; otherwise, we search in the right half. If the left half is not sorted, that means the right half must be sorted. We then check if the target is in the range of the right half, and if so we continue searching in the right half; otherwise, we search in the left half."
                    },
                    {
                        "username": "kimkass",
                        "content": "def count_rotations_binary(nums):\\n    lo = 0\\n    hi = len(nums)-1\\n\\n    while hi>lo:\\n        mid = lo+hi//2\\n        mid_number = nums[mid]\\n\\n        print(\"lo :\",lo ,\"hi :\", hi,  \"mid :\",mid ,\"mid number :\", mid_number)\\n\\n        if mid > 0 and nums[mid] < nums[mid-1]:\\n            return mid\\n\\n        elif nums[mid] < nums[hi]:\\n            hi = mid-1\\n\\n        else:\\n            lo = mid+1\\n\\n// input nums : test1 = {\\n    \\'input\\' : {\\n        \\'nums\\' : [4,5,6,7,8,1,2,3] # after rotating 5 times\\n    },\\n    \\'output\\' : 5 # rotated 5 times means output = 5\\n}\\n\\n// Test failed on second division where mid + 1 = 4. following the same lo+hi//2. expected answer: 4+7=11.  11//2 = 5. \\nI am getting 7 for division of 11//2 as mid. what\\'s the problem in this code ?"
                    },
                    {
                        "username": "bparanj",
                        "content": "The issue lies in the order of operations in this line:\\n\\n```python\\nmid = lo + hi // 2\\n```\\n\\nIn Python, the division operator `//` has higher precedence than the addition operator `+`. This means that your code is actually performing `(hi // 2)` first, and then adding `lo` to the result. This will cause `mid` to be calculated incorrectly.\\n\\nYou want to divide the sum of `lo` and `hi` by `2`, so you should use parentheses to ensure the correct order of operations:\\n\\n```python\\nmid = (lo + hi) // 2\\n```\\n\\nThis line will first add `lo` and `hi`, and then divide the result by `2` (performing integer division), which will correctly calculate the middle index. Here\\'s the corrected code:\\n\\n```python\\ndef count_rotations_binary(nums):\\n    lo = 0\\n    hi = len(nums)-1\\n\\n    while hi > lo:\\n        mid = (lo + hi) // 2\\n        mid_number = nums[mid]\\n\\n        print(\"lo :\", lo, \"hi :\", hi, \"mid :\", mid, \"mid number :\", mid_number)\\n\\n        if mid > 0 and nums[mid] < nums[mid-1]:\\n            return mid\\n        elif nums[mid] < nums[hi]:\\n            hi = mid - 1\\n        else:\\n            lo = mid + 1\\n```\\n\\nThis will now correctly calculate the middle index and should produce the expected result."
                    },
                    {
                        "username": "kimkass",
                        "content": "if the target is different for every list the function has to be separate for  every list.\nor passing two elements in parenthesis nums (list as input) and output(target number as input), where function should return target number index position will work ?"
                    },
                    {
                        "username": "bparanj",
                        "content": "Yes, you can certainly pass the target number as an additional argument to the function. This is a common practice and will allow you to use the same function to search for different targets in different lists. The function signature would look something like this:\\n\\n```python\\ndef binary_search(nums, target):\\n    # Implementation here\\n```\\n\\nIn the body of this function, you would implement your binary search (or whatever searching algorithm you\\'re using). This function would take a list of numbers (`nums`) and a target number (`target`), and it would return the index of `target` within `nums`. If `target` is not in `nums`, you could return `-1` or some other sentinel value.\\n\\nHere\\'s an example of how you might call this function:\\n\\n```python\\nnums = [4, 5, 6, 7, 8, 1, 2, 3]\\ntarget = 6\\nprint(binary_search(nums, target))  # This would print 2, assuming the list is zero-indexed\\n```\\n\\nBy parameterizing the target number, you can easily reuse the same function to search for different targets in different lists."
                    },
                    {
                        "username": "skadam183",
                        "content": "I am wondering if it\\'s only me who is thinking problem was too easy or too difficult that I didn\\'t understand.\\nIt was just one liner.\\n\\n` return nums.indexOf(target);`"
                    },
                    {
                        "username": "brbamcoding",
                        "content": "This would not have log time complexity. It would be linear"
                    },
                    {
                        "username": "ziico",
                        "content": "Why does this pass all the test cases with linear search if its time complexity is O(n). Shouldn\\'t it pass all the test cases only if binary search is used, as O(logn) is required. I\\'m confused??\\n"
                    },
                    {
                        "username": "rasin02",
                        "content": "Approch 1\\n\\n uses a while loop to repeatedly divide the search space in half until the target value is found or until the search space is exhausted. \\n The loop starts with the left index set to 0 and the right index set to the last element of the array.\\n The mid index is calculated as the average of the left and right indices. \\n The function then checks if the element at the mid index is equal to the target value, and if so, it returns the mid index as the result. If the element at the mid index is not equal to the target value, the function checks if the left side of the array is strictly increasing or not. \\n If it is, it checks if the target value is between the left and mid elements, and if so, it updates the right index to be one less than the mid index, otherwise it updates the left index to be one more than the mid index.\\n If the left side is not strictly increasing, the function checks if the target value is between the mid and right elements, and if so, it updates the left index to be one more than the mid index, otherwise it updates the right index to be one less than the mid index. \\n If the search space is exhausted without finding the target value, the function returns -1. \\n\\nint search(vector<int>& nums, int target) \\n    {\\n        int left=0;\\n        int right=nums.size()-1;\\n        int mid;\\n        while(left<=right)\\n        {\\n            mid=(left+right)/2;\\n            if(nums[mid]==target)\\n            return mid;\\n            //check if left side is strictly increasing or not\\n            else if (nums[left]<=nums[mid])\\n            {\\n                if(nums[left]<=target && nums[mid]>=target)\\n                \\n                    right=mid-1;\\n                    else \\n                    {\\n                    left=mid+1;\\n                    }\\n            \\n            }\\n            //check if right side is strictly increasing or not\\n\\n            else \\n            {\\n                if(nums[mid]<=target && nums[right]>=target)\\n                \\n                    left=mid+1;\\n                else \\n                    right=mid-1;\\n                \\n            }\\n        }   \\n        return -1;   \\n    }\\n\\nApproach 2\\nusing the concept the earlier solved provblem number 33\\nin which we were asked to find the minimin element in the roated sorted arrray\\nusign that concept we find the index of the minimum element  of the arrray and the we use the binary search to search the target in the start to index and  apply another search on the index+1 to end and how ever return the answer greater than -1 will be final answer\\ni`nt binary_search(vector<int>& arr, int beg, int end, int target) {\\n         while(beg <= end) {\\n            int mid = beg + (end - beg) / 2;\\n            if (arr[mid] == target) {\\n                return mid;\\n            } else if (arr[mid] <= target) {\\n                beg = mid + 1;\\n            } else {\\n                end = mid - 1;\\n            }\\n        }\\n        return -1;\\n   }\\n   \\nint findmin(vector<int>nums, int target)\\n{\\n    int start=0;\\n    int n=nums.size()-1;\\n    int end=n-1;\\n\\n    int mid;\\n    while(start<=end){\\n        mid=start+(end-start)/2;\\n        int prev=(mid+n-1)%n;\\n        int next=(mid+1)%n;\\n        if(nums[mid]<=prev && nums[mid]<=next)\\n        return mid;\\n        else if(nums[mid]>=nums[0])\\n            start=mid+1;\\n        else if(nums[mid]<=nums[n])\\n            end=mid-1;\\n    }\\n    return 0;\\n}\\n  int search(vector<int>& nums, int target) \\n    {\\n        int min_index=findmin(nums,target);\\n        int ans1=binary_search(nums,0,min_index,target);\\n        int ans2=binary_search(nums,min_index,nums.size()-1,target);\\n        int a=ans1>0?ans1:-1;\\n        int b=ans2>0?ans2:-1;\\n        if(a>=0)\\n        return a;\\n        else\\n        return b;\\n        \\n    }\\n`\\n"
                    },
                    {
                        "username": "Joshi_Deepti",
                        "content": "i wonder why binary search approach(T.C-O(logn))  is giving TLE and iterative solution(T.C-O(n)) is working fine.."
                    },
                    {
                        "username": "Minato235",
                        "content": "var search = function(nums, target) {\\n    for(let i=0;i<nums.length;i++){\\n    if(nums[i]==target) return i;\\n}\\nreturn -1;\\n};"
                    }
                ]
            },
            {
                "id": 1780019,
                "content": [
                    {
                        "username": "addu_coder",
                        "content": "I had used linear search and it\\'s find LoL!!!  @[leetcode](https://leetcode.com)"
                    },
                    {
                        "username": "NishantKende",
                        "content": "Guys, take it easy, Don\\'t get confused due to question\\'s description.\\nYou just need to search an array element inside given array. If you find it, return the index else return -1"
                    },
                    {
                        "username": "adityy",
                        "content": "why is this not working?\\nclass Solution {\\npublic:\\n    int search(vector<int>& nums, int target) {\\n        int high = nums.size()-1;\\n        int low = 0;\\n        while(low<high){\\n            int mid = low + (high - low)/2;\\n            if(nums[mid]==target) return mid+1;\\n            else if(nums[mid]>nums[mid+1]){\\n                if(nums[mid]>target)\\n                low = mid+1;\\n                else high = mid-1;\\n            }\\n            else if(nums[mid]<nums[mid+1]){\\n                if(nums[mid]>=target && nums[low]<=target)\\n                high = mid-1;\\n                else low = mid+1;\\n            }\\n        }\\n        return -1;\\n    }\\n};"
                    },
                    {
                        "username": "bparanj",
                        "content": "There are a couple of issues with your code. Here are the corrections:\\n\\n1. Your binary search loop should continue while `low <= high`, not while `low < high`. \\n\\n2. The check `nums[mid]==target` should return `mid`, not `mid+1`.\\n\\n3. Your conditions for checking which half to look in are incorrect. You want to determine if the left half is sorted and if the target is in that range, or if the right half is sorted and if the target is in that range.\\n\\nHere is a corrected version of your code:\\n\\n```cpp\\nclass Solution {\\npublic:\\n    int search(vector<int>& nums, int target) {\\n        int high = nums.size() - 1;\\n        int low = 0;\\n        while(low <= high){\\n            int mid = low + (high - low) / 2;\\n            if(nums[mid] == target) \\n                return mid;\\n            if(nums[low] <= nums[mid]) {  // Left half is sorted.\\n                if(nums[low] <= target && target < nums[mid]) \\n                    high = mid - 1;  // Target is in the left half.\\n                else\\n                    low = mid + 1;  // Target is in the right half.\\n            }\\n            else {  // Right half is sorted.\\n                if(nums[mid] < target && target <= nums[high])\\n                    low = mid + 1;  // Target is in the right half.\\n                else\\n                    high = mid - 1;  // Target is in the left half.\\n            }\\n        }\\n        return -1;\\n    }\\n};\\n```\\n\\nThis code works by first finding the middle of the current search range. If the middle element is the target, we\\'re done. Otherwise, we check if the left half of the range is sorted. If it is, and the target is in the range of the left half, we continue searching in the left half; otherwise, we search in the right half. If the left half is not sorted, that means the right half must be sorted. We then check if the target is in the range of the right half, and if so we continue searching in the right half; otherwise, we search in the left half."
                    },
                    {
                        "username": "kimkass",
                        "content": "def count_rotations_binary(nums):\\n    lo = 0\\n    hi = len(nums)-1\\n\\n    while hi>lo:\\n        mid = lo+hi//2\\n        mid_number = nums[mid]\\n\\n        print(\"lo :\",lo ,\"hi :\", hi,  \"mid :\",mid ,\"mid number :\", mid_number)\\n\\n        if mid > 0 and nums[mid] < nums[mid-1]:\\n            return mid\\n\\n        elif nums[mid] < nums[hi]:\\n            hi = mid-1\\n\\n        else:\\n            lo = mid+1\\n\\n// input nums : test1 = {\\n    \\'input\\' : {\\n        \\'nums\\' : [4,5,6,7,8,1,2,3] # after rotating 5 times\\n    },\\n    \\'output\\' : 5 # rotated 5 times means output = 5\\n}\\n\\n// Test failed on second division where mid + 1 = 4. following the same lo+hi//2. expected answer: 4+7=11.  11//2 = 5. \\nI am getting 7 for division of 11//2 as mid. what\\'s the problem in this code ?"
                    },
                    {
                        "username": "bparanj",
                        "content": "The issue lies in the order of operations in this line:\\n\\n```python\\nmid = lo + hi // 2\\n```\\n\\nIn Python, the division operator `//` has higher precedence than the addition operator `+`. This means that your code is actually performing `(hi // 2)` first, and then adding `lo` to the result. This will cause `mid` to be calculated incorrectly.\\n\\nYou want to divide the sum of `lo` and `hi` by `2`, so you should use parentheses to ensure the correct order of operations:\\n\\n```python\\nmid = (lo + hi) // 2\\n```\\n\\nThis line will first add `lo` and `hi`, and then divide the result by `2` (performing integer division), which will correctly calculate the middle index. Here\\'s the corrected code:\\n\\n```python\\ndef count_rotations_binary(nums):\\n    lo = 0\\n    hi = len(nums)-1\\n\\n    while hi > lo:\\n        mid = (lo + hi) // 2\\n        mid_number = nums[mid]\\n\\n        print(\"lo :\", lo, \"hi :\", hi, \"mid :\", mid, \"mid number :\", mid_number)\\n\\n        if mid > 0 and nums[mid] < nums[mid-1]:\\n            return mid\\n        elif nums[mid] < nums[hi]:\\n            hi = mid - 1\\n        else:\\n            lo = mid + 1\\n```\\n\\nThis will now correctly calculate the middle index and should produce the expected result."
                    },
                    {
                        "username": "kimkass",
                        "content": "if the target is different for every list the function has to be separate for  every list.\nor passing two elements in parenthesis nums (list as input) and output(target number as input), where function should return target number index position will work ?"
                    },
                    {
                        "username": "bparanj",
                        "content": "Yes, you can certainly pass the target number as an additional argument to the function. This is a common practice and will allow you to use the same function to search for different targets in different lists. The function signature would look something like this:\\n\\n```python\\ndef binary_search(nums, target):\\n    # Implementation here\\n```\\n\\nIn the body of this function, you would implement your binary search (or whatever searching algorithm you\\'re using). This function would take a list of numbers (`nums`) and a target number (`target`), and it would return the index of `target` within `nums`. If `target` is not in `nums`, you could return `-1` or some other sentinel value.\\n\\nHere\\'s an example of how you might call this function:\\n\\n```python\\nnums = [4, 5, 6, 7, 8, 1, 2, 3]\\ntarget = 6\\nprint(binary_search(nums, target))  # This would print 2, assuming the list is zero-indexed\\n```\\n\\nBy parameterizing the target number, you can easily reuse the same function to search for different targets in different lists."
                    },
                    {
                        "username": "skadam183",
                        "content": "I am wondering if it\\'s only me who is thinking problem was too easy or too difficult that I didn\\'t understand.\\nIt was just one liner.\\n\\n` return nums.indexOf(target);`"
                    },
                    {
                        "username": "brbamcoding",
                        "content": "This would not have log time complexity. It would be linear"
                    },
                    {
                        "username": "ziico",
                        "content": "Why does this pass all the test cases with linear search if its time complexity is O(n). Shouldn\\'t it pass all the test cases only if binary search is used, as O(logn) is required. I\\'m confused??\\n"
                    },
                    {
                        "username": "rasin02",
                        "content": "Approch 1\\n\\n uses a while loop to repeatedly divide the search space in half until the target value is found or until the search space is exhausted. \\n The loop starts with the left index set to 0 and the right index set to the last element of the array.\\n The mid index is calculated as the average of the left and right indices. \\n The function then checks if the element at the mid index is equal to the target value, and if so, it returns the mid index as the result. If the element at the mid index is not equal to the target value, the function checks if the left side of the array is strictly increasing or not. \\n If it is, it checks if the target value is between the left and mid elements, and if so, it updates the right index to be one less than the mid index, otherwise it updates the left index to be one more than the mid index.\\n If the left side is not strictly increasing, the function checks if the target value is between the mid and right elements, and if so, it updates the left index to be one more than the mid index, otherwise it updates the right index to be one less than the mid index. \\n If the search space is exhausted without finding the target value, the function returns -1. \\n\\nint search(vector<int>& nums, int target) \\n    {\\n        int left=0;\\n        int right=nums.size()-1;\\n        int mid;\\n        while(left<=right)\\n        {\\n            mid=(left+right)/2;\\n            if(nums[mid]==target)\\n            return mid;\\n            //check if left side is strictly increasing or not\\n            else if (nums[left]<=nums[mid])\\n            {\\n                if(nums[left]<=target && nums[mid]>=target)\\n                \\n                    right=mid-1;\\n                    else \\n                    {\\n                    left=mid+1;\\n                    }\\n            \\n            }\\n            //check if right side is strictly increasing or not\\n\\n            else \\n            {\\n                if(nums[mid]<=target && nums[right]>=target)\\n                \\n                    left=mid+1;\\n                else \\n                    right=mid-1;\\n                \\n            }\\n        }   \\n        return -1;   \\n    }\\n\\nApproach 2\\nusing the concept the earlier solved provblem number 33\\nin which we were asked to find the minimin element in the roated sorted arrray\\nusign that concept we find the index of the minimum element  of the arrray and the we use the binary search to search the target in the start to index and  apply another search on the index+1 to end and how ever return the answer greater than -1 will be final answer\\ni`nt binary_search(vector<int>& arr, int beg, int end, int target) {\\n         while(beg <= end) {\\n            int mid = beg + (end - beg) / 2;\\n            if (arr[mid] == target) {\\n                return mid;\\n            } else if (arr[mid] <= target) {\\n                beg = mid + 1;\\n            } else {\\n                end = mid - 1;\\n            }\\n        }\\n        return -1;\\n   }\\n   \\nint findmin(vector<int>nums, int target)\\n{\\n    int start=0;\\n    int n=nums.size()-1;\\n    int end=n-1;\\n\\n    int mid;\\n    while(start<=end){\\n        mid=start+(end-start)/2;\\n        int prev=(mid+n-1)%n;\\n        int next=(mid+1)%n;\\n        if(nums[mid]<=prev && nums[mid]<=next)\\n        return mid;\\n        else if(nums[mid]>=nums[0])\\n            start=mid+1;\\n        else if(nums[mid]<=nums[n])\\n            end=mid-1;\\n    }\\n    return 0;\\n}\\n  int search(vector<int>& nums, int target) \\n    {\\n        int min_index=findmin(nums,target);\\n        int ans1=binary_search(nums,0,min_index,target);\\n        int ans2=binary_search(nums,min_index,nums.size()-1,target);\\n        int a=ans1>0?ans1:-1;\\n        int b=ans2>0?ans2:-1;\\n        if(a>=0)\\n        return a;\\n        else\\n        return b;\\n        \\n    }\\n`\\n"
                    },
                    {
                        "username": "Joshi_Deepti",
                        "content": "i wonder why binary search approach(T.C-O(logn))  is giving TLE and iterative solution(T.C-O(n)) is working fine.."
                    },
                    {
                        "username": "Minato235",
                        "content": "var search = function(nums, target) {\\n    for(let i=0;i<nums.length;i++){\\n    if(nums[i]==target) return i;\\n}\\nreturn -1;\\n};"
                    }
                ]
            },
            {
                "id": 1779693,
                "content": [
                    {
                        "username": "addu_coder",
                        "content": "I had used linear search and it\\'s find LoL!!!  @[leetcode](https://leetcode.com)"
                    },
                    {
                        "username": "NishantKende",
                        "content": "Guys, take it easy, Don\\'t get confused due to question\\'s description.\\nYou just need to search an array element inside given array. If you find it, return the index else return -1"
                    },
                    {
                        "username": "adityy",
                        "content": "why is this not working?\\nclass Solution {\\npublic:\\n    int search(vector<int>& nums, int target) {\\n        int high = nums.size()-1;\\n        int low = 0;\\n        while(low<high){\\n            int mid = low + (high - low)/2;\\n            if(nums[mid]==target) return mid+1;\\n            else if(nums[mid]>nums[mid+1]){\\n                if(nums[mid]>target)\\n                low = mid+1;\\n                else high = mid-1;\\n            }\\n            else if(nums[mid]<nums[mid+1]){\\n                if(nums[mid]>=target && nums[low]<=target)\\n                high = mid-1;\\n                else low = mid+1;\\n            }\\n        }\\n        return -1;\\n    }\\n};"
                    },
                    {
                        "username": "bparanj",
                        "content": "There are a couple of issues with your code. Here are the corrections:\\n\\n1. Your binary search loop should continue while `low <= high`, not while `low < high`. \\n\\n2. The check `nums[mid]==target` should return `mid`, not `mid+1`.\\n\\n3. Your conditions for checking which half to look in are incorrect. You want to determine if the left half is sorted and if the target is in that range, or if the right half is sorted and if the target is in that range.\\n\\nHere is a corrected version of your code:\\n\\n```cpp\\nclass Solution {\\npublic:\\n    int search(vector<int>& nums, int target) {\\n        int high = nums.size() - 1;\\n        int low = 0;\\n        while(low <= high){\\n            int mid = low + (high - low) / 2;\\n            if(nums[mid] == target) \\n                return mid;\\n            if(nums[low] <= nums[mid]) {  // Left half is sorted.\\n                if(nums[low] <= target && target < nums[mid]) \\n                    high = mid - 1;  // Target is in the left half.\\n                else\\n                    low = mid + 1;  // Target is in the right half.\\n            }\\n            else {  // Right half is sorted.\\n                if(nums[mid] < target && target <= nums[high])\\n                    low = mid + 1;  // Target is in the right half.\\n                else\\n                    high = mid - 1;  // Target is in the left half.\\n            }\\n        }\\n        return -1;\\n    }\\n};\\n```\\n\\nThis code works by first finding the middle of the current search range. If the middle element is the target, we\\'re done. Otherwise, we check if the left half of the range is sorted. If it is, and the target is in the range of the left half, we continue searching in the left half; otherwise, we search in the right half. If the left half is not sorted, that means the right half must be sorted. We then check if the target is in the range of the right half, and if so we continue searching in the right half; otherwise, we search in the left half."
                    },
                    {
                        "username": "kimkass",
                        "content": "def count_rotations_binary(nums):\\n    lo = 0\\n    hi = len(nums)-1\\n\\n    while hi>lo:\\n        mid = lo+hi//2\\n        mid_number = nums[mid]\\n\\n        print(\"lo :\",lo ,\"hi :\", hi,  \"mid :\",mid ,\"mid number :\", mid_number)\\n\\n        if mid > 0 and nums[mid] < nums[mid-1]:\\n            return mid\\n\\n        elif nums[mid] < nums[hi]:\\n            hi = mid-1\\n\\n        else:\\n            lo = mid+1\\n\\n// input nums : test1 = {\\n    \\'input\\' : {\\n        \\'nums\\' : [4,5,6,7,8,1,2,3] # after rotating 5 times\\n    },\\n    \\'output\\' : 5 # rotated 5 times means output = 5\\n}\\n\\n// Test failed on second division where mid + 1 = 4. following the same lo+hi//2. expected answer: 4+7=11.  11//2 = 5. \\nI am getting 7 for division of 11//2 as mid. what\\'s the problem in this code ?"
                    },
                    {
                        "username": "bparanj",
                        "content": "The issue lies in the order of operations in this line:\\n\\n```python\\nmid = lo + hi // 2\\n```\\n\\nIn Python, the division operator `//` has higher precedence than the addition operator `+`. This means that your code is actually performing `(hi // 2)` first, and then adding `lo` to the result. This will cause `mid` to be calculated incorrectly.\\n\\nYou want to divide the sum of `lo` and `hi` by `2`, so you should use parentheses to ensure the correct order of operations:\\n\\n```python\\nmid = (lo + hi) // 2\\n```\\n\\nThis line will first add `lo` and `hi`, and then divide the result by `2` (performing integer division), which will correctly calculate the middle index. Here\\'s the corrected code:\\n\\n```python\\ndef count_rotations_binary(nums):\\n    lo = 0\\n    hi = len(nums)-1\\n\\n    while hi > lo:\\n        mid = (lo + hi) // 2\\n        mid_number = nums[mid]\\n\\n        print(\"lo :\", lo, \"hi :\", hi, \"mid :\", mid, \"mid number :\", mid_number)\\n\\n        if mid > 0 and nums[mid] < nums[mid-1]:\\n            return mid\\n        elif nums[mid] < nums[hi]:\\n            hi = mid - 1\\n        else:\\n            lo = mid + 1\\n```\\n\\nThis will now correctly calculate the middle index and should produce the expected result."
                    },
                    {
                        "username": "kimkass",
                        "content": "if the target is different for every list the function has to be separate for  every list.\nor passing two elements in parenthesis nums (list as input) and output(target number as input), where function should return target number index position will work ?"
                    },
                    {
                        "username": "bparanj",
                        "content": "Yes, you can certainly pass the target number as an additional argument to the function. This is a common practice and will allow you to use the same function to search for different targets in different lists. The function signature would look something like this:\\n\\n```python\\ndef binary_search(nums, target):\\n    # Implementation here\\n```\\n\\nIn the body of this function, you would implement your binary search (or whatever searching algorithm you\\'re using). This function would take a list of numbers (`nums`) and a target number (`target`), and it would return the index of `target` within `nums`. If `target` is not in `nums`, you could return `-1` or some other sentinel value.\\n\\nHere\\'s an example of how you might call this function:\\n\\n```python\\nnums = [4, 5, 6, 7, 8, 1, 2, 3]\\ntarget = 6\\nprint(binary_search(nums, target))  # This would print 2, assuming the list is zero-indexed\\n```\\n\\nBy parameterizing the target number, you can easily reuse the same function to search for different targets in different lists."
                    },
                    {
                        "username": "skadam183",
                        "content": "I am wondering if it\\'s only me who is thinking problem was too easy or too difficult that I didn\\'t understand.\\nIt was just one liner.\\n\\n` return nums.indexOf(target);`"
                    },
                    {
                        "username": "brbamcoding",
                        "content": "This would not have log time complexity. It would be linear"
                    },
                    {
                        "username": "ziico",
                        "content": "Why does this pass all the test cases with linear search if its time complexity is O(n). Shouldn\\'t it pass all the test cases only if binary search is used, as O(logn) is required. I\\'m confused??\\n"
                    },
                    {
                        "username": "rasin02",
                        "content": "Approch 1\\n\\n uses a while loop to repeatedly divide the search space in half until the target value is found or until the search space is exhausted. \\n The loop starts with the left index set to 0 and the right index set to the last element of the array.\\n The mid index is calculated as the average of the left and right indices. \\n The function then checks if the element at the mid index is equal to the target value, and if so, it returns the mid index as the result. If the element at the mid index is not equal to the target value, the function checks if the left side of the array is strictly increasing or not. \\n If it is, it checks if the target value is between the left and mid elements, and if so, it updates the right index to be one less than the mid index, otherwise it updates the left index to be one more than the mid index.\\n If the left side is not strictly increasing, the function checks if the target value is between the mid and right elements, and if so, it updates the left index to be one more than the mid index, otherwise it updates the right index to be one less than the mid index. \\n If the search space is exhausted without finding the target value, the function returns -1. \\n\\nint search(vector<int>& nums, int target) \\n    {\\n        int left=0;\\n        int right=nums.size()-1;\\n        int mid;\\n        while(left<=right)\\n        {\\n            mid=(left+right)/2;\\n            if(nums[mid]==target)\\n            return mid;\\n            //check if left side is strictly increasing or not\\n            else if (nums[left]<=nums[mid])\\n            {\\n                if(nums[left]<=target && nums[mid]>=target)\\n                \\n                    right=mid-1;\\n                    else \\n                    {\\n                    left=mid+1;\\n                    }\\n            \\n            }\\n            //check if right side is strictly increasing or not\\n\\n            else \\n            {\\n                if(nums[mid]<=target && nums[right]>=target)\\n                \\n                    left=mid+1;\\n                else \\n                    right=mid-1;\\n                \\n            }\\n        }   \\n        return -1;   \\n    }\\n\\nApproach 2\\nusing the concept the earlier solved provblem number 33\\nin which we were asked to find the minimin element in the roated sorted arrray\\nusign that concept we find the index of the minimum element  of the arrray and the we use the binary search to search the target in the start to index and  apply another search on the index+1 to end and how ever return the answer greater than -1 will be final answer\\ni`nt binary_search(vector<int>& arr, int beg, int end, int target) {\\n         while(beg <= end) {\\n            int mid = beg + (end - beg) / 2;\\n            if (arr[mid] == target) {\\n                return mid;\\n            } else if (arr[mid] <= target) {\\n                beg = mid + 1;\\n            } else {\\n                end = mid - 1;\\n            }\\n        }\\n        return -1;\\n   }\\n   \\nint findmin(vector<int>nums, int target)\\n{\\n    int start=0;\\n    int n=nums.size()-1;\\n    int end=n-1;\\n\\n    int mid;\\n    while(start<=end){\\n        mid=start+(end-start)/2;\\n        int prev=(mid+n-1)%n;\\n        int next=(mid+1)%n;\\n        if(nums[mid]<=prev && nums[mid]<=next)\\n        return mid;\\n        else if(nums[mid]>=nums[0])\\n            start=mid+1;\\n        else if(nums[mid]<=nums[n])\\n            end=mid-1;\\n    }\\n    return 0;\\n}\\n  int search(vector<int>& nums, int target) \\n    {\\n        int min_index=findmin(nums,target);\\n        int ans1=binary_search(nums,0,min_index,target);\\n        int ans2=binary_search(nums,min_index,nums.size()-1,target);\\n        int a=ans1>0?ans1:-1;\\n        int b=ans2>0?ans2:-1;\\n        if(a>=0)\\n        return a;\\n        else\\n        return b;\\n        \\n    }\\n`\\n"
                    },
                    {
                        "username": "Joshi_Deepti",
                        "content": "i wonder why binary search approach(T.C-O(logn))  is giving TLE and iterative solution(T.C-O(n)) is working fine.."
                    },
                    {
                        "username": "Minato235",
                        "content": "var search = function(nums, target) {\\n    for(let i=0;i<nums.length;i++){\\n    if(nums[i]==target) return i;\\n}\\nreturn -1;\\n};"
                    }
                ]
            },
            {
                "id": 1779228,
                "content": [
                    {
                        "username": "addu_coder",
                        "content": "I had used linear search and it\\'s find LoL!!!  @[leetcode](https://leetcode.com)"
                    },
                    {
                        "username": "NishantKende",
                        "content": "Guys, take it easy, Don\\'t get confused due to question\\'s description.\\nYou just need to search an array element inside given array. If you find it, return the index else return -1"
                    },
                    {
                        "username": "adityy",
                        "content": "why is this not working?\\nclass Solution {\\npublic:\\n    int search(vector<int>& nums, int target) {\\n        int high = nums.size()-1;\\n        int low = 0;\\n        while(low<high){\\n            int mid = low + (high - low)/2;\\n            if(nums[mid]==target) return mid+1;\\n            else if(nums[mid]>nums[mid+1]){\\n                if(nums[mid]>target)\\n                low = mid+1;\\n                else high = mid-1;\\n            }\\n            else if(nums[mid]<nums[mid+1]){\\n                if(nums[mid]>=target && nums[low]<=target)\\n                high = mid-1;\\n                else low = mid+1;\\n            }\\n        }\\n        return -1;\\n    }\\n};"
                    },
                    {
                        "username": "bparanj",
                        "content": "There are a couple of issues with your code. Here are the corrections:\\n\\n1. Your binary search loop should continue while `low <= high`, not while `low < high`. \\n\\n2. The check `nums[mid]==target` should return `mid`, not `mid+1`.\\n\\n3. Your conditions for checking which half to look in are incorrect. You want to determine if the left half is sorted and if the target is in that range, or if the right half is sorted and if the target is in that range.\\n\\nHere is a corrected version of your code:\\n\\n```cpp\\nclass Solution {\\npublic:\\n    int search(vector<int>& nums, int target) {\\n        int high = nums.size() - 1;\\n        int low = 0;\\n        while(low <= high){\\n            int mid = low + (high - low) / 2;\\n            if(nums[mid] == target) \\n                return mid;\\n            if(nums[low] <= nums[mid]) {  // Left half is sorted.\\n                if(nums[low] <= target && target < nums[mid]) \\n                    high = mid - 1;  // Target is in the left half.\\n                else\\n                    low = mid + 1;  // Target is in the right half.\\n            }\\n            else {  // Right half is sorted.\\n                if(nums[mid] < target && target <= nums[high])\\n                    low = mid + 1;  // Target is in the right half.\\n                else\\n                    high = mid - 1;  // Target is in the left half.\\n            }\\n        }\\n        return -1;\\n    }\\n};\\n```\\n\\nThis code works by first finding the middle of the current search range. If the middle element is the target, we\\'re done. Otherwise, we check if the left half of the range is sorted. If it is, and the target is in the range of the left half, we continue searching in the left half; otherwise, we search in the right half. If the left half is not sorted, that means the right half must be sorted. We then check if the target is in the range of the right half, and if so we continue searching in the right half; otherwise, we search in the left half."
                    },
                    {
                        "username": "kimkass",
                        "content": "def count_rotations_binary(nums):\\n    lo = 0\\n    hi = len(nums)-1\\n\\n    while hi>lo:\\n        mid = lo+hi//2\\n        mid_number = nums[mid]\\n\\n        print(\"lo :\",lo ,\"hi :\", hi,  \"mid :\",mid ,\"mid number :\", mid_number)\\n\\n        if mid > 0 and nums[mid] < nums[mid-1]:\\n            return mid\\n\\n        elif nums[mid] < nums[hi]:\\n            hi = mid-1\\n\\n        else:\\n            lo = mid+1\\n\\n// input nums : test1 = {\\n    \\'input\\' : {\\n        \\'nums\\' : [4,5,6,7,8,1,2,3] # after rotating 5 times\\n    },\\n    \\'output\\' : 5 # rotated 5 times means output = 5\\n}\\n\\n// Test failed on second division where mid + 1 = 4. following the same lo+hi//2. expected answer: 4+7=11.  11//2 = 5. \\nI am getting 7 for division of 11//2 as mid. what\\'s the problem in this code ?"
                    },
                    {
                        "username": "bparanj",
                        "content": "The issue lies in the order of operations in this line:\\n\\n```python\\nmid = lo + hi // 2\\n```\\n\\nIn Python, the division operator `//` has higher precedence than the addition operator `+`. This means that your code is actually performing `(hi // 2)` first, and then adding `lo` to the result. This will cause `mid` to be calculated incorrectly.\\n\\nYou want to divide the sum of `lo` and `hi` by `2`, so you should use parentheses to ensure the correct order of operations:\\n\\n```python\\nmid = (lo + hi) // 2\\n```\\n\\nThis line will first add `lo` and `hi`, and then divide the result by `2` (performing integer division), which will correctly calculate the middle index. Here\\'s the corrected code:\\n\\n```python\\ndef count_rotations_binary(nums):\\n    lo = 0\\n    hi = len(nums)-1\\n\\n    while hi > lo:\\n        mid = (lo + hi) // 2\\n        mid_number = nums[mid]\\n\\n        print(\"lo :\", lo, \"hi :\", hi, \"mid :\", mid, \"mid number :\", mid_number)\\n\\n        if mid > 0 and nums[mid] < nums[mid-1]:\\n            return mid\\n        elif nums[mid] < nums[hi]:\\n            hi = mid - 1\\n        else:\\n            lo = mid + 1\\n```\\n\\nThis will now correctly calculate the middle index and should produce the expected result."
                    },
                    {
                        "username": "kimkass",
                        "content": "if the target is different for every list the function has to be separate for  every list.\nor passing two elements in parenthesis nums (list as input) and output(target number as input), where function should return target number index position will work ?"
                    },
                    {
                        "username": "bparanj",
                        "content": "Yes, you can certainly pass the target number as an additional argument to the function. This is a common practice and will allow you to use the same function to search for different targets in different lists. The function signature would look something like this:\\n\\n```python\\ndef binary_search(nums, target):\\n    # Implementation here\\n```\\n\\nIn the body of this function, you would implement your binary search (or whatever searching algorithm you\\'re using). This function would take a list of numbers (`nums`) and a target number (`target`), and it would return the index of `target` within `nums`. If `target` is not in `nums`, you could return `-1` or some other sentinel value.\\n\\nHere\\'s an example of how you might call this function:\\n\\n```python\\nnums = [4, 5, 6, 7, 8, 1, 2, 3]\\ntarget = 6\\nprint(binary_search(nums, target))  # This would print 2, assuming the list is zero-indexed\\n```\\n\\nBy parameterizing the target number, you can easily reuse the same function to search for different targets in different lists."
                    },
                    {
                        "username": "skadam183",
                        "content": "I am wondering if it\\'s only me who is thinking problem was too easy or too difficult that I didn\\'t understand.\\nIt was just one liner.\\n\\n` return nums.indexOf(target);`"
                    },
                    {
                        "username": "brbamcoding",
                        "content": "This would not have log time complexity. It would be linear"
                    },
                    {
                        "username": "ziico",
                        "content": "Why does this pass all the test cases with linear search if its time complexity is O(n). Shouldn\\'t it pass all the test cases only if binary search is used, as O(logn) is required. I\\'m confused??\\n"
                    },
                    {
                        "username": "rasin02",
                        "content": "Approch 1\\n\\n uses a while loop to repeatedly divide the search space in half until the target value is found or until the search space is exhausted. \\n The loop starts with the left index set to 0 and the right index set to the last element of the array.\\n The mid index is calculated as the average of the left and right indices. \\n The function then checks if the element at the mid index is equal to the target value, and if so, it returns the mid index as the result. If the element at the mid index is not equal to the target value, the function checks if the left side of the array is strictly increasing or not. \\n If it is, it checks if the target value is between the left and mid elements, and if so, it updates the right index to be one less than the mid index, otherwise it updates the left index to be one more than the mid index.\\n If the left side is not strictly increasing, the function checks if the target value is between the mid and right elements, and if so, it updates the left index to be one more than the mid index, otherwise it updates the right index to be one less than the mid index. \\n If the search space is exhausted without finding the target value, the function returns -1. \\n\\nint search(vector<int>& nums, int target) \\n    {\\n        int left=0;\\n        int right=nums.size()-1;\\n        int mid;\\n        while(left<=right)\\n        {\\n            mid=(left+right)/2;\\n            if(nums[mid]==target)\\n            return mid;\\n            //check if left side is strictly increasing or not\\n            else if (nums[left]<=nums[mid])\\n            {\\n                if(nums[left]<=target && nums[mid]>=target)\\n                \\n                    right=mid-1;\\n                    else \\n                    {\\n                    left=mid+1;\\n                    }\\n            \\n            }\\n            //check if right side is strictly increasing or not\\n\\n            else \\n            {\\n                if(nums[mid]<=target && nums[right]>=target)\\n                \\n                    left=mid+1;\\n                else \\n                    right=mid-1;\\n                \\n            }\\n        }   \\n        return -1;   \\n    }\\n\\nApproach 2\\nusing the concept the earlier solved provblem number 33\\nin which we were asked to find the minimin element in the roated sorted arrray\\nusign that concept we find the index of the minimum element  of the arrray and the we use the binary search to search the target in the start to index and  apply another search on the index+1 to end and how ever return the answer greater than -1 will be final answer\\ni`nt binary_search(vector<int>& arr, int beg, int end, int target) {\\n         while(beg <= end) {\\n            int mid = beg + (end - beg) / 2;\\n            if (arr[mid] == target) {\\n                return mid;\\n            } else if (arr[mid] <= target) {\\n                beg = mid + 1;\\n            } else {\\n                end = mid - 1;\\n            }\\n        }\\n        return -1;\\n   }\\n   \\nint findmin(vector<int>nums, int target)\\n{\\n    int start=0;\\n    int n=nums.size()-1;\\n    int end=n-1;\\n\\n    int mid;\\n    while(start<=end){\\n        mid=start+(end-start)/2;\\n        int prev=(mid+n-1)%n;\\n        int next=(mid+1)%n;\\n        if(nums[mid]<=prev && nums[mid]<=next)\\n        return mid;\\n        else if(nums[mid]>=nums[0])\\n            start=mid+1;\\n        else if(nums[mid]<=nums[n])\\n            end=mid-1;\\n    }\\n    return 0;\\n}\\n  int search(vector<int>& nums, int target) \\n    {\\n        int min_index=findmin(nums,target);\\n        int ans1=binary_search(nums,0,min_index,target);\\n        int ans2=binary_search(nums,min_index,nums.size()-1,target);\\n        int a=ans1>0?ans1:-1;\\n        int b=ans2>0?ans2:-1;\\n        if(a>=0)\\n        return a;\\n        else\\n        return b;\\n        \\n    }\\n`\\n"
                    },
                    {
                        "username": "Joshi_Deepti",
                        "content": "i wonder why binary search approach(T.C-O(logn))  is giving TLE and iterative solution(T.C-O(n)) is working fine.."
                    },
                    {
                        "username": "Minato235",
                        "content": "var search = function(nums, target) {\\n    for(let i=0;i<nums.length;i++){\\n    if(nums[i]==target) return i;\\n}\\nreturn -1;\\n};"
                    }
                ]
            },
            {
                "id": 1777495,
                "content": [
                    {
                        "username": "addu_coder",
                        "content": "I had used linear search and it\\'s find LoL!!!  @[leetcode](https://leetcode.com)"
                    },
                    {
                        "username": "NishantKende",
                        "content": "Guys, take it easy, Don\\'t get confused due to question\\'s description.\\nYou just need to search an array element inside given array. If you find it, return the index else return -1"
                    },
                    {
                        "username": "adityy",
                        "content": "why is this not working?\\nclass Solution {\\npublic:\\n    int search(vector<int>& nums, int target) {\\n        int high = nums.size()-1;\\n        int low = 0;\\n        while(low<high){\\n            int mid = low + (high - low)/2;\\n            if(nums[mid]==target) return mid+1;\\n            else if(nums[mid]>nums[mid+1]){\\n                if(nums[mid]>target)\\n                low = mid+1;\\n                else high = mid-1;\\n            }\\n            else if(nums[mid]<nums[mid+1]){\\n                if(nums[mid]>=target && nums[low]<=target)\\n                high = mid-1;\\n                else low = mid+1;\\n            }\\n        }\\n        return -1;\\n    }\\n};"
                    },
                    {
                        "username": "bparanj",
                        "content": "There are a couple of issues with your code. Here are the corrections:\\n\\n1. Your binary search loop should continue while `low <= high`, not while `low < high`. \\n\\n2. The check `nums[mid]==target` should return `mid`, not `mid+1`.\\n\\n3. Your conditions for checking which half to look in are incorrect. You want to determine if the left half is sorted and if the target is in that range, or if the right half is sorted and if the target is in that range.\\n\\nHere is a corrected version of your code:\\n\\n```cpp\\nclass Solution {\\npublic:\\n    int search(vector<int>& nums, int target) {\\n        int high = nums.size() - 1;\\n        int low = 0;\\n        while(low <= high){\\n            int mid = low + (high - low) / 2;\\n            if(nums[mid] == target) \\n                return mid;\\n            if(nums[low] <= nums[mid]) {  // Left half is sorted.\\n                if(nums[low] <= target && target < nums[mid]) \\n                    high = mid - 1;  // Target is in the left half.\\n                else\\n                    low = mid + 1;  // Target is in the right half.\\n            }\\n            else {  // Right half is sorted.\\n                if(nums[mid] < target && target <= nums[high])\\n                    low = mid + 1;  // Target is in the right half.\\n                else\\n                    high = mid - 1;  // Target is in the left half.\\n            }\\n        }\\n        return -1;\\n    }\\n};\\n```\\n\\nThis code works by first finding the middle of the current search range. If the middle element is the target, we\\'re done. Otherwise, we check if the left half of the range is sorted. If it is, and the target is in the range of the left half, we continue searching in the left half; otherwise, we search in the right half. If the left half is not sorted, that means the right half must be sorted. We then check if the target is in the range of the right half, and if so we continue searching in the right half; otherwise, we search in the left half."
                    },
                    {
                        "username": "kimkass",
                        "content": "def count_rotations_binary(nums):\\n    lo = 0\\n    hi = len(nums)-1\\n\\n    while hi>lo:\\n        mid = lo+hi//2\\n        mid_number = nums[mid]\\n\\n        print(\"lo :\",lo ,\"hi :\", hi,  \"mid :\",mid ,\"mid number :\", mid_number)\\n\\n        if mid > 0 and nums[mid] < nums[mid-1]:\\n            return mid\\n\\n        elif nums[mid] < nums[hi]:\\n            hi = mid-1\\n\\n        else:\\n            lo = mid+1\\n\\n// input nums : test1 = {\\n    \\'input\\' : {\\n        \\'nums\\' : [4,5,6,7,8,1,2,3] # after rotating 5 times\\n    },\\n    \\'output\\' : 5 # rotated 5 times means output = 5\\n}\\n\\n// Test failed on second division where mid + 1 = 4. following the same lo+hi//2. expected answer: 4+7=11.  11//2 = 5. \\nI am getting 7 for division of 11//2 as mid. what\\'s the problem in this code ?"
                    },
                    {
                        "username": "bparanj",
                        "content": "The issue lies in the order of operations in this line:\\n\\n```python\\nmid = lo + hi // 2\\n```\\n\\nIn Python, the division operator `//` has higher precedence than the addition operator `+`. This means that your code is actually performing `(hi // 2)` first, and then adding `lo` to the result. This will cause `mid` to be calculated incorrectly.\\n\\nYou want to divide the sum of `lo` and `hi` by `2`, so you should use parentheses to ensure the correct order of operations:\\n\\n```python\\nmid = (lo + hi) // 2\\n```\\n\\nThis line will first add `lo` and `hi`, and then divide the result by `2` (performing integer division), which will correctly calculate the middle index. Here\\'s the corrected code:\\n\\n```python\\ndef count_rotations_binary(nums):\\n    lo = 0\\n    hi = len(nums)-1\\n\\n    while hi > lo:\\n        mid = (lo + hi) // 2\\n        mid_number = nums[mid]\\n\\n        print(\"lo :\", lo, \"hi :\", hi, \"mid :\", mid, \"mid number :\", mid_number)\\n\\n        if mid > 0 and nums[mid] < nums[mid-1]:\\n            return mid\\n        elif nums[mid] < nums[hi]:\\n            hi = mid - 1\\n        else:\\n            lo = mid + 1\\n```\\n\\nThis will now correctly calculate the middle index and should produce the expected result."
                    },
                    {
                        "username": "kimkass",
                        "content": "if the target is different for every list the function has to be separate for  every list.\nor passing two elements in parenthesis nums (list as input) and output(target number as input), where function should return target number index position will work ?"
                    },
                    {
                        "username": "bparanj",
                        "content": "Yes, you can certainly pass the target number as an additional argument to the function. This is a common practice and will allow you to use the same function to search for different targets in different lists. The function signature would look something like this:\\n\\n```python\\ndef binary_search(nums, target):\\n    # Implementation here\\n```\\n\\nIn the body of this function, you would implement your binary search (or whatever searching algorithm you\\'re using). This function would take a list of numbers (`nums`) and a target number (`target`), and it would return the index of `target` within `nums`. If `target` is not in `nums`, you could return `-1` or some other sentinel value.\\n\\nHere\\'s an example of how you might call this function:\\n\\n```python\\nnums = [4, 5, 6, 7, 8, 1, 2, 3]\\ntarget = 6\\nprint(binary_search(nums, target))  # This would print 2, assuming the list is zero-indexed\\n```\\n\\nBy parameterizing the target number, you can easily reuse the same function to search for different targets in different lists."
                    },
                    {
                        "username": "skadam183",
                        "content": "I am wondering if it\\'s only me who is thinking problem was too easy or too difficult that I didn\\'t understand.\\nIt was just one liner.\\n\\n` return nums.indexOf(target);`"
                    },
                    {
                        "username": "brbamcoding",
                        "content": "This would not have log time complexity. It would be linear"
                    },
                    {
                        "username": "ziico",
                        "content": "Why does this pass all the test cases with linear search if its time complexity is O(n). Shouldn\\'t it pass all the test cases only if binary search is used, as O(logn) is required. I\\'m confused??\\n"
                    },
                    {
                        "username": "rasin02",
                        "content": "Approch 1\\n\\n uses a while loop to repeatedly divide the search space in half until the target value is found or until the search space is exhausted. \\n The loop starts with the left index set to 0 and the right index set to the last element of the array.\\n The mid index is calculated as the average of the left and right indices. \\n The function then checks if the element at the mid index is equal to the target value, and if so, it returns the mid index as the result. If the element at the mid index is not equal to the target value, the function checks if the left side of the array is strictly increasing or not. \\n If it is, it checks if the target value is between the left and mid elements, and if so, it updates the right index to be one less than the mid index, otherwise it updates the left index to be one more than the mid index.\\n If the left side is not strictly increasing, the function checks if the target value is between the mid and right elements, and if so, it updates the left index to be one more than the mid index, otherwise it updates the right index to be one less than the mid index. \\n If the search space is exhausted without finding the target value, the function returns -1. \\n\\nint search(vector<int>& nums, int target) \\n    {\\n        int left=0;\\n        int right=nums.size()-1;\\n        int mid;\\n        while(left<=right)\\n        {\\n            mid=(left+right)/2;\\n            if(nums[mid]==target)\\n            return mid;\\n            //check if left side is strictly increasing or not\\n            else if (nums[left]<=nums[mid])\\n            {\\n                if(nums[left]<=target && nums[mid]>=target)\\n                \\n                    right=mid-1;\\n                    else \\n                    {\\n                    left=mid+1;\\n                    }\\n            \\n            }\\n            //check if right side is strictly increasing or not\\n\\n            else \\n            {\\n                if(nums[mid]<=target && nums[right]>=target)\\n                \\n                    left=mid+1;\\n                else \\n                    right=mid-1;\\n                \\n            }\\n        }   \\n        return -1;   \\n    }\\n\\nApproach 2\\nusing the concept the earlier solved provblem number 33\\nin which we were asked to find the minimin element in the roated sorted arrray\\nusign that concept we find the index of the minimum element  of the arrray and the we use the binary search to search the target in the start to index and  apply another search on the index+1 to end and how ever return the answer greater than -1 will be final answer\\ni`nt binary_search(vector<int>& arr, int beg, int end, int target) {\\n         while(beg <= end) {\\n            int mid = beg + (end - beg) / 2;\\n            if (arr[mid] == target) {\\n                return mid;\\n            } else if (arr[mid] <= target) {\\n                beg = mid + 1;\\n            } else {\\n                end = mid - 1;\\n            }\\n        }\\n        return -1;\\n   }\\n   \\nint findmin(vector<int>nums, int target)\\n{\\n    int start=0;\\n    int n=nums.size()-1;\\n    int end=n-1;\\n\\n    int mid;\\n    while(start<=end){\\n        mid=start+(end-start)/2;\\n        int prev=(mid+n-1)%n;\\n        int next=(mid+1)%n;\\n        if(nums[mid]<=prev && nums[mid]<=next)\\n        return mid;\\n        else if(nums[mid]>=nums[0])\\n            start=mid+1;\\n        else if(nums[mid]<=nums[n])\\n            end=mid-1;\\n    }\\n    return 0;\\n}\\n  int search(vector<int>& nums, int target) \\n    {\\n        int min_index=findmin(nums,target);\\n        int ans1=binary_search(nums,0,min_index,target);\\n        int ans2=binary_search(nums,min_index,nums.size()-1,target);\\n        int a=ans1>0?ans1:-1;\\n        int b=ans2>0?ans2:-1;\\n        if(a>=0)\\n        return a;\\n        else\\n        return b;\\n        \\n    }\\n`\\n"
                    },
                    {
                        "username": "Joshi_Deepti",
                        "content": "i wonder why binary search approach(T.C-O(logn))  is giving TLE and iterative solution(T.C-O(n)) is working fine.."
                    },
                    {
                        "username": "Minato235",
                        "content": "var search = function(nums, target) {\\n    for(let i=0;i<nums.length;i++){\\n    if(nums[i]==target) return i;\\n}\\nreturn -1;\\n};"
                    }
                ]
            },
            {
                "id": 1776630,
                "content": [
                    {
                        "username": "addu_coder",
                        "content": "I had used linear search and it\\'s find LoL!!!  @[leetcode](https://leetcode.com)"
                    },
                    {
                        "username": "NishantKende",
                        "content": "Guys, take it easy, Don\\'t get confused due to question\\'s description.\\nYou just need to search an array element inside given array. If you find it, return the index else return -1"
                    },
                    {
                        "username": "adityy",
                        "content": "why is this not working?\\nclass Solution {\\npublic:\\n    int search(vector<int>& nums, int target) {\\n        int high = nums.size()-1;\\n        int low = 0;\\n        while(low<high){\\n            int mid = low + (high - low)/2;\\n            if(nums[mid]==target) return mid+1;\\n            else if(nums[mid]>nums[mid+1]){\\n                if(nums[mid]>target)\\n                low = mid+1;\\n                else high = mid-1;\\n            }\\n            else if(nums[mid]<nums[mid+1]){\\n                if(nums[mid]>=target && nums[low]<=target)\\n                high = mid-1;\\n                else low = mid+1;\\n            }\\n        }\\n        return -1;\\n    }\\n};"
                    },
                    {
                        "username": "bparanj",
                        "content": "There are a couple of issues with your code. Here are the corrections:\\n\\n1. Your binary search loop should continue while `low <= high`, not while `low < high`. \\n\\n2. The check `nums[mid]==target` should return `mid`, not `mid+1`.\\n\\n3. Your conditions for checking which half to look in are incorrect. You want to determine if the left half is sorted and if the target is in that range, or if the right half is sorted and if the target is in that range.\\n\\nHere is a corrected version of your code:\\n\\n```cpp\\nclass Solution {\\npublic:\\n    int search(vector<int>& nums, int target) {\\n        int high = nums.size() - 1;\\n        int low = 0;\\n        while(low <= high){\\n            int mid = low + (high - low) / 2;\\n            if(nums[mid] == target) \\n                return mid;\\n            if(nums[low] <= nums[mid]) {  // Left half is sorted.\\n                if(nums[low] <= target && target < nums[mid]) \\n                    high = mid - 1;  // Target is in the left half.\\n                else\\n                    low = mid + 1;  // Target is in the right half.\\n            }\\n            else {  // Right half is sorted.\\n                if(nums[mid] < target && target <= nums[high])\\n                    low = mid + 1;  // Target is in the right half.\\n                else\\n                    high = mid - 1;  // Target is in the left half.\\n            }\\n        }\\n        return -1;\\n    }\\n};\\n```\\n\\nThis code works by first finding the middle of the current search range. If the middle element is the target, we\\'re done. Otherwise, we check if the left half of the range is sorted. If it is, and the target is in the range of the left half, we continue searching in the left half; otherwise, we search in the right half. If the left half is not sorted, that means the right half must be sorted. We then check if the target is in the range of the right half, and if so we continue searching in the right half; otherwise, we search in the left half."
                    },
                    {
                        "username": "kimkass",
                        "content": "def count_rotations_binary(nums):\\n    lo = 0\\n    hi = len(nums)-1\\n\\n    while hi>lo:\\n        mid = lo+hi//2\\n        mid_number = nums[mid]\\n\\n        print(\"lo :\",lo ,\"hi :\", hi,  \"mid :\",mid ,\"mid number :\", mid_number)\\n\\n        if mid > 0 and nums[mid] < nums[mid-1]:\\n            return mid\\n\\n        elif nums[mid] < nums[hi]:\\n            hi = mid-1\\n\\n        else:\\n            lo = mid+1\\n\\n// input nums : test1 = {\\n    \\'input\\' : {\\n        \\'nums\\' : [4,5,6,7,8,1,2,3] # after rotating 5 times\\n    },\\n    \\'output\\' : 5 # rotated 5 times means output = 5\\n}\\n\\n// Test failed on second division where mid + 1 = 4. following the same lo+hi//2. expected answer: 4+7=11.  11//2 = 5. \\nI am getting 7 for division of 11//2 as mid. what\\'s the problem in this code ?"
                    },
                    {
                        "username": "bparanj",
                        "content": "The issue lies in the order of operations in this line:\\n\\n```python\\nmid = lo + hi // 2\\n```\\n\\nIn Python, the division operator `//` has higher precedence than the addition operator `+`. This means that your code is actually performing `(hi // 2)` first, and then adding `lo` to the result. This will cause `mid` to be calculated incorrectly.\\n\\nYou want to divide the sum of `lo` and `hi` by `2`, so you should use parentheses to ensure the correct order of operations:\\n\\n```python\\nmid = (lo + hi) // 2\\n```\\n\\nThis line will first add `lo` and `hi`, and then divide the result by `2` (performing integer division), which will correctly calculate the middle index. Here\\'s the corrected code:\\n\\n```python\\ndef count_rotations_binary(nums):\\n    lo = 0\\n    hi = len(nums)-1\\n\\n    while hi > lo:\\n        mid = (lo + hi) // 2\\n        mid_number = nums[mid]\\n\\n        print(\"lo :\", lo, \"hi :\", hi, \"mid :\", mid, \"mid number :\", mid_number)\\n\\n        if mid > 0 and nums[mid] < nums[mid-1]:\\n            return mid\\n        elif nums[mid] < nums[hi]:\\n            hi = mid - 1\\n        else:\\n            lo = mid + 1\\n```\\n\\nThis will now correctly calculate the middle index and should produce the expected result."
                    },
                    {
                        "username": "kimkass",
                        "content": "if the target is different for every list the function has to be separate for  every list.\nor passing two elements in parenthesis nums (list as input) and output(target number as input), where function should return target number index position will work ?"
                    },
                    {
                        "username": "bparanj",
                        "content": "Yes, you can certainly pass the target number as an additional argument to the function. This is a common practice and will allow you to use the same function to search for different targets in different lists. The function signature would look something like this:\\n\\n```python\\ndef binary_search(nums, target):\\n    # Implementation here\\n```\\n\\nIn the body of this function, you would implement your binary search (or whatever searching algorithm you\\'re using). This function would take a list of numbers (`nums`) and a target number (`target`), and it would return the index of `target` within `nums`. If `target` is not in `nums`, you could return `-1` or some other sentinel value.\\n\\nHere\\'s an example of how you might call this function:\\n\\n```python\\nnums = [4, 5, 6, 7, 8, 1, 2, 3]\\ntarget = 6\\nprint(binary_search(nums, target))  # This would print 2, assuming the list is zero-indexed\\n```\\n\\nBy parameterizing the target number, you can easily reuse the same function to search for different targets in different lists."
                    },
                    {
                        "username": "skadam183",
                        "content": "I am wondering if it\\'s only me who is thinking problem was too easy or too difficult that I didn\\'t understand.\\nIt was just one liner.\\n\\n` return nums.indexOf(target);`"
                    },
                    {
                        "username": "brbamcoding",
                        "content": "This would not have log time complexity. It would be linear"
                    },
                    {
                        "username": "ziico",
                        "content": "Why does this pass all the test cases with linear search if its time complexity is O(n). Shouldn\\'t it pass all the test cases only if binary search is used, as O(logn) is required. I\\'m confused??\\n"
                    },
                    {
                        "username": "rasin02",
                        "content": "Approch 1\\n\\n uses a while loop to repeatedly divide the search space in half until the target value is found or until the search space is exhausted. \\n The loop starts with the left index set to 0 and the right index set to the last element of the array.\\n The mid index is calculated as the average of the left and right indices. \\n The function then checks if the element at the mid index is equal to the target value, and if so, it returns the mid index as the result. If the element at the mid index is not equal to the target value, the function checks if the left side of the array is strictly increasing or not. \\n If it is, it checks if the target value is between the left and mid elements, and if so, it updates the right index to be one less than the mid index, otherwise it updates the left index to be one more than the mid index.\\n If the left side is not strictly increasing, the function checks if the target value is between the mid and right elements, and if so, it updates the left index to be one more than the mid index, otherwise it updates the right index to be one less than the mid index. \\n If the search space is exhausted without finding the target value, the function returns -1. \\n\\nint search(vector<int>& nums, int target) \\n    {\\n        int left=0;\\n        int right=nums.size()-1;\\n        int mid;\\n        while(left<=right)\\n        {\\n            mid=(left+right)/2;\\n            if(nums[mid]==target)\\n            return mid;\\n            //check if left side is strictly increasing or not\\n            else if (nums[left]<=nums[mid])\\n            {\\n                if(nums[left]<=target && nums[mid]>=target)\\n                \\n                    right=mid-1;\\n                    else \\n                    {\\n                    left=mid+1;\\n                    }\\n            \\n            }\\n            //check if right side is strictly increasing or not\\n\\n            else \\n            {\\n                if(nums[mid]<=target && nums[right]>=target)\\n                \\n                    left=mid+1;\\n                else \\n                    right=mid-1;\\n                \\n            }\\n        }   \\n        return -1;   \\n    }\\n\\nApproach 2\\nusing the concept the earlier solved provblem number 33\\nin which we were asked to find the minimin element in the roated sorted arrray\\nusign that concept we find the index of the minimum element  of the arrray and the we use the binary search to search the target in the start to index and  apply another search on the index+1 to end and how ever return the answer greater than -1 will be final answer\\ni`nt binary_search(vector<int>& arr, int beg, int end, int target) {\\n         while(beg <= end) {\\n            int mid = beg + (end - beg) / 2;\\n            if (arr[mid] == target) {\\n                return mid;\\n            } else if (arr[mid] <= target) {\\n                beg = mid + 1;\\n            } else {\\n                end = mid - 1;\\n            }\\n        }\\n        return -1;\\n   }\\n   \\nint findmin(vector<int>nums, int target)\\n{\\n    int start=0;\\n    int n=nums.size()-1;\\n    int end=n-1;\\n\\n    int mid;\\n    while(start<=end){\\n        mid=start+(end-start)/2;\\n        int prev=(mid+n-1)%n;\\n        int next=(mid+1)%n;\\n        if(nums[mid]<=prev && nums[mid]<=next)\\n        return mid;\\n        else if(nums[mid]>=nums[0])\\n            start=mid+1;\\n        else if(nums[mid]<=nums[n])\\n            end=mid-1;\\n    }\\n    return 0;\\n}\\n  int search(vector<int>& nums, int target) \\n    {\\n        int min_index=findmin(nums,target);\\n        int ans1=binary_search(nums,0,min_index,target);\\n        int ans2=binary_search(nums,min_index,nums.size()-1,target);\\n        int a=ans1>0?ans1:-1;\\n        int b=ans2>0?ans2:-1;\\n        if(a>=0)\\n        return a;\\n        else\\n        return b;\\n        \\n    }\\n`\\n"
                    },
                    {
                        "username": "Joshi_Deepti",
                        "content": "i wonder why binary search approach(T.C-O(logn))  is giving TLE and iterative solution(T.C-O(n)) is working fine.."
                    },
                    {
                        "username": "Minato235",
                        "content": "var search = function(nums, target) {\\n    for(let i=0;i<nums.length;i++){\\n    if(nums[i]==target) return i;\\n}\\nreturn -1;\\n};"
                    }
                ]
            },
            {
                "id": 1772761,
                "content": [
                    {
                        "username": "addu_coder",
                        "content": "I had used linear search and it\\'s find LoL!!!  @[leetcode](https://leetcode.com)"
                    },
                    {
                        "username": "NishantKende",
                        "content": "Guys, take it easy, Don\\'t get confused due to question\\'s description.\\nYou just need to search an array element inside given array. If you find it, return the index else return -1"
                    },
                    {
                        "username": "adityy",
                        "content": "why is this not working?\\nclass Solution {\\npublic:\\n    int search(vector<int>& nums, int target) {\\n        int high = nums.size()-1;\\n        int low = 0;\\n        while(low<high){\\n            int mid = low + (high - low)/2;\\n            if(nums[mid]==target) return mid+1;\\n            else if(nums[mid]>nums[mid+1]){\\n                if(nums[mid]>target)\\n                low = mid+1;\\n                else high = mid-1;\\n            }\\n            else if(nums[mid]<nums[mid+1]){\\n                if(nums[mid]>=target && nums[low]<=target)\\n                high = mid-1;\\n                else low = mid+1;\\n            }\\n        }\\n        return -1;\\n    }\\n};"
                    },
                    {
                        "username": "bparanj",
                        "content": "There are a couple of issues with your code. Here are the corrections:\\n\\n1. Your binary search loop should continue while `low <= high`, not while `low < high`. \\n\\n2. The check `nums[mid]==target` should return `mid`, not `mid+1`.\\n\\n3. Your conditions for checking which half to look in are incorrect. You want to determine if the left half is sorted and if the target is in that range, or if the right half is sorted and if the target is in that range.\\n\\nHere is a corrected version of your code:\\n\\n```cpp\\nclass Solution {\\npublic:\\n    int search(vector<int>& nums, int target) {\\n        int high = nums.size() - 1;\\n        int low = 0;\\n        while(low <= high){\\n            int mid = low + (high - low) / 2;\\n            if(nums[mid] == target) \\n                return mid;\\n            if(nums[low] <= nums[mid]) {  // Left half is sorted.\\n                if(nums[low] <= target && target < nums[mid]) \\n                    high = mid - 1;  // Target is in the left half.\\n                else\\n                    low = mid + 1;  // Target is in the right half.\\n            }\\n            else {  // Right half is sorted.\\n                if(nums[mid] < target && target <= nums[high])\\n                    low = mid + 1;  // Target is in the right half.\\n                else\\n                    high = mid - 1;  // Target is in the left half.\\n            }\\n        }\\n        return -1;\\n    }\\n};\\n```\\n\\nThis code works by first finding the middle of the current search range. If the middle element is the target, we\\'re done. Otherwise, we check if the left half of the range is sorted. If it is, and the target is in the range of the left half, we continue searching in the left half; otherwise, we search in the right half. If the left half is not sorted, that means the right half must be sorted. We then check if the target is in the range of the right half, and if so we continue searching in the right half; otherwise, we search in the left half."
                    },
                    {
                        "username": "kimkass",
                        "content": "def count_rotations_binary(nums):\\n    lo = 0\\n    hi = len(nums)-1\\n\\n    while hi>lo:\\n        mid = lo+hi//2\\n        mid_number = nums[mid]\\n\\n        print(\"lo :\",lo ,\"hi :\", hi,  \"mid :\",mid ,\"mid number :\", mid_number)\\n\\n        if mid > 0 and nums[mid] < nums[mid-1]:\\n            return mid\\n\\n        elif nums[mid] < nums[hi]:\\n            hi = mid-1\\n\\n        else:\\n            lo = mid+1\\n\\n// input nums : test1 = {\\n    \\'input\\' : {\\n        \\'nums\\' : [4,5,6,7,8,1,2,3] # after rotating 5 times\\n    },\\n    \\'output\\' : 5 # rotated 5 times means output = 5\\n}\\n\\n// Test failed on second division where mid + 1 = 4. following the same lo+hi//2. expected answer: 4+7=11.  11//2 = 5. \\nI am getting 7 for division of 11//2 as mid. what\\'s the problem in this code ?"
                    },
                    {
                        "username": "bparanj",
                        "content": "The issue lies in the order of operations in this line:\\n\\n```python\\nmid = lo + hi // 2\\n```\\n\\nIn Python, the division operator `//` has higher precedence than the addition operator `+`. This means that your code is actually performing `(hi // 2)` first, and then adding `lo` to the result. This will cause `mid` to be calculated incorrectly.\\n\\nYou want to divide the sum of `lo` and `hi` by `2`, so you should use parentheses to ensure the correct order of operations:\\n\\n```python\\nmid = (lo + hi) // 2\\n```\\n\\nThis line will first add `lo` and `hi`, and then divide the result by `2` (performing integer division), which will correctly calculate the middle index. Here\\'s the corrected code:\\n\\n```python\\ndef count_rotations_binary(nums):\\n    lo = 0\\n    hi = len(nums)-1\\n\\n    while hi > lo:\\n        mid = (lo + hi) // 2\\n        mid_number = nums[mid]\\n\\n        print(\"lo :\", lo, \"hi :\", hi, \"mid :\", mid, \"mid number :\", mid_number)\\n\\n        if mid > 0 and nums[mid] < nums[mid-1]:\\n            return mid\\n        elif nums[mid] < nums[hi]:\\n            hi = mid - 1\\n        else:\\n            lo = mid + 1\\n```\\n\\nThis will now correctly calculate the middle index and should produce the expected result."
                    },
                    {
                        "username": "kimkass",
                        "content": "if the target is different for every list the function has to be separate for  every list.\nor passing two elements in parenthesis nums (list as input) and output(target number as input), where function should return target number index position will work ?"
                    },
                    {
                        "username": "bparanj",
                        "content": "Yes, you can certainly pass the target number as an additional argument to the function. This is a common practice and will allow you to use the same function to search for different targets in different lists. The function signature would look something like this:\\n\\n```python\\ndef binary_search(nums, target):\\n    # Implementation here\\n```\\n\\nIn the body of this function, you would implement your binary search (or whatever searching algorithm you\\'re using). This function would take a list of numbers (`nums`) and a target number (`target`), and it would return the index of `target` within `nums`. If `target` is not in `nums`, you could return `-1` or some other sentinel value.\\n\\nHere\\'s an example of how you might call this function:\\n\\n```python\\nnums = [4, 5, 6, 7, 8, 1, 2, 3]\\ntarget = 6\\nprint(binary_search(nums, target))  # This would print 2, assuming the list is zero-indexed\\n```\\n\\nBy parameterizing the target number, you can easily reuse the same function to search for different targets in different lists."
                    },
                    {
                        "username": "skadam183",
                        "content": "I am wondering if it\\'s only me who is thinking problem was too easy or too difficult that I didn\\'t understand.\\nIt was just one liner.\\n\\n` return nums.indexOf(target);`"
                    },
                    {
                        "username": "brbamcoding",
                        "content": "This would not have log time complexity. It would be linear"
                    },
                    {
                        "username": "ziico",
                        "content": "Why does this pass all the test cases with linear search if its time complexity is O(n). Shouldn\\'t it pass all the test cases only if binary search is used, as O(logn) is required. I\\'m confused??\\n"
                    },
                    {
                        "username": "rasin02",
                        "content": "Approch 1\\n\\n uses a while loop to repeatedly divide the search space in half until the target value is found or until the search space is exhausted. \\n The loop starts with the left index set to 0 and the right index set to the last element of the array.\\n The mid index is calculated as the average of the left and right indices. \\n The function then checks if the element at the mid index is equal to the target value, and if so, it returns the mid index as the result. If the element at the mid index is not equal to the target value, the function checks if the left side of the array is strictly increasing or not. \\n If it is, it checks if the target value is between the left and mid elements, and if so, it updates the right index to be one less than the mid index, otherwise it updates the left index to be one more than the mid index.\\n If the left side is not strictly increasing, the function checks if the target value is between the mid and right elements, and if so, it updates the left index to be one more than the mid index, otherwise it updates the right index to be one less than the mid index. \\n If the search space is exhausted without finding the target value, the function returns -1. \\n\\nint search(vector<int>& nums, int target) \\n    {\\n        int left=0;\\n        int right=nums.size()-1;\\n        int mid;\\n        while(left<=right)\\n        {\\n            mid=(left+right)/2;\\n            if(nums[mid]==target)\\n            return mid;\\n            //check if left side is strictly increasing or not\\n            else if (nums[left]<=nums[mid])\\n            {\\n                if(nums[left]<=target && nums[mid]>=target)\\n                \\n                    right=mid-1;\\n                    else \\n                    {\\n                    left=mid+1;\\n                    }\\n            \\n            }\\n            //check if right side is strictly increasing or not\\n\\n            else \\n            {\\n                if(nums[mid]<=target && nums[right]>=target)\\n                \\n                    left=mid+1;\\n                else \\n                    right=mid-1;\\n                \\n            }\\n        }   \\n        return -1;   \\n    }\\n\\nApproach 2\\nusing the concept the earlier solved provblem number 33\\nin which we were asked to find the minimin element in the roated sorted arrray\\nusign that concept we find the index of the minimum element  of the arrray and the we use the binary search to search the target in the start to index and  apply another search on the index+1 to end and how ever return the answer greater than -1 will be final answer\\ni`nt binary_search(vector<int>& arr, int beg, int end, int target) {\\n         while(beg <= end) {\\n            int mid = beg + (end - beg) / 2;\\n            if (arr[mid] == target) {\\n                return mid;\\n            } else if (arr[mid] <= target) {\\n                beg = mid + 1;\\n            } else {\\n                end = mid - 1;\\n            }\\n        }\\n        return -1;\\n   }\\n   \\nint findmin(vector<int>nums, int target)\\n{\\n    int start=0;\\n    int n=nums.size()-1;\\n    int end=n-1;\\n\\n    int mid;\\n    while(start<=end){\\n        mid=start+(end-start)/2;\\n        int prev=(mid+n-1)%n;\\n        int next=(mid+1)%n;\\n        if(nums[mid]<=prev && nums[mid]<=next)\\n        return mid;\\n        else if(nums[mid]>=nums[0])\\n            start=mid+1;\\n        else if(nums[mid]<=nums[n])\\n            end=mid-1;\\n    }\\n    return 0;\\n}\\n  int search(vector<int>& nums, int target) \\n    {\\n        int min_index=findmin(nums,target);\\n        int ans1=binary_search(nums,0,min_index,target);\\n        int ans2=binary_search(nums,min_index,nums.size()-1,target);\\n        int a=ans1>0?ans1:-1;\\n        int b=ans2>0?ans2:-1;\\n        if(a>=0)\\n        return a;\\n        else\\n        return b;\\n        \\n    }\\n`\\n"
                    },
                    {
                        "username": "Joshi_Deepti",
                        "content": "i wonder why binary search approach(T.C-O(logn))  is giving TLE and iterative solution(T.C-O(n)) is working fine.."
                    },
                    {
                        "username": "Minato235",
                        "content": "var search = function(nums, target) {\\n    for(let i=0;i<nums.length;i++){\\n    if(nums[i]==target) return i;\\n}\\nreturn -1;\\n};"
                    }
                ]
            },
            {
                "id": 1772688,
                "content": [
                    {
                        "username": "mahenderyadav9703488649",
                        "content": "int l=0,h=a.length-1,m=0;\\n\\t\\twhile(l<=h) {\\n\\t\\t\\tm=(l+h)/2;\\n\\t\\t\\tif(target==a[m]) {\\n\\t\\t\\t\\treturn m;\\n\\t\\t\\t}\\n\\t\\t\\t//left sorted portion\\n\\t\\t\\telse if(a[l]<=a[m]) {\\n\\t\\t\\t\\tif(target>=a[l]&&target<=a[m]) {\\n\\t\\t\\t\\t\\th=m-1;\\n\\t\\t\\t\\t}\\n\\t\\t\\t\\telse {\\n\\t\\t\\t\\t\\tl=m+1;\\n\\t\\t\\t\\t}\\n\\t\\t\\t}\\n\\t\\t\\t//right sorted portion\\n\\t\\t\\telse {\\n\\t\\t\\t\\tif(target>a[m]&&target<=a[h]) {\\n\\t\\t\\t\\t\\tl=m+1;\\n\\t\\t\\t\\t}\\n\\t\\t\\t\\telse {\\n\\t\\t\\t\\t\\th=m-1;\\n\\t\\t\\t\\t}\\n\\t\\t\\t}\\n\\t\\t}\\n\\t\\treturn -1;\\n\\t}\\n\\n\\tpublic static void main(String[] args) {\\n\\t}}\\n"
                    },
                    {
                        "username": "vk783838",
                        "content": "where is k in this question?"
                    },
                    {
                        "username": "mohamed_waseela",
                        "content": "https://youtu.be/-Qpk2XJ5XJQ"
                    },
                    {
                        "username": "deleted_user",
                        "content": "class Solution:\\n    def search(self, nums: List[int], target: int) -> int:\\n        for i in range(len(nums)):\\n            if nums[i] == target:\\n                return i\\n        return -1"
                    },
                    {
                        "username": "Kmello94",
                        "content": "The fact that the array is rotated has basically no impact. I\\'m confused about the purpose of this problem."
                    },
                    {
                        "username": "sumitpratap28",
                        "content": "Here the main goal is to divide the array recursively in such a way that will get the target in sorted sub-part of array, and point to be note that at least one part should be sorted, after every division step of binary search\\nSteps that need to follow recursively to find the sorted subarray to search for an element\\n\\n1). If mid>=a[start], it means first part is sorted try to search in it, if target exist in this (first) half range, then end should be shifted to mid-1, otherwise start should point to mid+1 i.e. second half start.\\n2). If mid<a[start], it means second half will be sorted try to search in it, if target exist in this half range, then start should be shifted to mid+1, otherwise end should point to mid-1, i.e. first half end.\\n\\nPoints to be noted:\\n\\n* In every step we are discarding one half of remained subarray or original array, same like binary search that\\'s why here the complexity still remains O(logn).\\n* In between division of subparts one of two steps stated above will come, and that\\'s why recursion is there or these steps should be under while loop."
                    },
                    {
                        "username": "hrishavratan",
                        "content": "I am getting heap buffer overflow without using any dynamic allocation in heap in the code this \\nint search(vector<int>& nums, int target) \\n    {\\n        int start=0,end=nums.size()-1,mid,key;\\n        for(mid=start+(end-start)/2;start<=end;mid=start+(end-start)/2)\\n        {\\n            \\n            if(nums[mid]<=nums[mid+1])\\n            {\\n                end=mid-1;\\n            }\\n            else\\n            {\\n                key=mid+1;\\n                break;\\n            }\\n        }\\n        if(nums[nums.size()-1]<target)\\n        {\\n            start=0,end=key-1;\\n        }\\n        else\\n        {\\n            start=key,end=nums.size()-1;\\n        }\\n        for(mid=start+(end-start)/2;start<=end;mid=start+(end-start)/2)\\n        {\\n            if(nums[mid]>target)\\n            {\\n                end=mid-1;\\n            }\\n            else if(nums[mid]<target)\\n            {\\n                start=mid+1;\\n            }\\n            else\\n            {\\n                return mid;\\n            }\\n        }\\n        return -1;\\n    }"
                    },
                    {
                        "username": "bparanj",
                        "content": "The error is because you are trying to access the index \"mid+1\" of the vector \"nums\" without checking whether \"mid+1\" is a valid index for the vector. If \"mid\" is the last index of the vector, \"mid+1\" will be out-of-bound, and trying to access such an index will result in undefined behavior such as heap buffer overflow.\\n\\nThe problematic line is:\\n```cpp\\nif(nums[mid]<=nums[mid+1])\\n```\\nTo fix this, you need to ensure that \"mid+1\" does not exceed the size of the vector before accessing it. Here\\'s how you could do it:\\n```cpp\\nif(mid < nums.size()-1 && nums[mid] <= nums[mid+1])\\n```\\nPlease ensure to apply similar changes to any other parts of the code that may attempt to access out-of-bound indices. Always remember that when working with arrays or vectors, it\\'s crucial to ensure that you\\'re not accessing indices outside of their size. This is a common source of bugs and can lead to serious problems such as buffer overflows."
                    },
                    {
                        "username": "kartikg_09",
                        "content": "https://github.com/kartikgupta09/java-/commit/468b4b631ffd1e0af9934e8508c22d8e3c19b04b"
                    },
                    {
                        "username": "khushimattu",
                        "content": "we simply have to search for that element in the array?"
                    },
                    {
                        "username": "khushimattu",
                        "content": "[@mr_unfunny_](/mr_unfunny_) oohh, got it."
                    },
                    {
                        "username": "mrunfunny",
                        "content": "[@Khushi_Mattu](/Khushi_Mattu) It\\'s not also a simple binary search. Because the array is rotated, we need to handle some extra edge cases. Doing it with simple linear search makes it an easy question. This question has weak test cases that\\'s why it allows linear search. It should\\'ve thrown a TLE on linear search."
                    },
                    {
                        "username": "khushimattu",
                        "content": "[@mr_unfunny_](/mr_unfunny_) oh so basically just binary search right? It was a medium level question so I was just shocked that we were expected to just do a search. :)"
                    },
                    {
                        "username": "mrunfunny",
                        "content": "A simple linear search would be O(N) but this question is asking us to solve it in O(lgn)."
                    },
                    {
                        "username": "mohamed_waseela",
                        "content": "Best Explanation:\\nhttps://youtu.be/zx-c48gtCsc"
                    }
                ]
            },
            {
                "id": 1754245,
                "content": [
                    {
                        "username": "mahenderyadav9703488649",
                        "content": "int l=0,h=a.length-1,m=0;\\n\\t\\twhile(l<=h) {\\n\\t\\t\\tm=(l+h)/2;\\n\\t\\t\\tif(target==a[m]) {\\n\\t\\t\\t\\treturn m;\\n\\t\\t\\t}\\n\\t\\t\\t//left sorted portion\\n\\t\\t\\telse if(a[l]<=a[m]) {\\n\\t\\t\\t\\tif(target>=a[l]&&target<=a[m]) {\\n\\t\\t\\t\\t\\th=m-1;\\n\\t\\t\\t\\t}\\n\\t\\t\\t\\telse {\\n\\t\\t\\t\\t\\tl=m+1;\\n\\t\\t\\t\\t}\\n\\t\\t\\t}\\n\\t\\t\\t//right sorted portion\\n\\t\\t\\telse {\\n\\t\\t\\t\\tif(target>a[m]&&target<=a[h]) {\\n\\t\\t\\t\\t\\tl=m+1;\\n\\t\\t\\t\\t}\\n\\t\\t\\t\\telse {\\n\\t\\t\\t\\t\\th=m-1;\\n\\t\\t\\t\\t}\\n\\t\\t\\t}\\n\\t\\t}\\n\\t\\treturn -1;\\n\\t}\\n\\n\\tpublic static void main(String[] args) {\\n\\t}}\\n"
                    },
                    {
                        "username": "vk783838",
                        "content": "where is k in this question?"
                    },
                    {
                        "username": "mohamed_waseela",
                        "content": "https://youtu.be/-Qpk2XJ5XJQ"
                    },
                    {
                        "username": "deleted_user",
                        "content": "class Solution:\\n    def search(self, nums: List[int], target: int) -> int:\\n        for i in range(len(nums)):\\n            if nums[i] == target:\\n                return i\\n        return -1"
                    },
                    {
                        "username": "Kmello94",
                        "content": "The fact that the array is rotated has basically no impact. I\\'m confused about the purpose of this problem."
                    },
                    {
                        "username": "sumitpratap28",
                        "content": "Here the main goal is to divide the array recursively in such a way that will get the target in sorted sub-part of array, and point to be note that at least one part should be sorted, after every division step of binary search\\nSteps that need to follow recursively to find the sorted subarray to search for an element\\n\\n1). If mid>=a[start], it means first part is sorted try to search in it, if target exist in this (first) half range, then end should be shifted to mid-1, otherwise start should point to mid+1 i.e. second half start.\\n2). If mid<a[start], it means second half will be sorted try to search in it, if target exist in this half range, then start should be shifted to mid+1, otherwise end should point to mid-1, i.e. first half end.\\n\\nPoints to be noted:\\n\\n* In every step we are discarding one half of remained subarray or original array, same like binary search that\\'s why here the complexity still remains O(logn).\\n* In between division of subparts one of two steps stated above will come, and that\\'s why recursion is there or these steps should be under while loop."
                    },
                    {
                        "username": "hrishavratan",
                        "content": "I am getting heap buffer overflow without using any dynamic allocation in heap in the code this \\nint search(vector<int>& nums, int target) \\n    {\\n        int start=0,end=nums.size()-1,mid,key;\\n        for(mid=start+(end-start)/2;start<=end;mid=start+(end-start)/2)\\n        {\\n            \\n            if(nums[mid]<=nums[mid+1])\\n            {\\n                end=mid-1;\\n            }\\n            else\\n            {\\n                key=mid+1;\\n                break;\\n            }\\n        }\\n        if(nums[nums.size()-1]<target)\\n        {\\n            start=0,end=key-1;\\n        }\\n        else\\n        {\\n            start=key,end=nums.size()-1;\\n        }\\n        for(mid=start+(end-start)/2;start<=end;mid=start+(end-start)/2)\\n        {\\n            if(nums[mid]>target)\\n            {\\n                end=mid-1;\\n            }\\n            else if(nums[mid]<target)\\n            {\\n                start=mid+1;\\n            }\\n            else\\n            {\\n                return mid;\\n            }\\n        }\\n        return -1;\\n    }"
                    },
                    {
                        "username": "bparanj",
                        "content": "The error is because you are trying to access the index \"mid+1\" of the vector \"nums\" without checking whether \"mid+1\" is a valid index for the vector. If \"mid\" is the last index of the vector, \"mid+1\" will be out-of-bound, and trying to access such an index will result in undefined behavior such as heap buffer overflow.\\n\\nThe problematic line is:\\n```cpp\\nif(nums[mid]<=nums[mid+1])\\n```\\nTo fix this, you need to ensure that \"mid+1\" does not exceed the size of the vector before accessing it. Here\\'s how you could do it:\\n```cpp\\nif(mid < nums.size()-1 && nums[mid] <= nums[mid+1])\\n```\\nPlease ensure to apply similar changes to any other parts of the code that may attempt to access out-of-bound indices. Always remember that when working with arrays or vectors, it\\'s crucial to ensure that you\\'re not accessing indices outside of their size. This is a common source of bugs and can lead to serious problems such as buffer overflows."
                    },
                    {
                        "username": "kartikg_09",
                        "content": "https://github.com/kartikgupta09/java-/commit/468b4b631ffd1e0af9934e8508c22d8e3c19b04b"
                    },
                    {
                        "username": "khushimattu",
                        "content": "we simply have to search for that element in the array?"
                    },
                    {
                        "username": "khushimattu",
                        "content": "[@mr_unfunny_](/mr_unfunny_) oohh, got it."
                    },
                    {
                        "username": "mrunfunny",
                        "content": "[@Khushi_Mattu](/Khushi_Mattu) It\\'s not also a simple binary search. Because the array is rotated, we need to handle some extra edge cases. Doing it with simple linear search makes it an easy question. This question has weak test cases that\\'s why it allows linear search. It should\\'ve thrown a TLE on linear search."
                    },
                    {
                        "username": "khushimattu",
                        "content": "[@mr_unfunny_](/mr_unfunny_) oh so basically just binary search right? It was a medium level question so I was just shocked that we were expected to just do a search. :)"
                    },
                    {
                        "username": "mrunfunny",
                        "content": "A simple linear search would be O(N) but this question is asking us to solve it in O(lgn)."
                    },
                    {
                        "username": "mohamed_waseela",
                        "content": "Best Explanation:\\nhttps://youtu.be/zx-c48gtCsc"
                    }
                ]
            },
            {
                "id": 1752599,
                "content": [
                    {
                        "username": "mahenderyadav9703488649",
                        "content": "int l=0,h=a.length-1,m=0;\\n\\t\\twhile(l<=h) {\\n\\t\\t\\tm=(l+h)/2;\\n\\t\\t\\tif(target==a[m]) {\\n\\t\\t\\t\\treturn m;\\n\\t\\t\\t}\\n\\t\\t\\t//left sorted portion\\n\\t\\t\\telse if(a[l]<=a[m]) {\\n\\t\\t\\t\\tif(target>=a[l]&&target<=a[m]) {\\n\\t\\t\\t\\t\\th=m-1;\\n\\t\\t\\t\\t}\\n\\t\\t\\t\\telse {\\n\\t\\t\\t\\t\\tl=m+1;\\n\\t\\t\\t\\t}\\n\\t\\t\\t}\\n\\t\\t\\t//right sorted portion\\n\\t\\t\\telse {\\n\\t\\t\\t\\tif(target>a[m]&&target<=a[h]) {\\n\\t\\t\\t\\t\\tl=m+1;\\n\\t\\t\\t\\t}\\n\\t\\t\\t\\telse {\\n\\t\\t\\t\\t\\th=m-1;\\n\\t\\t\\t\\t}\\n\\t\\t\\t}\\n\\t\\t}\\n\\t\\treturn -1;\\n\\t}\\n\\n\\tpublic static void main(String[] args) {\\n\\t}}\\n"
                    },
                    {
                        "username": "vk783838",
                        "content": "where is k in this question?"
                    },
                    {
                        "username": "mohamed_waseela",
                        "content": "https://youtu.be/-Qpk2XJ5XJQ"
                    },
                    {
                        "username": "deleted_user",
                        "content": "class Solution:\\n    def search(self, nums: List[int], target: int) -> int:\\n        for i in range(len(nums)):\\n            if nums[i] == target:\\n                return i\\n        return -1"
                    },
                    {
                        "username": "Kmello94",
                        "content": "The fact that the array is rotated has basically no impact. I\\'m confused about the purpose of this problem."
                    },
                    {
                        "username": "sumitpratap28",
                        "content": "Here the main goal is to divide the array recursively in such a way that will get the target in sorted sub-part of array, and point to be note that at least one part should be sorted, after every division step of binary search\\nSteps that need to follow recursively to find the sorted subarray to search for an element\\n\\n1). If mid>=a[start], it means first part is sorted try to search in it, if target exist in this (first) half range, then end should be shifted to mid-1, otherwise start should point to mid+1 i.e. second half start.\\n2). If mid<a[start], it means second half will be sorted try to search in it, if target exist in this half range, then start should be shifted to mid+1, otherwise end should point to mid-1, i.e. first half end.\\n\\nPoints to be noted:\\n\\n* In every step we are discarding one half of remained subarray or original array, same like binary search that\\'s why here the complexity still remains O(logn).\\n* In between division of subparts one of two steps stated above will come, and that\\'s why recursion is there or these steps should be under while loop."
                    },
                    {
                        "username": "hrishavratan",
                        "content": "I am getting heap buffer overflow without using any dynamic allocation in heap in the code this \\nint search(vector<int>& nums, int target) \\n    {\\n        int start=0,end=nums.size()-1,mid,key;\\n        for(mid=start+(end-start)/2;start<=end;mid=start+(end-start)/2)\\n        {\\n            \\n            if(nums[mid]<=nums[mid+1])\\n            {\\n                end=mid-1;\\n            }\\n            else\\n            {\\n                key=mid+1;\\n                break;\\n            }\\n        }\\n        if(nums[nums.size()-1]<target)\\n        {\\n            start=0,end=key-1;\\n        }\\n        else\\n        {\\n            start=key,end=nums.size()-1;\\n        }\\n        for(mid=start+(end-start)/2;start<=end;mid=start+(end-start)/2)\\n        {\\n            if(nums[mid]>target)\\n            {\\n                end=mid-1;\\n            }\\n            else if(nums[mid]<target)\\n            {\\n                start=mid+1;\\n            }\\n            else\\n            {\\n                return mid;\\n            }\\n        }\\n        return -1;\\n    }"
                    },
                    {
                        "username": "bparanj",
                        "content": "The error is because you are trying to access the index \"mid+1\" of the vector \"nums\" without checking whether \"mid+1\" is a valid index for the vector. If \"mid\" is the last index of the vector, \"mid+1\" will be out-of-bound, and trying to access such an index will result in undefined behavior such as heap buffer overflow.\\n\\nThe problematic line is:\\n```cpp\\nif(nums[mid]<=nums[mid+1])\\n```\\nTo fix this, you need to ensure that \"mid+1\" does not exceed the size of the vector before accessing it. Here\\'s how you could do it:\\n```cpp\\nif(mid < nums.size()-1 && nums[mid] <= nums[mid+1])\\n```\\nPlease ensure to apply similar changes to any other parts of the code that may attempt to access out-of-bound indices. Always remember that when working with arrays or vectors, it\\'s crucial to ensure that you\\'re not accessing indices outside of their size. This is a common source of bugs and can lead to serious problems such as buffer overflows."
                    },
                    {
                        "username": "kartikg_09",
                        "content": "https://github.com/kartikgupta09/java-/commit/468b4b631ffd1e0af9934e8508c22d8e3c19b04b"
                    },
                    {
                        "username": "khushimattu",
                        "content": "we simply have to search for that element in the array?"
                    },
                    {
                        "username": "khushimattu",
                        "content": "[@mr_unfunny_](/mr_unfunny_) oohh, got it."
                    },
                    {
                        "username": "mrunfunny",
                        "content": "[@Khushi_Mattu](/Khushi_Mattu) It\\'s not also a simple binary search. Because the array is rotated, we need to handle some extra edge cases. Doing it with simple linear search makes it an easy question. This question has weak test cases that\\'s why it allows linear search. It should\\'ve thrown a TLE on linear search."
                    },
                    {
                        "username": "khushimattu",
                        "content": "[@mr_unfunny_](/mr_unfunny_) oh so basically just binary search right? It was a medium level question so I was just shocked that we were expected to just do a search. :)"
                    },
                    {
                        "username": "mrunfunny",
                        "content": "A simple linear search would be O(N) but this question is asking us to solve it in O(lgn)."
                    },
                    {
                        "username": "mohamed_waseela",
                        "content": "Best Explanation:\\nhttps://youtu.be/zx-c48gtCsc"
                    }
                ]
            },
            {
                "id": 1748703,
                "content": [
                    {
                        "username": "mahenderyadav9703488649",
                        "content": "int l=0,h=a.length-1,m=0;\\n\\t\\twhile(l<=h) {\\n\\t\\t\\tm=(l+h)/2;\\n\\t\\t\\tif(target==a[m]) {\\n\\t\\t\\t\\treturn m;\\n\\t\\t\\t}\\n\\t\\t\\t//left sorted portion\\n\\t\\t\\telse if(a[l]<=a[m]) {\\n\\t\\t\\t\\tif(target>=a[l]&&target<=a[m]) {\\n\\t\\t\\t\\t\\th=m-1;\\n\\t\\t\\t\\t}\\n\\t\\t\\t\\telse {\\n\\t\\t\\t\\t\\tl=m+1;\\n\\t\\t\\t\\t}\\n\\t\\t\\t}\\n\\t\\t\\t//right sorted portion\\n\\t\\t\\telse {\\n\\t\\t\\t\\tif(target>a[m]&&target<=a[h]) {\\n\\t\\t\\t\\t\\tl=m+1;\\n\\t\\t\\t\\t}\\n\\t\\t\\t\\telse {\\n\\t\\t\\t\\t\\th=m-1;\\n\\t\\t\\t\\t}\\n\\t\\t\\t}\\n\\t\\t}\\n\\t\\treturn -1;\\n\\t}\\n\\n\\tpublic static void main(String[] args) {\\n\\t}}\\n"
                    },
                    {
                        "username": "vk783838",
                        "content": "where is k in this question?"
                    },
                    {
                        "username": "mohamed_waseela",
                        "content": "https://youtu.be/-Qpk2XJ5XJQ"
                    },
                    {
                        "username": "deleted_user",
                        "content": "class Solution:\\n    def search(self, nums: List[int], target: int) -> int:\\n        for i in range(len(nums)):\\n            if nums[i] == target:\\n                return i\\n        return -1"
                    },
                    {
                        "username": "Kmello94",
                        "content": "The fact that the array is rotated has basically no impact. I\\'m confused about the purpose of this problem."
                    },
                    {
                        "username": "sumitpratap28",
                        "content": "Here the main goal is to divide the array recursively in such a way that will get the target in sorted sub-part of array, and point to be note that at least one part should be sorted, after every division step of binary search\\nSteps that need to follow recursively to find the sorted subarray to search for an element\\n\\n1). If mid>=a[start], it means first part is sorted try to search in it, if target exist in this (first) half range, then end should be shifted to mid-1, otherwise start should point to mid+1 i.e. second half start.\\n2). If mid<a[start], it means second half will be sorted try to search in it, if target exist in this half range, then start should be shifted to mid+1, otherwise end should point to mid-1, i.e. first half end.\\n\\nPoints to be noted:\\n\\n* In every step we are discarding one half of remained subarray or original array, same like binary search that\\'s why here the complexity still remains O(logn).\\n* In between division of subparts one of two steps stated above will come, and that\\'s why recursion is there or these steps should be under while loop."
                    },
                    {
                        "username": "hrishavratan",
                        "content": "I am getting heap buffer overflow without using any dynamic allocation in heap in the code this \\nint search(vector<int>& nums, int target) \\n    {\\n        int start=0,end=nums.size()-1,mid,key;\\n        for(mid=start+(end-start)/2;start<=end;mid=start+(end-start)/2)\\n        {\\n            \\n            if(nums[mid]<=nums[mid+1])\\n            {\\n                end=mid-1;\\n            }\\n            else\\n            {\\n                key=mid+1;\\n                break;\\n            }\\n        }\\n        if(nums[nums.size()-1]<target)\\n        {\\n            start=0,end=key-1;\\n        }\\n        else\\n        {\\n            start=key,end=nums.size()-1;\\n        }\\n        for(mid=start+(end-start)/2;start<=end;mid=start+(end-start)/2)\\n        {\\n            if(nums[mid]>target)\\n            {\\n                end=mid-1;\\n            }\\n            else if(nums[mid]<target)\\n            {\\n                start=mid+1;\\n            }\\n            else\\n            {\\n                return mid;\\n            }\\n        }\\n        return -1;\\n    }"
                    },
                    {
                        "username": "bparanj",
                        "content": "The error is because you are trying to access the index \"mid+1\" of the vector \"nums\" without checking whether \"mid+1\" is a valid index for the vector. If \"mid\" is the last index of the vector, \"mid+1\" will be out-of-bound, and trying to access such an index will result in undefined behavior such as heap buffer overflow.\\n\\nThe problematic line is:\\n```cpp\\nif(nums[mid]<=nums[mid+1])\\n```\\nTo fix this, you need to ensure that \"mid+1\" does not exceed the size of the vector before accessing it. Here\\'s how you could do it:\\n```cpp\\nif(mid < nums.size()-1 && nums[mid] <= nums[mid+1])\\n```\\nPlease ensure to apply similar changes to any other parts of the code that may attempt to access out-of-bound indices. Always remember that when working with arrays or vectors, it\\'s crucial to ensure that you\\'re not accessing indices outside of their size. This is a common source of bugs and can lead to serious problems such as buffer overflows."
                    },
                    {
                        "username": "kartikg_09",
                        "content": "https://github.com/kartikgupta09/java-/commit/468b4b631ffd1e0af9934e8508c22d8e3c19b04b"
                    },
                    {
                        "username": "khushimattu",
                        "content": "we simply have to search for that element in the array?"
                    },
                    {
                        "username": "khushimattu",
                        "content": "[@mr_unfunny_](/mr_unfunny_) oohh, got it."
                    },
                    {
                        "username": "mrunfunny",
                        "content": "[@Khushi_Mattu](/Khushi_Mattu) It\\'s not also a simple binary search. Because the array is rotated, we need to handle some extra edge cases. Doing it with simple linear search makes it an easy question. This question has weak test cases that\\'s why it allows linear search. It should\\'ve thrown a TLE on linear search."
                    },
                    {
                        "username": "khushimattu",
                        "content": "[@mr_unfunny_](/mr_unfunny_) oh so basically just binary search right? It was a medium level question so I was just shocked that we were expected to just do a search. :)"
                    },
                    {
                        "username": "mrunfunny",
                        "content": "A simple linear search would be O(N) but this question is asking us to solve it in O(lgn)."
                    },
                    {
                        "username": "mohamed_waseela",
                        "content": "Best Explanation:\\nhttps://youtu.be/zx-c48gtCsc"
                    }
                ]
            },
            {
                "id": 1745551,
                "content": [
                    {
                        "username": "mahenderyadav9703488649",
                        "content": "int l=0,h=a.length-1,m=0;\\n\\t\\twhile(l<=h) {\\n\\t\\t\\tm=(l+h)/2;\\n\\t\\t\\tif(target==a[m]) {\\n\\t\\t\\t\\treturn m;\\n\\t\\t\\t}\\n\\t\\t\\t//left sorted portion\\n\\t\\t\\telse if(a[l]<=a[m]) {\\n\\t\\t\\t\\tif(target>=a[l]&&target<=a[m]) {\\n\\t\\t\\t\\t\\th=m-1;\\n\\t\\t\\t\\t}\\n\\t\\t\\t\\telse {\\n\\t\\t\\t\\t\\tl=m+1;\\n\\t\\t\\t\\t}\\n\\t\\t\\t}\\n\\t\\t\\t//right sorted portion\\n\\t\\t\\telse {\\n\\t\\t\\t\\tif(target>a[m]&&target<=a[h]) {\\n\\t\\t\\t\\t\\tl=m+1;\\n\\t\\t\\t\\t}\\n\\t\\t\\t\\telse {\\n\\t\\t\\t\\t\\th=m-1;\\n\\t\\t\\t\\t}\\n\\t\\t\\t}\\n\\t\\t}\\n\\t\\treturn -1;\\n\\t}\\n\\n\\tpublic static void main(String[] args) {\\n\\t}}\\n"
                    },
                    {
                        "username": "vk783838",
                        "content": "where is k in this question?"
                    },
                    {
                        "username": "mohamed_waseela",
                        "content": "https://youtu.be/-Qpk2XJ5XJQ"
                    },
                    {
                        "username": "deleted_user",
                        "content": "class Solution:\\n    def search(self, nums: List[int], target: int) -> int:\\n        for i in range(len(nums)):\\n            if nums[i] == target:\\n                return i\\n        return -1"
                    },
                    {
                        "username": "Kmello94",
                        "content": "The fact that the array is rotated has basically no impact. I\\'m confused about the purpose of this problem."
                    },
                    {
                        "username": "sumitpratap28",
                        "content": "Here the main goal is to divide the array recursively in such a way that will get the target in sorted sub-part of array, and point to be note that at least one part should be sorted, after every division step of binary search\\nSteps that need to follow recursively to find the sorted subarray to search for an element\\n\\n1). If mid>=a[start], it means first part is sorted try to search in it, if target exist in this (first) half range, then end should be shifted to mid-1, otherwise start should point to mid+1 i.e. second half start.\\n2). If mid<a[start], it means second half will be sorted try to search in it, if target exist in this half range, then start should be shifted to mid+1, otherwise end should point to mid-1, i.e. first half end.\\n\\nPoints to be noted:\\n\\n* In every step we are discarding one half of remained subarray or original array, same like binary search that\\'s why here the complexity still remains O(logn).\\n* In between division of subparts one of two steps stated above will come, and that\\'s why recursion is there or these steps should be under while loop."
                    },
                    {
                        "username": "hrishavratan",
                        "content": "I am getting heap buffer overflow without using any dynamic allocation in heap in the code this \\nint search(vector<int>& nums, int target) \\n    {\\n        int start=0,end=nums.size()-1,mid,key;\\n        for(mid=start+(end-start)/2;start<=end;mid=start+(end-start)/2)\\n        {\\n            \\n            if(nums[mid]<=nums[mid+1])\\n            {\\n                end=mid-1;\\n            }\\n            else\\n            {\\n                key=mid+1;\\n                break;\\n            }\\n        }\\n        if(nums[nums.size()-1]<target)\\n        {\\n            start=0,end=key-1;\\n        }\\n        else\\n        {\\n            start=key,end=nums.size()-1;\\n        }\\n        for(mid=start+(end-start)/2;start<=end;mid=start+(end-start)/2)\\n        {\\n            if(nums[mid]>target)\\n            {\\n                end=mid-1;\\n            }\\n            else if(nums[mid]<target)\\n            {\\n                start=mid+1;\\n            }\\n            else\\n            {\\n                return mid;\\n            }\\n        }\\n        return -1;\\n    }"
                    },
                    {
                        "username": "bparanj",
                        "content": "The error is because you are trying to access the index \"mid+1\" of the vector \"nums\" without checking whether \"mid+1\" is a valid index for the vector. If \"mid\" is the last index of the vector, \"mid+1\" will be out-of-bound, and trying to access such an index will result in undefined behavior such as heap buffer overflow.\\n\\nThe problematic line is:\\n```cpp\\nif(nums[mid]<=nums[mid+1])\\n```\\nTo fix this, you need to ensure that \"mid+1\" does not exceed the size of the vector before accessing it. Here\\'s how you could do it:\\n```cpp\\nif(mid < nums.size()-1 && nums[mid] <= nums[mid+1])\\n```\\nPlease ensure to apply similar changes to any other parts of the code that may attempt to access out-of-bound indices. Always remember that when working with arrays or vectors, it\\'s crucial to ensure that you\\'re not accessing indices outside of their size. This is a common source of bugs and can lead to serious problems such as buffer overflows."
                    },
                    {
                        "username": "kartikg_09",
                        "content": "https://github.com/kartikgupta09/java-/commit/468b4b631ffd1e0af9934e8508c22d8e3c19b04b"
                    },
                    {
                        "username": "khushimattu",
                        "content": "we simply have to search for that element in the array?"
                    },
                    {
                        "username": "khushimattu",
                        "content": "[@mr_unfunny_](/mr_unfunny_) oohh, got it."
                    },
                    {
                        "username": "mrunfunny",
                        "content": "[@Khushi_Mattu](/Khushi_Mattu) It\\'s not also a simple binary search. Because the array is rotated, we need to handle some extra edge cases. Doing it with simple linear search makes it an easy question. This question has weak test cases that\\'s why it allows linear search. It should\\'ve thrown a TLE on linear search."
                    },
                    {
                        "username": "khushimattu",
                        "content": "[@mr_unfunny_](/mr_unfunny_) oh so basically just binary search right? It was a medium level question so I was just shocked that we were expected to just do a search. :)"
                    },
                    {
                        "username": "mrunfunny",
                        "content": "A simple linear search would be O(N) but this question is asking us to solve it in O(lgn)."
                    },
                    {
                        "username": "mohamed_waseela",
                        "content": "Best Explanation:\\nhttps://youtu.be/zx-c48gtCsc"
                    }
                ]
            },
            {
                "id": 1743280,
                "content": [
                    {
                        "username": "mahenderyadav9703488649",
                        "content": "int l=0,h=a.length-1,m=0;\\n\\t\\twhile(l<=h) {\\n\\t\\t\\tm=(l+h)/2;\\n\\t\\t\\tif(target==a[m]) {\\n\\t\\t\\t\\treturn m;\\n\\t\\t\\t}\\n\\t\\t\\t//left sorted portion\\n\\t\\t\\telse if(a[l]<=a[m]) {\\n\\t\\t\\t\\tif(target>=a[l]&&target<=a[m]) {\\n\\t\\t\\t\\t\\th=m-1;\\n\\t\\t\\t\\t}\\n\\t\\t\\t\\telse {\\n\\t\\t\\t\\t\\tl=m+1;\\n\\t\\t\\t\\t}\\n\\t\\t\\t}\\n\\t\\t\\t//right sorted portion\\n\\t\\t\\telse {\\n\\t\\t\\t\\tif(target>a[m]&&target<=a[h]) {\\n\\t\\t\\t\\t\\tl=m+1;\\n\\t\\t\\t\\t}\\n\\t\\t\\t\\telse {\\n\\t\\t\\t\\t\\th=m-1;\\n\\t\\t\\t\\t}\\n\\t\\t\\t}\\n\\t\\t}\\n\\t\\treturn -1;\\n\\t}\\n\\n\\tpublic static void main(String[] args) {\\n\\t}}\\n"
                    },
                    {
                        "username": "vk783838",
                        "content": "where is k in this question?"
                    },
                    {
                        "username": "mohamed_waseela",
                        "content": "https://youtu.be/-Qpk2XJ5XJQ"
                    },
                    {
                        "username": "deleted_user",
                        "content": "class Solution:\\n    def search(self, nums: List[int], target: int) -> int:\\n        for i in range(len(nums)):\\n            if nums[i] == target:\\n                return i\\n        return -1"
                    },
                    {
                        "username": "Kmello94",
                        "content": "The fact that the array is rotated has basically no impact. I\\'m confused about the purpose of this problem."
                    },
                    {
                        "username": "sumitpratap28",
                        "content": "Here the main goal is to divide the array recursively in such a way that will get the target in sorted sub-part of array, and point to be note that at least one part should be sorted, after every division step of binary search\\nSteps that need to follow recursively to find the sorted subarray to search for an element\\n\\n1). If mid>=a[start], it means first part is sorted try to search in it, if target exist in this (first) half range, then end should be shifted to mid-1, otherwise start should point to mid+1 i.e. second half start.\\n2). If mid<a[start], it means second half will be sorted try to search in it, if target exist in this half range, then start should be shifted to mid+1, otherwise end should point to mid-1, i.e. first half end.\\n\\nPoints to be noted:\\n\\n* In every step we are discarding one half of remained subarray or original array, same like binary search that\\'s why here the complexity still remains O(logn).\\n* In between division of subparts one of two steps stated above will come, and that\\'s why recursion is there or these steps should be under while loop."
                    },
                    {
                        "username": "hrishavratan",
                        "content": "I am getting heap buffer overflow without using any dynamic allocation in heap in the code this \\nint search(vector<int>& nums, int target) \\n    {\\n        int start=0,end=nums.size()-1,mid,key;\\n        for(mid=start+(end-start)/2;start<=end;mid=start+(end-start)/2)\\n        {\\n            \\n            if(nums[mid]<=nums[mid+1])\\n            {\\n                end=mid-1;\\n            }\\n            else\\n            {\\n                key=mid+1;\\n                break;\\n            }\\n        }\\n        if(nums[nums.size()-1]<target)\\n        {\\n            start=0,end=key-1;\\n        }\\n        else\\n        {\\n            start=key,end=nums.size()-1;\\n        }\\n        for(mid=start+(end-start)/2;start<=end;mid=start+(end-start)/2)\\n        {\\n            if(nums[mid]>target)\\n            {\\n                end=mid-1;\\n            }\\n            else if(nums[mid]<target)\\n            {\\n                start=mid+1;\\n            }\\n            else\\n            {\\n                return mid;\\n            }\\n        }\\n        return -1;\\n    }"
                    },
                    {
                        "username": "bparanj",
                        "content": "The error is because you are trying to access the index \"mid+1\" of the vector \"nums\" without checking whether \"mid+1\" is a valid index for the vector. If \"mid\" is the last index of the vector, \"mid+1\" will be out-of-bound, and trying to access such an index will result in undefined behavior such as heap buffer overflow.\\n\\nThe problematic line is:\\n```cpp\\nif(nums[mid]<=nums[mid+1])\\n```\\nTo fix this, you need to ensure that \"mid+1\" does not exceed the size of the vector before accessing it. Here\\'s how you could do it:\\n```cpp\\nif(mid < nums.size()-1 && nums[mid] <= nums[mid+1])\\n```\\nPlease ensure to apply similar changes to any other parts of the code that may attempt to access out-of-bound indices. Always remember that when working with arrays or vectors, it\\'s crucial to ensure that you\\'re not accessing indices outside of their size. This is a common source of bugs and can lead to serious problems such as buffer overflows."
                    },
                    {
                        "username": "kartikg_09",
                        "content": "https://github.com/kartikgupta09/java-/commit/468b4b631ffd1e0af9934e8508c22d8e3c19b04b"
                    },
                    {
                        "username": "khushimattu",
                        "content": "we simply have to search for that element in the array?"
                    },
                    {
                        "username": "khushimattu",
                        "content": "[@mr_unfunny_](/mr_unfunny_) oohh, got it."
                    },
                    {
                        "username": "mrunfunny",
                        "content": "[@Khushi_Mattu](/Khushi_Mattu) It\\'s not also a simple binary search. Because the array is rotated, we need to handle some extra edge cases. Doing it with simple linear search makes it an easy question. This question has weak test cases that\\'s why it allows linear search. It should\\'ve thrown a TLE on linear search."
                    },
                    {
                        "username": "khushimattu",
                        "content": "[@mr_unfunny_](/mr_unfunny_) oh so basically just binary search right? It was a medium level question so I was just shocked that we were expected to just do a search. :)"
                    },
                    {
                        "username": "mrunfunny",
                        "content": "A simple linear search would be O(N) but this question is asking us to solve it in O(lgn)."
                    },
                    {
                        "username": "mohamed_waseela",
                        "content": "Best Explanation:\\nhttps://youtu.be/zx-c48gtCsc"
                    }
                ]
            },
            {
                "id": 1740788,
                "content": [
                    {
                        "username": "mahenderyadav9703488649",
                        "content": "int l=0,h=a.length-1,m=0;\\n\\t\\twhile(l<=h) {\\n\\t\\t\\tm=(l+h)/2;\\n\\t\\t\\tif(target==a[m]) {\\n\\t\\t\\t\\treturn m;\\n\\t\\t\\t}\\n\\t\\t\\t//left sorted portion\\n\\t\\t\\telse if(a[l]<=a[m]) {\\n\\t\\t\\t\\tif(target>=a[l]&&target<=a[m]) {\\n\\t\\t\\t\\t\\th=m-1;\\n\\t\\t\\t\\t}\\n\\t\\t\\t\\telse {\\n\\t\\t\\t\\t\\tl=m+1;\\n\\t\\t\\t\\t}\\n\\t\\t\\t}\\n\\t\\t\\t//right sorted portion\\n\\t\\t\\telse {\\n\\t\\t\\t\\tif(target>a[m]&&target<=a[h]) {\\n\\t\\t\\t\\t\\tl=m+1;\\n\\t\\t\\t\\t}\\n\\t\\t\\t\\telse {\\n\\t\\t\\t\\t\\th=m-1;\\n\\t\\t\\t\\t}\\n\\t\\t\\t}\\n\\t\\t}\\n\\t\\treturn -1;\\n\\t}\\n\\n\\tpublic static void main(String[] args) {\\n\\t}}\\n"
                    },
                    {
                        "username": "vk783838",
                        "content": "where is k in this question?"
                    },
                    {
                        "username": "mohamed_waseela",
                        "content": "https://youtu.be/-Qpk2XJ5XJQ"
                    },
                    {
                        "username": "deleted_user",
                        "content": "class Solution:\\n    def search(self, nums: List[int], target: int) -> int:\\n        for i in range(len(nums)):\\n            if nums[i] == target:\\n                return i\\n        return -1"
                    },
                    {
                        "username": "Kmello94",
                        "content": "The fact that the array is rotated has basically no impact. I\\'m confused about the purpose of this problem."
                    },
                    {
                        "username": "sumitpratap28",
                        "content": "Here the main goal is to divide the array recursively in such a way that will get the target in sorted sub-part of array, and point to be note that at least one part should be sorted, after every division step of binary search\\nSteps that need to follow recursively to find the sorted subarray to search for an element\\n\\n1). If mid>=a[start], it means first part is sorted try to search in it, if target exist in this (first) half range, then end should be shifted to mid-1, otherwise start should point to mid+1 i.e. second half start.\\n2). If mid<a[start], it means second half will be sorted try to search in it, if target exist in this half range, then start should be shifted to mid+1, otherwise end should point to mid-1, i.e. first half end.\\n\\nPoints to be noted:\\n\\n* In every step we are discarding one half of remained subarray or original array, same like binary search that\\'s why here the complexity still remains O(logn).\\n* In between division of subparts one of two steps stated above will come, and that\\'s why recursion is there or these steps should be under while loop."
                    },
                    {
                        "username": "hrishavratan",
                        "content": "I am getting heap buffer overflow without using any dynamic allocation in heap in the code this \\nint search(vector<int>& nums, int target) \\n    {\\n        int start=0,end=nums.size()-1,mid,key;\\n        for(mid=start+(end-start)/2;start<=end;mid=start+(end-start)/2)\\n        {\\n            \\n            if(nums[mid]<=nums[mid+1])\\n            {\\n                end=mid-1;\\n            }\\n            else\\n            {\\n                key=mid+1;\\n                break;\\n            }\\n        }\\n        if(nums[nums.size()-1]<target)\\n        {\\n            start=0,end=key-1;\\n        }\\n        else\\n        {\\n            start=key,end=nums.size()-1;\\n        }\\n        for(mid=start+(end-start)/2;start<=end;mid=start+(end-start)/2)\\n        {\\n            if(nums[mid]>target)\\n            {\\n                end=mid-1;\\n            }\\n            else if(nums[mid]<target)\\n            {\\n                start=mid+1;\\n            }\\n            else\\n            {\\n                return mid;\\n            }\\n        }\\n        return -1;\\n    }"
                    },
                    {
                        "username": "bparanj",
                        "content": "The error is because you are trying to access the index \"mid+1\" of the vector \"nums\" without checking whether \"mid+1\" is a valid index for the vector. If \"mid\" is the last index of the vector, \"mid+1\" will be out-of-bound, and trying to access such an index will result in undefined behavior such as heap buffer overflow.\\n\\nThe problematic line is:\\n```cpp\\nif(nums[mid]<=nums[mid+1])\\n```\\nTo fix this, you need to ensure that \"mid+1\" does not exceed the size of the vector before accessing it. Here\\'s how you could do it:\\n```cpp\\nif(mid < nums.size()-1 && nums[mid] <= nums[mid+1])\\n```\\nPlease ensure to apply similar changes to any other parts of the code that may attempt to access out-of-bound indices. Always remember that when working with arrays or vectors, it\\'s crucial to ensure that you\\'re not accessing indices outside of their size. This is a common source of bugs and can lead to serious problems such as buffer overflows."
                    },
                    {
                        "username": "kartikg_09",
                        "content": "https://github.com/kartikgupta09/java-/commit/468b4b631ffd1e0af9934e8508c22d8e3c19b04b"
                    },
                    {
                        "username": "khushimattu",
                        "content": "we simply have to search for that element in the array?"
                    },
                    {
                        "username": "khushimattu",
                        "content": "[@mr_unfunny_](/mr_unfunny_) oohh, got it."
                    },
                    {
                        "username": "mrunfunny",
                        "content": "[@Khushi_Mattu](/Khushi_Mattu) It\\'s not also a simple binary search. Because the array is rotated, we need to handle some extra edge cases. Doing it with simple linear search makes it an easy question. This question has weak test cases that\\'s why it allows linear search. It should\\'ve thrown a TLE on linear search."
                    },
                    {
                        "username": "khushimattu",
                        "content": "[@mr_unfunny_](/mr_unfunny_) oh so basically just binary search right? It was a medium level question so I was just shocked that we were expected to just do a search. :)"
                    },
                    {
                        "username": "mrunfunny",
                        "content": "A simple linear search would be O(N) but this question is asking us to solve it in O(lgn)."
                    },
                    {
                        "username": "mohamed_waseela",
                        "content": "Best Explanation:\\nhttps://youtu.be/zx-c48gtCsc"
                    }
                ]
            },
            {
                "id": 1737980,
                "content": [
                    {
                        "username": "mahenderyadav9703488649",
                        "content": "int l=0,h=a.length-1,m=0;\\n\\t\\twhile(l<=h) {\\n\\t\\t\\tm=(l+h)/2;\\n\\t\\t\\tif(target==a[m]) {\\n\\t\\t\\t\\treturn m;\\n\\t\\t\\t}\\n\\t\\t\\t//left sorted portion\\n\\t\\t\\telse if(a[l]<=a[m]) {\\n\\t\\t\\t\\tif(target>=a[l]&&target<=a[m]) {\\n\\t\\t\\t\\t\\th=m-1;\\n\\t\\t\\t\\t}\\n\\t\\t\\t\\telse {\\n\\t\\t\\t\\t\\tl=m+1;\\n\\t\\t\\t\\t}\\n\\t\\t\\t}\\n\\t\\t\\t//right sorted portion\\n\\t\\t\\telse {\\n\\t\\t\\t\\tif(target>a[m]&&target<=a[h]) {\\n\\t\\t\\t\\t\\tl=m+1;\\n\\t\\t\\t\\t}\\n\\t\\t\\t\\telse {\\n\\t\\t\\t\\t\\th=m-1;\\n\\t\\t\\t\\t}\\n\\t\\t\\t}\\n\\t\\t}\\n\\t\\treturn -1;\\n\\t}\\n\\n\\tpublic static void main(String[] args) {\\n\\t}}\\n"
                    },
                    {
                        "username": "vk783838",
                        "content": "where is k in this question?"
                    },
                    {
                        "username": "mohamed_waseela",
                        "content": "https://youtu.be/-Qpk2XJ5XJQ"
                    },
                    {
                        "username": "deleted_user",
                        "content": "class Solution:\\n    def search(self, nums: List[int], target: int) -> int:\\n        for i in range(len(nums)):\\n            if nums[i] == target:\\n                return i\\n        return -1"
                    },
                    {
                        "username": "Kmello94",
                        "content": "The fact that the array is rotated has basically no impact. I\\'m confused about the purpose of this problem."
                    },
                    {
                        "username": "sumitpratap28",
                        "content": "Here the main goal is to divide the array recursively in such a way that will get the target in sorted sub-part of array, and point to be note that at least one part should be sorted, after every division step of binary search\\nSteps that need to follow recursively to find the sorted subarray to search for an element\\n\\n1). If mid>=a[start], it means first part is sorted try to search in it, if target exist in this (first) half range, then end should be shifted to mid-1, otherwise start should point to mid+1 i.e. second half start.\\n2). If mid<a[start], it means second half will be sorted try to search in it, if target exist in this half range, then start should be shifted to mid+1, otherwise end should point to mid-1, i.e. first half end.\\n\\nPoints to be noted:\\n\\n* In every step we are discarding one half of remained subarray or original array, same like binary search that\\'s why here the complexity still remains O(logn).\\n* In between division of subparts one of two steps stated above will come, and that\\'s why recursion is there or these steps should be under while loop."
                    },
                    {
                        "username": "hrishavratan",
                        "content": "I am getting heap buffer overflow without using any dynamic allocation in heap in the code this \\nint search(vector<int>& nums, int target) \\n    {\\n        int start=0,end=nums.size()-1,mid,key;\\n        for(mid=start+(end-start)/2;start<=end;mid=start+(end-start)/2)\\n        {\\n            \\n            if(nums[mid]<=nums[mid+1])\\n            {\\n                end=mid-1;\\n            }\\n            else\\n            {\\n                key=mid+1;\\n                break;\\n            }\\n        }\\n        if(nums[nums.size()-1]<target)\\n        {\\n            start=0,end=key-1;\\n        }\\n        else\\n        {\\n            start=key,end=nums.size()-1;\\n        }\\n        for(mid=start+(end-start)/2;start<=end;mid=start+(end-start)/2)\\n        {\\n            if(nums[mid]>target)\\n            {\\n                end=mid-1;\\n            }\\n            else if(nums[mid]<target)\\n            {\\n                start=mid+1;\\n            }\\n            else\\n            {\\n                return mid;\\n            }\\n        }\\n        return -1;\\n    }"
                    },
                    {
                        "username": "bparanj",
                        "content": "The error is because you are trying to access the index \"mid+1\" of the vector \"nums\" without checking whether \"mid+1\" is a valid index for the vector. If \"mid\" is the last index of the vector, \"mid+1\" will be out-of-bound, and trying to access such an index will result in undefined behavior such as heap buffer overflow.\\n\\nThe problematic line is:\\n```cpp\\nif(nums[mid]<=nums[mid+1])\\n```\\nTo fix this, you need to ensure that \"mid+1\" does not exceed the size of the vector before accessing it. Here\\'s how you could do it:\\n```cpp\\nif(mid < nums.size()-1 && nums[mid] <= nums[mid+1])\\n```\\nPlease ensure to apply similar changes to any other parts of the code that may attempt to access out-of-bound indices. Always remember that when working with arrays or vectors, it\\'s crucial to ensure that you\\'re not accessing indices outside of their size. This is a common source of bugs and can lead to serious problems such as buffer overflows."
                    },
                    {
                        "username": "kartikg_09",
                        "content": "https://github.com/kartikgupta09/java-/commit/468b4b631ffd1e0af9934e8508c22d8e3c19b04b"
                    },
                    {
                        "username": "khushimattu",
                        "content": "we simply have to search for that element in the array?"
                    },
                    {
                        "username": "khushimattu",
                        "content": "[@mr_unfunny_](/mr_unfunny_) oohh, got it."
                    },
                    {
                        "username": "mrunfunny",
                        "content": "[@Khushi_Mattu](/Khushi_Mattu) It\\'s not also a simple binary search. Because the array is rotated, we need to handle some extra edge cases. Doing it with simple linear search makes it an easy question. This question has weak test cases that\\'s why it allows linear search. It should\\'ve thrown a TLE on linear search."
                    },
                    {
                        "username": "khushimattu",
                        "content": "[@mr_unfunny_](/mr_unfunny_) oh so basically just binary search right? It was a medium level question so I was just shocked that we were expected to just do a search. :)"
                    },
                    {
                        "username": "mrunfunny",
                        "content": "A simple linear search would be O(N) but this question is asking us to solve it in O(lgn)."
                    },
                    {
                        "username": "mohamed_waseela",
                        "content": "Best Explanation:\\nhttps://youtu.be/zx-c48gtCsc"
                    }
                ]
            },
            {
                "id": 1736924,
                "content": [
                    {
                        "username": "mahenderyadav9703488649",
                        "content": "int l=0,h=a.length-1,m=0;\\n\\t\\twhile(l<=h) {\\n\\t\\t\\tm=(l+h)/2;\\n\\t\\t\\tif(target==a[m]) {\\n\\t\\t\\t\\treturn m;\\n\\t\\t\\t}\\n\\t\\t\\t//left sorted portion\\n\\t\\t\\telse if(a[l]<=a[m]) {\\n\\t\\t\\t\\tif(target>=a[l]&&target<=a[m]) {\\n\\t\\t\\t\\t\\th=m-1;\\n\\t\\t\\t\\t}\\n\\t\\t\\t\\telse {\\n\\t\\t\\t\\t\\tl=m+1;\\n\\t\\t\\t\\t}\\n\\t\\t\\t}\\n\\t\\t\\t//right sorted portion\\n\\t\\t\\telse {\\n\\t\\t\\t\\tif(target>a[m]&&target<=a[h]) {\\n\\t\\t\\t\\t\\tl=m+1;\\n\\t\\t\\t\\t}\\n\\t\\t\\t\\telse {\\n\\t\\t\\t\\t\\th=m-1;\\n\\t\\t\\t\\t}\\n\\t\\t\\t}\\n\\t\\t}\\n\\t\\treturn -1;\\n\\t}\\n\\n\\tpublic static void main(String[] args) {\\n\\t}}\\n"
                    },
                    {
                        "username": "vk783838",
                        "content": "where is k in this question?"
                    },
                    {
                        "username": "mohamed_waseela",
                        "content": "https://youtu.be/-Qpk2XJ5XJQ"
                    },
                    {
                        "username": "deleted_user",
                        "content": "class Solution:\\n    def search(self, nums: List[int], target: int) -> int:\\n        for i in range(len(nums)):\\n            if nums[i] == target:\\n                return i\\n        return -1"
                    },
                    {
                        "username": "Kmello94",
                        "content": "The fact that the array is rotated has basically no impact. I\\'m confused about the purpose of this problem."
                    },
                    {
                        "username": "sumitpratap28",
                        "content": "Here the main goal is to divide the array recursively in such a way that will get the target in sorted sub-part of array, and point to be note that at least one part should be sorted, after every division step of binary search\\nSteps that need to follow recursively to find the sorted subarray to search for an element\\n\\n1). If mid>=a[start], it means first part is sorted try to search in it, if target exist in this (first) half range, then end should be shifted to mid-1, otherwise start should point to mid+1 i.e. second half start.\\n2). If mid<a[start], it means second half will be sorted try to search in it, if target exist in this half range, then start should be shifted to mid+1, otherwise end should point to mid-1, i.e. first half end.\\n\\nPoints to be noted:\\n\\n* In every step we are discarding one half of remained subarray or original array, same like binary search that\\'s why here the complexity still remains O(logn).\\n* In between division of subparts one of two steps stated above will come, and that\\'s why recursion is there or these steps should be under while loop."
                    },
                    {
                        "username": "hrishavratan",
                        "content": "I am getting heap buffer overflow without using any dynamic allocation in heap in the code this \\nint search(vector<int>& nums, int target) \\n    {\\n        int start=0,end=nums.size()-1,mid,key;\\n        for(mid=start+(end-start)/2;start<=end;mid=start+(end-start)/2)\\n        {\\n            \\n            if(nums[mid]<=nums[mid+1])\\n            {\\n                end=mid-1;\\n            }\\n            else\\n            {\\n                key=mid+1;\\n                break;\\n            }\\n        }\\n        if(nums[nums.size()-1]<target)\\n        {\\n            start=0,end=key-1;\\n        }\\n        else\\n        {\\n            start=key,end=nums.size()-1;\\n        }\\n        for(mid=start+(end-start)/2;start<=end;mid=start+(end-start)/2)\\n        {\\n            if(nums[mid]>target)\\n            {\\n                end=mid-1;\\n            }\\n            else if(nums[mid]<target)\\n            {\\n                start=mid+1;\\n            }\\n            else\\n            {\\n                return mid;\\n            }\\n        }\\n        return -1;\\n    }"
                    },
                    {
                        "username": "bparanj",
                        "content": "The error is because you are trying to access the index \"mid+1\" of the vector \"nums\" without checking whether \"mid+1\" is a valid index for the vector. If \"mid\" is the last index of the vector, \"mid+1\" will be out-of-bound, and trying to access such an index will result in undefined behavior such as heap buffer overflow.\\n\\nThe problematic line is:\\n```cpp\\nif(nums[mid]<=nums[mid+1])\\n```\\nTo fix this, you need to ensure that \"mid+1\" does not exceed the size of the vector before accessing it. Here\\'s how you could do it:\\n```cpp\\nif(mid < nums.size()-1 && nums[mid] <= nums[mid+1])\\n```\\nPlease ensure to apply similar changes to any other parts of the code that may attempt to access out-of-bound indices. Always remember that when working with arrays or vectors, it\\'s crucial to ensure that you\\'re not accessing indices outside of their size. This is a common source of bugs and can lead to serious problems such as buffer overflows."
                    },
                    {
                        "username": "kartikg_09",
                        "content": "https://github.com/kartikgupta09/java-/commit/468b4b631ffd1e0af9934e8508c22d8e3c19b04b"
                    },
                    {
                        "username": "khushimattu",
                        "content": "we simply have to search for that element in the array?"
                    },
                    {
                        "username": "khushimattu",
                        "content": "[@mr_unfunny_](/mr_unfunny_) oohh, got it."
                    },
                    {
                        "username": "mrunfunny",
                        "content": "[@Khushi_Mattu](/Khushi_Mattu) It\\'s not also a simple binary search. Because the array is rotated, we need to handle some extra edge cases. Doing it with simple linear search makes it an easy question. This question has weak test cases that\\'s why it allows linear search. It should\\'ve thrown a TLE on linear search."
                    },
                    {
                        "username": "khushimattu",
                        "content": "[@mr_unfunny_](/mr_unfunny_) oh so basically just binary search right? It was a medium level question so I was just shocked that we were expected to just do a search. :)"
                    },
                    {
                        "username": "mrunfunny",
                        "content": "A simple linear search would be O(N) but this question is asking us to solve it in O(lgn)."
                    },
                    {
                        "username": "mohamed_waseela",
                        "content": "Best Explanation:\\nhttps://youtu.be/zx-c48gtCsc"
                    }
                ]
            },
            {
                "id": 1733534,
                "content": [
                    {
                        "username": "mahenderyadav9703488649",
                        "content": "int l=0,h=a.length-1,m=0;\\n\\t\\twhile(l<=h) {\\n\\t\\t\\tm=(l+h)/2;\\n\\t\\t\\tif(target==a[m]) {\\n\\t\\t\\t\\treturn m;\\n\\t\\t\\t}\\n\\t\\t\\t//left sorted portion\\n\\t\\t\\telse if(a[l]<=a[m]) {\\n\\t\\t\\t\\tif(target>=a[l]&&target<=a[m]) {\\n\\t\\t\\t\\t\\th=m-1;\\n\\t\\t\\t\\t}\\n\\t\\t\\t\\telse {\\n\\t\\t\\t\\t\\tl=m+1;\\n\\t\\t\\t\\t}\\n\\t\\t\\t}\\n\\t\\t\\t//right sorted portion\\n\\t\\t\\telse {\\n\\t\\t\\t\\tif(target>a[m]&&target<=a[h]) {\\n\\t\\t\\t\\t\\tl=m+1;\\n\\t\\t\\t\\t}\\n\\t\\t\\t\\telse {\\n\\t\\t\\t\\t\\th=m-1;\\n\\t\\t\\t\\t}\\n\\t\\t\\t}\\n\\t\\t}\\n\\t\\treturn -1;\\n\\t}\\n\\n\\tpublic static void main(String[] args) {\\n\\t}}\\n"
                    },
                    {
                        "username": "vk783838",
                        "content": "where is k in this question?"
                    },
                    {
                        "username": "mohamed_waseela",
                        "content": "https://youtu.be/-Qpk2XJ5XJQ"
                    },
                    {
                        "username": "deleted_user",
                        "content": "class Solution:\\n    def search(self, nums: List[int], target: int) -> int:\\n        for i in range(len(nums)):\\n            if nums[i] == target:\\n                return i\\n        return -1"
                    },
                    {
                        "username": "Kmello94",
                        "content": "The fact that the array is rotated has basically no impact. I\\'m confused about the purpose of this problem."
                    },
                    {
                        "username": "sumitpratap28",
                        "content": "Here the main goal is to divide the array recursively in such a way that will get the target in sorted sub-part of array, and point to be note that at least one part should be sorted, after every division step of binary search\\nSteps that need to follow recursively to find the sorted subarray to search for an element\\n\\n1). If mid>=a[start], it means first part is sorted try to search in it, if target exist in this (first) half range, then end should be shifted to mid-1, otherwise start should point to mid+1 i.e. second half start.\\n2). If mid<a[start], it means second half will be sorted try to search in it, if target exist in this half range, then start should be shifted to mid+1, otherwise end should point to mid-1, i.e. first half end.\\n\\nPoints to be noted:\\n\\n* In every step we are discarding one half of remained subarray or original array, same like binary search that\\'s why here the complexity still remains O(logn).\\n* In between division of subparts one of two steps stated above will come, and that\\'s why recursion is there or these steps should be under while loop."
                    },
                    {
                        "username": "hrishavratan",
                        "content": "I am getting heap buffer overflow without using any dynamic allocation in heap in the code this \\nint search(vector<int>& nums, int target) \\n    {\\n        int start=0,end=nums.size()-1,mid,key;\\n        for(mid=start+(end-start)/2;start<=end;mid=start+(end-start)/2)\\n        {\\n            \\n            if(nums[mid]<=nums[mid+1])\\n            {\\n                end=mid-1;\\n            }\\n            else\\n            {\\n                key=mid+1;\\n                break;\\n            }\\n        }\\n        if(nums[nums.size()-1]<target)\\n        {\\n            start=0,end=key-1;\\n        }\\n        else\\n        {\\n            start=key,end=nums.size()-1;\\n        }\\n        for(mid=start+(end-start)/2;start<=end;mid=start+(end-start)/2)\\n        {\\n            if(nums[mid]>target)\\n            {\\n                end=mid-1;\\n            }\\n            else if(nums[mid]<target)\\n            {\\n                start=mid+1;\\n            }\\n            else\\n            {\\n                return mid;\\n            }\\n        }\\n        return -1;\\n    }"
                    },
                    {
                        "username": "bparanj",
                        "content": "The error is because you are trying to access the index \"mid+1\" of the vector \"nums\" without checking whether \"mid+1\" is a valid index for the vector. If \"mid\" is the last index of the vector, \"mid+1\" will be out-of-bound, and trying to access such an index will result in undefined behavior such as heap buffer overflow.\\n\\nThe problematic line is:\\n```cpp\\nif(nums[mid]<=nums[mid+1])\\n```\\nTo fix this, you need to ensure that \"mid+1\" does not exceed the size of the vector before accessing it. Here\\'s how you could do it:\\n```cpp\\nif(mid < nums.size()-1 && nums[mid] <= nums[mid+1])\\n```\\nPlease ensure to apply similar changes to any other parts of the code that may attempt to access out-of-bound indices. Always remember that when working with arrays or vectors, it\\'s crucial to ensure that you\\'re not accessing indices outside of their size. This is a common source of bugs and can lead to serious problems such as buffer overflows."
                    },
                    {
                        "username": "kartikg_09",
                        "content": "https://github.com/kartikgupta09/java-/commit/468b4b631ffd1e0af9934e8508c22d8e3c19b04b"
                    },
                    {
                        "username": "khushimattu",
                        "content": "we simply have to search for that element in the array?"
                    },
                    {
                        "username": "khushimattu",
                        "content": "[@mr_unfunny_](/mr_unfunny_) oohh, got it."
                    },
                    {
                        "username": "mrunfunny",
                        "content": "[@Khushi_Mattu](/Khushi_Mattu) It\\'s not also a simple binary search. Because the array is rotated, we need to handle some extra edge cases. Doing it with simple linear search makes it an easy question. This question has weak test cases that\\'s why it allows linear search. It should\\'ve thrown a TLE on linear search."
                    },
                    {
                        "username": "khushimattu",
                        "content": "[@mr_unfunny_](/mr_unfunny_) oh so basically just binary search right? It was a medium level question so I was just shocked that we were expected to just do a search. :)"
                    },
                    {
                        "username": "mrunfunny",
                        "content": "A simple linear search would be O(N) but this question is asking us to solve it in O(lgn)."
                    },
                    {
                        "username": "mohamed_waseela",
                        "content": "Best Explanation:\\nhttps://youtu.be/zx-c48gtCsc"
                    }
                ]
            },
            {
                "id": 1732369,
                "content": [
                    {
                        "username": "Srivamsi_Dandu",
                        "content": "class Solution {\\n    public static int search(int[] nums, int target){\\n        int pivot = findpiv(nums);\\n        System.out.println(\"pivot is\"+pivot);\\n        if(pivot==-1){\\n            return regularbin(nums,target,0,nums.length-1);\\n        }\\n        if(nums[pivot]==target){\\n            return pivot;\\n        }\\n        if(target>=nums[0]){\\n            return regularbin(nums,target,0,pivot-1);\\n        }\\n        return regularbin(nums,target,pivot+1,nums.length-1);\\n    }\\n    public static int regularbin(int[] nums,int target,int start,int end){\\n            int mid = 0;\\n            while (start<=end){\\n                mid = start+(end-start)/2;\\n                if(target>nums[mid]){\\n                    start=mid+1;\\n                }\\n                else if(target<nums[mid]){\\n                    end = mid-1;\\n                }\\n                else{\\n                    return mid;\\n                }\\n            }\\n            return -1;\\n    }\\n    public static int findpiv(int[] nums){\\n        int start  = 0;\\n        int end = nums.length-1;\\n        int mid =0;\\n        while (start<=end){\\n            mid = start+(end-start)/2;\\n            if(mid<end && nums[mid]>nums[mid+1]){\\n                return mid;\\n            }\\n            if(start<mid && nums[mid-1]>nums[mid]){\\n                return mid-1;\\n            }\\n            if(nums[start]>nums[mid]){\\n                end  = mid-1;\\n            }\\n            else {\\n                start = mid+1;\\n            }\\n        }\\n        return -1;\\n    }\\n}\\n\\nof any comments please comment down\\n"
                    },
                    {
                        "username": "Dastagir_Mulani_101",
                        "content": "Even solution with linear search i.e. O(n) is getting accepted, this should not happen isn\\'t it?? The problem makers should change the problem solution so it can accept only solution with O(log n) complexity otherwise should give TLE."
                    },
                    {
                        "username": "hb_134",
                        "content": "Why we do not use this ->  `sort(nums.begin(), nums.end());`\\nI know then the time complexity will increase but just ignore that part why we do not use this??\\n\\nPlease discuss with me in this part :)"
                    },
                    {
                        "username": "psionl0",
                        "content": "You are required to return the position of target. Sorting an array will change the position of its elements. You can do this but you will need to keep track of the original positions of the elements which will complicate the exercise."
                    },
                    {
                        "username": "bparanj",
                        "content": "Sorting an array is often a useful operation when you want to organize the data in a certain order, typically either ascending or descending. However, there are several reasons why you might not want to sort the array in the context of a particular problem.\\n\\n1. Preserving original order: Many problems require you to preserve the original order of elements in the array. Sorting the array would destroy this original order.\\n\\n2. Time complexity: As you mentioned, sorting an array has a time complexity of at least O(n log n) for most standard sorting algorithms. This could make your solution too slow if the input array is large.\\n\\n3. Space complexity: Sorting algorithms often require additional space. For example, the commonly used quicksort and mergesort algorithms are not in-place and need O(n) extra space.\\n\\n4. Problem Constraints: Sometimes, the problem statement specifically asks you not to sort the array or assumes that you\\'re working with an unsorted array.\\n\\n5. Changing the nature of the problem: Sometimes sorting an array could fundamentally change the nature of the problem you\\'re trying to solve.\\n\\nIn the context of the problem of searching in a rotated sorted array, sorting the array first would defeat the purpose of the problem. The challenge is to leverage the fact that the array is rotated and sorted to achieve a faster search time, ideally O(log n) which is possible with binary search. If you sort the array first, you would destroy the rotation and any information it might provide. Furthermore, you would still have to search through the sorted array, which would take O(log n) time with binary search, and when combined with the sorting step, would increase the overall time complexity of the solution."
                    },
                    {
                        "username": "iamvasusingh_",
                        "content": "why is my solution not working for [3,1] nums vector ?\n int search(vector<int>& nums, int target) {\n        int start=0;\n        int end=nums.size()-1;\n         while(start <= end)\n         {\n             int mid=(start + end)/2;\n            if(target == nums[mid])\n            {\n                return mid;\n            }\n            if(nums[start] < nums[mid])\n            {\n              if(target >= nums[start] && target<nums[mid])\n              {\n                  end=mid-1;\n              }\n              else\n             {\n               start=mid+1;\n             }\n            }\n            else\n            {\n                if(target > nums[mid] && target <= nums[end])\n                {\n                    start=mid+1;\n                }\n                else\n                {\n                    end=mid-1;\n                }\n            }\n         }\n         return -1;\n    }"
                    },
                    {
                        "username": "bparanj",
                        "content": "The code you provided is designed to handle a rotated sorted array. In the array [3, 1], the pivot point is at index 0, thus making the condition `nums[start] < nums[mid]` fail when `start` and `mid` are both 0.\\n\\nThis occurs because the array is only of length 2, and the element at the `start` and `mid` index is larger than the element at the `end` index. Your code, however, expects that for the first part of the array (`nums[start]` to `nums[mid]`), it will be in sorted order. But due to the pivot at index 0, this is not the case.\\n\\nTo fix this, you can include a check for when `start` and `mid` are equal:\\n\\n```cpp\\nint search(vector<int>& nums, int target) {\\n    int start=0;\\n    int end=nums.size()-1;\\n    while(start <= end)\\n    {\\n        int mid=(start + end)/2;\\n        if(target == nums[mid])\\n        {\\n            return mid;\\n        }\\n        if(nums[start] <= nums[mid]) // change < to <=\\n        {\\n            if(target >= nums[start] && target<nums[mid])\\n            {\\n                end=mid-1;\\n            }\\n            else\\n            {\\n                start=mid+1;\\n            }\\n        }\\n        else\\n        {\\n            if(target > nums[mid] && target <= nums[end])\\n            {\\n                start=mid+1;\\n            }\\n            else\\n            {\\n                end=mid-1;\\n            }\\n        }\\n    }\\n    return -1;\\n}\\n```\\nThis modification handles the case where the pivot is at the start index. Now, if `start` equals `mid` and `nums[start]` is not less than `nums[mid]`, it will still check if the target is within the first half of the array. This is suitable for arrays like [3,1] where the pivot is at the start of the array."
                    },
                    {
                        "username": "peaceTea",
                        "content": "I hate this question!!\\ngetting index out of bound error for some reason for finding the rotate index. absolutely crap"
                    },
                    {
                        "username": "nadeemmi313",
                        "content": "I apply linear search on this problem but it's not showing me Time Limit Exceed error. how it is possible . all test cases are successfully executed. "
                    },
                    {
                        "username": "AnkushR10",
                        "content": "https://github.com/AnkushRawat10601/Leetcode/blob/main/33_search_in_rotated_sorted_array.cpp"
                    },
                    {
                        "username": "alex_lanes",
                        "content": "Is this considered a O(log n) solutuion or a O(n/2) ? \\n\\n```/**\\n * @param  {number[]} nums\\n * @param  {number} target\\n * @return {number}\\n */\\nvar search = function( nums, target ){\\n    let first = 0,\\n        middle = Math.floor( nums.length / 2 ),\\n        last = nums.length - 1,\\n        indexOfTarget = ( start, end ) => {\\n            for( let index = start; index <= end; index++ ) if( nums[index] == target ) return index\\n            return -1\\n        },\\n        // [7,8,1,2,3,4,5,6] => right[ 3, 4, 5, 6 ] => [4, 7]\\n        sorted_indexes = ( nums[first] < nums[middle] ) ? [first, middle] : [middle + 1, last],\\n        // left[ 7, 8, 1, 2 ] => [0, 3]\\n        unsorted_indexes = sorted_indexes[0] != first && sorted_indexes[0] != middle ? [first, middle] : [middle + 1, last]\\n        // target = 2 in right[ 3, 4, 5, 6 ] ? false\\n        inSortedSide = nums[ sorted_indexes[0] ] <= target && target <= nums[ sorted_indexes[1] ]\\n\\n    if( nums[first] == target )         return first\\n    else if( nums[middle] == target )   return middle\\n    else if( nums[last] == target )     return last\\n    else if( inSortedSide )             return indexOfTarget( sorted_indexes[0], sorted_indexes[1] )\\n    else /* !inSortedSide */            return indexOfTarget( unsorted_indexes[0], unsorted_indexes[1] )\\n};"
                    },
                    {
                        "username": "bparanj",
                        "content": "This solution is neither O(log n) nor O(n/2). This solution is O(n) in the worst case scenario.\\n\\nThe reason for this is due to the `indexOfTarget` function. In the worst-case scenario, this function will iterate through roughly half of the elements in the array, which gives a time complexity of O(n).\\n\\nFor example, consider a case where the target value is at the end of the unsorted half of the array. The `indexOfTarget` function will need to iterate over all elements in the unsorted half, which can be up to n/2 elements. Because we drop constants in Big O notation, the time complexity of this function is O(n), not O(n/2).\\n\\nRemember, O(log n) complexity typically implies that you\\'re dividing the problem in half (or any constant fraction) with each step, such as in a binary search. O(n) complexity implies that you have to potentially check every element, which is what the `indexOfTarget` function is doing. Despite the initial checks and divisions of the array, the linear search performed by `indexOfTarget` dominates the time complexity of your solution. \\n\\nTo achieve O(log n) complexity for this problem, you would typically perform a modified binary search, adjusting the high and low points of your search based on the target and the median value, without scanning the array linearly."
                    },
                    {
                        "username": "tanmoy069",
                        "content": "why passed all the testcases with O(n) solution?"
                    },
                    {
                        "username": "Sri_Ram_194",
                        "content": "I think it is the best one in which just checking the each element in the array in which by taking the rotating the index, if nums[i]==given target then,,,\\nfor(int i=0;i<nums.length;i++)\\n        {\\n            if(nums[i]==target)\\n            {\\n                return i;\\n            }\\n        }\\n        return -1;"
                    }
                ]
            },
            {
                "id": 1730700,
                "content": [
                    {
                        "username": "Srivamsi_Dandu",
                        "content": "class Solution {\\n    public static int search(int[] nums, int target){\\n        int pivot = findpiv(nums);\\n        System.out.println(\"pivot is\"+pivot);\\n        if(pivot==-1){\\n            return regularbin(nums,target,0,nums.length-1);\\n        }\\n        if(nums[pivot]==target){\\n            return pivot;\\n        }\\n        if(target>=nums[0]){\\n            return regularbin(nums,target,0,pivot-1);\\n        }\\n        return regularbin(nums,target,pivot+1,nums.length-1);\\n    }\\n    public static int regularbin(int[] nums,int target,int start,int end){\\n            int mid = 0;\\n            while (start<=end){\\n                mid = start+(end-start)/2;\\n                if(target>nums[mid]){\\n                    start=mid+1;\\n                }\\n                else if(target<nums[mid]){\\n                    end = mid-1;\\n                }\\n                else{\\n                    return mid;\\n                }\\n            }\\n            return -1;\\n    }\\n    public static int findpiv(int[] nums){\\n        int start  = 0;\\n        int end = nums.length-1;\\n        int mid =0;\\n        while (start<=end){\\n            mid = start+(end-start)/2;\\n            if(mid<end && nums[mid]>nums[mid+1]){\\n                return mid;\\n            }\\n            if(start<mid && nums[mid-1]>nums[mid]){\\n                return mid-1;\\n            }\\n            if(nums[start]>nums[mid]){\\n                end  = mid-1;\\n            }\\n            else {\\n                start = mid+1;\\n            }\\n        }\\n        return -1;\\n    }\\n}\\n\\nof any comments please comment down\\n"
                    },
                    {
                        "username": "Dastagir_Mulani_101",
                        "content": "Even solution with linear search i.e. O(n) is getting accepted, this should not happen isn\\'t it?? The problem makers should change the problem solution so it can accept only solution with O(log n) complexity otherwise should give TLE."
                    },
                    {
                        "username": "hb_134",
                        "content": "Why we do not use this ->  `sort(nums.begin(), nums.end());`\\nI know then the time complexity will increase but just ignore that part why we do not use this??\\n\\nPlease discuss with me in this part :)"
                    },
                    {
                        "username": "psionl0",
                        "content": "You are required to return the position of target. Sorting an array will change the position of its elements. You can do this but you will need to keep track of the original positions of the elements which will complicate the exercise."
                    },
                    {
                        "username": "bparanj",
                        "content": "Sorting an array is often a useful operation when you want to organize the data in a certain order, typically either ascending or descending. However, there are several reasons why you might not want to sort the array in the context of a particular problem.\\n\\n1. Preserving original order: Many problems require you to preserve the original order of elements in the array. Sorting the array would destroy this original order.\\n\\n2. Time complexity: As you mentioned, sorting an array has a time complexity of at least O(n log n) for most standard sorting algorithms. This could make your solution too slow if the input array is large.\\n\\n3. Space complexity: Sorting algorithms often require additional space. For example, the commonly used quicksort and mergesort algorithms are not in-place and need O(n) extra space.\\n\\n4. Problem Constraints: Sometimes, the problem statement specifically asks you not to sort the array or assumes that you\\'re working with an unsorted array.\\n\\n5. Changing the nature of the problem: Sometimes sorting an array could fundamentally change the nature of the problem you\\'re trying to solve.\\n\\nIn the context of the problem of searching in a rotated sorted array, sorting the array first would defeat the purpose of the problem. The challenge is to leverage the fact that the array is rotated and sorted to achieve a faster search time, ideally O(log n) which is possible with binary search. If you sort the array first, you would destroy the rotation and any information it might provide. Furthermore, you would still have to search through the sorted array, which would take O(log n) time with binary search, and when combined with the sorting step, would increase the overall time complexity of the solution."
                    },
                    {
                        "username": "iamvasusingh_",
                        "content": "why is my solution not working for [3,1] nums vector ?\n int search(vector<int>& nums, int target) {\n        int start=0;\n        int end=nums.size()-1;\n         while(start <= end)\n         {\n             int mid=(start + end)/2;\n            if(target == nums[mid])\n            {\n                return mid;\n            }\n            if(nums[start] < nums[mid])\n            {\n              if(target >= nums[start] && target<nums[mid])\n              {\n                  end=mid-1;\n              }\n              else\n             {\n               start=mid+1;\n             }\n            }\n            else\n            {\n                if(target > nums[mid] && target <= nums[end])\n                {\n                    start=mid+1;\n                }\n                else\n                {\n                    end=mid-1;\n                }\n            }\n         }\n         return -1;\n    }"
                    },
                    {
                        "username": "bparanj",
                        "content": "The code you provided is designed to handle a rotated sorted array. In the array [3, 1], the pivot point is at index 0, thus making the condition `nums[start] < nums[mid]` fail when `start` and `mid` are both 0.\\n\\nThis occurs because the array is only of length 2, and the element at the `start` and `mid` index is larger than the element at the `end` index. Your code, however, expects that for the first part of the array (`nums[start]` to `nums[mid]`), it will be in sorted order. But due to the pivot at index 0, this is not the case.\\n\\nTo fix this, you can include a check for when `start` and `mid` are equal:\\n\\n```cpp\\nint search(vector<int>& nums, int target) {\\n    int start=0;\\n    int end=nums.size()-1;\\n    while(start <= end)\\n    {\\n        int mid=(start + end)/2;\\n        if(target == nums[mid])\\n        {\\n            return mid;\\n        }\\n        if(nums[start] <= nums[mid]) // change < to <=\\n        {\\n            if(target >= nums[start] && target<nums[mid])\\n            {\\n                end=mid-1;\\n            }\\n            else\\n            {\\n                start=mid+1;\\n            }\\n        }\\n        else\\n        {\\n            if(target > nums[mid] && target <= nums[end])\\n            {\\n                start=mid+1;\\n            }\\n            else\\n            {\\n                end=mid-1;\\n            }\\n        }\\n    }\\n    return -1;\\n}\\n```\\nThis modification handles the case where the pivot is at the start index. Now, if `start` equals `mid` and `nums[start]` is not less than `nums[mid]`, it will still check if the target is within the first half of the array. This is suitable for arrays like [3,1] where the pivot is at the start of the array."
                    },
                    {
                        "username": "peaceTea",
                        "content": "I hate this question!!\\ngetting index out of bound error for some reason for finding the rotate index. absolutely crap"
                    },
                    {
                        "username": "nadeemmi313",
                        "content": "I apply linear search on this problem but it's not showing me Time Limit Exceed error. how it is possible . all test cases are successfully executed. "
                    },
                    {
                        "username": "AnkushR10",
                        "content": "https://github.com/AnkushRawat10601/Leetcode/blob/main/33_search_in_rotated_sorted_array.cpp"
                    },
                    {
                        "username": "alex_lanes",
                        "content": "Is this considered a O(log n) solutuion or a O(n/2) ? \\n\\n```/**\\n * @param  {number[]} nums\\n * @param  {number} target\\n * @return {number}\\n */\\nvar search = function( nums, target ){\\n    let first = 0,\\n        middle = Math.floor( nums.length / 2 ),\\n        last = nums.length - 1,\\n        indexOfTarget = ( start, end ) => {\\n            for( let index = start; index <= end; index++ ) if( nums[index] == target ) return index\\n            return -1\\n        },\\n        // [7,8,1,2,3,4,5,6] => right[ 3, 4, 5, 6 ] => [4, 7]\\n        sorted_indexes = ( nums[first] < nums[middle] ) ? [first, middle] : [middle + 1, last],\\n        // left[ 7, 8, 1, 2 ] => [0, 3]\\n        unsorted_indexes = sorted_indexes[0] != first && sorted_indexes[0] != middle ? [first, middle] : [middle + 1, last]\\n        // target = 2 in right[ 3, 4, 5, 6 ] ? false\\n        inSortedSide = nums[ sorted_indexes[0] ] <= target && target <= nums[ sorted_indexes[1] ]\\n\\n    if( nums[first] == target )         return first\\n    else if( nums[middle] == target )   return middle\\n    else if( nums[last] == target )     return last\\n    else if( inSortedSide )             return indexOfTarget( sorted_indexes[0], sorted_indexes[1] )\\n    else /* !inSortedSide */            return indexOfTarget( unsorted_indexes[0], unsorted_indexes[1] )\\n};"
                    },
                    {
                        "username": "bparanj",
                        "content": "This solution is neither O(log n) nor O(n/2). This solution is O(n) in the worst case scenario.\\n\\nThe reason for this is due to the `indexOfTarget` function. In the worst-case scenario, this function will iterate through roughly half of the elements in the array, which gives a time complexity of O(n).\\n\\nFor example, consider a case where the target value is at the end of the unsorted half of the array. The `indexOfTarget` function will need to iterate over all elements in the unsorted half, which can be up to n/2 elements. Because we drop constants in Big O notation, the time complexity of this function is O(n), not O(n/2).\\n\\nRemember, O(log n) complexity typically implies that you\\'re dividing the problem in half (or any constant fraction) with each step, such as in a binary search. O(n) complexity implies that you have to potentially check every element, which is what the `indexOfTarget` function is doing. Despite the initial checks and divisions of the array, the linear search performed by `indexOfTarget` dominates the time complexity of your solution. \\n\\nTo achieve O(log n) complexity for this problem, you would typically perform a modified binary search, adjusting the high and low points of your search based on the target and the median value, without scanning the array linearly."
                    },
                    {
                        "username": "tanmoy069",
                        "content": "why passed all the testcases with O(n) solution?"
                    },
                    {
                        "username": "Sri_Ram_194",
                        "content": "I think it is the best one in which just checking the each element in the array in which by taking the rotating the index, if nums[i]==given target then,,,\\nfor(int i=0;i<nums.length;i++)\\n        {\\n            if(nums[i]==target)\\n            {\\n                return i;\\n            }\\n        }\\n        return -1;"
                    }
                ]
            },
            {
                "id": 1726990,
                "content": [
                    {
                        "username": "Srivamsi_Dandu",
                        "content": "class Solution {\\n    public static int search(int[] nums, int target){\\n        int pivot = findpiv(nums);\\n        System.out.println(\"pivot is\"+pivot);\\n        if(pivot==-1){\\n            return regularbin(nums,target,0,nums.length-1);\\n        }\\n        if(nums[pivot]==target){\\n            return pivot;\\n        }\\n        if(target>=nums[0]){\\n            return regularbin(nums,target,0,pivot-1);\\n        }\\n        return regularbin(nums,target,pivot+1,nums.length-1);\\n    }\\n    public static int regularbin(int[] nums,int target,int start,int end){\\n            int mid = 0;\\n            while (start<=end){\\n                mid = start+(end-start)/2;\\n                if(target>nums[mid]){\\n                    start=mid+1;\\n                }\\n                else if(target<nums[mid]){\\n                    end = mid-1;\\n                }\\n                else{\\n                    return mid;\\n                }\\n            }\\n            return -1;\\n    }\\n    public static int findpiv(int[] nums){\\n        int start  = 0;\\n        int end = nums.length-1;\\n        int mid =0;\\n        while (start<=end){\\n            mid = start+(end-start)/2;\\n            if(mid<end && nums[mid]>nums[mid+1]){\\n                return mid;\\n            }\\n            if(start<mid && nums[mid-1]>nums[mid]){\\n                return mid-1;\\n            }\\n            if(nums[start]>nums[mid]){\\n                end  = mid-1;\\n            }\\n            else {\\n                start = mid+1;\\n            }\\n        }\\n        return -1;\\n    }\\n}\\n\\nof any comments please comment down\\n"
                    },
                    {
                        "username": "Dastagir_Mulani_101",
                        "content": "Even solution with linear search i.e. O(n) is getting accepted, this should not happen isn\\'t it?? The problem makers should change the problem solution so it can accept only solution with O(log n) complexity otherwise should give TLE."
                    },
                    {
                        "username": "hb_134",
                        "content": "Why we do not use this ->  `sort(nums.begin(), nums.end());`\\nI know then the time complexity will increase but just ignore that part why we do not use this??\\n\\nPlease discuss with me in this part :)"
                    },
                    {
                        "username": "psionl0",
                        "content": "You are required to return the position of target. Sorting an array will change the position of its elements. You can do this but you will need to keep track of the original positions of the elements which will complicate the exercise."
                    },
                    {
                        "username": "bparanj",
                        "content": "Sorting an array is often a useful operation when you want to organize the data in a certain order, typically either ascending or descending. However, there are several reasons why you might not want to sort the array in the context of a particular problem.\\n\\n1. Preserving original order: Many problems require you to preserve the original order of elements in the array. Sorting the array would destroy this original order.\\n\\n2. Time complexity: As you mentioned, sorting an array has a time complexity of at least O(n log n) for most standard sorting algorithms. This could make your solution too slow if the input array is large.\\n\\n3. Space complexity: Sorting algorithms often require additional space. For example, the commonly used quicksort and mergesort algorithms are not in-place and need O(n) extra space.\\n\\n4. Problem Constraints: Sometimes, the problem statement specifically asks you not to sort the array or assumes that you\\'re working with an unsorted array.\\n\\n5. Changing the nature of the problem: Sometimes sorting an array could fundamentally change the nature of the problem you\\'re trying to solve.\\n\\nIn the context of the problem of searching in a rotated sorted array, sorting the array first would defeat the purpose of the problem. The challenge is to leverage the fact that the array is rotated and sorted to achieve a faster search time, ideally O(log n) which is possible with binary search. If you sort the array first, you would destroy the rotation and any information it might provide. Furthermore, you would still have to search through the sorted array, which would take O(log n) time with binary search, and when combined with the sorting step, would increase the overall time complexity of the solution."
                    },
                    {
                        "username": "iamvasusingh_",
                        "content": "why is my solution not working for [3,1] nums vector ?\n int search(vector<int>& nums, int target) {\n        int start=0;\n        int end=nums.size()-1;\n         while(start <= end)\n         {\n             int mid=(start + end)/2;\n            if(target == nums[mid])\n            {\n                return mid;\n            }\n            if(nums[start] < nums[mid])\n            {\n              if(target >= nums[start] && target<nums[mid])\n              {\n                  end=mid-1;\n              }\n              else\n             {\n               start=mid+1;\n             }\n            }\n            else\n            {\n                if(target > nums[mid] && target <= nums[end])\n                {\n                    start=mid+1;\n                }\n                else\n                {\n                    end=mid-1;\n                }\n            }\n         }\n         return -1;\n    }"
                    },
                    {
                        "username": "bparanj",
                        "content": "The code you provided is designed to handle a rotated sorted array. In the array [3, 1], the pivot point is at index 0, thus making the condition `nums[start] < nums[mid]` fail when `start` and `mid` are both 0.\\n\\nThis occurs because the array is only of length 2, and the element at the `start` and `mid` index is larger than the element at the `end` index. Your code, however, expects that for the first part of the array (`nums[start]` to `nums[mid]`), it will be in sorted order. But due to the pivot at index 0, this is not the case.\\n\\nTo fix this, you can include a check for when `start` and `mid` are equal:\\n\\n```cpp\\nint search(vector<int>& nums, int target) {\\n    int start=0;\\n    int end=nums.size()-1;\\n    while(start <= end)\\n    {\\n        int mid=(start + end)/2;\\n        if(target == nums[mid])\\n        {\\n            return mid;\\n        }\\n        if(nums[start] <= nums[mid]) // change < to <=\\n        {\\n            if(target >= nums[start] && target<nums[mid])\\n            {\\n                end=mid-1;\\n            }\\n            else\\n            {\\n                start=mid+1;\\n            }\\n        }\\n        else\\n        {\\n            if(target > nums[mid] && target <= nums[end])\\n            {\\n                start=mid+1;\\n            }\\n            else\\n            {\\n                end=mid-1;\\n            }\\n        }\\n    }\\n    return -1;\\n}\\n```\\nThis modification handles the case where the pivot is at the start index. Now, if `start` equals `mid` and `nums[start]` is not less than `nums[mid]`, it will still check if the target is within the first half of the array. This is suitable for arrays like [3,1] where the pivot is at the start of the array."
                    },
                    {
                        "username": "peaceTea",
                        "content": "I hate this question!!\\ngetting index out of bound error for some reason for finding the rotate index. absolutely crap"
                    },
                    {
                        "username": "nadeemmi313",
                        "content": "I apply linear search on this problem but it's not showing me Time Limit Exceed error. how it is possible . all test cases are successfully executed. "
                    },
                    {
                        "username": "AnkushR10",
                        "content": "https://github.com/AnkushRawat10601/Leetcode/blob/main/33_search_in_rotated_sorted_array.cpp"
                    },
                    {
                        "username": "alex_lanes",
                        "content": "Is this considered a O(log n) solutuion or a O(n/2) ? \\n\\n```/**\\n * @param  {number[]} nums\\n * @param  {number} target\\n * @return {number}\\n */\\nvar search = function( nums, target ){\\n    let first = 0,\\n        middle = Math.floor( nums.length / 2 ),\\n        last = nums.length - 1,\\n        indexOfTarget = ( start, end ) => {\\n            for( let index = start; index <= end; index++ ) if( nums[index] == target ) return index\\n            return -1\\n        },\\n        // [7,8,1,2,3,4,5,6] => right[ 3, 4, 5, 6 ] => [4, 7]\\n        sorted_indexes = ( nums[first] < nums[middle] ) ? [first, middle] : [middle + 1, last],\\n        // left[ 7, 8, 1, 2 ] => [0, 3]\\n        unsorted_indexes = sorted_indexes[0] != first && sorted_indexes[0] != middle ? [first, middle] : [middle + 1, last]\\n        // target = 2 in right[ 3, 4, 5, 6 ] ? false\\n        inSortedSide = nums[ sorted_indexes[0] ] <= target && target <= nums[ sorted_indexes[1] ]\\n\\n    if( nums[first] == target )         return first\\n    else if( nums[middle] == target )   return middle\\n    else if( nums[last] == target )     return last\\n    else if( inSortedSide )             return indexOfTarget( sorted_indexes[0], sorted_indexes[1] )\\n    else /* !inSortedSide */            return indexOfTarget( unsorted_indexes[0], unsorted_indexes[1] )\\n};"
                    },
                    {
                        "username": "bparanj",
                        "content": "This solution is neither O(log n) nor O(n/2). This solution is O(n) in the worst case scenario.\\n\\nThe reason for this is due to the `indexOfTarget` function. In the worst-case scenario, this function will iterate through roughly half of the elements in the array, which gives a time complexity of O(n).\\n\\nFor example, consider a case where the target value is at the end of the unsorted half of the array. The `indexOfTarget` function will need to iterate over all elements in the unsorted half, which can be up to n/2 elements. Because we drop constants in Big O notation, the time complexity of this function is O(n), not O(n/2).\\n\\nRemember, O(log n) complexity typically implies that you\\'re dividing the problem in half (or any constant fraction) with each step, such as in a binary search. O(n) complexity implies that you have to potentially check every element, which is what the `indexOfTarget` function is doing. Despite the initial checks and divisions of the array, the linear search performed by `indexOfTarget` dominates the time complexity of your solution. \\n\\nTo achieve O(log n) complexity for this problem, you would typically perform a modified binary search, adjusting the high and low points of your search based on the target and the median value, without scanning the array linearly."
                    },
                    {
                        "username": "tanmoy069",
                        "content": "why passed all the testcases with O(n) solution?"
                    },
                    {
                        "username": "Sri_Ram_194",
                        "content": "I think it is the best one in which just checking the each element in the array in which by taking the rotating the index, if nums[i]==given target then,,,\\nfor(int i=0;i<nums.length;i++)\\n        {\\n            if(nums[i]==target)\\n            {\\n                return i;\\n            }\\n        }\\n        return -1;"
                    }
                ]
            },
            {
                "id": 1726161,
                "content": [
                    {
                        "username": "Srivamsi_Dandu",
                        "content": "class Solution {\\n    public static int search(int[] nums, int target){\\n        int pivot = findpiv(nums);\\n        System.out.println(\"pivot is\"+pivot);\\n        if(pivot==-1){\\n            return regularbin(nums,target,0,nums.length-1);\\n        }\\n        if(nums[pivot]==target){\\n            return pivot;\\n        }\\n        if(target>=nums[0]){\\n            return regularbin(nums,target,0,pivot-1);\\n        }\\n        return regularbin(nums,target,pivot+1,nums.length-1);\\n    }\\n    public static int regularbin(int[] nums,int target,int start,int end){\\n            int mid = 0;\\n            while (start<=end){\\n                mid = start+(end-start)/2;\\n                if(target>nums[mid]){\\n                    start=mid+1;\\n                }\\n                else if(target<nums[mid]){\\n                    end = mid-1;\\n                }\\n                else{\\n                    return mid;\\n                }\\n            }\\n            return -1;\\n    }\\n    public static int findpiv(int[] nums){\\n        int start  = 0;\\n        int end = nums.length-1;\\n        int mid =0;\\n        while (start<=end){\\n            mid = start+(end-start)/2;\\n            if(mid<end && nums[mid]>nums[mid+1]){\\n                return mid;\\n            }\\n            if(start<mid && nums[mid-1]>nums[mid]){\\n                return mid-1;\\n            }\\n            if(nums[start]>nums[mid]){\\n                end  = mid-1;\\n            }\\n            else {\\n                start = mid+1;\\n            }\\n        }\\n        return -1;\\n    }\\n}\\n\\nof any comments please comment down\\n"
                    },
                    {
                        "username": "Dastagir_Mulani_101",
                        "content": "Even solution with linear search i.e. O(n) is getting accepted, this should not happen isn\\'t it?? The problem makers should change the problem solution so it can accept only solution with O(log n) complexity otherwise should give TLE."
                    },
                    {
                        "username": "hb_134",
                        "content": "Why we do not use this ->  `sort(nums.begin(), nums.end());`\\nI know then the time complexity will increase but just ignore that part why we do not use this??\\n\\nPlease discuss with me in this part :)"
                    },
                    {
                        "username": "psionl0",
                        "content": "You are required to return the position of target. Sorting an array will change the position of its elements. You can do this but you will need to keep track of the original positions of the elements which will complicate the exercise."
                    },
                    {
                        "username": "bparanj",
                        "content": "Sorting an array is often a useful operation when you want to organize the data in a certain order, typically either ascending or descending. However, there are several reasons why you might not want to sort the array in the context of a particular problem.\\n\\n1. Preserving original order: Many problems require you to preserve the original order of elements in the array. Sorting the array would destroy this original order.\\n\\n2. Time complexity: As you mentioned, sorting an array has a time complexity of at least O(n log n) for most standard sorting algorithms. This could make your solution too slow if the input array is large.\\n\\n3. Space complexity: Sorting algorithms often require additional space. For example, the commonly used quicksort and mergesort algorithms are not in-place and need O(n) extra space.\\n\\n4. Problem Constraints: Sometimes, the problem statement specifically asks you not to sort the array or assumes that you\\'re working with an unsorted array.\\n\\n5. Changing the nature of the problem: Sometimes sorting an array could fundamentally change the nature of the problem you\\'re trying to solve.\\n\\nIn the context of the problem of searching in a rotated sorted array, sorting the array first would defeat the purpose of the problem. The challenge is to leverage the fact that the array is rotated and sorted to achieve a faster search time, ideally O(log n) which is possible with binary search. If you sort the array first, you would destroy the rotation and any information it might provide. Furthermore, you would still have to search through the sorted array, which would take O(log n) time with binary search, and when combined with the sorting step, would increase the overall time complexity of the solution."
                    },
                    {
                        "username": "iamvasusingh_",
                        "content": "why is my solution not working for [3,1] nums vector ?\n int search(vector<int>& nums, int target) {\n        int start=0;\n        int end=nums.size()-1;\n         while(start <= end)\n         {\n             int mid=(start + end)/2;\n            if(target == nums[mid])\n            {\n                return mid;\n            }\n            if(nums[start] < nums[mid])\n            {\n              if(target >= nums[start] && target<nums[mid])\n              {\n                  end=mid-1;\n              }\n              else\n             {\n               start=mid+1;\n             }\n            }\n            else\n            {\n                if(target > nums[mid] && target <= nums[end])\n                {\n                    start=mid+1;\n                }\n                else\n                {\n                    end=mid-1;\n                }\n            }\n         }\n         return -1;\n    }"
                    },
                    {
                        "username": "bparanj",
                        "content": "The code you provided is designed to handle a rotated sorted array. In the array [3, 1], the pivot point is at index 0, thus making the condition `nums[start] < nums[mid]` fail when `start` and `mid` are both 0.\\n\\nThis occurs because the array is only of length 2, and the element at the `start` and `mid` index is larger than the element at the `end` index. Your code, however, expects that for the first part of the array (`nums[start]` to `nums[mid]`), it will be in sorted order. But due to the pivot at index 0, this is not the case.\\n\\nTo fix this, you can include a check for when `start` and `mid` are equal:\\n\\n```cpp\\nint search(vector<int>& nums, int target) {\\n    int start=0;\\n    int end=nums.size()-1;\\n    while(start <= end)\\n    {\\n        int mid=(start + end)/2;\\n        if(target == nums[mid])\\n        {\\n            return mid;\\n        }\\n        if(nums[start] <= nums[mid]) // change < to <=\\n        {\\n            if(target >= nums[start] && target<nums[mid])\\n            {\\n                end=mid-1;\\n            }\\n            else\\n            {\\n                start=mid+1;\\n            }\\n        }\\n        else\\n        {\\n            if(target > nums[mid] && target <= nums[end])\\n            {\\n                start=mid+1;\\n            }\\n            else\\n            {\\n                end=mid-1;\\n            }\\n        }\\n    }\\n    return -1;\\n}\\n```\\nThis modification handles the case where the pivot is at the start index. Now, if `start` equals `mid` and `nums[start]` is not less than `nums[mid]`, it will still check if the target is within the first half of the array. This is suitable for arrays like [3,1] where the pivot is at the start of the array."
                    },
                    {
                        "username": "peaceTea",
                        "content": "I hate this question!!\\ngetting index out of bound error for some reason for finding the rotate index. absolutely crap"
                    },
                    {
                        "username": "nadeemmi313",
                        "content": "I apply linear search on this problem but it's not showing me Time Limit Exceed error. how it is possible . all test cases are successfully executed. "
                    },
                    {
                        "username": "AnkushR10",
                        "content": "https://github.com/AnkushRawat10601/Leetcode/blob/main/33_search_in_rotated_sorted_array.cpp"
                    },
                    {
                        "username": "alex_lanes",
                        "content": "Is this considered a O(log n) solutuion or a O(n/2) ? \\n\\n```/**\\n * @param  {number[]} nums\\n * @param  {number} target\\n * @return {number}\\n */\\nvar search = function( nums, target ){\\n    let first = 0,\\n        middle = Math.floor( nums.length / 2 ),\\n        last = nums.length - 1,\\n        indexOfTarget = ( start, end ) => {\\n            for( let index = start; index <= end; index++ ) if( nums[index] == target ) return index\\n            return -1\\n        },\\n        // [7,8,1,2,3,4,5,6] => right[ 3, 4, 5, 6 ] => [4, 7]\\n        sorted_indexes = ( nums[first] < nums[middle] ) ? [first, middle] : [middle + 1, last],\\n        // left[ 7, 8, 1, 2 ] => [0, 3]\\n        unsorted_indexes = sorted_indexes[0] != first && sorted_indexes[0] != middle ? [first, middle] : [middle + 1, last]\\n        // target = 2 in right[ 3, 4, 5, 6 ] ? false\\n        inSortedSide = nums[ sorted_indexes[0] ] <= target && target <= nums[ sorted_indexes[1] ]\\n\\n    if( nums[first] == target )         return first\\n    else if( nums[middle] == target )   return middle\\n    else if( nums[last] == target )     return last\\n    else if( inSortedSide )             return indexOfTarget( sorted_indexes[0], sorted_indexes[1] )\\n    else /* !inSortedSide */            return indexOfTarget( unsorted_indexes[0], unsorted_indexes[1] )\\n};"
                    },
                    {
                        "username": "bparanj",
                        "content": "This solution is neither O(log n) nor O(n/2). This solution is O(n) in the worst case scenario.\\n\\nThe reason for this is due to the `indexOfTarget` function. In the worst-case scenario, this function will iterate through roughly half of the elements in the array, which gives a time complexity of O(n).\\n\\nFor example, consider a case where the target value is at the end of the unsorted half of the array. The `indexOfTarget` function will need to iterate over all elements in the unsorted half, which can be up to n/2 elements. Because we drop constants in Big O notation, the time complexity of this function is O(n), not O(n/2).\\n\\nRemember, O(log n) complexity typically implies that you\\'re dividing the problem in half (or any constant fraction) with each step, such as in a binary search. O(n) complexity implies that you have to potentially check every element, which is what the `indexOfTarget` function is doing. Despite the initial checks and divisions of the array, the linear search performed by `indexOfTarget` dominates the time complexity of your solution. \\n\\nTo achieve O(log n) complexity for this problem, you would typically perform a modified binary search, adjusting the high and low points of your search based on the target and the median value, without scanning the array linearly."
                    },
                    {
                        "username": "tanmoy069",
                        "content": "why passed all the testcases with O(n) solution?"
                    },
                    {
                        "username": "Sri_Ram_194",
                        "content": "I think it is the best one in which just checking the each element in the array in which by taking the rotating the index, if nums[i]==given target then,,,\\nfor(int i=0;i<nums.length;i++)\\n        {\\n            if(nums[i]==target)\\n            {\\n                return i;\\n            }\\n        }\\n        return -1;"
                    }
                ]
            },
            {
                "id": 1724793,
                "content": [
                    {
                        "username": "Srivamsi_Dandu",
                        "content": "class Solution {\\n    public static int search(int[] nums, int target){\\n        int pivot = findpiv(nums);\\n        System.out.println(\"pivot is\"+pivot);\\n        if(pivot==-1){\\n            return regularbin(nums,target,0,nums.length-1);\\n        }\\n        if(nums[pivot]==target){\\n            return pivot;\\n        }\\n        if(target>=nums[0]){\\n            return regularbin(nums,target,0,pivot-1);\\n        }\\n        return regularbin(nums,target,pivot+1,nums.length-1);\\n    }\\n    public static int regularbin(int[] nums,int target,int start,int end){\\n            int mid = 0;\\n            while (start<=end){\\n                mid = start+(end-start)/2;\\n                if(target>nums[mid]){\\n                    start=mid+1;\\n                }\\n                else if(target<nums[mid]){\\n                    end = mid-1;\\n                }\\n                else{\\n                    return mid;\\n                }\\n            }\\n            return -1;\\n    }\\n    public static int findpiv(int[] nums){\\n        int start  = 0;\\n        int end = nums.length-1;\\n        int mid =0;\\n        while (start<=end){\\n            mid = start+(end-start)/2;\\n            if(mid<end && nums[mid]>nums[mid+1]){\\n                return mid;\\n            }\\n            if(start<mid && nums[mid-1]>nums[mid]){\\n                return mid-1;\\n            }\\n            if(nums[start]>nums[mid]){\\n                end  = mid-1;\\n            }\\n            else {\\n                start = mid+1;\\n            }\\n        }\\n        return -1;\\n    }\\n}\\n\\nof any comments please comment down\\n"
                    },
                    {
                        "username": "Dastagir_Mulani_101",
                        "content": "Even solution with linear search i.e. O(n) is getting accepted, this should not happen isn\\'t it?? The problem makers should change the problem solution so it can accept only solution with O(log n) complexity otherwise should give TLE."
                    },
                    {
                        "username": "hb_134",
                        "content": "Why we do not use this ->  `sort(nums.begin(), nums.end());`\\nI know then the time complexity will increase but just ignore that part why we do not use this??\\n\\nPlease discuss with me in this part :)"
                    },
                    {
                        "username": "psionl0",
                        "content": "You are required to return the position of target. Sorting an array will change the position of its elements. You can do this but you will need to keep track of the original positions of the elements which will complicate the exercise."
                    },
                    {
                        "username": "bparanj",
                        "content": "Sorting an array is often a useful operation when you want to organize the data in a certain order, typically either ascending or descending. However, there are several reasons why you might not want to sort the array in the context of a particular problem.\\n\\n1. Preserving original order: Many problems require you to preserve the original order of elements in the array. Sorting the array would destroy this original order.\\n\\n2. Time complexity: As you mentioned, sorting an array has a time complexity of at least O(n log n) for most standard sorting algorithms. This could make your solution too slow if the input array is large.\\n\\n3. Space complexity: Sorting algorithms often require additional space. For example, the commonly used quicksort and mergesort algorithms are not in-place and need O(n) extra space.\\n\\n4. Problem Constraints: Sometimes, the problem statement specifically asks you not to sort the array or assumes that you\\'re working with an unsorted array.\\n\\n5. Changing the nature of the problem: Sometimes sorting an array could fundamentally change the nature of the problem you\\'re trying to solve.\\n\\nIn the context of the problem of searching in a rotated sorted array, sorting the array first would defeat the purpose of the problem. The challenge is to leverage the fact that the array is rotated and sorted to achieve a faster search time, ideally O(log n) which is possible with binary search. If you sort the array first, you would destroy the rotation and any information it might provide. Furthermore, you would still have to search through the sorted array, which would take O(log n) time with binary search, and when combined with the sorting step, would increase the overall time complexity of the solution."
                    },
                    {
                        "username": "iamvasusingh_",
                        "content": "why is my solution not working for [3,1] nums vector ?\n int search(vector<int>& nums, int target) {\n        int start=0;\n        int end=nums.size()-1;\n         while(start <= end)\n         {\n             int mid=(start + end)/2;\n            if(target == nums[mid])\n            {\n                return mid;\n            }\n            if(nums[start] < nums[mid])\n            {\n              if(target >= nums[start] && target<nums[mid])\n              {\n                  end=mid-1;\n              }\n              else\n             {\n               start=mid+1;\n             }\n            }\n            else\n            {\n                if(target > nums[mid] && target <= nums[end])\n                {\n                    start=mid+1;\n                }\n                else\n                {\n                    end=mid-1;\n                }\n            }\n         }\n         return -1;\n    }"
                    },
                    {
                        "username": "bparanj",
                        "content": "The code you provided is designed to handle a rotated sorted array. In the array [3, 1], the pivot point is at index 0, thus making the condition `nums[start] < nums[mid]` fail when `start` and `mid` are both 0.\\n\\nThis occurs because the array is only of length 2, and the element at the `start` and `mid` index is larger than the element at the `end` index. Your code, however, expects that for the first part of the array (`nums[start]` to `nums[mid]`), it will be in sorted order. But due to the pivot at index 0, this is not the case.\\n\\nTo fix this, you can include a check for when `start` and `mid` are equal:\\n\\n```cpp\\nint search(vector<int>& nums, int target) {\\n    int start=0;\\n    int end=nums.size()-1;\\n    while(start <= end)\\n    {\\n        int mid=(start + end)/2;\\n        if(target == nums[mid])\\n        {\\n            return mid;\\n        }\\n        if(nums[start] <= nums[mid]) // change < to <=\\n        {\\n            if(target >= nums[start] && target<nums[mid])\\n            {\\n                end=mid-1;\\n            }\\n            else\\n            {\\n                start=mid+1;\\n            }\\n        }\\n        else\\n        {\\n            if(target > nums[mid] && target <= nums[end])\\n            {\\n                start=mid+1;\\n            }\\n            else\\n            {\\n                end=mid-1;\\n            }\\n        }\\n    }\\n    return -1;\\n}\\n```\\nThis modification handles the case where the pivot is at the start index. Now, if `start` equals `mid` and `nums[start]` is not less than `nums[mid]`, it will still check if the target is within the first half of the array. This is suitable for arrays like [3,1] where the pivot is at the start of the array."
                    },
                    {
                        "username": "peaceTea",
                        "content": "I hate this question!!\\ngetting index out of bound error for some reason for finding the rotate index. absolutely crap"
                    },
                    {
                        "username": "nadeemmi313",
                        "content": "I apply linear search on this problem but it's not showing me Time Limit Exceed error. how it is possible . all test cases are successfully executed. "
                    },
                    {
                        "username": "AnkushR10",
                        "content": "https://github.com/AnkushRawat10601/Leetcode/blob/main/33_search_in_rotated_sorted_array.cpp"
                    },
                    {
                        "username": "alex_lanes",
                        "content": "Is this considered a O(log n) solutuion or a O(n/2) ? \\n\\n```/**\\n * @param  {number[]} nums\\n * @param  {number} target\\n * @return {number}\\n */\\nvar search = function( nums, target ){\\n    let first = 0,\\n        middle = Math.floor( nums.length / 2 ),\\n        last = nums.length - 1,\\n        indexOfTarget = ( start, end ) => {\\n            for( let index = start; index <= end; index++ ) if( nums[index] == target ) return index\\n            return -1\\n        },\\n        // [7,8,1,2,3,4,5,6] => right[ 3, 4, 5, 6 ] => [4, 7]\\n        sorted_indexes = ( nums[first] < nums[middle] ) ? [first, middle] : [middle + 1, last],\\n        // left[ 7, 8, 1, 2 ] => [0, 3]\\n        unsorted_indexes = sorted_indexes[0] != first && sorted_indexes[0] != middle ? [first, middle] : [middle + 1, last]\\n        // target = 2 in right[ 3, 4, 5, 6 ] ? false\\n        inSortedSide = nums[ sorted_indexes[0] ] <= target && target <= nums[ sorted_indexes[1] ]\\n\\n    if( nums[first] == target )         return first\\n    else if( nums[middle] == target )   return middle\\n    else if( nums[last] == target )     return last\\n    else if( inSortedSide )             return indexOfTarget( sorted_indexes[0], sorted_indexes[1] )\\n    else /* !inSortedSide */            return indexOfTarget( unsorted_indexes[0], unsorted_indexes[1] )\\n};"
                    },
                    {
                        "username": "bparanj",
                        "content": "This solution is neither O(log n) nor O(n/2). This solution is O(n) in the worst case scenario.\\n\\nThe reason for this is due to the `indexOfTarget` function. In the worst-case scenario, this function will iterate through roughly half of the elements in the array, which gives a time complexity of O(n).\\n\\nFor example, consider a case where the target value is at the end of the unsorted half of the array. The `indexOfTarget` function will need to iterate over all elements in the unsorted half, which can be up to n/2 elements. Because we drop constants in Big O notation, the time complexity of this function is O(n), not O(n/2).\\n\\nRemember, O(log n) complexity typically implies that you\\'re dividing the problem in half (or any constant fraction) with each step, such as in a binary search. O(n) complexity implies that you have to potentially check every element, which is what the `indexOfTarget` function is doing. Despite the initial checks and divisions of the array, the linear search performed by `indexOfTarget` dominates the time complexity of your solution. \\n\\nTo achieve O(log n) complexity for this problem, you would typically perform a modified binary search, adjusting the high and low points of your search based on the target and the median value, without scanning the array linearly."
                    },
                    {
                        "username": "tanmoy069",
                        "content": "why passed all the testcases with O(n) solution?"
                    },
                    {
                        "username": "Sri_Ram_194",
                        "content": "I think it is the best one in which just checking the each element in the array in which by taking the rotating the index, if nums[i]==given target then,,,\\nfor(int i=0;i<nums.length;i++)\\n        {\\n            if(nums[i]==target)\\n            {\\n                return i;\\n            }\\n        }\\n        return -1;"
                    }
                ]
            },
            {
                "id": 1723595,
                "content": [
                    {
                        "username": "Srivamsi_Dandu",
                        "content": "class Solution {\\n    public static int search(int[] nums, int target){\\n        int pivot = findpiv(nums);\\n        System.out.println(\"pivot is\"+pivot);\\n        if(pivot==-1){\\n            return regularbin(nums,target,0,nums.length-1);\\n        }\\n        if(nums[pivot]==target){\\n            return pivot;\\n        }\\n        if(target>=nums[0]){\\n            return regularbin(nums,target,0,pivot-1);\\n        }\\n        return regularbin(nums,target,pivot+1,nums.length-1);\\n    }\\n    public static int regularbin(int[] nums,int target,int start,int end){\\n            int mid = 0;\\n            while (start<=end){\\n                mid = start+(end-start)/2;\\n                if(target>nums[mid]){\\n                    start=mid+1;\\n                }\\n                else if(target<nums[mid]){\\n                    end = mid-1;\\n                }\\n                else{\\n                    return mid;\\n                }\\n            }\\n            return -1;\\n    }\\n    public static int findpiv(int[] nums){\\n        int start  = 0;\\n        int end = nums.length-1;\\n        int mid =0;\\n        while (start<=end){\\n            mid = start+(end-start)/2;\\n            if(mid<end && nums[mid]>nums[mid+1]){\\n                return mid;\\n            }\\n            if(start<mid && nums[mid-1]>nums[mid]){\\n                return mid-1;\\n            }\\n            if(nums[start]>nums[mid]){\\n                end  = mid-1;\\n            }\\n            else {\\n                start = mid+1;\\n            }\\n        }\\n        return -1;\\n    }\\n}\\n\\nof any comments please comment down\\n"
                    },
                    {
                        "username": "Dastagir_Mulani_101",
                        "content": "Even solution with linear search i.e. O(n) is getting accepted, this should not happen isn\\'t it?? The problem makers should change the problem solution so it can accept only solution with O(log n) complexity otherwise should give TLE."
                    },
                    {
                        "username": "hb_134",
                        "content": "Why we do not use this ->  `sort(nums.begin(), nums.end());`\\nI know then the time complexity will increase but just ignore that part why we do not use this??\\n\\nPlease discuss with me in this part :)"
                    },
                    {
                        "username": "psionl0",
                        "content": "You are required to return the position of target. Sorting an array will change the position of its elements. You can do this but you will need to keep track of the original positions of the elements which will complicate the exercise."
                    },
                    {
                        "username": "bparanj",
                        "content": "Sorting an array is often a useful operation when you want to organize the data in a certain order, typically either ascending or descending. However, there are several reasons why you might not want to sort the array in the context of a particular problem.\\n\\n1. Preserving original order: Many problems require you to preserve the original order of elements in the array. Sorting the array would destroy this original order.\\n\\n2. Time complexity: As you mentioned, sorting an array has a time complexity of at least O(n log n) for most standard sorting algorithms. This could make your solution too slow if the input array is large.\\n\\n3. Space complexity: Sorting algorithms often require additional space. For example, the commonly used quicksort and mergesort algorithms are not in-place and need O(n) extra space.\\n\\n4. Problem Constraints: Sometimes, the problem statement specifically asks you not to sort the array or assumes that you\\'re working with an unsorted array.\\n\\n5. Changing the nature of the problem: Sometimes sorting an array could fundamentally change the nature of the problem you\\'re trying to solve.\\n\\nIn the context of the problem of searching in a rotated sorted array, sorting the array first would defeat the purpose of the problem. The challenge is to leverage the fact that the array is rotated and sorted to achieve a faster search time, ideally O(log n) which is possible with binary search. If you sort the array first, you would destroy the rotation and any information it might provide. Furthermore, you would still have to search through the sorted array, which would take O(log n) time with binary search, and when combined with the sorting step, would increase the overall time complexity of the solution."
                    },
                    {
                        "username": "iamvasusingh_",
                        "content": "why is my solution not working for [3,1] nums vector ?\n int search(vector<int>& nums, int target) {\n        int start=0;\n        int end=nums.size()-1;\n         while(start <= end)\n         {\n             int mid=(start + end)/2;\n            if(target == nums[mid])\n            {\n                return mid;\n            }\n            if(nums[start] < nums[mid])\n            {\n              if(target >= nums[start] && target<nums[mid])\n              {\n                  end=mid-1;\n              }\n              else\n             {\n               start=mid+1;\n             }\n            }\n            else\n            {\n                if(target > nums[mid] && target <= nums[end])\n                {\n                    start=mid+1;\n                }\n                else\n                {\n                    end=mid-1;\n                }\n            }\n         }\n         return -1;\n    }"
                    },
                    {
                        "username": "bparanj",
                        "content": "The code you provided is designed to handle a rotated sorted array. In the array [3, 1], the pivot point is at index 0, thus making the condition `nums[start] < nums[mid]` fail when `start` and `mid` are both 0.\\n\\nThis occurs because the array is only of length 2, and the element at the `start` and `mid` index is larger than the element at the `end` index. Your code, however, expects that for the first part of the array (`nums[start]` to `nums[mid]`), it will be in sorted order. But due to the pivot at index 0, this is not the case.\\n\\nTo fix this, you can include a check for when `start` and `mid` are equal:\\n\\n```cpp\\nint search(vector<int>& nums, int target) {\\n    int start=0;\\n    int end=nums.size()-1;\\n    while(start <= end)\\n    {\\n        int mid=(start + end)/2;\\n        if(target == nums[mid])\\n        {\\n            return mid;\\n        }\\n        if(nums[start] <= nums[mid]) // change < to <=\\n        {\\n            if(target >= nums[start] && target<nums[mid])\\n            {\\n                end=mid-1;\\n            }\\n            else\\n            {\\n                start=mid+1;\\n            }\\n        }\\n        else\\n        {\\n            if(target > nums[mid] && target <= nums[end])\\n            {\\n                start=mid+1;\\n            }\\n            else\\n            {\\n                end=mid-1;\\n            }\\n        }\\n    }\\n    return -1;\\n}\\n```\\nThis modification handles the case where the pivot is at the start index. Now, if `start` equals `mid` and `nums[start]` is not less than `nums[mid]`, it will still check if the target is within the first half of the array. This is suitable for arrays like [3,1] where the pivot is at the start of the array."
                    },
                    {
                        "username": "peaceTea",
                        "content": "I hate this question!!\\ngetting index out of bound error for some reason for finding the rotate index. absolutely crap"
                    },
                    {
                        "username": "nadeemmi313",
                        "content": "I apply linear search on this problem but it's not showing me Time Limit Exceed error. how it is possible . all test cases are successfully executed. "
                    },
                    {
                        "username": "AnkushR10",
                        "content": "https://github.com/AnkushRawat10601/Leetcode/blob/main/33_search_in_rotated_sorted_array.cpp"
                    },
                    {
                        "username": "alex_lanes",
                        "content": "Is this considered a O(log n) solutuion or a O(n/2) ? \\n\\n```/**\\n * @param  {number[]} nums\\n * @param  {number} target\\n * @return {number}\\n */\\nvar search = function( nums, target ){\\n    let first = 0,\\n        middle = Math.floor( nums.length / 2 ),\\n        last = nums.length - 1,\\n        indexOfTarget = ( start, end ) => {\\n            for( let index = start; index <= end; index++ ) if( nums[index] == target ) return index\\n            return -1\\n        },\\n        // [7,8,1,2,3,4,5,6] => right[ 3, 4, 5, 6 ] => [4, 7]\\n        sorted_indexes = ( nums[first] < nums[middle] ) ? [first, middle] : [middle + 1, last],\\n        // left[ 7, 8, 1, 2 ] => [0, 3]\\n        unsorted_indexes = sorted_indexes[0] != first && sorted_indexes[0] != middle ? [first, middle] : [middle + 1, last]\\n        // target = 2 in right[ 3, 4, 5, 6 ] ? false\\n        inSortedSide = nums[ sorted_indexes[0] ] <= target && target <= nums[ sorted_indexes[1] ]\\n\\n    if( nums[first] == target )         return first\\n    else if( nums[middle] == target )   return middle\\n    else if( nums[last] == target )     return last\\n    else if( inSortedSide )             return indexOfTarget( sorted_indexes[0], sorted_indexes[1] )\\n    else /* !inSortedSide */            return indexOfTarget( unsorted_indexes[0], unsorted_indexes[1] )\\n};"
                    },
                    {
                        "username": "bparanj",
                        "content": "This solution is neither O(log n) nor O(n/2). This solution is O(n) in the worst case scenario.\\n\\nThe reason for this is due to the `indexOfTarget` function. In the worst-case scenario, this function will iterate through roughly half of the elements in the array, which gives a time complexity of O(n).\\n\\nFor example, consider a case where the target value is at the end of the unsorted half of the array. The `indexOfTarget` function will need to iterate over all elements in the unsorted half, which can be up to n/2 elements. Because we drop constants in Big O notation, the time complexity of this function is O(n), not O(n/2).\\n\\nRemember, O(log n) complexity typically implies that you\\'re dividing the problem in half (or any constant fraction) with each step, such as in a binary search. O(n) complexity implies that you have to potentially check every element, which is what the `indexOfTarget` function is doing. Despite the initial checks and divisions of the array, the linear search performed by `indexOfTarget` dominates the time complexity of your solution. \\n\\nTo achieve O(log n) complexity for this problem, you would typically perform a modified binary search, adjusting the high and low points of your search based on the target and the median value, without scanning the array linearly."
                    },
                    {
                        "username": "tanmoy069",
                        "content": "why passed all the testcases with O(n) solution?"
                    },
                    {
                        "username": "Sri_Ram_194",
                        "content": "I think it is the best one in which just checking the each element in the array in which by taking the rotating the index, if nums[i]==given target then,,,\\nfor(int i=0;i<nums.length;i++)\\n        {\\n            if(nums[i]==target)\\n            {\\n                return i;\\n            }\\n        }\\n        return -1;"
                    }
                ]
            },
            {
                "id": 1721248,
                "content": [
                    {
                        "username": "Srivamsi_Dandu",
                        "content": "class Solution {\\n    public static int search(int[] nums, int target){\\n        int pivot = findpiv(nums);\\n        System.out.println(\"pivot is\"+pivot);\\n        if(pivot==-1){\\n            return regularbin(nums,target,0,nums.length-1);\\n        }\\n        if(nums[pivot]==target){\\n            return pivot;\\n        }\\n        if(target>=nums[0]){\\n            return regularbin(nums,target,0,pivot-1);\\n        }\\n        return regularbin(nums,target,pivot+1,nums.length-1);\\n    }\\n    public static int regularbin(int[] nums,int target,int start,int end){\\n            int mid = 0;\\n            while (start<=end){\\n                mid = start+(end-start)/2;\\n                if(target>nums[mid]){\\n                    start=mid+1;\\n                }\\n                else if(target<nums[mid]){\\n                    end = mid-1;\\n                }\\n                else{\\n                    return mid;\\n                }\\n            }\\n            return -1;\\n    }\\n    public static int findpiv(int[] nums){\\n        int start  = 0;\\n        int end = nums.length-1;\\n        int mid =0;\\n        while (start<=end){\\n            mid = start+(end-start)/2;\\n            if(mid<end && nums[mid]>nums[mid+1]){\\n                return mid;\\n            }\\n            if(start<mid && nums[mid-1]>nums[mid]){\\n                return mid-1;\\n            }\\n            if(nums[start]>nums[mid]){\\n                end  = mid-1;\\n            }\\n            else {\\n                start = mid+1;\\n            }\\n        }\\n        return -1;\\n    }\\n}\\n\\nof any comments please comment down\\n"
                    },
                    {
                        "username": "Dastagir_Mulani_101",
                        "content": "Even solution with linear search i.e. O(n) is getting accepted, this should not happen isn\\'t it?? The problem makers should change the problem solution so it can accept only solution with O(log n) complexity otherwise should give TLE."
                    },
                    {
                        "username": "hb_134",
                        "content": "Why we do not use this ->  `sort(nums.begin(), nums.end());`\\nI know then the time complexity will increase but just ignore that part why we do not use this??\\n\\nPlease discuss with me in this part :)"
                    },
                    {
                        "username": "psionl0",
                        "content": "You are required to return the position of target. Sorting an array will change the position of its elements. You can do this but you will need to keep track of the original positions of the elements which will complicate the exercise."
                    },
                    {
                        "username": "bparanj",
                        "content": "Sorting an array is often a useful operation when you want to organize the data in a certain order, typically either ascending or descending. However, there are several reasons why you might not want to sort the array in the context of a particular problem.\\n\\n1. Preserving original order: Many problems require you to preserve the original order of elements in the array. Sorting the array would destroy this original order.\\n\\n2. Time complexity: As you mentioned, sorting an array has a time complexity of at least O(n log n) for most standard sorting algorithms. This could make your solution too slow if the input array is large.\\n\\n3. Space complexity: Sorting algorithms often require additional space. For example, the commonly used quicksort and mergesort algorithms are not in-place and need O(n) extra space.\\n\\n4. Problem Constraints: Sometimes, the problem statement specifically asks you not to sort the array or assumes that you\\'re working with an unsorted array.\\n\\n5. Changing the nature of the problem: Sometimes sorting an array could fundamentally change the nature of the problem you\\'re trying to solve.\\n\\nIn the context of the problem of searching in a rotated sorted array, sorting the array first would defeat the purpose of the problem. The challenge is to leverage the fact that the array is rotated and sorted to achieve a faster search time, ideally O(log n) which is possible with binary search. If you sort the array first, you would destroy the rotation and any information it might provide. Furthermore, you would still have to search through the sorted array, which would take O(log n) time with binary search, and when combined with the sorting step, would increase the overall time complexity of the solution."
                    },
                    {
                        "username": "iamvasusingh_",
                        "content": "why is my solution not working for [3,1] nums vector ?\n int search(vector<int>& nums, int target) {\n        int start=0;\n        int end=nums.size()-1;\n         while(start <= end)\n         {\n             int mid=(start + end)/2;\n            if(target == nums[mid])\n            {\n                return mid;\n            }\n            if(nums[start] < nums[mid])\n            {\n              if(target >= nums[start] && target<nums[mid])\n              {\n                  end=mid-1;\n              }\n              else\n             {\n               start=mid+1;\n             }\n            }\n            else\n            {\n                if(target > nums[mid] && target <= nums[end])\n                {\n                    start=mid+1;\n                }\n                else\n                {\n                    end=mid-1;\n                }\n            }\n         }\n         return -1;\n    }"
                    },
                    {
                        "username": "bparanj",
                        "content": "The code you provided is designed to handle a rotated sorted array. In the array [3, 1], the pivot point is at index 0, thus making the condition `nums[start] < nums[mid]` fail when `start` and `mid` are both 0.\\n\\nThis occurs because the array is only of length 2, and the element at the `start` and `mid` index is larger than the element at the `end` index. Your code, however, expects that for the first part of the array (`nums[start]` to `nums[mid]`), it will be in sorted order. But due to the pivot at index 0, this is not the case.\\n\\nTo fix this, you can include a check for when `start` and `mid` are equal:\\n\\n```cpp\\nint search(vector<int>& nums, int target) {\\n    int start=0;\\n    int end=nums.size()-1;\\n    while(start <= end)\\n    {\\n        int mid=(start + end)/2;\\n        if(target == nums[mid])\\n        {\\n            return mid;\\n        }\\n        if(nums[start] <= nums[mid]) // change < to <=\\n        {\\n            if(target >= nums[start] && target<nums[mid])\\n            {\\n                end=mid-1;\\n            }\\n            else\\n            {\\n                start=mid+1;\\n            }\\n        }\\n        else\\n        {\\n            if(target > nums[mid] && target <= nums[end])\\n            {\\n                start=mid+1;\\n            }\\n            else\\n            {\\n                end=mid-1;\\n            }\\n        }\\n    }\\n    return -1;\\n}\\n```\\nThis modification handles the case where the pivot is at the start index. Now, if `start` equals `mid` and `nums[start]` is not less than `nums[mid]`, it will still check if the target is within the first half of the array. This is suitable for arrays like [3,1] where the pivot is at the start of the array."
                    },
                    {
                        "username": "peaceTea",
                        "content": "I hate this question!!\\ngetting index out of bound error for some reason for finding the rotate index. absolutely crap"
                    },
                    {
                        "username": "nadeemmi313",
                        "content": "I apply linear search on this problem but it's not showing me Time Limit Exceed error. how it is possible . all test cases are successfully executed. "
                    },
                    {
                        "username": "AnkushR10",
                        "content": "https://github.com/AnkushRawat10601/Leetcode/blob/main/33_search_in_rotated_sorted_array.cpp"
                    },
                    {
                        "username": "alex_lanes",
                        "content": "Is this considered a O(log n) solutuion or a O(n/2) ? \\n\\n```/**\\n * @param  {number[]} nums\\n * @param  {number} target\\n * @return {number}\\n */\\nvar search = function( nums, target ){\\n    let first = 0,\\n        middle = Math.floor( nums.length / 2 ),\\n        last = nums.length - 1,\\n        indexOfTarget = ( start, end ) => {\\n            for( let index = start; index <= end; index++ ) if( nums[index] == target ) return index\\n            return -1\\n        },\\n        // [7,8,1,2,3,4,5,6] => right[ 3, 4, 5, 6 ] => [4, 7]\\n        sorted_indexes = ( nums[first] < nums[middle] ) ? [first, middle] : [middle + 1, last],\\n        // left[ 7, 8, 1, 2 ] => [0, 3]\\n        unsorted_indexes = sorted_indexes[0] != first && sorted_indexes[0] != middle ? [first, middle] : [middle + 1, last]\\n        // target = 2 in right[ 3, 4, 5, 6 ] ? false\\n        inSortedSide = nums[ sorted_indexes[0] ] <= target && target <= nums[ sorted_indexes[1] ]\\n\\n    if( nums[first] == target )         return first\\n    else if( nums[middle] == target )   return middle\\n    else if( nums[last] == target )     return last\\n    else if( inSortedSide )             return indexOfTarget( sorted_indexes[0], sorted_indexes[1] )\\n    else /* !inSortedSide */            return indexOfTarget( unsorted_indexes[0], unsorted_indexes[1] )\\n};"
                    },
                    {
                        "username": "bparanj",
                        "content": "This solution is neither O(log n) nor O(n/2). This solution is O(n) in the worst case scenario.\\n\\nThe reason for this is due to the `indexOfTarget` function. In the worst-case scenario, this function will iterate through roughly half of the elements in the array, which gives a time complexity of O(n).\\n\\nFor example, consider a case where the target value is at the end of the unsorted half of the array. The `indexOfTarget` function will need to iterate over all elements in the unsorted half, which can be up to n/2 elements. Because we drop constants in Big O notation, the time complexity of this function is O(n), not O(n/2).\\n\\nRemember, O(log n) complexity typically implies that you\\'re dividing the problem in half (or any constant fraction) with each step, such as in a binary search. O(n) complexity implies that you have to potentially check every element, which is what the `indexOfTarget` function is doing. Despite the initial checks and divisions of the array, the linear search performed by `indexOfTarget` dominates the time complexity of your solution. \\n\\nTo achieve O(log n) complexity for this problem, you would typically perform a modified binary search, adjusting the high and low points of your search based on the target and the median value, without scanning the array linearly."
                    },
                    {
                        "username": "tanmoy069",
                        "content": "why passed all the testcases with O(n) solution?"
                    },
                    {
                        "username": "Sri_Ram_194",
                        "content": "I think it is the best one in which just checking the each element in the array in which by taking the rotating the index, if nums[i]==given target then,,,\\nfor(int i=0;i<nums.length;i++)\\n        {\\n            if(nums[i]==target)\\n            {\\n                return i;\\n            }\\n        }\\n        return -1;"
                    }
                ]
            },
            {
                "id": 1716536,
                "content": [
                    {
                        "username": "Srivamsi_Dandu",
                        "content": "class Solution {\\n    public static int search(int[] nums, int target){\\n        int pivot = findpiv(nums);\\n        System.out.println(\"pivot is\"+pivot);\\n        if(pivot==-1){\\n            return regularbin(nums,target,0,nums.length-1);\\n        }\\n        if(nums[pivot]==target){\\n            return pivot;\\n        }\\n        if(target>=nums[0]){\\n            return regularbin(nums,target,0,pivot-1);\\n        }\\n        return regularbin(nums,target,pivot+1,nums.length-1);\\n    }\\n    public static int regularbin(int[] nums,int target,int start,int end){\\n            int mid = 0;\\n            while (start<=end){\\n                mid = start+(end-start)/2;\\n                if(target>nums[mid]){\\n                    start=mid+1;\\n                }\\n                else if(target<nums[mid]){\\n                    end = mid-1;\\n                }\\n                else{\\n                    return mid;\\n                }\\n            }\\n            return -1;\\n    }\\n    public static int findpiv(int[] nums){\\n        int start  = 0;\\n        int end = nums.length-1;\\n        int mid =0;\\n        while (start<=end){\\n            mid = start+(end-start)/2;\\n            if(mid<end && nums[mid]>nums[mid+1]){\\n                return mid;\\n            }\\n            if(start<mid && nums[mid-1]>nums[mid]){\\n                return mid-1;\\n            }\\n            if(nums[start]>nums[mid]){\\n                end  = mid-1;\\n            }\\n            else {\\n                start = mid+1;\\n            }\\n        }\\n        return -1;\\n    }\\n}\\n\\nof any comments please comment down\\n"
                    },
                    {
                        "username": "Dastagir_Mulani_101",
                        "content": "Even solution with linear search i.e. O(n) is getting accepted, this should not happen isn\\'t it?? The problem makers should change the problem solution so it can accept only solution with O(log n) complexity otherwise should give TLE."
                    },
                    {
                        "username": "hb_134",
                        "content": "Why we do not use this ->  `sort(nums.begin(), nums.end());`\\nI know then the time complexity will increase but just ignore that part why we do not use this??\\n\\nPlease discuss with me in this part :)"
                    },
                    {
                        "username": "psionl0",
                        "content": "You are required to return the position of target. Sorting an array will change the position of its elements. You can do this but you will need to keep track of the original positions of the elements which will complicate the exercise."
                    },
                    {
                        "username": "bparanj",
                        "content": "Sorting an array is often a useful operation when you want to organize the data in a certain order, typically either ascending or descending. However, there are several reasons why you might not want to sort the array in the context of a particular problem.\\n\\n1. Preserving original order: Many problems require you to preserve the original order of elements in the array. Sorting the array would destroy this original order.\\n\\n2. Time complexity: As you mentioned, sorting an array has a time complexity of at least O(n log n) for most standard sorting algorithms. This could make your solution too slow if the input array is large.\\n\\n3. Space complexity: Sorting algorithms often require additional space. For example, the commonly used quicksort and mergesort algorithms are not in-place and need O(n) extra space.\\n\\n4. Problem Constraints: Sometimes, the problem statement specifically asks you not to sort the array or assumes that you\\'re working with an unsorted array.\\n\\n5. Changing the nature of the problem: Sometimes sorting an array could fundamentally change the nature of the problem you\\'re trying to solve.\\n\\nIn the context of the problem of searching in a rotated sorted array, sorting the array first would defeat the purpose of the problem. The challenge is to leverage the fact that the array is rotated and sorted to achieve a faster search time, ideally O(log n) which is possible with binary search. If you sort the array first, you would destroy the rotation and any information it might provide. Furthermore, you would still have to search through the sorted array, which would take O(log n) time with binary search, and when combined with the sorting step, would increase the overall time complexity of the solution."
                    },
                    {
                        "username": "iamvasusingh_",
                        "content": "why is my solution not working for [3,1] nums vector ?\n int search(vector<int>& nums, int target) {\n        int start=0;\n        int end=nums.size()-1;\n         while(start <= end)\n         {\n             int mid=(start + end)/2;\n            if(target == nums[mid])\n            {\n                return mid;\n            }\n            if(nums[start] < nums[mid])\n            {\n              if(target >= nums[start] && target<nums[mid])\n              {\n                  end=mid-1;\n              }\n              else\n             {\n               start=mid+1;\n             }\n            }\n            else\n            {\n                if(target > nums[mid] && target <= nums[end])\n                {\n                    start=mid+1;\n                }\n                else\n                {\n                    end=mid-1;\n                }\n            }\n         }\n         return -1;\n    }"
                    },
                    {
                        "username": "bparanj",
                        "content": "The code you provided is designed to handle a rotated sorted array. In the array [3, 1], the pivot point is at index 0, thus making the condition `nums[start] < nums[mid]` fail when `start` and `mid` are both 0.\\n\\nThis occurs because the array is only of length 2, and the element at the `start` and `mid` index is larger than the element at the `end` index. Your code, however, expects that for the first part of the array (`nums[start]` to `nums[mid]`), it will be in sorted order. But due to the pivot at index 0, this is not the case.\\n\\nTo fix this, you can include a check for when `start` and `mid` are equal:\\n\\n```cpp\\nint search(vector<int>& nums, int target) {\\n    int start=0;\\n    int end=nums.size()-1;\\n    while(start <= end)\\n    {\\n        int mid=(start + end)/2;\\n        if(target == nums[mid])\\n        {\\n            return mid;\\n        }\\n        if(nums[start] <= nums[mid]) // change < to <=\\n        {\\n            if(target >= nums[start] && target<nums[mid])\\n            {\\n                end=mid-1;\\n            }\\n            else\\n            {\\n                start=mid+1;\\n            }\\n        }\\n        else\\n        {\\n            if(target > nums[mid] && target <= nums[end])\\n            {\\n                start=mid+1;\\n            }\\n            else\\n            {\\n                end=mid-1;\\n            }\\n        }\\n    }\\n    return -1;\\n}\\n```\\nThis modification handles the case where the pivot is at the start index. Now, if `start` equals `mid` and `nums[start]` is not less than `nums[mid]`, it will still check if the target is within the first half of the array. This is suitable for arrays like [3,1] where the pivot is at the start of the array."
                    },
                    {
                        "username": "peaceTea",
                        "content": "I hate this question!!\\ngetting index out of bound error for some reason for finding the rotate index. absolutely crap"
                    },
                    {
                        "username": "nadeemmi313",
                        "content": "I apply linear search on this problem but it's not showing me Time Limit Exceed error. how it is possible . all test cases are successfully executed. "
                    },
                    {
                        "username": "AnkushR10",
                        "content": "https://github.com/AnkushRawat10601/Leetcode/blob/main/33_search_in_rotated_sorted_array.cpp"
                    },
                    {
                        "username": "alex_lanes",
                        "content": "Is this considered a O(log n) solutuion or a O(n/2) ? \\n\\n```/**\\n * @param  {number[]} nums\\n * @param  {number} target\\n * @return {number}\\n */\\nvar search = function( nums, target ){\\n    let first = 0,\\n        middle = Math.floor( nums.length / 2 ),\\n        last = nums.length - 1,\\n        indexOfTarget = ( start, end ) => {\\n            for( let index = start; index <= end; index++ ) if( nums[index] == target ) return index\\n            return -1\\n        },\\n        // [7,8,1,2,3,4,5,6] => right[ 3, 4, 5, 6 ] => [4, 7]\\n        sorted_indexes = ( nums[first] < nums[middle] ) ? [first, middle] : [middle + 1, last],\\n        // left[ 7, 8, 1, 2 ] => [0, 3]\\n        unsorted_indexes = sorted_indexes[0] != first && sorted_indexes[0] != middle ? [first, middle] : [middle + 1, last]\\n        // target = 2 in right[ 3, 4, 5, 6 ] ? false\\n        inSortedSide = nums[ sorted_indexes[0] ] <= target && target <= nums[ sorted_indexes[1] ]\\n\\n    if( nums[first] == target )         return first\\n    else if( nums[middle] == target )   return middle\\n    else if( nums[last] == target )     return last\\n    else if( inSortedSide )             return indexOfTarget( sorted_indexes[0], sorted_indexes[1] )\\n    else /* !inSortedSide */            return indexOfTarget( unsorted_indexes[0], unsorted_indexes[1] )\\n};"
                    },
                    {
                        "username": "bparanj",
                        "content": "This solution is neither O(log n) nor O(n/2). This solution is O(n) in the worst case scenario.\\n\\nThe reason for this is due to the `indexOfTarget` function. In the worst-case scenario, this function will iterate through roughly half of the elements in the array, which gives a time complexity of O(n).\\n\\nFor example, consider a case where the target value is at the end of the unsorted half of the array. The `indexOfTarget` function will need to iterate over all elements in the unsorted half, which can be up to n/2 elements. Because we drop constants in Big O notation, the time complexity of this function is O(n), not O(n/2).\\n\\nRemember, O(log n) complexity typically implies that you\\'re dividing the problem in half (or any constant fraction) with each step, such as in a binary search. O(n) complexity implies that you have to potentially check every element, which is what the `indexOfTarget` function is doing. Despite the initial checks and divisions of the array, the linear search performed by `indexOfTarget` dominates the time complexity of your solution. \\n\\nTo achieve O(log n) complexity for this problem, you would typically perform a modified binary search, adjusting the high and low points of your search based on the target and the median value, without scanning the array linearly."
                    },
                    {
                        "username": "tanmoy069",
                        "content": "why passed all the testcases with O(n) solution?"
                    },
                    {
                        "username": "Sri_Ram_194",
                        "content": "I think it is the best one in which just checking the each element in the array in which by taking the rotating the index, if nums[i]==given target then,,,\\nfor(int i=0;i<nums.length;i++)\\n        {\\n            if(nums[i]==target)\\n            {\\n                return i;\\n            }\\n        }\\n        return -1;"
                    }
                ]
            },
            {
                "id": 1715179,
                "content": [
                    {
                        "username": "Srivamsi_Dandu",
                        "content": "class Solution {\\n    public static int search(int[] nums, int target){\\n        int pivot = findpiv(nums);\\n        System.out.println(\"pivot is\"+pivot);\\n        if(pivot==-1){\\n            return regularbin(nums,target,0,nums.length-1);\\n        }\\n        if(nums[pivot]==target){\\n            return pivot;\\n        }\\n        if(target>=nums[0]){\\n            return regularbin(nums,target,0,pivot-1);\\n        }\\n        return regularbin(nums,target,pivot+1,nums.length-1);\\n    }\\n    public static int regularbin(int[] nums,int target,int start,int end){\\n            int mid = 0;\\n            while (start<=end){\\n                mid = start+(end-start)/2;\\n                if(target>nums[mid]){\\n                    start=mid+1;\\n                }\\n                else if(target<nums[mid]){\\n                    end = mid-1;\\n                }\\n                else{\\n                    return mid;\\n                }\\n            }\\n            return -1;\\n    }\\n    public static int findpiv(int[] nums){\\n        int start  = 0;\\n        int end = nums.length-1;\\n        int mid =0;\\n        while (start<=end){\\n            mid = start+(end-start)/2;\\n            if(mid<end && nums[mid]>nums[mid+1]){\\n                return mid;\\n            }\\n            if(start<mid && nums[mid-1]>nums[mid]){\\n                return mid-1;\\n            }\\n            if(nums[start]>nums[mid]){\\n                end  = mid-1;\\n            }\\n            else {\\n                start = mid+1;\\n            }\\n        }\\n        return -1;\\n    }\\n}\\n\\nof any comments please comment down\\n"
                    },
                    {
                        "username": "Dastagir_Mulani_101",
                        "content": "Even solution with linear search i.e. O(n) is getting accepted, this should not happen isn\\'t it?? The problem makers should change the problem solution so it can accept only solution with O(log n) complexity otherwise should give TLE."
                    },
                    {
                        "username": "hb_134",
                        "content": "Why we do not use this ->  `sort(nums.begin(), nums.end());`\\nI know then the time complexity will increase but just ignore that part why we do not use this??\\n\\nPlease discuss with me in this part :)"
                    },
                    {
                        "username": "psionl0",
                        "content": "You are required to return the position of target. Sorting an array will change the position of its elements. You can do this but you will need to keep track of the original positions of the elements which will complicate the exercise."
                    },
                    {
                        "username": "bparanj",
                        "content": "Sorting an array is often a useful operation when you want to organize the data in a certain order, typically either ascending or descending. However, there are several reasons why you might not want to sort the array in the context of a particular problem.\\n\\n1. Preserving original order: Many problems require you to preserve the original order of elements in the array. Sorting the array would destroy this original order.\\n\\n2. Time complexity: As you mentioned, sorting an array has a time complexity of at least O(n log n) for most standard sorting algorithms. This could make your solution too slow if the input array is large.\\n\\n3. Space complexity: Sorting algorithms often require additional space. For example, the commonly used quicksort and mergesort algorithms are not in-place and need O(n) extra space.\\n\\n4. Problem Constraints: Sometimes, the problem statement specifically asks you not to sort the array or assumes that you\\'re working with an unsorted array.\\n\\n5. Changing the nature of the problem: Sometimes sorting an array could fundamentally change the nature of the problem you\\'re trying to solve.\\n\\nIn the context of the problem of searching in a rotated sorted array, sorting the array first would defeat the purpose of the problem. The challenge is to leverage the fact that the array is rotated and sorted to achieve a faster search time, ideally O(log n) which is possible with binary search. If you sort the array first, you would destroy the rotation and any information it might provide. Furthermore, you would still have to search through the sorted array, which would take O(log n) time with binary search, and when combined with the sorting step, would increase the overall time complexity of the solution."
                    },
                    {
                        "username": "iamvasusingh_",
                        "content": "why is my solution not working for [3,1] nums vector ?\n int search(vector<int>& nums, int target) {\n        int start=0;\n        int end=nums.size()-1;\n         while(start <= end)\n         {\n             int mid=(start + end)/2;\n            if(target == nums[mid])\n            {\n                return mid;\n            }\n            if(nums[start] < nums[mid])\n            {\n              if(target >= nums[start] && target<nums[mid])\n              {\n                  end=mid-1;\n              }\n              else\n             {\n               start=mid+1;\n             }\n            }\n            else\n            {\n                if(target > nums[mid] && target <= nums[end])\n                {\n                    start=mid+1;\n                }\n                else\n                {\n                    end=mid-1;\n                }\n            }\n         }\n         return -1;\n    }"
                    },
                    {
                        "username": "bparanj",
                        "content": "The code you provided is designed to handle a rotated sorted array. In the array [3, 1], the pivot point is at index 0, thus making the condition `nums[start] < nums[mid]` fail when `start` and `mid` are both 0.\\n\\nThis occurs because the array is only of length 2, and the element at the `start` and `mid` index is larger than the element at the `end` index. Your code, however, expects that for the first part of the array (`nums[start]` to `nums[mid]`), it will be in sorted order. But due to the pivot at index 0, this is not the case.\\n\\nTo fix this, you can include a check for when `start` and `mid` are equal:\\n\\n```cpp\\nint search(vector<int>& nums, int target) {\\n    int start=0;\\n    int end=nums.size()-1;\\n    while(start <= end)\\n    {\\n        int mid=(start + end)/2;\\n        if(target == nums[mid])\\n        {\\n            return mid;\\n        }\\n        if(nums[start] <= nums[mid]) // change < to <=\\n        {\\n            if(target >= nums[start] && target<nums[mid])\\n            {\\n                end=mid-1;\\n            }\\n            else\\n            {\\n                start=mid+1;\\n            }\\n        }\\n        else\\n        {\\n            if(target > nums[mid] && target <= nums[end])\\n            {\\n                start=mid+1;\\n            }\\n            else\\n            {\\n                end=mid-1;\\n            }\\n        }\\n    }\\n    return -1;\\n}\\n```\\nThis modification handles the case where the pivot is at the start index. Now, if `start` equals `mid` and `nums[start]` is not less than `nums[mid]`, it will still check if the target is within the first half of the array. This is suitable for arrays like [3,1] where the pivot is at the start of the array."
                    },
                    {
                        "username": "peaceTea",
                        "content": "I hate this question!!\\ngetting index out of bound error for some reason for finding the rotate index. absolutely crap"
                    },
                    {
                        "username": "nadeemmi313",
                        "content": "I apply linear search on this problem but it's not showing me Time Limit Exceed error. how it is possible . all test cases are successfully executed. "
                    },
                    {
                        "username": "AnkushR10",
                        "content": "https://github.com/AnkushRawat10601/Leetcode/blob/main/33_search_in_rotated_sorted_array.cpp"
                    },
                    {
                        "username": "alex_lanes",
                        "content": "Is this considered a O(log n) solutuion or a O(n/2) ? \\n\\n```/**\\n * @param  {number[]} nums\\n * @param  {number} target\\n * @return {number}\\n */\\nvar search = function( nums, target ){\\n    let first = 0,\\n        middle = Math.floor( nums.length / 2 ),\\n        last = nums.length - 1,\\n        indexOfTarget = ( start, end ) => {\\n            for( let index = start; index <= end; index++ ) if( nums[index] == target ) return index\\n            return -1\\n        },\\n        // [7,8,1,2,3,4,5,6] => right[ 3, 4, 5, 6 ] => [4, 7]\\n        sorted_indexes = ( nums[first] < nums[middle] ) ? [first, middle] : [middle + 1, last],\\n        // left[ 7, 8, 1, 2 ] => [0, 3]\\n        unsorted_indexes = sorted_indexes[0] != first && sorted_indexes[0] != middle ? [first, middle] : [middle + 1, last]\\n        // target = 2 in right[ 3, 4, 5, 6 ] ? false\\n        inSortedSide = nums[ sorted_indexes[0] ] <= target && target <= nums[ sorted_indexes[1] ]\\n\\n    if( nums[first] == target )         return first\\n    else if( nums[middle] == target )   return middle\\n    else if( nums[last] == target )     return last\\n    else if( inSortedSide )             return indexOfTarget( sorted_indexes[0], sorted_indexes[1] )\\n    else /* !inSortedSide */            return indexOfTarget( unsorted_indexes[0], unsorted_indexes[1] )\\n};"
                    },
                    {
                        "username": "bparanj",
                        "content": "This solution is neither O(log n) nor O(n/2). This solution is O(n) in the worst case scenario.\\n\\nThe reason for this is due to the `indexOfTarget` function. In the worst-case scenario, this function will iterate through roughly half of the elements in the array, which gives a time complexity of O(n).\\n\\nFor example, consider a case where the target value is at the end of the unsorted half of the array. The `indexOfTarget` function will need to iterate over all elements in the unsorted half, which can be up to n/2 elements. Because we drop constants in Big O notation, the time complexity of this function is O(n), not O(n/2).\\n\\nRemember, O(log n) complexity typically implies that you\\'re dividing the problem in half (or any constant fraction) with each step, such as in a binary search. O(n) complexity implies that you have to potentially check every element, which is what the `indexOfTarget` function is doing. Despite the initial checks and divisions of the array, the linear search performed by `indexOfTarget` dominates the time complexity of your solution. \\n\\nTo achieve O(log n) complexity for this problem, you would typically perform a modified binary search, adjusting the high and low points of your search based on the target and the median value, without scanning the array linearly."
                    },
                    {
                        "username": "tanmoy069",
                        "content": "why passed all the testcases with O(n) solution?"
                    },
                    {
                        "username": "Sri_Ram_194",
                        "content": "I think it is the best one in which just checking the each element in the array in which by taking the rotating the index, if nums[i]==given target then,,,\\nfor(int i=0;i<nums.length;i++)\\n        {\\n            if(nums[i]==target)\\n            {\\n                return i;\\n            }\\n        }\\n        return -1;"
                    }
                ]
            },
            {
                "id": 1713408,
                "content": [
                    {
                        "username": "Srivamsi_Dandu",
                        "content": "class Solution {\\n    public static int search(int[] nums, int target){\\n        int pivot = findpiv(nums);\\n        System.out.println(\"pivot is\"+pivot);\\n        if(pivot==-1){\\n            return regularbin(nums,target,0,nums.length-1);\\n        }\\n        if(nums[pivot]==target){\\n            return pivot;\\n        }\\n        if(target>=nums[0]){\\n            return regularbin(nums,target,0,pivot-1);\\n        }\\n        return regularbin(nums,target,pivot+1,nums.length-1);\\n    }\\n    public static int regularbin(int[] nums,int target,int start,int end){\\n            int mid = 0;\\n            while (start<=end){\\n                mid = start+(end-start)/2;\\n                if(target>nums[mid]){\\n                    start=mid+1;\\n                }\\n                else if(target<nums[mid]){\\n                    end = mid-1;\\n                }\\n                else{\\n                    return mid;\\n                }\\n            }\\n            return -1;\\n    }\\n    public static int findpiv(int[] nums){\\n        int start  = 0;\\n        int end = nums.length-1;\\n        int mid =0;\\n        while (start<=end){\\n            mid = start+(end-start)/2;\\n            if(mid<end && nums[mid]>nums[mid+1]){\\n                return mid;\\n            }\\n            if(start<mid && nums[mid-1]>nums[mid]){\\n                return mid-1;\\n            }\\n            if(nums[start]>nums[mid]){\\n                end  = mid-1;\\n            }\\n            else {\\n                start = mid+1;\\n            }\\n        }\\n        return -1;\\n    }\\n}\\n\\nof any comments please comment down\\n"
                    },
                    {
                        "username": "Dastagir_Mulani_101",
                        "content": "Even solution with linear search i.e. O(n) is getting accepted, this should not happen isn\\'t it?? The problem makers should change the problem solution so it can accept only solution with O(log n) complexity otherwise should give TLE."
                    },
                    {
                        "username": "hb_134",
                        "content": "Why we do not use this ->  `sort(nums.begin(), nums.end());`\\nI know then the time complexity will increase but just ignore that part why we do not use this??\\n\\nPlease discuss with me in this part :)"
                    },
                    {
                        "username": "psionl0",
                        "content": "You are required to return the position of target. Sorting an array will change the position of its elements. You can do this but you will need to keep track of the original positions of the elements which will complicate the exercise."
                    },
                    {
                        "username": "bparanj",
                        "content": "Sorting an array is often a useful operation when you want to organize the data in a certain order, typically either ascending or descending. However, there are several reasons why you might not want to sort the array in the context of a particular problem.\\n\\n1. Preserving original order: Many problems require you to preserve the original order of elements in the array. Sorting the array would destroy this original order.\\n\\n2. Time complexity: As you mentioned, sorting an array has a time complexity of at least O(n log n) for most standard sorting algorithms. This could make your solution too slow if the input array is large.\\n\\n3. Space complexity: Sorting algorithms often require additional space. For example, the commonly used quicksort and mergesort algorithms are not in-place and need O(n) extra space.\\n\\n4. Problem Constraints: Sometimes, the problem statement specifically asks you not to sort the array or assumes that you\\'re working with an unsorted array.\\n\\n5. Changing the nature of the problem: Sometimes sorting an array could fundamentally change the nature of the problem you\\'re trying to solve.\\n\\nIn the context of the problem of searching in a rotated sorted array, sorting the array first would defeat the purpose of the problem. The challenge is to leverage the fact that the array is rotated and sorted to achieve a faster search time, ideally O(log n) which is possible with binary search. If you sort the array first, you would destroy the rotation and any information it might provide. Furthermore, you would still have to search through the sorted array, which would take O(log n) time with binary search, and when combined with the sorting step, would increase the overall time complexity of the solution."
                    },
                    {
                        "username": "iamvasusingh_",
                        "content": "why is my solution not working for [3,1] nums vector ?\n int search(vector<int>& nums, int target) {\n        int start=0;\n        int end=nums.size()-1;\n         while(start <= end)\n         {\n             int mid=(start + end)/2;\n            if(target == nums[mid])\n            {\n                return mid;\n            }\n            if(nums[start] < nums[mid])\n            {\n              if(target >= nums[start] && target<nums[mid])\n              {\n                  end=mid-1;\n              }\n              else\n             {\n               start=mid+1;\n             }\n            }\n            else\n            {\n                if(target > nums[mid] && target <= nums[end])\n                {\n                    start=mid+1;\n                }\n                else\n                {\n                    end=mid-1;\n                }\n            }\n         }\n         return -1;\n    }"
                    },
                    {
                        "username": "bparanj",
                        "content": "The code you provided is designed to handle a rotated sorted array. In the array [3, 1], the pivot point is at index 0, thus making the condition `nums[start] < nums[mid]` fail when `start` and `mid` are both 0.\\n\\nThis occurs because the array is only of length 2, and the element at the `start` and `mid` index is larger than the element at the `end` index. Your code, however, expects that for the first part of the array (`nums[start]` to `nums[mid]`), it will be in sorted order. But due to the pivot at index 0, this is not the case.\\n\\nTo fix this, you can include a check for when `start` and `mid` are equal:\\n\\n```cpp\\nint search(vector<int>& nums, int target) {\\n    int start=0;\\n    int end=nums.size()-1;\\n    while(start <= end)\\n    {\\n        int mid=(start + end)/2;\\n        if(target == nums[mid])\\n        {\\n            return mid;\\n        }\\n        if(nums[start] <= nums[mid]) // change < to <=\\n        {\\n            if(target >= nums[start] && target<nums[mid])\\n            {\\n                end=mid-1;\\n            }\\n            else\\n            {\\n                start=mid+1;\\n            }\\n        }\\n        else\\n        {\\n            if(target > nums[mid] && target <= nums[end])\\n            {\\n                start=mid+1;\\n            }\\n            else\\n            {\\n                end=mid-1;\\n            }\\n        }\\n    }\\n    return -1;\\n}\\n```\\nThis modification handles the case where the pivot is at the start index. Now, if `start` equals `mid` and `nums[start]` is not less than `nums[mid]`, it will still check if the target is within the first half of the array. This is suitable for arrays like [3,1] where the pivot is at the start of the array."
                    },
                    {
                        "username": "peaceTea",
                        "content": "I hate this question!!\\ngetting index out of bound error for some reason for finding the rotate index. absolutely crap"
                    },
                    {
                        "username": "nadeemmi313",
                        "content": "I apply linear search on this problem but it's not showing me Time Limit Exceed error. how it is possible . all test cases are successfully executed. "
                    },
                    {
                        "username": "AnkushR10",
                        "content": "https://github.com/AnkushRawat10601/Leetcode/blob/main/33_search_in_rotated_sorted_array.cpp"
                    },
                    {
                        "username": "alex_lanes",
                        "content": "Is this considered a O(log n) solutuion or a O(n/2) ? \\n\\n```/**\\n * @param  {number[]} nums\\n * @param  {number} target\\n * @return {number}\\n */\\nvar search = function( nums, target ){\\n    let first = 0,\\n        middle = Math.floor( nums.length / 2 ),\\n        last = nums.length - 1,\\n        indexOfTarget = ( start, end ) => {\\n            for( let index = start; index <= end; index++ ) if( nums[index] == target ) return index\\n            return -1\\n        },\\n        // [7,8,1,2,3,4,5,6] => right[ 3, 4, 5, 6 ] => [4, 7]\\n        sorted_indexes = ( nums[first] < nums[middle] ) ? [first, middle] : [middle + 1, last],\\n        // left[ 7, 8, 1, 2 ] => [0, 3]\\n        unsorted_indexes = sorted_indexes[0] != first && sorted_indexes[0] != middle ? [first, middle] : [middle + 1, last]\\n        // target = 2 in right[ 3, 4, 5, 6 ] ? false\\n        inSortedSide = nums[ sorted_indexes[0] ] <= target && target <= nums[ sorted_indexes[1] ]\\n\\n    if( nums[first] == target )         return first\\n    else if( nums[middle] == target )   return middle\\n    else if( nums[last] == target )     return last\\n    else if( inSortedSide )             return indexOfTarget( sorted_indexes[0], sorted_indexes[1] )\\n    else /* !inSortedSide */            return indexOfTarget( unsorted_indexes[0], unsorted_indexes[1] )\\n};"
                    },
                    {
                        "username": "bparanj",
                        "content": "This solution is neither O(log n) nor O(n/2). This solution is O(n) in the worst case scenario.\\n\\nThe reason for this is due to the `indexOfTarget` function. In the worst-case scenario, this function will iterate through roughly half of the elements in the array, which gives a time complexity of O(n).\\n\\nFor example, consider a case where the target value is at the end of the unsorted half of the array. The `indexOfTarget` function will need to iterate over all elements in the unsorted half, which can be up to n/2 elements. Because we drop constants in Big O notation, the time complexity of this function is O(n), not O(n/2).\\n\\nRemember, O(log n) complexity typically implies that you\\'re dividing the problem in half (or any constant fraction) with each step, such as in a binary search. O(n) complexity implies that you have to potentially check every element, which is what the `indexOfTarget` function is doing. Despite the initial checks and divisions of the array, the linear search performed by `indexOfTarget` dominates the time complexity of your solution. \\n\\nTo achieve O(log n) complexity for this problem, you would typically perform a modified binary search, adjusting the high and low points of your search based on the target and the median value, without scanning the array linearly."
                    },
                    {
                        "username": "tanmoy069",
                        "content": "why passed all the testcases with O(n) solution?"
                    },
                    {
                        "username": "Sri_Ram_194",
                        "content": "I think it is the best one in which just checking the each element in the array in which by taking the rotating the index, if nums[i]==given target then,,,\\nfor(int i=0;i<nums.length;i++)\\n        {\\n            if(nums[i]==target)\\n            {\\n                return i;\\n            }\\n        }\\n        return -1;"
                    }
                ]
            },
            {
                "id": 1708843,
                "content": [
                    {
                        "username": "imvillen69",
                        "content": "Help me to debug this code .\\nclass Solution {\\npublic:\\n    int search(vector<int>& nums, int target) {\\n        int l = 0,h = nums.size() - 1;\\n        while(l <= h){\\n        int m = (l + (h - l))>>1;\\n        if(nums[m] == target)\\n            return m;\\n//left half is sorted.\\n        if(nums[l] <= nums[m])\\n        {\\n            if(target >= nums[l] && target <= nums[m]) //lies in range ..\\n            h = m - 1;\\n            else\\n            l = m + 1;\\n        }\\n//right half is sorted.\\n        else\\n        {\\n           if(target >= nums[m] && target <= nums[h]) // lies in range..\\n            l = m + 1;\\n            else\\n            h = m - 1; \\n        }\\n    }\\n        return - 1;\\n    }\\n};"
                    },
                    {
                        "username": "bparanj",
                        "content": "Your code appears to be correct for a binary search within a rotated sorted array. If the function doesn\\'t work as expected, there could be a few reasons why:\\n\\n1. The `vector` might not be sorted or properly rotated: This code assumes that the input `vector` is a sorted array that has been rotated. If it\\'s not, the code might not work as expected.\\n\\n2. The target number might not exist in the array: If the number you\\'re looking for isn\\'t in the array, the function will correctly return -1, which is the expected behavior.\\n\\n3. Compiler, environment, or runtime error: There could be a problem with your development environment or a runtime error causing the code to fail.\\n\\nI would suggest first verifying that your input is a rotated sorted array and the target number exists in it. If you\\'re still having problems, please provide more information about the specific error or issue you\\'re encountering. \\n\\nRemember, the provided function\\'s time complexity is O(log n) as it utilizes the concept of Binary Search, making it a very efficient solution for large arrays."
                    },
                    {
                        "username": "agarwalkaran253",
                        "content": "The logic I am using is finding the position where the trend changes and then putting the limits of i and j and then applying binary search on it ,yet it is giving me the wrong answer?\\nany suggestions?\\nMy code below------->\\n\\nclass Solution {\\npublic:\\n    int search(vector<int>& nums, int target) {\\n        int low=0,high=nums.size()-1;\\n        while(low<high)\\n        {\\n            int mid=(low+high)/2;\\n            if(nums[mid]>nums[high])\\n            low=mid+1;\\n            else\\n            high=mid-1;\\n        }\\n        //return low;\\n        int i=0,j=0;\\n        if(target>nums[high]){\\n        i=0;j=low-1;}\\n        else{\\n        i=low;j=nums.size()-1;}\\n        while(i<j){\\n            int mids=(i+j)/2;\\n            if(nums[mids]==target)\\n            return mids;\\n            else if(nums[mids]>target)\\n                j=mids-1;\\n            else\\n                i=mids+1;\\n        }\\n        return j;\\n    }\\n};\\n\\n"
                    },
                    {
                        "username": "bparanj",
                        "content": "Your approach to solve the problem using binary search is correct but there are some issues with your implementation:\\n\\n1. After finding the smallest element, you need to check whether the target is in the first half or the second half of the rotated array and search in the correct half. However, in your code, you\\'re defining the boundaries `i` and `j` incorrectly. You should compare the target with `nums[0]` instead of `nums[high]` because `nums[0]` would be the starting point of either of the sorted halves of the array.\\n\\n2. In the second while loop, you\\'re using `while(i<j)`. But you should use `while(i<=j)` to ensure the loop runs when `i` and `j` point to the same element.\\n\\n3. In the return statement, you\\'re returning `j`, which is not correct. If the target is not found, you should return -1.\\n\\nHere is your corrected code:\\n\\n```cpp\\nclass Solution {\\npublic:\\n    int search(vector<int>& nums, int target) {\\n        int low=0, high=nums.size()-1;\\n        while(low<high)\\n        {\\n            int mid=(low+high)/2;\\n            if(nums[mid]>nums[high])\\n                low=mid+1;\\n            else\\n                high=mid;\\n        }\\n        // low is now pointing to smallest element\\n        int i=0, j=0;\\n        if(target>=nums[0]){ // target is in the first half\\n            i=0; j=low;\\n        }\\n        else{ // target is in the second half\\n            i=low; j=nums.size()-1;\\n        }\\n        while(i<=j){ // modified from i<j to i<=j\\n            int mid=(i+j)/2;\\n            if(nums[mid]==target)\\n                return mid;\\n            else if(nums[mid]>target)\\n                j=mid-1;\\n            else\\n                i=mid+1;\\n        }\\n        return -1; // return -1 if target not found\\n    }\\n};\\n```\\nWith these changes, your code should work correctly to find the target in the rotated sorted array.\\n"
                    },
                    {
                        "username": "Aman-kumar-a",
                        "content": "pls tell me what\\'s the error in code\\npls help!!\\nint search_pivot(vector<int> & nums)\\n{\\n   int s=0;\\n  int  e=nums.size()-1;\\n   int mid=s+ (e-s)/2;\\n    while(s<e)\\n    {\\n        if(nums[mid]>=nums[0])\\n        {\\n            s=mid+1;\\n        }\\n        else\\n        {\\n            e=mid;\\n        }\\n      mid=s+ (e-s)/2;\\n    }\\n    return s;\\n}\\nint binary_search(vector<int>& nums,int s,int e,int key)\\n{\\n   int  start=s;\\n   int  end=e;\\n   int  mid=start + (end-start)/2;\\n   while(start<=end)\\n   {\\n       if(nums[mid]==key)\\n       {\\n           return mid;\\n       }\\n       else if(nums[mid]<key)\\n       {\\n           start=mid+1;\\n       }\\n       else\\n       {\\n           end=mid-1;\\n       }\\n      mid=start + (end-start)/2;\\n   }\\n    return -1;\\n}\\n\\nclass Solution {\\npublic:\\n    int search(vector<int>& nums, int target) {\\n        int n=nums.size()-1;\\n        int pivot=search_pivot(nums);\\n        if(target>=pivot && target<=nums[n-1] )\\n        {\\n           return  binary_search(nums,pivot,n-1,target);\\n        }\\n        else\\n        {\\n           return binary_search(nums,0,pivot-1,target); \\n        }\\n    }\\n};"
                    },
                    {
                        "username": "deleted_user",
                        "content": "class Solution {\\n    public int search(int[] nums, int target) {\\n        \\n        int idx=0;\\n\\n        for(int i=0;i<nums.length;i++){\\n            if(nums[i]==target){\\n                idx=i;\\n                break;\\n            }\\n            else{\\n                idx=-1;\\n            }\\n        \\n        }\\n        return idx;\\n    }\\n}\\n\\nthis code passed all test cases, do we need to include rotation part also (BST)?"
                    },
                    {
                        "username": "ansal_kumar",
                        "content": "simple linear search "
                    },
                    {
                        "username": "shivbhankushwaha862003672001",
                        "content": "class Solution {\\npublic:\\n\\nint findPivot(vector<int> &arr, int n){\\n     int s = 0;\\n     int e = n-1;\\n     int mid = s +(e-s)/2;\\n    \\n    while(s<e){\\n        if(arr[mid] >= arr[0]){\\n            s = mid +1;\\n        }\\n        else{\\n            e = mid;\\n        }\\n        mid = s +(e-s)/2;\\n    }\\n    return s;\\n}\\n\\nint binarySearch(vector<int> &arr,int s,int e, int k){\\n    int start = s;\\n    int end = e;\\n    int mid = start + (end - start)/2;\\n    \\n    while(start <= end){\\n        if(arr[mid] == k){\\n            return mid;\\n        }\\n        else if(k > arr[mid]){\\n            start = mid +1 ;\\n        }\\n        else if(k<arr[mid]){\\n            end = mid -1;\\n        }\\n        mid = start + (end - start)/2;\\n    }\\n    return -1;\\n}\\n\\nint findPosition(vector<int>& arr, int n, int k)\\n{\\n   int pivot = findPivot(arr,n);\\n    if(k >= arr[pivot] && k <= arr[n-1]){\\n        return binarySearch(arr,pivot,n-1,k);\\n    }\\n    else{\\n        return binarySearch(arr,0,pivot-1,k);\\n    }\\n}\\n\\n\\n    int search(vector<int>& nums, int target) {\\n        int n = nums.size();\\n       return findPosition(nums,n,target);\\n    }\\n};"
                    },
                    {
                        "username": "SaikatDass",
                        "content": "Search in rotated sorted array | java program | O(log n) complexity\nclass Solution {\n    public int search(int[] nums, int target) {\n        int n = nums.length;\n        int min = minSearch(nums);\n        if(nums[min] <= target && target <= nums[n - 1]){\n            return search(nums, min, n-1, target);\n        }\n        else{\n            return search(nums, 0, min, target);\n        }\n    }\n    public static int search(int[] nums, int start, int end, int target){\n        while(start <= end){\n            int mid = start + (end - start) / 2;\n            if(nums[mid] == target){\n                return mid;\n            }\n            else if(nums[mid] > target){\n                end = mid - 1;\n            }\n            else{\n                start = mid + 1;\n            }\n        }\n        return -1;\n    }\n    public static int minSearch(int[] nums){\n            int start = 0;\n            int end = nums.length - 1;\n            while(start < end){\n                int mid = start + (end - start) / 2; \n                if(mid > 0 && nums[mid - 1] > nums[mid]){\n                    return mid;\n                }\n                else if(nums[start] <= nums[mid] && nums[mid] > nums[end]){\n                    start = mid + 1;\n                }\n                else{\n                    end = mid - 1;\n                }\n            }\n            return start;\n        }\n}"
                    },
                    {
                        "username": "Ankush175",
                        "content": " `class Solution {\\n    public int search(int[] nums, int target) {\\n\\n        int start=0;\\n        int end = nums.length-1;\\n\\n        while(start<=end){\\n\\n            int mid = start+(end-start)/2;\\n\\n            if(nums[mid] == target){\\n                return mid;\\n            }\\n\\n            if(nums[start]<=nums[mid]){\\n                // the elements between start and end are in ascending order\\n\\n                if(nums[start]<=target && target<nums[mid]){\\n                    //the elements between start and end are in ascending order and,\\n                    //if the target lies between start and mid, so update end\\n                    end=mid-1;\\n                }\\n                else{\\n                    //if not the element lies between mid and end, so update start\\n                    start = mid+1;\\n                }\\n            }\\n            else{\\n                //the elements between start and mid are not in ascending order,i.e they are in descending order,the elements after mid will be in ascending order.\\n                if(nums[mid]<target && target<=nums[end]){\\n                    start = mid+1;\\n                }\\n                else{\\n                    end = mid-1;\\n                }\\n\\n            }\\n\\n        }\\n        return -1;\\n        \\n    }\\n}`"
                    },
                    {
                        "username": "yashdeora",
                        "content": "Here is problem solution in Python, Java, C++ and C programming.\\n[https://www.gyangav.com/2022/11/leetcode-search-in-rotated-sorted-array-problem-solution.html](https://www.gyangav.com/2022/11/leetcode-search-in-rotated-sorted-array-problem-solution.html)"
                    },
                    {
                        "username": "Bhautikbhalala123",
                        "content": "https://zeroplusfour.com/search-in-rotated-sorted-array-leetcode-solution/\\n\\nFull OPTIMAL solution in Java , Python , C++ , C \\n\\nGet all the solution here at :\\nhttps://zeroplusfour.com/leetcode-all-array-solution-list-all-in-one-place/\\n"
                    }
                ]
            },
            {
                "id": 1708621,
                "content": [
                    {
                        "username": "imvillen69",
                        "content": "Help me to debug this code .\\nclass Solution {\\npublic:\\n    int search(vector<int>& nums, int target) {\\n        int l = 0,h = nums.size() - 1;\\n        while(l <= h){\\n        int m = (l + (h - l))>>1;\\n        if(nums[m] == target)\\n            return m;\\n//left half is sorted.\\n        if(nums[l] <= nums[m])\\n        {\\n            if(target >= nums[l] && target <= nums[m]) //lies in range ..\\n            h = m - 1;\\n            else\\n            l = m + 1;\\n        }\\n//right half is sorted.\\n        else\\n        {\\n           if(target >= nums[m] && target <= nums[h]) // lies in range..\\n            l = m + 1;\\n            else\\n            h = m - 1; \\n        }\\n    }\\n        return - 1;\\n    }\\n};"
                    },
                    {
                        "username": "bparanj",
                        "content": "Your code appears to be correct for a binary search within a rotated sorted array. If the function doesn\\'t work as expected, there could be a few reasons why:\\n\\n1. The `vector` might not be sorted or properly rotated: This code assumes that the input `vector` is a sorted array that has been rotated. If it\\'s not, the code might not work as expected.\\n\\n2. The target number might not exist in the array: If the number you\\'re looking for isn\\'t in the array, the function will correctly return -1, which is the expected behavior.\\n\\n3. Compiler, environment, or runtime error: There could be a problem with your development environment or a runtime error causing the code to fail.\\n\\nI would suggest first verifying that your input is a rotated sorted array and the target number exists in it. If you\\'re still having problems, please provide more information about the specific error or issue you\\'re encountering. \\n\\nRemember, the provided function\\'s time complexity is O(log n) as it utilizes the concept of Binary Search, making it a very efficient solution for large arrays."
                    },
                    {
                        "username": "agarwalkaran253",
                        "content": "The logic I am using is finding the position where the trend changes and then putting the limits of i and j and then applying binary search on it ,yet it is giving me the wrong answer?\\nany suggestions?\\nMy code below------->\\n\\nclass Solution {\\npublic:\\n    int search(vector<int>& nums, int target) {\\n        int low=0,high=nums.size()-1;\\n        while(low<high)\\n        {\\n            int mid=(low+high)/2;\\n            if(nums[mid]>nums[high])\\n            low=mid+1;\\n            else\\n            high=mid-1;\\n        }\\n        //return low;\\n        int i=0,j=0;\\n        if(target>nums[high]){\\n        i=0;j=low-1;}\\n        else{\\n        i=low;j=nums.size()-1;}\\n        while(i<j){\\n            int mids=(i+j)/2;\\n            if(nums[mids]==target)\\n            return mids;\\n            else if(nums[mids]>target)\\n                j=mids-1;\\n            else\\n                i=mids+1;\\n        }\\n        return j;\\n    }\\n};\\n\\n"
                    },
                    {
                        "username": "bparanj",
                        "content": "Your approach to solve the problem using binary search is correct but there are some issues with your implementation:\\n\\n1. After finding the smallest element, you need to check whether the target is in the first half or the second half of the rotated array and search in the correct half. However, in your code, you\\'re defining the boundaries `i` and `j` incorrectly. You should compare the target with `nums[0]` instead of `nums[high]` because `nums[0]` would be the starting point of either of the sorted halves of the array.\\n\\n2. In the second while loop, you\\'re using `while(i<j)`. But you should use `while(i<=j)` to ensure the loop runs when `i` and `j` point to the same element.\\n\\n3. In the return statement, you\\'re returning `j`, which is not correct. If the target is not found, you should return -1.\\n\\nHere is your corrected code:\\n\\n```cpp\\nclass Solution {\\npublic:\\n    int search(vector<int>& nums, int target) {\\n        int low=0, high=nums.size()-1;\\n        while(low<high)\\n        {\\n            int mid=(low+high)/2;\\n            if(nums[mid]>nums[high])\\n                low=mid+1;\\n            else\\n                high=mid;\\n        }\\n        // low is now pointing to smallest element\\n        int i=0, j=0;\\n        if(target>=nums[0]){ // target is in the first half\\n            i=0; j=low;\\n        }\\n        else{ // target is in the second half\\n            i=low; j=nums.size()-1;\\n        }\\n        while(i<=j){ // modified from i<j to i<=j\\n            int mid=(i+j)/2;\\n            if(nums[mid]==target)\\n                return mid;\\n            else if(nums[mid]>target)\\n                j=mid-1;\\n            else\\n                i=mid+1;\\n        }\\n        return -1; // return -1 if target not found\\n    }\\n};\\n```\\nWith these changes, your code should work correctly to find the target in the rotated sorted array.\\n"
                    },
                    {
                        "username": "Aman-kumar-a",
                        "content": "pls tell me what\\'s the error in code\\npls help!!\\nint search_pivot(vector<int> & nums)\\n{\\n   int s=0;\\n  int  e=nums.size()-1;\\n   int mid=s+ (e-s)/2;\\n    while(s<e)\\n    {\\n        if(nums[mid]>=nums[0])\\n        {\\n            s=mid+1;\\n        }\\n        else\\n        {\\n            e=mid;\\n        }\\n      mid=s+ (e-s)/2;\\n    }\\n    return s;\\n}\\nint binary_search(vector<int>& nums,int s,int e,int key)\\n{\\n   int  start=s;\\n   int  end=e;\\n   int  mid=start + (end-start)/2;\\n   while(start<=end)\\n   {\\n       if(nums[mid]==key)\\n       {\\n           return mid;\\n       }\\n       else if(nums[mid]<key)\\n       {\\n           start=mid+1;\\n       }\\n       else\\n       {\\n           end=mid-1;\\n       }\\n      mid=start + (end-start)/2;\\n   }\\n    return -1;\\n}\\n\\nclass Solution {\\npublic:\\n    int search(vector<int>& nums, int target) {\\n        int n=nums.size()-1;\\n        int pivot=search_pivot(nums);\\n        if(target>=pivot && target<=nums[n-1] )\\n        {\\n           return  binary_search(nums,pivot,n-1,target);\\n        }\\n        else\\n        {\\n           return binary_search(nums,0,pivot-1,target); \\n        }\\n    }\\n};"
                    },
                    {
                        "username": "deleted_user",
                        "content": "class Solution {\\n    public int search(int[] nums, int target) {\\n        \\n        int idx=0;\\n\\n        for(int i=0;i<nums.length;i++){\\n            if(nums[i]==target){\\n                idx=i;\\n                break;\\n            }\\n            else{\\n                idx=-1;\\n            }\\n        \\n        }\\n        return idx;\\n    }\\n}\\n\\nthis code passed all test cases, do we need to include rotation part also (BST)?"
                    },
                    {
                        "username": "ansal_kumar",
                        "content": "simple linear search "
                    },
                    {
                        "username": "shivbhankushwaha862003672001",
                        "content": "class Solution {\\npublic:\\n\\nint findPivot(vector<int> &arr, int n){\\n     int s = 0;\\n     int e = n-1;\\n     int mid = s +(e-s)/2;\\n    \\n    while(s<e){\\n        if(arr[mid] >= arr[0]){\\n            s = mid +1;\\n        }\\n        else{\\n            e = mid;\\n        }\\n        mid = s +(e-s)/2;\\n    }\\n    return s;\\n}\\n\\nint binarySearch(vector<int> &arr,int s,int e, int k){\\n    int start = s;\\n    int end = e;\\n    int mid = start + (end - start)/2;\\n    \\n    while(start <= end){\\n        if(arr[mid] == k){\\n            return mid;\\n        }\\n        else if(k > arr[mid]){\\n            start = mid +1 ;\\n        }\\n        else if(k<arr[mid]){\\n            end = mid -1;\\n        }\\n        mid = start + (end - start)/2;\\n    }\\n    return -1;\\n}\\n\\nint findPosition(vector<int>& arr, int n, int k)\\n{\\n   int pivot = findPivot(arr,n);\\n    if(k >= arr[pivot] && k <= arr[n-1]){\\n        return binarySearch(arr,pivot,n-1,k);\\n    }\\n    else{\\n        return binarySearch(arr,0,pivot-1,k);\\n    }\\n}\\n\\n\\n    int search(vector<int>& nums, int target) {\\n        int n = nums.size();\\n       return findPosition(nums,n,target);\\n    }\\n};"
                    },
                    {
                        "username": "SaikatDass",
                        "content": "Search in rotated sorted array | java program | O(log n) complexity\nclass Solution {\n    public int search(int[] nums, int target) {\n        int n = nums.length;\n        int min = minSearch(nums);\n        if(nums[min] <= target && target <= nums[n - 1]){\n            return search(nums, min, n-1, target);\n        }\n        else{\n            return search(nums, 0, min, target);\n        }\n    }\n    public static int search(int[] nums, int start, int end, int target){\n        while(start <= end){\n            int mid = start + (end - start) / 2;\n            if(nums[mid] == target){\n                return mid;\n            }\n            else if(nums[mid] > target){\n                end = mid - 1;\n            }\n            else{\n                start = mid + 1;\n            }\n        }\n        return -1;\n    }\n    public static int minSearch(int[] nums){\n            int start = 0;\n            int end = nums.length - 1;\n            while(start < end){\n                int mid = start + (end - start) / 2; \n                if(mid > 0 && nums[mid - 1] > nums[mid]){\n                    return mid;\n                }\n                else if(nums[start] <= nums[mid] && nums[mid] > nums[end]){\n                    start = mid + 1;\n                }\n                else{\n                    end = mid - 1;\n                }\n            }\n            return start;\n        }\n}"
                    },
                    {
                        "username": "Ankush175",
                        "content": " `class Solution {\\n    public int search(int[] nums, int target) {\\n\\n        int start=0;\\n        int end = nums.length-1;\\n\\n        while(start<=end){\\n\\n            int mid = start+(end-start)/2;\\n\\n            if(nums[mid] == target){\\n                return mid;\\n            }\\n\\n            if(nums[start]<=nums[mid]){\\n                // the elements between start and end are in ascending order\\n\\n                if(nums[start]<=target && target<nums[mid]){\\n                    //the elements between start and end are in ascending order and,\\n                    //if the target lies between start and mid, so update end\\n                    end=mid-1;\\n                }\\n                else{\\n                    //if not the element lies between mid and end, so update start\\n                    start = mid+1;\\n                }\\n            }\\n            else{\\n                //the elements between start and mid are not in ascending order,i.e they are in descending order,the elements after mid will be in ascending order.\\n                if(nums[mid]<target && target<=nums[end]){\\n                    start = mid+1;\\n                }\\n                else{\\n                    end = mid-1;\\n                }\\n\\n            }\\n\\n        }\\n        return -1;\\n        \\n    }\\n}`"
                    },
                    {
                        "username": "yashdeora",
                        "content": "Here is problem solution in Python, Java, C++ and C programming.\\n[https://www.gyangav.com/2022/11/leetcode-search-in-rotated-sorted-array-problem-solution.html](https://www.gyangav.com/2022/11/leetcode-search-in-rotated-sorted-array-problem-solution.html)"
                    },
                    {
                        "username": "Bhautikbhalala123",
                        "content": "https://zeroplusfour.com/search-in-rotated-sorted-array-leetcode-solution/\\n\\nFull OPTIMAL solution in Java , Python , C++ , C \\n\\nGet all the solution here at :\\nhttps://zeroplusfour.com/leetcode-all-array-solution-list-all-in-one-place/\\n"
                    }
                ]
            },
            {
                "id": 1707994,
                "content": [
                    {
                        "username": "imvillen69",
                        "content": "Help me to debug this code .\\nclass Solution {\\npublic:\\n    int search(vector<int>& nums, int target) {\\n        int l = 0,h = nums.size() - 1;\\n        while(l <= h){\\n        int m = (l + (h - l))>>1;\\n        if(nums[m] == target)\\n            return m;\\n//left half is sorted.\\n        if(nums[l] <= nums[m])\\n        {\\n            if(target >= nums[l] && target <= nums[m]) //lies in range ..\\n            h = m - 1;\\n            else\\n            l = m + 1;\\n        }\\n//right half is sorted.\\n        else\\n        {\\n           if(target >= nums[m] && target <= nums[h]) // lies in range..\\n            l = m + 1;\\n            else\\n            h = m - 1; \\n        }\\n    }\\n        return - 1;\\n    }\\n};"
                    },
                    {
                        "username": "bparanj",
                        "content": "Your code appears to be correct for a binary search within a rotated sorted array. If the function doesn\\'t work as expected, there could be a few reasons why:\\n\\n1. The `vector` might not be sorted or properly rotated: This code assumes that the input `vector` is a sorted array that has been rotated. If it\\'s not, the code might not work as expected.\\n\\n2. The target number might not exist in the array: If the number you\\'re looking for isn\\'t in the array, the function will correctly return -1, which is the expected behavior.\\n\\n3. Compiler, environment, or runtime error: There could be a problem with your development environment or a runtime error causing the code to fail.\\n\\nI would suggest first verifying that your input is a rotated sorted array and the target number exists in it. If you\\'re still having problems, please provide more information about the specific error or issue you\\'re encountering. \\n\\nRemember, the provided function\\'s time complexity is O(log n) as it utilizes the concept of Binary Search, making it a very efficient solution for large arrays."
                    },
                    {
                        "username": "agarwalkaran253",
                        "content": "The logic I am using is finding the position where the trend changes and then putting the limits of i and j and then applying binary search on it ,yet it is giving me the wrong answer?\\nany suggestions?\\nMy code below------->\\n\\nclass Solution {\\npublic:\\n    int search(vector<int>& nums, int target) {\\n        int low=0,high=nums.size()-1;\\n        while(low<high)\\n        {\\n            int mid=(low+high)/2;\\n            if(nums[mid]>nums[high])\\n            low=mid+1;\\n            else\\n            high=mid-1;\\n        }\\n        //return low;\\n        int i=0,j=0;\\n        if(target>nums[high]){\\n        i=0;j=low-1;}\\n        else{\\n        i=low;j=nums.size()-1;}\\n        while(i<j){\\n            int mids=(i+j)/2;\\n            if(nums[mids]==target)\\n            return mids;\\n            else if(nums[mids]>target)\\n                j=mids-1;\\n            else\\n                i=mids+1;\\n        }\\n        return j;\\n    }\\n};\\n\\n"
                    },
                    {
                        "username": "bparanj",
                        "content": "Your approach to solve the problem using binary search is correct but there are some issues with your implementation:\\n\\n1. After finding the smallest element, you need to check whether the target is in the first half or the second half of the rotated array and search in the correct half. However, in your code, you\\'re defining the boundaries `i` and `j` incorrectly. You should compare the target with `nums[0]` instead of `nums[high]` because `nums[0]` would be the starting point of either of the sorted halves of the array.\\n\\n2. In the second while loop, you\\'re using `while(i<j)`. But you should use `while(i<=j)` to ensure the loop runs when `i` and `j` point to the same element.\\n\\n3. In the return statement, you\\'re returning `j`, which is not correct. If the target is not found, you should return -1.\\n\\nHere is your corrected code:\\n\\n```cpp\\nclass Solution {\\npublic:\\n    int search(vector<int>& nums, int target) {\\n        int low=0, high=nums.size()-1;\\n        while(low<high)\\n        {\\n            int mid=(low+high)/2;\\n            if(nums[mid]>nums[high])\\n                low=mid+1;\\n            else\\n                high=mid;\\n        }\\n        // low is now pointing to smallest element\\n        int i=0, j=0;\\n        if(target>=nums[0]){ // target is in the first half\\n            i=0; j=low;\\n        }\\n        else{ // target is in the second half\\n            i=low; j=nums.size()-1;\\n        }\\n        while(i<=j){ // modified from i<j to i<=j\\n            int mid=(i+j)/2;\\n            if(nums[mid]==target)\\n                return mid;\\n            else if(nums[mid]>target)\\n                j=mid-1;\\n            else\\n                i=mid+1;\\n        }\\n        return -1; // return -1 if target not found\\n    }\\n};\\n```\\nWith these changes, your code should work correctly to find the target in the rotated sorted array.\\n"
                    },
                    {
                        "username": "Aman-kumar-a",
                        "content": "pls tell me what\\'s the error in code\\npls help!!\\nint search_pivot(vector<int> & nums)\\n{\\n   int s=0;\\n  int  e=nums.size()-1;\\n   int mid=s+ (e-s)/2;\\n    while(s<e)\\n    {\\n        if(nums[mid]>=nums[0])\\n        {\\n            s=mid+1;\\n        }\\n        else\\n        {\\n            e=mid;\\n        }\\n      mid=s+ (e-s)/2;\\n    }\\n    return s;\\n}\\nint binary_search(vector<int>& nums,int s,int e,int key)\\n{\\n   int  start=s;\\n   int  end=e;\\n   int  mid=start + (end-start)/2;\\n   while(start<=end)\\n   {\\n       if(nums[mid]==key)\\n       {\\n           return mid;\\n       }\\n       else if(nums[mid]<key)\\n       {\\n           start=mid+1;\\n       }\\n       else\\n       {\\n           end=mid-1;\\n       }\\n      mid=start + (end-start)/2;\\n   }\\n    return -1;\\n}\\n\\nclass Solution {\\npublic:\\n    int search(vector<int>& nums, int target) {\\n        int n=nums.size()-1;\\n        int pivot=search_pivot(nums);\\n        if(target>=pivot && target<=nums[n-1] )\\n        {\\n           return  binary_search(nums,pivot,n-1,target);\\n        }\\n        else\\n        {\\n           return binary_search(nums,0,pivot-1,target); \\n        }\\n    }\\n};"
                    },
                    {
                        "username": "deleted_user",
                        "content": "class Solution {\\n    public int search(int[] nums, int target) {\\n        \\n        int idx=0;\\n\\n        for(int i=0;i<nums.length;i++){\\n            if(nums[i]==target){\\n                idx=i;\\n                break;\\n            }\\n            else{\\n                idx=-1;\\n            }\\n        \\n        }\\n        return idx;\\n    }\\n}\\n\\nthis code passed all test cases, do we need to include rotation part also (BST)?"
                    },
                    {
                        "username": "ansal_kumar",
                        "content": "simple linear search "
                    },
                    {
                        "username": "shivbhankushwaha862003672001",
                        "content": "class Solution {\\npublic:\\n\\nint findPivot(vector<int> &arr, int n){\\n     int s = 0;\\n     int e = n-1;\\n     int mid = s +(e-s)/2;\\n    \\n    while(s<e){\\n        if(arr[mid] >= arr[0]){\\n            s = mid +1;\\n        }\\n        else{\\n            e = mid;\\n        }\\n        mid = s +(e-s)/2;\\n    }\\n    return s;\\n}\\n\\nint binarySearch(vector<int> &arr,int s,int e, int k){\\n    int start = s;\\n    int end = e;\\n    int mid = start + (end - start)/2;\\n    \\n    while(start <= end){\\n        if(arr[mid] == k){\\n            return mid;\\n        }\\n        else if(k > arr[mid]){\\n            start = mid +1 ;\\n        }\\n        else if(k<arr[mid]){\\n            end = mid -1;\\n        }\\n        mid = start + (end - start)/2;\\n    }\\n    return -1;\\n}\\n\\nint findPosition(vector<int>& arr, int n, int k)\\n{\\n   int pivot = findPivot(arr,n);\\n    if(k >= arr[pivot] && k <= arr[n-1]){\\n        return binarySearch(arr,pivot,n-1,k);\\n    }\\n    else{\\n        return binarySearch(arr,0,pivot-1,k);\\n    }\\n}\\n\\n\\n    int search(vector<int>& nums, int target) {\\n        int n = nums.size();\\n       return findPosition(nums,n,target);\\n    }\\n};"
                    },
                    {
                        "username": "SaikatDass",
                        "content": "Search in rotated sorted array | java program | O(log n) complexity\nclass Solution {\n    public int search(int[] nums, int target) {\n        int n = nums.length;\n        int min = minSearch(nums);\n        if(nums[min] <= target && target <= nums[n - 1]){\n            return search(nums, min, n-1, target);\n        }\n        else{\n            return search(nums, 0, min, target);\n        }\n    }\n    public static int search(int[] nums, int start, int end, int target){\n        while(start <= end){\n            int mid = start + (end - start) / 2;\n            if(nums[mid] == target){\n                return mid;\n            }\n            else if(nums[mid] > target){\n                end = mid - 1;\n            }\n            else{\n                start = mid + 1;\n            }\n        }\n        return -1;\n    }\n    public static int minSearch(int[] nums){\n            int start = 0;\n            int end = nums.length - 1;\n            while(start < end){\n                int mid = start + (end - start) / 2; \n                if(mid > 0 && nums[mid - 1] > nums[mid]){\n                    return mid;\n                }\n                else if(nums[start] <= nums[mid] && nums[mid] > nums[end]){\n                    start = mid + 1;\n                }\n                else{\n                    end = mid - 1;\n                }\n            }\n            return start;\n        }\n}"
                    },
                    {
                        "username": "Ankush175",
                        "content": " `class Solution {\\n    public int search(int[] nums, int target) {\\n\\n        int start=0;\\n        int end = nums.length-1;\\n\\n        while(start<=end){\\n\\n            int mid = start+(end-start)/2;\\n\\n            if(nums[mid] == target){\\n                return mid;\\n            }\\n\\n            if(nums[start]<=nums[mid]){\\n                // the elements between start and end are in ascending order\\n\\n                if(nums[start]<=target && target<nums[mid]){\\n                    //the elements between start and end are in ascending order and,\\n                    //if the target lies between start and mid, so update end\\n                    end=mid-1;\\n                }\\n                else{\\n                    //if not the element lies between mid and end, so update start\\n                    start = mid+1;\\n                }\\n            }\\n            else{\\n                //the elements between start and mid are not in ascending order,i.e they are in descending order,the elements after mid will be in ascending order.\\n                if(nums[mid]<target && target<=nums[end]){\\n                    start = mid+1;\\n                }\\n                else{\\n                    end = mid-1;\\n                }\\n\\n            }\\n\\n        }\\n        return -1;\\n        \\n    }\\n}`"
                    },
                    {
                        "username": "yashdeora",
                        "content": "Here is problem solution in Python, Java, C++ and C programming.\\n[https://www.gyangav.com/2022/11/leetcode-search-in-rotated-sorted-array-problem-solution.html](https://www.gyangav.com/2022/11/leetcode-search-in-rotated-sorted-array-problem-solution.html)"
                    },
                    {
                        "username": "Bhautikbhalala123",
                        "content": "https://zeroplusfour.com/search-in-rotated-sorted-array-leetcode-solution/\\n\\nFull OPTIMAL solution in Java , Python , C++ , C \\n\\nGet all the solution here at :\\nhttps://zeroplusfour.com/leetcode-all-array-solution-list-all-in-one-place/\\n"
                    }
                ]
            },
            {
                "id": 1706261,
                "content": [
                    {
                        "username": "imvillen69",
                        "content": "Help me to debug this code .\\nclass Solution {\\npublic:\\n    int search(vector<int>& nums, int target) {\\n        int l = 0,h = nums.size() - 1;\\n        while(l <= h){\\n        int m = (l + (h - l))>>1;\\n        if(nums[m] == target)\\n            return m;\\n//left half is sorted.\\n        if(nums[l] <= nums[m])\\n        {\\n            if(target >= nums[l] && target <= nums[m]) //lies in range ..\\n            h = m - 1;\\n            else\\n            l = m + 1;\\n        }\\n//right half is sorted.\\n        else\\n        {\\n           if(target >= nums[m] && target <= nums[h]) // lies in range..\\n            l = m + 1;\\n            else\\n            h = m - 1; \\n        }\\n    }\\n        return - 1;\\n    }\\n};"
                    },
                    {
                        "username": "bparanj",
                        "content": "Your code appears to be correct for a binary search within a rotated sorted array. If the function doesn\\'t work as expected, there could be a few reasons why:\\n\\n1. The `vector` might not be sorted or properly rotated: This code assumes that the input `vector` is a sorted array that has been rotated. If it\\'s not, the code might not work as expected.\\n\\n2. The target number might not exist in the array: If the number you\\'re looking for isn\\'t in the array, the function will correctly return -1, which is the expected behavior.\\n\\n3. Compiler, environment, or runtime error: There could be a problem with your development environment or a runtime error causing the code to fail.\\n\\nI would suggest first verifying that your input is a rotated sorted array and the target number exists in it. If you\\'re still having problems, please provide more information about the specific error or issue you\\'re encountering. \\n\\nRemember, the provided function\\'s time complexity is O(log n) as it utilizes the concept of Binary Search, making it a very efficient solution for large arrays."
                    },
                    {
                        "username": "agarwalkaran253",
                        "content": "The logic I am using is finding the position where the trend changes and then putting the limits of i and j and then applying binary search on it ,yet it is giving me the wrong answer?\\nany suggestions?\\nMy code below------->\\n\\nclass Solution {\\npublic:\\n    int search(vector<int>& nums, int target) {\\n        int low=0,high=nums.size()-1;\\n        while(low<high)\\n        {\\n            int mid=(low+high)/2;\\n            if(nums[mid]>nums[high])\\n            low=mid+1;\\n            else\\n            high=mid-1;\\n        }\\n        //return low;\\n        int i=0,j=0;\\n        if(target>nums[high]){\\n        i=0;j=low-1;}\\n        else{\\n        i=low;j=nums.size()-1;}\\n        while(i<j){\\n            int mids=(i+j)/2;\\n            if(nums[mids]==target)\\n            return mids;\\n            else if(nums[mids]>target)\\n                j=mids-1;\\n            else\\n                i=mids+1;\\n        }\\n        return j;\\n    }\\n};\\n\\n"
                    },
                    {
                        "username": "bparanj",
                        "content": "Your approach to solve the problem using binary search is correct but there are some issues with your implementation:\\n\\n1. After finding the smallest element, you need to check whether the target is in the first half or the second half of the rotated array and search in the correct half. However, in your code, you\\'re defining the boundaries `i` and `j` incorrectly. You should compare the target with `nums[0]` instead of `nums[high]` because `nums[0]` would be the starting point of either of the sorted halves of the array.\\n\\n2. In the second while loop, you\\'re using `while(i<j)`. But you should use `while(i<=j)` to ensure the loop runs when `i` and `j` point to the same element.\\n\\n3. In the return statement, you\\'re returning `j`, which is not correct. If the target is not found, you should return -1.\\n\\nHere is your corrected code:\\n\\n```cpp\\nclass Solution {\\npublic:\\n    int search(vector<int>& nums, int target) {\\n        int low=0, high=nums.size()-1;\\n        while(low<high)\\n        {\\n            int mid=(low+high)/2;\\n            if(nums[mid]>nums[high])\\n                low=mid+1;\\n            else\\n                high=mid;\\n        }\\n        // low is now pointing to smallest element\\n        int i=0, j=0;\\n        if(target>=nums[0]){ // target is in the first half\\n            i=0; j=low;\\n        }\\n        else{ // target is in the second half\\n            i=low; j=nums.size()-1;\\n        }\\n        while(i<=j){ // modified from i<j to i<=j\\n            int mid=(i+j)/2;\\n            if(nums[mid]==target)\\n                return mid;\\n            else if(nums[mid]>target)\\n                j=mid-1;\\n            else\\n                i=mid+1;\\n        }\\n        return -1; // return -1 if target not found\\n    }\\n};\\n```\\nWith these changes, your code should work correctly to find the target in the rotated sorted array.\\n"
                    },
                    {
                        "username": "Aman-kumar-a",
                        "content": "pls tell me what\\'s the error in code\\npls help!!\\nint search_pivot(vector<int> & nums)\\n{\\n   int s=0;\\n  int  e=nums.size()-1;\\n   int mid=s+ (e-s)/2;\\n    while(s<e)\\n    {\\n        if(nums[mid]>=nums[0])\\n        {\\n            s=mid+1;\\n        }\\n        else\\n        {\\n            e=mid;\\n        }\\n      mid=s+ (e-s)/2;\\n    }\\n    return s;\\n}\\nint binary_search(vector<int>& nums,int s,int e,int key)\\n{\\n   int  start=s;\\n   int  end=e;\\n   int  mid=start + (end-start)/2;\\n   while(start<=end)\\n   {\\n       if(nums[mid]==key)\\n       {\\n           return mid;\\n       }\\n       else if(nums[mid]<key)\\n       {\\n           start=mid+1;\\n       }\\n       else\\n       {\\n           end=mid-1;\\n       }\\n      mid=start + (end-start)/2;\\n   }\\n    return -1;\\n}\\n\\nclass Solution {\\npublic:\\n    int search(vector<int>& nums, int target) {\\n        int n=nums.size()-1;\\n        int pivot=search_pivot(nums);\\n        if(target>=pivot && target<=nums[n-1] )\\n        {\\n           return  binary_search(nums,pivot,n-1,target);\\n        }\\n        else\\n        {\\n           return binary_search(nums,0,pivot-1,target); \\n        }\\n    }\\n};"
                    },
                    {
                        "username": "deleted_user",
                        "content": "class Solution {\\n    public int search(int[] nums, int target) {\\n        \\n        int idx=0;\\n\\n        for(int i=0;i<nums.length;i++){\\n            if(nums[i]==target){\\n                idx=i;\\n                break;\\n            }\\n            else{\\n                idx=-1;\\n            }\\n        \\n        }\\n        return idx;\\n    }\\n}\\n\\nthis code passed all test cases, do we need to include rotation part also (BST)?"
                    },
                    {
                        "username": "ansal_kumar",
                        "content": "simple linear search "
                    },
                    {
                        "username": "shivbhankushwaha862003672001",
                        "content": "class Solution {\\npublic:\\n\\nint findPivot(vector<int> &arr, int n){\\n     int s = 0;\\n     int e = n-1;\\n     int mid = s +(e-s)/2;\\n    \\n    while(s<e){\\n        if(arr[mid] >= arr[0]){\\n            s = mid +1;\\n        }\\n        else{\\n            e = mid;\\n        }\\n        mid = s +(e-s)/2;\\n    }\\n    return s;\\n}\\n\\nint binarySearch(vector<int> &arr,int s,int e, int k){\\n    int start = s;\\n    int end = e;\\n    int mid = start + (end - start)/2;\\n    \\n    while(start <= end){\\n        if(arr[mid] == k){\\n            return mid;\\n        }\\n        else if(k > arr[mid]){\\n            start = mid +1 ;\\n        }\\n        else if(k<arr[mid]){\\n            end = mid -1;\\n        }\\n        mid = start + (end - start)/2;\\n    }\\n    return -1;\\n}\\n\\nint findPosition(vector<int>& arr, int n, int k)\\n{\\n   int pivot = findPivot(arr,n);\\n    if(k >= arr[pivot] && k <= arr[n-1]){\\n        return binarySearch(arr,pivot,n-1,k);\\n    }\\n    else{\\n        return binarySearch(arr,0,pivot-1,k);\\n    }\\n}\\n\\n\\n    int search(vector<int>& nums, int target) {\\n        int n = nums.size();\\n       return findPosition(nums,n,target);\\n    }\\n};"
                    },
                    {
                        "username": "SaikatDass",
                        "content": "Search in rotated sorted array | java program | O(log n) complexity\nclass Solution {\n    public int search(int[] nums, int target) {\n        int n = nums.length;\n        int min = minSearch(nums);\n        if(nums[min] <= target && target <= nums[n - 1]){\n            return search(nums, min, n-1, target);\n        }\n        else{\n            return search(nums, 0, min, target);\n        }\n    }\n    public static int search(int[] nums, int start, int end, int target){\n        while(start <= end){\n            int mid = start + (end - start) / 2;\n            if(nums[mid] == target){\n                return mid;\n            }\n            else if(nums[mid] > target){\n                end = mid - 1;\n            }\n            else{\n                start = mid + 1;\n            }\n        }\n        return -1;\n    }\n    public static int minSearch(int[] nums){\n            int start = 0;\n            int end = nums.length - 1;\n            while(start < end){\n                int mid = start + (end - start) / 2; \n                if(mid > 0 && nums[mid - 1] > nums[mid]){\n                    return mid;\n                }\n                else if(nums[start] <= nums[mid] && nums[mid] > nums[end]){\n                    start = mid + 1;\n                }\n                else{\n                    end = mid - 1;\n                }\n            }\n            return start;\n        }\n}"
                    },
                    {
                        "username": "Ankush175",
                        "content": " `class Solution {\\n    public int search(int[] nums, int target) {\\n\\n        int start=0;\\n        int end = nums.length-1;\\n\\n        while(start<=end){\\n\\n            int mid = start+(end-start)/2;\\n\\n            if(nums[mid] == target){\\n                return mid;\\n            }\\n\\n            if(nums[start]<=nums[mid]){\\n                // the elements between start and end are in ascending order\\n\\n                if(nums[start]<=target && target<nums[mid]){\\n                    //the elements between start and end are in ascending order and,\\n                    //if the target lies between start and mid, so update end\\n                    end=mid-1;\\n                }\\n                else{\\n                    //if not the element lies between mid and end, so update start\\n                    start = mid+1;\\n                }\\n            }\\n            else{\\n                //the elements between start and mid are not in ascending order,i.e they are in descending order,the elements after mid will be in ascending order.\\n                if(nums[mid]<target && target<=nums[end]){\\n                    start = mid+1;\\n                }\\n                else{\\n                    end = mid-1;\\n                }\\n\\n            }\\n\\n        }\\n        return -1;\\n        \\n    }\\n}`"
                    },
                    {
                        "username": "yashdeora",
                        "content": "Here is problem solution in Python, Java, C++ and C programming.\\n[https://www.gyangav.com/2022/11/leetcode-search-in-rotated-sorted-array-problem-solution.html](https://www.gyangav.com/2022/11/leetcode-search-in-rotated-sorted-array-problem-solution.html)"
                    },
                    {
                        "username": "Bhautikbhalala123",
                        "content": "https://zeroplusfour.com/search-in-rotated-sorted-array-leetcode-solution/\\n\\nFull OPTIMAL solution in Java , Python , C++ , C \\n\\nGet all the solution here at :\\nhttps://zeroplusfour.com/leetcode-all-array-solution-list-all-in-one-place/\\n"
                    }
                ]
            },
            {
                "id": 1699812,
                "content": [
                    {
                        "username": "imvillen69",
                        "content": "Help me to debug this code .\\nclass Solution {\\npublic:\\n    int search(vector<int>& nums, int target) {\\n        int l = 0,h = nums.size() - 1;\\n        while(l <= h){\\n        int m = (l + (h - l))>>1;\\n        if(nums[m] == target)\\n            return m;\\n//left half is sorted.\\n        if(nums[l] <= nums[m])\\n        {\\n            if(target >= nums[l] && target <= nums[m]) //lies in range ..\\n            h = m - 1;\\n            else\\n            l = m + 1;\\n        }\\n//right half is sorted.\\n        else\\n        {\\n           if(target >= nums[m] && target <= nums[h]) // lies in range..\\n            l = m + 1;\\n            else\\n            h = m - 1; \\n        }\\n    }\\n        return - 1;\\n    }\\n};"
                    },
                    {
                        "username": "bparanj",
                        "content": "Your code appears to be correct for a binary search within a rotated sorted array. If the function doesn\\'t work as expected, there could be a few reasons why:\\n\\n1. The `vector` might not be sorted or properly rotated: This code assumes that the input `vector` is a sorted array that has been rotated. If it\\'s not, the code might not work as expected.\\n\\n2. The target number might not exist in the array: If the number you\\'re looking for isn\\'t in the array, the function will correctly return -1, which is the expected behavior.\\n\\n3. Compiler, environment, or runtime error: There could be a problem with your development environment or a runtime error causing the code to fail.\\n\\nI would suggest first verifying that your input is a rotated sorted array and the target number exists in it. If you\\'re still having problems, please provide more information about the specific error or issue you\\'re encountering. \\n\\nRemember, the provided function\\'s time complexity is O(log n) as it utilizes the concept of Binary Search, making it a very efficient solution for large arrays."
                    },
                    {
                        "username": "agarwalkaran253",
                        "content": "The logic I am using is finding the position where the trend changes and then putting the limits of i and j and then applying binary search on it ,yet it is giving me the wrong answer?\\nany suggestions?\\nMy code below------->\\n\\nclass Solution {\\npublic:\\n    int search(vector<int>& nums, int target) {\\n        int low=0,high=nums.size()-1;\\n        while(low<high)\\n        {\\n            int mid=(low+high)/2;\\n            if(nums[mid]>nums[high])\\n            low=mid+1;\\n            else\\n            high=mid-1;\\n        }\\n        //return low;\\n        int i=0,j=0;\\n        if(target>nums[high]){\\n        i=0;j=low-1;}\\n        else{\\n        i=low;j=nums.size()-1;}\\n        while(i<j){\\n            int mids=(i+j)/2;\\n            if(nums[mids]==target)\\n            return mids;\\n            else if(nums[mids]>target)\\n                j=mids-1;\\n            else\\n                i=mids+1;\\n        }\\n        return j;\\n    }\\n};\\n\\n"
                    },
                    {
                        "username": "bparanj",
                        "content": "Your approach to solve the problem using binary search is correct but there are some issues with your implementation:\\n\\n1. After finding the smallest element, you need to check whether the target is in the first half or the second half of the rotated array and search in the correct half. However, in your code, you\\'re defining the boundaries `i` and `j` incorrectly. You should compare the target with `nums[0]` instead of `nums[high]` because `nums[0]` would be the starting point of either of the sorted halves of the array.\\n\\n2. In the second while loop, you\\'re using `while(i<j)`. But you should use `while(i<=j)` to ensure the loop runs when `i` and `j` point to the same element.\\n\\n3. In the return statement, you\\'re returning `j`, which is not correct. If the target is not found, you should return -1.\\n\\nHere is your corrected code:\\n\\n```cpp\\nclass Solution {\\npublic:\\n    int search(vector<int>& nums, int target) {\\n        int low=0, high=nums.size()-1;\\n        while(low<high)\\n        {\\n            int mid=(low+high)/2;\\n            if(nums[mid]>nums[high])\\n                low=mid+1;\\n            else\\n                high=mid;\\n        }\\n        // low is now pointing to smallest element\\n        int i=0, j=0;\\n        if(target>=nums[0]){ // target is in the first half\\n            i=0; j=low;\\n        }\\n        else{ // target is in the second half\\n            i=low; j=nums.size()-1;\\n        }\\n        while(i<=j){ // modified from i<j to i<=j\\n            int mid=(i+j)/2;\\n            if(nums[mid]==target)\\n                return mid;\\n            else if(nums[mid]>target)\\n                j=mid-1;\\n            else\\n                i=mid+1;\\n        }\\n        return -1; // return -1 if target not found\\n    }\\n};\\n```\\nWith these changes, your code should work correctly to find the target in the rotated sorted array.\\n"
                    },
                    {
                        "username": "Aman-kumar-a",
                        "content": "pls tell me what\\'s the error in code\\npls help!!\\nint search_pivot(vector<int> & nums)\\n{\\n   int s=0;\\n  int  e=nums.size()-1;\\n   int mid=s+ (e-s)/2;\\n    while(s<e)\\n    {\\n        if(nums[mid]>=nums[0])\\n        {\\n            s=mid+1;\\n        }\\n        else\\n        {\\n            e=mid;\\n        }\\n      mid=s+ (e-s)/2;\\n    }\\n    return s;\\n}\\nint binary_search(vector<int>& nums,int s,int e,int key)\\n{\\n   int  start=s;\\n   int  end=e;\\n   int  mid=start + (end-start)/2;\\n   while(start<=end)\\n   {\\n       if(nums[mid]==key)\\n       {\\n           return mid;\\n       }\\n       else if(nums[mid]<key)\\n       {\\n           start=mid+1;\\n       }\\n       else\\n       {\\n           end=mid-1;\\n       }\\n      mid=start + (end-start)/2;\\n   }\\n    return -1;\\n}\\n\\nclass Solution {\\npublic:\\n    int search(vector<int>& nums, int target) {\\n        int n=nums.size()-1;\\n        int pivot=search_pivot(nums);\\n        if(target>=pivot && target<=nums[n-1] )\\n        {\\n           return  binary_search(nums,pivot,n-1,target);\\n        }\\n        else\\n        {\\n           return binary_search(nums,0,pivot-1,target); \\n        }\\n    }\\n};"
                    },
                    {
                        "username": "deleted_user",
                        "content": "class Solution {\\n    public int search(int[] nums, int target) {\\n        \\n        int idx=0;\\n\\n        for(int i=0;i<nums.length;i++){\\n            if(nums[i]==target){\\n                idx=i;\\n                break;\\n            }\\n            else{\\n                idx=-1;\\n            }\\n        \\n        }\\n        return idx;\\n    }\\n}\\n\\nthis code passed all test cases, do we need to include rotation part also (BST)?"
                    },
                    {
                        "username": "ansal_kumar",
                        "content": "simple linear search "
                    },
                    {
                        "username": "shivbhankushwaha862003672001",
                        "content": "class Solution {\\npublic:\\n\\nint findPivot(vector<int> &arr, int n){\\n     int s = 0;\\n     int e = n-1;\\n     int mid = s +(e-s)/2;\\n    \\n    while(s<e){\\n        if(arr[mid] >= arr[0]){\\n            s = mid +1;\\n        }\\n        else{\\n            e = mid;\\n        }\\n        mid = s +(e-s)/2;\\n    }\\n    return s;\\n}\\n\\nint binarySearch(vector<int> &arr,int s,int e, int k){\\n    int start = s;\\n    int end = e;\\n    int mid = start + (end - start)/2;\\n    \\n    while(start <= end){\\n        if(arr[mid] == k){\\n            return mid;\\n        }\\n        else if(k > arr[mid]){\\n            start = mid +1 ;\\n        }\\n        else if(k<arr[mid]){\\n            end = mid -1;\\n        }\\n        mid = start + (end - start)/2;\\n    }\\n    return -1;\\n}\\n\\nint findPosition(vector<int>& arr, int n, int k)\\n{\\n   int pivot = findPivot(arr,n);\\n    if(k >= arr[pivot] && k <= arr[n-1]){\\n        return binarySearch(arr,pivot,n-1,k);\\n    }\\n    else{\\n        return binarySearch(arr,0,pivot-1,k);\\n    }\\n}\\n\\n\\n    int search(vector<int>& nums, int target) {\\n        int n = nums.size();\\n       return findPosition(nums,n,target);\\n    }\\n};"
                    },
                    {
                        "username": "SaikatDass",
                        "content": "Search in rotated sorted array | java program | O(log n) complexity\nclass Solution {\n    public int search(int[] nums, int target) {\n        int n = nums.length;\n        int min = minSearch(nums);\n        if(nums[min] <= target && target <= nums[n - 1]){\n            return search(nums, min, n-1, target);\n        }\n        else{\n            return search(nums, 0, min, target);\n        }\n    }\n    public static int search(int[] nums, int start, int end, int target){\n        while(start <= end){\n            int mid = start + (end - start) / 2;\n            if(nums[mid] == target){\n                return mid;\n            }\n            else if(nums[mid] > target){\n                end = mid - 1;\n            }\n            else{\n                start = mid + 1;\n            }\n        }\n        return -1;\n    }\n    public static int minSearch(int[] nums){\n            int start = 0;\n            int end = nums.length - 1;\n            while(start < end){\n                int mid = start + (end - start) / 2; \n                if(mid > 0 && nums[mid - 1] > nums[mid]){\n                    return mid;\n                }\n                else if(nums[start] <= nums[mid] && nums[mid] > nums[end]){\n                    start = mid + 1;\n                }\n                else{\n                    end = mid - 1;\n                }\n            }\n            return start;\n        }\n}"
                    },
                    {
                        "username": "Ankush175",
                        "content": " `class Solution {\\n    public int search(int[] nums, int target) {\\n\\n        int start=0;\\n        int end = nums.length-1;\\n\\n        while(start<=end){\\n\\n            int mid = start+(end-start)/2;\\n\\n            if(nums[mid] == target){\\n                return mid;\\n            }\\n\\n            if(nums[start]<=nums[mid]){\\n                // the elements between start and end are in ascending order\\n\\n                if(nums[start]<=target && target<nums[mid]){\\n                    //the elements between start and end are in ascending order and,\\n                    //if the target lies between start and mid, so update end\\n                    end=mid-1;\\n                }\\n                else{\\n                    //if not the element lies between mid and end, so update start\\n                    start = mid+1;\\n                }\\n            }\\n            else{\\n                //the elements between start and mid are not in ascending order,i.e they are in descending order,the elements after mid will be in ascending order.\\n                if(nums[mid]<target && target<=nums[end]){\\n                    start = mid+1;\\n                }\\n                else{\\n                    end = mid-1;\\n                }\\n\\n            }\\n\\n        }\\n        return -1;\\n        \\n    }\\n}`"
                    },
                    {
                        "username": "yashdeora",
                        "content": "Here is problem solution in Python, Java, C++ and C programming.\\n[https://www.gyangav.com/2022/11/leetcode-search-in-rotated-sorted-array-problem-solution.html](https://www.gyangav.com/2022/11/leetcode-search-in-rotated-sorted-array-problem-solution.html)"
                    },
                    {
                        "username": "Bhautikbhalala123",
                        "content": "https://zeroplusfour.com/search-in-rotated-sorted-array-leetcode-solution/\\n\\nFull OPTIMAL solution in Java , Python , C++ , C \\n\\nGet all the solution here at :\\nhttps://zeroplusfour.com/leetcode-all-array-solution-list-all-in-one-place/\\n"
                    }
                ]
            },
            {
                "id": 1698622,
                "content": [
                    {
                        "username": "imvillen69",
                        "content": "Help me to debug this code .\\nclass Solution {\\npublic:\\n    int search(vector<int>& nums, int target) {\\n        int l = 0,h = nums.size() - 1;\\n        while(l <= h){\\n        int m = (l + (h - l))>>1;\\n        if(nums[m] == target)\\n            return m;\\n//left half is sorted.\\n        if(nums[l] <= nums[m])\\n        {\\n            if(target >= nums[l] && target <= nums[m]) //lies in range ..\\n            h = m - 1;\\n            else\\n            l = m + 1;\\n        }\\n//right half is sorted.\\n        else\\n        {\\n           if(target >= nums[m] && target <= nums[h]) // lies in range..\\n            l = m + 1;\\n            else\\n            h = m - 1; \\n        }\\n    }\\n        return - 1;\\n    }\\n};"
                    },
                    {
                        "username": "bparanj",
                        "content": "Your code appears to be correct for a binary search within a rotated sorted array. If the function doesn\\'t work as expected, there could be a few reasons why:\\n\\n1. The `vector` might not be sorted or properly rotated: This code assumes that the input `vector` is a sorted array that has been rotated. If it\\'s not, the code might not work as expected.\\n\\n2. The target number might not exist in the array: If the number you\\'re looking for isn\\'t in the array, the function will correctly return -1, which is the expected behavior.\\n\\n3. Compiler, environment, or runtime error: There could be a problem with your development environment or a runtime error causing the code to fail.\\n\\nI would suggest first verifying that your input is a rotated sorted array and the target number exists in it. If you\\'re still having problems, please provide more information about the specific error or issue you\\'re encountering. \\n\\nRemember, the provided function\\'s time complexity is O(log n) as it utilizes the concept of Binary Search, making it a very efficient solution for large arrays."
                    },
                    {
                        "username": "agarwalkaran253",
                        "content": "The logic I am using is finding the position where the trend changes and then putting the limits of i and j and then applying binary search on it ,yet it is giving me the wrong answer?\\nany suggestions?\\nMy code below------->\\n\\nclass Solution {\\npublic:\\n    int search(vector<int>& nums, int target) {\\n        int low=0,high=nums.size()-1;\\n        while(low<high)\\n        {\\n            int mid=(low+high)/2;\\n            if(nums[mid]>nums[high])\\n            low=mid+1;\\n            else\\n            high=mid-1;\\n        }\\n        //return low;\\n        int i=0,j=0;\\n        if(target>nums[high]){\\n        i=0;j=low-1;}\\n        else{\\n        i=low;j=nums.size()-1;}\\n        while(i<j){\\n            int mids=(i+j)/2;\\n            if(nums[mids]==target)\\n            return mids;\\n            else if(nums[mids]>target)\\n                j=mids-1;\\n            else\\n                i=mids+1;\\n        }\\n        return j;\\n    }\\n};\\n\\n"
                    },
                    {
                        "username": "bparanj",
                        "content": "Your approach to solve the problem using binary search is correct but there are some issues with your implementation:\\n\\n1. After finding the smallest element, you need to check whether the target is in the first half or the second half of the rotated array and search in the correct half. However, in your code, you\\'re defining the boundaries `i` and `j` incorrectly. You should compare the target with `nums[0]` instead of `nums[high]` because `nums[0]` would be the starting point of either of the sorted halves of the array.\\n\\n2. In the second while loop, you\\'re using `while(i<j)`. But you should use `while(i<=j)` to ensure the loop runs when `i` and `j` point to the same element.\\n\\n3. In the return statement, you\\'re returning `j`, which is not correct. If the target is not found, you should return -1.\\n\\nHere is your corrected code:\\n\\n```cpp\\nclass Solution {\\npublic:\\n    int search(vector<int>& nums, int target) {\\n        int low=0, high=nums.size()-1;\\n        while(low<high)\\n        {\\n            int mid=(low+high)/2;\\n            if(nums[mid]>nums[high])\\n                low=mid+1;\\n            else\\n                high=mid;\\n        }\\n        // low is now pointing to smallest element\\n        int i=0, j=0;\\n        if(target>=nums[0]){ // target is in the first half\\n            i=0; j=low;\\n        }\\n        else{ // target is in the second half\\n            i=low; j=nums.size()-1;\\n        }\\n        while(i<=j){ // modified from i<j to i<=j\\n            int mid=(i+j)/2;\\n            if(nums[mid]==target)\\n                return mid;\\n            else if(nums[mid]>target)\\n                j=mid-1;\\n            else\\n                i=mid+1;\\n        }\\n        return -1; // return -1 if target not found\\n    }\\n};\\n```\\nWith these changes, your code should work correctly to find the target in the rotated sorted array.\\n"
                    },
                    {
                        "username": "Aman-kumar-a",
                        "content": "pls tell me what\\'s the error in code\\npls help!!\\nint search_pivot(vector<int> & nums)\\n{\\n   int s=0;\\n  int  e=nums.size()-1;\\n   int mid=s+ (e-s)/2;\\n    while(s<e)\\n    {\\n        if(nums[mid]>=nums[0])\\n        {\\n            s=mid+1;\\n        }\\n        else\\n        {\\n            e=mid;\\n        }\\n      mid=s+ (e-s)/2;\\n    }\\n    return s;\\n}\\nint binary_search(vector<int>& nums,int s,int e,int key)\\n{\\n   int  start=s;\\n   int  end=e;\\n   int  mid=start + (end-start)/2;\\n   while(start<=end)\\n   {\\n       if(nums[mid]==key)\\n       {\\n           return mid;\\n       }\\n       else if(nums[mid]<key)\\n       {\\n           start=mid+1;\\n       }\\n       else\\n       {\\n           end=mid-1;\\n       }\\n      mid=start + (end-start)/2;\\n   }\\n    return -1;\\n}\\n\\nclass Solution {\\npublic:\\n    int search(vector<int>& nums, int target) {\\n        int n=nums.size()-1;\\n        int pivot=search_pivot(nums);\\n        if(target>=pivot && target<=nums[n-1] )\\n        {\\n           return  binary_search(nums,pivot,n-1,target);\\n        }\\n        else\\n        {\\n           return binary_search(nums,0,pivot-1,target); \\n        }\\n    }\\n};"
                    },
                    {
                        "username": "deleted_user",
                        "content": "class Solution {\\n    public int search(int[] nums, int target) {\\n        \\n        int idx=0;\\n\\n        for(int i=0;i<nums.length;i++){\\n            if(nums[i]==target){\\n                idx=i;\\n                break;\\n            }\\n            else{\\n                idx=-1;\\n            }\\n        \\n        }\\n        return idx;\\n    }\\n}\\n\\nthis code passed all test cases, do we need to include rotation part also (BST)?"
                    },
                    {
                        "username": "ansal_kumar",
                        "content": "simple linear search "
                    },
                    {
                        "username": "shivbhankushwaha862003672001",
                        "content": "class Solution {\\npublic:\\n\\nint findPivot(vector<int> &arr, int n){\\n     int s = 0;\\n     int e = n-1;\\n     int mid = s +(e-s)/2;\\n    \\n    while(s<e){\\n        if(arr[mid] >= arr[0]){\\n            s = mid +1;\\n        }\\n        else{\\n            e = mid;\\n        }\\n        mid = s +(e-s)/2;\\n    }\\n    return s;\\n}\\n\\nint binarySearch(vector<int> &arr,int s,int e, int k){\\n    int start = s;\\n    int end = e;\\n    int mid = start + (end - start)/2;\\n    \\n    while(start <= end){\\n        if(arr[mid] == k){\\n            return mid;\\n        }\\n        else if(k > arr[mid]){\\n            start = mid +1 ;\\n        }\\n        else if(k<arr[mid]){\\n            end = mid -1;\\n        }\\n        mid = start + (end - start)/2;\\n    }\\n    return -1;\\n}\\n\\nint findPosition(vector<int>& arr, int n, int k)\\n{\\n   int pivot = findPivot(arr,n);\\n    if(k >= arr[pivot] && k <= arr[n-1]){\\n        return binarySearch(arr,pivot,n-1,k);\\n    }\\n    else{\\n        return binarySearch(arr,0,pivot-1,k);\\n    }\\n}\\n\\n\\n    int search(vector<int>& nums, int target) {\\n        int n = nums.size();\\n       return findPosition(nums,n,target);\\n    }\\n};"
                    },
                    {
                        "username": "SaikatDass",
                        "content": "Search in rotated sorted array | java program | O(log n) complexity\nclass Solution {\n    public int search(int[] nums, int target) {\n        int n = nums.length;\n        int min = minSearch(nums);\n        if(nums[min] <= target && target <= nums[n - 1]){\n            return search(nums, min, n-1, target);\n        }\n        else{\n            return search(nums, 0, min, target);\n        }\n    }\n    public static int search(int[] nums, int start, int end, int target){\n        while(start <= end){\n            int mid = start + (end - start) / 2;\n            if(nums[mid] == target){\n                return mid;\n            }\n            else if(nums[mid] > target){\n                end = mid - 1;\n            }\n            else{\n                start = mid + 1;\n            }\n        }\n        return -1;\n    }\n    public static int minSearch(int[] nums){\n            int start = 0;\n            int end = nums.length - 1;\n            while(start < end){\n                int mid = start + (end - start) / 2; \n                if(mid > 0 && nums[mid - 1] > nums[mid]){\n                    return mid;\n                }\n                else if(nums[start] <= nums[mid] && nums[mid] > nums[end]){\n                    start = mid + 1;\n                }\n                else{\n                    end = mid - 1;\n                }\n            }\n            return start;\n        }\n}"
                    },
                    {
                        "username": "Ankush175",
                        "content": " `class Solution {\\n    public int search(int[] nums, int target) {\\n\\n        int start=0;\\n        int end = nums.length-1;\\n\\n        while(start<=end){\\n\\n            int mid = start+(end-start)/2;\\n\\n            if(nums[mid] == target){\\n                return mid;\\n            }\\n\\n            if(nums[start]<=nums[mid]){\\n                // the elements between start and end are in ascending order\\n\\n                if(nums[start]<=target && target<nums[mid]){\\n                    //the elements between start and end are in ascending order and,\\n                    //if the target lies between start and mid, so update end\\n                    end=mid-1;\\n                }\\n                else{\\n                    //if not the element lies between mid and end, so update start\\n                    start = mid+1;\\n                }\\n            }\\n            else{\\n                //the elements between start and mid are not in ascending order,i.e they are in descending order,the elements after mid will be in ascending order.\\n                if(nums[mid]<target && target<=nums[end]){\\n                    start = mid+1;\\n                }\\n                else{\\n                    end = mid-1;\\n                }\\n\\n            }\\n\\n        }\\n        return -1;\\n        \\n    }\\n}`"
                    },
                    {
                        "username": "yashdeora",
                        "content": "Here is problem solution in Python, Java, C++ and C programming.\\n[https://www.gyangav.com/2022/11/leetcode-search-in-rotated-sorted-array-problem-solution.html](https://www.gyangav.com/2022/11/leetcode-search-in-rotated-sorted-array-problem-solution.html)"
                    },
                    {
                        "username": "Bhautikbhalala123",
                        "content": "https://zeroplusfour.com/search-in-rotated-sorted-array-leetcode-solution/\\n\\nFull OPTIMAL solution in Java , Python , C++ , C \\n\\nGet all the solution here at :\\nhttps://zeroplusfour.com/leetcode-all-array-solution-list-all-in-one-place/\\n"
                    }
                ]
            },
            {
                "id": 1694716,
                "content": [
                    {
                        "username": "imvillen69",
                        "content": "Help me to debug this code .\\nclass Solution {\\npublic:\\n    int search(vector<int>& nums, int target) {\\n        int l = 0,h = nums.size() - 1;\\n        while(l <= h){\\n        int m = (l + (h - l))>>1;\\n        if(nums[m] == target)\\n            return m;\\n//left half is sorted.\\n        if(nums[l] <= nums[m])\\n        {\\n            if(target >= nums[l] && target <= nums[m]) //lies in range ..\\n            h = m - 1;\\n            else\\n            l = m + 1;\\n        }\\n//right half is sorted.\\n        else\\n        {\\n           if(target >= nums[m] && target <= nums[h]) // lies in range..\\n            l = m + 1;\\n            else\\n            h = m - 1; \\n        }\\n    }\\n        return - 1;\\n    }\\n};"
                    },
                    {
                        "username": "bparanj",
                        "content": "Your code appears to be correct for a binary search within a rotated sorted array. If the function doesn\\'t work as expected, there could be a few reasons why:\\n\\n1. The `vector` might not be sorted or properly rotated: This code assumes that the input `vector` is a sorted array that has been rotated. If it\\'s not, the code might not work as expected.\\n\\n2. The target number might not exist in the array: If the number you\\'re looking for isn\\'t in the array, the function will correctly return -1, which is the expected behavior.\\n\\n3. Compiler, environment, or runtime error: There could be a problem with your development environment or a runtime error causing the code to fail.\\n\\nI would suggest first verifying that your input is a rotated sorted array and the target number exists in it. If you\\'re still having problems, please provide more information about the specific error or issue you\\'re encountering. \\n\\nRemember, the provided function\\'s time complexity is O(log n) as it utilizes the concept of Binary Search, making it a very efficient solution for large arrays."
                    },
                    {
                        "username": "agarwalkaran253",
                        "content": "The logic I am using is finding the position where the trend changes and then putting the limits of i and j and then applying binary search on it ,yet it is giving me the wrong answer?\\nany suggestions?\\nMy code below------->\\n\\nclass Solution {\\npublic:\\n    int search(vector<int>& nums, int target) {\\n        int low=0,high=nums.size()-1;\\n        while(low<high)\\n        {\\n            int mid=(low+high)/2;\\n            if(nums[mid]>nums[high])\\n            low=mid+1;\\n            else\\n            high=mid-1;\\n        }\\n        //return low;\\n        int i=0,j=0;\\n        if(target>nums[high]){\\n        i=0;j=low-1;}\\n        else{\\n        i=low;j=nums.size()-1;}\\n        while(i<j){\\n            int mids=(i+j)/2;\\n            if(nums[mids]==target)\\n            return mids;\\n            else if(nums[mids]>target)\\n                j=mids-1;\\n            else\\n                i=mids+1;\\n        }\\n        return j;\\n    }\\n};\\n\\n"
                    },
                    {
                        "username": "bparanj",
                        "content": "Your approach to solve the problem using binary search is correct but there are some issues with your implementation:\\n\\n1. After finding the smallest element, you need to check whether the target is in the first half or the second half of the rotated array and search in the correct half. However, in your code, you\\'re defining the boundaries `i` and `j` incorrectly. You should compare the target with `nums[0]` instead of `nums[high]` because `nums[0]` would be the starting point of either of the sorted halves of the array.\\n\\n2. In the second while loop, you\\'re using `while(i<j)`. But you should use `while(i<=j)` to ensure the loop runs when `i` and `j` point to the same element.\\n\\n3. In the return statement, you\\'re returning `j`, which is not correct. If the target is not found, you should return -1.\\n\\nHere is your corrected code:\\n\\n```cpp\\nclass Solution {\\npublic:\\n    int search(vector<int>& nums, int target) {\\n        int low=0, high=nums.size()-1;\\n        while(low<high)\\n        {\\n            int mid=(low+high)/2;\\n            if(nums[mid]>nums[high])\\n                low=mid+1;\\n            else\\n                high=mid;\\n        }\\n        // low is now pointing to smallest element\\n        int i=0, j=0;\\n        if(target>=nums[0]){ // target is in the first half\\n            i=0; j=low;\\n        }\\n        else{ // target is in the second half\\n            i=low; j=nums.size()-1;\\n        }\\n        while(i<=j){ // modified from i<j to i<=j\\n            int mid=(i+j)/2;\\n            if(nums[mid]==target)\\n                return mid;\\n            else if(nums[mid]>target)\\n                j=mid-1;\\n            else\\n                i=mid+1;\\n        }\\n        return -1; // return -1 if target not found\\n    }\\n};\\n```\\nWith these changes, your code should work correctly to find the target in the rotated sorted array.\\n"
                    },
                    {
                        "username": "Aman-kumar-a",
                        "content": "pls tell me what\\'s the error in code\\npls help!!\\nint search_pivot(vector<int> & nums)\\n{\\n   int s=0;\\n  int  e=nums.size()-1;\\n   int mid=s+ (e-s)/2;\\n    while(s<e)\\n    {\\n        if(nums[mid]>=nums[0])\\n        {\\n            s=mid+1;\\n        }\\n        else\\n        {\\n            e=mid;\\n        }\\n      mid=s+ (e-s)/2;\\n    }\\n    return s;\\n}\\nint binary_search(vector<int>& nums,int s,int e,int key)\\n{\\n   int  start=s;\\n   int  end=e;\\n   int  mid=start + (end-start)/2;\\n   while(start<=end)\\n   {\\n       if(nums[mid]==key)\\n       {\\n           return mid;\\n       }\\n       else if(nums[mid]<key)\\n       {\\n           start=mid+1;\\n       }\\n       else\\n       {\\n           end=mid-1;\\n       }\\n      mid=start + (end-start)/2;\\n   }\\n    return -1;\\n}\\n\\nclass Solution {\\npublic:\\n    int search(vector<int>& nums, int target) {\\n        int n=nums.size()-1;\\n        int pivot=search_pivot(nums);\\n        if(target>=pivot && target<=nums[n-1] )\\n        {\\n           return  binary_search(nums,pivot,n-1,target);\\n        }\\n        else\\n        {\\n           return binary_search(nums,0,pivot-1,target); \\n        }\\n    }\\n};"
                    },
                    {
                        "username": "deleted_user",
                        "content": "class Solution {\\n    public int search(int[] nums, int target) {\\n        \\n        int idx=0;\\n\\n        for(int i=0;i<nums.length;i++){\\n            if(nums[i]==target){\\n                idx=i;\\n                break;\\n            }\\n            else{\\n                idx=-1;\\n            }\\n        \\n        }\\n        return idx;\\n    }\\n}\\n\\nthis code passed all test cases, do we need to include rotation part also (BST)?"
                    },
                    {
                        "username": "ansal_kumar",
                        "content": "simple linear search "
                    },
                    {
                        "username": "shivbhankushwaha862003672001",
                        "content": "class Solution {\\npublic:\\n\\nint findPivot(vector<int> &arr, int n){\\n     int s = 0;\\n     int e = n-1;\\n     int mid = s +(e-s)/2;\\n    \\n    while(s<e){\\n        if(arr[mid] >= arr[0]){\\n            s = mid +1;\\n        }\\n        else{\\n            e = mid;\\n        }\\n        mid = s +(e-s)/2;\\n    }\\n    return s;\\n}\\n\\nint binarySearch(vector<int> &arr,int s,int e, int k){\\n    int start = s;\\n    int end = e;\\n    int mid = start + (end - start)/2;\\n    \\n    while(start <= end){\\n        if(arr[mid] == k){\\n            return mid;\\n        }\\n        else if(k > arr[mid]){\\n            start = mid +1 ;\\n        }\\n        else if(k<arr[mid]){\\n            end = mid -1;\\n        }\\n        mid = start + (end - start)/2;\\n    }\\n    return -1;\\n}\\n\\nint findPosition(vector<int>& arr, int n, int k)\\n{\\n   int pivot = findPivot(arr,n);\\n    if(k >= arr[pivot] && k <= arr[n-1]){\\n        return binarySearch(arr,pivot,n-1,k);\\n    }\\n    else{\\n        return binarySearch(arr,0,pivot-1,k);\\n    }\\n}\\n\\n\\n    int search(vector<int>& nums, int target) {\\n        int n = nums.size();\\n       return findPosition(nums,n,target);\\n    }\\n};"
                    },
                    {
                        "username": "SaikatDass",
                        "content": "Search in rotated sorted array | java program | O(log n) complexity\nclass Solution {\n    public int search(int[] nums, int target) {\n        int n = nums.length;\n        int min = minSearch(nums);\n        if(nums[min] <= target && target <= nums[n - 1]){\n            return search(nums, min, n-1, target);\n        }\n        else{\n            return search(nums, 0, min, target);\n        }\n    }\n    public static int search(int[] nums, int start, int end, int target){\n        while(start <= end){\n            int mid = start + (end - start) / 2;\n            if(nums[mid] == target){\n                return mid;\n            }\n            else if(nums[mid] > target){\n                end = mid - 1;\n            }\n            else{\n                start = mid + 1;\n            }\n        }\n        return -1;\n    }\n    public static int minSearch(int[] nums){\n            int start = 0;\n            int end = nums.length - 1;\n            while(start < end){\n                int mid = start + (end - start) / 2; \n                if(mid > 0 && nums[mid - 1] > nums[mid]){\n                    return mid;\n                }\n                else if(nums[start] <= nums[mid] && nums[mid] > nums[end]){\n                    start = mid + 1;\n                }\n                else{\n                    end = mid - 1;\n                }\n            }\n            return start;\n        }\n}"
                    },
                    {
                        "username": "Ankush175",
                        "content": " `class Solution {\\n    public int search(int[] nums, int target) {\\n\\n        int start=0;\\n        int end = nums.length-1;\\n\\n        while(start<=end){\\n\\n            int mid = start+(end-start)/2;\\n\\n            if(nums[mid] == target){\\n                return mid;\\n            }\\n\\n            if(nums[start]<=nums[mid]){\\n                // the elements between start and end are in ascending order\\n\\n                if(nums[start]<=target && target<nums[mid]){\\n                    //the elements between start and end are in ascending order and,\\n                    //if the target lies between start and mid, so update end\\n                    end=mid-1;\\n                }\\n                else{\\n                    //if not the element lies between mid and end, so update start\\n                    start = mid+1;\\n                }\\n            }\\n            else{\\n                //the elements between start and mid are not in ascending order,i.e they are in descending order,the elements after mid will be in ascending order.\\n                if(nums[mid]<target && target<=nums[end]){\\n                    start = mid+1;\\n                }\\n                else{\\n                    end = mid-1;\\n                }\\n\\n            }\\n\\n        }\\n        return -1;\\n        \\n    }\\n}`"
                    },
                    {
                        "username": "yashdeora",
                        "content": "Here is problem solution in Python, Java, C++ and C programming.\\n[https://www.gyangav.com/2022/11/leetcode-search-in-rotated-sorted-array-problem-solution.html](https://www.gyangav.com/2022/11/leetcode-search-in-rotated-sorted-array-problem-solution.html)"
                    },
                    {
                        "username": "Bhautikbhalala123",
                        "content": "https://zeroplusfour.com/search-in-rotated-sorted-array-leetcode-solution/\\n\\nFull OPTIMAL solution in Java , Python , C++ , C \\n\\nGet all the solution here at :\\nhttps://zeroplusfour.com/leetcode-all-array-solution-list-all-in-one-place/\\n"
                    }
                ]
            },
            {
                "id": 1673808,
                "content": [
                    {
                        "username": "imvillen69",
                        "content": "Help me to debug this code .\\nclass Solution {\\npublic:\\n    int search(vector<int>& nums, int target) {\\n        int l = 0,h = nums.size() - 1;\\n        while(l <= h){\\n        int m = (l + (h - l))>>1;\\n        if(nums[m] == target)\\n            return m;\\n//left half is sorted.\\n        if(nums[l] <= nums[m])\\n        {\\n            if(target >= nums[l] && target <= nums[m]) //lies in range ..\\n            h = m - 1;\\n            else\\n            l = m + 1;\\n        }\\n//right half is sorted.\\n        else\\n        {\\n           if(target >= nums[m] && target <= nums[h]) // lies in range..\\n            l = m + 1;\\n            else\\n            h = m - 1; \\n        }\\n    }\\n        return - 1;\\n    }\\n};"
                    },
                    {
                        "username": "bparanj",
                        "content": "Your code appears to be correct for a binary search within a rotated sorted array. If the function doesn\\'t work as expected, there could be a few reasons why:\\n\\n1. The `vector` might not be sorted or properly rotated: This code assumes that the input `vector` is a sorted array that has been rotated. If it\\'s not, the code might not work as expected.\\n\\n2. The target number might not exist in the array: If the number you\\'re looking for isn\\'t in the array, the function will correctly return -1, which is the expected behavior.\\n\\n3. Compiler, environment, or runtime error: There could be a problem with your development environment or a runtime error causing the code to fail.\\n\\nI would suggest first verifying that your input is a rotated sorted array and the target number exists in it. If you\\'re still having problems, please provide more information about the specific error or issue you\\'re encountering. \\n\\nRemember, the provided function\\'s time complexity is O(log n) as it utilizes the concept of Binary Search, making it a very efficient solution for large arrays."
                    },
                    {
                        "username": "agarwalkaran253",
                        "content": "The logic I am using is finding the position where the trend changes and then putting the limits of i and j and then applying binary search on it ,yet it is giving me the wrong answer?\\nany suggestions?\\nMy code below------->\\n\\nclass Solution {\\npublic:\\n    int search(vector<int>& nums, int target) {\\n        int low=0,high=nums.size()-1;\\n        while(low<high)\\n        {\\n            int mid=(low+high)/2;\\n            if(nums[mid]>nums[high])\\n            low=mid+1;\\n            else\\n            high=mid-1;\\n        }\\n        //return low;\\n        int i=0,j=0;\\n        if(target>nums[high]){\\n        i=0;j=low-1;}\\n        else{\\n        i=low;j=nums.size()-1;}\\n        while(i<j){\\n            int mids=(i+j)/2;\\n            if(nums[mids]==target)\\n            return mids;\\n            else if(nums[mids]>target)\\n                j=mids-1;\\n            else\\n                i=mids+1;\\n        }\\n        return j;\\n    }\\n};\\n\\n"
                    },
                    {
                        "username": "bparanj",
                        "content": "Your approach to solve the problem using binary search is correct but there are some issues with your implementation:\\n\\n1. After finding the smallest element, you need to check whether the target is in the first half or the second half of the rotated array and search in the correct half. However, in your code, you\\'re defining the boundaries `i` and `j` incorrectly. You should compare the target with `nums[0]` instead of `nums[high]` because `nums[0]` would be the starting point of either of the sorted halves of the array.\\n\\n2. In the second while loop, you\\'re using `while(i<j)`. But you should use `while(i<=j)` to ensure the loop runs when `i` and `j` point to the same element.\\n\\n3. In the return statement, you\\'re returning `j`, which is not correct. If the target is not found, you should return -1.\\n\\nHere is your corrected code:\\n\\n```cpp\\nclass Solution {\\npublic:\\n    int search(vector<int>& nums, int target) {\\n        int low=0, high=nums.size()-1;\\n        while(low<high)\\n        {\\n            int mid=(low+high)/2;\\n            if(nums[mid]>nums[high])\\n                low=mid+1;\\n            else\\n                high=mid;\\n        }\\n        // low is now pointing to smallest element\\n        int i=0, j=0;\\n        if(target>=nums[0]){ // target is in the first half\\n            i=0; j=low;\\n        }\\n        else{ // target is in the second half\\n            i=low; j=nums.size()-1;\\n        }\\n        while(i<=j){ // modified from i<j to i<=j\\n            int mid=(i+j)/2;\\n            if(nums[mid]==target)\\n                return mid;\\n            else if(nums[mid]>target)\\n                j=mid-1;\\n            else\\n                i=mid+1;\\n        }\\n        return -1; // return -1 if target not found\\n    }\\n};\\n```\\nWith these changes, your code should work correctly to find the target in the rotated sorted array.\\n"
                    },
                    {
                        "username": "Aman-kumar-a",
                        "content": "pls tell me what\\'s the error in code\\npls help!!\\nint search_pivot(vector<int> & nums)\\n{\\n   int s=0;\\n  int  e=nums.size()-1;\\n   int mid=s+ (e-s)/2;\\n    while(s<e)\\n    {\\n        if(nums[mid]>=nums[0])\\n        {\\n            s=mid+1;\\n        }\\n        else\\n        {\\n            e=mid;\\n        }\\n      mid=s+ (e-s)/2;\\n    }\\n    return s;\\n}\\nint binary_search(vector<int>& nums,int s,int e,int key)\\n{\\n   int  start=s;\\n   int  end=e;\\n   int  mid=start + (end-start)/2;\\n   while(start<=end)\\n   {\\n       if(nums[mid]==key)\\n       {\\n           return mid;\\n       }\\n       else if(nums[mid]<key)\\n       {\\n           start=mid+1;\\n       }\\n       else\\n       {\\n           end=mid-1;\\n       }\\n      mid=start + (end-start)/2;\\n   }\\n    return -1;\\n}\\n\\nclass Solution {\\npublic:\\n    int search(vector<int>& nums, int target) {\\n        int n=nums.size()-1;\\n        int pivot=search_pivot(nums);\\n        if(target>=pivot && target<=nums[n-1] )\\n        {\\n           return  binary_search(nums,pivot,n-1,target);\\n        }\\n        else\\n        {\\n           return binary_search(nums,0,pivot-1,target); \\n        }\\n    }\\n};"
                    },
                    {
                        "username": "deleted_user",
                        "content": "class Solution {\\n    public int search(int[] nums, int target) {\\n        \\n        int idx=0;\\n\\n        for(int i=0;i<nums.length;i++){\\n            if(nums[i]==target){\\n                idx=i;\\n                break;\\n            }\\n            else{\\n                idx=-1;\\n            }\\n        \\n        }\\n        return idx;\\n    }\\n}\\n\\nthis code passed all test cases, do we need to include rotation part also (BST)?"
                    },
                    {
                        "username": "ansal_kumar",
                        "content": "simple linear search "
                    },
                    {
                        "username": "shivbhankushwaha862003672001",
                        "content": "class Solution {\\npublic:\\n\\nint findPivot(vector<int> &arr, int n){\\n     int s = 0;\\n     int e = n-1;\\n     int mid = s +(e-s)/2;\\n    \\n    while(s<e){\\n        if(arr[mid] >= arr[0]){\\n            s = mid +1;\\n        }\\n        else{\\n            e = mid;\\n        }\\n        mid = s +(e-s)/2;\\n    }\\n    return s;\\n}\\n\\nint binarySearch(vector<int> &arr,int s,int e, int k){\\n    int start = s;\\n    int end = e;\\n    int mid = start + (end - start)/2;\\n    \\n    while(start <= end){\\n        if(arr[mid] == k){\\n            return mid;\\n        }\\n        else if(k > arr[mid]){\\n            start = mid +1 ;\\n        }\\n        else if(k<arr[mid]){\\n            end = mid -1;\\n        }\\n        mid = start + (end - start)/2;\\n    }\\n    return -1;\\n}\\n\\nint findPosition(vector<int>& arr, int n, int k)\\n{\\n   int pivot = findPivot(arr,n);\\n    if(k >= arr[pivot] && k <= arr[n-1]){\\n        return binarySearch(arr,pivot,n-1,k);\\n    }\\n    else{\\n        return binarySearch(arr,0,pivot-1,k);\\n    }\\n}\\n\\n\\n    int search(vector<int>& nums, int target) {\\n        int n = nums.size();\\n       return findPosition(nums,n,target);\\n    }\\n};"
                    },
                    {
                        "username": "SaikatDass",
                        "content": "Search in rotated sorted array | java program | O(log n) complexity\nclass Solution {\n    public int search(int[] nums, int target) {\n        int n = nums.length;\n        int min = minSearch(nums);\n        if(nums[min] <= target && target <= nums[n - 1]){\n            return search(nums, min, n-1, target);\n        }\n        else{\n            return search(nums, 0, min, target);\n        }\n    }\n    public static int search(int[] nums, int start, int end, int target){\n        while(start <= end){\n            int mid = start + (end - start) / 2;\n            if(nums[mid] == target){\n                return mid;\n            }\n            else if(nums[mid] > target){\n                end = mid - 1;\n            }\n            else{\n                start = mid + 1;\n            }\n        }\n        return -1;\n    }\n    public static int minSearch(int[] nums){\n            int start = 0;\n            int end = nums.length - 1;\n            while(start < end){\n                int mid = start + (end - start) / 2; \n                if(mid > 0 && nums[mid - 1] > nums[mid]){\n                    return mid;\n                }\n                else if(nums[start] <= nums[mid] && nums[mid] > nums[end]){\n                    start = mid + 1;\n                }\n                else{\n                    end = mid - 1;\n                }\n            }\n            return start;\n        }\n}"
                    },
                    {
                        "username": "Ankush175",
                        "content": " `class Solution {\\n    public int search(int[] nums, int target) {\\n\\n        int start=0;\\n        int end = nums.length-1;\\n\\n        while(start<=end){\\n\\n            int mid = start+(end-start)/2;\\n\\n            if(nums[mid] == target){\\n                return mid;\\n            }\\n\\n            if(nums[start]<=nums[mid]){\\n                // the elements between start and end are in ascending order\\n\\n                if(nums[start]<=target && target<nums[mid]){\\n                    //the elements between start and end are in ascending order and,\\n                    //if the target lies between start and mid, so update end\\n                    end=mid-1;\\n                }\\n                else{\\n                    //if not the element lies between mid and end, so update start\\n                    start = mid+1;\\n                }\\n            }\\n            else{\\n                //the elements between start and mid are not in ascending order,i.e they are in descending order,the elements after mid will be in ascending order.\\n                if(nums[mid]<target && target<=nums[end]){\\n                    start = mid+1;\\n                }\\n                else{\\n                    end = mid-1;\\n                }\\n\\n            }\\n\\n        }\\n        return -1;\\n        \\n    }\\n}`"
                    },
                    {
                        "username": "yashdeora",
                        "content": "Here is problem solution in Python, Java, C++ and C programming.\\n[https://www.gyangav.com/2022/11/leetcode-search-in-rotated-sorted-array-problem-solution.html](https://www.gyangav.com/2022/11/leetcode-search-in-rotated-sorted-array-problem-solution.html)"
                    },
                    {
                        "username": "Bhautikbhalala123",
                        "content": "https://zeroplusfour.com/search-in-rotated-sorted-array-leetcode-solution/\\n\\nFull OPTIMAL solution in Java , Python , C++ , C \\n\\nGet all the solution here at :\\nhttps://zeroplusfour.com/leetcode-all-array-solution-list-all-in-one-place/\\n"
                    }
                ]
            },
            {
                "id": 1671299,
                "content": [
                    {
                        "username": "imvillen69",
                        "content": "Help me to debug this code .\\nclass Solution {\\npublic:\\n    int search(vector<int>& nums, int target) {\\n        int l = 0,h = nums.size() - 1;\\n        while(l <= h){\\n        int m = (l + (h - l))>>1;\\n        if(nums[m] == target)\\n            return m;\\n//left half is sorted.\\n        if(nums[l] <= nums[m])\\n        {\\n            if(target >= nums[l] && target <= nums[m]) //lies in range ..\\n            h = m - 1;\\n            else\\n            l = m + 1;\\n        }\\n//right half is sorted.\\n        else\\n        {\\n           if(target >= nums[m] && target <= nums[h]) // lies in range..\\n            l = m + 1;\\n            else\\n            h = m - 1; \\n        }\\n    }\\n        return - 1;\\n    }\\n};"
                    },
                    {
                        "username": "bparanj",
                        "content": "Your code appears to be correct for a binary search within a rotated sorted array. If the function doesn\\'t work as expected, there could be a few reasons why:\\n\\n1. The `vector` might not be sorted or properly rotated: This code assumes that the input `vector` is a sorted array that has been rotated. If it\\'s not, the code might not work as expected.\\n\\n2. The target number might not exist in the array: If the number you\\'re looking for isn\\'t in the array, the function will correctly return -1, which is the expected behavior.\\n\\n3. Compiler, environment, or runtime error: There could be a problem with your development environment or a runtime error causing the code to fail.\\n\\nI would suggest first verifying that your input is a rotated sorted array and the target number exists in it. If you\\'re still having problems, please provide more information about the specific error or issue you\\'re encountering. \\n\\nRemember, the provided function\\'s time complexity is O(log n) as it utilizes the concept of Binary Search, making it a very efficient solution for large arrays."
                    },
                    {
                        "username": "agarwalkaran253",
                        "content": "The logic I am using is finding the position where the trend changes and then putting the limits of i and j and then applying binary search on it ,yet it is giving me the wrong answer?\\nany suggestions?\\nMy code below------->\\n\\nclass Solution {\\npublic:\\n    int search(vector<int>& nums, int target) {\\n        int low=0,high=nums.size()-1;\\n        while(low<high)\\n        {\\n            int mid=(low+high)/2;\\n            if(nums[mid]>nums[high])\\n            low=mid+1;\\n            else\\n            high=mid-1;\\n        }\\n        //return low;\\n        int i=0,j=0;\\n        if(target>nums[high]){\\n        i=0;j=low-1;}\\n        else{\\n        i=low;j=nums.size()-1;}\\n        while(i<j){\\n            int mids=(i+j)/2;\\n            if(nums[mids]==target)\\n            return mids;\\n            else if(nums[mids]>target)\\n                j=mids-1;\\n            else\\n                i=mids+1;\\n        }\\n        return j;\\n    }\\n};\\n\\n"
                    },
                    {
                        "username": "bparanj",
                        "content": "Your approach to solve the problem using binary search is correct but there are some issues with your implementation:\\n\\n1. After finding the smallest element, you need to check whether the target is in the first half or the second half of the rotated array and search in the correct half. However, in your code, you\\'re defining the boundaries `i` and `j` incorrectly. You should compare the target with `nums[0]` instead of `nums[high]` because `nums[0]` would be the starting point of either of the sorted halves of the array.\\n\\n2. In the second while loop, you\\'re using `while(i<j)`. But you should use `while(i<=j)` to ensure the loop runs when `i` and `j` point to the same element.\\n\\n3. In the return statement, you\\'re returning `j`, which is not correct. If the target is not found, you should return -1.\\n\\nHere is your corrected code:\\n\\n```cpp\\nclass Solution {\\npublic:\\n    int search(vector<int>& nums, int target) {\\n        int low=0, high=nums.size()-1;\\n        while(low<high)\\n        {\\n            int mid=(low+high)/2;\\n            if(nums[mid]>nums[high])\\n                low=mid+1;\\n            else\\n                high=mid;\\n        }\\n        // low is now pointing to smallest element\\n        int i=0, j=0;\\n        if(target>=nums[0]){ // target is in the first half\\n            i=0; j=low;\\n        }\\n        else{ // target is in the second half\\n            i=low; j=nums.size()-1;\\n        }\\n        while(i<=j){ // modified from i<j to i<=j\\n            int mid=(i+j)/2;\\n            if(nums[mid]==target)\\n                return mid;\\n            else if(nums[mid]>target)\\n                j=mid-1;\\n            else\\n                i=mid+1;\\n        }\\n        return -1; // return -1 if target not found\\n    }\\n};\\n```\\nWith these changes, your code should work correctly to find the target in the rotated sorted array.\\n"
                    },
                    {
                        "username": "Aman-kumar-a",
                        "content": "pls tell me what\\'s the error in code\\npls help!!\\nint search_pivot(vector<int> & nums)\\n{\\n   int s=0;\\n  int  e=nums.size()-1;\\n   int mid=s+ (e-s)/2;\\n    while(s<e)\\n    {\\n        if(nums[mid]>=nums[0])\\n        {\\n            s=mid+1;\\n        }\\n        else\\n        {\\n            e=mid;\\n        }\\n      mid=s+ (e-s)/2;\\n    }\\n    return s;\\n}\\nint binary_search(vector<int>& nums,int s,int e,int key)\\n{\\n   int  start=s;\\n   int  end=e;\\n   int  mid=start + (end-start)/2;\\n   while(start<=end)\\n   {\\n       if(nums[mid]==key)\\n       {\\n           return mid;\\n       }\\n       else if(nums[mid]<key)\\n       {\\n           start=mid+1;\\n       }\\n       else\\n       {\\n           end=mid-1;\\n       }\\n      mid=start + (end-start)/2;\\n   }\\n    return -1;\\n}\\n\\nclass Solution {\\npublic:\\n    int search(vector<int>& nums, int target) {\\n        int n=nums.size()-1;\\n        int pivot=search_pivot(nums);\\n        if(target>=pivot && target<=nums[n-1] )\\n        {\\n           return  binary_search(nums,pivot,n-1,target);\\n        }\\n        else\\n        {\\n           return binary_search(nums,0,pivot-1,target); \\n        }\\n    }\\n};"
                    },
                    {
                        "username": "deleted_user",
                        "content": "class Solution {\\n    public int search(int[] nums, int target) {\\n        \\n        int idx=0;\\n\\n        for(int i=0;i<nums.length;i++){\\n            if(nums[i]==target){\\n                idx=i;\\n                break;\\n            }\\n            else{\\n                idx=-1;\\n            }\\n        \\n        }\\n        return idx;\\n    }\\n}\\n\\nthis code passed all test cases, do we need to include rotation part also (BST)?"
                    },
                    {
                        "username": "ansal_kumar",
                        "content": "simple linear search "
                    },
                    {
                        "username": "shivbhankushwaha862003672001",
                        "content": "class Solution {\\npublic:\\n\\nint findPivot(vector<int> &arr, int n){\\n     int s = 0;\\n     int e = n-1;\\n     int mid = s +(e-s)/2;\\n    \\n    while(s<e){\\n        if(arr[mid] >= arr[0]){\\n            s = mid +1;\\n        }\\n        else{\\n            e = mid;\\n        }\\n        mid = s +(e-s)/2;\\n    }\\n    return s;\\n}\\n\\nint binarySearch(vector<int> &arr,int s,int e, int k){\\n    int start = s;\\n    int end = e;\\n    int mid = start + (end - start)/2;\\n    \\n    while(start <= end){\\n        if(arr[mid] == k){\\n            return mid;\\n        }\\n        else if(k > arr[mid]){\\n            start = mid +1 ;\\n        }\\n        else if(k<arr[mid]){\\n            end = mid -1;\\n        }\\n        mid = start + (end - start)/2;\\n    }\\n    return -1;\\n}\\n\\nint findPosition(vector<int>& arr, int n, int k)\\n{\\n   int pivot = findPivot(arr,n);\\n    if(k >= arr[pivot] && k <= arr[n-1]){\\n        return binarySearch(arr,pivot,n-1,k);\\n    }\\n    else{\\n        return binarySearch(arr,0,pivot-1,k);\\n    }\\n}\\n\\n\\n    int search(vector<int>& nums, int target) {\\n        int n = nums.size();\\n       return findPosition(nums,n,target);\\n    }\\n};"
                    },
                    {
                        "username": "SaikatDass",
                        "content": "Search in rotated sorted array | java program | O(log n) complexity\nclass Solution {\n    public int search(int[] nums, int target) {\n        int n = nums.length;\n        int min = minSearch(nums);\n        if(nums[min] <= target && target <= nums[n - 1]){\n            return search(nums, min, n-1, target);\n        }\n        else{\n            return search(nums, 0, min, target);\n        }\n    }\n    public static int search(int[] nums, int start, int end, int target){\n        while(start <= end){\n            int mid = start + (end - start) / 2;\n            if(nums[mid] == target){\n                return mid;\n            }\n            else if(nums[mid] > target){\n                end = mid - 1;\n            }\n            else{\n                start = mid + 1;\n            }\n        }\n        return -1;\n    }\n    public static int minSearch(int[] nums){\n            int start = 0;\n            int end = nums.length - 1;\n            while(start < end){\n                int mid = start + (end - start) / 2; \n                if(mid > 0 && nums[mid - 1] > nums[mid]){\n                    return mid;\n                }\n                else if(nums[start] <= nums[mid] && nums[mid] > nums[end]){\n                    start = mid + 1;\n                }\n                else{\n                    end = mid - 1;\n                }\n            }\n            return start;\n        }\n}"
                    },
                    {
                        "username": "Ankush175",
                        "content": " `class Solution {\\n    public int search(int[] nums, int target) {\\n\\n        int start=0;\\n        int end = nums.length-1;\\n\\n        while(start<=end){\\n\\n            int mid = start+(end-start)/2;\\n\\n            if(nums[mid] == target){\\n                return mid;\\n            }\\n\\n            if(nums[start]<=nums[mid]){\\n                // the elements between start and end are in ascending order\\n\\n                if(nums[start]<=target && target<nums[mid]){\\n                    //the elements between start and end are in ascending order and,\\n                    //if the target lies between start and mid, so update end\\n                    end=mid-1;\\n                }\\n                else{\\n                    //if not the element lies between mid and end, so update start\\n                    start = mid+1;\\n                }\\n            }\\n            else{\\n                //the elements between start and mid are not in ascending order,i.e they are in descending order,the elements after mid will be in ascending order.\\n                if(nums[mid]<target && target<=nums[end]){\\n                    start = mid+1;\\n                }\\n                else{\\n                    end = mid-1;\\n                }\\n\\n            }\\n\\n        }\\n        return -1;\\n        \\n    }\\n}`"
                    },
                    {
                        "username": "yashdeora",
                        "content": "Here is problem solution in Python, Java, C++ and C programming.\\n[https://www.gyangav.com/2022/11/leetcode-search-in-rotated-sorted-array-problem-solution.html](https://www.gyangav.com/2022/11/leetcode-search-in-rotated-sorted-array-problem-solution.html)"
                    },
                    {
                        "username": "Bhautikbhalala123",
                        "content": "https://zeroplusfour.com/search-in-rotated-sorted-array-leetcode-solution/\\n\\nFull OPTIMAL solution in Java , Python , C++ , C \\n\\nGet all the solution here at :\\nhttps://zeroplusfour.com/leetcode-all-array-solution-list-all-in-one-place/\\n"
                    }
                ]
            },
            {
                "id": 1648672,
                "content": [
                    {
                        "username": "imvillen69",
                        "content": "Help me to debug this code .\\nclass Solution {\\npublic:\\n    int search(vector<int>& nums, int target) {\\n        int l = 0,h = nums.size() - 1;\\n        while(l <= h){\\n        int m = (l + (h - l))>>1;\\n        if(nums[m] == target)\\n            return m;\\n//left half is sorted.\\n        if(nums[l] <= nums[m])\\n        {\\n            if(target >= nums[l] && target <= nums[m]) //lies in range ..\\n            h = m - 1;\\n            else\\n            l = m + 1;\\n        }\\n//right half is sorted.\\n        else\\n        {\\n           if(target >= nums[m] && target <= nums[h]) // lies in range..\\n            l = m + 1;\\n            else\\n            h = m - 1; \\n        }\\n    }\\n        return - 1;\\n    }\\n};"
                    },
                    {
                        "username": "bparanj",
                        "content": "Your code appears to be correct for a binary search within a rotated sorted array. If the function doesn\\'t work as expected, there could be a few reasons why:\\n\\n1. The `vector` might not be sorted or properly rotated: This code assumes that the input `vector` is a sorted array that has been rotated. If it\\'s not, the code might not work as expected.\\n\\n2. The target number might not exist in the array: If the number you\\'re looking for isn\\'t in the array, the function will correctly return -1, which is the expected behavior.\\n\\n3. Compiler, environment, or runtime error: There could be a problem with your development environment or a runtime error causing the code to fail.\\n\\nI would suggest first verifying that your input is a rotated sorted array and the target number exists in it. If you\\'re still having problems, please provide more information about the specific error or issue you\\'re encountering. \\n\\nRemember, the provided function\\'s time complexity is O(log n) as it utilizes the concept of Binary Search, making it a very efficient solution for large arrays."
                    },
                    {
                        "username": "agarwalkaran253",
                        "content": "The logic I am using is finding the position where the trend changes and then putting the limits of i and j and then applying binary search on it ,yet it is giving me the wrong answer?\\nany suggestions?\\nMy code below------->\\n\\nclass Solution {\\npublic:\\n    int search(vector<int>& nums, int target) {\\n        int low=0,high=nums.size()-1;\\n        while(low<high)\\n        {\\n            int mid=(low+high)/2;\\n            if(nums[mid]>nums[high])\\n            low=mid+1;\\n            else\\n            high=mid-1;\\n        }\\n        //return low;\\n        int i=0,j=0;\\n        if(target>nums[high]){\\n        i=0;j=low-1;}\\n        else{\\n        i=low;j=nums.size()-1;}\\n        while(i<j){\\n            int mids=(i+j)/2;\\n            if(nums[mids]==target)\\n            return mids;\\n            else if(nums[mids]>target)\\n                j=mids-1;\\n            else\\n                i=mids+1;\\n        }\\n        return j;\\n    }\\n};\\n\\n"
                    },
                    {
                        "username": "bparanj",
                        "content": "Your approach to solve the problem using binary search is correct but there are some issues with your implementation:\\n\\n1. After finding the smallest element, you need to check whether the target is in the first half or the second half of the rotated array and search in the correct half. However, in your code, you\\'re defining the boundaries `i` and `j` incorrectly. You should compare the target with `nums[0]` instead of `nums[high]` because `nums[0]` would be the starting point of either of the sorted halves of the array.\\n\\n2. In the second while loop, you\\'re using `while(i<j)`. But you should use `while(i<=j)` to ensure the loop runs when `i` and `j` point to the same element.\\n\\n3. In the return statement, you\\'re returning `j`, which is not correct. If the target is not found, you should return -1.\\n\\nHere is your corrected code:\\n\\n```cpp\\nclass Solution {\\npublic:\\n    int search(vector<int>& nums, int target) {\\n        int low=0, high=nums.size()-1;\\n        while(low<high)\\n        {\\n            int mid=(low+high)/2;\\n            if(nums[mid]>nums[high])\\n                low=mid+1;\\n            else\\n                high=mid;\\n        }\\n        // low is now pointing to smallest element\\n        int i=0, j=0;\\n        if(target>=nums[0]){ // target is in the first half\\n            i=0; j=low;\\n        }\\n        else{ // target is in the second half\\n            i=low; j=nums.size()-1;\\n        }\\n        while(i<=j){ // modified from i<j to i<=j\\n            int mid=(i+j)/2;\\n            if(nums[mid]==target)\\n                return mid;\\n            else if(nums[mid]>target)\\n                j=mid-1;\\n            else\\n                i=mid+1;\\n        }\\n        return -1; // return -1 if target not found\\n    }\\n};\\n```\\nWith these changes, your code should work correctly to find the target in the rotated sorted array.\\n"
                    },
                    {
                        "username": "Aman-kumar-a",
                        "content": "pls tell me what\\'s the error in code\\npls help!!\\nint search_pivot(vector<int> & nums)\\n{\\n   int s=0;\\n  int  e=nums.size()-1;\\n   int mid=s+ (e-s)/2;\\n    while(s<e)\\n    {\\n        if(nums[mid]>=nums[0])\\n        {\\n            s=mid+1;\\n        }\\n        else\\n        {\\n            e=mid;\\n        }\\n      mid=s+ (e-s)/2;\\n    }\\n    return s;\\n}\\nint binary_search(vector<int>& nums,int s,int e,int key)\\n{\\n   int  start=s;\\n   int  end=e;\\n   int  mid=start + (end-start)/2;\\n   while(start<=end)\\n   {\\n       if(nums[mid]==key)\\n       {\\n           return mid;\\n       }\\n       else if(nums[mid]<key)\\n       {\\n           start=mid+1;\\n       }\\n       else\\n       {\\n           end=mid-1;\\n       }\\n      mid=start + (end-start)/2;\\n   }\\n    return -1;\\n}\\n\\nclass Solution {\\npublic:\\n    int search(vector<int>& nums, int target) {\\n        int n=nums.size()-1;\\n        int pivot=search_pivot(nums);\\n        if(target>=pivot && target<=nums[n-1] )\\n        {\\n           return  binary_search(nums,pivot,n-1,target);\\n        }\\n        else\\n        {\\n           return binary_search(nums,0,pivot-1,target); \\n        }\\n    }\\n};"
                    },
                    {
                        "username": "deleted_user",
                        "content": "class Solution {\\n    public int search(int[] nums, int target) {\\n        \\n        int idx=0;\\n\\n        for(int i=0;i<nums.length;i++){\\n            if(nums[i]==target){\\n                idx=i;\\n                break;\\n            }\\n            else{\\n                idx=-1;\\n            }\\n        \\n        }\\n        return idx;\\n    }\\n}\\n\\nthis code passed all test cases, do we need to include rotation part also (BST)?"
                    },
                    {
                        "username": "ansal_kumar",
                        "content": "simple linear search "
                    },
                    {
                        "username": "shivbhankushwaha862003672001",
                        "content": "class Solution {\\npublic:\\n\\nint findPivot(vector<int> &arr, int n){\\n     int s = 0;\\n     int e = n-1;\\n     int mid = s +(e-s)/2;\\n    \\n    while(s<e){\\n        if(arr[mid] >= arr[0]){\\n            s = mid +1;\\n        }\\n        else{\\n            e = mid;\\n        }\\n        mid = s +(e-s)/2;\\n    }\\n    return s;\\n}\\n\\nint binarySearch(vector<int> &arr,int s,int e, int k){\\n    int start = s;\\n    int end = e;\\n    int mid = start + (end - start)/2;\\n    \\n    while(start <= end){\\n        if(arr[mid] == k){\\n            return mid;\\n        }\\n        else if(k > arr[mid]){\\n            start = mid +1 ;\\n        }\\n        else if(k<arr[mid]){\\n            end = mid -1;\\n        }\\n        mid = start + (end - start)/2;\\n    }\\n    return -1;\\n}\\n\\nint findPosition(vector<int>& arr, int n, int k)\\n{\\n   int pivot = findPivot(arr,n);\\n    if(k >= arr[pivot] && k <= arr[n-1]){\\n        return binarySearch(arr,pivot,n-1,k);\\n    }\\n    else{\\n        return binarySearch(arr,0,pivot-1,k);\\n    }\\n}\\n\\n\\n    int search(vector<int>& nums, int target) {\\n        int n = nums.size();\\n       return findPosition(nums,n,target);\\n    }\\n};"
                    },
                    {
                        "username": "SaikatDass",
                        "content": "Search in rotated sorted array | java program | O(log n) complexity\nclass Solution {\n    public int search(int[] nums, int target) {\n        int n = nums.length;\n        int min = minSearch(nums);\n        if(nums[min] <= target && target <= nums[n - 1]){\n            return search(nums, min, n-1, target);\n        }\n        else{\n            return search(nums, 0, min, target);\n        }\n    }\n    public static int search(int[] nums, int start, int end, int target){\n        while(start <= end){\n            int mid = start + (end - start) / 2;\n            if(nums[mid] == target){\n                return mid;\n            }\n            else if(nums[mid] > target){\n                end = mid - 1;\n            }\n            else{\n                start = mid + 1;\n            }\n        }\n        return -1;\n    }\n    public static int minSearch(int[] nums){\n            int start = 0;\n            int end = nums.length - 1;\n            while(start < end){\n                int mid = start + (end - start) / 2; \n                if(mid > 0 && nums[mid - 1] > nums[mid]){\n                    return mid;\n                }\n                else if(nums[start] <= nums[mid] && nums[mid] > nums[end]){\n                    start = mid + 1;\n                }\n                else{\n                    end = mid - 1;\n                }\n            }\n            return start;\n        }\n}"
                    },
                    {
                        "username": "Ankush175",
                        "content": " `class Solution {\\n    public int search(int[] nums, int target) {\\n\\n        int start=0;\\n        int end = nums.length-1;\\n\\n        while(start<=end){\\n\\n            int mid = start+(end-start)/2;\\n\\n            if(nums[mid] == target){\\n                return mid;\\n            }\\n\\n            if(nums[start]<=nums[mid]){\\n                // the elements between start and end are in ascending order\\n\\n                if(nums[start]<=target && target<nums[mid]){\\n                    //the elements between start and end are in ascending order and,\\n                    //if the target lies between start and mid, so update end\\n                    end=mid-1;\\n                }\\n                else{\\n                    //if not the element lies between mid and end, so update start\\n                    start = mid+1;\\n                }\\n            }\\n            else{\\n                //the elements between start and mid are not in ascending order,i.e they are in descending order,the elements after mid will be in ascending order.\\n                if(nums[mid]<target && target<=nums[end]){\\n                    start = mid+1;\\n                }\\n                else{\\n                    end = mid-1;\\n                }\\n\\n            }\\n\\n        }\\n        return -1;\\n        \\n    }\\n}`"
                    },
                    {
                        "username": "yashdeora",
                        "content": "Here is problem solution in Python, Java, C++ and C programming.\\n[https://www.gyangav.com/2022/11/leetcode-search-in-rotated-sorted-array-problem-solution.html](https://www.gyangav.com/2022/11/leetcode-search-in-rotated-sorted-array-problem-solution.html)"
                    },
                    {
                        "username": "Bhautikbhalala123",
                        "content": "https://zeroplusfour.com/search-in-rotated-sorted-array-leetcode-solution/\\n\\nFull OPTIMAL solution in Java , Python , C++ , C \\n\\nGet all the solution here at :\\nhttps://zeroplusfour.com/leetcode-all-array-solution-list-all-in-one-place/\\n"
                    }
                ]
            }
        ]
    }
]